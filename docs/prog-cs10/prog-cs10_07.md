# 第七章\. 对象生命周期

.NET 托管执行模型的一个好处是运行时可以自动化大部分应用程序的内存管理。我已经展示了许多使用`new`关键字创建对象的示例，没有一个显式释放这些对象消耗的内存。

在大多数情况下，您无需采取任何措施来回收内存。运行时提供了一个*垃圾收集器*（GC），¹，一种自动发现对象不再使用并回收它们占用的内存的机制，以便可以用于新对象。然而，某些使用模式可能会导致性能问题，甚至完全失效 GC，因此了解其工作原理是很有用的。这在运行时间可能长达数天的长时间进程中尤为重要（短暂进程可能能够容忍一些内存泄漏）。

GC 旨在高效管理内存，但内存并不是您可能需要处理的唯一有限资源。有些东西在 CLR 中的内存占用很小，但代表相对昂贵的东西，例如数据库连接或来自 OS API 的句柄。GC 并不总是有效处理这些情况，因此我将解释`IDisposable`，这是专门设计用于处理比内存更紧急需要释放的东西的接口。

值类型通常有完全不同的生命周期规则——例如，一些局部变量值仅在其包含的方法运行期间存在。尽管如此，值类型有时会表现得像引用类型，并由 GC 管理。我将讨论为何这可能很有用，并解释使其成为可能的*装箱*机制。

# 垃圾收集

CLR 维护着一个*堆*，这是一个为由 GC 管理生命周期的对象和值提供内存的服务。每次使用`new`构造类的实例或创建新的数组对象时，CLR 都会分配一个新的堆块。GC 决定何时释放该块。

###### 注意

如果您正在编写一个在 Android 设备上运行使用.NET 的 Xamarin 工具的.NET 应用程序，则会有两个垃圾收集堆：一个用于.NET，一个用于 Java。在 Xamarin 应用程序中正常的 C#活动使用.NET 堆，因此只有当您编写使用 Xamarin 服务处理 Java 对象的 C#代码时，Java 堆才会出现。这是一本.NET 书籍，所以我将专注于.NET GC。

堆块包含对象的所有非静态字段，或者如果是数组，则包含所有元素。CLR 还会添加一个头部，该头部对于程序来说不是直接可见的。这包括指向描述对象类型的结构体的指针。这支持依赖于对象的真实类型的操作。例如，如果在引用上调用`GetType`，运行时会使用此指针来查找类型。（类型通常不完全由引用的静态类型决定，静态类型可以是接口类型或实际类型的基类。）它还用于确定在调用虚拟方法或接口成员时应使用哪个方法。CLR 还使用此信息来知道堆块的大小——头部不包括块大小，因为运行时可以从对象的类型推断出来。（大多数类型都是固定大小。只有两个例外，字符串和数组，CLR 将其作为特殊情况处理。）头部包含另一个字段，用于各种不同的目的，包括多线程同步和默认哈希码生成。堆块头部只是一个实现细节，不同的运行时可能会选择不同的策略。² 但是，了解开销是有用的。在 32 位系统上，头部长度为 8 字节；在 64 位进程中运行时，长度为 16 字节。因此，一个仅包含一个`double`类型字段的对象在 32 位进程中将消耗 16 字节，在 64 位进程中将消耗 24 字节。

尽管对象（即类的实例）始终位于堆上，值类型的实例却有所不同：一些位于堆上，而另一些则不是。³ 例如，CLR 将一些值类型的局部变量存储在堆栈上，但如果该值是类的实例字段，则类实例将位于堆上，因此该值将驻留在堆上的该对象内部。在某些情况下，一个值将拥有自己的整个堆块。

如果你通过引用类型变量使用某物，则正在访问堆上的内容。非常重要的一点是要明确我所说的引用类型变量的含义，因为遗憾的是，这里的术语有点混乱：在 C# 中，*引用* 这个术语描述了两种完全不同的东西。在本讨论中，引用是指你可以存储在派生自`object`类型（但不是`ValueType`）或接口类型的变量中的内容。这并不包括每个`in`-、`out`-或`ref`-风格的方法参数，也不包括`ref`变量或返回值。虽然它们也是某种形式的引用，但`ref int`参数是对值类型的引用，这与引用类型并不相同。（CLR 实际上使用与 C# 不同的术语来支持`ref`、`in`和`out`的机制：它称这些为*托管指针*，明确表明它们与对象引用有着不同。）

C# 使用的托管执行模型（以及所有 .NET 语言）意味着 CLR 知道您的代码创建的每个堆块，还知道程序存储引用的每个字段、变量和数组元素。这些信息使运行时能够随时确定哪些对象是*可达*的——即程序可能访问以使用其字段和其他成员的对象。如果一个对象不可达，则根据定义，程序将永远无法再次使用它。为了说明 CLR 如何确定可达性，我编写了一个简单的方法，从我的雇主网站获取网页，如示例 7-1 所示。

##### 示例 7-1\. 使用和丢弃对象

```cs
public static string FetchUrl(string relativeUri)
{
    var baseUri = new Uri("https://endjin.com/");
    var fullUri = new Uri(baseUri, relativeUri);
    var w = new HttpClient();
    HttpResponseMessage response = w.Send(
        new HttpRequestMessage(HttpMethod.Get, fullUri));
    return new StreamReader(response.Content.ReadAsStream()).ReadToEnd();
}
```

CLR 分析我们使用局部变量和方法参数的方式。例如，虽然`relativeUri`参数在整个方法中都是作用域内的，但我们只在构造第二个`Uri`时使用了一次作为参数，然后再也没有使用它。变量从接收值的第一个点到最后使用的最后点称为*活跃*。方法参数从方法开始直到最后使用，除非它们未被使用，否则它们将永远不活跃。局部变量稍后才会活跃；`baseUri`在分配初始值后变为活跃，然后在此示例中与`relativeUri`的最后使用同时停止活跃。活跃性是确定特定对象是否仍在使用的重要属性。

要了解活跃性的作用，请假设在示例 7-1 达到构造`HttpClient`行时，CLR 没有足够的空闲内存来容纳新对象。此时，CLR 可以向操作系统请求更多内存，但也可以选择尝试从不再使用的对象中释放内存，这意味着我们的程序不需要消耗比它已经使用的内存更多。⁴ 接下来的部分描述了当 CLR 选择第二个选项时的过程。

## 确定可达性

.NET 的基本方法是确定堆上哪些对象是可达的。如果程序无法获取某个对象，那么可以安全地丢弃它。CLR 首先确定程序中所有的根引用。*根引用*是指存储位置，例如局部变量，可能包含引用并已知已初始化，并且您的程序在将来某个时候可以使用它，而无需通过其他对象引用。并非所有存储位置都被视为根引用。如果对象包含某个引用类型的实例字段，则该字段不是根引用，因为在使用它之前，您需要获取对包含对象的引用，并且该对象本身可能不可达。但是，引用类型的静态字段是根引用，因为程序可以随时读取该字段的值——该字段将在组件定义该类型的组件卸载时变得不可访问，这在大多数情况下将是在程序退出时。

局部变量和方法参数更加有趣。有时它们是根引用，但有时并非如此。这取决于当前执行的方法的确切部分。只有在执行流程当前位于变量或参数活跃的区域内时，局部变量或参数才能成为根引用。因此，在示例 7-1 中，只有在`baseUri`获得其初始值并在构造第二个`Uri`之前，它才是根引用的。`fullUri`变量的根引用时间略长一些，因为它在接收到初始值后变为活跃，并在下一行构造`HttpClient`期间继续保持活跃；只有在调用`HttpRequestMessage`构造函数后，其生命周期才会结束。

###### 注意

当一个变量的最后一次使用是作为方法或构造函数调用的参数时，当方法调用开始时，它就不再是活跃的。在那一点上，被调用的方法接管—它自己的参数在开始时是活跃的（除了它不使用的参数）。然而，它们通常会在方法返回之前不再是活跃的。这意味着在示例 7-1 中，由 `fullUri` 引用的对象在 `HttpRequestMessage` 构造函数返回之前可能会因根引用的消失而无法访问。

由于程序执行时活跃变量集合会变化，根引用集合也会随之演变。为了确保在这一移动目标面前的正确行为，CLR 可以在垃圾回收时必要时暂停所有正在运行托管代码的线程。

活跃变量和静态字段并不是唯一的根引用种类。作为评估表达式结果所创建的临时对象需要在完成评估所需的时间内保持活跃，因此可能存在一些根引用，并不直接对应代码中的任何命名实体。还有其他类型的根。例如，`GCHandle` 类允许您显式创建新的根引用，在互操作场景中非常有用，以便让一些非托管代码访问特定对象。还有一些情况下根引用是隐式创建的。某些类型的应用程序可以与非.NET 基于对象的系统进行互操作（例如，在 Windows 应用程序中的 COM，或者在 Android 上的 Java），这些系统可以在不显式使用 `GCHandle` 的情况下建立根引用。如果 CLR 需要生成一个包装器，使您的某个.NET 对象对其他运行时可用，那么该包装器实际上将是一个根引用。调用非托管代码时可能还涉及传递指向堆上内存的指针，这意味着在调用的整个过程中相关堆块需要被视为可达。总体原则是，根引用将存在于必要的地方，以确保仍在使用中的对象保持可达。

在为所有线程建立了当前根引用的完整列表后，GC 确定哪些对象可以从这些引用中访问到。它依次检查每个引用，如果非空，GC 就知道它所引用的对象是可达的。可能会有重复的引用——多个根引用可能指向同一个对象，因此 GC 要追踪它已经看过的对象。对于每个新发现的对象，GC 将该对象中的所有引用类型的实例字段添加到它需要检查的引用列表中，并再次丢弃重复项（包括编译器生成的隐藏字段，例如自动属性中描述的那些，我在第三章中有描述）。对于它发现的任何引用类型数组的每个元素，它都会执行相同的操作。这意味着如果一个对象是可达的，它所引用的所有对象也都是可达的。GC 重复这个过程，直到没有新的引用需要检查为止。GC 没有发现可达的对象就意味着这些对象是不可达的，因为 GC 所做的只是程序做的事情：程序只能使用直接或间接通过其变量、临时本地存储、静态字段和其他根引用可访问的对象。

回到示例 7-1，如果 CLR 在构造`HttpClient`时决定运行 GC，那会意味着什么？`fullUri`变量仍然是活动的，所以它引用的`Uri`是可达的，但是`baseUri`不再活动。我们将`baseUri`的副本传递给第二个`Uri`的构造函数，如果它在字段中存储了引用的副本，那么`baseUri`不再活动也没关系；只要通过根引用开始就能访问到对象，那么对象就是可达的。但实际上，第二个`Uri`不会这样做，因此示例分配的第一个`Uri`将被视为不可达，CLR 将可以回收它所使用的内存。

如何确定可达性的一个重要结果是，GC 不会被循环引用搞糊涂。这就是.NET 使用 GC 而不是引用计数的一个原因（引用计数是另一种流行的自动内存管理方法）。如果你有两个相互引用的对象，引用计数方案会认为两个对象都在使用中，因为每个对象至少被引用了一次。但是这些对象可能是不可达的——如果没有其他引用指向它们，应用程序将无法使用它们。引用计数无法检测到这一点，因此可能导致内存泄漏；但 CLR 的 GC 方案不会受到它们相互引用的影响——GC 不会处理这两个对象中的任何一个，因此它会正确地确定它们不再使用。

## 意外地挫败了垃圾回收器

尽管垃圾回收器可以发现程序如何达到一个对象，但它无法证明它必然会这样做。拿示例 7-2 中那令人印象深刻的愚蠢代码来说吧。虽然你不会写出这么糟糕的代码，但它却犯了一个常见的错误。这个问题通常以更微妙的方式出现，但我想先用一个更明显的例子来展示它。一旦我展示了它如何阻止 GC 释放我们将不再使用的对象，我会描述一个不太直接但更现实的场景，这种问题经常发生在其中。

##### 示例 7-2\. 一个效率极低的代码片段

```cs
static void Main()
{
    var numbers = new List<string>();
    long total = 0;
    for (int i = 1; i < 100_000; ++i)
    {
        numbers.Add(i.ToString());
        total += i;
    }
    Console.WriteLine("Total: {total}, average: {total / numbers.Count}");
}
```

这里将从 1 加到 100,000 的数字相加，然后显示它们的平均值。这里的第一个错误是，我们甚至不需要在循环中进行加法，因为对于这种求和，有一个简单且非常有名的封闭形式解：`n*(n+1)/2`，在这种情况下`n`为 100,000。尽管存在这个数学错误，但这段代码做了更愚蠢的事情：它建立了一个包含它添加的每个数字的列表，但它所做的一切只是在最后检索它的`Count`属性以计算平均值。更糟糕的是，代码在将每个数字放入列表之前将其转换为字符串。它实际上从未使用过这些字符串。（我在这里展示了`Main`方法的声明，以明确说明`numbers`后来没有被使用。）

显然，这是一个刻意构造的例子，虽然我希望我能说在真实程序中从未遇到过这种令人困惑的毫无意义的事情。可悲的是，我遇到过至少和这个糟糕的例子一样糟糕的真实例子，尽管它们都更加隐晦——当你在野外遇到这种情况时，通常需要半个小时左右才能确定它确实在做如此惊人地毫无意义的事情。然而，我这里的重点并不是为软件开发标准叹息。这个例子的目的是展示你如何遇到 GC 的一个限制。

假设示例 7-2 中的循环已经运行了一段时间——也许是在第 90,000 次迭代，并且正在尝试向`numbers`列表添加一个条目。假设`List<string>`已经使用完了它的备用容量，因此`Add`方法将需要分配一个新的、更大的内部数组。CLR 此时可能会决定运行 GC，看看能否释放一些空间。会发生什么？

示例 7-2 创建了三种对象：在开始时构造了一个`List<string>`，在循环中每次调用`int`的`ToString()`方法创建一个新的`string`，还有更微妙的是，`List<string>`将分配一个`string[]`来保存对这些字符串的引用。因为我们不断添加新的项，它将不得不分配越来越大的数组。（这个数组是`List<string>`的实现细节，所以我们不能直接看到它。）因此问题是：GC 可以丢弃哪些对象来为`Add`调用中的更大数组腾出空间？

我们的`numbers`变量保持活动状态直到程序的最后一条语句，并且我们正在看代码中的较早部分，因此它引用的`List<string>`对象是可达的。它目前使用的`string[]`数组对象也必须是可达的：它正在分配一个更新、更大的数组，但它将需要复制旧数组的内容到新数组中，因此列表必须仍然有一个对当前数组的引用存储在其一个字段中。由于该数组仍然是可达的，数组引用的每个字符串也将是可达的。到目前为止，我们的程序已经创建了 90,000 个字符串，GC 将通过从我们的`numbers`变量开始，查看`List<string>`对象的字段，然后查看列表的一个私有字段引用的数组中的每个元素来找到所有这些字符串。

GC 可能能够收集的唯一分配的项目是`List<string>`在列表较小时创建的旧`string[]`数组，它现在不再有引用。当我们添加了 90,000 个项时，列表可能已经调整了自身大小多次。因此，取决于上次 GC 运行的时间，它可能能够找到一些现在未使用的数组。但更有趣的是这里它无法释放的内容。

程序永远不会使用它创建的 90,000 个字符串中的任何一个，因此理想情况下，我们希望垃圾收集器可以释放它们占用的内存 —— 它们将占用几兆字节。我们可以很容易地看出这些字符串没有被使用，因为这是一个如此简短的程序。但是垃圾收集器不知道这一点；它基于可达性做出决策，并且它正确地确定这 90,000 个字符串都是可达的，从`numbers`变量开始。对于垃圾收集器来说，列表的`Count`属性可能会在循环结束后查看列表的内容。我们知道它不会这样做，因为它不需要，但这是因为我们知道`Count`属性的含义。为了让垃圾收集器推断我们的程序永远不会直接或间接使用列表的任何元素，它需要了解`List<string>`在其`Add`和`Count`方法内部的工作方式。这意味着需要进行比我描述的机制更为详细的分析，这可能使得垃圾收集器的成本显著增加。此外，即使在需要严格复杂的步骤来检测此示例永远不会使用的可达对象的情况下，更现实的场景中，垃圾收集器也不太可能能够做出明显优于仅依赖可达性的预测。

例如，在缓存中更有可能遇到这个问题。如果你编写一个类来缓存获取或计算昂贵的数据，想象一下如果你的代码只是向缓存中添加项而不移除它们，会发生什么。只要缓存对象本身可达，所有缓存的数据都将是可达的。问题在于，你的缓存将占用越来越多的空间，除非你的计算机有足够的内存来容纳程序可能需要使用的每一个数据片段，否则最终会耗尽内存。

一个天真的开发者可能会抱怨，这应该是垃圾收集器的问题。垃圾收集的整点在于我不需要考虑内存管理，为什么突然间就内存不足了呢？但是，问题在于垃圾收集器无法知道哪些对象是安全可移除的。它并非能预见未来，因此无法准确预测你的程序将来可能需要哪些缓存项——如果代码在服务器上运行，未来的缓存使用可能取决于服务器收到的请求，而这是垃圾收集器无法预测的。因此，虽然我们可以想象到足够智能的内存管理可以分析像示例 7-2 这样简单的东西，但通常情况下，这不是垃圾收集器能解决的问题。因此，如果你将对象添加到集合中并保持这些集合可达，垃圾收集器将把这些集合中的所有东西都视为可达。你需要决定何时删除这些项。

集合不是唯一可以欺骗 GC 的情况。正如我将在 第九章 中展示的那样，存在一种常见的情况，即对事件的不慎使用可能导致内存泄漏。更一般地说，如果你的程序使得某个对象可以被访问到，GC 无法确定你是否会再次使用该对象，因此它必须保守处理。

话虽如此，有一种技术可以在一定程度上通过 GC 的帮助来缓解这个问题。

## 弱引用

尽管 GC 会跟踪可达对象字段中的普通引用，但也可能存在*弱引用*。GC 不会跟踪弱引用，因此如果通过弱引用是唯一可达对象的方式，GC 会将其视为不可达对象并将其移除。弱引用提供了一种告诉 CLR 的方式：“不要因为我而保留这个对象，但只要其他地方需要它，我希望能够访问它。” 示例 7-3 展示了使用 `WeakReference<T>` 的缓存。

##### 示例 7-3\. 在缓存中使用弱引用

```cs
public class WeakCache<TKey, TValue>
    where TKey : notnull
    where TValue : class
{
    private readonly Dictionary<TKey, WeakReference<TValue>> _cache = new ();

    public void Add(TKey key, TValue value)
    {
        _cache.Add(key, new WeakReference<TValue>(value));
    }

    public bool TryGetValue(
        TKey key, [NotNullWhen(true)] out TValue? cachedItem)
    {
        if (_cache.TryGetValue(key, out WeakReference<TValue>? entry))
        {
            bool isAlive = entry.TryGetTarget(out cachedItem);
            if (!isAlive)
            {
                _cache.Remove(key);
            }
            return isAlive;
        }
        else
        {
            cachedItem = null;
            return false;
        }
    }
}
```

这个缓存通过 `WeakReference<T>` 存储所有值。它的 `Add` 方法将希望作为弱引用的对象作为新 `WeakReference<T>` 的构造函数参数。`TryGetValue` 方法尝试检索之前使用 `Add` 存储的值。首先检查字典是否包含相关条目。如果包含，则该条目的值将是我们之前创建的 `WeakReference<T>`。我的代码调用该弱引用的 `TryGetTarget` 方法，如果对象仍然可用，则返回 `true`，否则返回 `false`。

###### 注意

可用性并不一定意味着可达性。自最近的 GC 以来，对象可能已经变得不可达。或者自对象分配以来可能根本没有进行 GC。`TryGet​Tar⁠get` 只能告诉你 GC 是否已经检测到它符合回收的条件。

如果对象可用，`TryGetTarget`将通过`out`参数提供它，这将是一个强引用。因此，如果此方法返回`true`，我们无需担心对象随后变得不可达的竞争条件——事实上，我们现在将该引用存储在通过`cachedItem`参数由调用方提供的变量中，将保持目标活动。如果`TryGetTarget`返回`false`，我的代码将从字典中删除相关条目，因为它代表一个不再存在的对象。这很重要，因为虽然弱引用不会保持其目标的活动状态，但`WeakReference<T>`本身是一个对象，GC 在我从字典中移除它之前无法释放它。示例 7-4 尝试运行此代码，强制进行了几次垃圾回收，以便我们可以看到它的运行情况。（这将每个阶段分成独立的方法，禁用内联，否则.NET 的 JIT 编译器将内联这些方法，这样会创建隐藏的临时变量，可能会使数组保持可达的时间比预期长，从而扭曲此测试的结果。）

##### 示例 7-4\. 练习弱缓存

```cs
internal class Program
{
    private static WeakCache<string, byte[]> cache = new ();
    private static byte[]? data = new byte[100];

    private static void Main(string[] args)
    {
        AddData();
        CheckStillAvailable();

        GC.Collect();
        CheckStillAvailable();

        SetOnlyRootToNull();
        GC.Collect();
        CheckNoLongerAvailable();
    }

 [MethodImpl(MethodImplOptions.NoInlining)]
    private static void AddData()
    {
        cache.Add("d", data!);
    }

 [MethodImpl(MethodImplOptions.NoInlining)]
    private static void CheckStillAvailable()
    {
        Console.WriteLine("Retrieval: " +
            cache.TryGetValue("d", out byte[]? fromCache));
        Console.WriteLine("Same ref?  " +
            object.ReferenceEquals(data, fromCache));
    }

 [MethodImpl(MethodImplOptions.NoInlining)]
    private static void SetOnlyRootToNull()
    {
        data = null;
    }

 [MethodImpl(MethodImplOptions.NoInlining)]
    private static void CheckNoLongerAvailable()
    {
        byte[]? fromCache;
        Console.WriteLine("Retrieval: " + cache.TryGetValue("d", out fromCache));
        Console.WriteLine("Null?  " + (fromCache == null));
    }
}
```

首先创建我的缓存类的实例，然后将一个 100 字节数组的引用添加到缓存中。它还将同一个数组的引用存储在名为`data`的静态字段中，保持其可达性，直到代码调用`SetOnlyRootToNull`，将其值设置为`null`。示例尝试在添加后立即从缓存中检索该值，并使用`object.ReferenceEquals`检查我们获取的值确实是指向我们放入的同一个对象。然后我强制进行垃圾回收，并再次尝试。（这种人为的测试代码是少数情况之一，您需要执行此操作，请参阅“强制垃圾回收”一节了解详情。）由于`data`字段仍然持有数组的引用，因此数组仍然是可达的，因此我们期望从缓存中仍然可以获取该值。接下来，我将`data`设置为`null`，因此我的代码不再保持该数组可达。唯一剩余的引用是一个弱引用，因此当我强制进行另一次 GC 时，我们期望该数组被收集，并且在缓存中的最终查找失败。为了验证这一点，我检查返回值和通过`out`参数返回的值，预期值为`false`和`null`。当我运行程序时，确实发生了这种情况，如您所见：

```cs
Retrieval: True
Same ref?  True
Retrieval: True
Same ref?  True
Retrieval: False
Null?  True
```

###### 注

编写用于说明 GC 行为的代码意味着进入危险的领域。操作原理保持不变，但小示例的确切行为随时间变化，通常是由于 JIT 编译期间执行的优化。完全有可能，如果您尝试这些示例，由于运行时的更改，您可能会看到不同的行为。

后面我会描述终结，这会通过引入一个暮光区域使情况变得更加复杂，其中对象被确定为不可达但尚未消失。处于此状态的对象通常没有多大用处，因此默认情况下，弱引用将把等待终结的对象视为已经消失。这称为*短弱引用*。如果出于某种原因，您需要知道对象是否确实已经消失（而不仅仅是正在逐渐移除），`WeakReference<T>` 类的构造函数具有多个重载，其中一些可以创建*长弱引用*，即使在不可达性和最终移除之间的这个区域中，也可以访问对象。

## 回收内存

到目前为止，我描述了 CLR 如何确定哪些对象不再使用，但还没有描述接下来会发生什么。在确定了垃圾之后，运行时必须进行收集。CLR 对小对象和大对象使用不同的策略。（默认情况下，.NET CLR 将大对象定义为大于 85,000 字节。Mono 将此标准设定为 8,000 字节以下。）大多数分配涉及小对象，因此我将首先介绍这些对象。

CLR 尝试保持堆的空闲空间连续。当应用程序刚启动时，这很容易，因为只有空闲空间，可以通过为每个新对象直接分配内存来保持连续。但是在第一次 GC 后，堆看起来可能不再那么整齐。大多数对象的生命周期很短，通常在任何一个 GC 后分配的大多数对象在下次 GC 运行时都不可达。然而，还是会有一些对象在使用中。应用程序不时会创建长时间存在的对象，GC 运行时可能正在使用一些对象，因此最近分配的堆块可能仍在使用中。这意味着堆的末尾可能看起来像图 7-1，灰色矩形表示可达块，白色矩形表示不再使用的块。

![](img/pc10_0701.png)

###### 图 7-1\. 堆中部分可达对象的部分

一种可能的分配策略是在需要新内存时开始使用这些空块，但这种方法存在几个问题。首先，它往往是浪费的，因为应用程序需要的块可能不会精确地适应可用的空洞。其次，在许多间隙存在且尝试选择能最小化浪费的空块时，找到合适的空块可能会有些昂贵。当然，并非不可能实现——许多堆都是这样工作的——但比起最初的情况，每个新块都可以直接分配到上一个块之后，因为所有的空闲空间都是连续的，这种堆碎片化的代价是相当昂贵的，因此 CLR 通常会尝试将堆恢复到自由空间连续的状态。如图 7-2 所示，它将所有可达对象向堆的起始位置移动，以便所有的空闲空间位于末尾，从而使其重新处于有利的状态，能够在连续的空闲空间块中一个接一个地分配新的堆块。

![](img/pc10_0702.png)

###### 图 7-2\. 堆在压缩后的部分

在这些重新定位的块移动后，运行时必须确保对这些块的引用仍然有效。CLR 偶然将引用实现为指针（尽管没有什么需要这样做——引用只是标识堆上某个特定实例的值）。它已经知道任何特定块的所有引用位置，因为它必须找到它们以发现哪些块是可达的。它在移动块时调整所有这些指针。

除了使堆块分配成本相对廉价外，压缩还提供了另一个性能优势。因为块被分配到连续的空闲空间区域中，快速创建的对象通常会在堆中彼此紧邻。这是很重要的，因为现代 CPU 中的高速缓存倾向于局部性（即当相关数据片段存储在一起时表现最佳）。

分配的低成本和良好局部性的高可能性有时意味着，垃圾收集堆比需要程序显式释放内存的传统堆提供更好的性能。这可能令人惊讶，因为 GC 似乎在非收集堆中做了很多额外的无用工作。然而，其中一些“额外”工作实际上并非如此——必须有东西来跟踪哪些对象正在使用，并且传统堆只是将这些管理开销推到我们的代码中。然而，重新定位现有内存块是有代价的，因此 CLR 使用一些技巧来最小化它需要做的复制量。

对于 CLR 来说，一个对象的年龄越长，一旦最终变得不可达时，压缩堆的成本就会越高。如果在 GC 运行时最近分配的对象是不可达的，那么对于该对象来说，压缩是免费的：它后面没有更多的对象，所以不需要移动任何东西。与你的程序分配的第一个对象相比——如果那个对象变得不可达，压缩意味着需要移动堆上的每个可达对象。更一般地说，一个对象的年龄越长，它后面放置的对象就越多，因此需要移动的数据量就越大才能压缩堆。复制 20 MB 的数据来节省 20 字节并不像是一个很好的权衡。因此，CLR 经常会推迟对堆中较老部分的压缩。

为了确定什么是“老”的，.NET 运行时将堆划分为*代*。⁵ 每次 GC 时，代之间的边界会移动，因为代是根据一个对象经历了多少次 GC 来定义的。在最近的 GC 之后分配的任何对象都在第 0 代中，因为它还没有经历任何收集。当下次 GC 运行时，仍然可达的第 0 代对象将按需移动以压缩堆，并被认为是在第 1 代中。

第 1 代中的对象还不被认为是老对象。GC 通常会在代码正在执行的过程中运行——毕竟，当堆上的空间被使用完时，它才会运行，如果程序处于空闲状态，这种情况就不会发生。因此，有很大的机会，一些最近分配的对象代表正在进行的工作，尽管它们当前是可达的，但它们很快就会变得不可达。第 1 代充当一种持有区，我们等待看看哪些对象是短命的，哪些是长寿的。

随着程序继续执行，GC 会不时运行，将新生的幸存对象提升到第 1 代。第 1 代中的一些对象将变得不可达。然而，GC 不一定会立即压缩堆的这一部分——它可能允许几次第 0 代的收集和压缩，然后才进行一次第 1 代的压缩，但最终还是会发生的。在此阶段幸存下来的对象将被移到第 2 代，这是最老的一代。

CLR 尝试从第 2 代中较不频繁地回收内存。研究显示，在大多数应用程序中，进入第 2 代的对象很可能会保持可访问状态很长时间，因此当其中一个对象最终变得不可达时，它很可能已经非常老了，周围的对象也是如此。这意味着为了回收内存而压缩堆的这一部分代价高昂，有两个原因：不仅可能是因为这个老对象后面跟着大量的其他对象（需要复制大量数据），而且它所占用的内存可能已经很长时间没有使用，意味着它可能不再位于 CPU 的缓存中，进一步减慢了复制的速度。而且，在收集之后，缓存成本会持续存在，因为如果 CPU 不得不在堆的旧区域移动数兆字节的数据，这可能会导致将其他数据从 CPU 的缓存中冲出。缓存的大小可以从低功耗、低成本端的 512 KB 开始，到高端、服务器导向芯片的超过 90 MB，但在中端，2 MB 到 16 MB 的缓存是典型的，并且许多 .NET 应用程序的堆将比这更大。应用程序之前使用的大部分数据将在第 2 代 GC 之前一直存在于缓存中，但是一旦 GC 完成，这些数据就会消失。因此，当 GC 完成并且正常执行恢复时，代码将会在一段时间内以慢动作运行，直到应用程序需要的数据重新加载到缓存中。

第 0 代和第 1 代有时被称为*短暂*代，因为它们主要包含存在时间很短的对象。（Mono 堆的这一部分通常称为*nursery*，因为它是为年轻对象而设的。）堆的这些部分的内容通常会在 CPU 的缓存中，因为它们最近已经被访问过，所以对于这些区域来说，压缩并不特别昂贵。此外，由于大多数对象的生命周期很短，GC 能够收集的大部分内存将来自这前两代对象，因此这些对象很可能会以消耗的 CPU 时间为代价提供最大的回报（即内存回收）。因此，在繁忙的程序中，每秒钟可能会看到几次短暂的收集，但在连续的第二代收集之间可能也常见几分钟的间隔。

CLR 对第 2 代对象还有另一个小技巧。它们通常变化不大，因此在 GC 的第一阶段中——即运行时检测可达对象的阶段——有很高的可能性会重复一些早期完成的工作，因为它将完全遵循相同的引用并对堆的显著部分产生相同的结果。因此，CLR 有时会使用操作系统的内存保护服务来检测旧的堆块何时被修改。这使得它能够依赖于早期 GC 操作的总结结果，而无需每次都重新执行所有工作。

GC 如何决定仅从第 0 代回收，还是从第 1 或甚至第 2 代回收？所有三代的回收都是通过消耗一定量的内存来触发的。因此，对于第 0 代的分配，一旦自上次 GC 以来分配了一些特定字节数，将会发生新的 GC。幸存下来的对象将移入第 1 代，CLR 会跟踪自上次第 1 代回收以来添加到第 1 代的字节数；如果该数字超过阈值，也会回收第 1 代。第 2 代的工作方式相同。这些阈值未记录，事实上它们甚至不是常量；CLR 监视您的分配模式，并修改这些阈值，以尝试找到在内存高效利用、最小化在 GC 中的 CPU 时间以及避免 CLR 在集合之间等待时间过长时产生的过度延迟之间的良好平衡。

###### 注意

这解释了为什么 CLR 不一定等到内存实际耗尽才触发 GC，正如前面提到的那样。提早运行 GC 可能更有效。

你可能会想知道前面信息的实际意义有多大。毕竟，底线似乎是 CLR 确保堆块在可访问时保持，一旦它们变得不可访问，它将最终回收它们的内存，并且它采用一种旨在高效执行此操作的策略。这种分代优化方案的细节对开发者有影响吗？它们告诉我们某些编码实践可能比其他实践更高效。

这个过程最显而易见的结果是，您分配的对象越多，GC 就越难工作。但即使不了解实现方式，您也可能猜到这一点。更微妙的是，较大的对象会导致 GC 工作更加艰难——每代的回收都是由应用程序使用的内存量触发的。因此，更大的对象不仅增加了内存压力，它们还由于触发更频繁的 GC 而消耗了更多的 CPU 周期。

或许从理解收集器的代性质中得出的最重要的事实是，对象的生存期对 GC 的工作量有影响。生存时间非常短的对象能够得到有效处理，因为它们使用的内存在第 0 代或第 1 代的收集中将很快被回收，并且需要移动以压缩堆的数据量很小。而生存时间非常长的对象也没问题，因为它们最终会进入第二代。它们不会经常被移动，因为对该堆部分的收集是不频繁的。此外，CLR 可能能够利用操作系统内存管理器的写入检测功能来更有效地管理老对象的可达性发现。然而，虽然生存时间非常短和非常长的对象都能得到有效处理，但是那些存活到第二代但又不久的对象则是一个问题。微软有时将这种情况描述为*中年危机*。

如果你的应用程序经常创建大量进入第二代但最终成为不可达的对象，CLR 将需要比通常更频繁地在第二代执行回收（实际上，第二代仅在全局回收期间进行回收，这也会回收之前由大对象使用的空闲空间）。这些通常比其他回收显著昂贵。压缩需要更多处理较老对象的工作，但同时在破坏第二代堆时也需要更多的清理工作。CLR 在堆的这一部分建立的关于可达性的图像可能需要重建，并且在压缩堆时，GC 将需要禁用用于启用写入检测的检测，这会带来成本。此外，这一部分堆中的大部分内容很可能也不会位于 CPU 的缓存中，因此处理它可能会很慢。

全局垃圾回收（Full GC）消耗的 CPU 时间明显多于短暂代的回收。在 UI 应用中，这可能导致用户遭遇到足以引起不适的延迟，尤其是如果堆的某些部分已被操作系统分页出去。在服务器应用中，全局回收可能导致服务请求处理时间显著波动。这些问题并非世界末日，正如我后面将描述的那样，CLR 提供了一些机制来减轻这些问题。即便如此，在设计将有趣数据缓存到内存中的代码时，最小化对象存活到第二代的数量对性能是有益的。在这一过程中，你需要考虑到垃圾回收行为的缓存老化策略可能会表现出低效，如果你不了解中年对象的危险，很难弄清楚原因。而且，正如我将在本章后面展示的那样，中年危机问题是你可能希望尽量避免使用 C#析构函数的一个原因。

顺便说一句，我没有提到一些堆操作的详细信息。 例如，我没有讨论 GC 通常如何将地址空间的部分专用于以固定大小的块分配内存，也没有详细讨论它如何提交和释放内存。 尽管这些机制很有趣，但与您如何设计代码有关的假设性 GC 对典型对象生命周期的了解要比意识更重要。 它们也往往会发生变化- .NET 6.0 在这个领域做出了重大修改以提高性能。

在讨论从不可达对象中收集内存的主题时，还有一件事要说。 正如前面提到的，大对象的工作方式不同。 有一个名为*大对象堆*（LOH）的单独堆，.NET 运行时会将大于 85,000 字节的对象放入其中；⁶ Mono 运行时使用 8,000 字节的阈值，因为它经常用于内存受限的环境。 这仅仅是对象本身，而不是对象在构建过程中分配的所有内存总和。 在示例 7-5 中的`GreedyObject`类的一个实例将非常小 - 它只需要足够的空间来存储单个引用，再加上堆块的开销。 在 32 位进程中，引用将占用 4 字节，开销将占用 8 字节，在 64 位进程中，这个空间将是两倍。 然而，它所引用的数组长度为 400,000 字节，因此会放在 LOH 中，而`GreedyObject`本身会放在普通堆中。

##### Example 7-5\. 一个带有大数组的小对象

```cs
public class GreedyObject
{
    public int[] MyData = new int[100_000];
}
```

在技术上，可以创建一个需要 LOH 的实例的类，但在生成的代码或高度构造的示例之外，这种情况不太可能发生。 实际上，大多数 LOH 堆块将包含数组和可能是字符串。

LOH 与普通堆的最大区别在于，GC 通常不会压缩 LOH，因为复制大对象很昂贵。（应用程序可以请求在下一个完整的 GC 时压缩 LOH。 但在当前 CLR 实现中，没有明确请求此操作的应用程序将永远不会使其 LOH 被压缩。） 它更像传统的 C 堆：CLR 维护一个空闲块列表，并根据请求的大小决定使用哪个块。 然而，空闲块列表是由与堆的其余部分使用相同的不可达性机制填充的。

## 垃圾收集器模式

尽管 .NET 运行时将在运行时调整触发每一代收集的阈值等方面调整 GC 的某些行为，它还提供了可配置的选择，以适应不同类型的应用程序。这些可分为两大类别——工作站和服务器，在每个类别中，您可以选择使用后台或非并发收集。后台收集默认开启，但默认的顶层模式取决于项目类型：对于控制台应用程序和使用 WPF 等 GUI 框架的应用程序，GC 运行在工作站模式下，但 ASP.NET Core Web 应用程序将其更改为服务器模式。您可以通过在您的 *.csproj* 文件中定义一个属性来显式控制 GC 模式，如 示例 7-6 所示。这可以放在根 `Project` 元素的任何位置。

##### 示例 7-6\. 在 .NET Core 应用程序项目文件中启用服务器 GC

```cs
<PropertyGroup>
  <ServerGarbageCollection>true</ServerGarbageCollection>
</PropertyGroup>
```

###### 注意

此 `ServerGarbageCollection` 属性使构建系统在生成您的应用程序的 *YourApplication.runtimeconfig.json* 文件时添加一个设置。这个文件包含一个 `configProperties` 部分，其中可以包含一个或多个 *CLR 主机配置开关*。在项目文件中启用服务器 GC 将在此配置文件中将 `Sys⁠tem.​GC.⁠Ser⁠ver` 开关设置为 `true`。所有 GC 设置也通过配置开关控制，如 JIT 编译器模式等 CLR 行为。

工作站模式是为客户端代码通常必须处理的工作负载设计的，在这种情况下，进程通常在任何时间都在处理单个任务或少量任务。工作站模式提供两种变体：非并发和后台。

在后台模式（默认模式）下，GC 尽量减少在 GC 期间挂起线程的时间。在某些 GC 阶段，CLR 需要暂停执行以确保一致性。对于短暂代的收集，线程将在操作的大部分时间内被挂起。这通常没问题，因为这些收集通常运行非常快速，它们花费的时间与未引起任何磁盘活动的页面错误相似。（这些非阻塞页面错误发生频率相当高，并且足够快，以至于许多开发人员甚至不知道它们发生过。）完整收集是问题所在，而后台模式处理这些情况有所不同。并非所有在收集中完成的工作都需要使一切停顿，后台模式利用这一点，使得完整（第二代）收集可以在后台线程上进行，而不强制其他线程阻塞，直到该收集完成。这对于具有 UI 的应用程序特别有用，因为它减少了由于 GC 而导致应用程序变得不响应的可能性。

非并发模式旨在优化单处理器单核心上的吞吐量。相比非并发 GC，后台 GC 在任何特定工作负载下使用的内存和 CPU 周期略多，但换取更低的延迟，可能更高效。对于某些工作负载，如果在项目文件中将`ConcurrentGarbageCollection`属性设置为`false`，则可能会发现代码运行更快。对于大多数客户端代码，最大的关注点是避免用户可见的延迟。用户对非响应更为敏感，而对次优平均 CPU 利用率的感知性较低，因此在交互式应用程序中，为了改善感知性能而多消耗一些内存和 CPU 周期通常是一个不错的权衡。

服务器模式与工作站模式显著不同。仅当您拥有多个硬件线程时才可用，例如，多核 CPU 或多个物理 CPU。（如果您已启用服务器 GC 但您的代码最终在单核机器上运行，它将退回到使用工作站 GC。）它的可用性与您运行的操作系统无关，例如，如果您拥有适当的硬件，不管您运行哪个 Windows 版本（包括非服务器和服务器版本），服务器模式都可用，而工作站模式始终可用。在服务器模式下，每个处理器核心都有其自己的堆部分，因此当一个线程独立于进程的其余部分工作时，它可以以最小的争用分配堆块。在服务器模式下，CLR 创建几个专用于 GC 的线程，每个逻辑 CPU 都有一个。这些线程比普通线程具有更高的优先级，因此当 GC 发生时，所有可用的 CPU 核心都会处理自己的堆，这可以在具有大堆的情况下提供比工作站模式更好的吞吐量。

###### 注

由一个线程创建的对象仍然可以被其他线程访问——从逻辑上讲，堆仍然是一个统一的服务。服务器模式只是一种针对大部分情况下每个线程独立工作的工作负载优化的实现策略。请注意，如果所有作业具有类似的堆分配模式，它的效果最佳。

在服务器模式下可能会出现一些问题。当机器上只有一个进程使用此模式时，效果最佳，因为它设置为在收集期间尝试同时使用所有 CPU 核心。它还倾向于使用比工作站模式更多的内存。如果单个服务器托管多个 .NET 进程并且所有进程都这样做，资源争用可能会降低效率。服务器 GC 的另一个问题是它更偏重于吞吐量而非响应时间。特别是，收集发生得较少，因为这倾向于增加多 CPU 收集能够提供的吞吐量优势，但也意味着每个单独的收集时间更长。

与工作站 GC 一样，服务器 GC 默认使用后台收集。在某些情况下，禁用它可能会提高吞吐量，但要注意可能引起的问题。例如，在非并发服务器模式下进行完整收集可能会导致网站响应严重延迟，特别是如果堆很大的情况下。您可以通过几种方式来缓解这个问题。您可以在收集发生之前请求通知（使用`System.GC`类的`RegisterForFullGCNotification`、`WaitForFullGCApproach`和`WaitForFullGCComplete`方法），如果您有服务器群，则运行完整 GC 的服务器可能会要求负载均衡器避免在 GC 完成之前传递请求给它。更简单的选择是保留后台收集功能。由于后台收集允许应用程序线程继续运行，甚至可以在后台进行 0 代和 1 代收集，因此它显著提高了应用程序在收集期间的响应时间，同时仍然提供服务器模式的吞吐量优势。

## 暂时挂起垃圾回收

可以要求.NET 在特定代码段运行时禁止 GC。如果您正在执行时间敏感的工作，这很有用。Windows、macOS 和 Linux 不是实时操作系统，因此从来没有任何保证，但是在关键时刻暂时排除 GC 可能仍然有助于减少事情在最糟糕的时刻变慢的机会。请注意，此机制通过提前执行可能在相关代码段中本来会发生的任何 GC 工作，因此这可能会导致 GC 相关的延迟比预期更早地发生。它只保证一旦您指定的代码区域开始运行，如果您满足某些要求，将不会再有进一步的 GC 发生——实际上，在时间关键工作开始之前，它会将必要的延迟排除在外。

`GC`类提供了`TryStartNoGCRegion`方法，您可以调用该方法指示您要开始一些需要不受 GC 中断影响的工作。您必须传入一个值，指示在此工作期间您将需要多少内存，它将尝试确保在继续之前至少有这么多内存可用（如果需要，执行 GC 以释放该空间）。如果该方法指示成功，则只要您不使用比请求的内存更多的内存，您的代码将不会被 GC 中断。在完成时间关键工作后，您应该调用`EndNoGCRegion`，使 GC 可以恢复其正常操作。如果在调用`EndNoGCRegion`之前，您的代码使用的内存超过了请求的量，CLR 可能会执行 GC，但只有在绝对不能避免直到调用`EndNoGCRegion`之前时才会执行。

虽然`TryStartNoGCRegion`的单参数形式会在必要时执行完整的 GC 以满足您的请求，但某些重载采用`bool`，使您能够告诉它，如果需要完整的阻塞 GC 来释放必要的空间，您更愿意中止。还有一些重载，您可以在其中分别指定普通堆和大对象堆的内存需求。

## 意外地破坏压缩

堆压缩是 CLR 的 GC 的重要特性，因为它对性能有显著积极影响。某些操作可能会阻止压缩，这是您希望尽量减少的事情，因为碎片化可能会增加内存使用并显著降低性能。

要能够压缩堆，CLR 需要能够移动堆块。通常情况下，它可以做到这一点，因为它知道应用程序引用堆块的所有位置，并且在重新定位块时可以调整所有引用。但是，如果您调用直接使用您提供的内存的操作系统 API 呢？例如，如果您从文件或网络套接字读取数据，那么这如何与 GC 交互？

如果使用读取或写入数据的系统调用，使用诸如硬盘或网络接口这样的设备，这些通常直接使用您应用程序的内存。如果您从磁盘读取数据，则操作系统可能会指示磁盘控制器将字节直接放入您应用程序传递给 API 的内存中。操作系统将执行必要的计算，以将虚拟地址转换为物理地址。（使用虚拟内存时，您的应用程序在指针中放置的值只间接相关于计算机 RAM 中的实际地址。）操作系统将在 I/O 请求期间锁定页面，以确保物理地址保持有效。然后，它将向磁盘系统提供该地址。这使得磁盘控制器可以将数据直接从磁盘复制到内存中，无需 CPU 进一步参与。这非常高效，但在遇到紧凑的堆时会遇到问题。如果内存块是堆上的`byte[]`数组怎么办？假设我们请求读取数据和磁盘能够提供数据之间发生了 GC。（机械硬盘的旋转盘片可能需要 10 毫秒或更长时间才能开始提供数据，从 CPU 的角度来看这是一个时代。）如果 GC 决定重新定位我们的`byte[]`数组以压缩堆，则操作系统提供给磁盘控制器的物理内存地址将过时，因此当控制器开始将数据放入内存时，它将写入错误的位置。

CLR 处理这个问题有三种方式。一种是让 GC 等待——在 I/O 操作进行期间，堆重定位可以暂停。但这是行不通的；一个忙碌的服务器可以连续运行数天，而没有进入没有 I/O 操作正在进行的状态。事实上，服务器甚至不需要忙碌。它可能会分配几个 `byte[]` 数组来容纳接下来的几个入站网络请求，并通常会尝试避免进入没有至少一个这样的缓冲区可用的状态。操作系统将拥有所有这些的指针，并且很可能已经为网络卡提供了相应的物理地址，以便它可以在数据开始到达时立即开始工作。因此，即使是空闲的服务器也有某些不能被重定位的缓冲区。

CLR 另一种选择是为这类操作提供一个单独的非移动堆。也许我们可以为 I/O 操作分配一个固定的内存块，然后在 I/O 完成后将结果复制到 `byte[]` 数组中的 GC 堆。但这也不是一个明智的解决方案。复制数据是昂贵的——你复制的入站或出站数据越多，服务器运行速度就越慢，因此你确实希望网络和磁盘硬件直接将数据复制到其自然位置或从其自然位置复制。如果这个假设的固定堆不仅仅是 CLR 的一个实现细节——如果它可以供应用程序代码直接使用以最小化复制，那可能会打开 GC 应该消除的所有内存管理错误的大门。

因此，CLR 使用第三种方法：有选择地防止堆块重定位。GC 在 I/O 操作进行期间可以自由运行，但某些堆块可以被固定。固定一个块会设置一个标志，告诉 GC 当前不能移动该块。因此，如果 GC 遇到这样的块，它将简单地将其留在原地，但会尝试重新定位其周围的所有内容。

通常有五种方式 C# 代码导致堆块被固定。你可以使用 `fixed` 关键字显式地这样做。这允许你获取一个指向存储位置（如字段或数组元素）的原始指针，编译器将生成确保固定指针在作用域内时，它引用的堆块将被固定的代码。固定块的更常见方式是通过互操作（即调用非托管代码，如操作系统 API）。如果你调用一个需要指向某物的指针的 API，CLR 将检测到指向堆块的情况，并自动固定该块。默认情况下，CLR 在方法返回时会自动取消固定。如果你调用一个异步 API，在返回后将继续使用内存，你可以使用前面提到的 `GCHandle` 类来固定一个堆块，直到你明确取消固定；这是第三种固定技术。

固定堆块的第四种和最常见的方法也是最不直接的：许多运行时库 API 会代表你调用非托管代码，并且会固定作为结果传递的数组。例如，运行时库定义了一个代表字节流的`Stream`类。这个抽象类有几个实现。一些流完全在内存中工作，但一些包装了 I/O 机制，提供对文件或通过网络套接字发送或接收的数据的访问。抽象的`Stream`基类定义了通过`byte[]`数组读取和写入数据的方法，而基于 I/O 的流实现通常会在必要时固定包含这些数组的堆块。

第五种方法是使用`GC`类的`AllocateArray<T>`方法。与其写`new byte[4096]`，你可以写`GC.AllocateArray<byte>(4096, pinned: true)`。通过将第二个参数设置为`true`，你告诉 CLR 你希望这个数组永久固定。CLR 为此目的维护了一个额外的堆，称为*固定对象堆*（POH）。与 LOH 一样，POH 中的数组不会被移动，避免了固定可能造成的开销。

###### 注意

POH 在.NET Framework 或 Mono 上不可用。它是在.NET 5.0 中引入的，因此在.NET Core 3.1 上也不可用（将完全支持直到 2022 年 12 月）。因此，`AllocateArray<T>`在这些较旧的.NET 版本上不可用。

如果你正在编写一个频繁进行固定操作的应用程序（例如大量的网络 I/O），你可能需要仔细考虑如何分配这些被固定的数组。固定对于最近分配的对象造成的损害最大，因为这些对象存在于堆的紧凑活动最频繁的区域。固定最近分配的块往往会导致堆的短暂部分碎片化。通常几乎立即恢复的内存现在必须等待块解固，因此当收集器能够访问这些块时，已经分配了更多其他块，这意味着需要更多工作来恢复内存。

如果固定导致你的应用程序出现问题，将会有一些常见的症状。在 GC 中花费的 CPU 时间百分比将相对较高——超过 10%被认为是不好的。但这并不一定说明固定是罪魁祸首——可能是中年对象导致了太多的全收集。因此，你可以监控堆上固定块的数量⁸，看看这是否是特定的罪魁祸首。如果看起来过度固定正在给你带来痛苦，那么如果你能使用.NET 5.0 或更高版本，你可以使用`GC.AllocateArray<T>`在 POH 上分配相关的块。

如果你需要支持没有 POH 的 .NET 版本，仍然有两种方法可以避免固定的开销。其中一种方法是设计你的应用程序，以便只固定在 LOH 上的块。记住，默认情况下 LOH 不会被压缩，因此固定不会产生任何成本 —— GC 无论如何都不会移动块。这样做的挑战在于它强制你只能使用至少 85,000 字节长的数组进行所有 I/O。这不一定是个问题，因为大多数 I/O API 可以告诉它们只使用数组的一部分。因此，如果你实际上想要处理 4,096 字节块，你可以创建一个足够大的数组来容纳至少 21 个这样的块。你需要编写一些代码来跟踪数组中使用的槽位，但如果它修复了性能问题，那可能是值得努力的。

###### 警告

如果你选择通过尝试使用 LOH 来减少固定，你需要记住它是一个实现细节。未来的 .NET 版本有可能完全删除 LOH。因此，你需要针对每个新版本的 .NET 重新审视你设计的这一方面。

讨论的 `Span<T>` 和 `Memory<T>` 类型在 第十八章 中可以使数组处理变得更加容易。它们不仅使得处理不存储在 GC 堆上的内存变得比以前容易得多，而且可以完全避免固定。事实上，处理固定的最佳策略通常是仅仅使用 `MemoryPool<T>`。在没有 POH 的运行时，它会采取措施为你减少固定的开销，而在 .NET 5.0 或更高版本中，默认情况下将内存分配到 POH 中。

减少固定影响的另一种方法是确保大部分固定只发生在第 2 代对象上。如果你为应用程序分配了一组缓冲区并在应用程序的整个生命周期内重用它们，这将意味着你正在固定 GC 几乎不太可能移动的块，使得临时代随时可以进行压缩。越早分配缓冲区越好，因为对象越老，GC 移动的可能性就越小，所以如果可能的话，在应用程序启动期间使用这种方法会更好。

## 强制垃圾收集

`System.GC` 类提供了一个 `Collect` 方法，允许你强制进行 GC。你可以传递一个表示你想收集的代数的数字，不带参数的重载执行完全收集。你很少会有充分的理由去调用 `GC.Collect`。我在这里提到它是因为它在网络上经常出现，这可能会让它看起来比实际更有用。

强制触发垃圾回收（GC）可能会导致问题。GC 监控自身的性能，并根据应用程序的分配模式调整其行为。但要做到这一点，它需要允许足够的时间进行收集，以便准确评估当前设置的效果。如果你过于频繁地强制进行收集，它将无法进行自我调整，结果将是双重的：GC 将运行比必要更频繁，并且当运行时，其行为将是次优的。这两个问题都可能增加在 GC 中消耗的 CPU 时间。

那么什么时候会强制进行收集？如果你知道你的应用程序刚刚完成了一些工作，并且即将进入空闲状态，那么考虑强制进行收集可能是值得的。GC 通常是由活动触发的，因此如果你知道你的应用程序即将进入休眠状态——也许它是一个刚刚完成了批处理作业并且在接下来的几个小时内不会再做任何工作的服务——你知道它不会分配新对象，因此不会自动触发 GC。因此，在应用程序进入休眠状态之前强制进行 GC 可以在应用程序进入休眠状态之前为操作系统释放内存提供机会。尽管如此，如果这是你的情况，也许值得考虑那些能够使你的进程完全退出的机制——当它们不活动时，只需要偶尔执行的作业或服务可以在完全不活动时完全卸载。但如果由于某些原因这种技术不适用——也许你的进程具有很高的启动成本或需要保持运行以接收传入的网络请求——那么强制进行完全的收集可能是下一个最佳选项。

值得注意的是，有一种情况下 GC 可能会在没有应用程序需要做任何事情的情况下被触发。当系统内存不足时，Windows 向所有运行中的进程广播消息。CLR 会处理此消息，并在发生时强制进行 GC。因此，即使你的应用程序不主动尝试释放内存，如果系统中其他部分需要内存，内存最终可能会被回收。

# 析构函数和终结

CLR 为了我们的利益而努力工作，以找出何时不再使用我们的对象。它可以通知你这一点——而不是简单地删除不可达对象，CLR 可以首先告知一个对象即将被删除。CLR 称之为终结，但在 C#中通过特殊语法来表达：要利用终结，你必须编写一个析构函数。

###### 警告

如果你的背景是 C++，不要被名称或类似的语法所误导。正如你将看到的，C#中的析构函数在某些重要方面与 C++中的析构函数是不同的。

示例 7-7 展示了一个析构函数。这段代码编译成了一个名为 `Finalize` 的方法的覆盖，正如第六章所提到的，这是由 `object` 基类定义的一个特殊方法。Finalizer 必须总是调用它们所覆盖的 `Finalize` 的基类实现。C# 为我们生成了这个调用，以防止我们违反这个规则，这也是为什么我们不能直接编写 `Finalize` 方法。你不能编写调用 finalizer 的代码——它们由 CLR 调用，因此我们不指定析构函数的可访问性级别。

##### 示例 7-7\. 带析构函数的类

```cs
public class LetMeKnowMineEnd
{
    ~LetMeKnowMineEnd()
    {
        Console.WriteLine("Goodbye, cruel world");
    }
}
```

CLR 不保证按任何特定的时间表运行 finalizer。首先，它需要检测到对象已变为不可达，这要等到 GC 运行才会发生。如果你的程序空闲，可能会很长一段时间不会发生；GC 通常只会在程序在执行某些操作时，或者系统范围的内存压力导致 GC 开始运行时才会运行。完全可能会在对象变为不可达与 CLR 注意到它已不可达之间经过几分钟、几小时，甚至几天的时间。

即使 CLR 确实检测到不可达性，它仍不保证会立即调用 finalizer。Finalizer 在专用线程上运行。因为当前版本的 CLR 只有一个 finalization 线程（无论你选择哪种 GC 模式），一个慢速的 finalizer 将会导致其他 finalizer 等待。

在大多数情况下，CLR 甚至不保证会运行所有的 finalizer。当一个进程退出时，如果 finalization 线程还没来得及运行所有尚存的 finalizer，它将会立即退出，而不会等待它们全部完成。

总之，如果你的程序既空闲又繁忙，finalizer 可能会被无限期地延迟，并且不能保证会运行。更糟糕的是——在 finalizer 中实际上无法做太多有用的事情。

你可能会认为 finalizer 是确保某些工作得以完全完成的好地方。例如，如果你的对象将数据写入文件但缓冲了数据以便能够写入少量大块而不是小而散的写入（因为大块写入通常更有效率），你可能会认为 finalization 是确保缓冲区中的数据已安全刷新到磁盘的明显场所。但请再次考虑。

在终结期间，一个对象不能信任其引用的其他对象。如果你的对象的析构函数运行了，你的对象必须已经变得不可达。这意味着你的对象引用的任何其他对象也很可能已经变得不可达。CLR 可能会同时发现相关对象组的不可达性——如果你的对象创建了三四个对象来帮助它完成工作，那么这些对象都将在同一时间变得不可达。CLR 不保证按任何顺序运行终结器。这意味着可能在你的析构函数运行时，你使用的所有对象都已经被终结。因此，如果它们执行任何最后的清理工作，现在已经为时过晚。例如，派生自`Stream`并提供对文件访问的`FileStream`类，在其析构函数中关闭其文件句柄。因此，如果你希望将数据刷新到`FileStream`中，现在已经为时过晚。

###### 注意

说实话，事情比我之前描述的要稍微好一些。尽管 CLR 不能保证运行大多数终结器，但实际上它通常会运行它们。缺乏保证仅在相对极端的情况下才有影响。即便如此，这并不能减轻一个事实，即通常不能依赖于析构函数中的其他对象。

由于析构函数似乎用处极小——也就是说，你不知道它们何时会运行，也不能在析构函数中使用其他对象——那么它们有什么用呢？

终结存在的主要原因是使得可以编写.NET 类型，这些类型是传统上由句柄表示的实体的包装器，例如文件和套接字。这些类型在 CLR 之外创建和管理——文件和套接字需要操作系统分配资源；库也可能提供基于句柄的 API，并且它们通常会在自己的私有堆上分配内存来存储有关句柄表示的信息。CLR 看不到这些活动——它只看到一个包含整数字段的.NET 对象，并不知道这个整数是 CLR 之外某些资源的句柄。因此，CLR 不知道当对象不再使用时关闭句柄的重要性。这就是终结器的作用：它们是放置代码的地方，告诉 CLR 之外的某些东西，由句柄表示的实体不再使用。在这种情况下，不能使用其他对象并不是问题。

###### 注意

如果你正在编写包装句柄的代码，通常应该使用从`SafeHandle`派生的内置类之一，或者在绝对必要的情况下，派生自己的类。这个基类通过一些面向句柄的辅助函数扩展了基本的终结机制。此外，它从互操作层获得特殊处理，以避免资源过早释放。

尽管前面已经讨论了其不可预测性和不可靠性，但还有一些其他用途需要最终化，这意味着它对你的帮助是有限的。有些类包含一个仅检查对象是否处于未完成工作状态的终结器。例如，如果你编写了一个在将数据缓冲到文件之前进行缓冲的类（如前所述），你需要定义一些方法，调用者在完成对象使用时应该使用这些方法（例如`Flush`或`Close`），然后你可以编写一个终结器来检查对象是否在被抛弃之前被放入了安全状态，如果没有，则引发错误。这将提供一种方式来发现程序是否忘记正确清理事物。

如果你编写了一个终结器，当你的对象处于不再需要最终化的状态时，你应该禁用它，因为最终化有其代价。如果你提供了一个`Close`或`Flush`方法，一旦这些方法被调用，最终化就不再需要了，所以你应该调用`System.GC`类的`SuppressFinalize`方法，让 GC 知道你的对象不再需要最终化。如果你的对象状态随后发生变化，你可以调用`ReRegisterForFinalize`方法来重新启用它。

最终化的最大成本是保证你的对象至少会存活到第一代，甚至可能更久。请记住，所有从第 0 代存活下来的对象都会进入第 1 代。如果你的对象有一个终结器，并且你没有通过调用`SuppressFinalize`来禁用它，CLR 不能在运行其终结器之前摆脱你的对象。由于终结器在单独的线程上异步运行，即使对象已被发现为不可达，它也必须保持活动状态。因此，尽管它是不可达的，但对象还不可收集。因此，它会继续存在到第 1 代。通常情况下，它将很快被最终化，这意味着对象随后会变成空间的浪费，直到进行第 1 代收集为止。这些收集比第 0 代收集频率低。如果你的对象在变得不可达之前已经进入第 1 代，那么终结器会增加在对象即将不再使用之前进入第 2 代的机会。因此，一个已最终化的对象对内存的使用效率不高，这是要避免最终化的原因，也是在确实需要最终化的对象中尽可能禁用它的原因。

###### 警告

即使 `SuppressFinalize` 可以避免大部分终结的昂贵开销，但是使用这种技术的对象仍然比完全没有终结器的对象有更高的开销。CLR 在构造可终结对象时会做一些额外的工作，以跟踪那些尚未终结的对象（调用 `SuppressFinalize` 只是将对象从这个跟踪列表中移除）。因此，尽管抑制终结比让它发生要好得多，但如果一开始就不要求它的话，会更好。

终结的一个稍微奇怪的后果是，GC 发现的一个不可达的对象可以使自身重新变得可达。可以编写一个析构函数，将 `this` 引用存储在根引用中，或者存储在通过根引用可达的集合中。没有任何限制阻止你这样做，对象将继续工作（尽管如果对象再次变得不可达，则其终结器不会第二次运行），但这是一件奇怪的事情。这被称为*复活*，但仅仅因为你能做到并不意味着你应该这样做。最好避免这种情况。

希望到现在为止，我已经说服你析构函数并不提供一种通用的机制来清理对象。它们主要只对处理那些在 CLR 控制范围之外的句柄有用，并且最好避免依赖它们。如果你需要及时、可靠地清理资源，还有更好的机制。

# IDisposable

运行时库定义了一个名为 `IDisposable` 的接口。CLR 不会特别对待这个接口，但是 C# 对其有一些内置的支持。`IDisposable` 是一个简单的抽象；如示例 7-8 所示，它仅定义了一个成员，即 `Dispose` 方法。

##### 示例 7-8\. `IDisposable` 接口

```cs
public interface IDisposable
{
    void Dispose();
}
```

`IDisposable` 背后的理念很简单。如果你的代码创建了一个实现了这个接口的对象，在你使用完该对象之后，应该调用 `Dispose` 方法（有时候会有例外，参见“可选的释放”）。这样可以让对象有机会释放它可能已经分配的资源。如果被处理的对象使用的是由句柄表示的资源，它通常会立即关闭这些句柄，而不是等待终结发生（同时应该抑制终结）。如果对象正在以有状态的方式使用某个远程机器上的服务——例如保持打开到服务器的连接以便能够发出请求——它会立即通知远程系统它不再需要这些服务，以任何必要的方式（例如关闭连接）。

###### 注

有一个持续存在的谬误，即调用 `Dispose` 会导致 GC 执行某些操作。您可能在网上看到 `Dispose` 会终结对象，甚至导致对象被垃圾回收。这纯属无稽之谈。CLR 并不会对 `IDisposable` 或 `Dispose` 进行特殊处理，与其他接口或方法无异。

`IDisposable` 很重要，因为一个对象可能占用的内存很少，但却绑定了一些昂贵的资源。例如，考虑一个代表与数据库连接的对象。这样的对象可能不需要很多字段——甚至可能只有一个包含表示连接的句柄的字段。从 CLR 的角度来看，这是一个相当便宜的对象，我们甚至可以分配成百上千个而不触发 GC。但在数据库服务器中情况可能不同——它可能需要为每个传入的连接分配大量内存。连接甚至可能受到许可条款的严格限制。（这说明了“资源”是一个相当广泛的概念——它几乎意味着任何可能耗尽的东西。）

依赖 GC 注意到数据库连接对象不再使用很可能是一个糟糕的策略。CLR 将知道我们已经分配了，比如说，50 个东西，但如果总共只消耗了几百字节，它将看不到运行 GC 的理由。然而我们的应用程序可能即将停滞——如果我们只有 50 个数据库连接许可证，下一个尝试创建连接将失败。即使没有许可限制，我们仍可能通过打开比需要更多的连接而对数据库资源使用效率极低。

我们必须尽快关闭连接对象，而不是等待 GC 告诉我们哪些对象不再使用。这就是 `IDisposable` 的作用所在。当然，它不仅仅适用于数据库连接。对于任何代表生活在 CLR 之外的东西的对象，如文件或网络连接，它至关重要。即使对于不受特别限制的资源，`IDisposable` 也提供了一种告知对象我们已经完成使用它们的方法，以便它们可以干净地关闭，解决了之前描述的对于执行内部缓冲的对象的问题。

###### 注意

如果资源创建成本高昂，可能希望重复使用它。数据库连接经常是这种情况，因此通常的做法是维护一个连接池。在完成使用连接后，不关闭连接，而是将其返回到池中，使其可以重新使用。（.NET 的许多数据访问提供程序可以为您执行此操作。）在这里仍然很有用的是 `IDisposable` 模型。当您向资源池请求资源时，通常会提供一个围绕真实资源的包装器，当您处置该包装器时，它会将资源返回到池中，而不是释放它。因此，调用 `Dispose` 实际上只是表示：“我不再需要这个对象了”，由 `IDisposable` 实现决定接下来如何处理它所代表的资源。

`IDisposable` 的实现必须能够容忍对 `Dispose` 的多次调用。尽管这意味着消费者可以多次调用 `Dispose` 而不会有害，但是在对象被处理后不应再试图使用它。事实上，运行库为此定义了一个特殊的异常，如果以这种方式误用对象，它们可以抛出：`ObjectDisposedException`。（我将在 第 8 章 中讨论异常。）

当然，您可以直接调用 `Dispose`，但是 C# 还支持三种方式使用 `IDisposable`：`foreach` 循环，`using` 语句和 `using` 声明。`using` 语句是一种确保一旦完成对实现 `IDisposable` 的对象的使用就可靠地释放它的方式。示例 7-9 展示了如何使用它。

##### 示例 7-9\. 一个 `using` 语句

```cs
using (StreamReader reader = File.OpenText(@"C:\temp\File.txt"))
{
    Console.WriteLine(reader.ReadToEnd());
}
```

这相当于 示例 7-10 中的代码。`try` 和 `finally` 关键字是 C# 异常处理系统的一部分，我将在 第 8 章 中详细讨论它们。在这种情况下，它们被用于确保在 `try` 块内的代码出现问题时，`finally` 块内的 `Dispose` 调用仍能执行。这也确保了如果在块的中间执行 `return` 语句，`Dispose` 也会被调用。（即使使用 `goto` 语句跳出块也是如此。）

##### 示例 7-10\. `using` 语句的扩展方式

```cs
{
    StreamReader reader = File.OpenText(@"C:\temp\File.txt");
    try
    {
        Console.WriteLine(reader.ReadToEnd());
    }
    finally
    {
        if (reader != null)
        {
            ((IDisposable) reader).Dispose();
        }
    }
}
```

如果 `using` 语句中声明的变量类型是值类型，C# 将不会生成检查 `null` 的代码，而直接调用 `Dispose`。

C# 支持一个更简单的替代方案，即使用声明，如 示例 7-11 所示。区别在于我们不需要提供一个块。使用声明在变量超出范围时释放其变量。它仍然生成 `try` 和 `finally` 块，因此在使用语句的块恰好完成于其他块的末尾的情况下（例如，它在方法的末尾完成），可以改为使用声明而不改变行为。这减少了嵌套块的数量，使您的代码更易读。（另一方面，对于普通的使用块，可能更容易看到对象何时不再使用。因此，每种样式都有其利弊。）

##### 示例 7-11\. 使用声明

```cs
using StreamReader reader = File.OpenText(@"C:\temp\File.txt");
Console.WriteLine(reader.ReadToEnd());
```

如果您需要在同一作用域内使用多个可释放资源，并且希望使用使用语句而不是声明（例如，因为您希望尽快释放资源而不是等待相关变量超出范围），您可以嵌套它们，但如果您在一个单独的块前堆叠多个使用语句可能更易于阅读。示例 7-12 使用此方法将一个文件的内容复制到另一个文件中。

##### 示例 7-12\. 堆叠使用语句

```cs
using (Stream source = File.OpenRead(@"C:\temp\File.txt"))
using (Stream copy = File.Create(@"C:\temp\Copy.txt"))
{
    source.CopyTo(copy);
}
```

堆叠使用语句不是一种特殊语法；这只是一个事实的结果，即使用语句总是后跟一个单独的嵌入语句，在调用 `Dispose` 之前将执行该语句。通常，该语句是一个块，但在 示例 7-12 中，第一个使用语句的嵌入语句是第二个使用语句。如果您使用使用声明而不是，堆叠是不必要的，因为这些没有相关的嵌入语句。

如果枚举器实现了 `IDisposable`，`foreach` 循环将生成使用 `IDisposable` 的代码。示例 7-13 展示了使用这种枚举器的 `foreach` 循环。

##### 示例 7-13\. `foreach` 循环

```cs
foreach (string file in Directory.EnumerateFiles(@"C:\temp"))
{
    Console.WriteLine(file);
}
```

`Directory` 类的 `EnumerateFiles` 方法返回一个 `IEnumerable<string>`。正如您在 第五章 中看到的，它有一个 `GetEnumerator` 方法返回一个 `IEnumer⁠ator​<string>`，这是继承自 `IDisposable` 的接口。因此，C# 编译器将生成与 示例 7-14 等效的代码。

##### 示例 7-14\. `foreach` 循环如何展开

```cs
{
    IEnumerator<string> e =
        Directory.EnumerateFiles(@"C:\temp").GetEnumerator();
    try
    {
        while (e.MoveNext())
        {
            string file = e.Current;
            Console.WriteLine(file);
        }
    }
    finally
    {
        if (e != null)
        {
            ((IDisposable) e).Dispose();
        }
    }
}
```

编译器可以生成几种变体，取决于集合的枚举器类型。如果它是实现了 `IDisposable` 的值类型，编译器在 `finally` 块中不会生成对 `null` 的检查（就像在 `using` 语句中一样）。如果枚举器的静态类型不实现 `IDisposable`，则结果取决于类型是否对继承开放。如果它是密封的，或者如果它是值类型，编译器将不会生成尝试调用 `Dispose` 的代码。如果它没有被密封，编译器将在 `finally` 块中生成代码，在运行时测试枚举器是否实现了 `IDisposable`，如果是，则调用 `Dispose`，否则不执行任何操作。

`IDisposable` 接口在使用起来最简单的情况是，在同一个方法中获取资源并在使用完毕后释放它，因为你可以编写一个 `using` 语句（或在适当的情况下，一个 `foreach` 循环）来确保调用 `Dispose`。但有时，你会编写一个创建可释放对象并将其引用放入字段的类，因为它需要在较长时间内使用该对象。例如，你可能会编写一个日志记录类，如果日志记录器对象将数据写入文件，则可能会保留 `StreamWriter` 对象。在这种情况下，C# 不会提供自动帮助，因此你需要确保任何包含的对象都被释放。你将编写自己的 `IDisposable` 实现来释放其他对象，就像示例 7-15 所示。请注意，此示例将 `_file` 设置为 `null`，因此不会尝试两次释放文件。这并非绝对必要，因为 `StreamWriter` 可以容忍对 `Dispose` 的多次调用。但这确实为 `Logger` 对象提供了一种简单的方法来知道它处于已释放状态，因此如果我们添加了一些真正的方法，我们可以检查 `_file`，如果为 `null`，则抛出 `ObjectDisposedException`。

##### 示例 7-15\. 释放包含的实例

```cs
public sealed class Logger : IDisposable
{
    private StreamWriter? _file;

    public Logger(string filePath)
    {
        _file = File.CreateText(filePath);
    }

    public void Dispose()
    {
        if (_file != null)
        {
            _file.Dispose();
            _file = null;
        }
    }
    // A real class would go on to do something with the StreamWriter, of course
}
```

此示例避开了一个重要的问题。该类是密封的，这避免了如何处理继承的问题。如果你编写一个未密封的类并实现了 `IDisposable`，你应该提供一种方法，让派生类添加自己的清理逻辑。最直接的解决方案是将 `Dispose` 声明为虚方法，以便派生类可以重写它，在调用基类实现的同时执行自己的清理。然而，在 .NET 中有时会看到更复杂的模式。

有些对象实现了`IDisposable`并且还有一个终结器。自从引入了`SafeHandle`及其相关类以来，一个类需要同时提供这两者的情况就相对不常见了（除非它是从`SafeHandle`派生而来）。通常只有处理句柄的包装器才需要终结器，而现在通常使用句柄的类会推迟到`SafeHandle`提供这个功能，而不是自己实现终结器。不过，也有例外情况，一些库类型实现了一种模式，旨在支持终结和`IDisposable`，使你能够在派生类中为两者提供自定义行为。例如，`Stream`基类就是这样工作的。

###### 警告

这种模式被称为*dispose 模式*，但不要认为在实现`IDisposable`时通常应该使用它。相反，几乎不需要这种模式。即使在它被发明时，也只有少数类需要它，而现在有了`SafeHandle`之后，几乎从不需要了（`SafeHandle`在.NET 2.0 中引入，所以自从 dispose 模式广泛有用以来已经很长时间了）。不幸的是，一些人误解了这种模式的狭窄实用性，所以你会找到一些善意但完全错误的建议告诉你应该对所有`IDisposable`实现使用它。请忽略这些建议。这种模式今天的主要相关性在于你有时会在旧类型（如`Stream`）中遇到它。

这种模式是定义一个受保护的`Dispose`重载，它接受一个`bool`参数。基类从其公共`Dispose`方法以及析构函数中调用此方法，分别传递`true`或`false`。这样，你只需重写一个方法，即受保护的`Dispose`方法。它可以包含对终结和处理通用的逻辑，比如关闭句柄，但你也可以执行任何特定于处理或终结的逻辑，因为参数告诉你正在执行哪种类型的清理。示例 7-16 展示了这种模式可能的样子。（这仅用于示例，`MyCustomLibraryInteropWrapper`类是为这个例子而虚构的。）

##### 示例 7-16\. 自定义终结和处理逻辑

```cs
public class MyFunkyStream : Stream
{
    // For illustration purposes only. Usually better to avoid this whole
    // pattern and to use some type derived from SafeHandle instead.
    private IntPtr _myCustomLibraryHandle;
    private Logger? _log;

    protected override void Dispose(bool disposing)
    {
        base.Dispose(disposing);

        if (_myCustomLibraryHandle != IntPtr.Zero)
        {
            MyCustomLibraryInteropWrapper.Close(_myCustomLibraryHandle);
            _myCustomLibraryHandle = IntPtr.Zero;
        }
        if (disposing)
        {
            if (_log != null)
            {
                _log.Dispose();
                _log = null;
            }
        }
    }

    // ...overloads of Stream's abstract methods would go here
}
```

这个假设性示例是对`Stream`抽象的自定义实现，它使用了一些外部非.NET 库，该库提供基于句柄的资源访问。我们更倾向于在公共`Dispose`方法调用时关闭句柄，但如果在我们的终结器运行时还没有发生这种情况，我们希望在那时关闭句柄。因此，代码检查句柄是否仍然打开，并在必要时关闭它，无论调用`Dispose(bool)`重载是否因显式释放对象或终结器运行而发生，我们都需要确保句柄在任一情况下都被关闭。然而，这个类似乎也使用了来自示例 7-15 的`Logger`类的实例。因为那是一个普通对象，我们不应在终结器中尝试使用它，所以我们只在对象被释放时尝试处理它。如果我们正在进行终结处理，那么尽管`Logger`本身不可终结，它使用的`FileStream`是可终结的；而且很可能`FileStream`的终结器已经在我们的`MyFunkyStream`类的终结器运行时运行过，因此在`Logger`上调用方法会是个坏主意。

当基类提供了这种虚拟的受保护的`Dispose`形式时，应该在其公共`Dispose`方法中调用`GC.SuppressFinalization`。`Stream`基类就是这样做的。更一般地说，如果你发现自己编写了一个既提供了`Dispose`又提供了终结器的类，那么无论你选择是否支持继承这种模式，当调用`Dispose`时，你都应该抑制终结处理。

既然我建议避免这种模式，那么像示例 7-15 这样的代码在不接受使用`sealed`的情况下应该怎么办？答案很简单：如果你正在编写一个实现了`IDisposable`的类，并且希望该类可以被继承（即不是`sealed`），请将你的`Dispose`方法设为`virtual`。这样，派生类型可以重写它以添加它们自己的处理逻辑（而这些重写应始终调用基类的`Dispose`）。

## 可选的处理

尽管你应该在大多数实现了`IDisposable`接口的对象上的某个时刻调用`Dispose`，但也有少数例外情况。例如，.NET 的反应式扩展（在 第十一章 中描述）提供了表示事件流订阅的`IDisposable`对象。你可以调用`Dispose`来取消订阅，但有些事件源会自然结束，自动关闭任何订阅。如果发生这种情况，你就不需要调用`Dispose`。此外，广泛与异步编程技术结合使用的`Task`类型（在 第十七章 中描述）实现了`IDisposable`，但除非你引起它分配一个`WaitHandle`，在正常使用中是不会发生的。`Task`通常的使用方式使得在它上面找到一个合适的时间调用`Dispose`特别麻烦，所以幸运的是通常情况下不需要这样做。

`HttpClient` 类是另一个例外，但方式不同。我们很少对这种类型的实例调用`Dispose`，这是因为我们被鼓励重用实例。如果每次需要时构造、使用和处理一个`HttpClient`，你会破坏其重用现有连接的能力，当多次向同一服务器发送请求时。这可能会导致两个问题。首先，打开 HTTP 连接有时可能比发送请求和接收响应更耗时，因此阻止`HttpClient`重用连接以随时间发送多个请求可能会引起显著的性能问题。只有重用`HttpClient`才能使连接重用起效果。⁹ 其次，TCP 协议（HTTP 的基础）具有的特性意味着操作系统不能总是立即回收与连接相关的所有资源：它可能需要保留连接的 TCP 端口相当长的时间（可能几分钟），即使你已告诉操作系统关闭了连接，也可能耗尽端口，阻止所有进一步的通信。

这样的例外情况并不常见。仅当你使用的类的文档明确说明不需要调用`Dispose`时，才可以安全地省略调用`Dispose`。

# **装箱**

当我讨论 GC 和对象生命周期时，还有一个话题我应该在这一章节中讲述：*装箱*。装箱是使得类型为`object`的变量能够引用值类型的过程。一个`object`变量只能持有对堆上某物的引用，那么它如何能引用一个`int`呢？当代码在 示例 7-17 中运行时会发生什么？

##### 示例 7-17\. 使用`int`作为对象

```cs
static void Show(object o)
{
    Console.WriteLine(o.ToString());
}

int num = 42;
Show(num);
```

`Show`方法期望一个对象，而我正在传递`num`，这是一个值类型`int`的局部变量。在这些情况下，C#会生成一个箱子，这实质上是一个值的引用类型包装器。CLR 可以自动为任何值类型提供一个箱子，尽管如果它没有提供，你可以编写自己的类来执行类似的操作。示例 7-18 展示了一个手工构建的箱子。

##### 示例 7-18\. 实际上不是箱子的工作原理

```cs
// Not a real box but similar in effect.
public class Box<T>
    where T : struct
{
    public readonly T Value;
    public Box(T v)
    {
        Value = v;
    }

    public override string? ToString() => Value.ToString();
    public override bool Equals(object? obj) => Value.Equals(obj);
    public override int GetHashCode() => Value.GetHashCode();
}
```

这是一个包含一个值类型实例作为唯一字段的相当普通的类。如果你在箱子上调用`object`的标准成员，这个类的重写使它看起来好像你直接调用了字段本身。因此，如果我将`new Box<int>(num)`作为参数传递给示例 7-17 中的`Show`，`Show`将接收到该箱子的引用。当`Show`调用`ToString`时，箱子将调用`int`字段的`ToString`，所以你会期望程序显示 42。

我们不需要编写示例 7-18，因为 CLR 将为我们构建这个箱子。它将在堆上创建一个包含装箱值副本的对象，并将标准`object`方法转发给装箱值。它还做了一些我们无法做到的事情。如果调用一个装箱的`int`的`GetType`方法来获取其类型，它将返回与直接调用`int`变量的`GetType`方法相同的`Type`对象。对于我的自定义`Box<T>`，我无法这样做，因为`GetType`不是虚拟的。此外，与手工构建的箱子相比，获取底层值更容易，因为解箱是 CLR 的内置特性。

如果你有一个类型为`object`的引用，并将其转换为`int`，CLR 将检查该引用是否确实指向一个装箱的`int`；如果是，CLR 将返回装箱值的副本。（如果不是，它会抛出`InvalidCastException`异常。）因此，在示例 7-17 的`Show`方法中，我可以写`(int) o`来获取原始值的副本，而如果我在示例 7-18 中使用该类，我将需要更复杂的`((Box<int>) o).Value`。

我还可以使用模式匹配来提取一个装箱值。示例 7-19 使用声明模式来检测变量`o`是否包含一个装箱的`int`的引用，如果是，则将其提取到局部变量`i`中。正如我们在第二章中看到的那样，当你像这样使用`is`操作符与模式时，如果模式匹配，则结果表达式评估为`true`，如果不匹配则为`false`。因此，仅当那里确实有一个`int`值需要解箱时，才会运行此`if`语句的主体。

##### 示例 7-19\. 使用类型模式进行拆箱

```cs
if (o is int i)
{
    Console.WriteLine(i * 2);
}
```

所有结构体都自动支持装箱，¹⁰ 不仅仅是内置的值类型。如果结构体实现了任何接口，该装箱将提供相同的所有接口。 （这是 示例 7-18 无法执行的另一个技巧。）

一些隐式转换会导致装箱。你可以在 示例 7-17 中看到这一点。我传递了一个 `int` 类型的表达式到需要 `object` 的地方，而不需要显式转换。隐式转换也存在于值与其类型实现的任何接口之间。例如，你可以将类型为 `int` 的值分配给类型为 `IComparable<int>` 的变量（或将其作为该类型的方法参数传递），而不需要进行转换。这将创建一个装箱，因为任何接口类型的变量都类似于 `object` 类型的变量，它们只能保存对堆上项目的引用。

###### 注意

隐式装箱转换不等同于隐式引用转换。这意味着它们在协变或逆变中不起作用。例如，`IEnumerable<int>` 与 `IEnumerable<object>` 不兼容，尽管从 `int` 到 `object` 存在隐式转换，因为这不是隐式引用转换。

隐式装箱偶尔可能会因两个原因之一而引起问题。首先，它会导致 GC 需要额外的工作。CLR 不会尝试缓存装箱，因此如果你编写一个执行 100,000 次的循环，并且该循环包含使用隐式装箱转换的表达式，你将会生成 100,000 个装箱，最终 GC 将不得不像清理堆上的其他任何内容一样清理它们。其次，每个装箱操作（和每个拆箱操作）都会复制值，这可能不会提供您预期的语义。示例 7-20 展示了一些可能令人惊讶的行为。

##### 示例 7-20\. 阐明可变结构的潜在问题

```cs
static void CallDispose(IDisposable o)
{
    o.Dispose();
}

DisposableValue dv = new ();
Console.WriteLine("Passing value variable:");
CallDispose(dv);
CallDispose(dv);
CallDispose(dv);

IDisposable id = dv;
Console.WriteLine("Passing interface variable:");
CallDispose(id);
CallDispose(id);
CallDispose(id);

Console.WriteLine("Calling Dispose directly on value variable:");
dv.Dispose();
dv.Dispose();
dv.Dispose();

Console.WriteLine("Passing value variable:");
CallDispose(dv);
CallDispose(dv);
CallDispose(dv);

public struct DisposableValue : IDisposable
{
    private bool _disposedYet;

    public void Dispose()
    {
        if (!_disposedYet)
        {
            Console.WriteLine("Disposing for first time");
            _disposedYet = true;
        }
        else
        {
            Console.WriteLine("Was already disposed");
        }
    }
}
```

`DisposableValue` 结构实现了我们之前看到的 `IDisposable` 接口。它跟踪它是否已被处理。程序包含一个 `CallDispose` 方法，该方法在任何 `IDisposable` 实例上调用 `Dispose`。程序声明了一个类型为 `DisposableValue` 的单一变量，并将其传递给 `CallDispose` 三次。以下是程序该部分的输出：

```cs
Passing value variable:
Disposing for first time
Disposing for first time
Disposing for first time
```

在所有三个场景中，该结构体似乎认为这是我们首次调用其 `Dispose` 方法。这是因为每次调用 `CallDispose` 都创建了一个新的装箱——我们实际上并没有传递 `dv` 变量；每次都传递了一个新的装箱副本，因此 `CallDispose` 方法每次都在不同的结构体实例上工作。这与值类型通常的工作方式一致——即使没有装箱，当你将其作为参数传递时，你得到的是一个副本（除非使用 `ref` 或 `in` 关键字）。

程序的下一部分最终只生成了一个装箱——它将值分配给另一个类型为`IDisposable`的局部变量。这使用了与我们直接将变量作为参数传递时相同的隐式转换，因此这创建了另一个装箱，但是仅仅是一次。然后我们将同一个引用传递给这个特定装箱的三次调用，这解释了为什么程序这一阶段的输出看起来不同：

```cs
Passing interface variable:
Disposing for first time
Was already disposed
Was already disposed
```

这三次对`CallDispose`的调用都使用了同一个装箱，其中包含我们结构体的一个实例，所以在第一次调用后，它就记住它已经被处理了。接下来，我们的程序直接在局部变量上调用`Dispose`，生成了这个输出：

```cs
Calling Dispose directly on value variable:
Disposing for first time
Was already disposed
Was already disposed
```

这里完全没有涉及装箱，所以我们正在修改局部变量的状态。只看了一眼代码的人可能没有预料到这个输出——我们已经将`dv`变量传递给一个调用其参数`Dispose`的方法，因此在第一次执行时，它可能会认为它尚未被处理。但是一旦你理解了`CallDispose`需要一个引用，因此不能直接使用值，那么在这一点之前每次调用`Dispose`操作的都是某个装箱副本，而不是局部变量本身，一切就显而易见了。

最后，我们再次进行三次调用，直接将`dv`传递给`CallDispose`。这正是我们在代码开头所做的，所以这些调用产生了更多的装箱副本。但这一次，我们复制的是一个已经处于已处理状态的值，因此我们看到了不同的输出：

```cs
Passing value variable:
Was already disposed
Was already disposed
Was already disposed
```

当你理解发生了什么时，这些行为都很简单，但是这要求你注意你正在处理一个值类型，并且理解何时装箱会导致隐式复制。这就是微软建议开发人员不要编写可能改变其状态的值类型的一个原因——如果一个值不能改变，那么该类型的装箱值也不能改变。无论你处理的是原始值还是装箱副本，影响都较小，因此避免性能损失时，理解何时会发生装箱仍然很有用。

在早期的.NET 版本中，装箱在集合类中十分普遍，直到.NET 2.0 引入泛型之前。集合类都是以`object`为基础工作的，所以如果你想要一个可变大小的整数列表，列表中的每个`int`都会被装箱。泛型集合类不会导致装箱——`List<int>`能够直接存储未装箱的值。

## 装箱 Nullable<T>

第三章描述了`Nullable<T>`类型，这是一个包装器，为任何值类型添加了空值支持。请记住，C#为此有特殊的语法，在值类型名称末尾加上一个问号，所以我们通常会写`int?`而不是`Nullable<int>`。当涉及到装箱时，CLR 对`Nullable<T>`有特殊支持。

`Nullable<T>`本身是一个值类型，因此如果您尝试获取对它的引用，编译器将生成试图将其装箱的代码，就像处理任何其他值类型一样。然而，在运行时，CLR 不会生成包含`Nullable<T>`本身副本的装箱。相反，它会检查值是否处于空状态（即其`HasValue`属性返回`false`），如果是，则返回`null`。否则，它将装箱包含的值。例如，如果`Nullable<int>`有一个值，将其装箱将产生类型为`int`的箱。这与您从普通`int`值开始时得到的箱无法区分。（其中一个结果是，示例 7-19 中显示的模式匹配无论最初装箱的变量类型是`int`还是`int?`，都可以使用`int`在声明模式中。）

您可以将装箱的`int`解包为`int?`或`int`类型的变量。因此，示例 7-21 中的所有三个解包操作都将成功。如果将第一行修改为从未处于空状态的`Nullable<int>`初始化`boxed`变量，则它们也将成功。 （如果您从处于空状态的`Nullable<int>`初始化`boxed`，那将产生与将其初始化为`null`相同的效果，此示例的最后一行将抛出`NullReferenceException`。）

##### 示例 7-21\. 将`int`解包成可空和非可空变量

```cs
object boxed = 42;
int? nv = boxed as int?;
int? nv2 = (int?) boxed;
int v = (int) boxed;
```

这是一个运行时特性，而不仅仅是编译器的聪明。IL `box`指令（这是 C#在想要装箱值时生成的内容）检测到`Nulla⁠ble​<T>`值；`unbox`和`unbox.any` IL 指令能够从`null`或引用基础类型的装箱值产生`Nulla⁠ble​<T>`值。因此，如果您编写自己的看起来像`Nullable<T>`的包装类型，它不会表现出相同的行为；如果您将您的类型的值分配给一个`object`，它将像处理任何其他值一样对您的整个包装进行装箱。只有因为 CLR 知道`Nullable<T>`的存在，它才会表现出不同的行为。

# 总结

在本章中，我描述了运行时提供的堆。我展示了 CLR 用于确定哪些堆对象仍可被你的代码访问的策略，以及它用于回收不再使用的对象所占用内存的基于代的机制。GC 并非能预见，因此如果你的程序保持了一个对象的可访问性，GC 必须假设你将来可能会使用该对象。这意味着有时你需要小心确保不会因为意外保留对象太长时间而导致内存泄漏。我们看了最终化机制及其各种限制和性能问题，并且我们还看了`IDisposable`，它是清理非内存资源的首选系统。最后，我们看到了值类型如何因装箱而表现得像引用类型。

下一章中，我将展示 C#如何呈现 CLR 的错误处理机制。

¹ 本章中“GC”缩写用来指代*垃圾收集器*机制以及垃圾收集，即垃圾收集器的功能。

² Mono 运行时的 GC 与.NET GC 没有共享代码，尽管它们现在都驻留在同一个 GitHub 仓库中。尽管如此，它们在这里使用相同的方法。

³ 使用`ref struct`定义的值类型是一个例外：它们总是存在于堆栈上。第十八章讨论了这些内容。

⁴ CLR 并不总是等到内存用尽才进行垃圾回收。稍后我会详细讨论这些细节。目前，重要的是时不时地它会尝试释放一些空间。

⁵ Mono 运行时使用了稍微简化的方案，但仍然依赖于将新旧对象区分对待的基本原则。

⁶ .NET 提供了一个配置设置，允许你更改这个阈值。

⁷ 虽然单核 CPU 如今已经很少见，但在虚拟机上运行，将只有一个核心呈现给它们托管的代码仍然很常见。例如，如果你的应用程序在使用按消耗计费的云托管服务。

⁸ 你可以使用一个名为 PerfView 的免费 Microsoft 工具来完成这个操作。另外，免费的 BenchmarkDotNet 工具具有内存诊断功能。

⁹ 严格来说，需要重复使用的是底层的`MessageHandler`。如果你从`IHttpClientFactory`获取一个`HttpClient`，释放它是无害的，因为工厂会持有处理程序并在多个`HttpClient`实例中重用它。

¹⁰ 除了`ref struct`类型，因为它们总是存在于堆栈上。
