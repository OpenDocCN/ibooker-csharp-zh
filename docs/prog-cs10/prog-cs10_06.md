# 第六章：继承

C#类支持*继承*，这是一种流行的面向对象代码重用机制。当你编写一个类时，可以选择性地指定一个基类。你的类将从这个基类派生，这意味着基类中的所有内容将出现在你的类中，以及你添加的任何成员。

类和基于类的记录类型仅支持单一继承（因此只能指定一个基类）。接口提供了一种多重继承的形式。值类型，包括`record struct`类型，根本不支持继承。其中一个原因是值类型通常不通过引用使用，这就移除了继承的主要好处之一：运行时多态性。继承与值类型的行为不一定不兼容——某些语言可以处理它——但通常存在问题。例如，将某个派生类型的值赋给其基类型的变量将导致丢失派生类型添加的所有字段，这是一个被称为*slicing*的问题。C#通过将继承限制为引用类型来避免这个问题。当你将某个派生类型的变量赋给基类型的变量时，你复制的是一个引用，而不是对象本身，因此对象保持完整。Slicing 仅在基类提供了克隆对象的方法且未提供派生类扩展它的方法时出现问题（或者提供了，但某个派生类未扩展它）。

类使用在示例 6-1 中展示的语法来指定基类——基类型出现在紧随类名后的冒号之后。本示例假设在项目的其他地方或其使用的库中已经定义了一个名为`SomeClass`的类。

##### 示例 6-1 指定一个基类

```cs
public class Derived : SomeClass
{
}

public class AlsoDerived : SomeClass, IDisposable
{
    public void Dispose() { }
}
```

如同你在第三章看到的那样，如果类实现了任何接口，这些接口也会在冒号后列出。如果你想要从一个类派生，并且还想实现接口，基类必须首先出现，正如示例 6-1 所示。

你可以从一个又从另一个类派生的类派生。示例 6-2 中的`MoreDerived`类派生自`Derived`，后者又派生自`Base`。

##### 示例 6-2 继承链

```cs
public class Base
{
}

public class Derived : Base
{
}

public class MoreDerived : Derived
{
}
```

这意味着`MoreDerived`从技术上讲具有多个基类：它直接从`Derived`派生，间接从`Base`派生（通过`Derived`）。这不是多重继承，因为只有一个继承链——任何单个类最多直接从一个基类派生。（所有类都直接或间接地从`object`派生，如果你没有指定基类，则默认为基类。）

由于派生类继承了基类的所有内容——包括所有字段、方法和其他成员，无论是公有的还是私有的——因此，派生类的一个实例可以执行基类实例可以执行的所有操作。这是许多语言中继承所暗示的经典的*是一个*关系。任何`MoreDerived`的实例都是`Derived`的实例，也是`Base`的实例。C#的类型系统认识到这种关系。

# 继承与转换

C# 提供了各种内置的隐式转换。在第二章中，我们看到数字类型的转换，但引用类型也有转换。如果某个类型`D`从`B`派生（直接或间接），那么类型`D`的引用可以隐式地转换为类型`B`的引用。这是基于我在前一节中描述的*是一个*关系——任何`D`的实例都是`B`。这种隐式转换使多态成为可能：编写的针对`B`的代码将能够与任何从`B`派生的类型一起工作。

隐式引用转换是特殊的。与其他转换不同，它们不会以任何方式改变值。（所有内置的隐式数字转换都会从其输入创建一个新值，通常涉及表示的变化。例如，整数 1 的二进制表示对于`float`和`int`类型是不同的。）实际上，它们转换的是引用的解释，而不是引用本身或它所引用的对象。正如你将在本章后面看到的，CLR 在考虑隐式引用转换的可用性时，会考虑到这些地方，但不会考虑其他形式的转换。

###### 警告

两个引用类型之间的自定义隐式转换不算作这些目的的隐式引用转换，因为需要调用方法来实现这样的转换。在隐式引用转换的特殊情况中，依赖于“转换”在运行时无需工作这一事实。

反向没有隐式转换——虽然一个类型为`B`的变量可以引用类型为`D`的对象，但不能保证它会这样做。可能有任意数量从`B`派生的类型，一个`B`变量可以引用它们中的任何一个实例。然而，有时你可能希望尝试将引用从基类型转换为派生类型，这种操作有时称为*下转型*。也许你知道某个变量确实持有某种类型的引用。或者你不确定，希望你的代码为特定类型提供额外的服务。C# 提供了三种方法来执行此操作。

我们可以使用强制转换语法尝试进行下转型。这是我们用于执行非隐式数字转换的相同语法，如示例 6-3 所示。

##### 示例 6-3\. 感觉下转型

```cs
public static void UseAsDerived(Base baseArg)
{
    var d = (Derived) baseArg;

    // ...go on to do something with d
}
```

因此，这种转换不能保证成功——这就是为什么我们不能使用隐式转换。如果在`baseArg`参数引用的对象既不是`Derived`的实例，也不是`Derived`的派生类时尝试这样做，转换将失败，抛出`InvalidCastException`（异常在第 8 章中描述）。

只有当你确信对象确实是你期望的类型时，才适合使用转换。如果对象类型不符合预期，你将认为这是一个错误。当 API 接受一个稍后将返回给你的对象时，这很有用。许多异步 API 会这样做，因为在同时启动多个操作的情况下，当你收到完成通知时，需要一种方法来确定哪个操作已经完成（尽管正如我们将在后面的章节中看到的，有各种方法来解决这个问题）。由于这些 API 不知道你将要关联到操作的数据类型，它们通常只接受`object`类型的引用，当引用最终交还给你时，你通常会使用转换将其转换回所需类型的引用。

有时，你不能确定一个对象是否具有特定类型。在这种情况下，你可以使用`as`运算符，如示例 6-4 所示。这允许你尝试转换而不会引发异常。如果转换失败，该运算符将返回`null`。

##### 示例 6-4\. `as`运算符

```cs
public static void MightUseAsDerived(Base b)
{
    var d = b as Derived;

    if (d != null)
    {
        // ...go on to do something with d
    }
}
```

尽管这种技术在现有代码中非常常见，但在 C# 7.0 中引入的模式提供了一种更简洁的替代方法。示例 6-5 与示例 6-4 具有相同的效果：只有在`b`引用`Derived`的实例时，`if`语句的主体才会执行，并且可以通过变量`d`访问它。此处的`is`关键字表示我们想要对`b`进行模式测试。在这种情况下，我们使用的是声明模式，它执行与`as`运算符相同的运行时类型测试。应用带有`is`的模式的表达式生成一个`bool`，指示模式是否匹配。我们可以将此用作`if`语句的条件表达式，无需与`null`进行比较。由于声明模式包含变量声明和初始化，示例 6-4 中需要两个语句的工作都可以合并到示例 6-5 的`if`语句中。

##### 示例 6-5\. 带有声明模式的`is`运算符

```cs
public static void MightUseAsDerived(Base b)
{
    if (b is Derived d)
    {
        // ...go on to do something with d
    }
}
```

除了更紧凑外，`is`运算符还有一个好处，即在`as`不起作用的一个情况下也可以起作用：您可以测试类型为`object`的引用是否引用值类型的实例，例如`int`。（这可能看起来有些矛盾——您怎么可能有一个指向不是引用类型的东西的引用？第七章将展示这是可能的。）`as`运算符不起作用，因为当实例不是指定类型时它返回`null`，但是当然它不能对值类型执行此操作——没有`int`类型的`null`。由于声明模式消除了对`null`的测试的需要——我们只使用`is`运算符生成的`bool`结果——我们可以自由使用值类型。

###### 提示

偶尔您可能希望检测特定类型是否存在，而无需执行转换。由于`is`可以跟随任何模式，因此您可以使用类型模式，例如，`is Derived`。这执行与声明模式相同的测试，而无需引入新变量。

使用刚才描述的技术进行转换时，不一定需要指定确切的类型。只要对象的真实类型到您要查找的类型之间存在隐式引用转换，这些操作就会成功。例如，假设您有一个类型为`Base`的变量，当前包含对`MoreDerived`实例的引用。显然，您可以将引用转换为`MoreDerived`（对于该类型，`as`和`is`也会成功），但正如您可能期望的那样，转换为`Derived`也可以工作。

这四种机制也适用于接口。当您尝试将引用转换为接口类型的引用（或使用类型模式测试接口类型）时，如果所引用的对象实现了相关接口，则转换将成功。

# 接口继承

接口支持继承，但与类继承并不完全相同。语法类似，但正如示例 6-6 所示，接口可以指定多个基接口。虽然.NET 仅提供单一实现继承，但这种限制不适用于接口，因为大多数可能导致多重继承的复杂性和潜在歧义都不适用于纯抽象类型。最棘手的问题围绕着字段的处理，这意味着即使具有默认实现的接口也支持多重继承，因为这些接口不能向实现类型添加字段或公共成员。（当类使用成员的默认实现时，该成员只能通过接口类型的引用访问。）

##### 示例 6-6\. 接口继承

```cs
interface IBase1
{
    void Base1Method();
}

interface IBase2
{
    void Base2Method();
}

interface IBoth : IBase1, IBase2
{
    void Method3();
}
```

尽管 *接口继承* 是这个特性的官方名称，但这是一个误称——尽管派生类从它们的基类继承所有成员，派生接口却不是这样。看起来它们似乎是这样的——给定类型为 `IBoth` 的变量，你可以调用由其基类定义的 `Base1Method` 和 `Base2Method` 方法。然而，接口继承的真正含义是，实现一个接口的任何类型都有义务实现所有继承的接口。因此，实现 `IBoth` 的类必须同时实现 `IBase1` 和 `IBase2`。这是一个微妙的区别，特别是因为 C# 不要求你显式列出基接口。在 示例 6-7 中的类仅声明它实现了 `IBoth`。然而，如果你使用 .NET 的反射 API 来检查类型定义，你会发现编译器已将 `IBase1` 和 `IBase2` 添加到类实现的接口列表中，以及显式声明的 `IBoth`。

##### 示例 6-7\. 实现一个派生接口

```cs
public class Impl : IBoth
{
    public void Base1Method()
    {
    }

    public void Base2Method()
    {
    }

    public void Method3()
    {
    }
}
```

由于派生接口的实现必须实现所有基接口，C# 允许你通过派生类型的引用直接访问基类的成员，因此类型为 `IBoth` 的变量提供了对 `Base1Method` 和 `Base2Method` 的访问，以及该接口自身的 `Method3`。从派生接口类型到它们的基类存在隐式引用转换。例如，类型为 `IBoth` 的引用可以分配给类型为 `IBase1` 和 `IBase2` 的变量。

# 泛型

如果你从一个泛型类派生，你必须提供它所需的类型参数。如果你的派生类型也是泛型的，你可以选择使用自己的类型参数作为参数，只要它们符合基类定义的任何约束。示例 6-8 展示了这两种技术，并且还说明了当从具有多个类型参数的类派生时，你可以使用混合方法，直接指定一个类型参数，对另一个类型参数则放任不管。

##### 示例 6-8\. 从泛型基类派生

```cs
public class GenericBase1<T>
{
    public T? Item { get; set; }
}

public class GenericBase2<TKey, TValue>
    where TValue : class
{
    public TKey? Key { get; set; }
    public TValue? Value { get; set; }
}

public class NonGenericDerived : GenericBase1<string>
{
}

public class GenericDerived<T> : GenericBase1<T>
{
}

public class MixedDerived<T> : GenericBase2<string, T>
    where T : class
{
}
```

尽管你可以自由地将任何类型参数用作基类的类型参数，但你不能从类型参数派生。如果你习惯于允许这样做的语言，这可能有点令人失望，但是 C# 语言规范明确禁止这样做。然而，你可以使用自己的类型作为基类的类型参数。你还可以为类型参数指定约束，要求它必须从你自己的类型派生。示例 6-9 展示了这些情况。

##### 示例 6-9\. 自引用类型参数

```cs
public class SelfAsTypeArgument : IComparable<SelfAsTypeArgument>
{
    // ...implementation removed for clarity
}

public class Curious<T>
    where T : Curious<T>
{
}
```

## 协变性和逆变性

在 第四章 中，我提到泛型类型有特殊的类型兼容规则，称为 *协变性* 和 *逆变性*。这些规则确定了当类型参数之间存在隐式转换时，某些泛型类型的引用是否可以相互隐式转换。

###### 注：

协变和逆变仅适用于接口和委托的泛型类型参数。（委托在第九章中描述。）你不能定义协变或逆变的类、结构体或记录。

考虑前面示例 6-2 中展示的简单的 `Base` 和 `Derived` 类，并查看接受任何 `Base` 的方法示例 6-10。 （它对它什么都不做，但这里重要的是它的签名说它可以使用什么。）

##### 示例 6-10\. 接受任何 `Base` 的方法

```cs
public static void UseBase(Base b)
{
}
```

我们已经知道，除了接受任何 `Base` 的引用外，这也可以接受任何从 `Base` 派生的类型的实例，比如 `Derived`。考虑一下示例 6-11 中的方法。

##### 示例 6-11\. 接受任何 `IEnumerable<Base>` 的方法

```cs
public static void AllYourBase(IEnumerable<Base> bases)
{
}
```

这需要一个实现了第五章中描述的 `IEnumerable<T>` 泛型接口的对象，其中 `T` 是 `Base`。如果我们尝试传递一个未实现 `IEnumerable<Base>` 但实现了 `IEnumerable<Derived>` 的对象，你认为会发生什么？示例 6-12 就这样做了，并且编译通过。

##### 示例 6-12\. 传递一个派生类型的 `IEnumerable<T>`

```cs
IEnumerable<Derived> derivedItems = new[] { new Derived(), new Derived() };
AllYourBase(derivedItems);
```

从直觉上讲，这是有道理的。`AllYourBase` 方法期望一个能够提供类型为 `Base` 的对象序列的对象。`IEnumerable<Derived>` 符合要求，因为它提供了 `Derived` 对象的序列，而任何 `Derived` 对象也都是 `Base`。但是，关于示例 6-13 中的代码呢？

##### 示例 6-13\. 接受任何 `ICollection<Base>` 的方法

```cs
public static void AddBase(ICollection<Base> bases)
{
    bases.Add(new Base());
}
```

回想一下第五章中提到的 `ICollection<T>` 派生自 `IEnumerable<T>`，并且它添加了以某些方式修改集合的能力。这个特定的方法通过向集合中添加一个新的 `Base` 对象来利用这一点。对于示例 6-14 中的代码来说，这将是个麻烦。

##### 示例 6-14\. 错误：尝试传递一个带有派生类型的 `ICollection<T>`

```cs
ICollection<Derived> derivedList = new List<Derived>();
AddBase(derivedList);  // Will not compile
```

使用 `derivedList` 变量的代码将期望该列表中的每个对象都是 `Derived` 类型（或者从中派生的类型，比如示例 6-2 中的 `MoreDerived` 类）。但是 示例 6-13 中的 `AddBase` 方法尝试添加一个普通的 `Base` 实例。这是不正确的，编译器也不允许这样做。调用 `AddBase` 将产生编译器错误，指出 `ICollection<Derived>` 类型的引用不能隐式转换为 `ICollection<Base>` 类型的引用。

编译器是如何知道这是不允许的，而非常相似的从`IEnumerable<Derived>`到`IEnumerable<Base>`的转换却是允许的？顺便说一句，并不是因为示例 6-13 包含可能引起问题的代码。即使`AddBase`方法完全为空，你仍然会得到相同的编译器错误。之所以在示例 6-12 中没有错误，是因为`IEnumerable<T>`接口将其类型参数`T`声明为协变。你在第五章中看到了这种语法，但我并没有特别强调，因此示例 6-15 再次展示了该接口定义中相关的部分。

##### 示例 6-15\. 协变类型参数

```cs
public interface IEnumerable<out T> : IEnumerable
```

那个`out`关键字完成了任务。（同样，C#延续了 C 家族传统，为每个关键字赋予多种功能——我们首次在方法参数返回信息给调用者的情境中见到此关键字。直观地说，将类型参数`T`描述为`out`是有意义的，因为`IEnumerable<T>`接口只*提供*了`T`—它并不定义任何*接受*`T`的成员。（该接口仅在一个地方使用了这个类型参数：它的只读`Current`属性。

将其与`ICollection<T>`进行比较。这个接口从`IEnumerable<T>`派生，因此显然可以从中获取`T`，但也可以将`T`传递给其`Add`方法。因此，`ICollection<T>`不能使用`out`注释其类型参数。（如果您尝试编写自己的类似接口，如果您声明类型参数为协变，编译器将产生错误。它不仅仅是凭您的话，而是检查确实不能在任何地方传递`T`。）

编译器拒绝示例 6-14 中的代码，因为`ICollection<T>`中的`T`不是协变的。术语*协变*和*逆变*来自数学中的*范畴论*分支。类似`IEnumerable<T>`的`T`行为的参数被称为协变，因为泛型类型的隐式引用转换与类型参数的转换方向相同：`Derived`可以隐式转换为`Base`，并且由于`IEnumerable<T>`中的`T`是协变的，`IEnumerable<Derived>`隐式转换为`IEnumerable<Base>`。

逆变工作方式相反，并且你可能会猜到，我们用`in`关键字表示它。使用类型成员的代码最容易看到它的实际作用，因此示例 6-16 展示了一对稍微有趣的类，比之前的示例稍有不同。

##### 示例 6-16\. 带有实际成员的类层次结构

```cs
public class Shape
{
    public Rect BoundingBox { get; set; }
}

public class RoundedRectangle : Shape
{
    public double CornerRadius { get; set; }
}
```

示例 6-17 定义了两个使用这些形状类型的类。它们都实现了我在第四章中介绍的 `IComparer<T>`。`BoxAreaComparer` 根据其边界框的面积比较两个形状 —— 边界框覆盖面积较大的形状将被认为比较大。另一方面，`CornerSharpnessComparer` 比较圆角矩形，看它们的角有多尖。

##### 示例 6-17\. 比较形状

```cs
public class BoxAreaComparer : IComparer<Shape>
{
    public int Compare(Shape? x, Shape? y)
    {
        if (x is null)
        {
            return y is null ? 0 : -1;
        }
        if (y is null)
        {
            return 1;
        }

        double xArea = x.BoundingBox.Width * x.BoundingBox.Height;
        double yArea = y.BoundingBox.Width * y.BoundingBox.Height;

        return Math.Sign(xArea - yArea);
    }
}

public class CornerSharpnessComparer : IComparer<RoundedRectangle>
{
    public int Compare(RoundedRectangle? x, RoundedRectangle? y)
    {
        if (x is null)
        {
            return y is null ? 0 : -1;
        }
        if (y is null)
        {
            return 1;
        }

        // Smaller corners are sharper, so smaller radius is "greater" for
        // the purpose of this comparison, hence the backward subtraction.
        return Math.Sign(y.CornerRadius - x.CornerRadius);
    }
}
```

`RoundedRectangle` 类型的引用隐式转换为 `Shape`，那么`IComparer<T>`呢？我们的 `BoxAreaComparer` 可以比较任何形状，并通过实现 `IComparer<Shape>` 声明了这一点。比较器的类型参数 `T` 只在 `Compare` 方法中使用，它可以接受任何 `Shape`。如果我们传递一对 `RoundedRectangle` 引用，它也不会感到困惑，因此我们的类完全可以作为 `IComparer<RoundedRectangle>`。因此，从 `IComparer<Shape>` 到 `IComparer<RoundedRectangle>` 的隐式转换是有意义的，并且实际上是允许的。然而，`CornerSharpnessComparer` 更挑剔。它使用 `CornerRadius` 属性，该属性仅在圆角矩形上可用，而不是在任何旧的 `Shape` 上。因此，从 `IComparer<RoundedRectangle>` 到 `IComparer<Shape>` 不存在隐式转换。

这与我们在`IEnumerable<T>`中看到的情况正好相反。当存在从 `T1` 到 `T2` 的隐式引用转换时，`IEnumerable<T1>` 和 `IEnumerable<T2>` 之间可以进行隐式转换。但是在 `IComparer<T>` 和 `IComparer<T2>` 之间的隐式转换则是在另一个方向上存在隐式引用转换：从 `T2` 到 `T1`。这种反向关系称为逆变。示例 6-18 是 `IComparer<T>` 的定义摘录，显示了这种逆变类型参数。

##### 示例 6-18\. 逆变类型参数

```cs
public interface IComparer<in T>
```

大多数泛型类型参数既不是协变也不是逆变（它们是*不变*的）。`ICollection<T>` 不能是变体，因为它包含一些接受 `T` 的成员和一些返回 `T` 的成员。`ICollection<Shape>` 可能包含不是 `RoundedRectangles` 的形状，所以你不能将它传递给一个期望 `ICollection<RoundedRectangle>` 的方法，因为这样的方法会期望从集合检索到的每个对象都是圆角矩形。相反，`ICollection<RoundedRectangle>` 不能期望允许添加除了圆角矩形之外的形状，所以你不能将 `ICollection<RoundedRectangle>` 传递给一个期望 `ICollection<Shape>` 的方法，因为该方法可能尝试添加其他类型的形状。

数组是协变的，就像`IEnumerable<T>`一样。这很奇怪，因为我们可以编写像示例 6-19 中的方法一样。

##### 示例 6-19\. 修改数组中的元素

```cs
public static void UseBaseArray(Base[] bases)
{
    bases[0] = new Base();
}
```

如果我试图使用 Example 6-20 中的代码调用此方法，我将犯与 Example 6-14 相同的错误，那里我试图将`ICollection<Derived>`传递给一个试图将不是`Derived`的东西放入集合中的方法。但是，虽然 Example 6-14 不能编译，Example 6-20 却可以，这归因于数组的令人惊讶的协变性。

##### Example 6-20\. 传递一个具有派生元素类型的数组

```cs
Derived[] derivedBases = { new Derived(), new Derived() };
UseBaseArray(derivedBases);
```

这使得看起来我们可以偷偷地让这个数组接受一个不是数组元素类型实例的引用——在这种情况下，将一个`Base`的引用放入`Derived[]`中。但这将违反类型系统。这是否意味着天要塌下来了？

实际上，C#正确禁止这种违规行为，但依赖 CLR 在运行时执行此操作。尽管类型为`Derived[]`的数组的引用可以隐式转换为类型为`Base[]`的引用，但任何试图将不符合类型系统的数组元素设置的尝试都会抛出`ArrayTypeMismatchException`异常。因此，当试图将一个`Base`的引用分配给`Derived[]`数组时，Example 6-19 会抛出该异常。

运行时检查确保了类型安全的维护，并且这使得一个便利特性得以实现。如果我们编写一个仅从数组中读取的方法，我们可以传递一些派生元素类型的数组。但缺点是 CLR 在运行时需要额外工作，当修改数组元素时，以确保没有类型不匹配。它可以优化代码以避免每次赋值都进行检查，但仍然会有一些开销，这意味着数组并不像可能的那么高效。

这种有些奇特的安排可以追溯到.NET 在正式化协变和逆变的概念之前的时期——这些概念是随着泛型引入.NET 2.0 而引入的。也许如果从一开始就有泛型，数组将不会如此奇怪，尽管说了这些，即使在.NET 2.0 之后，它们特有的协变形式多年来仍是框架中唯一内建的通过索引读取集合协变传递到方法的机制。直到.NET 4.5 引入了`IReadOnlyList<T>`（其中`T`是协变的），框架中才有只读索引集合接口，因此没有带有协变类型参数的标准索引集合接口（`IList<T>`是读/写的，因此像`ICollection<T>`一样，它不能提供协变）。

在我们讨论类型兼容性和继承带来的隐式引用转换时，还有一个类型需要我们关注：`object`。

# System.Object

在 C#中，`System.Object`类型，或者我们通常称之为`object`，非常有用，因为它可以充当一种通用容器：这种类型的变量可以持有几乎任何东西的引用。我之前提到过这一点，但我还没有解释为什么它是真的。这能行得通的原因是几乎所有东西都从`object`派生。

当你在编写一个类或记录时没有指定基类时，C# 编译器会自动将`object`作为基类。稍后我们会看到，对于某些类型，如结构体，它会选择不同的基类，但即使这些类型间接地从`object`派生。（作为例外，指针类型是一个例外——它们不从`object`派生。）

接口和对象之间的关系稍微复杂一些。接口不从`object`派生，因为接口只能指定其他接口作为其基类。然而，任何接口类型的引用都可以隐式转换为`object`类型的引用。这种转换总是有效的，因为能够实现接口的所有类型最终都从`object`派生。此外，即使严格来说，这些方法并不是接口的成员，C# 选择通过接口引用使`object`类的成员可用。这意味着任何类型的引用始终提供了由`object`定义的以下方法：`ToString`、`Equals`、`GetHashCode` 和 `GetType`。

## **System.Object 的普遍方法**

我已经在几个例子中使用了`ToString`。默认实现返回对象的类型名称，但许多类型提供了它们自己的`ToString`实现，返回对象当前值的更有用的文本表示。例如，数值类型返回其值的十进制表示，而`bool`返回`"True"`或`"False"`。

我在 第三章 中讨论了 `Equals` 和 `GetHashCode` 方法，但我会在这里简要回顾一下。`Equals` 允许将一个对象与任何其他对象进行比较。默认实现只执行标识比较，即只有当对象与自身比较时返回 `true`。许多类型提供了一个 `Equals` 方法，执行类似值的比较——例如，两个不同的 `string` 对象可能包含相同的文本，这种情况下它们将报告彼此相等。（如果需要对提供值比较的对象执行基于标识的比较，可以使用 `object` 类的静态 `ReferenceEquals` 方法。）顺便说一句，`object` 还定义了一个接受两个参数的静态版本的 `Equals` 方法。这检查参数是否为 `null`，如果两个参数都为 `null` 则返回 `true`，如果只有一个参数为 `null` 则返回 `false`；否则，它将委托给第一个参数的 `Equals` 方法。正如在 第三章 中讨论的那样，`GetHashCode` 返回一个整数，它是对象值的简化表示，被哈希机制（例如 `Dictionary<TKey, TValue>` 集合类）使用。任何两个 `Equals` 返回 `true` 的对象必须返回相同的哈希码。

`GetType` 方法提供了一种发现对象类型信息的方式。它返回一个 `Type` 类型的引用。这是反射 API 的一部分，是 第十三章 的主题。

除了这些可以通过任何引用访问的公共成员外，`object` 还定义了另外两个不是普遍可访问的成员。对象只能在自身上访问这些成员。它们是 `Finalize` 和 `MemberwiseClone`。CLR 调用 `Finalize` 方法来通知你的对象不再使用，并且它占用的内存即将被回收。在 C# 中，我们通常不直接使用 `Finalize` 方法，因为 C# 通过析构函数（我将在 第七章 中展示）来呈现这一机制。`MemberwiseClone` 创建一个与你的对象相同类型的新实例，其初始化为你的对象所有字段的副本。如果需要一种方式来创建对象的克隆，这可能比手动复制所有内容的代码更简单，尽管它不是非常快速。

最后两个方法之所以只能从对象内部访问，是因为你可能不希望其他人克隆你的对象，而且如果外部代码能调用 `Finalize` 方法，让你的对象误以为即将释放内存，这将毫无帮助。`object` 类限制了这些成员的可访问性。但它们不是私有的——这意味着只有 `object` 类本身才能访问它们，因为私有成员甚至对派生类也不可见。相反，`object` 将这些成员设置为 *protected*，这是为继承场景设计的访问限定符。

# 访问权限和继承

到目前为止，你应该已经熟悉了大多数可用于类型及其成员的访问级别。标记为 `public` 的元素对所有人可见，`private` 成员仅能从声明它们的类型内部访问，而 `internal` 成员对同一组件中定义的代码可见。¹ 但是通过继承，我们还可以获得其他三种访问权限选项。

以 `protected` 标记的成员在定义它的类型内部和任何派生类型内部都可用。但是对于使用你的类型实例的代码而言，`protected` 成员是不可访问的，就像 `private` 成员一样。

类型成员的下一个保护级别是 `protected internal`。（如果你喜欢，也可以写成 `internal protected`；顺序没有影响。）这使得成员比单独的 `protected` 或 `internal` 更容易访问：成员将对所有派生类型和共享同一个程序集的所有代码可见。

继承增加的第三个保护级别是 `protected private`。使用此标记的成员（或等效的 `private protected`）仅对从定义类型派生且位于同一组件中的类型可用。

你可以使用 `protected`、`protected internal` 或 `protected private` 来修饰类型的任何成员，而不仅仅是方法。你甚至可以使用这些访问权限修饰符来定义嵌套类型。

尽管 `protected` 和 `protected internal`（尽管不包括 `protected private`）成员不能通过定义类型的普通变量访问，它们仍然是类型公共 API 的一部分，这意味着任何有权访问你的类的人都能够使用这些成员。与大多数支持类似机制的语言一样，C# 中的 `protected` 成员通常用于提供派生类可能找到有用的服务。如果你编写了一个支持继承的 `public` 类，那么任何人都可以从它派生，并且能够访问其 `protected` 成员。因此，删除或更改 `protected` 成员会像删除或更改 `public` 成员一样，可能会破坏依赖于你的类的代码。

当你从一个类派生时，不能使你的类比其基类更可见。例如，如果你从一个 `internal` 类派生，你不能将你的类声明为 `public`。你的基类形成了你的类 API 的一部分，因此任何希望使用你的类的人实际上也在使用其基类；这意味着如果基类不可访问，你的类也将不可访问，这就是为什么 C# 不允许一个类比其基类更可见的原因。如果你从一个 `protected` 的嵌套类派生，你的派生类可以是 `protected`、`private` 或 `protected private`，但不能是 `public`、`internal` 或 `protected internal`。

###### 注

这个限制不适用于你实现的接口。`public`类可以自由实现`internal`或`private`接口。但是，它适用于接口的基接口：`public`接口不能从`internal`接口派生。

在定义方法时，还有另一个关键字可以为派生类型增加效果：`virtual`。

# 虚拟方法

*虚方法*是派生类型可以替换的方法。`object`定义的几种方法都是虚拟的：`ToString`、`Equals`、`GetHashCode`和`Finalize`方法都被设计为可替换的。用于生成对象值的有用文本表示所需的代码会因类型不同而大不相同，判断相等性和生成哈希码所需的逻辑也会不同。类型通常仅在需要在其不再使用时执行一些专门的清理工作时定义终结器。

并非所有方法都是虚方法。事实上，C#默认情况下使方法为非虚方法。`object`类的`GetType`方法不是虚方法，因此您可以始终信任它返回的信息，因为您知道您调用的是.NET 提供的`GetType`方法，而不是某种特定类型的替代品，旨在愚弄您。要声明方法应为虚方法，请使用`virtual`关键字，如示例 6-21 所示。

##### 示例 6-21\. 带有虚方法的类

```cs
public class BaseWithVirtual
{
    `public` `virtual` `void` `ShowMessage``(``)`
    {
        Console.WriteLine("Hello from BaseWithVirtual");
    }
}
```

###### 注意

你也可以将`virtual`关键字应用于属性。属性在底层只是方法，因此这会使访问器方法变为虚方法。事件也是如此，这在第 9 章中有讨论。

调用虚方法的语法并无特殊之处。如示例 6-22 所示，它看起来就像调用任何其他方法一样。

##### 示例 6-22\. 使用虚方法

```cs
public static void CallVirtualMethod(BaseWithVirtual o)
{
    o.ShowMessage();
}
```

虚方法调用与非虚方法调用的区别在于，虚方法调用会在运行时决定调用哪个方法。在示例 6-22 中的代码实际上会检查传入的对象，如果对象的类型提供了自己的`ShowMessage`实现，那么会调用那个实现，而不是在`BaseWithVirtual`中定义的实现。方法的选择基于目标对象在运行时的实际类型，而不是在编译时确定的表达式的静态类型。

###### 注意

由于虚方法调用是基于调用方法的对象的类型选择方法，静态方法不能是虚方法。

派生类型不必替换虚方法。示例 6-23 展示了两个从示例 6-21 派生的类。第一个保留了基类对`ShowMessage`的实现。第二个对其进行了重写。请注意`override`关键字——C#要求我们明确声明我们打算重写虚方法。

##### 示例 6-23\. 重写虚方法

```cs
public class DeriveWithoutOverride : BaseWithVirtual
{
}

public class DeriveAndOverride : BaseWithVirtual
{
    public override void ShowMessage()
    {
        Console.WriteLine("This is an override");
    }
}
```

我们可以将这些类型与示例 6-22 中的方法一起使用。示例 6-24 调用它三次，每次传入不同类型的对象。

##### 示例 6-24\. 利用虚方法

```cs
CallVirtualMethod(new BaseWithVirtual());
CallVirtualMethod(new DeriveWithoutOverride());
CallVirtualMethod(new DeriveAndOverride());
```

这产生了以下输出：

```cs
Hello from BaseWithVirtual
Hello from BaseWithVirtual
This is an override
```

显然，当我们传递基类的实例时，我们会得到基类的`ShowMessage`方法的输出。对于未提供重写的派生类，我们也会得到相同的输出。只有最终重写了该方法的类才会产生不同的输出。这表明虚方法提供了编写多态代码的一种方式：示例 6-22 可以使用多种类型。

当重写一个方法时，方法名和其参数类型必须完全匹配。在大多数情况下，返回类型也会相同，但并非总是如此。如果`virtual`方法的返回类型不是`void`，并且不是`ref`返回，则重写方法的返回类型可以不同，只要存在从该类型到`virtual`方法返回类型的隐式引用转换。简而言之，重写方法允许在返回类型上更为具体。这意味着像示例 6-25 这样的例子是合法的。

##### 示例 6-25\. 缩小返回类型的重写

```cs
public class Product { }
public class Book : Product { }

public class ProductSourceBase
{
    public virtual Product Get() { return new Product(); }
}

public class BookSource : ProductSourceBase
{
    public override Book Get() { return new Book(); }
}
```

注意，`Get`的重写的返回类型是`Book`，即使它重写的`virtual`方法返回`Product`也是如此。这是可以接受的，因为通过`ProductSourceBase`类型的引用调用此方法的任何东西都将期望得到一个`Product`类型的引用，并且由于继承关系，`Book`是`Product`的一种。因此，`ProductSourceBase`类型的用户将不会察觉到或受到此更改的影响。在直接处理派生类型的代码需要知道将返回的具体类型的情况下，此功能有时会很有用。

也许你会想知道为什么我们需要虚方法，考虑到接口也能实现多态代码。在 C# 8.0 之前，虚方法相对于接口的一个主要优势是，基类可以提供一个默认实现，派生类将默认获取这个实现，并仅在真正需要不同实现时提供自己的实现。语言中添加默认接口实现的功能意味着接口现在也可以做到这一点，尽管默认接口成员实现不能定义或访问非静态字段，因此与定义虚函数的类相比受到一定限制。 （由于默认接口实现需要运行时支持，对于需要在.NET Framework 上运行的代码是不可用的，这包括任何目标为.NET Standard 2.0 或更早版本的库。）但是，虚方法还有一个更微妙的优势，但在我们能够看到它之前，我们需要探索虚方法的一个特性，即乍一看更像接口工作方式的东西。

## 抽象方法

你可以定义一个虚方法而不提供默认实现。在 C#中，这称为*抽象方法*。如果一个类包含一个或多个抽象方法，则该类是不完整的，因为它未提供所有定义的方法。这种类也被描述为抽象类，无法创建抽象类的实例；尝试使用`new`运算符与抽象类将导致编译器错误。有时在讨论类时，明确某个特定类*不是*抽象类是有用的，我们通常使用术语*具体类*。

如果你从抽象类派生，那么除非你为所有抽象方法提供实现，否则你的派生类也将是抽象的。你必须使用`abstract`关键字声明你要写的抽象类；如果一个类有未实现的抽象方法（无论是自己定义的还是继承的），而没有使用`abstract`关键字声明为抽象类，C#编译器将报错。示例 6-26 展示了定义单个抽象方法的抽象类。抽象方法在定义上是虚的；如果没有办法让派生类提供方法体，定义一个没有方法体的方法也就没有多大用处。

##### 示例 6-26\. 一个抽象类

```cs
public abstract class AbstractBase
{
    public abstract void ShowMessage();
}
```

抽象方法声明只定义了签名，不包含方法体。与接口不同的是，每个抽象成员都有自己的可访问性——可以将抽象方法声明为`public`、`internal`、`protected internal`、`protected private`或`protected`。（将抽象或虚方法声明为`private`没有意义，因为该方法对派生类型是不可访问的，因此无法重写。）

###### 注意

虽然包含抽象方法的类必须是抽象的，但反之并非如此。尽管不寻常，将一个本来可以作为具体类的类定义为抽象是合法的。这样可以防止该类被实例化。从这种类派生的类将是具体类，而无需重写任何抽象方法。

抽象类有选择地声明它们实现接口，而无需提供完整的实现。但是，不能只省略未实现的成员。您必须显式声明其所有成员，并将您希望保留未实现的任何成员标记为抽象，就像示例 6-27 所示的那样。这迫使具体派生类型提供实现。

##### 示例 6-27. 抽象接口实现

```cs
public abstract class MustBeComparable : IComparable<string>
{
    public abstract int CompareTo(string? other);
}
```

抽象类和接口之间显然存在一些重叠。两者都提供了一种定义抽象类型的方式，使得代码在运行时无需知道确切的类型即可使用。每种选项都有其利弊。接口的优势在于单个类型可以实现多个接口，而类只能指定一个基类。但是抽象类可以定义字段，并且可以在其提供的任何默认成员实现中使用这些字段，并且它们还提供了一种在.NET Framework 上提供默认实现的方式。然而，在发布多个版本的库时，虚方法可以发挥出更为微妙的优势。

## 继承和库版本控制

想象一下，如果您编写并发布了一个定义了一些公共接口和抽象类的库，并且在该库的第二个版本中，您决定向其中一个接口添加一些新成员，会发生什么情况。这可能对使用您的代码的客户不会造成问题。当然，他们在使用接口类型的引用的任何地方都不会受到新功能添加的影响。但是，如果您的某些客户已编写了实现您接口的类型，会怎么样呢？例如，假设在未来的.NET 版本中，Microsoft 决定向`IEnumerable<T>`接口添加一个新成员。

如果接口不为新成员提供默认实现，那将是一场灾难。这个接口被广泛使用，但也被广泛实现。已经实现`IEnumerable<T>`的类将变得无效，因为它们不会提供这个新成员，因此旧代码将无法编译，已经编译的代码将在运行时抛出`MissingMethodException`错误。C# 对接口中的默认成员实现的支持可以减轻这一问题：如果微软确实向`IEnumerable<T>`添加了新成员，它可以提供一个默认实现以防止这些错误。这对于使用 .NET Framework 的人没有帮助，因为它不支持这个功能，但对于较新的运行时环境，这使得修改现有接口定义似乎是可行的。然而，还有一个更微妙的问题。一些类可能碰巧已经具有与新添加方法相同名称和签名的成员。如果该代码针对新的接口定义重新编译，编译器将将该现有成员视为接口实现的一部分，即使编写该方法的开发人员并没有这样的意图。因此，除非现有代码碰巧确实执行了新成员所需的操作，否则我们将遇到问题，并且我们不会收到编译器错误或警告来提醒我们。

因此，广泛接受的规则是一旦接口发布后就不要更改接口。如果您完全控制使用和实现接口的所有代码，那么您可以修改接口，因为您可以对受影响的代码进行任何必要的修改。但一旦接口可用于您无法控制的代码库中——也就是说，一旦它被发布——就不可能在不冒破坏其他人代码风险的情况下更改它。默认接口实现可以减轻这种风险，但它们无法消除现有方法在重新编译时被错误解释的问题。

抽象基类不必遭受这个问题的困扰。显然，引入新的抽象成员将导致完全相同的`MissingMethodException`失败，但引入新的虚拟方法则不会。（而且自从 C# v1 开始就有虚拟方法，这使您可以针对 .NET Framework，其中不支持默认接口实现支持。）

但是，如果在发布版本 1.0 的组件之后，在版本 1.1 中添加了一个新的虚拟方法，结果发现该方法与某个客户恰好在派生类中添加的方法具有相同的名称和签名呢？也许在版本 1.0 中，您的组件定义了示例 Example 6-28 中显示的相当无趣的基类。

##### 示例 6-28\. 基类版本 1.0

```cs
public class LibraryBase
{
}
```

如果您发布此库，可能会在[NuGet 软件包管理网站](https://nuget.org)上，或作为应用程序的某个软件开发工具包（SDK）的一部分。客户可能会编写一个派生类型，比如示例 6-29 中的一个。他们编写的`Start`方法显然不意图覆盖基类中的任何内容。

##### 示例 6-29\. 从版本 1.0 基础派生的类

```cs
public class CustomerDerived : LibraryBase
{
    public void Start()
    {
        Console.WriteLine("Derived type's Start method");
    }
}
```

由于您可能无法看到客户编写的每一行代码，因此您可能不知道这个`Start`方法。因此，在您组件的 1.1 版本中，您可能决定添加一个新的虚方法，也叫做`Start`，正如示例 6-30 所示。

##### 示例 6-30\. 基础类型版本 1.1

```cs
public class LibraryBase
{
    public virtual void Start() { }
}
```

想象一下，您的系统作为引入 v1.1 版本初始化过程的一部分调用了这个方法。您定义了一个默认的空实现，这样从`LibraryBase`派生的类型如果不需要参与该过程，则无需执行任何操作。希望参与的类型将覆盖此方法。但是在示例 6-29 中的类会发生什么呢？显然，编写此代码的开发人员并不打算参与您的新初始化机制，因为在编写代码时它并不存在。如果您的代码调用了`CustomerDerived`类的`Start`方法，则可能会出现问题，因为开发人员可能期望仅在他们的代码决定调用时才调用它。幸运的是，编译器会检测到此问题。如果客户尝试使用版本 1.1 的库编译示例 6-29，编译器会警告他们存在某些问题：

```cs
warning CS0114: 'CustomerDerived.Start()' hides inherited member
'LibraryBase.Start()'. To make the current member override that implementation,
add the override keyword. Otherwise add the new keyword.
```

这就是为什么当我们替换虚拟方法时，C#编译器要求使用`override`关键字的原因。它想知道我们是否打算覆盖现有的方法，以便如果我们没有打算这样做，它可以警告我们可能出现的命名冲突。（没有任何等效的关键字表示意图实现接口成员，这也是编译器无法检测到默认接口实现问题的原因。而这种缺失的原因是在 C# 8.0 之前不存在默认接口实现。）

我们得到了一个警告而不是错误，因为编译器在这种由于库的新版本发布而产生的情况下提供了一个可能是安全的行为。编译器推测——在这种情况下是正确的——编写`CustomerDerived`类型的开发人员并不打算覆盖`LibraryBase`类的`Start`方法。因此，与其让`CustomerDerived`类型的`Start`方法覆盖基类的虚方法，它*隐藏*了它。当派生类型引入一个与基类同名的新成员时，称为派生类型隐藏基类成员。

隐藏方法与重写方法有很大不同。当发生隐藏时，基础方法不会被替换。示例 6-31 展示了如何保留隐藏的`Start`方法。它创建了一个`CustomerDerived`对象，并将该对象的引用放入两个不同类型的变量中：一个是`CustomerDerived`类型，另一个是`LibraryBase`类型。然后通过每个变量分别调用`Start`方法。

##### 示例 6-31\. 隐藏与虚方法

```cs
var d = new CustomerDerived();
LibraryBase b = d;

d.Start();
b.Start();
```

当我们使用变量`d`时，调用`Start`方法实际上调用了派生类型的`Start`方法，即隐藏了基类成员的方法。但变量`b`的类型是`LibraryBase`，所以会调用基类的`Start`方法。如果`CustomerDerived`类重写了基类的`Start`方法而不是隐藏它，那么这两个方法调用都会调用重写的方法。

当由于新库版本而发生名称冲突时，通常隐藏行为是正确的做法。如果客户代码有一个`CustomerDerived`类型的变量，则该代码将希望调用特定于该派生类型的`Start`方法。然而，编译器会产生警告，因为它不能确定这是否是问题的原因。可能是你确实想要重写方法，只是忘记写`override`关键字了。

像许多开发人员一样，我不喜欢看到编译器警告，并且尽量避免提交产生警告的代码。但是如果新的库版本让你处于这种情况下，你应该怎么办？最好的长期解决方案可能是在派生类中更改方法的名称，以避免与新版本库中的方法冲突。然而，如果你面临截止日期，可能需要一个更快的解决方案。因此，C#允许您声明您知道存在名称冲突，并且您绝对想要隐藏基类成员，而不是重写它。正如示例 6-32 所示，您可以使用`new`关键字声明您已经意识到这个问题，并且绝对要隐藏基类成员。代码仍将以相同的方式工作，但您将不再收到警告，因为您已向编译器保证您知道发生了什么。但这是您应该在某个时候解决的问题，因为 sooner or later，在同一类型上存在两个意义不同但名称相同的方法很可能会导致混淆。

##### 示例 6-32\. 隐藏成员时避免警告

```cs
public class CustomerDerived : LibraryBase
{
    `public` `new` `void` `Start``(``)`
    {
        Console.WriteLine("Derived type's Start method");
    }
}
```

###### 注意

C#不允许你使用`new`关键字来处理默认接口实现带来的等价问题。没有办法保留接口提供的默认实现并声明具有相同签名的公共方法。这稍微让人沮丧，因为在二进制级别是可能的：如果在添加新成员并未重新编译实现接口的代码时，这就是你会得到的行为。你仍然可以拥有`ILibrary.Start`和`CustomerDerived.Start`的单独实现，但必须使用显式接口实现。

偶尔你可能会看到`new`关键字以这种方式使用，而不是处理库版本问题。例如，我在第五章中展示的`ISet<T>`接口使用它来引入一个新的`Add`方法。`ISet<T>`派生自`ICollection<T>`，一个已经提供了接受`T`实例并具有`void`返回类型的`Add`方法的接口。`ISet<T>`对此进行了微妙的更改，如示例 6-33 所示。

##### 示例 6-33\. 隐藏以更改签名

```cs
public interface ISet<T> : ICollection<T>
{
    new bool Add(T item);
    // ...other members omitted for clarity
}
```

`ISet<T>`接口的`Add`方法告诉你刚刚添加的项目是否已经存在于集合中，而基本的`ICollection<T>`接口的`Add`方法不支持这一点。`ISet<T>`需要其`Add`方法具有不同的返回类型——`bool`而不是`void`——因此它使用`new`关键字来隐藏`ICollection<T>`的方法。这两种方法仍然可用——如果你有两个变量，一个类型为`ICollection<T>`，另一个类型为`ISet<T>`，两者都引用同一个对象，你将能够通过前者访问`void Add`，通过后者访问`bool Add`。

微软本可以不这样做。它本可以将新的`Add`方法命名为其他名称，比如`AddIfNotPresent`。但只有一个方法名称用于向集合中添加事物可能会更少引起混淆，尤其是当你可以忽略返回值时，此时新的`Add`看起来与旧的`Add`无法区分。而大多数`ISet<T>`实现将通过直接调用`ISet<T>.Add`方法来实现`ICollection<T>.​Add`方法，因此它们具有相同的名称是有道理的。

除了上述示例之外，到目前为止，我只讨论了在编译旧代码以针对新版本库的情况下进行方法隐藏。如果您有已经编译但最终在新版本下运行的旧代码呢？当涉及的库是.NET 运行时库时，这是一个您极有可能遇到的情景。假设您正在使用第三方组件，这些组件只有二进制形式（例如，您从不提供源代码的公司购买了许可的组件）。供应商将这些组件构建为使用某个特定版本的.NET。如果您升级应用程序以与新版本的.NET 一起运行，您可能无法获取到更新的第三方组件版本——也许供应商尚未发布它们，或者可能已经停业。

如果您使用的组件是为.NET Standard 1.2 编译的，而您将它们用于为.NET 6.0 构建的项目中，所有这些旧组件将最终使用.NET 6.0 版本的运行时库。.NET 有一个版本策略，确保特定程序使用的所有组件都使用相同版本的运行时库，而不管每个组件可能是为哪个版本构建的。因此，完全有可能某些组件，如*OldControls.dll*，包含从.NET Standard 1.2 派生的类，并定义与.NET 6.0 中新增成员名称相冲突的成员。

这基本上与我之前描述的情景相同，只是针对旧版本库编写的代码不会重新编译。我们不会收到关于隐藏方法的编译器警告，因为那需要运行编译器，而我们只有相关组件的二进制文件。现在会发生什么呢？

幸运的是，我们不需要重新编译旧组件。C#编译器会为每个编译的方法设置各种标志，指示诸如方法是否虚拟，方法是否打算覆盖基类中的某个方法等内容。当您在方法上放置`new`关键字时，编译器会设置一个标志，指示该方法不打算覆盖任何东西。CLR 将其称为*newslot*标志。当 C#编译一个像示例 6-29 中的方法时，该方法既不指定`override`也不指定`new`，编译器也会为该方法设置相同的 newslot 标志，因为在编译该方法时，基类上没有同名方法。对于开发人员和编译器而言，`CustomerDerived`类的`Start`方法就像是一个全新的方法，与基类上的任何内容都没有关联。

当旧组件与定义基类的新版本库一起加载时，CLR 可以看到作者在 `CustomerDerived` 类中的意图——即使没有重新编译，CLR 也可以看到作者认为 `Start` 并不意味着要覆盖任何东西。因此，它将 `CustomerDerived.Start` 视为与 `LibraryBase.Start` 不同的方法——就像我们重新编译时一样隐藏基础方法。

顺便说一句，我提到的关于虚方法的一切也适用于属性，因为属性的访问器只是方法。因此，您可以定义虚属性，并且派生类可以以与方法完全相同的方式重写或隐藏这些属性。在 第九章 中我不会讲事件，但它们也是方法的一种形式，所以它们也可以是虚的。

偶尔，您可能希望编写一个类来重写虚方法，然后阻止派生类再次重写它。对此，C# 定义了 `sealed` 关键字，事实上，不仅仅是方法可以被标记为 sealed。

# Sealed Methods and Classes

虚方法故意通过继承来修改。而 sealed 方法则是相反的——它是一个不可重写的方法。在 C# 中，默认情况下方法是 sealed 的：方法不能被重写，除非声明为 virtual。但是当您重写虚方法时，可以使用 sealed 关键字将其封闭，阻止进一步修改。示例 6-34 使用这种技术提供了一个自定义的 `ToString` 实现，不能被派生类进一步重写。

##### 示例 6-34\. 一个 sealed 方法

```cs
public class FixedToString
{
    public sealed override string ToString() => "Arf arf!";
}
```

您还可以封闭整个类，防止任何人从中派生。示例 6-35 展示了一个不仅仅是什么都不做，还防止任何人扩展它以做一些有用事情的类。（通常您只会封闭做某些事情的类。这个例子只是为了说明关键字的使用位置。）

##### 示例 6-35\. 一个 sealed 类

```cs
public sealed class EndOfTheLine
{
}
```

一些类型本质上是 sealed 的。例如，值类型不支持继承，因此结构体、记录结构体和枚举实际上是 sealed。内置的 `string` 类也是 sealed 的。

密封类或方法通常有两个正常的原因。一是你希望保证某个特定不变量，如果你将类型开放以进行修改，将无法保证该不变量。例如，`string`类型的实例是不可变的。`string`类型本身不提供修改实例值的方法，因此由于无法从`string`派生，你可以保证如果你有一个`string`类型的引用，你就拥有一个不可变对象的引用。这使得在你不希望值改变的场景中使用它变得安全——例如，当你将对象作为字典的键（或任何依赖哈希码的其他东西）时，你需要值不变，因为如果在项目作为键使用时哈希码发生变化，容器将发生故障。

留下事物密封的另一个通常原因是，设计能够通过继承成功修改的类型很难，特别是如果你的类型将在你自己组织之外使用。简单地打开事物以进行修改是不够的——如果你决定使所有方法都虚拟化，这可能会使使用你的类型的人修改其行为变得容易，但当你维护基类时，你将会给自己找麻烦。除非你控制所有从你的类派生的代码，否则几乎不可能更改基类中的任何内容，因为你永远不会知道哪些方法可能已在派生类中被覆盖，这使得难以确保你类的内部状态始终一致。编写派生类型的开发人员无疑会尽力避免破坏事物，但他们将不可避免地依赖于未记录的你类行为的某些方面。因此，在通过继承开放你类的每个方面以供修改时，你剥夺了自己改变类的自由。

对于哪些方法（如果有的话）你应该非常谨慎地选择使其虚拟化。你还应该记录调用者是否允许完全替换方法，或者是否要求调用基本实现作为其覆盖的一部分。说到这一点，你该如何做到呢？

# 访问基类成员

在基类中范围内的所有内容，只要不是私有的，也将在派生类型中范围内，并且可访问。如果你想访问基类的某个成员，通常只需像访问自己类的普通成员一样访问即可。你可以通过`this`引用访问成员，或者直接按名称访问，而无需限定符。

然而，有些情况下你需要明确表示你打算引用基类成员。特别是，如果你重写了一个方法，用名称调用该方法将递归调用你的重写。如果你想调用原始的你重写的方法，有一个特殊的关键字用于这个，如 Example 6-36 中所示。

##### Example 6-36\. 覆盖后调用基类方法

```cs
public class CustomerDerived : LibraryBase
{
    public override void Start()
    {
        Console.WriteLine("Derived type's Start method");
        `base``.``Start``(``)``;`
    }
}
```

使用`base`关键字，我们选择了不使用正常的虚方法分发机制。如果我们只写了`Start()`，那将是一个递归调用，在这里是不希望的。通过写`base.Start()`，我们获得了在基类实例上可用的方法，也就是我们重写的方法。

如果继承链更深呢？假设`CustomerDerived`派生自`IntermediateBase`，而`IntermediateBase`又派生自`LibraryBase`并重写了`Start`方法。在这种情况下，在我们的`Cus⁠tom⁠er​Der⁠iv⁠ed`类型中写`base.Start()`将调用`IntermediateBase`定义的重写。没有办法绕过这一点直接调用原始的`LibraryBase.Start`。

在这个例子中，我在完成我的工作后调用了基类的实现。C#并不关心你什么时候调用基类——你可以在方法开始时调用它，在最后调用它，或者在方法中间的任何地方调用它。你甚至可以多次调用它，或者根本不调用它。调用基类方法的时间由基类的作者来决定，他需要文档化方法的重写是否应该调用基类实现。

你也可以对其他成员使用`base`关键字，如属性和事件。但是，对基类构造函数的访问方式略有不同。

# 继承和构造

尽管派生类继承了其基类的所有成员，但这对构造函数的意义与其他所有成员并不相同。对于其他成员，如果它们在基类中是公共的，它们也将成为派生类的公共成员，可供任何使用你的派生类的人访问。但构造函数是特殊的，因为使用你的类的人无法通过使用基类定义的构造函数来构造它。

这有一个很简单的原因：如果你想要一个某种类型`D`的实例，那么你会希望它是一个完整的`D`，包含了所有适当初始化的内容。假设`D`派生自`B`。如果你能直接使用`B`的其中一个构造函数，它将不会对`D`特有的部分进行任何操作。基类的构造函数不会知道任何由派生类定义的字段，因此无法对其进行初始化。如果你想要一个`D`，你只能使用知道如何初始化`D`的构造函数。因此，对于派生类，你只能使用由该派生类提供的构造函数，不管基类提供了哪些构造函数。

在本章中我展示的示例中，我之所以能忽略这一点，是因为 C#提供的默认构造函数。如你在第三章中看到的，如果你不写一个构造函数，C#会为你写一个不带参数的构造函数。对于派生类也是如此，生成的构造函数将调用基类的无参数构造函数。但是如果我开始编写自己的构造函数，情况就会改变。示例 6-37 定义了一对类，其中基类定义了一个显式的无参数构造函数，派生类定义了一个需要参数的构造函数。

##### 示例 6-37\. 派生类中没有默认构造函数

```cs
public class BaseWithZeroArgCtor
{
    public BaseWithZeroArgCtor()
    {
        Console.WriteLine("Base constructor");
    }
}

public class DerivedNoDefaultCtor : BaseWithZeroArgCtor
{
    public DerivedNoDefaultCtor(int i)
    {
        Console.WriteLine("Derived constructor");
    }
}
```

因为基类有一个零参数构造函数，我可以用`new BaseWithZeroArgCtor()`来构造它。但是对于派生类型，我不能这样做：我只能通过传递一个参数来构造它——例如，`new DerivedNoDefaultCtor(123)`。因此，就`DerivedNoDefaultCtor`的公开可见 API 而言，派生类似乎没有继承其基类的构造函数。

然而，实际上它确实已经继承了它，你可以通过构造派生类型的实例来看到得到的输出：

```cs
Base constructor
Derived constructor
```

在构造`DerivedNoDefaultCtor`的实例时，基类的构造函数会立即在派生类的构造函数之前运行。由于基类构造函数已运行，显然它是存在的。所有基类的构造函数都对派生类型可用，但只能由派生类中的构造函数调用。示例 6-37 隐式调用了基类构造函数：所有构造函数都要求在其基类上调用一个构造函数，如果你没有指定调用哪一个，编译器将为你调用基类的零参数构造函数。

如果基类没有定义一个无参构造函数怎么办？在这种情况下，如果你派生一个不指定调用哪个构造函数的类，你将会得到一个编译器错误。示例 6-38 展示了一个没有零参数构造函数的基类。（显式构造函数的存在禁用了编译器正常生成默认构造函数的机制，因此，这个基类只提供了一个带参数的构造函数。）它同时展示了一个派生类有两个构造函数，它们都使用`base`关键字显式调用基类的构造函数。

##### 示例 6-38\. 显式调用基类构造函数

```cs
public class BaseNoDefaultCtor
{
    public BaseNoDefaultCtor(int i)
    {
        Console.WriteLine("Base constructor: " + i);
    }
}

public class DerivedCallingBaseCtor : BaseNoDefaultCtor
{
    public DerivedCallingBaseCtor()
        `:` `base``(``123``)`
    {
        Console.WriteLine("Derived constructor (default)");
    }

    public DerivedCallingBaseCtor(int i)
        `:` `base``(``i``)`
    {
        Console.WriteLine("Derived constructor: " + i);
    }
}
```

这里的派生类决定提供一个无参构造函数，尽管基类没有这样的构造函数——它为基类需要的参数提供了一个常量值。第二个则直接将其参数传递给基类。

###### 注意

这里有一个经常被问到的问题：*如何提供与我的基类完全相同的所有构造函数，只需直接传递参数？* 答案是：*手动编写所有构造函数*。没有办法让 C#编译器生成一个看起来与基类提供的构造函数完全相同的构造函数集。您需要用比较冗长的方式来完成。

至少 Visual Studio、VS Code 或 JetBrains Rider 可以为您生成代码——如果您点击类声明，然后点击出现的快速操作图标，它将提供生成与基类中任何非私有构造函数具有相同参数的构造函数的选项，并自动为您传递所有参数。

正如第三章所示，类的字段初始化器在其构造函数之前运行。一旦涉及继承，情况就变得更加复杂，因为涉及多个类和多个构造函数。预测将会发生什么最简单的方法是理解，尽管实例字段初始化器和构造函数具有不同的语法，但 C#最终将所有特定类的初始化代码编译到构造函数中。此代码执行以下步骤：首先，运行特定于此类的字段初始化器（因此此步骤不包括基类字段初始化器——基类将自己照顾好）；接下来，调用基类构造函数；最后，运行构造函数体。这意味着在派生类中，您的实例字段初始化器将在基类构造之前运行——不仅仅是在基类构造函数体之前，甚至在基类的实例字段初始化之前。示例 6-39 说明了这一点。

##### 示例 6-39。探索构造顺序

```cs
public class BaseInit
{
    protected static int Init(string message)
    {
        Console.WriteLine(message);
        return 1;
    }

    private int b1 = Init("Base field b1");

    public BaseInit()
    {
        Init("Base constructor");
    }

    private int b2 = Init("Base field b2");
}

public class DerivedInit : BaseInit
{
    private int d1 = Init("Derived field d1");

    public DerivedInit()
    {
        Init("Derived constructor");
    }

    private int d2 = Init("Derived field d2");
}
```

我把字段初始化放在构造函数的两侧，只是为了表明它们相对于非字段成员的位置无关紧要。字段的顺序很重要，但只涉及彼此。构造`DerivedInit`类的实例会产生以下输出：

```cs
Derived field d1
Derived field d2
Base field b1
Base field b2
Base constructor
Derived constructor
```

这证实了派生类型的字段初始化器首先运行，然后是基类的字段初始化器，接着是基类构造函数，最后是派生类构造函数。换句话说，虽然构造函数体始于基类，但实例字段的初始化是反向进行的。

这就是为什么你不能在字段初始化器中调用实例方法的原因。静态方法是可用的，但实例方法不是，因为类远未准备就绪。如果派生类型的一个字段初始化器能够在基类上调用方法，可能会有问题，因为此时基类根本没有进行任何初始化——不仅其构造函数体尚未运行，而且其字段初始化器也尚未运行。如果实例方法在此阶段可用，我们将不得不编写所有的代码非常谨慎，因为我们不能假设我们的字段包含任何有用的内容。

正如你所见，构造函数体在进程中运行较晚，这就是我们可以在其中调用方法的原因。但这里仍然存在潜在的危险。如果基类定义了一个虚方法，并在其构造函数中调用该方法，如果派生类型覆盖了该方法，我们将在派生类型的构造函数体运行之前调用该方法。（在那时，它的字段初始化器将已经运行。实际上，这是字段初始化器以看似相反顺序运行的主要原因——这意味着派生类有一种在基类构造函数调用虚方法之前执行一些初始化的方式。）如果你熟悉 C++，你可能会猜想，当基类构造函数调用虚方法时，它将运行基本实现。但 C#的做法不同：基类的构造函数将在这种情况下调用派生类的重写方法。这不一定是问题，而且偶尔会很有用，但这意味着如果你希望你的对象在构造过程中调用自身的虚方法，你需要仔细思考并清楚地记录你的假设。

# 记录类型

当你定义一个`record`类型（或者你使用更明确但功能上相同的`record class`语法），从运行时的角度来看，生成的记录类型仍然是一个类。记录类型可以做大多数普通类能做的事情——尽管它们通常关注属性，你还可以添加其他成员，如方法和构造函数。事实证明，基于类的记录类型也支持继承。（自然地，由于`record struct`类型是值类型，它们不支持继承。）

记录类型存在一些继承约束。普通类不允许从记录类型继承——只有记录类型可以从记录类型派生。同样，记录类型只能从另一个记录类型或通常的`object`基类型继承。但在这些约束条件下，记录类型的继承工作方式与类相似。示例 6-40 展示了一个基本记录和几个派生类型。

##### 示例 6-40\. 记录继承

```cs
public abstract record OptionallyLabeled
{
    public string? Label { get; init; }
}

public record OptionallyLabeledItem : OptionallyLabeled;

public record Product(string Name) : OptionallyLabeled;
```

正如这显示的，我们可以将记录类型定义为`abstract`。当记录不使用位置语法时，我们从基类型（抽象或非抽象）继承的方式与类的方式相同：如`OptionallyLabeledItem`所示，我们在类型名称后放置一个冒号，后跟基类型名称。如果我们的派生类型想使用位置语法，则在参数列表后放置冒号和基类型，如`Product`类型所示。示例 6-41 展示了如何实例化在示例 6-40 中定义的两种派生类型。

##### 示例 6-41\. 实例化派生记录类型

```cs
var unlabeled = new OptionallyLabeledItem();
var labeled = new OptionallyLabeledItem
{
    Label = "New, improved!"
};

var unlabeledProduct = new Product("Book");
var labeledProduct = new Product("Shirt")
{
    Label = "Half price"
};
```

由于基类的`Label`属性不需要设置，我们可以自由地构造两种派生类型中的任意一种而不设置它。但是如果我们确实想设置它，我们使用的对象初始化语法与如果`Label`属性直接由`OptionallyLabeledItem`或`Product`定义的方式完全相同。但是如果基类型使用位置语法定义非可选属性，那么怎么办？正如示例 6-42 所示，记录继承语法允许我们向基类提供参数列表。

##### 示例 6-42\. 从位置记录派生

```cs
public abstract record Colorful(string Color);

public record LightBulb(string Color, int Lumens) : Colorful(Color);
```

`LightBulb`本身使用位置语法，并使用其两个构造参数之一作为基类要求的`Color`属性的值。但在某些情况下，您可能不想这样传递值：有时派生类型将知道要传递给基记录类型的值，就像示例 6-43 所示的那样。

##### 示例 6-43\. 将常量传递给位置基记录

```cs
public record FordModelT() : Colorful("Black");
```

因此，在这种情况下，尽管基`Colorful`记录使用位置语法，要求提供`Color`属性，但这个派生类型不传递该要求。流行的故事是，福特早期的汽车 Model T 只有一种颜色可供选择，因此这个特定的派生类型可以直接设置`Color`本身。`FordModelT`记录的用户无需提供`Color`，尽管这对于基`Colorful`类型是强制性参数。书呆子们现在可能渴望指出，这种油漆约束只适用于 Model T 生产的 19 年中的 12 年。我想吸引他们注意示例 6-44，它显示了尽管`FordModelT`类型在构建过程中不需要传递`Color`属性，但仍可以使用对象初始化设置。因此，这种记录类型使得可以像早期和晚期 Model T 一样指定颜色，但默认与这种汽车绝大多数确实是黑色的事实保持一致。

##### 示例 6-44\. 使用一个将强制基属性变为可选的派生记录

```cs
var commonModelT = new FordModelT();
var lateModelT = new FordModelT { Color = "Green" };
```

要能够使用示例 6-42 和 6-43 中显示的语法，在记录本身必须使用位置语法。 如果您仔细观察示例 6-43，您会发现在 `FordModelT` 类型名称之后有一个空参数列表。 虽然这可能看起来多余，但在这种情况下，需要将其放在这里，因为如果没有它，我们将不允许在冒号后直接写 `Colorful("Black")`。

还有其他方法可以将参数传递给位置基础记录。 正如第 3 章所述，当我们使用位置语法时，我们只是定义一个构造函数，因此另一种方法是使用常规语法来调用基类构造函数，正如示例 6-45 所示。

##### 示例 6-45\. 通过普通构造函数传递位置基础记录参数

```cs
public record RedDelicious : Colorful
{
    public RedDelicious() : base("Red")
    { }
}
```

最近几个示例处理了基类使用位置语法但派生类型不使用的情况。 但如果反过来，基类型不是位置的，而派生类型想要是位置的怎么办？ 如果派生类型只想添加一个或多个自己的属性，这很简单。 实际上，我们已经看到了产品类型在示例 6-40 中确实如此。 但是，如果基类型定义了一个可选属性（例如 `OptionallyLabeled.Label`），而派生类型想要将其变为强制性的，您可以这样做，但不能使用位置语法。 您必须像示例 6-46 所示一样完全编写构造函数。

##### 示例 6-46\. 使可选基本属性类位置性

```cs
public record LabeledDemographic : OptionallyLabeled
{
    public LabeledDemographic(string label)
    {
        Label = label;
    }

    public void Deconstruct(out string? label) => label = Label;
}
```

尽管这不使用位置语法，但它具有类似的效果，因为位置语法通过定义构造函数起作用。在示例 6-46 中构造函数的存在将阻止编译器生成默认的零参数构造函数，这意味着使用 `LabeledDemographic` 的代码在构造时必须提供 `Label` 属性，就像使用位置语法一样。在使用位置语法时，自动获得析构函数，但我这里不得不自己写。当试图对非位置记录派生类型强加位置行为时，编译器不生成析构函数会导致析构有点奇怪。基类将 `Label` 定义为可选，尽管我们定义了需要非空参数的构造函数，但在构造函数后可以使用对象初始化程序将其设置回 `null`。 （这看起来很奇怪但不违法）。所以我们的析构函数最终与构造函数不完全匹配。

## 记录、继承和`with`关键字

第三章展示了如何使用`with`表达式创建记录类型的修改副本。这会构建一个新实例，该实例除了在`with`关键字后面的大括号中指定的新属性值外，其他所有属性与原始实例相同。这种机制考虑了继承：`with`关键字生成的实例总是与其输入具有相同的类型，即使代码是以基础类型编写的，如示例 6-47。

##### 示例 6-47\. 在基础记录类型上使用`with`

```cs
OptionallyLabeled Discount(OptionallyLabeled item)
{
    return item with
    {
        Label = "60% off!"
    };
}
```

这里使用了从示例 6-40 中的抽象`OptionallyLabeled`记录类型。我们可以传递任何从该抽象基类派生的具体类型。示例 6-48 两次调用它，并传入两种不同的类型。

##### 示例 6-48\. 测试`with`如何与继承交互

```cs
Console.WriteLine(Discount(new OptionallyLabeledItem()));
Console.WriteLine(Discount(new Product("Sweater")));
```

运行该代码会产生以下输出：

```cs
OptionallyLabeledItem { Label = 60% off! }
Product { Label = 60% off!, Name = Sweater }
```

`Console.WriteLine`在其输入上调用`ToString`，而记录类型通过报告其名称及其属性值来实现此方法。因此，您可以从中看到，当`Discount`方法生成其输入的修改副本时，它成功地保留了类型信息。因此，即使`Discount`对`Product`记录类型或其`Name`属性一无所知，当它创建一个带有新`Label`值的副本时，`Name`属性也被正确地保留了下来。

这是由编译器为记录类型生成的代码所能够实现的。我已经在第三章中描述了复制构造函数，但光是这个还不够——`Discount`方法并不知道`OptionallyLabeledItem`或`Product`类型，因此它不会调用它们的复制构造函数。因此，记录类型还会得到一个隐藏的`virtual`方法，名为`<Clone>$`。在示例 6-47 中的`with`表达式会调用这个方法（然后继续设置`Label`属性）。由编译器生成的`<Clone>$`方法会调用自己的复制构造函数。由于派生的记录类型会重写`<Clone>$`，所以`with`表达式无论输入的类型如何，都会获得一个完全复制的记录。

# 特殊的基础类型

.NET 运行时库在 C#中定义了几种具有特殊意义的基础类型。其中最明显的是`System.Object`，我已经对其进行了详细描述。

还有`System.ValueType`。这是所有值类型的抽象基类型，因此你定义的任何`struct`或`record struct`，以及所有内置的值类型，如`int`和`bool`，都派生自`ValueType`。讽刺的是，`ValueType`本身是一个引用类型；只有从`ValueType`派生的类型才是值类型。像大多数类型一样，`ValueType`也派生自`System.Object`。在这里存在一个明显的概念上的困难：通常情况下，派生类包含其基类的所有功能，以及它们添加的任何功能。因此，考虑到`object`和`ValueType`都是引用类型，从`ValueType`派生的类型不是值类型似乎有些奇怪。而且，一个`object`变量如何能够持有一个不是引用类型的实例的引用，这也不是很明显。我将在第七章中解决所有这些问题。

在 C#中，不允许你编写一个明确从`ValueType`派生的类型。如果你想要编写一个从`ValueType`派生的类型，`struct`关键字就是为此而设计的。你可以声明一个`ValueType`类型的变量，但由于该类型未定义任何公共成员，`ValueType`引用不允许你做任何`object`引用做不到的事情。唯一显著的区别是，使用该类型的变量可以分配任何值类型的实例，但不能分配引用类型的实例。除此之外，它与`object`完全相同。因此，在 C#代码中明确提到`ValueType`相对比较少见。

所有枚举类型也都派生自一个共同的抽象基类型：`System.Enum`。由于枚举是值类型，你不会感到意外的是，`Enum`派生自`ValueType`。与`ValueType`类似，你永远不会明确从`Enum`派生——你使用`enum`关键字来定义枚举类型。与`ValueType`不同的是，`Enum`添加了一些有用的成员。例如，它的静态方法`GetValues`返回该枚举所有值的数组，而`GetNames`返回将所有值转换为字符串的数组。它还提供了`Parse`方法，用于从字符串表示转换回枚举值。

如第五章所述，所有的数组都源于一个共同的基类，`System.Array`，你已经看到了它所提供的特性。

`System.Exception`基类非常特殊：当你抛出异常时，C#要求抛出的对象必须是这种类型或者从它派生的类型。（异常是第八章的主题。）

委托类型都源于一个共同的基类型，`System.MulticastDelegate`，后者又从`System.Delegate`派生。我将在第九章中讨论这些内容。

这些都是 CTS 视为特殊的基本类型。还有一种基本类型被 C#编译器赋予特殊意义，那就是`Sys⁠tem.​Att⁠rib⁠ute`。在第一章中，我为方法和类应用了某些注解，以告诉单元测试框架将它们视为特殊处理。这些属性都对应于类型，因此当我将`[TestClass]`属性应用于一个类时，我使用了名为`TestClassAttribute`的类型。设计用作属性的类型都需要派生自`System.Attribute`。其中一些被编译器识别—例如，有些控制编译器将其生成的 EXE 和 DLL 文件的文件头中的版本号。我将在第十四章中展示所有这些内容。

# 摘要

C#支持单一实现继承，仅限于类或引用类型记录—你无法从结构体派生。然而，接口可以声明多个基类，类可以实现多个接口。从派生类型到基类型存在隐式引用转换，并且泛型接口和委托可以选择使用协变或逆变来提供额外的隐式引用转换。所有类型都派生自`System.Object`，确保所有变量都可用某些标准成员。我们看到虚方法如何允许派生类修改其基类的选定成员，以及如何使用封闭禁用该功能。我们还探讨了派生类型在访问成员时与其基类之间的关系，特别是构造函数。

我们对继承的探索已经完成，但是它引发了一些新问题，比如值类型和引用之间的关系以及终结器的作用。因此，在下一章中，我将讨论引用与对象生命周期之间的关系，以及 CLR 如何弥合引用和值类型之间的差距。

¹ 更准确地说，同一个程序集，还有友元程序集。第十二章描述了程序集。
