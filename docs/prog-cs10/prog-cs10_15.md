# 第十五章：文件和流

到目前为止，在本书中我展示的大多数技术都围绕着存在于对象和变量中的信息。这种状态存储在特定进程的内存中，但为了实用，程序必须与更广泛的世界进行交互。这可能通过 UI 框架实现，但有一种特定的抽象可以用于与外部世界的许多种交互：*流*。

流在计算中被如此广泛使用，以至于你无疑已经对它们非常熟悉了。在大多数其他编程系统中，.NET 流与它们基本相同：它只是一系列字节。这使得流对于许多常见功能非常有用，比如磁盘上的文件或 HTTP 响应的主体。控制台应用程序使用流来表示其输入和输出。如果你以交互方式运行这样的程序，用户在键盘上输入的文本成为程序的输入流，程序写入其输出流的任何内容都会显示在屏幕上。但程序不一定知道它的输入或输出类型——你可以重定向这些流以用于控制台程序。例如，输入流实际上可以提供磁盘上文件的内容，或者甚至可以是其他程序的输出。

###### 注意

并非所有的 I/O API 都是基于流的。例如，除了输入流之外，`Console` 类还提供了一个 `ReadKey` 方法，可以准确地返回哪个按键被按下，但这仅在输入来自键盘时有效。因此，虽然你可以编写不关心输入是交互式还是来自文件的程序，但有些程序更为挑剔。

流 API 向你提供原始的字节数据。然而，你也可以在不同的层次上操作。例如，有些面向文本的 API 可以包装底层流，这样你可以处理字符或字符串，而不是原始字节。还有各种*序列化*机制，允许你将.NET 对象转换为流表示，稍后可以将其转换回对象，从而可以持久保存对象的状态或将其状态发送到网络上。我稍后会展示这些更高级的 API，但首先让我们看看流抽象本身。

# Stream 类

`Stream`类定义在`System.IO`命名空间中。它是一个抽象基类，具有具体派生类型，如`FileStream`或`GZipStream`，代表特定类型的流。示例 15-1 展示了`Stream`类的三个最重要成员。它还有其他几个成员，但这些是抽象的核心。（稍后您将看到，还有`Read`和`Write`的异步版本。 .NET Core 3.1 和.NET 还提供了使用第十八章中描述的*span*类型之一替代数组的重载版本。本节中关于这些方法的所有内容也适用于异步和基于 span 的形式。）

##### Example 15-1\. `Stream`的最重要成员

```cs
public abstract int Read(byte[] buffer, int offset, int count);
public abstract void Write(byte[] buffer, int offset, int count);
public abstract long Position { get; set; }
```

一些流是只读的。例如，当控制台应用程序的输入流表示键盘或其他程序的输出时，程序无法向该流写入有意义的内容。（即使使用输入重定向运行具有文件输入的控制台应用程序，输入流也是只读的。）一些流是只写的，例如控制台应用程序的输出流。如果在只写流上调用`Read`方法或在只读流上调用`Write`方法，则这些方法会抛出`NotSupportedException`异常。

###### Tip

`Stream`类定义了各种描述流能力的`bool`属性，因此您不必等到出现异常才能知道流的类型。您可以检查`CanRead`或`CanWrite`属性。

`Read`和`Write`都以`byte[]`数组作为它们的第一个参数，并分别将数据复制到该数组中或从该数组中复制数据出来。随后的`offset`和`count`参数指示从数组的哪个元素开始，以及要读取或写入的字节数；您不必使用整个数组。请注意，没有参数指定要在流中的偏移量处读取或写入。这由`Position`属性管理 —— 它从零开始，但每次读取或写入时，位置会根据处理的字节数前进。

注意，`Read`方法返回一个`int`值。这告诉您从流中读取了多少字节 —— 该方法不保证提供您请求的数据量。这样做的一个明显原因是您可能已经达到流的末尾，因此即使您要求将 100 个字节读入数组中，当前`Position`和流的末尾之间可能只剩下 30 个字节的数据。然而，并不是这唯一可能导致您获取少于请求数据的原因，这经常会让人摸不着头脑，因此为了那些快速浏览本章节的人，我会做出一个警告。

###### Warning

如果你一次请求多个字节，`Stream` 可以出于任何原因返回少于你从 `Read` 请求的数据。你不应该假设调用 `Read` 返回了它所能返回的所有数据量，即使你有足够的理由知道你请求的数据量是可用的。

`Read` 稍微复杂的原因在于，某些流是实时的，代表程序运行时逐渐产生数据的信息源。例如，如果一个控制台应用程序在交互运行，其输入流只能在用户键入时提供数据；表示通过网络连接接收的数据的流只能在数据到达时提供数据。如果你调用 `Read` 并请求的数据超过当前可用的数据量，流可能会等待直到它有你请求的那么多数据，但它不必这样做——它可能会立即返回任何它当前已经有的数据。（它在返回之前必须等待的唯一情况是，如果它当前没有任何数据但尚未到达流的末尾。它必须返回至少一个字节，因为返回值 `0` 表示流的末尾。）如果你想确保读取特定数量的字节，你需要检查 `Read` 是否返回少于你想要的字节数，并在必要时继续调用它，直到你得到所需的数据。示例 15-2 展示了如何做到这一点。

##### 示例 15-2\. 读取特定数量的字节

```cs
static int ReadAll(Stream s, byte[] buffer, int offset, int length)
{
    if ((offset + length) > buffer.Length)
    {
        throw new ArgumentException("Buffer too small to hold requested data");
    }

    int bytesReadSoFar = 0;
    while (bytesReadSoFar < length)
    {
        int bytes = s.Read(
            buffer, offset + bytesReadSoFar, length - bytesReadSoFar);
        if (bytes == 0)
        {
            break;
        }
        bytesReadSoFar += bytes;
    }

    return bytesReadSoFar;
}
```

注意，这段代码检查了从 `Read` 返回的 `0` 值以检测流的末尾。如果没有这样的检查，如果在读取了被请求的数据量之前达到了流的末尾，它将永远循环下去。这意味着如果我们确实到达了流的末尾，这个方法将必须提供比调用者请求的数据少的数据量，因此这似乎并没有真正解决问题。然而，这确实排除了在没有到达流的末尾的情况下获得少于请求的数据量的情况。（你可以更改方法，使其在到达流的末尾之前提供指定数量的字节时抛出异常。这样，如果方法返回，它保证返回的字节数正好是所请求的数量。）

`Stream` 提供了一个更简单的读取方法。`ReadByte` 方法返回一个单字节，除非你已达到流的末尾，在这种情况下它返回值 `-1`。（它的返回类型是 `int`，允许它返回任何可能的 `byte` 值以及负值。）这避免了只返回部分请求数据的问题，因为如果你得到任何返回，你总是得到确切的一个字节。然而，如果你想读取更大的数据块，这并不特别方便或高效。

`Write`方法没有任何这些问题。如果成功，它始终接受您提供的所有数据。当然，它可能会失败——可能会因为错误（例如，磁盘空间不足或网络连接丢失）而在成功写入所有数据之前抛出异常。

## 位置和寻址

每次读取或写入时，流会自动更新其当前位置。如您在示例 15-1 中所见，`Position`属性可以设置，因此您可以尝试直接移动到特定位置。这并不保证能够成功，因为并非总是可能支持它。例如，代表通过 TCP 网络连接接收的数据的`Stream`可以无限产生数据——只要连接保持打开且另一端继续发送数据，流将继续响应对`Read`的调用。连接可能保持打开多天，并在此期间接收到数 TB 的数据。如果这样的流允许您设置其`Position`属性，使您的代码能够返回并重新读取先前接收到的数据，则流必须找到存储每个接收到的字节的地方，以防万一代码希望再次查看它。由于这可能涉及存储比磁盘上有空间更多的数据，显然是不切实际的，因此某些流在尝试设置`Position`属性时会抛出`NotSupportedException`。（有一个`CanSeek`属性，您可以使用它来发现特定流是否支持更改位置，因此就像只读和只写流一样，您不必等到出现异常才能找出它是否有效。）

除了`Position`属性外，`Stream`还定义了一个`Seek`方法，其签名如示例 15-3 所示。这使您可以相对于流的当前位置指定所需的位置。（对于不支持寻址的流，这也会抛出`NotSupportedException`。）

##### 示例 15-3\. `Seek`方法

```cs
public abstract long Seek(long offset, SeekOrigin origin);
```

如果将`SeekOrigin.Current`作为第二个参数传递，它将通过将第一个参数添加到当前位置来设置位置。如果要向后移动，可以传递负的`offset`。还可以传递`SeekOrigin.End`将位置设置为距离流末尾指定的字节数。传递`Seek​Ori⁠gin.Begin`与仅设置`Position`具有相同的逻辑效果——它将相对于流的起始位置设置位置。

## 刷新

与其他编程系统上许多流 API 一样，在`Stream`中写入数据不一定会立即使数据到达目的地。当调用`Write`时，你只知道它已经将你的数据复制到某个地方；但那可能是内存中的缓冲区，而不是最终的目标。例如，如果你向代表存储设备上文件的流写入单个字节，流对象通常会推迟将其写入驱动器，直到有足够的字节使得这样做值得。存储设备是基于块的，意味着写入以固定大小的块发生，通常是几千字节大小，因此等到有足够的数据来填充一个块再进行写入是有意义的。

这种缓冲通常是件好事——它提高了写入性能，同时使你可以忽略磁盘工作的细节。然而，缺点是如果你偶尔写入数据（例如将错误消息写入日志文件时），你可能会在程序写入数据到流和数据到达磁盘之间遇到长时间的延迟。对于试图通过查看当前正在运行的程序日志文件来诊断问题的人来说，这可能会令人困惑。更隐秘的是，如果你的程序崩溃，流缓冲区中尚未到达存储设备的任何数据可能会丢失。

因此，`Stream`类提供了`Flush`方法。这让你告诉流，你希望它执行任何必要的工作，以确保任何缓冲数据都被写入到其目标，即使这意味着对缓冲区的使用不是最优的情况。

###### 警告

使用`FileStream`时，`Flush`方法并不一定保证刷新的数据已经写入磁盘。它只是让流将数据传递给操作系统。在调用`Flush`之前，操作系统甚至还没有看到数据，因此如果突然终止进程，数据将会丢失。在`Flush`返回后，操作系统已经拥有你的代码已经写入的所有数据，因此可以在没有数据丢失的情况下终止进程。然而，操作系统可能会执行自己的额外缓冲，因此如果在操作系统开始将所有数据写入磁盘之前电源失败，数据仍可能丢失。如果需要确保数据已经持久写入（而不仅仅是确保你已经将数据交给操作系统），你还需要使用`WriteThrough`标志，描述在["FileStream Class"](https://example.org/filestream_class)中，或者调用带有`bool`参数的`Flush`重载，传递`true`以强制刷新到存储设备。

调用 `Dispose` 时，流会自动刷新其内容。只有在希望在写出缓冲数据后保持流打开状态时，才需要使用 `Flush`。如果流在打开但不活动期间会有较长时间，这一点尤其重要。（如果流代表网络连接，并且如果您的应用程序依赖于及时数据传递 —— 例如在线聊天应用程序或游戏 —— 即使您期望只有相对短暂的不活动期间，也应调用 `Flush`。）

## 复制

有时将所有数据从一个流复制到另一个流会很有用。你可以轻易地编写一个循环来做到这一点，但你不必这样做，因为 `Stream` 类的 `CopyTo` 方法（或等效的 `CopyToAsync`）已经为你实现了这一功能。关于它，没有太多可以说的。我提到它的主要原因是，开发人员通常因为不知道 `Stream` 中内置了这个功能，所以会自己编写这个方法的版本。

## 长度

一些流能够通过名为 `Length` 的属性报告它们的长度。与 `Position` 一样，该属性的类型为 `long` —— `Stream` 使用 64 位数值，因为流通常需要比 2GB 更大的容量，如果使用 `int` 表示大小和位置，则会受到上限的限制。

`Stream` 还定义了一个 `SetLength` 方法，用于在支持的情况下定义流的长度。在向文件写入大量数据时，可以考虑使用此方法，以确保有足够的空间来容纳所有希望写入的数据 —— 最好在开始之前遇到 `IOException`，而不是浪费时间进行注定失败的操作，并可能通过使用所有可用的空闲空间来引起系统范围的问题。然而，许多文件系统支持稀疏文件，允许创建远远大于可用空间的文件，因此在实践中，您可能直到开始写入非零数据时才会看到任何错误。即使如此，如果指定的长度超出文件系统支持的长度，`SetLength` 将抛出 `ArgumentException`。

并非所有流支持长度操作。`Stream` 类文档指出，`Length` 属性仅在支持 `CanSeek` 的流上可用。这是因为支持寻址的流通常是那些整个流内容在开始时就已知并且可访问的流。在内容在运行时生成的流上（例如代表用户输入的输入流或代表网络接收数据的流），通常也不会预先知道长度。至于 `SetLength`，文档说明仅在既支持写入又支持寻址的流上受支持。（与所有表示可选功能的成员一样，如果在不支持它们的流上尝试使用这些成员，`Length` 和 `SetLength` 将抛出 `NotSupportedException`。）

## 处置

一些流表示.NET 运行时外部的资源。例如，`FileStream`提供对文件内容的流访问，因此它需要从操作系统获取文件句柄。当你使用完毕后，关闭句柄非常重要；否则可能会阻止其他应用程序使用该文件。因此，`Stream`类实现了`IDisposable`接口（在第七章中描述），以便在必要时进行处理。正如我之前提到的，缓冲流如`FileStream`在调用`Dispose`之前会刷新它们的缓冲区，然后关闭句柄。

并非所有流类型都依赖于调用`Dispose`：例如，`MemoryStream`完全在内存中工作，因此 GC 可以负责处理它。但通常情况下，如果你创建了一个流，当你不再需要它时应该调用`Dispose`。

###### 注意

有些情况下，你会得到一个流，但并不是你的工作来处理它。例如，ASP.NET Core 可以提供流来表示 HTTP 请求和响应中的数据。它会为你创建这些流，并在你使用完之后进行处理，因此你不应该调用`Dispose`来处理它们。

令人困惑的是，`Stream`类也有一个`Close`方法。这是历史的偶然。在.NET 1.0 的第一个公共测试版发布时，并没有定义`IDisposable`，并且 C#也没有`using`语句——这个关键字仅用于`using`指令，用于将命名空间引入作用域。`Stream`类需要一种方式来知道何时清理其资源，但当时还没有一个标准的方法，所以它发明了自己的习惯用语。它定义了一个`Close`方法，这与其他编程系统中许多基于流的 API 使用的术语是一致的。在.NET 1.0 正式发布之前添加了`IDisposable`，并且`Stream`类增加了对其的支持，但保留了`Close`方法；如果移除它，将会影响到许多早期采用者，因为他们一直在使用测试版。但是，`Close`是多余的，并且文档明确建议不要使用它。文档说应该使用`Dispose`（通过`using`语句如果方便的话）。调用`Close`没有害处——它与`Dispose`之间没有实际区别——但`Dispose`是更常见的习惯用语，因此更为推荐。

## 异步操作

`Stream` 类提供了 `Read` 和 `Write` 的异步版本。请注意有两种形式。`Stream` 首次出现在 .NET 1.0 中，因此它支持当时的标准异步机制，即异步编程模型（APM，见第十六章）。通过 `BeginRead`、`EndRead`、`BeginWrite` 和 `EndWrite` 方法。此模型现已弃用，并已被较新的基于任务的异步模式（或 TAP，也见第十六章）所取代。`Stream` 通过其 `ReadAsync` 和 `WriteAsync` 方法支持此模式。还有两个操作最初没有任何异步形式，现在有了 TAP 版本：`FlushAsync` 和 `CopyToAsync`。（这些仅支持 TAP，因为 APM 在 Microsoft 添加这些方法时已经弃用。）

###### 警告

避免使用基于旧的 APM 的 `Begin`/`End` 形式的 `Read` 和 `Write`。在 .NET Core 的早期版本和 .NET Standard 2.0 之前，它们根本不存在。它们重新出现是为了更容易地将现有代码从 .NET Framework 迁移到 .NET Core，因此仅支持传统场景。

一些流类型利用非常高效的技术实现异步操作，直接对应于底层操作系统的异步能力。(`FileStream` 就是这样做的，以及.NET 可以提供的各种用于表示网络连接内容的流。) 您可能会遇到具有自定义流类型的库，这些流类型不会这样做，但即使如此，异步方法也会可用，因为基本的 `Stream` 类可以退回到使用多线程技术。

在使用异步读取和写入时需要注意的一点是，流只有一个 `Position` 属性。读取和写入取决于当前的 `Position`，并在完成时更新它，因此通常必须避免在已经开始的操作完成之前启动新的操作。但是，如果您希望从特定文件执行多个并发读取或写入操作，`FileStream` 对此有特殊处理。如果告诉它您将在异步模式下使用文件，则操作使用操作开始时 `Position` 的值，一旦异步读取或写入开始，您可以更改 `Position` 并启动另一个操作，而无需等待所有先前的操作完成。但这仅适用于 `FileStream`，且仅在文件以异步模式打开时。或者，可以使用稍后在本章描述的新 `RandomAccess` 类，而不是使用 `FileStream`。

.NET Core 3.1 和 .NET 5.0 及更高版本提供了 `IAsyncDisposable`，这是 `Dispose` 的异步形式。`Stream` 类实现了这一点，因为处置通常涉及刷新，这是一种潜在的缓慢操作。

## 具体的流类型

`Stream` 类是抽象的，因此要使用流，你需要一个具体的派生类型。在某些情况下，这些类型将由框架提供给你——例如，ASP.NET Core Web 框架提供了表示 HTTP 请求和响应主体的流对象，客户端的 `HttpClient` 类会执行类似操作。但有时你需要自己创建一个流对象。本节描述了一些常用的从 `Stream` 派生的类型。

`FileStream` 类表示文件系统上的文件。我将在“文件和目录”中描述这一点。

`MemoryStream` 允许你在 `byte[]` 数组之上创建一个流。你可以取一个现有的 `byte[]` 并将其包装在 `MemoryStream` 中，或者你可以创建一个 `MemoryStream`，然后通过调用 `Write`（或异步等效）来填充数据。完成后，你可以通过调用 `ToArray` 或 `GetBuffer` 来检索填充的 `byte[]`。(`ToArray` 分配一个基于实际写入的字节数的新数组。`GetBuffer` 更有效率，因为它返回 `MemoryStream` 正在使用的底层数组，但除非写入恰好完全填满它，否则返回的数组通常会超过实际使用的部分，在末尾有一些未使用的空间。) 当你需要与需要流的 API 一起工作但由于某些原因没有流时，此类非常有用。例如，本章后面描述的大多数序列化 API 都与流一起工作，但你可能希望将其与某些以 `byte[]` 为单位的其他 API 结合使用。`MemoryStream` 允许你在这两种表示之间建立桥梁。

Windows 和 Unix 都定义了一种进程间通信（IPC）机制，通过流连接两个进程。Windows 将其称为 *命名管道*。Unix 也有一个同名的机制，但完全不同；不过它确实提供了类似于 Windows 命名管道的机制：*域套接字*。虽然 Windows 命名管道和 Unix 域套接字的具体细节不同，但在 .NET 中，从 `PipeStream` 派生的各种类提供了对两者的共同抽象。

`BufferedStream` 是从 `Stream` 派生出来的，但在其构造函数中还接受一个 `Stream`。它添加了一个缓冲层，如果你想在设计为更大操作最佳的流上执行小读取或写入操作，这将非常有用。（对于 `FileStream`，你不需要使用这个，因为它有其自己内置的缓冲机制。）

有各种流类型可以以某种方式转换其他流的内容。例如，`DeflateStream`、`GZipStream` 和 `BrotliStream` 实现了三种广泛使用的压缩算法。你可以将它们包装在其他流周围，以压缩写入底层流的数据，或者解压读取自底层流的数据。（这些只提供了最低级别的压缩服务。如果你想处理流行的 ZIP 格式，用于压缩文件包，请使用 `ZipArchive` 类。）还有一个称为 `CryptoStream` 的类，可以使用.NET 支持的各种加密机制之一加密或解密其他流的内容。

## 一个类型，多种行为

正如你现在所见，抽象基类 `Stream` 在各种场景中被广泛使用。可以说，这是一个有点过于泛化的抽象。例如，像 `CanSeek` 这样的属性告诉你，你所拥有的特定 `Stream` 是否可以以某种方式使用，这可能是一个潜在问题的症状，是一种被称为 *代码异味* 的示例。.NET 流并不是发明这种一刀切的方法——它早在 Unix 和 C 编程语言的标准库中就很流行了。问题在于，当编写处理 `Stream` 的代码时，你可能不知道正在处理的是什么类型的东西。

有许多不同的方法可以使用 `Stream`，但经常遇到三种使用样式：

+   字节序列的顺序访问

+   随机访问，假定具有高效的缓存机制

+   访问设备或系统某些底层能力

正如你所知，不是所有的`Stream`实现都支持这三种模型——如果`CanSeek`返回`false`，那就排除了中间选项。但不太明显的是，即使这些属性表明某种能力可用，也不是所有流都同样高效地支持所有使用模型。

例如，我曾经参与过一个项目，该项目使用了一个库来访问云托管存储服务中的文件，并能用`Stream`对象表示这些文件。这看起来很方便，因为你可以将它们传递给任何可以处理`Stream`的 API。然而，它的设计非常适合前述列表中的第三种使用方式：每次调用`Read`（或`ReadAsync`）都会导致该库向存储服务发出 HTTP 请求。最初我们希望能够将其与另一个能够解析 Parquet 文件（一种广泛用于大容量数据处理的二进制表格数据存储格式）的库一起使用。然而，事实证明该库期望的是支持第二种访问方式的流：它会在文件中前后跳跃，进行大量相对较小的读取。它与我稍后将要描述的`FileStream`类型完美配合，因为后者很好地支持了前两种使用模式。（对于第二种模式，它依赖于操作系统进行缓存。）但是，直接将来自存储服务库的`Stream`直接插入 Parquet 解析库将会导致性能灾难。

当你遇到这种类型的不匹配时，往往并不明显。在这个例子中，像`CanSeek`这样的属性报告能力并没有暗示会有问题。而使用 Parquet 文件的应用程序通常使用某种远程存储服务，而不是本地文件系统，因此没有明显的理由认为该库会假设任何`Stream`都会提供类似本地文件系统的缓存。当我们尝试时，技术上它确实能够工作：存储库的`Stream`努力做到了一切所需，并且代码最终是正确的......但是要记住，每当你使用`Stream`时，确保你完全理解它将被应用的访问模式及其对这些模式的高效支持是非常重要的。

在某些情况下，你可能能够弥合这种差距。`BufferedStream`类通常可以接受仅设计用于前述第三种使用方式的`Stream`并使其适应第一种使用方式。然而，在运行库中没有任何内容可以为不本能地支持第二种使用方式的`Stream`添加对其的支持。（通常只有代表已完全在内存中或包装某些本地 API（例如操作系统文件系统 API）进行缓存的流才可用。）在这些情况下，你将需要重新考虑你的设计（例如，制作`Stream`内容的本地副本），更改`Stream`的使用方式，或编写某种自定义缓存适配器。（最终，我们编写了一个适配器，通过增加`BufferedStream`的能力，仅添加了足够的随机访问缓存来解决性能问题。）

# 无须`Stream`的随机访问和分散/聚集 I/O

`.NET 6.0` 在 `System.IO` 命名空间中新增了一个新类：`RandomAccess`。它可以在不使用 `Stream` 的情况下进行文件读写操作。它可以简化需要从单个文件执行多个并发读取的场景。它还可以执行跨越不是单个连续内存块的数据的单个读取或写入操作，利用底层操作系统处理此类读写的高效能力。

要使用 `RandomAccess`，必须使用 `.NET 6.0` 中新增的 `File` 类的 `OpenHandle` 方法打开文件，该方法返回 `SafeFileHandle`，它是围绕操作系统文件句柄的一次性包装。可以将其传递给 `RandomAccess` 提供的各种 `Read`、`ReadAsync`、`Write` 和 `WriteAsync` 静态方法。所有的读取和写入方法都要求你传递文件内的偏移量，这与 `Stream` 不同，后者会为你记住当前的 `Position`。每个方法都传递偏移量的优势在于，它避免了执行多个并发操作时出现的问题，正如前面描述的。示例 15-4 使用此方法直接从 Windows 的 *.exe* 文件中读取数据。注意，与 `Stream` 类似，读取操作可能获取比请求的数据量少，因此在需要读取特定字节数的情况下，你需要编写一个循环，以确保获取所需量的数据。

##### 示例 15-4\. 使用 `RandomAccess` 从文件中读取数据

```cs
static void ReadAll(SafeFileHandle fh, Span<byte> buffer, long offset)
{
    int soFar = 0;
    do
    {
        int read = RandomAccess.Read(fh, buffer[soFar..], offset + soFar);
        if (read == 0)
        {
            throw new InvalidOperationException(
                "Reached end of file before filling buffer");
        }
        soFar += read;
    } while (soFar < buffer.Length);
}

var stubSignature = new byte[2];
ReadAll(fh, stubSignature, 0);
if (stubSignature[0] != (byte)'M' || stubSignature[1] != (byte)'Z')
{
    Console.WriteLine("No 'MZ' at start of file - not an EXE file");
}
```

此示例仅执行单个读取以说明用法，但更复杂的示例可以自由执行多个并发读取，可以在多个线程上或使用 `ReadAsync` 方法。

这里的缓冲区以 `Span<byte>` 形式传递；`Write` 方法使用 `ReadOnlySpan<byte>`。异步形式则分别接受 `Memory<byte>` 和 `ReadOnlyMemory<byte>`。这些类型表示内存区域——通常是数组，但不一定。它们在第十八章中均有详细描述。

每个方法还提供了接受相关类型列表（例如`IReadOnlyList<Memory<byte>>`、`IReadOnlyList<ReadOnlyMemory<byte>>`等）的重载，以支持*scatter/gather* 读取或写入。这些操作中，单次读取或写入跨越多个内存块。如果要写出到文件的数据分布在多个内存区域中（例如因为所涉及的数据是通过对外部服务进行多次请求获得的），你可以执行单个写入操作，传入所有要写入的内存块列表。这比执行多个单独的写入要高效得多——操作系统可以直接处理这种 I/O，而在许多情况下，底层磁盘控制器硬件能够将散布在内存中的数据聚合成单个磁盘操作——它将散落在内存中的数据汇总起来，因此得名。同样的操作也适用于读取：你可以从文件中读取一块数据，并将其分布到多个目标缓冲区中。

# 文本导向类型

`Stream` 和 `RandomAccess` 类是面向字节的，但通常需要处理包含文本的文件。如果要处理存储在文件中（或通过网络接收到的）文本，使用基于字节的 API 是很麻烦的，因为这会迫使你显式处理所有可能发生的变化。例如，有多种约定来表示行的结束——Windows 通常使用值为`13`和`10`的两个字节，许多互联网标准如 HTTP 也是如此，但类 Unix 系统通常只使用值为`10`的单个字节。

目前也有多种流行的字符编码。有些文件每个字符使用一个字节，有些使用两个字节，还有一些使用可变长度编码。也有许多不同的单字节编码，因此，如果在文本文件中遇到字节值，例如`163`，除非知道使用的编码方式，否则无法知道其含义。

在使用单字节 Windows-1252 编码的文件中，值`163`代表英镑符号：£。¹ 但如果文件采用 ISO/IEC 8859-5 编码（设计用于使用西里尔字母的地区），同样的代码表示西里尔大写字母 DJE：Ђ。而如果文件使用 UTF-8 编码，值`163`只能作为多字节序列的一部分，代表一个单一字符。

当然，了解这些问题是任何开发者技能集的重要组成部分，但这并不意味着每次遇到文本都要处理每一个小细节。因此，.NET 定义了专门的抽象来处理文本。

## TextReader 和 TextWriter

抽象的 `TextReader` 和 `TextWriter` 类将数据表示为一系列 `char` 值。从逻辑上讲，这些类类似于流，但序列中的每个元素是一个 `char` 而不是一个 `byte`。然而，在细节上有一些区别。首先，有读和写的分离抽象。`Stream` 结合了这些功能，因为通常希望对单个实体进行读/写访问，特别是如果流表示磁盘上的文件。对于面向字节的随机访问，这是有意义的，但对于文本来说，这是一个问题的抽象。

变长编码使得支持随机写访问变得棘手（即能够在序列的任何点更改值）。考虑一下将一个 1 GB 的 UTF-8 文本文件的第一个字符 $ 替换为 £ 的意义。在 UTF-8 中，$ 字符只需要一个字节，但 £ 需要两个字节，因此更改第一个字符将需要在文件开头插入一个额外的字节。这意味着需要将剩余的文件内容——几乎 1 GB 的数据——向后移动一个字节。

即使只是只读的随机访问也相对昂贵。在一个 UTF-8 文件中找到第一百万个字符需要读取前 999,999 个字符，因为没有这样做，您无法知道其中包含的单字节和多字节字符的混合情况。第一百万个字符可能从第一百万个字节开始，但也可能从第四百万个字节开始，或者介于两者之间的任何位置。由于支持带有可变长度文本编码的随机访问是昂贵的，特别是对于可写数据，因此这些基于文本的类型不提供此功能。没有随机访问，将读者和写者合并为一个类型没有真正的好处。另外，将读者和写者类型分开消除了检查 `CanWrite` 属性的需要——您知道可以写入，因为您有一个 `TextWriter`。

`TextReader` 提供了几种读取数据的方式。最简单的是零参数重载的 `Read` 方法，它返回一个 `int`。如果已经到达输入的末尾，它将返回 `−1`，否则将返回一个字符值。（在确认非负后，您需要将其转换为 `char`。）此外，还有两种看起来类似于 `Stream` 类的 `Read` 方法的方法，正如 示例 15-5 所示。

##### 示例 15-5\. `TextReader` 块读取方法

```cs
public virtual int Read(char[] buffer, int index, int count) {...}
public virtual int ReadBlock(char[] buffer, int index, int count) {...}
```

就像`Stream.Read`一样，这些方法接受一个数组，以及数组中的索引和计数，并尝试读取指定数量的值。与`Stream`最明显的区别是，这些方法使用`char`而不是`byte`。但是`Read`和`ReadBlock`有什么区别呢？嗯，`ReadBlock`解决了我在 Example 15-2 中必须为`Stream`手动解决的问题：虽然`Read`可能返回比请求的字符数少，但`ReadBlock`不会在达到请求的字符数或到达内容结尾之前返回。

处理文本输入的挑战之一是处理各种行结束的约定，而`TextReader`可以使你免受这些影响。它的`ReadLine`方法读取整行输入并将其作为一个`string`返回。该字符串不包括行尾的字符。

###### 注意

`TextReader`并不假定特定的行结束约定。它接受回车符（字符值`13`，在字符串字面量中写作`\r`）或换行符（`10`，或`\n`）。如果这两个字符相邻出现，该字符对被视为单个行结束，尽管实际是两个字符。此处理仅在使用`ReadLine`或`Read​Li⁠neAsync`时发生。如果直接使用`Read`或`ReadBlock`在字符级别操作，你将看到行结束字符的确切形式。

`TextReader`还提供了`ReadToEnd`方法，它会将输入完全读取并作为一个单独的`string`返回。最后，还有`Peek`方法，与单参数的`Read`方法相同，但不会改变阅读器的状态。它允许你查看下一个字符而不消耗它，所以下次调用`Peek`或`Read`时，它将再次返回相同的字符。

至于`TextWriter`，它提供了两个重载方法用于写入：`Write`和`WriteLine`。每个方法都为所有内置的值类型（`bool`、`int`、`float`等）提供了重载。从功能上讲，该类本可以只使用一个接受`object`参数的重载方法，因为它可以直接调用参数的`ToString`方法，但是这些专门的重载方法使得可以避免装箱。`TextWriter`还提供了一个`Flush`方法，原因与`Stream`提供的相同。

默认情况下，`TextWriter`将使用操作系统的默认行结束序列。在 Windows 上是`\r\n`序列（先`13`，然后`10`）。在 Linux 上，每行末尾只有一个`\n`。你可以通过设置写入器的`NewLine`属性来更改这一行为。

这两个抽象类都实现了`IDisposable`接口，因为一些具体的派生文本阅读器和写入器类型是对其他可释放资源的包装。

与 `Stream` 一样，这些类提供了其方法的异步版本。与 `Stream` 不同的是，这是一个相当近期的增加，因此它们仅支持在 第十六章 中描述的基于任务的模式，可以使用 第十七章 中描述的 `await` 关键字消费。

## 具体的读取器和写入器类型

与 `Stream` 类似，.NET 中的各种 API 将向您提供 `TextReader` 和 `TextWriter` 对象。例如，`Console` 类定义了 `In` 和 `Out` 属性，用于提供对进程输入和输出流的文本访问。虽然我之前没有描述过这些，但我们已经在隐式地使用它们——`Console.WriteLine` 方法的重载只是为您调用 `Out.WriteLine` 的包装器。同样，`Console` 类的 `Read` 和 `ReadLine` 方法只是简单地转发到 `In.Read` 和 `In.ReadLine`。还有一个 `Error`，另一个用于将输出写入标准错误输出流的 `TextWriter`。但是，有一些直接派生自 `TextReader` 或 `TextWriter` 的具体类，您可能希望直接实例化它们。

### `StreamReader` 和 `StreamWriter`

可能最有用的具体文本读取器和写入器类型是 `StreamReader` 和 `StreamWriter`，它们包装了一个 `Stream` 对象。您可以将 `Stream` 作为构造函数参数传递，或者只需传递包含文件路径的字符串，它们将自动为您构造一个 `FileStream` 然后包装它。示例 15-6 使用此技术向文件写入一些文本。

##### 示例 15-6\. 使用 `StreamWriter` 向文件写入文本

```cs
using (var fw = new StreamWriter(@"c:\temp\out.txt"))
{
    fw.WriteLine($"Writing to a file at {DateTime.Now}");
}
```

提供了多种构造函数重载，以提供更精细的控制。当传递一个字符串以便使用 `StreamWriter`（而不是您已经获得的某个 `Stream`）时，可以选择性地传递一个 `bool`，指示是否从头开始或者追加到已存在的文件（传递 `true` 启用追加）。如果不传递此参数，则不使用追加，并且写入将从头开始。您还可以指定编码。默认情况下，`StreamWriter` 将使用没有字节顺序标记（BOM）的 UTF-8，但可以传递从 `Encoding` 类派生的任何类型，该类在 “编码” 中描述。

`StreamReader` 类似，可以通过传递 `Stream` 或包含文件路径的 `string` 来构造它，还可以选择性地指定编码。然而，如果不指定编码，其行为与 `StreamWriter` 稍有不同。`StreamWriter` 默认使用 UTF-8，而 `StreamReader` 则尝试从流内容中检测编码。它会查看前几个字节，并寻找一些特征，这些特征通常是确定特定编码正在使用的好迹象。如果编码的文本以 Unicode BOM 开头，这将极大地提高确定编码的准确性。

### `StringReader` 和 `StringWriter`

`StringReader` 和 `StringWriter` 类与 `MemoryStream` 的作用类似：当你需要与要求 `TextReader` 或 `TextWriter` 的 API 一起工作，但希望完全在内存中操作时，它们非常有用。`MemoryStream` 在 `byte[]` 数组上提供了 `Stream` API，`StringReader` 则将 `string` 包装为 `TextReader`，而 `StringWriter` 在 `StringBuilder` 上提供了 `TextWriter` API。

.NET 提供的用于处理 XML 的 API 之一，`XmlReader`，需要一个 `Stream` 或 `TextReader`。假设你有一个存储在 `string` 中的 XML 内容。如果在创建新的 `XmlReader` 时传递一个 `string`，它会将其解释为用于获取内容的 URI，而不是内容本身。接受一个 `string` 的 `StringReader` 构造函数会将该字符串包装为读取器的内容，我们可以将其传递给需要 `TextReader` 的 `XmlReader.Create` 重载方法，如 示例 15-7 所示。（这行代码用粗体标记，接下来的代码仅使用 `XmlReader` 读取内容以展示其按预期工作。）

##### 示例 15-7. 将字符串包装在 `StringReader` 中

```cs
string xmlContent =
    "<message><text>Hello</text><recipient>world</recipient></message>";
`var` `xmlReader` `=` `XmlReader``.``Create``(``new` `StringReader``(``xmlContent``)``)``;`
while (xmlReader.Read())
{
    if (xmlReader.NodeType == XmlNodeType.Text)
    {
        Console.WriteLine(xmlReader.Value);
    }
}
```

`StringWriter` 更为简单：你可以不带任何参数地构造它。在写入完成后，你可以调用 `ToString` 或 `GetStringBuilder` 来提取所有已写入的文本。

## 编码

正如前面提到的，如果使用 `StreamReader` 或 `StreamWriter`，它们需要知道底层流使用的字符编码，以便能够正确地在流中的字节和 .NET 的 `char` 或 `string` 类型之间进行转换。为了管理这一点，`System.Text` 命名空间定义了一个抽象的 `Encoding` 类，具有各种具体的编码特定公共派生类型，包括 `ASCIIEncoding`、`UTF7Encoding`、`UTF8Encoding`、`UTF32Encoding` 和 `UnicodeEncoding`。

大多数这些类型名称都是不言自明的，因为它们命名自它们代表的标准字符编码，比如 ASCII 或 UTF-8。需要稍作解释的是 `UnicodeEncoding` —— 毕竟，UTF-7、UTF-8 和 UTF-32 都是 Unicode 编码，那么这个`UnicodeEncoding`又是什么呢？当 Windows 在第一个 Windows NT 版本中引入对 Unicode 的支持时，采用了一个有点不太恰当的约定：在文档和各种 API 名称中，“Unicode”一词被用来指代一种 2 字节的小端字符编码，这只是众多可能的编码方案中的一种，它们都可以正确地描述为某种形式的“Unicode”。

`UnicodeEncoding` 类的命名是为了与这个历史约定保持一致，尽管即便如此，仍然有些令人困惑。在 Win32 API 中，“Unicode”所指的编码实际上是 UTF-16LE，但 `UnicodeEncoding` 类也能支持大端的 UTF-16BE。

基础的`Encoding`类定义了静态属性，返回我提到的所有编码类型的实例，因此如果需要表示特定编码的对象，通常只需写`Encoding.ASCII`或`Encoding.UTF8`等，而不是构造新对象。有两个类型为`UnicodeEncoding`的属性：`Unicode`属性返回一个配置为 UTF-16LE 的实例，`BigEndianUnicode`返回一个 UTF-16BE 的实例。

对于各种 Unicode 编码，这些属性将返回编码对象，告诉`StreamWriter`在输出开头生成 BOM。BOM 的主要目的是使读取编码文本的软件能够自动检测编码是大端序还是小端序（你也可以用它来识别 UTF-8，因为其编码 BOM 与其他编码不同）。如果知道将使用特定字节顺序的编码（例如 UTF-16LE），则 BOM 是不必要的，因为你已经知道顺序，但 Unicode 规范定义了可以通过以 BOM 开头的编码字节来广告正在使用的顺序的可适应格式。其 16 位版本称为 UTF-16，可以通过查看其是否以 0xFE、0xFF 或 0xFF、0xFE 开始来判断任何特定的 UTF-16 编码字节集是大端序还是小端序。

###### 警告

尽管 Unicode 定义了允许检测字节顺序的编码方案，但无法创建按此方式工作的`Encoding`对象——它总是具有特定的字节顺序。因此，尽管`Encoding`指定在写入数据时是否写入 BOM，但这不会影响读取数据的行为——它总是假定在构造`Encoding`时指定的字节顺序。这意味着`Encoding.UTF32`属性可能名字起得不太准确——它总是将数据解释为小端序，尽管 Unicode 规范允许 UTF-32 使用大端或小端序。`Encoding.UTF32`实际上是 UTF-32LE。

如前所述，在创建`StreamWriter`时未指定编码时，默认为无 BOM 的 UTF-8 编码，这与`Encoding.UTF8`不同，后者会生成 BOM。而`StreamReader`更有趣：如果未指定编码，它将尝试检测编码。因此，.NET 能够根据 Unicode 规范对 UTF-16 和 UTF-32 自动检测字节顺序；不过做法是在构造`StreamReader`时*不*指定特定编码。它会查找 BOM，如果找到，则使用适当的 Unicode 编码；否则假定为 UTF-8 编码。

UTF-8 是一种流行的编码方式。如果你的主要语言是英语，这是一种特别方便的表示方法，因为如果你只使用 ASCII 中可用的字符，每个字符将占据一个字节，并且编码后的文本将与 ASCII 编码具有相同的字节值。但不同于 ASCII，你不受限于 7 位字符集。所有 Unicode 代码点都可用；你只需对 ASCII 范围外的内容使用多字节表示。然而，尽管它非常广泛使用，UTF-8 并不是唯一流行的 8 位编码。

### 代码页编码

Windows，如同之前的 DOS 一样，长期支持扩展 ASCII 的 8 位编码。ASCII 是一个 7 位编码，意味着使用 8 位字节，你有 128 个“多余”的值可用于其他字符。这远远不足以覆盖每个区域的每个字符，但在特定国家内，通常足够应付（尽管并非总是如此——许多远东国家需要超过 8 位每字符的编码）。但每个国家往往希望有一套不同的非 ASCII 字符集，这取决于该地区流行的重音字符以及是否需要非罗马字母表。因此，为不同地区存在各种*代码页*。例如，代码页 1253 使用 193–254 范围内的值来定义希腊字母字符（用其余的非 ASCII 值填充有用字符，如非美元货币符号）。代码页 1255 定义希伯来字符，而 1256 则定义阿拉伯字符在上部范围内（这些特定代码页也有一些共同点，例如使用 128 表示欧元符号€，163 表示英镑符号£）。

最常见的代码页之一是 1252，因为它是英语环境下的 Windows 默认设置。这并不定义非罗马字母表；相反，它使用上部字符范围来放置有用的符号以及各种罗马字母的重音版本，使得广泛的西欧语言得到适当的表示。

你可以通过调用`Encoding.GetEncoding`方法，传入代码页号来创建代码页的编码。（你得到的对象的具体类型通常不是我之前列出的那些。这个方法可能会返回从`Encoding`派生的非公共类型。）示例 15-8 使用此方法将包含英镑符号的文本写入文件，使用代码页 1252。

##### 示例 15-8\. 使用 Windows 1252 代码页写入

```cs
using (var sw = new StreamWriter("Text.txt", false,
                                 Encoding.GetEncoding(1252)))
{
    sw.Write("£100");
}
```

这将把£符号编码为单字节，其值为`163`。使用默认的 UTF-8 编码，则会以两个字节编码，其值分别为`194`和`163`。

### 直接使用编码

`TextReader`和`TextWriter`并不是使用编码的唯一方式。代表编码的对象（如`Encoding.UTF8`）定义了各种成员。例如，`GetBytes`方法将`string`直接转换为`byte[]`数组，而`GetString`方法则进行相反的转换。

你还可以了解这些转换会产生多少数据。`GetByteCount`告诉你为给定字符串调用`GetBytes`将产生多大的数组，而`GetCharCount`告诉你解码特定数组将生成多少字符。你还可以找到在不知道确切文本情况下所需空间的上限，通过`GetMaxByteCount`方法。这个方法接受一个数字而不是一个`string`，它将其解释为字符串长度；由于.NET 字符串使用 UTF-16，这意味着这个 API 回答的问题是：“如果我有这么多 UTF-16 代码单元，那么在目标编码中表示相同文本可能需要的最大代码单元数是多少？”对于可变长度编码，这可能会产生显著的高估。例如，对于 UTF-8，`GetMaxByteCount`将输入字符串的长度乘以三³，并额外添加 3 个字节来处理可能出现的代理字符边缘情况。它生成了可能情况的正确描述，但是包含不需要在 UTF-8 中占用 3 个字节的任何字符（即英语或任何使用拉丁字母表的其他语言，以及使用希腊文、西里尔字母、希伯来文或阿拉伯文写作系统的任何文本）将需要比`GetMaxByteCount`预测的空间少得多。

有些编码可以提供一个*preamble*，即一系列独特的字节序列，如果在某些编码文本的开头找到它，表明你很可能正在查看使用该编码的内容。当你不知道正在使用哪种编码时，这可能非常有用。各种 Unicode 编码都会返回它们的 BOM 编码作为 preamble，你可以通过`GetPreamble`方法获取它。

`Encoding`类定义了实例属性，提供关于编码的信息。`EncodingName`返回编码的人类可读名称，但还有两个可用的名称。`WebName`属性返回与 Internet 分配号码管理局（IANA）注册的编码标准名称，该局管理互联网上的标准名称和编号，例如 MIME 类型。一些协议（如 HTTP）有时会将编码名称放入头部，这就是在该情况下应使用的文本。另外两个名称，`BodyName`和`HeaderName`，相对更为晦涩，仅用于互联网电子邮件——有不同的约定来表示某些编码在电子邮件正文和标题中的表示方式。

# 文件和目录

到目前为止，在本章中展示的抽象概念非常通用——您可以编写使用 `Stream` 的代码，而无需知道其中包含的字节来自何处或将要去哪里；同样，`TextReader` 和 `TextWriter` 不要求其数据有任何特定的起源或目的地。这很有用，因为它使得能够编写可应用于各种情境的代码成为可能。例如，基于流的 `GZipStream` 可以从文件、网络连接或任何其他流中压缩或解压缩数据。但是，有时您知道自己将处理文件并希望访问特定于文件的功能。本节描述了用于处理文件和文件系统的类。

## FileStream 类

`FileStream` 类继承自 `Stream` 类，表示文件系统中的文件。我已经偶尔使用过它几次了。相比基类，它只添加了相对较少的成员。`Lock` 和 `Unlock` 方法提供了在多个进程中使用单个文件时获取特定字节范围的独占访问的方式。`Name` 属性告诉你文件名。

`FileStream` 在其构造函数中提供了极大的灵活性——忽略带有 `[Obsolete]` 属性标记的构造函数，[⁴] 总共有不少于 10 个构造函数重载。创建 `FileStream` 的方法可分为两组：一种是已经有操作系统文件句柄的情况，另一种是没有文件句柄的情况。如果你已经从某处获得了句柄，你需要告诉 `FileStream` 该句柄提供了对文件的读、写或读/写访问权限，这可以通过传递 `FileAccess` 枚举值来实现。其他重载可选地允许你指定在读取或写入时要使用的缓冲区大小，以及一个指示句柄是否已为重叠 I/O（一种支持异步操作的 Win32 机制）打开的标志。（不带该标志的构造函数假定在创建文件句柄时未请求重叠 I/O。）

更常见的是使用其他构造函数，其中 `FileStream` 使用操作系统 API 代表您创建文件句柄。您可以提供不同级别的详细信息来指定希望如何完成这些操作。至少，您必须指定文件的路径和 `FileMode` 枚举值。Table 15-1 显示了此枚举定义的值，并描述了 `FileStream` 构造函数在已命名文件存在和不存在的情况下将如何处理每个值的情况。

表 15-1. `FileMode` 枚举

| 值 | 文件存在时的行为 | 文件不存在时的行为 |
| --- | --- | --- |
| `CreateNew` | 抛出 `IOException` | 创建新文件 |
| `Create` | 替换现有文件 | 创建新文件 |
| `Open` | 打开现有文件 | 抛出 `FileNotFoundException` |
| `OpenOrCreate` | 打开现有文件 | 创建新文件 |
| `Truncate` | 替换现有文件 | 抛出`FileNotFoundException` |
| `Append` | 打开现有文件，将`Position`设置为文件末尾 | 创建新文件 |

您也可以选择指定`FileAccess`。如果不指定，`FileStream`将使用`FileAccess.ReadWrite`，除非您选择了`FileMode.Append`。以追加模式打开的文件只能进行写入操作，因此在这种情况下，`FileStream`会选择`Write`。（如果在打开追加模式时传递显式的`FileAccess`请求除`Write`之外的任何值，构造函数会抛出`ArgumentException`。）

顺便说一下，在本节描述每个额外构造函数参数时，相关重载将还会接受之前描述过的所有参数（但`useAsync`参数除外，该参数仅出现在一个构造函数中）。正如示例 15-9 所示，大多数这些构造函数看起来都和前一个构造函数类似，只是多了一个额外参数。

##### 示例 15-9\. 使用路径的`FileStream`构造函数

```cs
public FileStream(string path, FileMode mode)
public FileStream(string path, FileMode mode, FileAccess access)
public FileStream(string path, FileMode mode, FileAccess access,
                  FileShare share)
public FileStream(string path, FileMode mode, FileAccess access,
                  FileShare share, int bufferSize)
public FileStream(string path, FileMode mode, FileAccess access,
                  FileShare share, int bufferSize, bool useAsync)
public FileStream(string path, FileMode mode, FileAccess access,
                  FileShare share, int bufferSize, FileOptions options)
```

那些接受`FileShare`类型参数的重载允许您指示是否需要独占文件访问权。如果传递`FileShare.None`，那么如果文件已在其他地方打开，构造函数将抛出`IOException`，如果成功打开，则在您完成使用文件之前，没有其他代码能够打开该文件。如果您愿意允许其他进程（或同一进程中的其他代码）同时打开文件，您可以指示您的代码是否能够容忍其他用户同时拥有文件的读取访问权、写入访问权或两者兼有。`FileShare`是一个类似标志的枚举，因此您可以指定`FileShare.Read|FileShare.Write`，但由于这是一个常见的组合，`FileShare`定义了一个预组合的`ReadWrite`值。

那些不显式指定`FileShare`的构造函数重载都使用`FileShare.Read`，这表示您的代码允许其他代码同时打开文件以进行读取，但不允许写入。例如，如果您正在向日志文件写入条目，那么您很可能会使用`FileMode.Append`和`FileShare.Read`，这意味着只有您的代码能够追加日志条目，但其他代码仍然可以使用`FileAccess.Read`打开文件以读取日志。如果两个程序尝试同时以写入访问方式打开同一日志文件，并且两者都指定了`FileShare.Read`（显式或作为隐式默认值），那么谁先进入就会成功，但第二个尝试时构造函数会抛出`IOException`，因为尝试打开文件进行写入与文件已经以没有`FileShare.Write`的方式打开的事实相冲突。在这种情况下，这是您想要的行为——如果两个程序尝试同时向同一文件末尾追加内容，结果将会非常混乱，因为每个程序都会有自己关于文件末尾位置的想法。

如果您尝试打开某个其他代码（可能是另一个进程或应用程序内的其他位置的代码）已经打开的文件，只有在您指定的 `FileAccess` 和 `FileShare` 与先前使用该文件的代码所使用的 `FileShare` 兼容时才会成功。同样地，如果您的代码已经打开了一个文件，那么在那一点上选择的 `FileShare` 决定了在您使用文件时其他代码可以成功应用的 `FileAccess` 和 `FileShare` 组合。例如，如果您想要读取一个其他进程正在写入的日志文件，那么如果那个进程指定了 `FileShare.Read`，您将需要使用 `FileAccess.Read`。 （那些未指定 `FileAccess` 的构造函数默认为 `FileAccess.ReadWrite`，在这种情况下将失败，因为如果某物已经使用 `FileShare.Read` 打开文件，则无法获得写访问权限。）但是您还需要指定 `FileShare.ReadWrite`。这在只想要读取的代码中可能看起来令人惊讶，但它是有道理的：它声明了我们不介意在我们读取时其他代码试图修改文件。`FileShare.Read` 的默认值表明我们在使用文件时不希望文件发生更改，但这对于从日志文件中*读取*是错误的选择——如果我们设法使用 `FileShare.Read` 打开日志文件，那将阻止主应用程序打开日志文件进行写入。

单独指定 `FileShare.Write`（而不与 `FileShare.Read` 结合）是合法的，但有点奇怪。它容忍同时存在具有写访问权限的其他句柄，但不允许读取者。您还可以传递 `Delete`（单独或与 `Read` 和/或 `Write` 结合使用），表示您不介意在您打开文件时有人尝试删除它。显然，如果尝试在文件被删除后使用文件，将会收到 I/O 异常，因此您需要为此做好准备，但有时这样做可能值得努力；否则，尝试删除文件时将会被阻止，而您已经打开了文件。

###### 警告

Unix 的文件锁机制比 Windows 少，因此这些锁定语义通常会在这些环境中映射为更简单的东西。此外，在 Unix 中，文件锁是建议性的，这意味着进程可以选择忽略它们。

我们可以传递的下一个信息片段是缓冲区大小。这控制了 `FileStream` 从文件系统读取和写入时使用的块大小。它的默认值为 4,096 字节。在大多数情况下，这个值都可以很好地工作，但是如果您正在处理非常高的数据量，较大的缓冲区大小可能会提供更好的吞吐量。然而，与所有性能问题一样，您应该测量此类更改的影响，看看是否值得——在某些情况下，您可能看不到数据吞吐量的任何差异，只会使用比必要更多一点的内存。

`useAsync` 标志允许你确定文件句柄是否以优化大型异步读取和写入的方式打开。（在 Windows 上，这会打开文件进行*重叠 I/O*，这是支持异步操作的 Win32 特性。）如果你以相对较大的块读取数据，并使用流的异步 API，通常通过设置此标志可以获得更好的性能。但是，如果每次读取几个字节，这种模式实际上会增加开销。如果访问文件的代码对性能特别敏感，值得尝试两种设置，看看哪种对你的工作负载更有效。正如前面提到的，这也使得可以在单个 `FileStream` 上执行多个并发操作。

下一个参数可以添加的类型是`FileOptions`。如果你非常注意的话，你会注意到在示例 15-9 中，到目前为止我们看过的每一个重载都添加了一个新参数，但是在这个中，`FileOptions` 参数*替换了* `bool useAsync` 参数。这是因为你可以用 `FileOptions` 指定的选项之一是异步访问。`FileOptions` 是一个标志枚举，所以你可以指定它提供的任何组合标志，这些标志在表 15-2 中有描述。

表 15-2\. `FileOptions` 标志

| 标志 | 含义 |
| --- | --- |
| `WriteThrough` | 禁用操作系统写入缓冲，数据直接传递到存储设备当你刷新流时 |
| `Asynchronous` | 指定使用异步 I/O |
| `RandomAccess` | 提示文件系统缓存，你将会进行查找，而不是按顺序读取或写入数据 |
| `SequentialScan` | 提示文件系统缓存，你将按顺序读取或写入数据 |
| `DeleteOnClose` | 告诉 `FileStream` 在调用 `Dispose` 时删除文件 |
| `Encrypted` | 加密文件，以防其他用户读取其内容 |

要注意`WriteThrough` 标志。虽然它按照预期工作，但可能没有预期的效果，因为某些硬盘会延迟写入以提高性能（许多硬盘有自己的 RAM，能够非常快速地接收来自计算机的数据，并在真正存储数据之前报告写入操作已完成）。`WriteThrough` 标志将确保当你释放或刷新流时，你写入的所有数据都已传送到驱动器，但驱动器不一定已将该数据持久写入，因此如果电源故障，你仍可能丢失数据。确切的行为将取决于你如何告诉操作系统配置驱动器。

.NET 6.0 添加了一个新的重载，接受两个参数：一个`string`（文件的路径）和一个`FileStreamOptions`。`FileStreamOptions`定义了我们刚刚讨论的每个设置的属性。因此，它具有`Mode`、`Access`、`Share`、`Options`和`BufferSize`。它还添加了一个新的设置，新添加到.NET 6.0 中，`PreallocationSize`，允许应用程序指示文件预计需要占用的空间大小。这使得操作系统可以检测到当空间不足时，并且可以预留空间，减少由于磁盘空间不足而导致的操作失败的可能性。`FileStreamOptions`的重载使得只设置那些不想要默认值的方面变得更容易——您只需设置相关属性。这意味着，如果没有一个`FileStream`构造函数重载正好符合您需要的参数组合，那也不再不方便。

虽然`FileStream`可以控制文件的内容，但有些操作可能非常繁琐，或者`FileStream`根本不支持。例如，您可以使用这个类复制文件，但这并不像可能的那么简单，并且`FileStream`没有提供任何删除文件的方法。因此，运行时库包含了一个专门的类来处理这类操作。

## 文件类

静态类`File`提供了各种文件操作的方法。`Delete`方法从文件系统中删除指定的文件。`Move`方法可以移动或重命名文件。还有一些方法用于检索文件系统存储的关于每个文件的信息和属性，如`GetCreationTime`、`GetLastAccessTime`、`GetLastWriteTime`⁵和`GetAttributes`。（最后一个返回一个`FileAttributes`值，这是一个标志枚举类型，告诉您文件是否为只读、隐藏文件、系统文件等等。）

`Encrypt`方法在某种程度上与`FileStream`重叠——正如您之前看到的，您可以在创建文件时请求以加密方式存储它。然而，`Encrypt`能够处理已经创建但未加密的文件——它会在原地对其进行加密。（这仅在 Windows 上支持，在文件系统支持的驱动器上有效。在其他操作系统上会抛出`PlatformNotSupportedException`异常，在 Windows 上如果指定的文件不支持加密也会抛出`NotSupportedException`异常。这与通过 Windows 文件资源管理器中的文件属性窗口启用加密具有相同的效果。）您还可以通过调用`Decrypt`将加密文件转换回未加密状态。

###### 注意

在读取加密文件之前，不需要先调用`Decrypt`。在以加密文件的相同用户账户登录时，可以像平常一样读取其内容——加密文件看起来就像普通文件，因为 Windows 在读取时会自动解密内容。这种特定的加密机制的目的是，如果其他用户设法获取文件访问权限（例如，如果它在被盗的外部驱动器上），文件内容将会看起来像随机垃圾。`Decrypt`移除了这种加密，这意味着任何能够访问文件的人都能查看其内容。

`File`提供的其他方法只是提供了更方便的方式来完成可以用`FileStream`手动完成的事情。`Copy`方法复制文件，虽然你可以使用`FileStream`的`CopyTo`方法来完成这个操作，但`Copy`方法会处理一些棘手的细节。例如，它确保目标文件保留诸如是否只读和是否启用加密等属性。

`Exists`方法允许你在尝试打开文件之前发现文件是否存在。虽然在尝试打开不存在的文件时，`FileStream`会抛出`FileNotFound`异常，但是`Exists`在你只需确定文件是否存在而不需要进行其他操作时很有用。如果你打算无论如何都要打开文件，并且只是想避免异常，那么你应该谨慎使用这个方法；仅仅因为`Exists`返回`true`并不意味着你不会收到`FileNotFound`异常。总是有可能在你检查文件存在性和尝试打开它之间，另一个进程删除了文件。或者，文件可能位于网络共享中，你可能会失去网络连接。因此，即使你试图避免引发异常，也应该时刻准备处理文件访问时可能出现的异常。

`File`提供了许多辅助方法来简化打开或创建文件的过程。`Create`方法简单地为你构造一个`FileStream`，传入适当的`FileMode`、`FileAccess`和`FileShare`值。示例 15-10 展示了如何使用它，同时展示了如果不使用`Create`辅助方法，等效的代码会是什么样子。`Create`方法提供了重载，允许你指定缓冲区大小、`FileOptions`和`FileSecurity`，但仍然为你提供了其他参数。

##### 示例 15-10\. `File.Create` versus 新建 `FileStream`

```cs
using (FileStream fs = File.Create("foo.bar"))
{
   ...
}

// Equivalent code without using File class
using (var fs = new FileStream("foo.bar", FileMode.Create,
                               FileAccess.ReadWrite, FileShare.None))
{
    ...
}
```

`File` 类的 `OpenRead` 和 `OpenWrite` 方法为当你想要打开现有文件以供读取或打开或创建文件以供写入时提供了类似的简化功能。还有一个需要传递 `FileMode` 的 `Open` 方法。这种方法的效用较低——它与也接受路径和模式参数的 `FileStream` 构造函数重载非常相似，自动提供适当的其他设置。它们的某种任意的区别在于，虽然 `FileStream` 构造函数默认为 `FileShare.Read`，但 `File.Open` 方法默认为 `FileShare.None`。

`File` 还提供了几个面向文本的辅助方法。最简单的方法是 `OpenText`，用于打开一个文本读取文件，但其价值有限，因为它与接受单个字符串参数的 `StreamReader` 构造函数的功能完全相同。只有在你偏好它使你的代码看起来更加整洁时才会使用它——如果你的代码大量使用 `File` 辅助方法，你可能会选择出于惯用性一致性的考虑使用它。

`File` 类暴露的几种方法都是面向文本的。这些方法使我们能够改进类似 示例 15-11 中所示的代码。它向日志文件追加一行文本。

##### 示例 15-11\. 使用 `StreamWriter` 向文件追加

```cs
static void Log(string message)
{
    using (var sw = new StreamWriter(@"c:\temp\log.txt", true))
    {
        sw.WriteLine(message);
    }
}
```

其中一个问题是一眼看不出 `StreamWriter` 是如何被打开的——`true` 参数的含义是什么？事实上，这告诉 `StreamWriter` 我们希望它在追加模式下创建底层的 `FileStream`。示例 15-12 也具有相同的效果——它使用 `File.AppendText`，为我们调用完全相同的 `FileStream` 构造函数。尽管我之前对于 `File.OpenText` 的评价有些苛刻，认为它提供的价值较低，但我认为 `File.AppendText` 曾经确实在可读性方面提供了真正有用的改进，而 `File.OpenText` 并没有。相比之下，通过 C# 添加了对命名参数的支持后，`AppendText` 看起来不再那么有用了——我们可以在 示例 15-11 中为 `append` 参数命名以达到类似的可读性改进。

##### 示例 15-12\. 使用 `File.AppendText` 创建一个追加的 `StreamWriter`

```cs
static void Log(string message)
{
    using (StreamWriter sw = File.AppendText(@"c:\temp\log.txt"))
    {
        sw.WriteLine(message);
    }
}
```

如果你只想将一些文本附加到文件并立即关闭它，有一种更简单的方法。正如 示例 15-13 所示，我们可以使用 `AppendAllText` 辅助方法进一步简化事情。

##### 示例 15-13\. 将单个字符串附加到文件末尾

```cs
static void Log(string message)
{
    File.AppendAllText(@"c:\temp\log.txt", message);
}
```

要小心哦。这与示例 15-12 并不完全相同。该示例使用了`WriteLine`来追加文本，但示例 15-13 相当于只使用了`Write`。因此，如果你在多次调用示例 15-13 中的`Log`方法，除非你使用的字符串恰好包含行尾字符，否则你最终会在输出文件中得到一行长文本。如果你想逐行处理，可以使用`AppendAllLines`方法，该方法接受一个字符串集合，并将每个字符串作为新行追加到文件末尾。示例 15-14 使用此方法在每次调用时追加一整行。

##### 示例 15-14\. 向文件追加单行

```cs
static void Log(string message)
{
    File.AppendAllLines(@"c:\temp\log.txt", new[] { message });
}
```

由于 `AppendAllLines` 接受 `IEnumerable<string>`，因此您可以使用它来追加任意数量的行。但是如果您只想追加一行，它也完全可以胜任。`File` 还定义了 `WriteAllText` 和 `WriteAllLines` 方法，它们的工作方式非常相似，但如果指定路径处已经存在文件，它们将替换它而不是追加到它。

还有一些用于读取文件内容的相关文本方法。`ReadAllText`执行的是构造一个 `StreamReader`，然后调用其 `ReadToEnd` 方法的等效操作——它将整个文件内容作为一个单独的 `string` 返回。`ReadAllBytes`将整个文件读入一个 `byte[]` 数组。`ReadAllLines`将整个文件作为一个 `string[]` 数组读取，每行一个元素。`ReadLines`看起来非常相似。它以 `IEnumerable<string>` 的形式提供对整个文件的访问，每行一个条目，但不同之处在于它是懒加载的——与我在本段描述的所有其他方法不同，它不会一次性将整个文件读入内存，因此对于非常大的文件来说，`ReadLines`是更好的选择。它不仅消耗更少的内存，而且使您的代码能够更快地启动——只要从磁盘读取到第一行数据，您就可以开始处理数据，而其他方法在读取整个文件之前都不会返回。

## Directory 类

就像 `File` 是一个静态类，提供用于执行文件操作的方法一样，`Directory` 也是一个静态类，提供用于执行目录操作的方法。其中一些方法与 `File` 提供的方法非常相似——例如，有方法来获取和设置创建时间、最后访问时间和最后写入时间，还有 `Move`、`Exists` 和 `Delete` 方法。与 `File` 不同，`Directory.Delete` 有两个重载。一个只接受路径，只有在目录为空时才起作用。另一个还接受一个 `bool` 参数，如果为 `true`，将递归删除文件夹中的所有内容，包括嵌套的文件夹和它们包含的文件。请谨慎使用这个方法。

当然，还有专用于目录的方法。`GetFiles`接受一个目录路径，并返回包含该目录中每个文件的完整路径的`string[]`数组。还有一个重载方法，允许您指定一个模式来过滤结果，并且第三个重载方法接受一个模式，并且还可以使用一个标志来请求递归搜索所有子文件夹。示例 15-15 使用它来查找我的*Pictures*文件夹中所有具有*.jpg*扩展名的文件。（除非您也叫伊恩，否则您需要更改该路径以匹配您的帐户名称，以使其在您的计算机上起作用。）在实际应用程序中，您应该使用“已知文件夹”中显示的技术获取此路径。

##### 示例 15-15\. 递归搜索特定类型的文件

```cs
foreach (string file in Directory.GetFiles(@"c:\users\ian\Pictures",
                                           "*.jpg",
                                           SearchOption.AllDirectories))
{
    Console.WriteLine(file);
}
```

还有一个类似的`GetDirectories`方法，提供相同的三个重载，它返回指定目录中的目录而不是文件。还有一个`GetFileSystemEntries`方法，同样有三个重载，它返回文件和文件夹。

还有一些称为`EnumerateFiles`、`EnumerateDirectories`和`EnumerateFileSystemEntries`的方法，与三个`GetXxx`方法完全相同，但它们返回`IEnumerable<string>`。这是一种延迟枚举，因此您可以立即开始处理结果，而不是等待所有结果作为一个大数组。

`Directory`类提供与进程当前目录（每次调用文件 API 而不指定完整路径时使用的目录）相关的方法。`GetCurrentDirectory`返回路径，`SetCurrentDirectory`设置它。

您也可以创建新目录。`CreateDirectory`方法接受一个路径，并尝试创建尽可能多的目录，以确保路径存在。因此，如果您传递*C:\new\dir\here*，并且没有*C:\new*目录，它将创建三个新目录：首先它将创建*C:\new*，然后*C:\new\dir*，然后*C:\new\dir\here*。如果您请求的文件夹已经存在，它不会将其视为错误；它只是返回而不执行任何操作。

`GetDirectoryRoot`将目录路径剥离为驱动器名称或其他根目录，例如网络共享名称。例如，在 Windows 上，如果您传递*C:\temp\logs*，它将返回*C:\*；如果您传递*\\someserver\myshare\dir\test*，它将返回*\\someserver\myshare*。这种字符串分割操作，即将路径拆分为其组成部分，是一个非常常见的需求，因此有一个专门的类来处理这类操作。

## 路径类

`Path` 类提供了一些有用的工具函数，用于处理包含文件名的字符串。其中一些函数用于从文件路径中提取片段，比如包含的文件夹名称或文件扩展名。还有一些函数用于组合字符串，生成新的文件路径。这些大多数方法仅执行特定的字符串处理，不需要路径所指代的文件或目录真实存在。然而，也有一些方法超出了字符串操作的范畴。例如，`Path.GetFullPath` 方法会考虑当前目录，如果传入的参数不是绝对路径的话。但只有需要使用真实位置的方法才会这样做。

`Path.Combine` 方法处理了在组合文件夹和文件名时遇到的繁琐问题。如果你有一个文件夹名 *C:\temp* 和一个文件名 *log.txt*，将它们同时传给 `Path.Combine` 方法会返回 *C:\temp\log.txt*。如果将 *C:\temp\* 作为第一个参数传入，它也会正常工作，因此其中一个处理的问题是确定是否需要提供额外的 `\` 字符。如果第二个路径是绝对路径，它会检测并简单地忽略第一个路径，因此如果你传入 *C:\temp* 和 *C:\logs\log.txt*，结果将会是 *C:\logs\log.txt*。虽然这些问题可能看起来微不足道，但如果尝试通过字符串连接自己做文件路径的组合，很容易出错，因此你应该始终避免这样做，而是使用 `Path.Combine` 方法。

当涉及路径时，.NET Core 和 .NET 在不同平台上表现不同。在类 Unix 系统上，只使用 `/` 作为目录分隔符，因此 `Path` 类中期望路径包含目录的各种方法会在这些系统上将 `/` 视为唯一的分隔符。Windows 使用 `\` 作为分隔符，尽管在 Windows 上也普遍容忍使用 `/` 作为替代，`Path` 类也支持这一点。因此，`Path​.Com⁠bine("/x/y", "/z.txt")` 在 Windows 和 Linux 上会产生相同的结果，但 `Path.Combine(@"\x\y", @"\z.txt")` 则不会。此外，在 Windows 上，如果路径以驱动器号开头，则是绝对路径，但 Unix 不认识驱动器号。在上文中的例子中，如果在 Linux 或 macOS 上移除驱动器号并将 `\` 替换为 `/`，结果将会是你所期望的。

给定文件路径，`GetDirectoryName` 方法会移除文件名部分，仅返回目录。这个方法很好地说明了为什么你需要记住大多数 `Path` 类的成员不会查看文件系统。如果你没有考虑这一点，你可能会期望当你传递给 `GetDirectoryName` 一个目录名，比如 *C:\Program Files*，它会检测到这是一个目录并返回相同的字符串，但事实上它将仅返回 *C:\*。名称 *Program Files* 对于文件或目录来说都是一个完全合法的名称，由于 `GetDirectoryName` 不会检查磁盘，并且它期望传递的路径包括文件名，因此在这种情况下它会认为这是一个文件。（可以说，即使它意识到 *C:\Program Files* 是一个目录，*C:\* 也将是正确的结果，因为那是包含 *Program Files* 目录的目录。）该方法有效地查找最后的 `/` 或 `\` 字符，并返回其前面的所有内容。（因此，如果你传递一个带有尾部 `\` 的目录名，比如 *C:\Program Files\*，它将返回 *C:\Program Files*。然而，这个 API 的整个目的是从文件的完整路径中移除文件名。如果你已经有一个只有目录名的字符串，你不应该调用这个 API。）

`GetFileName` 方法返回文件名（包括扩展名，如果有）。和 `GetDirectoryName` 一样，它也查找最后的目录分隔符字符，但返回的是它后面的文本，而不是前面的文本。同样，它不查看文件系统——这完全通过字符串操作完成（尽管和所有这些操作一样，它考虑了本地系统对于目录分隔符或绝对路径的规则）。`GetFileNameWithoutExtension` 类似，但如果存在扩展名（如 *.txt* 或 *.jpg*），它会从名称的末尾移除扩展名。相反，`GetExtension` 返回扩展名而不返回其他内容。

如果您需要创建临时文件来执行一些工作，`Path` 提供了三个有用的方法。`GetRandomFileName` 使用随机数生成器创建一个您可以用于随机文件或文件夹的名称。这个随机数是密码强度的，具有两个有用的属性：名称将是唯一且难以猜测的。（如果攻击者能够预测临时文件的名称或位置，系统安全的某些攻击可能变得可能。）这个方法实际上不会在文件系统上创建任何内容，它只是返回一个合适的名称。另一方面，`GetTempFileName` 将在操作系统为临时文件提供的位置创建一个文件。这个文件将是空的，并且该方法返回其路径作为一个字符串。然后您可以打开文件并修改它。（这并不保证使用加密来选择一个真正随机的名称，因此不应依赖于此类文件位置的不可猜测性。它将是唯一的，但仅此而已。）您应该在完成对其的操作后删除由 `GetTempFileName` 创建的任何文件。最后，`GetTempPath` 返回 `GetTempFileName` 将使用的文件夹的路径；这并不会创建任何内容，但您可以与 `GetRandomFileName` 返回的名称（与 `Path.Combine` 结合使用）一起使用它来选择一个位置来创建您自己的临时文件。

## FileInfo、DirectoryInfo 和 FileSystemInfo

虽然 `File` 和 `Folder` 类提供了访问信息的方式——例如文件的创建时间以及它是系统文件还是只读文件——但如果您需要访问多个信息，这些类存在问题。使用单独的调用收集每个数据位不是很高效，因为可以通过更少的步骤从底层操作系统获取信息。此外，有时传递包含您需要的所有数据的单个对象可能更容易，而不是找到放置许多单独项目的地方。因此，`System.IO` 命名空间定义了包含有关文件或目录信息的 `FileInfo` 和 `DirectoryInfo` 类。由于存在一定的共同点，这些类型都派生自基类 `FileSystemInfo`。

要构造这些类的实例，您需要传递您想要的文件或文件夹的路径，就像 示例 15-16 中所示。顺便说一句，如果稍后您认为文件可能已被其他程序更改，并且您想要更新 `FileInfo` 或 `DirectoryInfo` 返回的信息，您可以调用 `Refresh`，它将重新加载来自文件系统的信息。

##### 示例 15-16\. 使用 `FileInfo` 显示有关文件的信息

```cs
var fi = new FileInfo(@"c:\temp\log.txt");
Console.WriteLine(
    $"{fi.FullName} ({fi.Length} bytes) last modified on {fi.LastWriteTime}");
```

除了提供对应于各种`File`和`Directory`方法获取信息（`CreationTime`、`Attributes`等）的属性外，这些信息类还提供了实例方法，这些方法对应于`File`和`Directory`的许多静态方法。例如，如果你有一个`FileInfo`，它提供了`Delete`、`Encrypt`和`Decrypt`等方法，这些方法的工作方式与它们的`File`名称相同，只是你不需要传递路径参数。还有一个名为`MoveTo`的对应方法，尽管名字不同，但功能相同。

`FileInfo`还提供了与使用`Stream`或`FileStream`打开文件的各种辅助方法的等效方法，例如`AppendText`、`OpenRead`和`OpenText`。也许更令人惊讶的是，`Create`和`CreateText`也是可用的。事实证明，你可以为尚不存在的文件构造一个`FileInfo`，然后使用这些辅助方法创建它。它不会尝试填充描述文件的任何属性，直到你尝试读取它们的第一次，因此它会推迟在那一点抛出`FileNotFound​Ex⁠ception`，以防你创建`FileInfo`是为了创建新文件。

如你所料，`DirectoryInfo`也提供了实例方法，这些方法对应于`Directory`定义的各种静态辅助方法。

## 已知文件夹

桌面应用程序有时需要使用特定的文件夹。例如，应用程序的设置通常存储在用户配置文件夹的特定文件夹中。有一个专门用于系统范围应用程序设置的文件夹。在 Windows 上，这些通常位于用户的*AppData*文件夹和*C:\ProgramData*文件夹中。Windows 还定义了图片、视频、音乐和文档的标准位置，还有代表特殊外壳功能的文件夹，例如桌面和用户的“收藏夹”。

尽管这些文件夹在不同系统中通常位于相同位置，但你不应假设它们会出现在你期望的位置。（因此，在真实代码中，你不应像示例 15-15 那样做。）许多这些文件夹在 Windows 的本地化版本中有不同的名称。甚至在特定语言中，也不能保证这些文件夹会出现在通常的位置——有些文件夹是可以移动的，并且它们的位置在不同版本的 Windows 中并不固定。

因此，如果需要访问特定的标准文件夹，应使用`Environment`类的`GetFolderPath`方法，如示例 15-17 中所示。这个方法接受来自嵌套的`Environment.SpecialFolder`枚举类型的成员，该枚举定义了 Windows 中所有已知文件夹类型的值。

##### 示例 15-17\. 发现存储设置的位置

```cs
string appSettingsRoot =
    Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
string myAppSettingsFolder =
    Path.Combine(appSettingsRoot, @"Endjin\FrobnicatorPro");
```

###### 注意

在非 Windows 系统上，对于大多数此枚举条目，`GetFolderPath` 返回空字符串，因为没有本地等效项。但是，有些项确实有效，比如 `MyDocuments`，`Common​Ap⁠plicationData` 和 `UserProfile`。

`ApplicationData` 文件夹位于用户配置文件的漫游部分。不需要在用户使用的所有计算机上复制的信息（例如，如果需要可以重建的缓存），应放在本地部分，可以使用 `LocalApplicationData` 枚举项获取。

# 序列化

`Stream`、`TextReader` 和 `TextWriter` 类型提供了在文件、网络或其他类似流的任何东西中读取和写入数据的能力，只要提供一个适当的具体类。但这些抽象仅支持字节或文本数据。假设您有一个具有多个类型属性的对象，包括一些数值类型，可能还包括对其他对象的引用，其中一些可能是集合。如果您希望将该对象的所有信息写入文件或通过网络连接发送，以便稍后在同一类型的对象和相同属性值的计算机上或连接的另一端重新构建该对象，该怎么办？

您可以使用本章中显示的抽象来完成此操作，但这需要相当多的工作。您需要编写代码来读取每个属性并将其值写入到 `Stream` 或 `TextWriter` 中，并且需要将值转换为二进制或文本。您还需要决定您的表示方式——您只是按固定顺序写入值，还是会设计一种方案来写入名称/值对，以便在日后需要添加更多属性时不受限制？您还需要想出处理集合和对其他对象的引用的方法，并且需要决定在面对循环引用时应采取的措施——如果两个对象互相引用，简单的代码可能会陷入无限循环。

.NET 提供了几种解决此问题的方案，每种方案在能够支持的场景复杂性、版本控制的处理能力以及与其他平台的互操作性方面存在不同的权衡。这些技术都属于广义上的*序列化*（因为它们涉及将对象的状态按顺序写入某种形式的数据存储中——序列化——例如 `Stream`）。多年来在 .NET 中引入了许多不同的机制，所以我不会涵盖所有内容。我只会介绍最能代表特定方法处理该问题的几种方式。

## BinaryReader、BinaryWriter 和 BinaryPrimitives

虽然它们不严格属于序列化形式，但任何关于此领域的讨论都不完整，没有涵盖`BinaryReader`和`BinaryWriter`类，因为它们解决了任何序列化和反序列化对象尝试必须处理的基本问题：它们可以将 CLR 的内置类型转换为字节流，`BinaryPrimitives`也做同样的事情，但它能够处理`Span<byte>`和相关类型，这些在第十八章中讨论过内存效率。

`BinaryWriter`是围绕可写的`Stream`的包装器。它提供了一个`Write`方法，支持除了`object`类型以外的所有内置类型的重载。因此，它可以接受任何数值类型、`string`、`char`或`bool`类型的值，并将该值的二进制表示写入`Stream`中。它还可以写入`byte`或`char`类型的数组。

`BinaryReader`是围绕可读的`Stream`的包装器，提供了各种用于读取数据的方法，每种方法对应于`BinaryWriter`提供的`Write`的重载。例如，您有`ReadDouble`、`ReadInt32`和`ReadString`等方法。

要使用这些类型，当您想要序列化一些数据时，可以创建一个`BinaryWriter`，并写入每个要存储的值。稍后当您想要反序列化该数据时，可以围绕包含写入的数据的流创建一个`BinaryReader`，并按照与首次写出数据时完全相同的顺序调用相关的读取方法。

`BinaryPrimitives`的工作方式略有不同。它专为需要最小化堆分配数量的代码设计，因此它不是一个包装器类型，而是一个静态类，提供了广泛的方法，如`ReadInt32LittleEndian`和`WriteUInt16BigEndian`。这些方法分别接受`ReadOnlySpan<byte>`和`Span<byte>`参数，因为它设计为直接处理内存中的数据（不一定是包装在`Stream`中）。然而，其基本原理是相同的：它在字节序列与基本的.NET 类型之间进行转换。（另外，字符串处理相对复杂：没有`ReadString`方法，因为返回`string`的任何方法都会在堆上创建一个新的字符串对象，除非有一个预先分配并反复分配的固定字符串集。有关详细信息，请参见第十八章。）

这些类仅解决了如何以二进制形式表示各种内置类型的问题。您仍然需要解决如何表示整个对象以及如何处理对象之间的引用等更复杂的结构。

## CLR 序列化

CLR 序列化如其名称所示，是内置到运行时本身的特性——它不仅仅是一个库功能。虽然它自.NET Framework 1.0 起就存在，但在最初几个版本的.NET Core 中并未支持，但微软最终以一种较简化的形式将其重新添加回去，以便更轻松地从.NET Framework 迁移应用程序。微软不鼓励使用它，但在某些场景中它仍然很受欢迎。在微服务环境中，它被广泛用于跨服务边界发送异常和相对简单的数据结构。.NET Core 和.NET 提供的有限支持针对这些场景，因此你不能对任意的.NET 对象进行序列化。

CLR 序列化最有趣的方面是它直接处理对象引用。如果你序列化一个`List<SomeType>`，其中列表中的多个条目引用同一个对象，CLR 序列化会检测到这一点，只存储该对象的一个副本，在反序列化时会重新创建这个一个对象多个引用的结构。（基于非常广泛使用的 JSON 格式的序列化系统通常不会这样做。）

类型需要选择 CLR 序列化。.NET 定义了一个`[Serializable]`属性，必须存在，一旦你添加了这个属性，CLR 就可以为你处理所有细节。序列化直接使用对象的字段。它使用反射来访问所有字段，无论是公共的还是私有的。`BinaryFormatter`类型（位于`System.Runtime.Serialization.Formatters.Binary`命名空间中）提供了一个`Serialize`方法，可以将任何可序列化类型的实例写入流中。它正确地检测到循环引用，在流中仅存储每个对象的一个副本。当我们将生成的流传递给`Deserialize`方法时，它将正确地恢复任何这样的结构。

因此这非常强大——通过添加一个属性，我可以将整个对象图写出来。但也有缺点：如果我改变了任何被序列化类型的实现，那么当新版本的代码尝试反序列化旧版本生成的流时，我会遇到问题。因此，这并不适合将应用程序的设置写入磁盘，因为这些设置可能会随着每个新版本而演变。实际上，你可以定制序列化的方式，这样可以支持版本控制，但到了这一步，你又要手工完成大部分工作。（实际上使用`BinaryReader`和`BinaryWriter`可能更容易。）此外，使用这种序列化方式很容易引入安全问题：控制反序列化流的人基本上可以完全控制你对象的所有字段。文档指出，`BinaryFormatter`“不安全且无法安全使用”，当你尝试使用它时会看到弃用警告。因此，我在这里只是描述 CLR 序列化，因为尽管微软试图终止它，但它仍然在使用，而且因为它的存在意味着你可能对对象创建有所假设——特别是引用类型只能通过其构造函数或通过`MemberwiseClone`创建，但事实证明这并非正确。

CLR 序列化的另一个问题是它生成的二进制流是.NET 特定的格式。如果需要处理该流的代码仅在.NET 上运行，那么这不是问题，但你可能希望生成更广泛受众使用的流。除了 CLR 序列化外，还有其他的序列化机制，这些机制可以生成其他系统更容易消费的流。

## JSON

JSON（JavaScript 对象表示法）是一种非常广泛使用的序列化格式，.NET 运行时库提供了在`System.Text.Json`命名空间中处理它的支持。⁶ 它提供了三种处理 JSON 数据的方式。

`Utf8JsonReader`和`Utf8JsonWriter`类型是类似流的抽象，它们将 JSON 数据内容表示为一系列元素。如果需要处理太大无法一次性加载到内存中的 JSON 文档，它们非常有用。它们构建在第十八章描述的内存高效机制上，该章包括一个完整示例，展示了如何使用这些类型处理 JSON。这是一个非常高性能的选择，但使用起来并不是最容易的。

###### 注意

正如名称所示，这些类型使用 UTF-8 编码来读取和写入 JSON。这是发送和存储 JSON 数据最广泛使用的编码方式，因此所有 `System.Text.Json` 都针对其进行了优化。因此，性能敏感的代码通常应避免在 .NET `string` 中获取 JSON 文档，因为这将使用 UTF-16 编码，需要在您可以使用这些 API 之前转换为 UTF-8。

还有 `JsonSerializer` 类，它在整个 .NET 对象和 JSON 之间进行转换。它要求您定义的类结构与 JSON 对应。

最后，`System.Text.Json` 提供了可以提供 JSON 文档结构描述的类型。当您在开发时不确定 JSON 数据结构的确切形式时，这些类型非常有用，因为它们提供了一个灵活的对象模型，可以适应任何形状的 JSON 数据。事实上，有两种方法可以实现这种方法。我们有 `JsonDocument`、`JsonElement` 和相关类型，提供了一种高效的只读机制，用于检查 JSON 文档，以及更灵活但略显低效的 `JsonNode`，它是可写的，使您可以从头开始构建 JSON 的描述，或者读入一些 JSON 然后修改它。

### JsonSerializer

`JsonSerializer` 提供了一种基于属性的序列化模型，您可以在其中定义一个或多个类，反映您需要处理的 JSON 数据的结构，然后可以在这些模型之间进行 JSON 数据的转换。

示例 15-18 展示了一个简单的模型，适合与 `JsonSerializer` 一起使用。正如您所见，我不必使用任何特定的基类，也没有强制要求的属性。

##### 示例 15-18\. 简单的 JSON 序列化模型

```cs
public class SimpleData
{
    public int Id { get; set; }
    public IList<string>? Names { get; set; }
    public NestedData? Location { get; set; }
    public IDictionary<string, int>? Map { get; set; }
}

public class NestedData
{
    public string? LocationName { get; set; }
    public double Latitude { get; set; }
    public double Longitude { get; set; }
}
```

示例 15-19 创建了此模型的一个实例，然后使用 `JsonConvert` 类的 `Serialize` 方法将其序列化为字符串。

##### 示例 15-19\. 使用 `JsonSerializer` 序列化数据

```cs
var model = new SimpleData
{
    Id = 42,
    Names = new[] { "Bell", "Stacey", "her", "Jane" },
    Location = new NestedData
    {
        LocationName = "London",
        Latitude = 51.503209,
        Longitude = -0.119145
    },
    Map = new Dictionary<string, int>
    {
        { "Answer", 42 },
        { "FirstPrime", 2 }
    }
};

string json = JsonSerializer.Serialize(
    model,
    new JsonSerializerOptions { WriteIndented = true });
Console.WriteLine(json);
```

`Serialize` 的第二个参数是可选的。我在这里使用它来缩进 JSON，使其更易于阅读。（默认情况下，`JsonSerializer` 将使用更高效的布局，没有不必要的空格，但这样更难阅读。）结果如下所示：

```cs
{
  "Id": 42,
  "Names": [
    "Bell",
    "Stacey",
    "her",
    "Jane"
  ],
  "Location": {
    "LocationName": "London",
    "Latitude": 51.503209,
    "Longitude": -0.119145
  },
  "Map": {
    "Answer": 42,
    "FirstPrime": 2
  }
}
```

正如您所见，每个 .NET 对象都变成了一个 JSON 对象，其中名称/值对应于模型中的属性。数字和字符串的表示与您的预期完全一致。`IList<string>` 变成了一个 JSON 数组，而 `IDictionary<string, int>` 则变成了另一个 JSON 字典。我在这些集合中使用了接口，但您也可以使用具体的 `List<T>` 和 `Dictio⁠nary​<TKey,TValue>` 类型。如果您喜欢，也可以使用普通的数组来表示列表。我倾向于使用接口，因为这样可以自由地使用任何集合类型（例如，示例 15-19 使用字符串数组初始化了 `Names` 属性，但也可以使用 `List<string>` 而不更改模型类型）。

将序列化后的 JSON 转换回模型同样简单，正如 示例 15-20 所示。

##### 示例 15-20\. 使用 `JsonSerializer` 反序列化数据

```cs
var deserialized = JsonSerializer.Deserialize<SimpleData>(json);
```

尽管如此简单的模型通常就足够了，但有时您可能需要控制序列化的某些方面，特别是在使用外部定义的 JSON 格式时。例如，您可能需要与使用与 .NET 不同的命名约定的 JSON API 一起工作——驼峰命名法很受欢迎，但与 .NET 属性的帕斯卡命名法冲突。解决此问题的一种方法是使用 `JsonPropertyName` 属性来指定在 JSON 中使用的名称，如 示例 15-21 所示。

##### 示例 15-21\. 使用 `JsonPropertyName` 属性控制 JSON

```cs
public class NestedData
{
 [JsonPropertyName("locationName")]
    public string? LocationName { get; set; }

 [JsonPropertyName("latitude")]
    public double Latitude { get; set; }

 [JsonPropertyName("longitude")]
    public double Longitude { get; set; }
}
```

在序列化时，`JsonSerializer` 会使用 `JsonPropertyName` 中指定的名称，并在反序列化时寻找这些名称。这种方法完全控制了 .NET 和 JSON 属性的命名，但在特定情况下也有更简单的解决方案。这种仅更改首字母大小写的重命名是如此常见，以至于可以让 `JsonSerializer` 来完成。传递给 `JsonSerializer.Serialize` 的 `JsonSerializationOptions` 可以选择使用 `JsonSerializerDefaults` 类型的可选构造函数参数，如果像 示例 15-22 中那样传递 `JsonSeri⁠ali⁠zerDefaults.Web`，将会得到驼峰样式的命名，而无需使用任何属性。

##### 示例 15-22\. 使用 `JsonSerializerDefaults` 来获取驼峰式属性名称

```cs
var options = new JsonSerializerOptions(JsonSerializerDefaults.Web)
{
    WriteIndented = true
};
string json = JsonSerializer.Serialize(
    model,
    options);
```

`JsonSerializerOptions` 还提供了处理循环引用的方法。假设你要序列化 `SelfRef` 类型的对象，如 示例 15-23 所示。

##### 示例 15-23\. 支持循环引用的类型

```cs
public class SelfRef
{
    public string? Name { get; set; }
    public SelfRef? Next { get; set; }
}
```

默认情况下，如果试图序列化直接或间接引用彼此的对象，将会收到 `JsonException` 报告可能存在循环。它说“可能”是因为默认情况下它不直接检测循环，而是 `JsonSerializer` 对任何对象图的深度都有一个限制。这可以通过 `JsonSerializerOptions.MaxDepth` 属性进行配置，但默认情况下，如果超过 64 个对象的深度，序列化器将报告错误。但是，可以通过设置 `ReferenceHandler` 来更改其行为。示例 15-24 将此设置为 `ReferenceHandler.Preserve`，使其能够序列化相互引用的 `SelfRef` 实例对。

##### 示例 15-24\. 序列化支持循环引用的类型

```cs
var options = new JsonSerializerOptions(JsonSerializerDefaults.Web)
{
    WriteIndented = true,
    ReferenceHandler = ReferenceHandler.Preserve
};
var circle = new SelfRef
{
    Name = "Top",
    Next = new SelfRef
    {
        Name = "Bottom",
    }
};
circle.Next.Next = circle;
string json = JsonSerializer.Serialize(circle, options);
```

为实现此目的，`JsonSerializer` 通过添加一个 `$id` 属性为对象分配标识符：

```cs
{
  "$id": "1",
  "name": "Top",
  "next": {
    "$id": "2",
    "name": "Bottom",
    "next": {
      "$ref": "1"
    }
  }
}
```

这使得序列化器在遇到循环引用时能够避免问题。每当它需要序列化属性时，它会检查该属性是否引用了已经写出的对象（或正在写出的对象）。如果是这样，而不是尝试再次写出对象（这将导致无限循环，因为它会不断遇到循环引用），序列化器会发出一个 JSON 对象，其中包含一个特殊名称为 `$ref` 的属性，指向相关的 `$id`。这不是 JSON 的普遍支持形式，因此 ID 生成默认情况下未启用。

你可以使用 `JsonSerializerOptions` 控制序列化的许多其他方面，例如为数据类型定义自定义序列化机制。例如，你可能想在 C# 代码中表示某些内容为 `DateTimeOffset`，但希望在 JSON 中将其变为带有特定日期时间格式的字符串。详细信息可以在 `System.Text.Json` 文档中找到。

### JSON 文档对象模型

`JsonSerializer` 要求你定义一个或多个类型来表示你想处理的 JSON 结构，而 `System.Text.Json` 则提供了一组固定类型，支持更动态的方法。你可以构建一个文档对象模型（DOM），其中诸如 `JsonElement` 或 `JsonNode` 的类型实例表示 JSON 的结构。

`System.Text.Json` 提供了两种构建 DOM 的方式。如果你已经有 JSON 格式的数据，可以使用 `JsonDocument` 类获取 JSON 的只读模型，其中每个对象、值和数组都表示为 `JsonElement`，而对象中的每个属性则表示为 `JsonProperty`。示例 15-25 使用 `JsonDocument` 调用 `RootElement.EnumerateObject()` 来发现 JSON 根对象中的所有属性。这返回一个 `JsonProperty` 结构的集合。

##### 示例 15-25\. 使用 `JsonDocument` 和 `JsonElement` 进行动态 JSON 检查

```cs
using (JsonDocument document = JsonDocument.Parse(json))
{
    foreach (JsonProperty property in document.RootElement.EnumerateObject())
    {
        Console.WriteLine($"Property: {property.Name} ({property.Value.ValueKind})");
    }
}
```

运行这段代码，处理早期示例生成的序列化文档后，会产生以下输出：

```cs
Property: id (Number)
Property: names (Array)
Property: location (Object)
Property: map (Object)
```

正如所示，我们能够在运行时发现存在的属性。`JsonProperty.Value` 返回一个 `JsonElement` 结构，可以检查其 `ValueKind` 来确定其所表示的 JSON 值类型。如果是数组，可以通过调用 `EnumerateArray` 枚举其内容；如果是字符串值，可以通过调用 `GetString` 读取其值。Example 15-26 使用这些方法展示了 `names` 属性中的所有字符串。

##### Example 15-26\. 使用 `JsonDocument` 和 `JsonElement` 动态枚举 JSON 数组

```cs
JsonElement namesElement = document.RootElement.GetProperty("names");
foreach (JsonElement name in namesElement.EnumerateArray())
{
    Console.WriteLine($"Name: {name.GetString()}");
}
```

正如本例还展示的那样，如果事先知道某个属性肯定存在，就无需使用 `EnumerateObject` 来查找它：可以直接调用 `GetProperty`。对于可选属性，还有 `TryGetProperty` 方法。Example 15-27 使用了两者：将根对象的 `location` 属性视为可选，但如果存在，还需要 `locationName`、`latitude` 和 `longitude` 属性。

##### Example 15-27\. 使用 `JsonElement` 读取 JSON 属性

```cs
if (root.TryGetProperty("location", out JsonElement locationElement))
{
    JsonElement nameElement = locationElement.GetProperty("locationName");
    JsonElement latitudeElement = locationElement.GetProperty("latitude");
    JsonElement longitudeElement = locationElement.GetProperty("longitude");
    string locationName = nameElement.GetString()!;
    double latitude = latitudeElement.GetDouble();
    double longitude = longitudeElement.GetDouble();
    Console.WriteLine($"Location: {locationName}: {latitude},{longitude}");
}
```

除了结构元素、对象和数组之外，在 [JSON 规范](https://oreil.ly/T1Qoe) 中的数据模型还识别四种基本数据类型：字符串、数字、布尔和 null。正如您所见，可以使用 `Kind` 属性确定 `JsonElement` 所表示的基本数据类型之一。如果是基本数据类型之一，可以使用相应的 `Get` 方法。最后两个示例都使用了 `GetString`，第二个示例还使用了 `GetDouble`。可以使用多种方法来获取数字：如果预期是整数，可以调用 `GetSByte`、`GetInt16`、`GetInt32` 或 `GetInt64`（也有无符号版本），具体取决于预期的值范围。还有 `GetDecimal` 方法。

`JsonElement` 还提供了读取特定格式字符串属性的方法：`GetGuid`、`GetDateTime`、`GetDateTimeOffset` 和 `GetBytesFromBase64`。

所有的 `Get` 方法如果数值不符合所需格式，都会抛出 `InvalidOperationException` 异常。它们都有对应的 `TryGet` 形式，可以在数据无法按预期方式解析时进行检测，而无需触发异常。

这些类型试图最小化分配的内存量。`JsonElement`和`JsonProperty`都是结构体，因此您可以在不引起额外堆分配的情况下获取它们。`JsonDocument`通过 UTF-8 格式保存底层数据，并且`JsonElement`和`JsonProperty`实例只是引用该数据，避免了分配相关数据的副本的需要。显然，底层数据确实需要存放在某处，并且根据您如何加载 JSON 到`JsonDocument`中的方式，可能需要分配一些内存来存放它。（例如，您可以传递一个`Stream`，由于并非所有流都可重播，`JsonDocument`可能需要复制流的内容。）`JsonDocument`使用.NET 运行库中可用的缓冲池特性来管理这些数据，这意味着如果应用程序解析许多 JSON 文档，它可能能够重用内存，减少垃圾收集器（GC）的压力。但这也意味着`JsonDocument`需要知道您何时完成对 JSON 的处理，以便可以将缓冲区返回到池中。这就是在使用`JsonDocument`时为什么要使用`using`语句的原因。

###### 警告

请注意，`JsonElement.GetString`比所有其他`Get`方法都更昂贵，因为它必须在堆上创建一个新的.NET 字符串。其他`Get`方法都返回值类型，因此它们不会导致堆分配。

我之前提到有两种处理 JSON DOM 的方式。`JsonDocument`提供了一个只读模型，允许您检查现有的 JSON。但还有`JsonNode`，它是可读/写的。您可以使用它的方式是`JsonDocument`不支持的。您可以从头开始建立一个对象模型来创建一个新的 JSON 文档。或者，您可以像使用`JsonDocument`一样解析现有的 JSON 到对象模型中，但是当您使用`JsonNode`时，结果模型是可修改的。因此，您可以使用它来加载一些 JSON 并对其进行修改，正如示例 15-28 所示。

##### 示例 15-28\. 使用`JsonNode`修改 JSON

```cs
JsonNode rootNode = JsonNode.Parse(json)!;
JsonNode mapNode = rootNode["map"]!;
mapNode["iceCream"] = 99;
```

这会将`json`中的 JSON 文本加载到`JsonNode`中，然后检索`map`属性。（此示例期望与前面示例中使用的 JSON 形式相同，其中属性名称为驼峰式命名。）到目前为止，这并没有做任何我们不能用`JsonDocument`做的事情。但最后一行在`map`对象中添加了一个新条目。正是这种修改文档的能力使`JsonNode`更加强大。那么如果`JsonNode`更强大，为什么还需要`JsonDocument`呢？这种能力是有代价的：`JsonNode`效率较低，因此如果不需要额外的灵活性，就不应使用它。

使用只读的`JsonDocument`和`JsonElement`或可写的`JsonNode`的主要优势在于，你无需定义任何类型来建模数据。它们还能更轻松地编写以数据结构驱动行为的代码，因为这些 API 能描述它们所找到的内容。只读形式通常比`JsonSerializer`更高效，因为在从 JSON 文档读取数据时可能能减少对象分配。

# 概要

`Stream`类是表示数据的字节序列的抽象。流可以支持读取、写入或两者，并且可以支持定位到任意偏移量以及直接的顺序访问。`TextReader`和`TextWriter`提供严格的字符数据顺序读取和写入，抽象化字符编码。这些类型可以位于文件、网络连接、内存之上，或者你可以实现自己版本的这些抽象类。`FileStream`类还提供一些其他的文件系统访问功能，但为了完全控制，我们还有`File`和`Directory`类。当字节和字符串不足时，.NET 提供各种序列化机制，可以自动映射对象在内存中的状态与可以写入磁盘或发送到网络或任何其他类似流目标的表示之间的关系；这种表示后来可以转换回相同类型的对象，并且具有等效的状态。

正如你所看到的，一些文件和流 API 提供了异步形式，可以帮助提升性能，特别是在高并发系统中。下一章将讨论并发性、并行性以及这些 API 的异步形式所使用的基于任务的模式。

¹ 你可能认为井号是#，但如果像我一样是英国人，那就不对了。这就像有人坚持把@称为美元符号一样。Unicode 对#的官方名称是*number sign*，它还允许使用我偏爱的选项*hash*，以及*octothorpe*、*crosshatch*，以及遗憾的是*英镑符号*。

² 以防你还不知道这个术语，在*小端*表示中，多字节值以低位字节开始，因此在 16 位小端中，值 0x1234 将是 0x34、0x12，而大端版本将是 0x12、0x34。小端看起来是颠倒的，但它是 Intel 处理器的本地格式。

³ 一些 Unicode 字符在 UTF-8 中可以占据最多 4 个字节，因此乘以三似乎可能低估了。然而，所有这些字符在 UTF-16 中都需要两个代码单元。在.NET 中的任何单个`char`在 UTF-8 中最多只需要 3 个字节。

⁴ 当 .NET 2.0 引入了一种新的操作系统句柄表示方式时，四种重载方法变得过时了。那时接受 `IntPtr` 的重载方法被弃用，取而代之的是接受 `SafeFileHandle` 的新方法。

⁵ 这些方法都返回一个相对于计算机当前时区的 `DateTime`。每个方法都有一个相应的等效方法，返回相对于时区零的时间（例如 `GetCreationTimeUtc`）。

⁶ 这在 .NET Framework 上不可用。在那里，开源的 JSON.NET 项目，在 [Newtonsoft 网站](https://oreil.ly/LpJfk) 或通过 NuGet 的 `Newtonsoft.Json`，是一个受欢迎的选择。
