# 第九章：委托、Lambda 和事件

使用 API 的最常见方法是调用其类提供的方法和属性，但有时需要反向操作——API 可能需要调用您的代码，这种操作通常称为*回调*。在第五章中，我展示了数组和列表提供的搜索功能。为了使用这些功能，我编写了一个方法，在其参数满足我的条件时返回`true`，相关的 API 会为每个检查的项调用我的方法。并非所有的回调都是如此即时的。异步 API 在长时间运行的工作完成时可以调用我们代码中的方法。在客户端应用程序中，我希望我的代码在用户以特定方式与某些视觉元素交互时运行，例如点击按钮。

接口和虚方法可以实现回调。在第四章中，我展示了`IComparer<T>`接口，它定义了一个`CompareTo`方法。像`Array.Sort`这样的方法在我们需要定制排序顺序时会调用它。您可以想象一个 UI 框架，它定义了一个`IClickHandler`接口，具有一个`Click`方法，可能还有`DoubleClick`。如果我们希望被通知按钮点击，框架可以要求我们实现此接口。

实际上，没有.NET 的 UI 框架使用基于接口的方法，因为当你需要多种类型的回调时，这种方法变得很麻烦。单击和双击只是用户交互的冰山一角——在 WPF 应用程序中，每个 UI 元素可以提供超过 100 种通知方式。大多数时候，您只需要处理来自任何特定元素的一个或两个事件，所以一个有 100 个方法需要实现的接口会很烦人。

将通知分散到多个接口可能会减少这种不便。默认接口实现可能会有所帮助，因为它可以提供所有回调的默认空实现，这意味着我们只需要覆盖我们感兴趣的那些。(.NET Standard 2.0 和 .NET Framework 都不支持这种语言特性，但一个针对这些目标的库可以提供一个带有虚方法的基类。) 但即使有了这些改进，这种面向对象的方法仍然存在严重的缺点。想象一个 UI 有四个按钮。在一个使用我刚才描述的方法的假设 UI 框架中，如果你希望每个按钮都有自己的点击处理程序，你需要四个不同的`IClickHandler`接口的实现类。一个类只能实现特定接口一次，所以你需要编写四个类。当我们真正想要做的是告诉一个按钮在点击时调用特定的方法时，这似乎非常麻烦。

C#提供了一个更简单的解决方案，即 *委托*，它是对方法的引用。如果你希望库为任何原因调用你的代码，通常你只需传递一个委托引用到你想让它调用的方法。我在第五章中展示了一个例子，我在示例 9-1 中重现了它。这个例子找到了一个`int[]`数组中第一个大于零的元素的索引。

##### 示例 9-1\. 使用委托搜索数组

```cs
public static int GetIndexOfFirstNonEmptyBin(int[] bins) =>
    Array.FindIndex(bins, IsGreaterThanZero);

private static bool IsGreaterThanZero(int value) => value > 0;
```

乍一看，这似乎非常简单：`Array.FindIndex`的第二个参数需要一个方法，它可以调用以询问特定元素是否匹配，因此我传递了我的`IsGreaterThanZero`方法作为参数。但是传递方法真正意味着什么，以及它如何与.NET 的类型系统，CTS 结合在一起？

# 委托类型

示例 9-2 显示了在示例 9-1 中使用的`FindIndex`方法的声明。第一个参数是要搜索的数组，但我们感兴趣的是第二个参数，那就是我传递了一个方法。

##### 示例 9-2\. 带有委托参数的方法

```cs
public static int FindIndex<T>(
      T[] array,
      `Predicate``<``T``>` `match`)
```

方法的第二个参数的类型是`Predicate<T>`，其中`T`是数组元素的类型，因为示例 9-1 使用了`int[]`，所以这将是一个`Predicate<int>`。（如果你对形式逻辑或计算机科学没有背景的话，这种类型使用 *predicate* 这个词表示一个函数，用来确定某件事是真还是假。例如，你可以有一个判断一个数是否为偶数的 predicate。这些谓词经常在这种过滤操作中使用。）示例 9-3 展示了如何定义这种类型。这是整个定义，不是摘录；如果你想写一个等同于`Predicate<T>`的类型，那么你只需要写这些。

##### 示例 9-3\. `Predicate<T>`委托类型

```cs
public delegate bool Predicate<in T>(T obj);
```

分解示例 9-3，我们像往常一样从可访问性开始，我们可以使用所有其他类型的关键字，例如`public`或`internal`。（像任何类型一样，委托类型可以选择地嵌套在其他类型中，在这种情况下，你也可以使用`private`或`protected`。）接下来是`delegate`关键字，告诉 C#编译器我们正在定义一个委托类型。定义的其余部分看起来不偶然，就像一个方法声明。我们有一个`bool`的返回类型。你把委托类型的名称放在你通常看到方法名称的地方。尖括号表示这是一个具有单个类型参数`T`的泛型类型，并且`in`关键字指示`T`是逆变的。最后，方法签名有一个该类型的单个参数。

###### 提示

在这里使用逆变性使您能够使用比通常所需更一般的谓词。例如，因为所有`string`类型的值都与`object`类型兼容，所以所有`Predicate<object>`类型的值也与`Predicate<string>`类型兼容。或者简单地说，如果一个 API 需要检查一个`string`的方法，那么如果您传递一个能够检查任何`object`的方法，它也能完美运行。第六章详细描述了逆变性。

委托类型在.NET 中是特殊的，并且它们的工作方式与类或结构完全不同。编译器生成一个表面上看起来正常的类型定义，其中包含各种我们稍后将详细讨论的成员，但是所有这些成员都是空的——C#不会为任何这些成员生成 IL。CLR 在运行时提供实现。

委托类型的实例通常称为委托，并且它们引用方法。如果方法的签名匹配，那么该方法与（即可由特定委托类型的实例引用）特定委托类型兼容。示例 9-1 中的`IsGreaterThanZero`方法接受一个`int`并返回一个`bool`，因此它与`Predicate<int>`兼容。匹配不必精确。如果参数类型可以进行隐式引用转换，则可以使用更一般的方法。（尽管这听起来与`T`逆变性的要点非常相似，但这是一个微妙不同的问题。在`Predicate<T>`中，`T`的逆变性确定了现有的`Predicate<T>`实例可以被转换成哪些类型。这与您是否可以从特定方法构造某个特定类型的新委托的规则是分开的：我现在描述的签名匹配规则即适用于非泛型委托，也适用于具有不变类型参数的泛型委托。）例如，一个返回类型为`bool`，单个参数类型为`object`的方法将与`Predicate<object>`兼容，但因为这样的方法可以接受`string`参数，它也将与`Predicate<string>`兼容。（它不会与`Predicate<int>`兼容，因为从`int`到`object`没有隐式引用转换。有一个隐式转换，但这是一个装箱转换，而不是引用转换。）

## 创建委托

创建委托的最简单方法是仅编写方法名称。示例 9-4 声明了一个变量`p`，并使用示例 9-1 中的`IsGreaterThanZero`方法对其进行初始化。（此代码要求`IsGreaterThanZero`在作用域内，因此我们只能在同一个类中编写此代码。）

##### 示例 9-4\. 创建委托

```cs
var p = IsGreaterThanZero;
```

这个示例没有提到特定需要的委托类型，这导致编译器从我将在本章后面描述的几组泛型类型中选择一个。¹ 在您无法使用这些类型的罕见情况下，它会为您定义一个类型。在这种情况下，它将使用`Func<int, bool>`，反映了`IsGreaterThanZero`是一个接受`int`并返回`bool`的方法。这是一个合理的选择，但如果我想使用`Predicate<int>`类型，因为我打算将其传递给`Array.FindIndex`，如示例 9-1 中所示，如果您不想使用编译器的默认选择，可以使用`new`关键字，正如示例 9-5 所示。这允许您声明类型，并在通常传递构造函数参数的地方，您可以提供兼容方法的名称。

##### 示例 9-5\. 构造委托

```cs
var p = new Predicate<int>(IsGreaterThanZero);
```

在实际应用中，我们很少对委托使用`new`关键字。只有在编译器无法推断出正确的委托类型时才是必需的。通常情况下，编译器可以从上下文中推断出正确的类型。示例 9-6 声明了一个带有显式类型的变量，因此编译器知道需要一个`Predicate<int>`类型 —— 我们不需要在这里使用`new`关键字。这将编译成与示例 9-5 相同的代码。

##### 示例 9-6\. 隐式委托构造

```cs
Predicate<int> p = IsGreaterThanZero;
```

这仍然明确提到了委托类型的名称，但通常我们甚至不需要这样做。示例 9-1 正确确定`IsGreaterThanZero`需要转换为`Predicate<int>`，而无需我们明确说明。编译器知道`FindIndex`的第二个参数是`Predicate<T>`，并且因为我们提供了类型为`int[]`的第一个参数，它推断出`T`是`int`，因此知道第二个参数的完整类型是`Predicate<int>`。在解决了这个问题后，它使用相同的内置隐式转换规则来构造委托，就像示例 9-6 一样。因此，当您将委托传递给方法时，编译器通常会自动确定正确的类型。

当代码像这样按名称引用方法时，该名称在技术上称为*方法组*，因为一个名称可能存在多个重载。编译器通过查找最佳匹配来缩小范围，类似于调用方法时如何选择重载。与方法调用一样，可能不存在匹配项或存在多个同样好的匹配项，在这些情况下，编译器会产生错误。

方法组可以采用几种形式。在迄今为止的示例中，我使用了未限定的方法名，这仅在所讨论方法在范围内时有效。如果要引用另一个类中定义的静态方法，则需要使用类名限定它，正如 Example 9-7 所示。

##### Example 9-7\. 委托引用另一个类中的方法

```cs
internal class Program
{
    static void Main(string[] args)
    {
        `Predicate``<``int``>` `p1` `=` `Tests``.``IsGreaterThanZero``;`
        `Predicate``<``int``>` `p2` `=` `Tests``.``IsLessThanZero``;`
    }
}

internal class Tests
{
    public static bool IsGreaterThanZero(int value) => value > 0;

    public static bool IsLessThanZero(int value) => value < 0;
}
```

委托不必引用静态方法。它们可以引用实例方法。有几种方法可以实现这一点。一种方法是简单地从处于该方法范围内的上下文中按名称引用实例方法。Example 9-8 中的`GetIsGreaterThanPredicate`方法返回引用`IsGreaterThan`的委托。两者都是实例方法，因此只能与对象引用一起使用，但`GetIsGreaterThanPredicate`具有隐式的`this`引用，并且编译器会自动将其提供给隐式创建的委托。

##### Example 9-8\. 隐式实例委托

```cs
public class ThresholdComparer
{
    public int Threshold { get; set; }

    public bool IsGreaterThan(int value) => value > Threshold;

    public Predicate<int> GetIsGreaterThanPredicate() => IsGreaterThan;
}
```

或者，您可以明确指定您想要的实例。Example 9-9 从 Example 9-8 创建了`ThresholdComparer`类的三个实例，然后为`IsGreaterThan`方法创建了三个委托，每个实例一个。

##### Example 9-9\. 显式实例委托

```cs
var zeroThreshold = new ThresholdComparer { Threshold = 0 };
var tenThreshold = new ThresholdComparer { Threshold = 10 };
var hundredThreshold = new ThresholdComparer { Threshold = 100 };

Predicate<int> greaterThanZero = zeroThreshold.IsGreaterThan;
Predicate<int> greaterThanTen = tenThreshold.IsGreaterThan;
Predicate<int> greaterThanOneHundred = hundredThreshold.IsGreaterThan;
```

您不必局限于形式为`*variableName*.*MethodName*`的简单表达式。您可以取任何评估为对象引用的表达式，然后只需附加`.*MethodName*`；如果对象具有一个或多个名为`*MethodName*`的方法，则将其视为有效的方法组。

###### 注

到目前为止，我只展示了单参数委托，但您可以定义带有任意数量参数的委托类型。例如，运行时库定义了`Comparison<T>`，它比较两个项目，因此需要两个参数（均为类型`T`）。

C#不允许您创建引用实例方法的委托，而不指定您想要的实例（隐式或显式），并且它将始终使用该实例初始化委托。

###### 注

当您将委托传递给其他代码时，该代码无需知道委托的目标是静态方法还是实例方法。对于实例方法，使用委托的代码不会提供实例。引用实例方法的委托始终知道它们引用的实例以及方法。

有另一种创建委托的方式，如果你在运行时并不一定知道要使用哪个方法或对象，这种方式可能会很有用：你可以使用反射 API（我将在第十三章中详细解释）。首先，你获取一个`MethodInfo`，这是表示特定方法的对象。然后调用它的`CreateDelegate`方法，传递委托类型和必要时的目标对象。（如果你要创建一个引用静态方法的委托，就没有目标对象，因此有一个只接受委托类型的重载。）这将创建一个引用`MethodInfo`实例所标识的任何方法的委托。示例 9-10 使用了这种技术。它获取一个`Type`对象（也是反射 API 的一部分；它是引用特定类型的一种方式），表示`ThresholdComparer`类。接下来，它要求该对象获取表示`IsGreaterThan`方法的`MethodInfo`。然后调用它上面的`Create​Dele⁠gate`重载，传递委托类型和目标实例。

##### 示例 9-10\. `CreateDelegate`

```cs
MethodInfo m = typeof(ThresholdComparer).GetMethod("IsGreaterThan")!;
var greaterThanZero = (Predicate<int>) m.CreateDelegate(
    typeof(Predicate<int>), zeroThreshold);
```

还有另一种执行相同工作的方式：`Delegate`类型有一个静态的`CreateDelegate`方法，它避免了获取`MethodInfo`的需要。你传递两个`Type`对象——委托类型和定义目标方法的类型——还有方法名。如果你已经有了`MethodInfo`，那么最好直接使用它，但如果只有方法名，这种替代方式更加方便。

总结到目前为止，委托标识特定的函数，如果这是一个实例函数，委托还包含一个对象引用。但有些委托可以做更多的事情。

## 多播委托

如果你用像 ILDASM 这样的反向工程工具查看任何委托类型，² 你会看到无论是运行库提供的类型还是你自己定义的类型，它们都派生自一个称为`MulticastDelegate`的基类型。顾名思义，这意味着委托可以引用多个方法。这主要在通知场景中很有用，当某个事件发生时可能需要调用多个方法。然而，所有委托都支持这一点，无论你是否需要。

即使具有非`void`返回类型的委托也派生自`MulticastDelegate`。这通常没有太多意义。例如，需要`Predicate<T>`的代码通常会检查返回值。`Array.FindIndex` 使用它来判断元素是否符合搜索条件。如果单个委托引用多个方法，`FindIndex`应该如何处理多个返回值？事实上，它将执行所有方法，但只会返回最后一个方法的返回值。（可以编写代码为多播委托提供特殊处理，但`FindIndex`并未如此。）

多播功能可通过 `Delegate` 类的静态 `Combine` 方法使用。它接受任何两个委托并返回单个委托。当调用结果委托时，就像您依次调用两个原始委托一样。即使您传递给 `Combine` 的委托已经引用多个方法，也可以将其链接在一起形成越来越大的多播委托。如果两个参数中都引用了相同的方法，则生成的组合委托将调用它两次。

###### 注意

委托的组合总是产生一个新的委托。而 `Combine` 方法不会修改您传递的任何一个委托。

实际上，我们很少显式调用 `Delegate.Combine`，因为 C# 内置支持组合委托。您可以使用 `+` 或 `+=` 运算符。示例 9-11 展示了将 示例 9-9 中的三个委托组合成一个多播委托的两种方式。两个结果委托是等效的——这只是展示了两种编写相同内容的方式。这两种情况都编译成对 `Delegate.Combine` 的几次调用。

##### 示例 9-11\. 组合委托

```cs
Predicate<int> megaPredicate1 =
    greaterThanZero + greaterThanTen + greaterThanOneHundred;

Predicate<int> megaPredicate2 = greaterThanZero;
megaPredicate2 += greaterThanTen;
megaPredicate2 += greaterThanOneHundred;
```

您还可以使用 `-` 或 `-=` 运算符，这将产生一个新的委托，它是第一个操作数的副本，但是其对第二个操作数引用的方法的最后引用已被移除。正如您可能猜到的那样，这将转换为对 `Delegate.Remove` 的调用。

## 调用委托

到目前为止，我展示了如何创建一个委托，但是如果您正在编写需要调用来自调用者提供的方法的自己的 API 呢？首先，您需要选择一个委托类型。您可以使用运行时库提供的一个，或者必要时，您可以定义自己的委托类型。然后，您可以将这个委托类型用作方法参数或属性。示例 9-12 展示了当您想要调用委托引用的方法（或方法）时该怎么做。

##### 示例 9-12\. 调用委托

```cs
public static void CallMeRightBack(Predicate<int> userCallback)
{
    `bool` `result` `=` `userCallback``(``42``)``;`
    Console.WriteLine(result);
}
```

正如这个并不十分现实的示例所示，您可以像使用函数一样使用委托类型的参数。这也适用于局部变量、字段和属性。事实上，任何产生委托的表达式后面都可以跟随括号中的参数列表。编译器将生成调用委托的代码。如果委托具有非 `void` 返回类型，则调用表达式的值将是底层方法返回的值（或者，在委托引用多个方法的情况下，将是最终方法返回的值）。

尽管委托是具有运行时生成代码的特殊类型，但调用它们并没有什么神奇之处。调用单目标方法的委托的效果就好像你的代码以传统方式调用目标方法一样。调用多播委托就像依次调用其每个目标方法一样。无论哪种情况，调用都发生在同一个线程上，并且异常以与直接调用方法时完全相同的方式传播出来。

如果你想从多播委托中获取所有返回值，可以控制调用过程。委托提供了`GetInvocationList`方法，该方法返回一个数组，数组中包含每个原始多播委托所引用的单方法委托。如果在普通的、非多播委托上调用此方法，则该列表将只包含一个委托；但如果正在利用多播特性，则可以循环遍历数组，依次调用每个委托。

还有一种偶尔有用的调用委托的方法。基类`Delegate`提供了`DynamicInvoke`方法。你可以在任何类型的委托上调用它，而无需在编译时精确知道需要哪些参数。它接受一个`object[]`类型的`params`数组，因此你可以传递任意数量的参数。它将在运行时验证参数的数量和类型。这可以实现某些后期绑定的场景。通过`dynamic`关键字（在第二章中讨论）启用的内在语言特性更为全面，但由于额外的灵活性，稍微更为复杂，所以如果`DynamicInvoke`正好符合你的需求，那么它是更好的选择。

## 常见委托类型

运行时库提供了几种有用的委托类型，通常情况下你可以使用这些类型而不需要定义自己的委托。例如，有一组名为`Action`的泛型委托，其类型参数数量各不相同。所有这些委托都遵循一个共同的模式：对于每个类型参数，都有一个相应类型的方法参数。示例 9-13 展示了前四个委托，包括零参数形式。

##### 示例 9-13\. 前几个`Action`委托

```cs
public delegate void Action();
public delegate void Action<in T1>(T1 arg1);
public delegate void Action<in T1, in T2 >(T1 arg1, T2 arg2);
public delegate void Action<in T1, in T2, in T3>(T1 arg1, T2 arg2, T3 arg3);
```

尽管这显然是一个开放性的概念——你可以想象具有任意数量参数的这种形式的委托——但 CTS 不提供一种将此类类型定义为模式的方法，因此运行时库必须将每种形式定义为单独的类型。因此，没有`Action`的 200 参数形式。最大的形式有 16 个参数。

`Action`的明显限制是这些类型都有`void`返回类型，因此无法引用返回值的方法。但是有一类类似的委托类型，`Func`，它允许任何返回类型。示例 9-14 展示了这个家族中的前几个委托，正如你所见，它们与`Action`非常相似。它们只是多了一个额外的最终类型参数，`TResult`，用于指定返回类型。与`Action<T>`类似，这些委托可以有多达 16 个参数。

##### 示例 9-14\. 前几个`Func`委托

```cs
public delegate TResult Func<out TResult>();
public delegate TResult Func<in T1, out TResult>(T1 arg1);
public delegate TResult Func<in T1, in T2, out TResult>(T1 arg1, T2 arg2);
public delegate TResult Func<in T1, in T2, in T3, out TResult>(
    T1 arg1, T2 arg2, T3 arg3);
```

这些`Action`和`Func`类型是 C#在可能的情况下用作委托表达式的*自然*类型。你之前在示例 9-4 中看到过这一点，在没有其他指定时，编译器选择了`Func<int, bool>`。它将使用`Action`家族来处理返回类型为`void`的方法。

这两类委托看起来已经涵盖了大多数需求。除非你在编写超过 16 个参数的大型方法，否则你几乎不会需要其他东西。然而，有些情况无法用泛型类型参数来表达。例如，如果你需要一个可以使用`ref`、`in`或`out`参数的委托，你不能简单地写`Func<bool, string, out int>`。这是因为在.NET 中并没有`out int`这样的类型。`out`关键字确切地说明了参数如何传递给方法。泛型类型参数只能指定类型，无法完全传达`in`、`out`和`ref`参数之间的区别。³ 因此，在这些情况下，你必须编写一个匹配的委托类型。

定义自定义委托类型的另一个原因是你不能将`ref struct`作为泛型类型参数使用。(第十八章讨论了这些类型。) 因此，如果你尝试使用`ref struct`类型`Span<int>`实例化泛型`Action<T>`类型，例如写`Action<Span<int>>`，你将会得到一个编译器错误。这种限制存在是因为`ref struct`类型只能在某些情况下使用（它们必须始终存在于堆栈上），而无法确定任何特定的泛型类型或方法是否仅在允许的方式中使用其类型参数。（你可以想象一种新的类型参数约束来表达这一点，但在撰写本文时，还没有这样的约束存在。）因此，如果你需要一个能够引用接受`ref struct`参数的方法的委托类型，它必须是一个专用的非泛型委托。

###### 注意

如果你依赖编译器确定委托表达式的自然类型（例如，你写了`var m = SomeMethod;`），那么这些不能使用`Func`和`Action`委托的情况就是编译器为你生成委托类型的情况。

这些限制中没有一个可以解释为什么运行库定义了一个单独的 `Predicate<T>` 委托类型。`Func<T, bool>` 完全可以很好地工作。有时这种专门的委托类型的存在是历史的偶然：许多委托类型早在添加这些通用的 `Action` 和 `Func` 类型之前就存在了。但这并不是唯一的原因——即使现在也在不断添加新的委托类型。主要原因是有时定义一个专门的委托类型以指示特定语义是很有用的。

如果你有一个 `Func<T, bool>`，你只知道有一个接受 `T` 并返回 `bool` 的方法。但是对于 `Predicate<T>`，有一个暗示的含义：它对该 `T` 实例做出决策，并相应地返回 `true` 或 `false`；并非所有接受单个参数并返回 `bool` 的方法都适合这种模式。通过提供 `Predicate<T>`，你不仅仅是说你有一个具有特定签名的方法；你在说你有一个服务于特定目的的方法。例如，`HashSet<T>`（在 第五章 中描述）有一个 `Add` 方法，接受单个参数并返回 `bool`，因此与 `Predicate<T>` 的签名匹配，但不符合语义。`Add` 的主要工作是执行带有副作用的操作，并返回执行信息，而断言只是告诉你关于值或对象的一些信息。

运行库定义了许多委托类型，其中大多数比 `Predicate<T>` 更专门化。例如，`System.IO` 命名空间及其派生类定义了几个与特定事件相关的委托类型，例如 `SerialPinChangedEventHandler`，仅在处理老式串行端口（如一度无处不在的 RS232 接口）时使用。

## 类型兼容性

委托类型之间不会相互派生。在 C# 中定义的任何委托类型都会直接派生自`MulticastDelegate`，就像运行库中的所有委托类型一样。然而，类型系统通过协变和逆变支持某些泛型委托类型的隐式引用转换。这些规则与接口的规则非常相似。正如示例 9-3 中的 `in` 关键字所示，`Predicate<T>` 中的类型参数 `T` 是逆变的，这意味着如果两个类型 `A` 和 `B` 之间存在隐式引用转换，那么类型 `Predicate<B>` 和 `Predicate<A>` 之间也存在隐式引用转换。示例 9-15 展示了由此启用的隐式转换。

##### 示例 9-15\. 委托协变性

```cs
public static bool IsLongString(object o)
{
    return o is string s && s.Length > 20;
}

static void Main(string[] args)
{
    Predicate<object> po = IsLongString;
    `Predicate``<``string``>` `ps` `=` `po``;`
    Console.WriteLine(ps("Too short"));
}
```

`Main` 方法首先创建一个引用 `IsLongString` 方法的 `Predicate<object>`。该谓词类型的任何目标方法都能检查任何类型的 `object`，因此，显然它能够满足需要检查字符串的代码的需求，因此隐式转换为 `Predicate<string>` 应该成功 —— 这得益于逆变性。协变也与接口的工作方式相同，因此通常与委托的返回类型相关联。我们使用 `out` 关键字表示协变类型参数。所有内置的 `Func` 委托类型都具有协变类型参数 `TResult`，表示函数的返回类型。函数参数的类型参数都是逆变的，所有 `Action` 委托类型的类型参数也是如此。

###### 注意

基于变异的委托转换是隐式引用转换。这意味着当你转换引用时，结果仍然指向同一个委托实例。（所有隐式引用转换都具有这个特性，但并非所有隐式转换都是这样工作的。隐式数值转换会创建目标类型的新实例；隐式装箱转换会在堆上创建一个新的装箱。）因此，在 Example 9-15 中，`po` 和 `ps` 引用堆上的同一个委托。这与将 `IsLongString` 分配给两个变量的方式略有不同 —— 那会创建两个不同类型的委托。

你可能也期望看起来相同的委托是兼容的。例如，`Predicate<int>` 可以引用任何 `Func<int, bool>` 可以使用的方法，反之亦然，因此你可能期望这两种类型之间存在隐式转换。你可能会受到 C# 规范中“委托兼容性”部分的鼓励，该部分指出具有相同参数列表和返回类型的委托是兼容的（事实上，它进一步指出允许某些差异，例如，我之前提到的参数类型可能不同，只要有特定的隐式引用转换可用）。然而，如果你尝试在 Example 9-16 中的代码，它不会工作。

##### Example 9-16\. 非法委托转换

```cs
Predicate<string> pred = IsLongString;
Func<string, bool> f = pred;  // Will fail with compiler error
```

添加显式强制转换也不行 —— 它会移除编译器错误，但你只会得到一个运行时错误。CTS 认为这些是不兼容的类型，因此使用一个委托类型声明的变量不能持有指向不同委托类型的引用，即使它们的方法签名是兼容的（除非涉及到两个委托类型基于相同泛型委托类型并且由于协变或逆变而兼容）。这不是 C# 委托兼容性规则设计的情况 —— 它们主要用于确定特定方法是否可以作为特定委托类型的目标。

“兼容”委托类型之间的类型不兼容可能看起来有些奇怪，但结构上相同的委托类型不一定具有相同的语义，正如我们在`Predicate<T>`和`Func<T,bool>`中已经看到的。如果你发现自己需要执行这种类型的转换，这可能表明你的代码设计有些问题。⁴

## 语法背后

尽管只需一行代码即可定义委托类型（正如示例 9-3 所示），但编译器将其转换为定义了三个方法和一个构造函数的类型。当然，该类型还继承自其基类的成员。所有委托都派生自`MulticastDelegate`，尽管所有有趣的实例成员都来自其基类`Delegate`。（`Delegate`继承自`object`，因此委托也都具有普遍存在的`object`方法。）甚至`GetInvocationList`，一个明显面向多播的特性，也是由`Delegate`基类定义的。

###### 注意

`Delegate`和`MulticastDelegate`之间的分割是历史意外的毫无意义和任意结果。最初的计划是支持多播和单播委托，但在.NET 1.0 的预发布期末期间放弃了这种区分，现在所有委托类型都支持多播实例。这件事情发生得相当晚，以至于微软认为将两个基类合并为一个太过冒险，因此尽管没有任何实际目的，这种分割仍然存在。

我已经描述了`Delegate`定义的一些公共实例成员：`DynamicInvoke`和`GetInvocationList`方法。还有两个：`Method`属性返回表示目标方法的`MethodInfo`。（第十三章描述了`MethodInfo`类型。）`Target`属性返回将作为目标方法的隐式`this`参数传递的对象；如果委托引用静态方法，则`Target`将返回`null`。示例 9-17 展示了委托类型的编译器生成构造函数和方法的签名。具体细节因类型而异；这些是`Predicate<T>`类型的生成成员。

##### 示例 9-17\. 委托类型的成员

```cs
public Predicate(object target, IntPtr method);

public bool Invoke(T obj);

public IAsyncResult BeginInvoke(T obj, AsyncCallback callback, object state);
public bool EndInvoke(IAsyncResult result);
```

你定义的任何委托类型都会有四个相似的成员。编译后，它们都还没有实现体。编译器只生成它们的声明，因为 CLR 会在运行时提供它们的实现。

构造函数接受目标对象（对于静态方法为`null`）和标识方法的`IntPtr`。⁵ 请注意，这不是由`Method`属性返回的`MethodInfo`。相反，这是一个*函数标记*，用于表示目标方法的不透明二进制标识符。CLR 可以为所有成员和类型提供二进制元数据标记，但在 C#中没有用于处理它们的语法，因此我们通常看不到它们。当你构造委托类型的新实例时，编译器会自动生成检索函数标记的 IL。委托在内部使用标记的原因是，它们比使用反射 API 类型如`MethodInfo`更高效。

`Invoke`方法是调用委托的目标方法（或方法）的方法。你可以从 C#显式地使用它，就像示例 9-18 展示的那样。它几乎与示例 9-12 完全相同，唯一的区别是委托变量后面跟着`.Invoke`。这生成的代码与示例 9-12 完全相同，所以是使用`Invoke`还是像将委托标识符视为方法名使用的语法风格问题。作为一名以前的 C++开发者，我一直觉得示例 9-12 的语法很熟悉，因为它类似于在那种语言中使用函数指针，但有人认为显式写出`Invoke`可以更容易地看出代码正在使用委托。

##### 示例 9-18\. 显式使用`Invoke`

```cs
public static void CallMeRightBack(Predicate<int> userCallback)
{
    bool result = userCallback.Invoke(42);
    Console.WriteLine(result);
}
```

这种显式形式的一个好处是，你可以使用空值条件运算符来处理委托变量为`null`的情况。示例 9-19 使用这种方法仅在提供非空参数时尝试调用。

##### 示例 9-19\. 使用空值条件运算符调用`Invoke`

```cs
public static void CallMeMaybe(Action<int>? userCallback)
{
    userCallback?.Invoke(42);
}
```

`Invoke`方法是委托类型方法签名的所在地。当你定义委托类型时，这是你指定的返回类型和参数列表的地方。当编译器需要检查一个特定方法是否与委托类型兼容时（例如，当你创建该类型的新委托时），编译器将`Invoke`方法与你提供的方法进行比较。

如 示例 9-17 所示，所有委托类型都有`BeginInvoke`和`EndInvoke`方法。这些方法曾经提供了一种使用线程池的方式，但它们已被弃用，并且在当前版本的.NET 上不起作用（如果调用任一方法将导致`PlatformNotSupportedException`）。它们仍然在.NET Framework 上工作，但已经过时。您应该忽略这些过时的方法，而是使用 第十六章 中描述的技术。这些方法曾经流行的主要原因是它们提供了一种从一个线程传递一组值到另一个线程的简单方法 - 您可以将您需要的任何东西作为委托的参数传递。但是，C#现在有了解决这个问题的更好方式：匿名函数。

# 匿名函数

C#允许您创建委托而无需显式定义单独的方法。您可以编写一个特殊类型的表达式，其值为一个方法。您可以将它们视为*方法表达式*或*函数表达式*，但官方名称是*匿名函数*。表达式可以直接作为参数传递或直接分配给变量，因此这些表达式产生的方法没有名称。 （至少在 C#中是这样。运行时要求所有方法都有名称，因此 C#为这些东西生成了隐藏的名称，但从 C#语言的角度来看，它们是匿名的。）

对于简单的方法，内联表达式的能力可以消除大量的混乱。正如我们将在 “捕获变量” 中看到的那样，编译器利用了委托不仅仅是方法的引用这一事实，以便为匿名函数提供对包含方法中作用域的任何变量的访问。

由于历史原因，C# 提供了两种定义匿名函数的方式。较旧的方式涉及`delegate`关键字，并在 示例 9-20 中展示。这种形式被称为*匿名方法*。⁶ 我将`FindIndex`的每个参数放在单独的行上，以突出显示匿名函数（作为第二个参数），但 C#并不要求这样做。

##### 示例 9-20\. 匿名方法语法

```cs
public static int GetIndexOfFirstNonEmptyBin(int[] bins)
{
    return Array.FindIndex(
        bins,
        `delegate` `(``int` `value``)` `{` `return` `value` `>` `0``;` `}`
    );
}
```

在某些方面，这类似于定义方法的普通语法。参数列表出现在括号内，后面跟着包含方法体的块（顺便说一句，它可以包含任意数量的代码块，局部变量，循环和任何其他可以放入正常方法的内容）。但是，我们没有方法名，而是关键字`delegate`。编译器推断返回类型。在这种情况下，`FindIndex`方法的签名声明第二个参数为`Predicate<T>`，告诉编译器返回类型必须是`bool`。

实际上，编译器不仅仅知道返回类型。我已经传递了一个`int[]`数组给`FindIndex`，因此编译器会推断类型参数`T`为`int`，使得第二个参数成为`Predicate<int>`。这意味着在示例 9-20 中，我必须提供信息——委托参数的类型——而编译器已经知道。C#的后续版本引入了更紧凑的匿名函数语法，更好地利用了编译器的推断能力，如示例 9-21 所示。

##### 示例 9-21\. Lambda 语法

```cs
public static int GetIndexOfFirstNonEmptyBin(int[] bins)
{
    return Array.FindIndex(
        bins,
        `value` `=``>` `value` `>` `0`
    );
}
```

这种形式的匿名函数称为*lambda 表达式*，它是一种基于函数的计算模型的数学分支的名称。选择希腊字母 lambda (λ) 没有特别的意义。这是 1930 年代印刷技术限制的意外结果。lambda 演算的发明者 Alonzo Church 最初希望有一个不同的符号，但当他首次发表有关该主题的论文时，排版机操作员决定打印 λ，因为这是机器能产生的最接近 Church 符号的符号。尽管起源不佳，这个任意选择的术语已经变得无处不在。LISP，一个早期和有影响力的编程语言，用 lambda 来表示函数表达式，从那时起，许多语言都效仿，包括 C#。

示例 9-21 与示例 9-20 完全等价；我只是能够省略掉各种东西。`=>`符号明确标记这是一个 lambda 表达式，因此编译器不需要那个笨重且丑陋的`delegate`关键字来识别这是一个匿名函数。编译器从周围的上下文知道方法必须接受一个`int`，因此不需要指定参数的类型；我只提供了参数的名称：`value`。对于只包含单个表达式的简单方法，lambda 语法允许你省略块和`return`语句。这些都使得 lambda 变得非常紧凑，但在某些情况下，你可能不想省略那么多，正如示例 9-22 所示，这里有各种可选的特性。本示例中的每个 lambda 都是等效的。

##### 示例 9-22\. Lambda 变体

```cs
Predicate<int> p1 = value => value > 0;
Predicate<int> p2 = (value) => value > 0;
Predicate<int> p3 = (int value) => value > 0;
Predicate<int> p4 = value => { return value > 0; };
Predicate<int> p5 = (value) => { return value > 0; };
Predicate<int> p6 = (int value) => { return value > 0; };
Predicate<int> p7 = bool (value) => value > 0;
Predicate<int> p8 = bool (int value) => value > 0;
Predicate<int> p9 = bool (value) => { return value > 0; };
Predicate<int> pA = bool (int value) => { return value > 0; };
```

第一种变体是你可以在参数周围加括号。对于单个参数来说是可选的，但是对于多参数 lambda 是强制的。你还可以显式地指定参数的类型（在这种情况下，即使只有一个参数，也需要括号）。如果 lambda 返回一个值并且你喜欢的话，你还可以使用一个块而不是单个表达式，此时如果 lambda 返回一个值，你还必须使用 `return` 关键字。使用块的正常理由是如果你想在方法内部编写多个语句。C# 10.0 添加的最后四行展示了一种新能力：你可以显式地指定返回类型，尽管只有在参数列表在括号内时才允许这样做。

也许你会想知道为什么有这么多不同的形式——为什么不只有一种语法形式就行了呢？尽管示例 9-22 的最后一行显示了最一般的形式，但比起第一行，它也更加凌乱。由于 lambda 的目标之一是提供一个比匿名方法更简洁的替代方案，C#支持这些可以在没有歧义的情况下使用的较短形式。

你也可以编写一个不带参数的 lambda。就像示例 9-23 展示的那样，我们只需在 `=>` 符号前面放置一个空括号对即可。（正如这个示例还展示的那样，使用大于等于运算符 `>=` 的 lambda 看起来可能有些奇怪，因为 `=>` 和 `>=` 之间的无意义相似性。）

##### 示例 9-23\. 零参数 lambda

```cs
Func<bool> isAfternoon = () => DateTime.Now.Hour >= 12;
```

灵活而简洁的语法意味着 lambda 函数几乎取代了较老的匿名方法语法。然而，旧语法有一个优点：它允许你完全省略参数列表。在一些情况下，当你提供一个回调时，你只需要知道你等待的事情现在已经发生了。这在使用本章后面描述的标准事件模式时尤为常见，因为这要求事件处理程序即使在没有作用的情况下也接受参数。例如，当点击按钮时，除了点击了这一事实之外，没有其他太多要说的了，但是在.NET 的各种 UI 框架中，所有按钮类型都会向事件处理程序传递两个参数。示例 9-24 通过使用省略参数列表的匿名方法成功地忽略了这一点。

##### 示例 9-24\. 忽略匿名方法中的参数

```cs
EventHandler clickHandler = delegate { Debug.WriteLine("Clicked!"); };
```

`EventHandler` 是一个委托类型，要求其目标方法接受两个参数，类型分别为 `object` 和 `EventArgs`。如果我们的处理程序需要访问其中任何一个，当然可以添加参数列表，但匿名方法语法允许我们想省略就省略。lambda 则无法做到这一点。尽管如此，C# 10.0 增加了一个新功能，使忽略参数稍微不那么繁琐，示例 9-25 就展示了这一点。

##### 示例 9-25\. 一个丢弃其参数的 lambda

```cs
EventHandler clickHandler = (_, _) => Debug.WriteLine("Clicked!");
```

这与示例 9-24 具有完全相同的效果，但使用了 lambda 语法。我在括号中提供了参数列表，但因为我不想使用任何参数，所以在每个位置放置了一个下划线。这表示一个*丢弃*。您在早期章节的模式中看到过`_`字符，其意义在这里基本相似：它表明我们知道有一个可用的值；只是我们不关心它是什么，也不打算使用它。

###### 提示

在 C# 10.0 引入对此废弃语法的支持之前，人们经常使用类似的约定。下划线符号是一个有效的标识符，因此对于单参数 lambda，没有什么可以阻止您定义一个名为`_`的参数并选择不引用它。对于多个参数，情况会变得奇怪，因为您不能为两个参数使用相同的名称，这意味着示例 9-25 在旧版本的 C#中无法编译。为了解决这个问题，人们只是使用多个下划线，因此您可能会看到一个以`(_, __, ___) =>`开头的 lambda。幸运的是，C# 10.0 允许我们在整个过程中只使用一个`_`。

## 捕获的变量

虽然匿名函数在源代码中通常比完整的普通方法占用更少的空间，但它们不仅仅是简洁。C#编译器利用委托不仅能够引用方法，还能引用一些额外上下文的能力，提供了一个极其有用的功能：它可以使包含方法中的变量对匿名函数可用。示例 9-26 展示了一个返回`Predicate<int>`的方法。它使用一个 lambda 创建这个，该 lambda 使用包含方法中的参数。

##### 示例 9-26\. 使用包含方法中的变量

```cs
public static Predicate<int> IsGreaterThan(int threshold)
{
    return value => value > threshold;
}
```

这提供了与示例 9-8 中的`ThresholdComparer`类相同的功能，但我们只需编写一个简单的方法，而不是整个类。通过使用表达式主体方法，可以使其更加紧凑，正如示例 9-27 所示。（这可能有点*过于*简洁——在`>`附近使用两个不同的`=>`并排，不会为可读性赢得任何奖项。）

##### 示例 9-27\. 使用包含方法中的变量（表达式主体）

```cs
public static Predicate<int> IsGreaterThan(int threshold) =>
    value => value > threshold;
```

无论是哪种形式，代码都几乎看似简单至极，因此值得仔细查看其作用。`IsGreaterThan`方法返回一个委托实例。该委托的目标方法执行简单的比较——它评估`value > threshold`表达式并返回结果。该表达式中的`value`变量只是委托的参数——由调用`IsGreaterThan`返回的`Predicate<int>`的代码传递的`int`。示例 9-28 的第二行调用该代码，并将 200 作为`value`参数传入。

##### 示例 9-28\. `value` 参数的来源

```cs
Predicate<int> greaterThanTen = IsGreaterThan(10);
bool result = greaterThanTen(200);
```

表达式中的 `threshold` 变量比较棘手。这不是匿名函数的参数。它是 `IsGreaterThan` 的参数，而 示例 9-28 将 `10` 作为 `threshold` 参数传递。但是，在我们调用它返回的委托之前，`IsGreaterThan` 必须返回。由于该方法的参数已经返回，你可能会认为变量在调用委托时不再可用。事实上，这没问题，因为编译器为我们做了一些工作。如果匿名函数使用了包含方法声明的局部变量，或者使用了该方法的参数，编译器会生成一个类来保存这些变量，以便它们可以超越创建它们的方法的生命周期。编译器会在包含方法中生成代码来创建这个类的实例。（记住，每个块的调用都有自己的一组局部变量，因此如果任何局部变量被推入对象以延长它们的生命周期，每个调用都将需要一个新对象。）这也是流行神话的原因之一，该神话声称值类型的局部变量总是存储在堆栈上是不正确的——在这种情况下，编译器将传入的 `threshold` 参数的值复制到堆上对象的字段中，并且使用 `threshold` 变量的代码最终使用该字段。示例 9-29 显示了编译器为 示例 9-26 中的匿名函数生成的代码。

##### 示例 9-29\. 为匿名函数生成的代码

```cs
[CompilerGenerated]
private sealed class <>c__DisplayClass0_0
{
    public int threshold;

    public bool <IsGreaterThan>b__0(int value)
    {
        return (value > this.threshold);
    }
}
```

所有类和方法的名称都以 C# 标识符中非法的字符开头，以确保这些编译器生成的代码不会与我们编写的任何内容冲突——这在技术上称为 *不可言说的名称*。（顺便说一句，确切的名称并不固定，如果你尝试的话可能会发现它们略有不同。）这些生成的代码与 示例 9-8 中的 `ThresholdComparer` 类非常相似，这并不奇怪，因为目标是一样的：委托需要某种可以引用的方法，而该方法的行为取决于一个不固定的值。匿名函数不是运行时类型系统的一个特性，因此编译器必须生成一个类来提供这种行为，超越 CLR 基本委托功能的范围。

###### 注意

局部函数（在第三章描述）也可以访问其包含方法的局部变量。通常情况下，这不会改变这些变量的生命周期，因为局部函数在其包含方法之外是不可访问的。但是，如果你创建一个引用局部函数的委托，这意味着它可能在包含方法返回后被调用，因此编译器会执行与匿名函数相同的技巧，使变量能够在外部方法返回后继续存在。

一旦你了解到在编写匿名函数时实际发生的情况，自然而然地就能知道内部方法不仅能读取变量，还能修改它。这个变量只是一个对象中的字段，两个方法——匿名函数和包含方法——都可以访问到。示例 9-30 利用这一点来维护一个从匿名函数更新的计数。

##### 示例 9-30\. 修改被捕获的变量

```cs
static void Calculate(int[] nums)
{
    int zeroEntryCount = 0;
    int[] nonZeroNums = Array.FindAll(
        nums,
        v =>
        {
            if (v == 0)
            {
                zeroEntryCount += 1;
                return false;
            }
            else
            {
                return true;
            }
        });
    Console.WriteLine($"Number of zero entries: {zeroEntryCount}");
    Console.WriteLine($"First non-zero entry: {nonZeroNums[0]}");
}
```

对于包含方法的所有作用域内的内容，匿名函数也同样适用。如果包含方法是一个实例方法，这还包括类型的任何实例成员，因此你的匿名函数可以访问字段、属性和方法。（编译器通过在生成的类中添加一个字段来持有 `this` 引用的副本来支持这一点。）编译器只在需要时将生成的类中的内容添加到类中，如示例 9-29 所示，如果不使用包含作用域的变量或实例成员，则可能生成静态方法。

前面示例中的 `FindAll` 方法在返回后不会保留委托——任何回调将在 `FindAll` 运行时发生。然而，并非所有情况都是这样的。一些 API 执行异步工作，并且将在将来的某个时刻调用你，到那时包含方法可能已经返回了。这意味着任何被匿名函数捕获的变量将比包含方法的生存周期更长。总体来说，这是可以接受的，因为所有被捕获的变量都存储在堆上的对象中，因此匿名函数并不依赖于不再存在的堆栈帧。但有一件事需要特别注意，在回调完成之前一定要显式释放资源。示例 9-31 展示了一个容易犯的错误。它使用了一个异步、基于回调的 API 来通过 HTTP 下载特定 URL 的资源。（这在 `HttpClient.GetStreamAsync` 返回的 `Task<Stream>` 上调用 `ContinueWith` 方法，传递一个委托，该委托将在 HTTP 响应返回后调用。这个方法是第十六章描述的任务并行库的一部分。）

##### 示例 9-31\. 过早释放

```cs
HttpClient http = GetHttpClient();
using (FileStream file = File.OpenWrite(@"c:\temp\page.txt"))
{
    http.GetStreamAsync("https://endjin.com/")
        .ContinueWith((Task<Stream> t) => t.Result.CopyToAsync(file));
} // Will probably dispose FileStream before callback runs
```

在此示例中的`using`语句将在外部方法的作用域中的`file`变量离开范围的地方立即处置`FileStream`。问题在于，这个`file`变量也被用在一个匿名函数中，这很可能会在执行该外部方法的线程离开该`using`语句的块之后运行。编译器不知道内部块将何时运行——它不知道这是否像`Array.FindAll`使用的同步回调或异步回调。因此，在这里它无法做任何特殊处理——它只是在块的结尾调用`Dispose`，因为这是我们的代码告诉它要做的事情。

###### 注意

讨论的异步语言特性见第十七章，可以帮助避免这种问题。当您使用这些特性来消耗展现这种`Task`-based 模式的 API 时，编译器可以确切地知道事物保持在作用域中的时间。这使得编译器可以为您生成继续回调，并且作为其中的一部分，它可以安排一个`using`语句在正确的时刻调用`Dispose`。

在性能关键的代码中，你可能需要考虑匿名函数的成本。如果匿名函数使用外部作用域的变量，那么除了创建用于引用匿名函数的委托对象之外，您可能还会创建另一个对象：用于保存共享局部变量的生成类的实例。编译器在可以时会重用这些变量持有者——例如，如果一个方法包含两个匿名函数，它们可能能够共享一个对象。即使有了这种优化，您仍然在创建额外的对象，增加了垃圾回收的压力。（而且在某些情况下，即使您从未触发创建委托的代码路径，也可能会创建此对象。）这并不是特别昂贵——通常这些对象很小——但是如果您面临特别严峻的性能问题，通过以更加冗长的方式编写来减少对象分配的数量，您可能能够稍微改善一些性能。

###### 注意

本地函数并不总是产生相同的开销。当本地函数使用其外部方法的变量时，它并不延长其生命周期。因此，编译器不需要在堆上创建对象来保存共享变量。它仍然会创建一个类型来保存所有共享变量，但将其定义为`struct`，作为隐藏的`in`参数传递引用，从而避免了对堆块的需求。（如果创建一个引用本地函数的委托，它就不能使用此优化，而是恢复到使用匿名函数时使用的相同策略，将共享变量放在堆上的对象中。）

更微妙的是，在匿名函数中使用外部范围的局部变量将延长这些变量的生存期，这可能意味着 GC 在检测这些变量引用的对象不再使用时需要更长时间。正如您可能从第 7 章中记得的那样，CLR 分析您的代码以确定何时使用变量，以便它可以在等待引用它们的变量超出范围之前释放对象。这使得某些对象使用的内存可以显著提前回收，特别是在需要长时间完成的方法中。但是，活跃性分析仅适用于传统的局部变量。它不能应用于在匿名函数中使用的变量，因为编译器会将这些变量转换为字段。（从 CLR 的角度来看，它们根本不是局部变量。）由于 C#通常将特定范围的所有这些转换变量放入单个对象中，您会发现在方法完成并且包含这些变量的对象变得不可访问之前，这些变量引用的对象都无法被回收。这意味着在某些情况下，当您完成后使用`null`设置一个局部变量，可能会使得特定对象的内存在下次 GC 时被回收。 （通常，这是一个不好的建议，即使对于匿名函数也可能没有实际上有用的效果。只有在性能测试显示明显优势的情况下才应该这样做。但是，在您看到与 GC 相关的性能问题，并且您大量使用长时间运行的匿名函数的情况下，进行调查是值得的。）

避免在匿名函数中出现这些潜在的性能问题非常简单：不要使用捕获的变量。如果一个匿名函数从未尝试使用其包含范围中的任何内容，C#编译器将不会启用相应的机制，完全避免所有开销。您可以通过使用`static`关键字来告知编译器，您打算避免捕获变量，如示例 9-32 所示。正如普通的`static`方法没有对其定义类型的实例的隐式访问一样，`static`匿名函数也无法访问其包含范围。使用`static`不会改变代码生成方式 —— 任何不依赖于捕获的匿名函数都会避免所有与捕获相关的开销，无论是否标记为`static`。这只是要求编译器在您意外尝试使用函数包含范围中的变量时报告错误。

##### 示例 9-32\. 使用`static`退出变量捕获

```cs
public static Predicate<int> IsGreaterThan10() => static value => value > 10;
```

变量捕获有时也可能导致错误，特别是由于`for`循环中与子范围相关的微妙问题。(`foreach`循环不会出现这个问题。)示例 9-33 遇到了这个问题。

##### Example 9-33\. `for` 循环中的问题变量捕获

```cs
public static void Caught()
{
    var greaterThanN = new Predicate<int>[10];
    for (int i = 0; i < greaterThanN.Length; ++i)
    {
        greaterThanN[i] = value => value > i; // Bad use of i
    }

    Console.WriteLine(greaterThanN5);
    Console.WriteLine(greaterThanN5);
}
```

本示例初始化了一个 `Predicate<int>` 委托数组，其中每个委托测试值是否大于某个数字。（顺便说一句，您不必使用数组来看到我即将描述的问题。您的循环可以将其创建的委托传递给 第十六章 中描述的某种机制，该机制通过在多个线程上运行代码来实现并行处理。但数组使得更容易展示问题。）具体来说，它将值与循环计数器 `i` 比较，后者决定数组中每个委托的位置，因此您可能期望索引为 5 的元素引用与 5 进行比较的方法。如果是这样，此代码将显示两次 `True`。实际上，它显示 `True` 然后是 `False`。结果发现，Example 9-33 生成了一个委托数组，其中每个元素都将其参数与 10 进行比较。

当人们遇到这种情况时，通常会感到惊讶。事后来看，当您知道 C# 编译器如何使匿名函数能够使用其包含作用域的变量时，很容易理解为什么会发生这种情况。`for` 循环声明了变量 `i`，因为它不仅被包含的 `Caught` 方法使用，还被循环创建的每个委托使用，所以编译器将会生成一个类似于 Example 9-29 中的类，并且该变量将存在于该类的一个字段中。由于变量在循环开始时进入作用域，并在循环的整个过程中保持在作用域中，编译器将创建一个该生成类的实例，并且这个实例将被所有委托共享。因此，当循环增加 `i` 时，这会修改所有委托的行为，因为它们都使用相同的 `i` 变量。

从根本上说，问题在于这里只有一个 `i` 变量。您可以通过在循环内部引入一个新变量来修复代码。Example 9-34 将 `i` 的值复制到另一个本地变量 `current` 中，该变量在迭代开始时才进入作用域，并在每次迭代结束时退出作用域。因此，尽管只有一个 `i` 变量，该变量在循环运行期间持续存在，但我们实际上在每次循环中都得到一个新的 `current` 变量。由于每个委托都有自己独特的 `current` 变量，这种修改意味着数组中的每个委托将其参数与特定迭代时循环计数器的值进行比较。

##### Example 9-34\. 修改循环以捕获当前值

```cs
for (int i = 0; i < greaterThanN.Length; ++i)
{
    `int` `current` `=` `i``;`
    greaterThanN[i] = value => value > current;
}
```

编译器仍然会生成类似于 Example 9-29 中的类，用于保存内联方法和包含方法共享的 `current` 变量，但这一次，它会在每次循环时创建该类的新实例，以便为每个匿名函数提供该变量的不同实例。（当使用 `foreach` 循环时，作用域规则略有不同：其迭代变量的作用域是每次迭代的，这意味着每次循环逻辑上是变量的不同实例，因此不需要像在 `for` 循环中那样在循环内部添加额外变量。）

或许你会想知道，如果编写一个使用多个作用域变量的匿名函数会发生什么。Example 9-35 声明了一个名为 `offset` 的变量，在循环之前，并且 lambda 同时使用了那个变量以及只在一次迭代中存在的变量。

##### Example 9-35\. 在不同作用域捕获变量

```cs
`int` `offset` `=` `10``;`
for (int i = 0; i < greaterThanN.Length; ++i)
{
    int current = i;
    `greaterThanN``[``i``]` `=` `value` `=``>` `value` `>` `(``current` `+` `offset``)``;`
}
```

在这种情况下，编译器会生成两个类，一个用于保存每次迭代共享变量（例如本例中的 `current`），另一个用于保存整个循环范围的变量（例如本例中的 `offset`）。每个委托的目标对象都包含内部作用域变量，并且该作用域变量包含对外部作用域的引用。

Figure 9-1 大致展示了这种工作方式，尽管它已经简化只展示了前五个项目。`greaterThanN` 变量包含一个对数组的引用。每个数组元素包含对委托的引用。每个委托引用同一个方法，但每个委托都有不同的目标对象，这就是每个委托如何捕获不同实例的 `current` 变量。每个目标对象都引用一个包含从循环外部捕获的 `offset` 变量的单一对象。

![](img/pc10_0901.png)

###### Figure 9-1\. 委托和捕获作用域

## Lambdas and Expression Trees

Lambdas 除了提供委托之外，还有一个额外的小技巧。某些 lambda 会生成表示代码的数据结构。当你在需要 `Expression<T>` 的上下文中使用 lambda 语法时，就会发生这种情况，其中 `T` 是委托类型。`Expression<T>` 本身不是委托类型；它是运行时库中的特殊类型（位于 `System.Linq.Expressions` 命名空间），触发编译器对 lambda 的替代处理。Example 9-36 就使用了这种类型。

##### Example 9-36\. 一个 lambda 表达式

```cs
Expression<Func<int, bool>> greaterThanZero = value => value > 0;
```

此示例看起来与本章节中已展示的一些 lambda 和委托很相似，但编译器处理方式完全不同。它不会生成一个方法——不会有编译后的 IL 代码表示 lambda 的主体。相反，编译器会生成类似于 Example 9-37 中的代码。

##### 示例 9-37\. 编译器对 lambda 表达式的处理

```cs
ParameterExpression valueParam = Expression.Parameter(typeof(int), "value");
ConstantExpression constantZero = Expression.Constant(0);
BinaryExpression comparison = Expression.GreaterThan(valueParam, constantZero);
Expression<Func<int, bool>> greaterThanZero =
    Expression.Lambda<Func<int, bool>>(comparison, valueParam);
```

这段代码调用`Expression`类提供的各种工厂函数，为 lambda 中的每个子表达式生成一个对象。从简单的操作数开始——`value`参数和常量值`0`。这些被输入一个代表“大于”比较表达式的对象中，进而成为代表整个 lambda 表达式的对象的主体。

能够为表达式生成对象模型使得编写一个 API 成为可能，其行为由表达式的结构和内容控制。例如，某些数据访问 API 可以接受类似于示例 9-36 和 9-37 生成的表达式，并用它来生成数据库查询的一部分。我将在第十章中讨论 C#的集成查询特性，但示例 9-38 展示了 lambda 表达式如何被用作查询的基础。

##### 示例 9-38\. 表达式和数据库查询

```cs
var expensiveProducts = dbContext.Products.Where(p => p.ListPrice > 3000);
```

此示例恰好使用了一个名为 Entity Framework 的 Microsoft 库，但是其他各种数据访问技术也支持相同的方法。在此示例中，`Where`方法接受一个类型为`Expression<Func<Product,bool>>`的参数。⁷ `Product`是一个对应数据库实体的类，但这里重要的是使用了`Expression<T>`。这意味着编译器将生成代码，创建一个对象树，其结构对应于 lambda 表达式。`Where`方法处理这个表达式树，生成包含此子句的 SQL 查询：`WHERE [Extent1].[ListPrice] > cast(3000 as decimal(18))`。因此，尽管我将查询编写为 C#表达式，但查找匹配对象的所有工作都将在我的数据库服务器上完成。

表达式树被添加到 C#中，以作为 LINQ 的一部分来处理此类查询（在第十章中讨论）。但是，与大多数与 LINQ 相关的功能一样，也可以用于其他用途。例如，用于自动化测试的流行.NET 库称为[Moq](https://github.com/moq)就利用了这一点。它创建接口的假实现用于测试目的，并使用 lambda 表达式提供一个简单的 API 来配置这些假实现的行为。示例 9-39 使用 Moq 的`Mock<T>`类创建.NET 的`IEqualityComparer<string>`接口的假实现。代码调用`Setup`方法，该方法接受一个表达式，指示我们想要为其定义特殊处理的特定调用——在本例中，如果假实现的`IEqualityComparer<string>.Equals`以`"Color"`和`"Colour"`作为参数被调用，则希望它返回`true`。

##### 示例 9-39\. Moq 库使用 lambda 表达式的例子

```cs
var fakeComparer = new Mock<IEqualityComparer<string>>();
fakeComparer
    .Setup(c => c.Equals("Color", "Colour"))
    .Returns(true);
```

如果`Setup`的参数只是一个委托，Moq 将无法检查它。但因为它是一个表达式树，Moq 能够深入其中并找出我们所要求的内容。

###### 警告

不幸的是，表达式树是 C#中落后于语言其余部分的一个领域。它们在 C# 3.0 中引入，自那以后增加的各种语言特性，如对元组和异步表达式的支持，无法在表达式树中使用，因为对象模型无法表示它们。

# 事件

有时候，对象能够在有趣的事情发生时提供通知是很有用的——在客户端 UI 框架中，例如，你会想知道用户何时点击应用程序的按钮。委托提供了通知所需的基本回调机制，但你可以用许多方法来使用它们。委托应该作为方法参数传递、构造函数参数传递，还是作为属性传递？你应该如何支持取消订阅通知？CTS 通过一种特殊的类成员——*事件*来正式回答这些问题，并且 C#有与事件一起工作的语法。示例 9-40 展示了一个带有事件成员的类。

##### 示例 9-40\. 一个带有事件的类

```cs
public class Eventful
{
    `public` `event` `Action``<``string``>``?` `Announcement``;`

    public void Announce(string message)
    {
        Announcement?.Invoke(message);
    }
}
```

和所有成员一样，你可以从一个可访问性限定符开始，如果你省略了它，它将默认为`private`。接下来，`event`关键字将其单独标识为事件。然后是事件的类型，可以是任何委托类型。我使用了`Action<string>`，尽管你很快会看到，这是一个不正统的选择。最后，我们放置成员名称，所以这个例子定义了一个名为`Announcement`的事件。

要处理一个事件，你必须提供一个正确类型的委托，并且你必须使用`+=`语法将该委托附加为处理程序。示例 9-41 使用了一个 lambda 表达式，但你可以使用任何产生或隐式转换为事件所需类型的委托的表达式。

##### 示例 9-41\. 处理事件

```cs
var source = new Eventful();
source.Announcement += m => Console.WriteLine("Announcement: " + m);
```

除了定义事件之外，示例 9-40 还展示了如何*引发*事件——也就是说，如何调用已附加到事件的所有处理程序。它的`Announce`使用了相同的语法，如果`Announcement`是一个包含我们想要调用的委托的字段，我们将使用这个语法。实际上，就类内部代码而言，事件看起来确实像是一个字段。我选择在这里显式地使用委托的`Invoke`成员，而不是写`Announcement(message)`，因为这让我可以使用空值条件运算符(`?.`)。这会导致编译器只在委托不为 null 时才生成调用代码。否则，我必须编写一个`if`语句来验证字段不为 null 才能调用它。

那么为什么我们需要一种特殊的成员类型，如果这看起来只是一个字段？好吧，它只从定义类的内部看起来像一个字段。类外的代码无法引发事件，所以在 示例 9-42 中显示的代码将无法编译。

##### 示例 9-42\. 如何不引发事件

```cs
var source = new Eventful();
source.Announcement("Will this work?"); // No, this will not even compile
```

从外部看，你只能对事件做两件事：使用 `+=` 添加处理程序和使用 `-=` 删除处理程序。添加和删除事件处理程序的语法是不寻常的，因为这是 C# 中唯一可以使用 `+=` 和 `-=` 而没有相应独立的 `+` 或 `-` 运算符的情况。`+=` 和 `-=` 对事件的操作最终都是伪装成方法调用。就像属性实际上是具有特殊语法的方法对一样，事件也是如此。它们在概念上类似于 示例 9-43 中显示的代码。（实际代码包括一些相当复杂的无锁、线程安全代码。我没有显示这些代码，因为多线程会模糊其基本意图。）这不会产生完全相同的效果，因为 `event` 关键字向类型添加了标识方法为事件的元数据，因此这只是用于说明的示例。

##### 示例 9-43\. 声明事件的近似效果

```cs
private Action<string>? Announcement;

// Not the actual code.
// The real code is more complex, to tolerate concurrent calls.
public void add_Announcement(Action<string> handler)
{
    Announcement += handler;
}
public void remove_Announcement(Action<string> handler)
{
    Announcement -= handler;
}
```

与属性类似，事件主要存在是为了提供一种方便且独特的语法，并使工具更容易知道如何呈现类提供的特性。事件对于 UI 元素尤为重要。在大多数 UI 框架中，表示交互元素的对象通常可以触发多种事件，对应不同形式的输入，例如键盘、鼠标或触摸。通常还会有与特定控件行为相关的事件，比如在列表中选择新项目。因为 CTS 定义了一种标准习语，使元素可以公开事件，因此视觉 UI 设计工具（例如内置于 Visual Studio 中的工具）可以显示可用事件并为您生成处理程序。

## 标准事件委托模式

示例 9-40 中的事件使用 `Action<T>` 委托类型，这是不寻常的，因为几乎所有事件实际上都使用符合特定模式的委托类型。该模式要求委托的方法签名具有两个参数。第一个参数的类型是 `object`，第二个参数的类型要么是 `EventArgs`，要么是从 `EventArgs` 派生的某种类型。示例 9-44 展示了 `System` 命名空间中的 `EventHandler` 委托类型，这是这种模式中最简单且最广泛使用的例子。

##### 示例 9-44\. `EventHandler` 委托类型

```cs
public delegate void EventHandler(object sender, EventArgs e);
```

第一个参数通常称为`sender`，因为事件源会将自身的引用传递给此参数。这意味着，如果你将单个委托附加到多个事件源，处理程序始终可以知道哪个源引发了特定的通知。

第二个参数提供了一个放置特定事件信息的地方。例如，WPF UI 元素定义了各种处理鼠标输入的事件，使用更专门的委托类型，例如`MouseButtonEventHandler`，其签名指定了一个相应的专用事件参数，提供关于事件的详细信息。例如，`MouseButtonEventArgs`定义了一个`GetPosition`方法，告诉你鼠标在按钮点击时的位置，它还定义了各种其他属性，包括`ClickCount`和`Timestamp`。

无论第二个参数的专用类型是什么，它始终会派生自基本的`EventArgs`类型。这个基本类型并不是很有趣——它除了`object`提供的标准成员外没有添加任何成员。然而，它确实使得可以编写一个通用方法，可以附加到使用这种模式的任何事件上。委托兼容性的规则意味着，即使委托类型指定了第二个参数类型为`MouseButtonEventArgs`，一个第二个参数类型为`EventArgs`的方法也是一个可以接受的目标。这在代码生成或其他基础设施场景中偶尔是有用的。然而，标准事件模式的主要好处仅仅是熟悉性——有经验的 C#开发人员通常期望事件能够以这种方式工作。

## 自定义添加和删除方法

有时，你可能不想使用 C#编译器生成的默认事件实现。例如，一个类可能定义了大量事件，其中大多数在大多数实例上都不会被使用。UI 框架经常具有这种特性。WPF UI 可以有成千上万的元素，每个元素都提供超过 100 个事件，但通常你只会给少数几个元素附加处理程序，甚至对于这些元素，你也只处理提供的少数事件。在这种情况下，让每个元素都为每个可用事件分配一个字段是低效的。

对于大量很少使用的事件，默认的基于字段的实现可能会为 UI 中的每个元素增加数百字节的占用空间，这可能会对性能产生可察觉的影响。（在典型的 WPF 应用程序中，这可能会累积到几十万字节。虽然在现代计算机的内存容量下这听起来不多，但它可能使你的代码无法有效利用 CPU 缓存，导致应用响应速度急剧下降。即使缓存的大小为几兆字节，但最快速的部分通常要小得多，而在关键数据结构中浪费几百千字节可能会对性能造成重大影响。）

如果你要避免使用默认的编译器生成的事件实现，另一个原因是你可能希望在引发事件时拥有更复杂的语义。例如，WPF 支持*事件冒泡*：如果一个 UI 元素不处理某些事件，这些事件将会被传递给父元素，然后是父元素的父元素，依此类推直到找到一个处理程序或达到顶部。虽然在 C#提供的标准事件实现中可以实现这种方案，但当事件处理程序相对稀少时，采用更高效的策略是可能的。

为了支持这些场景，C#允许你为事件提供自己的 add 和 remove 方法。从外部看，它看起来像一个普通的事件——使用你的类的任何人都将使用相同的`+=`和`-=`语法来添加和移除处理程序——并且不可能知道它提供了自定义实现。示例 9-45 展示了一个具有两个事件的类，并使用一个共享的字典跟踪哪些对象处理了哪些事件。该方法可扩展到更多事件——字典使用对象对作为键，因此每个条目代表特定的（源，事件）对。（顺便说一句，这不是生产质量的代码。在多线程使用时不安全，当仍附有事件处理程序的`ScarceEventSource`实例不再使用时还会泄露内存。这个例子只是展示了自定义事件处理程序的外观；它不是一个完全工程化的解决方案。）

##### 示例 9-45\. 自定义`add`和`remove`用于稀疏事件

```cs
public class ScarceEventSource
{
    // One dictionary shared by all instances of this class,
    // tracking all handlers for all events.
    // Beware of memory leaks - this code is for illustration only.
    private static readonly
     Dictionary<(ScarceEventSource, object), EventHandler> _eventHandlers
      = new();

    // Objects used as keys to identify particular events in the dictionary.
    private static readonly object EventOneId = new();
    private static readonly object EventTwoId = new();

    public event EventHandler EventOne
    {
        add
        {
            AddEvent(EventOneId, value);
        }
        remove
        {
            RemoveEvent(EventOneId, value);
        }
    }

    public event EventHandler EventTwo
    {
        add
        {
            AddEvent(EventTwoId, value);
        }
        remove
        {
            RemoveEvent(EventTwoId, value);
        }
    }

    public void RaiseBoth()
    {
        RaiseEvent(EventOneId, EventArgs.Empty);
        RaiseEvent(EventTwoId, EventArgs.Empty);
    }

    private (ScarceEventSource, object) MakeKey(object eventId) => (this, eventId);

    private void AddEvent(object eventId, EventHandler handler)
    {
        var key = MakeKey(eventId);
        _eventHandlers.TryGetValue(key, out EventHandler? entry);
        entry += handler;
        _eventHandlers[key] = entry;
    }

    private void RemoveEvent(object eventId, EventHandler handler)
    {
        var key = MakeKey(eventId);
        EventHandler? entry = _eventHandlers[key];
        entry -= handler;
        if (entry == null)
        {
            _eventHandlers.Remove(key);
        }
        else
        {
            _eventHandlers[key] = entry;
        }
    }

    private void RaiseEvent(object eventId, EventArgs e)
    {
        var key = MakeKey(eventId);
        if (_eventHandlers.TryGetValue(key, out EventHandler? handler))
        {
            handler(this, e);
        }
    }
}
```

自定义事件的语法与完整属性语法类似：在成员声明后添加一个块，其中包含两个成员，虽然它们称为`add`和`remove`而不是`get`和`set`。（与属性不同的是，你必须始终提供这两种方法。）这会禁用通常会保存事件的字段的生成，这意味着`ScarceEventSource`类根本没有实例字段——这种类型的实例尽可能小。

这种小内存占用的代价是复杂性显著增加；我编写的代码行数大约是使用编译器生成事件所需的 16 倍，而且为了修复前面描述的缺陷，我们可能还需要更多。此外，只有在大多数情况下事件确实没有被处理时，这种技术才会提供改进——如果我为该类的每个实例都附加了这两个事件的处理程序，那么基于字典的存储将消耗比每个类实例中简单拥有一个字段更多的内存。因此，只有在你需要非标准事件触发行为或非常确定你确实会节省内存并且节省是值得的情况下，你应该考虑这种自定义事件处理方式。

## 事件与垃圾回收器

就 GC 而言，委托和任何其他普通对象一样。如果 GC 发现委托实例是可达的，那么它将检查 `Target` 属性，以及该属性所引用的任何对象也将被视为可达，以及该对象再次引用的任何对象。虽然这没有什么显著之处，但是在某些情况下，保留事件处理程序可能导致对象在内存中持续存在，而你可能希望它们被 GC 收集。

关于委托和事件本身没有任何固有的特性使它们异常可能导致 GC 失败。如果你确实遇到与事件相关的内存泄漏，它的结构与任何其他 .NET 内存泄漏相同：从根引用开始，会有一些引用链使得对象在使用完毕后仍然可达。尽管如此，事件通常因为它们经常用于可能导致问题的方式而特别受到内存泄漏的责备。

例如，假设你的应用程序维护一些表示其状态的对象模型，而你的 UI 代码位于一个单独的层中，利用该底层模型，使其适应屏幕上的展示。通常建议采用这种分层方式——将处理用户交互的代码与实现应用逻辑的代码混合在一起是一个不好的主意。但是如果底层模型广播状态变化，UI 需要反映这些变化，则可能会出现问题。如果这些变化是通过事件广播的，那么你的 UI 代码通常会将处理程序附加到这些事件上。

现在想象有人关闭你应用程序的一个窗口。你希望表示该窗口 UI 的对象在下次 GC 运行时都被检测为不可达。UI 框架很可能已经尝试使这成为可能。例如，WPF 确保其每个 `Window` 类的实例在相应窗口打开时都是可达的，但一旦窗口关闭，它就停止保持对窗口的引用，以便能够收集该窗口的所有 UI 对象。

然而，如果你在主应用程序模型中处理事件，并在 `Window` 派生类中的方法中未显式删除该处理程序，那么你将会遇到问题。只要你的应用程序仍在运行，可能会有某个地方保持你的应用程序的底层模型可达。这意味着任何被应用程序模型的委托所持有的目标对象（例如作为事件处理程序添加的委托）将继续可达，阻止 GC 释放它们。因此，如果一个现在关闭的窗口的 `Window` 派生对象仍在处理来自你的应用程序模型的事件，那么该窗口及其包含的所有 UI 元素仍将可达，并且不会被垃圾回收。

###### 注意

有一种持久的错误观念认为，这种基于事件的内存泄漏与循环引用有关。事实上，GC 完全可以处理循环引用。确实，在这些场景中通常存在循环引用，但它们不是问题的根源。问题是在你不再需要它们之后，意外地保持对象的可达性。无论是否存在循环引用，这样做都会导致问题。

你可以通过确保，如果你的 UI 层附加处理程序到长时间保持活跃的对象上，当相关的 UI 元素不再使用时，移除这些处理程序来处理这个问题。或者，你可以使用弱引用来确保，如果你的事件源是唯一持有目标引用的东西，它不会保持其活跃性。WPF 可以帮助你处理这个问题——它提供了一个 `WeakEventManager` 类，允许你以一种使处理对象能够在不需要取消订阅事件的情况下被垃圾回收的方式处理事件。WPF 在将 UI 数据绑定到提供属性更改通知事件的数据源时，就使用了这种技术。

###### 注意

虽然事件相关的泄漏通常出现在用户界面中，但它们可能发生在任何地方。只要事件源仍然可达，所有附加的处理程序也将保持可达。

## 事件与委托

一些 API 通过事件提供通知，而其他一些直接使用委托。你应该如何决定使用哪种方法？在某些情况下，决策可能已经为你做出，因为你想支持某种特定习惯用语。例如，如果你希望你的 API 支持 C# 中的异步特性，你将需要实现 第十七章 中描述的模式，该模式使用委托而不是事件作为完成回调。另一方面，事件提供了明确的订阅和取消订阅的方式，在某些情况下将使它们成为更好的选择。约定是另一个考虑因素：如果你正在编写一个 UI 元素，事件很可能是合适的，因为那是主要的习惯用语。

在约束或惯例无法提供答案的情况下，您需要考虑回调的使用方式。如果通知会有多个订阅者，事件可能是最佳选择。这并非绝对必要，因为任何委托都能够支持多播行为，但按照惯例，这种行为通常通过事件提供。如果您的类的用户将需要在某个时候移除处理程序，事件也可能是一个不错的选择。尽管如此，如果需要更高级的功能，则`IObservable`接口也支持多播和取消订阅，并且可能是一个更好的选择。此接口是.NET 的响应式扩展的一部分，并在第十一章中描述。

如果只有一个目标方法才能实现，通常将委托作为方法或构造函数的参数传递。例如，如果委托类型具有非`void`返回值，并且 API 依赖于它（例如传递给`Array.FindAll`的谓词返回的`bool`），那么具有多个目标或零个目标是没有意义的。在这里，事件的用法不正确，因为它的订阅模型认为无论是附加零个处理程序还是多个处理程序都是完全正常的。

偶尔会出现一些场景，可能希望有零个处理程序或一个处理程序，但从不超过一个处理程序。例如，WPF 的`CollectionView`类可以对集合中的数据进行排序、分组和过滤。通过提供`Predicate<object>`来配置过滤。这不是作为构造函数参数传递的，因为过滤是可选的，所以类定义了一个`Filter`属性。在这里使用事件是不合适的，部分原因是`Predicate<object>`不符合通常的事件委托模式，但主要是因为类需要一个明确的是或否的答案，所以不希望支持多个目标。（当然，所有委托类型都支持多播，这意味着仍然可以提供多个目标。但使用属性而不是事件的决定表明在此尝试提供多个回调并不有用。）

# **委托与接口**

在本章的开头，我提到委托比接口提供了一个更不繁琐的回调和通知机制。那么为什么一些 API 要求调用者实现接口来启用回调呢？为什么我们有`IComparer<T>`而不是委托？实际上，我们两者都有 —— 有一个委托类型称为`Comparison<T>`，许多接受`IComparer<T>`的 API 也支持它作为替代。数组和`List<T>`有重载的`Sort`方法，可以接受任一种类型。

在某些情况下，面向对象的方法可能比使用委托更可取。实现`IComparer<T>`的对象可以提供属性来调整比较的方式（例如，选择不同的排序标准）。您可能希望跨多个回调收集和汇总信息，尽管您可以通过捕获变量来实现这一点，但如果通过对象的属性在最后再次获取信息会更容易。

这实际上是由编写被调用代码的人决定的问题，而不是由编写调用代码的开发者决定的。委托更灵活，因为它允许 API 的消费者决定如何组织他们的代码，而接口则强加了约束。然而，如果接口恰好与您想要的抽象一致，委托可能会显得像是一个令人恼火的额外细节。这就是为什么一些 API 提供两种选择的原因，例如接受`IComparer<T>`或`Comparison<T>`的排序 API。

如果你需要提供多个相关的回调，接口可能比委托更可取。.NET 的响应式扩展定义了一个通知的抽象，包括在事件序列结束或出现错误时知道的能力，因此在该模型中，订阅者实现一个包含三个方法的接口——`OnNext`、`OnCompleted`和`OnError`。使用接口是有道理的，因为这三种方法通常需要一起使用才能完成订阅。

# 总结

委托是提供对方法引用的对象，可以是静态方法或实例方法。对于实例方法，委托还保存对目标对象的引用，因此调用委托的代码不需要提供目标。委托还可以引用多个方法，尽管如果委托的返回类型不是`void`，这会使事情复杂化。虽然委托类型在 CLR 中得到特殊处理，但它们仍然只是引用类型，这意味着可以将委托的引用作为参数传递、从方法中返回并存储在字段、变量或属性中。委托类型为目标方法定义了一个签名。这通过类型的`Invoke`方法表示，但 C# 可以隐藏这一点，提供一个语法，可以直接调用委托表达式，而不必显式引用`Invoke`。您可以构造一个委托，引用任何具有兼容签名的方法。您还可以让 C# 为您做更多的工作——如果您使用 lambda 语法创建一个匿名函数，C# 将为您提供一个合适的声明，并且可以在幕后为内部方法使包含方法中的变量可用。委托是事件的基础，它为通知提供了一个正式的发布/订阅模型。

C# 中特别广泛使用委托的一个特性是 LINQ，这将在下一章讨论。

¹ 在 C# 10.0 之前，编译器不会为你选择，而且这个例子会产生编译器错误。如果你遇到的代码费力地指定了编译器本来会选择的委托类型，那么它很可能是在 C# 10.0 发布之前编写的。

² ILDASM 随 Visual Studio 一起提供。在撰写本文时，微软并未提供跨平台版本，但你可以使用[开源项目 ILSpy](https://oreil.ly/ILSpy)。

³ 你可能记得泛型类型*定义*可以使用`in`和`out`关键字，但那是不同的。它指示泛型类型中的类型*参数*是反变还是协变。当你为类型参数提供具体的*参数*时，你不能使用`in`或`out`。

⁴ 或者，你可能只是自然界动态语言的爱好者之一，对通过静态类型表达语义感到过敏。如果是这样的话，C# 可能不是适合你的语言。

⁵ `IntPtr` 是一个通常用于不透明句柄值的值类型。在与互操作方案中有时你也会看到它 —— 在.NET 中，如果你看到一个来自操作系统 API 的原始句柄，它可能被表示为`IntPtr`，尽管在许多情况下，这已被`SafeHandle`取代。

⁶ 不幸的是，有两个相似的术语，它们几乎但不完全意味着同一件事情。C# 文档将*匿名函数*作为这两种方法表达式的通用术语。*匿名方法*可能更合适一些，因为并不是所有这些东西严格上都是函数 —— 它们可以有一个`void`返回值 —— 但在微软需要一个通用术语来指代这些东西时，那个名字已经被使用了。

⁷ 在这里看到`Func<Product,bool>`而不是`Predicate<Product>`可能会让你感到惊讶。`Where`方法是一个名为 LINQ 的 .NET 功能的一部分，该功能广泛使用委托。为了避免定义大量新的委托类型，LINQ 使用`Func`类型，并且为了 API 的一致性，即使其他标准类型也适用，它也更喜欢使用`Func`。
