# 第十六章：多线程

多线程使应用程序能够同时执行多个代码片段。这样做的两个常见原因之一是利用计算机的并行处理能力——多核 CPU 现在几乎无处不在，为了充分发挥性能潜力，您需要提供多个工作流以让所有核心有些有用的事情做。编写多线程代码的另一个常见原因是防止在执行缓慢操作（例如从磁盘读取）时进展停滞。

解决第二个问题的方式并不只有多线程——异步技术可能更可取。C# 提供了支持异步工作的特性。异步执行不一定意味着多线程，但实际上两者通常相关，我将在本章节描述一些异步编程模型。然而，本章节侧重于线程的基础知识。我将在第十七章中描述语言级别支持异步代码的特性。

# 线程

所有能运行 .NET 的操作系统都允许每个进程包含多个线程（尽管如果构建到 Web Assembly 并在浏览器中运行代码，当前特定环境不支持创建新线程）。每个线程都有自己的堆栈，操作系统呈现的假象是线程获得整个 CPU *硬件线程* 用于自己。 （见下一个侧边栏，“处理器、核心和硬件线程”）您可以创建比计算机提供的硬件线程数量更多的操作系统线程，因为操作系统虚拟化 CPU，从一个线程切换到另一个线程。我写这篇文章时使用的计算机有 16 个硬件线程，这是一个相当慷慨的数量，但比机器上运行的各种进程当前活动的 8,893 个线程还远远不够。

CLR 在操作系统线程之上提供自己的线程抽象。在 .NET Core 和 .NET 中，将始终存在直接关系——每个`Thread`对象直接对应于某个特定的底层操作系统线程。在 .NET Framework 中，这种关系并不保证存在——使用 CLR 的非托管托管 API 来自定义 CLR 和其包含进程之间的关系的应用程序理论上可以导致 CLR 线程在不同的操作系统线程之间移动。实际上，这种能力极少被使用，因此即使在 .NET Framework 中，在实践中每个 CLR 线程通常也会对应一个操作系统线程。

我将很快介绍`Thread`类，但在编写多线程代码之前，您需要了解在使用多个线程时管理状态的基本规则¹。

## 线程、变量和共享状态

每个 CLR 线程都拥有各自的线程特定资源，比如调用栈（保存方法参数和一些局部变量）。因为每个线程都有自己的栈，最终存储在其中的局部变量将仅属于该线程。每次调用方法时，都会得到一个新的局部变量集合。递归依赖于此特性，但在多线程代码中同样重要，因为对多个线程可访问的数据进行处理需要更多的注意，特别是如果数据发生变化的情况下。协调对共享数据的访问是复杂的。我将在“同步”章节中描述一些技术，但在可能的情况下最好避免这个问题，而栈的线程局部特性能够极大地帮助解决问题。

举例来说，考虑一个基于 Web 的应用程序。繁忙的站点必须同时处理来自多个用户的请求，因此您很可能会遇到这样一种情况：某个特定的代码（例如您站点首页的代码）同时在多个不同的线程上执行—ASP.NET Core 使用多线程能够为多个用户提供相同的逻辑页面。（网站通常不只是简单地提供相同的内容，因为页面通常根据特定用户进行定制，所以如果有 1,000 个用户请求查看主页，它将执行生成该页面的代码 1,000 次。）ASP.NET Core 提供了各种您的代码需要使用的对象，但其中大多数都是特定于特定请求的。因此，如果您的代码能够完全使用这些对象和局部变量，每个线程可以完全独立运行。如果需要共享状态（例如对多个线程可见的对象，可能通过静态字段或属性），生活将变得更加困难，但局部变量通常是比较简单的。

为什么只是“通常”？如果使用 lambda 表达式或匿名函数，情况会变得更加复杂，因为它们允许在包含方法中声明变量，然后在内部方法中使用该变量。现在这个变量对两个或更多方法都是可用的，并且在多线程情况下，这些方法可能会并发执行。（就 CLR 而言，它不再是真正的局部变量，而是编译器生成类中的字段。）在多个方法之间共享局部变量会导致局部性的保证丧失，因此您需要像对待更明显共享的项目（如静态属性和字段）那样谨慎对待这些变量。

在多线程环境中，另一个需要记住的重要点是变量和它所引用的对象之间的区别。（这仅涉及引用类型变量的问题。）尽管局部变量仅在其声明方法内部可访问，但该变量可能并不是唯一引用特定对象的变量。有时候它可能是——如果你在方法内部创建对象并且从未将其存储在任何可以使其对更广泛的受众可访问的地方，那么你就无需担心。示例 16-1 创建的`StringBuilder`仅在创建它的方法内部使用。

##### 示例 16-1\. 对象可见性和方法

```cs
public static string FormatDictionary<TKey, TValue>(
    IDictionary<TKey, TValue> input)
{
    var sb = new StringBuilder();
    foreach (var item in input)
    {
        sb.AppendFormat("{0}: {1}", item.Key, item.Value);
        sb.AppendLine();
    }

    return sb.ToString();
}
```

此代码无需担心其他线程可能试图修改`StringBuilder`。这里没有嵌套方法，因此`sb`变量确实是局部的，而这是唯一包含对`StringBuilder`的引用的内容。（这依赖于`StringBuilder`并未在其他线程可能看到的任何地方秘密存储其`this`引用的事实。）

但是`input`参数呢？它也是方法的局部变量，但它引用的对象却不是：调用`FormatDictionary`的代码得决定`input`引用的是什么。单看示例 16-1，无法确定它所引用的字典对象是否正在被其他线程使用。调用代码可能创建一个字典，并创建两个线程，其中一个修改字典，而另一个调用此`FormatDictionary`方法。这会造成问题：大多数字典实现不支持在一个线程修改字典的同时另一个线程使用它。即使你正在使用一个设计用于处理并发使用的集合，通常也不允许在枚举其内容的同时修改集合（例如`foreach`循环）。

你可能会认为任何设计用于同时从多个线程使用的集合（你可以说是*线程安全*集合）应该允许一个线程在修改其内容的同时另一个线程迭代其内容。如果不允许这样做，那么它如何是线程安全的呢？实际上，在此场景中，线程安全集合与非线程安全集合的主要区别在于可预测性：当它检测到这种情况发生时，线程安全集合可能会抛出异常，而非线程安全集合则不能保证会执行任何特定的操作。它可能会崩溃，或者你可能会从迭代中得到令人困惑的结果，例如单个条目多次出现。它可能会做任何事情，因为你正在不支持的方式中使用它。有时候，线程安全意味着失败以明确定义和可预测的方式发生。

事实上，`System.Collection.Concurrent` 命名空间中的各种集合确实支持在进行枚举时进行更改而不抛出异常。然而，它们大多数具有与其他集合类不同的 API，专门支持并发，因此它们通常不能直接替换。

没有任何方法可以确保 示例 16-1 在多线程环境中安全地使用其 `input` 参数，因为它完全取决于其调用者。并发危害需要在更高的级别处理。事实上，“线程安全”这个术语可能是误导性的，因为它暗示了一般情况下不可能的事情。经验不足的开发人员经常陷入这样的陷阱，认为只要确保他们使用的所有对象都是线程安全的，他们就免于思考其代码中的线程问题责任。但这通常行不通，因为虽然单个线程安全对象会维护其自身的完整性，但这并不能保证你的应用程序状态作为一个整体是一致的。

为了说明这一点，示例 16-2 使用了 `System.Collections.Concurrent` 命名空间中的 `ConcurrentDictionary<TKey, TValue>` 类。该类定义的每个操作在某种意义上都是线程安全的，因为每个操作都会使对象保持一致的状态，并且会在调用前产生预期的结果。然而，这个例子却构造出了一个非线程安全的使用方式。

##### 示例 16-2\. 非线程安全的线程安全集合使用

```cs
static string UseDictionary(ConcurrentDictionary<int, string> cd)
{
    cd[1] = "One";
    return cd[1];
}
```

看起来这似乎不会失败。（这也似乎毫无意义；这只是为了展示即使是一个非常简单的代码片段也可能出错。）但是如果字典实例被多个线程使用（考虑到我们选择的是专为多线程使用而设计的类型），完全有可能在设置键 1 的值并尝试检索它之间，某些其他线程已经删除了该条目。如果我将这段代码放入一个程序中，该程序在多个线程上重复运行此方法，但也有几个其他线程忙于删除相同的条目，我最终会看到 `KeyNotFoundException`。

并发系统需要一种自上而下的策略来确保系统范围内的一致性。（这就是为什么数据库管理系统通常使用事务的原因，事务将一组操作组合在一起作为原子工作单元，要么完全成功，要么完全不影响。这种原子分组是事务帮助确保系统范围内状态一致性的关键部分。）查看 示例 16-1，这意味着调用 `FormatDictionary` 的代码负责确保字典在方法执行期间可以自由使用。

###### 警告

虽然调用代码应确保它传递的任何对象在方法调用期间都是安全使用的，但通常不能假设可以保存对参数的引用以供将来使用。匿名函数和委托使得意外地这样做变得容易——如果嵌套方法引用其包含方法的参数，并且如果该嵌套方法在包含方法返回后运行，则不能再安全地假设您被允许访问参数所引用的对象。如果需要这样做，您需要记录您对何时可以使用对象的假设，并检查调用方法的任何代码以确保这些假设是有效的。

## 线程本地存储

有时在比单个方法更广泛的范围内维护线程本地状态可能很有用。运行时库的各个部分都在做这件事。例如，`System.Transactions` 命名空间定义了一个用于与数据库、消息队列和任何支持它们的资源管理器使用事务的 API。它提供了一个隐式模型，您可以在其中启动环境事务，并且任何支持此事务的操作将自动加入其中，而无需传递任何显式的与事务相关的参数。（它还支持显式模型，如果您更喜欢的话。）`Transaction` 类的静态 `Current` 属性返回当前线程的环境事务，如果当前线程没有正在进行的环境事务，则返回 `null`。

为了支持这种每线程状态，.NET 提供了 `ThreadLocal<T>` 类。示例 16-3 使用它来为委托提供包装，该委托仅允许在任一线程上任一时间只有一个对委托的调用进行中。

##### 使用 `ThreadLocal<T>` 的示例 16-3

```cs
class Notifier
{
    private readonly Action _callback;
    private readonly ThreadLocal<bool> _isCallbackInProgress = new();

    public Notifier(Action callback)
    {
        _callback = callback;
    }

    public void Notify()
    {
        if (_isCallbackInProgress.Value)
        {
            throw new InvalidOperationException(
                "Notification already in progress on this thread");
        }

        try
        {
            _isCallbackInProgress.Value = true;
            _callback();
        }
        finally
        {
            _isCallbackInProgress.Value = false;
        }
    }
}
```

如果 `Notify` 回调的方法尝试再次调用 `Notify`，这将通过抛出异常来阻止递归尝试。但是，因为它使用 `ThreadLocal<bool>` 来跟踪是否正在进行调用，这将允许同时调用，只要每次调用发生在不同的线程上。

您可以通过 `Value` 属性获取和设置 `ThreadLocal<T>` 为当前线程保存的值。构造函数是重载的，您可以传递一个 `Func<T>`，每次新线程首次尝试检索值时都会调用它以创建默认初始值。（初始化是惰性的——回调不会在每次新线程启动时都运行。`ThreadLocal<T>` 仅在新线程首次尝试使用值时调用回调。）您可以创建的 `ThreadLocal<T>` 对象数量没有固定限制。

`ThreadLocal<T>`还为跨线程通信提供了一些支持。如果你向接受布尔值的某个构造函数重载传递`true`参数，该对象将维护一个报告每个线程存储的最新值的集合，可以通过其`Values`属性获取。仅在构造对象时请求此服务时，它才提供此服务，因为这需要额外的管理工作。此外，如果你使用引用类型作为类型参数，启用跟踪可能意味着对象的存活时间会更长。通常情况下，线程在`ThreadLocal<T>`中存储的任何引用在线程终止时将不再存在，如果该引用是使对象可达的唯一引用，垃圾回收器将能够回收其内存。但如果启用跟踪，所有这些引用将在`ThreadLocal<T>`实例本身可达期间保持可达，因为`Values`即使对于已终止的线程也会报告值。

关于线程本地存储，有一件事需要特别注意。如果你为每个线程创建一个新对象，请注意应用程序可能在其生命周期内创建大量线程，特别是如果你使用线程池（稍后将详细描述）。如果你创建的每个线程对象很昂贵，这可能会引起问题。此外，如果存在任何一次性的线程本地资源，你不一定知道何时线程终止；线程池会定期创建和销毁线程，而无需告知你。

如果你不需要每次新线程首次使用线程本地存储时自动创建对象，你可以简单地使用`[ThreadStatic]`属性标注静态字段。这由 CLR 处理：这意味着每个访问此字段的线程都会得到自己独立的字段。这可以减少需要分配的对象数量。但要小心：对于这些字段可以定义字段初始化器，但初始化器仅在第一个访问该字段的线程运行时执行。对于使用相同`[ThreadStatic]`的其他线程，字段最初将包含该字段类型的默认零值。

最后需要注意的一点是：如果你计划使用 第十七章 中描述的异步语言特性，那么要谨慎使用线程本地存储（以及基于它的任何机制），因为这些特性使得单个方法的调用可以在进展过程中使用多个不同的线程。对于这种类型的方法来说使用环境事务或依赖于线程本地状态的任何其他事物将是一个不好的主意。许多.NET 功能可能会使用线程本地存储（例如，ASP.NET Core 框架的静态 `HttpContext.Current` 属性，它返回与当前线程处理的 HTTP 请求相关的对象），实际上是与称为*执行上下文*的东西关联的信息。执行上下文更加灵活，因为它可以在需要时跨线程跳转。我稍后会进行描述。

要使我刚刚讨论的问题变得相关，我们需要使用多个线程。有四种主要方法可以使用多线程。一种方法是在你的代表创建多个线程的框架中运行代码，例如 ASP.NET Core。另一种方法是使用某些类型的基于回调的 API。有关此的一些常见模式描述在 “任务” 和 “其他异步模式” 中。但是使用线程的两种最直接的方法是显式创建新线程或使用.NET 线程池。

## 线程类

正如我之前提到的，`Thread` 类（定义在 `System.Threading` 命名空间中）表示一个 CLR 线程。你可以通过 `Thread.CurrentThread` 属性获得一个代表执行你的代码的线程的 `Thread` 对象的引用，但是如果你想要引入一些多线程，你可以构造一个新的 `Thread` 对象。

当一个新线程开始时，它需要知道它应该运行哪些代码，因此你必须提供一个委托，线程将在开始时调用委托引用的方法。线程会运行直到该方法正常返回，或允许异常传播到堆栈顶部（或线程通过任何操作系统机制被强制终止或杀死其包含的进程）。示例 16-4 创建了三个线程同时下载三个网页的内容。

##### 示例 16-4\. 创建线程

```cs
internal static class Program
{
    private static readonly HttpClient http = new();

    private static void Main(string[] args)
    {
        Thread t1 = new(MyThreadEntryPoint);
        Thread t2 = new(MyThreadEntryPoint);
        Thread t3 = new(MyThreadEntryPoint);

        t1.Start("https://endjin.com/");
        t2.Start("https://oreilly.com/");
        t3.Start("https://dotnet.microsoft.com/");
    }

    private static void MyThreadEntryPoint(object? arg)
    {
        string url = (string)arg!;

        Console.WriteLine($"Downloading {url}");
        var response = http.Send(new HttpRequestMessage(HttpMethod.Get, url));
        using StreamReader r = new(response.Content.ReadAsStream());
        string page = r.ReadToEnd();
        Console.WriteLine($"Downloaded {url}, length {page.Length}");
    }
}
```

`Thread`构造函数有重载，并接受两种委托类型。`ThreadStart`委托需要一个不带参数且不返回值的方法，但在示例 16-4 中，`MyThreadEntryPoint`方法接受一个`object`参数，这与另一个委托类型`ParameterizedThreadStart`匹配。这提供了一种方法来向每个线程传递参数，这在多个不同线程调用相同方法时非常有用，就像这个示例所做的那样。线程在调用`Start`之前不会运行，并且如果使用`ParameterizedThreadStart`委托类型，则必须调用接受单个`object`参数的重载。我正在使用这个功能让每个线程从不同的 URL 下载。

`Thread`构造函数还有两个重载，每个在委托参数之后添加一个`int`参数。这个`int`指定线程的堆栈大小。当前的.NET 实现要求堆栈在内存中是连续的，因此需要预分配堆栈的地址空间。如果线程耗尽了这个空间，CLR 会抛出`StackOverflowException`。（通常只有在错误导致无限递归时才会看到这些异常。）如果没有提供这个参数，CLR 将使用进程的默认堆栈大小。（这取决于操作系统；在 Windows 上通常为 1 MB。您可以通过设置`DOTNET_DefaultStackSize`环境变量来更改它。请注意，它将该值解释为十六进制数。）通常情况下不需要更改这个设置，但也不是不可能的。如果您有产生非常深堆栈的递归代码，可能需要在具有较大堆栈的线程上运行它。相反，如果您创建大量线程，可能希望减少堆栈大小以节省资源，因为默认的 1 MB 通常远远超过实际需要的量。但是，通常不建议创建如此大量的线程。因此，在大多数情况下，您将仅创建适度数量的线程，并使用使用默认堆栈大小的构造函数。

注意，在示例 16-4 中的`Main`方法在启动三个线程后立即返回。尽管如此，应用程序会继续运行——直到所有线程都完成为止。CLR 会保持进程处于活动状态，直到没有正在运行的*前台线程*为止，其中前台线程指的是未明确指定为后台线程的任何线程。如果要阻止特定线程继续运行进程，请将其`IsBackground`属性设置为`true`。（这意味着后台线程可能会在执行过程中被终止，因此在这些线程上执行的工作需要小心。）

直接创建线程并非唯一选择。线程池提供了一个常用的替代方案。

## 线程池

在大多数操作系统中，创建和关闭线程相对昂贵。如果需要执行一段相对较短的工作（例如提供一个网页或类似的简短操作），创建一个线程来完成这项工作，并在完成后将其关闭是一个不好的主意。这个策略有两个严重问题：首先，你可能会在启动和关闭成本上消耗更多资源，而不是在有用的工作上；其次，如果你不断创建新线程以应对更多的工作，系统在负载下可能会变得停滞不前——在重负载情况下，创建越来越多的线程往往会降低吞吐量。这是因为，除了基本的每个线程的开销，如堆栈所需的内存外，操作系统需要定期在可运行的线程之间切换，以使它们都能进展，而这种切换本身也有开销。

为避免这些问题，.NET 提供了一个线程池。你可以提供一个委托，运行时将调用线程池中的一个线程。如果有必要，它将创建一个新线程，但在可能的情况下，它将重用之前创建的线程，如果所有创建的线程都在忙，它可能会将你的工作等待在队列中。在方法运行后，CLR 通常不会终止线程；相反，线程将留在池中，等待其他工作项在多个工作项之间摊销创建线程的成本。如果有必要，它会创建新线程，但它尝试将线程数保持在一个水平，以使可运行线程的数量匹配硬件线程的数量，以最小化切换成本。

###### 警告

线程池始终创建后台线程，因此，如果线程池在你的进程中最后一个前台线程退出时正在执行某些操作，工作将不会完成，因为所有后台线程将在此时终止。如果需要确保线程池上的工作完成，你必须在允许所有前台线程完成之前等待其完成。

### 使用 Task 启动线程池工作

使用线程池的常用方法是通过 `Task` 类。这是任务并行库的一部分（在“任务”中有更详细的讨论），但其基本使用非常简单，如示例 16-5 所示。

##### 示例 16-5。使用 `Task` 在线程池上运行代码

```cs
Task.Run(() => MyThreadEntryPoint("https://oreilly.com/"));
```

这将 lambda 排队等待在线程池上执行（当它运行时，只调用来自示例 16-4 的 `MyThreadEntryPoint` 方法）。如果有线程可用，它将立即开始运行；否则，它将等待在队列中，直到有线程可用（要么是因为其他正在进行的工作项完成，要么是因为线程池决定向池中添加新线程）。

还有其他使用线程池的方法，其中最明显的是通过`ThreadPool`类。其`QueueUserWorkItem`方法的工作方式与`Start`类似——你传递一个委托，它将方法排队等待执行。这是一个较低级别的 API，它不提供任何直接处理工作完成的方式，也不能链式操作，所以在大多数情况下，`Task`类更可取。

### 线程创建启发式方法

运行时根据你提供的工作负载调整线程数量。它使用的启发式方法没有记录并且在.NET 的不同版本中已经改变，因此你不应依赖于我即将描述的确切行为；然而，大致了解可以预期发生的事情仍然很有用。

如果你只给线程池 CPU 绑定的工作，即你要求它执行的每个方法都花费全部时间进行计算，并且从不阻塞等待 I/O 完成，你可能会得到与系统中每个硬件线程相对应的一个线程池线程（尽管如果单个工作项目耗时足够长，线程池可能会决定分配更多线程）。例如，在我写这篇文章时使用的八核双路超线程计算机上，首先排队一堆 CPU 密集型工作项目会导致 CLR 创建 16 个线程池线程，并且只要工作项目大约每秒完成一次，线程数量大部分时候都保持在这个水平（偶尔会超过，因为运行时会尝试不时添加额外的线程以查看其对吞吐量的影响，然后再次降回来）。但是，如果程序处理项目的速度下降，CLR 会逐渐增加线程计数。

如果线程池线程被阻塞（例如，它们正在等待来自磁盘的数据或者从服务器上的网络响应），CLR 会更快地增加线程池线程的数量。同样，它从每个硬件线程开始，但是当慢工作项目几乎不消耗处理器时间时，它可以每秒添加两次线程。

无论哪种情况，CLR 最终会停止添加线程。在 32 位进程中，确切的默认限制因 .NET 版本而异，通常约为 1,000 个线程。在 64 位模式下，默认值似乎是 32,767。您可以更改此限制——`ThreadPool` 类具有 `SetMaxThreads` 方法，允许您为进程配置不同的限制。您可能会遇到其他限制，从而导致更低的实际限制。例如，每个线程都有自己的堆栈，必须占用虚拟地址空间的连续范围。默认情况下，每个线程获得 1 MB 的进程地址空间用于其堆栈，因此当您有 1,000 个线程时，仅用于堆栈的地址空间就将达到 1 GB。32 位进程仅有 4 GB 的地址空间，因此您可能没有足够的空间来请求的线程数量。无论如何，1,000 个线程通常比有用的更多，因此如果达到这么高，这可能是您应该调查的一些潜在问题的症状。因此，如果调用 `SetMaxThreads`，通常会是为了指定一个较低的限制——您可能会发现，在某些工作负载下，通过限制线程数量来减少对系统资源的争用程度，从而提高吞吐量。

`ThreadPool` 还具有 `SetMinThreads` 方法。这使您可以确保线程数不会低于某个数字。这对于那些希望在最小数量的线程下能够立即以最大速度运行，而不必等待线程池的启发式算法调整线程计数的应用程序非常有用。

## 线程亲和性和同步上下文

有些对象要求您只能从特定的线程中使用它们。这在 UI 代码中特别常见——WPF 和 Windows Forms UI 框架要求 UI 对象必须从创建它们的线程上使用。这被称为*线程亲和性*，虽然它通常是一个 UI 的关注点，但也可能在互操作性场景中出现——一些 COM 对象具有线程亲和性。

如果您想编写多线程代码，线程亲和性可能会让生活变得尴尬。假设您已经精心实现了一个多线程算法，可以利用最终用户计算机上的所有硬件线程，在多核 CPU 上运行时显著提高性能，与单线程算法相比。一旦算法完成，您可能希望向最终用户呈现结果。UI 对象的线程亲和性要求您在特定线程上执行最后一步操作，但您的多线程代码可能会在其他线程上生成最终结果。（事实上，为了确保 UI 在进行工作时保持响应，您可能完全避免使用 UI 线程进行 CPU 密集型工作。）如果您试图从某个随机的工作线程更新 UI，则 UI 框架将抛出异常，指责您违反了其线程亲和性要求。您需要想办法将消息传回 UI 线程，以便它可以显示结果。

运行时库提供了`SynchronizationContext`类来帮助处理这些情况。其`Current`静态属性返回一个`SynchronizationContext`类的实例，表示当前代码运行的上下文。例如，在 WPF 应用程序中，如果在 UI 线程上检索此属性，它将返回与该线程关联的对象。您可以存储`Current`返回的对象，并在任何时候从任何线程使用它来执行进一步的 UI 线程工作。示例 16-6 正是这样做的，以便它可以在线程池线程上执行一些潜在的缓慢工作，然后在 UI 线程上更新 UI。

##### 示例 16-6\. 使用线程池然后`SynchronizationContext`

```cs
private void findButton_Click(object sender, RoutedEventArgs e)
{
    `SynchronizationContext` `uiContext` `=` `SynchronizationContext``.``Current``!``;`

    Task.Run(() =>
    {
        string pictures =
            Environment.GetFolderPath(Environment.SpecialFolder.MyPictures);
        var folder = new DirectoryInfo(pictures);
        FileInfo[] allFiles =
            folder.GetFiles("*.jpg", SearchOption.AllDirectories);
        FileInfo? largest =
            allFiles.OrderByDescending(f => f.Length).FirstOrDefault();

        if (largest is not null)
        {
            `uiContext``.``Post``(``_` `=``>`
            {
                long sizeMB = largest.Length / (1024 * 1024);
                outputTextBox.Text =
                    $"Largest file ({sizeMB}MB) is {largest.FullName}";
            },
            null);
        }
    });
}
```

此代码处理按钮的`Click`事件。（它恰好是一个 WPF 应用程序，但`SynchronizationContext`在其他桌面 UI 框架（如 Windows Forms）中的工作方式完全相同。）UI 元素在 UI 线程上引发其事件，因此当点击处理程序的第一行检索当前的`SynchronizationContext`时，它将获取 UI 线程的上下文。然后，代码通过`Task`类在线程池线程上运行一些工作。该代码查看用户“图片”文件夹中的每张图片，搜索最大的文件，因此可能需要一段时间。在 UI 线程上执行缓慢的工作是一个坏主意——属于该线程的 UI 元素在 UI 线程忙于其他事情时无法响应用户输入。因此将其推入线程池是个好主意。

在这里使用线程池的问题在于，一旦工作完成，我们就在错误的线程上更新 UI。此代码更新文本框的 `Text` 属性，如果我们尝试从线程池线程中执行此操作，将会抛出异常。因此，当工作完成时，它使用先前检索的 `SynchronizationContext` 对象，并调用其 `Post` 方法。该方法接受一个委托，并安排在 UI 线程上调用它。在幕后，它向 Windows 消息队列发布一个自定义消息，当 UI 线程的主消息处理循环接收到该消息时，将调用委托。

###### 提示

`Post` 方法不等待工作完成。有一个名为 `Send` 的方法可以等待，但我建议不要使用它。使工作线程在等待 UI 线程执行某些操作时阻塞可能存在风险，因为如果 UI 线程当前正在等待工作线程执行某些操作，应用程序将出现死锁。`Post` 通过允许工作线程与 UI 线程并发运行来避免此问题。

示例 16-6 在开始线程池工作之前，仍然在 UI 线程上检索 `SynchronizationContext.Current`。这很重要，因为这个静态属性是上下文敏感的——只有在 UI 线程上时，它才返回 UI 线程的上下文。事实上，在 WPF 中，每个窗口可能都有自己的 UI 线程，因此不可能有一个返回 *the* UI 线程的 API——可能会有多个。如果你从线程池线程读取此属性，它返回的上下文对象将无法将工作发布到 UI 线程上。

`SynchronizationContext` 机制是可扩展的，因此如果需要，你可以从中派生自己的类型，并可以调用其静态方法 `SetSynchronizationContext` 将你的上下文设为当前线程的上下文。在单元测试场景中这非常有用——它使你能够编写测试来验证对象是否正确地与 `SynchronizationContext` 交互，而无需创建真正的 UI。

## 执行上下文

`SynchronizationContext` 类有一个类似的伙伴，叫做 `ExecutionContext`。它提供了类似的服务，允许你捕获当前的上下文，然后稍后在同一上下文中运行委托，但有两点不同。首先，它捕获不同的内容。其次，它使用不同的方法重新建立上下文。`SynchronizationContext` 通常会在特定的线程上运行你的工作，而 `ExecutionContext` 则总是使用你的线程，并确保所有捕获的上下文信息都可在该线程上使用。区分这两者的一种思路是，`SynchronizationContext` 在现有上下文中完成工作，而 `ExecutionContext` 则将上下文信息带给你。

###### 警告

有点令人困惑的是，在 .NET Framework 上，`ExecutionContext` 的实现捕获当前的 `SynchonizationContext`，因此从某种意义上讲，`ExecutionContext` 是 `SynchronizationContext` 的超集。然而，`ExecutionContext` 在调用委托时不使用捕获的 `SynchronizationContext`。它所做的只是确保，如果通过 `ExecutionContext` 执行的代码读取 `SynchonizationContext.Current` 属性，它将获取在捕获 `ExecutionContext` 时当前的 `SynchronizationContext` 属性。这不一定是当前线程正在运行的 `SynchonizationContext`！这个设计缺陷在 .NET Core 中已经修复。

调用 `ExecutionContext.Capture` 方法可以检索当前的上下文。执行上下文不会捕获线程局部存储，但会包括当前的*逻辑调用上下文*中的任何信息。您可以通过 `CallContext` 类访问这些信息，该类提供 `LogicalSetData` 和 `LogicalGetData` 方法来存储和检索名称/值对，或通过更高级的包装器 `Async​Lo⁠cal<T>` 访问。这些信息通常与当前线程相关联，但是如果在捕获的执行上下文中运行代码，即使该代码在完全不同的线程上运行，逻辑上下文中的信息也将可用。

.NET 在一些异步模式中描述的情况下，当长时间运行的工作从一个线程开始，最终在另一个线程上继续时（这在本章的某些异步模式中会发生），会在内部使用 `ExecutionContext` 类。如果您编写接受稍后将调用的回调函数的任何代码，您可能希望以类似的方式使用执行上下文。为此，您调用 `Capture` 方法来获取当前的上下文，稍后可以将其传递给 `Run` 方法以调用委托。示例 16-7 展示了 `ExecutionContext` 的工作方式。

##### 示例 16-7\. 使用 `ExecutionContext`

```cs
public class Defer
{
    private readonly Action _callback;
    private readonly ExecutionContext? _context;

    public Defer(Action callback)
    {
        _callback = callback;
        _context = ExecutionContext.Capture()!;
    }

    public void Run()
    {
        if (_context is null) { _callback(); return; }
        // When ExecutionContext.Run invokes the lambda we supply as the 2nd
        // argument, it passes that lambda the value we supplied as the 3rd
        // argument to Run. Here we're passing _callback, so the lambda has
        // access to the Action we want to invoke. It would have been simpler
        // to write "_ => _callback()", but the lambda would then need to
        // capture 'this' to be able to access _callback, and that capture
        // would cause an additional allocation.
        ExecutionContext.Run(_context, (cb) => ((Action)cb!)(), _callback);
    }
}
```

在 .NET Framework 中，单个捕获的 `ExecutionContext` 不能同时在多个线程上使用。有时您可能需要在特定上下文中调用多个不同的方法，在多线程环境中，您可能无法保证上一个方法在调用下一个方法之前已经返回。对于这种情况，`ExecutionContext` 提供了一个 `CreateCopy` 方法，生成上下文的副本，使您能够通过等效的上下文进行多个并发调用。在 .NET Core 和 .NET 中，`ExecutionContext` 是不可变的，这意味着不再受此限制，`CreateCopy` 方法只返回其自身引用。

# 同步

有时候，您可能需要编写多线程代码，其中多个线程可以访问相同的状态。例如，在第五章中，我建议服务器可以使用 `Dictionary<TKey, TValue>` 作为缓存的一部分，以避免在接收到多个类似请求时重复工作。虽然这种缓存在某些场景下可以提供显著的性能优势，但在多线程环境中却是一个挑战。（如果您正在处理具有严格性能要求的服务器代码，很可能需要多个线程来处理请求。）`Dictionary<TKey, TValue>` 类的文档中的线程安全部分指出：

> `Dictionary<TKey, TValue>` 可以支持多个读取器同时操作，只要不修改集合。即便如此，枚举集合本质上不是线程安全的过程。在枚举与写访问竞争的罕见情况下，必须在整个枚举过程中锁定集合。要允许集合被多个线程同时读取和写入，必须实现自己的同步。

这比我们所期望的要好——运行库中绝大多数类型根本不支持实例的多线程使用。大多数类型在类级别支持多线程使用，但是每个实例必须一次使用一个线程。 `Dictionary<TKey, TValue>` 更为宽松：它明确支持多个并发读取器，这对我们的缓存场景听起来很有利。然而，在修改集合时，我们不仅必须确保不会尝试同时从多个线程修改它，还必须确保在此期间没有正在进行的读取操作。

其他通用的集合类也提供类似的保证（不同于库中的大多数其他类）。例如，`List<T>`、`Queue<T>`、`Stack<T>`、`SortedDictionary<TKey, TValue>`、`HashSet<T>` 和 `SortedSet<T>` 都支持并发的只读使用。（同样，如果您修改了这些集合的任何实例，必须确保没有其他线程同时修改或读取同一个实例。）当然，在尝试多线程使用任何类型之前，您应该始终检查文档。² 请注意，通用集合接口类型不提供线程安全保证——尽管 `List<T>` 支持并发读取，但并非所有 `IList<T>` 的实现都会如此。 （例如，想象一个包装潜在缓慢内容的实现，比如文件内容。这种包装可能会缓存数据以提高读取操作的速度。从这样的列表中读取项目可能会改变其内部状态，因此如果代码没有采取保护措施，同时从多个线程进行读取可能会导致读取失败。）

如果你可以安排在多线程代码使用数据结构时永远不修改数据结构，则许多集合类提供的并发访问支持可能已经足够。但如果某些线程需要修改共享状态，则需要协调对该状态的访问。为此，.NET 提供了各种同步机制，可以确保在必要时线程轮流访问共享对象。在本节中，我将描述最常用的几种。

## 监视器和 lock 关键字

用于同步多线程共享状态的首选选项是 `Monitor` 类。这很受欢迎，因为它高效且提供了直观的模型，而且 C# 提供了直接的语言支持，使用起来非常简单。示例 16-8 展示了一个使用 `lock` 关键字（其实使用 `Monitor` 类）的类，每当它读取或修改其内部状态时都会使用它。这确保了只有一个线程会同时访问该状态。

##### 示例 16-8\. 使用 `lock` 保护状态

```cs
public class SaleLog
{
    private readonly object _sync = new();

    private decimal _total;

    private readonly List<string> _saleDetails = new();

    public decimal Total
    {
        get
        {
            lock (_sync)
            {
                return _total;
            }
        }
    }

    public void AddSale(string item, decimal price)
    {
        string details = $"{item} sold at {price}";
        lock (_sync)
        {
            _total += price;
            _saleDetails.Add(details);
        }
    }

    public string[] GetDetails(out decimal total)
    {
        lock (_sync)
        {
            total = _total;
            return _saleDetails.ToArray();
        }
    }
}
```

要使用 `lock` 关键字，你需要提供一个对象引用和一段代码块。C# 编译器生成的代码将导致 CLR 确保任何时候一个对象的 `lock` 块内不会有多于一个线程。假设你创建了 `SaleLog` 类的单个实例，并且在一个线程上调用了 `AddSale` 方法，而在另一个线程上同时调用了 `GetDetails`。两个线程都会达到 `lock` 语句，传入相同的 `_sync` 字段。无论哪个线程先到达，都将被允许运行 `lock` 后面的代码块。另一个线程将被阻塞，直到第一个线程离开其 `lock` 块为止。

`SaleLog` 类仅在使用 `_sync` 参数的 `lock` 块内部使用其字段。这确保所有对字段的访问都是串行化的（在并发意义上——即线程一次只能访问一个字段，而不是同时进入）。当 `GetDetails` 方法从 `_total` 和 `_saleDetails` 字段读取时，可以确信它得到的是一致的视图——总数将与销售详情列表的当前内容保持一致，因为修改这两个数据的代码都在单个 `lock` 块内执行。这意味着从使用 `_sync` 的任何其他 `lock` 块的视角来看，更新将看起来是原子的。

即使是用于返回总数的`get`访问器，使用`lock`块可能看起来有些过度。然而，`decimal`是一个 128 位的值，因此对于这种类型的数据访问并不是固有地原子的——如果没有那个`lock`，返回的值可能由`_total`在不同时间点上具有的两个或更多值的混合组成。（例如，底部 64 位可能来自比顶部 64 位更旧的值。）这经常被描述为*破碎读*。CLR 仅对大小不超过 4 字节的数据类型和引用保证原子读写，即使在引用大于 4 字节的平台上也是如此。（它仅对自然对齐字段保证这一点，但在 C#中，字段总是对齐的，除非你故意为了互操作目的而使它们错位。）

示例 16-8 的一个微妙但重要的细节是，每当它返回关于其内部状态的信息时，它都会返回一个副本。`Total`属性的类型是`decimal`，这是一个值类型，值总是作为副本返回。但是当涉及到条目列表时，`GetDetails`方法调用`ToArray`，它将构建一个包含列表当前内容副本的新数组。直接返回`_saleDetails`中的引用将是一个错误，因为这将使得`SalesLog`类外部的代码能够访问和修改集合而不使用`lock`。我们需要确保对该集合的所有访问都是同步的，如果我们的类向外部提供对其内部状态的引用，我们将失去这种能力。

###### 提示

如果你编写的代码执行一些多线程工作，最终停止，那么在工作停止后共享对状态的引用是可以的。但是，如果对象正在进行多线程修改，你需要确保对该对象状态的所有使用都受到保护。

`lock`关键字接受任何对象引用，所以你可能会想知道为什么我专门创建了一个对象——不能直接传递`this`吗？那确实可以工作，但问题在于你的`this`引用不是私有的——它是外部代码使用你的对象的同一个引用。使用你对象的公开可见特性来同步访问私有状态是不明智的；其他代码可能会决定将你的对象的引用用作某些完全不相关的`lock`块的参数。在这种情况下，可能不会造成问题，但在更复杂的代码中，它可能会以一种可能导致性能问题甚至死锁的方式将概念上不相关的并发行为联系在一起。因此，通常最好以防御性编程，并使用只有你的代码可以访问的东西作为`lock`参数。当然，我可以使用`_saleDetails`字段，因为它引用了只有我的类可以访问的对象。然而，即使你进行防御性编程，也不应假设其他开发人员会这样做，因此一般来说，最安全的做法是避免使用你没有编写的类的实例作为`lock`的参数，因为你无法确定它是否在使用它自己的`this`引用进行自身的锁定目的。

你可以使用任何对象引用这一事实在任何情况下都有些奇怪。大多数.NET 的同步机制使用某种不同类型的实例作为同步的参考点。（例如，如果你想要读者/写者锁定语义，你会使用`ReaderWriterLockSlim`类的实例，而不仅仅是任意对象。）`Monitor`类（即`lock`使用的类）是一个例外，它可以追溯到与 Java 的某种程度兼容性的旧需求。（Java 有类似的锁原语。）这与现代.NET 开发无关，因此这个特性现在只是一个历史上的特殊情况。使用一个专门作为`lock`参数的独特对象，与锁定的成本相比增加了最小的开销，并且倾向于使同步管理变得更加清晰。

###### 注意

你不能将值类型用作`lock`的参数——C#会阻止这样做，这是有道理的。编译器会在`lock`参数上执行隐式转换为`object`，对于引用类型来说，在运行时不需要 CLR 做任何事情。但是当你将值类型转换为`object`类型的引用时，需要创建一个装箱。那个装箱将成为`lock`的参数，这将是一个问题，因为每次将值转换为`object`引用时，都会得到一个新的装箱。因此，每次运行`lock`时，它会得到一个不同的对象，这意味着实际上没有同步。这就是为什么编译器阻止你尝试这样做的原因。

### 如何扩展 `lock` 关键字

每个 `lock` 块转换为代码，执行三件事情：首先，调用 `Monitor.Enter`，传递给 `lock` 的参数。然后尝试运行块中的代码。最后，一般情况下，一旦块完成，将调用 `Monitor.Exit`。但由于异常，情况并不完全简单。如果您在块中放置的代码引发异常，代码仍然会调用 `Monitor.Exit`，但需要处理 `Monitor.Enter` 本身引发异常的可能性，这意味着线程没有获取锁，因此不应调用 `Monitor.Exit`。示例 16-9 展示了编译器在 示例 16-8 中的 `GetDetails` 方法中 `lock` 块的处理方式。

##### 示例 16-9\. `lock` 块的展开方式

```cs
bool lockWasTaken = false;
object temp = _sync;
try
{
    Monitor.Enter(temp, ref lockWasTaken);
    {
        total = _total;
        return _saleDetails.ToArray();
    }
}
finally
{
    if (lockWasTaken)
    {
        Monitor.Exit(temp);
    }
}
```

`Monitor.Enter` 是一个 API，它负责发现是否有其他线程已经拥有锁，并在这种情况下使当前线程等待。如果此操作返回，通常意味着获取锁成功。（可能会发生死锁，这种情况下它将永远不会返回。）由于内存耗尽等异常情况的发生，有可能会出现获取失败的小概率情况。虽然这种情况不太常见，但生成的代码仍会考虑这一点——这就是对 `lockWasTaken` 变量进行稍微绕远的代码的目的。（实际上，编译器会将其作为一个无法访问名称的隐藏变量。顺便说一句，我已经命名它以显示这里发生了什么。）`Monitor.Enter` 方法确保获取锁与更新指示锁是否被获取的标志是原子性的，这样 `finally` 块将仅在成功获取锁时尝试调用 `Exit`。

`Monitor.Exit` 告诉 CLR 我们不再需要对我们同步访问的任何资源进行独占访问，如果其他任何线程在对象内的 `Monitor.Enter` 中等待，则允许其中一个线程继续执行。编译器将此放置在 `finally` 块中，以确保无论您通过运行到末尾、从中间返回还是抛出异常退出块，锁都将被释放。

`lock` 块在异常发生时调用 `Monitor.Exit`，这是一把双刃剑。一方面，通过确保在失败时释放锁，它减少了死锁的可能性。另一方面，如果在修改某些共享状态时发生异常，系统可能处于不一致的状态；释放锁将允许其他线程访问该状态，可能导致进一步的问题。在某些情况下，如果异常发生时保持锁定状态可能更好——一个死锁的进程可能比在损坏状态下继续运行造成的危害小。更健壮的策略是编写能够在异常情况下保证一致性的代码，方法可以是如果异常阻止了完整的更新集，则回滚任何已进行的更改；或通过以原子方式改变状态（例如，将新状态放入一个全新对象，并仅在更新对象完全初始化后将其替换为先前的对象）。但这已经超出了编译器能自动处理的范围。

### 等待和通知

`Monitor` 类不仅仅用于确保线程轮流执行。它还提供了一种方法，让线程等待来自其他线程的通知。如果一个线程已经获取了特定对象的监视器，它可以调用 `Monitor.Wait` 并传入该对象。这有两个效果：释放监视器并使线程阻塞。线程将阻塞，直到其他线程为相同的对象调用 `Monitor.Pulse` 或 `PulseAll`。调用这些方法时，线程必须持有监视器。(`Wait`, `Pulse` 和 `PulseAll` 在没有持有相关监视器时会抛出异常。)

如果一个线程调用 `Pulse`，则允许一个等待在 `Wait` 中的线程唤醒。调用 `PulseAll` 则允许所有等待在该对象监视器上的线程运行。无论哪种情况，`Monitor.Wait` 在返回前都会重新获取监视器，因此即使调用 `PulseAll`，线程也会逐个唤醒——第二个线程在第一个线程释放监视器之前无法从 `Wait` 返回。事实上，直到调用 `Pulse` 或 `PulseAll` 的线程释放锁，没有线程能够从 `Wait` 返回。

示例 16-10 使用 `Wait` 和 `Pulse` 包装了一个 `Queue<T>`，使得从队列中检索项目的线程在队列为空时等待。（这只是为了说明，如果你需要这种类型的队列，不必自己编写，可以使用内置的 `BlockingCollection<T>` 或 `System.Thread⁠ing​.Channels` 中的类型。）

##### 示例 16-10\. `Wait` 和 `Pulse`

```cs
public class MessageQueue<T>
{
    private readonly object _sync = new();

    private readonly Queue<T> _queue = new();

    public void Post(T message)
    {
        lock (_sync)
        {
            bool wasEmpty = _queue.Count == 0;
            _queue.Enqueue(message);
            if (wasEmpty)
            {
                Monitor.Pulse(_sync);
            }
        }
    }

    public T Get()
    {
        lock (_sync)
        {
            while (_queue.Count == 0)
            {
                Monitor.Wait(_sync);
            }
            return _queue.Dequeue();
        }
    }
}
```

本示例以两种方式使用监视器。它通过 `lock` 关键字确保一次只有一个线程使用保存排队项的 `Queue<T>`。但它还使用等待和通知使消费项的线程在队列为空时能够有效地阻塞，并使任何添加新项到队列的线程能唤醒被阻塞的读取线程。

### 超时

无论是等待通知还是尝试获取锁定，都可以指定超时，表示如果操作在指定时间内未成功，则希望放弃。对于锁的获取，使用不同的方法 `TryEnter`，但在等待通知时，只需使用不同的重载。（没有编译器支持这一点，因此你将无法使用 `lock` 关键字。）在两种情况下，你可以传递一个表示最大等待时间（以毫秒为单位）的 `int` 或 `TimeSpan` 值。两者都返回一个指示操作是否成功的 `bool`。

你可以使用这个方法来避免进程死锁，但如果你的代码在超时内未能获取锁，那么你就面临着如何处理这个问题的困扰。如果你的应用程序无法获取需要的锁，那么它不能简单地无视原本要做的工作。终止进程可能是唯一现实的选择，因为死锁通常是 bug 的症状，所以如果发生了，你的进程可能已经处于受损状态。尽管如此，一些开发人员对锁的获取可能不那么严格，可能认为死锁是正常的情况。在这种情况下，可能放弃你原本尝试的操作，稍后重试工作，或者只是记录一个失败，放弃这个特定的操作，并继续进行进程的其他工作，可能是一个可行的策略。但这可能是一种风险策略。

## 自旋锁

`SpinLock` 提供了与 `Monitor` 类的 `Enter` 和 `Exit` 方法类似的逻辑模型。（它不支持等待和通知。）它是一个值类型，因此在某些情况下，它可以减少需要分配以支持锁定的对象数量——`Monitor` 需要基于堆的对象。然而，它也更简单：它仅使用一种策略来处理争用，而 `Monitor` 从相同的策略开始，然后在一段时间后将切换到具有更高初始开销但如果涉及长时间等待则更有效的策略。

当调用 `Enter` 方法（无论是 `Monitor` 还是 `SpinLock`）时，如果锁可用，则会非常快地获取该锁——成本通常是少量的 CPU 指令。如果锁已被另一个线程持有，CLR 将在一个轮询锁的循环中等待（即*自旋*），直到锁被释放。如果锁仅被持有很短的时间，这可以是一种非常高效的策略，因为它避免了操作系统介入，并且在锁可用的情况下非常快速。即使存在争用，自旋在多核或多 CPU 系统上也可以是最有效的策略，因为如果锁仅被持有很短的时间（例如只需执行加法运算两个 `decimal` 的时间），线程在锁变得可用之前不必自旋很长时间。

`Monitor` 和 `SpinLock` 的区别在于，`Monitor` 最终会放弃自旋，转而使用操作系统的调度器。这将产生相当于执行许多千甚至百万次 CPU 指令的成本，这就是为什么 `Monitor` 开始时使用与 `SpinLock` 类似的方法。然而，如果锁长时间不可用，自旋效率低下——即使只自旋几毫秒，现代 CPU 上会涉及数百万次自旋，在这种情况下，执行成千上万条指令以有效地挂起线程看起来更好一些。（自旋在单核系统上也存在问题，因为自旋依赖于持有锁的线程能够取得进展。^(3）

`SpinLock` 没有后备策略。与 `Monitor` 不同，它会自旋，直到成功获取锁或超时（如果指定了超时）。因此，文档建议，如果在持有锁期间执行某些操作（例如等待 I/O 完成或调用可能阻塞的其他代码），不应使用 `SpinLock`。它还建议不要通过接口、虚方法或委托调用方法，或者分配内存。如果在做任何较为复杂的事情，最好还是使用 `Monitor`。然而，对于访问 `decimal`，`SpinLock` 可能是一种适当的保护方式，正如 Example 16-11 所示。

##### Example 16-11\. 使用 `SpinLock` 保护 `decimal` 的访问

```cs
public class DecimalTotal
{
    private decimal _total;

    private SpinLock _lock;

    public decimal Total
    {
        get
        {
            bool acquiredLock = false;
            try
            {
                _lock.Enter(ref acquiredLock);
                return _total;
            }
            finally
            {
                if (acquiredLock)
                {
                    _lock.Exit();
                }
            }
        }
    }

    public void Add(decimal value)
    {
        bool acquiredLock = false;
        try
        {
            _lock.Enter(ref acquiredLock);
            _total += value;
        }
        finally
        {
            if (acquiredLock)
            {
                _lock.Exit();
            }
        }
    }
}
```

由于缺乏编译器支持，我们必须编写比使用`lock`更多的代码。也许这样做并不值得——因为`Monitor`在开始时会自旋，所以性能可能相似，因此这里唯一的好处是我们避免了为执行锁定而分配额外的堆对象。（`SpinLock`是一个`struct`，所以它存在于`DecimalTotal`对象的堆块内。）只有在通过性能分析证明在实际工作负载下它比监视器表现更好时，才应该使用`SpinLock`。

## 读者/写者锁

`ReaderWriterLockSlim`类提供了一种不同的锁定模型，与`Monitor`和`SpinLock`呈现的模型不同。使用`ReaderWriterLockSlim`时，获取锁时需指定自己是读取器还是写入器。该锁允许多个线程同时成为读取器。但是，当一个线程请求以写入器身份获取锁时，该锁会暂时阻止任何试图读取的线程，并等待所有已经在读取的线程释放其锁，然后才授予想要写入的线程访问权限。一旦写入器释放其锁，所有等待读取的线程就可以重新进入。这使得写入线程可以获得独占访问，但这也意味着当没有写入发生时，所有读取者可以并行进行。

###### 警告

还有一个`ReaderWriterLock`类。不应使用它，因为即使没有锁争用，它也存在性能问题，并且当读取器和写入器线程都在等待获取锁时，它也会做出次优选择。较新的`ReaderWriterLockSlim`类已经存在很长时间（自.NET 3.5 起），并建议在所有场景中使用它而不是旧类。旧类仅保留用于向后兼容。

这听起来可能适合.NET 内置的许多集合类。正如我之前描述的，它们通常支持多个并发的读取线程，但要求修改必须由一个线程独占完成，并且在进行修改时没有读取器活动。然而，并不是在你偶尔同时有读者和写者的情况下就一定要选择这种锁。

尽管“slim”锁相较于其前身有了性能改进，但是获取该锁的时间仍比进入监视器要长。如果计划仅短时间持有该锁，可能更好直接使用监视器——通过更大的并发性提供的理论改进可能会被获取锁所需的额外工作所抵消。即使持有锁的时间较长，只有在更新偶尔发生时，读者/写者锁才会带来好处。如果有一连串的线程都想修改数据，你不太可能看到任何性能改进。

与所有性能驱动的选择一样，如果你考虑使用 `Reader​Wri⁠terLockSlim` 而不是普通监视器的简单替代方案，请在实际工作负载下用这两种选择来测量性能，看看这种变化是否有任何影响。

## 事件对象

Windows 的本机 API，Win32，一直提供了称为 *事件* 的同步原语。从 .NET 的角度来看，这个名称有点不幸，因为它定义了这个术语的完全不同含义，正如 第九章 中讨论的那样。在本节中，当我提到事件时，我指的是同步原语，除非我明确将其作为 .NET 事件进行限定。

`ManualResetEvent` 类提供了一种机制，其中一个线程可以等待另一个线程的通知。这与 `Monitor` 类的 `Wait` 和 `Pulse` 不同。首先，你不需要拥有监视器或其他锁定来等待或发出事件信号。其次，`Monitor` 类的脉冲方法只有在至少有一个其他线程在 `Monitor.Wait` 中阻塞在该对象上时才会起作用——如果没有任何等待，那么脉冲就好像从未发生过一样。但是 `ManualResetEvent` 记住它的状态——一旦发出信号，除非你通过调用 `Reset` 手动将其重置（因此得名），它将不会返回到未发出信号的状态。这使其在某些场景中非常有用，例如某个线程 A 无法继续直到另一个线程 B 完成了一些需要不可预测时间的工作。线程 A 可能需要等待，但当 A 检查时，线程 B 可能已经完成了工作。示例 16-12 使用了这种技术来执行一些重叠的工作。

##### 示例 16-12\. 使用 `ManualResetEvent` 等待工作完成

```cs
static void LogFailure(string message, string mailServer)
{
    var email = new SmtpClient(mailServer);

    `using` `(``var` `emailSent` `=` `new` `ManualResetEvent``(``false``)``)`
    {
        object sync = new();
        bool tooLate = false; // Prevent call to Set after a timeout
        `email``.``SendCompleted` `+``=` `(``_``,` `_``)` `=``>` `// (Event arguments unused here) `        `{`
            `lock``(``sync``)`
            `{`
                `if` `(``!``tooLate``)` `{` `emailSent``.``Set``(``)``;` `}`
            `}`
        `}``;`
        email.SendAsync("logger@example.com", "sysadmin@example.com",
            "Failure Report", "An error occurred: " + message, null);

        LogPersistently(message);

        `if` `(``!``emailSent``.``WaitOne``(``TimeSpan``.``FromMinutes``(``1``)``)``)`
        {
            LogPersistently("Timeout sending email for error: " + message);
        }

        lock (sync)
        {
            tooLate = true;
        }
    }
}
```

此方法使用 `System.Net.Mail` 命名空间中的 `SmtpClient` 类通过电子邮件向系统管理员发送错误报告。它还调用一个未在此处显示的内部方法 `LogPersistently` 将失败记录在本地日志机制中。由于这些都是可能需要一些时间的操作，代码会异步发送电子邮件——`SendAsync` 方法会立即返回，类会在电子邮件发送完成后引发一个 .NET 事件。这使得代码可以在发送电子邮件的同时继续执行 `LogPersistently` 方法。

记录了消息后，该方法在返回之前等待电子邮件发送完成，这就是 `ManualResetEvent` 的用武之地。通过将 `false` 传递给构造函数，我将事件置于初始未发出信号状态。但在处理电子邮件 `SendCompleted` .NET 事件的处理程序中，我调用同步事件的 `Set` 方法，这将使其进入发出信号状态。（在生产代码中，我还会检查 .NET 事件处理程序的参数，看看是否有错误，但这里我省略了，因为它与我要说明的点无关。）

最后，我调用`WaitOne`，它会阻塞直到事件被标记为已信号。`SmtpClient`可能完成工作得很快，以至于在我调用`LogPersistently`返回之前邮件已经发送出去了。但没关系——在这种情况下，`WaitOne`会立即返回，因为一旦调用`Set`，`ManualResetEvent`就会保持信号状态。所以不管哪个工作先完成——持久化日志还是发送邮件，`WaitOne`都会在邮件发送后让线程继续。关于这个方法奇怪名称的背景，请参见下一个侧边栏，“WaitHandle”。

还有一个`AutoResetEvent`。一旦单个线程从等待此类事件返回，它会自动恢复到未标记状态。因此，在此事件上调用`Set`将最多允许一个线程通过。如果在没有线程等待时调用一次`Set`，事件将保持设置状态，所以不像`Monitor.Pulse`，通知不会丢失。但该事件不会维护等待设置的数量——如果在没有线程等待事件的情况下调用两次`Set`，它仍然只允许第一个线程通过，并立即重置。

这两种事件类型只间接地继承自`WaitHandle`，通过`EventWaitHandle`基类。你可以直接使用它，并且可以通过构造函数参数指定手动或自动重置。但更有趣的是`EventWaitHandle`允许你跨进程边界工作（仅限于 Windows）。底层的 Win32 事件对象可以被命名，如果你知道另一个进程创建的事件的名称，你可以在构造`EventWaitHandle`时传递该名称来打开它。（如果还不存在你指定名称的事件，则你的进程将创建它。）在 Unix 上不存在与命名事件的等效物，因此如果尝试在这些环境中创建一个，将会得到`PlatformNotSupportedException`异常，尽管支持单进程使用，因此你可以自由使用这些类型，只要不尝试指定名称。

还有一个`ManualResetEventSlim`类。但与非精简的读取/写入器不同，`ManualResetEvent`并未被其精简后继者取代，因为只有旧类型支持跨进程使用。`ManualResetEventSlim`类的主要优点是，如果你的代码只需等待很短的时间，它可能更高效，因为它会像`SpinLock`一样轮询一段时间。这样可以避免使用相对昂贵的 OS 调度服务。但最终它会放弃并回退到更重的机制。（即使在这种情况下，它也稍微更高效，因为它不需要支持跨进程操作，因此使用更轻量级的机制。）自动事件没有精简版本，因为自动重置事件并不广泛使用。

## 障碍

在前面的章节中，我展示了如何使用事件来协调并发工作，使得一个线程在继续之前等待某些事件发生。运行时库提供了一个类来处理类似的协调，但语义略有不同。`Barrier` 类可以处理多个参与者，并且还可以支持多个*阶段*，这意味着线程可以在工作进行过程中多次等待彼此。`Barrier` 是对称的——在 示例 16-12 中，事件处理程序调用 `Set` 而另一个线程调用 `WaitOne`，而使用 `Barrier`，所有参与者都调用 `SignalAndWait` 方法，这实际上将设置和等待组合成一个操作。

当参与者调用 `SignalAndWait` 时，方法会阻塞，直到所有参与者都调用它为止，此时它们都将解除阻塞并且可以继续。因为你在构造函数参数中传递了计数值，所以 `Barrier` 知道要期望多少参与者。

多阶段操作只是简单地再来一次。一旦最后一个参与者调用 `SignalAndWait` 并释放其他线程，如果有任何线程第二次调用 `SignalAndWait`，它将像以前一样被阻塞，直到所有其他线程第二次调用它。`CurrentPhaseNumber` 告诉你到目前为止这种情况发生了多少次。

这种对称性使得 `Barrier` 不如 示例 16-12 中的 `ManualResetEvent` 适合，因为在后者中，只有一个线程真正需要等待。让 `SendComplete` 事件处理程序等待持久日志更新完成没有任何好处——只有一个参与者关心工作何时完成。`ManualResetEvent` 只支持单个参与者，但这并不一定是使用 `Barrier` 的理由。如果你想要带有多个参与者的事件风格的不对称性，还有另一种方法：倒计时。

## CountdownEvent

`CountdownEvent` 类类似于事件，但它允许你指定在允许等待线程通过之前必须被信号量标记的次数。构造函数接受一个初始计数参数，你可以随时通过调用 `AddCount` 增加计数。调用 `Signal` 方法来减少计数；默认情况下，它会减少一个，但有一种重载可以让你减少指定数量。

`Wait` 方法会阻塞，直到计数器达到零。如果你想查看当前计数以了解还有多少工作要做，可以读取 `CurrentCount` 属性。

## 信号量

另一个在并发系统中广泛使用的基于计数的系统被称为*信号量*。Windows 对此有原生支持，而.NET 的`Semaphore`类最初设计为其包装器。与事件包装器类似，`Semaphore`派生自`WaitHandle`，在非 Windows 平台上会模拟其行为。`CountdownEvent`在计数达到零后才允许等待线程通过，而`Semaphore`则在计数为零时开始阻塞线程。如果你希望确保不超过特定数量的线程同时执行某些工作，可以使用它。

因为`Semaphore`派生自`WaitHandle`，所以调用`WaitOne`方法来等待。只有在计数已经为零时才会阻塞。它在返回时将计数减一。通过调用`Release`来增加计数。您必须在构造函数参数中指定初始计数，并且还必须提供一个最大计数——如果调用`Release`尝试将计数设置为超过最大值，它将引发异常。

与事件类似，Windows 支持信号量的跨进程使用，因此可以选择将信号量名称作为构造函数参数传递。这将打开现有的信号量，如果尚未存在具有指定名称的信号量，则创建一个新的信号量。

还有一个`SemaphoreSlim`类。与`ManualResetEventSlim`类似，在线程通常不必长时间阻塞的场景中提供了性能优势。`SemaphoreSlim`提供了两种递减计数的方式。其`Wait`方法与`Semaphore`类的`WaitOne`方法类似，但它还提供了`WaitAsync`，它返回一个`Task`，一旦计数为非零就完成（并在完成任务时递减计数）。这意味着您无需阻塞线程等待信号量可用。此外，这意味着您可以使用第十七章中描述的`await`关键字来递减信号量。

## 互斥体

Windows 定义了一个名为*互斥体*的同步原语，为此.NET 提供了一个包装类`Mutex`。名称简称为“互斥”，因为一次只能有一个线程拥有互斥体——如果线程 A 拥有了互斥体，线程 B 就不能拥有，反之亦然。这也正是`lock`关键字通过`Monitor`类为我们所做的，但`Mutex`提供了两个优点。它支持跨进程：与其他跨进程同步原语一样，在构造互斥体时可以传递一个名称。（而且与其他所有类型不同，在 Unix 平台上也支持命名。）使用`Mutex`还可以在单个操作中等待多个对象。

###### 注意

`ThreadPool.RegisterWaitForSingleObject`方法不适用于互斥体，因为 Win32 要求互斥体所有权与特定线程相关联，而线程池的内部工作意味着`RegisterWaitForSingleObject`无法确定哪个线程池线程处理具有互斥体的回调。

通过调用`WaitOne`获取互斥体，如果在那时某个其他线程拥有互斥体，则`WaitOne`将阻塞，直到该线程调用`ReleaseMutex`。一旦`WaitOne`成功返回，你就拥有了互斥体。你必须在获取互斥体的同一线程上释放互斥体。

`Mutex`类没有“slim”版本。我们已经有了低开销的等价物，因为所有.NET 对象都具有通过`Monitor`和`lock`关键字提供轻量级互斥的天然能力。

## Interlocked

`Interlocked`类与本节到目前为止描述的其他类型有些不同。它支持对共享数据的并发访问，但不是同步原语。相反，它定义了静态方法，提供各种简单操作的原子形式。

例如，它提供了`Increment`、`Decrement`和`Add`方法，支持`int`和`long`值的重载。（这些操作类似——增加或减少只是加 1 或-1。）加法涉及从某个存储位置读取值，计算修改后的值，并将其存回同一存储位置，如果使用普通的 C#运算符进行此操作，如果多个线程尝试同时修改同一位置，可能会出现问题。如果值最初为`0`，某个线程读取该值，然后另一个线程也读取该值，如果两者都加 1 并将结果存回，则它们最终都将写回`1`——两个线程尝试增加值，但实际上只增加了一个。使用`Interlocked`形式的这些操作可以防止这种重叠发生。

`Interlocked`还提供了用于交换值的各种方法。`Exchange`方法接受两个参数：一个值的引用和一个值。它返回当前在第一个参数引用的位置的值，并用作第二个参数提供的值覆盖该位置，并且将这两个步骤作为单个原子操作执行。它支持`int`、`uint`、`long`、`ulong`、`object`、`float`、`double`，以及一种称为`IntPtr`的类型，表示非托管指针。还有一个泛型的`Exchange<T>`，其中`T`可以是任何引用类型。

还支持条件交换，使用`CompareExchange`方法。它接受三个值——与`Exchange`一样，它接受一个对要修改的某个变量的引用，以及要替换它的值，但还接受第三个参数：您认为已经在存储位置中的值。如果存储位置中的值与预期值不匹配，则此方法不会更改存储位置。（它仍然返回存储位置中的任何值，无论它是否修改了它。）实际上，可以根据这个方法来实现我描述的其他`Interlocked`操作。示例 16-13 使用它来实现一个交错增量操作。

##### 示例 16-13\. 使用`CompareExchange`

```cs
static int InterlockedIncrement(ref int target)
{
    int current, newValue;
    do
    {
        current = target;
        newValue = current + 1;
    }
    while (Interlocked.CompareExchange(ref target, newValue, current)
            != current);
    return newValue;
}
```

对于其他操作，模式是相同的：读取当前值，计算要替换它的值，然后仅在该值在此期间似乎未更改时替换它。如果在获取当前值和替换它之间值发生更改，则再次尝试。在这里需要稍微小心——即使`CompareExchange`成功，其他线程在您读取值和更新值之间可能两次修改该值，第二次更新将事情恢复到第一次更新之前。对于加法和减法，这并不重要，因为它不影响结果，但一般来说，您不应太过于假设成功更新表示什么。如果您有疑问，通常最好坚持使用更重的同步机制之一。

最简单的`Interlocked`操作是`Read`方法。它接受一个`ref long`并原子地读取该值，与通过`Interlocked`执行的同一变量上的任何其他操作相关。这使您可以安全地读取 64 位值——一般来说，CLR 不保证 64 位读取是原子的（在 64 位进程中，它们通常是，但如果您需要在 32 位架构上保证原子性，则需要使用`Interlocked.Read`）。没有 32 位值的重载，因为对它们的读写总是原子的。

`Interlocked`支持的操作对应于大多数 CPU 可以直接支持的原子操作。（一些 CPU 架构本能地支持所有这些操作，而其他一些则仅支持比较和交换，并通过这种方式构建其他所有操作。但无论如何，这些操作最多只是几条指令。）这意味着它们相对高效。与使用普通代码执行等效的非原子操作相比，它们成本要高得多，因为原子 CPU 指令需要在所有 CPU 核心（以及在安装了多个物理上分离的 CPU 的计算机中，所有 CPU 芯片）之间协调以保证原子性。尽管如此，它们的成本远低于`lock`语句在操作系统级别上阻塞线程时所付出的代价的一小部分。

这类操作有时被描述为*无锁*操作。这种说法并不完全准确——计算机在硬件的相对低层级上会非常短暂地获取锁。原子读-修改-写操作实际上会在计算机的内存上占用独占锁定，持续两个总线周期。然而，不会获取操作系统的锁，调度程序也不需要介入，而且这些锁持有的时间极短——通常仅仅是一个机器码指令。更重要的是，这里使用的高度专门化和低级别的锁定形式不允许在等待获取另一个锁时保持一个锁的持有状态——代码每次只能锁定一件事情。这意味着这种操作不会发生死锁。然而，排除死锁的简单性也有其两面性。

互锁操作的缺点在于原子性仅适用于极其简单的操作。仅使用`Interlocked`在多线程环境中构建更复杂的逻辑非常困难。相比之下，使用高级别的同步原语更容易且风险较小，因为这些原语使得保护更复杂的操作变得相对容易，而不仅仅是单个计算。通常情况下，你只会在对性能要求极高的工作中使用`Interlocked`，即使如此，你也应该仔细测量以验证它是否产生了你期望的效果——例如示例 16-13 中的代码在理论上可以循环任意次数才最终完成，因此它可能比你预期的成本更高。

在使用低级原子操作编写正确代码时的最大挑战之一是，您可能会遇到由 CPU 缓存工作方式引起的问题。一个线程执行的工作可能不会立即对其他线程可见，并且在某些情况下，内存访问可能不会按照代码指定的顺序发生。使用更高级别的同步原语可以通过强制执行某些顺序约束来避免这些问题，但如果您决定使用`Interlocked`来构建自己的同步机制，您需要理解.NET 为多个线程同时访问同一内存时定义的内存模型，并且通常需要使用`Interlocked`类定义的`MemoryBarrier`方法或`Volatile`类定义的各种方法来确保正确性。这超出了本书的范围，也是编写看起来工作正常但在重载时（即在这可能最为重要的时候）实际上出错的代码的一个很好的方法，因此这类技术很少值得成本。除非您真的别无选择，否则请坚持我在本章讨论过的其他机制。

## 延迟初始化

当您需要一个对象能够从多个线程访问时，如果该对象可能是不可变的（即，其字段在构造后不会更改），通常可以避免需要同步。多个线程同时从同一位置读取数据始终是安全的——只有在数据需要更改时才会出现问题。然而，这里有一个挑战：何时以及如何初始化共享对象？一种解决方法可能是将对象的引用存储在静态字段中，并从静态构造函数或字段初始化程序初始化该静态字段——CLR 保证对任何类的静态初始化仅运行一次。然而，这可能会导致对象比您想要的更早地被创建。如果在静态初始化中执行了太多工作，则可能会对应用程序启动所需的时间产生不利影响。

在初始化对象之前，您可能希望等到第一次需要该对象。这被称为*延迟初始化*。这并不特别难实现——您可以检查字段是否为`null`，如果不是，则初始化它，并使用`lock`确保只有一个线程可以构造该值。然而，开发人员似乎对展示自己有多聪明有着 remarkable 的食欲，这可能会有一个潜在的不良结果，即显示他们并不像他们认为的那么聪明。

`lock` 关键字虽然效率相当高，但通过使用 `Interlocked` 可能会更好。然而，在多处理器系统上的内存访问重排序的微妙之处使得编写代码既快速又聪明，但并非总是有效。为了避免这种反复出现的问题，.NET 提供了两个类来执行延迟初始化，而无需使用 `lock` 或其他潜在昂贵的同步原语。其中最简单的是 `Lazy<T>`。

### Lazy<T>

`Lazy<T>` 类提供了一个 `Value` 属性，类型为 `T`，并且在首次读取该属性之前不会创建 `Value` 返回的实例。默认情况下，`Lazy<T>` 将使用 `T` 的无参数构造函数，但您可以提供自己的方法来创建该实例。

`Lazy<T>` 能够为您处理竞态条件。实际上，您可以配置所需的多线程保护级别。由于延迟初始化在单线程环境中也可能很有用，因此您可以通过将 `false` 或 `LazyThreadSafetyMode.None` 作为构造函数参数来完全禁用多线程支持。但对于多线程环境，您可以在 `LazyThreadSafetyMode` 枚举中选择其他两种模式之一。

这些决定了如果多个线程几乎同时尝试首次读取 `Value` 属性时会发生什么。`PublicationOnly` 并不尝试确保只有一个线程创建对象 - 它仅在线程完成对象创建时应用任何同步。首个完成构造或初始化的线程将提供对象，其他已启动初始化的线程生成的对象均被丢弃。一旦值可用，所有进一步尝试读取 `Value` 的操作将直接返回该值。

如果选择 `ExecutionAndPublication`，则只允许单个线程尝试构造。这可能看起来不太浪费，但 `PublicationOnly` 提供了一个潜在的优势：因为它在初始化过程中避免了持有任何锁，所以在初始化代码本身尝试获取任何锁时，您不太可能引入死锁 bug。`PublicationOnly` 还会以不同的方式处理错误。如果第一次初始化尝试引发异常，则其他开始构造尝试的线程将有机会完成，而对于 `ExecutionAndPublication`，如果唯一的初始化尝试失败，则会保留异常，并且每次读取 `Value` 时都会抛出异常。

### LazyInitializer

支持延迟初始化的另一个类是 `LazyInitializer`。这是一个静态类，您完全通过其静态泛型方法使用它。与 `Lazy<T>` 相比稍微复杂一些，但它避免了除所需的惰性分配实例之外的额外对象的分配。示例 16-14 展示了如何使用它。

##### 示例 16-14\. 使用 `LazyInitializer`

```cs
public class Cache<T>
{
    private static Dictionary<string, T>? _d;

    public static IDictionary<string, T> Dictionary =>
        LazyInitializer.EnsureInitialized(ref _d);
}
```

如果字段为空，则`EnsureInitialized`方法会构造参数类型的一个实例——在本例中为`Dictionary<string, T>`。否则，它将返回字段中已有的值。还有一些其他重载方式。您可以像对`Lazy<T>`一样传递回调。您还可以传递一个`ref bool`参数，它将检查以发现初始化是否已经发生（并在执行初始化时将其设置为`true`）。

静态字段初始化程序会给我们带来相同的一次性初始化，但可能会在进程的生命周期中运行得更早。在具有多个字段的更复杂类中，静态初始化甚至可能导致不必要的工作，因为它适用于整个类，所以您可能会构造不会被使用的对象。这可能增加应用程序启动所需的时间。`LazyInitializer`允许您在首次使用时初始化各个字段，确保只做必要的工作。

## 其他类库并发支持

`System.Collections.Concurrent`命名空间定义了各种集合，在多线程环境中提供了比通常的集合更慷慨的保证，这意味着您可以在不需要任何其他同步原语的情况下使用它们。但要小心，尽管单个操作在多线程世界中可能具有良好定义的行为，但如果您需要执行的操作涉及多个步骤，这并不一定会帮助您。您可能仍然需要在更广泛的范围内进行协调以确保一致性。但在某些情况下，并发集合可能是您所需要的全部内容。

与非并发集合不同，`ConcurrentDictionary`、`ConcurrentBag`、`ConcurrentStack`和`ConcurrentQueue`都支持在枚举（例如使用`foreach`循环）这些内容进行的同时修改它们的内容。字典提供了一个实时枚举器，这意味着如果在枚举过程中添加或删除了值，枚举器可能会显示一些已添加的项，但可能不会显示已删除的项。它不提供明确的保证，主要是因为在多线程代码中，当两个事情发生在两个不同的线程上时，不总是完全清楚哪个事件发生得更早——相对论的法则意味着这可能取决于您的观点。

这意味着，枚举器在从字典中删除该项之后似乎仍返回该项是可能的。袋子、堆栈和队列采取了不同的方法：它们的枚举器都会拍摄快照并在其上进行迭代，因此`foreach`循环将看到一组内容，这组内容与过去某个时间点集合中的内容一致，即使该集合此后可能已发生变化。

正如我在第五章中已经提到的，并发集合提供的 API 与其非并发对应物相似，但增加了一些成员以支持原子添加和删除项目。例如，`ConcurrentDictionary`提供了一个`GetOrAdd`方法，如果已存在条目则返回现有条目，否则添加一个新条目。

运行库的另一部分，可以帮助您处理并发而无需显式使用同步原语，就是 Rx（这是第十一章的主题）。它提供各种运算符，可以将多个异步流组合成单一流。这些操作管理并发问题，记住每个单一的可观察对象都会一次为观察者提供一个项目。

Rx 采取必要的步骤来确保即使是从许多个体流合并输入，这些流都在同时生成项目，它也能遵守这些规则。只要所有源都遵循规则，Rx 就不会要求观察者一次处理多个事物。

`System.Threading.Channels` NuGet 包提供了支持生产者/消费者模式的类型，其中一个或多个线程生成数据，而其他线程消费这些数据。您可以选择通道是否缓冲，使生产者可以超过消费者，以及超过多少。 （`System.Collections.Concurrent`中的`BlockingCollection<T>`也提供这种服务。但是它不太灵活，不支持第十七章中描述的`await`关键字。）

最后，在多线程场景中，值得考虑的是不可变集合类，我在第五章中有描述。这些集合支持任意数量线程的并发访问，并且因为它们是不可变的，所以从不会出现如何处理并发写访问的问题。显然，不可变性带来了很大的约束，但如果能找到一种方法与这些类型一起工作（记住，内置的`string`类型是不可变的，因此你已经有了一些使用不可变数据的经验），它们在某些并发场景中非常有用。

# 任务

在本章的前面部分，我展示了如何使用`Task`类在线程池中启动工作。这个类不仅仅是线程池的一个包装器。`Task`及其相关类型构成的任务并行库（TPL）可以处理更广泛的场景。任务特别重要，因为 C#的异步语言特性（这是第十七章的主题）能够直接与其一起工作。运行库中许多 API 都提供基于任务的异步操作。

虽然任务是使用线程池的首选方式，但它们不仅仅是关于多线程的。基本的抽象比那更加灵活。

## `Task` 和 `Task<T>` 类

TPL 的核心有两个类：`Task` 和从它派生的类 `Task<T>`。`Task` 基类表示可能需要一些时间才能完成的工作。`Task<T>` 则扩展此功能以表示完成时会产生结果（类型为 `T`）的工作。（非泛型 `Task` 不产生任何结果。它是异步版本的 `void` 返回类型。）注意，这些不一定涉及线程的概念。

大多数 I/O 操作可能需要一段时间才能完成，在大多数情况下，运行时库为它们提供了基于任务的 API。示例 16-15 使用异步方法作为字符串获取网页内容。由于它无法立即返回字符串 —— 可能需要一些时间来下载页面 —— 因此它返回一个任务。

##### 示例 16-15\. 基于任务的网络下载

```cs
var w = new HttpClient();
string url = "https://endjin.com/";
Task<string> webGetTask = w.GetStringAsync(url);
```

###### 注意

大多数基于任务的 API 遵循一种命名约定，即它们以 `Async` 结尾，如果有相应的同步 API，则该 API 的名称不带 `Async` 后缀。例如，`System.IO` 中的 `Stream` 类，提供对字节流的访问，具有 `Write` 方法用于将字节写入流，该方法是同步的（即它在完成工作之前会等待）。它还提供 `WriteAsync` 方法。它与 `Write` 做的事情相同，但因为它是异步的，所以返回而不等待工作完成。它返回一个 `Task` 来表示工作；这种约定称为 *基于任务的异步模式*（TAP）。

`GetStringAsync` 方法不等待下载完成，因此几乎立即返回。要执行下载，计算机必须向相关服务器发送消息，然后必须等待响应。一旦请求启动，CPU 在大部分请求进程中无需执行任何工作，这意味着此操作大部分时间无需涉及线程。因此，此方法不需要在调用 `Task.Run` 时包装某些基础同步 API 的调用。事实上，`HttpClient` 甚至没有大多数操作的同步版本。对于同时提供 I/O API 的类，如 `Stream`，同步版本通常是对基本异步实现的包装：当您调用阻塞 API 执行 I/O 时，它通常会在内部执行异步操作，然后只是阻塞调用线程，直到该工作完成。即使在完全非异步的情况下，例如，`FileStream` 可以使用非异步操作系统文件 API 实现 `Read` 和 `Write` —— OS 内核中的 I/O 通常是异步的。

因此，尽管 `Task` 和 `Task<T>` 类很容易生成通过在线程池线程运行方法的任务，它们也能够表示在大部分时间内不需要使用线程的基本异步操作。虽然这不是官方术语的一部分，我将这种操作描述为*无线程任务*，以区分它们与完全在线程池线程上运行的任务。

### `ValueTask` 和 `ValueTask<T>`

`Task` 和 `Task<T>` 非常灵活，不仅因为它们可以表示基于线程和无线程的操作。正如你将看到的，它们提供了多种机制来发现它们所代表的工作何时完成，包括将多个任务组合为一个任务的能力。多个线程可以同时等待同一个任务。你可以编写缓存机制，重复地分配同一个任务，即使在任务完成之后很长时间仍然如此。这一切都非常方便，但也意味着这些任务类型也具有一些开销。对于更受限的情况，.NET 定义了更少灵活的 `ValueTask` 和 `ValueTask<T>` 类型，在某些情况下效率更高。

这些类型与它们的普通对应类型之间最重要的区别在于 `ValueTask` 和 `ValueTask<T>` 都是值类型。在性能敏感的代码中，这一点非常重要，因为它可以减少代码分配的对象数量，从而减少应用程序执行垃圾回收工作的时间。你可能会认为，通常涉及并发工作的上下文切换成本可能很高，以至于在处理异步操作时，对象分配的成本将是你最不用担心的问题之一。虽然这通常是正确的，但有一个非常重要的场景，`Task<T>` 的垃圾回收开销可能会成为一个问题：有时运行缓慢但通常不会的操作。

对于 I/O API 来说，执行缓冲以减少对操作系统的调用是非常常见的。如果你向 `Stream` 写入少量字节，它通常会将这些字节放入缓冲区，并等待，直到要么你写入足够的数据使其值得将其发送到操作系统，要么你显式调用 `Flush`。读取时也常常进行缓冲——如果你从文件中读取一个字节，操作系统通常会从驱动器中读取整个扇区（通常至少为 4 KB），并且该数据通常会保存在内存中，因此当你请求第二个字节时，不需要再进行 I/O 操作。实际上，如果你编写一个循环，以相对较小的块（例如一次一行文本）从文件中读取数据，那么大多数读取操作将立即完成，因为要读取的数据已经被提前获取。

在这些情况下，大多数对异步 API 的调用会立即完成，创建任务对象的 GC 开销可能会变得显著。这就是为什么引入了 `ValueTask` 和 `ValueTask<T>`。（这些是内置于 .NET Core、.NET 和 .NET Standard 2.1 中的。在 .NET Framework 中，你可以通过 `System.Threading.Tasks.Extensions` NuGet 包获取它们。）这些类型使得可能的是潜在的异步操作可以在不需要分配任何对象的情况下立即完成。在无法立即完成的情况下，这些类型最终会成为 `Task` 或 `Task<T>` 对象的包装器，此时开销会返回，但在只有少数调用需要这样做的情况下，这些类型可以在使用了低分配技术的代码中提供显著的性能提升，尤其是在 第十八章 中描述的代码中。

非泛型的 `ValueTask` 很少被使用，因为产生无结果的异步操作可以直接返回 `Task.CompletedTask` 静态属性，它提供了一个可重复使用的任务，已经处于完成状态，避免了任何 GC 开销。但需要生成结果的任务通常不能重用现有任务。（也有一些例外情况：运行时库通常会为 `Task<bool>` 使用缓存的预完成任务，因为只有两种可能的结果。但对于 `Task<int>`，没有实际的方法来维护每个可能结果的预完成任务列表。）

这些值任务类型有一些限制。它们是单次使用的：与 `Task` 和 `Task<T>` 不同，你不应该将这些类型存储在字典或 `Lazy<T>` 中以提供缓存的异步值。在完成之前尝试检索 `ValueTask<T>` 的 `Result` 是错误的。多次检索 `Result` 也是错误的。一般来说，你应该使用 `ValueTask` 或 `ValueTask<T>` 进行一次 `await` 操作（如 第十七章 中所述），然后再也不要使用它们了。（或者，如果必要，可以通过调用其 `AsTask` 方法来获取完整的 `Task` 或 `Task<T>`，带有所有对应的开销，此时你不应再对值任务进行任何操作。）

因为值类型任务是在 TPL 出现多年后引入的，类库经常使用 `Task<T>`，而你可能期望看到的是 `ValueTask<T>`。例如，`Stream` 类的 `ReadAsync` 方法都是主要候选项，但因为大多数这些方法在 `ValueTask<T>` 存在之前就定义好了，所以它们大多返回 `Task<T>`。不过，最近添加的重载版本接受 `Memory<byte>` 而不是 `byte[]`，确实返回 `ValueTask<T>`，而且更一般地说，在增加对 第十八章 中描述的新内存高效技术支持的 API 中，这些方法通常会返回 `ValueTask<T>`。如果你处于对任务的 GC 开销非常敏感的环境中，你可能会希望无论如何都使用这些技术。

### 任务创建选项

你可以通过使用 `Task.Factory` 或 `Task<T>.Factory` 的 `StartNew` 方法创建一个基于线程的任务，而不是使用 `Task.Run`，这样可以更好地控制新任务的某些方面。 `StartNew` 的一些重载接受 `enum` 类型 `TaskCreationOptions` 的参数，这提供了对 TPL 如何调度任务的一些控制。

`PreferFairness` 标志请求在已经调度的任务之后运行该任务。默认情况下，线程池通常先运行最近添加的任务（即后进先出，或者 LIFO 策略），因为这样更有效地利用 CPU 缓存。

`LongRunning` 标志警告 TPL 任务可能会运行很长时间。默认情况下，TPL 的调度器优化相对较短的工作项 —— 即多达几秒钟的任何工作。此标志表明工作可能需要更长时间，这种情况下，TPL 可能会修改其调度。如果有太多长时间运行的任务，它们可能会使用完所有线程，即使某些排队的工作项可能要短得多，它们仍然需要等待在缓慢工作的后面才能开始。但如果 TPL 知道哪些项目可能快速运行，哪些可能较慢，它可以以不同的优先级进行调度，以避免这些问题。

其他 `TaskCreationOptions` 设置涉及父/子任务关系和调度器，稍后我将进行描述。

### 任务状态

任务在其生命周期中经历多个状态，你可以使用 `Task` 类的 `Status` 属性来发现它所处的位置。这返回 `enum` 类型 `TaskStatus` 的值。如果任务成功完成，则该属性将返回枚举的 `RanToCompletion` 值。如果任务失败，则为 `Faulted`。如果使用 “Cancellation” 中显示的技术取消任务，则状态将为 `Canceled`。

在“进行中”主题上有几种变体，其中`Running`是最明显的——表示某个线程当前正在执行任务。代表 I/O 的任务在进行时通常不需要线程，因此它永远不会进入该状态——它始于`WaitingForActivation`状态，然后通常直接转换为三种最终状态之一（`RanToCompletion`、`Faulted`或`Canceled`）。基于线程的任务也可以处于`WaitingForActivation`状态，但只有在某些情况下才会阻止其运行，这通常发生在您设置任务仅在某些其他任务完成时运行时（我稍后将展示如何做到）。基于线程的任务也可能处于`WaitingToRun`状态，这意味着它在队列中等待线程池线程变得可用。可以在任务之间建立父/子关系，已经完成的父任务创建了一些尚未完成的子任务将处于`WaitingForChildrenToComplete`状态。

最后，还有`Created`状态。您很少见到它，因为它表示您已创建但尚未请求运行的基于线程的任务。使用任务工厂的`StartNew`方法或`Task.Run`创建的任务中永远不会看到这一点，但如果直接构造新的`Task`，则会看到这一点。

大多数情况下，`TaskStatus`属性中的详细级别可能过于复杂，因此`Task`类定义了各种更简单的`bool`属性。如果只想知道任务是否没有更多工作要做（并且不关心它成功、失败还是被取消），可以使用`IsCompleted`属性。如果想检查失败或取消，可以使用`IsFaulted`或`IsCanceled`。

### 检索结果

假设您有一个`Task<T>`，可以通过提供一个 API 或创建返回值的基于线程的任务获取它。如果任务成功完成，您可能希望检索其结果，您可以从`Result`属性中获取。因此，由示例 16-15 创建的任务使网页内容在`webGetTask.Result`中可用。

如果尝试在任务完成之前读取`Result`属性，则会阻塞您的线程，直到结果可用。（如果有一个普通的`Task`，它不返回结果，并且您想要等待其完成，可以直接调用`Wait`。）如果操作失败，则`Result`会抛出异常（`Wait`也会如此），尽管这并不像您可能期望的那样直接，我将在“错误处理”中讨论。

###### 警告

你应该避免在未完成的任务上使用`Result`。在某些情况下，这可能会导致死锁。这在桌面应用程序中特别常见，因为某些工作需要在特定线程上进行，如果通过读取未完成任务的`Result`来阻塞线程，可能会阻止任务完成。即使不会发生死锁，通过阻塞`Result`可能会导致性能问题，因为它会占用线程池线程，这些线程本来可以继续进行有用的工作。在未完成的`ValueTask<T>`中读取`Result`是不允许的。

在大多数情况下，最好使用 C#的异步语言特性来检索结果。这将是下一章的主题，但作为一个预览，示例 16-16 展示了你如何使用它来获取获取网页的任务结果。（你需要在方法声明前面应用`async`关键字才能使用`await`关键字。）

##### 示例 16-16\. 使用`await`获取任务结果

```cs
string pageContent = await webGetTask;
```

这看起来可能并不像是简单地写`webGetTask.Result`这样的改进，但正如我在第十七章中所展示的，这段代码并不是看上去的那样——C#编译器会将这个语句重组成一个回调驱动的状态机，使你能够在不阻塞调用线程的情况下获取结果。（如果操作尚未完成，线程会返回给调用者，当操作完成时，方法的其余部分稍后运行。）

但是异步语言特性是如何使这个工作的——代码如何发现任务何时完成？`Result`或`Wait`让你坐下等待这种情况发生，阻塞线程，但这实际上违背了使用异步 API 的初衷。通常情况下，你希望在任务完成时收到通知，你可以通过*继续*来实现这一点。

## 继续

任务提供了名为`ContinueWith`的方法的各种重载。这将创建一个新的基于线程的任务，在你调用`ContinueWith`的任务完成时执行（无论是成功完成、失败还是取消）。示例 16-17 在示例 16-15 中创建的任务上使用了这个方法。

##### 示例 16-17\. 一个继续

```cs
webGetTask.ContinueWith(t =>
{
    string webContent = t.Result;
    Console.WriteLine("Web page length: " + webContent.Length);
});
```

一个继续任务始终是一个基于线程的任务（无论其前置任务是基于线程、基于 I/O 还是其他什么）。当你调用`ContinueWith`时，任务会立即创建，但在其前置任务完成之前不会变为可运行状态。（它最初处于`WaitingForActivation`状态。）

###### 注意

继续是一个独立的任务——`ContinueWith`返回一个`Task<T>`或`Task`，取决于你提供的委托是否返回结果。如果你想要链接一系列操作，你可以为一个继续设置一个继续。

您为继续任务提供的方法（例如在 示例 16-17 中的 lambda 表达式）将其前置任务作为其参数，并且我已经使用它来检索结果。我也可以使用包含方法中的 `webGetTask` 变量，因为它引用相同的任务。但是，通过使用参数，示例 16-17 中的 lambda 表达式不使用其包含方法的任何变量，这使得编译器可以生成稍微更高效的代码——它不需要创建对象来保存共享变量，并且它可以重用创建的委托实例，因为它不必为每个调用创建特定于上下文的委托实例。这意味着如果我认为这样做会使代码更易读，我也可以轻松地将其分离为普通的非内联方法。

您可能会认为在 示例 16-17 中存在一个可能的问题：如果下载完成得非常快，以至于 `webGetTask` 已经在代码管理附加继续任务之前完成了怎么办？实际上，这并不重要——如果您在已经完成的任务上调用 `ContinueWith`，它仍然会运行继续任务。它只是立即安排它。您可以附加任意数量的继续任务。在任务完成之前附加的所有继续任务将在其完成时安排执行。而在任务完成后附加的继续任务将立即安排执行。

默认情况下，继续任务将像任何其他任务一样在线程池上安排执行。然而，有些事情可以改变它的运行方式。

一些 `ContinueWith` 的重载接受一个 `enum` 类型的参数 `TaskContinua⁠tionOptions`，它控制任务如何（以及是否）被安排。这包括与 `TaskCreationOptions` 可用的所有选项相同的选项，但添加了一些特定于继续任务的选项。

您可以指定继续任务仅在特定情况下运行。例如，`OnlyOnRanToCompletion` 标志将确保继续任务仅在前置任务成功时运行。还有类似的 `OnlyOnFaulted` 和 `OnlyOnCan⁠celed` 标志。或者，您可以指定 `NotOnRanToCompletion`，这意味着继续任务仅在任务故障或取消时运行。

###### 注意

您可以为单个任务创建多个继续任务。因此，您可以设置一个处理成功情况，另一个处理失败情况。

您还可以指定`ExecuteSynchronously`。这表示连续性不应作为单独的工作项进行调度。通常，当任务完成时，该任务的任何连续性将被调度执行，并且必须等待直到正常的线程池机制从队列中选择工作项并执行它们。（如果使用默认选项，这不会花费太多时间——除非指定了`PreferFairness`，线程池用于任务的 LIFO 操作意味着最近调度的项目先运行。）然而，如果您的完成仅需非常少量的工作，将其调度为完全独立的项目的开销可能过大。因此，`ExecuteSynchronously` 允许您在同一个线程池工作项上挂载完成任务——TPL 将在前驱完成后立即运行这种类型的连续性，然后将线程返回给池。只有在连续性将快速运行时才应使用此选项。

`LazyCancellation` 选项处理了一种棘手的情况，如果您使任务可取消（如后文所述的“Cancellation”），并且使用了连续性，那么可能会出现问题。如果取消了一个任务，默认情况下任何连续性会立即变为可运行状态。如果被取消的任务本身设置为另一个尚未完成的任务的连续性，并且有自己的连续性，正如示例 16-18 所示，这可能会产生一种轻微令人惊讶的效果。

##### 示例 16-18\. 取消和链式连续性

```cs
private static void ShowContinuations()
{
    Task op = Task.Run(DoSomething);
    var cs = new CancellationTokenSource();
    Task onDone = op.ContinueWith(
        _ => Console.WriteLine("Never runs"),
        cs.Token);
    Task andAnotherThing = onDone.ContinueWith(
        _ => Console.WriteLine("Continuation's continuation"));
    cs.Cancel();
}

static void DoSomething()
{
    Thread.Sleep(1000);
    Console.WriteLine("Initial task finishing");
}
```

这将创建一个任务，将调用`DoSomething`，然后是该任务的可取消连续性（`onDone`中的`Task`），然后是作为第一个连续性的最终任务（`andAnotherThing`）。此代码几乎立即被取消，几乎可以肯定会在第一个任务完成之前发生。其效果是最终任务在第一个任务完成之前运行。当`onDone`完成时，最终的`andAnotherThing`任务变为可运行状态，即使该完成是由于取消了`onDone`。由于这里存在一条链——`andAnotherThing`是`onDone`的连续性，而`onDone`是`op`的连续性——`andAnotherThing`在`op`完成之前运行有些奇怪。`LazyCancellation` 改变了行为，使得第一个连续性不会被视为完成，直到其前驱完成，这意味着最终的连续性只有在第一个任务完成后才会运行。

还有另一种控制任务执行方式的机制：您可以指定调度程序。

## 调度程序

所有基于线程的任务都由`TaskScheduler`执行。默认情况下，您将得到 TPL 提供的通过线程池运行工作项的调度程序。然而，还有其他类型的调度程序，甚至可以自己编写。

选择非默认调度程序最常见的原因是处理线程关联性要求。`TaskScheduler`类的静态`FromCurrentSynchroniza⁠tion​Context`方法基于调用该方法的当前同步上下文返回调度程序。该调度程序将通过该同步上下文执行所有工作。因此，如果您从 UI 线程调用`FromCurrentSynchronizationContext`，则生成的调度程序可用于运行可以安全更新 UI 的任务。通常，您会在后续操作中使用此功能——可以运行一些基于任务的异步工作，然后连接一个后续操作，在完成该工作时更新 UI。示例 16-19 展示了在 WPF 应用程序窗口的代码后台文件中使用此技术。

##### 示例 16-19\. 在 UI 线程上安排后续操作

```cs
public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();
    }

    private static readonly HttpClient w = new();
    `private` `readonly` `TaskScheduler` `_uiScheduler` `=`
        `TaskScheduler``.``FromCurrentSynchronizationContext``(``)``;`

    private void FetchButtonClicked(object sender, RoutedEventArgs e)
    {
        string url = "https://endjin.com/";
        Task<string> webGetTask = w.GetStringAsync(url);

        webGetTask.ContinueWith(t =>
        {
            string webContent = t.Result;
            outputTextBox.Text = webContent;
        },
        `_uiScheduler``)``;`
    }
}
```

这使用字段初始化程序获取调度程序——UI 元素的构造函数在 UI 线程上运行，因此这将获取一个用于 UI 线程同步上下文的调度程序。然后，单击处理程序使用`HttpClient`类的`GetStringAsync`下载网页。这将异步运行，因此不会阻塞 UI 线程，这意味着在下载进行时应用程序仍然响应。该方法设置了一个使用`ContinueWith`的重载形式来设置任务的后续操作。这确保了当获取内容的任务完成时，传递给`ContinueWith`的 lambda 表达式在 UI 线程上运行，因此可以安全地访问 UI 元素。

###### 提示

虽然这样做完全有效，但在下一章中描述的`await`关键字提供了这个特定问题的更简单的解决方案。

运行时库提供了三种内置调度程序。有一个使用线程池的默认调度程序，还有一个使用同步上下文的调度程序，正如我刚才展示的那样。第三个由名为`ConcurrentExclusiveSchedulerPair`的类提供，并且正如其名称所示，它提供了两个调度程序，通过属性可用。`ConcurrentScheduler`属性返回一个类似于默认调度程序的并发运行任务的调度程序。`ExclusiveScheduler`属性返回一个用于逐个运行任务的调度程序，并在这样做时暂时挂起另一个调度程序（这让我想起了本章前面描述的读者/写者同步语义——它允许在需要时排他性，但其余时间并发运行）。

## 错误处理

`Task`对象在其工作失败时通过进入`Faulted`状态来指示。失败时总会至少有一个异常与之关联，但 TPL 允许复合任务——包含多个子任务的任务。这使得可能发生多个失败，并且根任务将报告它们所有。`Task`定义了一个`Exception`属性，其类型为`AggregateException`。你可能还记得第八章中提到的，除了从基类`Exception`类型继承的`InnerException`属性外，`AggregateException`还定义了一个`InnerExceptions`属性，返回一个异常集合。在这里你将找到导致任务失败的所有异常的完整集合。（如果任务不是复合任务，则通常只会有一个。）

如果尝试获取`Result`属性或在故障任务上调用`Wait`，它将抛出与从`Exception`属性返回的相同的`AggregateException`。故障任务会记住你是否使用了这些成员中的至少一个，如果你尚未这样做，它将考虑异常为*未观察到*。TPL 使用终结来跟踪具有未观察异常的故障任务，如果允许这样的任务变得不可达，`TaskScheduler`将引发其静态的`UnobservedTaskException`事件。这给了你最后一次机会来处理异常，之后它将丢失。

## 自定义无线程任务

许多基于 I/O 的 API 返回无线程任务。如果你希望，你也可以这样做。`TaskCompletionSource<T>`类提供了一种创建`Task<T>`的方式，它不具有在线程池上运行的相关方法，而是在你告诉它完成时完成。没有非泛型的`TaskCompletionSource`，但也不需要。`Task<T>`派生自`Task`，因此你可以随意选择任何类型参数。按照惯例，大多数开发人员在不需要提供返回值时使用`TaskCompletionSource<object?>`。

假设你正在使用一个不提供基于任务的 API 的类，并且希望添加一个基于任务的包装器。我在示例 16-12 中使用的`SmtpClient`类支持旧的基于事件的异步模式，但不支持基于任务的模式。示例 16-20 使用该 API 与`TaskCompletionSource<object?>`结合提供了一个基于任务的包装器。（是的，在那里有`Canceled`/`Cancelled`的两种拼写。TPL 一致使用`Canceled`，但旧 API 展示了更多的变化。）

##### 示例 16-20. 使用`TaskCompletionSource<T>`

```cs
public static class SmtpAsyncExtensions
{
    public static Task SendTaskAsync(this SmtpClient mailClient, string from,
                                string recipients, string subject, string body)
    {
        var tcs = new TaskCompletionSource<object?>();

        void CompletionHandler(object s, AsyncCompletedEventArgs e)
        {
            // Check this is the notification for our SendAsync.
            if (!object.ReferenceEquals(e.UserState, tcs)) { return; }
            mailClient.SendCompleted -= CompletionHandler;
            if (e.Canceled)
            {
                tcs.SetCanceled();
            }
            else if (e.Error != null)
            {
                tcs.SetException(e.Error);
            }
            else
            {
                tcs.SetResult(null);
            }
        };

        mailClient.SendCompleted += CompletionHandler;
        mailClient.SendAsync(from, recipients, subject, body, tcs);

        return tcs.Task;
    }
}
```

`SmtpClient`通过引发事件来通知我们操作已完成。此事件的处理程序首先检查事件是否对应于我们对`SendAsync`的调用，而不是可能已经在进行的其他操作。然后，它会分离自身（以防止在后续使用相同`SmtpClient`进行工作时再次运行）。接着，它检测操作是成功、取消还是失败，并在`TaskCompletionSource<object>`上分别调用`SetResult`、`SetCanceled`或`SetException`方法。这将导致任务转换为相应状态，并负责运行任何附加到该任务的后续操作。完成源通过其`Task`属性使其创建的无关线程`Task`对象可用，并且此方法返回该对象。

## 父/子关系

如果基于线程的任务方法创建一个新的基于线程的任务，默认情况下，这些任务之间没有特定的关系。然而，`TaskCreationOptions`标志之一是`AttachedToParent`，如果设置了这个标志，新创建的任务将作为当前执行任务的子任务。这意味着父任务直到所有子任务完成后才报告完成（当然，其自身的方法也需要完成）。如果任何子任务出现故障，父任务也将失败，并且将所有子任务的异常包含在自己的`AggregateException`中。

您还可以为继续任务指定`AttachedToParent`标志。请注意，这并不使其成为其先前任务的子任务。它将成为在调用`ContinueWith`创建继续任务时正在运行的任何任务的子任务。

###### 注意

线程无关任务（例如，大多数代表 I/O 的任务）通常不能作为其他任务的子任务。如果通过`TaskCompletionSource<T>`自行创建一个，那么可以做到，因为该类有一个构造函数重载接受`TaskCreationOptions`。然而，大多数 .NET API 返回的任务没有提供请求将任务设为子任务的方法。

父/子关系并不是创建基于多个其他项目结果的任务的唯一方式。

## 复合任务

`Task`类具有静态的`WhenAll`和`WhenAny`方法。每个方法都有重载，接受任务集合或`Task<T>`对象集合作为唯一参数。`WhenAll`方法返回一个`Task`或`Task<T[]>`，仅当提供的所有任务完成时才完成（在后一种情况下，复合任务生成包含每个单独任务结果的数组）。`WhenAny`方法返回一个`Task<Task>`或`Task<Task<T>>`，只要第一个任务完成就完成，并将该任务作为结果返回。

与父任务一样，如果`WhenAll`生成的任务中的任何任务失败，那么所有失败任务的异常将在组合任务的`AggregateException`中可用。（`WhenAny`不报告错误。它在第一个任务完成时就完成了，您必须检查它以发现是否失败。）

您可以将继续任务附加到这些任务上，但还有一个稍微更直接的路线。而不是使用`WhenAll`或`WhenAny`创建复合任务，然后在结果上调用`ContinueWith`，您可以直接调用任务工厂的`ContinueWhenAll`或`Continue​WhenAny`方法。同样，这些方法接受一个`Task`或`Task<T>`的集合，但它们还接受一个要作为继续调用的方法。

# 其他异步模式

尽管 TPL 提供了公开异步 API 的首选机制，但在其添加之前，.NET 已经存在了将近十年，因此您可能会遇到较旧的方法。最长建立的形式是异步编程模型（APM）。这是在.NET 1.0 中引入的，因此广泛实现，但现在不鼓励使用。按照这种模式，方法成对出现：一个用于启动工作，另一个用于在完成时收集结果。示例 16-21 展示了`System.IO`命名空间中`Stream`类中的这样一对方法，同时显示了相应的同步方法。（今天编写的代码应该使用基于任务的`WriteAsync`。）

##### 示例 16-21\. APM 对及其相应的同步方法

```cs
public virtual IAsyncResult BeginWrite(byte[] buffer, int offset, int count,
    AsyncCallback callback, object state)...
public virtual void EndWrite(IAsyncResult asyncResult)...

public abstract void Write(byte[] buffer, int offset, int count)...
```

注意，`BeginWrite`方法的前三个参数与`Write`方法的参数相同。在 APM 中，`Begin*Xxx*`方法接受所有输入（即任何普通参数和任何`ref`参数，但不是`out`参数，如果有的话）。`End*Xxx*`方法提供任何输出，这意味着返回值，任何`ref`参数（因为这些可以传递信息进入或退出），以及任何`out`参数。

`Begin*Xxx*`方法还接受两个额外的参数：类型为`AsyncCallback`的委托，当操作完成时将调用它，以及类型为`object`的参数，接受您希望与操作关联的任何对象（或者如果您不需要则为`null`）。此方法还返回一个`IAsync​Result`，表示异步操作。

当调用完成回调时，您可以调用`End*Xxx*`方法，传入与`Begin*Xxx*`方法返回的相同的`IAsyncResult`对象，这将提供返回值（如果有的话）。如果操作失败，`End*Xxx*`方法将引发异常。

你可以用一个`Task`封装使用 APM 的 API。`Task`和`Task<T>`提供的`TaskFactory`对象提供了`FromAsync`方法，你可以向其传递一对委托，用于`Begin*Xxx*`和`End*Xxx*`方法，并传递`Begin*Xxx*`方法需要的任何参数。这将返回代表操作的`Task`或`Task<T>`。

另一个常见的旧模式是事件驱动的异步模式（EAP）。本章中你已经见过一个示例——`SmtpClient`使用了这种模式。使用此模式，一个类提供启动操作的方法和操作完成时引发的相应事件。方法和事件通常具有相关的名称，如`SendAsync`和`SendCompleted`。此模式的一个重要特点是方法捕获同步上下文并使用它来引发事件，这意味着如果在 UI 代码中使用支持此模式的对象，它有效地呈现了单线程异步模型。这使得它比 APM 更容易使用，因为在异步工作完成时，你无需编写额外的代码以返回到 UI 线程。

没有自动化机制可以将 EAP 包装在任务中，但如我在示例 16-20 中所示，这并不特别难。

异步代码中还有一种常见模式：由 C#异步语言特性（`async`和`await`关键字）支持的*可等待*模式。如我在示例 16-16 中展示的，你可以直接使用这些特性消耗 TPL 任务，但语言不会直接识别`Task`，而且可以等待的东西不限于任务。你可以用`await`关键字与实现特定模式的任何东西一起使用。我将在第十七章中展示这一点。

# 取消

.NET 定义了一种用于取消慢操作的标准机制。可取消操作接受类型为`CancellationToken`的参数，如果将其设置为取消状态，则操作将尽早停止而不是运行到完成。

`CancellationToken`类型本身不提供任何方法来启动取消操作——API 设计为你可以告诉操作何时取消，而不给予它们取消与同一`CancellationToken`相关联的其他操作的权力。取消操作通过单独的对象`CancellationTokenSource`管理。顾名思义，你可以使用它来获取任意数量的`CancellationToken`实例。如果调用`CancellationTokenSource`对象的`Cancel`方法，它将设置所有相关联的`CancellationToken`实例为取消状态。

一些我之前描述过的同步机制可以接收`CancellationToken`。（从`WaitHandle`派生的那些机制不能，因为底层的 Windows 原语不支持.NET 的取消模型。`Monitor`也不支持取消，但许多较新的 API 支持。）任务型 API 通常也会接收取消标记，而 TPL 本身也提供了带有取消标记的`StartNew`和`ContinueWith`方法的重载版本。如果任务已经开始运行，TPL 无法取消它，但如果在任务开始运行之前取消任务，TPL 会将其从预定任务队列中移除。如果希望在任务开始运行后能取消任务，就需要在任务体内编写代码来检查`CancellationToken`，并在其`IsCancellationRequested`属性为`true`时放弃工作。

取消支持并不普遍，因为并非总是可能取消一些操作。例如，一旦消息已经通过网络发送出去，就无法取消发送。一些操作允许在达到某个不可逆转的点之前取消工作。（例如，如果消息已排队等待发送但实际上尚未发送，则可能取消还为时不晚。）这意味着即使提供了取消功能，它也可能不起作用。因此，在使用取消功能时，需要做好它可能无法正常工作的准备。

# 并行性

运行时库包括一些类，可以在多个线程上并发地处理数据集合。有三种方法可以做到这一点：`Parallel`类、并行 LINQ 和 TPL 数据流。

## 并行类

`Parallel`类提供了四个静态方法：`For`、`ForEach`、`ForEachAsync`和`Invoke`。最后一个方法接收一个委托数组并执行它们所有，可能并行执行。（它决定是否使用并行取决于各种因素，如计算机的硬件线程数量、系统的负载情况以及要处理的项数。）`For`和`ForEach`方法模仿了同名的 C#循环结构，但它们也可能并行执行迭代。`ForEachAsync`是.NET 6.0 中新增的，也模仿了`foreach`，但提供了更好的异步操作支持，包括能够与`IAsyncEnumerable<T>`（如`await foreach`）一起工作或让每个迭代执行异步操作（相当于在`foreach`循环体中使用`await`）。

示例 16-22 展示了在执行两组样本卷积的代码中使用`Parallel.For`。这是一种在信号处理中常用的高度重复的操作。（实际上，快速傅里叶变换提供了更有效的执行方式，除非卷积核很小，但那段代码的复杂性将会掩盖这里的主要主题，即`Parallel`类。）它为每个输入样本产生一个输出样本。每个输出样本是通过计算两个输入的一系列值对的乘积之和来产生的。对于大数据集，这可能会很耗时，因此这是您可能希望通过在多处理器上分布执行来加速的工作类型。每个单独的输出样本值都可以独立计算，因此它是并行化的一个很好的候选对象。

##### 示例 16-22。并行卷积

```cs
static float[] ParallelConvolution(float[] input, float[] kernel)
{
    float[] output = new float[input.Length];
    Parallel.For(0, input.Length, i =>
    {
        float total = 0;
        for (int k = 0; k < Math.Min(kernel.Length, i + 1); ++k)
        {
            total += input[i - k] * kernel[k];
        }
        output[i] = total;
    });

    return output;
}
```

这段代码的基本结构与一对嵌套的`for`循环非常相似。我只是用`Parallel.For`替换了外层的`for`循环。（我没有尝试并行化内部循环 - 如果每个单独的步骤都很简单，`Parallel.For`将会在执行代码之外花费更多时间来处理内务工作。）

第一个参数`0`设置了循环计数器的初始值，第二个参数设置了上限。最后一个参数是一个委托，将为循环计数器的每个值调用一次，并且如果`Parallel`类的启发式算法告诉它这可能会产生加速效果，则调用将同时发生。在多核机器上使用大数据集运行此方法将导致所有可用的硬件线程充分利用。

可能通过更友好的方式将工作分区以获得更好的性能 - 幼稚的并行化可能会给人以高性能的印象，因为它可以利用所有 CPU 核心，但交付的吞吐量却不够优化。然而，在复杂性和性能之间存在一种权衡，而`Parallel`类的简单性通常可以在相对较少的工作量下提供可观的收益。

## 并行 LINQ

并行 LINQ 是一个与内存中的信息一起工作的 LINQ 提供程序，类似于 LINQ 到对象。`System.Linq`命名空间通过名为`AsParallel`的扩展方法为任何`IEnumerable<T>`（由`ParallelEnumerable`类定义）提供了这一功能。这将返回一个`ParallelQuery<T>`，支持通常的 LINQ 操作符。

以这种方式构建的任何 LINQ 查询都提供了一个`ForAll`方法，该方法接受一个委托。当您调用此方法时，它会为查询生成的所有项目并行调用委托，在可能的情况下使用多个线程。

## TPL 数据流

TPL Dataflow 是一个运行时库特性，允许您构建一个对象图，这些对象在信息流经它们时执行某种处理。您可以告诉 TPL 哪些节点需要按顺序处理信息，哪些可以同时处理多个数据块。您将数据推入图中，TPL 将管理每个节点处理块的过程，并尝试优化并行级别以匹配计算机上可用的资源。

数据流 API 位于`System.Threading.Tasks.Dataflow`命名空间中（它内置于 .NET Core 和 .NET 中；在 .NET Framework 中，您需要添加对 NuGet 包的引用，也称为`System.Threading.Tasks.Dataflow`）。它非常庞大和复杂，可以单独占据一整章。不幸的是，这超出了本书的范围。我提到它是因为对于某些工作来说，了解它是值得的。

# 摘要

线程提供同时执行多段代码的能力。在具有多个 CPU 执行单元（即多个硬件线程）的计算机上，您可以通过使用多个软件线程利用这种并行潜力。您可以使用`Thread`类显式创建新的软件线程，或者您可以使用线程池或并行化机制（如`Parallel`类或 Parallel LINQ）自动确定要使用多少线程来运行应用程序提供的工作。如果多个线程需要使用和修改共享数据结构，则需要使用 .NET 提供的同步机制来确保线程可以正确协调它们的工作。

线程也可以提供一种执行多个并发操作的方式，这些操作不需要整个时间都占用 CPU（例如，等待外部服务的响应），但通常使用异步 API（如果可用的话）执行这类工作更为高效。任务并行库（TPL）提供了适用于这两种并发方式的抽象。它可以管理线程池中的多个工作项，支持组合多个操作和处理可能复杂的错误场景，其`Task`抽象也可以表示固有的异步操作。下一章将介绍 C# 语言特性，大大简化了与任务的工作。

¹ 在此处广泛使用“状态”一词。我只是指存储在变量和对象中的信息。

² 在撰写本文时，文档并未为`HashSet<T>`和`SortedSet<T>`提供只读线程安全性保证。尽管如此，微软已经向我保证这些结构也支持并发读取。

³ 在只有一个硬件线程的机器上，当`SpinLock`进入其循环时，它告诉操作系统调度程序它希望让出 CPU 的控制权，以便其他线程（希望包括当前持有锁的线程）可以取得进展。即使在多核系统上，`SpinLock`有时也会这样做，以避免过多的自旋可能导致的一些微妙问题。
