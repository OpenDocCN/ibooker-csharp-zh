# 附录 B 清洁代码检查清单

当你遇到不熟悉的代码或编写新代码时，可以使用这个简短的检查清单。这个清单并不全面，只是你自己的研究的一个起点。

一般

+   我的代码读起来像叙述。我为人类编写代码，而不是为机器。

+   只有在必要时，我才记录我的代码。我的代码应该能够自我表达。

+   我提供了关于如何构建和发布我的代码库的明确说明。在适当的地方，我提供了工作构建脚本/Makefile 或 CI/CD 设置说明。

+   除非有非常好的理由，否则我使用原生功能而不是实现自己的库。

+   我的代码在设计模式、文档和命名约定上保持一致。我不会在开发过程中改变事物并违反既定模式。

+   我已经给我的应用程序添加了日志记录功能，这样当事情出错时，我或其他开发者可以调试。

类

+   我的类具有最严格的访问修饰符。

+   我的班级命名准确。

+   我的类只对特定对象执行操作，因此遵循单一职责原则。

+   我的类位于我的项目中的正确文件夹中。

+   如果我在实现我的类时遇到困难，我会退一步，简要描述一下类的功能和预期功能。这种重新聚焦可以帮助编写更干净的代码。如果我的类应该做多件事，我会将其拆分。

方法

+   我的函数具有最严格的访问修饰符。

+   我的函数命名准确，并且正确地描述了其中的逻辑（不遗漏任何内容）。

+   我的函数只执行一个通用操作或从与其操作相关的其他函数收集信息。它遵循单一职责原则。

+   如果我的函数有公共访问修饰符，我不会在该函数内执行任何操作。公共方法调用其他较小的方法并组织输出。

+   我的方法有单元测试支持。单元测试应该覆盖主要成功和失败逻辑分支。

变量、字段和属性（VFP）

+   我的 VFP 类型是最抽象的类型。如果我可以使用接口而不是具体类型，我就使用接口。这促进了多态性和 Liskov 替换原则的使用。

+   我没有将任何“魔法数字”分配给变量。

+   在可能的情况下，我将我的 VFP 限制在尽可能紧密的访问修饰符上。如果一个 VFP 可以被设置为只读，我就将其设置为只读。如果一个 VFP 可以被设置为常量，我就将其设置为常量。

+   我总是验证我的输入参数。这可以保护我不受不想要的空指针异常和操作无效状态的数据的影响。

+   在适当的情况下，我使用枚举和常量而不是字符串字面量。

测试

+   我总是给我的代码提供适当的单元测试。

+   在可能的情况下，我遵循测试驱动开发。

+   我并不关注代码覆盖率。我的测试目标是防止意外副作用，并验证我对需求和现有代码的假设。

+   如果我的某个更改破坏了测试，我会修复测试。

+   我总是编写最少的代码来满足所有测试。任何多余的行都会增加维护代码的量。
