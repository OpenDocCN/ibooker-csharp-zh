# A

函数式编程

说学习 FP 使你成为一个更好的程序员是轶事性的。确实，FP 提供了一种替代方案，通常更简单，可以用来思考问题。此外，许多 FP 技术可以成功地应用于其他语言。无论你使用什么语言，以函数式风格进行编程都能带来好处。

FP 与其说是一套特定的工具或语言，不如说是一种心态。熟悉不同的编程范式使你成为一个更好的程序员，而多范式程序员比多语言程序员更有力量。因此……

由于本书的章节已经整理好了技术背景，这个附录不涉及 FP 在并发方面的应用，如不可变性、引用透明性、无副作用函数和惰性评估。相反，它涵盖了关于 FP 是什么以及为什么你应该关心它的基本信息。

## 什么是函数式编程？

FP 对不同的人意味着不同的事情。它是一种将计算视为表达式评估的程序范式。科学中的*范式*描述了不同的概念或思维模式。

FP 涉及使用状态和可变数据来解决领域问题，它基于λ演算。因此，函数是*一等值*。

FP 是一种编程风格，它通过评估表达式与执行语句之间的推理来进行。术语*表达式*来自数学；表达式总是返回一个结果（值），而不改变程序状态。一个*语句*不返回任何内容，并且可以改变程序状态：

+   *语句执行*指的是将程序表达为一系列命令或语句。命令指定如何通过创建对象和操作它们来实现最终结果。

+   *表达式评估*指的是程序如何指定你想要作为结果获取的对象属性。你不需要指定构建对象所需的步骤，并且不能在对象创建之前意外地使用该对象。

### 函数式编程的好处

这里是 FP（函数式编程）的好处列表：

+   *可组合性和模块化*——通过引入纯函数，你可以组合函数并从简单函数中创建高级抽象。使用模块，程序可以以更好的方式组织。可组合性是战胜复杂性的最有力的工具；它让你能够定义和构建复杂问题的解决方案。

+   *表达性*——你可以用简洁和声明性的格式表达复杂的思想，提高意图的清晰度和对程序进行推理的能力，并减少代码复杂性。

+   *可靠性和测试*—函数不存在副作用；一个函数只评估并返回一个依赖于其参数的值。因此，你可以通过仅关注其参数来检查函数，这允许进行更好的测试，以便轻松验证代码的正确性。

+   *更易并发的实现*—并发鼓励引用透明性和不可变性，这是在多个核心上有效运行正确、无锁的并发应用程序的主要关键。

+   *惰性评估*—你可以按需检索函数的结果。假设你有一个大数据流要分析。多亏了 LINQ，你可以使用延迟执行和惰性评估按需（仅在需要时）处理你的数据分析。

+   *生产力*—这是一个巨大的好处：你可以用更少的代码行数实现与其他范式相同的功能。生产力减少了开发程序所需的时间，这可以转化为更大的利润空间。

+   *正确性*—你可以编写更少的代码，自然地减少可能出现的错误数量。

+   *可维护性*——这种好处来自于其他好处，例如代码可组合、模块化、表达性强和正确。

学习函数式编程将导致代码更加模块化、面向表达式、概念简单。这些函数式编程资产的组合让你能够理解你的代码正在做什么，无论它正在执行多少线程。

### 函数式编程的原则

函数式编程（FP）有四个主要原则，这些原则导致了一种可组合和声明式的编程风格：

+   高阶函数（HOFs）作为一等值

+   不变性

+   纯函数，也称为无副作用函数

+   声明式编程风格

## 程序范式的冲突：从命令式到面向对象再到函数式编程

> 面向对象编程通过封装移动部分使代码易于理解。函数式编程通过最小化移动部分来使代码易于理解。

—迈克尔·费思，著有《与遗留代码一起工作》，通过推特

本节描述了三种编程范式：

+   *命令式编程*通过改变程序状态和定义执行命令的顺序来描述计算。因此，命令式范式是一种通过计算一系列语句来改变状态的风格。

+   *函数式编程*通过将计算视为表达式的评估来构建程序的结构和元素；因此，FP 促进不可变性和避免状态。

+   *面向对象编程*（OOP）组织对象而不是动作，其数据结构包含数据而不是逻辑。主要的编程范式可以分为命令式和函数式。OOP 与命令式和函数式编程是正交的，这意味着它可以与两者结合使用。你不必偏好一种范式而牺牲另一种，但你可以使用函数式或命令式概念编写具有 OOP 风格的软件。

面向对象编程（OOP）已经存在了近二十年，其设计原则被 Java、C#和 VB.Net 等语言所采用。OOP 之所以取得巨大成功，是因为它能够表示和模拟用户域，提高了抽象级别。OOP 语言引入背后的主要思想是代码复用性，但这一思想常常被特定场景和临时对象所需的修改和定制所扭曲。使用低耦合和良好代码复用性开发的 OOP 程序就像一个复杂的迷宫，有许多秘密和复杂的通道，降低了代码的可读性。

为了减轻这种难以实现的代码复用性，开发者开始创建设计模式来应对面向对象编程（OOP）繁琐的本质。设计模式鼓励开发者根据模式定制软件，使得代码库更加复杂、难以理解，并且在某些情况下，尽管可维护但仍然远未达到可复用的程度。在 OOP 中，设计模式在定义解决重复设计问题时是有用的，但它们可以被视为语言本身抽象的缺陷。

在 FP 中，设计模式有不同的含义；实际上，由于抽象级别更高以及作为构建块使用的高阶函数，大多数特定于 OOP 的设计模式在函数式语言中都是不必要的。FP 风格中更高的抽象级别和围绕低级细节的减少工作量具有产生更短程序的优势。当程序变得小的时候，它更容易理解、改进和验证。FP 对代码复用和减少重复代码有出色的支持，这是编写更少出错代码的最有效方式。

### 用于提高抽象级别的高阶函数

HOF 的原则意味着函数可以作为参数传递给其他函数，并且函数可以在它们的返回值中返回不同的函数。.NET 有泛型委托的概念，如`Action<T>`和`Func<T, TResult>`，可以用作 HOF 来传递带有 lambda 支持的函数作为参数。以下是在 C#中使用泛型委托`Func<T,R>`的示例：

```
Func<int, double> fCos = n => Math.Cos( (double)n );
double x = fCos(5); 
IEnumerable<double> values = Enumerable.Range(1, 10).Select(fCos); 
```

相应的代码可以用 F#中的函数语义来表示，无需显式使用`Func<T, TResult>`委托：

```
let fCos = fun n -> Math.Cos( double n )
let x = fCos 5
let values = [1..10] |> List.map fCos 
```

HOFs（高阶函数）是利用 FP（函数式编程）力量的核心。HOFs 具有以下优势：

+   组合和模块化

+   代码复用性

+   能够创建高度动态和适应性的系统

在函数式编程（FP）中，函数被视为一等值，这意味着函数可以被变量命名，可以被分配给变量，并且可以出现在任何其他语言构造可以出现的地方。如果你来自直接的面向对象（OOP）经验，这个概念允许你以非规范的方式使用函数，例如将相对通用的操作应用于标准数据结构。高阶函数（HOFs）让你专注于结果，而不是步骤。这是在处理函数式语言时的一个基本且强大的转变。不同的函数式技术允许你实现函数式组合：

+   组合

+   柯里化

+   部分应用函数或部分应用

使用委托的强大功能可以表达针对不仅执行单一操作的方法，还可以增强、重用和扩展的行为引擎的功能。这种编程风格是函数范式的基础，其优点是减少了代码重构的数量：而不是拥有多个专用且僵化的方法，程序可以通过更少但更通用和可重用的方法来表示，这些方法可以扩展以处理多个和不同的场景。

### 高阶函数和 lambda 表达式用于代码重用

使用 lambda 表达式的一个许多有用的原因是为了重构代码，减少冗余。在像 C# 这样的内存管理语言中，尽可能确定性地释放资源是一种良好的实践。考虑以下示例：

```
string text;
using (var stream = new StreamReader(path)) 
{
    text = stream.ReadToEnd();
} 
```

在此代码中，`StreamReader` 资源通过 `using` 关键字进行释放。这是一个众所周知的模式，但存在局限性。由于可释放变量是在 `using` 范围内声明的，因此该模式不可重用，一旦释放后便无法重用，并且如果它调用已释放的对象，会引发异常。以经典面向对象（OOP）风格重构代码并非易事。可以使用模板方法模式，但这种解决方案也引入了更多复杂性，需要为每个派生类创建新的基类和实现。一个更好且更优雅的解决方案是使用 lambda 表达式（匿名委托）。以下是实现静态辅助方法及其使用的代码：

```
R Using<T,R>(this T item, Func<T, R> func) where T : **IDisposable** {
    using (item)
           return func(item);
}

string text = new StreamReader(path).**Using**(stream => stream.ReadToEnd()); 
```

此代码实现了一个灵活且可重用的清理可释放资源的模式。这里唯一的约束是泛型类型 `T` 必须是实现 `IDisposable` 的类型。

### Lambda 表达式和匿名函数

术语 *lambda* 或 *lambda 表达式* 最常指匿名函数。lambda 表达式的目的是基于函数表达计算，使用变量绑定和替换。用更简单的话说，lambda 表达式是替代委托实例的无名方法，引入了 *匿名函数* 的概念。

Lambda 表达式提高了抽象级别，从而简化了编程体验。基于 Lambda 演算的函数式语言，如 F#，用于表达对函数抽象的计算；因此，Lambda 表达式是 FP 语言的一部分。然而，在 C# 中，引入 Lambda 的主要动机是促进基于流的抽象，这使基于声明的 API 成为可能。这种抽象提供了一条通往多核并行处理的自然路径，使 Lambda 表达式成为当前计算领域的一个宝贵工具。

要创建 Lambda 表达式，您需要在 Lambda 操作符 `=>`（发音为“goes to”）的左侧指定输入参数（如果有），并将表达式或语句块放在右侧。例如，Lambda 表达式 `(x, y) => x + y` 指定了两个参数 `x` 和 `y`，并返回这些值的总和。

每个 Lambda 表达式有三个部分：

+   `(x, y)` — 一组参数。

+   `=>` — 分隔参数列表和结果表达式的“goes to”运算符（`=>`）。

+   `x + y` — 一组执行操作或返回值的语句。在这个例子中，Lambda 表达式返回 `x` 和 `y` 的总和。

下面是如何实现具有相同行为的三个 Lambda 表达式：

```
Func<int, int, int> add = delegate(int x, int x){ return x + y; };
Func<int, int, int> add = (int x, int y) => { return x + y; };
Func<int, int, int> add = (x, y) => x + y 
```

`Func<int, int, int>` 这一部分定义了一个函数，它接受两个整数并返回一个新的整数。

在 F# 中，强类型系统可以在没有显式声明的情况下将名称或标签绑定到函数。F# 函数是原始值，类似于整数和字符串。可以将前面的函数翻译成等效的 F# 语法，如下所示：

```
let add = (fun x y -> x + y)
let add = (+) 
```

在 F# 中，`*plus*`（+）运算符是一个与 `*add*` 具有相同签名的函数，它接受两个数字并返回它们的和作为结果。

Lambda 表达式是一种简单而有效的解决方案，用于分配和执行一段内联代码块，尤其是在代码块仅服务于特定目的且不需要将其定义为方法的情况下。将 Lambda 表达式引入代码中有许多优点。以下是一个简短的列表：

+   您不需要对类型进行显式参数化；编译器可以确定参数类型。

+   简洁的内联编码（函数存在于行内）避免了开发者必须在其他地方查找功能时造成的干扰。

+   捕获变量限制了类级别变量的暴露。

+   Lambda 表达式使代码的流程易于阅读和理解。

### Currying

“柯里化”这个术语起源于 Haskell Curry，他是函数式编程发展的重要影响者，一位数学家。柯里化是一种让你模块化函数和重用代码的技术。基本思想是将接受多个参数的函数的评估转换为一系列函数的评估，每个函数只有一个参数。函数式语言与数学概念密切相关，其中函数只能有一个参数。F# 遵循这一概念，因为具有多个参数的函数被声明为一系列新函数，每个函数只有一个参数。

在实践中，其他 .NET 语言具有具有多个参数的函数；从面向对象的角度来看，如果你没有传递给函数所有期望的参数，编译器会抛出异常。相反，在函数式编程（FP）中，编写一个返回任何你给出的函数的柯里化函数非常容易。但如前所述，lambda 表达式提供了创建匿名委托的出色语法，从而使得实现柯里化函数变得简单。此外，在支持闭包的任何编程语言中都可以实现柯里化——这是一个有趣的概念，因为这种技术简化了 lambda 表达式，包括只有单个参数的函数。

柯里化技术使得可以将所有具有一个或多个参数的函数视为只接受一个参数，而不考虑执行所需的参数数量。这创建了一个函数链，其中每个函数只消耗一个参数。

在这个函数链的末尾，所有参数都一次性可用，这使得原始函数可以执行。此外，柯里化允许你创建由固定基函数参数生成的专用函数组。例如，当你对一个具有两个参数的函数进行柯里化并将其应用到第一个参数时，功能被限制在一维。这不是限制，而是一种强大的技术，因为然后你可以将新函数应用到第二个参数来计算特定的值。

在数学符号中，这两个函数之间存在一个重要的区别：

```
Add(x, y, z)
Add x y z 
```

差别在于第一个函数接受一个类型为 `tuple` 的单个参数（由三个项目 `x`、`y` 和 `z` 组成），而第二个函数接受输入项 `x` 并返回一个接受输入项 `y` 的函数，该函数返回一个接受项目 `z` 的函数，然后返回最终计算的结果。用更简单的话说，等效函数可以重写为

```
(((Add x) y) z) 
```

重要的是要提到，函数应用是左结合的，一次只接受一个参数。之前的函数 `Add` 是对 `x` 的应用，然后结果被应用到 `y` 上。这个应用的结果 `((Add x) y)` 然后被应用到 `z` 上。因为每个过渡步骤都产生一个函数，所以定义一个函数如下是完全可行的

```
Plus2 = Add 2 
```

这个函数等同于`Add x`。在这种情况下，你可以期待函数`Plus2`接受两个输入参数，并且它总是传递 2 作为固定参数。为了清晰起见，可以将前面的函数重写如下：

```
Plus2 x = Add 2 x 
```

产生中间函数（每个函数接受一个输入参数）的过程称为*柯里化*。让我们看看柯里化的实际应用。考虑以下使用 lambda 表达式的简单 C#函数：

```
Func<int,int,int> add = (x,y) => x + y;         
Func<int,Func<int,int>> curriedAdd = x => y => x + y; 
```

这段代码定义了一个函数`Func<int, int, int> add`，它接受两个整数作为参数并返回一个整数。当调用此函数时，编译器需要两个参数`x`和`y`。但函数`add`的柯里化版本`curried­Add`导致一个具有特殊签名`Func<int,Fun< int, int>>`的委托。

通常，任何类型为`Func<A,B,R>`的委托都可以转换为类型为`Func<A, Func<B,R>>`的委托。这个柯里化函数只接受一个参数，并返回一个函数，该函数接受原始函数作为参数，然后返回类型为`A`的值。柯里化函数`curriedAdd`可以用来创建强大的专用函数。例如，你可以通过添加值 1 来定义一个`increment`函数：

```
Func<int,int> increment = curriedAdd(1) 
```

现在，你可以使用这个函数来定义其他执行多种形式的加法操作的函数：

```
int a = curriedAdd(30)
int b = increment(41)

Func<int, int> add30 = curriedAdd(30)
int c = add30(12) 
```

函数柯里化的一个好处是创建专用函数更容易重用；但真正的力量在于柯里化函数引入了一个有用的概念，称为*部分应用函数*，这在下一节中会介绍。柯里化技术的其他好处包括函数参数减少和易于重用的抽象函数。

#### C#中的自动柯里化

使用扩展方法可以在 C#中自动化并提高柯里化技术的抽象级别。在这个例子中，curry 扩展方法的目的是通过引入语法糖来隐藏柯里化实现：

```
static Func<A, Func<B, R>> Curry<A, B, R>(this Func<A, B, R> function)
{
    return a => b => function(a, b);
} 
```

这是使用辅助扩展方法重构的代码：

```
Func<int,int,int> add = (x,y) => x + y;
Func<int,Func<int,int>> curriedAdd = add.Curry(); 
```

这种语法看起来更简洁。重要的是要注意，编译器可以推断出所有函数中使用的类型，并且这对于这一点非常有帮助。事实上，尽管`Curry`是一个泛型函数，但不需要显式传递泛型参数。使用这种柯里化技术让你可以使用不同的语法，这更有利于从简单函数构建复杂复合函数的库。你可以作为本书资源的部分下载的源代码中包含了一个包含完整辅助方法实现的库，包括自动柯里化的扩展方法。

#### 取消柯里化

就像将柯里化技术应用于一个函数一样，你可以通过使用高阶函数来逆转柯里化函数，从而取消柯里化一个函数。显然，取消柯里化是柯里化的相反转换。将取消柯里化视为通过应用通用的取消柯里化函数来撤销柯里化的技术。

在以下示例中，具有签名`Func<A, Func<B, R>>`的柯里化函数将被转换回一个多参数函数：

```
public static Func<A, B, R> Uncurry<A, B, R>(Func<A, Func<B, R>> function) 
                                      => (x, y) => function(x)(y); 
```

函数去柯里化的主要目的是将柯里化函数的签名转换回更面向对象（OOP）的风格。

#### F#中的柯里化

在 F#中，函数声明默认是柯里化的。尽管这是编译器为你自动完成的，但了解 F#如何处理柯里化函数是有帮助的。

以下示例显示了两个 F#函数，它们用于乘以两个值。如果你不熟悉 F#，这些函数可能看起来等效或至少相似，但它们并不相同：

```
let multiplyOne (x,y) = x * y
let multiplyTwo x y = x * y

let resultOne = multiplyOne(7, 8)
let resultTwo = multiplyTwo 7 8
let values = (7,8)
let resultThree = multiplyOne values 
```

除了语法之外，这些函数之间没有明显的差异，但它们的行为不同。第一个函数只有一个参数，它是一个包含所需值的元组，但第二个函数有两个不同的参数`x`和`y`。

当你查看这些函数声明的签名时，差异变得明显：

```
val multiplyOne : (int * int) -> int
val multiplyTwo : int -> int -> int 
```

现在很明显，这些函数是不同的。第一个函数接受一个元组作为输入参数并返回一个整数。第二个函数接受一个整数作为其第一个输入，并返回一个接受整数作为输入并返回整数的函数。这个接受两个参数的第二个函数被编译器自动转换成一系列函数，每个函数有一个输入参数。

此示例显示了等效的柯里化函数，这是编译器为你解释的方式：

```
let multiplyOne x y = x * y
let multiplyTwo = fn x -> fun y -> x * y

let resultOne = multiplyOne 7 8
let resultTwo = multiplyTwo 7 8
let resultThree = 
    let tempMultiplyBy7 = multiplyOne 7
    tempMultiplyBy7 8 
```

在 F#中，这些函数的实现是等效的，因为，如前所述，它们默认是柯里化的。柯里化的主要目的是为了优化函数，以便更容易地进行部分应用。

### 部分应用函数

*部分应用函数*（或部分函数应用）是将多个参数固定到函数中并产生另一个较小阶数（函数的*阶数*是它的参数数量）的函数的技术。通过这种方式，部分函数提供了一个比预期更少的参数的函数，为给定的值产生一个专门的函数。除了函数组合外，部分应用函数还使函数模块化成为可能。

更简单地说，部分函数应用是一个将值绑定到参数的过程，这意味着部分应用函数是通过使用固定（默认）值来减少函数参数数量的函数。如果你有一个具有`N`个参数的函数，你可以创建一个具有`N-1`个参数的函数，该函数使用固定参数调用原始函数。因为部分应用依赖于柯里化，所以这两种技术同时发生。部分应用与柯里化的区别在于，部分应用将多个参数绑定到一个值上，因此要评估函数的其余部分，你需要应用剩余的参数。

通常，部分应用将一个通用函数转换为一个新且专门的函数。让我们以 C# 的柯里化函数为例：

```
Func<int,int,int> add = (x,y) => x + y; 
```

你如何创建一个单参数的新函数？

在这种情况下，部分函数应用变得有用，因为你可以对原始函数的第一个参数应用一个默认值来部分应用一个函数到一个高阶函数 (HOF)。以下是可以用来部分应用函数的扩展方法：

```
static Func<B, R> Partial<A, B, R>(this Func<A, B, R> function, A argument) 
                             => argument2 => function(argument, argument2); 
```

下面是一个练习这种技术的例子：

```
Func<int, int, int> max = Math.Max;
Func<int, int> max5 = max.Partial(5);

int a = max5(8);
int b = max5(2);
int c = max5(12); 
```

`Math.Max(int, int)` 是一个可以通过部分应用函数进行扩展的函数示例。在这种情况下引入部分应用函数，默认参数 `5` 被固定，它创建了一个新的专用函数 `max5`，该函数在两个数字之间评估最大值，默认为 `5`。多亏了部分应用，你从一个现有的函数中创建了一个新的、更具体的函数。

从面向对象的角度来看，将部分函数应用视为覆盖函数的一种方式。还可以使用这种技术来扩展第三方库的即时功能，该库本身不可扩展。

如前所述，在 F# 中函数默认是柯里化的，这比在 C# 中创建部分函数更容易。部分函数应用有许多好处，包括以下内容：

+   它们允许函数在没有犹豫的情况下被组合。

+   它们通过避免构建包含具有不同输入数量重写版本的同一种方法的不必要类，减轻了传递一组单独参数的需求。

+   它们使开发者能够通过参数化其行为来编写高度通用的函数。

使用部分函数应用的实际好处是，只提供部分参数构建的函数有利于代码重用、功能扩展性和组合。此外，部分应用函数简化了在编程风格中使用高阶函数。部分函数应用还可以延迟以改进性能，这在第 2.6 节中介绍过。

### C# 中部分函数应用和柯里化的力量

让我们考虑一个更完整的部分函数应用和柯里化的例子，它可以涵盖实际使用场景。`Retry` 在 列表 A.1 中是一个为任何无参数且返回类型为 `T` 的函数的 `Func<T>` 委托的扩展方法。此方法的目的是在 `try-catch` 块中执行传入的函数，如果在执行过程中抛出异常，则函数将重试操作，最多重试三次。

列表 A.1 中的 `Retry` 扩展方法

```
public static T Retry<T>(this Func<T> function)   ①  
{
 int retry = 0;   ②  
 T result = default(T);   ③  
        bool success = false;
     do{
            try {
 result = function();   ④  
 success = true;   ⑤  
            }
            catch {
 retry++;   ⑥  
            }
 } while (!success && retry < 3);   ⑥  
     return result;
} 
```

假设这种方法试图从文件中读取文本。在下面的代码中，方法`ReadText`接受一个文件路径作为输入并返回文件中的文本。为了执行带有附加的`Retry`行为的功能，以便在出现问题时回退并恢复，你可以使用闭包，如下所示：

```
static string ReadText(string filePath) => File.ReadAllText(filePath);

string filePath = "TextFile.txt";
Func<string> readText = () => ReadText(filePath);

string text = readText.Retry(); 
```

你可以使用 lambda 表达式捕获局部变量`filePath`并将其传递给`ReadText`方法。这个过程让你可以创建一个与`Retry`扩展方法的签名匹配的`Func<string>`，并将其附加。如果文件被阻塞或被另一个进程拥有，将抛出错误，并且`Retry`功能将按预期启动。如果第一次调用失败，该方法将第二次和第三次重试。最后，它返回类型`T`的默认值。

这确实可行，但你可能会想知道如果你想要重试一个需要字符串参数的函数会发生什么。解决方案是部分应用该函数。下面的代码实现了一个接受字符串参数的函数，该参数是从中读取文本的文件路径，然后将其传递给`ReadText`方法。由于`Retry`行为只适用于不接受参数的函数，所以代码无法编译：

```
Func<string, string> readText = (path) => ReadText(path);

string text = readText.Retry();          
string text = readText(filePath).Retry(); 
```

`Retry`的行为不适用于这个版本的`readText`。一个可能的解决方案是编写另一个版本的`Retry`方法，该方法接受一个额外的泛型类型参数，该参数指定了在调用时需要传递的参数类型。这不是最佳选择，因为你必须弄清楚如何将这种新的`Retry`逻辑共享到所有使用它的方法中，每个方法都有不同的参数或实现。

更好的选择是使用并组合柯里化和部分函数应用。在下面的列表中，辅助方法`Curry`和`Partial`被定义为扩展方法。

列表 A.2 C#中的`Retry`辅助扩展

```
static class RetryExtensions
{
    public static Func<R> Partial<T, R>(this Func<T, R> function, T arg){
            return () => function(arg); 
    }    

    public static Func<T, Func<R>> Curry<T, R>(this Func<T, R> function){
        return arg => () => function(arg);
    }
}

Func<string, string> readText = (path) => ReadText(path);

string text = readText.Partial("TextFile.txt").Retry();

Func<string, Func<string>> curriedReadText = readText.Curry();
string text = curriedReadText("TextFile.txt").Retry(); 
```

这种方法让你可以注入文件路径并平滑地使用`Retry`函数。这是因为辅助函数`Partial`和`Curry`都将`readText`函数转换为一个不需要参数的函数，最终与`Retry`的签名相匹配。
