- en: Chapter 4\. Advanced C#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章。高级C#
- en: In this chapter, we cover advanced C# topics that build on concepts explored
    in Chapters [2](ch02.html#chash_language_basics) and [3](ch03.html#creating_types_in_chash).
    You should read the first four sections sequentially; you can read the remaining
    sections in any order.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了在第[2](ch02.html#chash_language_basics)章和第[3](ch03.html#creating_types_in_chash)章探讨的概念基础上构建的高级C#主题。您应该按顺序阅读前四个部分；其余部分可以任意顺序阅读。
- en: Delegates
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 委托
- en: A delegate is an object that knows how to call a method.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 委托是一个知道如何调用方法的对象。
- en: 'A *delegate type* defines the kind of method that *delegate instances* can
    call. Specifically, it defines the method’s *return type* and its *parameter types*.
    The following defines a delegate type called `Transformer`:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*委托类型*定义了*委托实例*可以调用的方法类型。具体而言，它定义了方法的*返回类型*和*参数类型*。以下定义了一个名为`Transformer`的委托类型：'
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`Transformer` is compatible with any method with an `int` return type and a
    single `int` parameter, such as this:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`Transformer`与任何具有`int`返回类型和单个`int`参数的方法兼容，例如：'
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or, more tersely:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更简洁地说：
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Assigning a method to a delegate variable creates a delegate *instance*:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法分配给委托变量会创建委托*实例*：
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can invoke a delegate instance in the same way as a method:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像调用方法一样调用委托实例：
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here’s a complete example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个完整的例子：
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A delegate instance literally acts as a delegate for the caller: the caller
    invokes the delegate, and then the delegate calls the target method. This indirection
    decouples the caller from the target method.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 委托实例实际上充当调用者的代表：调用者调用委托，然后委托调用目标方法。这种间接性解耦了调用者与目标方法之间的关系。
- en: 'The statement:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 语句：
- en: '[PRE6]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'is shorthand for:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 是的缩写为：
- en: '[PRE7]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Technically, we are specifying a *method group* when we refer to `Square` without
    brackets or arguments. If the method is overloaded, C# will pick the correct overload
    based on the signature of the delegate to which it’s being assigned.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，当我们不使用括号或参数引用`Square`时，我们正在指定一个*方法组*。如果方法被重载，C#将根据分配给它的委托的签名选择正确的重载。
- en: The expression
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式
- en: '[PRE8]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: is shorthand for
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 是的缩写
- en: '[PRE9]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-27
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A delegate is similar to a *callback*, a general term that captures constructs
    such as C function pointers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 委托类似于*回调*，这是一个泛指，涵盖了诸如C函数指针之类的构造。
- en: Writing Plug-in Methods with Delegates
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用委托编写插件方法
- en: 'A delegate variable is assigned a method at runtime. This is useful for writing
    plug-in methods. In this example, we have a utility method named `Transform` that
    applies a transform to each element in an integer array. The `Transform` method
    has a delegate parameter, which you can use for specifying a plug-in transform:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 委托变量在运行时分配一个方法。这对于编写插件方法非常有用。在本例中，我们有一个名为`Transform`的实用方法，它将转换应用于整数数组中的每个元素。`Transform`方法有一个委托参数，您可以用来指定一个插件转换：
- en: '[PRE10]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can change the transformation just by changing `Square` to `Cube` in the
    second line of code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在代码的第二行中将`Square`更改为`Cube`来更改转换。
- en: Our `Transform` method is a *higher-order function* because it’s a function
    that takes a function as an argument. (A method that *returns* a delegate would
    also be a higher-order function.)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Transform`方法是一个*高阶函数*，因为它是一个接受函数作为参数的函数。（返回委托的方法也将是高阶函数。）
- en: Instance and Static Method Targets
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例和静态方法目标
- en: 'A delegate’s target method can be a local, static, or instance method. The
    following illustrates a static target method:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 委托的目标方法可以是局部、静态或实例方法。以下示例说明了一个静态目标方法：
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following illustrates an instance target method:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了一个实例目标方法：
- en: '[PRE12]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When an *instance* method is assigned to a delegate object, the latter maintains
    a reference not only to the method but also to the *instance* to which the method
    belongs. The `System.Delegate` class’s `Target` property represents this instance
    (and will be null for a delegate referencing a static method). Here’s an example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当将*实例*方法分配给委托对象时，后者不仅保留对方法的引用，还保留对方法所属*实例*的引用。`System.Delegate`类的`Target`属性表示这个实例（对于引用静态方法的委托将为空）。以下是一个例子：
- en: '[PRE13]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Because the instance is stored in the delegate’s `Target` property, its lifetime
    is extended to (at least as long as) the delegate’s lifetime.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因为实例存储在委托的`Target`属性中，其生命周期延长至（至少与）委托的生命周期相同。
- en: Multicast Delegates
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多播委托
- en: 'All delegate instances have *multicast* capability. This means that a delegate
    instance can reference not just a single target method but also a list of target
    methods. The `+` and `+=` operators combine delegate instances:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所有委托实例都具有*多播*能力。这意味着委托实例可以引用不只一个单一目标方法，还可以引用一个目标方法列表。`+` 和 `+=` 操作符可以组合委托实例：
- en: '[PRE14]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The last line is functionally the same as the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行与以下内容功能上是相同的：
- en: '[PRE15]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Invoking `d` will now call both `SomeMethod1` and `SomeMethod2`. Delegates are
    invoked in the order in which they are added.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `d` 现在将调用 `SomeMethod1` 和 `SomeMethod2`。委托按照添加的顺序被调用。
- en: 'The `-` and `-=` operators remove the right delegate operand from the left
    delegate operand:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`-` 和 `-=` 操作符会从左侧委托操作数中移除右侧委托操作数：'
- en: '[PRE16]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Invoking `d` will now cause only `SomeMethod2` to be invoked.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `d` 现在只会导致 `SomeMethod2` 被调用。
- en: 'Calling `+` or `+=` on a delegate variable with a `null` value works, and it
    is equivalent to assigning the variable to a new value:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个委托变量的值为`null`时，对其调用`+`或`+=`操作是有效的，并且等同于将该变量赋值为一个新值：
- en: '[PRE17]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Similarly, calling `-=` on a delegate variable with a single matching target
    is equivalent to assigning `null` to that variable.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对一个委托变量调用`-=`并匹配单一目标，等同于将该变量赋值为`null`。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Delegates are *immutable*, so when you call `+=` or `-=`, you’re in fact creating
    a *new* delegate instance and assigning it to the existing variable.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 委托是*不可变的*，因此当您调用 `+=` 或 `-=` 时，实际上是创建一个*新的*委托实例并将其赋给现有变量。
- en: If a multicast delegate has a nonvoid return type, the caller receives the return
    value from the last method to be invoked. The preceding methods are still called,
    but their return values are discarded. For most scenarios in which multicast delegates
    are used, they have `void` return types, so this subtlety does not arise.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个多播委托具有非`void`返回类型，调用者将接收到最后一个被调用方法的返回值。前面的方法仍然会被调用，但它们的返回值会被丢弃。在大多数使用多播委托的场景中，它们具有`void`返回类型，因此这种细微差别并不会出现。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: All delegate types implicitly derive from `System.MulticastDelegate`, which
    inherits from `System.Delegate`. C# compiles `+`, `-`, `+=`, and `-=` operations
    made on a delegate to the static `Combine` and `Remove` methods of the `System.Delegate`
    class.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所有委托类型都隐式派生自`System.MulticastDelegate`，后者继承自`System.Delegate`。在C#中，对委托进行的`+`、`-`、`+=`和`-=`操作会被编译为`System.Delegate`类的静态`Combine`和`Remove`方法。
- en: Multicast delegate example
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多播委托示例
- en: 'Suppose that you wrote a method that took a long time to execute. That method
    could regularly report progress to its caller by invoking a delegate. In this
    example, the `HardWork` method has a `ProgressReporter` delegate parameter, which
    it invokes to indicate progress:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您编写了一个执行时间长的方法。该方法可以通过调用委托定期向其调用者报告进度。在这个例子中，`HardWork` 方法具有一个 `ProgressReporter`
    委托参数，用于指示进度：
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To monitor progress, we can create a multicast delegate instance `p`, such
    that progress is monitored by two independent methods:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了监视进度，我们可以创建一个多播委托实例 `p`，使得进度由两个独立的方法监视：
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Generic Delegate Types
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型委托类型
- en: 'A delegate type can contain generic type parameters:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 委托类型可以包含泛型类型参数：
- en: '[PRE20]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With this definition, we can write a generalized `Transform` utility method
    that works on any type:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个定义，我们可以编写一个通用的 `Transform` 实用方法，适用于任何类型：
- en: '[PRE21]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The Func and Action Delegates
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Func 和 Action 委托
- en: 'With generic delegates, it becomes possible to write a small set of delegate
    types that are so general they can work for methods of any return type and any
    (reasonable) number of arguments. These delegates are the `Func` and `Action`
    delegates, defined in the `System` namespace (the `in` and `out` annotations indicate
    *variance*, which we cover in the context of delegates shortly):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用泛型委托，可以编写一小组委托类型，这些类型如此通用，可以处理任何返回类型和任意（合理数量的）参数。这些委托是在 `System` 命名空间中定义的
    `Func` 和 `Action` 委托（`in` 和 `out` 注释指示*变异*，我们会在委托上下文中详细讨论）：
- en: '[PRE22]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'These delegates are extremely general. The `Transformer` delegate in our previous
    example can be replaced with a `Func` delegate that takes a single argument of
    type `T` and returns a same-typed value:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些委托非常通用。在前面的例子中，`Transformer` 委托可以被一个 `Func` 委托替换，它接受类型为 `T` 的单一参数，并返回相同类型的值：
- en: '[PRE23]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The only practical scenarios not covered by these delegates are `ref`/`out`
    and pointer parameters.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这些委托未覆盖的唯一实际场景是`ref`/`out`和指针参数。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When C# was first introduced, the `Func` and `Action` delegates did not exist
    (because generics did not exist). It’s for this historical reason that much of
    .NET uses custom delegate types rather than `Func` and `Action`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当C#首次引入时，不存在`Func`和`Action`委托（因为没有泛型）。正因为这个历史原因，.NET的许多部分使用自定义委托类型而不是`Func`和`Action`。
- en: Delegates Versus Interfaces
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 委托与接口的比较
- en: 'A problem that you can solve with a delegate can also be solved with an interface.
    For instance, we can rewrite our original example with an interface called `ITransformer`
    instead of a delegate:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 用委托解决的问题也可以用接口解决。例如，我们可以使用名为`ITransformer`的接口而不是委托来重写我们的原始示例：
- en: '[PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'A delegate design might be a better choice than an interface design if one
    or more of these conditions are true:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以下一个或多个条件为真，则委托设计可能是一个更好的选择而不是接口设计：
- en: The interface defines only a single method.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口仅定义一个方法。
- en: Multicast capability is needed.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要多播功能。
- en: The subscriber needs to implement the interface multiple times.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅者需要多次实现接口。
- en: 'In the `ITransformer` example, we don’t need to multicast. However, the interface
    defines only a single method. Furthermore, our subscriber might need to implement
    `ITransformer` multiple times, to support different transforms, such as square
    or cube. With interfaces, we’re forced into writing a separate type per transform
    because a class can implement `ITransformer` only once. This is quite cumbersome:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ITransformer`示例中，我们不需要多播。然而，接口只定义了一个方法。此外，我们的订阅者可能需要多次实现`ITransformer`，以支持不同的转换，比如平方或立方。使用接口时，我们被迫为每种转换编写单独的类型，因为类只能实现`ITransformer`一次。这相当麻烦：
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Delegate Compatibility
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 委托的兼容性
- en: Type compatibility
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型的兼容性
- en: 'Delegate types are all incompatible with one another, even if their signatures
    are the same:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 即使委托类型的签名相同，它们之间也是不兼容的：
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-90
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following, however, is permitted:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，允许以下内容：
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Delegate instances are considered equal if they have the same method targets:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果委托实例具有相同的方法目标，则视为相等。
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Multicast delegates are considered equal if they reference the same methods
    *in the same order*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多播委托引用了*相同顺序*的相同方法，则被视为相等。
- en: Parameter compatibility
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数的兼容性
- en: 'When you call a method, you can supply arguments that have more specific types
    than the parameters of that method. This is ordinary polymorphic behavior. For
    the same reason, a delegate can have more specific parameter types than its method
    target. This is called *contravariance*. Here’s an example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用一个方法时，可以提供比该方法参数更具体的参数。这是普通的多态行为。出于同样的原因，委托的参数类型可能比其方法目标更具体。这被称为*逆变性*。以下是一个例子：
- en: '[PRE29]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: (As with type parameter variance, delegates are variant only for *reference
    conversions*.)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: （与类型参数的变异性类似，委托只对*引用转换*进行变异。）
- en: A delegate merely calls a method on someone else’s behalf. In this case, the
    `StringAction` is invoked with an argument of type `string`. When the argument
    is then relayed to the target method, the argument is implicitly upcast to an
    `object`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 委托仅代表他人调用方法。在这种情况下，`StringAction`以`string`类型的参数调用。然后将参数传递给目标方法时，参数会隐式向上转型为`object`。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The standard event pattern is designed to help you utilize contravariance through
    its use of the common `EventArgs` base class. For example, you can have a single
    method invoked by two different delegates, one passing a `MouseEventArgs` and
    the other passing a `KeyEventArgs`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 标准事件模式旨在通过使用常见的`EventArgs`基类帮助您利用逆变性。例如，可以通过两个不同的委托调用单个方法，一个传递`MouseEventArgs`，另一个传递`KeyEventArgs`。
- en: Return type compatibility
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回类型的兼容性
- en: 'If you call a method, you might get back a type that is more specific than
    what you asked for. This is ordinary polymorphic behavior. For the same reason,
    a delegate’s target method might return a more specific type than described by
    the delegate. This is called *covariance*:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你调用一个方法，可能会得到一个比你要求的更具体的类型。这是普通的多态行为。出于同样的原因，委托的目标方法可能返回比委托描述的更具体的类型。这被称为*协变*：
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`ObjectRetriever` expects to get back an `object`, but an `object` *subclass*
    will also do: delegate return types are *covariant*.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObjectRetriever`期望返回一个`object`，但是一个`object`的*子类*也可以：委托的返回类型是*协变*的。'
- en: Generic delegate type parameter variance
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 泛型委托类型参数的变异性
- en: In [Chapter 3](ch03.html#creating_types_in_chash), we saw how generic interfaces
    support covariant and contravariant type parameters. The same capability exists
    for delegates, too.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html#creating_types_in_chash)中，我们看到了泛型接口支持协变和逆变的类型参数。对于委托也存在相同的能力。
- en: 'If you’re defining a generic delegate type, it’s good practice to do the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在定义通用委托类型，以下是一个良好的实践：
- en: Mark a type parameter used only on the return value as covariant (`out`).
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将仅用于返回值的类型参数标记为协变（`out`）。
- en: Mark any type parameters used only on parameters as contravariant (`in`).
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将仅用于参数的类型参数标记为逆变（`in`）。
- en: Doing so allows conversions to work naturally by respecting inheritance relationships
    between types.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做可以通过尊重类型之间的继承关系，使转换自然工作。
- en: The following delegate (defined in the `System` namespace) has a covariant `TResult:`
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的委托（在`System`命名空间中定义）具有协变的`TResult:`
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This allows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许：
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The following delegate (defined in the `System` namespace) has a contravariant
    `T:`
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的委托（在`System`命名空间中定义）具有逆变的`T:`
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This allows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许：
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Events
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: 'When using delegates, two emergent roles commonly appear: *broadcaster* and
    *subscriber*.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用委托时，通常会出现两种新角色：*广播器*和*订阅者*。
- en: The *broadcaster* is a type that contains a delegate field. The broadcaster
    decides when to broadcast, by invoking the delegate.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*广播器*是包含委托字段的类型。广播器通过调用委托来决定何时广播。'
- en: The *subscribers* are the method target recipients. A subscriber decides when
    to start and stop listening by calling `+=` and `-=` on the broadcaster’s delegate.
    A subscriber does not know about, or interfere with, other subscribers.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*订阅者*是方法的目标接收者。订阅者通过调用广播器委托的`+=`和`-=`来决定何时开始和停止监听。订阅者不知道或干预其他订阅者。'
- en: Events are a language feature that formalizes this pattern. An `event` is a
    construct that exposes just the subset of delegate features required for the broadcaster/subscriber
    model. The main purpose of events is to *prevent subscribers from interfering
    with one another*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是一种语言特性，正式化了这一模式。`event`是一种仅公开委托子集的构造，适用于广播者/订阅者模型。事件的主要目的是*防止订阅者相互干扰*。
- en: 'The easiest way to declare an event is to put the `event` keyword in front
    of a delegate member:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 声明事件的最简单方法是在委托成员前面放置`event`关键字：
- en: '[PRE35]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Code within the `Broadcaster` type has full access to `PriceChanged` and can
    treat it as a delegate. Code outside of `Broadcaster` can perform only `+=` and
    `-=` operations on the `PriceChanged` event.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`Broadcaster`类型内的代码可以完全访问`PriceChanged`并将其视为委托。在`Broadcaster`外部的代码只能对`PriceChanged`事件执行`+=`和`-=`操作。'
- en: 'Consider the following example. The `Stock` class fires its `PriceChanged`
    event every time the `Price` of the `Stock` changes:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例。`Stock`类每次`Stock`的`Price`更改时都会触发其`PriceChanged`事件：
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If we remove the `event` keyword from our example so that `PriceChanged` becomes
    an ordinary delegate field, our example would give the same results. However,
    `Stock` would be less robust insomuch as subscribers could do the following things
    to interfere with one another:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从示例中移除`event`关键字，使`PriceChanged`成为普通的委托字段，我们的示例将产生相同的结果。但是，`Stock`会不太健壮，因为订阅者可以通过以下方式相互干扰：
- en: Replace other subscribers by reassigning `PriceChanged` (instead of using the
    `+=` operator).
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过重新分配`PriceChanged`（而不是使用`+=`运算符）替换其他订阅者。
- en: Clear all subscribers (by setting `PriceChanged` to `null`).
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除所有订阅者（通过将`PriceChanged`设置为`null`）。
- en: Broadcast to other subscribers by invoking the delegate.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用委托向其他订阅者广播。
- en: Standard Event Pattern
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准事件模式
- en: 'In almost all cases for which events are defined in the .NET libraries, their
    definition adheres to a standard pattern designed to provide consistency across
    library and user code. At the core of the standard event pattern is `System.EventArgs`,
    a predefined .NET class with no members (other than the static `Empty` field).
    `EventArgs` is a base class for conveying information for an event. In our `Stock`
    example, we would subclass `EventArgs` to convey the old and new prices when a
    `PriceChanged` event is fired:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET库中定义事件的几乎所有情况下，它们的定义遵循设计的标准模式，以提供库和用户代码之间的一致性。标准事件模式的核心是`System.EventArgs`，这是一个预定义的.NET类，没有成员（除了静态的`Empty`字段）。`EventArgs`是传递事件信息的基类。在我们的`Stock`示例中，当`PriceChanged`事件被触发时，我们会子类化`EventArgs`以传递旧价格和新价格：
- en: '[PRE37]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: For reusability, the `EventArgs` subclass is named according to the information
    it contains (rather than the event for which it will be used). It typically exposes
    data as properties or as read-only fields.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可重用性，`EventArgs`子类根据其包含的信息命名（而不是将用于其的事件）。通常将数据公开为属性或只读字段。
- en: 'With an `EventArgs` subclass in place, the next step is to choose or define
    a delegate for the event. There are three rules:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`EventArgs`子类之后，下一步是选择或定义事件的委托。有三条规则：
- en: It must have a `void` return type.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须具有`void`返回类型。
- en: 'It must accept two arguments: the first of type `object` and the second a subclass
    of `EventArgs`. The first argument indicates the event broadcaster, and the second
    argument contains the extra information to convey.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须接受两个参数：第一个是`object`类型，第二个是`EventArgs`的子类。第一个参数表示事件广播器，第二个参数包含要传递的额外信息。
- en: Its name must end with `EventHandler`.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其名称必须以`EventHandler`结尾。
- en: '.NET defines a generic delegate called `System.EventHandler<>` to help with
    this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: .NET定义了一个名为`System.EventHandler<>`的通用委托来帮助处理此问题：
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-145
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Before generics existed in the language (prior to C# 2.0), we would have had
    to instead write a custom delegate as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在语言中存在泛型之前（即C# 2.0之前），我们必须编写一个自定义委托来代替：
- en: '[PRE39]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: For historical reasons, most events within the .NET libraries use delegates
    defined in this way.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于历史原因，.NET库中的大多数事件使用此方式定义委托。
- en: 'The next step is to define an event of the chosen delegate type. Here, we use
    the generic `EventHandler` delegate:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义所选委托类型的事件。在这里，我们使用泛型的`EventHandler`委托：
- en: '[PRE40]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, the pattern requires that you write a protected virtual method that
    fires the event. The name must match the name of the event, prefixed with the
    word “On,” and then accept a single `EventArgs` argument:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，模式要求您编写一个保护虚拟方法来触发事件。名称必须与事件名称匹配，前缀为“On”，然后接受单个`EventArgs`参数：
- en: '[PRE41]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-153
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'To work robustly in multithreaded scenarios ([Chapter 14](ch14.html#concurrency_and_asynchron)),
    you need to assign the delegate to a temporary variable before testing and invoking
    it:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要在多线程场景下可靠地工作（[第14章](ch14.html#concurrency_and_asynchron)），您需要在测试和调用之前将委托分配给一个临时变量：
- en: '[PRE42]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can achieve the same functionality without the `temp` variable with the
    null-conditional operator:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用空值条件运算符来实现相同的功能，而不需要`temp`变量：
- en: '[PRE43]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Being both thread-safe and succinct, this is the best general way to invoke
    events.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 既线程安全又简洁，这是调用事件的最佳通用方法。
- en: This provides a central point from which subclasses can invoke or override the
    event (assuming the class is not sealed).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一个中心点，供子类调用或覆盖事件（假设类不是密封的）。
- en: 'Here’s the complete example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的示例：
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The predefined nongeneric `EventHandler` delegate can be used when an event
    doesn’t carry extra information. In this example, we rewrite `Stock` such that
    the `PriceChanged` event is fired after the price changes, and no information
    about the event is necessary, other than it happened. We also make use of the
    `Even⁠t​Args.Empty` property in order to avoid unnecessarily instantiating an
    instance of `EventArgs`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 预定义的非泛型`EventHandler`委托可用于事件不携带额外信息的情况。在本例中，我们重新编写`Stock`，使得`PriceChanged`事件在价格变动后触发，并且除了发生事件之外，不需要任何有关事件的信息。我们还利用了`Even⁠t​Args.Empty`属性，以避免不必要地实例化`EventArgs`的实例：
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Event Accessors
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件访问器
- en: 'An event’s *accessors* are the implementations of its `+=` and `-=` functions.
    By default, accessors are implemented implicitly by the compiler. Consider this
    event declaration:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 事件的*访问器*是其`+=`和`-=`函数的实现。默认情况下，编译器会隐式实现访问器。考虑以下事件声明：
- en: '[PRE46]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The compiler converts this to the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将其转换为以下内容：
- en: A private delegate field
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有委托字段
- en: A public pair of event accessor functions (`add_PriceChanged` and `remove_Pri⁠ce​Changed`)
    whose implementations forward the `+=` and `-=` operations to the private delegate
    field
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对公共事件访问器函数（`add_PriceChanged`和`remove_Pri⁠ce​Changed`），其实现将`+=`和`-=`操作转发到私有委托字段
- en: 'You can take over this process by defining *explicit* event accessors. Here’s
    a manual implementation of the `PriceChanged` event from our previous example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过定义*显式*事件访问器来接管此过程。以下是我们之前示例中`PriceChanged`事件的手动实现：
- en: '[PRE47]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This example is functionally identical to C#’s default accessor implementation
    (except that C# also ensures thread safety around updating the delegate via a
    lock-free compare-and-swap algorithm; see [*http://albahari.com/threading*](http://albahari.com/threading)).
    By defining event accessors ourselves, we instruct C# not to generate default
    field and accessor logic.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例在功能上与C#的默认访问器实现相同（除了C#还通过无锁比较和交换算法确保围绕更新委托的线程安全性；参见[*http://albahari.com/threading*](http://albahari.com/threading)）。通过自定义事件访问器，我们指示C#不生成默认字段和访问器逻辑。
- en: 'With explicit event accessors, you can apply more complex strategies to the
    storage and access of the underlying delegate. There are three scenarios for which
    this is useful:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用显式事件访问器，可以对底层委托的存储和访问应用更复杂的策略。这是三种有用的情况：
- en: When the event accessors are merely relays for another class that is broadcasting
    the event.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当事件访问器仅仅是为另一个正在广播事件的类中继的情况。
- en: When the class exposes many events, for which most of the time very few subscribers
    exist, such as a Windows control. In such cases, it is better to store the subscriber’s
    delegate instances in a dictionary because a dictionary will contain less storage
    overhead than dozens of null delegate field references.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当类公开许多事件时，其中大多数时间只存在很少的订阅者，例如Windows控件。在这种情况下，最好将订阅者的委托实例存储在字典中，因为字典的存储开销比数十个空委托字段引用要小得多。
- en: When explicitly implementing an interface that declares an event.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当显式实现声明事件的接口时。
- en: 'Here is an example that illustrates the last point:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子来说明最后一点：
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note
  id: totrans-179
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `add` and `remove` parts of an event are compiled to `add_*XXX*` and `remove_*XXX*`
    methods.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 事件的`add`和`remove`部分被编译为`add_*XXX*`和`remove_*XXX*`方法。
- en: Event Modifiers
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件修饰符
- en: 'Like methods, events can be virtual, overridden, abstract, or sealed. Events
    can also be static:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 像方法一样，事件可以是虚拟的、重写的、抽象的或封闭的。事件也可以是静态的：
- en: '[PRE49]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Lambda Expressions
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: 'A *lambda expression* is an unnamed method written in place of a delegate instance.
    The compiler immediately converts the lambda expression to either of the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式是在委托实例的位置编写的未命名方法。编译器立即将Lambda表达式转换为以下之一：
- en: A delegate instance.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个委托实例。
- en: An *expression tree*, of type `Expression<TDelegate>`, representing the code
    inside the lambda expression in a traversable object model. This allows the lambda
    expression to be interpreted later at runtime (see [“Building Query Expressions”](ch08.html#building_query_expressions)).
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*表达式树*，类型为`Expression<TDelegate>`，表示Lambda表达式内部代码的可遍历对象模型。这允许Lambda表达式在运行时后续解释（参见[“构建查询表达式”](ch08.html#building_query_expressions)）。
- en: 'In the following example, `x => x * x` is a lambda expression:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，`x => x * x`是一个Lambda表达式：
- en: '[PRE50]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Internally, the compiler resolves lambda expressions of this type by writing
    a private method and then moving the expression’s code into that method.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，编译器通过编写一个私有方法，然后将表达式的代码移到该方法中来解析此类型的Lambda表达式。
- en: 'A lambda expression has the following form:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式具有以下形式：
- en: '[PRE51]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: For convenience, you can omit the parentheses if and only if there is exactly
    one parameter of an inferable type.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，如果且仅当存在一个可推断类型的参数时，可以省略括号。
- en: 'In our example, there is a single parameter, `x`, and the expression is `x
    * x`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，有一个名为`x`的单一参数，表达式为`x * x`：
- en: '[PRE52]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Each parameter of the lambda expression corresponds to a delegate parameter,
    and the type of the expression (which may be `void`) corresponds to the return
    type of the delegate.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式的每个参数对应于一个委托参数，表达式的类型（可能是`void`）对应于委托的返回类型。
- en: 'In our example, `x` corresponds to parameter `i`, and the expression `x * x`
    corresponds to the return type `int`, therefore being compatible with the `Transformer`
    delegate:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`x`对应于参数`i`，表达式`x * x`对应于返回类型`int`，因此与`Transformer`委托兼容：
- en: '[PRE53]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'A lambda expression’s code can be a *statement block* instead of an expression.
    We can rewrite our example as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式的代码可以是一个*语句块*而不是一个表达式。我们可以将我们的例子重写如下：
- en: '[PRE54]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Lambda expressions are used most commonly with the `Func` and `Action` delegates,
    so you will most often see our earlier expression written as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式最常与`Func`和`Action`委托一起使用，因此您通常会看到我们之前的表达式写成如下形式：
- en: '[PRE55]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Here’s an example of an expression that accepts two parameters:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个接受两个参数的表达式的例子：
- en: '[PRE56]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you do not need to use the parameters, you can *discard* them with an underscore
    (from C# 9):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不需要使用参数，可以使用下划线*丢弃*它们（从C# 9开始）：
- en: '[PRE57]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here’s an example of an expression that takes zero arguments:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不带参数的表达式的示例：
- en: '[PRE58]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'From C# 10, the compiler permits implicit typing with lambda expressions that
    can be resolved via the `Func` and `Action` delegates, so we can shorten this
    statement to:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 10开始，编译器允许使用可以通过`Func`和`Action`委托解析的lambda表达式进行隐式类型推断，因此我们可以将此语句缩短为：
- en: '[PRE59]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Explicitly Specifying Lambda Parameter and Return Types
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式指定Lambda参数和返回类型
- en: 'The compiler can usually *infer* the type of lambda parameters contextually.
    When this is not the case, you must specify the type of each parameter explicitly.
    Consider the following two methods:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器无法上下文推断lambda参数的类型时，通常可以*推断*出类型。在这种情况下，必须显式指定每个参数的类型。考虑以下两种方法：
- en: '[PRE60]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The following code will fail to compile, because the compiler cannot infer
    the type of `x`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将无法编译，因为编译器无法推断出`x`的类型：
- en: '[PRE61]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We can fix this by explicitly specifying `x`’s type as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过显式指定`x`的类型来修复这个问题，如下所示：
- en: '[PRE62]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This particular example is simple enough that it can be fixed in two other
    ways:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定示例足够简单，可以通过另外两种方式修复：
- en: '[PRE63]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The following example illustrates another use for explicit parameter types
    (from C# 10):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例演示了从C# 10开始的显式参数类型的另一种用法：
- en: '[PRE64]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The compiler infers `sqr` to be of type `Func<int,int>`. (Without specifying
    `int`, implicit typing would fail: the compiler would know that `sqr` should be
    `Func<T,T>`, but it wouldn’t know what `T` should be.)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器推断`sqr`的类型为`Func<int,int>`。（不指定`int`时，隐式类型推断将失败：编译器知道`sqr`应该是`Func<T,T>`，但不知道`T`应该是什么。）
- en: 'From C# 10, you can also specify the lambda return type:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 10开始，您还可以指定lambda返回类型：
- en: '[PRE65]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Specifying a return type can improve compiler performance with complex nested
    lambdas.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 指定返回类型可以提高复杂嵌套lambda的编译器性能。
- en: Default Lambda Parameters (C# 12)
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认Lambda参数（C# 12）
- en: 'Just as ordinary methods can have optional parameters:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 就像普通方法可以有可选参数一样：
- en: '[PRE66]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'so, too, can lambda expressions:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，lambda表达式也可以：
- en: '[PRE67]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This feature is useful with libraries such as ASP.NET Minimal API.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能在诸如ASP.NET Minimal API等库中非常有用。
- en: Capturing Outer Variables
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获外部变量
- en: 'A lambda expression can reference any variables that are accessible where the
    lambda expression is defined. These are called *outer variables*, and can include
    local variables, parameters, and fields:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: lambda表达式可以引用在定义lambda表达式的位置可访问的任何变量。这些称为外部变量，可以包括局部变量、参数和字段：
- en: '[PRE68]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Outer variables referenced by a lambda expression are called *captured variables*.
    A lambda expression that captures variables is called a *closure*.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: lambda表达式引用的外部变量称为*捕获变量*。捕获变量的lambda表达式称为*闭包*。
- en: Note
  id: totrans-237
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Variables can also be captured by anonymous methods and local methods. The rules
    for captured variables, in these cases, are the same.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 变量也可以被匿名方法和局部方法所捕获。在这些情况下，捕获变量的规则是相同的。
- en: 'Captured variables are evaluated when the delegate is actually *invoked*, not
    when the variables were *captured*:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当委托实际*调用*时，捕获的变量被评估，而不是在捕获变量时评估：
- en: '[PRE69]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Lambda expressions can themselves update captured variables:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: lambda表达式本身可以更新捕获的变量：
- en: '[PRE70]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Captured variables have their lifetimes extended to that of the delegate. In
    the following example, the local variable `seed` would ordinarily disappear from
    scope when `Natural` finished executing. But because `seed` has been *captured*,
    its lifetime is extended to that of the capturing delegate, `natural`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获变量的生命周期延长到委托的生命周期。在以下示例中，局部变量`seed`在`Natural`执行完成后通常会从作用域中消失。但因为`seed`已被*捕获*，其生命周期延长到捕获委托`natural`的生命周期：
- en: '[PRE71]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'A local variable *instantiated* within a lambda expression is unique per invocation
    of the delegate instance. If we refactor our previous example to instantiate `seed`
    *within* the lambda expression, we get a different (in this case, undesirable)
    result:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在lambda表达式内部实例化的局部变量每次委托实例调用时都是唯一的。如果我们将先前的示例重构为在lambda表达式内部实例化`seed`，我们将得到一个不同的（在本例中是不可取的）结果：
- en: '[PRE72]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Note
  id: totrans-247
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Capturing is internally implemented by “hoisting” the captured variables into
    fields of a private class. When the method is called, the class is instantiated
    and lifetime-bound to the delegate instance.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获是通过将捕获的变量“提升”为私有类的字段来内部实现的。当调用方法时，该类被实例化并与委托实例绑定其生命周期。
- en: Static lambdas
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态lambda
- en: When you capture local variables, parameters, instance fields, or the `this`
    reference, the compiler may need to create and instantiate a private class to
    store a reference to the captured data. This incurs a small performance cost,
    because memory must be allocated (and subsequently collected). In situations where
    performance is critical, one micro-optimization strategy is to minimize the load
    on the garbage collector by ensuring that code hot paths incur few or no allocations.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当捕获局部变量、参数、实例字段或`this`引用时，编译器可能需要创建和实例化一个私有类来存储对捕获数据的引用。这会带来一定的性能成本，因为需要分配（以及随后回收）内存。在性能至关重要的情况下，一种微优化策略是通过确保代码热点路径几乎不或完全不产生分配来减少垃圾收集器的负担。
- en: 'From C# 9, you can ensure that a lambda expression, local function, or anonymous
    method doesn’t capture state by applying the `static` keyword. This can be useful
    in micro-optimization scenarios to prevent unintentional memory allocations. For
    example, we can apply the static modifier to a lambda expression as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 9开始，可以通过应用`static`关键字来确保lambda表达式、局部函数或匿名方法不会捕获状态。这在微优化场景中可能很有用，以防止意外的内存分配。例如，可以如下所示将static修饰符应用于lambda表达式：
- en: '[PRE73]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'If we later try to modify the lambda expression such that it captures a local
    variable, the compiler will generate an error:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果稍后尝试修改lambda表达式以捕获局部变量，则编译器将生成错误：
- en: '[PRE74]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Note
  id: totrans-255
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The lambda itself evaluates to a delegate instance, which requires a memory
    allocation. However, if the lambda doesn’t capture variables, the compiler will
    reuse a single cached instance across the life of the application, so there will
    be no cost in practice.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: lambda本身会评估为一个委托实例，这需要进行内存分配。然而，如果lambda不捕获变量，编译器将在应用程序的整个生命周期内重用单个缓存实例，因此实际上不会产生额外的成本。
- en: 'This feature can also be used with local methods. In the following example,
    the `Multiply` method cannot access the `factor` variable:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能也可用于局部方法。在以下示例中，`Multiply`方法无法访问`factor`变量：
- en: '[PRE75]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Of course, the `Multiply` method could still explicitly allocate memory by calling
    `new`. What this protects us from is a potential allocation by *stealth*. Applying
    `static` here is also arguably useful as a documentation tool, indicating a reduced
    level of coupling.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`Multiply`方法仍然可以通过调用`new`来显式分配内存。这种方法保护我们免受*偷偷摸摸*分配的潜在风险。在此处应用`static`也可视为一种文档工具，指示减少耦合级别。
- en: Static lambdas can still access static variables and constants (because these
    do not require a closure).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 静态lambda仍然可以访问静态变量和常量（因为这些不需要闭包）。
- en: Note
  id: totrans-261
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `static` keyword acts merely as a *check*; it has no effect on the IL that
    the compiler produces. Without the `static` keyword, the compiler does not generate
    a closure unless it needs to (and even then, it has tricks to mitigate the cost).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`static`关键字仅作为一种*检查*存在；它对编译器生成的IL没有影响。如果没有`static`关键字，编译器不会生成闭包，除非它需要（即使如此，它也有一些技巧来减轻成本）。'
- en: Capturing iteration variables
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获迭代变量
- en: 'When you capture the iteration variable of a `for` loop, C# treats that variable
    as though it were declared *outside* the loop. This means that the *same* variable
    is captured in each iteration. The following program writes `333` instead of `012`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当你捕获`for`循环的迭代变量时，C#会将该变量视为在循环*外部*声明的变量。这意味着每次迭代都会捕获*同一个*变量。以下程序输出的是`333`而不是`012`：
- en: '[PRE76]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Each closure (shown in boldface) captures the same variable, `i`. (This actually
    makes sense when you consider that `i` is a variable whose value persists between
    loop iterations; you can even explicitly change `i` within the loop body if you
    want.) The consequence is that when the delegates are later invoked, each delegate
    sees `i`’s value at the time of *invocation*—which is 3\. We can illustrate this
    better by expanding the `for` loop, as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 每个闭包（**closure**）捕获的是同一个变量，`i`。（这在考虑到`i`是一个变量，其值在循环迭代之间保持不变时确实是有意义的；如果需要的话，甚至可以在循环体内显式修改`i`。）其结果是，当稍后调用这些委托时，每个委托看到的是调用时`i`的值——这里是3。我们可以通过展开`for`循环来更好地说明这一点：
- en: '[PRE77]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The solution, if we want to write `012`, is to assign the iteration variable
    to a local variable that’s scoped *within* the loop:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要输出`012`，解决方案是将迭代变量分配给循环内部作用域的局部变量：
- en: '[PRE78]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Because `loopScopedi` is freshly created on every iteration, each closure captures
    a *different* variable.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`loopScopedi`在每次迭代时都是全新创建的，所以每个闭包捕获的是*不同*的变量。
- en: Note
  id: totrans-271
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Prior to C# 5.0, `foreach` loops worked in the same way. This caused considerable
    confusion: unlike with a `for` loop, the iteration variable in a `foreach` loop
    is immutable, and so you would expect it to be treated as local to the loop body.
    The good news is that it’s now fixed and you can safely capture a `foreach` loop’s
    iteration variable without surprises.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 5.0 之前，`foreach` 循环的工作方式相同。这引起了相当大的混淆：与 `for` 循环不同，`foreach` 循环中的迭代变量是不可变的，因此你期望它在循环体内部被视为局部变量。好消息是现在已经修复，你可以安全地捕获
    `foreach` 循环的迭代变量而不会有任何意外。
- en: Lambda Expressions Versus Local Methods
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda 表达式与局部方法
- en: 'The functionality of local methods (see [“Local methods”](ch03.html#local_methods-id00077))
    overlaps with that of lambda expressions. Local methods have the following three
    advantages:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 局部方法的功能（参见 [“局部方法”](ch03.html#local_methods-id00077)）与 lambda 表达式重叠。局部方法有以下三个优点：
- en: They can be recursive (they can call themselves) without ugly hacks.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以是递归的（可以调用自身），而无需丑陋的 hack。
- en: They avoid the clutter of specifying a delegate type.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们避免了指定委托类型的混乱。
- en: They incur slightly less overhead.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的开销稍微少一些。
- en: Local methods are more efficient because they avoid the indirection of a delegate
    (which costs some CPU cycles and a memory allocation). They can also access local
    variables of the containing method without the compiler having to “hoist” the
    captured variables into a hidden class.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 局部方法更高效，因为它们避免了委托的间接调用（这会消耗一些 CPU 循环和内存分配）。它们还可以访问包含方法的局部变量，而无需编译器将捕获的变量提升到隐藏类中。
- en: 'However, in many cases you *need* a delegate—most commonly when calling a higher-order
    function, that is, a method with a delegate-typed parameter:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在许多情况下，*你需要* 一个委托 —— 最常见的情况是调用高阶函数，即具有委托类型参数的方法：
- en: '[PRE79]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: (You can see plenty more of these in [Chapter 8](ch08.html#linq_queries)). In
    such cases, you need a delegate anyway, and it’s in precisely these cases that
    lambda expressions are usually terser and cleaner.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: （你可以在 [第 8 章](ch08.html#linq_queries) 中看到更多类似的内容）。在这种情况下，无论如何都需要委托，通常 lambda
    表达式更简洁更清晰。
- en: Anonymous Methods
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名方法
- en: 'Anonymous methods are a C# 2.0 feature that was mostly subsumed by C# 3.0’s
    lambda expressions. An anonymous method is like a lambda expression, but it lacks
    the following features:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名方法是 C# 2.0 的一个特性，大部分被 C# 3.0 的 lambda 表达式所取代。匿名方法类似于 lambda 表达式，但它缺少以下功能：
- en: Implicitly typed parameters
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式类型参数
- en: Expression syntax (an anonymous method must always be a statement block)
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式语法（匿名方法必须始终是一个语句块）
- en: The ability to compile to an expression tree, by assigning to `Expression<T>`
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译为表达式树的能力，通过分配给 `Expression<T>`
- en: 'An anonymous method uses the `delegate` keyword followed (optionally) by a
    parameter declaration and then a method body. For example:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名方法使用 `delegate` 关键字，后跟（可选的）参数声明，然后是方法体。例如：
- en: '[PRE80]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The first line is semantically equivalent to the following lambda expression:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行在语义上等同于以下 lambda 表达式：
- en: '[PRE81]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Or simply:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 或者简单地说：
- en: '[PRE82]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Anonymous methods capture outer variables in the same way lambda expressions
    do, and can be preceded by the `static` keyword to make them behave like static
    lambdas.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名方法与 lambda 表达式一样捕获外部变量，并且可以在前面加上 `static` 关键字使其行为类似静态 lambda。
- en: Note
  id: totrans-294
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'A unique feature of anonymous methods is that you can omit the parameter declaration
    entirely—even if the delegate expects it. This can be useful in declaring events
    with a default empty handler:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名方法的一个独特特性是你可以完全省略参数声明，即使委托期望有参数。这在声明带有默认空处理程序的事件时非常有用：
- en: '[PRE83]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This avoids the need for a null check before firing the event. The following
    is also legal:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以避免在触发事件前进行空检查。以下也是合法的：
- en: '[PRE84]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: try Statements and Exceptions
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`try` 语句和异常'
- en: A `try` statement specifies a code block subject to error-handling or cleanup
    code. The `try` *block* must be followed by one or more `catch` *blocks* and/or
    a `finally` *block*, or both. The `catch` block executes when an error is thrown
    in the `try` block. The `finally` block executes after execution leaves the `try`
    block (or, if present, the `catch` block) to perform cleanup code, regardless
    of whether an exception was thrown.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`try` 语句指定一个受错误处理或清理代码控制的代码块。`try` *块* 必须后跟一个或多个 `catch` *块* 和/或一个 `finally`
    *块*，或两者都有。当在 `try` 块中抛出错误时，`catch` 块执行。`finally` 块在执行离开 `try` 块（或如果存在的话，`catch`
    块）后执行清理代码，无论是否抛出异常。'
- en: A `catch` block has access to an `Exception` object that contains information
    about the error. You use a `catch` block to either compensate for the error or
    *rethrow* the exception. You rethrow an exception if you merely want to log the
    problem or if you want to rethrow a new, higher-level exception type.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch`块可以访问包含有关错误信息的`Exception`对象。您使用`catch`块来补偿错误或*重新抛出*异常。如果您仅想记录问题或重新抛出新的更高级别的异常类型，则重新抛出异常。'
- en: 'A `finally` block adds determinism to your program: the CLR endeavors to always
    execute it. It’s useful for cleanup tasks such as closing network connections.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally`块为您的程序增加了确定性：CLR努力始终执行它。用于关闭网络连接等清理任务很有用。'
- en: 'A `try` statement looks like this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`语句看起来像这样：'
- en: '[PRE85]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Consider the following program:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下程序：
- en: '[PRE86]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Because `x` is zero, the runtime throws a `DivideByZeroException` and our program
    terminates. We can prevent this by catching the exception as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`x`为零，运行时引发了`DivideByZeroException`并且我们的程序终止。我们可以通过捕获异常来防止这种情况，如下所示：
- en: '[PRE87]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Here’s the output:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出：
- en: '[PRE88]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Note
  id: totrans-311
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This is a simple example to illustrate exception handling. We could deal with
    this particular scenario better in practice by checking explicitly for the divisor
    being zero before calling `Calc`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的示例，用于说明异常处理。在实际中，我们可以通过在调用`Calc`之前显式检查除数是否为零来更好地处理这种特定情况。
- en: Checking for preventable errors is preferable to relying on `try`/`catch` blocks
    because exceptions are relatively expensive to handle, taking hundreds of clock
    cycles or more.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 检查可预防的错误优于依赖`try`/`catch`块，因为异常处理相对较昂贵，需要数百个时钟周期或更多。
- en: 'When an exception is thrown within a `try` statement, the CLR performs a test:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`try`语句中引发异常时，CLR执行测试：
- en: '*Does the* `try` *statement have any compatible* `catch` *blocks?*'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '*在* `try` *语句中是否有任何兼容的* `catch` *块？*'
- en: If so, execution jumps to the compatible `catch` block, followed by the `finally`
    block (if present), and then execution continues normally.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是这样，执行将跳转到兼容的`catch`块，然后是`finally`块（如果存在），然后正常继续执行。
- en: If not, execution jumps directly to the `finally` block (if present), then the
    CLR looks up the call stack for other `try` blocks; if found, it repeats the test.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有，执行直接跳转到`finally`块（如果存在），然后CLR在调用堆栈中查找其他`try`块；如果找到，它会重复测试。
- en: If no function in the call stack takes responsibility for the exception, the
    program terminates.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用堆栈中没有任何函数负责异常，则程序终止。
- en: The catch Clause
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`catch`子句'
- en: A `catch` clause specifies what type of exception to catch. This must either
    be `System.Exception` or a subclass of `System.Exception`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch`子句指定要捕获的异常类型。这必须是`System.Exception`或`System.Exception`的子类。'
- en: 'Catching `System.Exception` catches all possible errors. This is useful in
    the following circumstances:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获`System.Exception`可以捕获所有可能的错误。在以下情况下这非常有用：
- en: Your program can potentially recover regardless of the specific exception type.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论具体的异常类型如何，您的程序都可能恢复。
- en: You plan to rethrow the exception (perhaps after logging it).
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您计划重新抛出异常（可能在记录日志后）。
- en: Your error handler is the last resort, prior to termination of the program.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理程序是程序终止之前的最后一道防线。
- en: More typically, though, you catch *specific exception types* in order to avoid
    having to deal with circumstances for which your handler wasn’t designed (e.g.,
    an `OutOfMemoryException`).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，您会捕获*特定的异常类型*，以避免处理处理程序未设计的情况（例如，`OutOfMemoryException`）。
- en: 'You can handle multiple exception types with multiple `catch` clauses (again,
    this example could be written with explicit argument checking rather than exception
    handling):'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用多个`catch`子句处理多个异常类型（再次强调，这个例子可以通过显式的参数检查而不是异常处理来编写）：
- en: '[PRE89]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Only one `catch` clause executes for a given exception. If you want to include
    a safety net to catch more general exceptions (such as `System.Exception`), you
    must put the more-specific handlers *first*.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的异常，只有一个`catch`子句会执行。如果您想包含一个捕获更一般异常（如`System.Exception`）的安全网，必须将更具体的处理程序*放在前面*。
- en: 'An exception can be caught without specifying a variable, if you don’t need
    to access its properties:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不需要访问其属性，可以在`catch`子句中捕获异常而不指定变量：
- en: '[PRE90]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Furthermore, you can omit both the variable and the type (meaning that all
    exceptions will be caught):'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以省略变量和类型（这意味着将捕获所有异常）：
- en: '[PRE91]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Exception filters
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常过滤器
- en: 'You can specify an *exception filter* in a `catch` clause by adding a `when`
    clause:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过添加`when`子句在`catch`子句中指定*异常过滤器*：
- en: '[PRE92]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'If a `WebException` is thrown in this example, the Boolean expression following
    the `when` keyword is then evaluated. If the result is false, the `catch` block
    in question is ignored and any subsequent `catch` clauses are considered. With
    exception filters, it can be meaningful to catch the same exception type again:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在此示例中抛出 `WebException`，则将评估 `when` 关键字后面的布尔表达式。如果结果为 false，则忽略相关的 `catch`
    块并考虑后续的 `catch` 子句。使用异常过滤器可以捕获同一类型的异常再次抛出是有意义的：
- en: '[PRE93]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The Boolean expression in the `when` clause can be side-effecting, such as a
    method that logs the exception for diagnostic purposes.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`when` 子句中的布尔表达式可以具有副作用，例如记录异常以进行诊断。'
- en: The finally Block
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: finally 块
- en: A `finally` block always executes—regardless of whether an exception is thrown
    and whether the `try` block runs to completion. You typically use `finally` blocks
    for cleanup code.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally` 块始终执行——无论是否抛出异常以及 `try` 块是否完成。通常使用 `finally` 块进行清理代码。'
- en: 'A `finally` block executes after any of the following:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally` 块在以下任一情况之后执行：'
- en: A `catch` block finishes (or throws a new exception).
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catch` 块完成（或抛出新异常）。'
- en: The `try` block finishes (or throws an exception for which there’s no `catch`
    block).
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try` 块完成（或抛出没有相应 `catch` 块的异常）。'
- en: Control leaves the `try` block because of a `jump` statement (e.g., `return`
    or `goto`).
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为 `jump` 语句（例如 `return` 或 `goto`）而离开 `try` 块。
- en: The only things that can defeat a `finally` block are an infinite loop or the
    process ending abruptly.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一能够打败 `finally` 块的是无限循环或进程突然终止。
- en: 'A `finally` block helps add determinism to a program. In the following example,
    the file that we open *always* gets closed, regardless of whether:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally` 块有助于使程序具有确定性。在以下示例中，我们打开的文件 *总是* 被关闭，无论是否：'
- en: The `try` block finishes normally.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try` 块正常完成。'
- en: Execution returns early because the file is empty (`EndOfStream`).
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于文件为空（`EndOfStream`），执行提前返回。
- en: 'An `IOException` is thrown while reading the file:'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在读取文件时抛出 `IOException`：
- en: '[PRE94]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: In this example, we closed the file by calling `Dispose` on the `StreamReader`.
    Calling `Dispose` on an object, within a `finally` block, is a standard convention
    and is supported explicitly in C# through the `using` statement.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过在 `StreamReader` 上调用 `Dispose` 方法来关闭文件。在 `finally` 块中调用对象的 `Dispose`
    方法是一种标准约定，并且在 C# 中通过 `using` 语句明确支持。
- en: The using statement
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: using 语句
- en: Many classes encapsulate unmanaged resources, such as file handles, graphics
    handles, or database connections. These classes implement `System.IDisposable`,
    which defines a single parameterless method named `Dispose` to clean up these
    resources. The `using` statement provides an elegant syntax for calling `Dispose`
    on an `IDisposable` object within a `finally` block.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 许多类封装了非托管资源，例如文件句柄、图形句柄或数据库连接。这些类实现了 `System.IDisposable` 接口，该接口定义了一个名为 `Dispose`
    的无参方法来清理这些资源。`using` 语句为在 `finally` 块中调用 `Dispose` 提供了一种优雅的语法。
- en: Thus
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 因此
- en: '[PRE95]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'is precisely equivalent to the following:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 等价于以下内容：
- en: '[PRE96]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: using declarations
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: using 声明
- en: 'If you omit the brackets and statement block following a `using` statement
    (C# 8+), it becomes a *using declaration*. The resource is then disposed when
    execution falls outside the *enclosing* statement block:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略 `using` 语句（C# 8+）后面的大括号和语句块，则它变成了 *using 声明*。当执行流程跳出 *封闭* 语句块时，资源将被释放：
- en: '[PRE97]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: In this case, `reader` will be disposed when execution falls outside the `if`
    statement block.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当执行流程离开 `if` 语句块时，`reader` 将被释放。
- en: Throwing Exceptions
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抛出异常
- en: 'Exceptions can be thrown either by the runtime or in user code. In this example,
    `Display` throws a `System.ArgumentNullException`:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 异常可以由运行时或用户代码抛出。在此示例中，`Display` 抛出了 `System.ArgumentNullException`：
- en: '[PRE98]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Note
  id: totrans-365
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Because null-checking an argument and throwing an `ArgumentNullException` is
    such a common code path, there’s actually a shortcut for it, from .NET 6:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 因为对参数进行空值检查并抛出 `ArgumentNullException` 是如此常见的代码路径，所以实际上从 .NET 6 开始有了一种快捷方式：
- en: '[PRE99]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Notice that we didn’t need to specify the name of the parameter. We’ll explain
    why later, in [“CallerArgumentExpression”](#callerargumentexpression-id00054).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们无需指定参数的名称。稍后我们将在 [“CallerArgumentExpression”](https://example.org/callerargumentexpression-id00054)
    中解释原因。
- en: throw expressions
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: throw 表达式
- en: '`throw` can also appear as an expression in expression-bodied functions:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`throw` 也可以出现作为表达式的形式在表达式体函数中：'
- en: '[PRE100]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'A `throw` expression can also appear in a ternary conditional expression:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`throw` 表达式也可以出现在三元条件表达式中：'
- en: '[PRE101]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Rethrowing an exception
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新抛出异常
- en: 'You can capture and rethrow an exception as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按以下方式捕获并重新抛出异常：
- en: '[PRE102]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Note
  id: totrans-377
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If we replaced `throw` with `throw ex`, the example would still work, but the
    `StackTrace` property of the newly propagated exception would no longer reflect
    the original error.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用`throw ex`替换`throw`，例子仍然可以工作，但是新传播的异常的`StackTrace`属性将不再反映原始错误。
- en: 'Rethrowing in this manner lets you log an error without *swallowing* it. It
    also lets you back out of handling an exception should circumstances turn out
    to be beyond what you expected. The other common scenario is to rethrow a more
    specific exception type:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式重新抛出可以让您记录错误而不是*吞噬*它。它还允许您退出处理异常，如果情况超出您的预期。另一个常见情况是重新抛出更具体的异常类型：
- en: '[PRE103]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Notice that when we constructed `XmlException`, we passed in the original exception,
    `ex`, as the second argument. This argument populates the `InnerException` property
    of the new exception and aids debugging. Nearly all types of exception offer a
    similar constructor.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们构造`XmlException`时，我们将原始异常`ex`作为第二个参数传递。此参数填充新异常的`InnerException`属性，并有助于调试。几乎所有类型的异常都提供类似的构造函数。
- en: Rethrowing a *less*-specific exception is something you might do when crossing
    a trust boundary, so as not to leak technical information to potential hackers.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 重新抛出*较少*具体的异常是在跨越信任边界时可能会做的事情，以便不向潜在的黑客泄露技术信息。
- en: Key Properties of System.Exception
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: System.Exception的关键属性
- en: 'The most important properties of `System.Exception` are the following:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Exception`的最重要属性如下：'
- en: '`StackTrace`'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackTrace`'
- en: A string representing all the methods that are called from the origin of the
    exception to the `catch` block.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 表示从异常发生源到`catch`块调用的所有方法的字符串。
- en: '`Message`'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`Message`'
- en: A string with a description of the error.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 描述错误的字符串。
- en: '`InnerException`'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`InnerException`'
- en: The inner exception (if any) that caused the outer exception. This, itself,
    can have another `InnerException`.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 导致外部异常的内部异常（如果有）。这本身可能有另一个`InnerException`。
- en: Note
  id: totrans-391
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: All exceptions in C# are runtime exceptions—there is no equivalent to Java’s
    compile-time checked exceptions.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 所有C#中的异常都是运行时异常——没有Java中编译时检查的异常等价物。
- en: Common Exception Types
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见的异常类型
- en: 'The following exception types are used widely throughout the CLR and .NET libraries.
    You can throw these yourself or use them as base classes for deriving custom exception
    types:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 下列异常类型广泛用于CLR和.NET库中。您可以自行抛出这些异常或将它们用作派生自定义异常类型的基类：
- en: '`System.ArgumentException`'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.ArgumentException`'
- en: Thrown when a function is called with a bogus argument. This generally indicates
    a program bug.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用伪造参数调用函数时抛出。这通常表示程序错误。
- en: '`System.ArgumentNullException`'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.ArgumentNullException`'
- en: Subclass of `ArgumentException` that’s thrown when a function argument is (unexpectedly)
    `null`.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArgumentException`的子类，在函数参数（意外地）为`null`时抛出。'
- en: '`System.ArgumentOutOfRangeException`'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.ArgumentOutOfRangeException`'
- en: Subclass of `ArgumentException` that’s thrown when a (usually numeric) argument
    is too big or too small. For example, this is thrown when passing a negative number
    into a function that accepts only positive values.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 当（通常是数值的）参数太大或太小时抛出的`ArgumentException`的子类。例如，当向仅接受正值的函数传递负数时抛出此异常。
- en: '`System.InvalidOperationException`'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.InvalidOperationException`'
- en: Thrown when the state of an object is unsuitable for a method to successfully
    execute, regardless of any particular argument values. Examples include reading
    an unopened file or getting the next element from an enumerator for which the
    underlying list has been modified partway through the iteration.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象的状态不适合方法成功执行时抛出，而不考虑任何特定的参数值。例如，尝试读取未打开的文件或从在迭代过程中修改了基础列表的枚举器中获取下一个元素时。
- en: '`System.NotSupportedException`'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.NotSupportedException`'
- en: Thrown to indicate that a particular functionality is not supported. A good
    example is calling the `Add` method on a collection for which `IsReadOnly` returns
    `true`.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 表示不支持特定功能。一个很好的例子是在返回`true`的集合上调用`Add`方法的情况。
- en: '`System.NotImplementedException`'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.NotImplementedException`'
- en: Thrown to indicate that a function has not yet been implemented.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出以指示函数尚未实现。
- en: '`System.ObjectDisposedException`'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.ObjectDisposedException`'
- en: Thrown when the object upon which the function is called has been disposed.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用函数所在的对象已释放时抛出。
- en: 'Another commonly encountered exception type is `NullReferenceException`. The
    CLR throws this exception when you attempt to access a member of an object whose
    value is `null` (indicating a bug in your code). You can throw a `NullReferenceException`
    directly (for testing purposes) as follows:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的异常类型是 `NullReferenceException`。当您尝试访问其值为 `null` 的对象的成员时（表示代码中存在 bug），CLR
    会引发此异常。您可以如下直接抛出 `NullReferenceException`（供测试目的）：
- en: '[PRE104]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The TryXXX Method Pattern
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TryXXX 方法模式
- en: 'When writing a method, you have a choice, when something goes wrong, to return
    some kind of failure code or throw an exception. In general, you throw an exception
    when the error is outside the normal workflow—or if you expect that the immediate
    caller won’t be able to cope with it. Occasionally, though, it can be best to
    offer both choices to the consumer. An example of this is the `int` type, which
    defines two versions of its `Parse` method:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写方法时，当出现问题时，您可以选择返回某种失败代码或引发异常。通常情况下，当错误超出正常工作流程时，或者您预期直接调用者无法处理时，可以引发异常。不过，偶尔提供两种选择给消费者可能更好。一个例子是
    `int` 类型，它定义了其 `Parse` 方法的两个版本：
- en: '[PRE105]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: If parsing fails, `Parse` throws an exception; `TryParse` returns `false`.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 如果解析失败，`Parse` 抛出异常；`TryParse` 返回 `false`。
- en: 'You can implement this pattern by having the `*XXX*` method call the `Try*XXX*`
    method as follows:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将 `*XXX*` 方法调用 `Try*XXX*` 方法来实现此模式，如下所示：
- en: '[PRE106]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Alternatives to Exceptions
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常的替代方法
- en: As with `int.TryParse`, a function can communicate failure by sending an error
    code back to the calling function via a return type or parameter. Although this
    can work with simple and predictable failures, it becomes clumsy when extended
    to unusual or unpredictable errors, polluting method signatures and creating unnecessary
    complexity and clutter.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `int.TryParse` 一样，函数可以通过返回类型或参数将失败传递给调用函数。尽管这可以处理简单和可预测的失败，但在处理不寻常或不可预测的错误时会变得笨拙，会污染方法签名并创建不必要的复杂性和混乱。
- en: It also cannot generalize to functions that are not methods, such as operators
    (e.g., the division operator) or properties. An alternative is to place the error
    in a common place where all functions in the call stack can see it (e.g., a static
    method that stores the current error per thread). This, though, requires each
    function to participate in an error-propagation pattern, which is cumbersome and,
    ironically, itself error prone.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 它也不能泛化为不是方法的函数，例如运算符（例如，除法运算符）或属性。一个替代方法是将错误放置在一个公共位置，让调用堆栈中的所有函数都能看到它（例如，一个静态方法，它在每个线程中存储当前错误）。然而，这要求每个函数参与错误传播模式，这很麻烦，而且具有讽刺性的是，这本身也容易出错。
- en: Enumeration and Iterators
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举和迭代器
- en: Enumeration
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举
- en: 'An *enumerator* is a read-only, forward-only cursor over a *sequence of values*.
    C# treats a type as an enumerator if it does any of the following:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *枚举器* 是对 *一系列值* 的只读、单向游标。如果类型执行以下任一操作，则 C# 将其视为枚举器：
- en: Has a public parameterless method named `MoveNext` and property called `Current`
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有名为 `MoveNext` 的公共无参数方法和名为 `Current` 的属性
- en: Implements `System.Collections.Generic.IEnumerator<T>`
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `System.Collections.Generic.IEnumerator<T>`
- en: Implements `System.Collections.IEnumerator`
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `System.Collections.IEnumerator`
- en: 'The `foreach` statement iterates over an *enumerable* object. An enumerable
    object is the logical representation of a sequence. It is not itself a cursor
    but an object that produces cursors over itself. C# treats a type as enumerable
    if it does any of the following (the check is performed in this order):'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach` 语句遍历 *可枚举对象*。可枚举对象是序列的逻辑表示。它本身不是游标，而是生成其自身上的游标的对象。如果类型执行以下任一操作，则
    C# 将其视为可枚举类型（按此顺序进行检查）：'
- en: Has a public parameterless method named `GetEnumerator` that returns an enumerator
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有名为 `GetEnumerator` 的公共无参数方法，返回一个枚举器
- en: Implements `System.Collections.Generic.IEnumerable<T>`
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `System.Collections.Generic.IEnumerable<T>`
- en: Implements `System.Collections.IEnumerable`
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `System.Collections.IEnumerable`
- en: (From C# 9) Can bind to an *extension method* named `GetEnumerator` that returns
    an enumerator (see [“Extension Methods”](#extension_methods))
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （来自 C# 9）可以绑定到名为 `GetEnumerator` 的 *扩展方法*，该方法返回一个枚举器（参见 [“扩展方法”](#extension_methods)）
- en: 'The enumeration pattern is as follows:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举模式如下所示：
- en: '[PRE107]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Here is the high-level way of iterating through the characters in the word
    “beer” using a `foreach` statement:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用 `foreach` 语句高级遍历单词“beer”中的字符的方法：
- en: '[PRE108]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Here is the low-level way of iterating through the characters in “beer” without
    using a `foreach` statement:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在不使用`foreach`语句的情况下迭代“beer”中字符的低级方式：
- en: '[PRE109]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: If the enumerator implements `IDisposable`, the `foreach` statement also acts
    as a `using` statement, implicitly disposing the enumerator object.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 如果枚举器实现了`IDisposable`，那么`foreach`语句也充当`using`语句，隐式地处理枚举器对象。
- en: '[Chapter 7](ch07.html#collections-id00055) explains the enumeration interfaces
    in further detail.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '[第7章](ch07.html#collections-id00055)详细解释了枚举接口。'
- en: Collection Initializers and Collection Expressions
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合初始化器和集合表达式
- en: 'You can instantiate and populate an enumerable object in a single step via
    a *collection initializer*:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过*集合初始化器*一次性实例化和填充可枚举对象：
- en: '[PRE110]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'From C# 12, you can shorten this further with a *collection expression* (note
    the square brackets):'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 12开始，您可以使用*集合表达式*（请注意方括号）进一步缩短：
- en: '[PRE111]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Note
  id: totrans-444
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Collection expressions are *target-typed*, meaning that the type of `[1,2,3]`
    depends on the type to which it’s assigned (in this case, `List<int>`). In the
    following example, the target types are `int[]` and `Span<int>` (which we cover
    in [Chapter 23](ch23.html#spanless_thantgreater_than_and-id00089)):'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 集合表达式是*目标类型化*的，这意味着`[1,2,3]`的类型取决于分配给它的类型（在本例中为`List<int>`）。在下面的例子中，目标类型是`int[]`和`Span<int>`（我们在[第23章](ch23.html#spanless_thantgreater_than_and-id00089)中介绍）：
- en: '[PRE112]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Target typing means that you can omit the type in other scenarios where the
    compiler can infer it, such as when calling methods:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 目标类型化意味着您可以在编译器可以推断出类型的其他场景中省略类型，例如调用方法时：
- en: '[PRE113]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The compiler translates this to the following:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将其翻译为以下内容：
- en: '[PRE114]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: This requires that the enumerable object implements the `System.Collections.IEnumerable`
    interface, and that it has an `Add` method that has the appropriate number of
    parameters for the call. (With collection expressions, the compiler also supports
    other patterns to allow for the creation of read-only collections.)
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 这要求可枚举对象实现`System.Collections.IEnumerable`接口，并且具有适用于调用的`Add`方法的适当数量的参数。（使用集合表达式时，编译器还支持其他模式，以允许创建只读集合。）
- en: 'You can similarly initialize dictionaries (see [“Dictionaries”](ch07.html#dictionaries))
    as follows:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，您可以按以下方式初始化字典（参见[“字典”](ch07.html#dictionaries)）：
- en: '[PRE115]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Or, more succinctly:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更简洁地说：
- en: '[PRE116]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The latter is valid not only with dictionaries but also with any type for which
    an indexer exists.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 后者不仅对字典有效，而且对于任何具有索引器的类型也有效。
- en: Iterators
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器
- en: 'Whereas a `foreach` statement is a *consumer* of an enumerator, an iterator
    is a *producer* of an enumerator. In this example, we use an iterator to return
    a sequence of Fibonacci numbers (where each number is the sum of the previous
    two):'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 而`foreach`语句是枚举器的*消费者*，迭代器是枚举器的*生产者*。在这个例子中，我们使用迭代器返回斐波那契数列的序列（其中每个数字是前两个数字的和）：
- en: '[PRE117]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Whereas a `return` statement expresses, “Here’s the value you asked me to return
    from this method,” a `yield return` statement expresses, “Here’s the next element
    you asked me to yield from this enumerator.” On each `yield` statement, control
    is returned to the caller, but the callee’s state is maintained so that the method
    can continue executing as soon as the caller enumerates the next element. The
    lifetime of this state is bound to the enumerator such that the state can be released
    when the caller has finished enumerating.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 而`return`语句表达“这是您要求我从此方法返回的值”，`yield return`语句表达“这是您要求我从此枚举器中生成的下一个元素”。在每个`yield`语句上，控制返回给调用者，但调用者的状态保持不变，以便方法可以继续执行，只要调用者枚举下一个元素。此状态的生命周期绑定到枚举器，以便在调用者完成枚举时可以释放该状态。
- en: Note
  id: totrans-461
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The compiler converts iterator methods into private classes that implement `IEnumerable<T>`
    and/or `IEnumerator<T>`. The logic within the iterator block is “inverted” and
    spliced into the `MoveNext` method and `Current` property on the compiler-written
    enumerator class. This means that when you call an iterator method, all you’re
    doing is instantiating the compiler-written class; none of your code actually
    runs! Your code runs only when you start enumerating over the resultant sequence,
    typically with a `foreach` statement.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将迭代方法转换为实现`IEnumerable<T>`和/或`IEnumerator<T>`的私有类。迭代器块内的逻辑被“反转”并拼接到编译器生成的枚举器类的`MoveNext`方法和`Current`属性中。这意味着当您调用迭代方法时，您所做的只是实例化编译器生成的类；您的代码实际上并不运行！只有当您开始枚举结果序列时，通常使用`foreach`语句时，您的代码才会运行。
- en: Iterators can be local methods (see [“Local methods”](ch03.html#local_methods-id00077)).
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器可以是局部方法（见[“局部方法”](ch03.html#local_methods-id00077)）。
- en: Iterator Semantics
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器语义
- en: 'An iterator is a method, property, or indexer that contains one or more `yield`
    statements. An iterator must return one of the following four interfaces (otherwise,
    the compiler will generate an error):'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是一个包含一个或多个`yield`语句的方法、属性或索引器。迭代器必须返回以下四个接口之一（否则，编译器将生成错误）：
- en: '[PRE118]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: An iterator has different semantics, depending on whether it returns an *enumerable*
    interface or an *enumerator* interface. We describe this in [Chapter 7](ch07.html#collections-id00055).
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 一个迭代器根据其返回的是*可枚举*接口还是*枚举器*接口具有不同的语义。我们在[第 7 章](ch07.html#collections-id00055)中描述了这一点。
- en: '*Multiple yield statements* are permitted:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '*允许多个 yield 语句*：'
- en: '[PRE119]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: yield break
  id: totrans-470
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: yield break
- en: 'A return statement is illegal in an iterator block; instead you must use the
    `yield break` statement to indicate that the iterator block should exit early,
    without returning more elements. We can modify `Foo` as follows to demonstrate:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在迭代器块中，不能使用返回语句；而是必须使用 `yield break` 语句指示迭代器块应提前退出，不返回更多元素。我们可以修改 `Foo` 如下所示来演示：
- en: '[PRE120]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Iterators and try/catch/finally blocks
  id: totrans-473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代器和try/catch/finally块
- en: 'A `yield return` statement cannot appear in a `try` block that has a `catch`
    clause:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield return` 语句不能出现在带有 `catch` 子句的 `try` 块中：'
- en: '[PRE121]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Nor can `yield return` appear in a `catch` or `finally` block. These restrictions
    are due to the fact that the compiler must translate iterators into ordinary classes
    with `MoveNext`, `Current`, and `Dispose` members, and translating exception-handling
    blocks would create excessive complexity.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield return` 也不能出现在 `catch` 或 `finally` 块中。这些限制是因为编译器必须将迭代器转换为具有 `MoveNext`、`Current`
    和 `Dispose` 成员的普通类，并且转换异常处理块会导致过多的复杂性。'
- en: 'You can, however, yield within a `try` block that has (only) a `finally` block:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以在仅有 `finally` 块的 `try` 块中使用 `yield`：
- en: '[PRE122]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The code in the `finally` block executes when the consuming enumerator reaches
    the end of the sequence or is disposed. A `foreach` statement implicitly disposes
    the enumerator if you break early, making this a safe way to consume enumerators.
    When working with enumerators explicitly, a trap is to abandon enumeration early
    without disposing it, circumventing the `finally` block. You can avoid this risk
    by wrapping explicit use of enumerators in a `using` statement:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 当消费枚举器到达序列末尾或被处理时，`finally`块中的代码将执行。如果提前中断`foreach`语句，则会隐式处理枚举器，这是一种安全的枚举方式。在显式处理枚举器时，一个陷阱是在不处理它的情况下提前放弃枚举，绕过`finally`块。通过将显式使用枚举器包装在`using`语句中，可以避免这种风险：
- en: '[PRE123]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Composing Sequences
  id: totrans-481
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合序列
- en: 'Iterators are highly composable. We can extend our example, this time to output
    even Fibonacci numbers only:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器具有高度的可组合性。我们可以扩展我们的示例，这次只输出偶数 Fibonacci 数：
- en: '[PRE124]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Each element is not calculated until the last moment—when requested by a `MoveNext()`
    operation. [Figure 4-1](#composing_sequences-id00056) shows the data requests
    and data output over time.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 直到请求执行 `MoveNext()` 操作时，每个元素才会被计算。[图 4-1](#composing_sequences-id00056)显示了随时间的数据请求和数据输出。
- en: '![Composing sequences](assets/cn10_0401.png)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![组合序列](assets/cn10_0401.png)'
- en: Figure 4-1\. Composing sequences
  id: totrans-486
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-1\. 组合序列
- en: The composability of the iterator pattern is extremely useful in LINQ; we discuss
    the subject again in [Chapter 8](ch08.html#linq_queries).
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器模式的组合性在 LINQ 中非常有用；我们在[第 8 章](ch08.html#linq_queries)中再次讨论这个主题。
- en: Nullable Value Types
  id: totrans-488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可空值类型
- en: 'Reference types can represent a nonexistent value with a null reference. Value
    types, however, cannot ordinarily represent null values:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型可以用空引用表示不存在的值。然而，值类型通常不能表示空值：
- en: '[PRE125]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'To represent null in a value type, you must use a special construct called
    a *nullable type*. A nullable type is denoted with a value type followed by the
    `?` symbol:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 要在值类型中表示空值，必须使用称为*可空类型*的特殊构造：可空类型由值类型后跟`?`符号表示：
- en: '[PRE126]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Nullable<T> Struct
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Nullable<T> 结构
- en: '`T?` translates into `System.Nullable<T>`, which is a lightweight immutable
    structure, having only two fields, to represent `Value` and `HasValue`. The essence
    of `System.Nullable<T>` is very simple:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '`T?` 转换为 `System.Nullable<T>`，这是一个轻量级的不可变结构，只有两个字段，用于表示 `Value` 和 `HasValue`。`System.Nullable<T>`
    的本质非常简单：'
- en: '[PRE127]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The code
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE128]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'translates to the following:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为以下内容：
- en: '[PRE129]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Attempting to retrieve `Value` when `HasValue` is false throws an `InvalidOperatio⁠n​Exception`.
    `GetValueOrDefault()` returns `Value` if `HasValue` is true; otherwise, it returns
    `new T()` or a specified custom default value.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 当`HasValue`为false时尝试检索`Value`会抛出`InvalidOperationException`。如果`HasValue`为true，则`GetValueOrDefault()`返回`Value`；否则，返回`new
    T()`或指定的自定义默认值。
- en: The default value of `T?` is `null`.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '`T?`的默认值为`null`。'
- en: Implicit and Explicit Nullable Conversions
  id: totrans-502
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可空隐式和显式转换
- en: 'The conversion from `T` to `T?` is implicit, whereas from `T?` to `T` the conversion
    is explicit:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 从`T`到`T?`的转换是隐式的，而从`T?`到`T`的转换是显式的：
- en: '[PRE130]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: The explicit cast is directly equivalent to calling the nullable object’s `Value`
    property. Hence, an `InvalidOperationException` is thrown if `HasValue` is false.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 显式转换直接等效于调用可空对象的`Value`属性。因此，如果`HasValue`为false，则抛出`InvalidOperationException`。
- en: Boxing and Unboxing Nullable Values
  id: totrans-506
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装箱和拆箱可空值
- en: When `T?` is boxed, the boxed value on the heap contains `T`, not `T?`. This
    optimization is possible because a boxed value is a reference type that can already
    express null.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 当`T?`装箱时，堆上的装箱值包含`T`，而不是`T?`。这种优化是可能的，因为装箱值是可以表示null的引用类型。
- en: 'C# also permits the unboxing of nullable value types with the `as` operator.
    The result will be `null` if the cast fails:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: C#还允许使用`as`操作符对可空值类型进行拆箱。如果转换失败，则结果为`null`：
- en: '[PRE131]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Operator Lifting
  id: totrans-510
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作符提升
- en: 'The `Nullable<T>` struct does not define operators such as `<`, `>`, or even
    `==`. Despite this, the following code compiles and executes correctly:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '`Nullable<T>`结构体未定义诸如`<`、`>`或`==`等操作符。尽管如此，以下代码编译并正确执行：'
- en: '[PRE132]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'This works because the compiler borrows or “lifts” the less-than operator from
    the underlying value type. Semantically, it translates the preceding comparison
    expression into this:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为编译器从基础值类型中借用或“提升”了小于操作符。语义上，它将前面的比较表达式转换为：
- en: '[PRE133]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: In other words, if both `x` and `y` have values, it compares via `int`’s less-than
    operator; otherwise, it returns `false`.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果`x`和`y`都有值，则通过`int`的小于操作符比较；否则，返回`false`。
- en: 'Operator lifting means that you can implicitly use `T`’s operators on `T?`.
    You can define operators for `T?` in order to provide special-purpose null behavior,
    but in the vast majority of cases, it’s best to rely on the compiler automatically
    applying systematic nullable logic for you. Here are some examples:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符提升意味着你可以隐式地在`T?`上使用`T`的操作符。你可以为`T?`定义操作符以提供特定的空值行为，但在绝大多数情况下，最好依赖编译器自动为你应用系统化的可空逻辑。以下是一些示例：
- en: '[PRE134]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: The compiler performs null logic differently depending on the category of operator.
    The following sections explain these different rules.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器根据操作符的类别以不同的方式执行空值逻辑。以下各节解释了这些不同的规则。
- en: Equality operators (== and !=)
  id: totrans-519
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 等式操作符（==和!=）
- en: 'Lifted equality operators handle nulls just like reference types do. This means
    that two null values are equal:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 提升的等式操作符处理null与引用类型一样。这意味着两个null值是相等的：
- en: '[PRE135]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Further:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 更进一步：
- en: If exactly one operand is null, the operands are unequal.
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果恰好一个操作数为null，则操作数不相等。
- en: If both operands are non-null, their `Value`s are compared.
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个操作数均为非null，则比较它们的`Value`。
- en: Relational operators (<, <=, >=, >)
  id: totrans-525
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关系操作符（<、<=、>=、>）
- en: 'The relational operators work on the principle that it is meaningless to compare
    null operands. This means that comparing a null value to either a null or a non-null
    value returns `false`:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 关系操作符的工作原理是对比null操作数是无意义的。这意味着将null值与null或非null值进行比较会返回`false`：
- en: '[PRE136]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: All other operators (+, −, *, /, %, &, |, ^, <<, >>, +, ++, --, !, ~)
  id: totrans-528
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 所有其他操作符（+、-、*、/、%、&、|、^、<<、>>、+、++、--、!、~）
- en: 'These operators return null when any of the operands are null. This pattern
    should be familiar to SQL users:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 当任一操作数为null时，这些操作符返回null。这种模式对SQL用户来说应该很熟悉：
- en: '[PRE137]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: An exception is when the `&` and `|` operators are applied to `bool?`, which
    we discuss shortly.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 例外情况是当我们讨论将`&`和`|`操作符应用于`bool?`时。
- en: Mixing nullable and non-nullable types
  id: totrans-532
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混合可空和非可空类型
- en: 'You can mix and match nullable and non-nullable value types (this works because
    there is an implicit conversion from `T` to `T?`):'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以混合使用可空和非可空值类型（这是因为从`T`到`T?`有隐式转换）：
- en: '[PRE138]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: bool? with & and | Operators
  id: totrans-535
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带`&`和`|`操作符的`bool?`
- en: 'When supplied operands of type `bool?` the `&` and `|` operators treat `null`
    as an *unknown value*. So, `null | true` is true because:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 当提供`bool?`类型的操作数时，`&`和`|`操作符将`null`视为*未知值*。因此，`null | true`为true，因为：
- en: If the unknown value is false, the result would be true.
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果未知值为false，则结果为true。
- en: If the unknown value is true, the result would be true.
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果未知值为真，则结果将为真。
- en: 'Similarly, `null & false` is false. This behavior should be familiar to SQL
    users. The following example enumerates other combinations:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，`null & false` 是假的。这种行为对 SQL 用户来说应该很熟悉。以下例子列举了其他的组合：
- en: '[PRE139]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Nullable Value Types and Null Operators
  id: totrans-541
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可空值类型和空运算符
- en: 'Nullable value types work particularly well with the `??` operator (see [“Null-Coalescing
    Operator”](ch02.html#null_coalescing_operator)), as illustrated in this example:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 可空值类型与 `??` 运算符（参见[“空合并运算符”](ch02.html#null_coalescing_operator)）特别配合得很好，正如本例所示：
- en: '[PRE140]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Using `??` on a nullable value type is equivalent to calling `GetValueOrDefault`
    with an explicit default value except that the expression for the default value
    is never evaluated if the variable is not null.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 对可空值类型使用 `??` 等同于使用具有显式默认值的 `GetValueOrDefault` 方法，只是如果变量为空，则默认值表达式永远不会被评估。
- en: 'Nullable value types also work well with the null-conditional operator (see
    [“Null-Conditional Operator”](ch02.html#null_conditional_operator)). In the following
    example, length evaluates to null:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 可空值类型也与空条件运算符（参见[“空条件运算符”](ch02.html#null_conditional_operator)）非常配合。在下面的例子中，长度评估为空：
- en: '[PRE141]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'We can combine this with the null-coalescing operator to evaluate to zero instead
    of null:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以与空合并运算符结合，使其评估为零而不是空：
- en: '[PRE142]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Scenarios for Nullable Value Types
  id: totrans-549
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可空值类型的场景
- en: 'One of the most common scenarios for nullable value types is to represent unknown
    values. This frequently occurs in database programming, where a class is mapped
    to a table with nullable columns. If these columns are strings (e.g., an EmailAddress
    column on a Customer table), there is no problem because string is a reference
    type in the CLR, which can be null. However, most other SQL column types map to
    CLR struct types, making nullable value types very useful when mapping SQL to
    the CLR:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 可空值类型最常见的场景之一是表示未知值。这在数据库编程中经常发生，其中一个类映射到具有可空列的表。如果这些列是字符串（例如客户表上的 EmailAddress
    列），则没有问题，因为字符串是 CLR 中的引用类型，可以为空。然而，大多数其他 SQL 列类型映射到 CLR 结构类型，使得可空值类型在将 SQL 映射到
    CLR 时非常有用：
- en: '[PRE143]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'A nullable type can also be used to represent the backing field of what’s sometimes
    called an *ambient property*. An ambient property, if null, returns the value
    of its parent:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 可空类型也可以用来表示所谓的*环境属性*的后备字段。如果环境属性为空，它将返回其父级的值：
- en: '[PRE144]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Alternatives to Nullable Value Types
  id: totrans-554
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可空值类型的替代方案
- en: 'Before nullable value types were part of the C# language (i.e., before C# 2.0),
    there were many strategies to deal with them, examples of which still appear in
    the .NET libraries for historical reasons. One of these strategies is to designate
    a particular non-null value as the “null value”; an example is in the string and
    array classes. `String.IndexOf` returns the magic value of `−1` when the character
    is not found:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 语言中引入可空值类型之前（即在 C# 2.0 之前），有许多处理它们的策略，出于历史原因，在 .NET 库中仍然存在这些策略的示例。其中一种策略是指定一个特定的非空值作为“空值”，例如在字符串和数组类中。当字符未找到时，`String.IndexOf`
    返回魔术值 `−1`：
- en: '[PRE145]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'However, `Array.IndexOf` returns `−1` only if the index is 0-bounded. The more
    general formula is that `IndexOf` returns one less than the lower bound of the
    array. In the next example, `IndexOf` returns `0` when an element is not found:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，只有当索引为 0 时，`Array.IndexOf` 才返回 `-1`。更一般的规则是 `IndexOf` 返回数组的下界减一。在下一个例子中，当未找到元素时，`IndexOf`
    返回 `0`：
- en: '[PRE146]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Nominating a “magic value” is problematic for several reasons:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 指定“魔术值”存在多种问题：
- en: It means that each value type has a different representation of null. In contrast,
    nullable value types provide one common pattern that works for all value types.
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这意味着每种值类型都有不同的空表示。相反，可空值类型提供了一个对所有值类型都适用的共同模式。
- en: There might be no reasonable designated value. In the previous example, −1 could
    not always be used. The same is true for our earlier example representing an unknown
    account balance.
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能没有合理的指定值。在前面的例子中，`−1` 并不总是可用。在代表未知账户余额的早期例子中也是如此。
- en: Forgetting to test for the magic value results in an incorrect value that might
    go unnoticed until later in execution—when it pulls an unintended magic trick.
    Forgetting to test `HasValue` on a null value, however, throws an `InvalidOperationException`
    on the spot.
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忘记测试魔术值将导致不正确的值，可能直到后期执行时才会被注意到——当它执行意外的魔术把戏时。然而，忘记在空值上测试 `HasValue` 会立即抛出 `InvalidOperationException`。
- en: The ability for a value to be null is not captured in the *type*. Types communicate
    the intention of a program, allow the compiler to check for correctness, and enable
    a consistent set of rules enforced by the compiler.
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值可以为null的能力不包含在*类型*中。类型传达程序的意图，允许编译器检查正确性，并启用编译器强制执行的一致规则集。
- en: Nullable Reference Types
  id: totrans-564
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可空引用类型
- en: Whereas *nullable value types* bring nullability to value types, *nullable reference
    types* (C# 8+) do the opposite. When enabled, they bring (a degree of) *non-nullability*
    to reference types, with the purpose of helping to avoid `NullReferenceException`s.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 而*可空值类型*将空性引入值类型，*可空引用类型*（C# 8+）则相反。启用后，它们引入了引用类型的*非空性*（某种程度），旨在帮助避免`NullReferenceException`。
- en: Nullable reference types introduce a level of safety that’s enforced purely
    by the compiler, in the form of warnings when it detects code that’s at risk of
    generating a `NullReferenceException`.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 可空引用类型引入了一种安全级别，完全由编译器强制执行，当检测到有可能引发`NullReferenceException`的代码时会发出警告。
- en: 'To enable nullable reference types, you must either add the `Nullable` element
    to your *.csproj* project file (if you want to enable it for the entire project):'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用可空引用类型，您必须在您的 *.csproj* 项目文件中添加`Nullable`元素（如果要为整个项目启用）：
- en: '[PRE147]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'or/and use the following directives in your code, in the places where it should
    take effect:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 或/和在代码中使用以下指令，以在应该生效的地方生效：
- en: '[PRE148]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'After being enabled, the compiler makes non-nullability the default: if you
    want a reference type to accept nulls without the compiler generating a warning,
    you must apply the `?` suffix to indicate a *nullable reference type*. In the
    following example, `s1` is non-nullable, whereas `s2` is nullable:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 启用后，编译器将非空性作为默认值：如果希望引用类型接受空值而不生成编译器警告，则必须应用`?`后缀以指示*可空引用类型*。在以下示例中，`s1`是非可空的，而`s2`是可空的：
- en: '[PRE149]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Note
  id: totrans-573
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Because nullable reference types are compile-time constructs, there’s no runtime
    difference between `string` and `string?`. In contrast, nullable value types introduce
    something concrete into the type system, namely the `Nullable<T>` struct.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 因为可空引用类型是编译时构造，所以`string`和`string?`之间没有运行时差异。相比之下，可空值类型在类型系统中引入了具体的内容，即`Nullable<T>`结构体。
- en: 'The following also generates a warning because `x` is not initialized:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`x`未初始化，以下示例也会生成警告：
- en: '[PRE150]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: The warning disappears if you initialize `x`, either via a field initializer
    or via code in the constructor.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过字段初始化程序或构造函数中的代码初始化`x`，则警告消失。
- en: The Null-Forgiving Operator
  id: totrans-578
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空值允许操作符
- en: 'The compiler also warns you upon dereferencing a nullable reference type, if
    it thinks a `NullReferenceException` might occur. In the following example, accessing
    the string’s `Length` property generates a warning:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译器认为可能会发生`NullReferenceException`，它还会在解引用可空引用类型时向您发出警告。在以下示例中，访问字符串的`Length`属性会生成警告：
- en: '[PRE151]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'You can remove the warning with the *null-forgiving operator* (`!`):'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用*空值允许操作符*（`!`）消除警告：
- en: '[PRE152]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Our use of the null-forgiving operator in this example is dangerous in that
    we could end up throwing the very `NullReferenceException` we were trying to avoid
    in the first place. We could fix it as follows:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中使用空值允许操作符是危险的，因为我们最终可能会抛出我们试图避免的`NullReferenceException`。我们可以按如下方式修复它：
- en: '[PRE153]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Notice now that we don’t need the null-forgiving operator. This is because the
    compiler performs *static flow analysis* and is smart enough to infer—at least
    in simple cases—when a dereference is safe and there’s no chance of a `NullReferenceException`.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请注意，我们不再需要空值允许操作符。这是因为编译器执行*静态流分析*，在至少简单情况下能够推断出解引用是安全的，不会发生`NullReferenceException`。
- en: 'The compiler’s ability to detect and warn is not bulletproof, and there are
    also limits to what’s possible in terms of coverage. For instance, it’s unable
    to know whether an array’s elements have been populated, and so the following
    does not generate a warning:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器检测和警告的能力并非万无一失，并且在覆盖范围方面也存在限制。例如，它无法知道数组的元素是否已被填充，因此以下示例不会生成警告：
- en: '[PRE154]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Separating the Annotation and Warning Contexts
  id: totrans-588
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分离注解和警告上下文
- en: 'Enabling nullable reference types via the `#nullable enable` directive (or
    the `<Nullable>enable</Nullable>` project setting) does two things:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`#nullable enable`指令（或`<Nullable>enable</Nullable>`项目设置）启用可空引用类型有两个作用：
- en: It enables the *nullable annotation context*, which tells the compiler to treat
    all reference-type variable declarations as non-nullable unless suffixed by the
    `?` symbol.
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它启用*可空注解上下文*，告诉编译器将所有引用类型变量声明视为非可空，除非后缀带有`?`符号。
- en: It enables the *nullable warning context*, which tells the compiler to generate
    warnings upon encountering code at risk of throwing a `NullReference​Excep⁠tion`.
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它启用*可空警告上下文*，告诉编译器在遇到可能引发`NullReference​Excep⁠tion`的代码时生成警告。
- en: 'It can sometimes be useful to separate these two concepts and enable *just*
    the annotation context, or (less usefully) *just* the warning context:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 有时将这两个概念分开并仅启用*注解上下文*可能很有用，或者（不太有用地）仅启用*警告上下文*：
- en: '[PRE155]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: (The same trick works with `#nullable disable` and `#nullable restore`.)
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: （同样的技巧适用于`#nullable disable`和`#nullable restore`。）
- en: 'You can also do it via the project file:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过项目文件来完成：
- en: '[PRE156]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Enabling just the annotation context for a particular class or assembly can
    be a good first step in introducing nullable reference types into a legacy codebase.
    By correctly annotating public members, you ensure your class or assembly can
    act as a “good citizen” to other classes or assemblies—so that *they* can benefit
    fully from nullable reference types—without having to deal with warnings in your
    own class or assembly.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 仅为特定类或程序集启用注解上下文可能是将可空引用类型引入传统代码库的良好首选步骤。通过正确注解公共成员，您确保您的类或程序集可以作为其他类或程序集的“良好公民”来充分受益于可空引用类型，而无需处理自己类或程序集中的警告。
- en: Treating Nullable Warnings as Errors
  id: totrans-598
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将可空警告视为错误
- en: 'In greenfield projects, it makes sense to fully enable the nullable context
    from the outset. You might want to take the additional step of treating nullable
    warnings as errors so that your project cannot compile until all null warnings
    have been resolved:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 在新项目中，从一开始完全启用可空上下文是有意义的。您可能还希望进一步将可空警告视为错误，以便在解决所有空警告之前，项目无法编译完成：
- en: '[PRE157]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Extension Methods
  id: totrans-601
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展方法
- en: 'Extension methods allow an existing type to be extended with new methods without
    altering the definition of the original type. An extension method is a static
    method of a static class, where the `this` modifier is applied to the first parameter.
    The type of the first parameter will be the type that is extended:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法允许扩展现有类型并添加新方法，而无需更改原始类型的定义。扩展方法是静态类的静态方法，其中第一个参数应用了`this`修饰符。第一个参数的类型将是被扩展的类型：
- en: '[PRE158]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'The `IsCapitalized` extension method can be called as though it were an instance
    method on a string, as follows:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 可以像在字符串上调用实例方法一样调用`IsCapitalized`扩展方法，如下所示：
- en: '[PRE159]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'An extension method call, when compiled, is translated back into an ordinary
    static method call:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，扩展方法调用将转换为普通的静态方法调用：
- en: '[PRE160]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'The translation works as follows:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译工作如下所示：
- en: '[PRE161]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Interfaces can be extended, too:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 接口也可以扩展：
- en: '[PRE162]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Extension Method Chaining
  id: totrans-612
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展方法链
- en: 'Extension methods, like instance methods, provide a tidy way to chain functions.
    Consider the following two functions:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法与实例方法一样，提供了一种整洁的方法来链式调用函数。考虑以下两个函数：
- en: '[PRE163]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '`x` and `y` are equivalent, and both evaluate to `"Sausages"`, but `x` uses
    extension methods, whereas `y` uses static methods:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '`x`和`y`是等价的，都会评估为`"Sausages"`，但`x`使用扩展方法，而`y`使用静态方法：'
- en: '[PRE164]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Ambiguity and Resolution
  id: totrans-617
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 歧义和解决方法
- en: Namespaces
  id: totrans-618
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名空间
- en: 'An extension method cannot be accessed unless its class is in scope, typically
    by its namespace being imported. Consider the extension method `IsCapitalized`
    in the following example:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 除非其类在范围内，否则无法访问扩展方法。考虑以下示例中的扩展方法`IsCapitalized`：
- en: '[PRE165]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'To use `IsCapitalized`, the following application must import `Utils` in order
    to avoid a compile-time error:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`IsCapitalized`，应用程序必须导入`Utils`，以避免编译时错误。
- en: '[PRE166]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Extension methods versus instance methods
  id: totrans-623
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展方法与实例方法
- en: 'Any compatible instance method will always take precedence over an extension
    method. In the following example, `Test`’s `Foo` method will always take precedence,
    even when called with an argument `x` of type `int`:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 任何兼容的实例方法始终优先于扩展方法。在以下示例中，即使使用类型为`int`的参数`x`调用，`Test`的`Foo`方法也始终优先：
- en: '[PRE167]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: The only way to call the extension method in this case is via normal static
    syntax, in other words, `Extensions.Foo(...)`.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下调用扩展方法的唯一方法是通过正常的静态语法，换句话说，`Extensions.Foo(...)`。
- en: Extension methods versus extension methods
  id: totrans-627
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展方法与扩展方法
- en: If two extension methods have the same signature, the extension method must
    be called as an ordinary static method to disambiguate the method to call. If
    one extension method has more specific arguments, however, the more specific method
    takes precedence.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个扩展方法具有相同的签名，则必须将扩展方法作为普通静态方法调用以消除调用的歧义。然而，如果一个扩展方法具有更具体的参数，则更具体的方法优先。
- en: 'To illustrate, consider the following two classes:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，考虑以下两个类：
- en: '[PRE168]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'The following code calls `StringHelper`’s `IsCapitalized` method:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码调用`StringHelper`的`IsCapitalized`方法：
- en: '[PRE169]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: Classes and structs are considered more specific than interfaces.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 类和结构被认为比接口更具体。
- en: Demoting an extension method
  id: totrans-634
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 降级扩展方法
- en: An interesting scenario can arise when Microsoft adds an extension method to
    a .NET runtime library that conflicts with an extension method in some existing
    third-party library. As the author of the third-party library, you might want
    to “withdraw” your extension method, but without removing it and without breaking
    binary compatibility with existing consumers.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 当Microsoft向.NET运行时库添加一个扩展方法与某些现有第三方库中的扩展方法冲突时，可能会出现有趣的情况。作为第三方库的作者，您可能希望“撤回”您的扩展方法，但不删除它并且不破坏现有消费者的二进制兼容性。
- en: Fortunately, this is easy to accomplish, simply by removing the `this` keyword
    from your extension method’s definition. This demotes your extension method to
    an ordinary static method. The beauty of this solution is that any assembly that
    was compiled against your old library will continue to work (and bind to *your*
    method, as before). The reason is that extension method calls are converted to
    static method calls during compilation.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，通过简单地从扩展方法的定义中移除`this`关键字，这是很容易实现的。这将把您的扩展方法降级为普通的静态方法。这种解决方案的美妙之处在于，任何针对旧库编译的程序集都将继续工作（并像以前一样绑定到*您*的方法）。原因是编译时将扩展方法调用转换为静态方法调用。
- en: Consumers will be affected by your demotion only when they recompile, at which
    time calls to your former extension method will bind to Microsoft’s version (if
    the namespace has been imported). Should the consumer still want to call your
    method, they can do so by invoking it as a static method.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当消费者重新编译时，他们的降级才会受到影响，此时对您以前的扩展方法的调用将绑定到Microsoft的版本（如果已导入命名空间）。如果消费者仍然希望调用您的方法，他们可以将其作为静态方法调用。
- en: Anonymous Types
  id: totrans-638
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名类型
- en: 'An anonymous type is a simple class created by the compiler on the fly to store
    a set of values. To create an anonymous type, use the `new` keyword followed by
    an object initializer, specifying the properties and values the type will contain;
    for example:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名类型是编译器即时创建的简单类，用于存储一组值。要创建匿名类型，请使用`new`关键字，后面跟一个对象初始化器，指定类型将包含的属性和值；例如：
- en: '[PRE170]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'The compiler translates this to (approximately) the following:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将其翻译为（大致）以下内容：
- en: '[PRE171]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: You must use the `var` keyword to reference an anonymous type because it doesn’t
    have a name.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须使用`var`关键字引用匿名类型，因为它没有名称。
- en: The property name of an anonymous type can be inferred from an expression that
    is itself an identifier (or ends with one); thus
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名类型的属性名称可以从一个自身是标识符的表达式中推断出（或以标识符结尾）；因此
- en: '[PRE172]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'is equivalent to the following:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 等效于以下内容：
- en: '[PRE173]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'Two anonymous type instances declared within the same assembly will have the
    same underlying type if their elements are named and typed identically:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 两个在同一程序集中声明的匿名类型实例，如果它们的元素命名和类型相同，则具有相同的基础类型：
- en: '[PRE174]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Additionally, the `Equals` method is overridden to perform *structural equality
    comparison* (comparison of the data):'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Equals`方法被重写以执行*结构相等比较*（数据的比较）：
- en: '[PRE175]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'Whereas the equality operator (`==`) performs referential comparison:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 而等号操作符（`==`）执行引用比较：
- en: '[PRE176]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'You can create arrays of anonymous types as follows:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按以下方式创建匿名类型的数组：
- en: '[PRE177]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'A method cannot (usefully) return an anonymously typed object, because it is
    illegal to write a method whose return type is `var`:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方法不能（有用地）返回一个匿名类型的对象，因为编写其返回类型为`var`的方法是非法的：
- en: '[PRE178]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: (In the following sections, we will describe records and tuples, which offer
    alternative approaches for returning multiple values from a method.)
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: （在接下来的几节中，我们将描述记录和元组，它们提供了从方法返回多个值的替代方法。）
- en: 'Anonymous types are immutable, so instances cannot be modified after creation.
    However, from C# 10, you can use the `with` keyword to create a copy with variations
    (*nondestructive mutation*):'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名类型是不可变的，因此实例在创建后无法修改。但是，从C# 10开始，你可以使用`with`关键字创建具有变化的副本（*非破坏性变异*）：
- en: '[PRE179]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Anonymous types are particularly useful when writing LINQ queries (see [Chapter 8](ch08.html#linq_queries)).
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写LINQ查询时，匿名类型特别有用（参见 [第8章](ch08.html#linq_queries)）。
- en: Tuples
  id: totrans-662
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: Like anonymous types, tuples provide a simple way to store a set of values.
    Tuples were introduced into C# with the main purpose of allowing methods to return
    multiple values without resorting to `out` parameters (something you cannot do
    with anonymous types). Since then, however, *records* have been introduced, offering
    a concise typed approach that we will describe in the following section.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 像匿名类型一样，元组提供了一种简单的方式来存储一组值。元组在C#中引入，主要目的是允许方法返回多个值，而无需使用`out`参数（这是匿名类型无法做到的）。然而，自那时以来，*记录*已被引入，提供了一种简洁的类型化方法，我们将在下一节中描述。
- en: Note
  id: totrans-664
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Tuples do almost everything that anonymous types do and have the potential advantage
    of being value types, but they suffer—as you’ll see soon—from runtime type erasure
    with named elements.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 元组几乎可以做到匿名类型的所有功能，并且具有作为值类型的潜力优势，但正如你很快将看到的，它们遭受来自命名元素的运行时类型擦除的影响。
- en: 'The simplest way to create a *tuple literal* is to list the desired values
    in parentheses. This creates a tuple with *unnamed* elements, which you refer
    to as `Item1`, `Item2`, and so on:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 创建*元组字面量*的最简单方法是在括号中列出所需的值。这样会创建一个带有*未命名*元素的元组，你可以通过`Item1`、`Item2`等引用它们：
- en: '[PRE180]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Tuples are *value types*, with *mutable* (read/write) elements:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是*值类型*，其元素是*可变的*（可读/可写）：
- en: '[PRE181]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Unlike with anonymous types, you can specify a *tuple type* explicitly. Just
    list each of the element types in parentheses:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 与匿名类型不同，你可以明确地指定一个*元组类型*。只需在括号中列出每个元素的类型：
- en: '[PRE182]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'This means that you can usefully return a tuple from a method:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以有用地从方法返回一个元组：
- en: '[PRE183]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Tuples play well with generics, so the following types are all legal:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 元组与泛型很好地配合，因此以下类型都是合法的：
- en: '[PRE184]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Naming Tuple Elements
  id: totrans-676
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名元组元素
- en: 'You can optionally give meaningful names to elements when creating tuple literals:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 创建元组字面量时，你可以选择为元素指定有意义的名称：
- en: '[PRE185]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'You can do the same when specifying *tuple types*:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定*元组类型*时，你可以做同样的事情：
- en: '[PRE186]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: Note
  id: totrans-681
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'In [“Records”](#records-id00087), we’ll show how you can define simple classes
    or structs noiselessly, making it effortless to define a formal return type:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [“记录”](#records-id00087) 中，我们将展示如何定义简单的类或结构体，使得定义正式返回类型变得轻而易举：
- en: '[PRE187]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: Unlike with tuples, a record’s properties (`Name` and `Age`) are strongly typed
    and so can easily be refactored. This approach also reduces code duplication and
    encourages good design in a couple of ways. First, the process of deciding on
    a simple noncontrived name for the type helps validate your design (an inability
    to do so can indicate lack of a single cohesive purpose). Second, it’s likely
    that you’ll end up adding methods or other code to the record (well-named types
    tend to *attract code*), and moving code to the data is a core principle of good
    object-oriented design.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 与元组不同，记录的属性（`Name`和`Age`）是强类型的，因此可以轻松重构。这种方法还减少了代码重复，并以几种方式鼓励良好的设计。首先，决定一个简单而不牵强的类型名称的过程有助于验证你的设计（无法做到这一点可能表明缺乏单一的一致性目的）。其次，你可能最终会为记录添加方法或其他代码（命名良好的类型往往*吸引代码*），并将代码移到数据中是良好面向对象设计的核心原则。
- en: Note that you can still treat the elements as unnamed and refer to them as `Item1`,
    `Item2`, etc. (although Visual Studio hides these fields from IntelliSense).
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你仍然可以将元素视为无名称，并将它们称为`Item1`、`Item2`等（尽管Visual Studio会在IntelliSense中隐藏这些字段）。
- en: 'Element names are automatically *inferred* from property or field names:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 元素名称会自动从属性或字段名称*推断*：
- en: '[PRE188]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Tuples are type compatible with one another if their element types match up
    (in order). Their element names need not:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 如果元组的元素类型匹配（顺序相符），它们之间是类型兼容的。它们的元素名称不需要相同：
- en: '[PRE189]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'Our particular example leads to confusing results:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的特定示例导致了混乱的结果：
- en: '[PRE190]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Type erasure
  id: totrans-692
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型擦除
- en: 'We stated previously that the C# compiler handles anonymous types by building
    custom classes with named properties for each of the elements. With tuples, C#
    works differently and uses a preexisting family of generic structs:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到C#编译器通过为每个元素构建具有命名属性的自定义类来处理匿名类型。使用元组时，C#的工作方式不同，并使用预先存在的通用结构体系列：
- en: '[PRE191]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: Each of the `ValueTuple<>` structs has fields named `Item1`, `Item2`, and so
    on.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`ValueTuple<>`结构体都有名为`Item1`、`Item2`等的字段。
- en: 'Hence, `(string,int)` is an alias for `ValueTuple<string,int>`, and this means
    that named tuple elements have no corresponding property names in the underlying
    types. Instead, the names exist only in the source code, and in the imagination
    of the compiler. At runtime, the names mostly disappear, so if you decompile a
    program that refers to named tuple elements, you’ll see just references to `Item1`,
    `Item2`, and so on. Further, when you examine a tuple variable in a debugger after
    having assigned it to an `object` (or `Dump` it in LINQPad), the element names
    are not there. And for the most part, you cannot use *reflection* ([Chapter 18](ch18.html#reflection_and_metadata))
    to determine a tuple’s element names at runtime. This means that with APIs such
    as `System.Net.Http.HttpClient`, tuples cannot replace anonymous types in scenarios
    such as the following:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`(string,int)`是`ValueTuple<string,int>`的别名，这意味着命名元组元素在基础类型中没有对应的属性名称。相反，名称仅存在于源代码中和编译器的想象中。在运行时，名称大部分消失，因此，如果反编译引用命名元组元素的程序，您将只看到对`Item1`、`Item2`等的引用。此外，在将元组变量分配给`object`（或在LINQPad中`Dump`）并在调试器中检查时，元素名称不存在。而且，在大多数情况下，您不能使用*反射*（见[第18章](ch18.html#reflection_and_metadata)）在运行时确定元组的元素名称。这意味着在诸如`System.Net.Http.HttpClient`等API中，元组不能替换匿名类型，例如以下情景：
- en: '[PRE192]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Note
  id: totrans-698
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We said that the names *mostly* disappear because there’s an exception. With
    methods/properties that return named tuple types, the compiler emits the element
    names by applying a custom attribute called `TupleElementNamesAttribute` (see
    [“Attributes”](#attributes)) to the member’s return type. This allows named elements
    to work when calling methods in a different assembly (for which the compiler does
    not have the source code).
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说过，名称*大部分*会消失，因为有例外情况。对于返回命名元组类型的方法/属性，编译器通过将名为`TupleElementNamesAttribute`的自定义属性（参见[“属性”](#attributes)）应用于成员的返回类型来发出元素名称。这允许在调用不同程序集中的方法时命名元素可以正常工作（编译器没有源代码）。
- en: Aliasing Tuples (C# 12)
  id: totrans-700
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 给元组取别名（C# 12）
- en: 'From C# 12, you can leverage the `using` directive to define aliases for tuples:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 12开始，您可以利用`using`指令为元组定义别名：
- en: '[PRE193]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'This feature also works with tuples that have named elements:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能还适用于具有命名元素的元组：
- en: '[PRE194]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'Again, we’ll see shortly how records offer a fully typed solution with the
    same level of conciseness:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们很快将看到如何使用记录提供完全类型化的解决方案，具有相同的简洁性：
- en: '[PRE195]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: ValueTuple.Create
  id: totrans-707
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ValueTuple.Create
- en: 'You can also create tuples via a factory method on the (nongeneric) `ValueTuple`
    type:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过`ValueTuple`类型（非泛型）上的工厂方法创建元组：
- en: '[PRE196]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: Deconstructing Tuples
  id: totrans-710
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解构元组
- en: 'Tuples implicitly support the deconstruction pattern (see [“Deconstructors”](ch03.html#deconstructors-id00060)),
    so you can easily *deconstruct* a tuple into individual variables. Consider the
    following:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 元组隐式支持解构模式（见[“解构方法”](ch03.html#deconstructors-id00060)），因此您可以轻松*解构*元组为单独的变量。考虑以下示例：
- en: '[PRE197]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'With the tuple’s deconstructor, you can simplify the code to this:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 使用元组的解构方法，您可以简化代码如下：
- en: '[PRE198]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'The syntax for deconstruction is confusingly similar to the syntax for declaring
    a tuple with named elements. The following highlights the difference:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 解构语法与声明具有命名元素的元组的语法令人困惑地相似。以下突出了两者的区别：
- en: '[PRE199]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'Here’s another example, this time when calling a method, and with type inference
    (`var`):'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个例子，这次是在调用方法时，并使用类型推断（`var`）：
- en: '[PRE200]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'You can also deconstruct directly into fields and properties, which provides
    a nice shortcut for populating multiple fields or properties in a constructor:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以直接解构到字段和属性中，这为在构造函数中填充多个字段或属性提供了一个便捷的快捷方式：
- en: '[PRE201]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: Equality Comparison
  id: totrans-721
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相等比较
- en: 'As with anonymous types, the `Equals` method performs structural equality comparison.
    This means that it compares the underlying *data* rather than the *reference*:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 与匿名类型类似，`Equals`方法执行结构相等比较。这意味着它比较底层的*数据*而不是*引用*：
- en: '[PRE202]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'In addition, `ValueTuple<>` overloads the `==` and `!=` operators:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`ValueTuple<>`重载了`==`和`!=`运算符：
- en: '[PRE203]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: Tuples also override the `GetHashCode` method, making it practical to use tuples
    as keys in dictionaries. We cover equality comparison in detail in [“Equality
    Comparison”](ch06.html#equality_comparison-id00067), and dictionaries in [Chapter 7](ch07.html#collections-id00055).
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 元组还重写了`GetHashCode`方法，使得在字典中可以实际使用元组作为键。我们在[“相等比较”](ch06.html#equality_comparison-id00067)中详细介绍了相等比较，并在[第7章](ch07.html#collections-id00055)中介绍了字典。
- en: The `ValueTuple<>` types also implement `IComparable` (see [“Order Comparison”](ch06.html#order_comparison)),
    making it possible to use tuples as a sorting key.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValueTuple<>`类型还实现了`IComparable`（参见[“顺序比较”](ch06.html#order_comparison)），使得可以将元组用作排序键。'
- en: The System.Tuple classes
  id: totrans-728
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`System.Tuple` 类'
- en: 'You’ll find another family of generic types in the `System` namespace called
    `Tuple` (rather than `ValueTuple`). These were introduced back in 2010 and were
    defined as classes (whereas the `ValueTuple` types are structs). Defining tuples
    as classes was in retrospect considered a mistake: in the scenarios in which tuples
    are commonly used, structs have a slight performance advantage (in that they avoid
    unnecessary memory allocations), with almost no downside. Hence, when Microsoft
    added language support for tuples in C# 7, it ignored the existing `Tuple` types
    in favor of the new `ValueTuple`. You might still come across the `Tuple` classes
    in code written prior to C# 7\. They have no special language support and are
    used as follows:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在`System`命名空间中找到另一系列泛型类型，称为`Tuple`（而不是`ValueTuple`）。这些类型在2010年引入，并被定义为类（而`ValueTuple`类型是结构）。事后认为将元组定义为类是一个错误：在元组常用的情况下，结构具有轻微的性能优势（它们避免了不必要的内存分配），几乎没有缺点。因此，当Microsoft在C#
    7中为元组添加语言支持时，它忽略了现有的`Tuple`类型，转而支持新的`ValueTuple`。您可能仍会在C# 7之前编写的代码中遇到`Tuple`类。它们没有特殊的语言支持，使用方式如下：
- en: '[PRE204]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: Records
  id: totrans-731
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录
- en: A *record* is a special kind of class or struct that’s designed to work well
    with immutable (read-only) data. Its most useful feature is *nondestructive mutation*;
    however, records are also useful in creating types that just combine or hold data.
    In simple cases, they eliminate boilerplate code while honoring the equality semantics
    most suitable for immutable types.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: '*记录*是一种特殊的类或结构，设计用于与不可变（只读）数据良好配合。它最有用的特性是*非破坏性变异*；然而，记录还可用于创建仅组合或保存数据的类型。在简单情况下，它们消除了样板代码，同时尊重最适合不可变类型的相等语义。'
- en: Records are purely a C# compile-time construct. At runtime, the CLR sees them
    just as classes or structs (with a bunch of extra “synthesized” members added
    by the compiler).
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 记录纯粹是C#的编译时构造。在运行时，CLR只将它们视为类或结构（编译器添加了一堆额外的“合成”成员）。
- en: Background
  id: totrans-734
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景
- en: Writing immutable types (whose fields cannot be modified after initialization)
    is a popular strategy for simplifying software and reducing bugs. It’s also a
    core aspect of functional programming, where mutable state is avoided and functions
    are treated as data. LINQ is inspired by this principle.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 编写不可变类型（其字段在初始化后不能被修改）是简化软件并减少错误的流行策略。它也是函数式编程的核心方面，其中避免可变状态，并将函数视为数据。LINQ受此原则启发。
- en: In order to “modify” an immutable object, you must create a new one and copy
    over the data while incorporating your modifications (this is called *nondestructive
    mutation*). In terms of performance, this is not as inefficient as you might expect,
    because a *shallow copy* will always suffice (a *deep copy*, where you also copy
    subobjects and collections, is unnecessary when data is immutable). But in terms
    of coding effort, implementing nondestructive mutation can be very inefficient,
    especially when there are many properties. Records solve this problem via a language-supported
    pattern.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 为了“修改”一个不可变对象，你必须创建一个新对象，并复制数据，同时合并你的修改（这被称为*非破坏性变异*）。在性能方面，这并不像你想象的那么低效，因为*浅复制*总是足够了（*深复制*，其中还复制子对象和集合，在数据不可变时是不必要的）。但从编码工作量来看，实现非破坏性变异可能非常低效，特别是当存在许多属性时。记录通过语言支持的模式解决了这个问题。
- en: A second issue is that programmers—particularly *functional programmers*—sometimes
    use immutable types just to combine data (without adding behavior). Defining such
    types is more work than it should be, requiring a constructor to assign each parameter
    to each public property (a deconstructor may also be useful). With records, the
    compiler can do this work for you.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是程序员，特别是*函数式程序员*，有时仅仅使用不可变类型来组合数据（而不添加行为）。定义这样的类型比应该更多工作，需要一个构造函数将每个参数分配给每个公共属性（析构函数也可能有用）。有了记录，编译器可以为您完成这项工作。
- en: Finally, one of the consequences of an object being immutable is that its identity
    cannot change, which means that it’s more useful for such types to implement *structural
    equality* than *referential equality*. Structural equality means that two instances
    are the same if their data is the same (as with tuples). Records give you structural
    equality by default—regardless of whether the underlying type is a class or struct—without
    any boilerplate code.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对象不可变的一个后果是其标识不能更改，这意味着对于这样的类型来说，实现*结构相等性*比*引用相等性*更有用。结构相等性意味着如果它们的数据相同，则两个实例相同（与元组一样）。记录默认为您提供结构相等性
    —— 无论基础类型是类还是结构体 —— 而不需要任何样板代码。
- en: Defining a Record
  id: totrans-739
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义记录
- en: A record definition is like a class or struct definition, and can contain the
    same kinds of members, including fields, properties, methods, and so on. Records
    can implement interfaces, and (class-based) records can subclass other (class-based)
    records.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 记录定义类似于类或结构体定义，可以包含相同类型的成员，包括字段、属性、方法等。记录可以实现接口，（基于类的）记录可以继承其他（基于类的）记录。
- en: 'By default, the underlying type of a record is a class:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，记录的基础类型是类：
- en: '[PRE205]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'From C# 10, the underlying type of a record can also be a struct:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 10开始，记录的基础类型也可以是结构体：
- en: '[PRE206]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: (`record class` is also legal and has the same meaning as `record`.)
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: （`record class`也是合法的，并且与`record`具有相同的含义。）
- en: 'A simple record might contain just a bunch of init-only properties, and perhaps
    a constructor:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的记录可能只包含一堆仅初始化的属性，以及可能的构造函数：
- en: '[PRE207]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: Note
  id: totrans-748
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Our constructor employs a shortcut that we described in the preceding section.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的构造函数使用了我们在前一节中描述的快捷方式。
- en: '[PRE208]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'is equivalent (in this case) to the following:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下等效于以下内容：
- en: '[PRE209]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'Upon compilation, C# transforms the record definition into a class (or struct)
    and performs the following additional steps:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时，C#将记录定义转换为类（或结构体），并执行以下附加步骤：
- en: It writes a protected *copy constructor* (and a hidden *Clone* method) to facilitate
    nondestructive mutation.
  id: totrans-754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它编写一个受保护的*拷贝构造函数*（以及一个隐藏的*克隆*方法），以便进行非破坏性变异。
- en: It overrides/overloads the equality-related functions to implement structural
    equality.
  id: totrans-755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它重写/重载了与相等性相关的函数，以实现结构相等性。
- en: It overrides the `ToString()` method (to expand the record’s public properties,
    as with anonymous types).
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它重写了`ToString()`方法（扩展记录的公共属性，就像匿名类型一样）。
- en: 'The preceding record declaration expands into something like this:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的记录声明会扩展为类似于这样的内容：
- en: '[PRE210]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: Note
  id: totrans-759
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'While there’s nothing to stop you from putting *optional parameters* into the
    constructor, a good pattern (at least in public libraries) is to leave them out
    of the constructor and expose them purely as init-only properties:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以将*可选参数*放入构造函数中，但在公共库中，一个好的模式是将它们留在构造函数之外，并且仅公开它们作为仅初始化的属性：
- en: '[PRE211]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: The advantage of this pattern is that you can safely add init-only properties
    later without breaking binary compatibility with consumers who have compiled against
    older versions of your assembly.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的优势在于，您可以安全地稍后添加仅初始化的属性，而不会破坏与已编译为旧版本程序集的消费者的二进制兼容性。
- en: Parameter lists
  id: totrans-763
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数列表
- en: 'A record definition can be shortened through the use of a *parameter list*:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 记录定义可以通过*参数列表*进行简化：
- en: '[PRE212]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'Parameters can include the `in` and `params` modifiers, but not `out` or `ref`.
    If a parameter list is specified, the compiler performs the following extra steps:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以包括`in`和`params`修饰符，但不能包括`out`或`ref`。如果指定了参数列表，则编译器执行以下额外步骤：
- en: It writes an init-only property per parameter.
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为每个参数编写了一个仅初始化的属性。
- en: It writes a *primary constructor* to populate the properties.
  id: totrans-768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它编写一个*主构造函数*来填充属性。
- en: It writes a deconstructor.
  id: totrans-769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它编写了一个析构函数。
- en: 'This means that if we declare our `Point` record simply as:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果我们简单地将我们的`Point`记录声明为：
- en: '[PRE213]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'the compiler will end up generating (almost) exactly what we listed in the
    preceding expansion. A minor difference is that the parameter names in the primary
    constructor will end up as `X` and `Y` instead of `x` and `y`:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器最终生成的（几乎）与我们在前面展开中列出的内容完全相同。一个小的差异是主构造函数中的参数名称最终会变为`X`和`Y`，而不是`x`和`y`：
- en: '[PRE214]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: Note
  id: totrans-774
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Also, due to being a *primary constructor*, parameters `X` and `Y` become magically
    available to any field or property initializers in your record. We discuss the
    subtleties of this later, in [“Primary Constructors”](#primary_constructors).
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于是*主构造函数*，参数`X`和`Y`会自动在记录中的任何字段或属性初始化器中变为可用。我们稍后在[“主构造函数”](#primary_constructors)中讨论这一点的微妙之处。
- en: 'Another difference, when you define a parameter list, is that the compiler
    also generates a deconstructor:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个区别是，当您定义参数列表时，编译器还会生成一个解构器：
- en: '[PRE215]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'Records with parameter lists can be subclassed using the following syntax:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下语法对带参数列表的记录进行子类化：
- en: '[PRE216]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'The compiler then emits a primary constructor as follows:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，编译器发出主构造函数如下所示：
- en: '[PRE217]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: Note
  id: totrans-782
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Parameter lists offer a nice shortcut when you need a class that simply groups
    together a bunch of values (a *product type* in functional programming) and can
    also be useful for prototyping. As we’ll see later, they’re not so helpful when
    you need to add logic to the `init` accessors (such as argument validation).
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要一个简单地将一堆值（函数式编程中的*产品类型*）组合在一起的类时，参数列表提供了一个不错的快捷方式，并且在原型设计时也可能非常有用。后面我们将看到，当您需要向`init`访问器添加逻辑（例如参数验证）时，它们并不是那么有用。
- en: Nondestructive Mutation
  id: totrans-784
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非破坏性变异
- en: 'The most important step that the compiler performs with all records is to write
    a *copy constructor* (and a hidden *Clone* method). This enables nondestructive
    mutation via the `with` keyword:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器对所有记录执行的最重要步骤是编写*复制构造函数*（和一个隐藏的*Clone*方法）。这使得通过`with`关键字进行非破坏性变异成为可能：
- en: '[PRE218]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'In this example, `p2` is a copy of `p1`, but with its `Y` property set to 4\.
    The benefit is more apparent when there are more properties:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`p2`是`p1`的副本，但其`Y`属性设置为4。当有更多属性时，这种好处更加明显：
- en: '[PRE219]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'Here’s the output:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出：
- en: '[PRE220]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'Nondestructive mutation occurs in two phases:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 非破坏性变异分为两个阶段进行：
- en: First, the *copy constructor* clones the record. By default, it copies each
    of the record’s underlying fields, creating a faithful replica while bypassing
    (the overhead of) any logic in the `init` accessors. All fields are included (public
    and private, as well as the hidden fields that back automatic properties).
  id: totrans-792
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，*复制构造函数*克隆记录。默认情况下，它会复制记录的每个基础字段，创建一个忠实的复制品，同时绕过（初始化访问器的）任何逻辑开销。所有字段都包括在内（公共和私有的，以及支持自动属性的隐藏字段）。
- en: Then, each property in the *member initializer list* is updated (this time using
    the `init` accessors).
  id: totrans-793
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，更新*成员初始化列表*中的每个属性（这次使用`init`访问器）。
- en: The compiler translates
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器转换
- en: '[PRE221]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'into something functionally equivalent to the following:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为以下内容的功能等效物：
- en: '[PRE222]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: (The same code would not compile if you wrote it explicitly because `A` and
    `C` are init-only properties. Furthermore, the copy constructor is *protected*;
    C# works around this by invoking it via a public hidden method that it writes
    into the record called `<Clone>$`.)
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: （如果您显式编写，相同的代码将无法编译，因为`A`和`C`是仅初始化的属性。此外，复制构造函数是*受保护*的；C#通过调用一个写入到记录中的公共隐藏方法来解决此问题，该方法名为`<Clone>$`。）
- en: 'If necessary, you can define your own *copy constructor*. C# will then use
    your definition instead of writing one itself:'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，您可以定义自己的*复制构造函数*。C#将使用您的定义而不是自己写一个：
- en: '[PRE223]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: Writing a custom copy constructor might be useful if your record contains mutable
    subobjects or collections that you wish to clone, or if there are computed fields
    that you wish to clear. Unfortunately, you can only *replace*, not *enhance*,
    the default implementation.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的记录包含可变子对象或您希望克隆的集合，或者包含希望清除的计算字段，则编写自定义复制构造函数可能很有用。不幸的是，您只能*替换*默认实现，而不能*增强*它。
- en: Note
  id: totrans-802
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'When subclassing another record, the copy constructor is responsible for copying
    only its own fields. To copy the base record’s fields, delegate to the base:'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 当子类化另一个记录时，复制构造函数负责仅复制自己的字段。要复制基记录的字段，请委托给基类：
- en: '[PRE224]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: Property Validation
  id: totrans-805
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性验证
- en: 'With explicit properties, you can write validation logic into the `init` accessors.
    In the following example, we ensure that `X` can never be `NaN` (Not a Number):'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 使用显式属性，您可以将验证逻辑写入`init`访问器。在以下示例中，我们确保`X`永远不会是`NaN`（非数字）：
- en: '[PRE225]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '**Our design ensures that validation occurs both during construction and when
    the object is nondestructively mutated:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们的设计确保验证发生在构造期间和对象在非破坏性变异时：'
- en: '[PRE226]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 'Recall that the automatically generated *copy constructor* copies over all
    fields and automatic properties. This means that the generated copy constructor
    will now look like this:'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，自动生成的*复制构造函数*会复制所有字段和自动属性。这意味着生成的复制构造函数现在看起来像这样：
- en: '[PRE227]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: Notice that the copying of the `_x` field circumvents the `X` property accessor.
    However, this cannot break anything, because it’s faithfully copying an object
    that will have already been safely populated via `X`’s `init` accessor.**  **##
    Calculated Fields and Lazy Evaluation
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，复制`_x`字段绕过了`X`属性访问器。然而，这不会造成任何问题，因为它忠实地复制了一个已经通过`X`的`init`访问器安全填充的对象。
- en: 'A popular functional programming pattern that works well with immutable types
    is *lazy evaluation*, where a value is not computed until required and then is
    cached for reuse. Suppose, for instance, that we want to define a property in
    our `Point` record that returns the distance from the origin `(0, 0)`:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流行的函数式编程模式，在不可变类型中表现良好，是*惰性求值*，其中值在需要时才计算，并且缓存以便重用。例如，假设我们想在我们的`Point`记录中定义一个属性，返回到原点`(0,
    0)`的距离：
- en: '[PRE228]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: 'Let’s now try to refactor this to avoid the cost of recomputing `DistanceFromOrigin`
    every time the property is accessed. We’ll start by removing the property list
    and defining `X`, `Y`, and `DistanceFromOrigin` as read-only properties. Then
    we can calculate the latter in the constructor:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试重构这段代码，以避免每次访问属性时重新计算`DistanceFromOrigin`的成本。我们将从移除属性列表开始，并将`X`、`Y`和`DistanceFromOrigin`定义为只读属性。然后我们可以在构造函数中计算后者：
- en: '[PRE229]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: 'This works, but it doesn’t allow for nondestructive mutation (changing `X`
    and `Y` to init-only properties would break the code because `DistanceFromOrigin`
    would become stale after the `init` accessors execute). It’s also suboptimal in
    that the calculation is always performed, regardless of whether the `DistanceFromOrigin`
    property is ever read. The optimal solution is to cache its value in a field and
    populate it *lazily* (on first use):'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以工作，但不允许非破坏性变异（将`X`和`Y`更改为仅初始化属性将破坏代码，因为在`init`访问器执行后，`DistanceFromOrigin`将变为陈旧）。此外，计算总是执行的，无论是否读取了`DistanceFromOrigin`属性，这也是次优解。最佳解决方案是在字段中缓存其值，并*延迟*（首次使用时）填充它：
- en: '[PRE230]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: Note
  id: totrans-819
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Technically, we *mutate* `_distance` in this code. It’s still fair, though,
    to call `Point` an immutable type. Mutating a field purely to populate a lazy
    value does not invalidate the principles or benefits of immutability, and can
    even be masked through the use of the `Lazy<T>` type that we describe in [Chapter 21](ch21.html#advanced_threadin).
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，技术上来说，我们*改变了* `_distance`。尽管如此，称`Point`为不可变类型仍然合理。纯粹为了填充延迟值而变异字段，并不会使不可变性的原则或好处失效，并且可以通过我们在[第21章](ch21.html#advanced_threadin)中描述的`Lazy<T>`类型来隐藏。
- en: 'With C#’s *null-coalescing assignment operator* (`??=`), we can reduce the
    entire property declaration to one line of code:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C#的*空值合并赋值运算符*(`??=`)，我们可以将整个属性声明减少为一行代码：
- en: '[PRE231]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: (This says, return `_distance` if it’s non-null; otherwise, return `Math.Sqrt
    (X*X + Y*Y)` while assigning it to `_distance`.)
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: （这句话的意思是，如果`_distance`非空，则返回它；否则，返回`Math.Sqrt(X*X + Y*Y)`并将其赋给`_distance`。）
- en: 'To make this work with init-only properties, we need one further step, which
    is to clear the cached `_distance` field when `X` or `Y` is updated via the `init`
    accessor. Here’s the complete code:'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 要使其与仅初始化属性一起工作，我们需要进一步的一步，即在通过`init`访问器更新`X`或`Y`时清除缓存的`_distance`字段。以下是完整的代码：
- en: '[PRE232]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '`Point` can now be mutated nondestructively:'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: '`Point`现在可以进行非破坏性变异：'
- en: '[PRE233]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'A nice bonus is that the autogenerated copy constructor copies over the cached
    `_distance` field. This means that should a record have other properties that
    aren’t involved in the calculation, a nondestructive mutation of those properties
    wouldn’t trigger an unnecessary loss of the cached value. If you don’t care for
    this bonus, an alternative to clearing the cached value in the `init` accessors
    is to write a custom copy constructor that ignores the cached field. This is more
    concise because it works with parameter lists, and the custom copy constructor
    can leverage the deconstructor:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的额外好处是，自动生成的复制构造函数会复制缓存的`_distance`字段。这意味着，如果一个记录有其他不参与计算的属性，对这些属性进行非破坏性变异不会触发不必要的缓存值丢失。如果您不喜欢这个额外好处，另一种方法是在`init`访问器中清除缓存值，编写一个自定义复制构造函数，它会忽略缓存字段。这样更简洁，因为它适用于参数列表，而自定义复制构造函数可以利用析构函数：
- en: '[PRE234]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: Note that with either solution, the addition of lazy calculated fields breaks
    the default structural equality comparison (because such fields may or may not
    be populated), although we’ll see shortly that it’s relatively easy to fix.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，无论采用哪种解决方案，添加延迟计算字段都会破坏默认的结构相等比较（因为这些字段可能已经填充，也可能没有填充），尽管我们很快就会看到修复它相对容易。
- en: Primary Constructors
  id: totrans-831
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主构造函数
- en: When you define a record with a parameter list, the compiler generates property
    declarations automatically, as well as a *primary constructor* (and a deconstructor).
    As we’ve seen, this works well in simple cases, and in more complex cases you
    can omit the parameter list and write the property declarations and constructor
    manually.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 当您定义一个带有参数列表的记录时，编译器会自动生成属性声明，以及一个*主构造函数*（和解构函数）。正如我们所见，这在简单情况下运行良好，在更复杂的情况下，您可以省略参数列表并手动编写属性声明和构造函数。
- en: 'C# also offers a mildly useful intermediate option—if you’re willing to deal
    with the curious semantics of primary constructors—which is to define a parameter
    list while writing some or all of the property declarations yourself:'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: C# 还提供了一个稍微有用的中间选项——如果你愿意处理主构造函数的奇特语义——那就是在自己编写一部分或全部属性声明的同时定义参数列表：
- en: '[PRE235]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: In this case, we “took over” the `ID` property definition, defining it as read-only
    (instead of init-only), preventing it from partaking in nondestructive mutation.
    If you never need to nondestructively mutate a particular property, making it
    read-only lets you store computed data in the record without having to code up
    a refresh mechanism.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们“接管”了`ID`属性的定义，将其定义为只读（而不是`init-only`），防止其参与非破坏性变异。如果您从不需要非破坏性地改变特定属性，将其设为只读可以让您在记录中存储计算数据，而无需编写刷新机制。
- en: 'Notice that we needed to include a *property initializer* (in boldface):'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们需要包含*属性初始化器*（用粗体标出）：
- en: '[PRE236]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: When you “take over” a property declaration, you become responsible for initializing
    its value; the primary constructor no longer does this automatically. (This exactly
    matches the behavior when defining primary constructors on classes or structs.)
    Also note that the `ID` in boldface refers to the *primary constructor parameter*,
    not the `ID` property.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 当您“接管”一个属性声明时，您需要负责初始化其值；主构造函数不再自动执行此操作。（这与在类或结构体上定义主构造函数时的行为完全一致。）同时注意，粗体中的`ID`指的是*主构造函数参数*，而不是`ID`属性。
- en: Note
  id: totrans-839
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'With record structs, it’s legal to redefine a property as a field:'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 对于记录结构体，重新定义属性作为字段是合法的：
- en: '[PRE237]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'In keeping with the semantics of primary constructors on classes and structs
    (see [“Primary Constructors”](#primary_constructors)), the primary constructor
    parameters (`ID`, `LastName`, and `GivenName` in this case) are magically visible
    to all field and property initializers. We can illustrate this by extending our
    example as follows:'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 与类和结构体上主构造函数的语义保持一致（参见[“主构造函数”](#primary_constructors)），主构造函数参数（在这种情况下是`ID`、`LastName`和`GivenName`）神奇地对所有字段和属性初始化器可见。我们可以通过以下扩展示例来说明这一点：
- en: '[PRE238]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: Again, the `ID` in boldface refers to the primary constructor parameter, not
    the property. (The reason for there not being an ambiguity is that it’s illegal
    to access properties from initializers.)
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，粗体中的`ID`指的是主构造函数的参数，而不是属性。（不存在歧义的原因是从初始化器中访问属性是非法的。）
- en: In this example, we calculated `_enrollmentYear` from the first four digits
    of the `ID`. While it’s safe to store this in a read-only field (because the `ID`
    property is read-only and so cannot be nondestructively mutated), this code would
    not work so well in the real world. The reason is that without an explicit constructor,
    there’s no central place in which to validate `ID` and throw a meaningful exception
    should it be invalid (a common requirement).
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们根据`ID`的前四位数字计算了`_enrollmentYear`。虽然将其存储在只读字段中是安全的（因为`ID`属性是只读的，因此不能非破坏性地变异），但是在实际情况下，这段代码可能效果不佳。原因在于没有显式的构造函数，没有一个集中的地方来验证`ID`并在其无效时抛出一个有意义的异常（这是一个常见的需求）。
- en: 'Validation is also a good reason for needing to write explicit init-only accessors
    (as we discussed in [“Property Validation”](#property_validation)). Unfortunately,
    primary constructors do not play well in this scenario. To illustrate, consider
    the following record, where an `init` accessor performs a null validation check:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 验证也是需要编写显式的`init-only`访问器的一个好理由（正如我们在[“属性验证”](#property_validation)中讨论的那样）。不幸的是，主构造函数在这种情况下表现不佳。为了说明这一点，考虑下面的记录，其中`init`访问器执行了一个空值验证检查：
- en: '[PRE239]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: 'Because `Name` is not an automatic property, it cannot define an initializer.
    The best we can do is put the initializer on the backing field (in boldface).
    Unfortunately, doing so bypasses the null check:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Name`不是自动属性，所以不能定义初始化器。我们能做的最好的就是将初始化器放在背后的字段上（用粗体标出）。不幸的是，这样做会绕过空值检查：
- en: '[PRE240]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'The difficulty is that there’s no way to assign a primary constructor parameter
    to a property without writing the constructor ourselves. While there are workarounds
    (such as factoring the `init` validation logic into a separate static method that
    we call twice), the simplest workaround is to avoid the parameter list altogether
    and write an ordinary constructor manually (and deconstructor, should you need
    it):'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 难点在于没有办法在不编写构造函数的情况下将主构造函数参数分配给属性。虽然有解决方法（例如将 `init` 验证逻辑分解为我们调用两次的单独静态方法），但最简单的解决方法是完全避免参数列表，并手动编写一个普通的构造函数（以及析构函数，如果需要）：
- en: '[PRE241]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: Records and Equality Comparison
  id: totrans-852
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录和相等比较
- en: 'Just as with structs, anonymous types, and tuples, records provide structural
    equality out of the box, meaning that two records are equal if their fields (and
    automatic properties) are equal:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 正如结构体、匿名类型和元组一样，记录提供了开箱即用的结构相等性，这意味着如果它们的字段（和自动属性）相等，则两个记录是相等的：
- en: '[PRE242]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'The *equality operator* also works with records (as it does with tuples):'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: '*等式运算符* 也适用于记录（就像适用于元组一样）：'
- en: '[PRE243]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: The default equality implementation for records is unavoidably fragile. In particular,
    it breaks if the record contains lazy values, transient values, arrays, or collection
    types (which require special handling for equality comparison). Fortunately, it’s
    relatively easy to fix (should you need equality to work), and doing so is less
    work than adding full equality behavior to classes or structs.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 记录的默认相等实现是无法避免的脆弱的。特别是，如果记录包含惰性值、临时值、数组或集合类型（需要特殊处理以进行相等比较），则会出现问题。幸运的是，如果需要使相等性工作，修复它相对来说比为类或结构体添加完整的相等行为要简单得多。
- en: 'Unlike with classes and structs, you do not (and cannot) override the `object.Equals`
    method; instead, you define a public `Equals` method with the following signature:'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 与类和结构体不同，你不需要（也不能）重写 `object.Equals` 方法；相反，你需要定义一个公共的 `Equals` 方法，具有以下签名：
- en: '[PRE244]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: The `Equals` method must be `virtual` (not `override`), and it must be *strongly
    typed* such that it accepts the actual record type (`Point` in this case, not
    `object`). Once you get the signature right, the compiler will automatically patch
    in your method.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: '`Equals` 方法必须是 `virtual`（而不是 `override`），并且它必须是*强类型*的，以便接受实际的记录类型（在本例中为 `Point`，而不是
    `object`）。一旦你正确定义了签名，编译器将自动补充你的方法。'
- en: In our example, we changed the equality logic such that we compare only `X`
    and `Y` (and ignore `_someOtherField`).
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们改变了相等逻辑，只比较 `X` 和 `Y`（并忽略 `_someOtherField`）。
- en: 'Should you subclass another record, you can call the `base.Equals` method:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要对另一个记录进行子类化，你可以调用 `base.Equals` 方法：
- en: '[PRE245]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'As with any type, if you take over equality comparison, you should also override
    `GetHashCode()`. A nice feature of records is that you don’t overload `!=` or
    `==`; nor do you implement `IEquatable<T>`: this is all done for you. We cover
    this topic of equality comparison fully in [“Equality Comparison”](ch06.html#equality_comparison-id00067).**  **#
    Patterns'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何类型一样，如果你接管了相等比较，你也应该重写 `GetHashCode()`。记录的一个好处是你不需要重载 `!=` 或 `==`；也不需要实现
    `IEquatable<T>`：这一切都为你完成了。我们在[“相等比较”](ch06.html#equality_comparison-id00067)章节中详细讨论了相等比较的主题。**  **#
    模式
- en: 'In [Chapter 3](ch03.html#creating_types_in_chash), we demonstrated how to use
    the `is` operator to test whether a reference conversion will succeed:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](ch03.html#creating_types_in_chash)中，我们演示了如何使用 `is` 运算符来测试引用转换是否成功：
- en: '[PRE246]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: 'Or, more concisely:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更简洁地说：
- en: '[PRE247]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: 'This shortcut employs one kind of pattern called a *type pattern*. The `is`
    operator also supports other patterns that were introduced in recent versions
    of C#, such as the *property pattern*:'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 这个快捷方式使用了一种称为*类型模式*的模式之一。`is` 运算符还支持其他在最近版本的 C# 中引入的模式，例如*属性模式*：
- en: '[PRE248]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: 'Patterns are supported in the following contexts:'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 模式在以下上下文中得到支持：
- en: After the `is` operator (`*variable* is *pattern*`)
  id: totrans-872
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `is` 运算符之后（`*variable* is *pattern*`）
- en: In switch statements
  id: totrans-873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 switch 语句中
- en: In switch expressions
  id: totrans-874
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 switch 表达式中
- en: We’ve already covered the type pattern (and briefly, the tuple pattern) in [“Switching
    on types”](ch02.html#switching_on_types) and [“The is operator”](ch03.html#the_is_operator).
    In this section, we cover more advanced patterns that were introduced in recent
    versions of C#.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[“类型切换”](ch02.html#switching_on_types)和[“is 运算符”](ch03.html#the_is_operator)中简要介绍了类型模式（以及元组模式）。在本节中，我们将介绍最近版本的
    C# 中引入的更高级的模式。
- en: Some of the more specialized patterns are intended mostly for use in switch
    statements/expressions. Here, they reduce the need for `when` clauses and let
    you use switches where you couldn’t previously.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 一些更专业的模式主要用于switch语句/表达式中。这些模式减少了`when`子句的需要，并允许您在以前无法使用switch的情况下使用它们。
- en: Note
  id: totrans-877
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The patterns in this section are mildly to moderately useful in some scenarios.
    Remember that you can always replace highly patterned switch expressions with
    simple `if` statements—or, in some cases, the ternary conditional operator—often
    without much extra code.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的模式在某些情况下略微或中度有用。请记住，您总是可以用简单的`if`语句或在某些情况下，三元条件运算符，替换高度模式化的switch表达式，通常不需要额外的代码。
- en: Constant Pattern
  id: totrans-879
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量模式
- en: 'The constant pattern lets you match directly to a constant, and is useful when
    working with the `object` type:'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 常量模式允许您直接匹配常量，并在使用`object`类型时非常有用：
- en: '[PRE249]'
  id: totrans-881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: 'This expression in boldface is equivalent to the following:'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 粗体表达式等同于以下内容：
- en: '[PRE250]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: (Being a static operator, C# won’t let you use `==` to compare an `object` directly
    to a constant, because the compiler needs to know the types in advance.)
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: （作为静态操作符，C#不允许您直接使用`==`将`object`与常量进行比较，因为编译器需要预先知道类型。）
- en: 'On its own, this pattern is only marginally useful in that there’s a reasonable
    alternative:'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 单独使用时，此模式只在有合理替代方案时才有少量用处：
- en: '[PRE251]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: As we’ll see soon, the constant pattern becomes much more useful with *pattern
    combinators*.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将很快看到的，与*模式组合器*一起，常量模式变得更加有用。
- en: Relational Patterns
  id: totrans-888
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系模式
- en: 'From C# 9, you can use the `<`, `>`, `<=`, and `>=` operators in patterns:'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 9开始，您可以在模式中使用`<`、`>`、`<=`和`>=`操作符：
- en: '[PRE252]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: 'This becomes meaningfully useful in a `switch`:'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 在`switch`语句中，这变得非常有用：
- en: '[PRE253]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: Relational patterns become even more useful in conjunction with *pattern combinators*.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 关系模式与*模式组合器*结合使用时更加实用。
- en: Note
  id: totrans-894
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The relational pattern also works when the variable has a compile-time type
    of `object`, but you have to be extremely careful with your use of numeric constants.
    In the following example, the last line prints False because we are attempting
    to match a decimal value to an integer literal:'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量具有编译时`object`类型时，关系模式也起作用，但您必须非常小心使用数值常量。在下面的示例中，最后一行输出False，因为我们试图将一个十进制值与整数字面值进行匹配：
- en: '[PRE254]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: Pattern Combinators
  id: totrans-897
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式组合器
- en: 'From C# 9, you can use the `and`, `or`, and `not` keywords to combine patterns:'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 9开始，您可以使用`and`、`or`和`not`关键字组合模式：
- en: '[PRE255]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: As with the `&&` and `||` operators, `and` has higher precedence than `or`.
    You can override this with parentheses.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 与`&&`和`||`运算符一样，`and`比`or`具有更高的优先级。您可以使用括号覆盖此优先级。
- en: 'A nice trick is to combine the `not` combinator with the *type pattern* to
    test whether an object is (not) a type:'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的技巧是将`not`组合器与*类型模式*结合使用，以测试对象是否为（不是）某种类型：
- en: '[PRE256]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: 'This looks nicer than:'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 这比以下形式更好看：
- en: '[PRE257]'
  id: totrans-904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: var Pattern
  id: totrans-905
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量模式
- en: 'The *var pattern* is a variation of the *type pattern* whereby you replace
    the type name with the `var` keyword. The conversion always succeeds, so its purpose
    is merely to let you reuse the variable that follows:'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: '*var模式*是*类型模式*的一种变体，其中您用`var`关键字替换类型名称。转换总是成功的，因此它的目的仅仅是让您重用随后的变量：'
- en: '[PRE258]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: 'This is equivalent to:'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于：
- en: '[PRE259]'
  id: totrans-909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: The ability to introduce and reuse an intermediate variable (`upper`, in this
    case) in an expression-bodied method is convenient—particularly in lambda expressions.
    Unfortunately, it tends to be useful only when the method in question has a `bool`
    return type.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 在表达式主体方法中引入和重用中间变量（在此示例中为`upper`）在lambda表达式中非常方便——尤其是当问题方法具有`bool`返回类型时。不幸的是，它在该模式有一个合理的替代方案时才是有用的。
- en: Tuple and Positional Patterns
  id: totrans-911
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组和位置模式
- en: 'The *tuple pattern* (introduced in C# 8) matches tuples:'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: '*元组模式*（C# 8引入）匹配元组：'
- en: '[PRE260]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: 'You can use this to switch on multiple values:'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以用此功能切换多个值：
- en: '[PRE261]'
  id: totrans-915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: 'The tuple pattern can be considered a special case of the *positional pattern*
    (C# 8+), which matches any type that exposes a `Deconstruct` method (see [“Deconstructors”](ch03.html#deconstructors-id00060)).
    In the following example, we leverage the `Point` record’s compiler-generated
    deconstructor:'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 元组模式可以被视为*位置模式*（C# 8+）的特例，它匹配任何具有`Deconstruct`方法的类型（参见[“Deconstructors”](ch03.html#deconstructors-id00060)）。在下面的示例中，我们利用`Point`记录的编译生成解构器：
- en: '[PRE262]'
  id: totrans-917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: 'You can deconstruct as you match, using the following syntax:'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在匹配的同时解构，使用以下语法：
- en: '[PRE263]'
  id: totrans-919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: 'Here’s a switch expression that combines a type pattern with a positional pattern:'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个结合类型模式和位置模式的switch表达式：
- en: '[PRE264]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: Property Patterns
  id: totrans-922
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性模式
- en: 'A property pattern (C# 8+) matches on one or more of an object’s property values.
    We gave a simple example previously in the context of the `is` operator:'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 属性模式（C# 8+）匹配对象的一个或多个属性值。我们之前在`is`运算符的上下文中给出了一个简单的例子：
- en: '[PRE265]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: 'However, this doesn’t save much over the following:'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并没有比以下内容节省多少：
- en: '[PRE266]'
  id: totrans-926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: 'With switch statements and expressions, property patterns are more useful.
    Consider the `System.Uri` class, which represents a URI. It has properties that
    include `Scheme`, `Host`, `Port`, and `IsLoopback`. In writing a firewall, we
    could decide whether to allow or block a URI by employing a switch expression
    that uses property patterns:'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`switch`语句和表达式时，属性模式更加有用。考虑`System.Uri`类，它表示一个URI。它的属性包括`Scheme`、`Host`、`Port`和`IsLoopback`。在编写防火墙时，我们可以决定是否允许或阻止URI的使用，通过使用使用属性模式的`switch`表达式：
- en: '[PRE267]'
  id: totrans-928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: 'You can nest properties, making the following clause legal:'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以嵌套属性，使以下子句合法：
- en: '[PRE268]'
  id: totrans-930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: 'which, from C# 10, can be simplified to:'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 10开始，可以简化为：
- en: '[PRE269]'
  id: totrans-932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: 'You can use other patterns inside property patterns, including the relational
    pattern:'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在属性模式中使用其他模式，包括关系模式：
- en: '[PRE270]'
  id: totrans-934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: 'More elaborate conditions can be expressed with a `when` clause:'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的条件可以用`when`子句表示：
- en: '[PRE271]'
  id: totrans-936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: 'You can also combine the property pattern with the type pattern:'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将属性模式与类型模式结合使用：
- en: '[PRE272]'
  id: totrans-938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: 'As you might expect with type patterns, you can introduce a variable at the
    end of a clause and then consume that variable:'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能期望的那样，你可以在子句的末尾引入一个变量，然后使用该变量：
- en: '[PRE273]'
  id: totrans-940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: 'You can also use that variable in a `when` clause:'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在`when`子句中使用该变量：
- en: '[PRE274]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: 'A somewhat bizarre twist with property patterns is that you can also introduce
    variables at the *property* level:'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性模式中有点奇怪的是，你也可以在*属性*级别引入变量：
- en: '[PRE275]'
  id: totrans-944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: 'Implicit typing is permitted, so you can substitute `string` with `var`. Here’s
    a complete example:'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式类型允许使用，因此你可以用`var`替换`string`。这里是一个完整的示例：
- en: '[PRE276]'
  id: totrans-946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: 'It’s difficult to invent examples for which this saves more than a few characters.
    In our case, the alternative is actually shorter:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 很难找到一个例子，可以节省多于几个字符。在我们的情况下，另一种选择实际上更短：
- en: '[PRE277]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: 'Or:'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 或：
- en: '[PRE278]'
  id: totrans-950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: List Patterns
  id: totrans-951
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表模式
- en: List patterns (from C# 11) work with any collection type that is countable (with
    a `Count` or `Length` property) and indexable (with an indexer of type `int` or
    `System.Index`).
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 列表模式（从C# 11开始）适用于任何可计数的集合类型（具有`Count`或`Length`属性）和可索引的类型（具有`int`或`System.Index`类型的索引器）。
- en: 'A list pattern matches a series of elements in square brackets:'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 列表模式匹配方括号中的一系列元素：
- en: '[PRE279]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: 'An underscore matches a single element of any value:'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线匹配任何值的单个元素：
- en: '[PRE280]'
  id: totrans-956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: 'The `var` pattern also works in matching a single element:'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: '`var`模式也适用于匹配单个元素：'
- en: '[PRE281]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: 'Two dots indicate a *slice*. A slice matches zero or more elements:'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 两个冒号表示一个*切片*。切片匹配零个或多个元素：
- en: '[PRE282]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: 'With arrays and other types that support indices and ranges (see [“Indices
    and Ranges”](ch02.html#indices_and_ranges-id00073)), you can follow a slice with
    a `var` pattern:'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 对于支持索引和范围的数组和其他类型（请参阅[“索引和范围”](ch02.html#indices_and_ranges-id00073)），你可以在`var`模式后跟随一个切片：
- en: '[PRE283]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: A list pattern can include at most one slice.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 列表模式最多可以包含一个切片。
- en: Attributes
  id: totrans-964
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: You’re already familiar with the notion of attributing code elements of a program
    with modifiers, such as `virtual` or `ref`. These constructs are built into the
    language. *Attributes* are an extensible mechanism for adding custom information
    to code elements (assemblies, types, members, return values, parameters, and generic
    type parameters). This extensibility is useful for services that integrate deeply
    into the type system, without requiring special keywords or constructs in the
    C# language.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经熟悉了将程序代码元素归属为带有修饰符（如`virtual`或`ref`）的概念。这些结构内置于语言中。*属性*是一种可扩展的机制，用于向代码元素（程序集、类型、成员、返回值、参数和泛型类型参数）添加自定义信息。这种可扩展性对于深度集成到类型系统中的服务非常有用，而不需要特殊的关键字或C#语言中的构造。
- en: Attribute Classes
  id: totrans-966
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性类
- en: 'An attribute is defined by a class that inherits (directly or indirectly) from
    the abstract class `System.Attribute`. To attach an attribute to a code element,
    specify the attribute’s type name in square brackets, before the code element.
    For example, the following attaches the `ObsoleteAttribute` to the `Foo` class:'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 属性由继承（直接或间接）自抽象类`System.Attribute`的类定义。要将属性附加到代码元素，请在代码元素之前的方括号中指定属性的类型名称。例如，以下代码将`ObsoleteAttribute`附加到`Foo`类：
- en: '[PRE284]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: 'This particular attribute is recognized by the compiler and will cause compiler
    warnings if a type or member marked as obsolete is referenced. By convention,
    all attribute types end in the word “Attribute.” C# recognizes this and allows
    you to omit the suffix when attaching an attribute:'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的属性被编译器识别，如果引用了被标记为过时的类型或成员，将会引发编译器警告。按照惯例，所有属性类型的名称都以“Attribute”结尾。C#识别这一点，并允许你在附加属性时省略后缀：
- en: '[PRE285]'
  id: totrans-970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '`ObsoleteAttribute` is a type declared in the `System` namespace as follows
    (simplified for brevity):'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObsoleteAttribute`是一个在`System`命名空间中声明的类型（简化以减少篇幅）：'
- en: '[PRE286]'
  id: totrans-972
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: The .NET libraries include many predefined attributes. We describe how to write
    your own attributes in [Chapter 18](ch18.html#reflection_and_metadata).
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: .NET库包含许多预定义的属性。我们在[第18章](ch18.html#reflection_and_metadata)中描述如何编写自己的属性。
- en: Named and Positional Attribute Parameters
  id: totrans-974
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名和位置属性参数
- en: 'Attributes can have parameters. In the following example, we apply `XmlTypeAttribute`
    to a class. This attribute instructs the XML serializer (in `System.Xml.Serialization`)
    as to how an object is represented in XML and accepts several *attribute parameters*.
    The following attribute maps the `CustomerEntity` class to an XML element named
    `Customer`, which belongs to the `http://oreilly.com` namespace:'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 属性可以有参数。在以下示例中，我们将`XmlTypeAttribute`应用于一个类。这个属性指示XML序列化器（位于`System.Xml.Serialization`中）如何表示XML中的对象，并接受几个*属性参数*。以下属性将`CustomerEntity`类映射到名为`Customer`的XML元素，该元素属于`http://oreilly.com`命名空间：
- en: '[PRE287]'
  id: totrans-976
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: (We cover XML and JSON serialization in the online supplement at [*http://www.albahari.com/nutshell*](http://www.albahari.com/nutshell).)
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: （我们在在线补充中介绍XML和JSON序列化，网址为[*http://www.albahari.com/nutshell*](http://www.albahari.com/nutshell)。）
- en: 'Attribute parameters fall into one of two categories: *positional* or *named*.
    In the preceding example, the first argument is a positional parameter; the second
    is a named parameter. Positional parameters correspond to parameters of the attribute
    type’s public constructors. Named parameters correspond to public fields or public
    properties on the attribute type.'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 属性参数分为两类：*位置参数*和*命名参数*。在前面的示例中，第一个参数是位置参数，第二个是命名参数。位置参数对应于属性类型的公共构造函数的参数。命名参数对应于属性类型上的公共字段或公共属性。
- en: When specifying an attribute, you must include positional parameters that correspond
    to one of the attribute’s constructors. Named parameters are optional.
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定属性时，必须包括与属性构造函数对应的位置参数。命名参数是可选的。
- en: In [Chapter 18](ch18.html#reflection_and_metadata), we describe the valid parameter
    types and rules for their evaluation.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第18章](ch18.html#reflection_and_metadata)中，我们描述了有效的参数类型及其评估规则。
- en: Applying Attributes to Assemblies and Backing Fields
  id: totrans-981
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将属性应用于程序集和后备字段
- en: 'Implicitly, the target of an attribute is the code element it immediately precedes,
    which is typically a type or type member. You can also attach attributes, however,
    to an assembly. This requires that you explicitly specify the attribute’s target.
    Here is how you can use the `AssemblyFileVersion` attribute to attach a version
    to the assembly:'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式地，属性的目标是它紧接着的代码元素，通常是一个类型或类型成员。但是，你也可以将属性附加到一个程序集上。这需要你明确指定属性的目标。以下是如何使用`AssemblyFileVersion`属性为程序集附加版本号的方法：
- en: '[PRE288]'
  id: totrans-983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: 'With the `field:` prefix, you can apply an attribute to the backing fields
    of an automatic property. This is useful in special cases, such as when applying
    the (now-deprecated) `NonSerialized` attribute:'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`field:`前缀，你可以将属性应用于自动属性的后备字段。在某些特殊情况下，例如应用（现已过时的）`NonSerialized`属性时，这是非常有用的：
- en: '[PRE289]'
  id: totrans-985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: Applying Attributes to Lambda Expressions
  id: totrans-986
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将属性应用于lambda表达式
- en: 'From C# 10, you can apply attributes to the method, parameters, and return
    value of a lambda expression:'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 10开始，你可以将属性应用于lambda表达式的方法、参数和返回值：
- en: '[PRE290]'
  id: totrans-988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: Note
  id: totrans-989
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This is useful when working with frameworks—such as ASP.NET—that rely on you
    placing attributes on methods that you write. With this feature, you can avoid
    having to create named methods for simple operations.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 当与依赖于你在编写的方法上放置属性的框架（如ASP.NET）一起工作时，这非常有用。有了这个特性，你可以避免为简单操作创建命名方法。
- en: 'These attributes are applied to the compiler-generated method to which the
    delegate points. In [Chapter 18](ch18.html#reflection_and_metadata), we’ll describe
    how to reflect over attributes in code. For now, here’s the extra code you need
    to resolve that indirection:'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性应用于委托指向的编译器生成的方法。在[第18章](ch18.html#reflection_and_metadata)中，我们将描述如何在代码中反射属性。现在，这是解析该间接引用所需的额外代码：
- en: '[PRE291]'
  id: totrans-992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: To avoid syntactical ambiguity when applying attributes to a parameter on a
    lambda expression, parentheses are always required. Attributes are not permitted
    on expression-tree lambdas.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在lambda表达式的参数上应用属性时的语法歧义，总是需要括号。不允许在表达树lambda上使用属性。
- en: Specifying Multiple Attributes
  id: totrans-994
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定多个属性
- en: 'You can specify multiple attributes for a single code element. You can list
    each attribute either within the same pair of square brackets (separated by a
    comma) or in separate pairs of square brackets (or a combination of the two).
    The following three examples are semantically identical:'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为单个代码元素指定多个属性。你可以在同一对方括号内（用逗号分隔）列出每个属性，或者在不同的方括号对内列出（或者两者的组合）。以下三个示例在语义上是相同的：
- en: '[PRE292]'
  id: totrans-996
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: Caller Info Attributes
  id: totrans-997
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用者信息属性
- en: 'You can tag optional parameters with one of three *caller info attributes*,
    which instruct the compiler to feed information obtained from the caller’s source
    code into the parameter’s default value:'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用三种*调用者信息属性*中的一种标记可选参数，指示编译器将来自调用者源代码的信息输入到参数的默认值中：
- en: '`[CallerMemberName]` applies the caller’s member name.'
  id: totrans-999
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[CallerMemberName]`应用调用者的成员名称。'
- en: '`[CallerFilePath]` applies the path to the caller’s source code file.'
  id: totrans-1000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[CallerFilePath]`应用调用者源代码文件的路径。'
- en: '`[CallerLineNumber]` applies the line number in the caller’s source code file.'
  id: totrans-1001
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[CallerLineNumber]`应用调用者源代码文件中的行号。'
- en: 'The `Foo` method in the following program demonstrates all three:'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 下面程序中的`Foo`方法演示了所有三种属性：
- en: '[PRE293]'
  id: totrans-1003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: 'Assuming that our program resides in *c:\source\test\Program.cs*, the output
    would be:'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的程序位于*c:\source\test\Program.cs*，输出将会是：
- en: '[PRE294]'
  id: totrans-1005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: 'As with standard optional parameters, the substitution is done at the *calling
    site*. Hence, our `Main` method is syntactic sugar for this:'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准可选参数一样，替换是在*调用点*完成的。因此，我们的`Main`方法对应的语法糖如下：
- en: '[PRE295]'
  id: totrans-1007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: 'Caller info attributes are useful for logging—and for implementing patterns
    such as firing a single change notification event whenever any property on an
    object changes. In fact, there’s a standard interface for this in the `System.ComponentModel`
    namespace, called `INotifyPropertyChanged`:'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者信息属性对于日志记录非常有用，以及用于实现模式，例如在对象的任何属性更改时触发单个更改通知事件。实际上，在`System.ComponentModel`命名空间中有一个名为`INotifyPropertyChanged`的标准接口：
- en: '[PRE296]'
  id: totrans-1009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: 'Notice that `PropertyChangedEventArgs` requires the name of the property that
    changed. By applying the `[CallerMemberName]` attribute, however, we can implement
    this interface and invoke the event without ever specifying property names:'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`PropertyChangedEventArgs`需要更改的属性名称。然而，通过应用`[CallerMemberName]`属性，我们可以实现此接口并在不指定属性名称的情况下调用事件：
- en: '[PRE297]'
  id: totrans-1011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: CallerArgumentExpression
  id: totrans-1012
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CallerArgumentExpression
- en: 'A method parameter to which you apply the `[CallerArgumentExpression]` attribute
    (from C# 10) captures an argument expression from the call site:'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 10开始，你可以将`[CallerArgumentExpression]`属性应用于方法参数，以从调用点捕获参数表达式：
- en: '[PRE298]'
  id: totrans-1014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: 'The compiler feeds in the calling expression’s source code literally, including
    comments:'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会直接将调用表达式的源代码输入，包括注释：
- en: '[PRE299]'
  id: totrans-1016
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: 'The main application for this feature is when writing validation and assertion
    libraries. In the following example, an exception is thrown, whose message includes
    the text “2 + 2 == 5”. This aids in debugging:'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能的主要应用程序是在编写验证和断言库时。在以下示例中，抛出了一个异常，其消息包含文本“2 + 2 == 5”。这有助于调试：
- en: '[PRE300]'
  id: totrans-1018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: 'Another example is the static `ThrowIfNull` method on the `ArgumentNullException`
    class. This method was introduced in .NET 6 and is defined as follows:'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是`.NET 6`中`ArgumentNullException`类上的静态`ThrowIfNull`方法。该方法定义如下：
- en: '[PRE301]'
  id: totrans-1020
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: 'It is used as follows:'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 它的使用方式如下：
- en: '[PRE302]'
  id: totrans-1022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: You can use `[CallerArgumentExpression]` multiple times, to capture multiple
    argument expressions.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 可以多次使用`[CallerArgumentExpression]`，以捕获多个参数表达式。
- en: Dynamic Binding
  id: totrans-1024
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态绑定
- en: '*Dynamic binding* defers *binding*—the process of resolving types, members,
    and operators—from compile time to runtime. Dynamic binding is useful when at
    compile time *you* know that a certain function, member, or operation exists,
    but the *compiler* does not. This commonly occurs when you are interoperating
    with dynamic languages (such as IronPython) and COM as well as for scenarios in
    which you might otherwise use reflection.'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: '*动态绑定*将*绑定*——即解析类型、成员和运算符的过程——从编译时延迟到运行时。当在编译时*您*知道某个函数、成员或操作存在，但*编译器*不知道时，动态绑定就很有用。这通常发生在与动态语言（如IronPython）和COM的交互以及其他可能需要使用反射的情况下。'
- en: 'A dynamic type is declared with the contextual keyword `dynamic`:'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 动态类型是使用上下文关键字`dynamic`声明的：
- en: '[PRE303]'
  id: totrans-1027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: A dynamic type tells the compiler to relax. We expect the runtime type of `d`
    to have a `Quack` method. We just can’t prove it statically. Because `d` is dynamic,
    the compiler defers binding `Quack` to `d` until runtime. To understand what this
    means requires distinguishing between *static binding* and *dynamic binding*.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 动态类型告诉编译器放松。我们期望`d`的运行时类型有一个名为`Quack`的方法。我们只是不能在静态上下文中证明它。因为`d`是动态的，编译器将绑定`Quack`到`d`推迟到运行时。要理解这意味着什么，需要区分*静态绑定*和*动态绑定*。
- en: Static Binding Versus Dynamic Binding
  id: totrans-1029
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态绑定与动态绑定
- en: 'The canonical binding example is mapping a name to a specific function when
    compiling an expression. To compile the following expression, the compiler needs
    to find the implementation of the method named `Quack`:'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的绑定示例是在编译表达式时将名称映射到特定函数。要编译以下表达式，编译器需要找到名为`Quack`的方法的实现：
- en: '[PRE304]'
  id: totrans-1031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: 'Let’s suppose that the static type of `d` is `Duck`:'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`d`的静态类型是`Duck`：
- en: '[PRE305]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: In the simplest case, the compiler does the binding by looking for a parameterless
    method named `Quack` on `Duck`. Failing that, the compiler extends its search
    to methods taking optional parameters, methods on base classes of `Duck`, and
    extension methods that take `Duck` as its first parameter. If no match is found,
    you’ll get a compilation error. Regardless of what method is bound, the bottom
    line is that the binding is done by the compiler, and the binding utterly depends
    on statically knowing the types of the operands (in this case, `d`). This makes
    it *static binding*.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，编译器通过查找`Duck`上名为`Quack`的无参方法来进行绑定。如果找不到，则编译器会扩展搜索至接受可选参数的方法、`Duck`的基类方法，以及将`Duck`作为第一个参数的扩展方法。如果没有找到匹配项，将会出现编译错误。无论绑定了哪种方法，最终的结果是由编译器完成的，且绑定完全依赖于静态地知道操作数的类型（在本例中为`d`）。这称为*静态绑定*。
- en: 'Now let’s change the static type of `d` to `object`:'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将`d`的静态类型改为`object`：
- en: '[PRE306]'
  id: totrans-1036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: 'Calling `Quack` gives us a compilation error, because although the value stored
    in `d` can contain a method called `Quack`, the compiler cannot know it, because
    the only information it has is the type of the variable, which in this case is
    `object`. But let’s now change the static type of `d` to `dynamic`:'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`Quack`会导致编译错误，因为虽然存储在`d`中的值可能包含名为`Quack`的方法，但编译器无法知道，因为它唯一知道的信息是变量的类型，而在这种情况下是`object`。但现在让我们将`d`的静态类型改为`dynamic`：
- en: '[PRE307]'
  id: totrans-1038
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: A `dynamic` type is like `object`—it’s equally nondescriptive about a type.
    The difference is that it lets you use it in ways that aren’t known at compile
    time. A dynamic object binds at runtime based on its runtime type, not its compile-time
    type. When the compiler sees a dynamically bound expression (which in general
    is an expression that contains any value of type `dynamic`), it merely packages
    up the expression such that the binding can be done later at runtime.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynamic`类型类似于`object`——它对类型的描述同样不具体。不同之处在于，它允许您以编译时未知的方式使用它。动态对象根据其运行时类型而不是编译时类型在运行时绑定。当编译器看到一个动态绑定的表达式（通常是包含任何`dynamic`类型值的表达式），它只是简单地打包表达式，以便稍后在运行时进行绑定。'
- en: At runtime, if a dynamic object implements `IDynamicMetaObjectProvider`, that
    interface is used to perform the binding. If not, binding occurs in almost the
    same way as it would have had the compiler known the dynamic object’s runtime
    type. These two alternatives are called *custom binding* and *language binding*.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，如果动态对象实现了`IDynamicMetaObjectProvider`接口，则会使用该接口执行绑定。如果没有，则绑定方式几乎与编译器了解动态对象的运行时类型时的方式相同。这两种替代方式称为*自定义绑定*和*语言绑定*。
- en: Custom Binding
  id: totrans-1041
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义绑定
- en: Custom binding occurs when a dynamic object implements `IDynamicMetaObjectProvider`
    (IDMOP). Although you can implement IDMOP on types that you write in C#, and that
    is useful to do, the more common case is that you have acquired an IDMOP object
    from a dynamic language that is implemented in .NET on the Dynamic Language Runtime
    (DLR), such as IronPython or IronRuby. Objects from those languages implicitly
    implement IDMOP as a means to directly control the meanings of operations performed
    on them.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义绑定发生在动态对象实现`IDynamicMetaObjectProvider`（IDMOP）时。虽然你可以在你用C#编写的类型上实现IDMOP，这样做很有用，但更常见的情况是你从.NET上的动态语言（如IronPython或IronRuby）中获得了一个IDMOP对象。这些语言的对象会隐式实现IDMOP，以便直接控制对它们执行的操作的含义。
- en: 'We discuss custom binders in greater detail in [Chapter 19](ch19.html#dynamic_programming),
    but for now, let’s write a simple one to demonstrate the feature:'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会在[第19章](ch19.html#dynamic_programming)中更详细地讨论自定义绑定器，但现在让我们编写一个简单的示例来演示这个功能：
- en: '[PRE308]'
  id: totrans-1044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: The `Duck` class doesn’t actually have a `Quack` method. Instead, it uses custom
    binding to intercept and interpret all method calls.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: '`Duck`类实际上没有`Quack`方法。相反，它使用自定义绑定来拦截和解释所有方法调用。'
- en: Language Binding
  id: totrans-1046
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语言绑定
- en: 'Language binding occurs when a dynamic object does not implement `IDynamic​Me⁠taObjectProvider`.
    It is useful when working around imperfectly designed types or inherent limitations
    in the .NET type system (we explore more scenarios in [Chapter 19](ch19.html#dynamic_programming)).
    A typical problem when using numeric types is that they have no common interface.
    We have seen that we can bind methods dynamically; the same is true for operators:'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 语言绑定发生在动态对象不实现`IDynamic​Me⁠taObjectProvider`时。当你在处理.NET类型系统中的不完善设计类型或固有限制时，语言绑定就非常有用（我们在[第19章](ch19.html#dynamic_programming)中探讨更多场景）。在使用数值类型时，一个典型的问题是它们没有共同的接口。我们已经看到我们可以动态绑定方法；同样适用于操作符：
- en: '[PRE309]'
  id: totrans-1048
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: The benefit is obvious—you don’t need to duplicate code for each numeric type.
    However, you lose static type safety, risking runtime exceptions rather than compile-time
    errors.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 利益显而易见——你不需要为每种数值类型重复编写代码。然而，你失去了静态类型安全性，可能面临运行时异常而不是编译时错误。
- en: Note
  id: totrans-1050
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Dynamic binding circumvents static type safety, but not runtime type safety.
    Unlike with reflection ([Chapter 18](ch18.html#reflection_and_metadata)), you
    can’t circumvent member accessibility rules with dynamic binding.
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 动态绑定绕过了静态类型安全性，但没有绕过运行时类型安全性。与反射不同（[第18章](ch18.html#reflection_and_metadata)），你不能通过动态绑定绕过成员的可访问性规则。
- en: By design, language runtime binding behaves as similarly as possible to static
    binding, had the runtime types of the dynamic objects been known at compile time.
    In our previous example, the behavior of our program would be identical if we
    hardcoded `Mean` to work with the `int` type. The most notable exception in parity
    between static and dynamic binding is for extension methods, which we discuss
    in [“Uncallable Functions”](#uncallable_functions).
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 设计上，语言运行时绑定尽可能地与静态绑定行为相似，如果动态对象的运行时类型在编译时已知的话。在我们之前的例子中，如果我们将`Mean`硬编码为与`int`类型一起工作，程序的行为将是相同的。静态和动态绑定之间最显著的不同之处在于扩展方法，我们在[“不可调用的函数”](#uncallable_functions)中讨论。
- en: Note
  id: totrans-1053
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Dynamic binding also incurs a performance hit. Because of the DLR’s caching
    mechanisms, however, repeated calls to the same dynamic expression are optimized—allowing
    you to efficiently call dynamic expressions in a loop. This optimization brings
    the typical overhead for a simple dynamic expression on today’s hardware down
    to less than 100 ns.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 动态绑定还会带来性能损耗。由于DLR的缓存机制，对同一个动态表达式的重复调用被优化——允许你在循环中高效地调用动态表达式。这种优化使得在当今硬件上对简单动态表达式的典型开销降低到不到100纳秒。
- en: RuntimeBinderException
  id: totrans-1055
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RuntimeBinderException
- en: 'If a member fails to bind, a `RuntimeBinderException` is thrown. You can think
    of this like a compile-time error at runtime:'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成员无法绑定，将抛出`RuntimeBinderException`。你可以把它看作是运行时的编译时错误：
- en: '[PRE310]'
  id: totrans-1057
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: The exception is thrown because the `int` type has no `Hello` method.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出异常是因为`int`类型没有`Hello`方法。
- en: Runtime Representation of Dynamic
  id: totrans-1059
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态的运行时表示
- en: 'There is a deep equivalence between the `dynamic` and `object` types. The runtime
    treats the following expression as `true`:'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynamic`类型与`object`类型之间存在深层次的等价性。运行时会将以下表达式视为`true`：'
- en: '[PRE311]'
  id: totrans-1061
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: 'This principle extends to constructed types and array types:'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则也适用于构造类型和数组类型：
- en: '[PRE312]'
  id: totrans-1063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: 'Like an object reference, a dynamic reference can point to an object of any
    type (except pointer types):'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 与对象引用类似，动态引用可以指向任何类型的对象（除了指针类型）：
- en: '[PRE313]'
  id: totrans-1065
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: 'Structurally, there is no difference between an object reference and a dynamic
    reference. A dynamic reference simply enables dynamic operations on the object
    it points to. You can convert from `object` to `dynamic` to perform any dynamic
    operation you want on an `object`:'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 结构上，对象引用和动态引用之间没有区别。动态引用只是允许在其指向的对象上执行动态操作。您可以从 `object` 转换为 `dynamic`，以便在 `object`
    上执行任何您想要的动态操作：
- en: '[PRE314]'
  id: totrans-1067
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: Note
  id: totrans-1068
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Reflecting on a type exposing (public) `dynamic` members reveals that those
    members are represented as annotated `object`s. For example,
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 反映公开的具有 `dynamic` 成员的类型会显示这些成员表示为带注释的 `object`。例如，
- en: '[PRE315]'
  id: totrans-1070
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: 'is equivalent to:'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于：
- en: '[PRE316]'
  id: totrans-1072
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: This allows consumers of that type to know that `Foo` should be treated as dynamic
    while allowing languages that don’t support dynamic binding to fall back to `object`.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许该类型的消费者知道 `Foo` 应该被视为动态，同时允许不支持动态绑定的语言退回到 `object`。
- en: Dynamic Conversions
  id: totrans-1074
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态转换
- en: 'The `dynamic` type has implicit conversions to and from all other types:'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynamic` 类型对所有其他类型具有隐式转换：'
- en: '[PRE317]'
  id: totrans-1076
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: For the conversion to succeed, the runtime type of the dynamic object must be
    implicitly convertible to the target static type. The preceding example worked
    because an `int` is implicitly convertible to a `long`.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 为了转换成功，动态对象的运行时类型必须隐式可转换为目标静态类型。前面的例子之所以有效，是因为 `int` 隐式可转换为 `long`。
- en: 'The following example throws a `RuntimeBinderException` because an `int` is
    not implicitly convertible to a `short`:'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例引发 `RuntimeBinderException`，因为 `int` 不是 `short` 的隐式转换类型：
- en: '[PRE318]'
  id: totrans-1079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: var Versus dynamic
  id: totrans-1080
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: var 与 dynamic 的比较
- en: 'The `var` and `dynamic` types bear a superficial resemblance, but the difference
    is deep:'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: '`var` 和 `dynamic` 类型在表面上看起来相似，但其差异深远：'
- en: '`var` says, “Let the *compiler* figure out the type.”'
  id: totrans-1082
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var` 表示：“让 *编译器* 确定类型。”'
- en: '`dynamic` says, “Let the *runtime* figure out the type.”'
  id: totrans-1083
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dynamic` 表示：“让 *运行时* 确定类型。”'
- en: 'To illustrate:'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明：
- en: '[PRE319]'
  id: totrans-1085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: 'The static type of a variable declared with `var` can be `dynamic`:'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `var` 声明的变量的静态类型可以是 `dynamic`：
- en: '[PRE320]'
  id: totrans-1087
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: Dynamic Expressions
  id: totrans-1088
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态表达式
- en: Fields, properties, methods, events, constructors, indexers, operators, and
    conversions can all be called dynamically.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 字段、属性、方法、事件、构造函数、索引器、运算符和转换都可以动态调用。
- en: 'Trying to consume the result of a dynamic expression with a `void` return type
    is prohibited—just as with a statically typed expression. The difference is that
    the error occurs at runtime:'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用具有 `void` 返回类型的动态表达式的结果是被禁止的，就像使用静态类型表达式一样。不同之处在于错误发生在运行时：
- en: '[PRE321]'
  id: totrans-1091
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: 'Expressions involving dynamic operands are typically themselves dynamic because
    the effect of absent type information is cascading:'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及动态操作数的表达式通常本身是动态的，因为缺少类型信息的影响是级联的：
- en: '[PRE322]'
  id: totrans-1093
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: 'There are a couple of obvious exceptions to this rule. First, casting a dynamic
    expression to a static type yields a static expression:'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个明显的例外情况。首先，将动态表达式转换为静态类型会产生静态表达式：
- en: '[PRE323]'
  id: totrans-1095
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: 'Second, constructor invocations always yield static expressions—even when called
    with dynamic arguments. In this example, `x` is statically typed to a `StringBuilder`:'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，构造函数调用始终产生静态表达式，即使使用动态参数调用。在此示例中，`x` 的静态类型为 `StringBuilder`：
- en: '[PRE324]'
  id: totrans-1097
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: In addition, there are a few edge cases for which an expression containing a
    dynamic argument is static, including passing an index to an array and delegate
    creation expressions.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些边缘情况，其中包含动态参数的表达式是静态的，包括向数组传递索引和委托创建表达式。
- en: Dynamic Calls Without Dynamic Receivers
  id: totrans-1099
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 没有动态接收者的动态调用
- en: 'The canonical use case for `dynamic` involves a dynamic *receiver*. This means
    that a dynamic object is the receiver of a dynamic function call:'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynamic` 的典型用例涉及动态 *接收者*。这意味着动态对象是动态函数调用的接收者：'
- en: '[PRE325]'
  id: totrans-1101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: 'However, you can also call statically known functions with dynamic arguments.
    Such calls are subject to dynamic overload resolution, and can include the following:'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您也可以使用动态参数调用静态已知函数。此类调用会受动态重载解析的影响，并可以包括以下内容：
- en: Static methods
  id: totrans-1103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态方法
- en: Instance constructors
  id: totrans-1104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例构造函数
- en: Instance methods on receivers with a statically known type
  id: totrans-1105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有静态已知类型接收者的实例方法
- en: 'In the following example, the particular `Foo` that gets dynamically bound
    is dependent on the runtime type of the dynamic argument:'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，根据动态参数的运行时类型，特定的 `Foo` 将被动态绑定：
- en: '[PRE326]'
  id: totrans-1107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: 'Because a dynamic receiver is not involved, the compiler can statically perform
    a basic check to see whether the dynamic call will succeed. It checks whether
    a function with the correct name and number of parameters exists. If no candidate
    is found, you get a compile-time error:'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 因为没有涉及动态接收器，编译器可以静态执行基本检查，以查看动态调用是否会成功。它会检查是否存在名称和参数数量正确的函数。如果没有找到候选项，您将会得到一个编译时错误：
- en: '[PRE327]'
  id: totrans-1109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: Static Types in Dynamic Expressions
  id: totrans-1110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态表达式中的静态类型
- en: 'It’s obvious that dynamic types are used in dynamic binding. It’s not so obvious
    that static types are also used—wherever possible—in dynamic binding. Consider
    the following:'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，动态类型在动态绑定中被使用。而静态类型也会在可能的情况下被使用，这一点并不那么明显。考虑以下情况：
- en: '[PRE328]'
  id: totrans-1112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: The call to `Foo(o,d)` is dynamically bound because one of its arguments, `d`,
    is `dynamic`. But because `o` is statically known, the binding—even though it
    occurs dynamically—will make use of that. In this case, overload resolution will
    pick the second implementation of `Foo` due to the static type of `o` and the
    runtime type of `d`. In other words, the compiler is “as static as it can possibly
    be.”
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`Foo(o,d)`是动态绑定的，因为它的参数`d`是`dynamic`。但是因为`o`是静态已知的，尽管它是动态发生的绑定，但会利用到它。在这种情况下，重载解析将因`o`的静态类型和`d`的运行时类型选择`Foo`的第二个实现。换句话说，编译器“尽可能静态”。
- en: Uncallable Functions
  id: totrans-1114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无法调用的函数
- en: 'Some functions cannot be called dynamically. You cannot call the following:'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 有些函数无法动态调用。您无法调用以下内容：
- en: Extension methods (via extension method syntax)
  id: totrans-1116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展方法（通过扩展方法语法）
- en: Members of an interface, if you need to cast to that interface to do so
  id: totrans-1117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要将其转换为该接口才能调用接口的成员
- en: Base members hidden by a subclass
  id: totrans-1118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类隐藏的基类成员
- en: Understanding why this is so is useful in understanding dynamic binding.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这一点对理解动态绑定非常有用。
- en: 'Dynamic binding requires two pieces of information: the name of the function
    to call and the object upon which to call the function. However, in each of the
    three uncallable scenarios, an *additional type* is involved, which is known only
    at compile time. As of this writing, there’s no way to specify these additional
    types dynamically.'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 动态绑定需要两个信息：要调用的函数的名称和要调用函数的对象。然而，在这三种无法调用的情况中，涉及一个*额外的类型*，它只在编译时知道。截至本文撰写时，没有办法动态指定这些额外类型。
- en: When calling extension methods, that additional type is implicit. It’s the static
    class on which the extension method is defined. The compiler searches for it given
    the `using` directives in your source code. This makes extension methods compile-time-only
    concepts because `using` directives melt away upon compilation (after they’ve
    done their job in the binding process in mapping simple names to namespace-qualified
    names).
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用扩展方法时，隐含了那个额外的类型。它是定义扩展方法的静态类。编译器会根据源代码中的`using`指令来搜索它。这使得扩展方法只在编译时存在，因为`using`指令在编译后就会消失（在绑定过程中将简单名称映射到命名空间限定名称后）。
- en: 'When calling members via an interface, you specify that additional type via
    an implicit or explicit cast. There are two scenarios for which you might want
    to do this: when calling explicitly implemented interface members and when calling
    interface members implemented in a type internal to another assembly. We can illustrate
    the former with the following two types:'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过接口调用成员时，您需要通过隐式或显式转换指定额外的类型。有两种情况您可能需要这样做：当显式调用接口成员和当调用另一个程序集中类型内实现的接口成员时。我们可以用以下两种类型来说明前者：
- en: '[PRE329]'
  id: totrans-1123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: 'To call the `Test` method, we must cast to the `IFoo` interface. This is easy
    with static typing:'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用`Test`方法，我们必须将其转换为`IFoo`接口。这在静态类型中很容易实现：
- en: '[PRE330]'
  id: totrans-1125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: 'Now consider the situation with dynamic typing:'
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑动态类型的情况：
- en: '[PRE331]'
  id: totrans-1127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: 'The implicit cast shown in bold tells the *compiler* to bind subsequent member
    calls on `f` to `IFoo` rather than `Foo`—in other words, to view that object through
    the lens of the `IFoo` interface. However, that lens is lost at runtime, so the
    DLR cannot complete the binding. The loss is illustrated as follows:'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 粗体显示的隐式转换告诉*编译器*将接下来对`f`的成员调用绑定到`IFoo`而不是`Foo`，换句话说，通过`IFoo`接口的视角来看待这个对象。然而，这个视角在运行时丢失了，因此
    DLR 无法完成绑定。这种丢失如下所示：
- en: '[PRE332]'
  id: totrans-1129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: 'A similar situation arises when calling a hidden base member: you must specify
    an additional type via either a cast or the `base` keyword—and that additional
    type is lost at runtime.'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用隐藏的基类成员时也会出现类似情况：您必须通过转换或`base`关键字指定一个额外的类型，并且这个额外的类型在运行时丢失了。
- en: Note
  id: totrans-1131
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Should you need to invoke interface members dynamically, a workaround is to
    use the Uncapsulator open source library, available on NuGet and GitHub. Uncapsulator
    was written by the author to address this problem, and leverages *custom binding*
    to provide a better dynamic than `dynamic`:'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要动态调用接口成员，一种解决方法是使用 Uncapsulator 开源库，该库可在 NuGet 和 GitHub 上获得。Uncapsulator
    是作者为解决此问题而编写的，并利用 *自定义绑定* 比 `dynamic` 提供更好的动态性：
- en: '[PRE333]'
  id: totrans-1133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: Uncapsulator also lets you cast to base types and interfaces by name, dynamically
    call static members, and access nonpublic members of a type.
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: Uncapsulator 还允许你通过名称将类型转换为基本类型和接口，动态调用静态成员，并访问类型的非公共成员。
- en: Operator Overloading
  id: totrans-1135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作符重载
- en: You can overload operators to provide more natural syntax for custom types.
    Operator overloading is most appropriately used for implementing custom structs
    that represent fairly primitive data types. For example, a custom numeric type
    is an excellent candidate for operator overloading.
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过重载操作符为自定义类型提供更自然的语法。操作符重载最适合用于实现代表相当原始数据类型的自定义结构体。例如，自定义数值类型非常适合进行操作符重载。
- en: 'The following symbolic operators can be overloaded:'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 可以重载以下符号操作符：
- en: '| `+` (unary) | `-` (unary) | `!` | `˜` | `++` |'
  id: totrans-1138
  prefs: []
  type: TYPE_TB
  zh: '| `+`（一元）| `-`（一元）| `!` | `˜` | `++` |'
- en: '| `--` | `+` | `-` | `*` | `/` |'
  id: totrans-1139
  prefs: []
  type: TYPE_TB
  zh: '| `--` | `+` | `-` | `*` | `/` |'
- en: '| `%` | `&` | `&#124;` | `^` | `<<` |'
  id: totrans-1140
  prefs: []
  type: TYPE_TB
  zh: '| `%` | `&` | `&#124;` | `^` | `<<` |'
- en: '| `>>` | `==` | `!=` | `>` | `<` |'
  id: totrans-1141
  prefs: []
  type: TYPE_TB
  zh: '| `>>` | `==` | `!=` | `>` | `<` |'
- en: '| `>=` | `<=` |  |  |  |'
  id: totrans-1142
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | `<=` |  |  |  |'
- en: 'The following operators are also overloadable:'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下运算符也可以进行重载：
- en: Implicit and explicit conversions (with the `implicit` and `explicit` keywords)
  id: totrans-1144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `implicit` 和 `explicit` 关键字进行隐式和显式转换
- en: The `true` and `false` *operators* (not *literals*)
  id: totrans-1145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`true` 和 `false` *操作符*（而非 *字面值*）'
- en: 'The following operators are indirectly overloaded:'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下操作符间接地进行了重载：
- en: The compound assignment operators (e.g., `+=`, `/=`) are implicitly overridden
    by overriding the noncompound operators (e.g., `+`, `/`).
  id: totrans-1147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复合赋值操作符（例如 `+=`、`/=`）由重载非复合操作符（例如 `+`、`/`）隐式重载。
- en: The conditional operators `&&` and `||` are implicitly overridden by overriding
    the bitwise operators `&` and `|`.
  id: totrans-1148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件操作符 `&&` 和 `||` 通过重载位操作符 `&` 和 `|` 隐式重载。
- en: Operator Functions
  id: totrans-1149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作符函数
- en: 'You overload an operator by declaring an *operator function*. An operator function
    has the following rules:'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 通过声明 *操作符函数* 来重载操作符。操作符函数具有以下规则：
- en: The name of the function is specified with the `operator` keyword followed by
    an operator symbol.
  id: totrans-1151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的名称由 `operator` 关键字指定，后跟操作符符号。
- en: The operator function must be marked `static` and `public`.
  id: totrans-1152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作符函数必须标记为 `static` 和 `public`。
- en: The parameters of the operator function represent the operands.
  id: totrans-1153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作符函数的参数表示操作数。
- en: The return type of an operator function represents the result of an expression.
  id: totrans-1154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作符函数的返回类型表示表达式的结果。
- en: At least one of the operands must be the type in which the operator function
    is declared.
  id: totrans-1155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作数中至少有一个操作数必须是声明操作符函数的类型。
- en: 'In the following example, we define a struct called `Note` representing a musical
    note and then overload the `+` operator:'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们定义了一个名为 `Note` 的结构体来表示音符，然后重载了 `+` 操作符：
- en: '[PRE334]'
  id: totrans-1157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: 'This overload allows us to add an `int` to a `Note`:'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 这种重载允许我们将一个 `int` 添加到一个 `Note` 中：
- en: '[PRE335]'
  id: totrans-1159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: 'Overloading an operator automatically overloads the corresponding compound
    assignment operator. In our example, because we overrode `+`, we can use `+=`,
    too:'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重载一个操作符时，相应的复合赋值操作符也会自动进行重载。例如，在我们的例子中，因为我们重载了`+`，所以我们也可以使用`+=`：
- en: '[PRE336]'
  id: totrans-1161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: 'Just as with methods and properties, C# allows operator functions comprising
    a single expression to be written more tersely with expression-bodied syntax:'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 就像方法和属性一样，C# 允许将操作符函数写得更简洁，采用表达式体语法来编写单一表达式的操作符函数：
- en: '[PRE337]'
  id: totrans-1163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: Checked operators
  id: totrans-1164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Checked 操作符
- en: 'From C# 11, when you declare an operator function, you can also declare a `checked`
    version:'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 11 开始，当你声明一个操作符函数时，还可以声明一个 `checked` 版本：
- en: '[PRE338]'
  id: totrans-1166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: 'The checked version will be called inside checked expressions or blocks:'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 checked 表达式或块中将调用 checked 版本：
- en: '[PRE339]'
  id: totrans-1168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: Overloading Equality and Comparison Operators
  id: totrans-1169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重载相等和比较操作符
- en: 'Equality and comparison operators are sometimes overridden when writing structs,
    and in rare cases when writing classes. Special rules and obligations come with
    overloading the equality and comparison operators, which we explain in [Chapter 6](ch06.html#dotnet_fundamentals).
    A summary of these rules is as follows:'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写结构时，有时会重载相等和比较运算符，在编写类时也有这种情况。重载相等和比较运算符会带来特殊的规则和义务，我们在[第6章](ch06.html#dotnet_fundamentals)中有详细解释。这些规则的摘要如下：
- en: Pairing
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 配对
- en: The C# compiler enforces operators that are logical pairs to both be defined.
    These operators are (`==` `!=`), (`<` `>`), and (`<=` `>=`).
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: C#编译器要求定义逻辑对的操作符。这些操作符是(`==` `!=`)，(`<` `>`)，以及(`<=` `>=`)。
- en: '`Equals` and `GetHashCode`'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: '`Equals`和`GetHashCode`'
- en: In most cases, if you overload (`==`) and (`!=`), you must override the `Equals`
    and `GetHashCode` methods defined on `object` in order to get meaningful behavior.
    The C# compiler will give a warning if you do not do this. (See [“Equality Comparison”](#equality_comparison-id00016)
    for more details.)
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，如果重载了(`==`)和(`!=`)，必须重写`object`中定义的`Equals`和`GetHashCode`方法才能得到有意义的行为。如果不这样做，C#编译器会发出警告。（详情见[“相等比较”](#equality_comparison-id00016)。）
- en: '`IComparable` and `IComparable<T>`'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: '`IComparable`和`IComparable<T>`'
- en: If you overload (`< >`) and (`<= >=`), you should implement `IComparable` and
    `IComparable<T>`.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果重载了(`< >`)和(`<= >=`)，应该实现`IComparable`和`IComparable<T>`。
- en: Custom Implicit and Explicit Conversions
  id: totrans-1177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义隐式和显式转换
- en: Implicit and explicit conversions are overloadable operators. These conversions
    are typically overloaded to make converting between strongly related types (such
    as numeric types) concise and natural.
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式和显式转换是可以重载的操作符。这些转换通常被重载，以使得在强相关类型（如数值类型）之间进行转换变得简洁和自然。
- en: 'To convert between weakly related types, the following strategies are more
    suitable:'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 要在弱相关类型之间进行转换，以下策略更适合：
- en: Write a constructor that has a parameter of the type to convert from.
  id: totrans-1180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个构造函数，其参数是要从中转换的类型。
- en: Write `To*XXX*` and (static) `From*XXX*` methods to convert between types.
  id: totrans-1181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写`To*XXX*`和（静态的）`From*XXX*`方法来在类型之间进行转换。
- en: As explained in the discussion on types, the rationale behind implicit conversions
    is that they are guaranteed to succeed and not lose information during the conversion.
    Conversely, an explicit conversion should be required either when runtime circumstances
    will determine whether the conversion will succeed or if information might be
    lost during the conversion.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 如类型讨论中所述，隐式转换的基本理由是它们保证成功且在转换过程中不会丢失信息。相反，显式转换应该在运行时情况决定是否转换成功或者在转换过程中可能会丢失信息时才需要。
- en: 'In this example, we define conversions between our musical `Note` type and
    a double (which represents the frequency in hertz of that note):'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了我们的音乐`Note`类型与一个表示该音符频率的double之间的转换：
- en: '[PRE340]'
  id: totrans-1184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: Note
  id: totrans-1185
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Following our own guidelines, this example might be better implemented with
    a `ToFrequency` method (and a static `FromFrequency` method) instead of implicit
    and explicit operators.
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们自己的指导方针，这个示例可能最好用一个`ToFrequency`方法（和一个静态的`FromFrequency`方法）来实现，而不是用隐式和显式操作符。
- en: Warning
  id: totrans-1187
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'Custom conversions are ignored by the `as` and `is` operators:'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义转换在`as`和`is`运算符中被忽略：
- en: '[PRE341]'
  id: totrans-1189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: Overloading true and false
  id: totrans-1190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重载true和false
- en: 'The `true` and `false` operators are overloaded in the extremely rare case
    of types that are Boolean “in spirit” but do not have a conversion to `bool`.
    An example is a type that implements three-state logic: by overloading `true`
    and `false`, such a type can work seamlessly with conditional statements and operators—namely,
    `if`, `do`, `while`, `for`, `&&`, `||`, and `?:`. The `System.Data.SqlTypes.SqlBoolean`
    struct provides this functionality:'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 在极少数情况下，如果类型在精神上是布尔型但没有转换为`bool`，则会重载`true`和`false`操作符。一个例子是实现了三态逻辑的类型：通过重载`true`和`false`，这样的类型可以与条件语句和操作符（即`if`、`do`、`while`、`for`、`&&`、`||`和`?:`）无缝配合工作。`System.Data.SqlTypes.SqlBoolean`结构提供了这种功能：
- en: '[PRE342]'
  id: totrans-1192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: 'The following code is a reimplementation of the parts of `SqlBoolean` necessary
    to demonstrate the `true` and `false` operators:'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码重新实现了展示`true`和`false`操作符所需的`SqlBoolean`部分：
- en: '[PRE343]'
  id: totrans-1194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: Static Polymorphism
  id: totrans-1195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态多态
- en: In [“Calling Static Virtual/Abstract Interface Members”](ch18.html#calling_static_virtualsolidusabstract_i),
    we introduced an advanced feature whereby an interface can define `static virtual`
    or `static abstract` members, which are then implemented as static members by
    classes and structs. Later, in [“Generic Constraints”](ch03.html#generic_constraints)
    we showed that applying an interface constraint to a type parameter gives a method
    access to that interface’s members. In this section, we’ll demonstrate how this
    enables *static polymorphism*, allowing for features such as generic math.
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“调用静态虚/抽象接口成员”](ch18.html#calling_static_virtualsolidusabstract_i)中，我们介绍了一个高级功能，即接口可以定义`static
    virtual`或`static abstract`成员，然后类和结构体通过静态成员来实现。稍后，在[“泛型约束”](ch03.html#generic_constraints)中，我们展示了将接口约束应用于类型参数，使方法能够访问该接口的成员。在本节中，我们将演示如何通过这种方式实现*静态多态性*，从而支持诸如通用数学之类的功能。
- en: 'To illustrate, consider the following interface, which defines a static method
    to create a random instance of some type `T`:'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，考虑以下接口，它定义了创建某种类型`T`的随机实例的静态方法：
- en: '[PRE344]'
  id: totrans-1198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: 'Suppose that we wish to implement this interface in the following record:'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望在以下记录中实现此接口：
- en: '[PRE345]'
  id: totrans-1200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: 'With the help of the `System.Random` class (whose `Next` method generates a
    random integer), we can implement the static `CreateRandom` method as follows:'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 借助`System.Random`类（其`Next`方法生成随机整数），我们可以如下实现静态`CreateRandom`方法：
- en: '[PRE346]'
  id: totrans-1202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: 'To call this method via the interface, we use a *constrained type parameter*.
    The following method creates an array of test data using this approach:'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过接口调用此方法，我们使用*约束类型参数*。以下方法使用这种方法创建测试数据的数组：
- en: '[PRE347]'
  id: totrans-1204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: 'This line of code demonstrates its use:'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 此行代码展示了它的使用：
- en: '[PRE348]'
  id: totrans-1206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: Our call to the static `CreateRandom` method in `CreateTestData` is *polymorphic*
    because it works not just with `Point`, but with any type that implements `ICreateRandom<T>`.
    This is different from *instance* polymorphism, because we don’t need an *instance*
    of `ICreateRandom<T>` on which to call `CreateRandom`; we call `CreateRandom`
    on the type itself.
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`CreateTestData`中对静态`CreateRandom`方法的调用是*多态*的，因为它不仅适用于`Point`，还适用于任何实现`ICreateRandom<T>`的类型。这与*实例*多态不同，因为我们不需要一个`ICreateRandom<T>`的*实例*来调用`CreateRandom`；我们直接在类型本身上调用`CreateRandom`。
- en: Polymorphic Operators
  id: totrans-1208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态运算符
- en: 'Because operators are essentially static functions (see [“Operator Overloading”](#operator_overloading)),
    operators can also be declared as static virtual interface members:'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 因为操作符本质上是静态函数（参见[“运算符重载”](#operator_overloading)），操作符也可以声明为静态虚接口成员：
- en: '[PRE349]'
  id: totrans-1210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: Note
  id: totrans-1211
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The *self-referencing* type constraint in this interface definition is necessary
    to satisfy the compiler’s rules for operator overloading. Recall that when defining
    an operator function, at least one of the operands must be the type in which the
    operator function is declared. In this example, our operands are of type `T`,
    whereas the containing type is `IAddable<T>`, so we require a self-referencing
    type constraint to allow `T` to be treated as `IAddable<T>`.
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 在此接口定义中，*自引用*类型约束对满足编译器对操作符重载的规则是必要的。回想一下，当定义一个操作符函数时，至少一个操作数必须是声明操作符函数的类型。在本例中，我们的操作数是类型`T`，而包含的类型是`IAddable<T>`，因此我们需要一个自引用类型约束，以允许将`T`视为`IAddable<T>`。
- en: 'Here’s how we can implement the interface:'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何实现接口的方法：
- en: '[PRE350]'
  id: totrans-1214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: 'With a constrained type parameter, we can then write a method that calls our
    addition operator polymorphically (with edge-case handling omitted for brevity):'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 通过约束类型参数，我们可以编写一个调用我们的加法操作符的方法（为简洁起见，省略了边缘情况处理）：
- en: '[PRE351]'
  id: totrans-1216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: Our call to the `+` operator (via the `+=` operator) is polymorphic because
    it binds to `IAddable<T>`, not `Point`. Hence, our `Sum` method works with all
    types that implement `IAddable<T>`.
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`+`操作符（通过`+=`操作符）的调用是多态的，因为它绑定到`IAddable<T>`，而不是`Point`。因此，我们的`Sum`方法适用于所有实现`IAddable<T>`的类型。
- en: 'Of course, an interface such as `IAddable<T>` would be much more useful if
    it were defined in the .NET runtime, and if all .NET numeric types implemented
    it. Fortunately, this is indeed the case from .NET 7: the `System.Numerics` namespace
    includes (a more sophisticated version of) `IAddable`, along with many other arithmetic
    interfaces—most of which are encompassed by `INumber<TSelf>`.'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果像`.NET 7`中那样在`.NET`运行时中定义`IAddable<T>`这样的接口，并且所有`.NET`数值类型都实现它，那么这样的接口将会非常有用。幸运的是，这确实是情况：`System.Numerics`命名空间包括（更复杂的版本）`IAddable`，以及许多其他算术接口，其中大多数都包含在`INumber<TSelf>`中。
- en: Generic Math
  id: totrans-1219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用数学
- en: 'Before .NET 7, code that performed arithmetic had to be hardcoded to a particular
    numeric type:'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 7 之前，执行算术运算的代码必须针对特定的数值类型进行硬编码：
- en: '[PRE352]'
  id: totrans-1221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '.NET 7 introduced the `INumber<TSelf>` interface to unify arithmetic operations
    across numeric types. This means that you can now write a generic version of the
    preceding method:'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 7 引入了`INumber<TSelf>`接口，统一了不同数值类型的算术操作。这意味着现在可以编写前述方法的通用版本：
- en: '[PRE353]'
  id: totrans-1223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '`INumber<TSelf>` is implemented by all real and integral numeric types in .NET
    (as well as `char`) and can be thought of as an umbrella interface, comprising
    other more granular interfaces for each kind of arithmetic operation (addition,
    subtraction, multiplication, division, modulus calculation, comparison, and so
    on), as well as interfaces for parsing and formatting. Here’s one such interface:'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: '`INumber<TSelf>` 在 .NET 中的所有实数和整数数值类型（以及 `char`）中都有实现，并且可以被视为一个大伞接口，包括每种算术操作（加法、减法、乘法、除法、取模运算、比较等）的更细粒度接口，以及用于解析和格式化的接口。以下是一个这样的接口示例：'
- en: '[PRE354]'
  id: totrans-1225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: 'The `static abstract +` operator is what allows the `+=` operator to work inside
    our `Sum` method. Also note the use of `static virtual` on the checked operator:
    this provides a default fallback behavior for implementors that don’t provide
    a checked version of the addition operator.'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: '`static abstract +` 操作符使得 `+=` 操作符能够在我们的 `Sum` 方法内工作。同时注意在 checked 操作符上使用 `static
    virtual`：这为不提供 checked 版本的加法操作符的实现者提供了默认的回退行为。'
- en: 'The `System.Numerics` namespace also contains interfaces that are not part
    of `INumber` for operations specific to certain kinds of numbers (such as floating-point).
    To compute a root mean square, for instance, we can add the `IRootFunctions<T>`
    interface to the constraint list to expose its static `RootN` method to `T`:'
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Numerics` 命名空间还包含一些不属于 `INumber` 的接口，用于特定类型的数值操作（如浮点数）。例如，要计算均方根，可以将
    `IRootFunctions<T>` 接口添加到约束列表中，以公开其静态的 `RootN` 方法给 `T` 使用：'
- en: '[PRE355]'
  id: totrans-1228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: Unsafe Code and Pointers
  id: totrans-1229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不安全代码与指针
- en: C# supports direct memory manipulation via pointers within blocks of code marked
    as `unsafe`. Pointer types are useful for interoperating with native APIs, for
    accessing memory outside the managed heap, and in implementing micro-optimizations
    in performance-critical hotspots.
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: C# 支持在标记为`unsafe`的代码块内通过指针直接进行内存操作。指针类型对于与本地 API 互操作、访问托管堆外内存以及在性能关键点实施微优化非常有用。
- en: Projects that include unsafe code must specify `<AllowUnsafeBlocks>true</AllowUnsafeBlocks>`
    in the project file.
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 包含不安全代码的项目必须在项目文件中指定 `<AllowUnsafeBlocks>true</AllowUnsafeBlocks>`。
- en: Pointer Basics
  id: totrans-1232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针基础知识
- en: 'For every value type or reference type *V*, there is a corresponding pointer
    type *V**. A pointer instance holds the address of a variable. Pointer types can
    be (unsafely) cast to any other pointer type. Following are the main pointer operators:'
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种值类型或引用类型 *V*，都存在相应的指针类型 *V**。指针实例保存变量的地址。指针类型可以（不安全地）转换为任何其他指针类型。以下是主要的指针操作符：
- en: '| Operator | Meaning |'
  id: totrans-1234
  prefs: []
  type: TYPE_TB
  zh: '| 操作符 | 意义 |'
- en: '| --- | --- |'
  id: totrans-1235
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `&` | The *address-of* operator returns a pointer to the address of a variable.
    |'
  id: totrans-1236
  prefs: []
  type: TYPE_TB
  zh: '| `&` | *取地址* 操作符返回一个指向变量地址的指针。 |'
- en: '| `*` | The *dereference* operator returns the variable at the address of a
    pointer. |'
  id: totrans-1237
  prefs: []
  type: TYPE_TB
  zh: '| `*` | *解引用* 操作符返回指针地址处的变量。 |'
- en: '| `->` | The *pointer-to-member* operator is a syntactic shortcut, in which
    `x->y` is equivalent to `(*x).y`. |'
  id: totrans-1238
  prefs: []
  type: TYPE_TB
  zh: '| `->` | *成员指针* 操作符是一个语法快捷方式，其中 `x->y` 等效于 `(*x).y`。 |'
- en: In keeping with C, adding (or subtracting) an integer offset to a pointer generates
    another pointer. Subtracting one pointer from another generates a 64-bit integer
    (on both 64-bit and 32-bit platforms).
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C 语言一致，将整数偏移量添加（或减去）到指针会生成另一个指针。从一个指针减去另一个指针会生成一个64位整数（无论是64位还是32位平台）。
- en: Unsafe Code
  id: totrans-1240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不安全代码
- en: 'By marking a type, type member, or statement block with the `unsafe` keyword,
    you’re permitted to use pointer types and perform C style pointer operations on
    memory within that scope. Here is an example of using pointers to quickly process
    a bitmap:'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `unsafe` 关键字标记类型、类型成员或语句块，允许在该作用域内使用指针类型并执行 C 风格的内存操作。以下是使用指针快速处理位图的示例：
- en: '[PRE356]'
  id: totrans-1242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: Unsafe code can run faster than a corresponding safe implementation. In this
    case, the code would have required a nested loop with array indexing and bounds
    checking. An unsafe C# method can also be faster than calling an external C function
    given that there is no overhead associated with leaving the managed execution
    environment.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 不安全代码可能比对应的安全实现运行更快。在这种情况下，该代码需要一个带有数组索引和边界检查的嵌套循环。不安全的 C# 方法也可以比调用外部的 C 函数更快，因为离开托管执行环境时没有相关的开销。
- en: The fixed Statement
  id: totrans-1244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 固定语句
- en: The `fixed` statement is required to pin a managed object, such as the bitmap
    in the previous example. During the execution of a program, many objects are allocated
    and deallocated from the heap. To avoid unnecessary waste or fragmentation of
    memory, the garbage collector moves objects around. Pointing to an object is futile
    if its address could change while referencing it, so the `fixed` statement tells
    the garbage collector to “pin” the object and not move it around. This can have
    an impact on the efficiency of the runtime, so you should use fixed blocks only
    briefly, and you should avoid heap allocation within the fixed block.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: '`fixed` 语句用于固定托管对象，例如前面示例中的位图。在程序执行期间，堆上分配和释放许多对象。为了避免内存的不必要浪费或碎片化，垃圾回收器会移动对象。如果指向对象的地址在引用时可能发生更改，则指向对象是没有意义的，因此
    `fixed` 语句告诉垃圾回收器“固定”对象并且不移动它。这可能会影响运行时的效率，因此应该只在需要的时候使用固定块，并且应该避免在固定块内分配堆。'
- en: Within a `fixed` statement, you can get a pointer to any value type, an array
    of value types, or a string. In the case of arrays and strings, the pointer will
    actually point to the first element, which is a value type.
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `fixed` 语句中，你可以获取任何值类型、值类型数组或字符串的指针。对于数组和字符串，指针实际上将指向第一个元素，该元素是一个值类型。
- en: 'Value types declared inline within reference types require the reference type
    to be pinned, as follows:'
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 在引用类型内声明的值类型需要进行固定，如下所示：
- en: '[PRE357]'
  id: totrans-1248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: We describe the `fixed` statement further in [“Mapping a Struct to Unmanaged
    Memory”](ch24.html#mapping_a_struct_to_unmanaged_memory).
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [“将结构映射到非托管内存”](ch24.html#mapping_a_struct_to_unmanaged_memory) 进一步描述了 `fixed`
    语句。
- en: The Pointer-to-Member Operator
  id: totrans-1250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成员指针操作符
- en: 'In addition to the `&` and `*` operators, C# also provides the C++ style `->`
    operator, which you can use on structs:'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `&` 和 `*` 操作符外，C# 还提供了类似 C++ 的 `->` 操作符，你可以在结构体上使用它：
- en: '[PRE358]'
  id: totrans-1252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: The stackalloc Keyword
  id: totrans-1253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: stackalloc 关键字
- en: 'You can allocate memory in a block on the stack explicitly by using the `stackalloc`
    keyword. Because it is allocated on the stack, its lifetime is limited to the
    execution of the method, just as with any other local variable (whose life hasn’t
    been extended by virtue of being captured by a lambda expression, iterator block,
    or asynchronous function). The block can use the `[]` operator to index into memory:'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `stackalloc` 关键字显式在堆栈上分配内存块。因为它在堆栈上分配，其生命周期仅限于方法的执行，就像任何其他局部变量一样（如果它没有被
    lambda 表达式、迭代器块或异步函数捕获，则其生命期未延长）。该块可以使用 `[]` 操作符来索引内存：
- en: '[PRE359]'
  id: totrans-1255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: 'In [Chapter 23](ch23.html#spanless_thantgreater_than_and-id00089), we describe
    how you can use `Span<T>` to manage stack-allocated memory without using the `unsafe`
    keyword:'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 23 章](ch23.html#spanless_thantgreater_than_and-id00089) 中，我们描述了如何使用 `Span<T>`
    来管理堆栈分配的内存，而不使用 `unsafe` 关键字：
- en: '[PRE360]'
  id: totrans-1257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: Fixed-Size Buffers
  id: totrans-1258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 固定大小的缓冲区
- en: 'The `fixed` keyword has another use, which is to create fixed-size buffers
    within structs (this can be useful when calling an unmanaged function; see [Chapter 24](ch24.html#native_and_com_interoperabilit)):'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: '`fixed` 关键字还有另一个用途，即在结构体内创建固定大小的缓冲区（在调用非托管函数时很有用；参见 [第 24 章](ch24.html#native_and_com_interoperabilit)）：'
- en: '[PRE361]'
  id: totrans-1260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: 'Fixed-size buffers are not arrays: if `Buffer` were an array, it would consist
    of a reference to an object stored on the (managed) heap, rather than 30 bytes
    within the struct itself.'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 固定大小的缓冲区不是数组：如果 `Buffer` 是数组，则它将由存储在（托管）堆上的对象的引用组成，而不是结构体本身的 30 个字节。
- en: 'The `fixed` keyword is also used in this example to pin the object on the heap
    that contains the buffer (which will be the instance of `UnsafeClass`). Hence,
    `fixed` means two different things: fixed in *size* and fixed in *place*. The
    two are often used together, in that a fixed-size buffer must be fixed in place
    to be used.'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: '`fixed` 关键字在本例中还用于固定包含缓冲区的堆上对象（这将是 `UnsafeClass` 的实例）。因此，`fixed` 意味着两种不同的含义：*大小*
    固定和 *位置* 固定。这两者经常一起使用，即固定大小的缓冲区必须固定在位置上才能使用。'
- en: void*
  id: totrans-1263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: void*
- en: 'A *void pointer* (`void*`) makes no assumptions about the type of the underlying
    data and is useful for functions that deal with raw memory. An implicit conversion
    exists from any pointer type to `void*`. A `void*` cannot be dereferenced, and
    arithmetic operations cannot be performed on void pointers. Here’s an example:'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: '*无类型指针*（`void*`）不对底层数据类型做任何假设，对处理原始内存的函数非常有用。任何指针类型都可以隐式转换为`void*`。不能对`void*`进行解引用，并且不能对其进行算术运算。这里有一个例子：'
- en: '[PRE362]'
  id: totrans-1265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: Native-Sized Integers
  id: totrans-1266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原生大小的整数
- en: 'The `nint` and `nuint` *native-sized* integer types (introduced in C# 9) are
    sized to match the address space of the process at runtime (in practice, 32 or
    64 bits). Native-sized integers behave like standard integers, with full support
    for arithmetic operations and overflow checking:'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: '*原生大小*的整数类型`nint`和`nuint`（在C# 9中引入）的大小与运行时进程的地址空间匹配（实际上是32位或64位）。原生大小的整数的行为类似于标准整数，完全支持算术运算和溢出检查：'
- en: '[PRE363]'
  id: totrans-1268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: Native-sized integers can be assigned 32-bit integer constants (but not 64-bit
    integer constants, because these might overflow at runtime). You can use an explicit
    cast to convert to or from other integral types.
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 原生大小的整数可以被分配为32位整数常量（但不能是64位整数常量，因为这些可能在运行时溢出）。您可以使用显式转换来转换到或从其他整数类型。
- en: You can use native-sized integers to represent memory addresses or offsets without
    the use of pointers. `nuint` is also a natural type for representing the length
    of a memory block.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用原生大小的整数来表示内存地址或偏移量，而无需使用指针。`nuint`也是表示内存块长度的自然类型。
- en: 'When working with pointers, native-sized integers can improve efficiency because
    the result of subtracting two pointers in C# is always a 64-bit integer (`long`),
    which is inefficient on 32-bit platforms. By first casting the pointers to `nint`,
    the result of a subtraction is also `nint` (which will be 32 bits on a 32-bit
    platform):'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理指针时，使用原生大小的整数可以提高效率，因为在C#中两个指针相减的结果始终是一个64位整数（`long`），这在32位平台上效率低下。通过首先将指针转换为`nint`，减法的结果也将是`nint`（在32位平台上将为32位）：
- en: '[PRE364]'
  id: totrans-1272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: Note
  id: totrans-1273
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A good example of the real-world use of `nint` and `nuint` in conjunction with
    pointers is in the implementation of `Buffer.MemoryCopy`. You can see this in
    the .NET source code for *Buffer.cs* on GitHub, or by decompiling the method in
    ILSpy. A simplified version has also been included in the LINQPad samples for
    *C# 12 in a Nutshell*.
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现`Buffer.MemoryCopy`时，结合指针使用`nint`和`nuint`的一个现实世界用例是在GitHub上的*.NET*源代码中的*Buffer.cs*，或通过在ILSpy中反编译方法。在*C#
    12 in a Nutshell*的LINQPad示例中也包含了一个简化版本。
- en: Runtime handling when targeting .NET 7+
  id: totrans-1275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行时处理在目标为.NET 7+时
- en: For projects that target .NET 7 or above, `nint` and `nuint` act as synonyms
    for the underlying .NET types `System.IntPtr` and `System.UIntPtr` (in the same
    way that `int` acts as a synonym for `System.Int32`). This works because the `IntPtr`
    and `UIntPtr` types (which have existed since .NET Framework 1.0, but with limited
    functionality) were enhanced in .NET 7 to enable full arithmetic capabilities
    and overflow checking with the C# compiler.
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 对于目标为.NET 7或更高版本的项目，`nint`和`nuint`作为底层.NET类型`System.IntPtr`和`System.UIntPtr`的同义词（就像`int`是`System.Int32`的同义词一样）。这是因为`IntPtr`和`UIntPtr`类型（自.NET
    Framework 1.0以来就存在，但功能有限）在.NET 7中得到增强，以使C#编译器具有完整的算术功能和溢出检查。
- en: Note
  id: totrans-1277
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The addition of checked arithmetic capability to `IntPtr`/`UIntPtr` is technically
    a breaking change. However, the effects are limited, because legacy code that
    relies on `IntPtr` not honoring `checked` blocks will not break when merely *run*
    under .NET 7+; to break, the project must also be *recompiled* with a .NET 7+
    target. This means that library authors need not worry about the breaking change
    until they release a new version that specifically targets .NET 7 or later.
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 向`IntPtr`/`UIntPtr`添加了检查算术能力在技术上是一种破坏性变更。但是，其影响有限，因为依赖于`IntPtr`不遵守`checked`块的遗留代码仅在仅在.NET
    7+下*运行*时不会中断；要中断，项目必须同时使用.NET 7+目标*重新编译*。这意味着库作者在发布专门针对.NET 7或更高版本的新版本之前不必担心这种破坏性变更。
- en: Runtime handling when targeting .NET 6 or below
  id: totrans-1279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行时处理在目标为.NET 6或更低版本时
- en: 'For projects that target .NET 6 or below (or .NET Standard), `nint` and `nuint`
    still use `IntPtr` and `UIntPtr` as their underlying runtime types. However, because
    the legacy `IntPtr` and `UIntPtr` types lack support for most arithmetic operations,
    the compiler fills in the gaps, making the `nint`/`nuint` types behave as they
    would in .NET 7+ (including allowing `checked` operations). You can think of an
    `nint`/`nuint` variable as an `IntPtr`/`UIntPtr` wearing a special hat. This hat
    is recognized by the compiler to mean “please treat me as a modern `IntPtr`/`UIntPtr`.”
    This hat is naturally lost should you later cast to an `IntPtr`/`UIntPtr`:'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 对于目标 .NET 6 或以下版本（或 .NET Standard）的项目，`nint` 和 `nuint` 仍然使用 `IntPtr` 和 `UIntPtr`
    作为它们的底层运行时类型。但是，由于传统的 `IntPtr` 和 `UIntPtr` 类型缺乏大多数算术操作的支持，编译器填补了这些空白，使 `nint`/`nuint`
    类型的行为与 .NET 7+ 中的行为相同（包括允许 `checked` 操作）。您可以将 `nint`/`nuint` 变量视为戴着特殊帽子的 `IntPtr`/`UIntPtr`。编译器识别此帽子以意味着“请将我视为现代的
    `IntPtr`/`UIntPtr`”。如果稍后将其强制转换为 `IntPtr`/`UIntPtr`，则自然会失去这顶帽子：
- en: '[PRE365]'
  id: totrans-1281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: Function Pointers
  id: totrans-1282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数指针
- en: A *function pointer* (from C# 9) is like a delegate, but without the indirection
    of a delegate instance; instead, it points directly to a method. A function pointer
    can point only to static methods, lacks multicast capability, and requires an
    `unsafe` context (because it bypasses runtime type safety). Its main purpose is
    to simplify and optimize interop with unmanaged APIs (see [“Callbacks from Unmanaged
    Code”](ch24.html#callbacks_from_unmanaged_code)).
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数指针*（来自 C# 9）类似于委托，但不带委托实例的间接性；而是直接指向方法。函数指针只能指向静态方法，缺少多播功能，并且需要在 `unsafe`
    上下文中（因为它绕过运行时类型安全性）。它的主要目的是简化和优化与不受管理的 API 的交互（请参阅[“来自不受管理代码的回调”](ch24.html#callbacks_from_unmanaged_code)）。'
- en: 'A function pointer type is declared as follows (with the return type appearing
    last):'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 函数指针类型声明如下（返回类型最后出现）：
- en: '[PRE366]'
  id: totrans-1285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: 'This matches a function with this signature:'
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 这与具有此签名的函数匹配：
- en: '[PRE367]'
  id: totrans-1287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: 'The `&` operator creates a function pointer from a method group. Here’s a complete
    example:'
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: '`&` 运算符从方法组创建函数指针。以下是一个完整的示例：'
- en: '[PRE368]'
  id: totrans-1289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: 'In this example, `functionPointer` is not an *object* upon which you can call
    a method such as `Invoke` (or with a reference to a `Target` object). Instead,
    it’s a variable that points directly to the target method’s address in memory:'
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`functionPointer` 不是您可以调用 `Invoke` 方法的 *对象*（或带有对 `Target` 对象的引用）。相反，它是一个变量，直接指向内存中目标方法的地址：
- en: '[PRE369]'
  id: totrans-1291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: 'Like any other pointer, it’s not subject to runtime type checking. The following
    treats our function’s return value as a `decimal` (which, being longer than an
    `int`, means that we incorporate some random memory into the output):'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他指针一样，它不受运行时类型检查的影响。以下代码将我们函数的返回值视为 `decimal`（因为比 `int` 更长，这意味着我们将一些随机内存合并到输出中）：
- en: '[PRE370]'
  id: totrans-1293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[SkipLocalsInit]'
  id: totrans-1294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[跳过局部初始化]'
- en: 'When C# compiles a method, it emits a flag that instructs the runtime to initialize
    the method’s local variables to their default values (by zeroing the memory).
    From C# 9, you can ask the compiler not to emit this flag by applying the `[Ski⁠p​LocalsI⁠nit]`
    attribute to a method (in the `System.Runtime.CompilerServices` namespace):'
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 当 C# 编译方法时，它会发出一个标志，指示运行时初始化方法的局部变量为它们的默认值（通过清零内存）。从 C# 9 开始，您可以通过将[Ski⁠p​LocalsI⁠nit]
    属性应用于方法（位于 `System.Runtime.CompilerServices` 命名空间中）来要求编译器不要发出此标志：
- en: '[PRE371]'
  id: totrans-1296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: 'You can also apply this attribute to a type—which is equivalent to applying
    it to all of the type’s methods—or even an entire module (the container for an
    assembly):'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将此属性应用于类型——相当于将其应用于类型的所有方法——甚至是整个模块（程序集的容器）：
- en: '[PRE372]'
  id: totrans-1298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: In normal safe scenarios, `[SkipLocalsInit]` has little effect on functionality
    or performance, because C#’s definite assignment policy requires that you explicitly
    assign local variables before they can be read. This means that the JIT optimizer
    is likely to emit the same machine code, whether or not the attribute is applied.
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常的安全场景中，[跳过局部初始化] 对功能或性能几乎没有影响，因为 C# 的明确赋值策略要求在读取之前必须显式赋值局部变量。这意味着 JIT 优化器很可能会发出相同的机器码，无论是否应用了该属性。
- en: 'In an unsafe context, however, use of `[SkipLocalsInit]` can usefully save
    the CLR from the overhead of initializing value-typed local variables, creating
    a small performance gain with methods that make extensive use of the stack (through
    a large `stackalloc`). The following example prints uninitialized memory when
    `[SkipLocalsInit]` is applied (instead of all zeros):'
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在不安全的上下文中，使用 `[SkipLocalsInit]` 可以有效地减少 CLR 初始化值类型本地变量的开销，在大量使用堆栈的方法（通过大量使用
    `stackalloc`）中创建小的性能收益。当应用 `[SkipLocalsInit]` 时，以下示例打印未初始化的内存（而不是全部为零）：
- en: '[PRE373]'
  id: totrans-1301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: 'Interestingly, you can achieve the same result in a “safe” context through
    the use of `Span<T>`:'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在“安全”上下文中，你可以通过使用 `Span<T>` 来达到相同的结果：
- en: '[PRE374]'
  id: totrans-1303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: Consequently, use of `[SkipLocalsInit]` requires that you compile your project
    with `<AllowUnsafeBlocks>` set to true—even if none of your methods are marked
    as `unsafe`.
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用 `[SkipLocalsInit]` 需要将项目编译设置为 `<AllowUnsafeBlocks>` 为 true——即使您的方法中没有一个标记为
    `unsafe`。
- en: Preprocessor Directives
  id: totrans-1305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预处理指令
- en: 'Preprocessor directives supply the compiler with additional information about
    regions of code. The most common preprocessor directives are the conditional directives,
    which provide a way to include or exclude regions of code from compilation:'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理指令为编译器提供有关代码区域的附加信息。最常见的预处理指令是条件指令，它们提供了一种在编译中包含或排除代码区域的方式：
- en: '[PRE375]'
  id: totrans-1307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: 'In this class, the statement in `Foo` is compiled as conditionally dependent
    upon the presence of the `DEBUG` symbol. If we remove the `DEBUG` symbol, the
    statement is not compiled. You can define preprocessor symbols within a source
    file (as we have done) or at a project level in the *.csproj* file:'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 在此类中，`Foo` 中的语句在依赖于 `DEBUG` 符号的存在时进行条件编译。如果移除 `DEBUG` 符号，则不会编译该语句。您可以在源文件内（如我们所做的）或在
    *.csproj* 文件的项目级别定义预处理符号：
- en: '[PRE376]'
  id: totrans-1309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: 'With the `#if` and `#elif` directives, you can use the `||`, `&&`, and `!`
    operators to perform *or*, *and*, and *not* operations on multiple symbols. The
    following directive instructs the compiler to include the code that follows if
    the `TESTMODE` symbol is defined and the `DEBUG` symbol is not defined:'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `#if` 和 `#elif` 指令，可以使用 `||`, `&&`, 和 `!` 运算符对多个符号进行 *或*、*与* 和 *非* 操作。以下指令指示编译器在定义
    `TESTMODE` 符号且未定义 `DEBUG` 符号时包含随后的代码：
- en: '[PRE377]'
  id: totrans-1311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: Keep in mind, however, that you’re not building an ordinary C# expression, and
    the symbols upon which you operate have absolutely no connection to *variables*—static
    or otherwise.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您并非在构建普通的 C# 表达式，而且您操作的符号与 *变量* —— 无论是静态还是其他方式的 —— 完全没有关联。
- en: The `#error` and `#warning` symbols prevent accidental misuse of conditional
    directives by making the compiler generate a warning or error given an undesirable
    set of compilation symbols. [Table 4-1](#preprocessor_directives-id00086) lists
    the preprocessor directives.
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: '`#error` 和 `#warning` 符号通过使编译器生成警告或错误来防止条件指令的意外误用，给定不良的编译符号集。[表 4-1](#preprocessor_directives-id00086)
    列出了预处理指令。'
- en: Table 4-1\. Preprocessor directives
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-1\. 预处理指令
- en: '| Preprocessor directive | Action |'
  id: totrans-1315
  prefs: []
  type: TYPE_TB
  zh: '| 预处理指令 | 动作 |'
- en: '| --- | --- |'
  id: totrans-1316
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `#define *symbol*` | Defines `*symbol*` |'
  id: totrans-1317
  prefs: []
  type: TYPE_TB
  zh: '| `#define *symbol*` | 定义 `*symbol*` |'
- en: '| `#undef *symbol*` | Undefines `*symbol*` |'
  id: totrans-1318
  prefs: []
  type: TYPE_TB
  zh: '| `#undef *symbol*` | 取消定义 `*symbol*` |'
- en: '| `#if *symbol* [*operator symbol2*]...` | `*symbol*` to test |'
  id: totrans-1319
  prefs: []
  type: TYPE_TB
  zh: '| `#if *symbol* [*operator symbol2*]...` | 要测试的 `*symbol*` |'
- en: '|  | `*operator*`s are `==`, `!=`, `&&`, and `&#124;&#124;` followed by `#else`,
    `#elif`, and `#endif` |'
  id: totrans-1320
  prefs: []
  type: TYPE_TB
  zh: '|  | `*operator*`s 包括 `==`, `!=`, `&&`, 和 `&#124;&#124;`，后跟 `#else`, `#elif`,
    和 `#endif` |'
- en: '| `#else` | Executes code to subsequent `#endif` |'
  id: totrans-1321
  prefs: []
  type: TYPE_TB
  zh: '| `#else` | 执行 `#endif` 后的代码 |'
- en: '| `#elif *symbol* [*operator symbol2*]` | Combines `#else` branch and `#if`
    test |'
  id: totrans-1322
  prefs: []
  type: TYPE_TB
  zh: '| `#elif *symbol* [*operator symbol2*]` | 结合 `#else` 分支和 `#if` 测试 |'
- en: '| `#endif` | Ends conditional directives |'
  id: totrans-1323
  prefs: []
  type: TYPE_TB
  zh: '| `#endif` | 结束条件指令 |'
- en: '| `#warning *text*` | `*text*` of the warning to appear in compiler output
    |'
  id: totrans-1324
  prefs: []
  type: TYPE_TB
  zh: '| `#warning *text*` | 编译器输出的警告 `*text*` |'
- en: '| `#error *text*` | `*text*` of the error to appear in compiler output |'
  id: totrans-1325
  prefs: []
  type: TYPE_TB
  zh: '| `#error *text*` | 编译器输出的错误 `*text*` |'
- en: '| `#error version` | Reports the compiler version and exits |'
  id: totrans-1326
  prefs: []
  type: TYPE_TB
  zh: '| `#error version` | 报告编译器版本并退出 |'
- en: '| `#pragma warning [disable &#124; restore]` | Disables/restores compiler warning(s)
    |'
  id: totrans-1327
  prefs: []
  type: TYPE_TB
  zh: '| `#pragma warning [disable &#124; restore]` | 禁用/恢复编译器警告 |'
- en: '| `#line [ *number* ["*file*"] &#124; hidden]` | `*number*` specifies the line
    in source code (a column can also be specified from C# 10); `*file*` is the filename
    to appear in computer output; `hidden` instructs debuggers to skip over code from
    this point until the next `#line` directive |'
  id: totrans-1328
  prefs: []
  type: TYPE_TB
  zh: '| `#line [ *number* ["*file*"] &#124; hidden]` | `*number*` 指定源代码中的行（从 C# 10
    开始也可以指定列）；`*file*` 是计算机输出中显示的文件名；`hidden` 指示调试器跳过从此处到下一个 `#line` 指令的代码 |'
- en: '| `#region *name*` | Marks the beginning of an outline |'
  id: totrans-1329
  prefs: []
  type: TYPE_TB
  zh: '| `#region *name*` | 标记大纲的开始位置 |'
- en: '| `#endregion` | Ends an outline region |'
  id: totrans-1330
  prefs: []
  type: TYPE_TB
  zh: '| `#endregion` | 结束大纲区域 |'
- en: '| `#nullable *option*` | See [“Nullable reference types”](ch01.html#nullable_reference_types-id00030)
    |'
  id: totrans-1331
  prefs: []
  type: TYPE_TB
  zh: '| `#nullable *option*` | 参见 [“可空引用类型”](ch01.html#nullable_reference_types-id00030)
    |'
- en: Conditional Attributes
  id: totrans-1332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件特性
- en: 'An attribute decorated with the `Conditional` attribute will be compiled only
    if a given preprocessor symbol is present:'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Conditional` 属性修饰的特性仅在给定预处理器符号存在时才会被编译：
- en: '[PRE378]'
  id: totrans-1334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: The compiler will incorporate the `[Test]` attributes only if the `DEBUG` symbol
    is in scope for *file2.cs*.
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器仅在 `DEBUG` 符号适用于 *file2.cs* 时才会包含 `[Test]` 特性。
- en: Pragma Warning
  id: totrans-1336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pragma Warning
- en: The compiler generates a warning when it spots something in your code that seems
    unintentional. Unlike errors, warnings don’t ordinarily prevent your application
    from compiling.
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器在发现代码中出现看似不经意的内容时会生成警告。与错误不同，警告通常不会阻止应用程序编译。
- en: Compiler warnings can be extremely valuable in spotting bugs. Their usefulness,
    however, is undermined when you get *false* warnings. In a large application,
    maintaining a good signal-to-noise ratio is essential if the “real” warnings are
    to be noticed.
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器警告在发现 bug 时非常有价值。然而，当你遇到*假*警告时，它们的实用性就会受到影响。在大型应用程序中，保持良好的信噪比是非常重要的，这样才能注意到“真正”的警告。
- en: 'To this effect, the compiler allows you to selectively suppress warnings by
    using the `#pragma warning` directive. In this example, we instruct the compiler
    not to warn us about the field `Message` not being used:'
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，编译器允许您通过使用 `#pragma warning` 指令有选择地抑制警告。在此示例中，我们指示编译器不要警告我们未使用的 `Message`
    字段：
- en: '[PRE379]'
  id: totrans-1340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: Omitting the number in the `#pragma warning` directive disables or restores
    all warning codes.
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: 在`#pragma warning`指令中省略数字会禁用或恢复所有警告代码。
- en: If you are thorough in applying this directive, you can compile with the `/warnaserror`
    switch—this instructs the compiler to treat any residual warnings as errors.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在应用此指令时很彻底，可以使用 `/warnaserror` 开关进行编译 —— 这会指示编译器将任何剩余的警告视为错误。
- en: XML Documentation
  id: totrans-1343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XML 文档
- en: 'A *documentation comment* is a piece of embedded XML that documents a type
    or member. A documentation comment comes immediately before a type or member declaration
    and starts with three slashes:'
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: '*文档注释*是嵌入的 XML 片段，用于记录类型或成员。文档注释紧跟在类型或成员声明之前，并以三个斜杠开头：'
- en: '[PRE380]'
  id: totrans-1345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: 'Multiline comments can be done like this:'
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: 可以这样编写多行注释：
- en: '[PRE381]'
  id: totrans-1347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: 'Or like this (notice the extra star at the start):'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 或者像这样（注意开头的额外星号）：
- en: '[PRE382]'
  id: totrans-1349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: 'If you add the following option to your *.csproj* file:'
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 *.csproj* 文件中添加以下选项：
- en: '[PRE383]'
  id: totrans-1351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: 'the compiler extracts and collates documentation comments into the specified
    XML file. This has two main uses:'
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会提取和整理文档注释到指定的 XML 文件中。这有两个主要用途：
- en: If placed in the same folder as the compiled assembly, tools such as Visual
    Studio and LINQPad automatically read the XML file and use the information to
    provide IntelliSense member listings to consumers of the assembly of the same
    name.
  id: totrans-1353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果放置在与编译后程序集相同的文件夹中，像 Visual Studio 和 LINQPad 这样的工具会自动读取 XML 文件，并使用其中的信息为同名程序集的消费者提供
    IntelliSense 成员列表。
- en: Third-party tools (such as Sandcastle and NDoc) can transform the XML file into
    an HTML help file.
  id: totrans-1354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方工具（如 Sandcastle 和 NDoc）可以将 XML 文件转换为 HTML 帮助文件。
- en: Standard XML Documentation Tags
  id: totrans-1355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准 XML 文档标签
- en: 'Here are the standard XML tags that Visual Studio and documentation generators
    recognize:'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 Visual Studio 和文档生成器识别的标准 XML 标签：
- en: '`<summary>`'
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: '`<summary>`'
- en: '[PRE384]'
  id: totrans-1358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: Indicates the tool tip that IntelliSense should display for the type or member;
    typically a single phrase or sentence.
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 指示 IntelliSense 应显示给类型或成员的工具提示；通常是单个短语或句子。
- en: '`<remarks>`'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: '`<remarks>`'
- en: '[PRE385]'
  id: totrans-1361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: Additional text that describes the type or member. Documentation generators
    pick this up and merge it into the bulk of a type or member’s description.
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 描述类型或成员的额外文本。文档生成器会将其获取并合并到类型或成员描述的主体中。
- en: '`<param>`'
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: '`<param>`'
- en: '[PRE386]'
  id: totrans-1364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: Explains a parameter on a method.
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 解释方法的参数。
- en: '`<returns>`'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: '`<returns>`'
- en: '[PRE387]'
  id: totrans-1367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: Explains the return value for a method.
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 解释方法的返回值。
- en: '`<exception>`'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: '`<exception>`'
- en: '[PRE388]'
  id: totrans-1370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: Lists an exception that a method can throw (`cref` refers to the exception type).
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 列出方法可能引发的异常（`cref` 引用异常类型）。
- en: '`<example>`'
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: '`<example>`'
- en: '[PRE389]'
  id: totrans-1373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: Denotes an example (used by documentation generators). This usually contains
    both description text and source code (source code is typically within a `<c>`
    or `<code>` tag).
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 表示示例（由文档生成器使用）。这通常包含描述文本和源代码（源代码通常在 `<c>` 或 `<code>` 标签内）。
- en: '`<c>`'
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: '`<c>`'
- en: '[PRE390]'
  id: totrans-1376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: Indicates an inline code snippet. This tag is usually used within an `<example>`
    block.
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 指示内联代码片段。此标签通常在 `<example>` 块内使用。
- en: '`<code>`'
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: '`<code>`'
- en: '[PRE391]'
  id: totrans-1379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: Indicates a multiline code sample. This tag is usually used within an `<example>`
    block.
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 表示一个多行代码示例。此标签通常在`<example>`块内使用。
- en: '`<see>`'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: '`<see>`'
- en: '[PRE392]'
  id: totrans-1382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: Inserts an inline cross-reference to another type or member. HTML documentation
    generators typically convert this to a hyperlink. The compiler emits a warning
    if the type or member name is invalid. To refer to generic types, use curly braces;
    for example, `cref="Foo{T,U}"`.
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 插入对另一个类型或成员的内联交叉引用。HTML 文档生成器通常会将其转换为超链接。如果类型或成员名称无效，编译器会发出警告。要引用泛型类型，请使用花括号；例如，`cref="Foo{T,U}"`。
- en: '`<seealso>`'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: '`<seealso>`'
- en: '[PRE393]'
  id: totrans-1385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: Cross-references another type or member. Documentation generators typically
    write this into a separate “See Also” section at the bottom of the page.
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉引用另一个类型或成员。文档生成器通常会将其写入页面底部的单独的“参见”部分。
- en: '`<paramref>`'
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: '`<paramref>`'
- en: '[PRE394]'
  id: totrans-1388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: References a parameter from within a `<summary>` or `<remarks>` tag.
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `<summary>` 或 `<remarks>` 标签内引用参数。
- en: '`<list>`'
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: '`<list>`'
- en: '[PRE395]'
  id: totrans-1391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: Instructs documentation generators to emit a bulleted, numbered, or table-style
    list.
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 指示文档生成器生成项目符号、编号或表格样式列表。
- en: '`<para>`'
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: '`<para>`'
- en: '[PRE396]'
  id: totrans-1394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: Instructs documentation generators to format the contents into a separate paragraph.
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 指示文档生成器将内容格式化为单独的段落。
- en: '`<include>`'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: '`<include>`'
- en: '[PRE397]'
  id: totrans-1397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: Merges an external XML file that contains documentation. The path attribute
    denotes an XPath query to a specific element in that file.
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 合并包含文档的外部 XML 文件。路径属性表示对该文件中特定元素的 XPath 查询。
- en: User-Defined Tags
  id: totrans-1399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户定义的标签
- en: Little is special about the predefined XML tags recognized by the C# compiler,
    and you are free to define your own. The only special processing done by the compiler
    is on the `<param>` tag (in which it verifies the parameter name and that all
    the parameters on the method are documented) and the `cref` attribute (in which
    it verifies that the attribute refers to a real type or member and expands it
    to a fully qualified type or member ID). You can also use the `cref` attribute
    in your own tags; it is verified and expanded just as it is in the predefined
    `<exception>`, `<permission>`, `<see>`, and `<seealso>` tags.
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: C# 编译器识别的预定义 XML 标签没有特别之处，您可以自由定义自己的标签。编译器唯一特别处理的是 `<param>` 标签（其中验证参数名称及方法的所有参数是否都已文档化）和
    `cref` 属性（验证属性是否指向真实类型或成员，并将其扩展为完全限定的类型或成员 ID）。您也可以在自定义标签中使用 `cref` 属性；编译器会像在预定义的
    `<exception>`、`<permission>`、`<see>` 和 `<seealso>` 标签中一样验证和扩展它。
- en: Type or Member Cross-References
  id: totrans-1401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型或成员的交叉引用
- en: 'Type names and type or member cross-references are translated into IDs that
    uniquely define the type or member. These names are composed of a prefix that
    defines what the ID represents and a signature of the type or member. Following
    are the member prefixes:'
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 类型名称和类型或成员的交叉引用被翻译为唯一定义类型或成员的 ID。这些名称由定义 ID 表示的前缀和类型或成员的签名组成。以下是成员前缀：
- en: '| XML type prefix | ID prefixes applied to… |'
  id: totrans-1403
  prefs: []
  type: TYPE_TB
  zh: '| XML 类型前缀 | 应用于... 的 ID 前缀 |'
- en: '| --- | --- |'
  id: totrans-1404
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `N` | Namespace |'
  id: totrans-1405
  prefs: []
  type: TYPE_TB
  zh: '| `N` | 命名空间 |'
- en: '| `T` | Type (class, struct, enum, interface, delegate) |'
  id: totrans-1406
  prefs: []
  type: TYPE_TB
  zh: '| `T` | 类型（类、结构体、枚举、接口、委托） |'
- en: '| `F` | Field |'
  id: totrans-1407
  prefs: []
  type: TYPE_TB
  zh: '| `F` | 字段 |'
- en: '| `P` | Property (includes indexers) |'
  id: totrans-1408
  prefs: []
  type: TYPE_TB
  zh: '| `P` | 属性（包括索引器） |'
- en: '| `M` | Method (includes special methods) |'
  id: totrans-1409
  prefs: []
  type: TYPE_TB
  zh: '| `M` | 方法（包括特殊方法） |'
- en: '| `E` | Event |'
  id: totrans-1410
  prefs: []
  type: TYPE_TB
  zh: '| `E` | 事件 |'
- en: '| `!` | Error |'
  id: totrans-1411
  prefs: []
  type: TYPE_TB
  zh: '| `!` | 错误 |'
- en: The rules describing how the signatures are generated are well documented, although
    fairly complex.
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 描述如何生成签名的规则已经有详细文档，尽管相当复杂。
- en: 'Here is an example of a type and the IDs that are generated:'
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是类型和生成的 ID 的示例：
- en: '[PRE398]**'
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE398]**'
