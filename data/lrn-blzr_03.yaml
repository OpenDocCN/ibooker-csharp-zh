- en: Chapter 2\. Executing the App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章。执行应用程序
- en: In this chapter, you’ll learn how a Blazor WebAssembly app starts executing—from
    the rendering of static HTML to the invocation of JavaScript that bootstraps Blazor,
    you’ll be exploring the anatomy of the app. This includes the `Program` entry
    point and the startup conventions. You’ll learn about the router, client-side
    navigation, shared components, and layouts. You’ll also learn about top-level
    navigation and custom components in the app. All of this will be taught using
    the Learning Blazor sample application’s source code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习 Blazor WebAssembly 应用程序的启动执行过程——从静态 HTML 的渲染到调用引导 Blazor 的 JavaScript，你将探索应用程序的解剖结构。这包括
    `Program` 入口点和启动约定。你将了解路由器、客户端导航、共享组件和布局。你还将学习应用程序中的顶级导航和自定义组件。所有这些都将通过 Learning
    Blazor 示例应用程序的源代码进行讲解。
- en: Try to embrace the mindset that you’re onboarding as a new developer to an existing
    application—much like you would in the real world. Try to imagine that you’re
    starting a new journey, where you’re getting brought up to speed on an existing
    codebase. The idea is that I’ll be your mentor; I’ll meticulously walk through
    the code, presenting it to you and explaining exactly what it’s doing and how
    it’s doing it. You’ll learn why certain decisions were made and what alternative
    approaches should be considered. You should have a grasp of how the model app
    works and will be prepared to work with it in future chapters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试拥抱作为新开发者加入现有应用程序的心态——就像在现实世界中一样。设想你正在开始一个新的旅程，在这个旅程中，你将迅速了解现有代码库。我的角色是你的导师；我将仔细地遍历代码，向你展示并解释它正在做什么及如何做到这一点。你将了解到为什么做出了某些决策以及应该考虑哪些替代方法。你应该掌握这个模型应用程序的工作原理，并准备在未来的章节中使用它。
- en: In the previous chapter, you learned a bit about the web app development platform,
    the ASP.NET Core as a framework, open source development, the programming languages
    of the web, and development environments Now let’s talk code. As Linus Torvalds,
    the creator of Linux, said, “Talk is cheap. Show me the code.” The model app is
    the basis for the entire book, where you’ll learn how all of the major features
    of Blazor work and how to use other amazing features. We’ll look at the code together,
    and you’ll get to read the code and let it tell you its own story. In the next
    few sections, you’ll learn how the Blazor framework initializes the app and how
    the app starts executing. I suggest you check out [*https://webassemblyof.net*](https://webassemblyof.net)
    to see what the final web app looks like. Feel free to click around and try out
    the various features to familiarize yourself with the app.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学到了一些关于 Web 应用开发平台 ASP.NET Core 的知识，作为一个框架、开源开发、Web 的编程语言以及开发环境。现在让我们来谈谈代码。正如
    Linux 的创建者 Linus Torvalds 所说，“谈话很廉价。给我看代码。”这个模型应用程序是整本书的基础，你将学习 Blazor 的所有主要功能以及如何使用其他令人惊叹的特性。我们将一起查看代码，你将阅读代码并让它告诉你它自己的故事。在接下来的几节中，你将学习
    Blazor 框架如何初始化应用程序以及应用程序如何开始执行。建议你访问 [*https://webassemblyof.net*](https://webassemblyof.net)
    查看最终的 Web 应用程序是什么样子。随意点击并尝试各种功能，以熟悉应用程序。
- en: Requesting the Initial Page
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求初始页面
- en: Let’s start by evaluating what happens when a client browser wants to access
    our application. It requests the initial page (given its URL), and HTML is returned
    from the server. Within the HTML itself, there are `<link>` and `<script>` elements.
    These define additional references to resources that our Blazor application needs
    to start accepting user input with components rendered from the Blazor markup.
    The resources include, but are not limited to, CSS, JavaScript, images, Wasm files,
    and .NET dynamic-link libraries (.dlls). These additional resources are requested
    as part of the initial page load, and while this is happening there can be no
    interaction with the app. Depending on the size of the peripheral resources and
    the connection speed of the client, the amount of time it takes for the app to
    become interactive will vary.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从评估客户端浏览器访问我们应用程序时发生的情况开始。它请求初始页面（根据其 URL），服务器返回 HTML。在 HTML 中，有 `<link>`
    和 `<script>` 元素。这些定义了我们的 Blazor 应用程序启动时需要的额外资源的引用。这些资源包括但不限于 CSS、JavaScript、图像、Wasm
    文件和 .NET 动态链接库（.dll 文件）。这些额外的资源会作为初始页面加载的一部分被请求，这时无法与应用程序进行交互。根据外围资源的大小和客户端的连接速度，应用程序变得交互的时间会有所不同。
- en: The *Time to Interactive* (TTI) is a measurement of the amount of time it takes
    before a website is ready to accept user input. One of the trade-offs of using
    Blazor WebAssembly is that the initial load time of the app is a bit longer than
    that of Blazor Server. The app has to be downloaded to the browser before running,
    whereas with Blazor Server the app is rendered dynamically on the web host. This
    requires the .NET runtime and a configured web server.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 交互时间（TTI）是网站准备接受用户输入之前所需的时间的测量。使用 Blazor WebAssembly 的一个权衡是应用程序的初始加载时间比 Blazor
    Server 的要长一些。应用程序必须在运行之前下载到浏览器中，而在 Blazor Server 中，应用程序是动态呈现在 Web 主机上的。这需要 .NET
    运行时和配置的 Web 服务器。
- en: Tip
  id: totrans-7
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: One advantage of using Blazor WebAssembly is that the app can be hosted as a
    static web app. Serving static files is much faster and less error-prone than
    serving dynamic content. But it does come at a cost. The app will be downloaded
    to the client browser, and the client browser will have to download the entire
    app. This can be a large download, and it can be a bit slower than the app running
    on the server.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Blazor WebAssembly 的一个优势是应用可以作为静态 Web 应用程序托管。提供静态文件比提供动态内容要快得多，也更不容易出错。但这是有代价的。应用将被下载到客户端浏览器，并且客户端浏览器将不得不下载整个应用。这可能是一个很大的下载量，并且可能比在服务器上运行的应用慢一些。
- en: The TTI for Blazor WebAssembly can be a bit longer than that of Blazor Server.
    Hypothetically, if the TTI is more than a few seconds, users will expect some
    sort of visual indication, such as an animated spinning gear cog to show that
    the app is loading.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor WebAssembly 的 TTI 可能比 Blazor Server 的要长一些。假设，如果 TTI 超过几秒钟，用户会期望某种视觉指示，比如一个动画旋转的齿轮来显示应用正在加载。
- en: With Blazor WebAssembly, you can *lazy load* full .NET assemblies. This is much
    like doing the equivalent thing in JavaScript—where various components are represented
    by JavaScript—but instead we get to use C#. This feature can make your application
    more efficient by fetching only the dependent assembly on demand and when needed.
    Before showing you how to lazy load assemblies, however, you’ll learn how the
    Blazor WebAssembly application startup loads assemblies.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Blazor WebAssembly，您可以*延迟加载*完整的 .NET 程序集。这很像在 JavaScript 中做等效的事情——各种组件由 JavaScript
    表示——但我们可以使用 C#。这个功能可以通过仅在需要时按需获取依赖程序集来使您的应用程序更有效。然而，在向您展示如何延迟加载程序集之前，您将学习 Blazor
    WebAssembly 应用程序启动如何加载程序集。
- en: Let’s start by examining the parts of the initial page’s HTML content.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从检查初始页面的 HTML 内容的部分开始。
- en: App Startup and Bootstrapping
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序启动和引导
- en: 'The following HTML is served to the client, and it’s important to understand
    what the client browser will do when it renders it. Let’s jump in and take a look
    at the *wwwroot/index.html* file from the Web.Client project. I know it’s a lot,
    but read through it first, and we’ll go through it piece-by-piece after:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 HTML 被提供给客户端，了解客户端浏览器在呈现时会做什么很重要。让我们跳进来看看 Web.Client 项目中的 *wwwroot/index.html*
    文件。我知道这很多，但先阅读一遍，然后我们会逐步解释它：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s break down each of the primary sections. We’ll start with reading through
    the `<head>` tag’s child elements:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个解释每个主要部分。我们将从阅读`<head>`标签的子元素开始：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The app uses the web standard UTF-8 character set, and there’s also a `viewport`
    specification, both of which are very common `<meta>` tags in HTML. We set the
    initial `<title>` of the page to `"Learning Blazor"`. After the title is a set
    of `<link>` elements. If you spend time evaluating alternative options to the
    default Bootstrap CSS from the template, you may consider a CSS framework that
    takes zero JavaScript dependencies.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序使用 Web 标准 UTF-8 字符集，并且还有一个`viewport`规范，这两者都是 HTML 中非常常见的`<meta>`标签。我们将页面的初始`<title>`设置为`"学习
    Blazor"`。标题后是一组`<link>`元素。如果您花时间评估模板中默认的 Bootstrap CSS 的替代选项，您可能会考虑一个不依赖 JavaScript
    的 CSS 框架。
- en: In this instance, Bulma was chosen as the CSS framework because it’s amazingly
    simple and clean. This is a perfect match for Blazor, as we can use C# instead
    of JavaScript to change styles at will. As described in [the Bulma documentation](https://oreil.ly/kstH3),
    “Bulma is a CSS library. This means it provides CSS classes to help you style
    your HTML code. To use Bulma, you can either use the pre-compiled *.css* file
    or install the *.sass* files so you can customize it to your needs.” Bulma provides
    everything needed to style the website; with extensibility in mind, you have modern
    utilities, helpers, elements, components, forms, and layout styles. Bulma also
    has a huge developer community following, where extensions are shared. These additional
    CSS packages depend on Bulma itself; they just override or extend existing class
    definitions. This is the same approach in any web app development and is not unique
    to Blazor.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，选择了 Bulma 作为 CSS 框架，因为它非常简单且干净。这与 Blazor 完美匹配，因为我们可以使用 C# 而不是 JavaScript
    随意更改样式。正如 [Bulma 文档](https://oreil.ly/kstH3) 中所述，“Bulma 是一个 CSS 库。这意味着它提供了 CSS
    类来帮助您样式化 HTML 代码。要使用 Bulma，您可以使用预编译的 *.css* 文件或安装 *.sass* 文件，以便根据需要自定义。” Bulma
    提供了所有需要的内容来样式化网站；考虑到可扩展性，它具有现代实用程序、助手、元素、组件、表单和布局样式。Bulma 还拥有庞大的开发者社区追随者，分享扩展内容。这些额外的
    CSS 包依赖于 Bulma 本身；它们只是覆盖或扩展现有的类定义。这与任何 Web 应用开发中的方法相同，不仅适用于 Blazor。
- en: 'When we see a `<link>` element that has a `rel` attribute set to `"preload"`,
    it indicates that these requests will happen asynchronously. This works by adding
    the `as="style" onload="this.rel=''stylesheet''"` attributes. This lets the browser
    know that the `<link>` is for a style sheet. It will also eventually load the
    resource, and when it does it will set `rel` to `"stylesheet"`. Let’s think of
    this as the *hot-swap on load tactic*. We will pull in some additional CSS references
    for sliders, quick views, tooltips, and media-query-centric `@media (prefers-color-scheme:
    dark) { /* styles */ }` functionality. This exposes the ability to detect the
    client’s preferred color scheme and apply the appropriate styles. For example,
    an alternative color scheme to the default `white` is `dark`. These two color
    schemes account for the majority of all web user experiences.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们看到 `<link>` 元素的 `rel` 属性设置为 `"preload"` 时，表示这些请求将异步进行。这是通过添加 `as="style"
    onload="this.rel=''stylesheet''"` 属性实现的。这让浏览器知道 `<link>` 是用于样式表的。它最终会加载资源，并在加载时将
    `rel` 设置为 `"stylesheet"`。我们可以将其视为 *加载时热替换策略*。我们将引入一些额外的 CSS 引用，用于滑块、快速视图、工具提示以及媒体查询中心的
    `@media (prefers-color-scheme: dark) { /* styles */ }` 功能。这暴露了检测客户端首选颜色方案并应用适当样式的能力。例如，与默认的
    `white` 相比，另一种颜色方案是 `dark`。这两种颜色方案涵盖了大多数 Web 用户体验。'
- en: We then define another `<link>` with an `href` to the */css/app.css* path to
    the web server.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义另一个 `<link>`，其 `href` 是到 Web 服务器上 */css/app.css* 路径的。
- en: The important styles from Bulma are not using the *hot-swap on load tactic*.
    While the app is loading, it’s styled appropriately to communicate that the app
    is working (see [Figure 2-1](#blazor_webassembly_loading)). The app also preemptively
    declares `<link rel="manifest" href="/​man⁠ifest.json" />` with the corresponding
    `<link>` icons. This is specifically to expose icons and the PWA capabilities.
    Per MDN’s [HTML reference guide](https://oreil.ly/X62KY), “the HTML < base> element
    specifies the base URL to use for all relative URLs in a document. There can be
    only one `<base>` element in a document.”
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Bulma 中的重要样式没有使用 *加载时热替换策略*。在应用程序加载时，它会适当地进行样式设置，以传达应用程序正在工作的信息（见 [图2-1](#blazor_webassembly_loading)）
    。应用程序还预先声明了 `<link rel="manifest" href="/​man⁠ifest.json" />`，并附带相应的 `<link>`
    图标。这是为了显露图标和 PWA 的能力。根据 MDN 的 [HTML 参考指南](https://oreil.ly/X62KY)，“HTML `<base>`
    元素指定文档中所有相对 URL 使用的基础 URL。文档中只能有一个 `<base>` 元素。”
- en: 'All applications should consider the usage of iconography where possible to
    make for a more accessible web experience. Icons, when done correctly, can immediately
    convey a message and intent, and often with little text. I proudly use Font Awesome;
    they have a free offering and provide seamless integration of it wherever it is
    needed in Blazor markup. A `<script>` points to my Font Awesome kit registered
    to my app. The next line, immediately following the Font Awesome source, is the
    application’s JavaScript bits. There are three primary areas of focus in web app
    development, each within the */js*, */css*, and */_content* directories. After
    familiarizing yourself with the child elements of the `<head>` node, we can move
    on. Next, we’ll take a look at the content of the `<body>` nodes:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，所有应用程序都应考虑使用图标来提供更易访问的网络体验。正确使用图标可以立即传达信息和意图，通常只需很少的文本。我自豪地使用 Font Awesome；它们提供免费的服务，并可以在
    Blazor 标记中无缝集成。一个`<script>`指向我 Font Awesome 的套件已经注册到我的应用。紧随 Font Awesome 源之后的下一行是应用程序的
    JavaScript 部分。Web 应用程序开发的三个主要关注点分别位于 */js*、*/css* 和 */_content* 目录中。在熟悉了 `<head>`
    节点的子元素之后，我们可以继续。接下来，我们将查看 `<body>` 节点的内容：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The first tag in the `<body>` element is `<div id="app">...</div>`. This is
    the root of the Blazor application, the true SPA. It is very important to understand
    that the contents of this target element will be automatically and dynamically
    changed to represent the Wasm application’s manipulation of the DOM. Most SPA
    developers settle with letting the UX be a giant white wall of `10pt` default
    font with black text that reads “Loading…” It’s not okay for UX. Ideally, we’d
    want to provide visual cues to the user that the application is responsive and
    loading. One approach to achieve this is to have a `<div>` initially represent
    a basic splash screen. In this case, the model app will include the Blazor logo
    image and a message that reads `"Blazor WebAssembly: Loading..."` It will also
    show an animated loading spinner icon.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`<body>` 元素中的第一个标签是 `<div id="app">...</div>`。这是 Blazor 应用程序的根，真正的单页应用程序。非常重要的一点是理解，此目标元素的内容将自动和动态地更改以表示
    Wasm 应用程序对 DOM 的操作。大多数单页应用程序开发者会让用户体验成为一个巨大的白色墙壁，使用默认字体大小为`10pt`，黑色文本显示“加载中……”。这种用户体验是不可接受的。理想情况下，我们希望向用户提供视觉提示，表明应用程序正在响应和加载中。一种方法是让一个
    `<div>` 最初代表一个基本的闪屏屏幕。在这种情况下，模型应用程序将包括 Blazor 标志图像和一个消息，显示为`"Blazor WebAssembly:
    Loading..."`，还会显示一个动画加载旋转图标。'
- en: '`<section id="splash">...</section>` acts as the loading markup. It will be
    replaced when Blazor is ready. This markup is not Blazor but rather HTML and CSS.
    This markup will render similarly to that shown in [Figure 2-1](#blazor_webassembly_loading).
    Without this markup, the default loading experience has black text and says “Loading.”
    This gives you the ability to customize the splash (or loading) screen UX.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`<section id="splash">...</section>` 作为加载标记的功能。当 Blazor 准备就绪时，它将被替换。这个标记不是
    Blazor，而是 HTML 和 CSS。这个标记将类似于[图 2-1](#blazor_webassembly_loading)中显示的内容。如果没有这个标记，默认的加载体验将会是黑色文本并显示“加载中”。这使您能够自定义闪屏（或加载）屏幕的用户体验。'
- en: Tip
  id: totrans-26
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: When writing your Blazor apps, you should consider adding a loading indicator
    to your application. This is a great way to give users a sense of progress and
    avoid a “white screen of death” when the application is first loaded.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写 Blazor 应用程序时，您应考虑向应用程序添加加载指示器。这是一种很好的方法，可以让用户感知到进度，并在应用程序首次加载时避免“白屏死机”的现象。
- en: '![](assets/lblz_0201.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lblz_0201.png)'
- en: Figure 2-1\. An indicator lets the user know the app is loading
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-1\. 指示器让用户知道应用程序正在加载中
- en: In the *index.html* file, following the *app* node, there lies the “blazor-error-ui”
    `<div>` element. This is adjusted from the template to be a bit more suited to
    our app’s styling. This specific element identifier will be used by Blazor when
    it’s bootstrapping itself into the driver seat. If there are any unrecoverable
    errors, it will show this element. If all goes well, you shouldn’t see this.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *index.html* 文件中，跟随 *app* 节点之后，有一个“blazor-error-ui” `<div>` 元素。这与模板不同，适合我们应用程序的样式。当
    Blazor 自己启动时，此特定元素标识符将被使用。如果有任何无法恢复的错误，它将显示此元素。如果一切顺利，您不应该看到此元素。
- en: 'After the error element are a few remaining `<script>` tags. These are the
    JavaScript references for our referenced components, such as authentication and
    our Twitter Component library. The final two `<script>` tags are very important:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在错误元素之后是几个剩余的 `<script>` 标签。这些是我们引用的组件（如身份验证和 Twitter 组件库）的 JavaScript 引用。最后两个
    `<script>` 标签非常重要：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first `<script>` tag’s referenced JavaScript (the *blazor.webassembly.js*
    file) is what starts the execution of Blazor WebAssembly. Without this line, this
    app would not render anything besides a never-ending loading page. This JavaScript
    file initiates the boot subroutine from Blazor, where WebAssembly takes hold,
    JavaScript interop lights up, and the fun starts! The various .NET executables,
    namely *.dlls*, are fetched, and the Mono runtime is prepared. As part of the
    Blazor boot subroutine, the *app* element is discovered in the document. The entry
    point of the app is invoked. This is where the .NET app starts executing in the
    context of WebAssembly.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `<script>` 标签引用的 JavaScript（*blazor.webassembly.js* 文件）是启动 Blazor WebAssembly
    执行的来源。没有这一行，此应用程序除了一个永远加载的页面外将不会渲染任何内容。这个 JavaScript 文件启动了 Blazor 的启动子例程，在这里 WebAssembly
    生效，JavaScript 交互开始，乐趣开始！各种 .NET 可执行文件，即 *.dll 文件，被获取，并准备好 Mono 运行时。作为 Blazor 启动子例程的一部分，文档中的
    *app* 元素被发现。应用程序的入口点被调用。这是 .NET 应用程序在 WebAssembly 上下文中开始执行的地方。
- en: The second `<script>` tag registers the application’s service worker JavaScript
    code. This exposes our app as a PWA, which is a nice feature. It’s a way to make
    your app available offline and service worker functionality. For more information
    about PWAs, see Microsoft’s [“Overview of Progressive Web Apps (PWAs)” documentation](https://oreil.ly/5Ji8p).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 `<script>` 标签注册了应用程序的服务工作线程 JavaScript 代码。这使得我们的应用程序成为 PWA，这是一个很好的功能。这是一种使您的应用程序离线可用和服务工作线程功能的方式。有关
    PWA 的更多信息，请参阅 Microsoft 的 [“渐进式 Web 应用程序 (PWAs) 概述” 文档](https://oreil.ly/5Ji8p)。
- en: Blazor WebAssembly App Internals
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Blazor WebAssembly 应用程序内部
- en: Every application has a required entry point. In a web client app, that is the
    initial request to the web server where the app is hosted. When the *_frame⁠work/​blazor.webassembly.js*
    file is running, it starts requesting .dlls, and the runtime starts the Blazor
    application’s executable. With Blazor WebAssembly, like most other .NET apps,
    the *Program.cs* is the entry point. [Example 2-1](#blazor_webassembly_program)
    is the Web.Client project’s *Program.cs* C# file of the model app.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都有一个必需的入口点。在 Web 客户端应用程序中，这是对托管应用程序的 Web 服务器的初始请求。当运行 *_frame⁠work/​blazor.webassembly.js*
    文件时，它开始请求 .dll 文件，运行时启动 Blazor 应用程序的可执行文件。与大多数其他 .NET 应用程序一样，在 Blazor WebAssembly
    中，*Program.cs* 是入口点。[示例 2-1](#blazor_webassembly_program) 是模型应用程序的 Web.Client
    项目的 *Program.cs* C# 文件。
- en: Example 2-1\. Web.Client/Program.cs
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-1\. Web.Client/Program.cs
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Blazor relies on dependency injection as a first-class citizen of its core architecture.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 依赖于依赖注入作为其核心架构的一部分。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '*Dependency injection* (DI) is defined as an object declaring other objects
    as a dependency and a mechanism in which these dependencies are injected into
    the dependent object. A basic example of this would be `ServiceOne` requiring
    `ServiceTwo`, and a service provider instantiates `ServiceOne` given `ServiceTwo`
    as a dependency. In this contrived example, both `ServiceOne` and `ServiceTwo`
    would have to be registered with the service provider. `ServiceTwo` is instantiated
    by the provider and passed to `ServiceOne` as a dependency whenever `ServiceOne`
    is used.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*依赖注入*（DI）被定义为一个对象声明其他对象作为依赖项，并且一种机制将这些依赖项注入到依赖对象中。一个基本的例子是 `ServiceOne` 需要
    `ServiceTwo`，并且服务提供者在给定 `ServiceTwo` 依赖项时实例化 `ServiceOne`。在这个构造的示例中，`ServiceOne`
    和 `ServiceTwo` 都必须在服务提供者中注册。每当使用 `ServiceOne` 时，服务提供者会实例化 `ServiceTwo` 并将其作为依赖项传递给
    `ServiceOne`。'
- en: 'The entry point is succinct and makes use of C#’s top-level program syntax,
    which requires less boilerplate, such as omitting a `class Program` object. We
    create a default `WebAssemblyHostBuilder` from the app’s `args`. The `builder`
    instance adds two root components: first, the `App` component paired with the
    `#app` selector, which will resolve our `<div id="app"></div>` element from the
    previously discussed *index.html* file. Second, we add a `HeadOutlet` component
    after the `<head>` content. This `Head​Out⁠let` is provided by Blazor, and it
    enables the ability to dynamically append or update `<meta>` tags or related `<head>`
    content to the HTML document.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 入口点简洁，并利用了 C# 的顶级程序语法，这需要更少的样板，如省略了 `class Program` 对象。我们从应用程序的 `args` 创建了一个默认的
    `WebAssemblyHostBuilder`。`builder` 实例添加了两个根组件：首先是 `App` 组件，配对了 `#app` 选择器，它将解析我们在之前讨论的
    *index.html* 文件中的 `<div id="app"></div>` 元素。其次，我们在 `<head>` 内容之后添加了一个 `HeadOutlet`
    组件。这个 `Head​Out⁠let` 是由 Blazor 提供的，它使得能够动态附加或更新 HTML 文档的 `<meta>` 标签或相关的 `<head>`
    内容。
- en: 'When the application is running in a development environment, the minimum logging
    level is set appropriately to debug. The `builder` invokes `ConfigureServices`,
    which is an extension method that encapsulates the registration of various services
    the client app requires. The services that are registered include the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序在开发环境中运行时，最小的日志记录级别会适当地设置为调试。`builder`调用了`ConfigureServices`，这是一个封装了客户端应用程序所需的各种服务注册的扩展方法。已注册的服务包括以下内容：
- en: '`ApiAccessAuthorizationMessageHandler`'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApiAccessAuthorizationMessageHandler`'
- en: The custom handler used to authorize outbound HTTP requests using an access
    token
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 用于使用访问令牌授权出站 HTTP 请求的自定义处理程序
- en: '`CultureService`'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`CultureService`'
- en: An intermediary custom service used specifically to encapsulate common logic
    related to the client `CultureInfo`
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个中间的自定义服务，专门用于封装与客户端`CultureInfo`相关的常见逻辑
- en: '`HttpClient`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient`'
- en: A framework-provided HTTP client configured with the culture services’ two-letter
    ISO language name as a default request header
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个由框架提供的 HTTP 客户端，配置了两字母 ISO 语言名称作为默认请求头的文化服务
- en: '`MsalAuthentication`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`MsalAuthentication`'
- en: The framework-provided Azure business-to-consumer (B2C) and Microsoft Authentication
    Library (MSAL), which is bound and configured for the app’s tenant
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 框架提供的 Azure 企业对消费者 (B2C) 和 Microsoft 身份验证库 (MSAL)，这些都是绑定并为应用程序的租户配置的
- en: '`SharedHubConnection`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`SharedHubConnection`'
- en: A custom service that shares a single SignalR `HubConnection` with multiple
    components
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个自定义服务，将单个 SignalR `HubConnection` 与多个组件共享
- en: '`AppInMemoryState`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppInMemoryState`'
- en: A custom service used to expose in-memory application state
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 用于公开内存中应用程序状态的自定义服务
- en: '`CoalescingStringLocalizer<T>`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`CoalescingStringLocalizer<T>`'
- en: A generic custom service that leverages a component-first localization attempt,
    falling back to a shared approach
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个通用的自定义服务，利用了首先组件的本地化尝试，然后回退到共享的方法
- en: '`GeoLocationService`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`GeoLocationService`'
- en: The custom client service for querying geographical information given a longitude
    and latitude
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 用于查询给定经度和纬度的地理信息的自定义客户端服务
- en: After all the services are registered, we call `builder.Build()`, which returns
    a `WebAssemblyHost` object, and this type implements the `IAsyncDisposable` interface.
    As such, we’re mindful to properly `await using` the `host` instance. This asynchronously
    uses the `host` and will implicitly dispose of it when it’s no longer needed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有服务注册之后，我们调用`builder.Build()`，这会返回一个`WebAssemblyHost`对象，这个类型实现了`IAsyncDisposable`接口。因此，我们要谨慎地使用`await
    using`这个`host`实例。这样异步使用`host`，并在不再需要时隐式地释放它。
- en: Detecting Client Culture at Startup
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在启动时检测客户端文化
- en: 'You may have noticed that the `host` had another extension method that was
    used. The `host.TrySetDefaultCulture` method will attempt to set the default culture.
    The `culture` in this context is represented by the [`CultureInfo`](https://oreil.ly/PrM7u)
    .NET object and acts as the locale of the browser, such as `en-US`, for example.
    The extension method is defined with the *WebAssemblyHostExtensions.cs* C# file
    of the Web.Client project:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到`host`还使用了另一个扩展方法。`host.TrySetDefaultCulture`方法会尝试设置默认文化。在这个上下文中，`culture`由[`CultureInfo`](https://oreil.ly/PrM7u)
    .NET 对象表示，并且充当浏览器的区域设置，例如 `en-US`。该扩展方法在 Web.Client 项目的 *WebAssemblyHostExtensions.cs*
    C# 文件中定义：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: From the `host` instance, its `Services` property is available as an `IServiceProvider`
    type. This is exposed as `host.Services`, and we use it to resolve services from
    the DI container. This is referred to as the *service locator pattern* because
    services are located manually from a provider.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从`host`实例中，它的`Services`属性以`IServiceProvider`类型可用。这被暴露为`host.Services`，我们使用它来从
    DI 容器中解析服务。这被称为*服务定位器模式*，因为服务是从提供程序手动定位的。
- en: Tip
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You don’t need to use this pattern elsewhere because .NET handles things. In
    the spirit of “best practices,” you should always prefer the framework-provided
    DI (or third-party) container implementations. We’re using it only because we
    want to load the application in a specific culture, which starts early.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要在其他地方使用这种模式，因为 .NET 会处理这些事情。在“最佳实践”的精神下，你应该始终优先选择框架提供的 DI（或第三方）容器实现。我们只是在这里使用它，因为我们想要以特定文化加载应用程序，这需要早期开始。
- en: We don’t need to use this pattern anywhere else in the app, as the framework
    will automatically resolve the services we need through either constructor or
    property injection. We start by calling for `ILocalStorageService`, described
    in [Chapter 7](ch07.html#chapter-seven). We then ask for it to retrieve a `string`
    value that corresponds to the `StorageKeys.ClientCulture` key. `StorageKeys` is
    a `static class` that exposes various literals, constants, and verbatim values
    that the app makes use of for consistency. If the `clientCulture` value is `null`,
    we’ll assign a reasonable default of `"en-US"`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在应用程序的其他地方不需要使用这种模式，因为框架将通过构造函数或属性注入自动解析我们需要的服务。我们首先调用 `ILocalStorageService`，这在
    [第七章](ch07.html#chapter-seven) 中有描述。然后，我们要求它检索与 `StorageKeys.ClientCulture` 键对应的
    `string` 值。`StorageKeys` 是一个静态类，用于保持应用程序一致性的各种字面值、常量和逐字值。如果 `clientCulture` 值为
    `null`，我们将分配一个合理的默认值 `"en-US"`。
- en: Since these `culture` values come from the client, we cannot trust it—this is
    why we wrap the attempt to create a `CultureInfo` in a `try`/`catch` block. Finally,
    we run the application associated with the contextual `host` instance. From this
    entry point, the `App` component is the first Blazor component that starts.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些 `culture` 值来自客户端，我们不能信任它们 —— 这就是为什么我们用 `try`/`catch` 块来尝试创建 `CultureInfo`。最后，我们运行与上下文
    `host` 实例相关联的应用程序。从这个入口点开始，`App` 组件是第一个启动的 Blazor 组件。
- en: Layouts, Shared Components, and Navigation
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局、共享组件和导航
- en: 'The *App.razor* file is the first of all Blazor components, and it contains
    the `<Router>`, which is used to provide data that corresponds to the navigation
    state. Consider the following *App.razor* file markup of the Web.Client project:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*App.razor* 文件是所有 Blazor 组件中的第一个，它包含 `<Router>`，用于提供与导航状态对应的数据。考虑 Web.Client
    项目中 *App.razor* 文件标记的以下内容：'
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is the top-level Blazor component of the app itself and is named appropriately
    as `App`. The `App` component is the first component that is rendered. It is the
    root component of the application, and all child components of the app are rendered
    within this component.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是应用程序本身的顶层 Blazor 组件，恰当地命名为 `App`。`App` 组件是第一个被渲染的组件。它是应用程序的根组件，所有应用程序的子组件都在这个组件内部渲染。
- en: Blazor navigation essentials
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Blazor 导航要点
- en: Let’s evaluate the `App` component markup in-depth and understand the various
    parts.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入评估 `App` 组件的标记，并理解其各个部分。
- en: The `<CascadingAuthenticationState>` component is the outermost component within
    our application. As the name implies, it will cascade the authentication state
    through to interested child components.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`<CascadingAuthenticationState>` 组件是我们应用程序中最外层的组件。顾名思义，它将认证状态级联到感兴趣的子组件。'
- en: Note
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The approach of *cascading* state through component hierarchies has become very
    common due to its ease of use and similarity to related patterns, like that of
    CSS. The same concept is also applicable at the OS level, with systems such as
    lightweight directory access protocol (LDAP) permissions. Try thinking in graphs
    because this is a common pattern in software whenever there is a graph/tree to
    cascade over. That’s the idea behind cascading state.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过组件层次结构传播状态的方法由于易用性和与相关模式（如 CSS 类似）的相似性而变得非常常见。同样的概念在操作系统层面也适用，比如轻量级目录访问协议（LDAP）权限系统。尝试在图形中考虑这个思路，因为这是软件中有图形/树状结构需要级联的常见模式。这就是级联状态背后的理念。
- en: As an example, an ancestor component can define a `<CascadingValue>` component
    with any value. This value can flow down the component hierarchy to any number
    of descendant components. Consuming components use the `CascadingParameter` attribute
    to receive the value from the parent. This concept is covered in greater detail
    as we continue to explore the app. Let’s continue descending the component hierarchy.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个祖先组件为例，可以定义一个 `<CascadingValue>` 组件，并赋予任意值。这个值可以沿着组件层次结构流向任意数量的后代组件。消费组件使用
    `CascadingParameter` 属性从父组件接收这个值。随着我们继续探索应用程序，这个概念将会被更详细地覆盖。让我们继续下降到组件层次结构中。
- en: 'The first nested child is the `Error` component. It’s a custom component that
    is defined in the *Error.razor* file:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个嵌套子组件是 `Error` 组件。它是一个自定义组件，定义在 *Error.razor* 文件中：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_executing_the_app_CO1-1)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_executing_the_app_CO1-1)'
- en: The `@inject` syntax is a Razor directive.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`@inject` 语法是 Razor 指令。'
- en: '[![2](assets/2.png)](#co_executing_the_app_CO1-2)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_executing_the_app_CO1-2)'
- en: The `Error` component makes use of *cascades*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Error` 组件使用了 *cascades*。'
- en: '[![3](assets/3.png)](#co_executing_the_app_CO1-3)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_executing_the_app_CO1-3)'
- en: An `@code` directive is a way to add C# class-scoped members to a component.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`@code` 指令是向组件添加 C# 类范围成员的一种方式。'
- en: '[![4](assets/4.png)](#co_executing_the_app_CO1-4)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_executing_the_app_CO1-4)'
- en: The `ChildContent` property is a parameter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChildContent` 属性是一个参数。'
- en: '[![5](assets/5.png)](#co_executing_the_app_CO1-5)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_executing_the_app_CO1-5)'
- en: The `ProcessError` method is accessible to all of the consuming components.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProcessError` 方法对所有消费组件都是可访问的。'
- en: There are several common directives that you’ll learn as part of Blazor development.
    This specific directive instructs the Razor view engine to *inject* the `ILogger<Error>`
    service from the service provider. This is how Blazor components use DI, through
    property injection instead of constructor injection.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Blazor 开发的一部分，有几个常见的指令。这个特定的指令指示 Razor 视图引擎从服务提供程序 *注入* `ILogger<Error>`
    服务。这是 Blazor 组件使用 DI 的方式，通过属性注入而不是构造函数注入。
- en: The `<CascadingValue>` markup includes the template rendering of an `@Child​Con⁠tent`.
    The `ChildContent` is both a `[Parameter]` and a `RenderFragment`. This allows
    for the `Error` component to render any child content, including Blazor components.
    When there is a single `RenderFragment` defined as part of a templated component,
    its child content can be represented as pure Razor markup.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`<CascadingValue>` 标记包括 `@Child​Con⁠tent` 的模板渲染。`ChildContent` 同时是 `[Parameter]`
    和 `RenderFragment`。这允许 `Error` 组件呈现任何子内容，包括 Blazor 组件。在模板化组件的单个 `RenderFragment`
    定义时，其子内容可以表示为纯 Razor 标记。'
- en: A `RenderFragment` is a void returning `delegate` type that accepts a `RenderTreeBuilder`.
    It represents a segment of UI content. The `RenderTreeBuilder` type is a low-level
    Blazor class that exposes methods for building a C# representation of the DOM.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderFragment` 是一个返回 `void` 的 `delegate` 类型，接受 `RenderTreeBuilder`。它表示 UI
    内容的一个片段。`RenderTreeBuilder` 类型是一个低级 Blazor 类，公开了用于构建 DOM 的 C# 表示的方法。'
- en: '`<CascadingValue>` is a Blazor (or framework-provided) component that provides
    a cascading value to all descendant components. `CascadingValue.Value` is assigned
    `this`, which is the `Error` component instance itself. This means that all descendant
    components will have access to the `ProcessError` method if they choose to consume
    it. Descendant components would need to define a `[CascadingParameter]` property
    of type `Error` for it to flow through to it.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`<CascadingValue>` 是一个 Blazor（或框架提供的）组件，为所有后代组件提供级联值。`CascadingValue.Value`
    被分配为 `this`，即 `Error` 组件实例本身。这意味着所有后代组件如果选择消耗它，将能够访问 `ProcessError` 方法。后代组件需要定义一个
    `[CascadingParameter]` 属性，类型为 `Error`，才能使其流入其中。'
- en: The `Parameter` attribute is provided by Blazor as a way to denote that a property
    of a component is a parameter. These are available as binding targets from consuming
    components as attribute assignments in Razor markup.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parameter` 属性由 Blazor 提供，用于表示组件的属性是参数。这些作为绑定目标从消费组件作为 Razor 标记中的属性分配可用。'
- en: The `ProcessError` method expects an `Exception` instance, which it uses to
    log as an error. The child content of the `Error` component is the `Router`. The
    `Router` component is what enables our SPA’s client-side routing, meaning routing
    occurs on the client, and the page doesn’t need to refresh.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProcessError` 方法期望一个 `Exception` 实例，用于记录为错误。`Error` 组件的子内容是 `Router`。`Router`
    组件是我们 SPA 的客户端路由的实现，这意味着路由发生在客户端，页面不需要刷新。'
- en: The Router
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由器
- en: 'The `Router` is a framework-provided component that’s used in the *src/Web.Cli⁠ent/​App.razor*
    file. It specifies an `AppAssembly` parameter that is assigned to the `typeof(App).Assembly`
    by convention. Additionally, the `Context` parameter allows us to specify the
    name of the parameter. We assign the name of `routeData`, which overrides the
    default name of `context`. The `Router` also defines multiple named `RenderFragment`
    components; because there are multiple, we must explicitly specify child content.
    This is where the corresponding `RenderFragment` name comes in. For example, when
    the router is unable to find a matching route, we define what the page should
    render the `NotFound` content. Consider the following `NotFound` content section
    from the `Router` markup:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Router`是框架提供的组件，用于*src/Web.Client/App.razor*文件。它指定了一个`AppAssembly`参数，按照惯例将其赋给`typeof(App).Assembly`。此外，`Context`参数允许我们指定参数的名称。我们分配了`routeData`的名称，覆盖了默认名称`context`。`Router`还定义了多个命名的`RenderFragment`组件；因为有多个，我们必须明确指定子内容。这就是对应的`RenderFragment`名称的用处。例如，当路由器无法找到匹配的路由时，我们定义页面应该渲染`NotFound`内容。考虑以下`Router`标记中的`NotFound`内容部分：'
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This layout is based on the `MainLayout` component and sets its child as the
    `NotFoundPage` component. Assuming the user navigates to a route that doesn’t
    exist, they’d end up on our custom HTTP 404 page, which is localized and styled
    consistently with our app. We’ll handle HTTP status code 401 in the next section.
    However, when the router does match an expected route, the `Found` content is
    rendered. Consider the following `Found` content section from the `Router` markup:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此布局基于`MainLayout`组件，并将其子项设置为`NotFoundPage`组件。假设用户导航到不存在的路由，他们将会进入我们自定义的HTTP
    404页面，该页面与我们的应用程序一致地本地化和样式化。我们将在下一节处理HTTP状态码401。但是，当路由器确实匹配预期的路由时，将渲染`Found`内容。考虑以下`Router`标记中的`Found`内容部分：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Redirect to login when unauthenticated
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未经授权时重定向到登录页
- en: If you recall from earlier, the `Found` content is just a `RenderFragment`.
    The child content, in this case, is the `AuthorizeRouteView` component. This route
    view is displayed only when the user is authorized to view it. It adheres to `MainLayout`
    as its default. The `RouteData` is assigned from the contextual `routeData`. The
    route data itself defines which component the router will render and the corresponding
    parameters from the route.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得之前的内容，`Found`内容只是一个`RenderFragment`。在这种情况下，子内容是`AuthorizeRouteView`组件。此路由视图仅在用户被授权查看时显示。它遵循`MainLayout`作为其默认值。`RouteData`从上下文的`routeData`分配。路由数据本身定义了路由器将渲染的组件以及来自路由的相应参数。
- en: 'When the user is not authorized, we redirect them to the login screen using
    the `RedirectToLogin` component:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户未经授权时，我们使用`RedirectToLogin`组件将其重定向到登录屏幕：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](assets/1.png)](#co_executing_the_app_CO2-1)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_executing_the_app_CO2-1)'
- en: The `RedirectToLogin` component requires the `NavigationManager`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`RedirectToLogin`组件需要`NavigationManager`。'
- en: '[![2](assets/2.png)](#co_executing_the_app_CO2-2)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_executing_the_app_CO2-2)'
- en: The `OnInitialized` method navigates to the authentication login page.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnInitialized`方法导航到身份验证登录页面。'
- en: The `RedirectToLogin` component injects the `NavigationManager`, and when it’s
    initialized, it navigates to the `authentication/login` route with the escaped
    `returnUrl` query string. When the user is authorized, the route view renders
    `MainLayout`, which is a subclass of Blazor’s `LayoutComponentBase`. While the
    markup defines all of the layout of the app, it also splats `@Body` in the appropriate
    spot. This is another `RenderFragment` that is inherited from `LayoutComponentBase`.
    The body content is what the router ultimately controls for its client-side routing.
    In other words, as users navigate the site, the router dynamically updates the
    DOM with rendered Blazor components within the `@Body` segment.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`RedirectToLogin`组件注入了`NavigationManager`，并且在初始化时导航到`authentication/login`路由，带有转义的`returnUrl`查询字符串。当用户被授权时，路由视图将渲染`MainLayout`，它是Blazor的`LayoutComponentBase`的子类。虽然标记定义了应用程序的所有布局，但它也在适当的位置打散`@Body`。这是另一个从`LayoutComponentBase`继承的`RenderFragment`。正如用户在站点上导航时，路由器动态更新DOM，渲染Blazor组件在`@Body`段内。'
- en: We `override` the `OnInitialized` method. This is our first look at overriding
    `ComponentBase` class functionality, but this is very common in Blazor. There
    are several `virtual` methods (methods that can be overridden) in the `ComponentBase`
    class, most of which represent different points of a component’s lifecycle.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 `override` 了 `OnInitialized` 方法。这是我们首次查看重写 `ComponentBase` 类功能，但在 Blazor
    中非常常见。`ComponentBase` 类中有几个 `virtual` 方法（可以重写的方法），大多数代表组件生命周期的不同阶段。
- en: Blazor component lifecycle
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Blazor 组件生命周期
- en: Continuing from the aforementioned *RedirectToLogin.razor.* file, there is an
    `override` method named `OnInitialized`. This method is one of several lifecycle
    methods that will occur at specific points in the life of a component. Blazor
    components inherit the `Microsoft.AspNetCore.Components.ComponentBase` class.
    Please consider [Table 2-1](#component_lifecycle_methods) for reference.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 继续从上述 *RedirectToLogin.razor.* 文件开始，存在一个名为 `OnInitialized` 的 `override` 方法。这个方法是组件生命周期中特定点之一的几个生命周期方法之一。Blazor
    组件继承了 `Microsoft.AspNetCore.Components.ComponentBase` 类。请参考 [Table 2-1](#component_lifecycle_methods)
    以供参考。
- en: Table 2-1\. `ComponentBase` lifecycle methods
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-1\. `ComponentBase` 生命周期方法
- en: '| Order | Method name(s) | Description |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 顺序 | 方法名 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | `SetParametersAsync` | Sets parameters supplied by the component’s parent
    in the render tree |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 1 | `SetParametersAsync` | 设置组件在渲染树中由其父组件提供的参数 |'
- en: '| 2 | `OnInitialized` `OnInitializedAsync` | Method invoked when the component
    is ready to start, having received its initial parameters from its parent in the
    render tree |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 2 | `OnInitialized` `OnInitializedAsync` | 当组件准备就绪时调用的方法，从其父组件在渲染树中接收到其初始参数
    |'
- en: '| 3 | `OnParametersSet` `OnParametersSetAsync` | Method invoked when the component
    has received parameters from its parent in the render tree and the incoming values
    have been assigned to properties |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 3 | `OnParametersSet` `OnParametersSetAsync` | 当组件从其父组件接收到渲染树中的参数并且传入值已分配给属性时调用的方法
    |'
- en: '| 4 | `OnAfterRender` `OnAfterRenderAsync` | Method invoked after each time
    the component has been rendered |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 4 | `OnAfterRender` `OnAfterRenderAsync` | 在每次组件渲染后调用的方法 |'
- en: The MainLayout component
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MainLayout 组件
- en: 'The *MainLayout.razor* file, as the name indicates, represents the main layout.
    Within this markup, the navigation bar (navbar), header, footer, and content areas
    are organized and structured:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*MainLayout.razor* 文件，顾名思义，表示主要布局。在此标记中，导航栏（navbar）、头部、底部和内容区域都被组织和结构化了：'
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_executing_the_app_CO3-1)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_executing_the_app_CO3-1)'
- en: The first two lines of this layout Razor file are two C# expressions, indicated
    by their leading `@` symbol.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此布局 Razor 文件的前两行是两个 C# 表达式，由其前导 `@` 符号指示。
- en: '[![2](assets/2.png)](#co_executing_the_app_CO3-2)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_executing_the_app_CO3-2)'
- en: '`<section>` is a native HTML element, and it’s perfectly valid with Razor syntax.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`<section>` 是一个原生 HTML 元素，它在 Razor 语法中是完全有效的。'
- en: '[![3](assets/3.png)](#co_executing_the_app_CO3-3)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_executing_the_app_CO3-3)'
- en: Within the `<section>` element’s semantic header and navbar, `<NavLink>` is
    referenced.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `<section>` 元素的语义头部和导航栏中，引用了 `<NavLink>`。
- en: '[![4](assets/4.png)](#co_executing_the_app_CO3-4)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_executing_the_app_CO3-4)'
- en: The next section of the navbar is built out, with a custom `NavBar` component.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个导航栏部分是由自定义 `NavBar` 组件构建而成。
- en: '[![5](assets/5.png)](#co_executing_the_app_CO3-5)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_executing_the_app_CO3-5)'
- en: The `@Body` render fragment is defined within the center of the DOM.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DOM 的中心定义了 `@Body` 渲染片段。
- en: '[![6](assets/6.png)](#co_executing_the_app_CO3-6)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_executing_the_app_CO3-6)'
- en: The native HTML `footer` element is the parent to the custom `PageFooter` component,
    which is responsible for rendering the very bottom of the page.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 原生 HTML `footer` 元素是自定义 `PageFooter` 组件的父元素，负责渲染页面底部。
- en: These two directives represent various behaviors required within this component.
    The first of the two is the `@inherits` directive, which instructs the component
    to inherit from the `LayoutComponentBase` class. This means that it’s a subclass
    of the framework’s `LayoutComponentBase` class. This layout base class is an implementation
    of `IComponent` and exposes a `Body` render fragment. This allows us to make the
    content whatever the app’s `Router` provides as output. The main layout component
    uses the `@inject` directive to request the service provider to resolve an `IString​Lo⁠calizer<MainLayout>`,
    which is assigned to a component-accessible member named `Localizer`. We’ll cover
    localization in [Chapter 5](ch05.html#chapter-five).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个指令代表了此组件内部所需的各种行为。两者中的第一个是`@inherits`指令，它指示组件从`LayoutComponentBase`类继承。这意味着它是框架的`LayoutComponentBase`类的子类。此布局基类实现了`IComponent`并公开了一个`Body`渲染片段。这使得我们可以将内容设置为应用程序的`Router`输出的任何内容。主要布局组件使用`@inject`指令请求服务提供者来解析`IString​Lo⁠calizer<MainLayout>`，并将其分配给一个名为`Localizer`的组件可访问成员。我们将在[第五章](ch05.html#chapter-five)中详细讨论本地化。
- en: '`<section>` is a native HTML element, and it’s perfectly valid Razor syntax.
    Notice how we can transition from C# to HTML seamlessly, in either direction.
    We define some standard HTML, with a bit of semantic markup. It’s known that you
    have familiarity with HTML and CSS, and we won’t put too much emphasis on that.
    Because this is such a large project, we’d likely have this HTML and CSS provided
    by our imaginary UX department.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`<section>`是一个原生HTML元素，它是完全有效的Razor语法。注意我们如何可以无缝地在C#和HTML之间进行过渡。我们定义了一些标准的HTML，带有一些语义化的标记。你对HTML和CSS有所熟悉，我们不会过多强调这一点。因为这是一个如此大的项目，我们很可能会由我们想象中的UX部门提供这些HTML和CSS。'
- en: Within the `<section>` element’s semantic header and navbar, `<NavLink>` is
    referenced. This is a framework-provided component. The `NavLink` component is
    used to expose the user interactive aspect of the component’s logic. It handles
    the routing of the Blazor application and relies on the value within the browser’s
    URL bar. This represents the app’s “Home” navigation route, and it’s branded with
    the Blazor logo.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<section>`元素的语义化标题和导航栏中，引用了`<NavLink>`。这是一个由框架提供的组件。`NavLink`组件用于暴露组件逻辑的用户交互部分。它处理Blazor应用程序的路由，并依赖于浏览器URL栏中的值。这代表了应用程序的“主页”导航路由，并带有Blazor标志。
- en: The next section of the navigation bar is built out with a custom `NavBar` component.
    There is a bit of familiar protective markup, where the app specifies it’s available
    only when `AuthorizerView` has `Authorized` content to render in the browser.
    The earlier components mentioned were either left-aligned or centered, and the
    next components are grouped and pushed to the end or far-right-hand side of the
    navbar. Immediately to the right of this component grouping is a `LoginDisplay`.
    Let’s have a deep look into the `LoginDisplay` component (see also [“Understanding
    the LoginDisplay component”](#login_display)). This group of elements is theme-aware,
    meaning it will render in one of two ways, either the `dark` theme or the `light`
    theme (see [“The header and footer components”](#header-footer-components) for
    visual examples).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 导航栏的下一个部分是使用自定义的`NavBar`组件构建的。这里有一些熟悉的保护性标记，当`AuthorizerView`有授权内容在浏览器中渲染时，应用程序才会显示它。前面提到的组件要么左对齐要么居中，而下一个组件则分组并推到导航栏的末尾或最右侧。这组件组合的右侧是一个`LoginDisplay`。让我们深入了解`LoginDisplay`组件（另请参见[“理解LoginDisplay组件”](#login_display)）。这些元素组是主题感知的，这意味着它将以两种方式之一进行渲染，即`dark`主题或`light`主题（请参见[“头部和尾部组件”](#header-footer-components)的视觉示例）。
- en: The `@Body` render fragment is defined within the center of the DOM. `@Body`
    is the primary aspect of the Blazor navigation and the output target for the router.
    In other words, as users navigate, the client-side routing renders HTML within
    the `@Body` placeholder.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Body`渲染片段被定义在DOM的中心位置。`@Body`是Blazor导航的主要组成部分，也是路由器的输出目标。换句话说，当用户导航时，客户端路由将HTML渲染在`@Body`占位符内。'
- en: The custom NavBar component
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义的NavBar组件
- en: 'Admittedly, there’s a lot to soak in from that layout component markup, but
    when you take the time to mentally parse each part, it will make sense. There
    are a few custom components, one of which is `<NavBar />`. This references the
    *NavBar.razor* file:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，从该布局组件标记中吸取的信息很多，但当您花时间逐个理解每个部分时，它将会变得清晰明了。其中有几个自定义组件，其中之一是`<NavBar />`。它引用了*NavBar.razor*文件：
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_executing_the_app_CO4-1)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_executing_the_app_CO4-1)'
- en: Inherits from `LocalizableComponentBase` to take advantage of the base functionality.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 继承自 `LocalizableComponentBase` 以利用基本功能。
- en: '[![2](assets/2.png)](#co_executing_the_app_CO4-2)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_executing_the_app_CO4-2)'
- en: The `<NavLink>` component is provided by the framework and works with the router.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`<NavLink>` 组件由框架提供，并与路由器一起使用。'
- en: '[![3](assets/3.png)](#co_executing_the_app_CO4-3)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_executing_the_app_CO4-3)'
- en: The second route is for tweets and corresponds to the `/tweets` route.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个路由是用于推文，对应 `/tweets` 路由。
- en: '[![4](assets/4.png)](#co_executing_the_app_CO4-4)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_executing_the_app_CO4-4)'
- en: The third route is for Pwned? and corresponds to the `/pwned` route.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个路由是用于 Pwned？对应 `/pwned` 路由。
- en: Like most custom components, this too inherits from `LocalizableComponentBase`
    to take advantage of the base functionality. The base functionality is detailed
    in [Chapter 5](ch05.html#chapter-five). The framework-provided `<NavLink>` component
    works with the router. The first route is the chat room and corresponds to the
    `/chat` route. While each of the previous route names is retrieved using the `@Localizer`
    indexer, the “Pwned?” route is not because it’s a brand name.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数自定义组件一样，这个组件也继承自 `LocalizableComponentBase` 以利用基本功能。基本功能在 [第 5 章](ch05.html#chapter-five)
    中有详细描述。框架提供的 `<NavLink>` 组件与路由器一起工作。第一个路由是聊天室，对应 `/chat` 路由。虽然之前的每个路由名称都是使用 `@Localizer`
    索引器检索的，但“Pwned？”路由不是，因为它是一个品牌名。
- en: The header and footer components
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标题和页脚组件
- en: The header for the app contains links to Home, Chat, Tweets, Pwned, and Contact
    pages. These are all navigable routes that the `Router` will recognize. The icons
    to the right are for Theme, Audio Descriptions, Language Selection, Task List,
    Notifications, and Log out. The log-out functionality does rely on the app’s navigation
    to navigate to routes, but the other buttons could be considered utilitarian.
    They open modals for global functionality and expose user preferences. The header
    itself supports the `dark` and `light` themes, as shown in Figures [2-2](#dark_navbar)
    and [2-3](#light_navbar).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的标题包含指向主页、聊天、推文、Pwned 和联系页面的链接。这些都是 `Router` 将识别的可导航路由。右侧的图标用于主题、音频描述、语言选择、任务列表、通知和登出。登出功能依赖于应用程序的导航以导航到路由，但其他按钮可以视为实用按钮。它们打开用于全局功能的模态框并公开用户首选项。标题本身支持
    `dark` 和 `light` 主题，如图 [2-2](#dark_navbar) 和 [2-3](#light_navbar) 所示。
- en: '![](assets/lblz_0202.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lblz_0202.png)'
- en: Figure 2-2\. An example navigation header with the `dark` theme
  id: totrans-156
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-2\. 具有 `dark` 主题的示例导航标题
- en: '![](assets/lblz_0203.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lblz_0203.png)'
- en: Figure 2-3\. An example navigation header with the `light` theme
  id: totrans-158
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-3\. 具有 `light` 主题的示例导航标题
- en: 'Let’s look at the `PageFooter` component first, defined in the *PageFooter.razor*
    file:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看定义在 *PageFooter.razor* 文件中的 `PageFooter` 组件：
- en: '[PRE13]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_executing_the_app_CO5-1)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_executing_the_app_CO5-1)'
- en: The component inherit from the `LocalizableComponentBase` class.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 组件继承自 `LocalizableComponentBase` 类。
- en: '[![2](assets/2.png)](#co_executing_the_app_CO5-2)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_executing_the_app_CO5-2)'
- en: Column one reads `"Learning Blazor by David Pine"`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列读取 `"Learning Blazor by David Pine"`。
- en: '[![3](assets/3.png)](#co_executing_the_app_CO5-3)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_executing_the_app_CO5-3)'
- en: 'In the second column, there are two links: one for the source codes’ MIT license
    and the GitHub source code link.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二列，有两个链接：一个是源代码的 MIT 许可证，另一个是 GitHub 源代码链接。
- en: '[![4](assets/4.png)](#co_executing_the_app_CO5-4)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_executing_the_app_CO5-4)'
- en: The third column contains links to the *Privacy* and *Terms and Conditions*
    pages.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 第三列包含 *隐私* 和 *条款和条件* 页面的链接。
- en: '[![5](assets/5.png)](#co_executing_the_app_CO5-5)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_executing_the_app_CO5-5)'
- en: The last column contains the .NET runtime version that the client browser is
    running.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一列包含客户端浏览器正在运行的 .NET 运行时版本。
- en: We are establishing a pattern, by having custom components inherit from the
    `LocalizableComponentBase` common base class. The custom `PageFooter` component
    is written by defining a four-column layout with centered text. From left to right
    starting at column one, the name of the application appears and a byline, `"Learning
    Blazor by David Pine"`, is rendered with a nontranslatable bold phrase. The second
    column links to the source codes’ MIT license and the GitHub source code link.
    The third column contains links to the *Privacy* and *Terms and Conditions* pages,
    and the text is localized. Localization of Blazor apps is covered in [Chapter 5](ch05.html#chapter-five).
    The .NET runtime version is useful because it tells the developer immediately
    what version of the framework is being used.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在建立一种模式，通过使自定义组件从`LocalizableComponentBase`通用基类继承。自定义的`PageFooter`组件通过定义一个四列布局并居中文本来编写。从左到右从第一列开始，显示应用程序名称和一个标题为`"Learning
    Blazor by David Pine"`的非可翻译粗体短语。第二列链接到源代码的MIT许可证和GitHub源代码链接。第三列包含*隐私*和*条款与条件*页面的链接，并进行了本地化处理。Blazor应用程序的本地化在[第5章](ch05.html#chapter-five)中有详细介绍。.NET运行时版本非常有用，因为它立即告诉开发人员正在使用的框架版本。
- en: More often than not, I prefer to have my Razor markup files accompanied by a
    code-behind file. In this way, the separate files help to isolate concerns where
    markup exists in Razor and logic exists in C#. For simple components, components
    that have a few parameters, and markup elements, it’s fine to just have everything
    in a Razor file with an `@code` directive. But when using the code-behind approach,
    you might think of this as *component shadowing*, as the component’s markup is
    shadowed by a C# file from the Visual Studio editor, as shown in [Figure 2-4](#component_shadowing).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 多数情况下，我更喜欢我的Razor标记文件配有代码后端文件。这样，分离的文件有助于在Razor中存在标记和在C#中存在逻辑的问题。对于简单组件、具有少量参数和标记元素的组件，仅在Razor文件中使用`@code`指令也是可以的。但是在使用代码后端方法时，您可以将其视为*组件阴影*，因为组件的标记被Visual
    Studio编辑器中的C#文件所遮蔽，如[图2-4](#component_shadowing)所示。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: Component shadowing is the act of creating a C# file that matches the name of
    an existing Razor file but appends the *.cs* file extension. For example, the
    *PageFooter.razor* and *PageFooter.razor.cs* files exemplify component shadowing
    because they’re nested in the Visual Studio editor and together they both represent
    the `public partial PageFooter class`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 组件阴影是指创建一个与现有Razor文件同名但附加*.cs*文件扩展名的C#文件。例如，*PageFooter.razor*和*PageFooter.razor.cs*文件就展示了组件阴影，因为它们在Visual
    Studio编辑器中嵌套，并且共同代表`public partial PageFooter class`。
- en: '![](assets/lblz_0204.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lblz_0204.png)'
- en: Figure 2-4\. Component shadowing in Visual Studio Solution Explorer
  id: totrans-176
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-4\. Visual Studio解决方案资源管理器中的组件阴影
- en: 'Consider the *PageFooter.razor.cs* component shadow file:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑*PageFooter.razor.cs*组件阴影文件：
- en: '[PRE14]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](assets/1.png)](#co_executing_the_app_CO6-1)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_executing_the_app_CO6-1)'
- en: Several constants are defined.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了几个常量。
- en: '[![2](assets/2.png)](#co_executing_the_app_CO6-2)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_executing_the_app_CO6-2)'
- en: The `OnInitialized` lifecycle method assigns the framework description.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnInitialized`生命周期方法分配框架描述。'
- en: There are several `const string` fields defined that contain URL literals. These
    are used to bind to the Razor markup. We `override` the `OnInitialized` lifecycle
    method and assign the `_frameDescription` value from the inherited `LocalizableComponentBase.AppState`
    variable.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了几个包含URL文本的`const string`字段。这些字段用于与Razor标记绑定。我们`override`了`OnInitialized`生命周期方法，并从继承的`LocalizableComponentBase.AppState`变量分配了`_frameDescription`值。
- en: The component is also theme-aware of the client browser preferences for either
    `light` or `dark`. For example, see Figures [2-5](#dark_footer) and [2-6](#light_footer).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 组件还能够根据客户端浏览器偏好的`light`或`dark`主题进行自动适配。例如，请参见[2-5](#dark_footer)和[2-6](#light_footer)图。
- en: '![](assets/lblz_0205.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lblz_0205.png)'
- en: Figure 2-5\. An example footer with the `dark` theme
  id: totrans-186
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-5\. 具有`dark`主题的示例页脚
- en: '![](assets/lblz_0206.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lblz_0206.png)'
- en: Figure 2-6\. An example footer with the `light` theme
  id: totrans-188
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-6\. 具有`light`主题的示例页脚
- en: The footer doesn’t strive for too much. It’s intentionally simple, providing
    only a few links to relevant information for the app.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 页脚并不追求过多，而是故意保持简单，仅提供一些应用程序相关信息的链接。
- en: 'The `MainLayout` component is more than just Razor markup; it, too, has a shadowed
    component. Consider the *MainLayout.razor.cs* file:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainLayout`组件不仅仅是Razor标记；它还具有一个带有阴影的组件。考虑*MainLayout.razor.cs*文件：'
- en: '[PRE15]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](assets/1.png)](#co_executing_the_app_CO7-1)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_executing_the_app_CO7-1)'
- en: '`MainLayout` is a `sealed partial class`.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainLayout` 是一个 `sealed partial class`。'
- en: '[![2](assets/2.png)](#co_executing_the_app_CO7-2)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_executing_the_app_CO7-2)'
- en: The `AppInMemoryState` instance is injected into the component.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppInMemoryState` 实例被注入到组件中。'
- en: '[![3](assets/3.png)](#co_executing_the_app_CO7-3)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_executing_the_app_CO7-3)'
- en: The `OnInitialized` method is overridden to allow the subscription to the `AppInMemoryState.StateChanged`
    event.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnInitialized` 方法被重写，以允许订阅 `AppInMemoryState.StateChanged` 事件。'
- en: '[![4](assets/4.png)](#co_executing_the_app_CO7-4)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_executing_the_app_CO7-4)'
- en: The `Dispose` method unsubscribes from the `AppInMemoryState.StateChanged` event.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dispose` 方法取消订阅 `AppInMemoryState.StateChanged` 事件。'
- en: You’ll notice that `MainLayout` is a `sealed partial class`; it’s `partial`
    so that it can serve as code-behind to the Razor markup, and it’s `sealed` so
    that it’s not inheritable by other components. It implements the `IDisposable`
    interface to perform necessary cleanup. Let’s ensure that we’re following the
    concepts of *component shadowing* and *component inheritance*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到 `MainLayout` 是一个 `sealed partial class`；它是 `partial` 的，以便作为 Razor 标记的代码后台，它是
    `sealed` 的，因此不能被其他组件继承。它实现了 `IDisposable` 接口以执行必要的清理工作。让我们确保我们遵循 *组件阴影* 和 *组件继承*
    的概念。
- en: The `AppInMemoryState` instance is injected into the component. This application
    state object is in-memory only; if the user refreshes the page, the state is lost.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppInMemoryState` 实例被注入到组件中。此应用状态对象仅存在于内存中；如果用户刷新页面，则状态将丢失。'
- en: The `OnInitialized` method is overridden from the base, and it’s used to subscribe
    to the `AppInMemoryState.StateChanged` event. The event handler is the framework-provided
    `ComponentBase.StateHasChanged` method. Eventing is a common idiom of C#, and
    it can be very useful. The `StateHasChanged` method notifies the component that
    its state has changed. When applicable, this will cause the component to be rerendered.
    `AppState.FrameworkDescription` is assigned from `Runtime​Informa⁠tion.FrameworkDescription`.
    This is the value that was displayed in the right-hand column of the footer, such
    as “.NET 6.”
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnInitialized` 方法从基类重写，并用于订阅 `AppInMemoryState.StateChanged` 事件。事件处理程序是框架提供的
    `ComponentBase.StateHasChanged` 方法。事件处理是 C# 的常见习语，非常有用。`StateHasChanged` 方法通知组件其状态已更改。在适用的情况下，这将导致组件重新渲染。`AppState.FrameworkDescription`
    是从 `Runtime​Informa⁠tion.FrameworkDescription` 赋值的。这是在页脚右侧列显示的值，例如 “.NET 6”。'
- en: Tip
  id: totrans-203
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The `StateHasChanged` method should be called only when required to avoid potentially
    unnecessarily forcing a component to rerender. When calling this method in an
    asynchronous context, wrap it in an `await` statement passing it into the `InvokeAsync`
    method. This will execute the supplied work item on the associated renderer’s
    synchronization context, ensuring it’s executed on the appropriate thread.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在必要时调用 `StateHasChanged` 方法，以避免可能不必要地强制组件重新渲染。在异步上下文中调用此方法时，请将其包装在 `await`
    语句中，并将其传递给 `InvokeAsync` 方法。这将在关联的渲染器同步上下文中执行提供的工作项，确保它在适当的线程上执行。
- en: 'You may need to explicitly call `StateHasChanged` in the following conditions:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，您可能需要显式调用 `StateHasChanged`：
- en: An asynchronous handler involves multiple asynchronous phases.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步处理程序涉及多个异步阶段。
- en: The Blazor rendering and event-handling system receives a call from something
    external.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blazor 渲染和事件处理系统接收来自外部的调用。
- en: You need to render a component outside the subtree that is rerendered by a particular
    event.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要在不重新渲染特定事件的子树之外呈现组件。
- en: For more information about triggering a render, see Microsoft’s [“ASP.NET Core
    Razor Component Rendering” documentation](https://oreil.ly/Kt3cm).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 有关触发渲染的更多信息，请参阅 Microsoft 的 [“ASP.NET Core Razor 组件渲染”文档](https://oreil.ly/Kt3cm)。
- en: The `Dispose` method ensures that if the `AppState` instance `is not null`,
    it will unsubscribe from the `AppInMemoryState.StateChanged` event. This kind
    of explicit cleanup helps to ensure that the component will not cause a memory
    leak due to event handlers not being unsubscribed.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dispose` 方法确保如果 `AppState` 实例 `不为 null`，它将取消订阅 `AppInMemoryState.StateChanged`
    事件。这种显式清理有助于确保组件不会因未取消订阅事件处理程序而导致内存泄漏。'
- en: An in-memory app state model
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个内存中的应用状态模型
- en: 'Blazor apps can store their state using an in-memory methodology. In this approach,
    you register your app state container as a singleton service, meaning there’s
    only one instance for the app to share. The service itself exposes an event that
    subscribes to the `StateHasChanged` method, and as properties on the state object
    are updated, they fire the event. Consider the *AppInMemoryState.cs* C# file:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor应用程序可以使用内存方法存储其状态。在此方法中，您将注册您的应用状态容器作为单例服务，这意味着应用程序共享的只有一个实例。服务本身公开了一个事件，订阅`StateHasChanged`方法，并且在状态对象的属性更新时触发该事件。考虑*C#文件AppInMemoryState.cs*：
- en: '[PRE16]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[![1](assets/1.png)](#co_executing_the_app_CO8-1)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_executing_the_app_CO8-1)'
- en: These fields and properties represent the various app states.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字段和属性表示了各种应用程序状态。
- en: '[![2](assets/2.png)](#co_executing_the_app_CO8-2)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_executing_the_app_CO8-2)'
- en: We will render the `FrameworkDescription` property.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将呈现`FrameworkDescription`属性。
- en: '[![3](assets/3.png)](#co_executing_the_app_CO8-3)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_executing_the_app_CO8-3)'
- en: The `AppStateChanged` method is called.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 调用了`AppStateChanged`方法。
- en: '[![4](assets/4.png)](#co_executing_the_app_CO8-4)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_executing_the_app_CO8-4)'
- en: There is an `Action` field named `StateChanged`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为`StateChanged`的`Action`字段。
- en: '[![5](assets/5.png)](#co_executing_the_app_CO8-5)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_executing_the_app_CO8-5)'
- en: The `AppStateChanged` method invokes the `StateChanged` event.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppStateChanged`方法调用了`StateChanged`事件。'
- en: Several backing fields are declared, which will be used to store the values
    of various publicly accessible properties that represent various app states.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 声明了几个备份字段，用于存储表示各种应用程序状态的各个公共可访问属性的值。
- en: As an example of the pattern used to communicate app state changes, consider
    the `FrameworkDescription` property. Its `get` accessor goes to the backing field,
    and the `set` accessor assigns to the backing field.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以通信应用程序状态更改模式为例，考虑`FrameworkDescription`属性。其`get`访问器访问备份字段，而`set`访问器则将其分配给备份字段。
- en: After the `value` has been assigned to the backing field, the `AppStateChanged`
    method is called. This pattern is followed for all properties and their corresponding
    backing fields.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`value`分配给备份字段之后，将调用`AppStateChanged`方法。所有属性及其对应的备份字段都遵循此模式。
- en: The class exposes a nullable `Action` as an `event` named `StateChanged`. Interested
    parties can subscribe to this for change notifications.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 该类公开了一个名为`StateChanged`的可空`Action`作为事件。感兴趣的方可以订阅此事件以获取更改通知。
- en: The `AppStateChanged` method is expressed as the invocation of the `StateChanged`
    event. It’s conditionally a NOOP (or “no operation”) when the event is `null`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppStateChanged`方法表示为调用`StateChanged`事件。当事件为`null`时，它条件上是NOOP（或“无操作”）。'
- en: This in-memory state management mechanism is used to expose client voice preferences,
    whether or not the client is preferring the dark theme, and the value for the
    framework description. To have the application state persist across browser sessions,
    you’d use an alternative approach, such as local storage. There are trade-offs
    in each approach; while using in-memory app state is less work, it will not persist
    beyond browser sessions. To persist beyond browser sessions, you rely on JavaScript
    interop to use a local storage mechanism.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此内存状态管理机制用于公开客户端语音偏好，客户端是否偏爱暗黑主题以及框架描述的值。要使应用程序状态在浏览器会话之间持久化，您可以使用另一种方法，如本地存储。每种方法都有权衡；使用内存中的应用程序状态少了工作量，但不会在浏览器会话之间持久存在。要持久存在浏览器会话之间，您依赖JavaScript交互操作来使用本地存储机制。
- en: Note
  id: totrans-230
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re a JavaScript SPA developer, you might be familiar with the *Flux pattern*.
    It was introduced by Facebook to provide a clear separation of concerns. The pattern
    grew in popularity with the React Redux project, which is a JavaScript implementation
    of the Flux pattern used in React. There is an implementation of this for Blazor
    known as [Fluxor](https://oreil.ly/nI5v3) by Peter Morris. While it is beyond
    the scope of this book, it’s worth exploring as a potential in-memory state management
    option.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是JavaScript SPA开发人员，则可能熟悉*Flux模式*。它由Facebook引入，以提供明确的关注点分离。该模式随着React Redux项目的流行而增长，后者是在React中使用的Flux模式的JavaScript实现。在Blazor中有一个名为[Fluxor](https://oreil.ly/nI5v3)的实现，由Peter
    Morris开发。虽然超出本书的范围，但作为潜在的内存状态管理选项值得探讨。
- en: Understanding the LoginDisplay component
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解`LoginDisplay`组件
- en: 'The `LoginDisplay` component renders only a few things to the HTML, but there’s
    a bit of code to understand:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginDisplay`组件仅向HTML渲染少量内容，但需要理解一些代码：'
- en: '[PRE17]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](assets/1.png)](#co_executing_the_app_CO9-1)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_executing_the_app_CO9-1)'
- en: The component defines two directives.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件定义了两个指令。
- en: '[![2](assets/2.png)](#co_executing_the_app_CO9-2)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_executing_the_app_CO9-2)'
- en: The component markup uses the framework-provided `AuthorizeView` component.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件的标记使用了框架提供的`AuthorizeView`组件。
- en: 'The component defines two directives: one to specify that it *inherits* from
    `LocalizableComponentBase` and one to *inject* the `SignOutSessionStateManager`
    service. `LocalizableComponentBase` is a custom base component, which is covered
    in [Chapter 5](ch05.html#chapter-five).'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件定义了两个指令：一个指定它从`LocalizableComponentBase`继承，另一个*注入*`SignOutSessionStateManager`服务。`LocalizableComponentBase`是一个自定义的基础组件，在[第5章](ch05.html#chapter-five)中有详细介绍。
- en: The component markup uses the `AuthorizeView` component and its various authorized-state-dependent
    templates to render content when the user is currently authorizing, already authorized,
    or not authorized. Each of these states has independent markup.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件的标记使用`AuthorizeView`组件及其各种依赖于授权状态的模板来呈现内容，当用户正在授权、已经授权或未经授权时。每个状态都有独立的标记。
- en: When authorizing, the “logging in” message is localized and rendered to the
    screen. When the user is authorized, the `context` exposes the `ClaimsPrincipal`
    object that’s assigned to the `user` variable. Consider the `Localizer` object
    from the previous markup. This specific type comes from the inheritance of the
    custom `LocalizableComponentBase<LoginDisplay>` class. This `Localizer` exposes
    localization functionality that is based on Microsoft’s resource (*.resx*)-driven
    key/value pairs (KVPs) and the frameworks’ `IStringLocalizer<T>` type. The custom
    *LocalizableComponent​Base.cs* class is located in the *Components* directory.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行授权时，“正在登录”消息被本地化并呈现到屏幕上。当用户经过授权时，`context`暴露了分配给`user`变量的`ClaimsPrincipal`对象。考虑前面标记中的`Localizer`对象。这种特定类型来自于自定义`LocalizableComponentBase<LoginDisplay>`类的继承。这个`Localizer`提供了基于Microsoft资源驱动的键/值对（KVPs）和框架的`IStringLocalizer<T>`类型的本地化功能。自定义的*LocalizableComponentBase.cs*类位于*Components*目录中。
- en: The code creates a tool tip it will render—the string concatenation of the user’s
    name and email address. The tool tip is bound to the button element’s `data-tooltip`
    attribute. This is part of the Bulma CSS framework for tool tips. Hovering over
    the logout button will render the message. When the user is not authorized, we
    render a button with a localized login message.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 代码创建了一个工具提示，它将呈现用户姓名和电子邮件地址的字符串连接。工具提示绑定到按钮元素的`data-tooltip`属性。这是Bulma CSS框架中工具提示的一部分。当悬停在注销按钮上时，将呈现消息。当用户未经授权时，我们会呈现一个带有本地化登录消息的按钮。
- en: 'Next, let’s take a look at its shadowed component, the *LoginDisplay.cs* file:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来看一下它的阴影组件，*LoginDisplay.cs*文件：
- en: '[PRE18]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This component provides two functions that use the injected `Navigation` service.
    The `Navigation` property is assigned by the DI framework and is functionally
    equivalent to the component’s `@inject` directive syntax. Each method navigates
    to the desired authentication route. When `OnLogOut` is invoked, `SignOutManager`
    has its sign-out state set before navigating away. Each route is handled by the
    app’s corresponding authentication logic. The user will see their name next to
    a logout button when they’re authenticated, but if they’re not authenticated,
    they will see only a login button. Users can sign up with the application by providing
    and validating their email. This is managed by Azure Active Directory (Azure AD)
    business-to-consumer (B2C). As an alternative to signing up with the application,
    you can use one of the available third-party authentication providers, such as
    Google, Twitter, and GitHub.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件提供了两个使用注入的`Navigation`服务的函数。`Navigation`属性由DI框架分配，并且在功能上等同于组件的`@inject`指令语法。每个方法导航到所需的认证路由。当调用`OnLogOut`时，在导航之前，`SignOutManager`将其登出状态设置。每个路由由应用程序相应的认证逻辑处理。用户在经过身份验证后将在注销按钮旁看到其姓名，但如果未经身份验证，则仅会看到登录按钮。用户可以通过提供和验证其电子邮件与应用程序注册。这由Azure
    Active Directory（Azure AD）业务对消费者（B2C）管理。作为与应用程序注册的替代方案，您可以使用可用的第三方身份验证提供程序，如Google、Twitter和GitHub。
- en: Native theme awareness
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原生主题感知
- en: 'An app’s ability to be color-scheme aware is highly recommended for all modern
    web apps. From CSS, it is easy to specify style rules that are scoped to media-dependent
    queryable values. Consider the following CSS:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有现代Web应用程序，强烈建议应用程序具备色彩方案感知能力。从CSS中，很容易指定针对媒体相关查询值的样式规则。考虑以下CSS：
- en: '[PRE19]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The rules within this media query apply only when the browser is set to prefer
    the `dark` theme. These media queries can also be accessed programmatically from
    JavaScript. The [`window.matchMedia` method](https://oreil.ly/uFPAD) is used to
    detect changes to the client browser preferences. Let’s look first at the *ThemeIndicator​Com⁠ponent.razor*
    file:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此媒体查询中的规则仅在浏览器设置为偏好 `dark` 主题时应用。这些媒体查询也可以通过 JavaScript 从程序中访问。使用 [`window.matchMedia`
    方法](https://oreil.ly/uFPAD) 检测客户端浏览器偏好的更改。首先让我们看一下 *ThemeIndicator​Com⁠ponent.razor*
    文件：
- en: '[PRE20]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[![1](assets/1.png)](#co_executing_the_app_CO10-1)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_executing_the_app_CO10-1)'
- en: Inherits from the generic `LocalizableComponentBase` class.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 继承自通用的 `LocalizableComponentBase` 类。
- en: '[![2](assets/2.png)](#co_executing_the_app_CO10-2)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_executing_the_app_CO10-2)'
- en: The primary markup for `ThemeIndicatorComponent` is the button.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThemeIndicatorComponent` 的主要标记是按钮。'
- en: '[![3](assets/3.png)](#co_executing_the_app_CO10-3)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_executing_the_app_CO10-3)'
- en: '`ThemeIndicatorComponent` makes use of `<HeadContent>`.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThemeIndicatorComponent` 使用 `<HeadContent>`。'
- en: Hopefully, you’re noticing that a lot of components are inheriting from the
    generic `LocalizableComponentBase` class. Again, we’ll cover this in [Chapter 5](ch05.html#chapter-five).
    Just know that it exposes a `Localizer` member that lets us get a localized string
    value given a string key via a free-range indexer.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您已经注意到，许多组件都是从通用的 `LocalizableComponentBase` 类继承而来。我们将在 [第五章](ch05.html#chapter-five)
    再次讨论这一点。只需知道它公开了一个 `Localizer` 成员，通过自由索引器可以让我们根据字符串键获取本地化字符串值。
- en: The primary markup for `ThemeIndicatorComponent` is the button. The button’s
    `class` attribute is mixed, with verbatim class names and Razor expressions that
    are evaluated at runtime. The `_buttonClass` member is a C# string field that
    is bound to the `"is-"` prefix. This button also has a tool tip, and its message
    is conditionally assigned dependent on the ternary expression from the `_isDarkTheme`
    boolean value. The Font Awesome class is also bound to an `_iconClass` field member.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThemeIndicatorComponent` 的主要标记是按钮。按钮的 `class` 属性混合了直接的类名和在运行时求值的 Razor 表达式。`_buttonClass`
    成员是一个 C# 字符串字段，绑定到 `"is-"` 前缀。此按钮还有一个工具提示，其消息根据 `_isDarkTheme` 布尔值的三元表达式有条件地赋值。Font
    Awesome 类也绑定到 `_iconClass` 字段成员。'
- en: '`ThemeIndicatorComponent` makes use of `<HeadContent>`. This is a framework-provided
    component that allows us to dynamically update the HTML’s `<head>` content. It’s
    very powerful and useful for updating `<meta>` elements on the fly. When the theme
    is `dark`, the app specifies that the Twitter widgets should also be themed accordingly.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThemeIndicatorComponent` 使用 `<HeadContent>`。这是一个由框架提供的组件，允许我们动态更新 HTML 的 `<head>`
    内容。它非常强大，用于在运行时更新 `<meta>` 元素非常有用。当主题为 `dark` 时，应用程序指定 Twitter 小部件也应相应地进行主题设置。'
- en: Note
  id: totrans-260
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: While the `HeadContent` component can update `meta` tags, it’s still not ideal
    for search engine optimization (SEO) when using Blazor WebAssembly. This is because
    the `meta` tags are updated dynamically. To achieve static `meta` tag values,
    you’d have to use Blazor WebAssembly prerendering. For more information about
    component integration scenarios, see Microsoft’s [“Prerender and Integrate ASP.NET
    Core Razor Components” documentation](https://oreil.ly/NmB4A).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `HeadContent` 组件可以更新 `meta` 标签，但在使用 Blazor WebAssembly 时，这对于搜索引擎优化（SEO）来说仍然不是理想的。这是因为
    `meta` 标签是动态更新的。要实现静态的 `meta` 标签值，您必须使用 Blazor WebAssembly 预渲染。有关组件集成方案的更多信息，请参阅微软的
    [“预渲染和集成 ASP.NET Core Razor 组件” 文档](https://oreil.ly/NmB4A)。
- en: 'Next, let’s look at its corresponding component shadow, the C# file *ThemeIndicator​Component.razor.cs*:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下其对应的组件阴影，即 C# 文件 *ThemeIndicator​Component.razor.cs*：
- en: '[PRE21]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[![1](assets/1.png)](#co_executing_the_app_CO11-1)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_executing_the_app_CO11-1)'
- en: The `ThemeIndicatorComponent` component shadow is defined.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了 `ThemeIndicatorComponent` 组件的阴影。
- en: '[![2](assets/2.png)](#co_executing_the_app_CO11-2)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_executing_the_app_CO11-2)'
- en: There are a few conditional CSS classes that are bound to field values.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个条件性的 CSS 类绑定到字段值。
- en: '[![3](assets/3.png)](#co_executing_the_app_CO11-3)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_executing_the_app_CO11-3)'
- en: The component overrides `OnInitializedAsync`, where it performs a bit of app
    state theme logic.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 组件重写了 `OnInitializedAsync` 方法，在此方法中执行一些应用程序状态主题逻辑。
- en: '[![4](assets/4.png)](#co_executing_the_app_CO11-4)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_executing_the_app_CO11-4)'
- en: The callback method named `UpdateDarkThemePreference`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 名为 `UpdateDarkThemePreference` 的回调方法。
- en: '`ThemeIndicatorComponent` is a read-only indicator of the current theme detected.
    There are only two types the app supports: Light and Dark. There are a few private
    fields, but you’ll recall that these are accessible to the markup and bound where
    needed. These two `string` fields are simple ternary expressions based on the
    `AppState.IsDarkTheme` value. The component overrides `OnInitializedAsync`, where
    it assigns the current state of the `AppState.IsDarkTheme` variable and calls
    the `Get​Cur⁠rentDarkThemePreference` method, which is an `IJSRuntime` extension
    method. This method requires the `ThemeIndicatorComponent` to reference itself
    and the callback method name. C#’s `nameof` expression produces the name of its
    argument, which in this case is the callback. This means that we’re registering
    our .NET component to receive a callback from the JavaScript side given a .NET
    object reference.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThemeIndicatorComponent` 是当前检测到的主题的只读指示器。应用程序仅支持两种类型：Light 和 Dark。有几个私有字段，但您会记得这些字段在需要时可以通过标记访问和绑定。这两个
    `string` 字段是基于 `AppState.IsDarkTheme` 值的简单三元表达式。组件重写了 `OnInitializedAsync` 方法，在其中分配了
    `AppState.IsDarkTheme` 变量的当前状态，并调用 `Get​Cur⁠rentDarkThemePreference` 方法，这是一个 `IJSRuntime`
    扩展方法。该方法要求 `ThemeIndicatorComponent` 引用自身和回调方法的名称。C# 的 `nameof` 表达式生成其参数的名称，本例中为回调函数的名称。这意味着我们正在注册我们的
    .NET 组件，以便在给定 .NET 对象引用时从 JavaScript 端接收回调。'
- en: 'The callback method named `UpdateDarkThemePreference` expects the `isDarkTheme`
    value. The method must be decorated with the `JSInvokable` attribute for it to
    be callable from JavaScript. Since this callback can be invoked anytime after
    the component is initialized, it must use the combination of `InvokeAsync` and
    `StateHasChanged`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 名为 `UpdateDarkThemePreference` 的回调方法预期 `isDarkTheme` 值。必须使用 `JSInvokable` 属性装饰该方法，以便从
    JavaScript 中调用。由于此回调可以在组件初始化后的任何时候调用，因此必须使用 `InvokeAsync` 和 `StateHasChanged`
    的组合：
- en: '`InvokeAsync`'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`InvokeAsync`'
- en: Executes the supplied work item on the associated renderer’s synchronization
    context.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在关联的渲染器同步上下文中执行提供的工作项。
- en: '`StateHasChanged`'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`StateHasChanged`'
- en: Notifies the component that its state has changed. When applicable, this will
    cause the component to be rerendered.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 通知组件其状态已更改。在适用的情况下，这将导致组件重新渲染。
- en: 'Let’s now consider the following *JSRuntimeExtensions.cs* C# file for the `GetCurrentDarkThemePreferenceAsync`
    extension method:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑下面的 *JSRuntimeExtensions.cs* C# 文件，用于 `GetCurrentDarkThemePreferenceAsync`
    扩展方法：
- en: '[PRE22]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[![1](assets/1.png)](#co_executing_the_app_CO12-1)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_executing_the_app_CO12-1)'
- en: The `dotnetObj` parameter is generic and constrained to `class`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`dotnetObj` 参数是泛型参数，被限制为 `class`。'
- en: '[![2](assets/2.png)](#co_executing_the_app_CO12-2)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_executing_the_app_CO12-2)'
- en: The `javaScript` runtime instance calls interop methods.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`javaScript` 运行时实例调用互操作方法。'
- en: '[![3](assets/3.png)](#co_executing_the_app_CO12-3)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_executing_the_app_CO12-3)'
- en: The `"app.getClientPrefersColorScheme"` method is called.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `"app.getClientPrefersColorScheme"` 方法。
- en: '[![4](assets/4.png)](#co_executing_the_app_CO12-4)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_executing_the_app_CO12-4)'
- en: An argument with a value of `"dark"` is passed to the `"app.getClientPrefers​Co⁠lorScheme"`
    method.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 将值为 `"dark"` 的参数传递给 `"app.getClientPrefers​Co⁠lorScheme"` 方法。
- en: '[![5](assets/5.png)](#co_executing_the_app_CO12-5)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_executing_the_app_CO12-5)'
- en: '`DotNetObjectReference.Create(dotnetObj)` creates an instance of `DotNet​Ob⁠jectReference<ThemeIndicatorComponent>`.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`DotNetObjectReference.Create(dotnetObj)` 创建一个 `DotNet​Ob⁠jectReference<ThemeIndicatorComponent>`
    实例。'
- en: '[![6](assets/6.png)](#co_executing_the_app_CO12-6)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_executing_the_app_CO12-6)'
- en: '`callbackMethodName` is the calling method name.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`callbackMethodName` 是调用方法的名称。'
- en: The extension method defines a generic type parameter, `T`, which is constrained
    to a `class`. The object instance, in this case, is `ThemeIndicatorComponent`,
    but it could be any `class`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法定义了一个泛型类型参数 `T`，该参数被限制为 `class`。在本例中，对象实例是 `ThemeIndicatorComponent`，但它可以是任何
    `class`。
- en: The `javaScript` runtime instance is used to call a `ValueTask<bool>` returning
    interop function. The `"app.getClientPrefersColorScheme"` method is a JavaScript
    method that is accessible on the `window` scope.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `javaScript` 运行时实例调用返回 `ValueTask<bool>` 的互操作函数。`"app.getClientPrefersColorScheme"`
    方法是一个可以在 `window` 范围内访问的 JavaScript 方法。
- en: The hardcoded value of `"dark"` is passed to the `app.getClientPrefersColorScheme`
    function as the first parameter. It’s hardcoded because we know that we’re trying
    to evaluate whether or not the current client browser prefers the dark theme.
    When they do, this will return `true`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '"dark"的硬编码值作为第一个参数传递给`app.getClientPrefersColorScheme`函数。它是硬编码的，因为我们知道我们正在尝试评估当前客户端浏览器是否喜欢暗主题。当他们喜欢时，这将返回`true`。'
- en: '`DotNetObjectReference.Create(dotnetObj)` creates an instance of `DotNetObject​Re⁠ference<ThemeIndicatorComponent>`,
    and this is passed to the corresponding JavaScript function as the second parameter.
    This is used as a reference so that JavaScript can call back into the .NET component.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`DotNetObjectReference.Create(dotnetObj)` 创建一个`DotNetObject​Re⁠ference<ThemeIndicatorComponent>`的实例，并将其作为第二个参数传递给相应的
    JavaScript 函数。这被用作一个引用，以便 JavaScript 可以回调到 .NET 组件。'
- en: '`callbackMethodName` is a method name from the calling `ThemeIndicatorComponent`
    instance that is decorated with a `JSInvokable` attribute. This method can and
    will be called from JavaScript when needed.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`callbackMethodName` 是调用的`ThemeIndicatorComponent`实例中的方法名，该方法装饰有`JSInvokable`属性。当需要时，此方法可以从
    JavaScript 中调用。'
- en: 'Considering this is your first look at JavaScript interop, let me anticipate
    and answer a few questions you may have:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这是你第一次接触 JavaScript 互操作，让我预见并回答你可能有的一些问题：
- en: Question
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 问题
- en: Where is this JavaScript coming from, and what does it look like?
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 JavaScript 是从哪里来的，它是什么样子？
- en: Answer
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 答案
- en: This JavaScript is part of the *app.js* file that was referenced in the *index.html*.
    It’s served under the *wwwroot* folder. We’ll look at the source in the next section.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 JavaScript 是*index.html*中引用的*app.js*文件的一部分。它位于*wwwroot*文件夹下。我们将在下一节中查看源代码。
- en: Question
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 问题
- en: What capabilities does it have?
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有哪些功能？
- en: Answer
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 答案
- en: That depends on what you’re looking to achieve, but really, anything you might
    imagine. For this specific use case, the JavaScript will expose a utilitarian
    helper function named `getClientPrefersColorScheme`. Internally, JavaScript relies
    on the `window.matchMedia` APIs. The .NET code makes an interop call into JavaScript
    and passes a component reference. The JavaScript code registers an event handler
    to monitor whether the user changes their color scheme preference. The current
    preference is returned immediately back to .NET from JavaScript, but the event
    handler is still registered. If the user preference changes, using the given component
    reference, the JavaScript code will make an interop call back into .NET with the
    new color scheme preference. This exemplifies bidirectional interop.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于你想要实现什么，但实际上，任何你可能想象到的东西。对于这个特定的用例，JavaScript 将公开一个实用的辅助函数，名为`getClientPrefersColorScheme`。在内部，JavaScript
    依赖于`window.matchMedia` API。.NET 代码通过 JavaScript 进行交互调用，并传递一个组件引用。JavaScript 代码注册了一个事件处理程序，以监视用户是否更改了他们的颜色方案首选项。当前的首选项立即从
    JavaScript 返回到 .NET，但事件处理程序仍然注册。如果用户偏好更改，JavaScript 代码将使用给定的组件引用向 .NET 发出交互调用，传递新的颜色方案首选项。这展示了双向互操作性。
- en: Question
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 问题
- en: When do I need to write JavaScript interop code?
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我什么时候需要编写 JavaScript 互操作代码？
- en: Answer
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 答案
- en: Whenever you need finite control over a sequence of JavaScript APIs. A good
    example is when you need to interact with a third-party library or when calling
    native JavaScript APIs. You’ll see some good examples for when it’s appropriate
    to write JavaScript interop code throughout the book.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您需要对一系列 JavaScript API 进行有限控制时。一个很好的例子是当您需要与第三方库交互或调用原生 JavaScript API 时。在本书中，您将看到一些适合编写
    JavaScript 互操作代码的良好示例。
- en: Warning
  id: totrans-310
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Blazor is responsible for manipulating the DOM. If Blazor doesn’t support the
    DOM manipulation your app requires, you might need to write JavaScript interop
    code to achieve the desired behavior. However, this should be rare. Ideally, you’d
    avoid having two different approaches to the same problem.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 负责操作 DOM。如果 Blazor 不支持您的应用程序所需的 DOM 操作，您可能需要编写 JavaScript 互操作代码来实现所需的行为。但这应该是少数情况。理想情况下，您应该避免在解决同一问题时使用两种不同的方法。
- en: 'This specific JavaScript API uses the media query APIs, which are native to
    JavaScript. Consider the *app.js* JavaScript file:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的 JavaScript API 使用了媒体查询 API，这些 API 是 JavaScript 的本机支持。考虑*app.js* JavaScript
    文件：
- en: '[PRE23]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](assets/1.png)](#co_executing_the_app_CO13-1)'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_executing_the_app_CO13-1)'
- en: Consider the `getClientPrefersColorScheme` function.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑`getClientPrefersColorScheme`函数。
- en: '[![2](assets/2.png)](#co_executing_the_app_CO13-2)'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_executing_the_app_CO13-2)'
- en: A `media` instance is assigned from the call to `window.matchMedia`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 从调用`window.matchMedia`分配一个`media`实例。
- en: '[![3](assets/3.png)](#co_executing_the_app_CO13-3)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_executing_the_app_CO13-3)'
- en: The `media.onchange` event handler property is assigned to an inline function.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 将`media.onchange`事件处理程序属性分配给一个内联函数。
- en: '[![4](assets/4.png)](#co_executing_the_app_CO13-4)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_executing_the_app_CO13-4)'
- en: When the `media` instance changes, the .NET object has its callback invoked.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当`media`实例发生变化时，.NET对象会调用其回调函数。
- en: '[![5](assets/5.png)](#co_executing_the_app_CO13-5)'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_executing_the_app_CO13-5)'
- en: The `media.matches` value is returned.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`media.matches`值。
- en: '[![6](assets/6.png)](#co_executing_the_app_CO13-6)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_executing_the_app_CO13-6)'
- en: '`getClientPrefersColorScheme` is added to the `window.app` object.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`getClientPrefersColorScheme`被添加到`window.app`对象。'
- en: The `getClientPrefersColorScheme` function is defined as a `const` function
    with `color`, `dotnetObj`, and `callbackMethodName` parameters. A `media` instance
    is assigned from the call to `window.matchMedia`, given the media query string.
    The `media.onchange` event handler property is assigned to an inline function.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`getClientPrefersColorScheme`函数被定义为一个带有`color`、`dotnetObj`和`callbackMethodName`参数的`const`函数。从调用`window.matchMedia`分配一个`media`实例，给定媒体查询字符串。将`media.onchange`事件处理程序属性分配给一个内联函数。'
- en: The event handler inline function relies on the `dotnetObj` instance, which
    is a reference to the calling Blazor component. This is JavaScript interop in
    which JavaScript calls into .NET. In other words, if the user changes their preferences,
    the `onchange` event is fired and the Blazor component has its `callbackMethodName`
    invoked.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理程序内联函数依赖于`dotnetObj`实例，该实例是对调用的Blazor组件的引用。这是JavaScript与.NET的交互，换句话说，如果用户更改其偏好设置，则触发`onchange`事件，并调用Blazor组件的`callbackMethodName`。
- en: The `media.matches` value is returned, indicating to the caller the current
    value of whether the media query string matches. `getClientPrefersColorScheme`
    is added to the `window.app` object.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`media.matches`值，向调用方指示媒体查询字符串当前匹配的值。`getClientPrefersColorScheme`被添加到`window.app`对象。
- en: Putting all of this together, you can reference `<ThemeIndicatorComponent />`
    in any Blazor component, and you’d have a self-contained, color scheme–aware component.
    As the client preferences change, the component dynamically updates its current
    rendered HTML representation of the color scheme. The component relies on JavaScript
    interop, and it’s seamless from C#.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些内容结合起来，您可以在任何Blazor组件中引用`<ThemeIndicatorComponent />`，并拥有一个自包含的、颜色方案感知的组件。随着客户端偏好的变化，组件会动态更新其当前呈现的HTML表示的颜色方案。该组件依赖于JavaScript互操作，并且从C#无缝集成。
- en: Summary
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, I guided you through the inner workings of how Blazor Web­Assem⁠bly
    starts. From the serving and processing of static HTML to the invocation of JavaScript
    that bootstraps Blazor, you explored the anatomy of the app. This includes the
    `Program` entry point and the startup conventions. You learned about the router,
    client-side navigation, shared components, and layouts. You also learned about
    top-level navigation components in the app and how content is rendered through
    `RenderFragment` placeholders. The model app demonstrated a native color scheme–aware
    component and an example of JavaScript interop. In the next chapter, you’ll see
    how to author custom Blazor components and how to use JavaScript interop. You’ll
    learn more about how Blazor uses authentication to verify a user’s identity and
    how to conditionally render markup. Finally, you’ll see how to use various data-binding
    techniques and rely on data from HTTP services.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我指导您了解了Blazor WebAssembly启动的内部工作原理。从静态HTML的服务和处理到调用JavaScript引导Blazor的过程，您探索了应用程序的解剖学。这包括`Program`入口点和启动约定。您了解了路由器、客户端导航、共享组件和布局。您还了解了应用程序中顶级导航组件以及如何通过`RenderFragment`占位符渲染内容。示范应用程序展示了一个原生的颜色方案感知组件和一个JavaScript互操作的示例。在下一章中，您将看到如何编写自定义Blazor组件以及如何使用JavaScript互操作。您将进一步了解Blazor如何使用身份验证来验证用户的身份以及如何有条件地渲染标记。最后，您将看到如何使用各种数据绑定技术并依赖来自HTTP服务的数据。
