- en: Chapter 17\. Assemblies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第17章。程序集
- en: An *assembly* is the basic unit of deployment in .NET and is also the container
    for all types. An assembly contains compiled types with their Intermediate Language
    (IL) code, runtime resources, and information to assist with versioning and referencing
    other assemblies. An assembly also defines a boundary for type resolution. In
    .NET, an assembly comprises a single file with a *.dll* extension.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*程序集*是.NET中的部署基本单元，也是所有类型的容器。程序集包含具有其中间语言（IL）代码的编译类型，运行时资源，并帮助版本控制和引用其他程序集的信息。程序集还定义了类型解析的边界。在.NET中，一个程序集由一个扩展名为*.dll*的单个文件组成。'
- en: Note
  id: totrans-2
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'When you build an executable application in .NET, you end up with two files:
    an assembly (*.dll*) and an executable launcher (*.exe*) appropriate to the platform
    you’re targeting.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在.NET中构建可执行应用程序时，最终会得到两个文件：一个程序集（*.dll*）和一个适合目标平台的可执行启动器（*.exe*）。
- en: This differs from what happens in .NET Framework, which generates a *portable
    executable* (PE) assembly. A PE has an *.exe* extension and acts both as an assembly
    and an application launcher. A PE can simultaneously target 32- and 64-bit versions
    of Windows.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这与.NET Framework中的情况不同，后者生成一个*可移植可执行文件*（PE）程序集。PE具有*.exe*扩展名，既可以作为程序集，又可以作为应用程序启动器。PE可以同时针对32位和64位Windows版本。
- en: 'Most of the types in this chapter come from the following namespaces:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章大部分类型来自以下命名空间：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What’s in an Assembly
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个程序集的内容
- en: 'An assembly contains four kinds of things:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个程序集包含四种内容：
- en: An assembly manifest
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 程序集清单
- en: Provides information to the CLR, such as the assembly’s name, version, and other
    assemblies that it references
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 提供CLR的信息，例如程序集的名称、版本和其他它引用的程序集
- en: An application manifest
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序清单
- en: Provides information to the operating system, such as how the assembly should
    be deployed and whether administrative elevation is required
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 提供操作系统的信息，例如程序集应如何部署以及是否需要管理员权限
- en: Compiled types
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 编译类型
- en: The compiled IL code and metadata of the types defined within the assembly
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 程序集中定义的类型的编译IL代码和元数据
- en: Resources
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 资源
- en: Other data embedded within the assembly, such as images and localizable text
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 程序集中嵌入的其他数据，例如图像和可本地化文本
- en: Of these, only the *assembly manifest* is mandatory, although an assembly nearly
    always contains compiled types (unless it’s a resource assembly. See [“Resources
    and Satellite Assemblies”](#resources_and_satellite_assemblies)).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些中，只有*程序集清单*是强制的，尽管一个程序集几乎总是包含编译的类型（除非它是一个资源程序集。参见[“资源和卫星程序集”](#resources_and_satellite_assemblies)）。
- en: The Assembly Manifest
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序集清单
- en: 'The assembly manifest serves two purposes:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 程序集清单有两个目的：
- en: It describes the assembly to the managed hosting environment.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它描述了程序集给托管的主机环境。
- en: It acts as a directory to the modules, types, and resources in the assembly.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它充当模块、类型和程序集中的资源的目录。
- en: Assemblies are thus *self-describing*. A consumer can discover all of an assembly’s
    data, types, and functions—without needing additional files.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，程序集是*自描述的*。使用者可以发现程序集的所有数据、类型和函数，而无需额外的文件。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: An assembly manifest is not something you add explicitly to an assembly—it’s
    automatically embedded into an assembly as part of compilation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 程序集清单并不是你明确添加到程序集中的东西——它是编译过程中自动嵌入到程序集中的一部分。
- en: 'Here’s a summary of the functionally significant data stored in the manifest:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是存储在清单中的功能重要数据的摘要：
- en: The simple name of the assembly
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序集的简单名称
- en: A version number (`AssemblyVersion`)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本号（`AssemblyVersion`）
- en: A public key and signed hash of the assembly, if strongly named
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序集的公钥和签名哈希（如果是强命名的）
- en: A list of referenced assemblies, including their version and public key
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用程序集的列表，包括它们的版本和公钥
- en: A list of types defined in the assembly
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出程序集中定义的类型
- en: The culture it targets, if a satellite assembly (`AssemblyCulture`)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它所针对的文化，如果是卫星程序集（`AssemblyCulture`）
- en: 'The manifest can also store the following informational data:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 清单还可以存储以下信息数据：
- en: A full title and description (`AssemblyTitle` and `AssemblyDescription`)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整的标题和描述（`AssemblyTitle` 和 `AssemblyDescription`）
- en: Company and copyright information (`AssemblyCompany` and `AssemblyCopyright`)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公司和版权信息（`AssemblyCompany` 和 `AssemblyCopyright`）
- en: A display version (`AssemblyInformationalVersion`)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示版本（`AssemblyInformationalVersion`）
- en: Additional attributes for custom data
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于自定义数据的其他属性
- en: Some of this data is derived from arguments given to the compiler, such as the
    list of referenced assemblies or the public key with which to sign the assembly.
    The rest comes from assembly attributes, indicated in parentheses.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些数据源于向编译器提供的参数，例如引用的程序集列表或用于签名程序集的公钥。其余部分来自程序集属性，括在括号中。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can view the contents of an assembly’s manifest with the .NET tool *ildasm.exe*.
    In [Chapter 18](ch18.html#reflection_and_metadata), we describe how to use reflection
    to do the same programmatically.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 .NET 工具 *ildasm.exe* 查看程序集清单的内容。在 [第 18 章](ch18.html#reflection_and_metadata)
    中，我们描述了如何使用反射以编程方式执行相同操作。
- en: Specifying assembly attributes
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定程序集属性
- en: Commonly used assembly attributes can be specified in Visual Studio on the project’s
    Properties page, on the Package tab. The settings on that tab are added to the
    project file (*.csproj*).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 常用程序集属性可以在项目的属性页上指定，位于“包”选项卡中的 Visual Studio 中。该选项卡上的设置将添加到项目文件（*.csproj*）中。
- en: To specify attributes not supported by the Package tab, or if not working with
    a *.csproj* file, you can specify assembly attributes in source code (this is
    often done in a file called *AssemblyInfo.cs*).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定不受“包”选项卡支持的属性，或者不使用 *.csproj* 文件，可以在源代码中指定程序集属性（通常在名为 *AssemblyInfo.cs* 的文件中完成）。
- en: 'A dedicated attributes file contains only `using` statements and assembly attribute
    declarations. For example, to expose internally scoped types to a unit test project,
    you would do this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 专用属性文件仅包含 `using` 语句和程序集属性声明。例如，要向单元测试项目公开内部作用域类型，可以执行以下操作：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Application Manifest (Windows)
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序清单（Windows）
- en: An application manifest is an XML file that communicates information about the
    assembly to the OS. An application manifest is embedded into the startup executable
    as a Win32 resource during the build process. If present, the manifest is read
    and processed before the CLR loads the assembly—and can influence how Windows
    launches the application’s process.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序清单是一个 XML 文件，用于向操作系统传达有关程序集的信息。在构建过程中，应用程序清单作为 Win32 资源嵌入到启动可执行文件中。如果存在清单，则在
    CLR 加载程序集之前会读取和处理清单，可能影响 Windows 启动应用程序的方式。
- en: 'A .NET application manifest has a root element called `assembly` in the XML
    namespace `urn:schemas-microsoft-com:asm.v1`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 应用程序清单在 XML 命名空间 `urn:schemas-microsoft-com:asm.v1` 中具有名为 `assembly` 的根元素：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following manifest instructs the OS to request administrative elevation:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下清单指示操作系统请求管理员权限：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: (UWP applications have a far more elaborate manifest, described in the *Package​.appxmanifest*
    file. This includes a declaration of the program’s capabilities, which determine
    permissions granted by the OS. The easiest way to edit this file is with Visual
    Studio, which displays a dialog when you double-click the manifest file.)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: （UWP 应用程序具有更为复杂的清单，在 *Package​.appxmanifest* 文件中进行描述。这包括程序的功能声明，决定了操作系统授予的权限。编辑此文件的最简单方式是使用
    Visual Studio，双击清单文件时会显示对话框。）
- en: Deploying an application manifest
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署应用程序清单
- en: You can add an application manifest to a .NET project in Visual Studio by right-clicking
    your project in Solution Explorer, selecting Add, then New Item, and then choosing
    Application Manifest File. Upon building, the manifest will be embedded into the
    output assembly.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中，通过在解决方案资源管理器中右键单击项目，选择“添加”，然后选择“新建项目”，再选择“应用程序清单文件”，即可向 .NET
    项目添加应用程序清单。构建项目后，清单将嵌入到输出的程序集中。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The .NET tool *ildasm.exe* is blind to the presence of an embedded application
    manifest. Visual Studio, however, indicates whether an embedded application manifest
    is present if you double-click the assembly in Solution Explorer.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 工具 *ildasm.exe* 无法感知嵌入的应用程序清单的存在。但是，使用 Visual Studio 时，如果在解决方案资源管理器中双击程序集，可以看到是否存在嵌入的应用程序清单。
- en: Modules
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块
- en: The contents of an assembly are actually packaged within an intermediate container,
    called a *module*. A module corresponds to a file containing the contents of an
    assembly. The reason for this extra layer of containership is to allow an assembly
    to span multiple files, a feature present in .NET Framework but absent in .NET
    5+ and .NET Core. [Figure 17-1](#single_file_assembly) illustrates the relationship.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 程序集的内容实际上打包在一个中间容器中，称为 *模块*。模块对应于包含程序集内容的文件。引入此额外的容器层的原因是允许一个程序集跨多个文件。这是 .NET
    Framework 中存在但在 .NET 5+ 和 .NET Core 中缺失的功能。[图 17-1](#single_file_assembly) 描述了这种关系。
- en: '![Single-file assembly](assets/cn10_1701.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![单文件程序集](assets/cn10_1701.png)'
- en: Figure 17-1\. Single-file assembly
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图17-1\. 单文件组件
- en: Although .NET does not support multifile assemblies, at times you need to be
    aware of the extra level of containership that modules impose. The main scenario
    is with reflection (see [“Reflecting Assemblies”](ch18.html#reflecting_assemblies)
    and [“Emitting Assemblies and Types”](ch18.html#emitting_assemblies_and_types)).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 .NET 不支持多文件组件，但有时您需要注意模块带来的额外层次结构。主要场景是反射（见 [“反射组件”](ch18.html#reflecting_assemblies)
    和 [“生成组件和类型”](ch18.html#emitting_assemblies_and_types)）。
- en: The Assembly Class
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Assembly 类
- en: 'The `Assembly` class in `System.Reflection` is a gateway to accessing assembly
    metadata at runtime. There are a number of ways to obtain an assembly object:
    the simplest is via a `Type`’s `Assembly` property:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Reflection` 中的 `Assembly` 类是在运行时访问组件元数据的入口。有多种方法可以获取组件对象：最简单的方法是通过
    `Type` 的 `Assembly` 属性：'
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can also obtain an `Assembly` object by calling one of `Assembly`’s static
    methods:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过调用 `Assembly` 的静态方法之一来获取 `Assembly` 对象：
- en: '`GetExecutingAssembly`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetExecutingAssembly`'
- en: Returns the assembly of the type that defines the currently executing function
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 返回定义当前执行函数的类型的组件
- en: '`GetCallingAssembly`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetCallingAssembly`'
- en: Does the same as `GetExecutingAssembly` but for the function that called the
    currently executing function
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 执行与 `GetExecutingAssembly` 相同的操作，但适用于调用当前执行函数的函数
- en: '`GetEntryAssembly`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetEntryAssembly`'
- en: Returns the assembly defining the application’s original entry method
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 返回定义应用程序原始入口方法的组件
- en: After you have an `Assembly` object, you can use its properties and methods
    to query the assembly’s metadata and reflect upon its types. [Table 17-1](#assembly_members)
    shows a summary of these functions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 获取 `Assembly` 对象后，您可以使用其属性和方法查询组件的元数据，并反映其类型。[表 17-1](#assembly_members) 总结了这些功能。
- en: Table 17-1\. Assembly members
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 表17-1\. 组件成员
- en: '| Functions | Purpose | See the section... |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 目的 | 参见章节... |'
- en: '| --- | --- | --- |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `FullName`, `GetName` | Returns the fully qualified name or an `AssemblyName`
    object | [“Assembly Names”](#assembly_names) |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `FullName`, `GetName` | 返回完全限定名称或 `AssemblyName` 对象 | [“组件名称”](#assembly_names)
    |'
- en: '| `CodeBase`, `Location` | Location of the assembly file | [“Loading, Resolving,
    and Isolating Assemblies”](#loadingcomma_resolvingcomma_and_isolati) |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `CodeBase`, `Location` | 组件文件的位置 | [“加载、解析和隔离组件”](#loadingcomma_resolvingcomma_and_isolati)
    |'
- en: '| `Load`, `LoadFrom`, `LoadFile` | Manually loads an assembly into memory |
    [“Loading, Resolving, and Isolating Assemblies”](#loadingcomma_resolvingcomma_and_isolati)
    |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `Load`, `LoadFrom`, `LoadFile` | 手动将组件加载到内存中 | [“加载、解析和隔离组件”](#loadingcomma_resolvingcomma_and_isolati)
    |'
- en: '| `GetSatelliteAssembly` | Locates the satellite assembly of a given culture
    | [“Resources and Satellite Assemblies”](#resources_and_satellite_assemblies)
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `GetSatelliteAssembly` | 定位给定文化的卫星组件 | [“资源和卫星组件”](#resources_and_satellite_assemblies)
    |'
- en: '| `GetType`, `GetTypes` | Returns a type, or all types, defined in the assembly
    | [“Reflecting and Activating Types”](ch18.html#reflecting_and_activating_types)
    |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `GetType`, `GetTypes` | 返回组件中定义的类型或所有类型 | [“反射和激活类型”](ch18.html#reflecting_and_activating_types)
    |'
- en: '| `EntryPoint` | Returns the application’s entry method, as a `MethodInfo`
    | [“Reflecting and Invoking Members”](ch18.html#reflecting_and_invoking_members)
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `EntryPoint` | 返回应用程序的入口方法，作为 `MethodInfo` | [“反射和调用成员”](ch18.html#reflecting_and_invoking_members)
    |'
- en: '| `GetModule`, `GetModules`, `ManifestModule` | Returns all modules, or the
    main module, of an assembly | [“Reflecting Assemblies”](ch18.html#reflecting_assemblies)
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `GetModule`, `GetModules`, `ManifestModule` | 返回组件的所有模块或主模块 | [“反射组件”](ch18.html#reflecting_assemblies)
    |'
- en: '| `GetCustomAttribute`, `GetCustomAttributes` | Returns the assembly’s attributes
    | [“Working with Attributes”](ch18.html#working_with_attributes) |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `GetCustomAttribute`, `GetCustomAttributes` | 返回组件的属性 | [“使用属性”](ch18.html#working_with_attributes)
    |'
- en: Strong Names and Assembly Signing
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强命名和组件签名
- en: Note
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Strongly naming an assembly was important in .NET Framework for two reasons:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET Framework 中，强命名组件之所以重要有两个原因：
- en: It allowed the assembly to be loaded into the “Global assembly cache.”
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许组件加载到“全局组件缓存”中。
- en: It allowed the assembly to by referenced by other strongly named assemblies.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许其他强命名组件引用该组件。
- en: Strong naming is much less important in .NET 5+ and .NET Core, because these
    runtimes do not have a global assembly cache, nor do they impose the second restriction.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 5+ 和 .NET Core 中，强命名不再那么重要，因为这些运行时没有全局组件缓存，也不会施加第二个限制。
- en: 'A *strongly named* assembly has a unique identity. It works by adding two bits
    of metadata to the manifest:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 强命名的程序集具有唯一的标识。它通过向清单添加两个元数据来工作：
- en: A *unique number* that belongs to the authors of the assembly
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属于程序集作者的*唯一编号*
- en: A *signed hash* of the assembly, proving that the unique number holder produced
    the assembly
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序集的签名哈希，证明唯一编号持有者生成了该程序集
- en: This requires a public/private key pair. The *public key* provides the unique
    identifying number, and the *private key* facilitates signing.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一个公共/私有密钥对。*公共密钥*提供唯一的标识号码，*私有密钥*用于签名。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '*Strong-name*-signing is not the same as *Authenticode*-signing. We cover Authenticode
    later in this chapter.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*强名称*签名与*Authenticode*签名不同。我们稍后在本章讨论Authenticode。'
- en: 'The public key is valuable in guaranteeing the uniqueness of assembly references:
    a strongly named assembly incorporates the public key into its identity.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 公共密钥在保证程序集引用的唯一性方面非常有价值：强命名的程序集将公钥并入其标识中。
- en: In .NET Framework, the private key protects your assembly from tampering, in
    that without your private key, no one can release a modified version of the assembly
    without the signature breaking. In practice, this is of use when loading an assembly
    into .NET Framework’s global assembly cache. In .NET 5+ and .NET Core, the signature
    is of little use because it’s never checked.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET Framework中，私钥保护您的程序集免受篡改，没有私钥，无法发布修改版而不破坏签名的程序集。实际上，在将程序集加载到.NET Framework的全局程序集缓存时，这非常有用。在.NET
    5+和.NET Core中，签名几乎没有用，因为从未检查过。
- en: Adding a strong name to a previously “weak” named assembly changes its identity.
    For this reason, it pays to strong-name an assembly from the outset if you think
    the assembly might need a strong name in the future.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 向之前命名“弱”的程序集添加强名称会改变其标识。因此，如果您认为程序集将来可能需要强名称，最好从一开始就为其添加强名称。
- en: How to Strongly Name an Assembly
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何为程序集提供强名称
- en: 'To give an assembly a strong name, first generate a public/private key pair
    with the *sn.exe* utility:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要为程序集提供强名称，首先使用*sn.exe*实用程序生成公共/私有密钥对：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Visual Studio installs a shortcut called *Developer Command Prompt for VS*,
    which starts a command prompt whose `PATH` contains development tools such as
    *sn.exe*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio安装了一个名为*Developer Command Prompt for VS*的快捷方式，它启动的命令提示符包含开发工具，如*sn.exe*。
- en: This manufactures a new key pair and stores it to a file called *MyKeyPair.snk*.
    If you subsequently lose this file, you will permanently lose the ability to recompile
    your assembly with the same identity.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这会生成一个新的密钥对，并将其存储到名为*MyKeyPair.snk*的文件中。如果随后丢失此文件，您将永久失去使用相同标识重新编译程序集的能力。
- en: You can sign an assembly with this file by updating your project file. From
    Visual Studio, go to the Project Properties window, and then, on the *Signing*
    tab, select the “Sign the assembly” checkbox and select your *.snk* file.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过更新项目文件来使用此文件对程序集进行签名。从Visual Studio，转到项目属性窗口，然后在*Signing*选项卡上，选中“Sign the
    assembly”复选框，并选择您的*.snk*文件。
- en: The same key pair can sign multiple assemblies—they’ll still have distinct identities
    if their simple names differ.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的密钥对可以签署多个程序集 - 如果它们的简单名称不同，则它们仍将具有不同的标识。
- en: Assembly Names
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序集名称
- en: 'An assembly’s “identity” comprises four pieces of metadata from its manifest:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 程序集的“标识”由其清单中的四个元数据组成：
- en: Its simple name
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其简单名称
- en: Its version (“0.0.0.0” if not present)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其版本号（如果不存在则为“0.0.0.0”）
- en: Its culture (“neutral” if not a satellite)
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其文化（如果不是卫星则为“neutral”）
- en: Its public key token (“null” if not strongly named)
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其公钥令牌（如果未强命名则为“null”）
- en: The simple name comes not from any attribute, but from the name of the file
    to which it was originally compiled (less any extension). So, the simple name
    of the *System.Xml.dll* assembly is “System.Xml.” Renaming a file doesn’t change
    the assembly’s simple name.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 简单名称并非由任何属性命名，而是来自最初编译的文件名称（减去任何扩展名）。因此，*System.Xml.dll* 程序集的简单名称是“System.Xml”。重命名文件不会改变程序集的简单名称。
- en: 'The version number comes from the `AssemblyVersion` attribute. It’s a string
    divided into four parts as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 版本号来自`AssemblyVersion`属性。它是一个分为四部分的字符串，如下所示：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can specify a version number as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以如下指定版本号：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The culture comes from the `AssemblyCulture` attribute and applies to satellite
    assemblies, described later in the section [“Resources and Satellite Assemblies”](#resources_and_satellite_assemblies).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 文化来自`AssemblyCulture`属性，并适用于稍后在“资源和卫星程序集”部分描述的卫星程序集。
- en: The public key token comes from the strong name supplied at compile time, as
    we discussed in the preceding section.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥标记来自于编译时提供的强名称，正如我们在前面的部分讨论的那样。
- en: Fully Qualified Names
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完全限定名称
- en: 'A fully qualified assembly name is a string that includes all four identifying
    components, in this format:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 完全限定的程序集名称是一个字符串，其中包括所有四个标识组件，格式如下：
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For example, the fully qualified name of *System.Private.CoreLib.dll* is *System.Private.CoreLib,
    Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*System.Private.CoreLib.dll*的完全限定名称是*System.Private.CoreLib, Version=4.0.0.0,
    Culture=neutral, PublicKeyToken=7cec85d7bea7798e*。
- en: If the assembly has no `AssemblyVersion` attribute, the version appears as `0.0.0.0`.
    If it is unsigned, its public key token appears as `null`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序集没有`AssemblyVersion`属性，则版本显示为`0.0.0.0`。如果它未签名，则其公钥标记显示为`null`。
- en: An `Assembly` object’s `FullName` property returns its fully qualified name.
    The compiler always uses fully qualified names when recording assembly references
    in the manifest.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`Assembly`对象的`FullName`属性返回其完全限定名称。编译器在记录程序集引用到清单中时总是使用完全限定名称。'
- en: Note
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A fully qualified assembly name does not include a directory path to assist
    in locating it on disk. Locating an assembly residing in another directory is
    an entirely separate matter that we pick up in [“Loading, Resolving, and Isolating
    Assemblies”](#loadingcomma_resolvingcomma_and_isolati).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 完全限定的程序集名称不包括用于在磁盘上定位它的目录路径。定位位于另一个目录中的程序集是一个完全不同的问题，我们将在[“加载、解析和隔离程序集”](#loadingcomma_resolvingcomma_and_isolati)中讨论。
- en: The AssemblyName Class
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`AssemblyName`类'
- en: '`AssemblyName` is a class with a typed property for each of the four components
    of a fully qualified assembly name. `AssemblyName` has two purposes:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`AssemblyName`是一个类，每个完全限定程序集名称的组件都有一个类型化的属性。`AssemblyName`有两个目的：'
- en: It parses or builds a fully qualified assembly name.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它解析或构建一个完全限定的程序集名称。
- en: It stores some extra data to assist in resolving (finding) the assembly.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它存储一些额外的数据以帮助解析（查找）程序集。
- en: 'You can obtain an `AssemblyName` object in any of the following ways:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下任一方式获得一个`AssemblyName`对象：
- en: Instantiate an `AssemblyName`, providing a fully qualified name.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化一个`AssemblyName`，提供完全限定名。
- en: Call `GetName` on an existing `Assembly`.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现有的`Assembly`上调用`GetName`。
- en: Call `AssemblyName.GetAssemblyName`, providing the path to an assembly file
    on disk.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`AssemblyName.GetAssemblyName`，提供磁盘上程序集文件的路径。
- en: You can also instantiate an `AssemblyName` object without any arguments and
    then set each of its properties to build a fully qualified name. An `AssemblyName`
    is mutable when constructed in this manner.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以实例化一个没有任何参数的`AssemblyName`对象，然后设置每个属性以构建一个完全限定名。以这种方式构造的`AssemblyName`是可变的。
- en: 'Here are its essential properties and methods:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是它的基本属性和方法：
- en: '[PRE9]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`Version` is itself a strongly typed representation, with properties for `Major`,
    `Minor`, `Build`, and `Revision` numbers. `GetPublicKey` returns the full cryptographic
    public key; `GetPublicKeyToken` returns the last eight bytes used in establishing
    identity.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Version`本身是一个强类型表示，具有`Major`、`Minor`、`Build`和`Revision`数字的属性。`GetPublicKey`返回完整的加密公钥；`GetPublicKeyToken`返回用于建立身份的最后八个字节。'
- en: 'To use `AssemblyName` to obtain the simple name of an assembly:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`AssemblyName`获取程序集的简单名称：
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To get an assembly version:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取程序集版本：
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Assembly Informational and File Versions
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序集信息和文件版本
- en: 'Two further assembly attributes are available for expressing version-related
    information. Unlike `AssemblyVersion`, the following two attributes do not affect
    an assembly’s identity and so have no effect on what happens at compile-time or
    at runtime:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个与版本相关的程序集属性可用。与`AssemblyVersion`不同，以下两个属性不会影响程序集的标识，因此对编译时或运行时发生的情况没有影响：
- en: '`AssemblyInformationalVersion`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`AssemblyInformationalVersion`'
- en: The version as displayed to the end user. This is visible in the Windows File
    Properties dialog box as Product Version. Any string can go here, such as “5.1
    Beta 2.” Typically, all of the assemblies in an application would be assigned
    the same informational version number.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最终用户可见的版本。这在Windows文件属性对话框中显示为产品版本。可以在此处使用任何字符串，例如“5.1 Beta 2”。通常，应用程序中的所有程序集将被分配相同的信息版本号。
- en: '`AssemblyFileVersion`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`AssemblyFileVersion`'
- en: This is intended to refer to the build number for that assembly. This is visible
    in the Windows File Properties dialog box as File Version. As with `AssemblyVersion`,
    it must contain a string consisting of up to four numbers separated by periods.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用来指代该程序集的生成编号。在Windows文件属性对话框中称为文件版本。与`AssemblyVersion`一样，它必须包含一个由点分隔的最多四个数字组成的字符串。
- en: Authenticode Signing
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Authenticode签名
- en: '*Authenticode* is a code-signing system whose purpose is to prove the identity
    of the publisher. Authenticode and *strong-name* signing are independent: you
    can sign an assembly with either or both systems.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*Authenticode*是一个代码签名系统，其目的是证明发布者的身份。Authenticode和*强名称*签名是独立的：您可以使用任一或两种系统对程序集进行签名。'
- en: Although strong-name signing can prove that assemblies A, B, and C came from
    the same party (assuming the private key hasn’t been leaked), it can’t tell you
    who that party was. To know that the party was Joe Albahari—or Microsoft Corporation—you
    need Authenticode.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管强名称签名可以证明程序集A、B和C来自同一方（假设私钥未泄漏），但它不能告诉您那个方是谁。要知道方是Joe Albahari或Microsoft Corporation，您需要Authenticode。
- en: Authenticode is useful when downloading programs from the internet, because
    it provides assurance that a program came from whoever was named by the Certificate
    Authority and was not modified in transit. It also prevents the “Unknown Publisher”
    warning when running a downloaded application for the first time. Authenticode
    signing is also a requirement when submitting apps to the Windows Store.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 从互联网下载程序时，Authenticode非常有用，因为它确保程序来自证书颁发机构指定的发布者，并且在传输过程中未经修改。它还可以防止第一次运行下载应用程序时的“未知发布者”警告。提交应用程序到Windows商店也需要Authenticode签名。
- en: Authenticode works with not only .NET assemblies, but also unmanaged executables
    and binaries such as *.msi* deployment files. Of course, Authenticode doesn’t
    guarantee that a program is free from malware—although it does make it less likely.
    A person or entity has been willing to put its name (backed by a passport or company
    document) behind the executable or library.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Authenticode不仅适用于.NET程序集，还适用于非托管可执行文件和二进制文件，如*.msi*部署文件。当然，Authenticode并不能保证程序没有恶意软件——尽管它确实降低了这种可能性。一个人或实体愿意在可执行文件或库文件背后署名（由护照或公司文件支持）。
- en: Note
  id: totrans-154
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The CLR does not treat an Authenticode signature as part of an assembly’s identity.
    However, it can read and validate Authenticode signatures on demand, as you’ll
    see soon.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: CLR不将Authenticode签名视为程序集身份的一部分。然而，它可以按需读取和验证Authenticode签名，您将很快看到。
- en: Signing with Authenticode requires that you contact a *Certificate Authority*
    (CA) with evidence of your personal identity or company’s identity (articles of
    incorporation, etc.). After the CA has checked your documents, it will issue an
    X.509 code-signing certificate that is typically valid for one to five years.
    This enables you to sign assemblies with the *signtool* utility. You can also
    make a certificate yourself with the *makecert* utility; however, it will be recognized
    only on computers on which the certificate is explicitly installed.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Authenticode需要与*证书颁发机构*（CA）联系，提供个人身份或公司身份的证明（公司章程等）。CA审核您的文件后，将颁发一个通常有效期为一到五年的X.509代码签名证书。这使您可以使用*signtool*实用程序签名程序集。您也可以使用*makecert*实用程序自行创建证书；但是，它只能在显式安装了该证书的计算机上识别。
- en: The fact that (non-self-signed) certificates can work on any computer relies
    on public key infrastructure. Essentially, your certificate is signed with another
    certificate belonging to a CA. The CA is trusted because all CAs are loaded into
    the OS. (To see them, go to the Windows Control Panel and then, in the search
    box, type `**certificate**`. In the Administrative Tools section, click “Manage
    computer certificates.” This launches the Certificate Manager. Open the node Trusted
    Root Certification Authorities and click Certificates.) A CA can revoke a publisher’s
    certificate if leaked, so verifying an Authenticode signature requires periodically
    asking the CA for an up-to-date list of certification revocations.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: (非自签名)证书可以在任何计算机上工作的事实依赖于公钥基础设施。基本上，您的证书由另一个属于CA的证书签名。CA是受信任的，因为所有CA都加载到操作系统中。（要查看它们，请转到Windows控制面板，然后在搜索框中键入`**certificate**`。在“管理计算机证书”中，打开“受信任的根证书颁发机构”节点，然后单击证书。这将启动证书管理器。）如果泄露了发布者的证书，CA可以吊销其证书，因此验证Authenticode签名需要定期向CA请求最新的证书吊销列表。
- en: Because Authenticode uses cryptographic signing, an Authenticode signature is
    invalid if someone subsequently tampers with the file. We discuss cryptography,
    hashing, and signing in [Chapter 20](ch20.html#cryptography-id00013).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Authenticode使用加密签名，如果有人随后篡改文件，Authenticode签名将无效。我们将在[第20章](ch20.html#cryptography-id00013)讨论加密、哈希和签名。
- en: How to Sign with Authenticode
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用Authenticode签名
- en: Obtaining and installing a certificate
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取和安装证书
- en: The first step is to obtain a code-signing certificate from a CA (see the sidebar
    that follows). You can then either work with the certificate as a password-protected
    file or load the certificate into the computer’s certificate store. The benefit
    of doing the latter is that you can sign without needing to specify a password.
    This is advantageous because it prevents having a password visible in automated
    build scripts or batch files.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是从CA获取代码签名证书（请参阅接下来的侧边栏）。然后，您可以将证书作为受密码保护的文件处理，或者将证书加载到计算机的证书存储中。后者的好处是，您可以在不需要指定密码的情况下进行签名。这是有利的，因为它可以防止密码出现在自动构建脚本或批处理文件中。
- en: To load a certificate into the computer’s certificate store, open the Certificate
    Manager as described earlier. Open the Personal folder, right-click its Certificates
    folder, and then pick All Tasks/Import. An import wizard guides you through the
    process. After the import is complete, click the View button on the certificate,
    go to the Details tab, and copy the certificate’s *thumbprint*. This is the SHA-256
    hash that you’ll subsequently need to identify the certificate when signing.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要将证书加载到计算机的证书存储中，请如前所述打开证书管理器。打开个人文件夹，右键单击其证书文件夹，然后选择所有任务/导入。导入向导将指导您完成整个过程。导入完成后，单击证书上的“查看”按钮，转到“详细信息”选项卡，并复制证书的*指纹*。这是SHA-256哈希值，您随后需要用它来识别签名时使用的证书。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you also want to strong-name-sign your assembly, you must do so *before*
    Authenticode signing. This is because the CLR knows about Authenticode signing,
    but not vice versa. So, if you strong-name-sign an assembly *after* Authenticode-signing
    it, the latter will see the addition of the CLR’s strong name as an unauthorized
    modification and consider the assembly tampered.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还希望对程序集进行强名称签名，必须在进行Authenticode签名之前*完成*。这是因为CLR了解Authenticode签名，但反之不然。因此，如果在Authenticode签名后再对程序集进行强名称签名，后者将视CLR的强名称添加为未经授权的修改，并认为程序集已被篡改。
- en: Signing with signtool.exe
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用signtool.exe进行签名
- en: 'You can Authenticode-sign your programs with the *signtool* utility that comes
    with Visual Studio (look in the *Microsoft SDKs\ClickOnce\SignTool* folder under
    *Program Files*). The following signs a file called *LINQPad.exe* with the certificate
    located in the computer’s *My Store* called “Joseph Albahari,” using the secure
    SHA256 hashing algorithm:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用随Visual Studio提供的*signtool*工具对程序进行Authenticode签名（在*Program Files*下的*Microsoft
    SDKs\ClickOnce\SignTool*文件夹中查找）。以下是使用计算机的*My Store*中名为“Joseph Albahari”的证书，并使用安全的SHA256哈希算法对名为*LINQPad.exe*的文件进行签名的示例：
- en: '[PRE12]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can also specify a description and product URL with `/d` and `/du`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`/d`和`/du`指定描述和产品URL：
- en: '[PRE13]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In most cases, you will also want to specify a *time-stamping server*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，您还需要指定一个*时间戳服务器*。
- en: Time stamping
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间戳
- en: 'After your certificate expires, you’ll no longer be able to sign programs.
    However, programs that you signed *before* its expiry will still be valid—if you
    specified a *time-stamping server* with the `/tr` switch when signing. The CA
    will provide you with a URI for this purpose: the following is for Comodo (or
    K Software):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的证书过期后，您将无法再签名程序。但是，如果在其过期*之前*使用`/tr`开关指定了*时间戳服务器*来签名程序，那么您之前签名的程序仍将有效。CA将为此提供一个URI：以下是为Comodo（或K
    Software）提供的：
- en: '[PRE14]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Verifying that a program has been signed
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证程序是否已签名
- en: The easiest way to view an Authenticode signature on a file is to view the file’s
    properties in Windows Explorer (look in the Digital Signatures tab). The *signtool*
    utility also provides an option for this.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows资源管理器中查看文件的Authenticode签名最简单的方法是查看文件属性（查看数字签名选项卡）。*signtool*工具也提供了此选项。
- en: Resources and Satellite Assemblies
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源和卫星程序集
- en: 'An application typically contains not only executable code, but also content
    such as text, images, or XML files. Such content can be represented in an assembly
    through a *resource*. There are two overlapping use cases for resources:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通常不仅包含可执行代码，还包括文本、图像或XML文件等内容。这些内容可以通过*资源*在程序集中表示。资源有两个重叠的用途场景：
- en: Incorporating data that cannot go into source code, such as images
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含不能放入源代码的数据，例如图片
- en: Storing data that might need translation in a multilingual application
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多语言应用程序中存储可能需要翻译的数据
- en: 'An assembly resource is ultimately a byte stream with a name. You can think
    of an assembly as containing a dictionary of byte arrays keyed by string. You
    can see this in *ildasm* if you disassemble an assembly that contains a resource
    called *banner.jpg* and a resource called *data.xml*:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 程序集资源最终是一个带有名称的字节流。你可以将程序集看作是包含以字符串为键的字节数组字典。如果你反汇编包含名为 *banner.jpg* 和名为 *data.xml*
    的资源的程序集，可以在 *ildasm* 中看到这一点：
- en: '[PRE15]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this case, *banner.jpg* and *data.xml* were included directly in the assembly—each
    as its own embedded resource. This is the simplest way to work.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，*banner.jpg* 和 *data.xml* 直接包含在程序集中，每个作为其自身的嵌入资源。这是最简单的工作方式。
- en: .NET also lets you add content through intermediate *.resources* containers.
    These are designed for holding content that might require translation into different
    languages. Localized *.resources* can be packaged as individual satellite assemblies
    that are automatically picked up at runtime, based on the user’s OS language.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 还允许你通过中间的 *.resources* 容器添加内容。这些设计用于保存可能需要翻译成不同语言的内容。本地化的 *.resources*
    可以打包为个别的卫星程序集，根据用户操作系统语言在运行时自动选择。
- en: '[Figure 17-2](#resources) illustrates an assembly that contains two directly
    embedded resources, plus a *.resources* container called *welcome.resources*,
    for which we’ve created two localized satellites.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 17-2](#resources) 说明了一个包含两个直接嵌入资源以及一个名为 *welcome.resources* 的 *.resources*
    容器的程序集，我们已经为它创建了两个本地化卫星。'
- en: '![Resources](assets/cn10_1702.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![资源](assets/cn10_1702.png)'
- en: Figure 17-2\. Resources
  id: totrans-186
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 17-2\. 资源
- en: Directly Embedding Resources
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直接嵌入资源
- en: Note
  id: totrans-188
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Embedding resources into assemblies is not supported in Windows Store apps.
    Instead, add any extra files to your deployment package, and access them by reading
    from your application `StorageFolder` (`Package.Cur⁠rent​.Installed​Location`).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows Store 应用中不支持将资源嵌入到程序集中。相反，将任何额外的文件添加到你的部署包中，并通过从应用的 `StorageFolder`
    (`Package.Current.InstalledLocation`) 读取它们来访问。
- en: 'To directly embed a resource using Visual Studio:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用 Visual Studio 嵌入资源：
- en: Add the file to your project.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件添加到你的项目中。
- en: Set its build action to Embedded Resource.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其构建操作设置为嵌入资源。
- en: Visual Studio always prefixes resource names with the project’s default namespace,
    plus the names of any subfolders in which the file is contained. So, if your project’s
    default namespace was `Westwind.Reports` and your file was called *banner.jpg*
    in the folder *pictures*, the resource name would be *Westwind.Reports.pictures.banner.jpg*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 总是使用项目的默认命名空间前缀资源名称，加上包含文件的任何子文件夹的名称。所以，如果你的项目默认命名空间是 `Westwind.Reports`，并且你的文件在名为
    *pictures* 的文件夹中叫做 *banner.jpg*，资源名称将是 *Westwind.Reports.pictures.banner.jpg*。
- en: Note
  id: totrans-194
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Resource names are case sensitive. This makes project subfolder names in Visual
    Studio that contain resources effectively case sensitive.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 资源名称区分大小写。这使得在包含资源的 Visual Studio 项目子文件夹名称实际上是大小写敏感的。
- en: 'To retrieve a resource, you call `GetManifestResourceStream` on the assembly
    containing the resource. This returns a stream, which you can then read as any
    other:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索资源，可以在包含资源的程序集上调用 `GetManifestResourceStream`。这会返回一个流，你可以像处理其他流一样读取它：
- en: '[PRE16]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The stream returned is seekable, so you can also do this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的流是可寻址的，所以你也可以这样做：
- en: '[PRE17]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you’ve used Visual Studio to embed the resource, you must remember to include
    the namespace-based prefix. To help avoid error, you can specify the prefix in
    a separate argument, using a *type*. The type’s namespace is used as the prefix:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Visual Studio 嵌入资源，必须记得包含基于命名空间的前缀。为了帮助避免错误，你可以在单独的参数中指定前缀，使用*类型*。类型的命名空间被用作前缀：
- en: '[PRE18]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`X` can be any type with the desired namespace of your resource (typically,
    a type in the same project folder).'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`X` 可以是带有你资源所需命名空间的任何类型（通常是同一项目文件夹中的类型）。'
- en: Note
  id: totrans-203
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Setting a project item’s build action in Visual Studio to Resource within a
    Windows Presentation Foundation (WPF) application is *not* the same as setting
    its build action to Embedded Resource. The former actually adds the item to a
    *.resources* file called *<AssemblyName>.g.resources*, whose content you access
    through WPF’s `Application` class, using a URI as a key.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows Presentation Foundation（WPF）应用程序中，将项目项的构建操作设置为资源与设置其构建操作设置为嵌入资源不同。前者实际上将项目添加到名为
    *<AssemblyName>.g.resources* 的 *.resources* 文件中，其内容可以通过 WPF 的 `Application` 类访问，使用
    URI 作为键。
- en: To add to the confusion, WPF further overloads the term “resource.” *Static
    resources* and *dynamic resources* are both unrelated to assembly resources!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加混淆，WPF 进一步重载了术语“资源”。*静态资源* 和 *动态资源* 都与程序集资源无关！
- en: '`GetManifestResourceNames` returns the names of all resources in the assembly.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetManifestResourceNames` 返回程序集中所有资源的名称。'
- en: .resources Files
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .resources 文件
- en: '*.resources* files are containers for potentially localizable content. A *.resources*
    file ends up as an embedded resource within an assembly—just like any other kind
    of file. The difference is that you must do the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*.resources* 文件是包含潜在本地化内容的容器。 *.resources* 文件最终作为嵌入式资源嵌入到程序集中，就像任何其他类型的文件一样。区别在于，您必须执行以下操作：'
- en: Package your content into the *.resources* file to begin with
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将内容打包到 *.resources* 文件中开始
- en: Access its content through a `ResourceManager` or *pack URI* rather than a `Get​ManifestResourceStream`
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `ResourceManager` 或 *pack URI* 访问其内容，而不是通过 `Get​ManifestResourceStream` 获取。
- en: '*.resources* files are structured in binary and so are not human-editable;
    therefore, you must rely on tools provided by .NET and Visual Studio to work with
    them. The standard approach with strings or simple data types is to use the *.resx*
    format, which can be converted to a *.resources* file either by Visual Studio
    or the `resgen` tool. The *.resx* format is also suitable for images intended
    for a Windows Forms or ASP.NET application.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*.resources* 文件以二进制结构化，因此不适合人工编辑；因此，您必须依赖 .NET 和 Visual Studio 提供的工具来处理它们。对于字符串或简单数据类型的标准方法是使用
    *.resx* 格式，该格式可以通过 Visual Studio 或 `resgen` 工具转换为 *.resources* 文件。 *.resx* 格式也适用于用于
    Windows Forms 或 ASP.NET 应用程序的图像。'
- en: In a WPF application, you must use Visual Studio’s “Resource” build action for
    images or similar content needing to be referenced by URI. This applies whether
    localization is needed or not.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WPF 应用程序中，无论是否需要本地化，都必须使用 Visual Studio 的“资源”构建操作来处理需要通过 URI 引用的图像或类似内容。
- en: We describe how to do each of these in the following sections.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在以下各节中描述如何执行每个操作。
- en: .resx Files
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .resx 文件
- en: 'A *.resx* file is a design-time format for producing *.resources* files. A
    *.resx* file uses XML and is structured with name/value pairs as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*.resx* 文件是用于生成 *.resources* 文件的设计时格式。 *.resx* 文件使用 XML，并且结构化为以下名称/值对：'
- en: '[PRE19]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To create a *.resx* file in Visual Studio, add a project item of type Resources
    File. The rest of the work is done automatically:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Visual Studio 中创建 *.resx* 文件，请添加类型为资源文件的项目项。其余工作将自动完成：
- en: The correct header is created.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了正确的标头。
- en: A designer is provided for adding strings, images, files, and other kinds of
    data.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了一个设计器，用于添加字符串、图像、文件和其他类型的数据。
- en: The *.resx* file is automatically converted to the *.resources* format and embedded
    into the assembly upon compilation.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*.resx* 文件在编译时自动转换为 *.resources* 格式并嵌入到程序集中。'
- en: A class is written to help you access the data later on.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个类来帮助您稍后访问数据。
- en: Note
  id: totrans-222
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The resource designer adds images as typed `Image` objects (*System.Drawing.dll*)
    rather than as byte arrays, making them unsuitable for WPF applications.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 资源设计器将图像添加为类型化的 `Image` 对象（*System.Drawing.dll*），而不是字节数组，因此不适用于 WPF 应用程序。
- en: Reading .resources files
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取 .resources 文件
- en: Note
  id: totrans-225
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you create a *.resx* file in Visual Studio, a class of the same name is generated
    automatically with properties to retrieve each of its items.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 Visual Studio 中创建 *.resx* 文件，则将自动生成同名类，其中包含检索其各个项的属性。
- en: 'The `ResourceManager` class reads *.resources* files embedded within an assembly:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResourceManager` 类读取嵌入在程序集中的 *.resources* 文件：'
- en: '[PRE20]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: (The first argument must be namespace-prefixed if the resource was compiled
    in Visual Studio.)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: （如果资源是在 Visual Studio 中编译的，则第一个参数必须带命名空间前缀。）
- en: 'You can then access what’s inside by calling `GetString` or `GetObject` with
    a cast:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过调用 `GetString` 或 `GetObject`（进行强制转换）访问其中的内容。
- en: '[PRE21]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To enumerate the contents of a *.resources* file:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要枚举 *.resources* 文件的内容：
- en: '[PRE22]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Creating a pack URI resource in Visual Studio
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中创建 pack URI 资源
- en: 'In a WPF application, XAML files need to be able to access resources by URI.
    For instance:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WPF 应用程序中，XAML 文件需要能够通过 URI 访问资源。例如：
- en: '[PRE23]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Or, if the resource is in another assembly:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果资源在另一个程序集中：
- en: '[PRE24]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: (`Component` is a literal keyword.)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: （`Component` 是一个字面关键字。）
- en: To create resources that can be loaded in this manner, you cannot use *.resx*
    files. Instead, you must add the files to your project and set their build action
    to Resource (not Embedded Resource). Visual Studio then compiles them into a *.resources*
    file called *<AssemblyName>.g.resources*—also the home of compiled XAML (*.baml*)
    files.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建能以这种方式加载的资源，你不能使用*.resx*文件。相反，你必须将文件添加到项目中，并将它们的构建操作设置为Resource（而不是Embedded
    Resource）。然后，Visual Studio会将它们编译成一个名为*<AssemblyName>.g.resources*的*.resources*文件——也是编译XAML（*.baml*）文件的位置。
- en: 'To load a URI-keyed resource programmatically, call `Application.GetResource​Stream`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要以编程方式加载URI键入的资源，请调用`Application.GetResource​Stream`：
- en: '[PRE25]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Notice we used a relative URI. You can also use an absolute URI in exactly
    the following format (the three commas are not a typo):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用了一个相对URI。你也可以使用完全相同格式的绝对URI（三个逗号不是打字错误）：
- en: '[PRE26]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you’d rather specify an `Assembly` object, you can retrieve content instead
    with a `ResourceManager`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更愿意指定一个`Assembly`对象，你可以使用`ResourceManager`来检索内容：
- en: '[PRE27]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: A `ResourceManager` also lets you enumerate the content of a *.g.resources*
    container within a given assembly.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResourceManager`还允许你枚举给定程序集内*.g.resources*容器的内容。'
- en: Satellite Assemblies
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 卫星程序集
- en: Data embedded in *.resources* is localizable.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入在*.resources*中的数据是可本地化的。
- en: Resource localization is relevant when your application runs on a version of
    Windows built to display everything in a different language. For consistency,
    your application should use that same language, too.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用程序在用于显示不同语言的Windows版本上运行时，资源本地化就显得尤为重要。为了保持一致性，你的应用程序也应该使用相同的语言。
- en: 'A typical setup is as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的设置如下：
- en: The main assembly contains *.resources* for the default, or *fallback*, language.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主程序集包含默认或*回退*语言的*.resources*。
- en: Separate *satellite assemblies* contain localized *.resources* translated to
    different languages.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分开的*卫星程序集*包含翻译成不同语言的本地化*.resources*。
- en: When your application runs, .NET examines the language of the current OS (from
    `CultureInfo.CurrentUICulture`). Whenever you request a resource using `Resour⁠ce​Manager`,
    the runtime looks for a localized satellite assembly. If one’s available—and it
    contains the resource key you requested—it’s used in place of the main assembly’s
    version.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用程序运行时，.NET会检查当前操作系统的语言（来自`CultureInfo.CurrentUICulture`）。每当你使用`Resour⁠ce​Manager`请求资源时，运行时会查找本地化的卫星程序集。如果有可用的卫星程序集，并且它包含你请求的资源键，则会用它替代主程序集的版本。
- en: This means that you can enhance language support simply by adding new satellites—without
    changing the main assembly.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以通过添加新的卫星程序集来简单增强语言支持，而无需更改主程序集。
- en: Note
  id: totrans-256
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A satellite assembly cannot contain executable code, only resources.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 一个卫星程序集不能包含可执行代码，只能包含资源。
- en: 'Satellite assemblies are deployed in subdirectories of the assembly’s folder,
    as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 卫星程序集部署在程序集文件夹的子目录中，如下所示：
- en: '[PRE28]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`*XX*` refers to the two-letter language code (such as “de” for German) or
    a language and region code (such as “en-GB” for English in Great Britain). This
    naming system allows the CLR to find and load the correct satellite assembly automatically.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`*XX*`指的是两个字母的语言代码（例如德语为“de”）或语言和区域代码（例如英语在英国的代码为“en-GB”）。这种命名系统允许CLR自动找到并加载正确的卫星程序集。'
- en: Building satellite assemblies
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建卫星程序集
- en: 'Recall our previous *.resx* example, which included the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们之前的*.resx*示例，其中包括以下内容：
- en: '[PRE29]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We then retrieved the greeting at runtime as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在运行时检索问候语如下：
- en: '[PRE30]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Suppose that we want this to instead write “hallo” if running on the German
    version of Windows. The first step is to add another *.resx* file named *welcome.de.resx*
    that substitutes *hello* for *hallo*:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望在德语版Windows上运行时写入“hallo”而不是“hello”。第一步是添加另一个名为*welcome.de.resx*的*.resx*文件，将*hello*替换为*hallo*：
- en: '[PRE31]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In Visual Studio, this is all you need to do—when you rebuild, a satellite assembly
    called *MyApp.resources.dll* is automatically created in a subdirectory called
    *de*.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中，这是你需要做的一切——重新构建时，一个名为*MyApp.resources.dll*的卫星程序集会自动创建在名为*de*的子目录中。
- en: Testing satellite assemblies
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试卫星程序集
- en: 'To simulate running on an OS with a different language, you must change the
    `CurrentUICulture` using the `Thread` class:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要模拟在具有不同语言的操作系统上运行，你必须使用`Thread`类来更改`CurrentUICulture`：
- en: '[PRE32]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`CultureInfo.CurrentUICulture` is a read-only version of the same property.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`CultureInfo.CurrentUICulture`是相同属性的只读版本。'
- en: Note
  id: totrans-273
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A useful testing strategy is to ℓѻ¢αℓïʐɘ into words that can still be read as
    English but do not use the standard Roman Unicode characters.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的测试策略是将ℓѻ¢αℓïʐɘ转换为仍然可以读作英语但不使用标准罗马Unicode字符的单词。
- en: Visual Studio designer support
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Visual Studio 设计器支持
- en: The designers in Visual Studio provide extended support for localizing components
    and visual elements. The WPF designer has its own workflow for localization; other
    `Component`-based designers use a design-time-only property to make it appear
    that a component or Windows Forms control has a `Language` property. To customize
    for another language, simply change the `Language` property and then start modifying
    the component. All properties of controls that are attributed as `Localizable`
    will be saved to a *.resx* file for that language. You can switch between languages
    at any time just by changing the `Language` property.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio中的设计器为本地化组件和视觉元素提供了扩展支持。WPF设计器有自己的本地化工作流程；其他基于组件的设计器使用设计时属性，使组件或Windows
    Forms控件看起来具有`Language`属性。要定制为另一种语言，只需更改`Language`属性，然后开始修改组件。所有被标记为`Localizable`的控件属性都将保存到该语言的*.resx*文件中。您可以随时通过更改`Language`属性来在不同语言之间切换。
- en: Cultures and Subcultures
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文化和子文化
- en: 'Cultures are split into cultures and subcultures. A culture represents a particular
    language; a subculture represents a regional variation of that language. The .NET
    runtime follows the `RFC1766` standard, which represents cultures and subcultures
    with two-letter codes. Here are the codes for English and German cultures:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 文化被分为文化和子文化。文化代表特定的语言；子文化代表该语言的区域变体。.NET运行时遵循`RFC1766`标准，使用两字母代码表示文化和子文化。这里是英语和德语文化的代码：
- en: '[PRE33]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here are the codes for the Australian English and Austrian German subcultures:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是澳大利亚英语和奥地利德语子文化的代码：
- en: '[PRE34]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A culture is represented in .NET with the `System.Globalization.CultureInfo`
    class. You can examine the current culture of your application, as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，文化使用`System.Globalization.CultureInfo`类表示。您可以检查应用程序的当前文化，如下所示：
- en: '[PRE35]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Running this on a computer localized for Australia illustrates the difference
    between the two:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置为澳大利亚本地化的计算机上运行这个示例，可以展示两者之间的差异：
- en: '[PRE36]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`CurrentCulture` reflects the regional settings of the Windows Control Panel,
    whereas `CurrentUICulture` reflects the language of the OS.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`CurrentCulture`反映了Windows控制面板的区域设置，而`CurrentUICulture`反映了操作系统的语言。'
- en: Regional settings include such things as time zone and the formatting of currency
    and dates. `CurrentCulture` determines the default behavior of such functions
    as `DateTime.Parse`. Regional settings can be customized to the point where they
    no longer resemble any particular culture.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 区域设置包括时区、货币和日期格式等内容。`CurrentCulture`决定了诸如`DateTime.Parse`等函数的默认行为。区域设置可以定制到不再符合任何特定文化的程度。
- en: '`CurrentUICulture` determines the language in which the computer communicates
    with the user. Australia doesn’t need a separate version of English for this purpose,
    so it just uses the US one. If I spent a couple of months working in Austria,
    I would go to the Control Panel and change my `CurrentCulture` to Austrian-German.
    However, given that I can’t speak German, my `CurrentUICulture` would remain US
    English.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`CurrentUICulture`决定计算机与用户通信的语言。澳大利亚在这方面不需要单独的英语版本，因此只使用美国英语。如果我在奥地利工作了几个月，我会去控制面板将我的`CurrentCulture`更改为奥地利德语。但是，考虑到我不会说德语，我的`CurrentUICulture`仍然是美国英语。'
- en: '`ResourceManager`, by default, uses the current thread’s `CurrentUICulture`
    property to determine the correct satellite assembly to load. `ResourceManager`
    uses a fallback mechanism when loading resources. If a subculture assembly is
    defined, that one is used; otherwise, it falls back to the generic culture. If
    the generic culture is not present, it falls back to the default culture in the
    main assembly.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResourceManager`默认使用当前线程的`CurrentUICulture`属性来确定加载正确卫星程序集。在加载资源时，`ResourceManager`使用回退机制。如果定义了子文化程序集，则使用该程序集；否则，回退到通用文化。如果通用文化不存在，则回退到主程序集中的默认文化。'
- en: Loading, Resolving, and Isolating Assemblies
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载、解析和隔离程序集
- en: Loading an assembly from a known location is a relatively simple process. We
    refer to this as *assembly loading*.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 从已知位置加载程序集是一个相对简单的过程。我们称之为*程序集加载*。
- en: More commonly, however, you (or the CLR) will need to load an assembly knowing
    only its full (or simple) name. This is called *assembly resolution*. Assembly
    resolution differs from loading in that the assembly must first be located.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，更常见的情况是，您（或CLR）需要加载一个程序集，只知道其完整（或简单）名称。这称为*程序集解析*。程序集解析与加载不同之处在于必须首先定位程序集。
- en: 'Assembly resolution is triggered in two scenarios:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 程序集解析在两种情况下触发：
- en: By the CLR, when it needs to resolve a dependency
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由CLR在需要解析依赖项时
- en: Explicitly, when you call a method such as `Assembly.Load(AssemblyName)`
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确地说，当您调用诸如`Assembly.Load(AssemblyName)`的方法时
- en: 'To illustrate the first scenario, consider an application comprising a main
    assembly plus a set of statically referenced library assemblies (dependencies),
    as shown in this example:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明第一个场景，考虑一个由主程序集和一组静态引用的库程序集（依赖项）组成的应用程序，如本例所示：
- en: '[PRE37]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: By “statically referenced,” we mean that *AdventureGame.dll* was compiled with
    references to *Terrain.dll* and *UIEngine.dll*. The compiler itself does not need
    to perform assembly resolution, because it’s told (either explicitly or by MSBuild)
    where to find *Terrain.dll* and *UIEngine.dll*. During compilation, it writes
    the *full names* of the Terrain and UIEngine assemblies into the metadata of *AdventureGame.dll*
    but no information on where to find them. So, at runtime, the Terrain and UIEngine
    assemblies must be *resolved*.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: “静态引用”是指*AdventureGame.dll*编译时引用了*Terrain.dll*和*UIEngine.dll*。编译器本身不需要执行程序集解析，因为它被告知（明确或通过MSBuild）在哪里找到*Terrain.dll*和*UIEngine.dll*。在编译过程中，它将Terrain和UIEngine程序集的*完整名称*写入*AdventureGame.dll*的元数据中，但不包含有关如何找到它们的信息。因此，在运行时，必须*解析*Terrain和UIEngine程序集。
- en: Assembly loading and resolution is handled by an *assembly load context* (ALC);
    specifically, an instance of the `AssemblyLoadContext` class in `System.Runtime.Loader`.
    Because *AdventureGame.dll* is the main assembly for the application, the CLR
    uses the *default ALC* (`AssemblyLoadContext.Default`) to resolve its dependencies.
    The default ALC resolves dependencies first by looking for and examining a file
    called *AdventureGame.deps.json* (which describes where to find dependencies),
    or if not present, it looks in the application base folder, where it will find
    *Terrain.dll* and *UIEngine.dll*. (The default ALC also resolves the .NET runtime
    assemblies.)
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 程序集加载和解析由*程序集加载上下文*（ALC）处理；具体来说，是`System.Runtime.Loader`中`AssemblyLoadContext`类的一个实例。因为*AdventureGame.dll*是应用程序的主程序集，CLR使用*默认ALC*（`AssemblyLoadContext.Default`）来解析其依赖项。默认ALC首先通过查找和检查名为*AdventureGame.deps.json*的文件（描述了依赖项的位置），或者如果不存在，则在应用程序基础文件夹中查找，那里将找到*Terrain.dll*和*UIEngine.dll*。（默认ALC还解析.NET运行时程序集。）
- en: As a developer, you can dynamically load additional assemblies during the execution
    of your program. For example, you might want to package optional features in assemblies
    that you deploy only when those features have been purchased. In such a case,
    you could load the extra assemblies, when present, by calling `Assembly`​.`Load(AssemblyName)`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，您可以在程序执行过程中动态加载额外的程序集。例如，您可能希望将可选功能打包在仅在购买这些功能时部署的程序集中。在这种情况下，您可以通过调用`Assembly.Load(AssemblyName)`来加载额外的程序集（如果存在）。
- en: A more complex example would be implementing a plug-in system whereby the user
    can provide third-party assemblies that your application detects and loads at
    runtime to extend your application’s functionality. The complexity arises because
    each plug-in assembly might have its own dependencies that must also be resolved.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更复杂的例子是实现一个插件系统，用户可以提供第三方程序集，您的应用程序在运行时检测并加载以扩展应用程序的功能。复杂性在于每个插件程序集可能有自己的依赖项，这些依赖项也必须被解析。
- en: By subclassing `AssemblyLoadContext` and overriding its assembly resolution
    method (`Load`), you can control how a plug-in finds its dependencies. For example,
    you might decide that each plug-in should reside in its own folder, and its dependencies
    should also reside in that folder.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对`AssemblyLoadContext`进行子类化并重写其程序集解析方法（`Load`），您可以控制插件如何找到其依赖项。例如，您可能决定每个插件都应该位于自己的文件夹中，而其依赖项也应该位于该文件夹中。
- en: 'ALCs have another purpose: by instantiating a separate `AssemblyLoadContext`
    for each (plug-in + dependencies), you can keep each isolated, ensuring that their
    dependencies load in parallel and do not interfere with one another (nor the host
    application). Each, for instance, can have its own version of JSON.NET. Hence,
    in addition to *loading* and *resolution*, ALCs also provide a mechanism for *isolation*.
    Under certain conditions, ALCs can even be *unloaded*, freeing their memory.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ALC还有另一个目的：通过为每个（插件+依赖项）实例化单独的`AssemblyLoadContext`，您可以保持每个ALC的隔离性，确保它们的依赖项并行加载且不会相互干扰（也不会干扰宿主应用程序）。例如，每个ALC可以拥有自己的JSON.NET版本。因此，除了*加载*和*解析*之外，ALC还提供了一种*隔离*的机制。在某些条件下，ALC甚至可以*卸载*，释放其内存。
- en: 'In this section, we elaborate on each of these principles and describe the
    following:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们详细阐述了这些原则，并描述了以下内容：
- en: How ALCs handle loading and resolution
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ALC如何处理加载和解析
- en: The role of the default ALC
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认ALC的角色
- en: '`Assembly.Load` and contextual ALCs'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assembly.Load`和上下文ALC'
- en: How to use `AssemblyDependencyResolver`
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`AssemblyDependencyResolver`
- en: How to load and resolve unmanaged libraries
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何加载和解析非托管库
- en: Unloading ALCs
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卸载ALC
- en: The legacy assembly loading methods
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旧版程序集加载方法
- en: Then, we put the theory to work and demonstrate how to write a plug-in system
    with ALC isolation.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将理论付诸实践，并展示如何使用ALC隔离编写插件系统。
- en: Note
  id: totrans-313
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `AssemblyLoadContext` class is new to .NET 5+ and .NET Core. In .NET Framework,
    ALCs were present but restricted and hidden: the only way to create and interact
    with them was indirectly via the `LoadFile(string)`, `LoadFrom(string)`, and `Load(byte[])`
    static methods on the `Assembly` class. Compared to the ALC API, these methods
    are inflexible, and their use can lead to surprises (particularly when handling
    dependencies). For this reason, it’s best to favor explicit use of the `AssemblyLoadContext`
    API in .NET 5+ and .NET Core.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`AssemblyLoadContext`类是.NET 5+和.NET Core中的新功能。在.NET Framework中，ALC存在但受限且隐藏：与其间接地通过`Assembly`类的`LoadFile(string)`、`LoadFrom(string)`和`Load(byte[])`静态方法交互是唯一的方式。与ALC
    API相比，这些方法不够灵活，并且在处理依赖项时可能会出现意外情况。因此，在.NET 5+和.NET Core中最好明确使用`AssemblyLoadContext`API。'
- en: Assembly Load Contexts
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序集加载上下文
- en: As we just discussed, the `AssemblyLoadContext` class is responsible for loading
    and resolving assemblies as well as providing a mechanism for isolation.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚讨论的那样，`AssemblyLoadContext`类负责加载和解析程序集，并提供隔离的机制。
- en: 'Every .NET `Assembly` object belongs to exactly one `AssemblyLoadContext`.
    You can obtain the ALC for an assembly, as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 每个.NET `Assembly`对象都属于一个唯一的`AssemblyLoadContext`。您可以按如下方式获取一个程序集的ALC：
- en: '[PRE38]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Conversely, you can think of an ALC as “containing” or “owning” assemblies,
    which you can obtain via its `Assemblies` property. Following on from the previous
    example:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，您可以将ALC视为“包含”或“拥有”程序集的容器，您可以通过其`Assemblies`属性获取它们。继续前面的例子：
- en: '[PRE39]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `AssemblyLoadContext` class also has a static `All` property that enumerates
    all ALCs.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`AssemblyLoadContext`类还有一个静态的`All`属性，用于枚举所有的ALC。'
- en: You can create a new ALC just by instantiating `AssemblyLoadContext` and providing
    a name (the name is helpful when debugging), although more commonly, you’d first
    subclass `AssemblyLoadContext` so that you can implement logic to *resolve* dependencies;
    in other words, load an assembly from its *name*.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过实例化`AssemblyLoadContext`并提供一个名称（在调试时这个名称很有帮助）来创建一个新的ALC，尽管更常见的做法是首先子类化`AssemblyLoadContext`，以便您可以实现解析依赖项的逻辑；换句话说，根据其*名称*加载一个程序集。
- en: Loading assemblies
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载程序集
- en: '`AssemblyLoadContext` provides the following methods to explicitly load an
    assembly into its context:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`AssemblyLoadContext`提供了以下方法来显式地将程序集加载到其上下文中：'
- en: '[PRE40]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The first method loads an assembly from a file path, whereas the second method
    loads it from a `Stream` (which can come directly from memory). The second parameter
    is optional and corresponds to the contents of the project debug (*.pdb*) file,
    which allows stack traces to include source code information when code executes
    (useful in exception reporting).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法从文件路径加载程序集，而第二种方法从`Stream`加载它（可以直接来自内存）。第二个参数是可选的，对应于项目调试（*.pdb*）文件的内容，这允许堆栈跟踪在代码执行时包含源代码信息（在异常报告中非常有用）。
- en: With both of these methods, no *resolution* takes place.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两种方法都不会进行*解析*。
- en: 'The following loads the assembly *c:\temp\foo.dll* into its own ALC:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将程序集*c:\temp\foo.dll*加载到其自己的ALC中：
- en: '[PRE41]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If the assembly is valid, loading will always succeed, subject to one important
    rule: an assembly’s *simple name* must be unique within its ALC. This means that
    you cannot load multiple versions of the same-named assembly into a single ALC;
    to do this, you must create additional ALCs. We could load another copy of *foo.dll*,
    as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序集有效，则加载将始终成功，但受到一个重要规则的限制：程序集的 *简单名称* 必须在其 ALC 中唯一。这意味着不能将同名程序集的多个版本加载到单个
    ALC 中；要实现此目的，必须创建额外的 ALC。
- en: '[PRE42]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note that types that originate from different `Assembly` objects are incompatible
    even if the assemblies are otherwise identical. In our example, the types in `assem`
    are incompatible with the types in `assem2`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使程序集在其他方面相同，但源自不同 `Assembly` 对象的类型也是不兼容的。在我们的示例中，`assem` 中的类型与 `assem2`
    中的类型是不兼容的。
- en: After an assembly is loaded, it cannot be unloaded except by unloading its ALC
    (see [“Unloading ALCs”](#unloading_alcs)). The CLR maintains a lock of the file
    for the duration that it’s loaded.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载程序集后，除非卸载其 ALC（请参阅 [“卸载 ALCs”](#unloading_alcs)），否则无法卸载程序集。CLR 在加载期间保持文件的锁定状态。
- en: Note
  id: totrans-334
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can avoid locking the file by loading the assembly via a byte array:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过通过字节数组加载程序集来避免锁定文件：
- en: '[PRE43]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This has two drawbacks:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这有两个缺点：
- en: The assembly’s `Location` property will end up blank. Sometimes, it’s useful
    to know where an assembly was loaded from (and some APIs rely on it being populated).
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序集的 `Location` 属性最终将为空白。有时，知道程序集加载自何处（某些 API 依赖于此填充）是很有用的。
- en: Private memory consumption must increase immediately to accommodate the full
    size of the assembly. If you instead load from a filename, the CLR uses a memory-mapped
    file, which enables lazy loading and process sharing. Also, should memory run
    low, the OS can release its memory and reload as required without writing to a
    page file.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有内存消耗必须立即增加以适应程序集的完整大小。如果您从文件名加载，则 CLR 使用内存映射文件，这使得延迟加载和进程共享成为可能。此外，如果内存不足，操作系统可以释放其内存并根据需要重新加载，而无需写入分页文件。
- en: LoadFromAssemblyName
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LoadFromAssemblyName
- en: '`AssemblyLoadContext` also provides the following method, which loads an assembly
    by *name*:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`AssemblyLoadContext` 还提供了以下方法，通过 *名称* 加载程序集：'
- en: '[PRE44]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Unlike the two methods just discussed, you don’t pass in any information to
    indicate where the assembly is located; instead you’re instructing the ALC to
    *resolve* the assembly.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 与刚讨论的两种方法不同，您不需要传递任何信息来指示程序集的位置；相反，您正在指示 ALC *解析* 程序集。
- en: Resolving assemblies
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析程序集
- en: The preceding method triggers *assembly resolution*. The CLR also triggers assembly
    resolution when loading dependencies. For example, suppose that assembly A statically
    references assembly B. To resolve reference B, the CLR triggers assembly resolution
    on whichever *ALC assembly A was loaded into.*
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法触发了 *程序集解析*。CLR 在加载依赖项时也会触发程序集解析。例如，假设程序集 A 静态引用程序集 B。为了解析引用 B，CLR 会在加载程序集
    A 的 *ALC 程序集* 上触发程序集解析。
- en: Note
  id: totrans-346
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The CLR resolves dependencies by triggering assembly resolution—whether the
    triggering assembly is in the default or a custom ALC. The difference is that
    with the default ALC, the resolution rules are hardcoded, whereas with a custom
    ALC, you write the rules yourself.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: CLR 通过触发程序集解析来解析依赖关系——触发程序集的是默认的还是自定义的 ALC。不同之处在于，默认 ALC 的解析规则是硬编码的，而自定义 ALC
    则需要您自己编写规则。
- en: 'Here’s what then happens:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 然后发生了以下情况：
- en: The CLR first checks whether an identical resolution has already taken place
    in that ALC (with a matching full assembly name); if so, it returns the `Assembly`
    it returned before.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CLR 首先检查在该 ALC 中是否已经进行了相同的解析（使用匹配的完整程序集名称）；如果是，则返回它之前返回的 `Assembly`。
- en: Otherwise, it calls the ALC’s (virtual protected) `Load` method, which does
    the work of locating and loading the assembly. The default ALC’s `Load` method
    applies the rules we describe in [“The Default ALC”](#the_default_alc). With a
    custom ALC, it’s entirely up to you how you locate the assembly. For instance,
    you might look in some folder and then call `LoadFromAssemblyPath` when you find
    the assembly. It’s also perfectly legal to return an already-loaded assembly from
    the same or another ALC (we demonstrate this in [“Writing a Plug-In System”](#writing_a_plug_in_system)).
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，CLR 调用ALC的（虚拟受保护的） `Load` 方法，执行定位和加载程序集的工作。默认ALC的 `Load` 方法适用我们在 [“默认ALC”](#the_default_alc)
    中描述的规则。使用自定义ALC，您完全可以决定如何定位程序集。例如，您可以在某个文件夹中查找，然后在找到程序集时调用 `LoadFromAssemblyPath`。从同一或另一个ALC返回已加载的程序集也是完全合法的（我们在
    [“编写插件系统”](#writing_a_plug_in_system) 中演示了这一点）。
- en: If Step 2 returns null, the CLR then calls the `Load` method on the default
    ALC (this serves as a useful “fallback” for resolving .NET runtime and common
    application assemblies).
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果第二步返回 null，CLR 将在默认的ALC上调用 `Load` 方法（这作为解析.NET运行时和常见应用程序程序集的有用“回退”）。
- en: If Step 3 returns null, the CLR then fires the `Resolving` events on both ALCs—first,
    on the default ALC and then on the original ALC.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果第三步返回 null，CLR 将在两个ALC上依次触发 `Resolving` 事件：首先是默认的ALC，然后是原始的ALC。
- en: '(For compatibility with .NET Framework): If the assembly still hasn’t been
    resolved, the `AppDomain.CurrentDomain.AssemblyResolve` event fires.'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （与.NET Framework兼容性）：如果程序集仍未解析，`AppDomain.CurrentDomain.AssemblyResolve` 事件将触发。
- en: Note
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: After this process completes, the CLR does a “sanity check” to ensure that whatever
    assembly was loaded has a name that’s compatible with what was requested. The
    simple name must match; the public key token must match *if specified*. The version
    need not match—it can be higher or lower than what was requested.
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成此过程后，CLR 进行“健全性检查”，以确保加载的程序集名称与请求的兼容。简单名称必须匹配；如果指定了，则公钥令牌必须匹配。版本不需要匹配 - 可以比请求的版本高或低。
- en: 'From this, we can see that there are two ways to implement assembly resolution
    in a custom ALC:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 由此可见，在自定义ALC中实现程序集解析有两种方法：
- en: Override the ALC’s `Load` method. This gives your ALC “first say” over what
    happens, which is usually desirable (and essential when you need isolation).
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重写ALC的 `Load` 方法。这使得您的ALC在发生的事情上“第一说”，通常是可取的（当需要隔离时是必要的）。
- en: Handle the ALC’s `Resolving` event. This fires only *after* the default ALC
    has failed to resolve assembly.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理ALC的 `Resolving` 事件。这仅在默认ALC未能解析程序集后才触发。
- en: Note
  id: totrans-359
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you attach multiple event handlers to the `Resolving` event, the first to
    return a non-null value wins.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将多个事件处理程序附加到 `Resolving` 事件，第一个返回非 null 值的事件处理程序胜出。
- en: To illustrate, let’s assume that we want to load an assembly that our main application
    knew nothing about at compile time, called *foo.dll*, located in *c:\temp* (which
    is different from our application folder). We’ll also assume that *foo.dll* has
    a private dependency on *bar.dll*. We want to ensure that when we load *c:\temp\foo.dll*
    and execute its code, *c:\temp\bar.dll* can correctly resolve. We also want to
    ensure that `foo` and its private dependency, `bar`, do not interfere with the
    main application.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 举例说明，假设我们要加载一个主应用程序在编译时不知道的程序集 *foo.dll*，位于 *c:\temp*（与我们的应用程序文件夹不同）。我们还假设 *foo.dll*
    私有依赖于 *bar.dll*。我们希望确保当加载 *c:\temp\foo.dll* 并执行其代码时，*c:\temp\bar.dll* 能够正确解析。我们还希望确保
    `foo` 及其私有依赖项 `bar` 不会影响主应用程序。
- en: 'Let’s begin by writing a custom ALC that overrides `Load`:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编写自定义ALC重写 `Load` 开始：
- en: '[PRE45]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Notice that in the `Load` method, we return `null` if the assembly file is not
    present. This check is important because *foo.dll* will also have dependencies
    on the .NET BCL assemblies; hence, the `Load` method will be called on assemblies
    such as `System.Runtime`. By returning null, we allow the CLR to fall back to
    the default ALC, which will correctly resolve these assemblies.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 `Load` 方法中，如果程序集文件不存在，则返回 `null` 是重要的检查。这是因为 *foo.dll* 也依赖于.NET BCL程序集；因此，当像
    `System.Runtime` 这样的程序集调用 `Load` 方法时，我们返回 null，允许CLR回退到默认的ALC，从而正确解析这些程序集。
- en: Note
  id: totrans-365
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that we didn’t attempt to load the .NET runtime BCL assemblies into our
    own ALC. These system assemblies are not designed to run outside the default ALC,
    and attempts to load them into your own ALC can result in incorrect behavior,
    performance degradation, and unexpected type incompatibility.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有尝试将 .NET 运行时 BCL 程序集加载到我们自己的 ALC 中。这些系统程序集并不适用于在默认 ALC 之外运行，尝试加载它们到您自己的
    ALC 可能导致不正确的行为、性能下降和意外的类型不兼容。
- en: 'Here’s how we could use our custom ALC to load the *foo.dll* assembly in *c:\temp*:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用我们的自定义 ALC 加载 *c:\temp* 中的 *foo.dll* 程序集：
- en: '[PRE46]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When we subsequently begin calling code in the `foo` assembly, the CLR will
    at some point need to resolve the dependency on *bar.dll*. This is when the custom
    ALC’s `Load` method will fire and successfully locate the *bar.dll* assembly in
    *c:\temp*.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们随后开始调用 `foo` 程序集中的代码时，CLR 最终会需要解析对 *bar.dll* 的依赖关系。这是自定义 ALC 的 `Load` 方法将会触发并成功在
    *c:\temp* 中定位 *bar.dll* 程序集的时机。
- en: 'In this case, our `Load` method is also capable of resolving *foo.dll*, so
    we could simplify our code to this:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的 `Load` 方法也能够解析 *foo.dll*，所以我们可以简化我们的代码为：
- en: '[PRE47]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, let’s consider an alternative solution: instead of subclassing `AssemblyLoad​Con⁠text`
    and overriding `Load`, we could instantiate a plain `AssemblyLoadContext` and
    handle its `Resolving` event:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一种替代方案：不是子类化 `AssemblyLoadContext` 并重写 `Load`，而是实例化一个普通的 `AssemblyLoadContext`
    并处理其 `Resolving` 事件：
- en: '[PRE48]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Notice now that we don’t need to check whether the assembly exists. Because
    the `Resolving` event fires *after* the default ALC has had a chance to resolve
    the assembly (and only when it fails), our handler won’t fire for the .NET BCL
    assemblies. This makes this solution simpler, although there’s a disadvantage.
    Remember that in our scenario, the main application knew nothing about *foo.dll*
    or *bar.dll* at compile time. This means that it’s possible for the main application
    to itself depend on assemblies called *foo.dll* or *bar.dll*. If this were to
    occur, the `Resolving` event would never fire, and the application’s `foo` and
    `bar` assemblies would load instead. In other words, we would fail to achieve
    *isolation*.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请注意，我们不需要检查程序集是否存在。因为 `Resolving` 事件是在默认 ALC 尝试解析程序集失败后触发的，所以我们的处理程序不会对 .NET
    BCL 程序集触发。这使得这种解决方案更简单，尽管存在一个缺点。请记住，在我们的场景中，主应用程序在编译时不知道 *foo.dll* 或 *bar.dll*。这意味着主应用程序可能依赖于编译时存在的
    *foo.dll* 或 *bar.dll*。如果这种情况发生，`Resolving` 事件将不会触发，而是加载应用程序的 `foo` 和 `bar` 程序集。换句话说，我们将无法实现*隔离*。
- en: Note
  id: totrans-375
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Our `FolderBasedALC` class is good for illustrating the concept of assembly
    resolution, but it’s of less use in real life because it cannot handle platform-specific
    and (for library projects) development-time NuGet dependencies. In [“AssemblyDependencyResolver”](#assemblydependencyresolver),
    we describe the solution to this problem, and in [“Writing a Plug-In System”](#writing_a_plug_in_system),
    we give a detailed example.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `FolderBasedALC` 类很好地说明了程序集解析的概念，但在实际应用中用处较小，因为它无法处理特定于平台和（对于库项目）开发时的 NuGet
    依赖项。在[“AssemblyDependencyResolver”](#assemblydependencyresolver)中，我们描述了解决此问题的方法，在[“编写插件系统”](#writing_a_plug_in_system)中，我们给出了详细的示例。
- en: The Default ALC
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认 ALC
- en: When an application starts, the CLR assigns a special ALC to the static `AssemblyLoadContext`.`Default`
    property. The default ALC is where your startup assembly loads, along with its
    statically referenced dependencies and the .NET runtime BCL assemblies.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，CLR 会为静态的 `AssemblyLoadContext.Default` 属性分配一个特殊的 ALC。默认的 ALC 是启动程序集加载的地方，以及其静态引用的依赖项和
    .NET 运行时 BCL 程序集。
- en: The default ALC looks first in the *default probing* paths to automatically
    resolve assemblies (see [“Default probing”](#default_probing)); this normally
    equates to the locations indicated in the application’s *.deps.json* and *.runtimeconfig.json*
    files.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 ALC 首先在*默认探测*路径中查找以自动解析程序集（见[“默认探测”](#default_probing)）；这通常等同于应用程序的 *.deps.json*
    和 *.runtimeconfig.json* 文件中指示的位置。
- en: 'If the ALC cannot find an assembly in its default probing paths, its `Resolving`
    event fires. Handling this event lets you load the assembly from other locations,
    which means that you can deploy an application’s dependencies to additional locations,
    such as subfolders, shared folders, or even as a binary resource inside the host
    assembly:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 ALC 在其默认探测路径中找不到一个程序集，将会触发其`Resolving`事件。处理此事件可以让您从其他位置加载程序集，这意味着您可以将应用程序的依赖项部署到其他位置，如子文件夹、共享文件夹，甚至作为主机程序集内的二进制资源：
- en: '[PRE49]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `Resolving` event in the default ALC also fires when a custom ALC fails
    to resolve (in other words, when its `Load` method returns `null`) and the default
    ALC is unable to resolve the assembly.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认ALC中，当自定义ALC无法解析（换句话说，当其`Load`方法返回`null`时）且默认ALC无法解析该程序集时，“Resolving”事件也会触发。
- en: You can also load assemblies into the default ALC from outside the `Resolving`
    event. Before proceeding, however, you should first determine whether you can
    solve the problem better by using a separate ALC or with the approaches we describe
    in the following section (which use the *executing* and *contextual* ALCs). Hardcoding
    to the default ALC makes your code brittle because it cannot as a whole be isolated
    (for instance, by unit testing frameworks or by LINQPad).
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从外部加载程序集到默认ALC中的`Resolving`事件之外。但在继续之前，您应该首先确定是否可以通过使用单独的ALC或使用我们在以下部分描述的方法（使用*executing*和*contextual*
    ALC）来更好地解决问题。因为将代码硬编码到默认ALC会使其变得脆弱，因为它不能完全被隔离（例如通过单元测试框架或LINQPad）。
- en: If you still want to proceed, it’s preferable to call a *resolution method*
    (i.e., `LoadFrom​AssemblyName`) rather than a *loading method* (such as `LoadFromAssemblyPath`)—especially
    if your assembly is statically referenced. This is because it’s possible that
    the assembly might already be loaded, in which case `LoadFromAssemblyName` will
    return the already-loaded assembly, whereas `LoadFromAssemblyPath` will throw
    an exception.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仍然希望继续，最好调用一个*解析方法*（如`LoadFromAssemblyName`），而不是一个*加载方法*（例如`LoadFromAssemblyPath`）——特别是如果您的程序集是静态引用的情况下。这是因为可能已经加载了该程序集，此时`LoadFromAssemblyName`将返回已加载的程序集，而`LoadFromAssemblyPath`将抛出异常。
- en: (With `LoadFromAssemblyPath`, you can also run the risk of loading the assembly
    from a place that’s inconsistent with where the ALC’s default resolution mechanism
    would find it.)
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: （使用`LoadFromAssemblyPath`时，您也可能面临从与ALC默认解析机制不一致的位置加载程序集的风险。）
- en: If the assembly is in a place where the ALC won’t automatically find it, you
    can still follow this procedure and additionally handle the ALC’s `Resolving`
    event.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序集位于ALC不会自动找到的位置，您仍然可以遵循此过程并另外处理ALC的`Resolving`事件。
- en: 'Note that when calling `LoadFromAssemblyName`, you don’t need to provide the
    full name; the simple name will do (and is valid even if the assembly is strongly
    named):'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在调用`LoadFromAssemblyName`时，您不需要提供完整的名称；简单名称就足够了（即使程序集是强命名的也是有效的）：
- en: '[PRE50]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: However, if you include the public key token in the name, it must match with
    what’s loaded.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果在名称中包含公钥令牌，则必须与加载的内容匹配。
- en: Default probing
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认探测
- en: 'The default probing paths normally comprise the following:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 默认探测路径通常包括以下内容：
- en: Paths specified in *AppName.deps.json* (where *AppName* is the name of your
    application’s main assembly). If this file is not present, the application base
    folder is used instead.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径在*AppName.deps.json*中指定（其中*AppName*是您的应用程序主程序集的名称）。如果此文件不存在，则使用应用程序基础文件夹。
- en: Folders containing the .NET runtime system assemblies (if your application is
    Framework-dependent).
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含.NET运行时系统程序集的文件夹（如果您的应用程序是依赖于Framework的）。
- en: MSBuild automatically generates a file called *AppName.deps.json*, which describes
    where to find all of its dependencies. These include platform-agnostic assemblies,
    which are placed in the application base folder, and platform-specific assemblies,
    which are placed in the *runtimes\* subdirectory under a subfolder such as *win*
    or *unix*.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: MSBuild会自动生成一个名为*AppName.deps.json*的文件，其中描述了如何找到所有依赖项。这些包括跨平台的程序集，放置在应用程序基础文件夹中，以及特定于平台的程序集，放置在*runtimes\*子目录下的一个子文件夹中，例如*win*或*unix*。
- en: The paths specified in the generated *.deps.json* file are relative to the application
    base folder—or any additional folders that you specify in the `additionalProbingPaths`
    section of the *AppName.runtimeconfig.json* and/or *AppName.runtimeconfig.dev.json*
    configuration files (the latter is intended only for the development environment).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成的*.deps.json*文件中指定的路径是相对于应用程序基础文件夹的，或者是您在*AppName.runtimeconfig.json*和/或*AppName.runtimeconfig.dev.json*配置文件的`additionalProbingPaths`部分中指定的任何附加文件夹（后者仅适用于开发环境）。
- en: The “Current” ALC
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “当前”ALC
- en: In the preceding section, we cautioned against explicitly loading assemblies
    into the default ALC. What you usually want, instead, is to load/resolve into
    the “current” ALC.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们警告不要显式加载程序集到默认ALC中。您通常希望的是加载/解析到“当前”ALC中。
- en: 'In most cases, the “current” ALC is the one containing the currently executing
    assembly:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，“当前”的ALC是包含当前执行程序集的ALC：
- en: '[PRE51]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here’s a more flexible and explicit way to obtain the ALC:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种更灵活和明确的获取ALC的方式：
- en: '[PRE52]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Sometimes, it’s impossible to infer the “current” ALC. For example, suppose
    that you were responsible for writing the .NET binary serializer (we describe
    serialization in the online supplement at [*http://www.albahari.com/nutshell*](http://www.albahari.com/nutshell)).
    A serializer such as this writes the full names of the types that it serializes
    (including their assembly names), which must be *resolved* during deserialization.
    The question is, which ALC should you use? The problem with relying on the executing
    assembly is that it will return whatever assembly contains the deserializer, not
    the assembly that’s *calling* the deserializer.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，不可能推断“当前”的ALC。例如，假设您负责编写.NET二进制序列化器（我们在[*http://www.albahari.com/nutshell*](http://www.albahari.com/nutshell)的在线补充中描述了序列化）。这样的序列化器写入它序列化的类型的完整名称（包括它们的程序集名称），在反序列化期间必须进行*解析*。问题是，您应该使用哪个ALC？依赖执行程序集的问题是，它将返回包含反序列化器的程序集，而不是*调用*反序列化器的程序集。
- en: 'The best solution is not to guess but to ask:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳解决方案不是猜测，而是询问：
- en: '[PRE53]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Being explicit maximizes flexibility and minimizes the chance of making mistakes.
    The caller can now decide what should count as the “current” ALC:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 明确指定可最大化灵活性并最小化出错几率。调用者现在可以决定什么应该算作“当前”的ALC：
- en: '[PRE54]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Assembly.Load and Contextual ALCs
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Assembly.Load和上下文ALCs
- en: 'To help with the common case of loading an assembly into the currently executing
    ALC; that is:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助加载程序集到当前执行的ALC的常见情况；即：
- en: '[PRE55]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Microsoft has defined the following method in the `Assembly` class:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft已在`Assembly`类中定义了以下方法：
- en: '[PRE56]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'as well as a functionally identical version that accepts an `AssemblyName`
    object:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 以及一个功能上相同的接受`AssemblyName`对象版本：
- en: '[PRE57]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: (Don’t confuse these methods with the legacy `Load(byte[])` method, which behaves
    in a totally different manner—see [“The Legacy Loading Methods”](#the_legacy_loading_methods).)
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: （不要将这些方法与完全不同方式行为的旧版`Load(byte[])`方法混淆，请参阅[“旧版加载方法”](#the_legacy_loading_methods)。）
- en: 'As with `LoadFromAssemblyName`, you have a choice of specifying the assembly’s
    simple, partial, or full name:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 与`LoadFromAssemblyName`一样，您可以选择指定程序集的简单、部分或完整名称：
- en: '[PRE58]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This loads the `System.Private.Xml` assembly into whatever ALC the *executing
    code’s assembly* is loaded in.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`System.Private.Xml`程序集加载到执行代码所在的任何ALC中。
- en: 'In this case, we specified a simple name. The following strings would also
    be valid, and all would have the same result in .NET:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们指定了一个简单名称。以下字符串也是有效的，并且在.NET中结果相同：
- en: '[PRE59]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: If you choose to specify a public key token, it must match with what’s loaded.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择指定公钥令牌，它必须与加载的内容匹配。
- en: Note
  id: totrans-421
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The Microsoft Developer Network (MSDN) cautions against loading an assembly
    from a partial name, recommending that you specify the exact version and public
    key token. Their rationale is based on factors relevant to .NET Framework, such
    as the effects of the Global Assembly Cache and Code Access Security. In .NET
    5+ and .NET Core, these factors aren’t present, and it’s generally safe to load
    from a simple or partial name.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft开发人员网络（MSDN）警告不要根据部分名称加载程序集，建议您指定确切的版本和公钥令牌。他们的理由基于.NET Framework相关因素，例如全局程序集缓存和代码访问安全性的影响。在.NET
    5+和.NET Core中，这些因素不存在，因此通常可以从简单或部分名称加载。
- en: Both of these methods are strictly for *resolution*, so you cannot specify a
    file path. (If you populate the `CodeBase` property in the `AssemblyName` object,
    it will be ignored.)
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都严格用于*解析*，因此不能指定文件路径。（如果在`AssemblyName`对象的`CodeBase`属性中填充内容，将会被忽略。）
- en: Warning
  id: totrans-424
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'Don’t fall into the trap of using `Assembly.Load` to load a statically referenced
    assembly. All you need do in this case is refer to a type in the assembly and
    obtain the assembly from that:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 不要陷入使用`Assembly.Load`加载静态引用程序集的陷阱。在这种情况下，您只需引用程序集中的某个类型并从中获取该程序集：
- en: '[PRE60]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Or, you could even do this:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您甚至可以这样做：
- en: '[PRE61]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This prevents hardcoding the assembly name (which you might change in the future)
    while triggering assembly resolution on the *executing code’s* ALC (as would happen
    with `Assembly.Load`).
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以避免硬编码程序集名称（您将来可能会更改），同时在*执行代码的*ALC上触发程序集解析（就像使用`Assembly.Load`一样）。
- en: 'If you were to write the `Assembly`.`Load` method yourself, it would (almost)
    look like this:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要自己编写`Assembly`.`Load`方法，它（几乎）看起来会像这样：
- en: '[PRE62]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: EnterContextualReflection
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: EnterContextualReflection
- en: '`Assembly`.`Load`’s strategy of using the calling assembly’s ALC context fails
    when `Assembly`.`Load` is called via an intermediary, such as a deserializer or
    unit test runner. If the intermediary is defined in a different assembly, the
    intermediary’s load context is used instead of the caller’s load context.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过中介（如反序列化器或单元测试运行器）调用`Assembly`.`Load`时，`Assembly`.`Load`使用调用方的加载上下文的策略失败。如果中介定义在不同的程序集中，则使用中介的加载上下文而不是调用方的加载上下文。
- en: Note
  id: totrans-434
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We described this scenario earlier, when we talked about how you might write
    a deserializer. In such cases, the ideal solution is to force the caller to specify
    an ALC rather than inferring it with `Assembly.Load(string)`.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在早些时候描述了这种情况，当我们讨论如何编写反序列化器时。在这种情况下，理想的解决方案是强制调用者指定一个ALC，而不是通过`Assembly.Load(string)`推断它。
- en: But because .NET 5+ and .NET Core evolved from .NET Framework—where isolation
    was accomplished with application domains rather than ALCs—the ideal solution
    is not prevalent, and `Assembly.Load(string)` is sometimes used inappropriately
    in scenarios in which the ALC cannot be reliably inferred. An example is the .NET
    binary serializer.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于.NET 5+和.NET Core是从.NET Framework进化而来——在那里，隔离是通过应用程序域而不是ALC完成的——理想的解决方案并不普遍，有时在无法可靠推断ALC的情况下，会不适当地使用`Assembly.Load(string)`。一个例子是.NET二进制序列化器。
- en: To allow `Assembly`.`Load` to still work in such scenarios, Microsoft has added
    a method to `AssemblyLoadContext` called `EnterContextualReflection`. This assigns
    an ALC to `AssemblyLoadContext`.`CurrentContextualReflectionContext`. Although
    this is a static property, its value is stored in an `AsyncLocal` variable, so
    it can hold separate values on different threads (but still be preserved throughout
    asynchronous operations).
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在这种场景下仍然允许`Assembly`.`Load`工作，Microsoft添加了一个方法到`AssemblyLoadContext`，名为`EnterContextualReflection`。这会将一个ALC分配给`AssemblyLoadContext`.`CurrentContextualReflectionContext`。虽然这是一个静态属性，但它的值存储在一个`AsyncLocal`变量中，因此可以在不同线程上持有不同的值（但在整个异步操作期间仍然保持）。
- en: 'If this property is non-null, `Assembly`.`Load` automatically uses it in preference
    to the calling ALC:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此属性非空，`Assembly`.`Load`会自动使用它，而不是调用方的ALC：
- en: '[PRE63]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We previously demonstrated how you could write a method that’s functionally
    similar to `Assembly`.`Load`. Here’s a more accurate version that takes the contextual
    reflection context into account:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前演示了如何编写一个功能类似于`Assembly`.`Load`的方法。这里是一个更准确的版本，考虑到了上下文反射上下文：
- en: '[PRE64]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Even though the contextual reflection context can be useful in allowing legacy
    code to run, a more robust solution (as we described earlier) is to modify the
    code that calls `Assembly.Load` so that it instead calls `LoadFromAssemblyName`
    on an ALC that’s passed in by the caller.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 即使上下文反射上下文对于允许旧代码运行可能有用，但更健壮的解决方案（正如我们之前所描述的）是修改调用`Assembly.Load`的代码，使其改为在由调用者传入的ALC上调用`LoadFromAssemblyName`。
- en: Note
  id: totrans-443
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: .NET Framework has no equivalent of `EnterContextualReflection`—and does not
    need it—despite having the same `Assembly`.`Load` methods. This is because with
    .NET Framework, isolation is accomplished primarily with *application domains*
    rather than ALCs. Application domains provide a stronger isolation model whereby
    each application domain has its own default load context, so isolation can still
    work even when only the default load context is used.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework没有`EnterContextualReflection`的等价物——也不需要它——尽管有相同的`Assembly`.`Load`方法。这是因为在.NET
    Framework中，隔离主要通过*应用程序域*而不是ALC完成。应用程序域提供了更强的隔离模型，每个应用程序域都有自己的默认加载上下文，因此即使只使用默认加载上下文，隔离仍然可以工作。
- en: Loading and Resolving Unmanaged Libraries
  id: totrans-445
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载和解析非托管库
- en: 'ALCs can also load and resolve native libraries. Native resolution is triggered
    when you call an external method that’s marked with the `[DllImport]` attribute:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: ALC也可以加载和解析本机库。当调用标有`[DllImport]`属性的外部方法时，会触发本机解析：
- en: '[PRE65]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Because we didn’t specify a full path in the `[DllImport]` attribute, calling
    `Some​Nati⁠veMethod` triggers a resolution in whatever ALC contains the assembly
    in which `SomeNativeMethod` is defined.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在`[DllImport]`属性中没有指定完整路径，调用`Some​Nati⁠veMethod`会触发在包含`SomeNativeMethod`定义的程序集的任何ALC中的解析。
- en: 'The virtual *resolving* method in the ALC is called `LoadUnmanagedDll`, and
    the *loading* method is called `LoadUnmanagedDllFromPath`:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: ALC中的虚拟*解析*方法称为`LoadUnmanagedDll`，*加载*方法称为`LoadUnmanagedDllFromPath`：
- en: '[PRE66]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If you’re unable to locate the file, you can return `IntPtr.Zero`. The CLR will
    then fire the ALC’s `ResolvingUnmanagedDll` event.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法找到文件，可以返回`IntPtr.Zero`。CLR 将会触发 ALC 的`ResolvingUnmanagedDll`事件。
- en: 'Interestingly, the `LoadUnmanagedDllFromPath` method is protected, so you won’t
    usually be able to call it from a `ResolvingUnmanagedDll` event handler. However,
    you can achieve the same result by calling the static `NativeLibrary.Load`:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，`LoadUnmanagedDllFromPath`方法是受保护的，因此您通常无法从`ResolvingUnmanagedDll`事件处理程序中调用它。但是，您可以通过调用静态的`NativeLibrary.Load`来达到相同的效果：
- en: '[PRE67]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Although native libraries are typically resolved and loaded by ALCs, they don’t
    “belong” to an ALC. After it’s loaded, a native library stands on its own and
    takes responsibility for resolving any transitive dependencies that it might have.
    Furthermore, native libraries are global to the process, so it’s not possible
    to load two different versions of a native library if they have the same filename.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通常由 ALC 解析和加载本机库，但本机库并不属于任何 ALC。加载后，本机库独立存在，并负责解析可能具有的任何传递依赖项。此外，本机库是进程全局的，因此如果具有相同文件名的两个不同版本的本机库，是不可能加载的。
- en: AssemblyDependencyResolver
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AssemblyDependencyResolver
- en: In [“Default probing”](#default_probing), we said that the default ALC reads
    the *.deps.json* and *.runtimeconfig.json* files, if present, in determining where
    to look to resolve platform-specific and development-time NuGet dependencies.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“默认探测”](#default_probing)中，我们说默认的 ALC 会读取*.deps.json*和*.runtimeconfig.json*文件（如果存在），以确定在哪里查找解析平台特定和开发时
    NuGet 依赖项。
- en: If you want to load an assembly into a custom ALC that has platform-specific
    or NuGet dependencies, you’ll need to somehow reproduce this logic. You could
    accomplish this by parsing the configuration files and carefully following the
    rules on platform-specific monikers, but doing so is not only difficult, but the
    code that you write will break if the rules change in a later version of .NET.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想将一个具有平台特定或 NuGet 依赖项的程序集加载到自定义 ALC 中，您需要以某种方式复制此逻辑。您可以通过解析配置文件并仔细遵循平台特定的标识规则来完成此操作，但这不仅很困难，而且如果
    .NET 的后续版本中更改了规则，您编写的代码将会出错。
- en: 'The `AssemblyDependencyResolver` class solves this problem. To use it, you
    instantiate it with the path of the assembly whose dependencies you want to probe:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '`AssemblyDependencyResolver`类解决了这个问题。要使用它，您需要实例化它并提供您想要探测其依赖项的程序集的路径：'
- en: '[PRE68]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then, to find the path of a dependency, you call the `ResolveAssemblyToPath`
    method:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要找到依赖项的路径，您需要调用`ResolveAssemblyToPath`方法：
- en: '[PRE69]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In the absence of a *.deps.json* file (or if the .*deps.json* doesn’t contain
    anything relevant to *bar.dll*), this will evaluate to *c:\temp\bar.dll*.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有*.deps.json*文件（或者*.deps.json*文件中没有与*bar.dll*相关的内容），则将评估为*c:\temp\bar.dll*。
- en: You can similarly resolve unmanaged dependencies by calling `ResolveUnmana⁠ged​DllToPath`.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用`ResolveUnmana⁠ged​DllToPath`类似地解析非托管依赖项。
- en: 'A great way to illustrate a more complex scenario is to create a new Console
    project called `ClientApp` and then add a NuGet reference to *Microsoft.Data.SqlClient*.
    Add the following class:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 说明更复杂场景的一个很好的方法是创建一个名为`ClientApp`的新控制台项目，然后为其添加一个*Microsoft.Data.SqlClient*的
    NuGet 引用。添加以下类：
- en: '[PRE70]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now build the application and look in the output folder: you’ll see a file
    called *Microsoft.Data.SqlClient.dll*. However, this file *never loads* when run,
    and attempting to explicitly load it throws an exception. The assembly that actually
    loads is located in the *runtimes\win* (or *runtimes/unix*) subfolder; the default
    ALC knows to load it because it parses the *ClientApp.deps.json* file.'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建应用程序并查看输出文件夹：您会看到一个名为*Microsoft.Data.SqlClient.dll*的文件。但是，运行时此文件*不会加载*，并且尝试显式加载它会引发异常。实际加载的程序集位于*runtimes\win*（或*runtimes/unix*）子文件夹中；默认的
    ALC 知道加载它，因为它解析了*ClientApp.deps.json*文件。
- en: 'If you were to try to load the *ClientApp.dll* assembly from another application,
    you’d need to write an ALC that can resolve its dependency, *Microsoft.Data.SqlClient.dll*.
    In doing so, it would be insufficient to merely look in the folder where *ClientApp.dll*
    is located (as we did in [“Resolving assemblies”](#resolving_assemblies)). Instead,
    you’d need to use `AssemblyDependencyResolver` to determine where that file is
    located for the platform in use:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您试图从另一个应用程序加载*ClientApp.dll*程序集，您需要编写一个可以解析其依赖项*Microsoft.Data.SqlClient.dll*的
    ALC。在此过程中，仅仅查找*ClientApp.dll*所在的文件夹是不够的（就像我们在[“解析程序集”](#resolving_assemblies)中所做的那样）。相反，您需要使用`AssemblyDependencyResolver`来确定正在使用的平台中该文件的位置：
- en: '[PRE71]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'On a Windows machine, this outputs the following:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows机器上，这将输出以下内容：
- en: '[PRE72]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We give a complete example in [“Writing a Plug-In System”](#writing_a_plug_in_system).
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[“编写插件系统”](#writing_a_plug_in_system)中提供了一个完整的示例。
- en: Unloading ALCs
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 卸载ALC
- en: 'In simple cases, it’s possible to unload a nondefault `AssemblyLoadContext`,
    freeing memory and releasing file locks on the assemblies it loaded. For this
    to work, the ALC must have been instantiated with the `isCollectible` parameter
    `true`:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单的情况下，可以卸载非默认的`AssemblyLoadContext`，释放内存并释放它加载的程序集的文件锁。为了使其工作，ALC必须使用`isCollectible`参数`true`进行实例化：
- en: '[PRE73]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: You can then call the `Unload` method on the ALC to initiate the unload process.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以调用ALC上的`Unload`方法来启动卸载过程。
- en: The unload model is cooperative rather than preemptive. If any methods in any
    of the ALC’s assemblies are executing, the unload will be deferred until those
    methods finish.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 卸载模型是合作性的，而不是抢占式的。如果任何ALC的程序集中的任何方法正在执行，则卸载将被推迟，直到这些方法完成。
- en: The actual unload takes place during garbage collection; it will not take place
    if anything from outside the ALC has any (nonweak) reference to anything inside
    the ALC (including objects, types, and assemblies). It’s not uncommon for APIs
    (including those in the .NET BCL) to cache objects in static fields or dictionaries—or
    subscribe to events—and this makes it easy to create references that will prevent
    an unload, especially if code in the ALC uses APIs outside its ALC in a nontrivial
    way. Determining the cause of a failed unload is difficult and requires the use
    of tools such as WinDbg.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的卸载发生在垃圾回收期间；如果来自ALC外部的任何东西（包括对象、类型和程序集）对ALC内部的任何东西具有任何（非弱）引用，则不会发生卸载。在.NET
    BCL中，包括静态字段或字典中缓存对象以及订阅事件是很常见的API，这使得很容易创建引用，阻止卸载，尤其是如果ALC中的代码以非平凡的方式使用其ALC外的API。确定卸载失败的原因很困难，需要使用诸如WinDbg之类的工具。
- en: The Legacy Loading Methods
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旧加载方法
- en: 'If you’re still using .NET Framework (or writing a library that targets .NET
    Standard and want to support .NET Framework), you won’t be able to use the `AssemblyLoadContext`
    class. Loading is accomplished instead by using the following methods:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仍在使用.NET Framework（或编写目标为.NET Standard并希望支持.NET Framework的库），则无法使用`AssemblyLoadContext`类。取而代之的是通过以下方法实现加载：
- en: '[PRE74]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '`LoadFile` and `Load(byte[])` provide isolation, whereas `LoadFrom` does not.'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadFile`和`Load(byte[])`提供隔离性，而`LoadFrom`则不提供。'
- en: Resolution is accomplished by handling the application domain’s `AssemblyResolve`
    event, which works like the default ALC’s `Resolving` event.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 通过处理应用程序域的`AssemblyResolve`事件来实现解析，其工作方式类似于默认ALC的`Resolving`事件。
- en: The `Assembly.Load(string)` method is also available to trigger resolution and
    works in a similar way.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '`Assembly.Load(string)`方法也可用于触发解析，并以类似的方式工作。'
- en: LoadFrom
  id: totrans-484
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LoadFrom
- en: '`LoadFrom` loads an assembly from a given path into the default ALC. It’s a
    bit like calling `AssemblyLoadContext.Default.LoadFromAssemblyPath` except for
    the following:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadFrom`从给定路径加载程序集到默认ALC中。这有点像调用`AssemblyLoadContext.Default.LoadFromAssemblyPath`，除了以下几点：'
- en: If an assembly with the same simple name is already present in the default ALC,
    `LoadFrom` returns that assembly rather than throwing an exception.
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在默认ALC中已经存在具有相同简单名称的程序集，则`LoadFrom`返回该程序集，而不是抛出异常。
- en: If an assembly with the same simple name is *not* already present in the default
    ALC and a load takes place, the assembly is given a special “LoadFrom” status.
    This status affects the default ALC’s resolution logic, in that should that assembly
    have any dependencies in the *same folder*, those dependencies will resolve automatically.
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在默认的ALC中尚未存在具有相同简单名称的程序集，并且发生了加载，则该程序集将被赋予特殊的“LoadFrom”状态。该状态影响默认ALC的解析逻辑，即如果该程序集在*相同的文件夹*中有任何依赖项，则这些依赖项将自动解析。
- en: Note
  id: totrans-488
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: .NET Framework has a *Global Assembly Cache* (GAC). If the assembly is present
    in the GAC, the CLR will always load from there instead. This applies to all three
    loading methods.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework有*全局程序集缓存*（GAC）。如果程序集存在于GAC中，则CLR将始终从那里加载。这适用于所有三种加载方法。
- en: '`LoadFrom`’s ability to automatically resolve transitive same-folder dependencies
    can be convenient—until it loads an assembly that it shouldn’t. Because such scenarios
    can be difficult to debug, it can be better to use `Load(string)` or `LoadFile`
    and resolve transitive dependencies by handling the application domain’s `AssemblyResolve`
    event. This gives you the power to decide how to resolve each assembly and allows
    for debugging (by creating a breakpoint inside the event handler).'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadFrom`自动解析传递性相同文件夹依赖项的能力可能很方便，直到它加载不应该加载的程序集。由于这种情况很难调试，最好使用`Load(string)`或`LoadFile`，并通过处理应用程序域的`AssemblyResolve`事件来解析传递性依赖项。这样可以让您决定如何解析每个程序集，并允许通过在事件处理程序内创建断点进行调试。'
- en: LoadFile and Load(byte[])
  id: totrans-491
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LoadFile 和 Load(byte[])
- en: '`LoadFile` and `Load(byte[])` load an assembly from a given file path or byte
    array into a new ALC. Unlike `LoadFrom`, these methods provide isolation and let
    you load multiple versions of the same assembly. However, there are two caveats:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadFile`和`Load(byte[])`从给定的文件路径或字节数组加载程序集到新的 ALC 中。与`LoadFrom`不同，这些方法提供了隔离并允许您加载同一程序集的多个版本。但是，有两个注意事项：'
- en: Calling `LoadFile` again with the identical path will return the previously
    loaded assembly.
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用相同路径再次调用`LoadFile`将返回先前加载的程序集。
- en: In .NET Framework, both methods first check the GAC and load from there instead
    if the assembly is present.
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 .NET Framework 中，这两种方法首先检查 GAC，并在程序集存在时从那里加载。
- en: With `LoadFile` and `Load(byte[])`, you end up with a separate ALC per assembly
    (caveats aside). This enables isolation, although it can make it more awkward
    to manage.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`LoadFile`和`Load(byte[])`，您会得到一个单独的 ALC 每个程序集（除了注意事项）。这种隔离使得管理变得更加复杂。
- en: 'To resolve dependencies, you handle the `AppDomain`’s `Resolving` event, which
    fires on all ALCs:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 要解析依赖项，您需要处理`AppDomain`的`Resolving`事件，该事件在所有 ALC 上触发：
- en: '[PRE75]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `args` variable also includes a property called `RequestingAssembly`, which
    tells you which assembly triggered the resolution.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '`args` 变量还包括一个名为 `RequestingAssembly` 的属性，该属性告诉您触发解析的程序集是哪个。'
- en: After locating the assembly, you can then call `Assembly`.`LoadFile` to load
    it.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 找到组件后，可以调用`Assembly`.`LoadFile`来加载它。
- en: Note
  id: totrans-500
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can enumerate all of the assemblies that have been loaded into the current
    application domain with `AppDomain.CurrentDomain.GetAssemblies()`. This works
    in .NET 5+, too, where it’s equivalent to the following:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`AppDomain.CurrentDomain.GetAssemblies()`枚举已加载到当前应用程序域中的所有程序集。在 .NET 5+
    中也适用，其等效于以下内容：
- en: '[PRE76]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Writing a Plug-In System
  id: totrans-503
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写插件系统
- en: To fully demonstrate the concepts that we’ve covered in this section, let’s
    write a plug-in system that uses unloadable ALCs to isolate each plug-in.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全演示本节中涵盖的概念，让我们编写一个插件系统，该系统使用无法卸载的 ALC 来隔离每个插件。
- en: 'Our demo system will initially comprise three .NET projects:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的演示系统最初将包括三个 .NET 项目：
- en: Plugin.Common (library)
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: Plugin.Common（库）
- en: Defines an interface that plug-ins will implement
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 定义插件将实现的接口
- en: Capitalizer (library)
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: Capitalizer（库）
- en: A plug-in that capitalizes text
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 一个将文本转换为大写的插件
- en: Plugin.Host (console application)
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: Plugin.Host（控制台应用程序）
- en: Locates and invokes plug-ins
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 定位并调用插件
- en: 'Let’s assume that the projects reside in the following directories:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 假设项目位于以下目录中：
- en: '[PRE77]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: All projects will reference the Plugin.Common library, and there will be no
    other interproject references.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 所有项目将引用 Plugin.Common 库，而没有其他项目间的引用。
- en: Note
  id: totrans-515
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If Plugin.Host were to reference Capitalizer, we wouldn’t be writing a plug-in
    system; the central idea is that the plug-ins are written by third parties after
    Plugin.Host and Plugin.Common have been published.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Plugin.Host 引用了 Capitalizer，我们将不会编写一个插件系统；中心思想是插件是由 Plugin.Host 和 Plugin.Common
    发布后的第三方编写的。
- en: If you’re using Visual Studio, it can be convenient to put all three projects
    into a single solution for the sake of this demo. If you do so, right-click the
    Plugin.Host project, choose Build Dependencies > Project Dependencies, and then
    tick the Capitalizer project. This forces Capitalizer to build when you run the
    Plugin.Host project, without adding a reference.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 Visual Studio，将这三个项目放入单个解决方案中可能会很方便，以便进行此演示。如果这样做，请右键单击 Plugin.Host 项目，选择“生成依赖项”
    > “项目依赖项”，然后选中 Capitalizer 项目。这样在运行 Plugin.Host 项目时，会强制 Capitalizer 在不添加引用的情况下进行构建。
- en: Plugin.Common
  id: totrans-518
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Plugin.Common
- en: 'Let’s begin with Plugin.Common. Our plug-ins will perform a very simple task,
    which is to transform a string. Here’s how we’ll define the interface:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 Plugin.Common 开始。我们的插件将执行一个非常简单的任务，即转换一个字符串。以下是我们如何定义接口：
- en: '[PRE78]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: That’s all there is to Plugin.Common.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 插件.Common就是这样。
- en: Capitalizer (plug-in)
  id: totrans-522
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大写（插件）
- en: 'Our Capitalizer plug-in will reference Plugin.Common and contain a single class.
    For now, we’ll keep the logic simple so that the plug-in has no extra dependencies:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的大写插件将引用Plugin.Common并包含一个单独的类。目前，我们将保持逻辑简单，以便插件没有额外的依赖关系：
- en: '[PRE79]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'If you build both projects and look in Capitalizer’s output folder, you’ll
    see the following two assemblies:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您构建了两个项目并查看大写插件的输出文件夹，您将看到以下两个程序集：
- en: '[PRE80]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Plugin.Host
  id: totrans-527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Plugin.Host
- en: 'Plugin.Host is a console application with two classes. The first class is a
    custom ALC to load the plug-ins:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: Plugin.Host是一个包含两个类的控制台应用程序。第一个类是加载插件的自定义ALC：
- en: '[PRE81]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: In the constructor, we pass in the path to the main plug-in assembly as well
    as a flag to indicate whether we’d like the ALC to be collectible (so that it
    can be unloaded).
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们传入主插件程序集的路径以及一个标志，指示我们是否希望ALC可以被收集（以便可以卸载它）。
- en: 'The `Load` method is where we handle dependency resolution. All plug-ins must
    reference Plugin.Common so that they can implement `ITextPlugin`. This means that
    the `Load` method will fire at some point to resolve Plugin.Common. We need to
    be careful because the plug-in’s output folder is likely to contain not only *Capitalizer.dll*
    but also its own copy of *Plugin.Common.dll*. If we were to load this copy of
    *Plugin.Common.dll* into the `PluginLoadContext`, we’d end up with two copies
    of the assembly: one in the host’s default context and one in the plug-in’s `PluginLoad​Con⁠text`.
    The assemblies would be incompatible, and the host would complain that the plug-in
    does not implement `ITextPlugin`!'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '`Load`方法是我们处理依赖项解析的地方。所有插件都必须引用Plugin.Common，以便它们可以实现`ITextPlugin`。这意味着`Load`方法将在某个时候触发以解析Plugin.Common。我们需要小心，因为插件的输出文件夹很可能不仅包含*Capitalizer.dll*，还包含自己的*Plugin.Common.dll*副本。如果我们加载这个*Plugin.Common.dll*副本到`PluginLoadContext`中，我们将得到两个程序集副本：一个在主机的默认上下文中，一个在插件的`PluginLoadContext`中。这些程序集将不兼容，主机将抱怨插件未实现`ITextPlugin`！'
- en: 'To solve this, we check explicitly for this condition:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，我们明确地检查这个条件：
- en: '[PRE82]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Returning null allows the host’s default ALC to instead resolve the assembly.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 返回null允许主机的默认ALC来解析程序集。
- en: Note
  id: totrans-535
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Instead of returning null, we could return `typeof(ITextPlugin).Assembly`, and
    it would also work correctly. How can we be certain that `ITextPlugin` will resolve
    on the host’s ALC and not on our `PluginLoadContext`? Remember that our `PluginLoadContext`
    class is defined in the `Plugin.Host` assembly. Therefore, any types that you
    statically reference from this class will trigger an assembly resolution on the
    ALC into which *its assembly*, `Plugin.Host`, was loaded.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是返回null，我们可以返回`typeof(ITextPlugin).Assembly`，它也将正确工作。我们如何确保`ITextPlugin`将在主机的ALC上解析，而不是在我们的`PluginLoadContext`上？请记住，我们的`PluginLoadContext`类定义在`Plugin.Host`程序集中。因此，您从这个类静态引用的任何类型都将触发在其加载的ALC上解析程序集的组件，即`Plugin.Host`。
- en: After checking for the common assembly, we use `AssemblyDependencyResolver`
    to locate any private dependencies that the plug-in might have. (Right now, there
    will be none.)
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 检查通用程序集后，我们使用`AssemblyDependencyResolver`来定位插件可能具有的任何私有依赖项。（现在不会有。）
- en: Notice that we also override the `LoadUnamangedDll` method. This ensures that
    if the plug-in has any unmanaged dependencies, these will load correctly, too.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还重写了`LoadUnamangedDll`方法。这确保了如果插件有任何非托管依赖项，它们也会正确加载。
- en: 'The second class to write in Plugin.Host is the main program itself. For simplicity,
    let’s hardcode the path to our Capitalizer plug-in (in real life, you might discover
    the paths of plug-ins by looking for DLLs in known locations or reading from a
    configuration file):'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: Plugin.Host的第二个要编写的类是程序的主要程序本身。为简单起见，让我们将路径硬编码到我们的Capitalizer插件（在现实生活中，您可能通过查找已知位置的DLL或从配置文件中读取来发现插件的路径）：
- en: '[PRE83]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Let’s look at the `TransformText` method. We first instantiate a new ALC for
    our plug-in and then ask it to load the main plug-in assembly. Next, we use Reflection
    to locate the type that implements `ITextPlugin` (we cover this in detail in [Chapter 18](ch18.html#reflection_and_metadata)).
    Then, we instantiate the plug-in, call the `TransformText` method, and unload
    the ALC.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`TransformText`方法。我们首先为我们的插件实例化一个新的ALC，然后要求它加载主插件程序集。接下来，我们使用反射来定位实现`ITextPlugin`接口的类型（我们在[第18章](ch18.html#reflection_and_metadata)中详细讨论这个）。然后，我们实例化插件，调用`TransformText`方法，然后卸载ALC。
- en: Note
  id: totrans-542
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you needed to call the `TransformText` method repeatedly, a better approach
    would be to cache the ALC rather than unloading it after each call.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要重复调用`TransformText`方法，更好的方法是缓存ALC而不是在每次调用后卸载它。
- en: 'Here’s the output:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE84]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Adding dependencies
  id: totrans-546
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加依赖项
- en: 'Our code is fully capable of resolving and isolating dependencies. To illustrate,
    let’s first add a NuGet reference to *Humanizer.Core*, version 2.6.2\. You can
    do this via the Visual Studio UI or by adding the following element to the *Capitalizer.csproj*
    file:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码完全能够解析和隔离依赖项。举例来说，让我们首先添加一个NuGet引用到*Humanizer.Core*，版本为2.6.2。你可以通过Visual
    Studio的UI或者将以下元素添加到*Capitalizer.csproj*文件来实现这一点：
- en: '[PRE85]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now, modify `CapitalizerPlugin`, as follows:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，修改`CapitalizerPlugin`如下：
- en: '[PRE86]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'If you rerun the program, the output will now be this:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 如果重新运行程序，输出现在将是这样的：
- en: '[PRE87]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Next, we create another plug-in called Pluralizer. Create a new .NET library
    project and add a NuGet reference to *Humanizer.Core*, version 2.7.9:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建另一个名为Pluralizer的插件。创建一个新的.NET库项目，并添加一个NuGet引用到*Humanizer.Core*，版本为2.7.9：
- en: '[PRE88]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now, add a class called `PluralizerPlugin`. This will be similar to `Capitalizer​Plu⁠gIn`,
    but we call the `Pluralize` method instead:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加一个名为`PluralizerPlugin`的类。这将类似于`Capitalizer​Plu⁠gIn`，但我们调用的是`Pluralize`方法：
- en: '[PRE89]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Finally, we need to add code to the Plugin.Host’s `Main` method to load and
    run the Pluralizer plug-in:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在Plugin.Host的`Main`方法中添加代码来加载和运行Pluralizer插件：
- en: '[PRE90]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The output will now be like this:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 输出现在将是这样的：
- en: '[PRE91]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'To fully see what’s going on, change the `UseCollectibleContexts` constant
    to false and add the following code to the `Main` method to enumerate the ALCs
    and their assemblies:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全了解发生了什么，请将`UseCollectibleContexts`常量更改为false，并将以下代码添加到`Main`方法以枚举ALC及其程序集：
- en: '[PRE92]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'In the output, you can see two different versions of Humanizer, each loaded
    into its own ALC:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，你可以看到两个不同版本的Humanizer，每个加载到它自己的ALC中：
- en: '[PRE93]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Note
  id: totrans-565
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Even if both plug-ins were to use the same version of Humanizer, the isolation
    of separate assemblies can still be beneficial because each will have its own
    static variables.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 即使两个插件都使用相同版本的Humanizer，分离的程序集仍然有益，因为每个程序集都有自己的静态变量。
