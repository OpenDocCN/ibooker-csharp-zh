- en: Chapter 21\. Advanced Threading
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 21 章。高级线程
- en: We started [Chapter 14](ch14.html#concurrency_and_asynchron) with the basics
    of threading as a precursor to tasks and asynchrony. Specifically, we showed how
    to start and configure a thread, and covered essential concepts such as thread
    pooling, blocking, spinning, and synchronization contexts. We also introduced
    locking and thread safety, and demonstrated the simplest signaling construct,
    `ManualResetEvent`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从基础线程（作为任务和异步的前导）开始[第 14 章](ch14.html#concurrency_and_asynchron)。具体来说，我们展示了如何启动和配置线程，并涵盖了线程池、阻塞、自旋和同步上下文等关键概念。我们还介绍了锁定和线程安全，并演示了最简单的信号构件`ManualResetEvent`。
- en: 'This chapter picks up where [Chapter 14](ch14.html#concurrency_and_asynchron)
    left off on the topic of threading. In the first three sections, we flesh out
    synchronization, locking, and thread safety in greater detail. We then cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章继续[第 14 章](ch14.html#concurrency_and_asynchron)关于线程的话题。在前三节中，我们更详细地阐述了同步、锁定和线程安全。然后，我们涵盖了：
- en: Nonexclusive locking (`Semaphore` and reader/writer locks)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非独占锁定（`Semaphore`和读写锁）
- en: All signaling constructs (`AutoResetEvent`, `ManualResetEvent`, `Countdow⁠n​Event`,
    and `Barrier`)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有信号构件（`AutoResetEvent`、`ManualResetEvent`、`Countdow⁠n​Event`和`Barrier`）
- en: Lazy initialization (`Lazy<T>` and `LazyInitializer`)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惰性初始化（`Lazy<T>`和`LazyInitializer`）
- en: Thread-local storage (`ThreadStaticAttribute`, `ThreadLocal<T>`, and `GetData`/`SetData`)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程本地存储（`ThreadStaticAttribute`、`ThreadLocal<T>`和`GetData`/`SetData`）
- en: Timers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时器
- en: 'Threading is such a vast topic that we’ve put additional material online to
    complete the picture. Visit [*http://albahari.com/threading*](http://albahari.com/threading)
    for a discussion on the following, more arcane, topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是如此广泛的话题，我们在网上提供了额外的材料以完整展示整个情景。请访问[*http://albahari.com/threading*](http://albahari.com/threading)进行更深入的讨论，包括以下更深奥的主题：
- en: '`Monitor.Wait` and `Monitor.Pulse` for specialized signaling scenarios'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专用信号场景中使用`Monitor.Wait`和`Monitor.Pulse`
- en: Nonblocking synchronization techniques for micro-optimization (`Interlocked`,
    memory barriers, `volatile`)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于微优化的非阻塞同步技术（`Interlocked`、内存屏障、`volatile`）
- en: '`SpinLock` and `SpinWait` for high-concurrency scenarios'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高并发场景下的`SpinLock`和`SpinWait`
- en: Synchronization Overview
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步概述
- en: '*Synchronization* is the act of coordinating concurrent actions for a predictable
    outcome. Synchronization is particularly important when multiple threads access
    the same data; it’s surprisingly easy to run aground in this area.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*同步*是协调并发操作以实现可预测结果的行为。在多个线程访问同一数据时，同步尤为重要；在这个领域中轻易犯错。'
- en: The simplest and most useful synchronization tools are arguably the continuations
    and task combinators described in [Chapter 14](ch14.html#concurrency_and_asynchron).
    By formulating concurrent programs into asynchronous operations strung together
    with continuations and combinators, you lessen the need for locking and signaling.
    However, there are still times when the lower-level constructs come into play.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是最简单且最有用的同步工具，毫无疑问是[第 14 章](ch14.html#concurrency_and_asynchron)中描述的延续和任务组合器。通过将并发程序制定为异步操作，并用延续和组合器串联起来，您可以减少对锁定和信号的需求。然而，在某些时候，低级构件仍然会发挥作用。
- en: 'The synchronization constructs can be divided into three categories:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 同步构件可分为三类：
- en: Exclusive locking
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 独占锁定
- en: Exclusive locking constructs allow just one thread to perform some activity
    or execute a section of code at a time. Their primary purpose is to let threads
    access shared writing state without interfering with one another. The exclusive
    locking constructs are `lock`, `Mutex`, and `SpinLock`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 独占锁定允许仅有一个线程执行某些活动或一段代码。它们的主要目的是让线程在不互相干扰的情况下访问共享写入状态。独占锁定构件包括`lock`、`Mutex`和`SpinLock`。
- en: Nonexclusive locking
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 非独占锁定
- en: Nonexclusive locking lets you *limit* concurrency. The nonexclusive locking
    constructs are `Semaphore`(`Slim`) and `ReaderWriterLock`(`Slim`).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 非独占锁定允许*限制*并发性。非独占锁定构件包括`Semaphore`(`Slim`)和`ReaderWriterLock`(`Slim`)。
- en: Signaling
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 信号
- en: These allow a thread to block until receiving one or more notifications from
    other thread(s). The signaling constructs include `ManualResetEvent`(`Slim`),
    `AutoResetEvent`, `CountdownEvent`, and `Barrier`. The former three are referred
    to as *event wait handles*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些允许线程在接收来自其他线程的一个或多个通知之前阻塞。信号构件包括`ManualResetEvent`(`Slim`)、`AutoResetEvent`、`CountdownEvent`和`Barrier`。前三者被称为*事件等待句柄*。
- en: It’s also possible (and tricky) to perform certain concurrent operations on
    shared state without locking through the use of *nonblocking synchronization constructs*.
    These are `Thread.MemoryBarrier`, `Thread.VolatileRead`, `Thread.VolatileWrite`,
    the `volatile` keyword, and the `Interlocked` class. We [cover this topic online](http://albahari.com/threading),
    along with `Monitor`’s `Wait`/`Pulse` methods, which you can use to write custom
    signaling logic.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以（而且很棘手地）通过使用*非阻塞同步构造*在共享状态上执行某些并发操作。这些构造包括`Thread.MemoryBarrier`、`Thread.VolatileRead`、`Thread.VolatileWrite`、`volatile`关键字和`Interlocked`类。我们在[在线文档中介绍了这个主题](http://albahari.com/threading)，同时还介绍了`Monitor`的`Wait`/`Pulse`方法，您可以使用它们来编写自定义的信号逻辑。
- en: Exclusive Locking
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 独占锁定
- en: 'There are three exclusive locking constructs: the `lock` statement, `Mutex`,
    and `SpinLock`. The `lock` construct is the most convenient and widely used, whereas
    the other two target niche scenarios:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种独占锁定构造：`lock`语句、`Mutex`和`SpinLock`。`lock`语句是最方便和广泛使用的，而其他两种则针对特定的场景：
- en: '`Mutex` lets you span multiple processes (computer-wide locks).'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mutex`允许您跨多个进程进行跨计算机范围的锁定。'
- en: '`SpinLock` implements a micro-optimization that can lessen context switches
    in high-concurrency scenarios (see [*http://albahari.com/threading*](http://albahari.com/threading)).'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SpinLock`实现了一种微优化，可以减少高并发场景中的上下文切换（参见[*http://albahari.com/threading*](http://albahari.com/threading))。'
- en: The lock Statement
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`lock`语句'
- en: 'To illustrate the need for locking, consider the following class:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明锁定的必要性，考虑以下类：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This class is not thread-safe: if `Go` were called by two threads simultaneously,
    it would be possible to get a division-by-zero error because `_val2` could be
    set to zero in one thread right as the other thread was in between executing the
    `if` statement and `Console.WriteLine`. Here’s how `lock` fixes the problem:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类不是线程安全的：如果两个线程同时调用`Go`方法，可能会因为一个线程在另一个线程在执行`if`语句和`Console.WriteLine`之间将`_val2`设置为零时而导致除零错误。这里是`lock`如何解决这个问题的方式：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Only one thread can lock the synchronizing object (in this case, `_locker`)
    at a time, and any contending threads are blocked until the lock is released.
    If more than one thread contends the lock, they are queued on a “ready queue”
    and granted the lock on a first-come, first-served basis.^([1](ch21.html#ch01fn15))
    Exclusive locks are sometimes said to enforce *serialized* access to whatever’s
    protected by the lock because one thread’s access cannot overlap with that of
    another. In this case, we’re protecting the logic inside the `Go` method as well
    as the fields `_val1` and `_val2`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个线程可以一次锁定同步对象（在本例中为`_locker`），任何竞争线程都会被阻塞，直到锁被释放。如果有多个线程竞争锁，它们会排队在“准备队列”上，并按先到先服务的顺序获得锁。[^1]
    独占锁有时被认为是强制*串行化*访问被锁定的内容，因为一个线程的访问不能与另一个线程的访问重叠。在这种情况下，我们保护`Go`方法内部的逻辑以及字段`_val1`和`_val2`。
- en: Monitor.Enter and Monitor.Exit
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Monitor.Enter`和`Monitor.Exit`'
- en: 'C#’s `lock` statement is in fact a syntactic shortcut for a call to the methods
    `Monitor.Enter` and `Monitor.Exit`, with a `try`/`finally` block. Here’s (a simplified
    version of) what’s actually happening within the `Go` method of the preceding
    example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: C#的`lock`语句实际上是调用`Monitor.Enter`和`Monitor.Exit`方法，并带有`try`/`finally`块的语法快捷方式。这里是前面示例中`Go`方法中实际发生的（简化版）：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Calling `Monitor.Exit` without first calling `Monitor.Enter` on the same object
    throws an exception.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一对象上调用`Monitor.Exit`之前未调用`Monitor.Enter`会引发异常。
- en: The lockTaken overloads
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`lockTaken`的重载版本'
- en: 'The code that we just demonstrated has a subtle vulnerability. Consider the
    (unlikely) event of an exception being thrown between the call to `Monitor.Enter`
    and the `try` block (due, perhaps, to an `OutOfMemoryException` or, in .NET Framework,
    if the thread is aborted). In such a scenario, the lock might or might not be
    taken. If the lock *is* taken, it won’t be released—because we’ll never enter
    the `try`/`finally` block. This will result in a leaked lock. To avoid this danger,
    `Monitor.Enter` defines the following overload:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚演示的代码存在一个微妙的漏洞。考虑在调用`Monitor.Enter`和`try`块之间抛出异常的情况（可能是由于`OutOfMemoryException`或在.NET
    Framework中，线程被中止）。在这种情况下，锁可能会被获取，也可能不会被获取。如果锁*被*获取，它将不会被释放，因为我们永远不会进入`try`/`finally`块。这将导致锁泄漏。为了避免这种危险，`Monitor.Enter`定义了以下重载：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`lockTaken` is false after this method if (and only if) the `Enter` method
    throws an exception and the lock was not taken.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`lockTaken`如果（且仅当）`Enter`方法抛出异常且未获取锁时，其值为false。'
- en: 'Here’s the more robust pattern of use (which is exactly how C# translates a
    `lock` statement):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是更健壮的使用模式（这正是 C# 如何转换 `lock` 语句的方式）。
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: TryEnter
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TryEnter
- en: '`Monitor` also provides a `TryEnter` method that allows a timeout to be specified,
    either in milliseconds or as a `TimeSpan`. The method then returns `true` if a
    lock was obtained, or `false` if no lock was obtained because the method timed
    out. `TryEnter` can also be called with no argument, which “tests” the lock, timing
    out immediately if the lock can’t be obtained immediately. As with the `Enter`
    method, `TryEnter` is overloaded to accept a `lockTaken` argument.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Monitor` 还提供了一个 `TryEnter` 方法，允许指定超时时间，可以是毫秒或 `TimeSpan`。该方法如果获取到锁则返回 `true`，如果因超时而未获取到锁则返回
    `false`。`TryEnter` 还可以不带参数调用，如果无法立即获取锁则立即超时。与 `Enter` 方法一样，`TryEnter` 被重载以接受 `lockTaken`
    参数。'
- en: Choosing the Synchronization Object
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择同步对象
- en: 'You can use any object visible to each of the partaking threads as a synchronizing
    object, subject to one hard rule: it must be a reference type. The synchronizing
    object is typically private (because this helps to encapsulate the locking logic)
    and is typically an instance or static field. The synchronizing object can double
    as the object it’s protecting, as the `_list` field does in the following example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用任何每个参与线程都可见的对象作为同步对象，但有一个硬性规定：它必须是引用类型。同步对象通常是私有的（因为这有助于封装锁定逻辑），通常是实例或静态字段。同步对象可以兼作其保护的对象，就像下面的示例中的
    `_list` 字段一样。
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A field dedicated for the purpose of locking (such as `_locker`, in the example
    prior) allows precise control over the scope and granularity of the lock. You
    can also use the containing object (`this`) as a synchronization object:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 专门用于锁定目的的字段（例如前面示例中的 `_locker`）允许对锁的范围和粒度进行精确控制。您还可以使用包含对象 (`this`) 作为同步对象：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Or even its type:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 或者甚至它的类型：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The disadvantage of locking in this way is that you’re not encapsulating the
    locking logic, so it becomes more difficult to prevent deadlocking and excessive
    blocking.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式锁定的缺点是，您没有封装锁定逻辑，因此更难以防止死锁和过度阻塞。
- en: You can also lock on local variables captured by lambda expressions or anonymous
    methods.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以锁定 lambda 表达式或匿名方法捕获的局部变量。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Locking doesn’t restrict access to the synchronizing object itself in any way.
    In other words, `x.ToString()` will not block because another thread has called
    `lock(x)`; both threads must call `lock(x)` in order for blocking to occur.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定并不以任何方式限制对同步对象本身的访问。换句话说，`x.ToString()` 不会因为另一个线程调用了 `lock(x)` 而被阻塞；要发生阻塞，两个线程必须同时调用
    `lock(x)`。
- en: When to Lock
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时进行锁定
- en: 'As a basic rule, you need to lock around accessing *any writable shared field*.
    Even in the simplest case—an assignment operation on a single field—you must consider
    synchronization. In the following class, neither the `Increment` nor the `Assign`
    method is thread-safe:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 作为基本规则，您需要在访问*任何可写共享字段*时进行锁定。即使在最简单的情况下——对单个字段的赋值操作——您也必须考虑同步。在下面的类中，`Increment`
    和 `Assign` 方法都不是线程安全的：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here are thread-safe versions of `Increment` and `Assign`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `Increment` 和 `Assign` 的线程安全版本：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Without locks, two problems can arise:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有锁定，可能会出现两个问题：
- en: Operations such as incrementing a variable (or even reading/writing a variable,
    under certain conditions) are not atomic.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作，如递增变量（或者在某些条件下甚至读取/写入变量），不是原子的。
- en: The compiler, CLR, and processor are entitled to reorder instructions and cache
    variables in CPU registers to improve performance—as long as such optimizations
    don’t change the behavior of a *single*-threaded program (or a multithreaded program
    that uses locks).
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器、CLR 和处理器有权重新排序指令和缓存 CPU 寄存器中的变量以提高性能——只要这些优化不会改变单线程程序（或使用锁的多线程程序）的行为。
- en: Locking mitigates the second problem because it creates a *memory barrier* before
    and after the lock. A memory barrier is a “fence” through which the effects of
    reordering and caching cannot penetrate.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定可以缓解第二个问题，因为它在锁定之前和之后创建了一个*内存屏障*。内存屏障是一个“栅栏”，通过它，重新排序和缓存的效果无法穿透。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'This applies not just to locks but to all synchronization constructs. So, if
    your use of a *signaling* construct, for instance, ensures that just one thread
    reads/writes a variable at a time, you don’t need to lock. Hence, the following
    code is thread-safe without locking around `x`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅适用于锁定，还适用于所有同步构造。因此，如果您使用*信号*构造确保只有一个线程在任一时间读取/写入变量，您无需锁定。因此，以下代码在围绕`x`加锁的情况下是线程安全的：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In [“Nonblocking Synchronization”](http://albahari.com/threading), we explain
    how this need arises and how the memory barriers and the `Interlocked` class can
    provide alternatives to locking in these situations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“非阻塞同步”](http://albahari.com/threading)一章中，我们解释了这种需求的起因以及内存屏障和`Interlocked`类在这些情况下提供的锁定替代方案。
- en: Locking and Atomicity
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锁定与原子性
- en: 'If a group of variables are always read and written within the same lock, you
    can say that the variables are read and written *atomically*. Let’s suppose that
    fields `x` and `y` are always read and assigned within a `lock` on object `locker`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一组变量总是在相同的锁定内读取和写入，您可以说这些变量被读取和写入*原子化*。假设字段 `x` 和 `y` 总是在对象 `locker` 上的 `lock`
    内读取和赋值：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can say that `x` and `y` are accessed atomically because the code block cannot
    be divided or preempted by the actions of another thread in such a way that it
    will change `x` or `y` and *invalidate its outcome*. You’ll never get a division-by-zero
    error, provided that `x` and `y` are always accessed within this same exclusive
    lock.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说 `x` 和 `y` 由于代码块无法在另一个线程的操作中被分割或抢占，因此它们是原子访问的，这将改变 `x` 或 `y` 并*使其失效*的结果。只要在相同的独占锁内始终访问
    `x` 和 `y`，您永远不会遇到除以零的错误。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The atomicity provided by a lock is violated if an exception is thrown within
    a `lock` block (whether or not multithreading is involved). For example, consider
    the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`lock`块内抛出异常（无论是否涉及多线程），锁提供的原子性将被破坏。例如，请考虑以下情况：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If an exception were thrown by `GetBankFee()`, the bank would lose money. In
    this case, we could avoid the problem by calling `GetBankFee` earlier. A solution
    for more complex cases is to implement “rollback” logic within a `catch` or `finally`
    block.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`GetBankFee()`抛出异常，银行将会损失资金。在这种情况下，我们可以通过早期调用`GetBankFee`来避免问题。在更复杂的情况下，可以在`catch`或`finally`块中实现“回滚”逻辑。
- en: '*Instruction* atomicity is a different, albeit analogous, concept: an instruction
    is atomic if it executes indivisibly on the underlying processor.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*指令*的原子性是一个不同但类似的概念：如果指令在底层处理器上以不可分割的方式执行，则该指令是原子的。'
- en: Nested Locking
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套锁定
- en: 'A thread can repeatedly lock the same object in a nested (*reentrant*) fashion:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 线程可以以嵌套（*可重入*）方式重复锁定同一对象：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Alternatively:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In these scenarios, the object is unlocked only when the outermost `lock` statement
    has exited—or a matching number of `Monitor.Exit` statements have executed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些场景中，对象只有在最外层的`lock`语句退出时——或者执行了匹配数量的`Monitor.Exit`语句后——才解锁。
- en: 'Nested locking is useful when one method calls another from within a lock:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法在锁定内调用另一个方法时，嵌套锁定非常有用：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A thread can block on only the first (outermost) lock.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一个线程只能在第一个（最外层）锁上阻塞。
- en: Deadlocks
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 死锁
- en: 'A deadlock happens when two threads each wait for a resource held by the other,
    so neither can proceed. The easiest way to illustrate this is with two locks:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个线程分别等待另一个持有的资源时，就会发生死锁，因此两者都无法继续进行。最简单的方法是使用两个锁来说明这一点：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can create more elaborate deadlocking chains with three or more threads.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用三个或更多线程创建更复杂的死锁链。
- en: Note
  id: totrans-91
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The CLR, in a standard hosting environment, is not like SQL Server and does
    not automatically detect and resolve deadlocks by terminating one of the offenders.
    A threading deadlock causes participating threads to block indefinitely, unless
    you’ve specified a locking timeout. (Under the SQL CLR integration host, however,
    deadlocks *are* automatically detected, and a [catchable] exception is thrown
    on one of the threads.)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准托管环境中，CLR 不像 SQL Server 那样自动检测和解决死锁问题，它会无限期地阻塞参与的线程，除非您已指定锁定超时。（然而，在 SQL
    CLR 集成主机中，死锁*会*自动检测，并在其中一个线程上抛出一个[可捕获的]异常。）
- en: Deadlocking is one of the most difficult problems in multithreading—especially
    when there are many interrelated objects. Fundamentally, the hard problem is that
    you can’t be sure what locks your *caller* has taken out.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程中，死锁是最困难的问题之一——特别是当存在许多相互关联的对象时。从根本上说，难题在于您无法确定*调用者*已经获取了哪些锁。
- en: So, you might lock private field `a` within your class `x`, unaware that your
    caller (or caller’s caller) has already locked field `b` within class `y`. Meanwhile,
    another thread is doing the reverse—creating a deadlock. Ironically, the problem
    is exacerbated by (good) object-oriented design patterns, because such patterns
    create call chains that are not determined until runtime.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可能会在类 `x` 内锁定私有字段 `a`，而不知道你的调用者（或调用者的调用者）已经在类 `y` 中锁定了字段 `b`。与此同时，另一个线程在做相反的事情——造成死锁。具有讽刺意味的是，这个问题被（好的）面向对象设计模式加剧了，因为这些模式创建的调用链直到运行时才确定。
- en: The popular advice “lock objects in a consistent order to prevent deadlocks,”
    although helpful in our initial example, is difficult to apply to the scenario
    just described. A better strategy is to be wary of locking around calls to methods
    in objects that might have references back to your own object. Also, consider
    whether you really need to lock around calls to methods in other classes (often
    you do—as you’ll see in [“Locking and Thread Safety”](#locking_and_thread_safet)—but
    sometimes there are other options). Relying more on higher-level synchronization
    options such as task continuations/combinators, data parallelism and immutable
    types (later in this chapter) can lessen the need for locking.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的建议“按一致的顺序锁定对象以防止死锁”，虽然在我们的初始示例中很有帮助，但很难应用到刚才描述的场景中。一个更好的策略是小心在调用可能会引用回你自己对象的对象方法时进行锁定。此外，考虑一下是否真的需要在调用其他类方法时进行锁定（通常是需要的——正如你将在[“锁定和线程安全”](#locking_and_thread_safet)中看到的——但有时也有其他选择）。更多依赖于高级别同步选项，如任务延续/组合器、数据并行和不可变类型（本章后面会介绍）可以减少对锁定的需求。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Here is an alternative way to perceive the problem: when you call out to other
    code while holding a lock, the encapsulation of that lock subtly *leaks*. This
    is not a fault in the CLR; it’s a fundamental limitation of locking in general.
    The problems of locking are being addressed in various research projects, including
    *Software Transactional Memory*.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一种理解问题的方式：当你在持有锁的同时调用其他代码时，该锁的封装会微妙地*泄漏*。这不是CLR的错误；这是锁定在一般情况下的一个根本限制。锁定问题正在被各种研究项目解决，包括*软件事务内存*。
- en: Another deadlocking scenario arises when calling `Dispatcher.Invoke` (in a WPF
    application) or `Control.Invoke` (in a Windows Forms application) while in possession
    of a lock. If the user interface happens to be running another method that’s waiting
    on the same lock, a deadlock will happen right there. You often can fix this simply
    by calling `BeginInvoke` instead of `Invoke` (or relying on asynchronous functions
    that do this implicitly when a synchronization context is present). Alternatively,
    you can release your lock before calling `Invoke`, although this won’t work if
    your *caller* took out the lock.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个死锁场景是在拥有锁时调用 `Dispatcher.Invoke`（在 WPF 应用程序中）或 `Control.Invoke`（在 Windows
    Forms 应用程序中）。如果用户界面碰巧正在运行另一个等待同一锁的方法，死锁将会发生。你通常可以通过简单地调用 `BeginInvoke` 而不是 `Invoke`（或者依赖于存在同步上下文时自动执行此操作的异步函数）来修复这个问题。或者，在调用
    `Invoke` 之前释放你的锁，尽管如果你的*调用者*获取了锁，则这种方法不起作用。
- en: Performance
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: 'Locking is fast: you can expect to acquire and release a lock in less than
    20 nanoseconds on a 2020-era computer if the lock is uncontended. If it is contended,
    the consequential context switch moves the overhead closer to the microsecond
    region, although it can be longer before the thread is actually rescheduled.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定速度很快：在2020年代的计算机上，如果锁没有争用，你可以期望在不到20纳秒内获取和释放一个锁。如果有争用，随之而来的上下文切换将使开销接近微秒区域，尽管在线程实际重新调度之前可能会更长。
- en: Mutex
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 互斥体
- en: A `Mutex` is like a C# `lock`, but it can work across multiple processes. In
    other words, `Mutex` can be *computer-wide* as well as *application-wide*. Acquiring
    and releasing an uncontended `Mutex` takes around half a microsecond—more than
    20 times slower than a `lock`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mutex` 就像是 C# 中的 `lock`，但可以跨多个进程工作。换句话说，`Mutex` 可以是*全局*的，也可以是*应用程序*级的。获取和释放一个没有争用的
    `Mutex` 大约需要半微秒，比 `lock` 慢20倍。'
- en: With a `Mutex` class, you call the `WaitOne` method to lock and `ReleaseMutex`
    to unlock. Just as with the `lock` statement, a `Mutex` can be released only from
    the same thread that obtained it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Mutex` 类，你调用 `WaitOne` 方法来锁定，`ReleaseMutex` 来解锁。与 `lock` 语句一样，只能从获取它的同一线程中释放
    `Mutex`。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you forget to call `ReleaseMutex` and simply call `Close` or `Dispose`, an
    `AbandonedMutexException` will be thrown upon anyone else waiting upon that mutex.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果忘记调用`ReleaseMutex`，而只是调用`Close`或`Dispose`，其他等待该互斥体的人会抛出`AbandonedMutexException`异常。
- en: 'A common use for a cross-process `Mutex` is to ensure that only one instance
    of a program can run at a time. Here’s how it’s done:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 跨进程使用的`Mutex`的常见用途是确保程序一次只能运行一个实例。以下是实现方式：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-108
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re running under Terminal Services or in separate Unix consoles, a computer-wide
    `Mutex` is ordinarily visible only to applications in the same session. To make
    it visible to all terminal server sessions, prefix its name with *Global\*, as
    shown in the example.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在终端服务或单独的Unix控制台下运行，计算机范围的`Mutex`通常只对同一会话中的应用程序可见。要使其对所有终端服务器会话可见，请在名称前加上*Global\*，如示例中所示。
- en: Locking and Thread Safety
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加锁与线程安全
- en: A program or method is thread-safe if it can work correctly in any multithreading
    scenario. Thread safety is achieved primarily with locking and by reducing the
    possibilities for thread interaction.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序或方法能够在任何多线程场景下正确工作，则它是线程安全的。通过加锁和减少线程交互的可能性来实现线程安全。
- en: 'General-purpose types are rarely thread-safe in their entirety, for the following
    reasons:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一般用途的类型完全不会是线程安全的，原因如下：
- en: The development burden in full thread safety can be significant, particularly
    if a type has many fields (each field is a potential for interaction in an arbitrarily
    multithreaded context).
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在完全实现线程安全时的开发负担可能很大，特别是如果一个类型有很多字段（每个字段都是在任意多线程环境中进行交互的潜在因素）。
- en: Thread safety can entail a performance cost (payable, in part, whether or not
    the type is actually used by multiple threads).
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程安全可能会带来性能开销（部分是由于类型是否真正被多线程使用而产生的）。
- en: A thread-safe type does not necessarily make the program using it thread-safe,
    and often the work involved in the latter makes the former redundant.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程安全的类型并不一定能使使用它的程序线程安全，而通常后者所涉及的工作会使前者变得多余。
- en: Thread safety is thus usually implemented just where it needs to be in order
    to handle a specific multithreading scenario.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，线程安全通常只在需要处理特定多线程场景时实现。
- en: There are, however, a few ways to “cheat” and have large and complex classes
    run safely in a multithreaded environment. One is to sacrifice granularity by
    wrapping large sections of code—even access to an entire object—within a single
    exclusive lock, enforcing serialized access at a high level. This tactic is, in
    fact, essential if you want to use thread-unsafe third-party code (or most .NET
    types, for that matter) in a multithreaded context. The trick is simply to use
    the same exclusive lock to protect access to all properties, methods, and fields
    on the thread-unsafe object. The solution works well if the object’s methods all
    execute quickly (otherwise, there will be a lot of blocking).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在多线程环境中运行大型和复杂类的几种“作弊”方法。其中一种方法是通过包装大段代码（甚至整个对象的访问）在单个独占锁中执行，强制高级别的序列化访问。事实上，如果你想在多线程环境中使用线程不安全的第三方代码（或大多数.NET类型），这种策略是必不可少的。关键是简单地使用相同的独占锁来保护对线程不安全对象的所有属性、方法和字段的访问。如果对象的方法都执行得很快，这种解决方案效果很好（否则将会有很多阻塞发生）。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Primitive types aside, few .NET types, when instantiated, are thread-safe for
    anything more than concurrent read-only access. The onus is on the developer to
    superimpose thread safety, typically with exclusive locks. (The collections in
    `System.Collections.Concurrent` that we cover in [Chapter 22](ch22.html#parallel_programming-id00071)
    are an exception.)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本类型之外，很少有.NET类型在实例化时对于任何更多于并发只读访问是线程安全的。开发者需要通过独占锁来实现线程安全（我们在[第22章](ch22.html#parallel_programming-id00071)中介绍的`System.Collections.Concurrent`集合是一个例外）。
- en: Another way to cheat is to minimize thread interaction by minimizing shared
    data. This is an excellent approach and is used implicitly in “stateless” middle-tier
    application and web-page servers. Because multiple client requests can arrive
    simultaneously, the server methods they call must be thread-safe. A stateless
    design (popular for reasons of scalability) intrinsically limits the possibility
    of interaction because classes do not save data between requests. Thread interaction
    is then limited just to the static fields that you might choose to create, for
    such purposes as caching commonly used data in memory and in providing infrastructure
    services such as authentication and auditing.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种欺骗的方法是通过最小化线程交互来最小化共享数据。这是一种极好的方法，隐式地在“无状态”中间层应用程序和网页服务器中使用。因为多个客户端请求可能同时到达，所以它们调用的服务器方法必须是线程安全的。无状态设计（由于可伸缩性原因而受欢迎）本质上限制了交互的可能性，因为类在请求之间不保存数据。然后，线程交互仅限于您可能选择创建的静态字段，用于在内存中缓存常用数据并提供诸如身份验证和审计等基础设施服务。
- en: Yet another solution (in rich-client applications) is to run code that accesses
    shared state on the UI thread. As we saw in [Chapter 14](ch14.html#concurrency_and_asynchron),
    asynchronous functions make this easy.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案（在富客户端应用程序中）是在UI线程上运行访问共享状态的代码。正如我们在[第14章](ch14.html#concurrency_and_asynchron)中看到的那样，异步函数使这变得容易。
- en: Thread Safety and .NET Types
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全和.NET类型
- en: 'You can use locking to convert thread-unsafe code into thread-safe code. A
    good application of this is .NET: nearly all of its nonprimitive types are not
    thread-safe (for anything more than read-only access) when instantiated, and yet
    you can use them in multithreaded code if all access to any given object is protected
    via a lock. Here’s an example in which two threads simultaneously add an item
    to the same `List` collection and then enumerate the list:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用锁定将线程不安全的代码转换为线程安全的代码。一个很好的应用是.NET：几乎所有非原始类型在实例化时都不是线程安全的（超过只读访问），但是如果所有对任何给定对象的访问都通过锁保护，则可以在多线程代码中使用它们。以下是一个例子，在该例子中，两个线程同时向相同的`List`集合添加项目，然后枚举该列表：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this case, we’re locking on the `_list` object itself. If we had two interrelated
    lists, we would need to choose a common object upon which to lock (we could nominate
    one of the lists, or better: use an independent field).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在对`_list`对象本身进行锁定。如果我们有两个相互关联的列表，我们将需要选择一个公共对象进行锁定（我们可以提名其中一个列表，或者更好的是使用独立字段）。
- en: Enumerating .NET collections is also thread-unsafe in the sense that an exception
    is thrown if the list is modified during enumeration. Rather than locking for
    the duration of enumeration, in this example, we first copy the items to an array.
    This avoids holding the lock excessively if what we’re doing during enumeration
    is potentially time-consuming. (Another solution is to use a reader/writer lock;
    see [“Reader/Writer Locks”](#readersoliduswriter_locks).)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举.NET集合在某种意义上也是线程不安全的，如果在枚举过程中修改列表，则会抛出异常。在枚举期间而不是持续锁定，例如，在此示例中，我们首先将项目复制到数组中。如果我们在枚举期间执行的操作可能耗时较长，则避免过多保持锁定。
    （另一个解决方案是使用读写锁；请参见[“读写锁”](#readersoliduswriter_locks)。）
- en: Locking around thread-safe objects
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在围绕线程安全对象进行锁定时
- en: 'Sometimes, you also need to lock around accessing thread-safe objects. To illustrate,
    imagine that .NET’s `List` class was, indeed, thread-safe, and we want to add
    an item to a list:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您还需要在访问线程安全对象时进行锁定。为了说明这一点，想象一下.NET的`List`类确实是线程安全的，并且我们想要向列表添加一个项目：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Regardless of whether the list was thread-safe, this statement is certainly
    not! The whole `if` statement would need to be wrapped in a lock to prevent preemption
    in between testing for containership and adding the new item. This same lock would
    then need to be used everywhere we modified that list. For instance, the following
    statement would also need to be wrapped in the identical lock to ensure that it
    did not preempt the former statement:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 无论列表是否线程安全，这个语句肯定不是！整个`if`语句都需要包装在锁中，以防止在测试容器和添加新项目之间被抢占。然后，同一把锁将需要在修改列表的任何地方使用。例如，以下语句也需要包装在相同的锁中，以确保它不会抢占前一个语句：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In other words, we would need to lock exactly as with our thread-unsafe collection
    classes (making the `List` class’s hypothetical thread safety redundant).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们需要像我们的线程不安全集合类一样进行锁定（使`List`类的假设线程安全性变得多余）。
- en: Note
  id: totrans-133
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Locking around accessing a collection can cause excessive blocking in highly
    concurrent environments. To this end, .NET provides a thread-safe queue, stack,
    and dictionary, which we discuss in [Chapter 22](ch22.html#parallel_programming-id00071).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问集合时进行锁定可能会在高度并发的环境中导致过多的阻塞。为此，.NET 提供了线程安全的队列、栈和字典，我们在[第22章](ch22.html#parallel_programming-id00071)中讨论过。
- en: Static members
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态成员
- en: Wrapping access to an object around a custom lock works only if all concurrent
    threads are aware of—and use—the lock. This might not be the case if the object
    is widely scoped. The worst case is with static members in a public type. For
    instance, imagine if the static property on the `DateTime` struct, `DateTime.Now`,
    was not thread-safe and that two concurrent calls could result in garbled output
    or an exception. The only way to remedy this with external locking might be to
    lock the type itself—`lock(typeof(DateTime))`—before calling `DateTime.Now`. This
    would work only if all programmers agreed to do this (which is unlikely). Furthermore,
    locking a type creates problems of its own.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在自定义锁周围包装对象的访问仅在所有并发线程都知道并使用该锁时才有效。如果对象的范围广泛，这可能不是情况。最糟糕的情况是公共类型中的静态成员。例如，想象一下如果`DateTime`
    结构上的静态属性 `DateTime.Now` 不是线程安全的，并且两个并发调用可能导致混乱的输出或异常。唯一修复此问题的外部锁可能是在调用 `DateTime.Now`
    之前锁定类型本身 — `lock(typeof(DateTime))`。只有当所有程序员同意执行此操作时才会起作用（这是不太可能的）。此外，在锁定类型本身时会创建自身的问题。
- en: 'For this reason, static members on the `DateTime` struct have been carefully
    programmed to be thread-safe. This is a common pattern throughout .NET: *static
    members are thread-safe; instance members are not.* Following this pattern also
    makes sense when writing types for public consumption, so as not to create impossible
    thread-safety conundrums. In other words, by making static methods thread-safe,
    you’re programming so as not to *preclude* thread safety for consumers of that
    type.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，`DateTime` 结构上的静态成员被精心设计为线程安全。这是.NET中的一个常见模式：*静态成员是线程安全的；实例成员则不是。* 遵循这个模式在为公共使用编写类型时也是有意义的，以免造成不可能的线程安全困境。换句话说，通过使静态方法线程安全，你在编程时不会*排除*那些类型的使用者的线程安全性。
- en: Note
  id: totrans-138
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Thread safety in static methods is something that you must explicitly code:
    it doesn’t happen automatically by virtue of the method being static!'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法中的线程安全性是你必须显式编码的内容：它不会因为方法是静态而自动发生！
- en: Read-only thread safety
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 只读线程安全性
- en: 'Making types thread-safe for concurrent read-only access (where possible) is
    advantageous because it means that consumers can avoid excessive locking. Many
    .NET types follow this principle: collections, for instance, are thread-safe for
    concurrent readers.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使类型对于并发只读访问（可能的情况下）是有利的，因为这意味着消费者可以避免过多的锁定。许多.NET类型遵循这一原则：例如，集合对于并发读取是线程安全的。
- en: 'Following this principle yourself is simple: if you document a type as being
    thread-safe for concurrent read-only access, don’t write to fields within methods
    that a consumer would expect to be read-only (or lock around doing so). For instance,
    in implementing a `ToArray()` method in a collection, you might begin by compacting
    the collection’s internal structure. However, this would make it thread-unsafe
    for consumers that expected this to be read-only.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这个原则本身很简单：如果你将一个类型标记为对于并发只读访问是线程安全的，请不要在消费者期望是只读的方法内写入字段（或在其周围进行锁定）。例如，在集合中实现
    `ToArray()` 方法时，你可能会首先压缩集合的内部结构。然而，这会使得消费者期望该方法是只读的时候线程不安全。
- en: 'Read-only thread safety is one of the reasons that enumerators are separate
    from “enumerables”: two threads can simultaneously enumerate over a collection
    because each gets a separate enumerator object.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 只读线程安全性是枚举器与“可枚举对象”分离的原因之一：两个线程可以同时枚举一个集合，因为每个线程都获得一个单独的枚举器对象。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'In the absence of documentation, it pays to be cautious in assuming whether
    a method is read-only in nature. A good example is the `Random` class: when you
    call `Random.Next()`, its internal implementation requires that it update private
    seed values. Therefore, you must either lock around using the `Random` class or
    maintain a separate instance per thread.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有文档的情况下，假设一个方法的性质是只读的是值得谨慎的。一个很好的例子是 `Random` 类：当你调用 `Random.Next()` 时，其内部实现需要更新私有种子值。因此，你必须要么在使用
    `Random` 类时进行锁定，要么为每个线程保持单独的实例。
- en: Thread Safety in Application Servers
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用服务器中的线程安全性
- en: Application servers need to be multithreaded to handle simultaneous client requests.
    ASP.NET Core and Web API applications are implicitly multithreaded. This means
    that when writing code on the server side, you must consider thread safety if
    there’s any possibility of interaction among the threads processing client requests.
    Fortunately, such a possibility is rare; a typical server class is either stateless
    (no fields) or has an activation model that creates a separate object instance
    for each client or each request. Interaction usually arises only through static
    fields, sometimes used for caching in memory parts of a database to improve performance.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 应用服务器需要是多线程的以处理同时的客户端请求。ASP.NET Core和Web API应用程序隐式地是多线程的。这意味着在服务器端编写代码时，如果可能有线程之间的交互，则必须考虑线程安全性。幸运的是，这种可能性很少；典型的服务器类要么是无状态的（没有字段），要么具有为每个客户端或每个请求创建单独对象实例的激活模型。交互通常仅通过静态字段产生，有时用于缓存数据库内存部分以提高性能。
- en: 'For example, suppose that you have a `RetrieveUser` method that queries a database:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您有一个`RetrieveUser`方法用于查询数据库：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If this method were called frequently, you could improve performance by caching
    the results in a static `Dictionary`. Here’s a conceptually simple solution that
    takes thread safety into account:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此方法经常被调用，可以通过将结果缓存到静态的`Dictionary`中来提高性能。以下是一个概念上简单的解决方案，考虑了线程安全性：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We must, at a minimum, lock around reading and updating the dictionary to ensure
    thread safety. In this example, we choose a practical compromise between simplicity
    and performance in locking. Our design creates a small potential for inefficiency:
    if two threads simultaneously called this method with the same previously unretrieved
    `id`, the `RetrieveUser` method would be called twice—and the dictionary would
    be updated unnecessarily. Locking once across the whole method would prevent this,
    but it would create a worse inefficiency: the entire cache would be locked up
    for the duration of calling `RetrieveUser`, during which time other threads would
    be blocked in retrieving *any* user.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 至少我们必须在读取和更新字典时进行锁定，以确保线程安全性。在这个例子中，我们在简单性和锁定性能之间选择了一个实际的折衷方案。我们的设计会造成小小的低效性：如果两个线程同时使用相同的先前未检索到的`id`调用此方法，`RetrieveUser`方法将被调用两次，字典将被不必要地更新。在整个方法内部进行一次锁定将防止这种情况发生，但会造成更糟糕的低效性：整个缓存在调用`RetrieveUser`期间将被锁定，期间其他线程将被阻塞在检索*任何*用户。
- en: 'For an ideal solution, we need to use the strategy we described in [“Completing
    synchronously”](ch14.html#completing_synchronously). Instead of caching `User`,
    we cache `Task<User>`, which the caller then awaits:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个理想的解决方案，我们需要使用我们在[“同步完成”](ch14.html#completing_synchronously)中描述的策略。我们不是缓存`User`，而是缓存`Task<User>`，然后调用者等待它：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice that we now have a single lock that covers the entire method’s logic.
    We can do this without hurting concurrency because all we’re doing inside the
    lock is accessing the dictionary and (potentially) *initiating* an asynchronous
    operation (by calling `Task.Run`). Should two threads call this method at the
    same time with the same ID, they’ll both end up awaiting the *same task*, which
    is exactly the outcome we want.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们现在有一个覆盖整个方法逻辑的单个锁。我们可以做到这一点而不影响并发性，因为在锁内部我们只是访问字典，并且（可能）*启动*一个异步操作（通过调用`Task.Run`）。如果两个线程同时使用相同的ID调用此方法，它们将都等待*相同的任务*，这正是我们想要的结果。
- en: Immutable Objects
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变对象
- en: An immutable object is one whose state cannot be altered—externally or internally.
    The fields in an immutable object are typically declared read-only and are fully
    initialized during construction.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变对象是一种状态不可更改的对象—无论是外部还是内部。不可变对象中的字段通常声明为只读，并在构造期间完全初始化。
- en: Immutability is a hallmark of functional programming—where instead of *mutating*
    an object, you create a new object with different properties. LINQ follows this
    paradigm. Immutability is also valuable in multithreading in that it avoids the
    problem of shared writable state—by eliminating (or minimizing) the writable.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性是函数式编程的标志，它不是*变异*对象，而是创建具有不同属性的新对象。LINQ遵循这一范式。在多线程环境中，不可变性也是有价值的，因为它避免了共享可写状态的问题，通过消除（或最小化）可写状态。
- en: 'One pattern is to use immutable objects to encapsulate a group of related fields,
    to minimize lock durations. To take a very simple example, suppose that we had
    two fields, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一种模式是使用不可变对象封装一组相关字段，以最小化锁定持续时间。举个非常简单的例子，假设我们有两个字段，如下所示：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now let’s assume that we want to read and write them atomically. Rather than
    locking around these fields, we could define the following immutable class:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们希望以原子方式读取和写入它们。与其在这些字段周围加锁不如定义以下不可变类：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then we could define a single field of that type, along with a locking object:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以定义一个该类型的单一字段，以及一个锁对象：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can now read and write values of that type without holding a lock for more
    than a single assignment:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在不超过单个赋值的情况下读取和写入该类型的值了：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To read the object, we first obtain a copy of the object reference (within
    a lock). Then, we can read its values without needing to hold onto the lock:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取对象，我们首先获取对象引用的副本（在锁内）。然后，我们可以读取其值而不需要保持锁定：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Nonexclusive Locking
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非排他锁定
- en: The nonexclusive locking constructs serve to *limit* concurrency. In this section,
    we cover semaphores and read/writer locks, and also illustrate how the `SemaphoreSlim`
    class can limit concurrency with asynchronous operations.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 非排他锁定构造用于*限制*并发。在本节中，我们介绍信号量和读/写锁，并演示了`SemaphoreSlim`类如何通过异步操作限制并发。
- en: Semaphore
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号量
- en: A semaphore is like a nightclub with a limited capacity, enforced by a bouncer.
    When the club is full, no more people can enter, and a queue builds up outside.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一个信号量就像一个有限容量的夜总会，由门卫强制执行。当夜总会满员时，不能再进入更多人，外面就会排起队伍。
- en: A semaphore’s *count* corresponds to the number of spaces in the nightclub.
    *Releasing* a semaphore *increases* the count; this typically happens when somebody
    leaves the club (corresponding to a resource being released), and also when the
    semaphore is initialized (to set its starting capacity). You can also call `Release`
    at any time to increase capacity.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量的*计数*对应于夜总会中的空位数。*释放*信号量*增加*计数；这通常发生在有人离开夜总会（对应于释放资源）或者初始化信号量时（设置其起始容量）。您也可以随时调用`Release`来增加容量。
- en: Waiting on a semaphore *decrements* the count, and typically occurs prior to
    a resource being obtained. Calling `Wait` on a semaphore whose current count is
    greater than `0` completes immediately.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在信号量上等待会*减少*计数，通常发生在获取资源之前。在信号量当前计数大于`0`时，调用`Wait`会立即完成。
- en: A semaphore can optionally have a maximum count that serves as a hard limit.
    Increasing the count beyond this limit throws an exception. When constructing
    a semaphore, you specify the initial count (starting capacity), and optionally,
    a maximum limit.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量可以选择性地有一个最大计数，作为硬限制。将计数增加到超过此限制会引发异常。在构造信号量时，您指定初始计数（起始容量），以及可选的最大限制。
- en: A semaphore with an initial count of one is similar to a `Mutex` or `lock`,
    except that the semaphore has no “owner”—it’s *thread agnostic*. Any thread can
    call `Release` on a `Semaphore`, whereas with `Mutex` and `lock`, only the thread
    that obtained the lock can release it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 初始计数为一的信号量类似于`Mutex`或`lock`，但信号量没有“所有者”——它是*线程不可知*的。任何线程都可以在信号量上调用`Release`，而在`Mutex`和`lock`中，只有获得锁的线程才能释放它。
- en: Note
  id: totrans-177
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are two functionally similar versions of this class: `Semaphore` and
    `SemaphoreSlim`. The latter has been optimized to meet the low-latency demands
    of parallel programming. It’s also useful in traditional multithreading because
    it lets you specify a cancellation token when waiting (see [“Cancellation”](ch14.html#cancellation)),
    and it exposes a `WaitAsync` method for asynchronous programming. You cannot use
    it, however, for interprocess signaling.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有两个功能上类似的版本：`Semaphore`和`SemaphoreSlim`。后者已经经过优化，以满足并行编程的低延迟需求。它在传统的多线程编程中也很有用，因为它允许在等待时指定取消令牌（见[“取消”](ch14.html#cancellation)），并且暴露了一个`WaitAsync`方法用于异步编程。但是，您不能用它来进行进程间信号传递。
- en: '`Semaphore` incurs about one microsecond in calling `WaitOne` and `Release`;
    `SemaphoreSlim` incurs about one-tenth of that.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`Semaphore`调用`WaitOne`和`Release`大约需要一微秒；`SemaphoreSlim`则大约需要十分之一微秒。'
- en: 'Semaphores can be useful in limiting concurrency—preventing too many threads
    from executing a particular piece of code at once. In the following example, five
    threads try to enter a nightclub that allows only three threads in at once:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量在限制并发方面非常有用——防止太多线程同时执行特定的代码片段。在以下示例中，五个线程试图进入一个一次只允许三个线程的夜总会：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It’s also legal to instantiate a semaphore with an initial count (capacity)
    of 0 and then call `Release` to increase its count. The following two semaphores
    are equivalent:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以合法地用初始计数（容量）为0来实例化一个信号量，然后调用`Release`来增加其计数。以下两个信号量是等价的：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: A `Semaphore`, if named, can span processes in the same way as a `Mutex` (named
    `Semaphore`s are available only on Windows, whereas named `Mutex` also work on
    Unix platforms).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`Semaphore`，如果命名，可以像`Mutex`一样跨进程工作（命名的`Semaphore`仅在Windows上可用，而命名的`Mutex`也适用于Unix平台）。
- en: Asynchronous semaphores and locks
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步信号量和锁
- en: 'It is illegal to lock across an `await` statement:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 跨越`await`语句进行锁定是非法的：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Doing so would make no sense, because locks are held by a thread, which typically
    changes when returning from an await. Locking also *blocks*, and blocking for
    a potentially long period of time is exactly what you’re *not* trying to achieve
    with asynchronous functions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是没有意义的，因为锁由一个线程持有，在从等待返回时通常会更改。锁定还会阻塞，并且阻塞可能很长时间，这正是您在异步函数中尝试*不*实现的。
- en: 'It’s still sometimes desirable, however, to make asynchronous operations execute
    sequentially—or limit the parallelism such that not more than *n* operations execute
    at once. For example, consider a web browser: it needs to perform asynchronous
    downloads in parallel, but it might want to impose a limit such that a maximum
    of 10 downloads happen at a time. We can achieve this by using a `SemaphoreSlim`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时仍然希望使异步操作按顺序执行——或者限制并行性，以便不超过*n*个操作同时执行。例如，考虑一个Web浏览器：它需要并行执行异步下载，但可能希望强加限制，最多同时进行10个下载。我们可以通过使用`SemaphoreSlim`来实现这一点：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Reducing the semaphore’s `initialCount` to `1` reduces the maximum parallelism
    to 1, turning this into an asynchronous lock.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 将信号量的`initialCount`减少到`1`会将最大并行性减少为1，将其转换为异步锁。
- en: Writing an EnterAsync extension method
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写一个EnterAsync扩展方法
- en: 'The following extension method simplifies the asynchronous use of `SemaphoreSlim`
    by using the `Disposable` class that we wrote in [“Anonymous Disposal”](ch12.html#anonymous_disposal):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下扩展方法通过使用我们在[“匿名处理”](ch12.html#anonymous_disposal)中编写的`Disposable`类简化了`SemaphoreSlim`的异步使用：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'With this method, we can rewrite our `DownloadWithSemaphoreAsync` method as
    follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这种方法，我们可以将我们的`DownloadWithSemaphoreAsync`方法重写如下：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Parallel.ForEachAsync
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Parallel.ForEachAsync
- en: 'From .NET 6, another approach to limit asynchronous concurrency is to use the
    `Parallel.ForEachAsync` method. Assuming `uris` in an array of URIs that you wish
    to download, here’s how to download them in parallel, while limiting the concurrency
    to a maximum of 10 parallel downloads:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 从.NET 6开始，另一种限制异步并发性的方法是使用`Parallel.ForEachAsync`方法。假设`uris`是您希望下载的URI数组，以下是如何并行下载它们，同时将并发性限制为最多10个并行下载：
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The other methods in the Parallel class are intended for (compute-bound) parallel
    programming scenarios, which we describe in [Chapter 22](ch22.html#parallel_programming-id00071).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Parallel类中的其他方法旨在（计算密集型）并行编程场景中使用，我们在[第22章](ch22.html#parallel_programming-id00071)中描述了这些场景。
- en: Reader/Writer Locks
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读者/写者锁
- en: Quite often, instances of a type are thread-safe for concurrent read operations,
    but not for concurrent updates (nor for a concurrent read and update). This can
    also be true with resources such as a file. Although protecting instances of such
    types with a simple exclusive lock for all modes of access usually does the trick,
    it can unreasonably restrict concurrency if there are many readers and just occasional
    updates. An example of where this could occur is in a business application server,
    for which commonly used data is cached for fast retrieval in static fields. The
    `ReaderWriterLockSlim` class is designed to provide maximum-availability locking
    in just this scenario.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，一个类型的实例对于并发读取操作是线程安全的，但对于并发更新（或并发读取和更新）是不安全的。这在像文件这样的资源上也可能是真实的。虽然使用简单的独占锁保护此类类型的实例通常可以达到预期的效果，但如果有许多读取者和偶尔的更新者，则可能会不合理地限制并发性。一个例子是在业务应用服务器中，常用数据被缓存以便在静态字段中快速检索。`ReaderWriterLockSlim`类专为在这种场景中提供最大可用性的锁定而设计。
- en: Note
  id: totrans-203
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`ReaderWriterLockSlim` is a replacement for the older “fat” `ReaderWriterLock`
    class. The latter is similar in functionality, but it is several times slower
    and has an inherent design fault in its mechanism for handling lock upgrades.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReaderWriterLockSlim`是旧的“fat”`ReaderWriterLock`类的替代品。后者在功能上类似，但速度慢几倍，并且在处理锁升级的机制上存在设计缺陷。'
- en: When compared to an ordinary `lock` (`Monitor.Enter`/`Exit`), `ReaderWriterLockSlim`
    is still twice as slow, though. The trade-off is less contention (when there’s
    a lot of reading and minimal writing).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通的`lock`（`Monitor.Enter`/`Exit`）相比，`ReaderWriterLockSlim`仍然慢两倍。权衡是更少的竞争（当有大量读取和最小的写入时）。
- en: 'With both classes, there are two basic kinds of lock—a read lock and a write
    lock:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两个类，有两种基本类型的锁——读锁和写锁：
- en: A write lock is universally exclusive.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写锁是互斥的。
- en: A read lock is compatible with other read locks.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读锁与其他读锁兼容。
- en: So, a thread holding a write lock blocks all other threads trying to obtain
    a read *or* write lock (and vice versa). But if no thread holds a write lock,
    any number of threads may concurrently obtain a read lock.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，持有写锁的线程会阻止所有试图获取读锁*或*写锁的其他线程（反之亦然）。但是，如果没有线程持有写锁，则任意数量的线程可以同时获取读锁。
- en: '`ReaderWriterLockSlim` defines the following methods for obtaining and releasing
    read/write locks:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReaderWriterLockSlim`定义了以下用于获取和释放读/写锁的方法：'
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Additionally, there are “Try” versions of all `Enter*XXX*` methods that accept
    timeout arguments in the style of `Monitor.TryEnter` (timeouts can occur quite
    easily if the resource is heavily contended). `ReaderWriterLock` provides similar
    methods, named `Acquire*XXX*` and `Release*XXX*`. These throw an `ApplicationException`
    if a timeout occurs, rather than returning `false`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有`Enter*XXX*`方法都有相应的“Try”版本，接受超时参数，类似于`Monitor.TryEnter`（如果资源争用严重，很容易出现超时）。
    `ReaderWriterLock`提供类似的方法，名为`Acquire*XXX*`和`Release*XXX*`。如果超时发生，这些方法会抛出`ApplicationException`，而不是返回`false`。
- en: 'The following program demonstrates `ReaderWriterLockSlim`. Three threads continually
    enumerate a list, while two further threads append a random number to the list
    every 100 ms. A read lock protects the list readers, and a write lock protects
    the list writers:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序演示了`ReaderWriterLockSlim`。三个线程不断枚举列表，而另外两个线程每100毫秒向列表追加一个随机数。读锁保护列表读取器，写锁保护列表写入器：
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-215
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In production code, you’d typically add `try`/`finally` blocks to ensure that
    locks were released if an exception were thrown.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产代码中，通常会添加`try`/`finally`块，以确保在抛出异常时释放锁。
- en: 'Here’s the result:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果：
- en: '[PRE38]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`ReaderWriterLockSlim` allows more concurrent `Read` activity than a simple
    lock. We can illustrate this by inserting the following line in the `Write` method,
    at the start of the `while` loop:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReaderWriterLockSlim`允许比简单锁更多的并发`Read`活动。我们可以通过在`Write`方法的`while`循环开始处插入以下行来说明这一点：'
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This nearly always prints “3 concurrent readers” (the `Read` methods spend
    most of their time inside the `foreach` loops). As well as `CurrentReadCount`,
    `ReaderWriterLockSlim` provides the following properties for monitoring locks:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎总是打印“3个并发读取器”（`Read`方法大部分时间在其`foreach`循环内）。除了`CurrentReadCount`，`ReaderWriterLockSlim`还提供了以下用于监视锁的属性：
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Upgradeable locks
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 升级锁
- en: 'Sometimes, it’s useful to swap a read lock for a write lock in a single atomic
    operation. For instance, suppose that you want to add an item to a list only if
    the item wasn’t already present. Ideally, you’d want to minimize the time spent
    holding the (exclusive) write lock, so you might proceed as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，将读锁替换为写锁在单个原子操作中是有用的。例如，假设您希望仅在列表中不存在该项时才将项添加到列表中。理想情况下，您希望尽量减少持有（独占）写锁的时间，因此可以按以下步骤进行：
- en: Obtain a read lock.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取读锁。
- en: Test whether the item is already present in the list; if so, release the lock
    and `return`.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试列表中是否已经存在该项；如果是，则释放锁并`return`。
- en: Release the read lock.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 释放读锁。
- en: Obtain a write lock.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取写锁。
- en: Add the item.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加该项。
- en: 'The problem is that another thread could sneak in and modify the list (e.g.,
    adding the same item) between Steps 3 and 4\. `ReaderWriterLockSlim` addresses
    this through a third kind of lock called an *upgradeable lock*. An upgradeable
    lock is like a read lock except that it can later be promoted to a write lock
    in an atomic operation. Here’s how you use it:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，在步骤3和步骤4之间，另一个线程可能会悄悄地修改列表（例如，添加相同的项）。 `ReaderWriterLockSlim`通过第三种称为*升级锁*的锁来解决这个问题。升级锁类似于读锁，但稍后可以以原子操作升级为写锁。以下是如何使用它的方法：
- en: Call `EnterUpgradeableReadLock`.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`EnterUpgradeableReadLock`。
- en: Perform read-based activities (e.g., test whether the item is already present
    in the list).
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行基于读的活动（例如，测试列表中是否已经存在该项）。
- en: Call `EnterWriteLock` (this converts the upgradeable lock to a write lock).
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`EnterWriteLock`（这将升级锁为写锁）。
- en: Perform write-based activities (e.g., add the item to the list).
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行基于写的活动（例如，将项添加到列表中）。
- en: Call `ExitWriteLock` (this converts the write lock back to an upgradeable lock).
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`ExitWriteLock`（这将写锁转换回升级锁）。
- en: Perform any other read-based activities.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行任何其他基于读取的活动。
- en: Call `ExitUpgradeableReadLock`.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`ExitUpgradeableReadLock`。
- en: From the caller’s perspective, it’s rather like nested or recursive locking.
    Functionally, though, in Step 3, `ReaderWriterLockSlim` releases your read lock
    and obtains a fresh write lock, atomically.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 从调用者的角度来看，这更像是嵌套或递归锁定。 但在功能上，在第3步中，`ReaderWriterLockSlim`释放您的读锁并原子性地获取一个新的写锁。
- en: 'There’s another important difference between upgradeable locks and read locks.
    Although an upgradeable lock can coexist with any number of *read* locks, only
    one upgradeable lock can itself be taken out at a time. This prevents conversion
    deadlocks by *serializing* competing conversions—just as update locks do in SQL
    Server:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 读锁和可升级锁之间还有一个重要的区别。 虽然可升级锁可以与任意数量的*读*锁共存，但每次只能获取一个可升级锁。 这通过*串行化*竞争转换来防止转换死锁，就像SQL
    Server中的更新锁一样：
- en: '| SQL Server | ReaderWriterLockSlim |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| SQL Server | ReaderWriterLockSlim |'
- en: '| --- | --- |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Share lock | Read lock |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 共享锁 | 读锁 |'
- en: '| Exclusive lock | Write lock |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 独占锁 | 写锁 |'
- en: '| Update lock | Upgradeable lock |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 更新锁 | 可升级锁 |'
- en: 'We can demonstrate an upgradeable lock by changing the `Write` method in the
    preceding example such that it adds a number to the list only if it’s not already
    present:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过更改前面示例中的`Write`方法来演示可升级锁，只有在列表中不存在时才添加一个数字：
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-247
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`ReaderWriterLock` can also do lock conversions—but unreliably because it doesn’t
    support the concept of upgradeable locks. This is why the designers of `ReaderWriterLockSlim`
    had to start afresh with a new class.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReaderWriterLock`也可以进行锁定转换，但不可靠，因为它不支持可升级锁的概念。 这就是为什么`ReaderWriterLockSlim`的设计者们不得不重新开始用一个新的类的原因。'
- en: Lock recursion
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 锁定递归
- en: 'Ordinarily, nested or recursive locking is prohibited with `ReaderWriterLockSlim`.
    Hence, the following throws an exception:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用`ReaderWriterLockSlim`禁止嵌套或递归锁定。 因此，以下操作会引发异常：
- en: '[PRE42]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'It runs without error, however, if you construct `ReaderWriterLockSlim` as
    follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您按以下方式构造`ReaderWriterLockSlim`，它将无错误运行：
- en: '[PRE43]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This ensures that recursive locking can happen only if you plan for it. Recursive
    locking can create undesired complexity because it’s possible to acquire more
    than one kind of lock:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保只有在计划中才能发生递归锁定。 递归锁定可能会产生不必要的复杂性，因为可能会获取多种类型的锁：
- en: '[PRE44]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The basic rule is that after you’ve acquired a lock, subsequent recursive locks
    can be less, but not greater, on the following scale:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 基本规则是，一旦你获得了一个锁，后续的递归锁可以按以下规模减少，但不能增加：
- en: Read Lock→Upgradeable Lock→Write Lock
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 读锁→可升级锁→写锁
- en: A request to promote an upgradeable lock to a write lock, however, is always
    legal.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请求将可升级锁升级为写锁总是合法的。
- en: Signaling with Event Wait Handles
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事件等待句柄进行信号传递
- en: 'The simplest kind of signaling constructs are called *event wait handles* (unrelated
    to C# events). Event wait handles come in three flavors: `AutoResetEvent`, `Manual​Re⁠setEvent`(`Slim`),
    and `CountdownEvent`. The former two are based on the common `EventWaitHandle`
    class from which they derive all their functionality.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的信号构造被称为*事件等待句柄*（与C#事件无关）。 事件等待句柄有三种类型：`AutoResetEvent`、`Manual​Re⁠setEvent`（`Slim`）和`CountdownEvent`。
    前两者基于常见的`EventWaitHandle`类，从中继承所有功能。
- en: AutoResetEvent
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AutoResetEvent
- en: 'An `AutoResetEvent` is like a ticket turnstile: inserting a ticket lets exactly
    one person through. The “auto” in the class’s name refers to the fact that an
    open turnstile automatically closes or “resets” after someone steps through. A
    thread waits, or blocks, at the turnstile by calling `WaitOne` (wait at this “one”
    turnstile until it opens), and a ticket is inserted by calling the `Set` method.
    If a number of threads call `WaitOne`, a queue^([2](ch21.html#ch01fn16)) builds
    up behind the turnstile. A ticket can come from any thread; in other words, any
    (unblocked) thread with access to the `AutoResetEvent` object can call `Set` on
    it to release one blocked thread.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`AutoResetEvent`类似于票证旋转门：插入一张票证允许一人通过。 类名中的“auto”指的是开放旋转门后自动关闭或“复位”的事实。 线程通过调用`WaitOne`（在这个“one”旋转门等待直到它打开）等待或阻塞在旋转门处，并通过调用`Set`方法插入票证。
    如果多个线程调用`WaitOne`，则在旋转门后面会形成一个队列^([2](ch21.html#ch01fn16))。 票证可以来自任何线程；换句话说，任何（未阻塞）有权访问`AutoResetEvent`对象的线程都可以在其上调用`Set`以释放一个被阻塞的线程。'
- en: 'You can create an `AutoResetEvent` in two ways. The first is via its constructor:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过两种方式创建`AutoResetEvent`。 第一种是通过其构造函数：
- en: '[PRE45]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '(Passing `true` into the constructor is equivalent to immediately calling `Set`
    upon it.) The second way to create an `AutoResetEvent` is as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: （在构造函数中传入`true`相当于立即调用`Set`。）创建`AutoResetEvent`的第二种方式如下：
- en: '[PRE46]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the following example, a thread is started whose job is simply to wait until
    signaled by another thread (see [Figure 21-1](#signaling_with_an_eventwaithandle)):'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，启动了一个线程，其工作是等待另一个线程的信号（参见[图21-1](#signaling_with_an_eventwaithandle)）：
- en: '[PRE47]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '![Signaling with an EventWaitHandle](assets/cn10_2101.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![使用EventWaitHandle进行信号](assets/cn10_2101.png)'
- en: Figure 21-1\. Signaling with an `EventWaitHandle`
  id: totrans-270
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图21-1\. 使用`EventWaitHandle`进行信号
- en: 'If `Set` is called when no thread is waiting, the handle stays open for as
    long as it takes until some thread calls `WaitOne`. This behavior helps prevent
    a race between a thread heading for the turnstile and a thread inserting a ticket
    (“Oops, inserted the ticket a microsecond too soon; now you’ll have to wait indefinitely!”).
    However, calling `Set` repeatedly on a turnstile at which no one is waiting doesn’t
    allow an entire party through when they arrive: only the next single person is
    let through, and the extra tickets are “wasted.”'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在没有线程等待时调用`Set`，则句柄保持打开状态，直到某个线程调用`WaitOne`。这种行为有助于防止一个线程走向旋转门，另一个线程插入票（“哎呀，票插得太早了，现在你将无限期地等待！”）。然而，在一个无人等待的旋转门上重复调用`Set`并不会在整个队伍到达时允许他们全部通过：只有下一个人可以通过，并且多余的票“被浪费”。
- en: Calling `Reset` on an `AutoResetEvent` closes the turnstile (should it be open)
    without waiting or blocking.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`Reset`关闭一个`AutoResetEvent`的旋转门（如果它是打开的），而不会等待或阻塞。
- en: '`WaitOne` accepts an optional timeout parameter, returning `false` if the wait
    ended because of a timeout rather than obtaining the signal.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`WaitOne`接受一个可选的超时参数，如果由于超时而结束等待，则返回`false`而不是获取信号。'
- en: Note
  id: totrans-274
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: Calling `WaitOne` with a timeout of `0` tests whether a wait handle is “open,”
    without blocking the caller. Keep in mind, though, that doing this resets the
    `AutoResetEvent` if it’s open.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用超时值`0`调用`WaitOne`可以测试等待句柄是否“打开”，而不会阻塞调用者。不过，请记住，如果已经打开，这样做会重置`AutoResetEvent`。
- en: Two-way signaling
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 双向信号
- en: Suppose that we want the main thread to signal a worker thread three times in
    a row. If the main thread simply calls `Set` on a wait handle several times in
    rapid succession, the second or third signal can become lost because the worker
    might take time to process each signal.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望主线程连续三次向工作线程发出信号。如果主线程快速连续调用等待句柄上的`Set`，则第二次或第三次信号可能会丢失，因为工作线程可能需要时间处理每个信号。
- en: 'The solution is for the main thread to wait until the worker’s ready before
    signaling it. We can do this by using another `AutoResetEvent`, as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是主线程在向其发出信号之前等待工作线程就绪。我们可以通过使用另一个`AutoResetEvent`来实现：
- en: '[PRE48]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[Figure 21-2](#two_way_signaling) shows this process.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '[图21-2](#two_way_signaling)展示了这个过程。'
- en: '![Two-way signaling](assets/cn10_2102.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![双向信号](assets/cn10_2102.png)'
- en: Figure 21-2\. Two-way signaling
  id: totrans-282
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图21-2\. 双向信号
- en: Here, we’re using a null message to indicate that the worker should end. With
    threads that run indefinitely, it’s important to have an exit strategy!
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用空消息来指示工作线程应该结束。对于运行无限期的线程，拥有退出策略是很重要的！
- en: ManualResetEvent
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ManualResetEvent
- en: As we described in [Chapter 14](ch14.html#concurrency_and_asynchron), a `ManualResetEvent`
    functions like a simple gate. Calling `Set` opens the gate, allowing *any* number
    of threads calling `WaitOne` to be let through. Calling `Reset` closes the gate.
    Threads that call `WaitOne` on a closed gate will block; when the gate is next
    opened, they will be released all at once. Apart from these differences, a `ManualResetEvent`
    functions like an `AutoResetEvent`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第14章](ch14.html#concurrency_and_asynchron)中描述的那样，`ManualResetEvent`的功能类似于一个简单的门闩。调用`Set`打开门闩，允许调用`WaitOne`的任意数量线程通过。调用`Reset`关闭门闩。调用`WaitOne`在关闭状态下的门闩会阻塞；下次打开门闩时，它们将一次性释放。除了这些差异，`ManualResetEvent`的功能与`AutoResetEvent`类似。
- en: 'As with `AutoResetEvent`, you can construct a `ManualResetEvent` in two ways:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 与`AutoResetEvent`一样，可以通过两种方式构造`ManualResetEvent`：
- en: '[PRE49]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note
  id: totrans-288
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: There’s another version of `ManualResetEvent` called `ManualResetEventSlim`.
    The latter is optimized for short waiting times—with the ability to opt into spinning
    for a set number of iterations. It also has a more efficient managed implementation
    and allows a `Wait` to be canceled via a `CancellationToken`. `ManualResetEventSlim`
    doesn’t subclass `WaitHandle`; however, it exposes a `WaitHandle` property that
    returns a `WaitHandle`-based object when called (with the performance profile
    of a traditional wait handle).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个称为`ManualResetEventSlim`的版本的`ManualResetEvent`。后者针对短等待时间进行了优化，具有可以选择自旋一定次数的能力。它还具有更有效的托管实现，并允许通过`CancellationToken`取消`Wait`。`ManualResetEventSlim`不继承自`WaitHandle`；但是，当调用时它公开一个`WaitHandle`属性，返回基于`WaitHandle`的对象（具有传统等待句柄的性能特征）。
- en: A `ManualResetEvent` is useful in allowing one thread to unblock many other
    threads. The reverse scenario is covered by `CountdownEvent`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`ManualResetEvent`在允许一个线程解除阻塞多个其他线程方面非常有用。相反的情况由`CountdownEvent`处理。'
- en: CountdownEvent
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CountdownEvent
- en: '`CountdownEvent` lets you wait on more than one thread. The class has an efficient,
    fully managed implementation. To use the class, instantiate it with the number
    of threads, or “counts,” that you want to wait on:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`CountdownEvent`允许您等待多个线程。该类具有高效的完全托管实现。要使用该类，请用您要等待的线程数或“计数”来实例化它：'
- en: '[PRE50]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Calling `Signal` decrements the “count”; calling `Wait` blocks until the count
    goes down to zero:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`Signal`减少“计数”；调用`Wait`阻塞直到计数减少为零：
- en: '[PRE51]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note
  id: totrans-296
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can sometimes more easily solve problems for which `CountdownEvent` is effective
    by using the *structured parallelism* constructs that we describe in [Chapter 22](ch22.html#parallel_programming-id00071)
    (PLINQ and the `Parallel` class).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您可以通过使用我们在[第22章](ch22.html#parallel_programming-id00071)中描述的*结构化并行*构造（如PLINQ和`Parallel`类）更轻松地解决适合`CountdownEvent`的问题。
- en: 'You can reincrement a `CountdownEvent`’s count by calling `AddCount`. However,
    if it has already reached zero, this throws an exception: you can’t “unsignal”
    a `CountdownEvent` by calling `AddCount`. To prevent the possibility of an exception
    being thrown, you can instead call `TryAddCount`, which returns `false` if the
    countdown is zero.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用`AddCount`重新增加`CountdownEvent`的计数。但是，如果它已经达到零，这将抛出异常：无法通过调用`AddCount`“取消”`CountdownEvent`。为防止抛出异常的可能性，您可以调用`TryAddCount`，如果倒计时为零，则返回`false`。
- en: 'To unsignal a countdown event, call `Reset`: this both unsignals the construct
    and resets its count to the original value.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 要取消标记一个倒计时事件，请调用`Reset`：这既取消了构造并将其计数重置为原始值。
- en: Like `ManualResetEventSlim`, `CountdownEvent` exposes a `WaitHandle` property
    for scenarios in which some other class or method expects an object based on `WaitHandle`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 像`ManualResetEventSlim`一样，`CountdownEvent`公开了一个`WaitHandle`属性，用于某些其他类或方法期望基于`WaitHandle`的对象的场景。
- en: Creating a Cross-Process EventWaitHandle
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建跨进程的EventWaitHandle
- en: '`EventWaitHandle`’s constructor allows a “named” `EventWaitHandle` to be created,
    capable of operating across multiple processes. The name is simply a string, and
    it can be any value that doesn’t unintentionally conflict with someone else’s!
    If the name is already in use on the computer, you get a reference to the same
    underlying `EventWaitHandle`; otherwise, the OS creates a new one. Here’s an example:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventWaitHandle`的构造函数允许创建一个“命名”的`EventWaitHandle`，能够跨多个进程进行操作。名称只是一个字符串，可以是任何不会意外与他人冲突的值！如果计算机上已经使用了该名称，则会得到对同一基础`EventWaitHandle`的引用；否则，操作系统会创建一个新的。以下是一个示例：'
- en: '[PRE52]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If two applications each ran this code, they would be able to signal each other:
    the wait handle would work across all threads in both processes.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个应用程序都运行此代码，则它们将能够互相发信号：等待句柄将跨所有线程在两个进程中运行。
- en: Named event wait handles are available only on Windows.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 命名事件等待句柄仅在Windows上可用。
- en: Wait Handles and Continuations
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等待句柄和继续
- en: 'Rather than waiting on a wait handle (and blocking your thread), you can attach
    a “continuation” to it by calling `ThreadPool.RegisterWaitForSingleObject`. This
    method accepts a delegate that is executed when a wait handle is signaled:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是等待等待句柄（并阻塞您的线程），您可以通过调用`ThreadPool.RegisterWaitForSingleObject`为其附加一个“继续”。此方法接受一个委托，在等待句柄被标记时执行：
- en: '[PRE53]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: When the wait handle is signaled (or a timeout elapses), the delegate runs on
    a pooled thread. You are then supposed to call `Unregister` to release the unmanaged
    handle to the callback.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 当等待句柄被标记（或超时时间到达）时，委托在一个池线程上运行。然后，您应该调用`Unregister`来释放到回调的非托管句柄。
- en: In addition to the wait handle and delegate, `RegisterWaitForSingleObject` accepts
    a “black box” object that it passes to your delegate method (rather like `ParameterizedThreadStart`)
    as well as a timeout in milliseconds (`-1` meaning no timeout) and a Boolean flag
    indicating whether the request is a one-off rather than recurring.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 除了等待句柄和委托之外，`RegisterWaitForSingleObject`还接受一个“黑匣子”对象，它将其传递给你的委托方法（类似于`ParameterizedThreadStart`），以及一个毫秒级超时（`-1`表示无超时）和一个布尔标志，指示请求是一次性而非定期的。
- en: Note
  id: totrans-311
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can reliably call `RegisterWaitForSingleObject` only once per wait handle.
    Calling this method again on the same wait handle causes an intermittent failure,
    whereby an unsignaled wait handle fires a callback as though it were signaled.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能可靠地对每个等待句柄调用一次`RegisterWaitForSingleObject`。在同一个等待句柄上再次调用此方法会导致间歇性失败，即使未信号化的等待句柄会像已信号化一样触发回调。
- en: This limitation makes (the nonslim) wait handles poorly suited to asynchronous
    programming.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 此限制使（非精简）等待句柄非常不适合异步编程。
- en: WaitAny, WaitAll, and SignalAndWait
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`WaitAll`、`WaitAny`和`SignalAndWait`'
- en: In addition to the `Set`, `WaitOne`, and `Reset` methods, there are static methods
    on the `WaitHandle` class to crack more complex synchronization nuts. The `WaitAny`,
    `WaitAll`, and `SignalAndWait` methods perform signaling and waiting operations
    on multiple handles. The wait handles can be of differing types (including `Mutex`
    and `Semaphore` given that these also derive from the abstract `WaitHandle` class).
    `ManualResetEventSlim` and `CountdownEvent` can also partake in these methods
    via their `WaitHandle` properties.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Set`、`WaitOne`和`Reset`方法之外，`WaitHandle`类上还有静态方法来解决更复杂的同步问题。`WaitAny`、`WaitAll`和`SignalAndWait`方法在多个句柄上执行信号和等待操作。等待句柄可以是不同类型的（包括`Mutex`和`Semaphore`，因为它们也从抽象的`WaitHandle`类派生）。通过它们的`WaitHandle`属性，`ManualResetEventSlim`和`CountdownEvent`也可以参与这些方法。
- en: Note
  id: totrans-316
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`WaitAll` and `SignalAndWait` have a weird connection to the legacy COM architecture:
    these methods require that the caller be in a multithreaded apartment, the model
    least suitable for interoperability. The main thread of a WPF or Windows Forms
    application, for example, is unable to interact with the clipboard in this mode.
    We discuss alternatives shortly.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`WaitAll`和`SignalAndWait`与传统的COM架构有一个奇怪的联系：这些方法要求调用者位于多线程公寓中，这种模型最不适合互操作性。例如，WPF或Windows
    Forms应用程序的主线程无法在此模式下与剪贴板交互。我们很快将讨论替代方法。'
- en: '`WaitHandle.WaitAny` waits for any one of an array of wait handles; `Wait​Han⁠dle.Wait​All`
    waits on all of the given handles, atomically. This means that if you wait on
    two `AutoResetEvents`:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`WaitHandle.WaitAny`在等待句柄数组中的任何一个句柄；`WaitHandle.WaitAll`原子地等待所有给定的句柄。这意味着如果你等待两个`AutoResetEvent`：'
- en: '`WaitAny` will never end up “latching” both events.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WaitAny`永远不会“锁住”两个事件。'
- en: '`WaitAll` will never end up “latching” only one event.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WaitAll`永远不会“锁住”仅一个事件。'
- en: '`SignalAndWait` calls `Set` on one `WaitHandle` and then calls `WaitOne` on
    another `WaitHandle`. After signaling the first handle, it will jump to the head
    of the queue in waiting on the second handle; this helps it succeed (although
    the operation is not truly atomic). You can think of this method as “swapping”
    one signal for another, and use it on a pair of `EventWaitHandle`s to set up two
    threads to rendezvous, or “meet,” at the same point in time. Either `AutoResetEvent`
    or `ManualResetEvent` will do the trick. The first thread executes the following:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`SignalAndWait`在一个`WaitHandle`上调用`Set`，然后在另一个`WaitHandle`上调用`WaitOne`。在信号第一个句柄后，它将立即排队等待第二个句柄；这有助于它成功（尽管操作并非真正原子）。你可以将这种方法看作是在一对`EventWaitHandle`上“交换”一个信号以设置两个线程在同一时间点“会合”或“汇合”。任一`AutoResetEvent`或`ManualResetEvent`都能完成任务。第一个线程执行以下操作：'
- en: '[PRE54]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The second thread does the opposite:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个线程执行相反操作：
- en: '[PRE55]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Alternatives to WaitAll and SignalAndWait
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替代方案替代`WaitAll`和`SignalAndWait`
- en: '`WaitAll` and `SignalAndWait` won’t run in a single-threaded apartment. Fortunately,
    there are alternatives. In the case of `SignalAndWait`, it’s rare that you need
    its queue-jumping semantics: in our rendezvous example, for instance, it would
    be valid simply to call `Set` on the first wait handle, and then `WaitOne` on
    the other, if wait handles were used solely for that rendezvous. In the following
    section, we explore yet another option for implementing a thread rendezvous.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`WaitAll` 和 `SignalAndWait` 不会在单线程公寓中运行。幸运的是，有替代方案。对于 `SignalAndWait`，很少需要其队列跳跃语义：例如，在我们的汇合示例中，如果仅仅是用等待句柄来实现，只需在第一个等待句柄上调用
    `Set`，然后在其他等待句柄上调用 `WaitOne` 就足够了。在下一节中，我们将探讨另一种实现线程汇合的选项。'
- en: In the case of `WaitAny` and `WaitAll`, if you don’t need atomicity, you can
    use the code we wrote in the previous section to convert the wait handles to tasks
    and then use `Task.WhenAny` and `Task.WhenAll` ([Chapter 14](ch14.html#concurrency_and_asynchron)).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `WaitAny` 和 `WaitAll`，如果不需要原子性，可以使用我们在前一节中编写的代码将等待句柄转换为任务，然后使用 `Task.WhenAny`
    和 `Task.WhenAll`（[第 14 章](ch14.html#concurrency_and_asynchron)）。
- en: If you need atomicity, you can take the lowest-level approach to signaling and
    write the logic yourself with `Monitor`’s `Wait` and `Pulse` methods. We describe
    `Wait` and `Pulse` in detail in [*http://albahari.com/threading*](http://albahari.com/threading).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要原子性，可以采用最低级别的信号处理方法，并使用 `Monitor` 的 `Wait` 和 `Pulse` 方法自行编写逻辑。我们在[*http://albahari.com/threading*](http://albahari.com/threading)中详细描述了
    `Wait` 和 `Pulse`。
- en: The Barrier Class
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Barrier 类
- en: The `Barrier` class implements a *thread execution barrier*, allowing many threads
    to rendezvous at a point in time (not to be confused with `Thread.MemoryBarrier`).
    The class is very fast and efficient, and is built upon `Wait`, `Pulse`, and spinlocks.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`Barrier` 类实现了*线程执行屏障*，允许多个线程在某个时间点汇合（与 `Thread.MemoryBarrier` 不要混淆）。该类非常快速高效，基于
    `Wait`、`Pulse` 和自旋锁实现。'
- en: 'To use this class:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此类：
- en: Instantiate it, specifying how many threads should partake in the rendezvous
    (you can change this later by calling `AddParticipants`/`RemoveParticipants`).
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化它时，指定应参与汇合的线程数（您可以随后调用 `AddParticipants`/`RemoveParticipants` 更改此值）。
- en: Have each thread call `SignalAndWait` when it wants to rendezvous.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个线程在希望汇合时都要调用 `SignalAndWait`。
- en: 'Instantiating `Barrier` with a value of `3` causes `SignalAndWait` to block
    until that method has been called three times. It then starts over: calling `SignalAndWait`
    again blocks until called another three times. This keeps each thread “in step”
    with every other thread.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 使用值为 `3` 实例化 `Barrier` 会导致 `SignalAndWait` 阻塞，直到该方法被调用三次。然后它重新开始：再次调用 `SignalAndWait`
    将阻塞，直到再次调用三次。这使得每个线程与其他线程“同步”。
- en: 'In the following example, each of three threads writes the numbers 0 through
    4 while keeping in step with the other threads:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，三个线程分别写入数字 0 到 4，并与其他线程保持同步：
- en: '[PRE56]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'A really useful feature of `Barrier` is that you can also specify a *post-phase
    action* when constructing it. This is a delegate that runs after `SignalAndWait`
    has been called *n* times, but *before* the threads are unblocked (as shown in
    the shaded area in [Figure 21-3](#barrier)). In our example, if we instantiate
    our barrier as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`Barrier` 的一个非常有用的特性是在构造时还可以指定*后阶段操作*。这是一个在调用 `SignalAndWait` *n* 次后、但线程解除阻塞之前运行的委托（如
    [图 21-3](#barrier) 中显示的阴影区域）。例如，如果我们按以下方式实例化我们的屏障：'
- en: '[PRE57]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'the output is this:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE58]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '![Barrier](assets/cn10_2103.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![Barrier](assets/cn10_2103.png)'
- en: Figure 21-3\. Barrier
  id: totrans-342
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 21-3\. 屏障
- en: A post-phase action can be useful for coalescing data from each of the worker
    threads. It doesn’t need to worry about preemption, because all workers are blocked
    while it does its thing.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 后阶段操作对于合并来自每个工作线程的数据非常有用。它不需要担心抢占，因为所有工作线程在其执行期间都会被阻塞。
- en: Lazy Initialization
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 惰性初始化
- en: 'A frequent problem in threading is how to lazily initialize a shared field
    in a thread-safe fashion. The need arises when you have a field of a type that’s
    expensive to construct:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 线程中常见的问题是如何以线程安全的方式惰性初始化共享字段。当需要构造成本高昂的类型字段时就会出现这种需求：
- en: '[PRE59]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The problem with this code is that instantiating `Foo` incurs the performance
    cost of instantiating `Expensive`—regardless of whether the `Expensive` field
    is ever accessed. The obvious answer is to construct the instance *on demand*:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的问题在于实例化 `Foo` 会导致实例化 `Expensive` 的性能成本，无论是否实际访问了 `Expensive` 字段。显而易见的答案是*按需*构造实例：
- en: '[PRE60]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The question then arises, is this thread-safe? Aside from the fact that we’re
    accessing `_expensive` outside a lock without a memory barrier, consider what
    would happen if two threads accessed this property at once. They could both satisfy
    the `if` statement’s predicate and each thread end up with a *different* instance
    of `Expensive`. Because this can lead to subtle errors, we would say, in general,
    that this code is not thread-safe.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 那么问题来了，这样做是否线程安全？除了我们在没有内存屏障的情况下在锁之外访问`_expensive`之外，考虑一下如果两个线程同时访问这个属性会发生什么。它们都可能满足`if`语句的谓词，每个线程最终都会得到一个*不同*的`Expensive`实例。因为这可能导致微妙的错误，我们通常会说，总的来说，这段代码是不线程安全的。
- en: 'The solution to the problem is to lock around checking and initializing the
    object:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 解决问题的方法是在检查和初始化对象周围加锁：
- en: '[PRE61]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Lazy<T>
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lazy<T>
- en: The `Lazy<T>` class is available to help with lazy initialization. If instantiated
    with an argument of `true`, it implements the thread-safe initialization pattern
    just described.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lazy<T>`类可用于帮助进行延迟初始化。如果使用`true`参数实例化它，它实现了刚刚描述的线程安全初始化模式。'
- en: Note
  id: totrans-354
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`Lazy<T>` actually implements a micro-optimized version of this pattern, called
    *double-checked locking*. Double-checked locking performs an additional volatile
    read to avoid the cost of obtaining a lock if the object is already initialized.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lazy<T>`实际上实现了这种模式的微优化版本，称为*双重检查锁定*。双重检查锁定执行额外的volatile读取，以避免在对象已初始化时获取锁的成本。'
- en: 'To use `Lazy<T>`, instantiate the class with a value factory delegate that
    tells it how to initialize a new value, and the argument `true`. Then, access
    its value via the `Value` property:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`Lazy<T>`，用告诉它如何初始化新值的值工厂委托实例化该类，并使用参数`true`。然后，通过`Value`属性访问其值：
- en: '[PRE62]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If you pass `false` into `Lazy<T>`’s constructor, it implements the thread-unsafe
    lazy initialization pattern that we described at the beginning of this section—this
    makes sense when you want to use `Lazy<T>` in a single-threaded context.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`false`传递给`Lazy<T>`的构造函数，它将实现我们在本节开头描述的线程不安全的延迟初始化模式——当您想在单线程上下文中使用`Lazy<T>`时，这是合理的。
- en: LazyInitializer
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LazyInitializer
- en: '`LazyInitializer` is a static class that works exactly like `Lazy<T>` except:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`LazyInitializer`是一个静态类，其工作方式与`Lazy<T>`完全相同，除了：'
- en: Its functionality is exposed through a static method that operates directly
    on a field in your own type. This prevents a level of indirection, improving performance
    in cases where you need extreme optimization.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的功能通过直接在自己类型的字段上操作的静态方法公开。这样可以避免一级间接，提高在需要极端优化的情况下的性能。
- en: It offers another mode of initialization in which multiple threads can race
    to initialize.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了另一种初始化模式，其中多个线程可以竞速初始化。
- en: 'To use `LazyInitializer`, call `EnsureInitialized` before accessing the field,
    passing a reference to the field and the factory delegate:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`LazyInitializer`，在访问字段之前调用`EnsureInitialized`，将字段的引用和工厂委托传递给它：
- en: '[PRE63]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You can also pass in another argument to request that competing threads *race*
    to initialize. This sounds similar to our original thread-unsafe example except
    that the first thread to finish always wins—and so you end up with only one instance.
    The advantage of this technique is that it’s even faster (on multicores) than
    double-checked locking because it can be implemented entirely without locks using
    advanced techniques that we describe in “Nonblocking Synchronization” and “Lazy
    Initialization” at [*http://albahari.com/threading*](http://albahari.com/threading).
    This is an extreme (and rarely needed) optimization that comes at a cost:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以传入另一个参数，请求竞争的线程*竞速*初始化。这听起来与我们原来的线程不安全的示例类似，不同之处在于第一个完成的线程总是获胜，因此最终只会得到一个实例。这种技术的优势在于，它甚至比双重检查锁定更快（在多核上），因为它可以完全不使用锁定，而是使用我们在“非阻塞同步”和“延迟初始化”中描述的先进技术。这是一种极端（而且很少需要的）优化，代价是：
- en: It’s slower when more threads race to initialize than you have cores.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当有更多的线程竞速初始化时，速度会变慢，超过了你的核心数。
- en: It potentially wastes CPU resources performing redundant initialization.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这可能会浪费CPU资源执行冗余的初始化。
- en: The initialization logic must be thread-safe (in this case, it would be thread-unsafe
    if `Expensive`’s constructor wrote to static fields, for instance).
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化逻辑必须是线程安全的（在这种情况下，如果`Expensive`的构造函数写入静态字段，它将是线程不安全的）。
- en: If the initializer instantiates an object requiring disposal, the “wasted” object
    won’t be disposed without additional logic.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果初始化器实例化一个需要处理的对象，没有额外逻辑的话，"浪费"的对象不会被处理。
- en: Thread-Local Storage
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程本地存储
- en: Much of this chapter has focused on synchronization constructs and the issues
    arising from having threads concurrently access the same data. Sometimes, however,
    you want to keep data isolated, ensuring that each thread has a separate copy.
    Local variables achieve exactly this, but they are useful only with transient
    data.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的大部分内容集中在同步构造和多线程同时访问相同数据带来的问题上。然而，有时您希望保持数据隔离，确保每个线程有自己的副本。局部变量正好实现了这一点，但它们仅适用于瞬态数据。
- en: 'The solution is *thread-local storage*. You might be hard-pressed to think
    of a requirement: data you’d want to keep isolated to a thread tends to be transient
    by nature. Its main application is for storing “out-of-band” data—that which supports
    the execution path’s infrastructure, such as messaging, transaction, and security
    tokens. Passing such data around in method parameters can be clumsy and can alienate
    all but your own methods; storing such information in ordinary static fields means
    sharing it among all threads.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是*线程本地存储*。您可能难以想象一种要求：希望将数据隔离到线程的数据通常是短暂性的。它的主要应用是用于存储“带外”数据——支持执行路径基础设施的数据，如消息、事务和安全令牌。在方法参数中传递这样的数据可能会很笨拙，也可能会疏远除了您自己的方法之外的所有人；在普通的静态字段中存储此类信息意味着在所有线程之间共享它。
- en: Thread-local storage can also be useful in optimizing parallel code. It allows
    each thread to exclusively access its own version of a thread-unsafe object without
    needing locks—and without needing to reconstruct that object between method calls.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 线程本地存储在优化并行代码方面也非常有用。它允许每个线程独占地访问其自己的版本的线程不安全对象，而无需锁定并且无需在方法调用之间重建该对象。
- en: There are four ways to implement thread-local storage. We take a look at them
    in the following subsections.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种实现线程本地存储的方法。我们将在以下小节中看一下它们。
- en: '[ThreadStatic]'
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[ThreadStatic]'
- en: 'The easiest approach to thread-local storage is to mark a static field with
    the `ThreadStatic` attribute:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的线程本地存储方法是使用`ThreadStatic`属性标记静态字段：
- en: '[PRE64]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Each thread then sees a separate copy of `_x`.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程都会看到`_x`的一个独立副本。
- en: Unfortunately, `[ThreadStatic]` doesn’t work with instance fields (it simply
    does nothing); nor does it play well with field initializers—they execute only
    *once* on the thread that’s running when the static constructor executes. If you
    need to work with instance fields—or start with a nondefault value—`ThreadLocal<T>`
    provides a better option.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`[ThreadStatic]`对实例字段无效（它仅仅不起作用）；它也无法很好地与字段初始化器配合使用——它们只在执行静态构造函数时在当前运行的线程上执行*一次*。如果需要操作实例字段或者以非默认值开始，`ThreadLocal<T>`提供了更好的选择。
- en: ThreadLocal<T>
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ThreadLocal<T>`'
- en: '`ThreadLocal<T>` provides thread-local storage for both static and instance
    fields, and allows you to specify default values.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadLocal<T>`为静态和实例字段提供了线程本地存储，并允许您指定默认值。'
- en: 'Here’s how to create a `ThreadLocal<int>` with a default value of `3` for each
    thread:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何为每个线程创建一个默认值为`3`的`ThreadLocal<int>`：
- en: '[PRE65]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You then use `_x`’s `Value` property to get or set its thread-local value.
    A bonus of using `ThreadLocal` is that values are lazily evaluated: the factory
    function evaluates on the first call (for each thread).'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用`_x`的`Value`属性获取或设置其线程本地值。使用`ThreadLocal`的一个额外好处是值的延迟评估：工厂函数在第一次调用时进行评估（对于每个线程）。
- en: ThreadLocal<T> and instance fields
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`ThreadLocal<T>`和实例字段'
- en: '`ThreadLocal<T>` is also useful with instance fields and captured local variables.
    For example, consider the problem of generating random numbers in a multithreaded
    environment. The `Random` class is not thread-safe, so we have to either lock
    around using `Random` (limiting concurrency) or generate a separate `Random` object
    for each thread. `ThreadLocal<T>` makes the latter easy:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadLocal<T>`在处理实例字段和捕获的局部变量时也非常有用。例如，考虑在多线程环境中生成随机数的问题。`Random`类不是线程安全的，因此我们必须在使用`Random`时要么加锁（限制并发性），要么为每个线程生成一个独立的`Random`对象。`ThreadLocal<T>`使后者变得简单：'
- en: '[PRE66]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Our factory function for creating the `Random` object is a bit simplistic,
    though, in that `Random`’s parameterless constructor relies on the system clock
    for a random number seed. This may be the same for two `Random` objects created
    within ~10 ms of each other. Here’s one way to fix it:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于创建`Random`对象的工厂函数有点简单，因为`Random`的无参构造函数依赖于系统时钟以获取随机数种子。这可能导致在相隔不到`10 ms`内创建的两个`Random`对象使用相同的种子。以下是解决此问题的一种方法：
- en: '[PRE67]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We use this in [Chapter 22](ch22.html#parallel_programming-id00071) (see the
    parallel spellchecking example in [“PLINQ”](ch22.html#plinq)).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第22章](ch22.html#parallel_programming-id00071)中使用这个（请参阅“PLINQ”中的并行拼写检查示例）。
- en: GetData and SetData
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取数据和设置数据
- en: 'The third approach is to use two methods in the `Thread` class: `GetData` and
    `SetData`. These store data in thread-specific “slots.” `Thread.GetData` reads
    from a thread’s isolated data store; `Thread.SetData` writes to it. Both methods
    require a `Local​DataStoreSlot` object to identify the slot. You can use the same
    slot across all threads and they’ll still get separate values. Here’s an example:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法是使用`Thread`类中的两个方法：`GetData`和`SetData`。它们将数据存储在特定于线程的“槽位”中。`Thread.GetData`从线程的隔离数据存储中读取；`Thread.SetData`向其写入。这两个方法都需要一个`LocalDataStoreSlot`对象来标识槽位。您可以在所有线程中使用相同的槽位，并且它们仍然会得到不同的值。以下是一个示例：
- en: '[PRE68]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In this instance, we called `Thread.GetNamedDataSlot`, which creates a named
    slot—this allows sharing of that slot across the application. Alternatively, you
    can control a slot’s scope yourself with an unnamed slot, obtained by calling
    `Thread.AllocateDataSlot`:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实例中，我们调用了`Thread.GetNamedDataSlot`，它创建了一个命名的槽位——这允许在整个应用程序中共享该槽位。或者，您可以通过调用`Thread.AllocateDataSlot`来自行控制槽位的作用域：
- en: '[PRE69]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '`Thread.FreeNamedDataSlot` will release a named data slot across all threads,
    but only once all references to that `LocalDataStoreSlot` have dropped out of
    scope and have been garbage-collected. This ensures that threads don’t have data
    slots pulled out from under their feet, as long as they keep a reference to the
    appropriate `LocalDataStoreSlot` object while the slot is needed.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread.FreeNamedDataSlot`将释放跨所有线程的命名数据槽，但仅当该`LocalDataStoreSlot`的所有引用都已经超出范围并且已被垃圾收集时。这确保线程在需要时保持对适当`LocalDataStoreSlot`对象的引用，以免槽位被废弃。'
- en: AsyncLocal<T>
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步本地
- en: 'The approaches to thread-local storage that we’ve discussed so far are incompatible
    with asynchronous functions, because after an `await`, execution can resume on
    a different thread. The `AsyncLocal<T>` class solves this by preserving its value
    across an `await`:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论的线程本地存储方法与异步函数不兼容，因为在`await`之后，执行可能会在不同的线程上恢复。`AsyncLocal<T>`类通过在`await`期间保留其值来解决这个问题：
- en: '[PRE70]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '`AsyncLocal<T>` is still able to keep operations started on separate threads
    apart, whether initiated by `Thread`.`Start` or `Task`.`Run`. The following writes
    “one one” and “two two”:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncLocal<T>`仍然能够区分在不同线程上启动的操作，无论是由`Thread.Start`还是`Task.Run`发起的。以下写入“one
    one”和“two two”：'
- en: '[PRE71]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`AsyncLocal<T>` has an interesting and unique nuance: if an `AsyncLocal<T>`
    object already has a value when a thread is started, the new thread will “inherit”
    that value:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncLocal<T>`有一个有趣且独特的细微差别：如果在线程启动时`AsyncLocal<T>`对象已经有一个值，新线程将“继承”该值：'
- en: '[PRE72]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The new thread, however, gets a *copy* of the value, so any changes that it
    makes will not affect the original:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，新线程得到的是值的*副本*，因此它所做的任何更改都不会影响原始值：
- en: '[PRE73]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Keep in mind that the new thread gets a *shallow* copy of the value. So, if
    you were to replace `Async<string>` with `Async<StringBuilder>` or `Async<List<string>>`,
    the new thread could clear the `StringBuilder` or add/remove items to the `List<string>`,
    and this would affect the original.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，新线程得到的是值的*浅拷贝*。因此，如果您将`Async<string>`替换为`Async<StringBuilder>`或`Async<List<string>>`，新线程可能会清除`StringBuilder`或向`List<string>`添加/删除项目，并且这将影响原始值。
- en: Timers
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定时器
- en: 'If you need to execute some method repeatedly at regular intervals, the easiest
    way is with a *timer*. Timers are convenient and efficient in their use of memory
    and resources—compared with techniques such as the following:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要定期在一定间隔内重复执行某个方法，最简单的方法是使用*定时器*。定时器在内存和资源的使用上非常方便和高效——相比于以下技术：
- en: '[PRE74]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Not only does this permanently tie up a thread resource, but without additional
    coding, `DoSomeAction` will happen at a later time each day. Timers solve these
    problems.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅会永久地占用一个线程资源，而且在没有额外编码的情况下，`DoSomeAction`将每天稍后的某个时间发生。定时器解决了这些问题。
- en: '.NET provides five timers. Two of these are general-purpose multithreaded timers:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: .NET提供了五种定时器。其中两种是通用多线程定时器：
- en: '`System.Threading.Timer`'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Threading.Timer`'
- en: '`System.Timers.Timer`'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Timers.Timer`'
- en: 'The other two are special-purpose single-threaded timers:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个是特定用途的单线程定时器：
- en: '`System.Windows.Forms.Timer` (Windows Forms timer)'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Windows.Forms.Timer`（Windows Forms定时器）'
- en: '`System.Windows.Threading.DispatcherTimer` (WPF timer)'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Windows.Threading.DispatcherTimer`（WPF定时器）'
- en: The multithreaded timers are more powerful, accurate, and flexible; the single-threaded
    timers are safer and more convenient for running simple tasks that update Windows
    Forms controls or WPF elements.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程定时器更强大、精确和灵活；单线程定时器更安全，更适合运行更新 Windows Forms 控件或 WPF 元素的简单任务。
- en: Finally, from .NET 6, there’s the `PeriodicTimer`, which we will cover first.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，从 .NET 6 开始，有 `PeriodicTimer`，我们将首先介绍它。
- en: PeriodicTimer
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PeriodicTimer
- en: '`PeriodicTimer` is not really a timer; it’s a class to help with asynchronous
    looping. It’s important to consider that since the advent of `async` and `await`,
    traditional timers are not usually necessary. Instead, the following pattern works
    nicely:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '`PeriodicTimer` 实际上并不是一个定时器；它是一个类，用于简化异步循环。考虑到 `async` 和 `await` 的出现，传统定时器通常不再必要。相反，以下模式效果良好：'
- en: '[PRE75]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Note
  id: totrans-422
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you call `StartPeriodicOperation` from a UI thread, it will behave as a single-threaded
    timer, because the await will always return on the same synchronization context.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从 UI 线程调用 `StartPeriodicOperation`，它将表现为单线程定时器，因为 await 将始终返回相同的同步上下文。
- en: You can make it behave as a multithreaded timer simply by adding `.ConfigureAwait(false)`
    to the await.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在 await 后添加 `.ConfigureAwait(false)`，即可使其表现为多线程定时器。
- en: '`PeriodicTimer` is a class to simplify this pattern:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`PeriodicTimer` 是一个用于简化此模式的类：'
- en: '[PRE76]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: PeriodicTimer also allows you to stop the timer by disposing the timer instance.
    This results in WaitForNextTickAsync returning false, allowing the loop to end.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: PeriodicTimer 还允许您通过释放定时器实例来停止定时器。这将导致 `WaitForNextTickAsync` 返回 false，从而结束循环。
- en: Multithreaded Timers
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多线程定时器
- en: '`System.Threading.Timer` is the simplest multithreaded timer: it has just a
    constructor and two methods (a delight for minimalists, as well as book authors!).
    In the following example, a timer calls the `Tick` method, which writes “tick...”
    after five seconds have elapsed, and then every second after that, until the user
    presses Enter:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Threading.Timer` 是最简单的多线程定时器：它只有一个构造函数和两个方法（对极简主义者和书籍作者来说是一种乐事！）。在以下示例中，定时器调用
    `Tick` 方法，在五秒钟后写入“tick...”，然后每秒执行一次，直到用户按下 Enter：'
- en: '[PRE77]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Note
  id: totrans-431
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: See [“Timers”](ch12.html#timers-id00111) for a discussion on disposing multithreaded
    timers.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[“定时器”](ch12.html#timers-id00111)，讨论如何处理释放多线程定时器的问题。
- en: You can change a timer’s interval later by calling its `Change` method. If you
    want a timer to fire just once, specify `Timeout.Infinite` in the constructor’s
    last argument.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用其 `Change` 方法，您可以稍后更改定时器的间隔。如果要使定时器仅触发一次，请在构造函数的最后一个参数中指定 `Timeout.Infinite`。
- en: '.NET provides another timer class of the same name in the `System.Timers` namespace.
    This simply wraps the `System.Threading.Timer`, providing additional convenience
    while using the identical underlying engine. Here’s a summary of its added features:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 在 `System.Timers` 命名空间中提供了另一个同名定时器类。它简单地包装了 `System.Threading.Timer`，在使用相同的底层引擎的同时提供了额外的便利性。以下是其新增功能的摘要：
- en: An `IComponent` implementation, allowing it to be sited in Visual Studio’s Designer’s
    component tray
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `IComponent` 接口，允许在 Visual Studio 的设计器组件托盘中设置
- en: An `Interval` property instead of a `Change` method
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Interval` 属性而非 `Change` 方法'
- en: An `Elapsed` *event* instead of a callback delegate
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Elapsed` *事件* 而非回调委托
- en: An `Enabled` property to start and stop the timer (its default value being `false`)
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Enabled` 属性用于启动和停止定时器（默认值为 `false`）'
- en: '`Start` and `Stop` methods in case you’re confused by `Enabled`'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Start` 和 `Stop` 方法，以防你对 `Enabled` 感到困惑'
- en: An `AutoReset` flag for indicating a recurring event (default value is `true`)
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `AutoReset` 标志用于指示重复事件（默认值为 `true`）
- en: A `SynchronizingObject` property with `Invoke` and `BeginInvoke` methods for
    safely calling methods on WPF elements and Windows Forms controls
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SynchronizingObject` 属性，具有 `Invoke` 和 `BeginInvoke` 方法，用于安全地调用 WPF 元素和 Windows
    Forms 控件的方法'
- en: 'Here’s an example:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE78]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Multithreaded timers use the thread pool to allow a few threads to serve many
    timers. This means that the callback method or `Elapsed` event can fire on a different
    thread each time it is called. Furthermore, the `Elapsed` event always fires (approximately)
    on time—regardless of whether the previous `Elapsed` event finished executing.
    Hence, callbacks or event handlers must be thread-safe.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程定时器使用线程池来服务多个定时器。这意味着每次调用回调方法或 `Elapsed` 事件时，它可能在不同的线程上触发。此外，`Elapsed` 事件始终（大致）按时触发，不受前一个
    `Elapsed` 事件是否执行完成的影响。因此，回调或事件处理程序必须是线程安全的。
- en: The precision of multithreaded timers depends on the OS, and is typically in
    the 10- to 20-millisecond region. If you need greater precision, you can use native
    interop and call the Windows multimedia timer. This has precision down to one
    millisecond, and it is defined in *winmm.dll*. First call `timeBeginPeriod` to
    inform the OS that you need high timing precision, and then call `timeSetEvent`
    to start a multimedia timer. When you’re done, call `timeKillEvent` to stop the
    timer and `timeEndPeriod` to inform the OS that you no longer need high timing
    precision. [Chapter 24](ch24.html#native_and_com_interoperabilit) demonstrates
    calling external methods with P/Invoke. You can find complete examples on the
    internet that use the multimedia timer by searching for the keywords *dllimport
    winmm.dll timesetevent*.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程定时器的精度取决于操作系统，通常在10到20毫秒范围内。如果需要更高的精度，可以使用本地Interop并调用Windows多媒体定时器。这种定时器的精度可达到一毫秒，定义在*winmm.dll*中。首先调用`timeBeginPeriod`通知操作系统您需要高时序精度，然后调用`timeSetEvent`启动多媒体定时器。完成后，调用`timeKillEvent`停止定时器，并调用`timeEndPeriod`通知操作系统您不再需要高时序精度。[第24章](ch24.html#native_and_com_interoperabilit)展示了如何使用P/Invoke调用外部方法。您可以通过搜索关键字*dllimport
    winmm.dll timesetevent*在互联网上找到使用多媒体定时器的完整示例。
- en: Single-Threaded Timers
  id: totrans-446
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单线程定时器
- en: '.NET provides timers designed to eliminate thread-safety issues for WPF and
    Windows Forms applications:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: .NET提供了专为消除WPF和Windows Forms应用程序的线程安全问题而设计的定时器：
- en: '`System.Windows.Threading.DispatcherTimer` (WPF)'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Windows.Threading.DispatcherTimer`（WPF）'
- en: '`System.Windows.Forms.Timer` (Windows Forms)'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Windows.Forms.Timer`（Windows Forms）'
- en: Note
  id: totrans-450
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: The single-threaded timers are not designed to work outside their respective
    environments. If you use a Windows Forms timer in a Windows Service application,
    for instance, the `Timer` event won’t fire!
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 单线程定时器不设计用于其各自的环境之外。例如，如果在Windows服务应用程序中使用Windows Forms定时器，则`Timer`事件不会触发！
- en: 'Both are like `System.Timers.Timer` in the members that they expose—`Interval`,
    `Start`, and `Stop` (and `Tick`, which is equivalent to `Elapsed`)—and are used
    in a similar manner. However, they differ in how they work internally. Instead
    of firing timer events on pooled threads, they post the events to the WPF or Windows
    Forms message loop. This means that the `Tick` event always fires on the same
    thread that originally created the timer—which, in a normal application, is the
    same thread used to manage all user interface elements and controls. This has
    a number of benefits:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 两者在公开的成员（如`Interval`、`Start`和`Stop`，以及等效于`Elapsed`的`Tick`）方面类似于`System.Timers.Timer`，并且使用方式类似。然而，它们在内部工作方式上有所不同。它们不是在池化线程上触发计时器事件，而是将事件发布到WPF或Windows
    Forms消息循环中。这意味着`Tick`事件始终在最初创建计时器的同一线程上触发——在正常应用程序中，这是用于管理所有用户界面元素和控件的同一线程。这带来了许多好处：
- en: You can forget about thread safety.
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以忘记线程安全性。
- en: A fresh `Tick` will never fire until the previous `Tick` has finished processing.
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的`Tick`将不会触发，直到前一个`Tick`处理完毕。
- en: You can update user interface elements and controls directly from `Tick` event
    handling code without calling `Control.BeginInvoke` or `Dispatcher.Begin​Invoke`.
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以直接从`Tick`事件处理代码更新用户界面元素和控件，无需调用`Control.BeginInvoke`或`Dispatcher.BeginInvoke`。
- en: 'Thus, a program employing these timers is not really multithreaded: you end
    up with the same kind of pseudo-concurrency that’s described in [Chapter 14](ch14.html#concurrency_and_asynchron)
    with asynchronous functions that execute on a UI thread. One thread serves all
    timers as well as the processing UI events, which means that the `Tick` event
    handler must execute quickly, otherwise the UI becomes unresponsive.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用这些定时器的程序实际上并非多线程：您最终会得到与[第14章](ch14.html#concurrency_and_asynchron)中描述的伪并发相同的伪并发，其中异步函数在UI线程上执行。一个线程为所有定时器和处理UI事件服务，这意味着`Tick`事件处理程序必须快速执行，否则UI会变得无响应。
- en: This makes the WPF and Windows Forms timers suitable for small jobs, typically
    updating some aspect of the UI (e.g., a clock or countdown display).
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得WPF和Windows Forms定时器适用于小型任务，通常用于更新UI的某些方面（例如时钟或倒计时显示）。
- en: In terms of precision, the single-threaded timers are similar to the multithreaded
    timers (tens of milliseconds), although they are typically less *accurate* because
    they can be delayed while other UI requests (or other timer events) are processed.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在精度方面，单线程定时器与多线程定时器类似（数十毫秒），尽管它们通常不如后者*准确*，因为它们可能会因其他UI请求（或其他计时器事件）而延迟。
- en: ^([1](ch21.html#ch01fn15-marker)) Nuances in the behavior of Windows and the
    CLR mean that the fairness of the queue can sometimes be violated.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch21.html#ch01fn15-marker)) Windows 和 CLR 行为的微妙之处意味着队列的公平性有时会受到侵犯。
- en: ^([2](ch21.html#ch01fn16-marker)) As with locks, the fairness of the queue can
    sometimes be violated due to nuances in the operating system.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch21.html#ch01fn16-marker)) 与锁一样，由于操作系统的微妙之处，队列的公平性有时也会被侵犯。
