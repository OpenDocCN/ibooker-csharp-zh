- en: Chapter 6\. Programming Asynchronously
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。异步编程
- en: It used to be that most of the code anyone wrote was synchronous. Things like
    concurrency, thread pools, and parallel programming were the domain of specialized
    experts who sometimes still got it wrong. Historical internet forums, UseNet,
    and even books were full of warnings to not try multithreading unless you know
    what you’re doing and have a strong requirement for it. However, that’s changed.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，大多数人编写的代码都是同步的。诸如并发性、线程池和并行编程等问题曾是专业专家的领域，有时甚至这些专家也会出错。历史上的互联网论坛、UseNet甚至书籍上都充满了警告，不要尝试多线程，除非你知道你在做什么，并且确实有强烈的需求。然而，现在情况已经改变。
- en: In 2010, Microsoft introduced the Task Parallel Library (TPL), which made it
    a lot easier to write multithreaded code. This coincided with the common availability
    of multithread/multicore CPU architectures. One of the TPL primitives was the
    `Task` class, which represented a promise to perform some work, on a separate
    thread, and return the results. Interestingly, PLINQ, which is covered in [Recipe
    4.10](ch04.xhtml#querying_in_parallel), shipped in the same time frame. TPL is
    still an important part of the developer’s toolkit for in-process CPU-intensive
    multithreading.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 2010年，微软推出了任务并行库（TPL），大大简化了编写多线程代码。这与多线程/多核CPU架构的普及同时出现。TPL的一个基本组件是`Task`类，它表示承诺在单独的线程上执行某些工作，并返回结果。有趣的是，PLINQ也在同一时间框架内推出，它在[第4.10节](ch04.xhtml#querying_in_parallel)中有详细介绍。TPL仍然是开发人员工具箱中处理内部CPU密集型多线程的重要组成部分。
- en: Building on the concepts of `Task`, from TPL, Microsoft introduced async via
    specialized language syntax in C# 4\. While we had asynchronous programming since
    C# 1, through delegates, it was more complex and less efficient. In C# 5, async
    simplified this by introducing the `async/await` keywords and making the code
    and its order of execution very similar to synchronous code. In addition to simplification,
    a primary use case for C# async is out-of-process communication, as opposed to
    where TPL shines for in-process CPU intensive work. When going out-of-process,
    think about accessing the file system, making a database query, or calling a REST
    API. Behind the scenes, async manages the threads for these operations so they
    don’t block and improves application performance and scalability. With async,
    we could reason about our logic in a simple way and still have the benefits and
    sophistication of asynchronous operation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 基于TPL的`Task`概念，微软在C# 4中通过专门的语言语法引入了异步。虽然自C# 1以来我们已经有了异步编程，通过委托，但它更复杂且效率更低。在C#
    5中，通过引入`async/await`关键字，异步编程变得简化，使得代码及其执行顺序非常类似于同步代码。除了简化之外，C#异步的一个主要用例是跨进程通信，与TPL擅长处理的内部CPU密集型工作形成对比。当进行跨进程操作时，考虑访问文件系统、进行数据库查询或调用REST
    API。在幕后，异步管理这些操作的线程，使其不会阻塞，并提高应用程序的性能和可伸缩性。使用异步，我们可以以简单的方式推理逻辑，同时享受异步操作的好处和复杂性。
- en: Since its introduction, Microsoft has continued to improve async, both via language
    features and .NET Framework libraries. This chapter covers these new features,
    such as async `Main` methods, the new `ValueTask` type, async iterators, and async
    disposal. There are also original capabilities of async that deserve special attention,
    such as writing safe async libraries, managing concurrent async tasks, cancellation,
    and progress reporting.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 自其推出以来，微软不断通过语言特性和.NET Framework库改进异步。本章介绍了这些新功能，如异步`Main`方法、新的`ValueTask`类型、异步迭代器和异步处理。还有一些异步的原始能力值得特别关注，例如编写安全的异步库、管理并发的异步任务、取消和进度报告。
- en: The theme of this chapter is checkout, where a customer has products in their
    shopping cart, they’ve started the checkout process, and the code needs to process
    each checkout request. We’ll start with the proper way to use async with console
    applications.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主题是结账，客户在购物车中有产品，他们已经开始结账流程，代码需要处理每个结账请求。我们将从控制台应用程序中正确使用异步开始。
- en: 6.1 Creating Async Console Applications
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.1 创建异步控制台应用程序
- en: Problem
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to use a library in a console application, but it only has an async
    API.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台应用程序中需要使用一个库，但它只有异步 API。
- en: Solution
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This class has async methods:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 该课程有异步方法：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here’s the old way to write an async console app:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是编写异步控制台应用程序的旧方法：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here’s the new recommended way to write an async console app:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是编写异步控制台应用程序的推荐方法：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Discussion
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: When first introduced, async was nearly everywhere and immediately useful. Still,
    there were edge cases, such as `Main` methods and `catch` and `finally` blocks,
    where async couldn’t be used. Fortunately, Microsoft fixed this in C# 7.1 and
    added more support in other parts of the .NET Framework that were lacking, for
    instance, async `ActionResult` in ASP.NET MVC. [Recipe 6.3](#creating_async_iterators)
    shows how async iterators solve another async problem.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 初次引入时，异步几乎随处可见并且立即有用。然而，在某些边缘情况下，比如 `Main` 方法以及 `catch` 和 `finally` 块，不能使用异步。幸运的是，Microsoft
    在 C# 7.1 中修复了这个问题，并在 .NET Framework 的其他部分增加了更多支持，例如 ASP.NET MVC 中的异步 `ActionResult`。[Recipe
    6.3](#creating_async_iterators) 展示了异步迭代器如何解决另一个异步问题。
- en: 'A prominent async addition, described in this section, is async `Main`. The
    problem was that, just like the `CheckoutService` class in the solution, many
    .NET Framework types and third-party libraries were written for async. However,
    without async `Main`, developers had to write problematic code. To demonstrate
    the problem, the solution includes two versions of a `Main` method: the old synchronous
    way and the new async approach.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述的一个显著的异步增强是异步 `Main`。问题在于，就像解决方案中的 `CheckoutService` 类一样，许多 .NET Framework
    类型和第三方库都是为异步编写的。然而，没有异步 `Main`，开发人员必须编写问题代码。为了演示问题，解决方案包括 `Main` 方法的两个版本：旧的同步方式和新的异步方法。
- en: With the old synchronous technique, developers were forced to use `Wait()` and
    `Result`, which are typical async antipatterns because of thread blocking and
    potential thread deadlocks and race conditions. [Recipe 6.4](#writing_safe_async_libraries)
    explains a scenario where writing code like this can cause a deadlock (and how
    to avoid it). These are members of the `Task` type, which async methods return.
    Unfortunately, this was the only choice in the first iteration of async if you
    wanted to write a command-line utility, text-based app, or demo app.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧的同步技术中，开发人员被迫使用 `Wait()` 和 `Result`，这是典型的异步反模式，因为会导致线程阻塞、潜在的线程死锁和竞争条件。[Recipe
    6.4](#writing_safe_async_libraries) 解释了一种情况，如果编写这样的代码可能会导致死锁（以及如何避免）。这些都是异步方法返回的
    `Task` 类型的成员。不幸的是，在第一次异步迭代中，如果想要编写命令行实用程序、文本应用程序或演示应用程序，这是唯一的选择。
- en: The second `Main` in the solution shows the new syntax, with the `async` modifier
    and the `Task` return type. All we have to do is `await` the call to `checkoutSvc.Start​A⁠sync()`
    and the code works fine.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案中的第二个 `Main` 显示了新的语法，包括 `async` 修饰符和 `Task` 返回类型。我们只需 `await` 调用 `checkoutSvc.StartAsync()`，代码就可以正常工作。
- en: Tip
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: As you know, `Main` can return `void` or `int`. The solution example with `Task`
    is for a `void` return. You can change that to `Task<int>` for an `int` return.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，`Main` 可以返回 `void` 或 `int`。这个使用 `Task` 的示例是为了 `void` 返回而设计的。你可以将其改为 `Task<int>`
    以返回 `int`。
- en: Essentially, Microsoft hasn’t recommended a safe way to call from synchronous
    code into asynchronous code. So this was a welcome addition that makes it much
    easier to write console apps that call async code. Also, notice that the entire
    call chain, from `Main` to `CheckoutService.StartAsync` and to other `CheckoutService`
    methods, is all async. Ideally, the entire call chain is async, but occasionally
    you will have an async method that only calls synchronous methods; you can learn
    more about that in [Recipe 6.6](#calling_synchronous_code_from_async_code).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，Microsoft 没有推荐一种安全的方式从同步代码调用异步代码。因此，这是一个受欢迎的补充，大大简化了编写调用异步代码的控制台应用程序的过程。还要注意，从
    `Main` 到 `CheckoutService.StartAsync` 再到其他 `CheckoutService` 方法的整个调用链都是异步的。理想情况下，整个调用链都应该是异步的，但偶尔你会有一个异步方法只调用同步方法；你可以在
    [Recipe 6.6](#calling_synchronous_code_from_async_code) 中了解更多相关信息。
- en: See Also
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 6.3, “Creating Async Iterators”](#creating_async_iterators)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 6.3, “创建异步迭代器”](#creating_async_iterators)'
- en: '[Recipe 6.4, “Writing Safe Async Libraries”](#writing_safe_async_libraries)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 6.4, “编写安全的异步库”](#writing_safe_async_libraries)'
- en: '[Recipe 6.6, “Calling Synchronous Code from Async Code”](#calling_synchronous_code_from_async_code)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 6.6, “从异步代码调用同步代码”](#calling_synchronous_code_from_async_code)'
- en: 6.2 Reducing Memory Allocations for Async Return Values
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.2 减少异步返回值的内存分配
- en: Problem
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to reduce memory consumption for your async code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望减少异步代码的内存消耗。
- en: Solution
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s how to use `ValueTask` instead of `Task` in async methods:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在异步方法中使用 `ValueTask` 而不是 `Task` 的方法：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And here’s the app that consumes that class:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是消耗该类的应用程序：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Discussion
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Since the beginning of async, we’ve returned types by either `Task` or `Task<T>`.
    That has always worked and will continue to work fine for any async code. Over
    time, though, people identified specific circumstances that open new performance
    opportunities concerning the fact that `Task` is a reference type and the runtime
    caches `Tasks`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 自从异步开始以来，我们一直通过 `Task` 或 `Task<T>` 返回类型。这种方式一直有效，并且将来也会继续适用于任何异步代码。然而，随着时间的推移，人们发现了特定情况，这些情况打开了关于
    `Task` 是引用类型以及运行时如何缓存 `Tasks` 的新性能机会。
- en: The `Task` class, by definition, is a reference type. That means the runtime
    allocates heap memory every time an async method returns a `Task`. As you know,
    value types allocate memory where they are defined, but they don’t cause garbage
    collector overhead.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task` 类根据定义是一个引用类型。这意味着每次异步方法返回 `Task` 时，运行时都会分配堆内存。正如你所知，值类型在定义它们的地方分配内存，但它们不会引起垃圾收集器的开销。'
- en: Perhaps not as obvious, another feature of `Tasks` is that the runtime caches
    them. Rather than `await` a method, it’s possible to reference the returned `Task`
    from an `async` method. With that `Task` reference, you can perform concurrent
    invocations on multiple tasks. You could also invoke that task more than once.
    The important point here is that the runtime has cached the task, resulting in
    more memory usage.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 或许不太明显，`Tasks` 的另一个特性是运行时会对其进行缓存。而不是使用 `await` 方法，可以直接引用从 `async` 方法返回的 `Task`。有了这个
    `Task` 的引用，你可以对多个任务进行并发调用。你也可以多次调用该任务。这里的重点是运行时已经缓存了任务，导致了更多的内存使用。
- en: As mentioned, in normal coding a `Task` works fine and you might not care. However,
    think about high-performance scenarios where a lot of `Task` objects get allocated
    and you are interested in finding ways to improve performance and scalability.
    The solution simulates a concept where this might matter. Imagine a business that
    needs to process a high volume of shopping cart checkouts each day. In that case,
    eliminating any overhead for object allocation, garbage collection, and memory
    pressure could be beneficial.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在普通编码中，`Task` 的使用是正常的，也许你并不在意。然而，考虑到高性能场景，会分配大量的 `Task` 对象，你可能有兴趣找到提升性能和可扩展性的方法。该解决方案模拟了一个可能会关注这个问题的概念。想象一下，一个企业每天需要处理大量的购物车结账操作。在这种情况下，消除任何对象分配、垃圾收集和内存压力可能都是有益的。
- en: To address these concerns, Microsoft added support for `ValueTask` (and `ValueTask<T>`)
    as async return types. As its name suggests, `ValueTask` is a value type. Because
    it’s a value type, the only memory allocation it incurs is wherever the value
    resides, on the stack in this case. By definition of a value type, there isn’t
    any unique heap allocation or garbage collection just for that value.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，Microsoft 添加了对 `ValueTask`（以及 `ValueTask<T>`）作为异步返回类型的支持。顾名思义，`ValueTask`
    是一个值类型。因为它是一个值类型，在这种情况下，它只会在栈上分配内存。根据值类型的定义，它并不会有独立的堆分配或者为了这个值而进行的垃圾收集。
- en: 'Further, the runtime does not cache `ValueType`, resulting in less memory allocation
    and cache management. This works great in high-performance/scalability scenarios.
    The `CheckoutService` in the solution demonstrates how to use `ValueTask`: just
    use it in place of `Task`. The assumption here is that the code will always `await`
    the method and never try to reuse the `ValueTask`. In the solution, that’s exactly
    what happens.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，运行时不会缓存 `ValueType`，这导致了更少的内存分配和缓存管理。这在高性能/可扩展性场景中非常有效。解决方案中的 `CheckoutService`
    展示了如何使用 `ValueTask`：只需在 `Task` 的位置使用它。这里的假设是代码总是会 `await` 方法，而不会尝试重用 `ValueTask`。在解决方案中，确实是这样。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re writing a reusable library for other developers, consider whether
    `ValueTask` is appropriate. By using `ValueTask`, you eliminate the ability of
    consuming code to perform concurrent task operations or any other advanced scenarios
    for where a `Task` is more appropriate. `Task` gives the most flexibility in this
    case.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在为其他开发人员编写可重用的库，请考虑 `ValueTask` 是否合适。通过使用 `ValueTask`，你消除了消费代码执行并发任务操作或其他高级场景的能力，这种情况下
    `Task` 提供了最大的灵活性。
- en: As is with most things, there’s a trade-off. All of the scenarios for which
    the runtime `Task` cache were useful are no longer options for `ValueTask`. With
    `ValueTask`, you can’t combine operations or reuse a `ValueTask` after the first
    time. Recipes [6.7](#waiting_for_parallel_tasks_to_complete) and [6.8](#handling_parallel_tasks_as_they_complete)
    show a couple of scenarios where `ValueTask` doesn’t work.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 就像大多数事物一样，存在权衡。运行时`Task`缓存对于`ValueTask`不再适用的所有场景都不再是选项。使用`ValueTask`时，不能将操作组合或在第一次之后重用`ValueTask`。菜谱
    [6.7](#waiting_for_parallel_tasks_to_complete) 和 [6.8](#handling_parallel_tasks_as_they_complete)
    展示了`ValueTask`无法使用的几种情况。
- en: To recap, use `ValueTask` when performance and scalability are a concern, and
    you’re free to use `Task` any other time.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，当性能和可扩展性成为问题时，请使用`ValueTask`，在其他时间则可以自由使用`Task`。
- en: See Also
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 6.7, “Waiting for Parallel Tasks to Complete”](#waiting_for_parallel_tasks_to_complete)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[菜谱 6.7，“等待并行任务完成”](#waiting_for_parallel_tasks_to_complete)'
- en: '[Recipe 6.8, “Handling Parallel Tasks as They Complete”](#handling_parallel_tasks_as_they_complete)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[菜谱 6.8，“处理并行任务完成时的情况”](#handling_parallel_tasks_as_they_complete)'
- en: 6.3 Creating Async Iterators
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.3 创建异步迭代器
- en: Problem
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You’re working with async code and a classical synchronous iterator won’t work.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在处理异步代码，而经典的同步迭代器将不起作用。
- en: Solution
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s the data for the checkout process:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结帐过程的数据：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is the checkout process for each request:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是每个请求的结帐过程：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The async iterator processes each request:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 异步迭代器处理每个请求：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, the application consumes the iterator to process each request:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，应用程序消耗迭代器来处理每个请求：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Discussion
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: While iterators are essential for .NET Framework collections like `List<T>`
    or a custom collection you’ve written, they can also be useful abstractions that
    hide complex data acquisition logic. The solution demonstrates a related scenario
    where an iterator might be useful—processing a stream of `CheckoutRequests` as
    if it were a collection.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然迭代器对于像`List<T>`这样的.NET Framework集合或者你自己编写的自定义集合至关重要，但它们也可以是有用的抽象，隐藏复杂的数据获取逻辑。该解决方案演示了一个相关的场景，迭代器可能会有用的地方——处理一个`CheckoutRequests`流，就像它是一个集合一样。
- en: An important aspect of the solution is that it’s impractical to hold too many
    `Check​ou⁠t​Request` instances in memory. If a system continuously receives orders,
    it needs to scale. In the solution, we imagine a polling implementation that continuously
    gets the next batch of `CheckoutRequests`. This reduces memory pressure and the
    iterator provides an abstraction that hides the complex details of how the program
    receives orders.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案的一个重要方面是，将太多的`Check​ou⁠t​Request`实例保存在内存中是不切实际的。如果一个系统不断接收订单，它需要进行扩展。在这个解决方案中，我们设想了一个轮询实现，持续获取下一批`CheckoutRequests`。这样可以减少内存压力，并且迭代器提供了一个抽象，隐藏了程序接收订单的复杂细节。
- en: In the early days of async, it would have been more complex to perform a task
    like this because the polling is asynchronous, making an out-of-process request.
    It’s clearly possible to find a library that lets this happen synchronously, but
    that ignores the benefit of async. The solution solves this problem with a newer
    interface for async streams, `IAsyncEnumerable`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步的早期阶段，执行像这样的任务会更加复杂，因为轮询是异步的，会发出一个进程外的请求。显然可以找到一个让这种情况同步发生的库，但这忽略了异步的好处。该解决方案通过`IAsyncEnumerable`提供了一个新的异步流接口来解决这个问题。
- en: The `CheckoutStream` class has an iterator named `GetRequestsAsync`, returning
    `IAsyncEnumerable<CheckoutRequest>`. This is the async equivalent of the `IEnumerable<T>`
    for synchronous iterators. Although the `while` loop continues forever in this
    demo and you’ll need to manually stop the app, [Recipe 6.9](#cancelling_async_operations)
    shows how to cancel the process gracefully. This iterator gets a new batch of
    `CheckoutRequests`, yields each item in the batch, and sleeps for a second before
    getting the next batch. The sleep, `Task.Delay`, is for demo purposes so you can
    see the output.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`CheckoutStream`类有一个名为`GetRequestsAsync`的迭代器，返回`IAsyncEnumerable<CheckoutRequest>`。这相当于同步迭代器的异步版本`IEnumerable<T>`。虽然在此演示中，`while`循环永远继续下去，你需要手动停止应用程序，[菜谱
    6.9](#cancelling_async_operations) 展示了如何优雅地取消该过程。此迭代器获取一个新的`CheckoutRequests`批次，生成批次中的每个项目，并在获取下一批之前休眠一秒钟。为了演示目的，休眠使用了`Task.Delay`。'
- en: Note
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `yield` keyword is syntactic sugar to help turn type members into iterators.
    `IEnumerable<T>` types, including `IAsync​Enumer⁠able​<T>`, have `MoveNext` and
    `Current` members, where `MoveNext` loads `Current` with the next value it reads.
    Behind the scenes, when the C# compiler sees an iterator, it generates a new class
    with the `MoveNext` and `Current` members. When invoking `yield`, such as in `yield
    return request` in `GetRequestsAsync`, the C# compiler instantiates that new class,
    calls `MoveNext`, and returns `Current`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield` 关键字是语法糖，用于将类型成员转换为迭代器。包括 `IAsync​Enumer⁠able​<T>` 在内的 `IEnumerable<T>`
    类型具有 `MoveNext` 和 `Current` 成员，其中 `MoveNext` 将 `Current` 加载为它读取的下一个值。在幕后，当 C#
    编译器看到一个迭代器时，它会生成一个新的类，其中包含 `MoveNext` 和 `Current` 成员。当在 `GetRequestsAsync` 中使用
    `yield return request` 等方式时，C# 编译器实例化该新类，调用 `MoveNext` 并返回 `Current`。'
- en: The `GetNextBatchAsync` method only returns a list of `CheckoutRequests`. However,
    imagine that this is really an async call to a network endpoint, queue, or service
    bus that has the next set of `CheckoutRequest` instances ready. Recipes [1.9](ch01.xhtml#designing_a_custom_exception),
    [3.7](ch03.xhtml#rethrowing_exceptions), and [3.9](ch03.xhtml#building_resilient_network_connections)
    demonstrate some of the issues you’ll care about when doing this. By moving all
    this complexity into the iterator, application code can consume data in a much
    simpler manner.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetNextBatchAsync` 方法仅返回 `CheckoutRequests` 列表。但是，请想象这实际上是一个异步调用到一个准备好下一组
    `CheckoutRequest` 实例的网络端点、队列或服务总线。食谱 [1.9](ch01.xhtml#designing_a_custom_exception)、[3.7](ch03.xhtml#rethrowing_exceptions)
    和 [3.9](ch03.xhtml#building_resilient_network_connections) 展示了在执行此操作时您关心的一些问题。通过将所有这些复杂性移入迭代器，应用代码可以以更简单的方式消耗数据。'
- en: The `Main` method shows how to consume an async iterator. The first thing to
    notice is the `async` modifier on the `foreach` loop. This was a new addition
    to C# for async streams. As you can see, it allows `foreach` to work with an `IAsyncEnumerable<T>`
    iterator.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法展示了如何消耗异步迭代器。首先要注意的是 `foreach` 循环上的 `async` 修饰符。这是 C# 中异步流的一个新补充。正如您所见，它允许
    `foreach` 与 `IAsyncEnumerable<T>` 迭代器一起工作。'
- en: See Also
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 1.9, “Designing a Custom Exception”](ch01.xhtml#designing_a_custom_exception)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 1.9 节，“设计自定义异常”](ch01.xhtml#designing_a_custom_exception)'
- en: '[Recipe 3.7, “Rethrowing Exceptions”](ch03.xhtml#rethrowing_exceptions)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 3.7 节，“重新抛出异常”](ch03.xhtml#rethrowing_exceptions)'
- en: '[Recipe 3.9, “Building Resilient Network Connections”](ch03.xhtml#building_resilient_network_connections)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 3.9 节，“构建弹性网络连接”](ch03.xhtml#building_resilient_network_connections)'
- en: '[Recipe 6.9, “Cancelling Async Operations”](#cancelling_async_operations)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 6.9 节，“取消异步操作”](#cancelling_async_operations)'
- en: 6.4 Writing Safe Async Libraries
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.4 编写安全的异步库
- en: Problem
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Your async code is causing a deadlock with the UI thread.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您的异步代码与 UI 线程引起死锁。
- en: Solution
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This class marshals the code off of the UI thread:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此类将代码从 UI 线程上移：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here’s the program that calls it:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是调用它的程序：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Discussion
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: UI technology such as Windows Forms, Windows Presentation Foundation (WPF),
    and WinUI run on a single thread—the UI thread. This simplifies the work a developer
    needs to do when working with UI code. However, if you’re using async or writing
    multithreaded logic, it’s easy for things to go wrong. In particular, if another
    thread attempts to do anything with the UI or run in the same logic of the UI
    thread, you run the risk of race conditions and deadlocks. To understand how bad
    the problem can be, consider that your application often runs perfectly in the
    development, QA, and production environments. Then, without notice, the UI locks
    up, customers begin to complain, and you can’t reproduce the problem.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: UI 技术（如 Windows Forms、Windows Presentation Foundation（WPF）和 WinUI）运行在单线程上 ——
    UI 线程上。这简化了开发人员在处理 UI 代码时需要做的工作。但是，如果您使用异步或编写多线程逻辑，事情很容易出错。特别是，如果另一个线程尝试对 UI 进行任何操作或在
    UI 线程的相同逻辑中运行，您就有可能发生竞态条件和死锁。要了解问题有多糟糕，请考虑您的应用程序通常在开发、QA 和生产环境中运行良好。然后，毫无征兆地，UI
    卡住了，客户开始抱怨，而您无法重现问题。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'In some cases, depending on the UI you’re using and the .NET version, you might
    get an exception like the following when accessing the UI from a non-UI thread:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，根据您使用的 UI 和 .NET 版本，当从非 UI 线程访问 UI 时可能会出现以下异常：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is good because at least you know there’s a problem.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，因为至少您知道存在问题。
- en: '[Recipe 6.1](#creating_async_console_applications) explained how calling `Wait`
    or assigning `Result` on a `Task` could cause a deadlock. The problem here occurs
    because `Wait` and `Result` block the UI thread, waiting on a response. The called
    async code executes, returns, and tries to run on the same thread. However, as
    just mentioned, the UI thread is blocked, causing a deadlock.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 6.1](#creating_async_console_applications)解释了如何通过调用`Wait`或在`Task`上分配`Result`可能会导致死锁。问题出在`Wait`和`Result`会阻塞UI线程，等待响应。异步调用的代码执行完毕并返回，试图在同一个线程上运行。然而，正如刚才提到的，UI线程被阻塞，导致死锁。'
- en: The solution fixes this problem in the `CheckoutService.StartAsync` method.
    Notice how it calls `ConfigureAwait(false)`—the only difference between this code
    and the solution in [Recipe 6.1](#creating_async_console_applications). What this
    does is marshal execution off of the calling thread (the UI thread) and onto a
    new thread. Now, when the thread returns from the async call, it won’t cause a
    deadlock.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案在`CheckoutService.StartAsync`方法中修复了这个问题。请注意它如何调用`ConfigureAwait(false)`——这段代码与[Recipe
    6.1](#creating_async_console_applications)中的解决方案唯一的区别就是这样做可以将执行从调用线程（UI线程）迁移到新线程上。现在，当线程从异步调用返回时，它不会导致死锁。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`ConfigureAwait(true)` is the default condition when awaiting a `Task`. Changing
    this default is only needed in advanced scenarios that are out of the scope of
    practical everyday engineering. If you ever see it in code, it might be good to
    question why someone needed it.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当等待一个`Task`时，默认条件是`ConfigureAwait(true)`。只有在实践工程之外的高级场景中才需要更改此默认设置。如果在代码中看到它，可能需要质疑为什么会有这种需求。
- en: A significant point to be made here is that the problem statement clearly says
    *libraries*. When writing a library, you want the code to work regardless of what
    code called it. Therefore, the library code must be independent and unaware of
    who the caller is. This is an example, as stated in [Recipe 1.5](ch01.xhtml#designing_application_layers),
    where separation of concerns is important. If the library code doesn’t manipulate
    the UI, which it never should, you’ll avoid threading problems like race conditions
    and deadlocks.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要强调的一个重点是，问题陈述明确提到*libraries*。在编写库时，希望代码能够独立于调用方运行。因此，库代码必须独立于调用方，并且不知道调用方是谁。这就是[Recipe
    1.5](ch01.xhtml#designing_application_layers)中所述的例子，分离关注点非常重要。如果库代码不涉及UI操作（它绝对不应该涉及），就能避免线程问题，如竞态条件和死锁。
- en: It’s important to note that if one `await` is on `ConfigureAwait(false)`, all
    `awaits` in a method should be also. The reason is that some methods execute so
    quickly that they execute synchronously, and `ConfigureAwait(false)` doesn’t marshal
    the thread. If another `await` then runs asynchronously, without `ConfigureAwait(false)`,
    you’ll have the same threading problems as if `ConfigureAwait(false)` was never
    called.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个`await`使用了`ConfigureAwait(false)`，那么该方法中的所有`await`也应该使用。原因是有些方法执行速度非常快，会同步执行，并且`ConfigureAwait(false)`不会调度线程。如果另一个`await`异步运行但没有使用`ConfigureAwait(false)`，你会遇到与未调用`ConfigureAwait(false)`时相同的线程问题。
- en: Warning
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Visual Studio analyzers set warnings on all non-UI code with async calls missing
    `ConfigureAwait(false)`. It might be tedious to add these, but you still should.
    Even if you think the first `await` of a method is guaranteed to run asynchronously,
    logic changes over time with maintenance, and you might inadvertently cause threading
    problems. It’s safer to leave this analyzer enabled and follow the recommendations.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 分析器在所有缺少`ConfigureAwait(false)`的非UI代码上设置警告。可能会觉得增加这些配置很麻烦，但你仍然应该这样做。即使你认为方法的第一个`await`保证会异步执行，逻辑在维护过程中可能会发生变化，而你可能会无意中引发线程问题。最安全的方法是保持分析器启用并遵循推荐。
- en: Another benefit of `ConfigureAwait(false)` is that it slightly improves efficiency.
    The default, `ConfigureAwait(true)`, incurs overhead for setting up a callback
    that marshals the completed thread onto the UI thread. `ConfigureAwait(false)`
    avoids this.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfigureAwait(false)`的另一个好处是它稍微提高了效率。默认的`ConfigureAwait(true)`会为设置回调而产生开销，该回调会将已完成的线程调度到UI线程上。而`ConfigureAwait(false)`则避免了这种情况。'
- en: Going back to the point about `ConfigureAwait(false)` being appropriate for
    library code, there are times when you don’t want to use it. More specifically,
    you don’t want to call `ConfigureAwait(false)` in UI code, in particular event
    handlers. Think about an event handler and what it does. It gets called in response
    to some user action, like a button click, and it sets status, updates waiting
    indicators, disables controls that the user shouldn’t interact with, makes the
    call, and afterward resets the UI. All of this work is happening on the UI thread,
    as it should. In this case, you don’t want to marshal off the UI thread with `ConfigureAwait(false)`
    because that will cause multithreaded UI problems.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在库代码中使用 `ConfigureAwait(false)` 适当性的问题，有时您不希望使用它。特别是在事件处理程序中，特别是在 UI 代码中，您不希望调用
    `ConfigureAwait(false)`。想一想事件处理程序及其功能。它是响应某些用户操作（如按钮点击）而调用的，它设置状态、更新等待指示器、禁用用户不应与之交互的控件，发起调用，然后重置
    UI。所有这些工作都在 UI 线程上进行，正如它应该的那样。在这种情况下，您不希望使用 `ConfigureAwait(false)` 将其调度到 UI 线程之外，因为这将导致多线程
    UI 问题。
- en: Although library code should never know about a UI, there are times when the
    code should communicate progress or status. Rather than accessing UI code directly,
    there’s another way to communicate status, as discussed in the next section.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然库代码不应该知道 UI 的存在，但有时代码应该传达进度或状态。与其直接访问 UI 代码，还有另一种通信状态的方式，如下一节讨论的内容。
- en: See Also
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Recipe 1.5, “Designing Application Layers”](ch01.xhtml#designing_application_layers)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[食谱 1.5，“设计应用程序层”](ch01.xhtml#designing_application_layers)'
- en: '[Recipe 6.5, “Updating Progress Asynchronously”](#updating_progress_asynchronously)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[食谱 6.5，“异步更新进度”](#updating_progress_asynchronously)'
- en: 6.5 Updating Progress Asynchronously
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.5 异步更新进度
- en: Problem
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to display the status from an async task without blocking the UI thread.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在不阻塞 UI 线程的情况下显示来自异步任务的状态。
- en: Solution
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This class holds progress status info:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此类包含进度状态信息：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This method reports progress:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法报告进度：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here’s the program that initializes and consumes progress updates:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是初始化和消耗进度更新的程序：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Discussion
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: As explained in [Recipe 6.4](#writing_safe_async_libraries), library code should
    never update the UI directly. If properly written, it will be running on a separate
    thread and be oblivious to who its caller is. That said, there are times when
    the business layer or library code might want to inform a caller of progress or
    status. The solution shows a situation where an iterator updates the UI with progress,
    defined in the `CheckoutRequestProgress` class. Essentially, the library code
    defines what type of progress information it offers and the calling code works
    with that. In this case, it’s the total number of orders processed and some message
    indicating status.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [食谱 6.4](#writing_safe_async_libraries) 所述，库代码永远不应直接更新 UI。如果正确编写，它将在单独的线程上运行，并且对其调用者毫不知情。尽管如此，业务层或库代码可能希望通知调用者进度或状态。解决方案展示了一个场景，其中迭代器使用
    `CheckoutRequestProgress` 类定义的进度信息更新 UI。基本上，库代码定义了它提供的进度信息类型，调用代码与之配合使用。在这种情况下，它是处理的订单总数和某些表示状态的消息。
- en: The `GetRequestAsync` method accepts a parameter of `IProgress<CheckoutRequestProgress>`,
    `progress`. The `IProgress<T>` is part of the .NET Framework, as is the `Progress<T>`
    class, which implements `IProgress<T>`. With the progress instance, `GetRequestsAsync`
    calls `Report`, passing an instance of `CheckoutRequestProgress` with populated
    properties. This sends the progress to a handler in the UI.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetRequestAsync` 方法接受一个名为 `progress` 的 `IProgress<CheckoutRequestProgress>`
    参数。`IProgress<T>` 是 .NET Framework 的一部分，`Progress<T>` 类实现了 `IProgress<T>` 接口。使用
    `progress` 实例，`GetRequestsAsync` 调用 `Report` 方法，并传递一个已填充属性的 `CheckoutRequestProgress`
    实例。这将进度发送到 UI 中的处理程序。'
- en: The `Main` method sets up reporting by instantiating a `Progress<CheckoutRequest​Pro⁠gress>`
    and assigning it to `progress`, an `IProgress<CheckoutRequestProgress>`. The `Progress<T>`
    constructor accepts an `Action` delegate, and `Main` assigns a lambda that writes
    progress to the console. Every time `GetRequestsAsync` calls `Report`, this lambda
    executes. Going full circle, `Main` passes `progress` as an argument to the `Get​Re⁠questsAsync`
    call, so it can reference the same object to report on.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法通过实例化 `Progress<CheckoutRequest​Pro⁠gress>` 并将其分配给 `progress`，一个 `IProgress<CheckoutRequestProgress>`，设置了报告。`Progress<T>`
    构造函数接受一个 `Action` 委托，并且 `Main` 分配了一个写入控制台进度的 lambda。每当 `GetRequestsAsync` 调用 `Report`
    方法时，此 lambda 就会执行。回到起点，`Main` 将 `progress` 作为参数传递给 `Get​Re⁠questsAsync` 调用，以便它可以引用同一个对象进行报告。'
- en: You might have noticed that `GetRequestAsync` is running asynchronously, and
    the `await` on `GetNextBatchAsync` and `Task.Delay` also call `ConfigureAwait(false)`.
    If that code runs on another thread, other than the UI thread, what’s the possibility
    of a deadlock? None, because `Progress<T>` marshals the call back onto the UI
    thread so the code can safely interact with the UI. Remember, the library code,
    `GetRequests​A⁠sync`, has no knowledge of the lambda argument for the `Process<T>`
    constructor’s `Action` parameter. That means the lambda can safely access any
    UI code as necessary for displaying progress.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到`GetRequestAsync`在异步运行，并且`GetNextBatchAsync`和`Task.Delay`上的`await`也调用了`ConfigureAwait(false)`。如果该代码在除了
    UI 线程之外的其他线程上运行，死锁的可能性是多少？没有，因为`Progress<T>`将回调调度到 UI 线程，所以代码可以安全地与 UI 进行交互。请记住，库代码`GetRequest​Async`对于`Process<T>`构造函数的`Action`参数的
    lambda 参数没有任何了解。这意味着 lambda 可以安全地访问任何需要显示进度的 UI 代码。
- en: See Also
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 6.4, “Writing Safe Async Libraries”](#writing_safe_async_libraries)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 6.4 节，“编写安全的异步库”](#writing_safe_async_libraries)'
- en: 6.6 Calling Synchronous Code from Async Code
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.6 调用同步代码从异步代码
- en: Problem
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: The only code inside your async method is synchronous and you want to `await`
    it asynchronously.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您的异步方法中唯一的代码是同步的，并且您希望以异步方式`await`它。
- en: Solution
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This class demonstrates how to return asynchronous results from synchronous
    logic:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这节课展示了如何从同步逻辑中返回异步结果：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is the code that runs the app:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行应用程序的代码：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Discussion
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'For simplicity, previous sections of this chapter call synchronous code from
    asynchronous code. One of the things you might have noticed is that Visual Studio
    (same as other IDEs) shows green squiggly underlines when an async method doesn’t
    `await` anything. You’ll also receive the following warning:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，本章的前几节从异步代码中调用同步代码。你可能已经注意到，Visual Studio（与其他 IDE 相同）在异步方法没有任何`await`时会显示绿色波浪线。您还会收到以下警告：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It’s good the compiler emits this warning because it could be an error. It’s
    possible you forgot to add the `await` modifier to an async method call. In that
    case, program execution doesn’t stop at the awaited method. Both the async method
    and the code that calls it run. The async method that wasn’t awaited might not
    complete if the program exits.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器发出这个警告是件好事，因为这可能是个错误。有可能你忘记了在异步方法调用上添加`await`修饰符。在这种情况下，程序不会在等待的方法处停止执行。异步方法和调用它的代码都会运行。如果没有等待的异步方法可能不会在程序退出时完成。
- en: Another problem is that if the async method that wasn’t awaited throws an exception,
    it won’t be caught because the calling code continued to run. A similar problem
    happens with `async` `void` methods where you can’t `await` them and there’s no
    way to catch exceptions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是，如果未等待的异步方法抛出异常，那么它将无法捕获，因为调用代码继续运行。使用`async void`方法时也会遇到类似的问题，因为你无法`await`它们，也没有办法捕获异常。
- en: Warning
  id: totrans-134
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: A couple of places in this chapter describe compiler warnings associated with
    async code. In a lot of circumstances, these warnings represent error conditions.
    Too often, I’ve encountered applications with unmanageable warning walls. It’s
    as if the developers somehow don’t believe warnings are a problem or aren’t paying
    attention. Understanding the implications of how a warning could be serious, especially
    accidentally forgetting to `await` an async method or failing to add `ConfigureAwait(false)`,
    as described in [Recipe 6.4](#writing_safe_async_libraries), might provide the
    motivation to prioritize cleaning up and maintaining warnings.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的几处地方描述了与异步代码相关的编译器警告。在许多情况下，这些警告代表错误条件。我经常遇到应用程序有着无法管理的警告墙。好像开发人员以某种方式不认为警告是个问题或者没有在意。了解忘记`await`异步方法或未添加`ConfigureAwait(false)`的严重后果，正如[第
    6.4 节](#writing_safe_async_libraries)所述，可能会促使您优先清理和维护警告。
- en: Sometimes the code inside of an async method is genuinely synchronous. It might
    have originally been async but changed in maintenance, or you have to implement
    an interface. In this case, you have a couple of approaches. One is to remove
    the `async/await` keywords in the call chain until you reach a higher-level method
    that requires async. If there are multiple callers awaiting that method or it’s
    part of a public interface for multiple applications, you might not want to do
    that refactoring right away. The other approach, demonstrated in the solution,
    is to `await` `Task.FromResult<T>`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有时异步方法内部的代码确实是同步的。它原本可能是异步的，但在维护时被修改了，或者你必须实现一个接口。在这种情况下，你有几种方法。一种方法是在调用链中删除`async/await`关键字，直到达到需要异步的更高级别方法。如果有多个调用者等待该方法，或者它是多个应用程序的公共接口的一部分，你可能不想立即进行重构。另一种方法，在解决方案中演示的是`await
    Task.FromResult<T>`。
- en: You can see how this works in the `CheckoutService`, for `StartAsync`, where
    each method returns the result of awaiting `Task.FromResult<T>`. The `Task.From​Re⁠sult​<T>`
    method is generic, so you can use it on any type.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`CheckoutService`中的`StartAsync`方法中看到它是如何工作的，其中每个方法返回等待`Task.FromResult<T>`的结果。`Task.FromResult<T>`方法是泛型的，因此可以用于任何类型。
- en: Awaiting `Task.FromResult<T>` works when the method needs to return a value.
    However, the `FinalizeTaskAsync` method only returns `Task`. Notice how that method
    simply awaits `Task.CompletedTask`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当方法需要返回一个值时，`await Task.FromResult<T>`是有效的。然而，`FinalizeTaskAsync`方法只返回`Task`。请注意，该方法只是简单地等待`Task.CompletedTask`。
- en: One of the things you might be thinking is that this is extra work just to get
    rid of a warning. While that’s true, consider the benefits. You do clear the warning
    and enjoy the productivity boost in keeping the warning wall trimmed. More importantly,
    the code explicitly states its intention, and developers doing maintenance will
    clearly see there isn’t an error from a missing `await`—the code is correct.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为这是多余的工作，只是为了消除一个警告。虽然这是事实，但考虑一下其好处。你确实消除了警告，并且享受到了保持警告墙修剪带来的生产力提升。更重要的是，代码明确表达了其意图，进行维护的开发人员清楚地看到没有由于缺少`await`而导致的错误——代码是正确的。
- en: See Also
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 6.4, “Writing Safe Async Libraries”](#writing_safe_async_libraries)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 6.4, “编写安全的异步库”](#writing_safe_async_libraries)'
- en: 6.7 Waiting for Parallel Tasks to Complete
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.7 等待并行任务完成
- en: Problem
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have multiple tasks, running in parallel, and need to wait for all of them
    to complete before continuing.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你有多个任务，同时运行，并且需要等待它们全部完成后才能继续。
- en: Solution
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This code runs parallel tasks:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码运行并行任务：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here’s the app that requests and handles parallel task results:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是请求和处理并行任务结果的应用程序：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Discussion
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: When performing an action, such as shopping cart checkout, you don’t want the
    user to wait too long for the app to return. Running too many operations sequentially
    can make the wait longer. One of the ways to improve that user experience is to
    run independent operations concurrently.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行如购物车结账等操作时，你不希望用户等待应用程序太长时间才返回。依次运行太多操作可能会增加等待时间。改善用户体验的一种方法是并发地运行独立操作。
- en: In the solution, the `CheckoutService` has four different async services. Here
    we assume that three of those operations, `ValidateAddress​A⁠sync`, `ValidateCredit​A⁠sync`,
    and `GetShoppingCart​A⁠sync`, don’t have any dependencies on each other. This
    makes them good candidates for running at the same time.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中，`CheckoutService`有四个不同的异步服务。在这里我们假设其中三个操作，`ValidateAddressAsync`、`ValidateCreditAsync`和`GetShoppingCartAsync`，彼此之间没有任何依赖关系。这使它们成为同时运行的良好候选者。
- en: The `StartAsync` method does this by creating a `List<Task>`. If you recall,
    awaiting a method is really an `await` on the returned `Task`. Without the `await`,
    each method returns a `Task`, but its logic doesn’t run until that task is awaited.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`StartAsync`方法通过创建一个`List<Task>`来实现这一点。如果你回忆起来，等待一个方法实际上就是在返回的`Task`上进行`await`。没有`await`，每个方法都会返回一个`Task`，但其逻辑直到等待该任务后才会运行。'
- en: The `Task` class has a `WhenAll` method, whose purpose is to run all of the
    tasks, specified by the `checkoutTasks` argument, concurrently. `WhenAll` waits
    until all of the `Tasks` complete before returning.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task`类有一个`WhenAll`方法，其目的是并发地运行由`checkoutTasks`参数指定的所有任务。`WhenAll`会等待所有`Tasks`完成后才返回。'
- en: Awaiting a single method with a return type is straightforward from the perspective
    that you assign the return value to a single variable. However, when running tasks
    concurrently, you need to correlate responses because `WhenAll` returns all tasks
    at the same time. Making an assumption about which tasks occur in which position
    of the collection could be error prone and cumbersome in maintenance. The code
    needs to know which response goes with which `Task`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 等待具有返回类型的单个方法，从角度来看很简单，因为你可以将返回值分配给单个变量。然而，在并行运行任务时，你需要关联响应，因为`WhenAll`同时返回所有任务。假设哪些任务发生在集合的哪个位置可能会出现错误，并且在维护时可能会很繁琐。代码需要知道哪个响应对应哪个`Task`。
- en: The solution does this via a tuple, where the `string` is the name of the method
    and `bool` is the response. The tuple and choice of contents was specific for
    this demo, and you would shape the task type in whatever way that makes sense
    for your app. This lets us know which task goes with which result. The `GetResultsAsync`
    method does this by iterating through the task array, and building the `WhenAllResult`,
    based on the method parameter of each response.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案通过元组实现，其中`string`是方法的名称，`bool`是响应。该元组及其内容的选择是为了这个演示而特定的，你可以根据你的应用程序适当调整任务类型。这让我们知道哪个任务对应哪个结果。`GetResultsAsync`方法通过迭代任务数组，并根据每个响应的方法参数构建`WhenAllResult`来实现这一点。
- en: Notice that the first line of `ValidateAddressAsync` is a commented statement
    that throws an `ArgumentException`. Uncommenting and running the app again results
    in an exception during the call to `WhenAll`. The `Main` method handles that exception
    with a `catch` on `AggregateException`. Since all tasks are running concurrently,
    one or more of them could throw an exception. The `AggregateException` collects
    those exceptions. Normally, you would look in the `InnerException` property for
    exception details. However, `AggregateException` has another property, `InnerExceptions`.
    The difference is that the `AggregateException` property is plural, which is intentional.
    For proper debugging, you can find all exceptions in the `InnerExceptions` property.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`ValidateAddressAsync`的第一行是一个被注释的语句，抛出了一个`ArgumentException`。取消注释并重新运行应用程序会在调用`WhenAll`时导致异常。`Main`方法通过对`AggregateException`的`catch`处理该异常。由于所有任务都在并行运行，其中一个或多个任务可能会抛出异常。`AggregateException`收集这些异常。通常情况下，你可以在`InnerException`属性中查找异常详细信息。然而，`AggregateException`还有另一个属性，即`InnerExceptions`。它们之间的区别在于`AggregateException`的属性是复数形式，这是有意为之的。为了正确调试，你可以在`InnerExceptions`属性中找到所有异常。
- en: See Also
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 6.8, “Handling Parallel Tasks as They Complete”](#handling_parallel_tasks_as_they_complete)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 6.8, “处理并行任务的完成情况”](#handling_parallel_tasks_as_they_complete)'
- en: 6.8 Handling Parallel Tasks as They Complete
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.8 处理并行任务的完成情况
- en: Problem
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You thought calling `Task.WhenAny` would be an efficient use of resources for
    processing results as they complete, but cost and performance are terrible.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你以为调用`Task.WhenAny`会高效利用资源来处理任务完成时的结果，但实际上成本和性能都很糟糕。
- en: Solution
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This is a sequential implementation for calling multiple tasks:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个顺序实现，用于调用多个任务：
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here’s a parallel implementation for calling multiple tasks:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个并行实现，用于调用多个任务：
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The next implementation processes tasks in parallel but handles each one as
    it returns:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个实现将任务并行处理，但在每个任务返回时处理它们：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This method shows how to get the first task that completes:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法展示了如何获取首个完成的任务：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `Main` method offers a choice of which method to start with:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`方法提供了选择从哪个方法开始：'
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Discussion
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The problem in this section explores the role of `Task.WhenAny`. If you try
    to use `Task.WhenAny` for processing tasks as they return, you might be surprised
    because it doesn’t work the way you expect.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 本节问题探讨了`Task.WhenAny`的作用。如果你尝试使用`Task.WhenAny`来处理任务返回时的处理，可能会感到意外，因为它的工作方式不符合你的预期。
- en: For the most part, the concept and organization of this solution operates similar
    to [Recipe 6.7](#waiting_for_parallel_tasks_to_complete)—the difference being
    that this solution shows different ways to run tasks and explains what you need
    to know to make the proper design decisions.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在大部分情况下，这个解决方案的概念和组织方式与[Recipe 6.7](#waiting_for_parallel_tasks_to_complete)类似——不同之处在于，这个解决方案展示了运行任务的不同方法，并解释了你需要知道的以做出适当的设计决策。
- en: The `StartBigONAsync` method operates like previous sections of this chapter
    that ran sequentially. Its performance is O(N) because it processes N tasks, one
    after the other.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`StartBigONAsync` 方法的运行方式类似本章前面顺序运行的部分。其性能为 O(N)，因为它依次处理 N 个任务。'
- en: '[Recipe 6.7](#waiting_for_parallel_tasks_to_complete) showed how to speed up
    program execution when tasks don’t depend on each other. It uses `Task.WhenAll`,
    shown in `StartBigO1Async`. The performance boost comes from its approximately
    O(1) performance—instead of performing N operations, it does 1\. To be more accurate,
    this is O(2) because `FinalizeCheckout​A⁠sync` runs after the other three complete.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 6.7](#waiting_for_parallel_tasks_to_complete) 展示了如何在任务之间不互相依赖时加快程序执行。它使用了
    `Task.WhenAll`，在 `StartBigO1Async` 中展示。性能提升来自其近似 O(1) 的性能——不需要执行 N 次操作，只执行 1 次。更准确地说，这是
    O(2)，因为 `FinalizeCheckout​A⁠sync` 在其他三个任务完成后运行。'
- en: 'In addition to `Task.WhenAll`, you can use `Task.WhenAny`. It might be natural
    to think that `Task.WhenAny` is a good way to run multiple tasks in parallel and
    then be able to process each task while the others are running. However, `Task.WhenAny`
    doesn’t work the way you think it does. Look at `StartBigONSquaredAsync` and follow
    the following logic:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `Task.WhenAll`，你还可以使用 `Task.WhenAny`。可能自然而然地认为 `Task.WhenAny` 是并行运行多个任务并能在其他任务运行时处理每个任务的好方法。然而，`Task.WhenAny`
    并不像你想象的那样工作。看看 `StartBigONSquaredAsync` 并按照以下逻辑操作：
- en: The `while` loop iterates as long as `checkoutTasks` still has contents.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`while` 循环在 `checkoutTasks` 仍有内容时迭代。'
- en: '`Task.WhenAny` starts all of the tasks in parallel.'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Task.WhenAny` 启动所有任务并行运行。'
- en: The fastest task returns.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最快的任务返回。
- en: Since that task returned, remove it from `checkoutTasks` so we don’t run it
    again.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自从该任务返回后，从 `checkoutTasks` 中移除它，以免再次运行。
- en: Collect the results from that task.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集该任务的结果。
- en: Do the loop again on the remaining tasks or stop when `checkoutTasks` is empty.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次在剩余任务上执行循环，或在 `checkoutTasks` 为空时停止。
- en: The first surprising mental hurdle in this algorithm is incorrectly thinking
    that subsequent loops operate on the same tasks, each returning as they complete.
    The reality is that each subsequent loop starts a brand-new set of tasks. This
    is how async works—you can `await` a task multiple times, but each `await` starts
    a new task. That means the code continuously starts new instances of remaining
    tasks on every loop. This looping pattern, with `Task.WhenAny`, doesn’t result
    in the O(1) performance you might have expected, like with `Task.WhenAll`, but
    rather O(N²). This solution only has three tasks, but imagine how performance
    would increasingly suffer as the task list grows.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在该算法中的第一个令人惊讶的心理障碍是错误地认为后续循环操作相同的任务，每个任务完成后返回。实际情况是每个后续循环都会启动一组全新的任务。这就是异步工作的方式——你可以多次
    `await` 一个任务，但每个 `await` 都会启动一个新的任务。这意味着代码在每次循环时都会连续启动剩余任务的新实例。这种循环模式与 `Task.WhenAny`，不像
    `Task.WhenAll` 那样，不会产生你可能预期的 O(1) 性能，而是 O(N²)。尽管此解决方案只有三个任务，但想象一下任务列表增长时性能会如何逐渐下降。
- en: Note
  id: totrans-187
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This chapter discusses performance with Big O notation. Especially when looking
    at algorithms that are O(N²), there’s a threshold of when too many operations
    ruin performance. [Recipe 3.10](ch03.xhtml#measuring_performance) shows how to
    measure application performance and find what that threshold is, based on your
    performance requirements.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了使用大 O 表示法的性能问题。特别是在查看 O(N²) 的算法时，存在一种过多操作会破坏性能的阈值。[Recipe 3.10](ch03.xhtml#measuring_performance)
    展示了如何测量应用程序的性能，并根据你的性能要求找到该阈值。
- en: To pile on, take that number of tasks and multiply it by the number of checkout
    operations that occur over a period of time. Not only would your application performance
    be bad, you might slow down servers with excessive network traffic and endpoint
    server processing. This might affect not only your own system, but other systems
    running concurrently too. Also, think about times when those network requests
    might be to cloud services on a consumption plan and how expensive that would
    get. This particular use case might be considered an antipattern, unless it’s
    used with a small number of tasks where the impact is minimal.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，考虑在一段时间内对检查操作次数进行乘法运算，这些任务的数量会增加。你的应用性能不仅会变差，还可能通过过多的网络流量和端点服务器处理来减慢服务器。这不仅可能影响你自己的系统，还可能影响同时运行的其他系统。此外，考虑到网络请求可能是云服务在消耗计划上的情况，这可能会非常昂贵。在这种特定的用例中，除非使用较少的任务并且影响最小，否则可能被视为反模式。
- en: Warning
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: On the internet, you’ll find articles explaining `Task.WhenAny` as a technique
    for running tasks in parallel and processing each as they complete. While that
    might work for a few tasks, this section explains the hazards of using `Task.WhenAny`
    for that use case.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上，您会找到解释`Task.WhenAny` 作为一种在并行运行任务并在完成时处理每个任务的技术的文章。虽然这对于一些任务可能有效，但本节讲述了在该用例中使用`Task.WhenAny`
    的危险性。
- en: That said, there is a use case where `Task.WhenAny` is effective—first task
    wins. In the solution, there’s a `ValidateCreditAsync` method showing this strategy.
    The scenario is that you have multiple sources to learn if a customer has good
    credit and a response from any one of those sources is reliable. Each service
    has different performance characteristics and you’re only interested in the one
    that returns first. You can discard the rest. This keeps performance at O(1).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，`Task.WhenAny` 在某些情况下非常有效——第一个任务获胜。在解决方案中，`ValidateCreditAsync` 方法展示了这种策略。场景是您有多个源来判断客户是否有良好的信用，而且来自任何一个源的响应都是可靠的。每个服务具有不同的性能特征，您只关心返回最快的那个。您可以丢弃其余的响应。这保持了O(1)的性能。
- en: '`ValidateCreditAsync` has a list of tasks to run. `Task.WhenAny` runs those
    tasks in parallel and the first task to complete comes back. The code processes
    that task and returns.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValidateCreditAsync` 包含要运行的任务列表。`Task.WhenAny` 并行运行这些任务，并返回第一个完成的任务。代码处理该任务并返回。'
- en: The side effect in this solution is that tasks other than the first that returned
    continue running. However, you don’t have access to them because only one task
    is returned. For this scenario, you don’t care about those tasks but should stop
    them to avoid using more resources than necessary. You can learn how to do that
    in the next section on cancelling tasks.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 本解决方案的副作用是除了返回的第一个任务之外，其他任务仍在继续运行。但是，您无法访问它们，因为只返回一个任务。对于这种情况，您并不关心这些任务，但应停止它们以避免使用比必要更多的资源。您可以在下一节关于取消任务的部分中了解如何做到这一点。
- en: See Also
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 3.10, “Measuring Performance”](ch03.xhtml#measuring_performance)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[3.10章节，“性能测量”](ch03.xhtml#measuring_performance)的配方'
- en: '[Recipe 6.7, “Waiting for Parallel Tasks to Complete”](#waiting_for_parallel_tasks_to_complete)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[6.7章节，“等待并行任务完成”](#waiting_for_parallel_tasks_to_complete)的配方'
- en: '[Recipe 6.9, “Cancelling Async Operations”](#cancelling_async_operations)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[6.9章节，“取消异步操作”](#cancelling_async_operations)'
- en: 6.9 Cancelling Async Operations
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.9 取消异步操作
- en: Problem
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have an async process in progress and need to stop it.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在进行异步过程，并需要停止它。
- en: Solution
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This class demonstrates multiple ways to cancel tasks:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 该类演示了取消任务的多种方法：
- en: '[PRE25]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here’s the app that initializes cancellation and shows how to cancel:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这是初始化取消并展示如何取消的应用程序：
- en: '[PRE26]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Discussion
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '[Recipe 6.3](#creating_async_iterators) has an async iterator with a `while`
    loop that never ends. That worked for a demo, but real applications often need
    a way to stop long-running processes. Think about a dialog that pops up with ongoing
    process status and offers a Cancel button, allowing you to stop the operation.
    Task cancellation has been around since the introduction of TPL and is instrumental
    in cancelling async operations too.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[6.3章节](#creating_async_iterators)具有一个永不结束的`while` 循环异步迭代器。这在演示中起作用，但实际应用程序通常需要一种停止长时间运行过程的方式。想象一下弹出具有正在进行的过程状态并提供取消按钮的对话框，允许您停止操作。任务取消自TPL引入以来一直存在，并且在取消异步操作中也是至关重要的。'
- en: In the solution, the `Main` method shows how to initialize cancellation. The
    `Cancel​la⁠tionTokenSource`, `cancelSource`, provides both tokens and control
    over cancellation. See how the parameter to the `CheckoutStream` constructor is
    a `Cancellation​To⁠ken`, set via the `Token` property from `cancelSource`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中，`Main` 方法展示了如何初始化取消。`Cancel​la⁠tionTokenSource`，`cancelSource`，提供了取消令牌和取消控制。请看`CheckoutStream`
    构造函数的参数是通过`cancelSource` 的`Token` 属性设置的`Cancellation​To⁠ken`。
- en: Because `cancelSource` can manage cancellation for all the code in its scope,
    you can pass a `CancellationToken` as a parameter to any constructors or methods
    with a `Cancel​la⁠tionToken` parameter, allowing you to cancel any operations
    from a single place, `cancelSource`. The solution doesn’t have a button and cancels
    after processing 10 `CheckoutRequests`. You can see how that works with the `count`
    variable that’s incremented in each loop, checks the number of requests, and breaks
    out of the loop after `10`. This program never gets to `10` because of the check
    on `count >= 5`, calling `cancelSource.Cancel()`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `cancelSource` 可以管理其范围内所有代码的取消，所以可以将 `CancellationToken` 作为参数传递给任何具有 `CancellationToken`
    参数的构造函数或方法，允许您从单个位置 `cancelSource` 取消任何操作。解决方案没有按钮，并在处理了 10 个 `CheckoutRequests`
    后取消。您可以看到 `count` 变量在每个循环中增加，检查请求的数量，并在 `10` 之后中断循环。由于对 `count >= 5` 的检查，程序永远不会达到
    `10`，因此调用 `cancelSource.Cancel()`。
- en: The call to `cancelSource.Cancel` sends the message that the process should
    be cancelled, but you still have to write code that recognizes the need to cancel.
    It’s proper to cancel as soon as possible, and `GetRequestsAsync` has several
    checks on `cancelToken.IsCancellationRequested`. The `IsCancellationRequested`
    property is `true` when `Cancel` is called on the `CancellationTokenSource` instance
    that passed the `CancelToken`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `cancelSource.Cancel` 的调用发送了应取消处理的消息，但您仍然需要编写能够识别取消需求的代码。尽早取消是正确的，而 `GetRequestsAsync`
    在多个检查中使用了 `cancelToken.IsCancellationRequested`。当在传递 `CancelToken` 的 `CancellationTokenSource`
    实例上调用 `Cancel` 时，`IsCancellationRequested` 属性为 `true`。
- en: Inside the loop, `IsCancellationRequested` breaks. Outside the loop, `IsCancellationRequested`
    sends an `IProgress<T>` status message to let the caller know that the operation
    was properly cancelled.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，`IsCancellationRequested` 中断。在循环外部，`IsCancellationRequested` 发送一个 `IProgress<T>`
    状态消息，以通知调用者操作已经正确取消。
- en: The `GetNextBatchAsync` method shows another way to handle cancellation, by
    throwing an `OperationCancelledException`. If you recall, the reason a method
    throws is because it is unable to complete the operation it was designed to do.
    In this case, `GetNextBatchAsync` did not retrieve records, so this could be a
    semantically correct way to respond. Even if this wasn’t a design decision that
    you would make, consider that `GetNextBatchAsync` might `await` another method,
    passing its `cancelToken`. When cancelled, that awaited async method could throw
    `OperationCancelled​Excep⁠tion`. Therefore, when handling cancellation, it’s safe
    to anticipate and handle `OperationCancelledException`. The solution does this
    by wrapping the call to `GetNextBatchAsync` in a `try/catch`, breaking the loop,
    and letting existing code report the cancelled status to the caller.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetNextBatchAsync` 方法展示了另一种处理取消的方式，即抛出 `OperationCancelledException`。如果你回想一下，方法抛出异常是因为它无法完成设计的操作。在这种情况下，`GetNextBatchAsync`
    没有检索记录，因此这可能是一个语义上正确的响应方式。即使这不是您会做出的设计决策，也要考虑到 `GetNextBatchAsync` 可能会 `await`
    另一个方法，传递其 `cancelToken`。当取消时，等待的异步方法可能会抛出 `OperationCancelledException`。因此，在处理取消时，可以安全地预期和处理
    `OperationCancelledException`。解决方案通过将对 `GetNextBatchAsync` 的调用包装在 `try/catch`
    中来执行此操作，从而中断循环，并让现有代码向调用者报告取消状态。'
- en: Whenever cancelling an operation, you might also need to clean up resources.
    The next section, [Recipe 6.10](#disposing_async_resources), discusses how to
    do that.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在取消操作时，您可能还需要清理资源。下一节 [食谱 6.10](#disposing_async_resources) 将讨论如何做到这一点。
- en: See Also
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 6.3, “Creating Async Iterators”](#creating_async_iterators)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[食谱 6.3，“创建异步迭代器”](#creating_async_iterators)'
- en: '[Recipe 6.10, “Disposing of Async Resources”](#disposing_async_resources)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[食谱 6.10，“处理异步资源释放”](#disposing_async_resources)'
- en: 6.10 Disposing of Async Resources
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.10 处理异步资源释放
- en: Problem
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have an async process with resources that must be disposed.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 您有一个必须释放资源的异步处理过程。
- en: Solution
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This class shows how to properly implement the async dispose pattern:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此类展示了如何正确实现异步释放模式：
- en: '[PRE27]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here’s the app that demonstrates how to use an async disposable object:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是演示如何使用异步可释放对象的应用程序：
- en: '[PRE28]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Discussion
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '[Recipe 1.1](ch01.xhtml#managing_object_lifetime) describes the dispose pattern
    and how it solves the problem of releasing resources when an object lifetime ends.
    That works well for synchronous code but not for asynchronous code. This section
    shows how to dispose of async resources with the async dispose pattern.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 1.1](ch01.xhtml#managing_object_lifetime)描述了释放资源的模式以及它如何解决对象生命周期结束时释放资源的问题。这对于同步代码很有效，但对于异步代码则不然。本节展示了如何使用异步释放模式释放异步资源。'
- en: 'In the solution, `CheckoutStream` has two fields: a `FileStream`, `asyncDisposeObj`,
    and an `HttpClient`, `syncDisposeObj`. Normally these would have names representing
    their purpose in the application, but in this instance, their names represent
    how they’re used in the solution to help follow a complex set of logic. As their
    names suggest, `asyncDisposeObj` references a resource that must be disposed of
    asynchronously; `syncDisposeObj` references a resource that must be disposed of
    synchronously. It’s important to think about both asynchronous and synchronous
    disposal at the same time, because it explains why their disposal processes are
    now intertwined.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中，`CheckoutStream`有两个字段：一个`FileStream`，`asyncDisposeObj`，和一个`HttpClient`，`syncDisposeObj`。通常，它们应该具有表示它们在应用程序中用途的名称，但在这种情况下，它们的名称表示它们在解决方案中如何帮助遵循复杂的逻辑集。正如它们的名称所示，`asyncDisposeObj`引用必须异步处理的资源；`syncDisposeObj`引用必须同步处理的资源。同时考虑异步和同步处理非常重要，因为这解释了为什么它们的处理过程现在是交织在一起的。
- en: For asynchronous and synchronous disposal, `CheckoutService` implements `IAsyncDisposable`
    and `IDisposable`, respectively. As discussed in [Recipe 1.1](ch01.xhtml#managing_object_lifetime),
    `IDisposable` specifies that classes must implement `Dispose`, with no parameters,
    and we add a virtual `Dispose(bool)`, with a `bool` parameter, and an optional
    destructor to implement the pattern. The solution doesn’t implement the optional
    destructor. For `IAsyncDisposable`, `CheckoutService` implements the required
    `DisposeAsync` method and a virtual `DisposeAsyncCore` method, neither of which
    have parameters.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 对于异步和同步释放，`CheckoutService`分别实现了`IAsyncDisposable`和`IDisposable`。正如在[Recipe
    1.1](ch01.xhtml#managing_object_lifetime)中讨论的那样，`IDisposable`指定类必须实现没有参数的`Dispose`，并且我们添加了一个带有`bool`参数的虚拟`Dispose(bool)`以及一个可选的析构函数来实现该模式。解决方案没有实现可选的析构函数。对于`IAsyncDisposable`，`CheckoutService`实现了必需的`DisposeAsync`方法和一个虚拟的`DisposeAsyncCore`方法，两者都没有参数。
- en: Both disposal paths, asynchronous and synchronous, could run, so they both must
    be prepared to release resources. On the synchronous path, `Dispose(bool)` not
    only calls `Dispose` on `syncDisposeObj`, but also attempts to call `Dispose`
    on `asyncDisposeObj`. Notice that `Dispose(bool)` also calls `DisposeThisObject`,
    which holds the same code that the asynchronous path needs to call too—it reduces
    duplication.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 异步和同步两条处理路径都可能运行，因此它们都必须准备好释放资源。在同步路径上，`Dispose(bool)`不仅调用`syncDisposeObj`的`Dispose`，还尝试调用`asyncDisposeObj`的`Dispose`。请注意，`Dispose(bool)`还调用`DisposeThisObject`，其中包含异步路径需要调用的相同代码，从而减少了重复。
- en: While `Dispose` and `DisposeAsync` are interface members, `Dispose(bool)` and
    `DisposeAsyncCore` are conventions. Also notice that they’re both `virtual`. This
    is part of the pattern, where derived classes can implement disposal by overriding
    these methods and calling them, via `base.Dispose(bool)` and `base.DisposeAsyncCore`,
    to ensure release of resources up the entire inheritance hierarchy.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Dispose`和`DisposeAsync`是接口成员，但`Dispose(bool)`和`DisposeAsyncCore`是约定俗成的。还要注意它们都是`virtual`的。这是模式的一部分，派生类可以通过重写这些方法并调用它们，通过`base.Dispose(bool)`和`base.DisposeAsyncCore`来确保释放整个继承层次结构中的资源。
- en: Both `Dispose` and `DisposeAsync` call `Dispose(bool)`, but `DisposeAsync` sets
    the `disposing` argument to `false`. If you recall, `disposing` is a flag for
    `Dispose(bool)` to release managed resources when set to `true`. Remember that
    `Dispose(bool)` is the synchronous path. Instead, `DisposeAsync` calls `DisposeAsyncCore`
    to release asynchronous resources.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dispose`和`DisposeAsync`都调用`Dispose(bool)`，但`DisposeAsync`将`disposing`参数设置为`false`。如果回想一下，`disposing`是`Dispose(bool)`在设置为`true`时释放托管资源的标志。请记住，`Dispose(bool)`是同步路径。相反，`DisposeAsync`调用`DisposeAsyncCore`释放异步资源。'
- en: As with `Dispose(true)`, `DisposeAsyncCore` attempts to release all managed
    resources. The async case is obvious. However, synchronous objects have a couple
    of possibilities. What if the synchronous object, now or in the future, implements
    `IAsyncDisposable`? Then, attempting to call `DisposeAsync` is the better choice
    when the code is on the asynchronous path. Otherwise, call the synchronous path,
    with `Dispose`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Dispose(true)`一样，`DisposeAsyncCore`尝试释放所有托管资源。异步情况很明显。然而，同步对象有几种可能性。如果同步对象当前或将来实现了`IAsyncDisposable`，那么在代码处于异步路径时尝试调用`DisposeAsync`是更好的选择。否则，调用同步路径，使用`Dispose`。
- en: As mentioned, both `Dispose(bool)` and `DisposeAsyncCore` call `DisposeThisObject`.
    In the solution scenario, the `GetRequestsAsync` iterator implements cancellation,
    as explained in [Recipe 6.9](#cancelling_async_operations). Depending on the situation,
    it might be good to cancel during the dispose process. For instance, what if the
    code needs to persist its latest good state or has a closure protocol with a network
    endpoint? It’s good to think through your situation, and the dispose and async
    dispose patterns can help.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，`Dispose(bool)`和`DisposeAsyncCore`都调用`DisposeThisObject`。在解决方案场景中，`GetRequestsAsync`迭代器实现了取消操作，如[第6.9节](#cancelling_async_operations)中所解释的那样。根据情况，可能在处理释放过程中取消是个不错的选择。例如，如果代码需要保存其最新的良好状态或者与网络端点有闭包协议，思考清楚是很重要的，而且释放和异步释放模式能帮助到你。
- en: Finally, notice how the `Main` method awaits a using statement on the `CheckoutStream`
    instance. This is the same `using` statement discussed in [Recipe 2.2](ch02.xhtml#simplifying_instance_cleanup),
    except that now it has an `await`. This ensures the code calls `DisposeAsync`
    at the end of the `Main` method.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意`Main`方法如何在`CheckoutStream`实例上等待使用语句。这与[第2.2节](ch02.xhtml#simplifying_instance_cleanup)中讨论的相同的`using`语句类似，只是现在有一个`await`。这确保代码在`Main`方法结束时调用`DisposeAsync`。
- en: See Also
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 1.1, “Managing Object End-of-Lifetime”](ch01.xhtml#managing_object_lifetime)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1.1节，“管理对象生命周期结束”](ch01.xhtml#managing_object_lifetime)'
- en: '[Recipe 2.2, “Simplifying Instance Cleanup”](ch02.xhtml#simplifying_instance_cleanup)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2.2节，“简化实例清理”](ch02.xhtml#simplifying_instance_cleanup)'
- en: '[Recipe 6.9, “Cancelling Async Operations”](#cancelling_async_operations)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[第6.9节，“取消异步操作”](#cancelling_async_operations)'
