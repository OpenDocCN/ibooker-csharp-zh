- en: Chapter 7\. Manipulating Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第七章 操控数据
- en: Every application uses data, and we need to manipulate that data from one form
    to another. This chapter offers several topics on data transformation in areas
    such as secret management, JSON serialization, and XML serialization.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都使用数据，并且我们需要将数据从一种形式转换为另一种形式。本章提供了关于数据转换的多个主题，如机密管理、JSON序列化和XML序列化。
- en: Secrets are data, such as passwords or API keys, that we don’t want to expose
    to third parties. This chapter has three sections on managing secrets for hashing,
    encryption, and hidden storage.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 机密信息是我们不希望向第三方公开的数据，例如密码或API密钥。本章包括三节关于管理这些机密信息的内容，包括哈希处理、加密和隐藏存储。
- en: Much of the data we work with today is in JSON format. Basic serialization/deserialization
    is simple in modern frameworks, and it’s even simpler when you own both the data
    consumer and provider. When consuming third-party data, you don’t have control
    over that data’s consistency or standards. That’s why the JSON sections of this
    chapter drill down on customizations to help you handle JSON in whatever format
    you need.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当今我们处理的许多数据都是以JSON格式。在现代框架中，基本的序列化/反序列化操作很简单，如果你同时拥有数据的消费者和提供者，这一切会更加简单。但是当你处理第三方数据时，你无法控制数据的一致性或标准。因此，本章的JSON部分深入探讨了定制方法，帮助你处理任何你需要的JSON格式数据。
- en: Finally, although JSON has a dominant place among internet data formats today,
    there’s still plenty of XML data to work with, which is the subject of the XML
    sections. You’ll see another flavor of LINQ, called LINQ to XML, which gives you
    full control over the serialization/deserialization process.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尽管JSON在当前互联网数据格式中占据主导地位，但仍然有大量XML数据需要处理，这是XML章节的主题。你将看到LINQ的另一种风格，称为LINQ
    to XML，它可以完全控制序列化/反序列化过程。
- en: 7.1 Generating Password Hashes
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.1 生成密码哈希
- en: Problem
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to securely store user passwords.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要安全地存储用户密码。
- en: Solution
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This method generates a random salt to protect secrets:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法生成一个随机盐来保护秘密：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The next two methods use that salt to generate hashes:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两种方法使用该盐生成哈希值：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And here’s how to use the methods to generate hashes:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何使用方法生成哈希值：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Discussion
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: ASP.NET identity has nice support for password and group/role management, which
    should be on anyone’s list of considerations when planning a new project. However,
    there are a lot of situations where ASP.NET identity won’t be the best option,
    for instance, when you have to use a database that ASP.NET identity doesn’t support
    or must use an existing database with its own homegrown password management.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Identity对密码和组/角色管理提供了很好的支持，这应该是在规划新项目时考虑的要点之一。然而，在某些情况下，例如当你必须使用ASP.NET
    Identity不支持的数据库或必须使用具有自己自制密码管理系统的现有数据库时，ASP.NET Identity可能不是最佳选择。
- en: 'When building a custom password management solution, best practice is to hash
    the password with a salt. A hash is a one-way translation of a password to a string
    of unintelligible characters. Every time you hash a specific password, you always
    get the same hash. That said, an important difference from encryption is that
    you can’t decrypt a hash—there’s no way to translate a hash back into the original
    password. That begs the question of how to know if the user enters the correct
    password. Since this is a book on C#, database development is out of scope. That
    said, here are the steps required to verify a password:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建自定义密码管理解决方案时，最佳实践是使用盐对密码进行哈希处理。哈希是将密码单向转换为一串无法理解的字符。每次你对特定密码进行哈希处理时，都会得到相同的哈希值。然而，与加密的重要区别在于你无法解密哈希值——没有办法将哈希值翻译回原始密码。这就引出了一个问题：如何知道用户输入了正确的密码。由于本书主要讲解C#，数据库开发超出了本书的范围。尽管如此，在这里我们列出了验证密码所需的步骤：
- en: When you create the user account, hash the password and store the hash in the
    database with the username.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用户账户时，对密码进行哈希处理，并将哈希值与用户名一起存储在数据库中。
- en: When the user logs in, they provide the username and password.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户登录时，他们提供用户名和密码。
- en: With the username, your code makes a database query and retrieves the matching
    hash.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用用户名，你的代码进行数据库查询，并检索匹配的哈希值。
- en: Hash the password the user entered.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对用户输入的密码进行哈希处理。
- en: Compare the hashed passwords.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较哈希密码。
- en: If the password hashes match, validation succeeds—otherwise validation fails.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果密码哈希匹配，则验证成功——否则验证失败。
- en: Security is a constant game of cat and mouse. As soon as we learned to protect
    passwords with hashes, hackers looked for ways to break through that. Ultimately,
    the best we can do is to find a level of security that makes it prohibitively
    expensive for hackers, based on our need to protect the information compared to
    the hacker’s desire to obtain it. How much security can you afford?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是一场持续的猫鼠游戏。我们刚刚学会用哈希保护密码，黑客们就寻找方法突破它。最终，我们能做的最好的事情就是找到一定程度的安全性，使得黑客因我们需要保护信息而愿意获取它的成本变得非常高昂。您能承受多少安全性成本？
- en: Fortunately, there’s an easy way to beef up password security. A security best
    practice around hashed passwords is to include a salt, a random array of bytes
    appended to a password. We save the salt in the database, along with the username
    and password. This is effective in protecting against a rainbow attack, described
    in the note. The `GenerateSalt` method in the solution produces a random 64-byte
    value. The salt prevents a rainbow attack and forces the hacker to drop down to
    a dictionary attack, which is much more compute-intensive.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个简单的方法来加强密码安全性。在处理哈希密码的安全最佳实践中，包含盐（salt）是一种方法，盐是追加到密码后的随机字节数组。我们将盐和用户名、密码一起保存在数据库中。这对于防范彩虹表攻击非常有效，详见注释。解决方案中的`GenerateSalt`方法生成一个随机的64字节值。盐可以防止彩虹表攻击，并迫使黑客转向更为计算密集的字典攻击。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注释
- en: 'If a hacker breaks into your system or figures out how to get a copy of the
    table holding passwords, there are a couple of common attacks: dictionary and
    rainbow.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果黑客侵入您的系统或者找到了存储密码的表格的副本，那么常见的攻击有两种：字典攻击和彩虹表攻击。
- en: 'In a dictionary attack, the hacker has a dictionary of words and phrases and
    iterates through that list, hashing each item and comparing to the database table.
    For all the complexity rules and the number of people who follow them, there are
    always some people that use single-word passwords. Spoiler alert: for all the
    people who think they’re clever with the symbol/number character replacements—that
    doesn’t work; the hacker’s dictionaries and algorithms already account for that.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典攻击中，黑客拥有一个包含单词和短语的字典列表，并逐个对列表中的项进行哈希处理，然后与数据库表进行比较。尽管有所有的复杂规则和遵循这些规则的人数，总会有些人使用单个单词密码。剧透警告：对于那些认为用符号/数字字符替换会变得聪明的人，这种方法行不通；黑客的字典和算法已经考虑到了这一点。
- en: The rainbow attack is another variation of the dictionary attack, and the difference
    is that the rainbow attack already hashed common words, so all they need is a
    simple comparison to move through the password table quicker.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 彩虹表攻击是字典攻击的另一种变体，其区别在于彩虹表已经对常见单词进行了哈希处理，因此他们只需进行简单的比较即可快速地遍历密码表。
- en: Both the `GenerateMD5Hash` and `GenerateSha256` hash methods accept a password
    and a salt. Both methods translate the password into a `byte[]`, concatenate the
    password and hash, and generate a hash. The syntactic difference between the MD5
    and SHA256 implementations is the `MD5CryptoServiceProvider` versus the `SHA256​Cryp⁠to​ServiceProvider`,
    respectively.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`GenerateMD5Hash`和`GenerateSha256`哈希方法都接受一个密码和一个盐。这两种方法都将密码转换为`byte[]`，连接密码和盐，然后生成一个哈希。MD5和SHA256实现之间的语法差异在于`MD5CryptoServiceProvider`与`SHA256​Cryp⁠to​ServiceProvider`。'
- en: In practice, there are different reasons to use specific hash algorithms. The
    .NET Framework has several hash algorithms, which you can find by looking up `HashAlgorithm`
    and examining its derived classes. Many recent implementations use the SHA256
    hash because it provides better protection than earlier hash algorithms. I included
    the MD5 algorithm to make the point that you don’t always have the luxury of selecting
    the algorithm because the password table might have already been created using
    MD5\. In this case, the inconvenience to users might preclude the need for them
    to reenter passwords to accommodate another hash algorithm.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，有不同的原因使用特定的哈希算法。.NET框架有几种哈希算法，你可以通过查找`HashAlgorithm`并检查其派生类来找到这些算法。许多最近的实现使用SHA256哈希，因为它比早期的哈希算法提供更好的保护。我包括MD5算法是为了说明你并不总是能够选择算法，因为密码表可能已经使用MD5创建。在这种情况下，对用户的不便可能会阻止他们重新输入密码以适应另一种哈希算法。
- en: The `Main` method demonstrates how to use these algorithms to generate hashes.
    An interesting bit here is calling `Convert.ToBase64String`. Anytime you’re moving
    data from one place to another, the transport mechanism has a protocol and format
    based on special characters. If the characters in the hashed bytes translate into
    special characters during transport, the software will break. A standard way to
    work around this is to use a data format known as Base64, which generates characters
    that won’t conflict with special data format or transport protocol characters.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法演示如何使用这些算法生成哈希值。这里的一个有趣之处是调用 `Convert.ToBase64String`。每当你在不同地方传输数据时，传输机制都有一套基于特殊字符的协议和格式。如果哈希字节中的字符在传输过程中转换为特殊字符，软件将会出现问题。解决这个问题的标准方法是使用一种名为
    Base64 的数据格式，它生成的字符不会与特殊的数据格式或传输协议字符冲突。'
- en: 7.2 Encrypting and Decrypting Secrets
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.2 加密和解密机密信息
- en: Problem
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have API keys that need to be encrypted at rest.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你有需要在静态状态下加密的 API 密钥。
- en: Solution
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This class encrypts and decrypts secrets:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类用于加密和解密机密信息：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here’s a method that generates a random key:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个生成随机密钥的方法：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here’s how to use the `Crypto` class and a random key to encrypt and decrypt
    secrets:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Crypto` 类和随机密钥加密和解密机密信息的方法如下：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Discussion
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: We often have secrets—API keys or other sensitive information—to protect. Encryption
    is how we protect information at rest. Before saving, we encrypt the data, and
    after retrieving the encrypted data, we decrypt it for use.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常有需要保护的秘密信息——API 密钥或其他敏感信息。加密是在静止状态下保护信息的方法。在保存之前，我们对数据进行加密，然后在检索加密数据后，我们对其进行解密以供使用。
- en: In the solution, the `Crypto` class has methods to encrypt and decrypt data.
    The `key` parameter is a secret value used by the encryption/decryption algorithms.
    We’ll be using a technique called *symmetric key encryption*, where we use a single
    key to encrypt/decrypt all the data. Clearly, you don’t store the encryption key
    in the same place as the data because if a hacker is able to read the data, they
    would also need to figure out where the encryption key is. In this demo, the `GenerateKey`
    method produces a random 32-bit key, required by the crypto provider.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中，`Crypto` 类具有加密和解密数据的方法。`key` 参数是加密/解密算法使用的秘密值。我们将使用称为 *对称密钥加密* 的技术，其中我们使用单个密钥来加密/解密所有数据。显然，你不应将加密密钥存储在与数据相同的位置，因为如果黑客能够读取数据，他们还需要找出加密密钥所在的位置。在此演示中，`GenerateKey`
    方法生成一个随机的 32 位密钥，加密提供程序所需。
- en: The crypto provider is the code that uses a special algorithm to encrypt/decrypt
    data. The solution example uses Advanced Encryption Standard (AES), which is a
    modern and secure encryption algorithm.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 加密提供程序是使用特殊算法加密/解密数据的代码。解决方案示例使用了先进加密标准 (AES)，这是一种现代和安全的加密算法。
- en: When saving the data, you pass the `plainText` string, along with the `key`,
    into the `Encrypt` method. Calling `AES.Create` returns an instance of `AES`.
    The value stored in the database is the concatenated initialization vector (IV)
    and encrypted text. Notice how the `memStream` first loads the IV from the `AES`
    instance.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存数据时，你将 `plainText` 字符串与 `key` 一起传递到 `Encrypt` 方法中。调用 `AES.Create` 返回 `AES`
    的一个实例。存储在数据库中的值是连接的初始化向量 (IV) 和加密文本。注意 `memStream` 首先从 `AES` 实例加载 IV 的方式。
- en: The three arguments to `CryptoStream` are the `memStream` (containing the IV),
    an `ICryptoTransform` (returned by the call to `AES.CreateEncryptor`), and a `Crypto​S⁠treamMode`
    (indicating that we’re writing to the stream). The `cryptoStream` instance will
    append encrypted bytes to the IV in `memStream`. We’re working with `byte[]` representations
    of the data, including `plainText`. Calling `Write` on `cryptoStream` performs
    the encryption, and calling `FlushFinalBlock` ensures all the bytes are processed
    and pushed into `memStream`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`CryptoStream` 的三个参数是 `memStream`（包含 IV）、`ICryptoTransform`（通过调用 `AES.CreateEncryptor`
    返回）、以及 `Crypto​S⁠treamMode`（指示我们正在向流中写入）。`cryptoStream` 实例将加密后的字节追加到 `memStream`
    中的 IV。我们使用数据的 `byte[]` 表示，包括 `plainText`。在 `cryptoStream` 上调用 `Write` 执行加密，在调用
    `FlushFinalBlock` 确保所有字节都被处理并推送到 `memStream` 中。'
- en: The `Decrypt` method reverses this process. In addition to the `key`, which
    is the same key used to encrypt, there’s a `cypherBytes` parameter. If you recall
    from the `Encrypt` process, the encrypted value includes both the IV and the appended
    encrypted value, and these are the contents of `cypherBytes`. After loading `memStream`
    with `cypherBytes`, the code repositions `memStream` to the beginning and extracts
    the IV into `iv`. This leaves the `memStream` positioned at `iv.Length`, where
    the encrypted value begins.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Decrypt` 方法反转了这个过程。除了与加密时相同的 `key` 外，还有一个 `cypherBytes` 参数。如果您回忆一下 `Encrypt`
    过程，加密值包括 IV 和附加的加密值，这些是 `cypherBytes` 的内容。加载了 `cypherBytes` 到 `memStream` 后，代码将
    `memStream` 重新定位到开头，并将 IV 提取到 `iv` 中。这样 `memStream` 就位于 IV 的长度处，加密值从这里开始。'
- en: This time, `cryptoStream` uses the encrypted text (`memStream` positioned appropriately).
    Here, `ICryptoTransform` is different because we call `CreateDecryptor` with `iv`
    and `key`. Also, the `CryptoStreamMode` needs to be `Read`. Calling `Read` on
    `cryptoStream` performs the decryption.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`cryptoStream` 使用了加密文本（`memStream` 适当位置）。在这里，`ICryptoTransform` 不同，因为我们使用
    `iv` 和 `key` 调用 `CreateDecryptor`。此外，`CryptoStreamMode` 需要设置为 `Read`。在 `cryptoStream`
    上调用 `Read` 执行解密操作。
- en: The `Main` method shows how to use the `Encrypt` and `Decrypt` methods. Notice
    that it uses the same `key` for both. The `Convert.ToBase64String` ensures we
    can work with the data without random bytes being interpreted in unexpected ways.
    For instance, if you print a binary file to the console, you might hear dings
    because some of the bytes were interpreted as bell characters. Also, when transporting
    data, Base64 helps avoid bytes being interpreted as transport protocol or formatting
    characters, which breaks code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法展示了如何使用 `Encrypt` 和 `Decrypt` 方法。请注意，它们都使用相同的 `key`。`Convert.ToBase64String`
    确保我们可以处理数据，避免随机字节被意外解释。例如，如果将二进制文件打印到控制台，可能会听到响声，因为某些字节被解释为响铃字符。此外，在传输数据时，Base64
    可以避免字节被解释为传输协议或格式字符，从而破坏代码。'
- en: 7.3 Hiding Development Secrets
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.3 隐藏开发秘密
- en: Problem
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to avoid accidentally checking secrets, like passwords and API keys,
    into source control.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要避免将密码和 API 密钥等秘密信息意外提交到源代码控制中。
- en: Solution
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s the project file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是项目文件：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This code shows how easy it is to add code supporting hidden secrets:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何轻松添加支持隐藏秘密的代码：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Discussion
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: This is so common, where developers accidentally check database connection strings
    from configuration files into source control. Another frequent issue is when a
    developer needs help in an online forum and accidentally leaves secrets in their
    code sample. Hopefully, it’s clear that these mistakes have the potential for
    grave damage to an application or even a business.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是很常见的问题，开发人员意外将数据库连接字符串从配置文件提交到源代码控制中。另一个常见问题是，开发人员在在线论坛寻求帮助时，在其代码示例中意外留下了秘密。希望能清楚地看到这些错误可能对应用程序甚至业务造成严重损害。
- en: One solution for this is to use the Secret Manager. While the Secret Manager
    is normally associated with ASP.NET because of built-in configuration support,
    you can use it with any type of application. The solution shows how easy it is
    to use the secret manager with a console application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种解决方案是使用 Secret Manager。虽然 Secret Manager 通常与 ASP.NET 关联紧密，因为它具有内置的配置支持，但您可以将其与任何类型的应用程序一起使用。该解决方案展示了如何在控制台应用程序中轻松使用
    Secret Manager。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This is a feature that’s useful for working in a development environment. In
    production, you would want to use a more secure option, for instance, Key Vault
    if you were deploying to Azure. Holding secrets in environment variables is another
    way to avoid storing them in code or configuration.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在开发环境中非常有用的功能。在生产环境中，您可能希望使用更安全的选项，例如，如果您部署到 Azure，则可能会使用密钥保管库（Key Vault）。将机密保存在环境变量中是避免将其存储在代码或配置中的另一种方式。
- en: 'Some project types, such as ASP.NET already have support for ensuring you don’t
    accidentally put development code in production, like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有些项目类型，如 ASP.NET，已经支持确保不会意外将开发代码部署到生产环境中，例如：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can set up an application to use Secret Manager with the dotnet CLI. The
    first thing is to update the project by typing this on the command line:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 dotnet CLI 配置应用程序以使用 Secret Manager。第一步是通过命令行更新项目：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'That adds a `UserSecretsID` tag to the project file, as previously shown. That
    GUID identifies the location in your file system where the secrets are stored.
    In this example, that location is:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这在项目文件中添加了一个`UserSecretsID`标签，如前所示。该GUID标识了存储秘密的文件系统位置。在这个示例中，该位置是：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'on Windows or:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上或：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: for Linux or macOS machines.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux或macOS机器。
- en: 'After setting up, you can start adding secrets, like this (in the same location
    as the project folder):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完成后，您可以开始添加秘密，就像这样（与项目文件夹相同的位置）：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can verify that the secret was saved by looking at `secrets.json` or the
    following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看`secrets.json`或以下命令来验证已保存的秘密：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `Main` method shows how to read Secret Manager keys. Remember to reference
    the `Microsoft.Extensions.Hosting` NuGet package. Just call `AddUserSecrets` on
    a new `ConfigurationBuilder`. Calling `Build` on that returns an `IConfigurationRoot`
    instance that provides indexer support for reading keys.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`方法展示了如何读取秘密管理器的密钥。记得引用`Microsoft.Extensions.Hosting` NuGet包。只需在新的`ConfigurationBuilder`上调用`AddUserSecrets`。在其上调用`Build`返回一个`IConfigurationRoot`实例，提供索引器支持以读取键。'
- en: 7.4 Producing JSON
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.4 生成JSON
- en: Problem
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to customize JSON output formatting.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要自定义JSON输出格式。
- en: Solution
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This code shows what a `PurchaseOrder` looks like:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码显示了`PurchaseOrder`的外观：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This code serializes a `PurchaseOrder`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码序列化了`PurchaseOrder`：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here’s how to populate a `PurchaseOrder`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何填充`PurchaseOrder`的方法：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `Main` method drives the process:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`方法驱动该过程：'
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And here’s the output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Discussion
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Just calling `JsonSerializer.Serialize`, from the `System.Text.Json` namespace,
    is a simple and quick way to serialize objects into JSON. If you own the producing
    and consuming parts of an application, this might be the way to go for simplicity
    and speed. However, it’s often the case that you’re consuming a third-party API
    that specifies its own JSON data format. Additionally, its naming convention won’t
    match C# Pascal-cased property names. This section shows how to perform those
    serializer output customizations.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 只需调用`JsonSerializer.Serialize`，来自`System.Text.Json`命名空间，这是将对象序列化为JSON的简单快速方法。如果您拥有应用程序的生产和消费部分，这可能是简单和快速的选择。但通常情况下，您会消费一个指定其自己JSON数据格式的第三方API。此外，其命名约定与C#
    Pascal大小写属性名称不匹配。本节显示如何执行这些序列化器输出的自定义。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Microsoft introduced the `System.Text.Json` namespace in .NET Core 3\. Previously,
    a popular choice was the excellently supported `Newtonsoft.Json` library.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft在.NET Core 3中引入了`System.Text.Json`命名空间。此前，一个广受欢迎的选择是得到了出色支持的`Newtonsoft.Json`库。
- en: In the solution scenario, we want to send a JSON document to an API, but the
    property names don’t match. That’s why `PurchaseOrder` (and supporting types)
    decorates properties with the `JsonPropertyName` attribute. The `JsonSerializer`
    uses `JsonPropertyName` to specify the output property name.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案场景中，我们希望将JSON文档发送到API，但属性名称不匹配。这就是为什么`PurchaseOrder`（及其支持类型）使用`JsonPropertyName`属性装饰属性。`JsonSerializer`使用`JsonPropertyName`指定输出属性名称。
- en: The `PurchaseOrderService` has a `View` method that serializes a `PurchaseOrder`.
    By default, the serializer output is a single line and we want to see formatted
    output. The code uses a `JsonSerializerOption`, with `WriteIndented` set to true,
    producing the output shown in the solution.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`PurchaseOrderService`有一个`View`方法，可以序列化`PurchaseOrder`。默认情况下，序列化器输出是单行的，我们希望看到格式化输出。代码使用了一个`JsonSerializerOption`，其中`WriteIndented`设置为`true`，产生了解决方案中显示的输出。'
- en: The `Main` method drives the process, getting a new `PurchaseOrder` and then
    calling `View` to print out the results.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`方法驱动该过程，获取一个新的`PurchaseOrder`，然后调用`View`打印出结果。'
- en: Sometimes, APIs grow organically and their naming conventions lack consistency,
    making this the ideal approach to customizing output. However, if you are using
    an API with a consistent naming convention, [Recipe 7.5](#consuming_json) explains
    how to build a converter to avoid decorating every property with `JsonPropertyName`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，API会有机地增长，它们的命名约定缺乏一致性，这使得自定义输出的理想方法。但是，如果您使用的是具有一致命名约定的API，[7.5章](#consuming_json)解释了如何构建转换器以避免为每个属性都装饰`JsonPropertyName`。
- en: See Also
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 7.5, “Consuming JSON”](#consuming_json)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[7.5章，“消费JSON”](#consuming_json)'
- en: 7.5 Consuming JSON
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.5 消费JSON
- en: Problem
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to read a JSON object that doesn’t fit default deserialization options.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要读取不符合默认反序列化选项的JSON对象。
- en: Solution
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s what a `PurchaseOrder` looks like:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`PurchaseOrder`的外观：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here’s a custom `JsonConverter` class:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个自定义`JsonConverter`类：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is a custom JSON naming policy:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是自定义的 JSON 命名策略：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This class simulates a request, returning JSON formatted data:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此类模拟请求，返回格式化为 JSON 的数据：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `Main` method shows how to use custom converters, options, and policies:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法显示了如何使用自定义转换器、选项和策略：'
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And here’s the output:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Discussion
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '`JsonSerializer` has a built-in converter for producing camel case property
    names, via `JsonInitializerOptions`, like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonSerializer` 具有用于生成驼峰命名属性名的内置转换器，通过 `JsonInitializerOptions`，像这样：'
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: That handles a lot of scenarios, but what if a third-party API didn’t use Pascal
    case or camel case property names? This solution includes support for property
    names that are snake case, where words are divided by an underscore. For instance,
    `SnakeCase` becomes `snake_case`. In addition to a new naming policy, the solution
    also includes other customizations, including `enum` support.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这处理了许多情况，但是如果第三方 API 没有使用帕斯卡命名或驼峰命名属性名称怎么办？此解决方案包括对由下划线分隔单词的蛇形命名属性名称的支持。例如，`SnakeCase`
    变成了 `snake_case`。除了新的命名策略外，该解决方案还包括其他定制，包括对 `enum` 的支持。
- en: Notice that `PurchaseOrder` doesn’t decorate any properties with `JsonPropertyName`.
    Instead, we use a custom naming policy, defined in the `SnakeCaseNamingPolicy`
    class, which derives from `JsonNamingPolicy`. The algorithm in `ConvertName` assumes
    that it has received a Pascal case property name. It iterates through characters,
    looking for an uppercase character. When encountering an uppercase character it
    appends an underscore, `_`, lowercases the letter, and appends the lowercase of
    the letter into the results. Otherwise, it appends the character, which is already
    lowercase.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`PurchaseOrder` 不会使用 `JsonPropertyName` 装饰任何属性。相反，我们使用自定义命名策略，在 `SnakeCaseNamingPolicy`
    类中定义，该类派生自 `JsonNamingPolicy`。`ConvertName` 中的算法假定它已收到帕斯卡命名规则的属性名。它迭代字符，查找大写字符。遇到大写字符时，它会附加下划线
    `_`，将字母小写，并将小写字母附加到结果中。否则，它附加字符，该字符已经是小写的。
- en: The `Main` method instantiates a `JsonSerializerOptions`, setting `PropertyNaming​Po⁠licy`
    to an instance of `SnakeCaseNamingPolicy`. This applies the naming policy to all
    property names, producing snake case property names.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法实例化了 `JsonSerializerOptions`，将 `PropertyNamingPolicy` 设置为 `SnakeCaseNamingPolicy`
    的实例。这将命名策略应用于所有属性名称，生成蛇形命名的属性名称。'
- en: Tip
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: As with many situations, you might encounter an exception to the rule, where
    a JSON property doesn’t conform to snake case rules. In that situation, use a
    `JsonPropertyName` attribute, as described in [Recipe 7.4](#producing_json), to
    that property, which overrides the naming policy.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多情况一样，您可能会遇到规则的例外情况，其中 JSON 属性不符合蛇形命名规则。在这种情况下，使用 `JsonPropertyName` 属性，如
    [Recipe 7.4](#producing_json) 中所述，覆盖该属性的命名策略。
- en: You might have noticed that `JsonSerializerOptions`, in `Main`, has other customizations.
    The `AllowTrailingCommas` is interesting because sometimes you receive JSON data
    containing a list, where the last item in the list has a trailing comma. This
    breaks deserialization, and setting `AllowTrailingCommas` to `true` ignores the
    trailing comma.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在 `Main` 中，`JsonSerializerOptions` 还具有其他定制。`AllowTrailingCommas` 很有趣，因为有时您会收到包含列表的
    JSON 数据，列表中的最后一项有一个尾随逗号。这会破坏反序列化，将 `AllowTrailingCommas` 设置为 `true` 可以忽略尾随逗号。
- en: '`PropertyNameCaseInsensitive` is an alternative that doesn’t consider the property
    name format. It allows lowercase property names to match their uppercase equivalent
    when deserializing. It’s useful when the incoming JSON property names might not
    be consistent in casing.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`PropertyNameCaseInsensitive` 是一种选择，不考虑属性名称的格式。在反序列化时，它允许小写属性名称与它们的大写等效项匹配。当传入的
    JSON 属性名称可能不一致时，这是有用的。'
- en: By default, `JsonSerializer` produces a single-line JSON document. Setting `Write​In⁠dented`
    formats the text for readability, as shown in the output.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`JsonSerializer` 生成单行 JSON 文档。设置 `WriteIndented` 可以格式化文本以提高可读性，如输出中所示。
- en: 'One of the properties, `Converters`, is a collection of types that do custom
    conversions on properties. The `PurchaseOrderStatusConverter`, which derives from
    `JsonConverter<T>`, allows deserialization of the `Status` property to the `PurchaseOrderStatus`
    enum. There are two ways to apply this: in `JsonSerialization` options or via
    attribute. Adding a converter to the `JsonSerializationOptions` `Converter` collection
    applies the conversion for all `PurchaseOrderStatus` property types. Also, the
    `PurchaseOrder` class decorates the `Status` property with a `JsonConverter` attribute.
    I added both methods in the solution so you could see how each of them work. Adding
    to the `Converters` collection is sufficient. However, if you wanted to apply
    a different converter to a specific property or needed different converters for
    different properties, then use the `JsonConverter` attribute, because it has precedence
    over the `Converters` collection.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个属性 `Converters` 是一个类型集合，用于在属性上进行自定义转换。`PurchaseOrderStatusConverter` 从 `JsonConverter<T>`
    派生，允许将 `Status` 属性反序列化为 `PurchaseOrderStatus` 枚举。有两种方法可以应用它：在 `JsonSerialization`
    选项中或通过属性。将转换器添加到 `JsonSerializationOptions` 的 `Converter` 集合中会为所有 `PurchaseOrderStatus`
    属性类型应用转换。此外，`PurchaseOrder` 类使用 `JsonConverter` 属性装饰 `Status` 属性。我在解决方案中添加了这两种方法，以便你能看到它们各自的工作方式。将转换器添加到
    `Converters` 集合中就足够了。但是，如果你想要为特定属性应用不同的转换器，或者需要为不同的属性使用不同的转换器，那么请使用 `JsonConverter`
    属性，因为它优先于 `Converters` 集合。
- en: The `Main` method shows how to use the same `JsonSerializationOptions` for both
    deserialization and serialization.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法展示了如何在反序列化和序列化中使用相同的 `JsonSerializationOptions`。'
- en: See Also
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 7.4, “Producing JSON”](#producing_json)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[7.4 节，“生成 JSON”](#producing_json)'
- en: 7.6 Working with JSON Data
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.6 处理 JSON 数据
- en: Problem
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You received JSON data that doesn’t cleanly deserialize into an object.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 收到了无法干净反序列化为对象的 JSON 数据。
- en: Solution
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s what a `PurchaseOrder` looks like:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 `PurchaseOrder` 的样例：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This class simulates a request that returns JSON data:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类模拟了返回 JSON 数据的请求：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here’s a class that supports custom deserialization:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是支持自定义反序列化的类：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `Main` method shows how to perform custom deserialization:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法展示了如何执行自定义反序列化：'
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Discussion
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: While using the `JsonSerializer` is the preferred choice in serialization and
    deserialization, sometimes you don’t get a clean one-to-one structural match between
    JSON and C# objects. For example, you might need to get data from different sources
    with different formats and have a single C# object to populate. Other times, you
    might have a hierarchical JSON document and want to flatten it into your own object.
    Another common situation is to have objects that already work with one version,
    and a new version of the API changes structure. In a way, these are multiple viewpoints
    of the same problem, which you can solve by doing custom deserialization.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在序列化和反序列化中使用 `JsonSerializer` 是首选，但有时你不会得到 JSON 和 C# 对象之间干净的一对一结构匹配。例如，你可能需要从不同格式的不同源获取数据，并有一个单一的
    C# 对象进行填充。其他时候，你可能有一个分层的 JSON 文档，并希望将其扁平化为你自己的对象。另一种常见情况是已经使用一个版本工作的对象，而 API 的新版本改变了结构。在某种程度上，这些都是同一个问题的多个视角，你可以通过自定义反序列化来解决。
- en: The two types from the `System.Text.Json` namespace for custom deserialization
    are `JsonDocument` and `JsonElement`. The `Main` method shows how to use `JsonDocument`
    to parse JSON input and obtain a `JsonElement` via the `RootElement` property.
    After that, we just work with `JsonElement` members.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 自 `System.Text.Json` 命名空间中用于自定义反序列化的两种类型是 `JsonDocument` 和 `JsonElement`。`Main`
    方法展示了如何使用 `JsonDocument` 解析 JSON 输入，并通过 `RootElement` 属性获取 `JsonElement`。之后，我们只需处理
    `JsonElement` 的成员。
- en: '`JsonElement` has several members, including `GetString` and `GetInt64`, for
    doing conversions. The problem with relying on those alone is that data is often
    not clean. Even if you own the consumer and producer ends of the application,
    obtaining perfectly clean data might be illusive. To solve this problem, I created
    the `JsonConversion​)Ex⁠tensions` class.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonElement` 有多个成员，包括 `GetString` 和 `GetInt64`，用于进行转换。仅仅依赖这些成员存在的问题是数据通常不干净。即使你拥有应用程序的生产者和消费者端，获得完全干净的数据可能也是难以实现的。为了解决这个问题，我创建了
    `JsonConversionExtensions` 类。'
- en: Conceptually, `JsonConversionExtensions` wraps a lot of boilerplate code that
    you need to call to ensure the data you’re reading is what you expect. It also
    has an optional default value concept.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在概念上，`JsonConversionExtensions` 包装了许多模板代码，你需要调用它们来确保你正在读取的数据是你所期望的。它还有一个可选的默认值概念。
- en: The first trick to work around is that a `null` value in `JsonElement` isn’t
    represented as `null`. The `IsNull` method examines the `ValueKind` property,
    checking if either the `Undefined` or `Null` properties are true. This is an important
    method used by other conversion methods.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 解决第一个问题的技巧是，`JsonElement`中的`null`值不表示为`null`。`IsNull`方法检查`ValueKind`属性，检查`Undefined`或`Null`属性是否为true。这是其他转换方法中使用的重要方法。
- en: Skimming through the rest of the methods, you’ll see a familiar pattern. Each
    of them checks for `IsNull` on the element and then uses one or more combinations
    of `TryGetXxx` and `IsNull` calls to get the value. This is safe and avoids exceptions
    in case the value is `null` or is of the wrong type. That’s right, some APIs document
    values of one type and return another type at runtime, set numbers to `null`,
    and omit properties.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览其余的方法，你会看到一个熟悉的模式。每个方法都会检查元素的`IsNull`，然后使用一个或多个`TryGetXxx`和`IsNull`的组合来获取值。这样做是安全的，在值为`null`或类型错误时避免异常。没错，一些API文档中的值是一个类型，运行时返回另一个类型，将数字设置为`null`，并省略属性。
- en: Each method has a default parameter. If the code isn’t able to extract a real
    value, it uses `defaultValue`. The `defaultValue` parameter is optional and reverts
    to the C# `default` of the return type.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法都有一个默认参数。如果代码无法提取真实值，它将使用`defaultValue`。`defaultValue`参数是可选的，会回到返回类型的C#
    `default`。
- en: The `Main` method shows how to construct an object with `JsonElement` and the
    `JsonConversionExtensions` class. You can see how the code populates each property
    with a `GetXxx` method.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`方法展示了如何使用`JsonElement`和`JsonConversionExtensions`类构造对象。你可以看到代码如何使用`GetXxx`方法填充每个属性。'
- en: A couple of useful `JsonElement` methods are `EnumerateObject` and `EnumerateArray`.
    In previous sections, `JsonSerializer` deserialized the JSON `additional_info`
    object into a C# dictionary. This is how you handle an object with variable information,
    where you don’t know what the properties of the object are. You might see this
    for an API that returns multiple errors in a single error JSON response, where
    each property is a code or description of the error. In the `PurchaseOrder` example,
    this represents a place where someone can add miscellaneous information that doesn’t
    fit into a predesigned property. To read these properties manually, use `EnumerateObject`.
    It returns each property/value pair in the object. You can see the LINQ statement
    that creates a new dictionary by extracting the `Key` and `Value` from each `JsonProperty`
    that `EnumerateObject` returns.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 几个有用的`JsonElement`方法是`EnumerateObject`和`EnumerateArray`。在前面的章节中，`JsonSerializer`将JSON
    `additional_info`对象反序列化为C#字典。这是处理具有可变信息对象的方法，你不知道对象属性是什么。在API返回单个错误JSON响应中，每个属性是一个错误的代码或描述。在`PurchaseOrder`示例中，这表示可以添加不适合预定义属性的杂项信息的地方。要手动读取这些属性，请使用`EnumerateObject`。它返回对象中的每个属性/值对。你可以看到LINQ语句如何通过从`EnumerateObject`返回的每个`JsonProperty`提取`Key`和`Value`来创建一个新字典。
- en: '`EnumerateArray` returns each element of a list. In the solution, we project
    each `JsonElement` returned from `EnumerateArray` into a new `PurchaseOrderItem`
    instance.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`EnumerateArray`返回列表的每个元素。在解决方案中，我们将从`EnumerateArray`返回的每个`JsonElement`投影到一个新的`PurchaseOrderItem`实例中。'
- en: The `JsonConversionExtensions` is incomplete, because it doesn’t include dates.
    Since `DateTime` processing is a special case, I separated it from this example;
    you can find more information about it in [Recipe 7.10](#flexible_datetime_reading).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonConversionExtensions`是不完整的，因为它不包括日期。由于`DateTime`处理是一个特例，我从这个示例中分离了它；你可以在[Recipe
    7.10](#flexible_datetime_reading)中找到更多信息。'
- en: See Also
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 7.10, “Flexible DateTime Reading”](#flexible_datetime_reading)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 7.10，“灵活的DateTime读取”](#flexible_datetime_reading)'
- en: 7.7 Consuming XML
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.7 消费XML
- en: Problem
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to convert an XML document to an object.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将XML文档转换为对象。
- en: Solution
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s what a `PurchaseOrder` looks like:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`PurchaseOrder`的样子：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This method simulates a request that returns XML data:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法模拟了返回XML数据的请求：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `Main` method shows how to deserialize XML into objects:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`方法展示了如何将XML反序列化为对象：'
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Discussion
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Before JSON took over as the dominant data format, XML was ubiquitous. When
    working with things like configuration files, project files, or Extensible Application
    Markup Language (XAML), it’s clear that XML is still with us. There’s also a fair
    amount of legacy code, including Windows Communication Foundation (WCF) Web Services,
    that uses XML extensively. For the time being, knowing how to work with XML is
    a valuable skill, and LINQ to XML is an excellent tool for that.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSON 成为主导数据格式之前，XML 无处不在。在处理配置文件、项目文件或可扩展应用标记语言（XAML）等方面，XML 仍然非常明显。还有相当数量的遗留代码，包括广泛使用
    XML 的 Windows Communication Foundation（WCF）Web 服务。暂时而言，掌握如何处理 XML 是一项宝贵的技能，而 LINQ
    to XML 是一个优秀的工具。
- en: The solution shows how to deserialize XML into a `PurchaseOrder` object. The
    first thing the `Main` method does is set up the namespace. Namespaces in XML
    are common, and the code creates a namespace tag, `or`. The `XNamespace` type
    has a converter that transforms a string into a namespace. `XNamespace` also overloads
    the `+` operator, letting you tag elements with a specific namespace, creating
    a new `XName`. The code sets up an `XName` for each element to make the construction
    of `PurchaseOrder` easier to read.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案展示了如何将 XML 反序列化为 `PurchaseOrder` 对象。`Main` 方法首先设置命名空间。XML 中的命名空间很常见，代码创建了一个命名空间标签
    `or`。`XNamespace` 类型有一个转换器，将字符串转换为命名空间。`XNamespace` 还重载了 `+` 运算符，允许您给元素打上特定的命名空间标签，创建一个新的
    `XName`。代码为每个元素设置了一个 `XName`，以使 `PurchaseOrder` 的构造更易于阅读。
- en: Each element has a namespace, except for `serialNum`, which is an attribute.
    You don’t annotate data attributes with namespaces because they’re in the containing
    element’s namespace. The exception is if you wanted to add a namespace attribute
    to an element, putting it into a new namespace.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 每个元素都有一个命名空间，`serialNum` 除外，它是一个属性。数据属性不需要用命名空间注释，因为它们位于包含元素的命名空间中。唯一的例外是，如果您想要向元素添加命名空间属性，将其放入新的命名空间中。
- en: After getting the XML, `Main` calls `XElement.Parse` to get a new `XElement`
    to work with. `XElement` has all the axis methods required to move around the
    document and read anything you need. This example keeps things simple by moving
    through the document hierarchically with the `Attribute`, `Element`, and `Descendants`
    axis methods.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取 XML 后，`Main` 调用 `XElement.Parse` 获取一个新的 `XElement` 来处理。`XElement` 具有移动文档和读取所需内容所需的所有轴方法。此示例通过使用
    `Attribute`、`Element` 和 `Descendants` 轴方法按层次移动文档来保持简单。
- en: The `Element` method helps read a subelement under the current element. The
    `Descendants` method goes one level deeper, accessing the children of a specified
    element. In the XML returned from `GetXml`, `PurchaseOrder` is the root element,
    represented by `poElmt`. Looking at the `PurchaseOrder`, `poElmt.Element(address)`
    reads the `Address` element, a subelement of `PurchaseOrder`. If you recall, `address`
    is a namespace-qualified `XName`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`Element` 方法帮助读取当前元素下的子元素。`Descendants` 方法深入一级，访问指定元素的子元素。从 `GetXml` 返回的 XML
    中，`PurchaseOrder` 是根元素，由 `poElmt` 表示。查看 `PurchaseOrder`，`poElmt.Element(address)`
    读取 `PurchaseOrder` 的子元素 `Address`。如您所知，`address` 是一个命名空间限定的 `XName`。'
- en: Populating the `AdditionalInfo` and `Items` properties shows how to use `Descendants`.
    We use `Element` to read the subelement and `Descendants` to get a list of that
    element’s children. For `AdditionalInfo`, `Descendants` are variable elements
    and values, and we don’t pass an `XName` argument. In the case of `Items`, we
    need to pass the `purchaseItem` `XName` to `Descendants` to operate on each object.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 填充 `AdditionalInfo` 和 `Items` 属性展示了如何使用 `Descendants`。我们使用 `Element` 来读取子元素，使用
    `Descendants` 来获取该元素的子元素列表。对于 `AdditionalInfo`，`Descendants` 是可变元素和值，并且我们不传递 `XName`
    参数。对于 `Items`，我们需要传递 `purchaseItem` 的 `XName` 给 `Descendants`，以便对每个对象进行操作。
- en: We use the `Attribute` method to populate the `SerialNumber` property of each
    `PurchaseOrderItem`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `Attribute` 方法来填充每个 `PurchaseOrderItem` 的 `SerialNumber` 属性。
- en: An interesting part of this object construction is the ability to declare the
    `out` parameter in `TryParse` operations. This allows us to code the assignment
    inline. Prior to this C# feature, we would need to declare the variable outside
    the object construction, which doesn’t feel natural, especially when populating
    during a LINQ projection, like the `Items` property in the solution.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象构造的有趣部分是在 `TryParse` 操作中声明 `out` 参数的能力。这使我们可以在对象构造时内联编码分配。在此 C# 特性之前，我们需要在对象构造外部声明变量，这在像解决方案中的
    LINQ 投影中填充 `Items` 属性时并不自然。
- en: See Also
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 7.8, “Producing XML”](#producting_xml)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 7.8, “生成XML”](#producting_xml)'
- en: 7.8 Producing XML
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.8 XML生成
- en: Problem
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to convert an object to XML.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将一个对象转换为XML。
- en: Solution
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s what a `PurchaseOrder` looks like:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`PurchaseOrder`的样子：
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This method simulates a data request that returns a `PurchaseOrder`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法模拟一个数据请求，返回一个`PurchaseOrder`：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `Main` method shows how to serialize that `PurchaseOrder` instance into
    XML:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`方法展示了如何将`PurchaseOrder`实例序列化为XML：'
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And here’s the output:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出结果：
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Discussion
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '[Recipe 7.7](#consuming_xml) deserialized an XML document into a `PurchaseOrder`
    object. This section goes in the other direction—serializing the `PurchaseOrder`
    into an XML document.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 7.7](#consuming_xml) 将一个XML文档反序列化为一个`PurchaseOrder`对象。这一部分则相反—将`PurchaseOrder`序列化为XML文档。'
- en: We start with the `XNamespace`, `or`, which is used as the `XName` parameter
    for each element to keep all elements in the same namespace.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`XNamespace`开始，用作每个元素的`XName`参数，以保持所有元素在同一个命名空间中。
- en: The solution builds the XML document via calls to `XElement` and `XAttribute`.
    The only place we use `XAttribute` is for the `SerialNumber` attribute on each
    `Purchase​Or⁠derItem` element.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案通过调用`XElement`和`XAttribute`构建XML文档。我们唯一使用`XAttribute`的地方是每个`PurchaseOrderItem`元素的`SerialNumber`属性。
- en: Visually, you can see that the LINQ to XML query clause is laid out with the
    same hierarchical structure as the XML output it produces. The solution uses two
    `XElement` constructor overloads. If an element is a bottom node, without children,
    the second parameter is the element value. However, if the element is a parent
    element, with children, the second parameter is a new `XElement`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 从视觉上看，你可以看到LINQ到XML查询子句的布局与其生成的XML输出具有相同的分层结构。解决方案使用了两个`XElement`构造函数重载。如果一个元素是一个底层节点，没有子元素，第二个参数是元素的值。然而，如果元素是一个父元素，有子元素，第二个参数是一个新的`XElement`。
- en: The LINQ statements for both `AdditionalInfo` and `Items` project into a new
    `XElement`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ语句用于`AdditionalInfo`和`Items`，生成一个新的`XElement`。
- en: See Also
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 7.7, “Consuming XML”](#consuming_xml)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 7.7, “消费XML”](#consuming_xml)'
- en: 7.9 Encoding and Decoding URL Parameters
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.9 编码和解码URL参数
- en: Problem
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You’ve working with an API that requires RFC 3986–compliant URLs.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在使用一个需要符合RFC 3986的API进行操作。
- en: Solution
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s a class that properly encodes URL parameters:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个正确编码URL参数的类：
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This method parses a URL, encodes parameters, and rebuilds the URL:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法解析URL，编码参数并重建URL：
- en: '[PRE38]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `Main` method compares different encodings:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`方法比较不同的编码方式：'
- en: '[PRE39]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Producing this output:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 生成这个输出：
- en: '[PRE40]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Discussion
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: If you’re building both the consumer and producer parts of network communications,
    such as an internal enterprise application, getting encoding right might not matter
    because both parts use the same library. However, some third-party APIs require
    strong compliance with RFC 3986\. Your first thought may be that the .NET `System.Uri`
    class has `EscapeUriString` and `EscapeDataString` methods. Unfortunately, these
    methods haven’t always implemented RFC 3986 properly. While .NET 5+ is cross-platform
    and seems to have a good implementation, earlier versions of the .NET Framework
    for different technologies did not. To fix this, I created the `Url` class in
    the solution.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你同时构建网络通信的消费者和生产者部分，比如内部企业应用，编码的正确性可能并不重要，因为这两部分使用同一个库。然而，某些第三方API要求严格遵守RFC
    3986。你可能首先想到的是.NET中的`System.Uri`类有`EscapeUriString`和`EscapeDataString`方法。不幸的是，这些方法并没有始终正确实现RFC
    3986。虽然.NET 5+跨平台并且看起来实现良好，但是.NET Framework的早期版本针对不同技术并没有这样做。为了解决这个问题，我在解决方案中创建了`Url`类。
- en: Note
  id: totrans-215
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: RFC 3986 is the standard defining internet URL encoding. RFC stands for “Request
    for Comments,” and standards are generally labeled with RFC followed by some unique
    number.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: RFC 3986是定义互联网URL编码的标准。RFC代表“请求评论”，标准通常以RFC后跟一些唯一编号。
- en: The `PercentEncode` replaces each character of the value parameter with a two-digit
    hex representation with a percent (`%`) prefix. The first operation is to call
    `EscapeDataString`. This method calls `Uri.EscapeDataString`. One of the issues
    with `Uri.​Esca⁠peDataString` is a length constraint, so this method chunks the
    input to ensure all the data is encoded. The approach is to allow `Uri.EscapeDataString`
    to take care of most of the conversion and let `PercentEncode` supplement for
    characters that weren’t encoded.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`PercentEncode` 将值参数的每个字符替换为带有百分号（`%`）前缀的两位十六进制表示。第一个操作是调用 `EscapeDataString`。该方法调用
    `Uri.EscapeDataString`。`Uri.EscapeDataString` 的一个问题是长度限制，因此该方法会将输入分块以确保所有数据都被编码。方法的思路是让
    `Uri.EscapeDataString` 处理大部分的转换工作，并让 `PercentEncode` 补充那些未被编码的字符。'
- en: '`PercentEncode` has a second parameter, `isParam`, that indicates whether we
    should encode parentheses. It defaults to `true`, and users would set it to `false`
    to prevent encoding parentheses, which is the only difference between the `IsParamReservedChars`
    and `NoParamReservedChars`. If the method finds a character that hasn’t been encoded,
    it does the encoding manually.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`PercentEncode` 还有一个第二个参数 `isParam`，用于指示是否应编码括号。它默认为 `true`，用户可以将其设置为 `false`
    以防止编码括号，这是 `IsParamReservedChars` 和 `NoParamReservedChars` 之间唯一的区别。如果该方法发现未编码的字符，它会手动进行编码。'
- en: We only encode query string parameter values because the base URL, segments,
    and parameter names are values that don’t need encoding. The `EscapeUrlParameters`
    method does this by splitting the URL from the parameters and iterating through
    each parameter. For each parameter, it splits the parameter name from its value
    and calls `PercentEncode` on the value. After encoding values, the code rebuilds
    and returns the URL.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只对查询字符串参数值进行编码，因为基本 URL、段和参数名称是不需要编码的值。`EscapeUrlParameters` 方法通过将 URL 与参数分离，并迭代每个参数来实现此目的。对于每个参数，它将参数名与其值分开，并对值调用
    `PercentEncode`。在对值进行编码之后，代码重建并返回 URL。
- en: The `Main` method shows the different types of encoding, illuminating why we
    chose the custom encoding approach. Notice that `Uri.EscapeUriString` didn’t encode
    the `+` symbol. Using `Uri.EscapeDataString` encoded the entire URL, which isn’t
    what you want. Breaking up the URL and encoding each value worked perfectly.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法展示了不同类型的编码，阐明了为什么选择了自定义编码方法。请注意，`Uri.EscapeUriString` 没有对 `+` 符号进行编码。使用
    `Uri.EscapeDataString` 对整个 URL 进行了编码，这并不是您想要的。将 URL 拆分并对每个值进行编码可以完美解决问题。'
- en: Remember that you might get good results in a .NET 5+ application. However,
    if you’re doing cross-platform work in older .NET Framework versions, the results
    of `Uri.EscapeUriString` and `Uri.EscapeDataString` are inconsistent and likely
    to cause bugs. Regardless of framework/technology version, the technique of only
    encoding parameter values is a common requirement.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在 .NET 5+ 应用程序中可能会获得良好的结果。但是，如果在旧的 .NET Framework 版本中进行跨平台工作，`Uri.EscapeUriString`
    和 `Uri.EscapeDataString` 的结果可能不一致，很可能会导致错误。无论使用哪个框架/技术版本，仅对参数值进行编码的技术是一个常见的需求。
- en: 7.10 Flexible DateTime Reading
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.10 灵活的日期时间读取
- en: Problem
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to parse `DateTime` values that can be in multiple different formats.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要解析可能以多种不同格式出现的 `DateTime` 值。
- en: Solution
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'These extension methods help in parsing dates:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这些扩展方法有助于解析日期：
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `Main` method shows how to extract and parse a JSON document date:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法展示了如何提取和解析 JSON 文档中的日期：'
- en: '[PRE42]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Discussion
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: When using third-party APIs, you’ll encounter occasional inconsistencies in
    data representation. One problematic area is parsing dates. Different APIs have
    different date formats or even represent different date properties with separate
    formats in the same API. The `StringExtensions` class in the solution helps fix
    this problem.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用第三方 API 时，您可能会遇到数据表示的偶发不一致。一个问题区域是解析日期。不同的 API 使用不同的日期格式，甚至在同一个 API 中，也可能用不同的格式表示不同的日期属性。解决方案中的
    `StringExtensions` 类帮助解决了这个问题。
- en: Note
  id: totrans-232
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: I extracted `StringExtensions` members from `JsonConversion​Ex⁠tensions` in
    [Recipe 7.6](#working_with_json_data).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我从 [7.6节](#working_with_json_data) 中的 `JsonConversionExtensions` 中提取了 `StringExtensions`
    成员。
- en: The solution includes a `dateFormats` array containing instances of date format
    strings. These are all the possible date formats that this code can accommodate.
    The `GetDate` method uses `dateFormats` in the call to `TryParseExact`. Whenever
    you encounter a new date format (for instance, if an API offers a new version
    and updates date formats), add it to `dateFormats`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案包括一个`dateFormats`数组，其中包含日期格式字符串的实例。这些都是此代码可以容纳的所有可能日期格式。`GetDate`方法在调用`TryParseExact`时使用`dateFormats`。每当遇到新的日期格式（例如，如果API提供了新版本并更新了日期格式），请将其添加到`dateFormats`中。
- en: It’s best practice to represent dates as UTC values, so the `DateTimeStyles`
    arguments reflect this assumption.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是将日期表示为UTC值，因此`DateTimeStyles`参数反映了这一假设。
- en: There are two overloads of `GetDate`, depending on whether you need to pass
    in a `string` or a `JsonElement`. The `JsonElement` overload uses the `GetString`
    extension method and forwards the result to the other `GetDate` method.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`GetDate`有两个重载，取决于您需要传递`string`还是`JsonElement`。`JsonElement`的重载使用`GetString`扩展方法，并将结果转发给另一个`GetDate`方法。
- en: These methods are safe because you have to account for bad data. They check
    for `null`, use `TryParse`, and return `default` values when they can’t read a
    valid value. The `defaultValue` is optional, using the `default` of the return
    type if not provided.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法是安全的，因为您必须考虑糟糕的数据。它们检查`null`，使用`TryParse`，并在无法读取有效值时返回`default`值。如果未提供`defaultValue`，则返回类型的`default`是可选的。
- en: See Also
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 7.6, “Working with JSON Data”](#working_with_json_data)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 7.6，“使用JSON数据”](#working_with_json_data)'
