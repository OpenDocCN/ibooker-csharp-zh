- en: Chapter 9\. Testing All the Things
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。测试所有的东西
- en: In this chapter, we’re going to explore the various testing options available
    to you as a Blazor developer. It’s important to know what you can test and how
    to test it. We’ll start with the most basic testing use cases that apply to all
    .NET and JavaScript developers alike. I’ll provide an introduction to testing
    and show you how to use the xUnit, bUnit, and Playwright testing frameworks. We
    will then move on to more advanced testing scenarios. We’ll finish with code examples
    that exemplify how to automate testing with GitHub Action workflows and how to
    write tests, such as unit, component, and end-to-end tests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨作为Blazor开发人员可用的各种测试选项。了解您可以测试什么以及如何测试非常重要。我们将从适用于所有.NET和JavaScript开发人员的最基本的测试用例开始。我将介绍测试并向您展示如何使用xUnit、bUnit和Playwright测试框架。然后我们将转向更高级的测试场景。最后，我们将以代码示例结束，展示如何使用GitHub
    Action工作流自动化测试，以及如何编写单元、组件和端到端测试。
- en: Why Test?
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么测试？
- en: You may be asking, “What’s the point of testing if your code works anyway?”
    That’s a fair question. For years, I felt the same way—I disliked testing because
    it seemed unnecessary. After years of writing code, however, I’ve changed my mind.
    Testing is a great way to ensure that your code works as expected and can be refactored
    as needed. Testing also helps make things work right if core business rules change.
    Just as I once said that good code is a love letter for the next developer, testing
    is a show of affection as well. Let’s get started with the smallest kind of test—the
    *unit test*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会问，“如果你的代码本来就能工作，测试的意义何在？”这是个公平的问题。多年来，我也持相同观点——我不喜欢测试，因为它看起来没有必要。然而，多年来编写代码后，我改变了看法。测试是确保您的代码按预期工作并能根据需要重构的好方法。测试还有助于在核心业务规则更改时使事情正常运行。就像我曾说过良好的代码是给下一个开发者的情书一样，测试也是一种表达情感的方式。让我们从最小的测试类型——*单元测试*开始吧。
- en: Unit Testing
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: A *unit test* is the most basic testing strategy that exercises a small, isolated
    piece or unit of code. A unit test should accept only known inputs and return
    expected outputs—it’s best to avoid randomization in testing. By automating the
    unit tests and avoiding human error, you’re more likely to catch potential issues
    in future refactorings.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*单元测试*是最基本的测试策略之一，用于测试小型、隔离的代码片段或单元。单元测试应接受已知输入并返回预期输出——最好避免在测试中使用随机化。通过自动化单元测试并避免人为错误，您更有可能在未来的重构中捕捉潜在问题。'
- en: Note
  id: totrans-6
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: All of the unit tests here are written in C#, but that’s not to say that you
    couldn’t write unit tests for the JavaScript code we used in our model app. I
    chose not to do this because the Learning Blazor app has very little JavaScript
    code and primarily wraps existing APIs, so it’s highly reliable. In other words,
    I’m not interested in maintaining tests that verify only framework code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这里的单元测试都是用C#编写的，但这并不意味着你不能为我们模型应用程序中使用的JavaScript代码编写单元测试。我选择不这样做是因为Learning
    Blazor应用程序几乎没有JavaScript代码，主要是包装现有的API，因此非常可靠。换句话说，我对维护仅验证框架代码的测试不感兴趣。
- en: A unit test is one of the best ways to ensure code functionality, but it is
    not a substitute for manual functional testing because it focuses on a single
    unit. You can use testing frameworks, like xUnit, MSTest, and NUnit, to write
    unit tests for your Blazor apps. All of these frameworks are well maintained,
    documented, supported, and feature-rich. Pair that with a GitHub repository, and
    you’re off to the races. With a GitHub workflow file, you can call the `dotnet
    test` CLI command to run unit tests.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是确保代码功能的最佳方式之一，但它不能替代手动功能测试，因为它侧重于单个单元。您可以使用测试框架，如xUnit、MSTest和NUnit，为您的Blazor应用程序编写单元测试。所有这些框架都得到了很好的维护、文档化、支持和功能丰富。再加上GitHub仓库，您就可以运用如虎添翼。有了GitHub工作流文件，您可以调用`dotnet
    test` CLI命令来运行单元测试。
- en: Tip
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: A fairly well-adopted unit testing strategy is to develop unit tests before
    writing the implementation of the code you’re testing. This is known as *test-driven
    development* (TDD). TDD has the benefit of being a bit more pragmatic in that
    you’re forced up front to think about how an API should be implemented before
    writing the code. This is a good way to ensure that you’re testing the right things.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相当普遍采用的单元测试策略是在编写要测试的代码实现之前开发单元测试。这被称为*测试驱动开发*（TDD）。TDD的好处在于在编写代码之前你被迫先考虑如何实现API。这是确保你测试正确事物的好方法。
- en: Defining Unit-Testable Code
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义可单元测试代码
- en: One good way to do unit testing is with an extension method. I’m a big fan of
    extension methods. They’re so useful that they’ve become idiomatic to C# development.
    Extension methods are a great way to add functionality to existing classes. There
    was a long-standing misconception that extension methods are difficult to unit
    test. This is not true. This comes from the concern that an extension method cannot
    be mocked (its implementation cannot be controlled or customized for unit testing),
    and therefore other logic that relies on extended functionality cannot be controlled.
    It’s believed that this makes it difficult to test. However, in reality, you can
    still test both extension methods and consuming functionality. You do not need
    to mock everything to write a unit test. Again, a unit test is concerned with
    only a unit of work, given known inputs and expecting specific outputs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的一个好方法是使用扩展方法。我非常喜欢扩展方法。它们非常有用，以至于它们已经成为C#开发的习惯用语。扩展方法是向现有类添加功能的好方法。长期以来有一个误解，即扩展方法很难进行单元测试。这是不正确的。这种观点来自于一个担忧，即无法对扩展方法进行模拟（无法控制或自定义其实现以进行单元测试），因此依赖扩展功能的其他逻辑无法进行控制。据信这使得测试变得困难。然而，实际上，你仍然可以测试扩展方法和消费功能。你不需要模拟所有东西来编写单元测试。再次强调，单元测试只关心一部分工作，给定已知输入并期望特定输出。
- en: 'In this section, we’re going to work through the Web.Extensions.Tests project
    of the model app that uses the common Arrange-Act-Assert testing pattern. In this
    pattern, we’ll arrange our inputs, act on the system under test, and assert the
    expected outputs are accurate. For more information about this pattern, see Microsoft’s
    [“Unit Testing Best Practices with .NET Core and .NET Standard” documentation](https://oreil.ly/WCx2o).
    Web​.Exten⁠sions.Tests is an xUnit test project that relies on `Microsoft.NET.Sdk`,
    and test projects like this can be created using the .NET CLI: `dotnet new xunit`
    command. The `xunit` template has all the dependencies specified and is ready
    to run tests. For more information, see the [xUnit website](https://xunit.net).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过Web.Extensions.Tests项目来实现模型应用程序，该项目使用常见的安排-执行-断言测试模式。在这个模式中，我们将安排我们的输入，在被测试的系统上执行操作，并断言预期的输出是准确的。关于这种模式的更多信息，请参阅Microsoft的[“.NET
    Core和.NET Standard单元测试最佳实践”文档](https://oreil.ly/WCx2o)。Web.Extensions.Tests是一个xUnit测试项目，依赖于`Microsoft.NET.Sdk`，像这样的测试项目可以使用.NET
    CLI创建：`dotnet new xunit`命令。`xunit`模板已经指定了所有依赖项，并准备好运行测试。有关更多信息，请参阅[xUnit网站](https://xunit.net)。
- en: 'Throughout the development and the discussion of the model app in this book,
    you’ve seen the `User` property wherever our authenticated user flows through
    the system. This property is a `ClaimsPrincipal` instance, and it serves as a
    good example of how to unit test an extension method. You may recall seeing that
    the `User.Get​FirstEmailAddress()` method is called (in the `Contact` page) from
    [Chapter 8](ch08.html#chapter-eight). This method is an extension method that
    returns the first email address from the user’s “emails” claim. Let’s look at
    the extension method functionality first to understand how it should function
    and consider the *ClaimsPrincipalExtensions.cs* file in the Web.Extensions class
    library project:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的开发和模型应用程序的讨论中，你可以在整个系统中看到`User`属性。这个属性是一个`ClaimsPrincipal`实例，它展示了如何对扩展方法进行单元测试的良好示例。你可能还记得在[第8章](ch08.html#chapter-eight)中从*联系*页面调用了`User.GetFirstEmailAddress()`方法。这个方法是一个扩展方法，用于从用户的“emails”声明中返回第一个电子邮件地址。首先让我们看一下扩展方法的功能，以了解它应该如何运作，并考虑Web.Extensions类库项目中的*ClaimsPrincipalExtensions.cs*文件：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_testing_all_the_things_CO1-1)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_testing_all_the_things_CO1-1)'
- en: The `GetFirstEmailAddress` method gets the first email address from the call
    to `GetEmailAddresses`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetFirstEmailAddress`方法从调用`GetEmailAddresses`获取第一个电子邮件地址。'
- en: '[![2](assets/2.png)](#co_testing_all_the_things_CO1-2)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_testing_all_the_things_CO1-2)'
- en: The `GetEmailAddresses` method gets all email addresses for a given user’s “emails”
    claim.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetEmailAddresses`方法从给定用户的“emails”声明中获取所有电子邮件地址。'
- en: The `ClaimsPrincipalExtensions` class could benefit from some unit tests as
    the functionality has several different logical branches. The logic is to return
    `null` when there is not an “emails” claim value. When there is an “emails” claim
    value, we want to return an array of email addresses from `GetEmailAddresses`.
    This method normalizes the claim value, effectively parsing whether the `string`
    value starts as an array, in which case it would deserialize it as JSON to a `string[]`.
    Otherwise, it’s treated as a single-length array with the sole email address.
    In other words, if there is only one email address, we want to return an array
    with one element. When there is more than one, we care only about the first.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClaimsPrincipalExtensions`类可以从一些单元测试中受益，因为其功能具有几个不同的逻辑分支。当没有“emails”声明值时，逻辑是返回`null`。当有“emails”声明值时，我们希望从`GetEmailAddresses`返回一个电子邮件地址数组。此方法规范化声明值，有效地解析`string`值是否作为数组开始，如果是，则将其反序列化为`string[]`。否则，它被视为一个只有一个元素的单长度数组，其中包含唯一的电子邮件地址。换句话说，如果只有一个电子邮件地址，我们希望返回一个包含一个元素的数组。当有多个电子邮件地址时，我们只关心第一个。'
- en: Writing an Extension Method Unit Test
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写扩展方法单元测试
- en: 'To unit test the `ClaimsPrincipal` extension method, we’ll need to be able
    to create an instance with known claims. Consider an internal helper class that’s
    used to build a custom `ClaimsPrincipal` instance, as in the *ClaimsPrincipalExtensionsTests​.Inter⁠nal.cs*
    C# file:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要对`ClaimsPrincipal`扩展方法进行单元测试，我们需要能够创建具有已知声明的实例。考虑一个内部辅助类，用于构建自定义`ClaimsPrincipal`实例，就像*C#文件ClaimsPrincipalExtensionsTests​.Inter⁠nal.cs*中的示例一样：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_testing_all_the_things_CO2-1)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_testing_all_the_things_CO2-1)'
- en: '`ClaimsPrincipalBuilder` is a helper class internal to `ClaimsPrincipal​Exten⁠sionsTests`.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClaimsPrincipalBuilder`是`ClaimsPrincipal​Exten⁠sionsTests`中的一个辅助类。'
- en: '[![2](assets/2.png)](#co_testing_all_the_things_CO2-2)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_testing_all_the_things_CO2-2)'
- en: The `WithClaim` method adds a claim type and value to the builder instance.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`WithClaim`方法向建造者实例添加声明类型和值。'
- en: '[![3](assets/3.png)](#co_testing_all_the_things_CO2-3)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_testing_all_the_things_CO2-3)'
- en: The `Build` method returns a `ClaimsPrincipal` instance, creating an identity
    with the claims in the builder.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`Build`方法返回一个`ClaimsPrincipal`实例，创建一个带有建造者中声明的身份。'
- en: 'The builder pattern (as described in [“Builder Pattern”](ch06.html#builder-pattern))
    is useful for this helper. Because we’re creating the `ClaimsPrincipal` type specific
    to the test, the framework will not provide the `User` instance. Instead, we’ll
    use the `WithClaim` method on the builder to add claims and then use the `Build`
    method to create a `Claim⁠s​Principal` instance. Each test can create its own
    instance (with known inputs). Let’s see this helper/builder in action by looking
    at the *ClaimsPrincipal​Exten⁠sionsTests.cs* file from the Web.Extensions.Tests
    project:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者模式（如描述在[“建造者模式”](ch06.html#builder-pattern)）对于这个辅助工具非常有用。因为我们正在创建特定于测试的`ClaimsPrincipal`类型，所以框架不会提供`User`实例。相反，我们将使用建造者的`WithClaim`方法添加声明，然后使用`Build`方法创建一个`Claim⁠s​Principal`实例。每个测试可以创建自己的实例（带有已知的输入）。我们可以通过查看来自Web.Extensions.Tests项目的*ClaimsPrincipal​Exten⁠sionsTests.cs*文件来看这个辅助工具/建造者的作用：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_testing_all_the_things_CO3-1)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_testing_all_the_things_CO3-1)'
- en: '`GetFirstEmailAddressNull` verifies that given no “emails” claim value, the
    method returns `null`.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetFirstEmailAddressNull`验证了没有“emails”声明值时，方法返回`null`。'
- en: '[![2](assets/2.png)](#co_testing_all_the_things_CO3-2)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_testing_all_the_things_CO3-2)'
- en: '`GetFirstEmailAddressKeyMismatch` verifies that given a claim type mismatch
    (there is no “emails” claim, instead “email”), the method returns `null`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetFirstEmailAddressKeyMismatch`验证了当声明类型不匹配时（没有“emails”声明，而是“email”），方法返回`null`。'
- en: '[![3](assets/3.png)](#co_testing_all_the_things_CO3-3)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_testing_all_the_things_CO3-3)'
- en: '`GetFirstEmailAddressArrayString` verifies that given an array of “emails”
    in the claim value, the first email address is returned.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetFirstEmailAddressArrayString`验证了当声明值中有一个“emails”数组时，返回第一个电子邮件地址。'
- en: '[![4](assets/4.png)](#co_testing_all_the_things_CO3-4)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_testing_all_the_things_CO3-4)'
- en: '`GetFirstEmailAddressGetSimpleString` verifies that given there’s a single
    “email,” it’s returned.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetFirstEmailAddressGetSimpleString`验证了只要有一个“email”，它就会返回。'
- en: '[![5](assets/5.png)](#co_testing_all_the_things_CO3-5)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_testing_all_the_things_CO3-5)'
- en: '`GetEmailAddressesCorrectlyGetsEmails` verifies when given claim type and value
    pair, the expected email addresses are returned.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetEmailAddressesCorrectlyGetsEmails`验证了当给定声明类型和值对时，返回预期的电子邮件地址。'
- en: The first four tests are decorated using the `Fact` attribute. This signals
    to xUnit’s discoverability mechanism that these methods represent a single unit
    test. Likewise, the last test is decorated with `Theory` and the `InlineData`
    attribute. This signals to xUnit that the test is a parameterized test. The `InlineData`
    attribute takes a string array of email addresses and the expected result. Unit
    tests decorated with `Theory` are run multiple times, once for each `InlineData`
    or against various data sets through other attributes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 前四个测试使用`Fact`属性进行装饰。这向 xUnit 的可发现性机制表明，这些方法代表了单个单元测试。同样，最后一个测试使用`Theory`和`InlineData`属性进行装饰。这向
    xUnit 表明这是一个参数化测试。`InlineData`属性接受一个电子邮件地址的字符串数组和预期结果。使用`Theory`装饰的单元测试会多次运行，每次运行一次`InlineData`或通过其他属性对各种数据集进行测试。
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: When writing `Theory` tests, it’s important to note that there are several types
    of data set attributes that can be used. You can do some powerful things with
    xUnit. I prefer it over the other options because it comes with analyzers that
    help ensure your tests are written correctly. For more information about xUnit
    analyzers, see my article [“xUnit Roslyn Analyzers”](https://oreil.ly/TP1pG).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写`Theory`测试时，重要的是注意可以使用多种类型的数据集属性。您可以使用 xUnit 执行一些强大的操作。我更喜欢它而不是其他选项，因为它带有分析器，帮助确保您的测试编写正确。有关
    xUnit 分析器的更多信息，请参阅我的文章[“xUnit Roslyn 分析器”](https://oreil.ly/TP1pG)。
- en: The `ClaimsPrincipalExtensionsTests` test class is a single set of eight unit
    tests. Some advantages to unit testing are that the tests usually run fast and
    they have good readability. At the time of writing, the Web.Extensions.Tests project
    had 31 tests, and it took 30 milliseconds to run all the tests.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClaimsPrincipalExtensionsTests` 测试类是一组八个单元测试。单元测试的一些优点是测试通常运行速度快且具有良好的可读性。在撰写本文时，Web.Extensions.Tests
    项目共有 31 个测试，所有测试运行时间为 30 毫秒。'
- en: Component Testing
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件测试
- en: Component testing focuses on a single component of functionality. Component
    tests have to deal with a bit more overhead than unit tests. This is because components
    often reference multiple other components, take on external dependencies, and
    manage the component’s state, among other reasons. With this added complexity
    comes a need for a test framework that can help you test your components.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 组件测试专注于功能的单个组件。与单元测试相比，组件测试需要处理更多的开销。这是因为组件通常引用多个其他组件，承担外部依赖项，并管理组件的状态，等等。随着这种增加的复杂性，需要一个可以帮助您测试组件的测试框架。
- en: 'Blazor components are unable to render themselves. This is where [bUnit](https://bunit.dev),
    a testing library for Blazor components, comes in. With bUnit, you can do the
    following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 组件无法自行呈现。这就是 [bUnit](https://bunit.dev) 这个用于 Blazor 组件的测试库的用武之地。通过 bUnit，您可以执行以下操作：
- en: Set up and define components under tests using C# or Razor syntax
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 C# 或 Razor 语法设置和定义正在测试的组件
- en: Verify outcomes using semantic HTML comparer
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用语义 HTML 比较器验证结果
- en: Interact with and inspect components as well as trigger event handlers
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与组件进行交互并检查组件，以及触发事件处理程序
- en: Pass parameters, cascade values, and inject services into components under test
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递参数、级联值和将服务注入到正在测试的组件中
- en: Mock `IJSRuntime`, Blazor authentication and authorization, and others
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟`IJSRuntime`、Blazor 认证和授权等
- en: To demonstrate component testing, we’re going to look at the Web.Client.Tests
    project in the model app. The Web.Client.Tests project was created using the same
    template as the xUnit test project that we did in the previous section. To simplify
    the passing of parameters to components and the verifying of markup, bUnit allows
    the test project to target the `Microsoft.NET.Sdk.Razor` SDK. This makes it a
    Razor project, so it can render Razor markup. The project also defines a `<Package​Refer⁠ence
    Include="bunit" Version="1.6.4" />` element, which tells the project to use the
    bUnit package. Like other test projects, we add a `<Project​Reference>` to the
    project that we’re going to write tests against. The `Web.Client​.Tests` project
    references the `Web.Client` project.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示组件测试，我们将查看模型应用程序中的 Web.Client.Tests 项目。Web.Client.Tests 项目是使用与我们在上一节中进行的
    xUnit 测试项目相同的模板创建的。为了简化向组件传递参数和验证标记，bUnit 允许测试项目针对`Microsoft.NET.Sdk.Razor` SDK。这使其成为一个
    Razor 项目，因此它可以呈现 Razor 标记。该项目还定义了一个 `<Package​Refer⁠ence Include="bunit" Version="1.6.4"
    />` 元素，告诉项目使用 bUnit 包。与其他测试项目一样，我们向项目添加了一个 `<Project​Reference>`，指向我们将要编写测试的项目。Web.Client.Tests
    项目引用了 Web.Client 项目。
- en: 'In this test, we’ll define some inputs and see how to write a test that arranges
    a component under test, acts on it, and then asserts that it renders correctly.
    Let’s jump right into a component test. Consider the *ChatMessageComponentTests.razor*
    Razor test file:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们将定义一些输入，并看看如何编写一个测试，安排一个组件进行测试，对其进行操作，然后断言其正确渲染。 让我们直接进入组件测试。 考虑 *ChatMessageComponentTests.razor*
    Razor 测试文件：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](assets/1.png)](#co_testing_all_the_things_CO4-1)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_testing_all_the_things_CO4-1)'
- en: The class inherits from the bUnit `TestContext` class.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 该类继承自 *bUnit* 的 *TestContext* 类。
- en: '[![2](assets/2.png)](#co_testing_all_the_things_CO4-2)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_testing_all_the_things_CO4-2)'
- en: Several test inputs are defined in the `ChatMessageInput` property.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *ChatMessageInput* 属性中定义了多个测试输入。
- en: '[![3](assets/3.png)](#co_testing_all_the_things_CO4-3)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_testing_all_the_things_CO4-3)'
- en: The test method is a theory, which means that it will be run multiple times,
    once for each element in the `ChatMessageInput` property.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 测试方法是一个理论，这意味着它将多次运行，每次运行时都会为 *ChatMessageInput* 属性中的每个元素运行一次。
- en: '[![4](assets/4.png)](#co_testing_all_the_things_CO4-4)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_testing_all_the_things_CO4-4)'
- en: '`ActorMessage` is arranged with inputs from the test method parameters.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActorMessage` 是根据测试方法参数进行安排的。'
- en: '[![5](assets/5.png)](#co_testing_all_the_things_CO4-5)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_testing_all_the_things_CO4-5)'
- en: '`ChatMessageComponent` is acted upon by rendering it given its required parameters.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChatMessageComponent` 根据其必需的参数进行渲染。'
- en: '[![6](assets/6.png)](#co_testing_all_the_things_CO4-6)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_testing_all_the_things_CO4-6)'
- en: The test asserts that the markup matches the expected markup.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 测试断言标记与预期标记匹配。
- en: The `ActorMessage` type is a `record` from the model app’s Web.Models project.
    The test framework provides `TestContext`, which is used to render the component
    under test (or `cut`). The `Render` method returns `IRenderedFragment`. The `MarkupMatches`
    method is one of many extension methods from bUnit that verifies that the rendered
    markup from the markup fragment matches the expected markup fragment.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActorMessage` 类型是模型应用的 *Web.Models* 项目中的 *record*。 测试框架提供了 *TestContext*，用于渲染待测试的组件（或
    *cut*）。 *Render* 方法返回 *IRenderedFragment*。 *MarkupMatches* 方法是来自 *bUnit* 的许多扩展方法之一，用于验证来自标记片段的渲染标记与预期标记的匹配。'
- en: To run these tests, you can use the `dotnet test` command or your favorite .NET
    IDE. When running these tests in Visual Studio, you can see the unique parameters
    for each test in the test summary details, as shown in [Figure 9-1](#component-test-results).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些测试，您可以使用 `dotnet test` 命令或您喜欢的 .NET IDE。 在 Visual Studio 中运行这些测试时，您可以在测试摘要详细信息中看到每个测试的唯一参数，如
    [图 9-1](#component-test-results) 所示。
- en: '![](assets/lblz_0901.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lblz_0901.png)'
- en: 'Figure 9-1\. Visual Studio: Test Explorer—test detail summary for the `ChatMessageComponentTests`'
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-1\. Visual Studio：测试资源管理器 —— *ChatMessageComponentTests* 的测试详细信息摘要
- en: Now that you’ve seen both unit tests and component tests, I’m going to show
    you how to achieve end-to-end testing. In the next section, I’ll introduce you
    to end-to-end testing with Playwright by Microsoft.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了单元测试和组件测试，我将展示如何实现端到端测试。 在下一节中，我将介绍 Microsoft 的 Playwright 如何进行端到端测试。
- en: End-to-End Testing with Playwright
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Playwright 进行端到端测试
- en: End-to-end testing is a way to test an entire scenario. It tests much more than
    the integration of a few parts of an app; instead, it exercises a full app scenario
    from beginning to end. [Playwright](https://playwright.dev) is a browser automation
    library that enables reliable end-to-end testing for modern web apps. It’s similar
    to Selenium, but in my professional experience, it is far more reliable and has
    an easier API surface area from the standpoint of ease of use. We can use Playwright
    to test our model app with multiple browsers, such as Chrome and Firefox.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试是测试整个场景的一种方式。 它不仅测试应用程序几个部分的集成，而是从头到尾执行整个应用程序场景。 [Playwright](https://playwright.dev)
    是一个浏览器自动化库，可为现代 Web 应用程序提供可靠的端到端测试。 它类似于 Selenium，但从我的专业经验来看，它更加可靠，并且在易用性方面具有更简单的
    API。 我们可以使用 Playwright 在多个浏览器（如 Chrome 和 Firefox）中测试我们的模型应用。
- en: 'To demonstrate end-to-end testing with Playwright, let’s look at a login test
    for our model app’s Web.Client project. As you may have realized, I enjoy writing
    `partial` classes and separating each `partial` into a separate file with shared
    common concepts. There’s a bit of utilitarian code in the *LoginTests.Utilities.cs*
    C# file in the Web.Client.EndToEndTests project:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示使用 Playwright 进行端到端测试，让我们看看模型应用的 Web.Client 项目中的登录测试。正如您可能已经意识到的那样，我喜欢编写
    `partial` 类，并将每个 `partial` 分离到具有共享通用概念的单独文件中。在 Web.Client.EndToEndTests 项目的 *LoginTests.Utilities.cs*
    C# 文件中有一些实用代码：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_testing_all_the_things_CO5-1)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_testing_all_the_things_CO5-1)'
- en: The class declares two constant `string` values, which are the live app URL
    for the Learning Blazor site and the authentication B2C site.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 该类声明了两个常量 `string` 值，分别是 Learning Blazor 站点的实时应用程序 URL 和认证 B2C 站点。
- en: '[![2](assets/2.png)](#co_testing_all_the_things_CO5-2)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_testing_all_the_things_CO5-2)'
- en: The `ToBrowser` method returns an `IBrowserType` instance, which is a wrapper
    around the Playwright browser type.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToBrowser` 方法返回一个 `IBrowserType` 实例，该实例是 Playwright 浏览器类型的包装器。'
- en: '[![3](assets/3.png)](#co_testing_all_the_things_CO5-3)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_testing_all_the_things_CO5-3)'
- en: The `GetTestCredentials` method returns a `Credentials` object, which is a `readonly
    record struct` type that contains the username and password for the test.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetTestCredentials` 方法返回一个 `Credentials` 对象，它是一个 `readonly record struct`
    类型，包含用于测试的用户名和密码。'
- en: '[![4](assets/4.png)](#co_testing_all_the_things_CO5-4)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_testing_all_the_things_CO5-4)'
- en: '`Credentials` is an immutable object with two `readonly string?` values representing
    a username and password pair.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`Credentials` 是一个不可变对象，具有两个 `readonly string?` 值，表示用户名和密码对。'
- en: '[![5](assets/5.png)](#co_testing_all_the_things_CO5-5)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_testing_all_the_things_CO5-5)'
- en: '`BrowserType` is an enumeration of the supported browsers.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`BrowserType` 是支持的浏览器的枚举。'
- en: These utilities will be used in the Playwright test itself.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实用工具将在 Playwright 测试中使用。
- en: Warning
  id: totrans-89
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The `Credentials` type is populated using environment variables. This is a *secure
    alternative* to hardcoding these values for the test. The environment variables
    are used for testing. The `TEST_USERNAME` and `TEST_PASSWORD` environment variables
    need to also exist in the continuous delivery pipeline. Luckily, if you’re using
    a GitHub repo, it’ll use GitHub Action workflows to consume encrypted secrets
    and run all the tests. This is good because it’s a secure alternative to hardcoding
    these values for the test, and the tests run automatically in the CI/CD pipeline.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Credentials` 类型使用环境变量进行填充。这是用于测试的*安全替代方案*，而不是在测试中硬编码这些值。环境变量用于测试。`TEST_USERNAME`
    和 `TEST_PASSWORD` 环境变量还需要存在于持续交付流水线中。幸运的是，如果您正在使用 GitHub 存储库，它将使用 GitHub Action
    工作流来消耗加密的密钥并运行所有测试。这很好，因为这是一个安全的替代方案，用于测试中的硬编码值，并且测试会自动在 CI/CD 流水线中运行。'
- en: 'The end-to-end tests run in both Chromium-based browsers (Chrome and Edge)
    and Firefox. Because these tests run in multiple browsers, you’ll need to specify
    input for each browser type. Let’s first look at the test input for Chromium by
    considering the following *LoginTests.Chromium.cs* file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试在基于 Chromium 的浏览器（Chrome 和 Edge）和 Firefox 中运行。因为这些测试在多个浏览器中运行，您需要为每种浏览器类型指定输入。让我们首先看一下
    Chromium 的测试输入，考虑以下 *LoginTests.Chromium.cs* 文件：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The xUnit testing framework allows for parameterization of test inputs. The
    `ChromiumLoginInputs` property is a collection of `object[]` objects, each of
    which contains the browser type, latitude, longitude, and the calculated location.
    There is an optional argument for `CultureInfo` to use for each test. The test
    input for Firefox is similar but with a different browser type. Consider the *LoginTests.Firefox.cs*
    file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: xUnit 测试框架允许对测试输入进行参数化。`ChromiumLoginInputs` 属性是一个 `object[]` 对象的集合，每个对象包含浏览器类型、纬度、经度和计算出的位置。每个测试还有一个可选的
    `CultureInfo` 参数。Firefox 的测试输入类似，但浏览器类型不同。考虑 *LoginTests.Firefox.cs* 文件：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The only difference between the two is the browser type. Next, let’s consider
    the *LoginTests.cs* file:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 两者之间唯一的区别是浏览器类型。接下来，让我们考虑 *LoginTests.cs* 文件：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_testing_all_the_things_CO6-1)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_testing_all_the_things_CO6-1)'
- en: The `IsHeadless` property is used when launching the test browser, and it determines
    whether the browser is launched in *headless* mode.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsHeadless` 属性在启动测试浏览器时使用，它确定浏览器是否以*无头*模式启动。'
- en: '[![2](assets/2.png)](#co_testing_all_the_things_CO6-2)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_testing_all_the_things_CO6-2)'
- en: '`CanLoginWithVerifiedCredentials` is a `Theory` test method that runs on both
    Chromium and Firefox browsers.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`CanLoginWithVerifiedCredentials`是一个在Chromium和Firefox浏览器上运行的`Theory`测试方法。'
- en: '[![3](assets/3.png)](#co_testing_all_the_things_CO6-3)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_testing_all_the_things_CO6-3)'
- en: The `playwright` object is initialized and creates a `browser` instance.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化了`playwright`对象并创建了浏览器实例。
- en: '[![4](assets/4.png)](#co_testing_all_the_things_CO6-4)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_testing_all_the_things_CO6-4)'
- en: The `browser` configures `geolocation` permissions and sets `latitude` and `longitude`
    to test values.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器配置了`geolocation`权限，并设置了`latitude`和`longitude`以测试数值。
- en: '[![5](assets/5.png)](#co_testing_all_the_things_CO6-5)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_testing_all_the_things_CO6-5)'
- en: The `context` from the configured `browser` creates a new page named `loginPage`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从配置的`browser`中的`context`创建名为`loginPage`的新页面。
- en: '[![6](assets/6.png)](#co_testing_all_the_things_CO6-6)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_testing_all_the_things_CO6-6)'
- en: The `loginPage` fills in the username and password and then clicks the “Sign
    in” button.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`loginPage`填写用户名和密码，然后点击“登录”按钮。'
- en: '[![7](assets/7.png)](#co_testing_all_the_things_CO6-7)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_testing_all_the_things_CO6-7)'
- en: The `text` from the `#weather-city-state` element is retrieved.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 检索`#weather-city-state`元素的`text`内容。
- en: The `CanLoginWithVerifiedCredentials` test is a good example of how to use Playwright.
    In this case, the test is considered a `Theory` test, and a set of parameters
    are passed in as arguments to the test. When using a `Theory` attribute, the test
    is run for each occurrence of test input collection—in this case, on both `Chromium`
    and `Firefox` browsers. The `GetTestCredentials` method is used to get the test
    credentials stored as environment variables. If they’re not present, the test
    will fail. The test browser instance is created and launched using the `ToBrowser`
    method. The `browser` object is configured with the `geolocation` permission,
    and `latitude` and `longitude` are set to test values. The `context` object is
    created, and `loginPage` is created from `context`. This is a result of awaiting
    the call to `NewPageAsync`. This method creates a new page in the browser context.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`CanLoginWithVerifiedCredentials`测试是如何使用Playwright的良好示例。在这种情况下，测试被认为是一个`Theory`测试，并且一组参数作为测试输入集合的参数传递给测试。在使用`Theory`属性时，测试将针对测试输入集合中的每个出现运行，本例中为`Chromium`和`Firefox`浏览器。使用`GetTestCredentials`方法获取存储为环境变量的测试凭据。如果不存在，测试将失败。使用`ToBrowser`方法创建并启动测试浏览器实例。配置`browser`对象的`geolocation`权限，并设置`latitude`和`longitude`为测试值。创建`context`对象，并从`context`创建`loginPage`。这是等待调用`NewPageAsync`的结果。此方法在浏览器上下文中创建新页面。'
- en: 'We’re validating that a verified and registered user can log in to the Learning
    Blazor site. We instruct the `context` to run and wait for `loginPage` to navigate
    to the Learning Blazor site. As part of this operation, we conditionally add an
    initialization script that will set the client culture with the given `locale`.
    This is extremely powerful, as it allows for the testing of translations. It tests
    the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们验证已验证和注册的用户可以登录到Learning Blazor网站。我们指示`context`运行并等待`loginPage`导航到Learning
    Blazor网站。作为操作的一部分，我们有条件地添加一个初始化脚本，将根据给定的`locale`设置客户端文化。这非常强大，因为它允许测试翻译。它测试以下内容：
- en: The user can log in with the correct credentials.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以使用正确的凭据登录。
- en: Given a user’s locale, the weather data is displayed in the correct language.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定用户的locale，天气数据以正确的语言显示。
- en: With `loginPage`, we then wait for the browser’s URL to match the login site
    URL. As the URL changes, the code will wait for the page to render its HTML, the
    document to be fully loaded, and the network to be idle. If this doesn’t happen
    within a configurable amount of time, the test will fail. Once this condition
    is met, we fill in the username and password and click the “Sign in” button.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`loginPage`等待浏览器的URL匹配登录站点的URL。随着URL的更改，代码将等待页面呈现其HTML，完全加载文档并处于空闲状态的网络。如果在可配置的时间内未能实现这一条件，则测试将失败。一旦满足此条件，我们填写用户名和密码，然后点击“登录”按钮。
- en: If we’re unable to interact with the login page or cannot find any of these
    specific elements or attributes, the test will fail. The test submits the login
    test credentials and given their `geolocation` permissions, the browser will be
    able to determine the current location. The test ends by verifying that the `#weather-city-state`
    element contains the correct text. The test `latitude` and `longitude` are set
    to the test’s theory values as parameters. The correct string is matched against
    the known formatted City, State, and Country values.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法与登录页面进行交互，或者找不到任何特定的元素或属性，测试将失败。测试提交登录测试凭据，并根据其 `geolocation` 权限，浏览器将能够确定当前位置。测试通过验证
    `#weather-city-state` 元素是否包含正确的文本来结束。测试的 `latitude` 和 `longitude` 参数设置为测试的理论值。正确的字符串与已知的格式化城市、州和国家值进行匹配。
- en: All of this functionality is possible only when an authenticated user is logged
    in and their location is known. This end-to-end test runs on two browsers, and
    it is triggered whenever you `push` code to `main` on the app’s GitHub repository.
    This automated testing functionality pairs perfectly with the other tests in the
    model app! All of these tests are run in an automated fashion, and the results
    are automatically published to the CI pipeline. Let’s take a look at that next.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在已认证用户登录并知道其位置时，所有这些功能才可能。此端到端测试在两个浏览器上运行，并且每当您向应用的 GitHub 仓库的 `main` 分支 `push`
    代码时触发。此自动化测试功能与模型应用中的其他测试完美配合！所有这些测试都以自动化方式运行，并且结果会自动发布到 CI 流水线。接下来我们来看看这一点。
- en: Automating Test Execution
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化测试执行
- en: A wise person once told me, “Automate yourself out of a job,”^([1](ch09.html#idm46364998674128))
    and I’m happy to tell you that this philosophy pays dividends. As a developer,
    your goal is to be lazy, in a way. Whenever you catch yourself doing the same
    thing repeatedly, it’s time to automate. One way to do this is to use GitHub Actions.
    I love GitHub Actions! It’s a powerful and straightforward tool that you can use
    to automate the testing of your code as the code changes. I’m very excited to
    use GitHub Actions to automate the testing of my code. I believe it’s straightforward
    to automate the deployment of my code. In my opinion, GitHub has perfected the
    art of automation. With just a few lines of code, you can create a fully automated
    CI/CD pipeline.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有智慧的人曾告诉我，“把自己自动化掉”，^([1](ch09.html#idm46364998674128)) 我很高兴告诉你，这种理念会带来回报。作为开发者，你的目标是某种程度上的懒惰。每当你发现自己重复做同样的事情时，就是自动化的时候了。使用
    GitHub Actions 是其中一种方法。我喜欢 GitHub Actions！它是一个强大且简单的工具，您可以使用它来自动化代码变更时的测试。我非常激动能够使用
    GitHub Actions 来自动化我的代码测试。我相信，自动化部署我的代码是非常直接的。在我看来，GitHub 已经完美地掌握了自动化的艺术。只需几行代码，您就可以创建一个完全自动化的
    CI/CD 流水线。
- en: 'In this section, I’ll show you how to automate a test with GitHub Action workflows,
    using the Learning Blazor app as an example. To start, all recognizable GitHub
    Action workflow files should reside in the *.github/workflows* directory of your
    project’s GitHub repository. For example, in the Learning Blazor repository, there’s
    a `.github/workflows/build-validation.yml` file used to build and run unit tests.
    The build will fail if any of the numerous tests fail. Let’s look at the *build-validation.yml*
    YAML file:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向您展示如何使用 GitHub Action workflows 自动化测试，以 Learning Blazor 应用为例。首先，所有可识别的
    GitHub Action workflow 文件都应位于项目的 GitHub 仓库的 *.github/workflows* 目录中。例如，在 Learning
    Blazor 仓库中，有一个 `.github/workflows/build-validation.yml` 文件用于构建和运行单元测试。如果任何测试失败，构建将失败。让我们看一下
    *build-validation.yml* YAML 文件：
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_testing_all_the_things_CO7-1)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_testing_all_the_things_CO7-1)'
- en: The `name` is what displays on the GitHub *README.md* file status badges, along
    with the status of the latest run.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`name` 就是显示在 GitHub *README.md* 文件状态徽章上的内容，以及最新运行的状态。'
- en: '[![2](assets/2.png)](#co_testing_all_the_things_CO7-2)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_testing_all_the_things_CO7-2)'
- en: Using the `on` attribute, we’re telling the GitHub Action to run on a specific
    event.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `on` 属性，我们告诉 GitHub Action 在特定事件上运行。
- en: '[![3](assets/3.png)](#co_testing_all_the_things_CO7-3)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_testing_all_the_things_CO7-3)'
- en: The `env` attribute is used to set environment variables.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`env` 属性用于设置环境变量。'
- en: '[![4](assets/4.png)](#co_testing_all_the_things_CO7-4)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_testing_all_the_things_CO7-4)'
- en: Every workflow has a `jobs` attribute, and a job has multiple `steps`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 workflow 都有一个 `jobs` 属性，而一个 job 则包含多个 `steps`。
- en: '[![5](assets/5.png)](#co_testing_all_the_things_CO7-5)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_testing_all_the_things_CO7-5)'
- en: Prepare the .NET CLI in the build environment, or install build dependencies.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建环境中准备 .NET CLI，或安装构建依赖项。
- en: '[![6](assets/6.png)](#co_testing_all_the_things_CO7-6)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_testing_all_the_things_CO7-6)'
- en: Playwright requires NodeJS and its package manager, the Node Package Manager
    (NPM).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Playwright 需要 NodeJS 及其包管理器，即 Node Package Manager（NPM）。
- en: '[![7](assets/7.png)](#co_testing_all_the_things_CO7-7)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_testing_all_the_things_CO7-7)'
- en: Finally, `dotnet test` is called, running all three sets of tests.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用 `dotnet test`，运行所有三组测试。
- en: In this case, we’re telling the workflow to run on a `push` event, and we’re
    running on only the `main` branch. We can specify additional logic to function
    on the `pull_request` event or even run it manually from the GitHub UI with the
    `workflow_dispatch` event. With this automated workflow, GitHub Actions will automatically
    run tests as your code changes so you don’t have to.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们告诉工作流在 `push` 事件时运行，并且仅在 `main` 分支上运行。我们可以指定额外的逻辑以在 `pull_request`
    事件上运行，或者甚至可以通过 GitHub UI 的 `workflow_dispatch` 事件手动运行它。通过这个自动化工作流，GitHub Actions
    将根据您的代码更改自动运行测试，这样您就无需手动操作。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, you learned why it’s important to test your code. You saw three
    distinct ways you can test your Blazor applications. You can use unit testing
    to make sure the tiniest pieces of your app are on point, component testing to
    make sure groups of things are going smoothly, and end-to-end testing to ensure
    that everything works together. You saw how to automate testing through GitHub
    Actions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解到测试代码的重要性。您看到了三种不同的方法来测试您的 Blazor 应用程序。您可以使用单元测试来确保应用程序的最小组成部分是正确的，使用组件测试来确保一组组件正常工作，以及使用端到端测试来确保一切协同工作。您还了解了如何通过
    GitHub Actions 自动化测试。
- en: We’ve covered a lot of ground throughout this entire book. I’ve shared with
    you some of the most important moving parts of an enterprise-scale app containing
    more than 90,000 lines of code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在整本书中覆盖了很多内容。我与您分享了一个包含超过 90,000 行代码的企业级应用程序的一些最重要的组成部分。
- en: 'To continue learning about Blazor, I encourage you to check out the following
    resources:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 若要继续学习 Blazor，我鼓励您查看以下资源：
- en: The [official Microsoft Docs](https://oreil.ly/eiO9A) by the amazing ASP.NET
    Core team
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由令人惊叹的 ASP.NET Core 团队编写的 [官方 Microsoft 文档](https://oreil.ly/eiO9A)
- en: The [Awesome Blazor GitHub repository](https://oreil.ly/icivq), which acts as
    a collection of awesome Blazor resources
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[了不起的 Blazor GitHub 仓库](https://oreil.ly/icivq)，作为一组出色的 Blazor 资源的集合'
- en: '[Blazor University (by Peter Morris)](https://oreil.ly/02X21), a free online
    Blazor site packed with educational content'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Blazor 大学（由 Peter Morris 创作）](https://oreil.ly/02X21)，一个免费的在线 Blazor 站点，充满了教育内容'
- en: '[On-demand Blazor content](https://oreil.ly/9UAnV) from the .NET Community
    on YouTube'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在需时的 Blazor 内容](https://oreil.ly/9UAnV) 来自 YouTube 上的 .NET 社区'
- en: I hope that you’ve enjoyed this book, and I hope that you’ll continue to learn
    and grow as a developer. All in all, Blazor is a very well-suited web application
    framework. To me, .NET has a huge advantage over other programming languages and
    platforms, as I have shown throughout this book. I hope that my love for this
    stack will shine through. Thank you for giving me this opportunity to walk you
    through *Learning Blazor*!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您喜欢这本书，并希望您作为开发人员继续学习和成长。总的来说，Blazor 是一个非常适合的 Web 应用程序框架。对我来说，.NET 在其他编程语言和平台上有很大优势，正如我在本书中展示的那样。希望我对这个技术栈的热爱能够通过。感谢您给我这个机会为您详细介绍
    *学习 Blazor*！
- en: ^([1](ch09.html#idm46364998674128-marker)) Scott Hanselman of Microsoft.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch09.html#idm46364998674128-marker)) Microsoft 的 Scott Hanselman。
