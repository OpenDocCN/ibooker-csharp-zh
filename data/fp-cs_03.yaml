- en: Chapter 3\. Functional Coding in C# 7 and Beyond
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章。C# 7 及以后的函数式编程
- en: I’m not sure when exactly the decision was made to make C# a hybrid Object-Oriented/Functional
    language. The very first foundation work was laid in C# 3\. That was when features
    like Lambda Expressions and Anonymous Types were introduced, which later went
    on to form parts of Linq in .NET 3.5.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我不确定具体是在何时做出决定将 C# 设计为混合面向对象/函数式语言。最初的基础工作是在 C# 3 中奠定的。那时引入了 Lambda 表达式和匿名类型等特性，后来成为
    .NET 3.5 中 LINQ 的一部分。
- en: After that though, there wasn’t much new in terms of Functional features for
    quite some time. In fact, it wasn’t really until the release on C# 7 in 2017 that
    Functional Programming seemed to become relevant again to the C# team.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在相当长的一段时间内，关于函数式特性并没有什么新东西。事实上，直到 2017 年 C# 7 发布之后，函数式编程似乎再次对 C# 团队变得相关起来。
- en: From C# 7 onwards, every version of C# has contained something new and exciting
    to do more Functional style coding, a trend that doesn’t currently show any signs
    of stopping!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 7 开始，每个版本的 C# 都包含了一些新的、令人兴奋的内容，以更多函数式编码的方式，这种趋势目前看来并没有停止的迹象！
- en: In the last chapter, we looked at Functional features that could be implemented
    in just about any C# codebase likely to still be in use out in the wild. In this
    chapter, we’re going to throw away that assumption and look at all the features
    you can make use of if your codebase is allowed to use any of the very latest
    features - or at least those released since C# 7.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看了一些几乎可以在野外使用的任何 C# 代码库中实现的函数式特性。在本章中，我们将抛弃这种假设，看看如果你的代码库允许使用最新的特性或至少自
    C# 7 以来发布的特性，你可以使用哪些功能。
- en: Tuples
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: Tuples were introduced in C#7\. Nuget packages do exist to allow some of the
    older versions of C# to use them too. They’re basically a way to throw together
    a quick-and-dirty collection of properties, without having to create and maintain
    a class.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 元组在 C# 7 中被引入。Nuget 包存在以允许一些旧版本的 C# 使用它们。它们基本上是一种快速且简单的属性集合方式，而无需创建和维护一个类。
- en: If you’ve got a few properties you want to hold onto for a minute in one place,
    then dispose of immediately, Tuples are great for that.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有几个属性想要在一个地方暂时保留一会儿，然后立即处理掉，元组非常适合。
- en: If you have multiple objects you want to pass between Selects, or multiple items
    you want to pass in or out of one, then you can use a Tuple.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有多个对象想要在选择操作之间传递，或者想要在一个操作中传入或传出多个项，那么你可以使用元组。
- en: 'This is an example of the sort of thing you might consider using Tuples for:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用元组的一个例子：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In my example, above, I use a Tuple to pair up data from two look-up functions
    for each given film Id, meaning I can run a subsequent Select to simplify the
    pair of objects into a single return value.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的例子中，我使用元组来配对每个给定电影 ID 的两个查找函数的数据，这意味着我可以运行后续的选择操作，将一对对象简化为单个返回值。
- en: Pattern Matching
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配
- en: Switch statements have been around for longer than just about any developers
    still working today. They have their uses, but they’re quite limited in what can
    be done with them. Functional Programming has taken that concept and moved it
    up a few levels. That’s what Pattern Matching is.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Switch 语句已经存在比今天大多数仍在工作的开发者还要久远。它们有它们的用途，但在所能做的事情上相当有限。函数式编程将这一概念提升了几个层次。这就是模式匹配的作用。
- en: It was C# 7 that started to introduce this feature to the C# language, and it
    has been subsequently enhanced multiple times in later versions, and most likely
    there will be yet more features added in the future.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7 开始引入这一功能到 C# 语言中，并在后续版本中进行了多次增强，未来很可能还会增加更多功能。
- en: Pattern matching is an amazing way to save yourself an awful lot of work. To
    show you what I mean, I’ll now show you a bit of Procedural code, and then how
    pattern matching is implemented in a few different versions of C#.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配是节省大量工作的一种绝佳方式。为了让你明白我的意思，我现在将展示一些过程式代码，并展示模式匹配在几个不同版本的 C# 中是如何实现的。
- en: Procedural Bank Accounts
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过程化银行账户
- en: For our example, let’s imagine one of the classic Object-Oriented worked examples
    - Bank Accounts. I’m going to create a set of bank account types, each with different
    rules for how to calculate the amount of interest. These aren’t really based on
    real banking, they’re straight out of my imagination.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，让我们想象一个经典的面向对象的示例 - 银行账户。我将创建一组银行账户类型，每种类型都有不同的规则来计算利息金额。这些并不是真实银行业务，完全出自我的想象。
- en: 'These are my rules:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我的规则：
- en: A standard bank account calculates interest by multiplying the balance by the
    interest Rate for the account
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准银行账户通过将余额乘以账户的利率来计算利息
- en: A premium bank account with a balance of 10,000 or less is a standard Bank account
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 余额为10,000或更少的高级银行账户是标准银行账户
- en: A premium bank account with a balance over 10,000 applies an interest rate augmented
    by a bonus additional rate
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 余额超过10,000的高级银行账户应用了一个额外奖励利率增强的利率
- en: A Millionaire’s bank account, who owns so much money it’s larger than the largest
    value a decimal can hold (It’s a really, really big number - around 8*10^28, so
    they must be very wealthy indeed. Do you think they’d be willing to lend me a
    little, if I were to ask? I could do with a new pair of shoes). They have an overflow
    balance property to add in all that money they own that is over the max decimal
    value, that they can’t store in the standard balance property like us plebs. They
    need the interest to be calculated based on both balances.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 百万富翁的银行账户，他们拥有的钱比一个十进制可以容纳的最大值还要多（这是一个非常非常大的数字 - 大约8*10^28，所以他们肯定非常富有。你认为如果我要求他们一点钱，他们会愿意借给我吗？我需要一双新鞋）。他们有一个溢出余额属性，用于添加所有那些他们拥有的超过最大十进制值的钱，这些钱无法像我们这些平民一样存储在标准余额属性中。他们需要根据两个余额计算利息。
- en: A Monopoly player’s bank account. They get an extra 200 for passing Go. I’m
    not implementing the “Go Direct to Jail” Logic, there are only so many hours in
    a day.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大富翁玩家的银行账户。他们经过“前进”时会额外得到200。我没有实现“直接去监狱”逻辑，一天只有那么多时间。
- en: 'These are my classes:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我的类：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The procedural approach to implementing the CalculateInterest feature for bank
    accounts - or as I think of it the “long-hand” approach, could possibly look like
    this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于银行账户实现计算利息功能的过程化方法 - 或者我认为的“长式”方法，可能会像这样：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As is typical with Procedural code, the above code isn’t very concise, and might
    take a little bit of reading to understand its intent. It’s also wide open to
    abuse if many more new rules are added once the system goes into production.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与过程化代码一样，上面的代码不太简洁，可能需要一点时间来理解其意图。一旦系统投入生产，如果添加了许多新规则，它也很容易被滥用。
- en: The Object-Oriented approach would be either to use an interface, or polymorphism
    - i.e. create an abstract base class with a virtual method for the CalculateNewBalance
    function. The issue with that is that the logic is now split over many places,
    rather than being contained in a single, easy-to-read function.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的方法要么使用接口，要么使用多态性 - 即创建一个带有CalculateNewBalance函数的抽象基类。问题在于，现在逻辑分散在许多地方，而不是包含在一个易于阅读的函数中。
- en: In the sections that follow, I’ll show how each subsequent version of C# handled
    this problem.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我将展示每个后续版本的C#是如何处理这个问题的。
- en: Pattern Matching in C# 7
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 7中的模式匹配
- en: C# 7 gave us two different ways of solving this problem. The first was the new
    `is` operator - a much more convenient way of checking types than had previously
    been available. An `is` operator can also be used to automatically cast the source
    variable to the correct type.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7为我们提供了解决这个问题的两种不同方法。首先是新的`is`运算符 - 一种比以前可用的检查类型更方便的方式。`is`运算符还可以用于自动将源变量转换为正确的类型。
- en: 'Our updated source would look something like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新后的源码将看起来像这样：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note in the code sample above, that with the `is` operator, we can also automatically
    wrap the source variable into a new local variable of the correct type.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意上述代码示例中，使用`is`运算符，我们还可以自动将源变量包装成正确类型的新局部变量。
- en: This isn’t bad, it’s a little more elegant, and we’ve saved ourselves a few
    redundant lines, but we could do better, and that’s where another feature of C#
    7 comes in - type switching.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这不错，有点更加优雅，我们也节省了一些冗余的行数，但我们可以做得更好，这就是C# 7的另一个特性介入的地方 - 类型切换。
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Pretty cool, right? Pattern Matching seems to be one of the most developed features
    of C# in recent years. As I’m about to show, every major version of C# since this
    has continued to add to it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 挺酷，对吧？模式匹配似乎是近年来C#中最发达的功能之一。正如我即将展示的，自此以来的每个主要C#版本都在其上继续添加功能。
- en: Pattern Matching in C# 8
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 8中的模式匹配
- en: Things moved up a notch in C# 8, pretty much the same concept, but with a new,
    updated matching syntax that more closely matches JSON, or a C# object initializer
    expression. Any number of clauses to properties or sub-properties of the object
    under examination can be put inside the curly braces, and the default case is
    now represented by the *_* discard character.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: C# 8 中的事情有了进展，基本上是相同的概念，但有了一个新的、更新的匹配语法，更接近 JSON，或者说是一个 C# 对象初始化表达式。任意数量的子句可以放在对象检查的大括号内，而默认情况现在由
    *_* 丢弃字符表示。
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Also, switch can now **also** be an expression, which you can use as the body
    of a small, single-purpose function with surprisingly rich functionality. This
    means it can also be stored in a Func delegate for potential passing around as
    a Higher-Order function.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，switch 现在**也**可以是一个表达式，你可以将其用作小型单用途函数的主体，具有出乎意料的丰富功能。这意味着它也可以存储在 Func 委托中，以便可能作为高阶函数传递。
- en: 'This is an example using an old childhood game: Scissor, Paper Stone. Known
    in the US as Rock, Paper, Scissors and in Japan as Janken. I’ve created a `Func`
    delegate in the following example with the following rules:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用老童年游戏的例子：剪刀、石头、布。在美国被称为石头、纸、剪刀，在日本被称为石头、纸、剪刀。在以下示例中，我创建了一个 `Func` 委托，并制定了以下规则：
- en: Both players drawing the same = draw
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两名玩家同时画出相同的 = 平局
- en: Scissors beats paper
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剪刀胜纸
- en: Paper beats stone
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 石头胜纸
- en: Stone beats scissors
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 石头胜剪刀
- en: This function is specifically determining what the result is from *my* perspective
    against my imaginary adversary.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数具体确定了从*我的*角度对我的想象对手的结果是什么。
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Having stored it in a ‘Func<SPS,SPS>’ typed variable, I can pass it around to
    wherever needs it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将其存储在 'Func<SPS,SPS>' 类型的变量中后，我可以将其传递到任何需要它的地方。
- en: 'This can be as a parameter to a function, so that the functionality can be
    injected at run-time:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以作为函数的参数，以便在运行时可以注入功能：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If I wanted to test the logic of this function without putting the actual logic
    into it, I could easily inject my own `Func` from a test method instead, so I
    wouldn’t have to care what the real logic is - that can be tested in a dedicated
    test elsewhere.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想要测试该函数的逻辑而不将实际逻辑放入其中，我可以轻松地从测试方法中注入自己的 `Func`，这样我就不必关心真实逻辑是什么——可以在其他专门的测试中进行测试。
- en: It’s another small way to make the structure even more useful.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使结构更加有用的又一个小改进。
- en: Pattern Matching in C# 9
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 9 中的模式匹配
- en: Nothing major added in C# 9, but a couple of nice little features. The `and`
    and `not` keywords from `is` expressions now work inside the curly braces of one
    of the patterns in the list, and it’s not necessary any longer to have a local
    variable for a cast type if the properties of it aren’t needed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 9 中没有添加重大内容，但有几个不错的小功能。现在在模式列表的大括号内部，`is` 表达式的 `and` 和 `not` 关键字可以工作了，并且如果不需要其属性，则不再需要一个用于转换类型的局部变量。
- en: Although not ground breaking, this does continue to reduce the amount of necessary
    boilerplate code, and gives us an extra few pieces of more expressive syntax.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是突破性的，但这确实继续减少必要的样板代码量，并为我们提供了更多表达性更强的语法片段。
- en: I’ve added a few more rules into the next example using these features. Now
    there are two categories of PremiumBankAccounts with different levels of special
    interest rates^([1](ch03.html#idm45400879635904)) and another bank account type
    for a Closed account, which shouldn’t generate any interest.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我在下一个示例中加入了一些更多的规则，使用这些功能。现在有两类带有不同特殊利率水平的 PremiumBankAccounts，还有一种用于已关闭账户的银行账户类型，不应该产生任何利息^([1](ch03.html#idm45400879635904))。
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Not bad, is it?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 还不错，对吧？
- en: Pattern Matching in C# 10
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 10 中的模式匹配
- en: Like C# 9, C# 10 includes just the addition of another nice time-and-boilerplate-saving
    feature. A simple syntax for comparing the properties of sub-objects belonging
    to the type being examined.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 像 C# 9 一样，C# 10 只是增加了另一个不错的节省时间和样板的功能。用于比较属于正在检查的类型的子对象属性的简单语法。
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this slightly silly example, it’s now possible to exclude all “Simon"s from
    earning so much money in Monopoly when passing Go. Poor, old me.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个有些愚蠢的例子中，现在可以在通过 Monopoly 时排除所有的“Simon”们赚取这么多钱。可怜的我。
- en: I’d suggest taking another moment at this point to examine the function, above.
    Think just how much code would have to be written if it weren’t done as a Pattern
    Matching expression! As it is, it **technically** comprises just a single line
    of code. One…​really long…​line of code, with a whole ton of NewLines in to make
    it readable. Still, the point stands.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议此时再花点时间检查上面的函数。想象一下，如果不作为模式匹配表达式完成，将需要编写多少行代码！事实上，它**从技术上讲**仅包括一行代码。一…真的很长…行代码，有很多
    NewLines 使其可读。尽管如此，这个观点仍然适用。
- en: C# 11
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 11
- en: C# 11 contains a new pattern matching feature which probably has a somewhat
    limited scope of useage, but will be devestatingly useful when something fits
    into that scope.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: C# 11 包含了一个新的模式匹配功能，可能使用范围有些有限，但当符合其条件时将会非常有用。
- en: The .NET team have added in the ability to match based on the contents of an
    Enumerable and even to deconstruct elements from it into separate variables.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 团队已经添加了基于 Enumerable 内容进行匹配甚至将其解构为单独变量的能力。
- en: Let’s imagine we were creating a very simple text-based adventure game. These
    were a big thing when I was very young. Adventure games you played by typing in
    commands. Imagine something like Monkey Island, but with no graphics, just text.
    You had to use your imagination a lot more back then.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象我们正在创建一个非常简单的基于文本的冒险游戏。当我很小的时候，这些东西很流行。冒险游戏是通过键入命令来玩的。想象一下像 Monkey Island
    这样的东西，但没有图形，只有文本。你必须更多地依靠自己的想象力。
- en: The first task would be to take the input from the user and decide what it is
    they’re trying to do. In English commands will just about universially have their
    relevant verbs as the first word of the sentance. “GO WEST”, “KILL THE GOBLIN”,
    “EAT THE SUSPICIOUS-LOOKING MUSHROOM”. The relevant verbs here are GO, KILL and
    EAT respectively.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个任务是从用户那里接收输入并决定他们试图做什么。在英语命令中，动词通常作为句子的第一个词。“GO WEST”，“KILL THE GOBLIN”，“EAT
    THE SUSPICIOUS-LOOKING MUSHROOM”。这里的相关动词是 GO、KILL 和 EAT 分别。
- en: 'Here’s how we’d use C# 11 pattern matching:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何使用 C# 11 模式匹配的方式：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The “..” in the above switch expression means “I don’t care what else is in
    the array, ignore it”. Putting a variable after it is used to contain everything
    else in the array besides those bits that’re specifically matched for.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 上述开关表达式中的“..”表示“我不在乎数组中的其他内容，请忽略它”。在其后放置一个变量用于包含除了那些特别匹配的部分之外的数组中的其他所有内容。
- en: In my example above, if I were to enter the text “GO WEST”, then the GoTo action
    would be called with a single-element array ["WEST"] as a parameter, because “GO”
    was part of the match.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在我上面的示例中，如果我输入文本“GO WEST”，那么 GoTo 操作将以单元素数组["WEST"]作为参数调用，因为“GO”是匹配的一部分。
- en: Here’s another neat way of using it. Imagine I’m processing people’s names into
    data structures and I want 3 of them to be FirstName, LastName and an array -
    MiddleNames (I’ve only got one middle name, but plenty of folks have many).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一种很好的使用方式。想象我正在将人们的姓名处理成数据结构，我想要其中3个是 FirstName、LastName 和一个数组 - MiddleNames（我只有一个中间名，但很多人有多个）。
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this example, the Person class is instantiated with:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，Person 类被实例化为：
- en: FirstName = “Percy”, LastName = “Kent-Smith”, MiddleNames = [ “James”, “Patrick”
    ]
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: FirstName = “Percy”, LastName = “Kent-Smith”, MiddleNames = [ “James”, “Patrick”
    ]
- en: I’m not sure I’ll find many uses for this, but it’ll probably get me very excited
    when I do. It’s a very powerful feature.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我不确定我会找到很多使用场景，但当我找到时，它可能会让我非常兴奋。这是一个非常强大的功能。
- en: Discriminated Unions
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区分联合
- en: 'I’m not sure whether this is something we’ll ever get in C# or not. I’m aware
    of at least 2 attempts to implement this concept that are available currently
    in Nuget:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我不确定这是否是我们将来在 C# 中会得到的东西。我知道目前 Nuget 上至少有两个尝试来实现这个概念：
- en: Harry McIntyre’s OneOf ([*https://github.com/mcintyre321/OneOf*](https://github.com/mcintyre321/OneOf))
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Harry McIntyre 的 OneOf ([*https://github.com/mcintyre321/OneOf*](https://github.com/mcintyre321/OneOf))
- en: Kim Hugener-Olsen’s Sundew.DiscriminatedUnions ([*https://github.com/sundews/Sundew.DiscriminatedUnions*](https://github.com/sundews/Sundew.DiscriminatedUnions))
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kim Hugener-Olsen 的 Sundew.DiscriminatedUnions ([*https://github.com/sundews/Sundew.DiscriminatedUnions*](https://github.com/sundews/Sundew.DiscriminatedUnions))
- en: I cover Discriminated Unions and how they could be implemented in C# in an awful
    lot more detail in Chapter 6, so skip ahead to there if you want to see more.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我在第6章详细讨论了区分联合及其在 C# 中的实现方式，如果您想了解更多，请跳转到那里。
- en: 'In brief: they’re a way of having a type that might actually be one of several
    types. They’re available natively in F#, but C# doesn’t have them to date and
    it’s anyone’s guess whether they ever will be available.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 简言之：它们是一种可能是几种类型之一的类型。它们在 F# 中可以本地使用，但是截至目前 C# 并没有这些功能，而它们是否会被添加还不得而知。
- en: In the meantime there are discussions happening over on GitHub ([*https://github.com/dotnet/csharplang/issues/113*](https://github.com/dotnet/csharplang/issues/113))
    and proposals in existence ([*https://github.com/dotnet/csharplang/blob/main/proposals/discriminated-unions.md*](https://github.com/dotnet/csharplang/blob/main/proposals/discriminated-unions.md)).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，在 GitHub 上正在进行讨论（[*https://github.com/dotnet/csharplang/issues/113*](https://github.com/dotnet/csharplang/issues/113)），并且已存在提案（[*https://github.com/dotnet/csharplang/blob/main/proposals/discriminated-unions.md*](https://github.com/dotnet/csharplang/blob/main/proposals/discriminated-unions.md)）。
- en: I’m not aware of any serious plans to add them to C# 12, so for now we’ll just
    have to keep watching the skies!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道有任何严肃的计划将它们添加到 C# 12 中，所以现在我们只能继续观望！
- en: Active Patterns
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动模式
- en: 'This an F# feature I can see being added to C# sooner or later. It’s an enhancement
    to Pattern Matching that allows functions to be executed in the left hand “pattern”
    side of the expression. This is an F# example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我可以预见到的一个 F# 特性很快会被添加到 C# 中。这是对模式匹配的增强，允许在表达式的左侧“模式”部分执行函数。这是一个 F# 的例子：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What F# developers are able to do, as in this example, is to provide their own
    custom functions to go on the left hand “pattern” side of the expression.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: F# 开发者能够做的事情，例如这个例子，是提供自己的自定义函数，以便放在表达式的左侧“模式”部分。
- en: “IsDateTime” is the custom function here, defined on the first line. It takes
    a string, and returns a value if the parse worked, and what is effectively a null
    result if it doesn’t.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，“IsDateTime”是自定义函数，定义在第一行。它接受一个字符串，并且如果解析成功则返回一个值，如果解析失败则返回一个类似于空结果的值。
- en: The pattern match expression “tryParseDateTime” uses IsDateTime as the pattern,
    if a value is returned from IsDateTime, then that case on the pattern match expression
    is selected and the resulting DateTime is returned.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配表达式“tryParseDateTime”使用 IsDateTime 作为模式，如果从 IsDateTime 返回了一个值，则选择模式匹配表达式中的该情况，并返回生成的
    DateTime。
- en: 'Don’t worry too much about the intricacies of F# syntax, I’m not expecting
    you to learn about that here. There are other books for F#, and you could probably
    do worse than one or more of these:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过多担心 F# 语法的复杂性，我不指望你在这里学习这些。有其他的 F# 书籍，你可能会选择一本或多本来了解。
- en: Get Programming with F# by Isaac Abraham (Manning)
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由 Isaac Abraham 撰写的《Get Programming with F#》（Manning）
- en: Essential F# by Ian Russell ([*https://leanpub.com/essential-fsharp*](https://leanpub.com/essential-fsharp))
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由 Ian Russell 编写的《Essential F#》（[*https://leanpub.com/essential-fsharp*](https://leanpub.com/essential-fsharp)）
- en: F# for Fun and Profit by Scott Wlaschin ([*https://fsharpforfunandprofit.com/*](https://fsharpforfunandprofit.com/))
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由 Scott Wlaschin 编写的《F# for Fun and Profit》（[*https://fsharpforfunandprofit.com/*](https://fsharpforfunandprofit.com/)）
- en: Whether either of these F# features becomes available in a later version of
    C# remains to be seen, but C# and F# share a common language runtime, so it’s
    not beyond imagining that they might be ported over.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个 F# 功能是否会在以后的 C# 版本中提供还有待观察，但是 C# 和 F# 共享一个通用语言运行时，因此它们被移植过来并非不可能。
- en: Read-only Structs
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 只读结构体
- en: I’m not going to discuss Structs a great deal here, there are other excellent
    books that talk about the features of C#^([2](ch03.html#idm45400872249424)) in
    far more detail. What’s great about them from a C# perspective is that they’re
    passed between functions by value, not reference - i.e. a copy is passed in, leaving
    the original untouched. The old OO technique of passing an object into a function
    for it to be modified there, away from the function that instantiated it - this
    is anathema to a Functional Programmer. We instantiate an object based on a class,
    and never change it again.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我这里不打算详细讨论结构体，还有其他优秀的书籍详细讲述了 C# 的特性。从 C# 的角度来看，它们的优点在于它们是按值在函数之间传递的，而不是按引用 -
    即传递的是一个副本，原始对象保持不变。传统的面向对象技术是将一个对象传递到一个函数中，以便在那里修改它，违背了函数式程序员的原则。我们基于类实例化一个对象，然后再也不改变它。
- en: Structs have been around for an awfully long time, and although they’re passed
    by value, they can still have their properties modified, so they aren’t immutable
    as such. At least until C# 7.2.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体已存在很长时间了，虽然它们是按值传递的，但仍然可以修改其属性，因此它们并非完全不可变。至少直到 C# 7.2。
- en: Now, it’s possible to add a readonly modifier to a Struct definition, which
    will enforce all properties of the struct as readonly at design time. Any attempt
    to add a setter to a property will result in a Compiler Error.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以向结构体定义添加只读修饰符，在设计时强制所有结构体属性为只读。任何尝试向属性添加设置器将导致编译器错误。
- en: 'Since all properties are enforced as readonly, in C# 7.2 itself, all properties
    need to be included in the constructor to be set. It would look like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有属性都被强制为只读，在C# 7.2中，所有属性都需要包含在构造函数中才能设置。看起来像这样：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is still a little clunky, forcing us to update the constructor with every
    property as they’re added to the struct, but it’s still better than nothing.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然有点笨拙，迫使我们在每次向结构体添加属性时更新构造函数，但这仍然比没有强化要好。
- en: 'It’s also worth discussing this case, where I’ve added in a List to the struct:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得讨论的是，我已经在结构体中添加了一个列表的情况：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will compile, and the application will run, but an error will be thrown
    when the `Add()` function is called. It’s nice that the read-only nature of the
    struct is being enforced, but I’m not a fan of having to worry about another potential
    unhandled exception.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这将编译，并且应用程序将运行，但当调用`Add()`函数时将抛出错误。结构体的只读性质被强制执行是件好事，但我不喜欢必须担心另一个潜在的未处理异常。
- en: But it’s a good thing that the developer can now add the readonly modifier to
    clarify intent, and it will prevent any easily-avoidable mutability being added
    to the struct. Even if it does mean that there has to be another layer of error
    handling.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 但是开发人员现在可以添加只读修饰符以澄清意图，这将防止任何可能避免的可变性添加到结构体中。即使这意味着还必须有另一层错误处理。
- en: Init only setters
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅初始化的设置器
- en: C# 9 introduced a new kind of auto-property type. We’ve already got `Get` and
    `Set`, but now there’s also `Init`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: C# 9引入了一种新的自动属性类型。我们已经有了`Get`和`Set`，但现在还有`Init`。
- en: If you have a class property with `Get` and `Set` attached to it, that means
    the property and be retrieved or replaced at any time.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个附有`Get`和`Set`的类属性，这意味着可以随时检索或替换该属性。
- en: If instead it has `Get` and `Init`, the it can have its value set when the object
    it’s part of is instantiated, but can’t then be changed again.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它有`Get`和`Init`，则在对象实例化时可以设置其值，但之后不能再更改。
- en: 'That means our read-only structs (and, indeed all of our classes too) can now
    have a slightly nicer syntax to be instantiated and then exist in a read-only
    state:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的只读结构体（以及我们所有的类）现在可以以稍微更美观的语法进行实例化，然后处于只读状态：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This means we don’t have to maintain a convoluted constructor (i.e. one with
    a parameter for literally every single property - and there could be dozens of
    them), along with the properties themselves, which has removed a potential source
    of annoying boilerplate code.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们不必再维护一个复杂的构造函数（即一个为每个属性都有参数的构造函数 - 可能会有几十个），以及属性本身，这消除了恼人的样板代码的潜在来源。
- en: We still have the issue with exceptions being thrown when attempting to modify
    Lists and sub-objects, though.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们仍然面临异常抛出的问题，当尝试修改列表和子对象时。
- en: Record types
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录类型
- en: In C# 9, one of my favorite features since Pattern Matching was added - record
    types. If you’ve not had a chance to play with these yourself yet, then do yourself
    a favor and do it as soon as possible. They’re fantastic.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 9中，自从模式匹配之后，我的最爱之一 - 记录类型。如果你还没有机会自己尝试过这些，那么请尽快尝试一下。它们非常棒。
- en: On the face of it, they look about the same as a struct. In C# 9, a record type
    is based on a class, and as such is passed around by reference.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，它们看起来与结构体相似。在C# 9中，记录类型基于类，因此通过引用传递。
- en: 'As of C# 10 and onwards that’s no longer the case, and records are treated
    more like structs, meaning they can be passed by value. Unlike a struct however,
    there is no readonly modifier, so immutability has to be enforced by the developer.
    This is an updated version of the Blade Runner code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 自C# 10及以后，这种情况不再适用，记录现在更像是结构体，这意味着它们可以按值传递。然而，与结构体不同的是，没有只读修饰符，因此不可变性必须由开发人员来强制执行。这是“银翼杀手”代码的更新版本：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It doesn’t look all that different, does it? Where records come into their
    own though, is when you want to create a modified version. Let’s imagine for a
    moment that in our C# 10 application, we wanted to create a new movie record for
    the Director’s Cut of Blade Runner^([3](ch03.html#idm45400871809840)). This is
    exactly the same for our purposes, except that it has a different title. To save
    defining data, we’ll literally copy over data from the original record, but with
    one modification. With a read-only struct, we’d have to do something like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来并没有那么不同，对吧？然而，记录真正独特之处在于当你想创建一个修改过的版本时。让我们假设一下，在我们的 C# 10 应用程序中，我们想为《银翼杀手》导演剪辑版创建一个新的电影记录^([3](ch03.html#idm45400871809840))。就我们的目的而言，这完全相同，只是有一个不同的标题。为了节省定义数据，我们会从原始记录中直接复制数据，但进行一处修改。如果是使用只读结构体，我们必须像这样做：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: That’s following the Functional paradigm, and it’s not too bad, but it’s another
    heap of boilerplate we have to include in our applications if we want to enforce
    Immutability.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这遵循函数式编程范式，并不算太糟糕，但如果我们想要强制不可变性，我们必须在应用程序中包含另一大堆样板代码。
- en: This becomes important if we’ve got something like a state object that needs
    to be updated regularly following interactions with the user, or external dependencies
    of some sort. That’s a lot of copying of properties we’d have to do using the
    read-only struct approach.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有类似需要根据用户交互或某种外部依赖定期更新的状态对象，那么这变得很重要。使用只读结构体方法，我们将不得不进行大量属性复制。
- en: 'Record types gives us an absolutely amazing new keyword - `with`. This is a
    quick, convenient way of creating a replica of an existing record but with a modification.
    The updated version of the Director’s Cut code with record types looks like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 记录类型为我们提供了一个绝对惊艳的新关键字 - `with`。这是一种快捷方便的方法，可以创建一个现有记录的副本，并进行修改。使用记录类型的《银翼杀手》导演剪辑版的更新代码如下所示：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Isn’t that cool? The sheer amount of boilerplate you can save yourself with
    record types is staggering.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 酷吧？使用记录类型可以节省大量的样板代码。
- en: I recently wrote a text adventure game in Functional C#. I made a central GameState
    record type, containing all of the progress the player has made so far. I used
    a massive Pattern Matching statement to work out what the player was doing this
    turn, and a simple **with** statement to update state by returning a modified
    duplicate record. It’s an elegant way to code state machines, and clarifies intent
    massively by cutting away so much of the uninteresting boilerplate.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我最近用函数式 C# 写了一个文本冒险游戏。我创建了一个名为 GameState 的中心记录类型，包含玩家迄今为止的所有进展。我使用了一个庞大的模式匹配语句来判断玩家本回合的操作，并使用简单的
    **with** 语句通过返回修改后的副本来更新状态。这是编写状态机的一种优雅方式，通过去除大量无趣的样板代码，大大澄清了意图。
- en: 'A last neat feature of Records is that you can even define them simply in a
    single line like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 记录的一个很棒的特性是，你甚至可以简单地用一行来定义它们，像这样：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Creating instances of Movie using this style of definition can’t be done with
    curly braces, it has to be done with a function:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种定义风格创建 Movie 的实例不能使用花括号，必须使用一个函数：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Note that all properties have to be supplied and in order, unless you use constructor
    tags like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，除非使用类似这样的构造标记，否则必须按顺序提供所有属性：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You *still* have to provide all of the properties, but you can put them in any
    order you like. For all the good that does you…​
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你*仍然*必须提供所有属性，但可以按任意顺序放置它们。这对你有多大好处呢……
- en: Which syntax you prefer is a matter of preference. In most circumstances they’re
    equivalent.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你更喜欢哪种语法是个人偏好问题。在大多数情况下，它们是等效的。
- en: Nullable Reference Types
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可空引用类型
- en: 'Despite what it sounds like, this isn’t actually a new type, like with record
    types. This is effectively a compiler option, which was introduced in C# 8\. This
    option is set in the CSPROJ file, like in this extract:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管听起来不像是一种新类型，就像记录类型一样。这实际上是一种编译器选项，是在 C# 8 中引入的。这个选项在 CSPROJ 文件中设置，就像这个摘录中的一样：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you prefer using a UI, then the option can also be set in the Build section
    of the project’s properties.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢使用 UI，则选项也可以在项目属性的“构建”部分中设置。
- en: 'Strictly speaking, activating the Null Reference Types feature doesn’t change
    the behavior of the code generated by the compiler, but it does add an extra set
    of warnings to the IDE and the compiler to help avoid a situation where NULL might
    end up assigned. Here are some that are added to my Movie record type, warning
    me that it’s possible for properties to end up null:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，启用空引用类型功能并不会改变编译器生成的代码行为，但它确实会在IDE和编译器中添加一组额外的警告，以帮助避免可能将 NULL 赋值的情况。以下是一些被添加到我的电影记录类型中的警告，提醒我属性可能会为
    NULL：
- en: '![Warnings for nullable properties on a Record](assets/ch03_001.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![记录中可空属性的警告](assets/ch03_001.png)'
- en: 'Another example occurs if I try to set the title of the Blade Runner Director’s
    Cut to NULL:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我试图将《银翼杀手导演剪辑版》的标题设置为 NULL，那么会出现另一个例子：
- en: '![Warning for setting a property to NULL](assets/ch03_002.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![设置属性为 NULL 的警告](assets/ch03_002.png)'
- en: Do bear in mind that these are only compiler warnings. The code will still execute
    without any errors at all. It’s just guiding you to writing code that’s less likely
    to contain null reference exceptions - which can only be a good thing.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这些只是编译器警告。代码仍将执行而没有任何错误。它只是指导您编写代码，减少包含空引用异常的可能性 - 这只能是一件好事。
- en: Avoiding the use of a NULL value is generally a good practice, functional programming
    or not. NULL is the so-called “Billion dollar mistake”. It was invented by Tony
    Hoare in the mid-60s, and it’s been one of the leading causes of bugs in producion
    ever since. An object being passed into something that turned out unexpextectly
    to be NULL. This gives rise to a Null-Reference Exception, and you don’t need
    to have been in this business long before you encounter your first one of those!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用 NULL 值通常是一个良好的实践，无论是否进行功能编程。NULL 被称为“十亿美元的错误”。它是由托尼·霍尔在60年代中期发明的，自那时以来，它一直是生产中错误的主要原因之一。将一个对象传递到某些意外地变成
    NULL 的地方。这会导致空引用异常，而在你遇到第一个这样的异常之前，你在这个行业中也不需要有很长时间！
- en: Having NULL as a value adds unneeded complexity to your codebase, and introduces
    another source of potential errrors. This is why it’s worth paying attention to
    the compiler warning and keeping NULL out of your codebase wherever possible.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将 NULL 作为一个值添加到您的代码库中会增加不必要的复杂性，并引入潜在错误的另一个来源。这就是为什么值得注意编译器警告，并尽可能避免在您的代码库中使用
    NULL。
- en: 'If there’s a perfectly good reason for a value to be NUL then you can do so
    by adding *?* characters to properties like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个值有很好的理由应为 NUL，则可以通过像这样添加 *?* 字符到属性中来实现：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The only circumstance under which I’d ever consider deliberately adding a nullable
    property to my codebase is where a 3rd party library requires it. Even then, I
    wouldn’t allow the Nullable to be persisted through the rest of my code - I’d
    probably tuck it away somewhere where the code that parses the external data can
    see it, then convert it into a safer, more controlled structure for passing to
    other areas of the system.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一考虑在我的代码库中故意添加可空属性的情况是第三方库需要它。即使如此，我也不会允许可空被持久化到我的代码中 - 我可能会把它藏在某个地方，让解析外部数据的代码能看到它，然后将其转换为更安全、更受控的结构，以传递给系统的其他部分。
- en: The Future
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未来
- en: As of the time of writing, C# 11 is out and well established as part of .NET
    7\. The plans are only starting to be put together for .NET 8 and C# 12, but it’s
    not clear what - if anything - they’ll be including for functional programmers.
    Given that it’s a stated intent by the C# team to continue to add more Functional
    features with every version, it’s a safe bet that there’ll be at least *something*
    new for us to do more Functional Programming with.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，C# 11 已经发布并作为 .NET 7 的一部分已经得到了很好的确认。.NET 8 和 C# 12 的计划刚刚开始制定，但尚不清楚它们将包含什么
    - 如果有的话 - 对功能编程人员来说可能会有一些新的东西可以做更多的功能编程。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at all the features of C# that have been released
    since Functional Programming began to be integrated in C# 3 and 4\. We looked
    at what they are, how they can be used, and why they’re worth considering.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们查看了自从功能编程开始集成到 C# 3 和 4 以来发布的所有 C# 特性。我们研究了它们是什么，如何使用它们，以及为什么值得考虑。
- en: 'Broadly these fall into two categories:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 广义上来说，这些可以分为两类：
- en: Pattern Matching, implemented in C# as an advanced form of switch statement
    that allows for incredibly powerful, code-saving logic to be written briefly and
    simply. We saw how every version of C# has contributed more pattern matching features
    to the developer.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配，在C#中实现为一种高级形式的switch语句，允许编写非常强大且节省代码的逻辑，简洁明了。我们看到每个C#版本都为开发者贡献了更多的模式匹配特性。
- en: Immutability, the ability to prevent variables from being altered once instantiated.
    It’s highly unlikely that true Immutability will ever be made available in C#
    for reasons of backwards-compatability, but new features are being added to C#,
    such as readonly structs and record types that make it easier for a developer
    to work in such a way that it’s easy to pretend that immutablility exists without
    having to add a lot of tedious boilerplate code to the application.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性，即变量一旦实例化就无法修改的能力。出于向后兼容性的原因，真正的不可变性在C#中很难实现，但C#正在新增一些特性，如只读结构体和记录类型，使开发者可以更轻松地以一种容易假装不可变性存在的方式工作，而无需向应用程序添加大量繁琐的样板代码。
- en: In the next chapter, we’re going to take things a step further, and demonstrate
    some ways to use some existing features of C# in novel ways to add to your Functional
    Programming tool belt.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步探讨一些方法，展示如何以新颖的方式使用C#的现有特性，以丰富您的函数式编程工具箱。
- en: ^([1](ch03.html#idm45400879635904-marker)) Which, frankly no bank would ever
    offer
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch03.html#idm45400879635904-marker)) 坦率地说，任何银行都不会提供这种服务。
- en: ^([2](ch03.html#idm45400872249424-marker)) You could do worse than *C# in a
    Nutshell*, also published by O’Reilly
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch03.html#idm45400872249424-marker)) *C# in a Nutshell* 这本书也是由 O’Reilly
    出版的，也是不错的选择。
- en: ^([3](ch03.html#idm45400871809840-marker)) Vastly superior to the theatrical
    cut, in my opinion.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch03.html#idm45400871809840-marker)) 在我看来，远远优于戏剧性的版本。
