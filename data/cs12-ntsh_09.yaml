- en: Chapter 9\. LINQ Operators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章\. LINQ 操作符
- en: 'This chapter describes each of the LINQ query operators. As well as serving
    as a reference, two of the sections, [“Projecting”](#projecting-id00076) and [“Joining”](#joining),
    cover a number of conceptual areas:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了 LINQ 查询操作符的每一个。除了作为参考之外，两个部分 [“投影”](#projecting-id00076) 和 [“连接”](#joining)
    还涵盖了许多概念领域：
- en: Projecting object hierarchies
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投影对象层次结构
- en: Joining with `Select`, `SelectMany`, `Join`, and `GroupJoin`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Select`、`SelectMany`、`Join` 和 `GroupJoin` 进行连接
- en: Query expressions with multiple range variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有多个范围变量的查询表达式
- en: 'All of the examples in this chapter assume that a `names` array is defined
    as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有示例假设一个 `names` 数组定义如下：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Examples that query a database assume that a variable called `dbContext` is
    instantiated as
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 查询数据库的示例假设一个名为 `dbContext` 的变量已被实例化为
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'where `NutshellContext` is defined as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `NutshellContext` 定义如下：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: All of the examples in this chapter are preloaded into LINQPad, along with a
    sample database with a matching schema. You can download LINQPad from [*http://www.linqpad.net*](http://www.linqpad.net).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有示例都预装在 LINQPad 中，包括一个具有匹配架构的示例数据库。您可以从 [*http://www.linqpad.net*](http://www.linqpad.net)
    下载 LINQPad。
- en: 'Here are corresponding SQL Server table definitions:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是相应的 SQL Server 表定义：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Overview
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this section, we provide an overview of the standard query operators. They
    fall into three categories:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们提供标准查询操作符的概述。它们分为三类：
- en: Sequence in, sequence out (sequence→sequence)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入序列，输出序列（序列 → 序列）
- en: Sequence in, single element or scalar value out
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入序列，输出单个元素或标量值
- en: Nothing in, sequence out (*generation* methods)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无输入，输出序列（*生成* 方法）
- en: We first present each of the three categories and the query operators they include,
    and then we take up each individual query operator in detail.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先介绍每个类别和它们包含的查询操作符，然后详细讨论每个单独的查询操作符。
- en: Sequence→Sequence
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列 → 序列
- en: Most query operators fall into this category—accepting one or more sequences
    as input and emitting a single output sequence. [Figure 9-1](#shape_changing_operators)
    illustrates those operators that restructure the shape of the sequences.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数查询操作符属于此类别，接受一个或多个序列作为输入，并输出单个输出序列。[图 9-1](#shape_changing_operators) 显示了重构序列形状的操作符。
- en: '![Shape-changing operators](assets/cn10_0901.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![形状变换操作符](assets/cn10_0901.png)'
- en: Figure 9-1\. Shape-changing operators
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-1\. 形状变换操作符
- en: Filtering
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤
- en: '`IEnumerable<TSource>` →`IEnumerable<TSource>`'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<TSource>` → `IEnumerable<TSource>`'
- en: Returns a subset of the original elements.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 返回原始元素的子集。
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Projecting
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 投影
- en: '`IEnumerable<TSource>`→`IEnumerable<TResult>`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<TSource>` → `IEnumerable<TResult>`'
- en: Transforms each element with a lambda function. `SelectMany` flattens nested
    sequences; `Select` and `SelectMany` perform inner joins, left outer joins, cross
    joins, and non-equi joins with EF Core.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 用 lambda 函数转换每个元素。`SelectMany` 可以展平嵌套序列；`Select` 和 `SelectMany` 可以在 EF Core
    中执行内连接、左外连接、交叉连接和非等连接。
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Joining
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接
- en: '`IEnumerable<TOuter>`, `IEnumerable<TInner>`→`IEnumerable<TResult>`'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<TOuter>`、`IEnumerable<TInner>` → `IEnumerable<TResult>`'
- en: 'Meshes elements of one sequence with another. `Join` and `GroupJoin` operators
    are designed to be efficient with local queries and support inner and left outer
    joins. The `Zip` operator enumerates two sequences in step, applying a function
    over each element pair. Rather than naming the type arguments `TOuter` and `TInner`,
    the `Zip` operator names them `TFirst` and `TSecond`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个序列的元素与另一个序列的元素合并。 `Join` 和 `GroupJoin` 操作符设计用于本地查询效率，并支持内连接和左外连接。 `Zip` 操作符按步骤枚举两个序列，并对每个元素对应用一个函数。与命名类型参数
    `TOuter` 和 `TInner` 不同，`Zip` 操作符将它们命名为 `TFirst` 和 `TSecond`：
- en: '`IEnumerable<TFirst>`, `IEnumerable<TSecond>`→`IEnumerable<TResult>`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<TFirst>`、`IEnumerable<TSecond>` → `IEnumerable<TResult>`'
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Ordering
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排序
- en: '`IEnumerable<TSource>`→`IOrderedEnumerable<TSource>`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<TSource>` → `IOrderedEnumerable<TSource>`'
- en: Returns a reordering of a sequence.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 返回序列的重新排序。
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Grouping
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分组
- en: '`IEnumerable<TSource>`→`IEnumerable<IGrouping<TKey,TElement>>`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<TSource>` → `IEnumerable<IGrouping<TKey,TElement>>`'
- en: '`IEnumerable<TSource>`→`IEnumerable<TElement[]>`'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<TSource>` → `IEnumerable<TElement[]>`'
- en: Groups a sequence into subsequences.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 将序列分组成子序列。
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Set operators
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合运算符
- en: '`IEnumerable<TSource>`, `IEnumerable<TSource>`→`IEnumerable<TSource>`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<TSource>`、`IEnumerable<TSource>` → `IEnumerable<TSource>`'
- en: Takes two same-typed sequences and returns their commonality, sum, or difference.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以两个相同类型的序列为参数，返回它们的共同性、总和或差异。
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Conversion methods: Import'
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换方法：导入
- en: '`IEnumerable`→`IEnumerable<TResult>`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable` → `IEnumerable<TResult>`'
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Conversion methods: Export'
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换方法：导出
- en: '`IEnumerable<TSource>`→An array, list, dictionary, lookup, or sequence'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<TSource>`→数组、列表、字典、查找或序列'
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Sequence→Element or Value
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sequence→Element or Value
- en: The following query operators accept an input sequence and emit a single element
    or value.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询运算符接受一个输入序列并输出单个元素或值。
- en: Element operators
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元素运算符
- en: '`IEnumerable<TSource>`→`TSource`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<TSource>`→`TSource`'
- en: Picks a single element from a sequence.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 从序列中选择单个元素。
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Aggregation methods
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 聚合方法
- en: '`IEnumerable<TSource>`→`*scalar*`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<TSource>`→`*scalar*`'
- en: Performs a computation across a sequence, returning a scalar value (typically
    a number).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 执行跨序列的计算，返回一个标量值（通常是一个数字）。
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Quantifiers
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 量词
- en: '`IEnumerable<TSource>`→`*bool*`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<TSource>`→`*bool*`'
- en: An aggregation returning `true` or `false`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`true`或`false`的聚合。
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Void→Sequence
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Void→Sequence
- en: In the third and final category are query operators that produce an output sequence
    from scratch.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个和最后一个类别中有一些查询运算符，可以从头开始生成输出序列。
- en: Generation methods
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成方法
- en: '`void`→`IEnumerable<TResult>`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`void`→`IEnumerable<TResult>`'
- en: Manufactures a simple sequence.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个简单的序列。
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Filtering
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤
- en: '`IEnumerable<TSource>`→`IEnumerable<TSource>`'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<TSource>`→`IEnumerable<TSource>`'
- en: '| Method | Description | SQL equivalents |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 | SQL 等效项 |'
- en: '| --- | --- | --- |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Where` | Returns a subset of elements that satisfy a given condition | `WHERE`
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `Where` | 返回满足给定条件的元素子集 | `WHERE` |'
- en: '| `Take` | Returns the first `count` elements and discards the rest | `WHERE
    ROW_NUMBER()...` *or* `TOP *n*` subquery |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `Take` | 返回前`count`个元素并丢弃其余部分 | `WHERE ROW_NUMBER()...` *或* `TOP *n*` 子查询
    |'
- en: '| `Skip` | Ignores the first `count` elements and returns the rest | `WHERE
    ROW_NUMBER()...` *or* `NOT IN (SELECT TOP *n*...)` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `Skip` | 忽略前`count`个元素并返回其余部分 | `WHERE ROW_NUMBER()...` *或* `NOT IN (SELECT
    TOP *n*...)` |'
- en: '| `TakeLast` | Takes only the last `count` elements | Exception thrown |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `TakeLast` | 仅保留最后`count`个元素 | 抛出异常 |'
- en: '| `SkipLast` | Ignores the last `count` element | Exception thrown |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `SkipLast` | 忽略最后`count`个元素 | 抛出异常 |'
- en: '| `TakeWhile` | Emits elements from the input sequence until the predicate
    is false | Exception thrown |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `TakeWhile` | 输出输入序列中满足断言的元素直到为假 | 抛出异常 |'
- en: '| `SkipWhile` | Ignores elements from the input sequence until the predicate
    is false, and then emits the rest | Exception thrown |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `SkipWhile` | 忽略输入序列中的元素直到断言为假，然后输出剩余元素 | 抛出异常 |'
- en: '| `Distinct`, `DistinctBy` | Returns a sequence that excludes duplicates |
    `SELECT DISTINCT...` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `Distinct`, `DistinctBy` | 返回一个排除重复项的序列 | `SELECT DISTINCT...` |'
- en: Note
  id: totrans-89
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The “SQL equivalents” column in the reference tables in this chapter do not
    necessarily correspond to what an `IQueryable` implementation such as EF Core
    will produce. Rather, it indicates what you’d typically use to do the same job
    if you were writing the SQL query yourself. Where there is no simple translation,
    the column is left blank. Where there is no translation at all, the column reads
    “Exception thrown.”
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 本章参考表中的“SQL 等效项”列未必对应于如 EF Core 等 IQueryable 实现将生成的内容。相反，它指示了如果你自己编写 SQL 查询，你通常会使用的方法。在没有简单转换的情况下，该列为空白。在根本没有翻译的情况下，该列读作“抛出异常”。
- en: '`Enumerable` implementation code, when shown, excludes checking for null arguments
    and indexing predicates.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当显示`Enumerable`实现代码时，不包括对空参数和索引断言的检查。
- en: With each of the filtering methods, you always end up with either the same number
    or fewer elements than you started with. You can never get more! The elements
    are also identical when they come out; they are not transformed in any way.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用每个过滤方法，你最终得到的元素数目要么与开始时相同，要么更少。当它们被输出时，它们也是相同的；它们不会以任何方式进行转换。
- en: Where
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Where
- en: '| Argument | Type |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 类型 |'
- en: '| --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Source sequence | `IEnumerable<TSource>` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 源序列 | `IEnumerable<TSource>` |'
- en: '| Predicate | `TSource => bool or (TSource,int) => bool`^([a](ch09.html#ch01fn8))
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 断言 | `TSource => bool or (TSource,int) => bool`^([a](ch09.html#ch01fn8))
    |'
- en: '| ^([a](ch09.html#ch01fn8-marker)) Prohibited with LINQ to SQL and Entity Framework
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch09.html#ch01fn8-marker)) 不适用于 LINQ to SQL 和 Entity Framework |'
- en: Query syntax
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询语法
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Enumerable.Where implementation
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Enumerable.Where 实现
- en: 'The internal implementation of `Enumerable.Where`, null checking aside, is
    functionally equivalent to the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 除了空检查外，`Enumerable.Where`的内部实现在功能上等同于以下内容：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Overview
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: '`Where` returns the elements from the input sequence that satisfy the given
    predicate.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`Where`返回满足给定条件的输入序列的元素。'
- en: 'For instance:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In query syntax:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询语法中：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A `where` clause can appear more than once in a query and be interspersed with
    `let`, `orderby`, and `join` clauses:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 查询中可以多次出现 `where` 子句，并与 `let`、`orderby` 和 `join` 子句交错：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Standard C# scoping rules apply to such queries. In other words, you cannot
    refer to a variable prior to declaring it with a range variable or a `let` clause.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 C# 作用域规则适用于此类查询。换句话说，在使用范围变量或 `let` 子句声明变量之前，无法引用该变量。
- en: Indexed filtering
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引过滤
- en: '`Where`’s predicate optionally accepts a second argument, of type `int`. This
    is fed with the position of each element within the input sequence, allowing the
    predicate to use this information in its filtering decision. For example, the
    following skips every second element:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`Where` 的谓词可以选择接受第二个参数，类型为 `int`。这个参数会接收每个元素在输入序列中的位置，允许谓词在其过滤决策中使用这些信息。例如，以下代码跳过每个第二个元素：'
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: An exception is thrown if you use indexed filtering in EF Core.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 EF Core 中，如果使用索引过滤，会引发异常。
- en: SQL LIKE comparisons in EF Core
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 EF Core 中的 SQL LIKE 比较
- en: 'The following methods on `string` translate to SQL’s `LIKE` operator:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`string` 上的以下方法翻译为 SQL 的 `LIKE` 操作符：'
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For instance, `c.Name.Contains ("abc")` translates to `customer.Name LIKE ''%abc%''`
    (or more accurately, a parameterized version of this). `Contains` lets you compare
    only against a locally evaluated expression; to compare against another column,
    you must use the `EF.Functions.Like` method:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`c.Name.Contains("abc")` 翻译为 `customer.Name LIKE '%abc%'`（或更准确地说，它的参数化版本）。`Contains`
    只允许针对本地评估的表达式进行比较；要针对另一列进行比较，必须使用 `EF.Functions.Like` 方法：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`EF.Functions.Like` also lets you perform more complex comparisons (e.g., `LIKE
    ''abc%def%''`).'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`EF.Functions.Like` 还允许您执行更复杂的比较（例如 `LIKE ''abc%def%''`）。'
- en: < and > string comparisons in EF Core
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 EF Core 中进行 `<` 和 `>` 的字符串比较
- en: 'You can perform *order* comparison on strings with `string`’s `CompareTo` method;
    this maps to SQL’s `<` and `>` operators:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `string` 的 `CompareTo` 方法对字符串执行 *顺序* 比较；这相当于 SQL 的 `<` 和 `>` 操作符：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: WHERE x IN (…, …, …) in EF Core
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 EF Core 中使用 `WHERE x IN (…, …, …)`
- en: 'With EF Core, you can apply the `Contains` operator to a local collection within
    a filter predicate. For instance:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 EF Core，您可以在过滤谓词中将 `Contains` 操作符应用于本地集合。例如：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This maps to SQL’s `IN` operator. In other words:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于 SQL 的 `IN` 操作符。换句话说：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If the local collection is an array of entities or nonscalar types, EF Core
    might instead emit an `EXISTS` clause.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果本地集合是实体数组或非标量类型，则 EF Core 可能会代替发出 `EXISTS` 子句。
- en: Take, TakeLast, Skip, SkipLast
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Take、TakeLast、Skip、SkipLast
- en: '| Argument | Type |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 类型 |'
- en: '| --- | --- |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Source sequence | `IEnumerable<TSource>` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 源序列 | `IEnumerable<TSource>` |'
- en: '| Number of elements to take or skip | `int` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 要获取或跳过的元素数量 | `int` |'
- en: '`Take` emits the first *n* elements and discards the rest; `Skip` discards
    the first *n* elements and emits the rest. The two methods are useful together
    when implementing a web page allowing a user to navigate through a large set of
    matching records. For instance, suppose that a user searches a book database for
    the term “mercury”, and there are 100 matches. The following returns the first
    20:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Take` 返回前 *n* 个元素并丢弃其余部分；`Skip` 丢弃前 *n* 个元素并返回其余部分。当实现允许用户浏览大量匹配记录的网页时，这两种方法一起非常有用。例如，假设用户在书籍数据库中搜索术语“mercury”，共有
    100 个匹配项。以下代码返回前 20 个：'
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The next query returns books 21 to 40:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个查询返回书籍 21 到 40：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: EF Core translates `Take` and `Skip` to the `ROW_NUMBER` function in SQL Server
    2005, or a `TOP` *n* subquery in earlier versions of SQL Server.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 将 `Take` 和 `Skip` 转换为 SQL Server 2005 中的 `ROW_NUMBER` 函数，或者在较早版本的 SQL
    Server 中转换为 `TOP` *n* 子查询。
- en: The `TakeLast` and `SkipLast` methods take or skip the last *n* elements.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`TakeLast` 和 `SkipLast` 方法接受或跳过最后 *n* 个元素。'
- en: From .NET 6, the `Take` method is overloaded to accept a `Range` variable. This
    overload can subsume the functionality of all four methods; for instance, `Take(5..)`
    is equivalent to `Skip(5)`, and `Take(..^5)` is equivalent to `SkipLast(5)`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从 .NET 6 开始，`Take` 方法重载以接受 `Range` 变量。此重载可以替代所有四种方法的功能；例如，`Take(5..)` 等同于 `Skip(5)`，而
    `Take(..^5)` 等同于 `SkipLast(5)`。
- en: TakeWhile and SkipWhile
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`TakeWhile` 和 `SkipWhile`'
- en: '| Argument | Type |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 类型 |'
- en: '| --- | --- |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Source sequence | `IEnumerable<TSource>` |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 源序列 | `IEnumerable<TSource>` |'
- en: '| Predicate | `TSource => bool` or `(TSource,int) => bool` |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 谓词 | `TSource => bool` 或 `(TSource,int) => bool` |'
- en: '`TakeWhile` enumerates the input sequence, emitting each item until the given
    predicate is false. It then ignores the remaining elements:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`TakeWhile` 枚举输入序列，返回每个项目，直到给定的谓词为假。然后忽略剩余元素：'
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`SkipWhile` enumerates the input sequence, ignoring each item until the given
    predicate is false. It then emits the remaining elements:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`SkipWhile`枚举输入序列，忽略每个项目，直到给定的谓词为false。然后，它发出剩余的元素：'
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`TakeWhile` and `SkipWhile` have no translation to SQL and throw an exception
    if used in an EF Core query.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`TakeWhile`和`SkipWhile`在SQL中没有对应的翻译，并且如果在EF Core查询中使用会抛出异常。'
- en: Distinct and DistinctBy
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不同和DistinctBy
- en: '`Distinct` returns the input sequence, stripped of duplicates. You can optionally
    pass in a custom equality comparer. The following returns distinct letters in
    a string:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`Distinct`返回输入序列，去除重复项。您可以选择传入自定义的相等比较器。以下返回字符串中不同的字母：'
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We can call LINQ methods directly on a string because `string` implements `IEnumerable<char>`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接在字符串上调用LINQ方法，因为`string`实现了`IEnumerable<char>`。
- en: 'The `DistinctBy` method was introduced in .NET 6 and lets you specify a key
    selector to be applied before performing equality comparison. The result of the
    following expression is `{1,2,3}`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`.NET 6`引入了`DistinctBy`方法，允许您指定在执行相等比较之前要应用的键选择器。以下表达式的结果是`{1,2,3}`：'
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Projecting
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 投影
- en: '`IEnumerable<TSource>`→ `IEnumerable<TResult>`'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<TSource>`→ `IEnumerable<TResult>`'
- en: '| Method | Description | SQL equivalents |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 | SQL等效项 |'
- en: '| --- | --- | --- |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Select` | Transforms each input element with the given lambda expression
    | `SELECT` |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `Select` | 使用给定的lambda表达式转换每个输入元素 | `SELECT` |'
- en: '| `SelectMany` | Transforms each input element, and then flattens and concatenates
    the resultant subsequences | `INNER JOIN`, `LEFT OUTER JOIN`,'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '| `SelectMany` | 转换每个输入元素，然后展平和连接生成的子序列 | `INNER JOIN`，`LEFT OUTER JOIN`，'
- en: '`CROSS JOIN` |'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`CROSS JOIN` |'
- en: Note
  id: totrans-167
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When querying a database, `Select` and `SelectMany` are the most versatile joining
    constructs; for local queries, `Join` and `GroupJoin` are the most *efficient*
    joining constructs.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询数据库时，`Select`和`SelectMany`是最通用的连接构造；对于本地查询，`Join`和`GroupJoin`是最*高效*的连接构造。
- en: Select
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Select
- en: '| Argument | Type |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 类型 |'
- en: '| --- | --- |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Source sequence | `IEnumerable<TSource>` |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 源序列 | `IEnumerable<TSource>` |'
- en: '| Result selector | `TSource => TResult` or `(TSource,int) => TResult`^([a](ch09.html#ch01fn9))
    |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 结果选择器 | `TSource => TResult` 或 `(TSource,int) => TResult`^([a](ch09.html#ch01fn9))
    |'
- en: '| ^([a](ch09.html#ch01fn9-marker)) Prohibited with EF Core |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch09.html#ch01fn9-marker)) 在EF Core中禁止使用 |'
- en: Query syntax
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询语法
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Enumerable implementation
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可枚举实现
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Overview
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: With `Select`, you always get the same number of elements that you started with.
    Each element, however, can be transformed in any manner by the lambda function.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Select`，您始终获得与开始时相同数量的元素。但是，每个元素可以由lambda函数以任何方式转换。
- en: 'The following selects the names of all fonts installed on the computer (from
    `System.Drawing`):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下选择安装在计算机上的所有字体的名称（来自`System.Drawing`）：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In this example, the `select` clause converts a `FontFamily` object to its
    name. Here’s the lambda equivalent:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`select`子句将`FontFamily`对象转换为其名称。以下是lambda等效项：
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`Select` statements are often used to project into anonymous types:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`Select`语句通常用于投影到匿名类型：'
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'A projection with no transformation is sometimes used with query syntax to
    satisfy the requirement that the query end in a `select` or `group` clause. The
    following selects fonts supporting strikeout:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 不带任何转换的投影有时与查询语法一起使用，以满足查询以`select`或`group`子句结束的要求。以下选择支持删除线的字体：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In such cases, the compiler omits the projection when translating to fluent
    syntax.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，编译器在转换为流畅语法时会省略投影。
- en: Indexed projection
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引投影
- en: 'The `selector` expression can optionally accept an integer argument, which
    acts as an indexer, providing the expression with the position of each input in
    the input sequence. This works only with local queries:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`selector`表达式可以选择性地接受一个整数参数，该参数充当索引器，为输入序列中每个输入的位置提供表达式。这仅适用于本地查询：'
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Select subqueries and object hierarchies
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择子查询和对象层次结构
- en: 'You can nest a subquery in a `select` clause to build an object hierarchy.
    The following example returns a collection describing each directory under `Path.GetTempPath()`,
    with a subcollection of files under each directory:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`select`子句中嵌套子查询以构建对象层次结构。以下示例返回描述`Path.GetTempPath()`下每个目录及其子文件集合的集合：
- en: '[PRE40]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The inner portion of this query can be called a *correlated subquery*. A subquery
    is correlated if it references an object in the outer query—in this case, it references
    `d`, the directory being enumerated.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询的内部部分可以称为*相关子查询*。如果子查询引用外部查询中的对象，则该子查询是相关的——在本例中，它引用了正在枚举的目录`d`。
- en: Note
  id: totrans-197
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A subquery inside a `Select` allows you to map one object hierarchy to another,
    or map a relational object model to a hierarchical object model.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Select`中的子查询允许您将一个对象层次结构映射到另一个对象层次结构，或者将关系对象模型映射到分层对象模型。
- en: With local queries, a subquery within a `Select` causes double-deferred execution.
    In our example, the files aren’t filtered or projected until the inner `foreach`
    statement enumerates.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本地查询，`Select`中的子查询会导致双重延迟执行。在我们的示例中，直到内部的 `foreach` 语句枚举时，文件才被过滤或投影。
- en: Subqueries and joins in EF Core
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: EF Core 中的子查询和连接
- en: 'Subquery projections work well in EF Core, and you can use them to do the work
    of SQL-style joins. Here’s how we retrieve each customer’s name along with their
    high-value purchases:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在 EF Core 中，子查询投影在功能上效果很好，您可以使用它们来执行类似 SQL 风格的连接。以下是如何检索每个客户的名称以及他们的高价值购买：
- en: '[PRE41]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-203
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Note the use of `ToList` in the subquery. EF Core 3 cannot create queryables
    from the subquery result when that subquery references the `DbContext`. This issue
    is being tracked by the EF Core team and might be resolved in a future release.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在子查询中使用 `ToList`。当子查询引用 `DbContext` 时，EF Core 3 无法从子查询结果创建可查询对象。此问题正在由 EF
    Core 团队跟踪，可能会在未来的版本中解决。
- en: Note
  id: totrans-205
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This style of query is ideally suited to interpreted queries. The outer query
    and subquery are processed as a unit, preventing unnecessary round-tripping. With
    local queries, however, it’s inefficient because every combination of outer and
    inner elements must be enumerated to get the few matching combinations. A better
    choice for local queries is `Join` or `GroupJoin`, described in the following
    sections.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这种查询方式非常适合解释查询。外部查询和子查询作为一个单元进行处理，避免了不必要的往返。然而，对于本地查询来说，效率较低，因为必须枚举每个外部和内部元素的组合才能获取少数匹配组合。本地查询的更好选择是在以下章节中描述的`Join`或`GroupJoin`。
- en: This query matches up objects from two disparate collections, and it can be
    thought of as a “join.” The difference between this and a conventional database
    join (or subquery) is that we’re not flattening the output into a single two-dimensional
    result set. We’re mapping the relational data to hierarchical data, rather than
    to flat data.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询将来自两个不同集合的对象匹配起来，可以被视为一个“连接”。与传统的数据库连接（或子查询）的不同之处在于，我们没有将输出展平成单个二维结果集。我们将关系数据映射到分层数据，而不是扁平数据。
- en: 'Here’s the same query simplified by using the `Purchases` collection navigation
    property on the `Customer` entity:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是通过在`Customer`实体上使用`Purchases`集合导航属性简化的相同查询：
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: (EF Core 3 does not require `ToList` when performing the subquery on a navigation
    property.)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: （在 EF Core 3 中，在导航属性上执行子查询时不需要 `ToList`。）
- en: 'Both queries are analogous to a left outer join in SQL in the sense that we
    get all customers in the outer enumeration, regardless of whether they have any
    purchases. To emulate an inner join—whereby customers without high-value purchases
    are excluded—we would need to add a filter condition on the purchases collection:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个查询与 SQL 中的左外连接类似，因为我们在外部枚举中获取所有客户，无论他们是否有任何购买。要模拟内连接——排除没有高价值购买的客户——我们需要在购买集合上添加一个过滤条件：
- en: '[PRE43]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This is slightly untidy, however, in that we’ve written the same predicate
    (`Price > 1000`) twice. We can avoid this duplication with a `let` clause:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样稍显凌乱，因为我们两次写了相同的谓词（`Price > 1000`）。我们可以通过 `let` 子句避免这种重复：
- en: '[PRE44]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This style of query is flexible. By changing `Any` to `Count`, for instance,
    we can modify the query to retrieve only customers with at least two high-value
    purchases:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这种查询方式非常灵活。例如，通过将 `Any` 修改为 `Count`，我们可以修改查询以仅检索至少有两个高价值购买的客户：
- en: '[PRE45]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Projecting into concrete types
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 投影到具体类型
- en: In the examples so far, we’ve instantiated anonymous types in the output. It
    can also be useful to instantiate (ordinary) named classes, which you populate
    with object initializers. Such classes can include custom logic and can be passed
    between methods and assemblies without using type information.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的例子中，我们在输出中实例化了匿名类型。在某些情况下，实例化（普通）命名类也很有用，您可以使用对象初始化程序填充它们。这种类可以包含自定义逻辑，并且可以在方法和程序集之间传递，而无需使用类型信息。
- en: 'A typical example is a custom business entity. A custom business entity is
    simply a class that you write with some properties but is designed to hide lower-level
    (database-related) details. You might exclude foreign key fields from business-entity
    classes, for instance. Assuming that we wrote custom entity classes called `CustomerEntity`
    and `PurchaseEntity`, here’s how we could project into them:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的例子是自定义业务实体。自定义业务实体只是您编写的带有一些属性的类，旨在隐藏较低级别（与数据库相关的）细节。例如，您可能会从业务实体类中排除外键字段。假设我们编写了名为
    `CustomerEntity` 和 `PurchaseEntity` 的自定义实体类，这是我们如何将其投射到它们中的方法：
- en: '[PRE46]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-221
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When created to transfer data between tiers in a program or between separate
    systems, custom business entity classes are often called data transfer objects
    (DTO). DTOs contain no business logic.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序或不同系统之间传输数据时，经常使用自定义业务实体类称为数据传输对象（DTO）。DTO 不包含任何业务逻辑。
- en: Notice that so far, we’ve not had to use a `Join` or `SelectMany` statement.
    This is because we’re maintaining the hierarchical shape of the data, as illustrated
    in [Figure 9-2](#projecting_an_object_hierarchy). With LINQ, you can often avoid
    the traditional SQL approach of flattening tables into a two-dimensional result
    set.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到到目前为止，我们还没有使用 `Join` 或 `SelectMany` 语句。这是因为我们保持了数据的层次形状，正如在 [Figure 9-2](#projecting_an_object_hierarchy)
    中所示。使用 LINQ，您通常可以避免传统的 SQL 方法，将表格展平为二维结果集。
- en: '![Projecting an object hierarchy](assets/cn10_0902.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![投射对象层次结构](assets/cn10_0902.png)'
- en: Figure 9-2\. Projecting an object hierarchy
  id: totrans-225
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-2\. 投射对象层次结构
- en: SelectMany
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SelectMany
- en: '| Argument | Type |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 类型 |'
- en: '| --- | --- |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Source sequence | `IEnumerable<TSource>` |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 源序列 | `IEnumerable<TSource>` |'
- en: '| Result selector | `TSource => IEnumerable<TResult>` or `(TSource,int) =>
    IEnumerable<TResult>`^([a](ch09.html#ch01fn10)) |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| 结果选择器 | `TSource => IEnumerable<TResult>` 或 `(TSource,int) => IEnumerable<TResult>`^([a](ch09.html#ch01fn10))
    |'
- en: '| ^([a](ch09.html#ch01fn10-marker)) Prohibited with EF Core |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch09.html#ch01fn10-marker)) EF Core 不允许使用 |'
- en: Query syntax
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询语法
- en: '[PRE47]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Enumerable implementation
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可枚举实现
- en: '[PRE48]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Overview
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概览
- en: '`SelectMany` concatenates subsequences into a single flat output sequence.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectMany` 将子序列连接成一个单一的扁平输出序列。'
- en: Recall that for each input element, `Select` yields exactly one output element.
    In contrast, `SelectMany` yields *0..n* output elements. The *0..n* elements come
    from a subsequence or child sequence that the lambda expression must emit.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，对于每个输入元素，`Select` 产生恰好一个输出元素。相比之下，`SelectMany` 产生*0..n*个输出元素。*0..n*元素来自于lambda表达式必须发出的子序列或子序列。
- en: You can use `SelectMany` to expand child sequences, flatten nested collections,
    and join two collections into a flat output sequence. Using the conveyor belt
    analogy, `SelectMany` funnels fresh material onto a conveyor belt. With `SelectMany`,
    each input element is the *trigger* for the introduction of fresh material. The
    fresh material is emitted by the `selector` lambda expression and must be a sequence.
    In other words, the lambda expression must emit a *child sequence* per input *element*.
    The final result is a concatenation of the child sequences emitted for each input
    element.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `SelectMany` 扩展子序列，展平嵌套集合，并将两个集合连接到一个扁平的输出序列中。使用传送带类比，`SelectMany` 将新鲜材料引入到传送带上。对于
    `SelectMany`，每个输入元素都是引入新鲜材料的*触发器*。新鲜材料由 `selector` lambda 表达式发出，必须是一个序列。换句话说，lambda
    表达式必须为每个输入*元素*发出一个*子序列*。最终结果是每个输入元素发出的子序列的串联。
- en: Starting with a simple example, suppose that we have the following array of
    names,
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个简单的例子开始，假设我们有以下名称数组，
- en: '[PRE49]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'that we want to convert to a single flat collection of words—in other words:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将其转换为单一的扁平单词集合——换句话说：
- en: '[PRE50]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`SelectMany` is ideal for this task, because we’re mapping each input element
    to a variable number of output elements. All we must do is come up with a `selector`
    expression that converts each input element to a child sequence. `string.Split`
    does the job nicely: it takes a string and splits it into words, emitting the
    result as an array:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这项任务最适合使用 `SelectMany`，因为我们将每个输入元素映射到一个变量数量的输出元素。我们所需做的就是提出一个 `selector` 表达式，将每个输入元素转换为子序列。`string.Split`
    很好地完成了这项工作：它接受一个字符串并将其拆分为单词，将结果作为数组发出：
- en: '[PRE51]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'So, here’s our `SelectMany` query and the result:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是我们的 `SelectMany` 查询和结果：
- en: '[PRE52]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note
  id: totrans-248
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you replace `SelectMany` with `Select`, you get the same results in hierarchical
    form. The following emits a sequence of string *arrays*, requiring nested `foreach`
    statements to enumerate:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将`SelectMany`替换为`Select`，您将以分层形式获得相同的结果。以下代码生成了一个字符串*数组*的序列，需要嵌套的`foreach`语句来枚举：
- en: '[PRE53]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The benefit of `SelectMany` is that it yields a single *flat* result sequence.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectMany`的好处在于它产生一个单一的*扁平*结果序列。'
- en: '`SelectMany` is supported in query syntax and is invoked by having an *additional
    generator*—in other words, an extra `from` clause in the query. The `from` keyword
    has two meanings in query syntax. At the start of a query, it introduces the original
    range variable and input sequence. *Anywhere else* in the query, it translates
    to `SelectMany`. Here’s our query in query syntax:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectMany`在查询语法中受支持，并且通过在查询中添加一个额外的`from`子句来调用它。`from`关键字在查询语法中有两个含义。在查询的开头，它引入原始的范围变量和输入序列。在查询的*任何其他地方*，它转换为`SelectMany`。以下是我们在查询语法中的查询：'
- en: '[PRE54]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note that the additional generator introduces a new range variable—in this case,
    `name`. The old range variable stays in scope, however, and we can subsequently
    access both.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，额外的生成器引入了一个新的范围变量——在这种情况下是`name`。然而，旧的范围变量仍然在作用域内，因此我们随后可以访问两者。
- en: Multiple range variables
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个范围变量
- en: In the preceding example, both `name` and `fullName` remain in scope until the
    query either ends or reaches an `into` clause. The extended scope of these variables
    is *the* killer scenario for query syntax over fluent syntax.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`name`和`fullName`在查询结束或达到`into`子句之前仍然在作用域内。这些变量的扩展作用域是查询语法相对于流畅语法的*杀手级*场景。
- en: 'To illustrate, we can take the preceding query and include `fullName` in the
    final projection:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们可以采用前面的查询，并在最终投影中包括`fullName`：
- en: '[PRE55]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Behind the scenes, the compiler must pull some tricks to let you access both
    variables. A good way to appreciate this is to try writing the same query in fluent
    syntax. It’s tricky! It becomes yet more difficult if you insert a `where` or
    `orderby` clause before projecting:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，编译器必须做一些技巧，让您访问这两个变量。欣赏这一点的好方法是尝试使用流畅语法编写相同的查询。这很棘手！如果在投影之前插入`where`或`orderby`子句，它将变得更加困难：
- en: '[PRE56]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The problem is that `SelectMany` emits a flat sequence of child elements—in
    our case, a flat collection of words. The original “outer” element from which
    it came (`fullName`) is lost. The solution is to “carry” the outer element with
    each child, in a temporary anonymous type:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于`SelectMany`生成了一个平坦的子元素序列——在我们的情况下，是单词的平坦集合。从中来的原始“外部”元素（`fullName`）丢失了。解决方案是使用一个临时的匿名类型将外部元素“携带”到每个子元素中：
- en: '[PRE57]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The only change here is that we’re wrapping each child element (`name`) in
    an anonymous type that also contains its `fullName`. This is similar to how a
    `let` clause is resolved. Here’s the final conversion to fluent syntax:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的变化是我们将每个子元素（`name`）包装在一个匿名类型中，该类型还包含其`fullName`。这类似于`let`子句的解析方式。这是转换为流畅语法的最终形式：
- en: '[PRE58]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Thinking in query syntax
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在查询语法中思考
- en: As we just demonstrated, there are good reasons to use query syntax if you need
    multiple range variables. In such cases, it helps to not only use query syntax
    but also to think directly in its terms.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚演示的，如果您需要多个范围变量，使用查询语法是有充分理由的。在这种情况下，不仅使用查询语法有帮助，而且直接用它的术语思考也是有益的。
- en: 'There are two basic patterns when writing additional generators. The first
    is *expanding and flattening subsequences*. To do this, you call a property or
    method on an existing range variable in your additional generator. We did this
    in the previous example:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 写入额外生成器时有两种基本模式。第一种是*展开和扁平化子序列*。为此，您在额外的生成器中调用现有范围变量的属性或方法。我们在前面的示例中已经这样做了：
- en: '[PRE59]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Here, we’ve expanded from enumerating full names to enumerating words. An analogous
    EF Core query is when you expand collection navigation properties. The following
    query lists all customers along with their purchases:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从枚举全名扩展到枚举单词。类似的 EF Core 查询是当您扩展集合导航属性时。以下查询列出了所有客户及其购买记录：
- en: '[PRE60]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, we’ve expanded each customer into a subsequence of purchases.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将每个客户扩展到购买的子序列中。
- en: 'The second pattern is performing a *cartesian product*, or *cross join*, in
    which every element of one sequence is matched with every element of another.
    To do this, introduce a generator whose `selector` expression returns a sequence
    unrelated to a range variable:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种模式执行的是*笛卡尔积*或*交叉连接*，其中一个序列的每个元素与另一个序列的每个元素匹配。为此，引入一个生成器，其`selector`表达式返回与范围变量无关的序列：
- en: '[PRE61]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This style of query is the basis of `SelectMany`-style *joins*.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这种查询风格是 `SelectMany` 类型的 *连接* 的基础。
- en: Joining with SelectMany
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 SelectMany 进行连接
- en: 'You can use `SelectMany` to join two sequences simply by filtering the results
    of a cross product. For instance, suppose that we want to match players for a
    game. We could start as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `SelectMany` 可以通过过滤交叉产品的结果简单地连接两个序列。例如，假设我们想要为游戏匹配玩家，我们可以这样开始：
- en: '[PRE62]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The query reads “For every player, reiterate every player, selecting player
    1 versus player 2.” Although we got what we asked for (a cross join), the results
    are not useful until we add a filter:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 查询读取为“对于每个玩家，迭代每个玩家，选择玩家1对玩家2”。虽然我们得到了我们要求的内容（一个交叉连接），但在添加过滤器之前结果并不有用：
- en: '[PRE63]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The filter predicate constitutes the *join condition*. Our query can be called
    a *non-equi join* because the join condition doesn’t use an equality operator.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤谓词构成了*连接条件*。我们的查询可以称为*非等值连接*，因为连接条件不使用等号运算符。
- en: SelectMany in EF Core
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: EF Core 中的 SelectMany
- en: '`SelectMany` in EF Core can perform cross joins, non-equi joins, inner joins,
    and left outer joins. You can use `SelectMany` with both predefined associations
    and ad hoc relationships—just as with `Select`. The difference is that `SelectMany`
    returns a flat rather than a hierarchical result set.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在 EF Core 中，`SelectMany` 可以执行交叉连接、非等值连接、内连接和左外连接。你可以像使用 `Select` 一样使用 `SelectMany`，既可以使用预定义的关联，也可以使用临时关系——不同之处在于
    `SelectMany` 返回平面而不是分层的结果集。
- en: 'An EF Core cross join is written just as in the preceding section. The following
    query matches every customer to every purchase (a cross join):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 的交叉连接与前一节中一样书写。以下查询将每个顾客与每个购买匹配（交叉连接）：
- en: '[PRE64]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'More typically, though, you’d want to match customers to only their own purchases.
    You achieve this by adding a `where` clause with a joining predicate. This results
    in a standard SQL-style equi-join:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 但更典型的情况是，你可能只想匹配顾客与其自己的购买。通过添加具有连接谓词的 `where` 子句来实现这一点。这会导致标准的 SQL 风格的等值连接：
- en: '[PRE65]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note
  id: totrans-287
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This translates well to SQL. In the next section, we see how it extends to support
    outer joins. Reformulating such queries with LINQ’s `Join` operator actually makes
    them *less* extensible—LINQ is opposite to SQL in this sense.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 SQL 中表现良好。在下一节中，我们将看到它如何扩展以支持外连接。使用 LINQ 的 `Join` 操作符重新制定这样的查询实际上会使其*不*易扩展——在这方面，LINQ与
    SQL 是相反的。
- en: 'If you have collection navigation properties in your entities, you can express
    the same query by expanding the subcollection instead of filtering the cross product:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在实体中有集合导航属性，你可以通过展开子集合而不是过滤交叉产品来表达相同的查询：
- en: '[PRE66]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The advantage is that we’ve eliminated the joining predicate. We’ve gone from
    filtering a cross product to expanding and flattening.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 优势在于我们消除了连接谓词。我们从过滤交叉产品转向扩展和展开。
- en: 'You can add `where` clauses to such a query for additional filtering. For instance,
    if we want only customers whose names started with “T”, we could filter as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为这样的查询添加 `where` 子句进行额外的过滤。例如，如果我们只想要以“T”开头的客户，我们可以如下过滤：
- en: '[PRE67]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This EF Core query would work equally well if the `where` clause were moved
    one line down because the same SQL is generated in both cases. If it is a local
    query, however, moving the `where` clause down would make it less efficient. With
    local queries, you should filter *before* joining.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `where` 子句移到下一行，此 EF Core 查询同样有效，因为两种情况下生成相同的 SQL。然而，如果是本地查询，将 `where` 子句移到下方可能会降低效率。在本地查询中，你应该在连接之前进行过滤。
- en: 'You can introduce new tables into the mix with additional `from` clauses. For
    instance, if each purchase had purchase item child rows, you could produce a flat
    result set of customers with their purchases, each with their purchase detail
    lines as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过额外的 `from` 子句将新表引入混合中。例如，如果每个购买有购买项目子行，你可以生成以下形式的平面结果集，其中包括顾客及其购买及其购买详细行：
- en: '[PRE68]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Each `from` clause introduces a new *child* table. To include data from a *parent*
    table (via a navigation property), you don’t add a `from` clause—you simply navigate
    to the property. For example, if each customer has a salesperson whose name you
    want to query, just do this:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `from` 子句引入一个新的 *子* 表。要包含通过导航属性从 *父* 表检索数据，你不需要添加 `from` 子句——只需导航到属性即可。例如，如果每个顾客都有一个销售员，你想查询其姓名，只需这样做：
- en: '[PRE69]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: You don’t use `SelectMany` in this case because there’s no subcollection to
    flatten. Parent navigation properties return a single item.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下不使用 `SelectMany`，因为没有子集合需要展开。父导航属性返回单个项。
- en: Outer joins with SelectMany
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 SelectMany 进行外连接
- en: 'We saw previously that a `Select` subquery yields a result analogous to a left
    outer join:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到，`Select`子查询产生的结果类似于左外连接：
- en: '[PRE70]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In this example, every outer element (customer) is included, regardless of
    whether the customer has any purchases. But suppose that we rewrite this query
    with `SelectMany` so that we can obtain a single flat collection rather than a
    hierarchical result set:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，每个外部元素（客户）都包括在内，无论客户是否有任何购买。但假设我们将此查询重写为`SelectMany`，以便我们可以获取一个单一的平坦集合而不是层次化结果集：
- en: '[PRE71]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In the process of flattening the query, we’ve switched to an inner join: customers
    are now included only for whom one or more high-value purchases exist. To get
    a left outer join with a flat result set, we must apply the `DefaultIfEmpty` query
    operator on the inner sequence. This method returns a sequence with a single null
    element if its input sequence has no elements. Here’s such a query, price predicate
    aside:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在展开查询的过程中，我们已经切换到内连接：现在只包括那些存在一个或多个高价值购买的客户。为了获得带有平坦结果集的左外连接，我们必须在内部序列上应用`DefaultIfEmpty`查询运算符。该方法在其输入序列没有元素时返回带有单个空元素的序列。以下是这样一个查询，价格谓词除外：
- en: '[PRE72]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This works perfectly with EF Core, returning all customers—even if they have
    no purchases. But if we were to run this as a local query, it would crash because
    when `p` is null, `p.Description` and `p.Price` throw a `NullReferenceException`.
    We can make our query robust in either scenario, as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 EF Core 中完美运行，返回所有客户，即使他们没有购买。但是如果我们将其作为本地查询运行，当`p`为空时，`p.Description`和`p.Price`会抛出`NullReferenceException`。我们可以使我们的查询在任何情况下都更加健壮，如下所示：
- en: '[PRE73]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Let’s now reintroduce the price filter. We cannot use a `where` clause as we
    did before, because it would execute *after* `DefaultIfEmpty`:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们重新引入价格过滤器。我们不能像以前那样使用`where`子句，因为它会在`DefaultIfEmpty`之后执行：
- en: '[PRE74]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The correct solution is to splice the `Where` clause *before* `DefaultIfEmpty`
    with a subquery:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的解决方案是在`DefaultIfEmpty`之前用一个子查询剪切`Where`子句：
- en: '[PRE75]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: EF Core translates this to a left outer join. This is an effective pattern for
    writing such queries.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 将其转换为左外连接。这是编写此类查询的有效模式。
- en: Note
  id: totrans-314
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re used to writing outer joins in SQL, you might be tempted to overlook
    the simpler option of a `Select` subquery for this style of query in favor of
    the awkward but familiar SQL-centric flat approach. The hierarchical result set
    from a `Select` subquery is often better suited to outer join–style queries because
    there are no additional nulls to deal with.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯于在 SQL 中编写外连接，你可能会倾向于忽视这种风格查询的更简单选项，而选择在这种风格查询中采用笨拙但熟悉的 SQL 中心的平坦方法。`Select`子查询产生的层次化结果集通常更适合于外连接风格的查询，因为没有额外的空值需要处理。
- en: Joining
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接
- en: '| Method | Description | SQL equivalents |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 | SQL 等效语句 |'
- en: '| --- | --- | --- |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Join` | Applies a lookup strategy to match elements from two collections,
    emitting a flat result set | `INNER JOIN` |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| `Join` | 应用查找策略以匹配两个集合的元素，生成平坦结果集 | `INNER JOIN` |'
- en: '| `GroupJoin` | Similar to `Join`, but emits a *hierarchical* result set |
    `INNER JOIN`, `LEFT OUTER JOIN` |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `GroupJoin` | 类似于`Join`，但生成一个*层次化*的结果集 | `INNER JOIN`，`LEFT OUTER JOIN` |'
- en: '| `Zip` | Enumerates two sequences in step (like a zipper), applying a function
    over each element pair | Exception thrown |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| `Zip` | 枚举两个序列以步骤方式（如拉链），对每对元素应用函数 | 抛出异常 |'
- en: Join and GroupJoin
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接与 GroupJoin
- en: '`IEnumerable<TOuter>`, `IEnumerable<TInner>`→`IEnumerable<TResult>`'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<TOuter>`, `IEnumerable<TInner>`→`IEnumerable<TResult>`'
- en: Join arguments
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接参数
- en: '| Argument | Type |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 类型 |'
- en: '| --- | --- |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Outer sequence | `IEnumerable<TOuter>` |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| 外部序列 | `IEnumerable<TOuter>` |'
- en: '| Inner sequence | `IEnumerable<TInner>` |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| 内部序列 | `IEnumerable<TInner>` |'
- en: '| Outer key selector | `TOuter => TKey` |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| 外部键选择器 | `TOuter => TKey` |'
- en: '| Inner key selector | `TInner => TKey` |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| 内部键选择器 | `TInner => TKey` |'
- en: '| Result selector | `(TOuter,TInner) => TResult` |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| 结果选择器 | `(TOuter,TInner) => TResult` |'
- en: GroupJoin arguments
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GroupJoin 参数
- en: '| Argument | Type |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 类型 |'
- en: '| --- | --- |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Outer sequence | `IEnumerable<TOuter>` |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| 外部序列 | `IEnumerable<TOuter>` |'
- en: '| Inner sequence | `IEnumerable<TInner>` |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| 内部序列 | `IEnumerable<TInner>` |'
- en: '| Outer key selector | `TOuter => TKey` |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| 外部键选择器 | `TOuter => TKey` |'
- en: '| Inner key selector | `TInner => TKey` |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| 内部键选择器 | `TInner => TKey` |'
- en: '| Result selector | `(TOuter`,`**IEnumerable<TInner>**) => TResult` |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| 结果选择器 | `(TOuter`,`**IEnumerable<TInner>**) => TResult` |'
- en: Query syntax
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询语法
- en: '[PRE76]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Overview
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: '`Join` and `GroupJoin` mesh two input sequences into a single output sequence.
    `Join` emits flat output; `GroupJoin` emits hierarchical output.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`Join` 和 `GroupJoin` 将两个输入序列合并为一个输出序列。`Join` 生成平坦的输出；`GroupJoin` 生成分层次的输出。'
- en: '`Join` and `GroupJoin` provide an alternative strategy to `Select` and `SelectMany`.
    The advantage of `Join` and `GroupJoin` is that they execute efficiently over
    local in-memory collections because they first load the inner sequence into a
    keyed lookup, avoiding the need to repeatedly enumerate over every inner element.
    The disadvantage is that they offer the equivalent of inner and left outer joins
    only; cross joins and non-equi joins must still be done using `Select`/`SelectMany`.
    With EF Core queries, `Join` and `GroupJoin` offer no real benefits over `Select`
    and `SelectMany`.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`Join` 和 `GroupJoin` 提供了一种替代策略来使用 `Select` 和 `SelectMany`。`Join` 和 `GroupJoin`
    的优势在于它们在本地内存中的集合上执行效率高，因为它们首先将内部序列加载到键控查找中，避免了需要重复枚举每个内部元素的问题。缺点是它们只提供了等效的内部和左外连接；交叉连接和非等连接仍需使用
    `Select`/`SelectMany`。在 EF Core 查询中，`Join` 和 `GroupJoin` 与 `Select` 和 `SelectMany`
    相比并没有实质性的优势。'
- en: '[Table 9-1](#joining_strategies) summarizes the differences between each of
    the joining strategies.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 9-1](#joining_strategies) 总结了每种连接策略之间的差异。'
- en: Table 9-1\. Joining strategies
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9-1\. 连接策略
- en: '| Strategy | Result shape | Local query efficiency | Inner joins | Left outer
    joins | Cross joins | Non-equi joins |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| 策略 | 结果形状 | 本地查询效率 | 内部连接 | 左外连接 | 交叉连接 | 非等连接 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| `Select` + `SelectMany` | Flat | Bad | Yes | Yes | Yes | Yes |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| `Select` + `SelectMany` | 平坦 | 差 | 是 | 是 | 是 | 是 |'
- en: '| `Select` + `Select` | Nested | Bad | Yes | Yes | Yes | Yes |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| `Select` + `Select` | 嵌套 | 差 | 是 | 是 | 是 | 是 |'
- en: '| `Join` | Flat | Good | Yes | — | — | — |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| `Join` | 平坦 | 良好 | 是 | — | — | — |'
- en: '| `GroupJoin` | Nested | Good | Yes | Yes | — | — |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| `GroupJoin` | 嵌套 | 良好 | 是 | 是 | — | — |'
- en: '| `GroupJoin` + `SelectMany` | Flat | Good | Yes | Yes | — | — |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| `GroupJoin` + `SelectMany` | 平坦 | 良好 | 是 | 是 | — | — |'
- en: Join
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Join
- en: The `Join` operator performs an inner join, emitting a flat output sequence.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`Join` 运算符执行内部连接，生成一个平坦的输出序列。'
- en: 'The following query lists all customers alongside their purchases without using
    a navigation property:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询列出了所有客户以及他们的购买内容，而不使用导航属性：
- en: '[PRE77]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The results match what we would get from a `SelectMany`-style query:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与我们从 `SelectMany` 风格的查询中获得的结果相匹配：
- en: '[PRE78]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'To see the benefit of `Join` over `SelectMany`, we must convert this to a local
    query. We can demonstrate this by first copying all customers and purchases to
    arrays and then querying the arrays:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到 `Join` 胜过 `SelectMany` 的好处，我们必须将其转换为本地查询。我们可以首先将所有的客户和购买内容复制到数组中，然后查询这些数组：
- en: '[PRE79]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Although both queries yield the same results, the `Join` query is considerably
    faster because its implementation in `Enumerable` preloads the inner collection
    (`purchases`) into a keyed lookup.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管两个查询产生相同的结果，但 `Join` 查询速度显著更快，因为它在 `Enumerable` 中的实现预加载了内部集合（`purchases`）到键控查找中。
- en: 'The query syntax for `join` can be written in general terms, as follows:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`Join` 的查询语法通常可以用一般化的术语来描述，如下所示：'
- en: '[PRE80]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Join operators in LINQ differentiate between the *outer sequence* and *inner
    sequence*. Syntactically:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 中的连接操作符区分 *外部序列* 和 *内部序列*。语法上：
- en: The *outer sequence* is the input sequence (`customers`, in this case).
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*外部序列* 是输入序列（在本例中是 `customers`）。'
- en: The *inner sequence* is the new collection you introduce (`purchases`, in this
    case).
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内部序列* 是你引入的新集合（在本例中是 `purchases`）。'
- en: '`Join` performs inner joins, meaning customers without purchases are excluded
    from the output. With inner joins, you can swap the inner and outer sequences
    in the query and still get the same results:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`Join` 执行内连接，意味着没有购买内容的客户将被排除在输出之外。在内连接中，您可以交换查询中的内部和外部序列，并且仍然可以得到相同的结果：'
- en: '[PRE81]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'You can add further `join` clauses to the same query. If each purchase, for
    instance, has one or more purchase items, you could join the purchase items, as
    follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向相同的查询添加进一步的 `join` 子句。例如，如果每个购买具有一个或多个购买项目，您可以加入购买项目，如下所示：
- en: '[PRE82]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '`purchases` acts as the *inner* sequence in the first join and as the *outer*
    sequence in the second join. You could obtain the same results (inefficiently)
    using nested `foreach` statements, as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个连接中，`purchases` 充当 *内部* 序列，在第二个连接中充当 *外部* 序列。你可以使用嵌套的 `foreach` 语句以不高效的方式获得相同的结果，如下所示：
- en: '[PRE83]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In query syntax, variables from earlier joins remain in scope—just as they do
    with `SelectMany`-style queries. You’re also permitted to insert `where` and `let`
    clauses in between `join` clauses.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询语法中，来自早期连接的变量保持在作用域内——就像在`SelectMany`样式的查询中一样。您还允许在`join`子句之间插入`where`和`let`子句。
- en: Joining on multiple keys
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在多个键上进行连接
- en: 'You can join on multiple keys with anonymous types, as follows:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用匿名类型在多个键上进行连接，如下所示：
- en: '[PRE84]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: For this to work, the two anonymous types must be structured identically. The
    compiler then implements each with the same internal type, making the joining
    keys compatible.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 要使其工作，这两个匿名类型必须结构相同。然后编译器使用相同的内部类型实现每个类型，使连接键兼容。
- en: Joining in fluent syntax
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在流畅的语法中进行连接
- en: The following query syntax join
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的查询语法连接
- en: '[PRE85]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'in fluent syntax is as follows:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在流畅的语法中如下所示：
- en: '[PRE86]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The result selector expression at the end creates each element in the output
    sequence. If you have additional clauses prior to projecting, such as `orderby`
    in this example:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的选择器表达式在输出序列中创建每个元素。如果您在投影之前有额外的子句，比如在这个例子中的`orderby`：
- en: '[PRE87]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'you must manufacture a temporary anonymous type in the result selector in fluent
    syntax. This keeps both `c` and `p` in scope following the join:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在流畅的语法中，你必须在结果选择器中制造一个临时的匿名类型。这样可以在连接之后保持`c`和`p`的作用域：
- en: '[PRE88]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Query syntax is usually preferable when joining; it’s less fiddly.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接时通常更喜欢使用查询语法；它不那么琐碎。
- en: GroupJoin
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GroupJoin
- en: '`GroupJoin` does the same work as `Join`, but instead of yielding a flat result,
    it yields a hierarchical result, grouped by each outer element. It also allows
    left outer joins. `GroupJoin` is not currently supported in EF Core.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`GroupJoin`做的工作与`Join`相同，但不是产生平坦的结果，而是产生按每个外部元素分组的分层结果。它还允许左外连接。`GroupJoin`目前不支持在EF
    Core中使用。'
- en: The query syntax for `GroupJoin` is the same as for `Join`, but is followed
    by the `into` keyword.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`GroupJoin`的查询语法与`Join`相同，但后面跟着`into`关键字。'
- en: 'Here’s the most basic example, using a local query:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用本地查询的最基本的示例：
- en: '[PRE89]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Note
  id: totrans-394
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'An `into` clause translates to `GroupJoin` only when it appears directly after
    a `join` clause. After a `select` or `group` clause, it means *query continuation*.
    The two uses of the `into` keyword are quite different, although they have one
    feature in common: they both introduce a new range variable.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`into`子句仅在直接出现在`join`子句之后时才会转换为`GroupJoin`。在`select`或`group`子句之后，它表示*查询继续*。`into`关键字的两种用法非常不同，尽管它们有一个共同点：它们都引入了一个新的范围变量。'
- en: 'The result is a sequence of sequences, which we could enumerate as follows:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个序列的序列，我们可以按以下方式枚举：
- en: '[PRE90]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'This isn’t very useful, however, because `purchaseSequence` has no reference
    to the customer. More commonly, you’d do this:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是很有用，因为`purchaseSequence`没有对客户的引用。更常见的是，你会这样做：
- en: '[PRE91]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'This gives the same results as the following (inefficient) `Select` subquery:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下（低效的）`Select`子查询给出相同的结果：
- en: '[PRE92]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'By default, `GroupJoin` does the equivalent of a left outer join. To get an
    inner join—whereby customers without purchases are excluded—you need to filter
    on `custPurchases`:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`GroupJoin`执行左外连接的等效操作。要获取内连接——即排除没有购买的客户——您需要在`custPurchases`上进行过滤：
- en: '[PRE93]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Clauses after a group-join `into` operate on *subsequences* of inner child
    elements, not *individual* child elements. This means that to filter individual
    purchases, you’d need to call `Where` *before* joining:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在组连接`into`之后的子句操作*内部子元素*的*子序列*，而不是*单个*子元素。这意味着要过滤单独的购买，你需要在连接*之前*调用`Where`：
- en: '[PRE94]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: You can construct lambda queries with `GroupJoin` as you would with `Join`.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像使用`Join`一样使用`GroupJoin`构建lambda查询。
- en: Flat outer joins
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平面外连接
- en: 'You run into a dilemma if you want both an outer join and a flat result set.
    `GroupJoin` gives you the outer join; `Join` gives you the flat result set. The
    solution is to first call `GroupJoin`, then `DefaultIfEmpty` on each child sequence,
    and then finally `SelectMany` on the result:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你既想要外连接又想要一个平面结果集，你会遇到一个困境。`GroupJoin`给你外连接；`Join`给你平面结果集。解决方案是首先调用`GroupJoin`，然后对每个子序列调用`DefaultIfEmpty`，最后在结果上调用`SelectMany`：
- en: '[PRE95]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '`DefaultIfEmpty` emits a sequence with a single null value if a subsequence
    of purchases is empty. The second `from` clause translates to `SelectMany`. In
    this role, it *expands and flattens* all the purchase subsequences, concatenating
    them into a single sequence of purchase *elements*.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefaultIfEmpty`如果购买的子序列为空，则发出一个包含单个空值的序列。第二个`from`子句转换为`SelectMany`。在这个角色中，它*展开和扁平化*所有的购买子序列，将它们连接成一个购买*元素*的单一序列。'
- en: Joining with lookups
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用查找进行连接
- en: The `Join` and `GroupJoin` methods in `Enumerable` work in two steps. First,
    they load the inner sequence into a *lookup*. Second, they query the outer sequence
    in combination with the lookup.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enumerable` 中的`Join`和`GroupJoin`方法分两步工作。首先，它们将内部序列加载到一个*查找表*中。其次，它们查询外部序列与查找表的组合。'
- en: 'A *lookup* is a sequence of groupings that can be accessed directly by key.
    Another way to think of it is as a dictionary of sequences—a dictionary that can
    accept many elements under each key (sometimes called a *multidictionary*). Lookups
    are read-only and defined by the following interface:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lookup* 是一系列可以直接通过键访问的分组。另一种思考方式是它像是一个序列的字典，一个可以在每个键下接受多个元素的字典（有时称为*多字典*）。Lookup
    是只读的，并由以下接口定义：'
- en: '[PRE96]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Note
  id: totrans-415
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The joining operators—like other sequence-emitting operators—honor deferred
    or lazy execution semantics. This means the lookup is not built until you begin
    enumerating the output sequence (and then the *entire* lookup is built right then).
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 连接运算符——如其他发射序列的运算符——遵循延迟或惰性执行语义。这意味着直到您开始枚举输出序列（然后*整个*查找表才会构建）时，查找表才会构建。
- en: 'You can create and query lookups manually as an alternative strategy to using
    the joining operators when dealing with local collections. There are a couple
    of benefits to doing so:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 处理本地集合时，手动创建和查询查找表是使用连接运算符的替代策略之一。这样做有几个好处：
- en: You can reuse the same lookup over multiple queries—as well as in ordinary imperative
    code.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在多个查询中重用相同的查找表，以及在普通命令式代码中。
- en: Querying a lookup is an excellent way of understanding how `Join` and `GroupJoin`
    work.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询查找表是理解`Join`和`GroupJoin`工作的一个绝佳方法。
- en: 'The `ToLookup` extension method creates a lookup. The following loads all purchases
    into a lookup—keyed by their `CustomerID`:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToLookup` 扩展方法创建一个查找表。以下加载所有购买记录到一个由它们的 `CustomerID` 键控的查找表中：'
- en: '[PRE97]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The first argument selects the key; the second argument selects the objects
    that are to be loaded as values into the lookup.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数选择键；第二个参数选择要加载到查找表中的对象值。
- en: 'Reading a lookup is rather like reading a dictionary except that the indexer
    returns a *sequence* of matching items rather than a *single* matching item. The
    following enumerates all purchases made by the customer whose ID is 1:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 读取查找表有点像读取字典，但是索引器返回的是匹配项的*序列*而不是*单个*匹配项。以下列出了顾客 ID 为 1 的所有购买记录：
- en: '[PRE98]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'With a lookup in place, you can write `SelectMany`/`Select` queries that execute
    as efficiently as `Join`/`GroupJoin` queries. `Join` is equivalent to using `SelectMany`
    on a lookup:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 有了查找表，您可以编写`SelectMany`/`Select`查询，其执行效率与`Join`/`GroupJoin`查询一样高。`Join`等同于在查找表上使用`SelectMany`：
- en: '[PRE99]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Adding a call to `DefaultIfEmpty` makes this into an outer join:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 添加对`DefaultIfEmpty`的调用可将其转换为外连接：
- en: '[PRE100]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '`GroupJoin` is equivalent to reading the lookup inside a projection:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '`GroupJoin` 相当于在投影中读取查找表：'
- en: '[PRE101]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Enumerable implementations
  id: totrans-431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Enumerable 实现
- en: 'Here’s the simplest valid implementation of `Enumerable.Join`, null checking
    aside:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Enumerable.Join`的最简单有效实现，忽略了空检查：
- en: '[PRE102]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '`GroupJoin`’s implementation is like that of `Join` but simpler:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`GroupJoin` 的实现类似于 `Join` 但更简单：'
- en: '[PRE103]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The Zip Operator
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Zip 操作符
- en: '`IEnumerable<TFirst>`, `IEnumerable<TSecond>`→`IEnumerable<TResult>`'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<TFirst>`, `IEnumerable<TSecond>`→`IEnumerable<TResult>`'
- en: 'The `Zip` operator enumerates two sequences in step (like a zipper), returning
    a sequence based on applying a function over each element pair. For instance,
    the following:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '`Zip` 操作符按步骤（如拉链一样）枚举两个序列，并返回基于每对元素应用函数的序列。例如，以下操作：'
- en: '[PRE104]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'produces a sequence with the following elements:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 生成具有以下元素的序列：
- en: '[PRE105]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Extra elements in either input sequence are ignored. `Zip` is not supported
    by EF Core.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 任一输入序列中的额外元素将被忽略。EF Core 不支持`Zip`。
- en: Ordering
  id: totrans-443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序
- en: '`IEnumerable<TSource>`→`IOrderedEnumerable<TSource>`'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<TSource>`→`IOrderedEnumerable<TSource>`'
- en: '| Method | Description | SQL equivalents |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 | SQL 等效项 |'
- en: '| --- | --- | --- |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `OrderBy, ThenBy` | Sorts a sequence in ascending order | `ORDER BY` ...
    |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '| `OrderBy, ThenBy` | 按升序排序序列 | `ORDER BY` ... |'
- en: '| `OrderByDescending, ThenByDescending` | Sorts a sequence in descending order
    | `ORDER BY` ... `DESC` |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '| `OrderByDescending, ThenByDescending` | 按降序排序序列 | `ORDER BY` ... `DESC` |'
- en: '| `Reverse` | Returns a sequence in reverse order | Exception thrown |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '| `Reverse` | 返回按照逆序排序的序列 | 抛出异常 |'
- en: Ordering operators return the same elements in a different order.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 排序运算符按不同顺序返回相同的元素。
- en: OrderBy, OrderByDescending, ThenBy, ThenByDescending
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OrderBy、OrderByDescending、ThenBy、ThenByDescending
- en: OrderBy and OrderByDescending arguments
  id: totrans-452
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OrderBy 和 OrderByDescending 参数
- en: '| Argument | Type |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 类型 |'
- en: '| --- | --- |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Input sequence | `IEnumerable<TSource>` |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '| 输入序列 | `IEnumerable<TSource>` |'
- en: '| Key selector | `TSource => TKey` |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '| 键选择器 | `TSource => TKey` |'
- en: Return type = `IOrderedEnumerable<TSource>`
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型 = `IOrderedEnumerable<TSource>`
- en: ThenBy and ThenByDescending arguments
  id: totrans-458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ThenBy和ThenByDescending参数
- en: '| Argument | Type |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 类型 |'
- en: '| --- | --- |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Input sequence | `IOrderedEnumerable<TSource>` |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| 输入序列 | `IOrderedEnumerable<TSource>` |'
- en: '| Key selector | `TSource => TKey` |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| 键选择器 | `TSource => TKey` |'
- en: Query syntax
  id: totrans-463
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询语法
- en: '[PRE106]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Overview
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: '`OrderBy` returns a sorted version of the input sequence, using the `keySelector`
    expression to make comparisons. The following query emits a sequence of names
    in alphabetical order:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderBy`返回输入序列的排序版本，使用`keySelector`表达式进行比较。以下查询以字母顺序输出名称序列：'
- en: '[PRE107]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The following sorts names by length:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码按长度排序名称：
- en: '[PRE108]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The relative order of elements with the same sorting key (in this case, Jay/Tom
    and Mary/Dick) is indeterminate—unless you append a `ThenBy` operator:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 具有相同排序键的元素的相对顺序（在本例中为Jay/Tom和Mary/Dick）是不确定的——除非您附加`ThenBy`运算符：
- en: '[PRE109]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '`ThenBy` reorders only elements that had the same sorting key in the preceding
    sort. You can chain any number of `ThenBy` operators. The following sorts first
    by length, then by the second character, and finally by the first character:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThenBy`只重新排序具有相同排序键的先前排序中的元素。您可以链接任意数量的`ThenBy`运算符。以下代码首先按长度排序，然后按第二个字符排序，最后按第一个字符排序：'
- en: '[PRE110]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Here’s the equivalent in query syntax:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是查询语法中的等效语句：
- en: '[PRE111]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Warning
  id: totrans-476
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'The following variation is *incorrect*—it will actually order first by `s[1]`
    and then by `s.Length` (or in the case of a database query, it will order *only*
    by `s[1]` and discard the former ordering):'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的变体是*不正确*的——它实际上将首先按`s[1]`排序，然后按`s.Length`排序（或在数据库查询的情况下，仅按`s[1]`排序并丢弃前一个排序）：
- en: '[PRE112]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'LINQ also provides `OrderByDescending` and `ThenByDescending` operators, which
    do the same things, emitting the results in reverse order. The following EF Core
    query retrieves purchases in descending order of price, with those of the same
    price listed alphabetically:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ还提供了`OrderByDescending`和`ThenByDescending`运算符，它们执行相同的操作，但以相反的顺序输出结果。以下是EF
    Core查询的示例，按价格降序检索购买项目，并按价格相同的字母顺序列出：
- en: '[PRE113]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'In query syntax:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 查询语法中：
- en: '[PRE114]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Comparers and collations
  id: totrans-483
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较器和排序规则
- en: 'In a local query, the key selector objects themselves determine the ordering
    algorithm via their default `IComparable` implementation (see [Chapter 7](ch07.html#collections-id00055)).
    You can override the sorting algorithm by passing in an `IComparer` object. The
    following performs a case-insensitive sort:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地查询中，键选择器对象本身通过其默认的`IComparable`实现来确定排序算法（参见[第7章](ch07.html#collections-id00055)）。您可以通过传入一个`IComparer`对象来覆盖排序算法。以下是执行不区分大小写排序的示例：
- en: '[PRE115]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Passing in a comparer is not supported in query syntax or in any way by EF
    Core. When querying a database, the comparison algorithm is determined by the
    participating column’s collation. If the collation is case sensitive, you can
    request a case-insensitive sort by calling `ToUpper` in the key selector:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询语法或EF Core中，不支持传入比较器的方式。在查询数据库时，比较算法由参与列的排序决定。如果排序是区分大小写的，则可以通过在键选择器中调用`ToUpper`来请求不区分大小写的排序：
- en: '[PRE116]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: IOrderedEnumerable and IOrderedQueryable
  id: totrans-488
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IOrderedEnumerable和IOrderedQueryable
- en: The ordering operators return special subtypes of `IEnumerable<T>`. Those in
    `Enumerable` return `IOrderedEnumerable<TSource>`; those in `Queryable` return
    `IOrderedQueryable<TSource>`. These subtypes allow a subsequent `ThenBy` operator
    to refine rather than replace the existing ordering.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 排序运算符返回`IEnumerable<T>`的特殊子类型。`Enumerable`中的返回`IOrderedEnumerable<TSource>`；`Queryable`中的返回`IOrderedQueryable<TSource>`。这些子类型允许后续的`ThenBy`运算符来细化而不是替换现有的排序。
- en: 'The additional members that these subtypes define are not publicly exposed,
    so they present like ordinary sequences. The fact that they are different types
    comes into play when building queries progressively:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 这些子类型定义的附加成员不公开显示，因此它们看起来像普通序列。它们是不同类型的事实在逐步构建查询时发挥作用：
- en: '[PRE117]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'If we instead declare `query1` of type `IEnumerable<string>`, the second line
    would not compile—`ThenBy` requires an input of type `IOrderedEnumerable<string>`.
    You can avoid worrying about this by implicitly typing range variables:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`query1`声明为`IEnumerable<string>`类型，第二行将无法编译——`ThenBy`需要`IOrderedEnumerable<string>`类型的输入。您可以通过隐式类型化范围变量来避免担心此问题：
- en: '[PRE118]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Implicit typing can create problems of its own, though. The following will
    not compile:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式类型化可能会带来自身的问题。以下内容将无法编译：
- en: '[PRE119]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The compiler infers `query` to be of type `IOrderedEnumerable<string>`, based
    on `OrderBy`’s output sequence type. However, the `Where` on the next line returns
    an ordinary `IEnumerable<string>`, which cannot be assigned back to `query`. You
    can work around this either with explicit typing or by calling `AsEnumerable()`
    after `OrderBy`:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器根据 `OrderBy` 的输出序列类型推断 `query` 的类型为 `IOrderedEnumerable<string>`。然而，下一行上的
    `Where` 返回一个普通的 `IEnumerable<string>`，它不能被赋回给 `query`。您可以通过显式类型或在 `OrderBy` 后调用
    `AsEnumerable()` 来解决这个问题：
- en: '[PRE120]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: The equivalent in interpreted queries is to call `AsQueryable`.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 解释查询中的等效操作是调用 `AsQueryable`。
- en: Grouping
  id: totrans-499
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分组
- en: '| Method | Description | SQL equivalents |'
  id: totrans-500
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 | SQL 等效项 |'
- en: '| --- | --- | --- |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `GroupBy` | Groups a sequence into subsequences | `GROUP BY` |'
  id: totrans-502
  prefs: []
  type: TYPE_TB
  zh: '| `GroupBy` | 将序列分组为子序列 | `GROUP BY` |'
- en: '| `Chunk` | Groups a sequence into arrays of a fixed size |   |'
  id: totrans-503
  prefs: []
  type: TYPE_TB
  zh: '| `Chunk` | 将序列分组为固定大小的数组 |   |'
- en: GroupBy
  id: totrans-504
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GroupBy
- en: '`IEnumerable<TSource>`→`IEnumerable<IGrouping<TKey,TElement>>`'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<TSource>`→`IEnumerable<IGrouping<TKey,TElement>>`'
- en: '| Argument | Type |'
  id: totrans-506
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 类型 |'
- en: '| --- | --- |'
  id: totrans-507
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Input sequence | `IEnumerable<TSource>` |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
  zh: '| 输入序列 | `IEnumerable<TSource>` |'
- en: '| Key selector | `TSource => TKey` |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
  zh: '| 键选择器 | `TSource => TKey` |'
- en: '| Element selector (optional) | `TSource => TElement` |'
  id: totrans-510
  prefs: []
  type: TYPE_TB
  zh: '| 元素选择器（可选） | `TSource => TElement` |'
- en: '| Comparer (optional) | `IEqualityComparer<TKey>` |'
  id: totrans-511
  prefs: []
  type: TYPE_TB
  zh: '| 比较器（可选） | `IEqualityComparer<TKey>` |'
- en: Query syntax
  id: totrans-512
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询语法
- en: '[PRE121]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Overview
  id: totrans-514
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: '`GroupBy` organizes a flat input sequence into sequences of *groups*. For example,
    the following organizes all of the files in *Path.GetTempPath()* by extension:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '`GroupBy` 将一个扁平的输入序列组织成 *组* 的序列。例如，以下内容通过扩展名组织 *Path.GetTempPath()* 中的所有文件：'
- en: '[PRE122]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Or, with implicit typing:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用隐式类型转换：
- en: '[PRE123]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Here’s how to enumerate the result:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何枚举结果的：
- en: '[PRE124]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '`Enumerable.GroupBy` works by reading the input elements into a temporary dictionary
    of lists so that all elements with the same key end up in the same sublist. It
    then emits a sequence of *groupings*. A grouping is a sequence with a `Key` property:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enumerable.GroupBy` 通过将输入元素读取到临时字典的列表中来工作，使得所有具有相同键的元素最终位于同一个子列表中。然后，它发出一个
    *分组* 的序列。分组是一个带有 `Key` 属性的序列：'
- en: '[PRE125]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'By default, the elements in each grouping are untransformed input elements
    unless you specify an `elementSelector` argument. The following projects each
    input element to uppercase:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每个分组中的元素未经转换，除非指定了 `elementSelector` 参数。以下内容将每个输入元素投影到大写：
- en: '[PRE126]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'An `elementSelector` is independent of the `keySelector`. In our case, this
    means that the `Key` on each grouping is still in its original case:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '`elementSelector` 独立于 `keySelector`。在我们的情况下，这意味着每个分组上的 `Key` 仍保持其原始大小写：'
- en: '[PRE127]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Note that the subcollections are not emitted in alphabetical order of key.
    `GroupBy` merely *groups;* it does not *sort*. In fact, it preserves the original
    ordering. To sort, you must add an `OrderBy` operator:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，子集合不会按键的字母顺序发出。 `GroupBy` 只是 *分组*，而不是 *排序*。实际上，它保留了原始顺序。要进行排序，必须添加 `OrderBy`
    运算符：
- en: '[PRE128]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '`GroupBy` has a simple and direct translation in query syntax:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '`GroupBy` 在查询语法中有一个简单明了的翻译：'
- en: '[PRE129]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Here’s our example in query syntax:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们的查询语法示例：
- en: '[PRE130]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'As with `select`, `group` “ends” a query—unless you add a query continuation
    clause:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `select` 一样，`group` "结束" 了查询 —— 除非您添加查询继续子句：
- en: '[PRE131]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Query continuations are often useful in a `group by` query. The next query
    filters out groups that have fewer than five files in them:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 查询继续子句在 `group by` 查询中经常很有用。下一个查询过滤掉少于五个文件的组：
- en: '[PRE132]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Note
  id: totrans-537
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A `where` after a `group by` is equivalent to HAVING in SQL. It applies to each
    subsequence or grouping as a whole rather than the individual elements.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '`group by` 后的 `where` 相当于 SQL 中的 HAVING。它适用于每个子序列或分组作为整体而不是个别元素。'
- en: 'Sometimes, you’re interested purely in the result of an aggregation on a grouping
    and so can abandon the subsequences:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您只对分组上的聚合结果感兴趣，因此可以放弃子序列：
- en: '[PRE133]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: GroupBy in EF Core
  id: totrans-541
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: EF Core 中的 GroupBy
- en: 'Grouping works in the same way when querying a database. If you have navigation
    properties set up, you’ll find, however, that the need to group arises less frequently
    than with standard SQL. For instance, to select customers with at least two purchases,
    you don’t need to `group`; the following query does the job nicely:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 当在数据库查询中使用分组时，分组的工作方式相同。如果设置了导航属性，您会发现，与标准 SQL 相比，需要分组的情况较少。例如，要选择至少有两次购买的客户，您不需要
    `group`；以下查询可以很好地完成工作：
- en: '[PRE134]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'An example of when you might use grouping is to list total sales by year:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 一个使用分组的示例是按年列出总销售额：
- en: '[PRE135]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'LINQ’s grouping is more powerful than SQL’s GROUP BY in that you can fetch
    all detail rows without any aggregation:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 的分组比 SQL 的 GROUP BY 更强大，因为你可以获取所有细节行而不进行任何聚合：
- en: '[PRE136]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: However, this doesn’t work in EF Core. An easy workaround is to call `.AsEnumerable()`
    just before grouping so that the grouping happens on the client. This is no less
    efficient as long as you perform any filtering *before* grouping so that you only
    fetch the data you need from the server.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这在 EF Core 中不起作用。一个简单的解决方法是在分组之前调用 `.AsEnumerable()`，以便在客户端上进行分组。只要在分组之前执行任何过滤操作，从服务器获取你需要的数据就不会影响效率。
- en: Another departure from traditional SQL comes in there being no obligation to
    project the variables or expressions used in grouping or sorting.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不同于传统 SQL 的地方在于没有义务投射到用于分组或排序的变量或表达式中。
- en: Grouping by multiple keys
  id: totrans-550
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按多个键分组
- en: 'You can group by a composite key, using an anonymous type:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过匿名类型来进行复合键分组：
- en: '[PRE137]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Custom equality comparers
  id: totrans-553
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义相等比较器
- en: 'You can pass a custom equality comparer into `GroupBy`, in a local query, to
    change the algorithm for key comparison. Rarely is this required, though, because
    changing the key selector expression is usually sufficient. For instance, the
    following creates a case-insensitive grouping:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地查询中，你可以将自定义的相等比较器传递给 `GroupBy`，以更改键比较的算法。尽管如此，很少需要这样做，因为通常只需更改键选择器表达式就足够了。例如，以下代码创建一个不区分大小写的分组：
- en: '[PRE138]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Chunk
  id: totrans-556
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 块
- en: '`IEnumerable<TSource>`→`IEnumerable<TElement[]>`'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<TSource>`→`IEnumerable<TElement[]>`'
- en: '| Argument | Type |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 类型 |'
- en: '| --- | --- |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Input sequence | `IEnumerable<TSource>` |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '| 输入序列 | `IEnumerable<TSource>` |'
- en: '| `size` | `int` |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '| `size` | `int` |'
- en: 'Introduced in .NET 6, `Chunk` groups a sequence into chunks of a given size
    (or fewer, if there aren’t enough elements):'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 6 中引入的 `Chunk` 方法将序列分组为指定大小的块（如果元素不足则可能更少）：
- en: '[PRE139]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Output:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE140]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Set Operators
  id: totrans-566
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合运算符
- en: '`IEnumerable<TSource>`, `IEnumerable<TSource>`→`IEnumerable<TSource>`'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<TSource>`, `IEnumerable<TSource>`→`IEnumerable<TSource>`'
- en: '| Method | Description | SQL equivalents |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 | SQL 等效项 |'
- en: '| --- | --- | --- |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Concat` | Returns a concatenation of elements in each of the two sequences
    | `UNION ALL` |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
  zh: '| `Concat` | 返回两个序列中所有元素的串联 | `UNION ALL` |'
- en: '| `Union`, `UnionBy` | Returns a concatenation of elements in each of the two
    sequences, excluding duplicates | `UNION` |'
  id: totrans-571
  prefs: []
  type: TYPE_TB
  zh: '| `Union`, `UnionBy` | 返回两个序列中各元素的串联，排除重复项 | `UNION` |'
- en: '| `Intersect`, `IntersectBy` | Returns elements present in both sequences |
    `WHERE ... IN (...)` |'
  id: totrans-572
  prefs: []
  type: TYPE_TB
  zh: '| `Intersect`, `IntersectBy` | 返回两个序列中都存在的元素 | `WHERE ... IN (...)` |'
- en: '| `Except`, `ExceptBy` | Returns elements present in the first but not the
    second sequence | `EXCEPT` *or* `WHERE ... NOT IN (...)` |'
  id: totrans-573
  prefs: []
  type: TYPE_TB
  zh: '| `Except`, `ExceptBy` | 返回第一个序列中存在但第二个序列中不存在的元素 | `EXCEPT` *或* `WHERE ...
    NOT IN (...)` |'
- en: Concat, Union, UnionBy
  id: totrans-574
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Concat, Union, UnionBy
- en: '`Concat` returns all the elements of the first sequence, followed by all the
    elements of the second. `Union` does the same but removes any duplicates:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '`Concat` 返回第一个序列的所有元素，然后是第二个序列的所有元素。`Union` 也是如此，但会移除任何重复项：'
- en: '[PRE141]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Specifying the type argument explicitly is useful when the sequences are differently
    typed but the elements have a common base type. For instance, with the reflection
    API ([Chapter 18](ch18.html#reflection_and_metadata)), methods and properties
    are represented with `MethodInfo` and `PropertyInfo` classes, which have a common
    base class called `MemberInfo`. We can concatenate methods and properties by stating
    that base class explicitly when calling `Concat`:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 明确指定类型参数在序列类型不同但元素具有共同基类型时非常有用。例如，在反射 API ([第18章](ch18.html#reflection_and_metadata))
    中，方法和属性分别由 `MethodInfo` 和 `PropertyInfo` 类表示，它们有一个称为 `MemberInfo` 的共同基类。我们可以在调用
    `Concat` 时显式地说明这个基类来连接方法和属性：
- en: '[PRE142]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'In the next example, we filter the methods before concatenating:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们在连接之前过滤了方法：
- en: '[PRE143]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'This example relies on interface type parameter variance: `methods` is of type
    `IEnumerable<MethodInfo>`, which requires a covariant conversion to `IEnumerable​<Mem⁠berInfo>`.
    It’s a good illustration of how variance makes things work more like you’d expect.'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例依赖于接口类型参数的协变性：`methods` 是 `IEnumerable<MethodInfo>` 类型，需要进行协变转换为 `IEnumerable<MemberInfo>`。这是一个很好的示例，说明了协变如何使事情更像你期望的那样工作。
- en: '`UnionBy` (introduced in .NET 6) takes a `keySelector`, which is used in determining
    whether an element is a duplicate. In the following example, we perform a case-insensitive
    union:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '`.NET 6` 引入的 `UnionBy` 方法接受一个 `keySelector`，用于确定元素是否重复。在以下示例中，我们执行不区分大小写的联合操作：'
- en: '[PRE144]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'In this case, the same thing can be accomplished with `Union`, if we supply
    an equality comparer:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果我们提供相等比较器，可以使用 `Union` 来实现相同的效果：
- en: '[PRE145]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Intersect, Intersect By, Except, and ExceptBy
  id: totrans-586
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Intersect、Intersect By、Except 和 ExceptBy
- en: '`Intersect` returns the elements that two sequences have in common. `Except`
    returns the elements in the first input sequence that are *not* present in the
    second:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '`Intersect` 返回两个序列中共同的元素。`Except` 返回第一个输入序列中不在第二个序列中的元素：'
- en: '[PRE146]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '`Enumerable.Except` works internally by loading all of the elements in the
    first collection into a dictionary and then removing from the dictionary all elements
    present in the second sequence. The equivalent in SQL is a `NOT EXISTS` or `NOT
    IN` subquery:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enumerable.Except` 的内部工作方式是将第一个集合中的所有元素加载到字典中，然后从字典中删除第二个序列中存在的所有元素。在 SQL
    中的等效操作是 `NOT EXISTS` 或 `NOT IN` 子查询：'
- en: '[PRE147]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: The `IntersectBy` and `ExceptBy` methods (from .NET 6) let you specify a key
    selector that’s applied before performing equality comparison (see the discussion
    on `UnionBy` in the preceding section).
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '`.NET 6` 中的 `IntersectBy` 和 `ExceptBy` 方法允许您指定键选择器，在执行相等比较之前应用（请参见前面部分关于 `UnionBy`
    的讨论）。'
- en: Conversion Methods
  id: totrans-592
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换方法
- en: 'LINQ deals primarily in sequences; in other words, collections of type `IEnumerable<T>`.
    The conversion methods convert to and from other types of collections:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 主要处理序列；换句话说，类型为 `IEnumerable<T>` 的集合。转换方法用于与其他类型的集合进行转换：
- en: '| Method | Description |'
  id: totrans-594
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-595
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `OfType` | Converts `IEnumerable` to `IEnumerable<T>`, discarding wrongly
    typed elements |'
  id: totrans-596
  prefs: []
  type: TYPE_TB
  zh: '| `OfType` | 将 `IEnumerable` 转换为 `IEnumerable<T>`，丢弃错误类型的元素 |'
- en: '| `Cast` | Converts `IEnumerable` to `IEnumerable<T>`, throwing an exception
    if there are any wrongly typed elements |'
  id: totrans-597
  prefs: []
  type: TYPE_TB
  zh: '| `Cast` | 将 `IEnumerable` 转换为 `IEnumerable<T>`，如果有错误类型的元素则抛出异常 |'
- en: '| `ToArray` | Converts `IEnumerable<T>` to `T[]` |'
  id: totrans-598
  prefs: []
  type: TYPE_TB
  zh: '| `ToArray` | 将 `IEnumerable<T>` 转换为 `T[]` |'
- en: '| `ToList` | Converts `IEnumerable<T>` to `List<T>` |'
  id: totrans-599
  prefs: []
  type: TYPE_TB
  zh: '| `ToList` | 将 `IEnumerable<T>` 转换为 `List<T>` |'
- en: '| `ToDictionary` | Converts `IEnumerable<T>` to `Dictionary<TKey,TValue>` |'
  id: totrans-600
  prefs: []
  type: TYPE_TB
  zh: '| `ToDictionary` | 将 `IEnumerable<T>` 转换为 `Dictionary<TKey, TValue>` |'
- en: '| `ToLookup` | Converts `IEnumerable<T>` to `ILookup<TKey,TElement>` |'
  id: totrans-601
  prefs: []
  type: TYPE_TB
  zh: '| `ToLookup` | 将 `IEnumerable<T>` 转换为 `ILookup<TKey, TElement>` |'
- en: '| `AsEnumerable` | Upcasts to `IEnumerable<T>` |'
  id: totrans-602
  prefs: []
  type: TYPE_TB
  zh: '| `AsEnumerable` | 向上转型为 `IEnumerable<T>` |'
- en: '| `AsQueryable` | Casts or converts to `IQueryable<T>` |'
  id: totrans-603
  prefs: []
  type: TYPE_TB
  zh: '| `AsQueryable` | 转换或转换为 `IQueryable<T>` |'
- en: OfType and Cast
  id: totrans-604
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OfType 和 Cast
- en: '`OfType` and `Cast` accept a nongeneric `IEnumerable` collection and emit a
    generic `IEnumerable<T>` sequence that you can subsequently query:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '`OfType` 和 `Cast` 接受一个非泛型的 `IEnumerable` 集合，并生成一个泛型的 `IEnumerable<T>` 序列，您可以随后进行查询：'
- en: '[PRE148]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '`Cast` and `OfType` differ in their behavior when encountering an input element
    that’s of an incompatible type. `Cast` throws an exception; `OfType` ignores the
    incompatible element. Continuing the preceding example:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到不兼容类型的输入元素时，`Cast` 和 `OfType` 的行为有所不同。`Cast` 抛出异常；`OfType` 忽略不兼容的元素。继续前面的示例：
- en: '[PRE149]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'The rules for element compatibility exactly follow those of C#’s `is` operator,
    and therefore consider only reference conversions and unboxing conversions. We
    can see this by examining the internal implementation of `OfType`:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 元素兼容性的规则完全遵循 C# 的 `is` 操作符的规则，因此仅考虑引用转换和拆箱转换。通过检查 `OfType` 的内部实现，我们可以看到这一点：
- en: '[PRE150]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '`Cast` has an identical implementation, except that it omits the type compatibility
    test:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cast` 有一个相同的实现，只是它省略了类型兼容性测试：'
- en: '[PRE151]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'A consequence of these implementations is that you cannot use `Cast` to perform
    numeric or custom conversions (for these, you must perform a `Select` operation
    instead). In other words, `Cast` is not as flexible as C#’s cast operator:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实现的结果是，您不能使用 `Cast` 进行数值或自定义转换（对于这些情况，您必须执行 `Select` 操作）。换句话说，`Cast` 不像 C#
    的转型操作符那样灵活：
- en: '[PRE152]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'We can demonstrate this by attempting to use `OfType` or `Cast` to convert
    a sequence of `int`s to a sequence of `long`s:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过尝试使用 `OfType` 或 `Cast` 将 `int` 序列转换为 `long` 序列来演示这一点：
- en: '[PRE153]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'When enumerated, `test1` emits zero elements and `test2` throws an exception.
    Examining `OfType`’s implementation, it’s fairly clear why. After substituting
    `TSource`, we get the following expression:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 在枚举时，`test1` 发出零个元素，而 `test2` 抛出异常。检查 `OfType` 的实现后，这一点就变得非常清楚。在替换 `TSource`
    后，我们得到以下表达式：
- en: '[PRE154]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: This returns `false` for an `int element`, due to the lack of an inheritance
    relationship.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `int 元素`，由于缺少继承关系，返回 `false`。
- en: Note
  id: totrans-620
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The reason that `test2` throws an exception when enumerated is more subtle.
    Notice in `Cast`’s implementation that `element` is of type `object`. When `TSource`
    is a value type, the CLR assumes this is an *unboxing conversion* and synthesizes
    a method that reproduces the scenario described in the section [“Boxing and Unboxing”](ch03.html#boxing_and_unboxing):'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '`test2` 在枚举时抛出异常的原因更加微妙。请注意在 `Cast` 的实现中，`element` 的类型是 `object`。当 `TSource`
    是值类型时，CLR 假定这是一种 *拆箱转换*，并合成一种方法来重现本节 [“装箱和拆箱”](ch03.html#boxing_and_unboxing)
    中描述的情景：'
- en: '[PRE155]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Because the `element` variable is declared of type `object`, an `object`-to-`long`
    cast is performed (an unboxing) rather than an `int`-to-`long` numeric conversion.
    Unboxing operations require an exact type match, so the `object`-to-`long` unbox
    fails when given an `int`.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `element` 变量声明为 `object` 类型，所以执行了 `object` 到 `long` 的转换（拆箱），而不是 `int` 到 `long`
    的数值转换。拆箱操作需要精确的类型匹配，因此在给定 `int` 时，`object` 到 `long` 的拆箱操作将失败。
- en: 'As we suggested previously, the solution is to use an ordinary `Select`:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前建议的，解决方案是使用普通的 `Select`：
- en: '[PRE156]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '`OfType` and `Cast` are also useful in downcasting elements in a generic input
    sequence. For instance, if you have an input sequence of type `IEnumerable<Fruit>`,
    `OfType<Apple>` would return just the apples. This is particularly useful in LINQ
    to XML (see [Chapter 10](ch10.html#linq_to_xml)).'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '`OfType` 和 `Cast` 在将泛型输入序列中的元素向下转换方面也很有用。例如，如果您有一个类型为 `IEnumerable<Fruit>`
    的输入序列，`OfType<Apple>` 将仅返回苹果。这在 LINQ to XML 中特别有用（请参阅 [第10章](ch10.html#linq_to_xml)）。'
- en: '`Cast` has query syntax support: simply precede the range variable with a type:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cast` 支持查询语法：只需在范围变量前加上类型：'
- en: '[PRE157]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: ToArray, ToList, ToDictionary, ToHashSet, ToLookup
  id: totrans-629
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ToArray, ToList, ToDictionary, ToHashSet, ToLookup
- en: '`ToArray`, `ToList`, and `ToHashSet` emit the results into an array, `List<T>`
    or `HashSet<T>`. When they execute, these operators force the immediate enumeration
    of the input sequence. For examples, refer to [“Deferred Execution”](ch08.html#deferred_executio).'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToArray`, `ToList`, 和 `ToHashSet` 将结果转换为数组，`List<T>` 或 `HashSet<T>`。执行时，这些操作符强制立即枚举输入序列。有关示例，请参阅
    [“延迟执行”](ch08.html#deferred_executio)。'
- en: '`ToDictionary` and `ToLookup` accept the following arguments:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToDictionary` 和 `ToLookup` 接受以下参数：'
- en: '| Argument | Type |'
  id: totrans-632
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 类型 |'
- en: '| --- | --- |'
  id: totrans-633
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Input sequence | `IEnumerable<TSource>` |'
  id: totrans-634
  prefs: []
  type: TYPE_TB
  zh: '| 输入序列 | `IEnumerable<TSource>` |'
- en: '| Key selector | `TSource => TKey` |'
  id: totrans-635
  prefs: []
  type: TYPE_TB
  zh: '| 键选择器 | `TSource => TKey` |'
- en: '| Element selector (optional) | `TSource => TElement` |'
  id: totrans-636
  prefs: []
  type: TYPE_TB
  zh: '| 元素选择器（可选） | `TSource => TElement` |'
- en: '| Comparer (optional) | `IEqualityComparer<TKey>` |'
  id: totrans-637
  prefs: []
  type: TYPE_TB
  zh: '| 比较器（可选） | `IEqualityComparer<TKey>` |'
- en: '`ToDictionary` also forces immediate execution of a sequence, writing the results
    to a generic `Dictionary`. The `keySelector` expression you provide must evaluate
    to a unique value for each element in the input sequence; otherwise, an exception
    is thrown. In contrast, `ToLookup` allows many elements of the same key. We described
    lookups in [“Joining with lookups”](#joining_with_lookups).'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToDictionary` 也强制立即执行序列，并将结果写入通用的 `Dictionary`。您提供的 `keySelector` 表达式必须对输入序列中的每个元素评估为唯一值；否则，将抛出异常。相比之下，`ToLookup`
    允许多个具有相同键的元素。我们在 [“使用查找进行连接”](#joining_with_lookups) 中描述了查找。'
- en: AsEnumerable and AsQueryable
  id: totrans-639
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AsEnumerable 和 AsQueryable
- en: '`AsEnumerable` upcasts a sequence to `IEnumerable<T>`, forcing the compiler
    to bind subsequent query operators to methods in `Enumerable` instead of `Queryable`.
    For an example, see [“Combining Interpreted and Local Queries”](ch08.html#combining_interpreted_and_local_queries).'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsEnumerable` 将序列向上转换为 `IEnumerable<T>`，强制编译器将后续查询操作绑定到 `Enumerable` 中的方法，而不是
    `Queryable`。有例子，请参见 [“组合解释和本地查询”](ch08.html#combining_interpreted_and_local_queries)。'
- en: '`AsQueryable` downcasts a sequence to `IQueryable<T>` if it implements that
    interface. Otherwise, it instantiates an `IQueryable<T>` wrapper over the local
    query.'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsQueryable` 如果实现了接口 `IQueryable<T>`，则将序列向下转换为 `IQueryable<T>`。否则，它会在本地查询上实例化一个
    `IQueryable<T>` 包装器。'
- en: Element Operators
  id: totrans-642
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元素操作符
- en: '`IEnumerable<TSource>`→ `TSource`'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<TSource>`→ `TSource`'
- en: '| Method | Description | SQL equivalents |'
  id: totrans-644
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 | SQL 等效项 |'
- en: '| --- | --- | --- |'
  id: totrans-645
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `First, FirstOrDefault` | Returns the first element in the sequence, optionally
    satisfying a predicate | `SELECT TOP 1` ... `ORDER BY` ... |'
  id: totrans-646
  prefs: []
  type: TYPE_TB
  zh: '| `First, FirstOrDefault` | 返回序列中的第一个元素，可选择满足谓词 | `SELECT TOP 1` ... `ORDER
    BY` ... |'
- en: '| `Last`, `LastOrDefault` | Returns the last element in the sequence, optionally
    satisfying a predicate | `SELECT TOP 1` ... `ORDER BY` ... `DESC` |'
  id: totrans-647
  prefs: []
  type: TYPE_TB
  zh: '| `Last`, `LastOrDefault` | 返回序列中的最后一个元素，可选择满足谓词 | `SELECT TOP 1` ... `ORDER
    BY` ... `DESC` |'
- en: '| `Single, SingleOrDefault` | Equivalent to `First/FirstOrDefault`, but throws
    an exception if there is more than one match |   |'
  id: totrans-648
  prefs: []
  type: TYPE_TB
  zh: '| `Single, SingleOrDefault` | 等同于 `First/FirstOrDefault`，但如果有多个匹配则抛出异常 |  
    |'
- en: '| `ElementAt, ElementAtOrDefault` | Returns the element at the specified position
    | Exception thrown |'
  id: totrans-649
  prefs: []
  type: TYPE_TB
  zh: '| `ElementAt, ElementAtOrDefault` | 返回指定位置的元素 | 抛出异常 |'
- en: '| `MinBy`, `MaxBy` | Returns the element with the smallest or largest value
    | Exception thrown |'
  id: totrans-650
  prefs: []
  type: TYPE_TB
  zh: '| `MinBy`, `MaxBy` | 返回具有最小或最大值的元素 | 抛出异常 |'
- en: '| `DefaultIfEmpty` | Returns a single-element sequence whose value is `default(TSource)`
    if the sequence has no elements | `OUTER JOIN` |'
  id: totrans-651
  prefs: []
  type: TYPE_TB
  zh: '| `DefaultIfEmpty` | 如果序列为空，则返回一个包含单个元素的序列，其值为 `default(TSource)` | `OUTER
    JOIN` |'
- en: Methods ending in “OrDefault” return `default(TSource)` rather than throwing
    an exception if the input sequence is empty or if no elements match the supplied
    predicate.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 以 “OrDefault” 结尾的方法在输入序列为空或没有元素与提供的谓词匹配时返回 `default(TSource)`，而不是抛出异常。
- en: '`default(TSource)` is `null` for reference type elements, `false` for the `bool`
    type, and zero for numeric types.'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 对于引用类型元素，`default(TSource)` 是 `null`，对于 `bool` 类型是 `false`，对于数值类型是零。
- en: First, Last, and Single
  id: totrans-654
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: First、Last 和 Single
- en: '| Argument | Type |'
  id: totrans-655
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 类型 |'
- en: '| --- | --- |'
  id: totrans-656
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Source sequence | `IEnumerable<TSource>` |'
  id: totrans-657
  prefs: []
  type: TYPE_TB
  zh: '| 源序列 | `IEnumerable<TSource>` |'
- en: '| Predicate (optional) | `TSource => bool` |'
  id: totrans-658
  prefs: []
  type: TYPE_TB
  zh: '| 谓词（可选） | `TSource => bool` |'
- en: 'The following example demonstrates `First` and `Last`:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了 `First` 和 `Last`：
- en: '[PRE158]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'The following demonstrates `First` versus `FirstOrDefault`:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 下面演示了 `First` 与 `FirstOrDefault` 的区别：
- en: '[PRE159]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'To prevent an exception, `Single` requires exactly one matching element; `SingleOrDefault`
    requires one *or zero* matching elements:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免异常，`Single` 需要恰好一个匹配元素；`SingleOrDefault` 需要一个 *或零* 个匹配元素：
- en: '[PRE160]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '`Single` is the “fussiest” in this family of element operators. `FirstOrDefault`
    and `LastOrDefault` are the most tolerant.'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '`Single` 在这些元素操作符中是“最挑剔”的。`FirstOrDefault` 和 `LastOrDefault` 则最为宽容。'
- en: 'In EF Core, `Single` is often used to retrieve a row from a table by primary
    key:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 在 EF Core 中，`Single` 经常用于通过主键从表中检索行：
- en: '[PRE161]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: ElementAt
  id: totrans-668
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ElementAt
- en: '| Argument | Type |'
  id: totrans-669
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 类型 |'
- en: '| --- | --- |'
  id: totrans-670
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Source sequence | `IEnumerable<TSource>` |'
  id: totrans-671
  prefs: []
  type: TYPE_TB
  zh: '| 源序列 | `IEnumerable<TSource>` |'
- en: '| Index of element to return | `int` |'
  id: totrans-672
  prefs: []
  type: TYPE_TB
  zh: '| 要返回的元素的索引 | `int` |'
- en: '`ElementAt` picks the *n*th element from the sequence:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '`ElementAt` 从序列中选取第 *n* 个元素：'
- en: '[PRE162]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '`Enumerable.ElementAt` is written such that if the input sequence happens to
    implement `IList<T>`, it calls `IList<T>`’s indexer. Otherwise, it enumerates
    *n* times and then returns the next element. `ElementAt` is not supported in EF
    Core.'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enumerable.ElementAt` 的实现如此，如果输入序列恰好实现了 `IList<T>`，则调用 `IList<T>` 的索引器。否则，它枚举
    *n* 次然后返回下一个元素。在 EF Core 中不支持 `ElementAt`。'
- en: MinBy and MaxBy
  id: totrans-676
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MinBy 和 MaxBy
- en: '`MinBy` and `MaxBy` (introduced in .NET 6) return the element with the smallest
    or largest value, as determined by a `keySelector`:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '`MinBy` 和 `MaxBy`（在 .NET 6 中引入）返回具有最小或最大值的元素，由 `keySelector` 决定：'
- en: '[PRE163]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'In contrast, `Min` and `Max` (which we will cover in the following section)
    return the smallest or largest value itself:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`Min` 和 `Max`（我们将在下一节中介绍）返回的是最小或最大的值本身：
- en: '[PRE164]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'If two or more elements share a minimum/maximum value, `MinBy`/`MaxBy` returns
    the first:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个或更多元素具有最小/最大值，则 `MinBy`/`MaxBy` 返回第一个：
- en: '[PRE165]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: If the input sequence is empty, `MinBy` and `MaxBy` return null if the element
    type is nullable (or throw an exception if the element type is not nullable).
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入序列为空，则如果元素类型可空，`MinBy` 和 `MaxBy` 返回 null（或者如果元素类型不可空则抛出异常）。
- en: DefaultIfEmpty
  id: totrans-684
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DefaultIfEmpty
- en: '`DefaultIfEmpty` returns a sequence containing a single element whose value
    is `default(TSource)` if the input sequence has no elements; otherwise, it returns
    the input sequence unchanged. You use this in writing flat outer joins: see [“Outer
    joins with SelectMany”](#outer_joins_with_selectmany) and [“Flat outer joins”](#flat_outer_joins).'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefaultIfEmpty` 返回一个包含单个元素的序列，其值为 `default(TSource)`，如果输入序列没有元素；否则，返回不变的输入序列。在编写平面外连接时使用它：参见
    [“使用 SelectMany 进行外连接”](#outer_joins_with_selectmany) 和 [“平面外连接”](#flat_outer_joins)。'
- en: Aggregation Methods
  id: totrans-686
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合方法
- en: '`IEnumerable<TSource>`→`*scalar*`'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<TSource>`→`*scalar*`'
- en: '| Method | Description | SQL equivalents |'
  id: totrans-688
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 | 对应的 SQL |'
- en: '| --- | --- | --- |'
  id: totrans-689
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Count, LongCount` | Returns the number of elements in the input sequence,
    optionally satisfying a predicate | `COUNT (...)` |'
  id: totrans-690
  prefs: []
  type: TYPE_TB
  zh: '| `Count, LongCount` | 返回输入序列中元素的数目，可选地满足谓词条件 | `COUNT (...)` |'
- en: '| `Min, Max` | Returns the smallest or largest element in the sequence | `MIN
    (...), MAX (...)` |'
  id: totrans-691
  prefs: []
  type: TYPE_TB
  zh: '| `Min, Max` | 返回序列中的最小或最大元素 | `MIN (...)`, `MAX (...)` |'
- en: '| `Sum, Average` | Calculates a numeric sum or average over elements in the
    sequence | `SUM (...), AVG (...)` |'
  id: totrans-692
  prefs: []
  type: TYPE_TB
  zh: '| `Sum, Average` | 计算序列中元素的数字总和或平均值 | `SUM (...), AVG (...)` |'
- en: '| `Aggregate` | Performs a custom aggregation | Exception thrown |'
  id: totrans-693
  prefs: []
  type: TYPE_TB
  zh: '| `Aggregate` | 执行自定义聚合 | 异常抛出 |'
- en: Count and LongCount
  id: totrans-694
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计数和 LongCount
- en: '| Argument | Type |'
  id: totrans-695
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 类型 |'
- en: '| --- | --- |'
  id: totrans-696
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Source sequence | `IEnumerable<TSource>` |'
  id: totrans-697
  prefs: []
  type: TYPE_TB
  zh: '| 源序列 | `IEnumerable<TSource>` |'
- en: '| Predicate (optional) | `TSource => bool` |'
  id: totrans-698
  prefs: []
  type: TYPE_TB
  zh: '| 谓词（可选） | `TSource => bool` |'
- en: '`Count` simply enumerates over a sequence, returning the number of items:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '`Count` 简单地枚举序列，返回项目数：'
- en: '[PRE166]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: The internal implementation of `Enumerable.Count` tests the input sequence to
    see whether it happens to implement `ICollection<T>`. If it does, it simply calls
    `ICollection<T>.Count`; otherwise, it enumerates over every item, incrementing
    a counter.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enumerable.Count` 的内部实现测试输入序列是否实现了 `ICollection<T>`。如果是，它只需调用 `ICollection<T>.Count`；否则，它会枚举每个项，递增计数器。'
- en: 'You can optionally supply a predicate:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 可以选择性地提供谓词：
- en: '[PRE167]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '`LongCount` does the same job as `Count` but returns a 64-bit integer, allowing
    for sequences of greater than two billion elements.'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '`LongCount` 执行与 `Count` 相同的工作，但返回一个 64 位整数，允许超过 20 亿元素的序列。'
- en: Min and Max
  id: totrans-705
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小值和最大值
- en: '| Argument | Type |'
  id: totrans-706
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 类型 |'
- en: '| --- | --- |'
  id: totrans-707
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Source sequence | `IEnumerable<TSource>` |'
  id: totrans-708
  prefs: []
  type: TYPE_TB
  zh: '| 源序列 | `IEnumerable<TSource>` |'
- en: '| Result selector (optional) | `TSource => TResult` |'
  id: totrans-709
  prefs: []
  type: TYPE_TB
  zh: '| 结果选择器（可选） | `TSource => TResult` |'
- en: '`Min` and `Max` return the smallest or largest element from a sequence:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '`Min` 和 `Max` 返回序列中的最小或最大元素：'
- en: '[PRE168]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'If you include a `selector` expression, each element is first projected:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 如果包含 `selector` 表达式，每个元素首先被投影：
- en: '[PRE169]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'A `selector` expression is mandatory if the items themselves are not intrinsically
    comparable—in other words, if they do not implement `IComparable<T>`:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目本身不是本质上可比较的（即它们没有实现 `IComparable<T>`），则 `selector` 表达式是强制性的：
- en: '[PRE170]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'A `selector` expression determines not only how elements are compared, but
    also the final result. In the preceding example, the final result is a decimal
    value, not a purchase object. To get the cheapest purchase, you need a subquery:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '`selector` 表达式不仅决定了如何比较元素，还决定了最终结果。在上面的例子中，最终结果是一个十进制值，而不是购买对象。要获取最便宜的购买，需要使用子查询：'
- en: '[PRE171]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: In this case, you could also formulate the query without an aggregation by using
    an `OrderBy` followed by `FirstOrDefault`.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您还可以通过使用 `OrderBy` 后跟 `FirstOrDefault` 而不使用聚合来构建查询。
- en: Sum and Average
  id: totrans-719
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总和与平均值
- en: '| Argument | Type |'
  id: totrans-720
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 类型 |'
- en: '| --- | --- |'
  id: totrans-721
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Source sequence | `IEnumerable<TSource>` |'
  id: totrans-722
  prefs: []
  type: TYPE_TB
  zh: '| 源序列 | `IEnumerable<TSource>` |'
- en: '| Result selector (optional) | `TSource => TResult` |'
  id: totrans-723
  prefs: []
  type: TYPE_TB
  zh: '| 结果选择器（可选） | `TSource => TResult` |'
- en: '`Sum` and `Average` are aggregation operators that are used in a similar manner
    to `Min` and `Max`:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sum` 和 `Average` 是聚合运算符，类似于 `Min` 和 `Max` 的使用方式：'
- en: '[PRE172]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'The following returns the total length of each of the strings in the `names`
    array:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 以下返回 `names` 数组中每个字符串的总长度：
- en: '[PRE173]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '`Sum` and `Average` are fairly restrictive in their typing. Their definitions
    are hardwired to each of the numeric types (`int`, `long`, `float`, `double`,
    `decimal`, and their nullable versions). In contrast, `Min` and `Max` can operate
    directly on anything that implements `IComparable<T>`—such as a `string`, for
    instance.'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sum` 和 `Average` 在其类型上比较严格。它们的定义硬编码到每种数值类型（`int`、`long`、`float`、`double`、`decimal`
    及其可空版本）。相比之下，`Min` 和 `Max` 可以直接操作任何实现了 `IComparable<T>` 的东西，比如 `string`。'
- en: 'Further, `Average` always returns either `decimal`, `float`, or `double`, according
    to the following table:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Average` 总是根据以下表格返回 `decimal`、`float` 或 `double`：
- en: '| Selector type | Result type |'
  id: totrans-730
  prefs: []
  type: TYPE_TB
  zh: '| 选择器类型 | 结果类型 |'
- en: '| --- | --- |'
  id: totrans-731
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `decimal` | `decimal` |'
  id: totrans-732
  prefs: []
  type: TYPE_TB
  zh: '| `decimal` | `decimal` |'
- en: '| `float` | `float` |'
  id: totrans-733
  prefs: []
  type: TYPE_TB
  zh: '| `float` | `float` |'
- en: '| `int, long, double` | `double` |'
  id: totrans-734
  prefs: []
  type: TYPE_TB
  zh: '| `int, long, double` | `double` |'
- en: 'This means that the following does not compile (“cannot convert `double` to
    `int`”):'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着以下内容无法编译（“无法将 `double` 转换为 `int`”）：
- en: '[PRE174]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'But this will compile:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 但以下内容将会编译：
- en: '[PRE175]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '`Average` implicitly upscales the input values to prevent loss of precision.
    In this example, we averaged integers and got 3.5 without needing to resort to
    an input element cast:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '`Average` 隐式地将输入值升级，以防止精度丢失。在这个例子中，我们对整数取平均值，得到了 3.5，而无需将输入元素强制转换为浮点数：'
- en: '[PRE176]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'When querying a database, `Sum` and `Average` translate to the standard SQL
    aggregations. The following query returns customers whose average purchase was
    more than $500:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询数据库时，`Sum` 和 `Average` 转换为标准的 SQL 聚合。以下查询返回平均购买超过 500 美元的客户：
- en: '[PRE177]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: Aggregate
  id: totrans-743
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚合
- en: '`Aggregate` allows you to specify a custom accumulation algorithm for implementing
    unusual aggregations. `Aggregate` is not supported in EF Core and is somewhat
    specialized in its use cases. The following demonstrates how `Aggregate` can do
    the work of `Sum`:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: '`Aggregate` 允许您指定用于实现不寻常聚合的自定义累积算法。`Aggregate` 在 EF Core 中不受支持，并且在其使用案例中有些特殊化。以下演示了如何使用
    `Aggregate` 完成 `Sum` 的工作：'
- en: '[PRE178]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: The first argument to `Aggregate` is the *seed*, from which accumulation starts.
    The second argument is an expression to update the accumulated value, given a
    fresh element. You can optionally supply a third argument to project the final
    result value from the accumulated value.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: '`Aggregate` 的第一个参数是*种子*，从中开始累积。第二个参数是一个表达式，用于在给定新元素时更新累积值。您还可以选择提供第三个参数，以从累积值中投影出最终结果值。'
- en: Note
  id: totrans-747
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Most problems for which `Aggregate` has been designed can be solved as easily
    with a `foreach` loop—and with more familiar syntax. The advantage of using `Aggregate`
    is that with large or complex aggregations, you can automatically parallelize
    the operation with PLINQ (see [Chapter 22](ch22.html#parallel_programming-id00071)).
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 `Aggregate` 设计的问题都可以通过 `foreach` 循环轻松解决，并且具有更熟悉的语法。使用 `Aggregate` 的优势在于，对于大型或复杂的聚合操作，您可以通过
    PLINQ 自动并行化操作（见[第 22 章](ch22.html#parallel_programming-id00071)）。
- en: Unseeded aggregations
  id: totrans-749
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未种子化的聚合
- en: 'You can omit the seed value when calling `Aggregate`, in which case the first
    element becomes the *implicit* seed, and aggregation proceeds from the second
    element. Here’s the preceding example, *unseeded*:'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `Aggregate` 时可以省略种子值，在这种情况下，第一个元素成为*隐式*种子，并且聚合从第二个元素开始。这里是前面的例子，*未种子化*：
- en: '[PRE179]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'This gives the same result as before, but we’re actually doing a *different
    calculation*. Before, we were calculating 0 + 1 + 2 + 3; now we’re calculating
    1 + 2 + 3\. We can better illustrate the difference by multiplying instead of
    adding:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了与之前相同的结果，但实际上我们正在*进行不同的计算*。之前，我们计算的是 0 + 1 + 2 + 3；现在我们计算的是 1 + 2 + 3。我们可以通过乘法而不是加法更好地说明这种差异：
- en: '[PRE180]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: As you’ll see in [Chapter 22](ch22.html#parallel_programming-id00071), unseeded
    aggregations have the advantage of being parallelizable without requiring the
    use of special overloads. However, there are some traps with unseeded aggregations.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将在[第 22 章](ch22.html#parallel_programming-id00071)中看到的那样，未种子化的聚合具有可以并行化的优势，而不需要使用特殊重载。但是，未种子化的聚合存在一些陷阱。
- en: Traps with unseeded aggregations
  id: totrans-755
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未种子化的聚合陷阱
- en: 'The unseeded aggregation methods are intended for use with delegates that are
    *commutative* and *associative*. If used otherwise, the result is either *unintuitive*
    (with ordinary queries) or *nondeterministic* (in the case that you parallelize
    the query with PLINQ). For example, consider the following function:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 未种子化的聚合方法适用于使用*可交换*和*可结合*的委托。如果用于其他用途，则结果要么是*不直观*的（对于普通查询），要么是*非确定性*的（在您使用 PLINQ
    并行化查询的情况下）。例如，考虑以下函数：
- en: '[PRE181]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'This is neither commutative nor associative. (For example, 1 + 2 * 2 != 2 +
    1 * 1.) Let’s see what happens when we use it to sum the square of the numbers
    2, 3, and 4:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 这既不是可交换的也不是可结合的。（例如，1 + 2 * 2 != 2 + 1 * 1。）让我们看看当我们用它来计算2、3和4的平方数之和时会发生什么：
- en: '[PRE182]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: Instead of calculating
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是计算
- en: '[PRE183]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'it calculates:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 它计算：
- en: '[PRE184]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'We can fix this in a number of ways. First, we could include 0 as the first
    element:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过多种方式解决这个问题。首先，我们可以将 0 包含为第一个元素：
- en: '[PRE185]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'Not only is this inelegant, but it will still give incorrect results if parallelized—because
    PLINQ uses the function’s assumed associativity by selecting *multiple* elements
    as seeds. To illustrate, if we denote our aggregation function as follows:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅不优雅，而且如果并行化的话仍会给出不正确的结果——因为 PLINQ 使用函数的假定结合性通过选择*多个*元素作为种子。为了说明，如果我们将我们的聚合函数表示如下：
- en: '[PRE186]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'LINQ to Objects would calculate this:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 对象将计算此结果：
- en: '[PRE187]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'whereas PLINQ might do this:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 而 PLINQ 可能会执行：
- en: '[PRE188]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'with the following result:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 得到以下结果：
- en: '[PRE189]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: There are two good solutions. The first is to turn this into a seeded aggregation
    with 0 as the seed. The only complication is that with PLINQ, we’d need to use
    a special overload in order for the query not to execute sequentially (see [“Optimizing
    PLINQ”](ch22.html#optimizing_plinq)).
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个好的解决方案。第一个是将其转换为以 0 作为种子的种子聚合。唯一的复杂性在于，使用 PLINQ 时，我们需要使用一个特殊的重载，以使查询不按顺序执行（见
    [“优化 PLINQ”](ch22.html#optimizing_plinq)）。
- en: 'The second solution is to restructure the query such that the aggregation function
    is commutative and associative:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个解决方案是重新构造查询，使聚合函数成为可交换和可结合的：
- en: '[PRE190]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Note
  id: totrans-777
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Of course, in such simple scenarios you can (and should) use the `Sum` operator
    instead of `Aggregate`:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这种简单场景下，您可以（并且应该）使用`Sum`操作符，而不是`Aggregate`：
- en: '[PRE191]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'You can actually go quite far just with `Sum` and `Average`. For instance,
    you can use `Average` to calculate a root-mean-square:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 您实际上可以通过`Sum`和`Average`做得相当远。例如，您可以使用`Average`计算均方根：
- en: '[PRE192]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'You can even calculate standard deviation:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以计算标准差：
- en: '[PRE193]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: Both are safe, efficient, and fully parallelizable. In [Chapter 22](ch22.html#parallel_programming-id00071),
    we give a practical example of a custom aggregation that can’t be reduced to `Sum`
    or `Average`.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都是安全的、高效的，并且完全可并行化。在[第22章](ch22.html#parallel_programming-id00071)，我们给出了一个无法简化为`Sum`或`Average`的自定义聚合的实际示例。
- en: Quantifiers
  id: totrans-785
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 量词
- en: '`IEnumerable<TSource>`→`*bool*`'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<TSource>`→`*bool*`'
- en: '| Method | Description | SQL equivalents |'
  id: totrans-787
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 | SQL等效项 |'
- en: '| --- | --- | --- |'
  id: totrans-788
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Contains` | Returns `true` if the input sequence contains the given element
    | `WHERE` ... `IN (`...`)` |'
  id: totrans-789
  prefs: []
  type: TYPE_TB
  zh: '| `Contains` | 如果输入序列包含给定元素，则返回`true` | `WHERE` ... `IN (`...`)` |'
- en: '| `Any` | Returns `true` if any elements satisfy the given predicate | `WHERE`
    ... `IN (`...`)` |'
  id: totrans-790
  prefs: []
  type: TYPE_TB
  zh: '| `Any` | 如果任何元素满足给定谓词，则返回`true` | `WHERE` ... `IN (`...`)` |'
- en: '| `All` | Returns `true` if all elements satisfy the given predicate | `WHERE
    (`...`)` |'
  id: totrans-791
  prefs: []
  type: TYPE_TB
  zh: '| `All` | 如果所有元素都满足给定谓词，则返回`true` | `WHERE (`...`)` |'
- en: '| `SequenceEqual` | Returns `true` if the second sequence has identical elements
    to the input sequence |   |'
  id: totrans-792
  prefs: []
  type: TYPE_TB
  zh: '| `SequenceEqual` | 如果第二个序列与输入序列具有相同的元素，则返回`true` |   |'
- en: Contains and Any
  id: totrans-793
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包含和Any
- en: The `Contains` method accepts an argument of type `TSource`; `Any` accepts an
    optional *predicate*.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: '`Contains`方法接受一个类型为`TSource`的参数；`Any`接受一个可选的*谓词*。'
- en: '`Contains` returns `true` if the given element is present:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: '`Contains` 如果给定元素存在，则返回`true`：'
- en: '[PRE194]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '`Any` returns `true` if the given expression is true for at least one element.
    We can rewrite the preceding query with `Any` as follows:'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: '`Any` 如果至少有一个元素满足给定表达式，则返回`true`。我们可以用`Any`重写前面的查询如下：'
- en: '[PRE195]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '`Any` can do everything that `Contains` can do, and more:'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '`Any` 可以执行`Contains`的所有操作，甚至更多：'
- en: '[PRE196]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'Calling `Any` without a predicate returns `true` if the sequence has one or
    more elements. Here’s another way to write the preceding query:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 调用不带谓词的`Any`，如果序列有一个或多个元素，则返回`true`。以下是重写前面查询的另一种方式：
- en: '[PRE197]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '`Any` is particularly useful in subqueries and is used often when querying
    databases; for example:'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: '`Any` 在子查询中特别有用，并且在查询数据库时经常使用；例如：'
- en: '[PRE198]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: All and SequenceEqual
  id: totrans-805
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: All 和 SequenceEqual
- en: '`All` returns `true` if all elements satisfy a predicate. The following returns
    customers whose purchases are less than $100:'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '`All` 如果所有元素都满足谓词，则返回`true`。以下查询返回购买金额少于$100的客户：'
- en: '[PRE199]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '`SequenceEqual` compares two sequences. To return `true`, each sequence must
    have identical elements, in the identical order. You can optionally provide an
    equality comparer; the default is `EqualityComparer<T>.Default`.'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '`SequenceEqual` 比较两个序列。要返回`true`，每个序列必须具有相同的元素，且顺序相同。您可以选择性地提供相等比较器；默认为`EqualityComparer<T>.Default`。'
- en: Generation Methods
  id: totrans-809
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成方法
- en: '`void`→`IEnumerable<TResult>`'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '`void`→`IEnumerable<TResult>`'
- en: '| Method | Description |'
  id: totrans-811
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-812
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Empty` | Creates an empty sequence |'
  id: totrans-813
  prefs: []
  type: TYPE_TB
  zh: '| `Empty` | 创建一个空序列 |'
- en: '| `Repeat` | Creates a sequence of repeating elements |'
  id: totrans-814
  prefs: []
  type: TYPE_TB
  zh: '| `Repeat` | 创建一个重复元素的序列 |'
- en: '| `Range` | Creates a sequence of integers |'
  id: totrans-815
  prefs: []
  type: TYPE_TB
  zh: '| `Range` | 创建一个整数序列 |'
- en: '`Empty`, `Repeat`, and `Range` are static (nonextension) methods that manufacture
    simple local sequences.'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: '`Empty`、`Repeat`和`Range`是静态（非扩展）方法，用于制造简单的本地序列。'
- en: Empty
  id: totrans-817
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Empty
- en: '`Empty` manufactures an empty sequence and requires just a type argument:'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: '`Empty` 制造一个空序列，并且只需一个类型参数：'
- en: '[PRE200]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'In conjunction with the `??` operator, `Empty` does the reverse of `DefaultIfEmpty`.
    For example, suppose that we have a jagged array of integers and we want to get
    all the integers into a single flat list. The following `SelectMany` query fails
    if any of the inner arrays is null:'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 与`??`操作符结合使用，`Empty`执行`DefaultIfEmpty`的反向操作。例如，假设我们有一个整数的嵌套数组，并且我们想将所有整数放入单个平面列表中。如果任何内部数组为null，则以下`SelectMany`查询将失败：
- en: '[PRE201]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '`Empty` in conjunction with `??` fixes the problem:'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '`Empty` 与`??`结合修复问题：'
- en: '[PRE202]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: Range and Repeat
  id: totrans-824
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范围和重复
- en: '`Range` accepts a starting index and count (both integers):'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: '`Range` 接受起始索引和计数（都是整数）：'
- en: '[PRE203]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '`Repeat` accepts an element to repeat, and the number of repetitions:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '`Repeat` 接受一个要重复的元素和重复的次数：'
- en: '[PRE204]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
