- en: Chapter 14\. Attributes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章 属性
- en: In .NET, you can annotate components, types, and their members with *attributes*.
    An attribute’s purpose is to control or modify the behavior of a framework, a
    tool, the compiler, or the CLR. For example, in [Chapter 1](ch01.xhtml#ch_introducing_csharp),
    I showed a class annotated with the `[TestClass]` attribute. This told a unit
    testing framework that the annotated class contains some tests to be run as part
    of a test suite.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，您可以使用*属性*为组件、类型及其成员添加注解。属性的目的是控制或修改框架、工具、编译器或CLR的行为。例如，在 [第1章](ch01.xhtml#ch_introducing_csharp)
    中，我展示了一个使用 `[TestClass]` 属性进行注释的类。这告诉单元测试框架，被注释的类包含一些作为测试套件一部分运行的测试。
- en: Attributes are passive containers of information that do nothing on their own.
    To draw an analogy with the physical world, if you print out a shipping label
    containing an address and tracking information and attach it to a package, that
    label will not in itself cause the package to make its way to a destination. Such
    a label is useful only once the package is in the hands of a shipping company.
    When the company picks up your parcel, it’ll expect to find the label and will
    use it to work out how to route your package. So the label is important, but ultimately,
    its only job is to provide information that some system requires. .NET attributes
    work the same way—they have an effect only if something goes looking for them.
    Some attributes are handled by the CLR or the compiler, but these are in the minority.
    The majority of attributes are consumed by frameworks, libraries, tools (such
    as a unit test runner), or your own code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是信息的被动容器，在自身不执行任何操作。可以通过与物理世界的类比来理解，如果您打印包含地址和跟踪信息的运输标签，并将其附加到包裹上，该标签本身不会导致包裹自行送达目的地。这样的标签只有在包裹交到运输公司手中时才有用。当公司取走您的包裹时，它会期望找到标签，并使用它来确定如何路由您的包裹。因此，标签很重要，但最终它的唯一工作是提供某些系统所需的信息。.NET
    属性的工作方式与此类似——它们只有在某些东西正在寻找它们时才会发挥作用。某些属性由CLR或编译器处理，但这些只是少数。大多数属性被框架、库、工具（如单元测试运行器）或您自己的代码消耗。
- en: Applying Attributes
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用属性
- en: To avoid having to introduce an extra set of concepts into the type system,
    .NET models attributes as instances of .NET types. To be used as an attribute,
    a type must derive from the `System.Attribute` class, but it can otherwise be
    entirely ordinary. To apply an attribute, you put the type’s name in square brackets,
    and this usually goes directly before the attribute’s target. (Since C# mostly
    ignores whitespace, attributes don’t have to be on a separate line, but that is
    the convention when the target is a type or a member.) [Example 14-1](#attributes_in_a_unit_test_class)
    shows some attributes from Microsoft’s test framework. I’ve applied one to the
    class to indicate that this contains tests I’d like to run, and I’ve also applied
    attributes to individual methods, telling the test framework which ones represent
    tests and which contain initialization code to be run before each test.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在类型系统中引入额外的概念，.NET将属性建模为.NET类型的实例。要作为属性使用，类型必须派生自 `System.Attribute` 类，但除此之外，它可以是完全普通的。要应用属性，您将类型名称放在方括号中，这通常直接放在属性的目标之前。（由于C#大多数情况下忽略空白字符，当目标是类型或成员时，属性不必位于单独的行上，但这是约定俗成的。）[示例 14-1](#attributes_in_a_unit_test_class)
    展示了来自微软测试框架的一些属性。我已经将一个应用到类上，以指示这个类包含我希望运行的测试，并且还将属性应用到单独的方法上，告知测试框架哪些方法代表测试，哪些包含要在每次测试前运行的初始化代码。
- en: Example 14-1\. Attributes in a unit test class
  id: totrans-5
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 14-1 单元测试类中的属性
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you look at the documentation for most attributes, you’ll find that their
    real name ends with `Attribute`. If there’s no class with the name you specify
    in the brackets, the C# compiler tries appending `Attribute`, so the `[TestClass]`
    attribute in [Example 14-1](#attributes_in_a_unit_test_class) refers to the `TestClassAttribute`
    class. If you really want to, you can spell the class name out in full—for example,
    `[TestClassAttribute]`—but it’s more common to use the shorter version.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看大多数属性的文档，您会发现它们的实际名称以 `Attribute` 结尾。如果在括号中指定的名称没有对应的类，C# 编译器会尝试添加 `Attribute`，所以
    [示例 14-1](#attributes_in_a_unit_test_class) 中的 `[TestClass]` 属性指的是 `TestClassAttribute`
    类。如果您确实希望如此，可以完整拼写类名，例如 `[TestClassAttribute]`，但更常见的是使用缩写版本。
- en: If you want to apply multiple attributes, you have two options. You can either
    provide multiple sets of brackets or put multiple attributes inside a single pair
    of brackets, separated by commas.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想应用多个属性，有两种选择。你可以提供多组括号，或者将多个属性放在单一对括号内，用逗号分隔。
- en: Some attribute types can take constructor arguments. For example, Microsoft’s
    test framework includes a `TestCategoryAttribute`. When running tests, you can
    choose to execute only those in a certain category. This attribute requires you
    to pass the category name as a constructor argument, because there would be no
    point in applying this attribute without specifying the name. As [Example 14-2](#attribute_with_constructor_argument)
    shows, the syntax for specifying an attribute’s constructor arguments is unsurprising.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一些属性类型可以接受构造函数参数。例如，微软的测试框架包含一个`TestCategoryAttribute`。在运行测试时，您可以选择仅执行某个类别中的测试。此属性要求您将类别名称作为构造函数参数传递，因为如果不指定名称，则应用此属性没有意义。正如[Example 14-2](#attribute_with_constructor_argument)所示，指定属性的构造函数参数的语法并不令人意外。
- en: Example 14-2\. Attribute with constructor argument
  id: totrans-10
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 14-2\. 带构造函数参数的属性
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can also specify property or field values. Some attributes have features
    that can be controlled only through properties or fields, and not constructor
    arguments. (If an attribute has lots of optional settings, it’s usually easier
    to present these as properties or fields, instead of defining a constructor overload
    for every conceivable combination of settings.) The syntax for this is to write
    one or more `*PropertyOrFieldName*=*Value*` entries after the constructor arguments
    (or instead of them, if there are no constructor arguments). [Example 14-3](#optional_attribute_settings_with_props)
    shows another attribute used in unit testing, `ExpectedExceptionAttribute`, which
    allows you to specify that when your test runs, you expect it to throw a particular
    exception. The exception type is mandatory, so we pass that as a constructor argument,
    but this attribute also allows you to state whether the test runner should accept
    exceptions of a type derived from the one specified. (By default, it will accept
    only an exact match.) This is controlled with the `AllowDerivedTypes` property.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以指定属性或字段的值。一些属性具有只能通过属性或字段控制的特性，而不是构造函数参数。（如果一个属性有很多可选设置，通常更容易将这些设置呈现为属性或字段，而不是为每种可能的设置组合定义构造函数重载。）其语法是在构造函数参数之后写一个或多个`*PropertyOrFieldName*=*Value*`条目（如果没有构造函数参数，则是代替它们）。[Example 14-3](#optional_attribute_settings_with_props)展示了另一个在单元测试中使用的属性，`ExpectedExceptionAttribute`，它允许你指定在测试运行时期望它抛出特定异常。异常类型是必需的，因此我们将其作为构造函数参数传递，但这个属性还允许你指定测试运行器是否接受从指定类型派生的异常。
    （默认情况下，它只接受完全匹配。）这由`AllowDerivedTypes`属性控制。
- en: Example 14-3\. Specifying optional attribute settings with properties
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 14-3\. 使用属性指定可选的属性设置
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Applying an attribute will not cause it to be constructed. All you are doing
    when you apply an attribute is providing instructions on how the attribute should
    be created and initialized if something should ask to see it. (There is a common
    misconception that method attributes are instantiated when the method runs. Not
    so.) When the compiler builds the metadata for an assembly, it includes information
    about which attributes have been applied to which items, including a list of constructor
    arguments and property values, and the CLR will dig that information out and use
    it only if something asks for it. For example, when you tell Visual Studio to
    run your unit tests, it will load your test assembly, and then for each public
    type, it asks the CLR for any test-related attributes. That’s the point at which
    the attributes get constructed. If you were simply to load the assembly by, say,
    adding a reference to it from another project and then using some of the types
    it contains, the attributes would never come into existence—they would remain
    as nothing more than a set of building instructions frozen into your assembly’s
    metadata.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 应用属性并不会导致它们被实例化。当你应用一个属性时，你所做的只是提供关于如何创建和初始化该属性的指令，如果有需要的话。（有一种常见的误解认为方法属性在方法运行时会被实例化，其实不然。）当编译器为程序集构建元数据时，它会包含关于已应用到哪些项上的属性的信息，包括构造函数参数和属性值的列表，CLR只有在有需要的时候才会提取出来使用。例如，当你要求Visual
    Studio运行你的单元测试时，它会加载你的测试程序集，然后对每个公共类型，它会向CLR查询任何与测试相关的属性。这就是属性被构造的时机。如果你只是简单地加载程序集，比如从另一个项目添加引用然后使用它包含的一些类型，属性就不会存在——它们只会保留在元数据中，作为一组冻结在程序集元数据中的构建指令。
- en: Attribute Targets
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性目标
- en: Attributes can be applied to numerous different kinds of targets. You can put
    attributes on any of the features of the type system represented in the reflection
    API that I showed in [Chapter 13](ch13.xhtml#ch_reflection). Specifically, you
    can apply attributes to assemblies, modules, types, methods, method parameters,
    constructors, fields, properties, events, and generic type parameters. In addition,
    you can supply attributes that target a method’s return value.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 属性可以应用于许多不同类型的目标。你可以在反射API中展示的类型系统特性的任何地方放置属性，就像我在[第13章](ch13.xhtml#ch_reflection)中展示的那样。具体来说，你可以将属性应用于程序集、模块、类型、方法、方法参数、构造函数、字段、属性、事件和泛型类型参数。此外，你还可以提供目标为方法返回值的属性。
- en: For most of these, you denote the target simply by putting the attribute in
    front of it. But that’s not an option for assemblies or modules, because there
    is no single feature that represents those in your source code—everything in your
    project goes into the assembly it produces, and modules are likewise an aggregate
    (typically constituting the whole assembly, as I described in [Chapter 12](ch12.xhtml#ch_assemblies)).
    So for these, we have to state the target explicitly at the start of the attribute.
    You will often see assembly-level attributes like the one shown in [Example 14-4](#assembly-level_attributes)
    in a *GlobalSuppressions.cs* file. Visual Studio sometimes makes suggestions for
    modifying your code, and if you choose to suppress these, it can do so with assembly-level
    attributes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数情况，你只需在目标前面放置属性即可标识目标。但对于程序集或模块来说不是这样，因为在你的源代码中没有单个特性代表它们——你项目中的所有内容都会进入它生成的程序集中，并且模块同样是一个集合体（通常构成整个程序集，就像我在[第12章](ch12.xhtml#ch_assemblies)中描述的那样）。因此，对于这些情况，我们必须在属性开头明确说明目标。你经常会在像*GlobalSuppressions.cs*文件中看到类似[示例14-4](#assembly-level_attributes)所示的程序集级别属性。Visual
    Studio有时会建议修改你的代码，如果你选择抑制这些警告，它就会使用程序集级别的属性来实现。
- en: Example 14-4\. Assembly-level attributes
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例14-4. 程序集级别属性
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can put assembly-level attributes in any file. The sole restriction is that
    they must appear before any namespace or type definitions. The only things that
    should come before assembly-level attributes are whichever `using` directives
    you need, comments, and whitespace (all of which are optional).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何文件中放置程序集级别的属性。唯一的限制是它们必须出现在任何命名空间或类型定义之前。程序集级别属性之前应该出现的只有你需要的`using`指令、注释和空白（这些都是可选的）。
- en: Module-level attributes follow the same pattern, although they are much less
    common, not least because multimodule assemblies are pretty rare and are not supported
    in the latest versions of .NET—they only work on .NET Framework. [Example 14-5](#module-level_attribute)
    shows how to configure the debuggability of a particular module, should you want
    one module in a multimodule assembly to be easily debuggable but the rest to be
    JIT-compiled with full optimizations. (This is a contrived scenario so that I
    can show the syntax. In practice, you’re unlikely ever to want to do this.) I’ll
    talk about the `DebuggableAttribute` later, in [“JIT compilation”](#jit_compilation).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 模块级别的属性遵循相同的模式，尽管它们非常少见，主要是因为多模块程序集非常罕见，并且在最新版本的.NET中不受支持——它们仅适用于.NET Framework。[示例 14-5](#模块级别属性)
    展示了如何配置特定模块的调试性，如果您希望多模块程序集中的一个模块易于调试，但其余模块带有完全优化的JIT编译，则可以使用此功能。（这是一个假设的场景，我只是为了展示语法。实际上，您不太可能需要这样做。）我稍后会讨论`DebuggableAttribute`，在[“JIT编译”](#JIT编译)中。
- en: Example 14-5\. Module-level attribute
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 14-5\. 模块级别属性
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Another kind of target that needs qualification is a compiler-generated field.
    You get these with properties in which you do not supply code for the getter or
    setter, and also in `event` members without explicit `add` and `remove` implementations.
    The attributes in [Example 14-6](#attributes_for_generated_field) apply to the
    fields that hold the property’s value and the delegate for the event; without
    the `field:` qualifiers, attributes in those positions would apply to the property
    or event itself.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种需要资格证书的目标是编译器生成的字段。当您在不为getter或setter提供代码的属性中使用时，以及在没有显式的`add`和`remove`实现的`event`成员中使用时，您会得到这些字段。[示例 14-6](#为生成字段的属性)
    中的属性应用于保存属性值的字段和事件委托；如果没有`field:`限定符，这些位置的属性将适用于属性或事件本身。
- en: Example 14-6\. Attribute for compiler-generated property and event fields
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 14-6\. 编译器生成的属性和事件字段的属性
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Methods’ return values can be annotated, and this also requires qualification,
    because return value attributes go in front of the method, the same place as attributes
    that apply to the method itself. (Attributes for parameters do not need qualification,
    because these appear inside the parentheses with the arguments.) [Example 14-7](#method_and_return_value_attributes)
    shows a method with attributes applied to both the method and the return type.
    (The attributes in this example are part of the interop services that enable .NET
    code to call external code, such as OS APIs. This example imports a function from
    a Win32 DLL, enabling you to use it from C#. There are several different representations
    for Boolean values in unmanaged code, so I’ve annotated the return type here with
    a `MarshalAsAttribute` to say which particular one the CLR should expect.)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的返回值可以进行注释，这也需要资格证书，因为返回值属性放在方法前面，与适用于方法本身的属性位于同一位置。（参数的属性不需要资格证书，因为这些属性与参数一起出现在括号内。）[示例 14-7](#方法和返回值属性)
    展示了一个同时应用于方法和返回类型的属性的方法。（本示例中的属性是支持互操作服务的一部分，这些服务使.NET代码能够调用外部代码，例如操作系统API。此示例导入了来自Win32
    DLL的函数，使您能够从C#中使用它。非托管代码中存在几种不同的布尔值表示形式，因此我在此处用`MarshalAsAttribute`对返回类型进行了注释，以说明CLR应该期望哪个特定形式。）
- en: Example 14-7\. Method and return value attributes
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 14-7\. 方法和返回值属性
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What about cases where we don’t write the method declaration explicitly? As
    you saw in [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events), the lambda syntax
    lets us write an expression whose value is a delegate. The compiler generates
    a normal method to hold the code (typically in a hidden class), and we might want
    to pass that method to a framework that uses attributes to control its functionality,
    such as the ASP.NET Core web framework. [Example 14-8](#lambda_attributes) shows
    how we can specify these attributes when using a lambda.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 那么对于我们不显式编写方法声明的情况呢？正如您在[第9章](ch09.xhtml#ch_delegates_lambdas_events)中看到的那样，Lambda语法允许我们编写一个值为委托的表达式。编译器会生成一个正常的方法来保存代码（通常是在一个隐藏的类中），我们可能希望将该方法传递给使用属性来控制其功能的框架，例如ASP.NET
    Core Web框架。[示例 14-8](#lambda属性) 展示了在使用Lambda时如何指定这些属性。
- en: Example 14-8\. Lambda with attributes
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 14-8\. 带属性的Lambda
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `MapGet` method here tells the ASP.NET Core framework how our application
    should behave when it receives `GET` requests on URLs matching a particular pattern.
    The first argument specifies the pattern, and the second is a delegate that defines
    the behavior. I’ve used the lambda syntax here, and I’ve applied a couple of attributes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`MapGet` 方法告诉 ASP.NET Core 框架应该在收到与特定模式匹配的 URL 的 `GET` 请求时如何行为。第一个参数指定模式，第二个是定义行为的委托。我在这里使用了
    lambda 语法，并应用了一些属性。'
- en: The first attribute is `[Authorize]`. This appears before the parameter list,
    so its target is the whole method. (You can also use a `return:` attribute in
    this position.) This causes ASP.NET Core to block unauthenticated requests that
    match this URL pattern. The `[FromRoute]` attribute is inside the parameter list’s
    parentheses, so it applies to the `id` parameter, and it tells ASP.NET Core that
    we want that particular parameter’s value to be taken from the expression of the
    same name in the URL pattern. So if a request came in for *https://myserver/items/42*,
    ASP.NET Core would first check that the request meets the application’s configured
    requirements for authentication and authorization, and if so, it would then invoke
    my lambda passing `42` as the `id` argument.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个属性是 `[Authorize]`。它出现在参数列表之前，因此其目标是整个方法。（您还可以在此位置使用 `return:` 属性。）这会导致 ASP.NET
    Core 阻止未经身份验证的请求匹配此 URL 模式。`[FromRoute]` 属性位于参数列表的括号内，因此它适用于 `id` 参数，并告诉 ASP.NET
    Core 我们希望从 URL 模式中同名表达式获取该特定参数的值。因此，如果请求 *https://myserver/items/42* 进来，ASP.NET
    Core 首先会检查请求是否符合应用程序配置的身份验证和授权要求，如果符合，然后会调用我的 lambda，并将 `42` 作为 `id` 参数传递。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '[Example 9-22](ch09.xhtml#lambda_variations) in [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events)
    showed that you can omit details in certain cases. The parentheses around the
    parameter list are normally optional for 1-argument lambdas. However, the parentheses
    *must* be present if you apply attributes to a lambda. To see why, imagine [Example 14-8](#lambda_attributes)
    without parentheses around the parameter list: it would be unclear whether the
    attributes were meant to apply to the method or the parameter.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[例子 9-22](ch09.xhtml#lambda_variations) 在 [第 9 章](ch09.xhtml#ch_delegates_lambdas_events)
    中展示了在某些情况下可以省略细节。参数列表周围的括号通常对于单参数 lambda 是可选的。但是，如果您要将属性应用于 lambda，则括号 *必须* 存在。要看清楚原因，请想象如果
    [例子 14-8](#lambda_attributes) 在参数列表周围没有括号：那么不清楚属性是应用于方法还是参数。'
- en: Compiler-Handled Attributes
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译器处理的属性
- en: The C# compiler recognizes certain attribute types and handles them in special
    ways. For example, assembly names and versions are set via attributes and also
    some related information about your assembly. As [Chapter 12](ch12.xhtml#ch_assemblies)
    described, in modern .NET projects, the build process generates a hidden source
    file containing these for you. If you’re curious, it usually ends up in the *obj\Debug*
    or *obj\Release* folder of your project, and it will be named something like *YourProject.AssemblyInfo.cs*.
    [Example 14-9](#auto_generated_assembly_info) shows a typical example.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: C# 编译器识别特定的属性类型，并以特殊方式处理它们。例如，程序集的名称和版本是通过属性设置的，还有一些关于您的程序集的相关信息。正如[第 12 章](ch12.xhtml#ch_assemblies)所述，在现代
    .NET 项目中，构建过程会为您生成一个隐藏的源文件，其中包含这些信息。如果您感兴趣，它通常会出现在项目的 *obj\Debug* 或 *obj\Release*
    文件夹中，并且名称通常类似于 *YourProject.AssemblyInfo.cs*。[例子 14-9](#auto_generated_assembly_info)
    展示了一个典型的示例。
- en: Example 14-9\. A typical generated file with assembly-level attributes
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例 14-9\. 具有程序集级属性的典型生成文件
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Old versions of the .NET Framework SDK did not generate this file at build time,
    so if you work on older projects, you will often find these attributes in a file
    called *AssemblyInfo.cs*. (By default Visual Studio hid this inside the project’s
    Properties node in Solution Explorer, but it was still just an ordinary source
    file.) The advantage of the file generation used in modern projects is that names
    are less likely to drift out of sync. For example, by default the assembly Product
    and Title will be the same as the project filename. If you rename the project
    file, the generated *YourRenamedProject.AssemblyInfo.cs* will change to match
    (unless you added `<Product>` and `<AssemblyTitle>` properties to your project
    file, in which case it will use those), whereas with the old *AssemblyInfo.cs*
    approach you could accidentally end up with mismatched names. Similarly, if you
    build a NuGet package from your project, certain properties end up in both the
    NuGet package and the compiled assembly. When these are all generated from information
    in the project file, it’s easier to keep things consistent.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版本的.NET Framework SDK在构建时未生成此文件，因此如果您处理旧项目，您经常会在名为*AssemblyInfo.cs*的文件中找到这些属性。（默认情况下，Visual
    Studio将其隐藏在解决方案资源管理器中项目的属性节点中，但它仍然只是一个普通的源文件。）现代项目中使用的文件生成优势在于，名称不太可能不同步。例如，默认情况下，程序集产品和标题将与项目文件名相同。如果重新命名项目文件，则生成的*YourRenamedProject.AssemblyInfo.cs*将相应更改（除非您向项目文件添加了`<Product>`和`<AssemblyTitle>`属性，在这种情况下它将使用这些属性），而旧的*AssemblyInfo.cs*方法则可能会意外导致名称不匹配。同样，如果从项目构建NuGet包，某些属性最终会出现在NuGet包和编译的程序集中。当这些都是从项目文件中的信息生成时，更容易保持一致性。
- en: Even though you only control these attributes indirectly, it’s useful to understand
    them since they affect the compiler output.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您只间接控制这些属性，理解它们也很有用，因为它们会影响编译器输出。
- en: Names and versions
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 名称和版本
- en: As you saw in [Chapter 12](ch12.xhtml#ch_assemblies), assemblies have a compound
    name. The simple name, which is typically the same as the filename but without
    the *.exe* or *.dll* extension, is configured as part of the project settings.
    The name also includes a version number, and this is controlled with an attribute,
    as [Example 14-10](#version_attributes) shows.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在[第12章](ch12.xhtml#ch_assemblies)看到的，程序集具有复合名称。简单名称通常与文件名相同，但不包括*.exe*或*.dll*扩展名，作为项目设置的一部分进行配置。名称还包括版本号，并且通过属性控制，如[示例14-10](#version_attributes)所示。
- en: Example 14-10\. Version attributes
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 14-10\. 版本属性
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you may recall from [Chapter 12](ch12.xhtml#ch_assemblies), the first of
    these sets the version part of the assembly’s name. The second has nothing to
    do with .NET—the compiler uses this to generate a Win32-style version resource.
    This is the version number end users will see if they select your assembly in
    Windows Explorer and open the Properties window.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能从[第12章](ch12.xhtml#ch_assemblies)回忆起的，第一个集合设置了程序集名称的版本部分。第二个与.NET无关——编译器使用它来生成Win32风格的版本资源。这是最终用户在Windows资源管理器中选择您的程序集并打开属性窗口时看到的版本号。
- en: The culture is also part of the assembly name. This will often be set automatically
    if you’re using the satellite resource assembly mechanisms described in [Chapter 12](ch12.xhtml#ch_assemblies).
    You can set it explicitly with the `AssemblyCulture` attribute, but for nonresource
    assemblies, the culture should usually not be set. (The only culture-related assembly-level
    attribute you will normally specify explicitly is the `Neu⁠tral⁠Res⁠our⁠ces⁠Lan⁠gua⁠ge​Att⁠rib⁠ute`,
    which I showed in [Chapter 12](ch12.xhtml#ch_assemblies).)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 区域性也是程序集名称的一部分。如果您正在使用[第12章](ch12.xhtml#ch_assemblies)描述的卫星资源程序集机制，通常会自动设置这一点。您可以使用`AssemblyCulture`属性显式设置它，但对于非资源程序集，通常不应设置区域性。（您通常会显式指定的唯一与文化相关的程序集级属性是我在[第12章](ch12.xhtml#ch_assemblies)展示的`NeutralResourcesLanguageAttribute`。）
- en: 'Strongly named assemblies have an additional component in their name: the public
    key token. The easiest way to set up a strong name in Visual Studio is with the
    “Strong naming” section of your project’s properties page (which is inside the
    Build section). If you’re using VS Code or some other editor, you can just add
    two properties to your *.csproj* file: `SignAssembly` set to `True`, and `AssemblyOriginatorKeyFile`
    with the path to your key file. However, you can also manage strong naming from
    the source code, because the compiler recognizes some special attributes for this.
    `AssemblyKeyFileAttribute` takes the name of a file that contains a key. Alternatively,
    you can install a key in the computer’s key store (which is part of the Windows
    cryptography system). If you want to do that, you can use the `AssemblyKeyNameAttribute`
    instead. The presence of either of these attributes causes the compiler to embed
    the public key in the assembly and include a hash of that key as the public key
    token of the strong name. If the key file includes the private key, the compiler
    will sign your assembly too. If it does not, it will fail to compile, unless you
    also enable either delay signing or public signing. You can enable delay signing
    by applying the `Ass⁠emb⁠ly​Del⁠ayS⁠ign⁠Att⁠rib⁠ute` with a constructor argument
    of `true`. Alternatively, you can add either `<DelaySign>true</DelaySign>` or
    `<PublicSign>true</PublicSign>` to your *.csproj* file.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 强名称程序集在其名称中有一个额外的组件：公钥标记。在 Visual Studio 中设置强名称的最简单方法是使用项目属性页中“强名称”部分（位于“生成”部分内）。如果您正在使用
    VS Code 或其他编辑器，您可以简单地在您的 *.csproj* 文件中添加两个属性：`SignAssembly` 设置为 `True`，并且 `AssemblyOriginatorKeyFile`
    设置为您密钥文件的路径。然而，您也可以通过源代码管理强命名，因为编译器识别一些特殊的属性用于此目的。`AssemblyKeyFileAttribute` 接受包含密钥的文件名。或者，您可以将密钥安装到计算机的密钥存储区（这是
    Windows 加密系统的一部分）。如果您想这样做，您可以使用 `AssemblyKeyNameAttribute`。这两个属性中的任何一个都会导致编译器将公钥嵌入程序集并将该密钥的哈希值作为强名称的公钥标记包含在其中。如果密钥文件包含私钥，编译器还会为您的程序集签名。如果不包含私钥，则编译器将无法编译，除非您还启用了延迟签名或公共签名。您可以通过应用带有参数`true`的`AssemblyDelaySignAttribute`来启用延迟签名。或者，您可以将`<DelaySign>true</DelaySign>`或`<PublicSign>true</PublicSign>`添加到您的
    *.csproj* 文件中。
- en: Warning
  id: totrans-51
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Although the key-related attributes trigger special handling from the compiler,
    it still embeds them in the metadata as normal attributes. So, if you use the
    `AssemblyKeyFileAttribute`, the path to your key file will be visible in the final
    compiled output. This is not necessarily a problem, but you might prefer not to
    advertise these sorts of details, so it may be better to use the project-level
    configuration for strong names than the attribute-based approach.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管与密钥相关的属性触发编译器的特殊处理，但它们仍然像普通属性一样嵌入到元数据中。因此，如果您使用`AssemblyKeyFileAttribute`，则您密钥文件的路径将显示在最终编译输出中。这并不一定是问题，但您可能更喜欢不公开这些细节，因此使用项目级别的强名称配置可能比基于属性的方法更好。
- en: Description and related resources
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述及相关资源
- en: The version resource produced by the `AssemblyFileVersion` attribute is not
    the only information that the C# compiler can embed in Win32-style resources.
    There are several other attributes providing copyright information and other descriptive
    text. [Example 14-11](#typical_assembly_description_attributes) shows a typical
    selection.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由`AssemblyFileVersion`属性生成的版本资源并非 C# 编译器可以嵌入到 Win32 样式资源中的唯一信息。还有几个其他属性提供版权信息和其他描述性文本。[示例 14-11](#typical_assembly_description_attributes)展示了典型的选择。
- en: Example 14-11\. Typical assembly description attributes
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 14-11\. 典型的程序集描述属性
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As with the file version, these are all visible in the Details tab of the Properties
    window that Windows Explorer can show for the file. And with all of these attributes,
    you can cause them to be generated by editing the project file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与文件版本一样，所有这些信息都可以在文件的属性窗口的详细信息选项卡中看到，这是 Windows Explorer 可以显示的。对于所有这些属性，您都可以通过编辑项目文件来生成它们。
- en: Caller information attributes
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用者信息属性
- en: There are some compiler-handled attributes designed for scenarios where your
    methods need information about the context from which they were invoked. This
    is useful for certain diagnostic logging or error handling scenarios, and it is
    also helpful when implementing a particular interface commonly used in UI code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些编译器处理的属性专为您的方法需要有关其被调用上下文信息的场景而设计。这在某些诊断日志记录或错误处理场景中很有用，当然，在实现通常在 UI 代码中使用的特定接口时也非常有帮助。
- en: '[Example 14-12](#applying_caller_info_attributes) illustrates how you can use
    these attributes in logging code. If you annotate method parameters with any of
    these three attributes, the compiler provides some special handling when callers
    omit the arguments. We can ask for the name of the member (method or property)
    that called the attributed method, the filename containing the code that called
    the method, or the line number from which the call was made. [Example 14-12](#applying_caller_info_attributes)
    asks for all three, but you can be more selective.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 14-12](#applying_caller_info_attributes)说明了如何在日志记录代码中使用这些属性。如果你用这三个属性中的任何一个注释方法参数，编译器在调用者省略参数时会进行一些特殊处理。我们可以请求调用带有注释方法的成员（方法或属性）的名称，调用该方法的包含代码的文件名，或者调用发生的行号。[示例 14-12](#applying_caller_info_attributes)请求了这三者，但你可以更有选择地使用。'
- en: Note
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: These attributes are allowed only for optional parameters. Optional arguments
    are required to specify a default value, but C# will always substitute a different
    value when these attributes are present, so the default you specify will not be
    used if you invoke the method from C# (or Visual Basic, which also supports these
    attributes). Nonetheless, you must provide a default because without one, the
    parameter is not optional, so we normally use empty strings, `null`, or the number
    `0`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性仅允许用于可选参数。可选参数需要指定默认值，但是当这些属性存在时，C#会始终替换为不同的值，因此你指定的默认值在从C#（或支持这些属性的Visual
    Basic）调用方法时不会被使用。尽管如此，你必须提供一个默认值，因为没有默认值时，参数就不是可选的，所以我们通常使用空字符串、`null`或数字`0`。
- en: Example 14-12\. Applying caller info attributes to method parameters
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 14-12\. 将调用者信息属性应用于方法参数
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you supply all arguments when invoking this method, nothing unusual happens.
    But if you omit any of the optional arguments, C# will generate code that provides
    information about the site from which the method was invoked. The default values
    for the three optional arguments in [Example 14-12](#applying_caller_info_attributes)
    will be the name of the method or property that called this `Log` method, the
    full path of the source code containing the code that made the call, and the line
    number from which `Log` was called.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在调用此方法时提供了所有参数，那么不会发生任何异常。但是如果省略了任何可选参数，C#会生成代码来提供关于调用该方法的位置的信息。在[示例 14-12](#applying_caller_info_attributes)中，三个可选参数的默认值将是调用此`Log`方法的方法或属性的名称，包含调用方法的源代码的完整路径，以及调用`Log`的行号。
- en: The `CallerMemberName` attribute has a superficial resemblance to the `nameof`
    operator, which we saw in [Chapter 8](ch08.xhtml#ch_exceptions). Both cause the
    compiler to create a string containing the name of some feature of the code, but
    they work quite differently. With `nameof`, you always know exactly what string
    you’ll get, because it’s determined by the expression you supply. (E.g., if we
    were to write `nameof(message)` inside `Log` in [Example 14-12](#applying_caller_info_attributes),
    it would always evaluate to `"message"`.) But `CallerMemberName` changes the way
    the compiler invokes the method to which they apply—`cal⁠lin⁠g​Met⁠hod` has that
    attribute, and its value is not fixed. It will depend on where this method is
    called from.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`CallerMemberName`属性与我们在[第8章](ch08.xhtml#ch_exceptions)中看到的`nameof`运算符有表面上的相似之处。两者都导致编译器创建包含代码某些特性名称的字符串，但它们的工作方式完全不同。使用`nameof`，你总是知道会得到什么字符串，因为它由你提供的表达式决定（例如，在[示例 14-12](#applying_caller_info_attributes)中的`Log`中写入`nameof(message)`，它将始终评估为`"message"`）。但是`CallerMemberName`改变了应用它们的方法被编译器调用的方式——`cal⁠lin⁠g​Met⁠hod`有该属性，其值不是固定的。它将取决于调用此方法的位置。'
- en: Note
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can discover the calling method another way: the `StackTrace` and `StackFrame`
    classes in the `System.Diagnostics` namespace can report information about methods
    above you in the call stack. However, these have a considerably higher runtime
    expense—the caller information attributes calculate the values at compile time,
    making the runtime overhead very low. (Likewise with `nameof`.) Also, `StackFrame`
    can determine the filename and line number only if debug symbols are available.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以另一种方式发现调用方法：`System.Diagnostics`命名空间中的`StackTrace`和`StackFrame`类可以报告调用堆栈中的上层方法的信息。然而，这些方法在运行时开销较高——调用者信息属性在编译时计算值，因此运行时开销非常低（`nameof`也是如此）。此外，`StackFrame`只能在存在调试符号时确定文件名和行号。
- en: Although diagnostic logging is the obvious application for this, I also mentioned
    a certain scenario that most .NET UI developers will be familiar with. The runtime
    libraries define an interface called `INotifyPropertyChanged`. As [Example 14-13](#inotifypropertychanged)
    shows, this is a very simple interface with just one member, an event called `PropertyChanged`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然诊断日志记录是显而易见的应用，我还提到了大多数.NET UI开发人员熟悉的某种场景。运行时库定义了一个称为`INotifyPropertyChanged`的接口。正如[示例 14-13](#inotifypropertychanged)所示，这是一个非常简单的接口，只有一个成员，一个称为`PropertyChanged`的事件。
- en: Example 14-13\. `INotifyPropertyChanged`
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 14-13\. `INotifyPropertyChanged`
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Types that implement this interface raise the `PropertyChanged` event every
    time one of their properties changes. The `PropertyChangedEventArgument` provides
    a string containing the name of the property that just changed. These change notifications
    are useful in UIs, because they enable an object to be used with databinding technologies
    (such as those provided by .NET’s WPF UI framework) that can automatically update
    the UI any time a property changes. Databinding can help you to achieve a clean
    separation between the code that deals directly with UI types and code that contains
    the logic that decides how the application should respond to user input.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此接口的类型在其属性更改时引发`PropertyChanged`事件。`PropertyChangedEventArgument`提供一个字符串，其中包含刚刚更改的属性的名称。这些更改通知在UI中非常有用，因为它们使对象能够与数据绑定技术（例如.NET的WPF
    UI框架提供的技术）一起使用，该技术可以在属性更改时自动更新UI。数据绑定可以帮助您实现UI类型直接处理的代码与包含决定应用程序如何响应用户输入的逻辑的代码之间的清晰分离。
- en: Implementing `INotifyPropertyChanged` can be both tedious and error-prone. Because
    the `PropertyChanged` event indicates which property changed as a string, it is
    very easy to mistype the property name, or to accidentally use the wrong name
    if you copy and paste the implementation from one property to another. Also, if
    you rename a property, it’s easy to forget to change the text used for the event,
    meaning that code that was previously correct will now provide the wrong name
    when raising the `PropertyChanged` event. The `nameof` operator helps avoid mistyping,
    and helps with renames, but can’t always detect cut-and-paste errors. (It won’t
    notice if you fail to update the name when pasting code between properties of
    the same class, for example.)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`INotifyPropertyChanged`可能既繁琐又容易出错。因为`PropertyChanged`事件以字符串形式指示哪个属性已更改，所以很容易拼写错误属性名称，或者在复制和粘贴实现时意外使用错误的名称。另外，如果重命名属性，很容易忘记更改事件的文本，这意味着以前正确的代码现在在引发`PropertyChanged`事件时会提供错误的名称。`nameof`运算符有助于避免拼写错误，并有助于重命名，但无法始终检测到复制和粘贴错误。（例如，在同一类的属性之间粘贴代码时，它不会注意到您未更新名称的情况。）
- en: Caller information attributes can help make implementing this interface much
    less error-prone. You can refer to [Example 14-14](#reusable_inotifypropertychanged_impl),
    which shows a base class that implements `INotifyPropertyChanged`, supplying a
    helper for raising change notifications in a way that exploits one of these attributes.
    (It also uses the null-conditional `?.` operator to ensure that it only invokes
    the event’s delegate if it is non-null. By the way, when you use the operator
    this way, C# generates code that only evaluates the delegate’s `Invoke` method’s
    arguments if it is non-null. So not only does it skip the call to `Invoke` when
    the delegate is null, it will also avoid constructing the `Pro⁠per⁠ty​Cha⁠nge⁠dEv⁠ent⁠Args`
    that would have been passed as an argument.) This code also detects whether the
    value really has changed, only raising the event when that’s the case, and its
    return value indicates whether it changed, in case callers might find that useful.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者信息属性可以帮助减少实现此接口时的错误。您可以参考[示例 14-14](#reusable_inotifypropertychanged_impl)，该示例显示了一个实现`INotifyPropertyChanged`的基类，提供了一个在利用这些属性之一时引发更改通知的帮助程序。（它还使用了空值条件运算符`?.`，以确保仅在委托非空时才调用事件的委托。顺便说一下，当您以这种方式使用运算符时，C#会生成只在委托非空时才评估委托的`Invoke`方法参数的代码。因此，它会跳过当委托为空时的调用`Invoke`，还会避免构造将作为参数传递的`Pro⁠per⁠ty​Cha⁠nge⁠dEv⁠ent⁠Args`。）此代码还会检测值是否真的已更改，仅在这种情况下引发事件，并且其返回值指示是否发生了更改，以防调用者可能会发现这有用。
- en: Example 14-14\. A reusable `INotifyPropertyChanged` implementation
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 14-14\. 可重用的`INotifyPropertyChanged`实现
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The presence of the `[CallerMemberName]` attribute means that a class deriving
    from this type does not need to specify the property name if it calls `SetProperty`
    from inside a property setter, as [Example 14-15](#raising_a_property_changed_event)
    shows.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 存在`[CallerMemberName]`属性意味着从此类型派生的类如果在属性设置器内部调用`SetProperty`，则无需指定属性名称，如[Example 14-15](#raising_a_property_changed_event)所示。
- en: Example 14-15\. Raising a property changed event
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 14-15\. 触发属性更改事件
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Even with the new attribute, implementing `INotifyPropertyChanged` is clearly
    more effort than an automatic property, where you just write `{ get; set; }` and
    let the compiler do the work for you. But it’s only a little more complex than
    an explicit implementation of a trivial field-backed property, and it’s simpler
    than would be possible without `[CallerMemberName]`, because I’ve been able to
    omit the property name when asking the base class to raise the event. More importantly,
    it’s less error prone: I can now be confident that the right name will be used
    every time, even if I rename the property at some point in the future.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有了新的属性，实现`INotifyPropertyChanged`显然比自动属性更费力，其中您只需编写`{ get; set; }`并让编译器为您完成工作。但它只比显式实现的简单字段支持属性复杂一点点，并且比没有`[CallerMemberName]`时简单，因为我能够在请求基类触发事件时省略属性名称。更重要的是，它更少容易出错：现在我可以确信每次都会使用正确的名称，即使将来某个时候重命名属性。
- en: '.NET 6.0 adds a new caller information attribute: `CallerArgumentExpression`.
    [Example 14-16](#caller_argument_expression_attr) shows an excerpt from the runtime
    libraries’ `ArgumentNullException` class. It declares a `ThrowIfNull` method that
    uses this attribute.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 6.0添加了一个新的调用者信息属性：`CallerArgumentExpression`。[Example 14-16](#caller_argument_expression_attr)展示了运行时库的`ArgumentNullException`类的摘录。它声明了一个使用此属性的`ThrowIfNull`方法。
- en: Example 14-16\. The `CallerArgumentExpressionAttribute` in `ArgumentNullException.ThrowIfNull`
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 14-16\. 在`ArgumentNullException.ThrowIfNull`中的`CallerArgumentExpressionAttribute`
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, the `CallerArgumentExpression` attribute takes a single string
    argument. This must be the name of another parameter in the same method—in this
    case there is only one other parameter, called `argument`, so it has to refer
    to that. The effect is that if you call this method without providing a value
    for the annotated `paramName` argument, the C# compiler will pass a string containing
    the exact expression you used for the argument that the attribute identified.
    [Example 14-17](#caller_argument_expression_in_use) shows how this `ThrowIfNull`
    method is typically called.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，`CallerArgumentExpression`属性接受一个字符串参数。这必须是同一方法中另一个参数的名称——在本例中只有一个叫做`argument`，因此必须引用它。其效果是，如果调用此方法而没有为注释的`paramName`参数提供值，C#编译器将传递包含该属性标识的参数的精确表达式的字符串。[Example 14-17](#caller_argument_expression_in_use)展示了`ThrowIfNull`方法的典型调用方式。
- en: Example 14-17\. Calling a method that uses `CallerArgumentExpressionAttribute`
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 14-17\. 调用使用`CallerArgumentExpressionAttribute`的方法
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `Greet` method needs `greetingRecipient` not to be null, so it calls `Arg⁠ume⁠nt​Nul⁠lEx⁠cep⁠tio⁠n.T⁠hro⁠wIf⁠Null`,
    passing in `greetingRecipient`. Because this code does not provide a second argument
    to `ThrowIfNull`, the compiler will provide the full text of the expression we
    used for the first argument. In this case, that’s `"gre⁠eti⁠ng​Rec⁠ipi⁠ent"`.
    So the effect is that when I run this program, it throws an `Arg⁠ume⁠nt​Nul⁠lEx⁠cep⁠tion`
    with this message:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Greet`方法需要`greetingRecipient`不为null，因此调用`Arg⁠ume⁠nt​Nul⁠lEx⁠cep⁠tio⁠n.T⁠hro⁠wIf⁠Null`，传入`greetingRecipient`。因为这段代码没有为`ThrowIfNull`提供第二个参数，编译器将提供我们用于第一个参数的表达式的完整文本。在这种情况下，即是`"gre⁠eti⁠ng​Rec⁠ipi⁠ent"`。因此，当运行此程序时，效果是抛出一个带有此消息的`Arg⁠ume⁠nt​Nul⁠lEx⁠cep⁠tio⁠n`：'
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Before C# 10.0, we would typically have used `nameof(greetingRecipient)` to
    tell `ArgumentNullException` the name of the offending argument. This new technique
    prevents a certain mistake: it used to be all too easy to pass the name of the
    wrong argument when throwing an exception. (This was particularly common if you
    needed to check multiple arguments for null—copying and pasting the relevant checks
    provided ample opportunities to make this mistake.)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 10.0之前，我们通常会使用`nameof(greetingRecipient)`来告诉`ArgumentNullException`有问题的参数名称。这种新技术防止了一种特定的错误：以前在抛出异常时很容易传递错误的参数名称。（如果您需要检查多个参数是否为null，复制和粘贴相关检查会提供大量机会来犯这种错误。）
- en: One of the scenarios this attribute supports is to improve assertion messages.
    For example, unit test libraries typically provide mechanisms for asserting that
    certain conditions are true after exercising the code under test. The idea is
    that if your test contains code such as `Assert.IsTrue(answer == 42);` the test
    library could use `[CallerArgumentExpression]` to be able to report the exact
    expression (`answer == 42`) on failure.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性支持的一个场景是改进断言消息。例如，单元测试库通常提供机制，用于在测试代码执行后断言某些条件是否为真。其思想是，如果您的测试包含类似 `Assert.IsTrue(answer
    == 42);` 的代码，测试库可以使用 `[CallerArgumentExpression]` 来在失败时报告确切的表达式 (`answer == 42`)。
- en: You might expect the `Debug.Assert` method in the runtime libraries to use this
    for similar reasons. However, to use `CallerArgumentExpressionAttribute`, you
    have to add a parameter to the method to receive the expression text (in addition
    to the existing parameter that receives the value of the expression), so it’s
    not a binary-compatible change. The new `ThrowIfNull` method is the only place
    the .NET 6.0 runtime libraries use this attribute, and at the time of writing
    this, the NuGet packages for Microsoft’s testing framework do not yet use this.
    But it seems likely that test frameworks will adopt this in time.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能期望运行时库中的 `Debug.Assert` 方法以类似的方式使用此属性。但是，要使用 `CallerArgumentExpressionAttribute`，您必须添加一个参数来接收表达式文本（除了接收表达式值的现有参数之外），因此这不是一个二进制兼容的更改。新的
    `ThrowIfNull` 方法是.NET 6.0 运行时库唯一使用此属性的地方，在我写这篇文章时，微软的测试框架的 NuGet 包尚未使用此属性。但是很可能测试框架会在未来采用这一特性。
- en: CLR-Handled Attributes
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CLR-Handled Attributes
- en: Some attributes get special treatment at runtime from the CLR. There is no official
    comprehensive list of such attributes, so in the next few sections, I will just
    describe some of the most widely used examples.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: CLR 在运行时会对某些属性进行特殊处理。目前还没有官方的全面属性列表，所以在接下来的几节中，我将简要描述一些最常用的例子。
- en: InternalsVisibleToAttribute
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: InternalsVisibleToAttribute
- en: You can apply the `InternalsVisibleToAttribute` to an assembly to declare that
    any `internal` types or members it defines should be visible to one or more other
    assemblies. A popular use for this is to enable unit testing of internal types.
    As [Example 14-18](#internalsvisibleto-attributes) shows, you pass the name of
    the assembly as a constructor argument.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将 `InternalsVisibleToAttribute` 应用于一个程序集，以声明其定义的任何 `internal` 类型或成员应该对一个或多个其他程序集可见。这种属性的一个常见用途是启用内部类型的单元测试。正如
    [示例 14-18](#internalsvisibleto-attributes) 所示，您可以将程序集的名称作为构造函数参数传递。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Strong naming complicates matters. Strongly named assemblies cannot make their
    internals visible to assemblies that are not strongly named, and vice versa. When
    a strongly named assembly makes its internals visible to another strongly named
    assembly, it must specify not just the simple name but also the public key of
    the assembly to which it is granting access. And this is not just the public key
    token I described in [Chapter 12](ch12.xhtml#ch_assemblies)—it is the hexadecimal
    for the entire public key, which will be several hundred digits. You can discover
    an assembly’s full public key with the .NET SDK’s *sn.exe* utility, using the
    `-Tp` switch followed by the assembly’s path.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 强名称会使事情变得更复杂。强名称的程序集无法将其内部成员对不强命名的程序集可见，反之亦然。当一个强命名的程序集将其内部成员对另一个强命名的程序集可见时，它必须指定不仅仅是简单名称，还包括要授予访问权限的程序集的公钥。这不仅仅是我在
    [第12章](ch12.xhtml#ch_assemblies) 中描述的公钥令牌——它是整个公钥的十六进制表示，可能有数百位数字。您可以使用 .NET SDK
    的 *sn.exe* 实用程序，使用 `-Tp` 开关，后跟程序集的路径，来发现程序集的完整公钥。
- en: Example 14-18\. `InternalsVisibleToAttribute`
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 14-18\. `InternalsVisibleToAttribute`
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This shows that you can make the types visible to multiple assemblies by applying
    the attribute multiple times, with a different assembly name each time.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明您可以通过多次应用该属性并每次使用不同的程序集名称，使类型对多个程序集可见。
- en: The CLR is responsible for enforcing accessibility rules. Normally, if you try
    to use an internal class from another assembly, you’ll get an error at runtime.
    (C# won’t even let you compile such code, but it’s possible to trick the compiler.
    Or you could write directly in IL. The IL assembler, *ILASM*, does what you tell
    it and imposes far fewer restrictions than C#. Once you get past the compile-time
    restrictions, then you’ll hit the runtime ones.) But when this attribute is present,
    the CLR relaxes its rules for the assemblies you list. The compiler also understands
    this attribute and lets code that tries to use externally defined internal types
    compile as long as the external library names your assembly in an `InternalsVisibleToAttribute`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: CLR 负责执行访问规则。通常，如果您尝试从另一个程序集使用内部类，您将在运行时收到错误。(C# 甚至不允许您编译这样的代码，但是有可能欺骗编译器。或者您可以直接编写
    IL。IL 汇编器 *ILASM* 会执行您告诉它的操作，并且比 C# 实施的限制少得多。一旦您通过了编译时的限制，然后您将遇到运行时限制。) 但是，当存在此属性时，CLR
    放宽了对您列出的程序集的规则。编译器也理解此属性，并允许尝试使用外部定义的内部类型的代码编译，只要外部库在 `InternalsVisibleToAttribute`
    中命名了您的程序集。
- en: Besides being useful in unit test scenarios, this attribute can also be helpful
    if you want to split code across multiple assemblies. If you have written a large
    class library, you might not want to put it into one massive DLL. If it has several
    areas that your customers might want to use in isolation, it could make sense
    to split it up so that they can deploy just the parts that they need. However,
    although you may be able to partition your library’s public-facing API, the implementation
    might not be as easy to divide, particularly if your codebase performs a lot of
    reuse. You might have many classes that are not designed for public consumption
    but that you use throughout your code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在单元测试场景中很有用外，这个属性还可以在您想要将代码分散到多个程序集的情况下帮助您。如果您编写了一个大型类库，可能不想将其放入一个庞大的 DLL
    中。如果它有几个区域是您的客户可能想要单独使用的，那么将它分割开来以便他们可以部署他们需要的部分就有意义了。但是，尽管您可能可以对库的公共 API 进行分区，但实现可能并不容易分割，特别是如果您的代码库执行大量重用。您可能有许多不设计为公共消费的类，但却在整个代码中使用。
- en: If it weren’t for the `InternalsVisibleToAttribute`, it would be awkward to
    reuse shared implementation details across assemblies. Either each assembly would
    need to contain its own copy of the relevant classes, or you’d need to make them
    public types in some common assembly. The problem with that second technique is
    that making types public effectively invites people to use them. Your documentation
    might state that the types are for the internal use of your framework and should
    not be used, but that won’t stop some people.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有`InternalsVisibleToAttribute`，跨程序集重用共享实现细节将会很尴尬。每个程序集都需要包含其相关类的副本，或者您需要在某个公共程序集中将它们作为公共类型。第二种技术的问题在于，将类型公开实际上邀请人们使用它们。您的文档可能说明这些类型是框架内部使用的，不应该使用，但这并不能阻止某些人。
- en: Fortunately, you don’t have to make them `public`. Any types that are just implementation
    details can remain `internal`, and you can make them available to all of your
    assemblies with the `InternalsVisibleToAttribute` while keeping them inaccessible
    to everyone else.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，您不必将它们设为 `public`。任何只是实现细节的类型可以保持 `internal`，并且您可以使用 `InternalsVisibleToAttribute`
    将它们对所有程序集可见，同时使它们对其他人不可访问。
- en: JIT compilation
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JIT 编译
- en: There are a few attributes that influence how the JIT compiler generates code.
    You can apply the `MethodImplAttribute` to a method, passing values from the `Met⁠hod​Imp⁠lOp⁠tions`
    enumeration. Its `NoInlining` value ensures that whenever your method is called
    by another method, it will be a full method call. Without this, the JIT compiler
    will sometimes just copy a method’s code directly into the calling code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 影响 JIT 编译器生成代码的几个属性。您可以将`MethodImplAttribute`应用于方法，并传递`Met⁠hod​Imp⁠lOp⁠tions`枚举中的值。其`NoInlining`值确保每当其他方法调用您的方法时，它将成为完整的方法调用。如果没有这个选项，JIT
    编译器有时会直接将方法的代码复制到调用代码中。
- en: In general, you’ll want to leave inlining enabled. The JIT compiler inlines
    only small methods, and it’s particularly important for tiny methods, such as
    property accessors. For simple field-based properties, invoking accessors with
    a normal function call often requires more code than inlining, so this optimization
    can produce code that’s smaller, as well as faster. (Even if the code is not smaller,
    it may still be faster, because function calls can be surprisingly expensive.
    Modern CPUs tend to handle long sequential streams of instructions more efficiently
    than code that leaps around from one location to another.) However, inlining is
    an optimization with observable side effects—an inlined method does not get its
    own stack frame. Earlier, I mentioned some diagnostic APIs you can use to inspect
    the stack, and inlining will change the number of reported stack frames. If you
    just want to ask the question “Which method is calling me?” the caller info attributes
    described earlier provide a more efficient way to discover this and will not be
    defeated by inlining, but if you have code that inspects the stack for any reason,
    it can sometimes be confused by inlining. So, just occasionally, it’s useful to
    disable it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，您应该保留内联功能。JIT 编译器仅内联小方法，对于诸如属性访问器之类的简单小方法尤为重要。对于基于字段的简单属性，通过普通函数调用调用访问器通常需要更多代码，而内联优化则可能产生更小、更快的代码。即使代码大小没有减小，它仍然可能更快，因为函数调用可能会意外地昂贵。现代
    CPU 倾向于更有效地处理长顺序指令流，而不是跳跃执行位置的代码。然而，内联是一个带有可观测副作用的优化——内联方法不会得到自己的堆栈帧。之前我提到过一些诊断
    API，您可以使用它们来检查堆栈，内联将改变报告的堆栈帧数量。如果您只想询问“是哪个方法在调用我？”，则前面描述的调用者信息属性提供了一种更有效的发现方法，不会受内联的影响，但如果您有检查堆栈的代码，有时可能会因内联而混淆。因此，偶尔禁用它是有用的。
- en: Conversely, you can specify `AggressiveInlining`, which encourages the JIT compiler
    to inline things it might otherwise leave as normal method calls. If you have
    identified a particular method as being highly performance sensitive, it might
    be worth trying this setting to see if it makes any difference, although be aware
    that it could make code either slower or faster—it will depend on the circumstances.
    Conversely, you can disable all optimizations with the `NoOptimization` option
    (although the documentation implies that this is more for the benefit of the CLR
    team at Microsoft than for consumers, because it is for “debugging possible code
    generation problems”).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您可以指定 `AggressiveInlining`，这鼓励 JIT 编译器内联那些通常作为普通方法调用的内容。如果您确定某个方法对性能非常敏感，尝试这个设置可能会产生不同效果，尽管请注意它可能使代码变慢或变快——这取决于具体情况。相反，您可以使用
    `NoOptimization` 选项禁用所有优化（尽管文档暗示这更多是为了微软的 CLR 团队而不是为了消费者，因为它是为了“调试可能的代码生成问题”）。
- en: Another attribute that has an impact on optimization is the `DebuggableAttribute`.
    The C# compiler automatically applies this to your assembly in Debug builds. The
    attribute tells the CLR to be less aggressive about certain optimizations, particularly
    ones that affect variable lifetime and ones that change the order in which code
    executes. Normally, the compiler is free to change such things as long as the
    final result of the code is the same, but this can cause confusion if you break
    into the middle of an optimized method with the debugger. This attribute ensures
    that variable values and the flow of execution are easy to follow in that scenario.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个对优化产生影响的属性是 `DebuggableAttribute`。在调试版本中，C# 编译器会自动将此属性应用到您的程序集中。该属性告诉 CLR
    在某些优化方面要更加谨慎，特别是那些影响变量生命周期和代码执行顺序的优化。通常情况下，编译器可以自由更改这些内容，只要最终代码的结果相同即可，但是如果您在调试器中打断点，可能会引起混乱。这个属性确保在这种情况下变量值和执行流程容易跟踪。
- en: STAThread and MTAThread
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: STAThread 和 MTAThread
- en: 'Applications that run only on Windows and that present a UI (e.g., anything
    using .NET’s WPF or Windows Forms frameworks) typically have the `[STAThread]`
    attribute on their `Main` method (although you won’t always see it, because the
    entry point is often generated by the build system for these kinds of applications).
    This is an instruction to the CLR’s interop services for the Component Object
    Model (COM), but it has broader implications: you need this attribute on `Main`
    if you want your main thread to host UI elements.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 只运行在 Windows 上并呈现 UI 的应用程序（例如使用 .NET 的 WPF 或 Windows Forms 框架的任何应用程序）通常在它们的
    `Main` 方法上有 `[STAThread]` 属性（尽管您不总是看到它，因为入口点通常由这些应用程序的构建系统生成）。这是对 CLR 的互操作服务的一条指令，用于组件对象模型
    (COM)，但它有更广泛的影响：如果您希望主线程托管 UI 元素，则需要在 `Main` 方法上放置此属性。
- en: Various Windows UI features rely on COM under the covers. The clipboard uses
    it, for example, as do certain kinds of controls. COM has several threading models,
    and only one of them is compatible with UI threads. One of the main reasons for
    this is that UI elements have thread affinity, so COM needs to ensure that it
    does certain work on the right thread. Also, if a UI thread doesn’t regularly
    check for messages and handle them, deadlock can ensue. If you don’t tell COM
    that a particular thread is a UI thread, it will omit these checks, and you will
    encounter problems.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 各种 Windows UI 功能都依赖于 COM。例如，剪贴板使用它，某些类型的控件也是如此。COM 有几种线程模型，只有一种与 UI 线程兼容。其中一个主要原因是
    UI 元素具有线程关联性，因此 COM 需要确保在正确的线程上执行某些工作。此外，如果 UI 线程不定期检查消息并处理它们，则可能发生死锁。如果您不告诉 COM
    特定线程是 UI 线程，它将省略这些检查，您将遇到问题。
- en: Note
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Even if you’re not writing UI code, some interop scenarios need the `[STAThread]`
    attribute, because certain COM components are incapable of working without it.
    However, UI work is the most common reason for seeing it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不编写 UI 代码，某些互操作场景需要 `[STAThread]` 属性，因为某些 COM 组件在没有它的情况下无法工作。不过，UI 工作是看到它的最常见原因。
- en: Since COM is managed for you by the CLR, the CLR needs to know that it should
    tell COM that a particular thread needs to be handled as a UI thread. When you
    create a new thread explicitly using the techniques shown in [Chapter 16](ch16.xhtml#ch_multithreading),
    you can configure its COM threading mode, but the main thread is a special case—the
    CLR creates it for you when your application starts, and by the time your code
    runs, it’s too late to configure the thread. Placing the `[STAThread]` attribute
    on the `Main` method tells the CLR that your main thread should be initialized
    for UI-compatible COM behavior.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 CLR 为您管理 COM，CLR 需要知道它应告诉 COM 特定线程需要作为 UI 线程处理。当您显式地使用 [Chapter 16](ch16.xhtml#ch_multithreading)
    中显示的技术创建新线程时，可以配置其 COM 线程模式，但主线程是一个特例 —— CLR 在应用程序启动时为您创建它，当您的代码运行时，配置线程已经太迟了。在
    `Main` 方法上放置 `[STAThread]` 属性告诉 CLR 您的主线程应初始化为兼容 UI 的 COM 行为。
- en: STA is short for *single-threaded apartment*. Threads that participate in COM
    always belong to either an STA or a *multithreaded apartment* (MTA). There are
    other kinds of apartments, but threads have only temporary membership in those;
    when a thread starts using COM, it must pick either STA or MTA mode. So there
    is, unsurprisingly, also an `[MTAThread]` attribute.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: STA 是 *单线程单元* 的缩写。参与 COM 的线程总是属于 STA 或 *多线程单元* (MTA) 中的一种。还有其他类型的单元，但线程只能在其中暂时成员；当线程开始使用
    COM 时，必须选择 STA 或 MTA 模式。因此，也有一个 `[MTAThread]` 属性。
- en: Interop
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 互操作
- en: The CLR’s interop services define numerous attributes. Most of them are handled
    directly by the CLR, because interop is an intrinsic feature of the runtime. Since
    the attributes make sense only in the context of the mechanisms they support,
    and because there are so many, I will not describe them in full here, but [Example 14-19](#interop_attributes_example)
    illustrates the kinds of things they can do.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: CLR 的互操作服务定义了许多属性。其中大多数由 CLR 直接处理，因为互操作是运行时的内在特性。由于这些属性只在它们支持的机制上下文中有意义，并且数量众多，我在这里不会详细描述它们，但
    [Example 14-19](#interop_attributes_example) 展示了它们可以做的事情类型。
- en: Example 14-19\. Interop attributes
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 14-19\. 互操作属性
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This uses two interop attributes that we saw earlier in [Example 14-7](#method_and_return_value_attributes)
    but in a somewhat more complex way. This calls into a function exposed by *advapi32.dll*,
    part of the Win32 API. The first argument to the `DllImport` attribute tells us
    that, but unlike the earlier example, this goes on to provide the interop layer
    with additional information. This API deals with strings, so interop needs to
    know which character representation is in use. This particular API uses a common
    Win32 idiom: it returns a Boolean value to indicate success or failure, but it
    also uses the Windows `SetLastError` API to provide more information in the failure
    case. The attribute’s `SetLastError` property tells the interop layer to retrieve
    that immediately after calling this API so that .NET code can inspect it if necessary.
    The `EntryPoint` property deals with the fact that Win32 APIs taking strings sometimes
    come in two forms, working with either 8-bit or 16-bit characters (Windows 95
    only supported 8-bit text, to conserve memory) and that we want to call the *Wide*
    form (hence the `W` suffix). It then uses `MarshalAs` on the two string arguments
    to tell the interop layer which of the many different string representations available
    in unmanaged code this particular API expects.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用了我们之前在[示例 14-7](#method_and_return_value_attributes)中看到的两个互操作属性，但使用方式稍显复杂。这调用了*advapi32.dll*中的一个函数，它是Win32
    API的一部分。`DllImport` 属性的第一个参数告诉我们这一点，但与之前的示例不同，这还提供了互操作层的额外信息。这个 API 处理字符串，所以互操作需要知道使用的字符表示法。这个特定的
    API 使用了一个常见的 Win32 习惯：它返回一个布尔值以指示成功或失败，但在失败情况下它还使用了 Windows 的 `SetLastError` API
    提供更多信息。属性的 `SetLastError` 属性告诉互操作层在调用此 API 后立即检索这些信息，以便 .NET 代码在必要时进行检查。`EntryPoint`
    属性处理了 Win32 API 可能有两种形式的字符串参数的事实，可以使用 8 位或 16 位字符（Windows 95 仅支持 8 位文本以节省内存），而我们希望调用*Wide*形式（因此使用
    `W` 后缀）。然后，在两个字符串参数上使用 `MarshalAs` 来告诉互操作层，非托管代码中的许多不同字符串表示中，这个特定的 API 需要哪一种。
- en: Defining and Consuming Attributes
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义和使用属性
- en: The vast majority of attributes you will come across are not intrinsic to the
    runtime or compiler. They are defined by class libraries and have an effect only
    if you are using the relevant libraries or frameworks. You are free to do exactly
    the same in your own code—you can define your own attribute types. Because attributes
    don’t do anything on their own—they don’t even get instantiated unless something
    asks to see them—it is normally useful to define an attribute type only if you’re
    writing some sort of framework, particularly one that is driven by reflection.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 绝大多数属性并非运行时或编译器本身固有的，而是由类库定义的，并且只有在使用相关的类库或框架时才会起作用。在你自己的代码中，你可以自由地做完全相同的事情——你可以定义自己的属性类型。因为属性本身不会自行执行任何操作——除非有什么东西要求查看它们，它们甚至不会被实例化——所以通常只在你编写某种类型的框架时定义属性类型才有用，尤其是那些受反射驱动的框架。
- en: For example, unit test frameworks often discover the test classes you write
    via reflection and enable you to control the test runner’s behavior with attributes.
    Another example is how Visual Studio uses reflection to discover the properties
    of editable objects on design surfaces (such as UI controls), and it will look
    for certain attributes that enable you to customize the editing behavior. Another
    application of attributes is to opt out of rules applied by the static code analysis
    tools. (The .NET SDK has built-in tools for detecting potential problems in your
    code. This is an extensible system, and NuGet packages can add analyzers that
    expand on this, potentially detecting common mistakes specific to a particular
    library.) Sometimes these tools get it wrong, and you can suppress their warnings
    by annotating your code with attributes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，单元测试框架经常通过反射发现你编写的测试类，并允许你使用属性控制测试运行程序的行为。另一个例子是 Visual Studio 如何利用反射发现设计表面上可编辑对象（如
    UI 控件）的属性，并且它将查找某些属性，这些属性使你可以自定义编辑行为。属性的另一个应用是选择性地排除静态代码分析工具应用的规则。（.NET SDK 包含用于检测代码潜在问题的内置工具。这是一个可扩展的系统，NuGet
    包可以添加扩展分析器，扩展这些工具，从而检测特定库可能出现的常见错误。）有时这些工具会出错，你可以通过用属性标注代码来抑制它们的警告。
- en: The common theme here is that some tool or framework examines your code and
    decides what to do based on what it finds. This is the kind of scenario in which
    attributes are a good fit. For example, attributes could be useful if you write
    an application that end users could extend. You might support loading of external
    assemblies that augment your application’s behavior—this is often known as a *plug-in*
    model. It might be useful to define an attribute that allows a plug-in to provide
    descriptive information about itself. It’s not strictly necessary to use attributes—you
    would probably define at least one interface that all plug-ins are required to
    implement, and you could have members in that interface for retrieving the necessary
    information. However, one advantage of using attributes is that you would not
    need to create an instance of the plug-in just to retrieve the description information.
    That would enable you to show the plug-in’s details to the user before loading
    it, which might be important if constructing the plug-in could have side effects
    that the user might not want.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的共同主题是，某些工具或框架会检查你的代码，并根据发现的内容决定要做什么。这种情况正是属性非常适合的场景。例如，如果你编写一个允许最终用户扩展的应用程序，属性可能会很有用。你可能支持加载扩展你应用程序行为的外部程序集——这通常被称为*插件*模型。定义一个允许插件提供有关自身描述信息的属性可能会很有用。使用属性并不是绝对必要的——你可能会定义至少一个接口，所有插件都必须实现该接口，并且可以在该接口中定义用于检索必要信息的成员。然而，使用属性的一个优点是，你不需要创建插件的实例来检索描述信息。这样可以在加载插件之前向用户显示插件的详细信息，如果构建插件可能会产生用户不想要的副作用，这可能很重要。
- en: Attribute Types
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性类型
- en: '[Example 14-20](#an_attribute_type) shows how an attribute containing information
    about a plug-in might look.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 14-20](#an_attribute_type)展示了一个包含有关插件信息的属性可能是什么样子。'
- en: Example 14-20\. An attribute type
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 14-20\. 一个属性类型
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To act as an attribute, a type must derive from the `Attribute` base class.
    Although `Attribute` defines various static methods for discovering and retrieving
    attributes, it does not provide very much of interest for instances. We do not
    derive from it to get any particular functionality; we do so because the compiler
    will not let you use a type as an attribute unless it derives from `Attribute`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要作为属性，类型必须派生自`Attribute`基类。虽然`Attribute`定义了各种静态方法来发现和检索属性，但对于实例来说并没有提供太多有趣的内容。我们并不是从中派生出任何特定功能；我们这样做是因为编译器不会让你使用一个类型作为属性，除非它派生自`Attribute`。
- en: Notice that my type’s name ends in the word `Attribute`. This is not an absolute
    requirement, but it is an extremely widely used convention. As you saw earlier,
    it’s even built into the compiler, which automatically adds the `Attribute` suffix
    if you leave it out when applying an attribute. So there’s usually no reason not
    to follow this convention.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我的类型名称以`Attribute`一词结尾。这不是绝对要求，但这是一个被广泛使用的约定。正如你之前看到的，即使在应用属性时忘记添加`Attribute`后缀，编译器也会自动添加。因此，通常没有理由不遵循这个约定。
- en: I’ve annotated my attribute type with an attribute. Most attribute types are
    annotated with the `AttributeUsageAttribute`, indicating the targets to which
    the attribute can usefully be applied. The C# compiler will enforce this. Since
    my attribute in [Example 14-20](#an_attribute_type) states that it may be applied
    only to classes, the compiler will generate an error if anyone attempts to apply
    it to anything else.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经用一个属性注释了我的属性类型。大多数属性类型都使用`AttributeUsageAttribute`进行注释，指示属性可以有用地应用到哪些目标上。C#编译器将强制执行这一点。由于我在[示例 14-20](#an_attribute_type)中的属性声明只能应用于类，如果有人尝试将其应用于其他任何东西，编译器将生成错误。
- en: Note
  id: totrans-133
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As you’ve seen, sometimes when we apply an attribute, we need to state its target.
    For example, when an attribute appears before a method, its target is the method,
    unless you qualify it with the `return:` prefix. You might have hoped that you’d
    be able to leave out these prefixes when using attributes that can target only
    certain members. For example, if an attribute can be applied only to an assembly,
    do you really need the `assembly:` qualifier? However, C# doesn’t let you leave
    it off. It uses the `AttributeUsageAttribute` only to verify that an attribute
    has not been misapplied.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，有时候当我们应用一个属性时，我们需要说明它的目标。例如，当一个属性出现在方法之前时，它的目标就是该方法，除非您用`return:`前缀加以限定。您可能希望在使用只能针对特定成员的属性时，能够省略这些前缀。例如，如果一个属性只能应用于程序集，您真的需要`assembly:`限定符吗？然而，C#
    不允许您省略它。它仅使用`AttributeUsageAttribute`来验证属性未被错误应用。
- en: My attribute defines only one constructor, so any code that uses it will have
    to pass the arguments that the constructor requires, as [Example 14-21](#applying_a_custom_attribute)
    does.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我的属性只定义了一个构造函数，因此任何使用它的代码都必须传递构造函数所需的参数，就像[示例 14-21](#applying_a_custom_attribute)所示。
- en: Example 14-21\. Applying an attribute
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 14-21\. 应用属性
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Attribute classes are free to define multiple constructor overloads to support
    different sets of information. They can also define properties as a way to support
    optional pieces of information. My attribute defines a `Description` property,
    which is not required because the constructor does not demand a value for it,
    but which I can set using the syntax I described earlier in this chapter. [Example 14-22](#providing_an_optional_property_value_for)
    shows how that looks for my attribute.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 属性类可以自由地定义多个构造函数重载，以支持不同的信息集。它们还可以定义属性作为支持可选信息的一种方式。我的属性定义了一个`Description`属性，这不是必需的，因为构造函数不要求为其提供值，但我可以使用本章前面描述的语法来设置它。[示例 14-22](#providing_an_optional_property_value_for)展示了我属性的样子。
- en: Example 14-22\. Providing an optional property value for an attribute
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 14-22\. 为属性提供可选的属性值
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So far, nothing I’ve shown will cause an instance of my `Plu⁠gin⁠Inf⁠orm⁠ation​Att⁠rib⁠ute`
    type to be created. These annotations are simply instructions for how the attribute
    should be initialized if anything asks to see it. So, if this attribute is to
    be useful, I need to write some code that will look for it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我展示的内容不会创建`Plu⁠gin⁠Inf⁠orm⁠ation​Att⁠rib⁠ute`类型的实例。这些注解只是指示，告诉属性在需要时应如何初始化。因此，如果要使用此属性，我需要编写一些代码来查找它。
- en: Retrieving Attributes
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取属性
- en: You can discover whether a particular kind of attribute has been applied using
    the reflection API, which can also instantiate the attribute for you. In [Chapter 13](ch13.xhtml#ch_reflection),
    I showed all of the reflection types representing the various targets to which
    attributes can be applied—types such as `MethodInfo`, `Type`, and `PropertyInfo`.
    These all implement an interface called `ICustomAttributeProvider`, as shown in
    [Example 14-23](#icustomattributeprovider).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用反射 API 来发现特定类型的属性是否已经应用，并且反射 API 也可以为您实例化该属性。在[第 13 章](ch13.xhtml#ch_reflection)中，我展示了表示各种属性目标的反射类型，例如`MethodInfo`、`Type`和`PropertyInfo`。它们都实现了一个名为`ICustomAttributeProvider`的接口，如[示例 14-23](#icustomattributeprovider)所示。
- en: Example 14-23\. `ICustomAttributeProvider`
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 14-23\. `ICustomAttributeProvider`
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `IsDefined` method simply tells you whether or not a particular attribute
    type is present—it does not instantiate it. The two `GetCustomAttributes` overloads
    create attributes and return them. (This is the point at which attributes are
    constructed and also when any properties the annotations specify are set.) The
    first overload returns all attributes applied to the target, while the second
    lets you request only those attributes of a particular type.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsDefined`方法仅告诉您特定属性类型是否存在，而不会实例化它。两个`GetCustomAttributes`重载会创建属性并返回它们。（这是属性被构造以及设置任何注解指定的属性的时机。）第一个重载返回应用于目标的所有属性，而第二个重载允许您仅请求特定类型的属性。'
- en: All of these methods take a `bool` argument that lets you specify whether you
    want only attributes that were applied directly to the target you’re inspecting
    or also attributes applied to the base type or types.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都接受一个`bool`参数，让您可以指定是否仅希望获取直接应用于您正在检查的目标的属性，或者还包括应用于基类型或类型的属性。
- en: This interface was introduced in .NET 1.0, so it does not use generics, meaning
    you need to cast the objects that come back. Fortunately, the `Cus⁠tom⁠Att⁠rib⁠ute​Ext⁠ens⁠ions`
    static class defines several extension methods. Instead of defining them for the
    `ICustomAttributeProvider` interface, it extends the reflection classes that offer
    attributes. For example, if you have a variable of type `Type`, you could call
    `GetCustomAttribute<PluginInformationAttribute>()` on it, which would construct
    and return the plug-in information attribute or `null` if the attribute is not
    present. [Example 14-24](#showing_plug-in_information) uses this to show all of
    the plug-in information from all the DLLs in a particular folder.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口在 .NET 1.0 中引入，因此它不使用泛型，这意味着您需要对返回的对象进行强制转换。幸运的是，`Cus⁠tom⁠Att⁠rib⁠ute​Ext⁠ens⁠ions`
    静态类定义了几个扩展方法。它并不是为 `ICustomAttributeProvider` 接口定义这些方法，而是扩展了提供属性的反射类。例如，如果您有一个
    `Type` 类型的变量，您可以在其上调用 `GetCustomAttribute<PluginInformationAttribute>()` 方法，这将构造并返回插件信息属性，如果该属性不存在，则返回
    `null`。[示例 14-24](#showing_plug-in_information) 使用此方法显示了特定文件夹中所有 DLL 的所有插件信息。
- en: Example 14-24\. Showing plug-in information
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 14-24\. 显示插件信息
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There’s one potential problem with this. I said that one benefit of attributes
    is that they can be retrieved without instantiating their target types. That’s
    true here—I’m not constructing any of the plug-ins in [Example 14-24](#showing_plug-in_information).
    However, I am loading the plug-in assemblies, and a possible side effect of enumerating
    the plug-ins would be to run static constructors in the plug-in DLLs. So, although
    I’m not deliberately running any code in those DLLs, I can’t guarantee that no
    code from those DLLs will run. If my goal is to present a list of plug-ins to
    the user, and to load and run only the ones explicitly selected, I’ve failed,
    because I’ve given plug-in code a chance to run. However, we can fix this.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做可能会存在一个潜在问题。我之前说过属性的一个好处是，可以在不实例化它们的目标类型的情况下检索它们。在这里是正确的 —— 我没有在 [示例 14-24](#showing_plug-in_information)
    中构造任何插件。然而，我正在加载插件程序集，枚举插件的一个可能副作用是运行插件 DLL 中的静态构造函数。因此，虽然我没有故意在这些 DLL 中运行任何代码，但我不能保证这些
    DLL 中的代码不会运行。如果我的目标是向用户呈现插件列表，并且仅加载和运行明确选择的插件，那么我已经失败了，因为我给插件代码一个运行的机会。不过，我们可以解决这个问题。
- en: Metadata-Only Load
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅加载元数据（Metadata-Only Load）
- en: You do not need to load an assembly fully in order to retrieve attribute information.
    As I discussed in [Chapter 13](ch13.xhtml#ch_reflection), you can load an assembly
    for reflection purposes only with the `MetadataLoadContext` class. This prevents
    any of the code in the assembly from running but enables you to inspect the types
    it contains. However, this presents a challenge for attributes. The usual way
    to inspect an attribute’s properties is to instantiate it by calling `GetCustomAttributes`
    or a related extension method. Since that involves constructing the attribute—which
    means running some code—it is not supported for assemblies loaded by `MetadataLoadContext`
    (not even if the attribute type in question were defined in a different assembly
    that had been fully loaded in the normal way). If I modified [Example 14-24](#showing_plug-in_information)
    to load the assembly with `Met⁠ada⁠ta​Loa⁠dCo⁠ntext`, the call to `Get⁠Cus⁠tom⁠Att⁠rib⁠ute⁠<Pl⁠ugi⁠nIn⁠for⁠mat⁠ion​Att⁠rib⁠ute>`
    would throw an exception.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要完全加载一个程序集才能检索属性信息。正如我在 [第 13 章](ch13.xhtml#ch_reflection) 中讨论的那样，您可以仅为反射目的加载程序集，使用
    `MetadataLoadContext` 类来实现。这样可以防止程序集中的任何代码运行，但可以检查其包含的类型。不过，这对属性造成了挑战。通常检查属性的属性的方法是通过调用
    `GetCustomAttributes` 或相关的扩展方法来实例化它。由于这涉及构造属性 —— 也就是运行某些代码 —— 对于由 `MetadataLoadContext`
    加载的程序集是不支持的（即使涉及的属性类型是在以正常方式完全加载的不同程序集中定义的）。如果我修改了 [示例 14-24](#showing_plug-in_information)
    来使用 `Met⁠ada⁠ta​Loa⁠dCo⁠ntext` 加载程序集，调用 `Get⁠Cus⁠tom⁠Att⁠rib⁠ute⁠<Pl⁠ugi⁠nIn⁠for⁠mat⁠ion​Att⁠rib⁠ute>`
    将会抛出异常。
- en: When loading for metadata only, you have to use the `GetCustomAttributesData`
    method. Instead of instantiating the attribute for you, this returns the information
    stored in the metadata—the instructions for creating the attribute. [Example 14-25](#retrieving_attributes_metadata_load)
    shows a version of the relevant code from [Example 14-24](#showing_plug-in_information)
    modified to work this way. (It also includes the code required to initialize the
    `MetadataLoadContext`.)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当仅加载元数据时，您必须使用`GetCustomAttributesData`方法。这不会为您实例化属性，而是返回存储在元数据中的信息——用于创建属性的指令。[Example 14-25](#retrieving_attributes_metadata_load)展示了从[Example 14-24](#showing_plug-in_information)修改为使用这种方式的相关代码版本。（还包括初始化`MetadataLoadContext`所需的代码。）
- en: Example 14-25\. Retrieving attributes with the `MetadataLoadContext`
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 14-25\. 使用`MetadataLoadContext`检索属性
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The code is rather more cumbersome because we don’t get back an instance of
    the attribute. `GetCustomAttributesData` returns a collection of `CustomAttributeData`
    objects. [Example 14-25](#retrieving_attributes_metadata_load) uses LINQ’s `SingleOrDefault`
    operator to find the entry for the `PluginInformationAttribute`, and if that’s
    present, the `info` variable in the query will end up holding a reference to the
    relevant `CustomAttributeData` object. The code then picks through the constructor
    arguments and property values using the `ConstructorArguments` and `NamedArguments`
    properties, enabling it to retrieve the three descriptive text values embedded
    in the attribute.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 代码非常繁琐，因为我们没有得到属性的实例。`GetCustomAttributesData`返回一个`CustomAttributeData`对象的集合。[Example 14-25](#retrieving_attributes_metadata_load)使用LINQ的`SingleOrDefault`操作符来查找`PluginInformationAttribute`的条目，如果存在，查询中的`info`变量将持有与相关`CustomAttributeData`对象的引用。然后，代码通过`ConstructorArguments`和`NamedArguments`属性逐步选择构造函数参数和属性值，从而能够检索嵌入在属性中的三个描述性文本值。
- en: As this demonstrates, the `MetadataLoadContext` adds complexity, so you should
    use it only if you need the benefits it offers. One benefit is the fact that it
    won’t run any of the assemblies you load. It can also load assemblies that might
    be rejected if they were loaded normally (e.g., because they target a specific
    processor architecture that doesn’t match your process). But if you don’t need
    the metadata-only option, accessing the attributes directly, as [Example 14-24](#showing_plug-in_information)
    does, is more convenient.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这个例子所示，`MetadataLoadContext`增加了复杂性，因此只有在需要它提供的好处时才应该使用它。其中一个好处是它不会运行您加载的任何程序集。它还可以加载通常会被拒绝加载的程序集（例如，因为它们针对的特定处理器架构与您的进程不匹配）。但是，如果您不需要仅仅是元数据选项，直接访问属性，如[Example 14-24](#showing_plug-in_information)所示，会更加方便。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Attributes provide a way to embed custom data into an assembly’s metadata. You
    can apply attributes to a type, any member of a type, a parameter, a return value,
    or even a whole assembly or one of its modules. A handful of attributes get special
    handling from the CLR, and a few control compiler features, but most have no intrinsic
    behavior, acting merely as passive information containers. Attributes do not even
    get instantiated unless something asks to see them. All of this makes attributes
    most useful in systems with reflection-driven behavior—if you already have one
    of the reflection API objects such as `ParameterInfo` or `Type`, you can ask it
    directly for attributes. You therefore most often see attributes used in frameworks
    that inspect your code with reflection, such as unit test frameworks, serialization
    frameworks, data-driven UI elements like Visual Studio’s Properties panel, or
    plug-in frameworks. If you are using a framework of this kind, you will typically
    be able to configure its behavior by annotating your code with the attributes
    the framework recognizes. If you are writing this sort of framework, then it may
    make sense to define your own attribute types.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 属性为将自定义数据嵌入程序集元数据提供了一种方法。您可以将属性应用于类型、类型的任何成员、参数、返回值，甚至整个程序集或其模块之一。一些属性由CLR特别处理，还有一些控制编译器功能，但大多数属性没有固有行为，仅充当被动信息容器。除非有人要求查看它们，否则属性甚至不会被实例化。所有这些使得属性在反射驱动行为的系统中最为有用——如果您已经有了反射API对象，比如`ParameterInfo`或`Type`，您可以直接向其询问属性。因此，您最常见到的是在检查您的代码的框架中使用属性，比如单元测试框架、序列化框架、像Visual
    Studio属性面板这样的数据驱动UI元素，或者插件框架。如果您使用这类框架，通常可以通过用框架识别的属性注解代码来配置其行为。如果您正在编写这种类型的框架，那么定义自己的属性类型可能是有意义的。
