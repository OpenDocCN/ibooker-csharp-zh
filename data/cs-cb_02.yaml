- en: Chapter 2\. Coding Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 编码算法
- en: We code every day, thinking about the problem we’re solving and ensuring that
    our algorithms work correctly. This is how it should be, and modern tools and
    software development kits increasingly free our time to do just that. Even so,
    there are features of C#, .NET, and coding in general that have significant effects
    on efficiency, performance, and maintainability.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们每天都在编码，思考我们要解决的问题，确保我们的算法正确运行。这就是应该的方式，现代工具和软件开发工具包越来越多地释放我们的时间，专注于这一点。即便如此，C#、.NET和编码中的某些特性仍然显著影响效率、性能和可维护性。
- en: Performance
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能
- en: A few subjects in this chapter discuss application performance, such as the
    efficient handling of strings, caching data, or delaying the instantiation of
    a type until you need it. In some simple scenarios, these things might not matter.
    However, in complex enterprise apps that need the performance and scale, keeping
    an eye on these techniques can help avoid expensive problems in production.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的几个主题讨论了应用程序性能，如高效处理字符串、缓存数据或延迟实例化类型直到需要时。在一些简单的场景中，这些事情可能并不重要。然而，在需要性能和规模的复杂企业应用程序中，关注这些技术可以帮助避免生产中的昂贵问题。
- en: Maintainability
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可维护性
- en: How you organize code can significantly affect its maintainability. Building
    on the discussions in [Chapter 1](ch01.xhtml#constructing_apps_and_types), you’ll
    see a new pattern and strategy and understand how they can help simplify an algorithm
    and make an app more extensible. Another section discusses using recursion for
    naturally occurring hierarchical data. Collecting these techniques and thinking
    about the best way to approach an algorithm can make a significant difference
    in the maintainability and quality of code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如何组织代码显著影响其可维护性。在[第1章](ch01.xhtml#constructing_apps_and_types)的讨论基础上，您将看到一种新的模式和策略，并理解它们如何简化算法并使应用程序更易扩展。另一节讨论了如何在自然发生的分层数据中使用递归。收集这些技术，并思考最佳算法的方法，可以显著提升代码的可维护性和质量。
- en: Mindset
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思维模式
- en: A couple of sections of this chapter might be interesting in specific contexts,
    illustrating different ways to think about solving problems. You might not use
    regular expressions every day, but they’re very useful when you need them. Another
    section, on converting to/from Unix time, looks into the future of .NET as a cross-platform
    language, knowing that we need a certain mindset to think about designing algorithms
    in an environment we might not have ever considered in the past.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的几个部分可能在特定环境下很有趣，展示了解决问题的不同思考方式。你可能不会每天都使用正则表达式，但在需要时它们非常有用。另一部分讨论了如何将时间转换为/从Unix时间，展望了.NET作为跨平台语言的未来，我们需要一种特定的思维方式来设计算法，这可能是我们以前从未考虑过的环境。
- en: 2.1 Processing Strings Efficiently
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.1 高效处理字符串
- en: Problem
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: A profiler indicates a problem in part of your code that builds a large string
    iteratively and you need to improve performance.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器指示您的代码中有问题，它迭代地构建了一个大字符串，您需要提升性能。
- en: Solution
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s an `InvoiceItem` class we’ll be working with:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要使用的`InvoiceItem`类：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This method produces sample data for the demo:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法生成演示的示例数据：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There are two methods for working with strings. First, the inefficient method:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种处理字符串的方法。首先是低效的方法：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next is the more efficient method:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是更高效的方法：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `Main` method ties all of this together:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`方法将所有这些联系在一起：'
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Discussion
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: There are different reasons why we need to gather data into a longer string.
    Reports, whether text based or formatted via HTML or other markup, require combining
    text strings. Sometimes we add items to an email or manually build PDF content
    as an email attachment. Other times we might need to export data in a nonstandard
    format for legacy systems. Too often, developers use string concatenation when
    `StringBuilder` is the superior choice.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有不同的原因需要将数据收集到更长的字符串中。报告，无论是基于文本还是通过HTML或其他标记格式化，都需要组合文本字符串。有时我们将项目添加到电子邮件中，或者手动构建PDF内容作为电子邮件附件。其他时候，我们可能需要以非标准格式导出数据用于遗留系统。开发人员在需要时经常使用字符串连接，而`StringBuilder`则是更优的选择。
- en: String concatenation is intuitive and quick to code, which is why so many people
    do it. However, concatenating strings can also kill application performance. The
    problem occurs because each concatenation performs expensive memory allocations.
    Let’s examine both the wrong way to build strings and the right way.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串连接是直观且编码速度快的操作，这就是为什么有那么多人这样做。然而，字符串连接也可能会降低应用程序的性能。问题出在每次连接都需要进行昂贵的内存分配。让我们看看如何用错误的方法和正确的方法来构建字符串。
- en: The logic in the `DoStringConcatenation` method extracts `Cost` and `Description`
    from each `InvoiceItem` and concatenates that to a growing string. Concatenating
    just a few strings might go unnoticed. However, imagine if this was 25, 50, or
    100 lines or more. Using an example similar to this recipe’s solution, [Recipe
    3.10](ch03.xhtml#measuring_performance) shows how string concatenation is an exponentially
    time-intensive operation that destroys application performance.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`DoStringConcatenation` 方法中的逻辑从每个 `InvoiceItem` 中提取 `Cost` 和 `Description`
    并将其连接到一个增长的字符串中。连接几个字符串可能不会被注意到。但是，想象一下如果有 25、50 或 100 行甚至更多。使用类似本章节解决方案的示例，[Recipe
    3.10](ch03.xhtml#measuring_performance) 展示了字符串连接是一个指数级耗时操作，会严重影响应用程序性能。'
- en: Note
  id: totrans-26
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When concatenating within the same expression, e.g., `string1 + string2`, the
    C# compiler can optimize the code. It’s the loop with concatenation that causes
    the huge performance hit.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个表达式内进行连接，例如，`string1 + string2`，C# 编译器可以优化这段代码。而循环连接则会导致性能急剧下降。
- en: The `DoStringBuilderConcatenation` method fixes this problem. It uses the `StringBuilder`
    class, which is in the `System.Text` namespace. It uses the builder pattern, described
    in [Recipe 1.10](ch01.xhtml#constructing_objects_with_complex_configuration),
    where each `AppendText` adds the new string to the `StringBuilder` instance, `reportsBuilder`.
    Before returning, the method calls `ToString` to convert the `StringBuilder` contents
    to a string.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`DoStringBuilderConcatenation` 方法解决了这个问题。它使用了位于 `System.Text` 命名空间中的 `StringBuilder`
    类。它使用了构建器模式，如 [Recipe 1.10](ch01.xhtml#constructing_objects_with_complex_configuration)
    中描述的那样，每个 `AppendText` 都将新字符串添加到 `StringBuilder` 实例 `reportsBuilder` 中。在返回之前，该方法调用
    `ToString` 方法将 `StringBuilder` 的内容转换为字符串。'
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: As a rule of thumb, once you’ve gone past four string concatenations, you’ll
    receive better performance by using `StringBuilder`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，一旦您超过四个字符串连接，使用 `StringBuilder` 就能获得更好的性能。
- en: Fortunately, the .NET ecosystem has many .NET Framework libraries and third-party
    libraries that help with forming strings of common format. You should use one
    of these libraries whenever possible because they’re often optimized for performance
    and will save time and make the code easier to read. To give you an idea, [Table 2-1](#data-formats-table)
    shows a few libraries to consider for common formats.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，.NET 生态系统中有许多 .NET Framework 库和第三方库，可以帮助处理常见格式的字符串。尽可能使用这些库，因为它们通常经过优化，可以节省时间并使代码更易于阅读。例如，[表 2-1](#data-formats-table)
    展示了一些常见格式的库。
- en: Table 2-1\. Data formats and libraries
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-1\. 数据格式和库
- en: '| Data format | Library |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| Data format | Library |'
- en: '| --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| JSON.NET 5 | System.Text.Json |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| JSON.NET 5 | System.Text.Json |'
- en: '| JSON ⇐ .NET 4.x | Json.NET |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| JSON ⇐ .NET 4.x | Json.NET |'
- en: '| XML | LINQ to XML |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| XML | LINQ to XML |'
- en: '| CSV | LINQ to CSV |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| CSV | LINQ to CSV |'
- en: '| HTML | System.Web.UI.HtmlTextWriter |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| HTML | System.Web.UI.HtmlTextWriter |'
- en: '| PDF | Various commercial and open source providers |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| PDF | 各种商业和开源提供者 |'
- en: '| Excel | Various commercial and open source providers |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| Excel | 各种商业和开源提供者 |'
- en: 'One more thought: custom search and filtering panels are common for giving
    users a simple way to query corporate data. Too frequently, developers use string
    concatenation to build Structured Query Language (SQL) queries. While string concatenation
    is easier, beyond performance, the problem with that is security. String-concatenated
    SQL statements open the opportunity for SQL injection attack. In this case, `StringBuilder`
    isn’t a solution. Instead, you should use a data library that parameterizes user
    input to circumvent SQL injection. There’s ADO.NET, LINQ providers, and other
    third-party data libraries that do input value parameterization for you. For dynamic
    queries, using a data library might be harder, but it is possible. You might want
    to seriously consider using LINQ, which I discuss in [Chapter 4](ch04.xhtml#querying_with_linq).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个想法：自定义搜索和过滤面板通常用于为用户提供查询企业数据的简单方式。开发人员经常使用字符串连接来构建结构化查询语言（SQL）查询。虽然字符串连接更简单，但除了性能之外，它的问题在于安全性。字符串连接的
    SQL 语句打开了 SQL 注入攻击的机会。在这种情况下，`StringBuilder` 不是一个解决方案。相反，你应该使用一个数据库库来对用户输入进行参数化，以避免
    SQL 注入。有 ADO.NET、LINQ 提供程序和其他第三方数据库库可以为你进行输入值参数化。对于动态查询，使用数据库库可能更难，但是可以做到。你可能需要认真考虑使用
    LINQ，我在 [第 4 章](ch04.xhtml#querying_with_linq) 中有讨论。
- en: See Also
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Recipe 1.10, “Constructing Objects with Complex Configuration”](ch01.xhtml#constructing_objects_with_complex_configuration)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[配方 1.10，“构造具有复杂配置的对象”](ch01.xhtml#constructing_objects_with_complex_configuration)'
- en: '[Recipe 3.10, “Measuring Performance”](ch03.xhtml#measuring_performance)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[配方 3.10，“性能测量”](ch03.xhtml#measuring_performance)'
- en: '[Chapter 4, “*Querying with LINQ*”](ch04.xhtml#querying_with_linq)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 4 章，“*使用 LINQ 进行查询*”](ch04.xhtml#querying_with_linq)'
- en: 2.2 Simplifying Instance Cleanup
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.2 简化实例清理
- en: Problem
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Old `using` statements cause unnecessary nesting and you want to clean up and
    simplify code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 旧的 `using` 语句会导致不必要的嵌套，你希望清理和简化代码。
- en: Solution
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This program has `using` statements for reading and writing to a text file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序有用于读写文本文件的 `using` 语句：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Discussion
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Before C# 8, `using` statement syntax required parentheses for `IDisposable`
    object instantiation and an enclosing block. During runtime, when the program
    reached the closing block, it would call `Dispose` on the instantiated object.
    If you needed multiple `using` statements to operate at the same time, developers
    would often nest them, resulting in extra space in addition to normal statement
    nesting. This pattern was enough of an annoyance to some developers that Microsoft
    added a feature to the language to simplify `using` statements.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 8 之前，`using` 语句的语法要求对 `IDisposable` 对象进行实例化并且包含一个封闭的代码块。在运行时，当程序执行到封闭的代码块时，会调用实例化对象的
    `Dispose` 方法。如果需要多个 `using` 语句同时操作，开发人员通常会将它们嵌套，导致除了正常语句嵌套之外还有额外的空间。对一些开发人员来说，这种模式已经足够恼人，以至于微软为语言添加了一个功能来简化
    `using` 语句。
- en: 'In the solution, you can see a couple of places where the new `using` statement
    syntax occurs: instantiating the `StreamWriter` in `WriteDetails` and instantiating
    the `StreamReader` in `ReadDetails`. In both cases, the `using` statement is on
    a single line. Gone are the parentheses and curly braces, and each statement terminates
    with a semicolon.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中，你可以看到新的 `using` 语句语法出现在几个地方：在 `WriteDetails` 中实例化 `StreamWriter` 和在 `ReadDetails`
    中实例化 `StreamReader`。在这两种情况下，`using` 语句都是单行的。括号和花括号已经消失，每个语句以分号结尾。
- en: The scope of the new `using` statement is its enclosing block, calling the `using`
    object’s `Dispose` method when execution reaches the end of the enclosing block.
    In the solution, the enclosing block is the method, which causes each `using`
    object’s `Dispose` method to be called at the end of the method.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 新 `using` 语句的作用域是其封闭的代码块，在执行到封闭的代码块的末尾时调用 `using` 对象的 `Dispose` 方法。在解决方案中，封闭的代码块是方法，这会导致每个
    `using` 对象的 `Dispose` 方法在方法结束时被调用。
- en: What’s different about the single-line `using` statement is that it will work
    with both `IDisposable` objects and objects that implement a disposable pattern.
    In this context, a disposable pattern means that the object doesn’t implement
    `IDisposable`, yet it has a parameterless `Dispose` method.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 单行 `using` 语句的不同之处在于它适用于既实现 `IDisposable` 接口又实现可释放模式的对象。在这个上下文中，可释放模式意味着对象不实现
    `IDisposable`，但它有一个无参数的 `Dispose` 方法。
- en: See Also
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Recipe 1.1, “Managing Object End-of-Lifetime”](ch01.xhtml#managing_object_lifetime)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[配方 1.1，“管理对象的生命周期”](ch01.xhtml#managing_object_lifetime)'
- en: 2.3 Keeping Logic Local
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.3 保持逻辑局部化
- en: Problem
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: An algorithm has complex logic that is better refactored to another method,
    but the logic is really only used in one place.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 算法具有复杂的逻辑，最好将其重构为另一个方法，但这些逻辑实际上只在一个地方使用。
- en: Solution
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'The program uses the `CustomerType` and `InvoiceItem`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用了`CustomerType`和`InvoiceItem`：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This method generates and returns a demo set of invoices:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法生成并返回一组演示发票：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, the `Main` method shows how to use a local function:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Main`方法展示了如何使用局部函数：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Discussion
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Local methods are useful whenever code is only relevant to a single method and
    you want to isolate that code. Reasons for isolating code are to give meaning
    to a set of complex logic, reuse logic and simplify calling code (perhaps a loop),
    or allow an async method to throw an exception before awaiting the enclosing method.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码仅与单个方法相关且希望隔离该代码时，局部方法非常有用。隔离代码的原因包括赋予一组复杂逻辑以意义、重用逻辑和简化调用代码（也许是一个循环），或者允许异步方法在等待封闭方法之前抛出异常。
- en: The `Main` method in the solution has a local method, named `ApplyDiscount`.
    This example demonstrates how a local method can simplify code. If you examine
    the code in `ApplyDiscount`, it might not be immediately clear what its purpose
    is. However, by separating that logic into its own method, anyone can read the
    method name and know what the purpose of the logic is. This is a great way to
    make code more maintainable, by expressing intent and making that logic local
    where another developer won’t need to hunt for a class method that might move
    around after future maintenance.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案中的`Main`方法具有一个名为`ApplyDiscount`的局部方法。此示例演示了局部方法如何简化代码。如果您检查`ApplyDiscount`中的代码，可能不会立即清楚其目的是什么。然而，通过将该逻辑分离到自己的方法中，任何人都可以阅读方法名称并知道逻辑的目的是什么。这是通过表达意图并使该逻辑局部化来使代码更易于维护的一个很好的方法，而其他开发人员不需要搜索可能在未来维护后移动的类方法。
- en: 2.4 Operating on Multiple Classes the Same Way
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.4 在多个类上执行相同操作
- en: Problem
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: An application must be extensible, for adding new plug-in capabilities, but
    you don’t want to rewrite existing code for new classes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序必须是可扩展的，以添加新的插件功能，但不希望为新的类重写现有代码。
- en: Solution
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This is a common interface for several classes to implement:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是几个类共同实现的常见接口：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here are a few classes that implement `IInvoice`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个实现了`IInvoice`接口的类：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This method populates a collection with objects that implement `IInvoice`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用实现了`IInvoice`接口的对象填充集合：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `Main` method has an algorithm that operates on the `IInvoice` interface:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`方法具有操作`IInvoice`接口的算法：'
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Discussion
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: As a developer’s career progresses, chances are they’ll encounter requirements
    that customers want an application to be “extensible.” Although the exact meaning
    is imprecise to even the most seasoned architects, there’s a general understanding
    that “extensibility” should be a theme in the application’s design. We generally
    move in this direction by identifying areas of the application that can and will
    change over time. Patterns can help with this, such as the factory classes of
    [Recipe 1.3](ch01.xhtml#delegating_object_creation_to_a_class), factory methods
    of [Recipe 1.4](ch01.xhtml#delegating_object_creation_to_a_method), and builders
    in [Recipe 1.10](ch01.xhtml#constructing_objects_with_complex_configuration).
    In a similar light, the strategy pattern described in this section helps organize
    code for extensibility.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 随着开发人员职业的进展，他们很可能会遇到客户希望应用程序具有“可扩展性”的要求。尽管即使对经验丰富的架构师来说，确切的含义也不精确，但普遍理解的是，“可扩展性”应该成为应用程序设计的一个主题。我们通常通过识别随时间可以和将会发生变化的应用程序区域来朝这个方向发展。设计模式可以帮助实现这一点，比如[食谱
    1.3](ch01.xhtml#delegating_object_creation_to_a_class)中的工厂类、[食谱 1.4](ch01.xhtml#delegating_object_creation_to_a_method)中的工厂方法以及[食谱
    1.10](ch01.xhtml#constructing_objects_with_complex_configuration)中的构建器。类似地，本节中描述的策略模式有助于组织可扩展性的代码。
- en: The strategy pattern is useful when there are multiple object types to work
    with at the same time and you want them to be interchangeable and write code one
    time that operates on each object the same way. In object-oriented terms, this
    is interface polymorphism. The software we use every day are classic examples
    of where a strategy could work. Office applications have different document types
    and allow developers to write their own add-ins. Browsers have add-ins that developers
    can write. The editors and integrated development environments (IDEs) you use
    every day have plug-in capabilities.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式在同时处理多种对象类型并希望它们可互换，并且希望只编写一次可以对每个对象执行相同操作的代码时非常有用。从面向对象的角度来看，这是接口多态性。我们每天使用的软件是策略模式的典型例子。办公应用程序有不同的文档类型，并允许开发人员编写自己的插件。浏览器有开发人员可以编写的插件。您每天使用的编辑器和集成开发环境（IDE）具有插件功能。
- en: The solution describes an application that operates on different types of invoices
    in the domains of banking, enterprise, and government. Each of these domains has
    its own business rules related to legal or other requirements. What makes this
    extensible is the fact that, in the future, we can add another class to handle
    invoices in another domain.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 该解决方案描述了在银行、企业和政府领域中操作不同类型发票的应用程序。每个领域都有其自己的与法律或其他要求相关的业务规则。使其可扩展的原因在于，将来我们可以添加另一个处理另一个领域发票的类。
- en: The glue to making this work is the `IInvoice` interface. It contains the required
    methods (or contract) that each implementing class must define. You can see that
    the `BankInvoice`, `EnterpriseInvoice`, and `GovernmentInvoices` each implement
    `IInvoice`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使其工作的关键是`IInvoice`接口。它包含每个实现类必须定义的必需方法（或合同）。你可以看到，`BankInvoice`、`EnterpriseInvoice`和`GovernmentInvoices`都实现了`IInvoice`。
- en: '`GetInvoices` simulates the situation where you would write code to populate
    invoices from a data source. Whenever you need to extend the framework, by adding
    a new `IInvoice` derived type, this is the only code that changes. Because all
    classes are `IInvoice`, they can all be returned via the same `IEnumerable<IInvoice>`
    collection.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetInvoices`模拟了您将从数据源填充发票的情况。每当需要通过添加新的`IInvoice`派生类型来扩展框架时，这是唯一会改变的代码。因为所有类都是`IInvoice`，所以它们都可以通过同一个`IEnumerable<IInvoice>`集合返回。'
- en: Note
  id: totrans-91
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Even though the `GetInvoices` implementation operated on `List<IInvoice>`, it
    returned an `IEnumerable<IInvoice>` from `GetInvoices`. By returning an interface
    here, `IEnumerable<T>`, callers don’t make any assumptions about the underlying
    collection implementation. That way, a future version of `GetInvoices` could potentially
    work with another collection type that implemented `IEnumerable<T>` if that other
    collection type was better for the new implementation. The benefit is that the
    code can change without changing the method signature and not break calling code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`GetInvoices`实现是在`List<IInvoice>`上操作的，它却从`GetInvoices`中返回了一个`IEnumerable<IInvoice>`。通过在这里返回一个接口`IEnumerable<T>`，调用者不对底层集合实现做任何假设。这样一来，如果将来`GetInvoices`的另一个实现更适合另一种实现类型，那么代码就可以更改而不更改方法签名，并且不会破坏调用代码。
- en: Finally, examine the `Main` method. It iterates on each `IInvoice` object, calling
    its methods. `Main` doesn’t care what the specific implementation is, and so its
    code never needs to change to accommodate instance-specific logic. You don’t need
    `if` or `switch` statements for special cases, which blow up into spaghetti code
    in maintenance. Any future changes will be on how `Main` works with the `IInvoice`
    interface. Any changes to business logic associated with invoices is limited to
    the invoice types themselves. This is easy to maintain, and it’s easy to figure
    out where logic is and should be. Further, it’s also easy to extend by adding
    a new plug-in class that implements `IInvoice`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请检查`Main`方法。它迭代每个`IInvoice`对象，调用其方法。`Main`不关心具体的实现是什么，因此其代码永远不需要改变以适应特定实例的逻辑。你不需要为特殊情况编写`if`或`switch`语句，这样会在维护时导致代码复杂难以维护。任何未来的更改将涉及`Main`如何与`IInvoice`接口一起工作。与发票相关的业务逻辑的任何更改都限于发票类型本身。这样易于维护，也容易确定逻辑的存在和应有的位置。此外，通过添加实现`IInvoice`的新插件类，还可以轻松扩展。
- en: See Also
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 1.3, “Delegating Object Creation to a Class”](ch01.xhtml#delegating_object_creation_to_a_class)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 1.3，“将对象创建委托给一个类”](ch01.xhtml#delegating_object_creation_to_a_class)'
- en: '[Recipe 1.4, “Delegating Object Creation to a Method”](ch01.xhtml#delegating_object_creation_to_a_method)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[配方 1.4，“将对象创建委托给方法”](ch01.xhtml#delegating_object_creation_to_a_method)'
- en: '[Recipe 1.10, “Constructing Objects with Complex Configuration”](ch01.xhtml#constructing_objects_with_complex_configuration)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[配方 1.10，“使用复杂配置构造对象”](ch01.xhtml#constructing_objects_with_complex_configuration)'
- en: 2.5 Checking for Type Equality
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.5 检查类型的相等性
- en: Problem
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to search for objects in a collection, and default equality won’t work.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在集合中搜索对象，而默认相等性无法胜任。
- en: Solution
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'The `Invoice` class implements `IEquatable<T>`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Invoice` 类实现了 `IEquatable<T>` 接口：'
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This code returns a collection of `Invoice` classes:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码返回一个 `Invoice` 类的集合：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here’s how to use the `Invoice` class:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Invoice` 类的方法如下：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Discussion
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The default equality semantics for reference types is reference equality and
    for value types is value equality. Reference equality means that when comparing
    objects, these objects are equal when their references refer to the same exact
    object instance. Value equality occurs when each member of an object is compared
    before two objects are considered equal. The problem with reference equality is
    that sometimes you have two instances of the same class, but you really want to
    compare their corresponding members to see if they are equal. Value equality might
    also pose a problem because you might only want to check part of the object to
    see if they’re equal.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型的默认相等性语义是引用相等性，而值类型的是值相等性。引用相等性意味着当比较对象时，这些对象仅在它们的引用指向同一个确切的对象实例时才相等。值相等性发生在比较对象的每个成员之前，这两个对象才被视为相等。引用相等性的问题在于，有时你有两个相同类的实例，但实际上想要比较它们的对应成员是否相等。值相等性可能也会带来问题，因为有时你可能只想检查对象的部分内容是否相等。
- en: To solve the problem of inadequate default equality, the solution implements
    custom equality on `Invoice`. The `Invoice` class implements the `IEquatable<T>`
    interface, where `T` is `Invoice`. Although `IEquatable<T>` requires an `Equals(T
    other)` method, you should also implement `Equals(object other)`, `GetHashCode()`,
    and the `==` and `!=` operators, resulting in a consistent definition of equality
    for all scenarios.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为解决默认相等性不足的问题，解决方案在 `Invoice` 上实现了自定义相等性。`Invoice` 类实现了 `IEquatable<T>` 接口，其中
    `T` 是 `Invoice`。尽管 `IEquatable<T>` 要求实现 `Equals(T other)` 方法，你还应该实现 `Equals(object
    other)`、`GetHashCode()` 方法以及 `==` 和 `!=` 操作符，以确保在所有情况下都有一致的相等性定义。
- en: There’s a lot of science in picking a good hash code, which is out of scope
    for this book, so the solution implementation is minimal.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择一个良好的哈希码时涉及很多科学问题，这超出了本书的范围，因此解决方案的实现是最小的。
- en: Note
  id: totrans-112
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: C# 9.0 Records give you `IEquatable<T>` logic by default. However, Records give
    you value equality, and you would want to implement `IEquatable<T>` yourself if
    you needed to be more specific. For instance, if your object has free-form text
    fields that don’t contribute to the identity of the object, why waste resources
    doing the unnecessary field comparisons? Another problem (maybe more rare) could
    be that some parts of a record might be different for temporal reasons, e.g.,
    temporary timestamps, status, or globally unique identifiers (GUIDs) that will
    cause the objects to never be equal during processing.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: C# 9.0 记录（Records）默认为你提供了 `IEquatable<T>` 逻辑。然而，记录（Records）提供了值相等性，如果需要更具体的实现
    `IEquatable<T>`，你需要自行实现。例如，如果你的对象具有不影响对象标识的自由文本字段，为何要浪费资源进行不必要的字段比较？另一个问题（可能更少见）可能是记录的某些部分基于时间原因会有所不同，例如临时时间戳、状态或全局唯一标识符（GUID），这将导致对象在处理过程中永远不相等。
- en: The equality implementation avoids repeating code. The `!=` operator invokes
    (and negates) the `==` operator. The `==` operator checks references and returns
    `true` if both references are `null` and `false` if only one reference is `null`.
    Both the `==` operator and the `Equals(object other)` method call the `Equals(Invoice
    other)` method.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 相等性实现避免了重复的代码。`!=` 操作符调用并取反 `==` 操作符。`==` 操作符检查引用并在两个引用都为 `null` 时返回 `true`，在只有一个引用为
    `null` 时返回 `false`。`==` 操作符和 `Equals(object other)` 方法都调用 `Equals(Invoice other)`
    方法。
- en: The current instance is clearly not `null`, so `Equals(Invoice other)` only
    checks the `other` reference and returns `false` if it’s `null`. Then it checks
    to see if `this` and `other` have reference equality, which would obviously mean
    they are equal. Then, if the objects aren’t the same type, they are not considered
    equal. Finally, return the results of the values to compare. In this example,
    the only things that make sense are the `CustomerID` and `Date`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当前实例显然不是 `null`，因此 `Equals(Invoice other)` 只检查 `other` 引用，如果它是 `null`，则返回 `false`。然后检查
    `this` 和 `other` 是否具有引用相等性，这显然意味着它们是相等的。然后，如果对象不是相同类型，则不被认为是相等的。最后，返回要比较的值的结果。在这个例子中，唯一有意义的是
    `CustomerID` 和 `Date`。
- en: Note
  id: totrans-116
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: One part of the `Equals(Invoice other)` method that you might change is the
    type check. You could have a different opinion, based on the requirements of your
    application. e.g., what if you wanted to check equality even if `other` was a
    derived type? Then change the logic to accept derived types also.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`Equals(Invoice other)` 方法中可以改变的一部分是类型检查。您可能会根据应用程序的要求有不同的看法。例如，如果希望即使 `other`
    是派生类型也能检查相等性，则更改逻辑以接受派生类型。'
- en: The `Main` method processes invoices, ensuring we don’t add duplicate invoices
    to a list. The loop calls the collection `Contains` method, which checks the object’s
    equality. If there isn’t a matching object, `Contains` adds the new `Invoice`
    instance to the `invoicesToProcess` list. When running the program, there are
    four invoices that exist in `allInvoices`, but only three are added to `invoicesToProcess`
    because there’s one duplicate (based on `CustomerID` and `Created`) in `allInvoices`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法处理发票，确保我们不会将重复的发票添加到列表中。循环调用集合的 `Contains` 方法，检查对象的相等性。如果没有匹配的对象，`Contains`
    将新的 `Invoice` 实例添加到 `invoicesToProcess` 列表中。运行程序时，在 `allInvoices` 中存在四张发票，但只有三张添加到
    `invoicesToProcess` 中，因为在 `allInvoices` 中有一个重复（基于 `CustomerID` 和 `Created`）。'
- en: 2.6 Processing Data Hierarchies
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.6 处理数据层次结构
- en: Problem
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: An app needs to work with hierarchical data, and an iterative approach is too
    complex and unnatural.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序需要处理层次数据，而迭代方法过于复杂和不自然。
- en: Solution
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This is the format of data we’re starting with:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们要处理的数据格式：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This method returns a collection of hierarchically related records:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回一组层次相关的记录：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is a recursive algorithm that transforms the flat data into a hierarchical
    form:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将扁平数据转换为层次形式的递归算法：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `Main` method runs the program and prints out the hierarchical data:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法运行程序并打印层次数据：'
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Discussion
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: It’s hard to tell how many times you have or will encounter iterative algorithms
    with complex logic and conditions on how the loop operates. Loops like `for`,
    `foreach`, and `while` are familiar and often used, even when more elegant solutions
    are available. I’m not suggesting there’s anything wrong with loops, which are
    integral parts of our language toolset. However, it’s useful to expand our minds
    to other techniques that might lend themselves to more elegant and maintainable
    code for given situations. Sometimes a declarative approach, like a lambda on
    a collection’s `ForEach` operator, is simple and clear. LINQ is a nice solution
    for working with object collections in memory, which is the subject of [Chapter 4](ch04.xhtml#querying_with_linq).
    Another alternative is recursion—the subject of this section.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 很难判断您将如何多次遇到迭代算法，其复杂逻辑和循环操作的条件。`for`、`foreach` 和 `while` 这样的循环是熟悉且经常使用的，即使有更优雅的解决方案存在。我并不是在暗示循环有什么问题，它们是语言工具集的重要部分。然而，对于给定情况，扩展我们的思维以探索其他可能更优雅和可维护的代码技术是有用的。有时候，像集合的
    `ForEach` 操作符上的 lambda 表达式这样的声明性方法是简单明了的。LINQ 是处理内存中对象集合的良好解决方案，这是 [第四章](ch04.xhtml#querying_with_linq)
    的主题。递归是本节的另一种选择。
- en: The main point I’m making here is that we need to write algorithms using the
    techniques that are most natural for a given situation. A lot of algorithms do
    use loops naturally, like iterating through a collection. Other tasks beckon for
    recursion. A class of algorithms that work on hierarchies might be excellent candidates
    for recursion.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里要表达的主要观点是，我们需要根据具体情况编写使用最自然的技术的算法。很多算法确实自然地使用循环，如遍历集合。其他任务可能需要递归。处理层次结构的一类算法可能非常适合使用递归。
- en: The solution demonstrates one of the areas where recursion simplifies processing
    and makes the code clear. It processes a list of categories based on billing.
    Notice that the `BillingCategory` class has both an `ID` and a `Parent`. These
    manage the hierarchy, where the `Parent` identifies the parent category. Any `BillingCategory`
    with a `null` `Parent` is a top-level category. This is a single table relational
    database (DB) representation of hierarchical data.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此解决方案展示了递归简化处理和使代码清晰的一个领域。它基于计费处理类别列表。请注意，`BillingCategory`类具有`ID`和`Parent`两个属性。这些属性管理层次结构，其中`Parent`标识父类别。任何具有`null`
    `Parent`的`BillingCategory`都是顶级类别。这是单表关系数据库（DB）表示的分层数据。
- en: The `GetBillingCategories` represents how the `BillingCategories` arrive from
    a DB. It’s a flat structure. Notice how the `Parent` properties reference their
    parent `BillingCategory` IDs. Another important fact about the data is that there
    isn’t a clean ordering between parents and children. In a real application, you’ll
    start off with a given set of categories and add new categories later. Again,
    maintenance in code and data over time changes how we approach algorithm design,
    and this would complicate an iterative solution.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetBillingCategories`展示了`BillingCategories`如何从数据库中获取。它是一个平面结构。请注意，`Parent`属性引用它们的父`BillingCategory`的ID。关于数据的另一个重要事实是父子之间没有明确的排序。在实际应用中，你将从给定的类别集开始，并随后添加新的类别。同样，随着时间在代码和数据的维护中变化，这会改变我们对算法设计的方法，从而复杂化迭代解决方案。'
- en: The purpose of this solution is to take the flat category representation and
    transform it into another list that represents the hierarchical relationship between
    categories. This was a simple solution, but you might imagine an object-based
    representation where parent categories contained a collection with child categories.
    The recursive algorithm that does this is the `BuildHierarchy` method.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案的目的是将平面类别表示转换为另一个列表，该列表表示类别之间的层次关系。这是一个简单的解决方案，但你可以想象一个基于对象的表示，其中父类别包含一个子类别集合。执行此操作的递归算法是`BuildHierarchy`方法。
- en: 'The `BuildHierarchy` method accepts three parameters: `categories`, `catID`,
    and `level`. The `categories` parameter is the flat collection from the DB and
    every recursive call receives a reference to this same collection. A potential
    optimization might be to remove categories that have already been processed, though
    the demo avoids anything distracting from presented concepts. The `catID` parameter
    is the `ID` for the current `BillingCategory`, and the code is searching for all
    subcategories whose `Parent` matches `catID`—as demonstrated by the `if` statement
    inside the `foreach` loop. The `level` parameter helps manage the visual representation
    of each category. The first statement inside the `if` block uses `level` to determine
    how many tabs (`\t`) to prefix to the category name. Every time we make a recursive
    call to `BuildHierarchy`, we increment `level` so that subcategories are indented
    more than their parents.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`BuildHierarchy`方法接受三个参数：`categories`、`catID`和`level`。`categories`参数是来自数据库的平面集合，每次递归调用都会接收到对同一集合的引用。一个潜在的优化可能是移除已经处理过的类别，尽管演示避免了任何会分散注意力的内容。`catID`参数是当前`BillingCategory`的`ID`，代码正在寻找其`Parent`匹配`catID`的所有子类别，正如`foreach`循环内部的`if`语句所示。`level`参数有助于管理每个类别的视觉表示。`if`块内的第一条语句使用`level`确定在类别名称前加上多少制表符（`\t`）。每次递归调用`BuildHierarchy`时，我们会增加`level`，以便子类别比其父类别缩进更多。'
- en: The algorithm calls `BuildHierarchy` with the same categories collection. Also,
    it uses the `ID` of the current category, not the `catID` parameter. This means
    that it recursively calls `BuildHierarchy` until it reaches the bottom-most categories.
    It will know it’s at the bottom of the hierarchy because the `foreach` loop completes
    with no new categories, because there aren’t any subcategories for the current
    (bottom) category.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 算法使用相同的类别集合调用`BuildHierarchy`。此外，它使用当前类别的`ID`，而不是`catID`参数。这意味着它递归调用`BuildHierarchy`，直到达到最底层的类别。它会通过`foreach`循环完成且没有新的类别，因为当前（最底层）类别没有子类别时，确定它位于层次结构的底部。
- en: After reaching the bottom, `BuildHierarchy` returns and continues the `foreach`
    loop, collecting all of the categories under the `catID`—that is, their `Parent`
    is `catID`. Then it appends any matching subcategories to the `found` collection
    to the calling `BuildHierarchy`. This continues until the algorithm reaches the
    top level and all root categories are processed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 到达底部后，`BuildHierarchy` 返回并继续 `foreach` 循环，收集 `catID` 下的所有类别——即它们的 `Parent` 是
    `catID`。然后将任何匹配的子类别附加到调用 `BuildHierarchy` 的 `found` 集合中。这将继续，直到算法达到顶层并处理所有根类别。
- en: Note
  id: totrans-140
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The recursive algorithm in this solution is referred to as depth-first search
    (DFS).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此解决方案中的递归算法称为深度优先搜索（DFS）。
- en: 'Having arrived at the top level, `BuildHierarchy` returns the entire collection
    to its original caller, which is `Main`. `Main` originally called `BuildHierarchy`
    with the entire flat `categories` collection. It set `catID` to `null`, indicating
    that `BuildHierarchy` should start at the root level. The `level` argument is
    `0`, indicating that we don’t want any tab prefixes on root-level category names.
    Here’s the output:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 到达顶层后，`BuildHierarchy` 将整个集合返回给其原始调用者，即 `Main`。`Main` 最初使用整个平面 `categories`
    集合调用 `BuildHierarchy`。它将 `catID` 设置为 `null`，表示 `BuildHierarchy` 应从根级别开始。`level`
    参数为 `0`，表示我们不希望在根级别类别名称上使用任何制表符前缀。这是输出：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Looking back at the `GetBillingCategories` method, you can see how the visual
    representation matches the data.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾 `GetBillingCategories` 方法时，您可以看到视觉表示与数据匹配的方式。
- en: 2.7 Converting from/to Unix Time
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.7 从/到 Unix 时间的转换
- en: Problem
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: A service is sending date information in seconds or ticks since the Linux epoch
    needs to be converted to a C#/.NET `DateTime`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 服务将日期信息发送为自Linux纪元以来的秒或滴答，需要转换为C#/.NET `DateTime`。
- en: Solution
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here are some values we’ll be using:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将使用的一些值：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'These methods convert from and to Linux epoch timestamps:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法转换为和从 Linux 纪元时间戳：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `Main` method demonstrates how to use those methods:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法演示如何使用这些方法：'
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Discussion
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Sometimes developers represent date/time data as milliseconds or ticks in a
    database. Ticks are measured as 100 nanoseconds. Both milliseconds and ticks represent
    time starting at a predefined epoch, which is some point in time that is the minimum
    date for a computing platform. For .NET, the epoch is 01/01/0001 00:00:00, corresponding
    to the `WindowsEpoch` field in the solution. This is the same as `DateTime.MinValue`,
    but defining it this way makes the example more explicit. For MacOS, the epoch
    is 1 January 1904, and for Linux, the epoch is 1 January 1970, as shown by the
    `Linux​E⁠poch` field in the solution.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有时开发人员在数据库中表示日期/时间数据为毫秒或滴答。滴答以100纳秒为单位计量。毫秒和滴答都表示从预定义纪元开始的时间，这是计算平台的最小日期。对于.NET，纪元是
    01/01/0001 00:00:00，对应解决方案中的 `WindowsEpoch` 字段。这与 `DateTime.MinValue` 相同，但以这种方式定义使示例更加明确。对于
    MacOS，纪元是 1904 年 1 月 1 日，对于 Linux，纪元是 1970 年 1 月 1 日，如解决方案中的 `LinuxEpoch` 字段所示。
- en: Note
  id: totrans-157
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There are various opinions on whether representing `DateTime` values as milliseconds
    or ticks is a proper design. However, I leave that debate to other people and
    venues. My habit is to use the `DateTime` format of the database I’m using. I
    also translate the `DateTime` to UTC because many apps need to exist beyond the
    local time zone and you need consistent translatable representation.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 关于将 `DateTime` 值表示为毫秒或滴答作为适当设计存在各种意见。但是，我将这场辩论留给其他人和场合。我的习惯是使用我正在使用的数据库的 `DateTime`
    格式。我还将 `DateTime` 转换为 UTC，因为许多应用程序需要存在超出本地时区，并且您需要一致的可转换表示。
- en: Increasingly, developers are more likely to encounter situations where they
    need to build cross-platform solutions or integrate with a third-party system
    with milliseconds or ticks based on a different epoch. For instance, the Twitter
    API began using milliseconds based on the Linux epoch in their 2020 version 2.0
    release. The solution example is inspired by code that works with milliseconds
    from Twitter API responses. The release of .NET Core gave us cross-platform capabilities
    for C# developers for console and ASP.NET MVC Core applications. .NET 5 continues
    the cross-platform story and the roadmap for .NET 6 includes the first rich GUI
    interface, codenamed Maui. If you’ve been accustomed to working solely in the
    Microsoft and .NET platforms, this should indicate that things continue to change
    along the type of thinking required for future development.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 越来越多的开发人员可能会遇到需要构建跨平台解决方案或与基于不同纪元的第三方系统集成的情况，例如，Twitter API在其2020年版本2.0中开始使用基于Linux纪元的毫秒数。解决方案示例受到处理来自Twitter
    API响应的毫秒的代码启发。.NET Core的发布为C#开发人员提供了控制台和ASP.NET MVC Core应用程序的跨平台能力。.NET 5继续跨平台故事，.NET
    6的路线图包括第一个丰富的GUI界面，代号Maui。如果您习惯于仅在Microsoft和.NET平台上工作，这应表明事物继续沿着未来开发所需的类型思维发展。
- en: The `ToLinuxTimestampFromDateTime` takes a .NET `DateTime` and converts it to
    a Linux timestamp. The Linux timestamp is the number of milliseconds from the
    Linux epoch. Since we’re working in milliseconds, the `TimeSpan` converts the
    `DateTime` ticks to milliseconds. To perform the conversion, we subtract the number
    of milliseconds between the .NET time and the equivalent Linux time, which we
    precalculated in `EpochMillisecondDifference` by subtracting the .NET (Windows)
    epoch from the Linux epoch. After the conversion, we need to round the value to
    eliminate excess precision. The default to `Math.Round` uses what’s called Bankers’
    Rounding, which is often not what we need, so the overload with `MidpointRounding.AwayFromZero`
    does the rounding we expect. The solution returns the final value as a string,
    and you can change that for what makes sense for your implementation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToLinuxTimestampFromDateTime`接受一个.NET `DateTime`并将其转换为Linux时间戳。Linux时间戳是从Linux纪元开始的毫秒数。由于我们在毫秒级别工作，`TimeSpan`将`DateTime`的刻度转换为毫秒。为了进行转换，我们从.NET时间和等效Linux时间之间的毫秒数中减去了数量，在`EpochMillisecondDifference`中通过从Linux纪元减去.NET（Windows）纪元进行预计算。转换后，我们需要将值四舍五入以消除过多的精度。默认的`Math.Round`使用所谓的银行家舍入，这通常不是我们所需要的，因此使用带有`MidpointRounding.AwayFromZero`的重载进行我们期望的舍入。解决方案将最终值作为字符串返回，您可以根据您的实现需求进行更改。'
- en: 'The `ToDateTimeFromLinuxTimestamp` method is remarkably simpler. After converting
    to a `ulong`, it creates a new timestamp from the milliseconds and adds that to
    the LinuxEpoch. Here’s the output from the `Main` method:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToDateTimeFromLinuxTimestamp`方法非常简单。将其转换为`ulong`后，它从毫秒创建一个新的时间戳，并将其加到LinuxEpoch上。以下是`Main`方法的输出：'
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, `DateTime.MinValue` is the same as the Windows epoch. Using
    1/1/2021 as a good date (at least we hope so), `Main` starts by properly converting
    that date to a Linux timestamp. Then it shows the wrong way to process that date.
    Finally, it calls `ToDateTimeFromLinuxTimestamp`, performing the proper translation.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`DateTime.MinValue`与Windows纪元相同。使用2021年1月1日作为一个好日期（至少我们希望如此），`Main`通过将该日期正确转换为Linux时间戳来开始。然后显示了处理该日期的错误方法。最后，它调用`ToDateTimeFromLinuxTimestamp`，执行正确的转换。
- en: 2.8 Caching Frequently Requested Data
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.8 缓存频繁请求的数据
- en: Problem
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Network latency is causing an app to run slowly because static, frequently used
    data is being fetched too often.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 网络延迟导致应用程序运行缓慢，因为静态且经常使用的数据经常被获取。
- en: Solution
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s the type of data that will be cached:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将被缓存的数据类型：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is the interface for the repository that retrieves the data:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是检索数据的存储库的接口：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is the repository that retrieves and caches the data:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是检索和缓存数据的存储库：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here’s the program that uses that repository:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用该存储库的程序：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Discussion
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Depending on the technology you’re using, there could be plenty of options for
    caching data through mechanisms like CDN, HTTP, and data source solutions. Each
    has a place and purpose, and this section doesn’t try to cover all of those options.
    Rather, it just has a quick and simple technique for caching data that could be
    helpful in many scenarios.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您使用的技术，可能有很多通过CDN、HTTP和数据源解决方案等机制缓存数据的选项。每种方法都有其适用的场景和目的，本节仅介绍了一种快速简单的数据缓存技术，适用于许多情况。
- en: You might have experienced a scenario where there’s a set of data used in a
    lot of different places. The nature of the data is typically lookup lists or business
    rule data. In the course of everyday work, we build queries that include this
    data either in direct select queries or in the form of database table joins. We
    forget about it until someone starts complaining about application performance.
    Analysis might reveal that there are a lot of queries that request that same data
    over and over again. If it’s practical, you can cache that data in memory to avoid
    network latency exacerbated by excessive queries to the same set of data.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能遇到过一种情况，即在许多不同地方使用一组数据。这些数据通常是查找列表或业务规则数据的性质。在日常工作中，我们构建包含这些数据的查询，可以直接选择查询，也可以作为数据库表连接的形式存在。直到有人开始抱怨应用程序性能时，我们才会注意到这一点。分析可能会显示，有大量查询不断请求相同的数据集。如果可行，您可以将这些数据缓存在内存中，以避免网络延迟因对相同数据集的过多查询而加剧。
- en: This isn’t a blanket solution because you have to think about whether it’s practical
    in your situation. For example, it’s impractical to hold too much data in memory,
    which will cause other scalability problems. Ideally, it’s a finite and relatively
    small set of data, like invoice categories. That data shouldn’t change too often
    because if you need real-time access to dynamic data, this won’t work. If the
    underlying data source changes, the cache is likely to be holding the old stale
    data.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是一个适用于所有情况的通用解决方案，因为您必须考虑在您的情况下是否实际可行。例如，在内存中保存过多数据是不现实的，这会引起其他可扩展性问题。理想情况下，这是一个有限且相对较小的数据集，例如发票类别。这些数据不应该经常更改，因为如果您需要实时访问动态数据，这种方法就行不通了。如果基础数据源发生更改，则缓存可能会保留旧的陈旧数据。
- en: The solution shows an `InvoiceCategory` class that we’re going to cache. It’s
    for a lookup list, just two values per object, a finite and relatively small set
    of values, and something that doesn’t change much. You can imagine that every
    query for invoices as well as admin or search screens with lookup lists would
    require this data. It might speed up invoice queries by removing the extra join
    and returning less data over the wire where you can join the cached data after
    the DB query.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案展示了一个`InvoiceCategory`类，我们将对其进行缓存。它是一个查找列表，每个对象仅有两个值，是一个有限且相对较小的集合，并且不经常变化。可以想象，每次发票查询以及包含查找列表的管理或搜索界面都需要这些数据。通过删除额外的连接并在数据库查询后加入缓存数据，可以加快发票查询速度并减少数据传输量。
- en: The solution has an `InventoryRepository` that implements the `IInvoiceRepository`
    interface. This wasn’t strictly necessary for this example, though it does support
    demonstrating another example of IoC, as discussed in [Recipe 1.2](ch01.xhtml#removing_explicit_dependencies).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案中有一个`InventoryRepository`，实现了`IInvoiceRepository`接口。尽管对于这个例子来说这并不是严格必要的，但它支持展示IoC的另一个例子，正如[Recipe
    1.2](ch01.xhtml#removing_explicit_dependencies)中讨论的那样。
- en: The `InvoiceRepository` class has an `invoiceCategories` field for holding a
    collection of `InvoiceCategory`. The `GetInvoiceCategories` method would normally
    make a DB query and return the results. However, this example only does the DB
    query if `invoiceCategories` is `null`, and caches the result in `invoiceCategories`.
    This way, subsequent requests get the cached version and don’t require a DB query.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`InvoiceRepository`类具有一个`invoiceCategories`字段，用于保存`InvoiceCategory`的集合。`GetInvoiceCategories`方法通常会进行数据库查询并返回结果。但是，在这个例子中，只有在`invoiceCategories`为`null`时才执行数据库查询，并将结果缓存到`invoiceCategories`中。这样，后续请求将获取缓存版本，而不需要进行数据库查询。'
- en: Note
  id: totrans-183
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `invoiceCategories` field is static because you only want a single cache.
    In stateless web scenarios, as in ASP.NET, the Internet Information Services (IIS)
    process recycles unpredictably, and developers are advised not to rely on static
    variables. This situation is different because if the recycle clears out `invoiceCategories`,
    leaving it `null`, the next query will repopulate it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`invoiceCategories` 字段是静态的，因为你只想要一个单一的缓存。在无状态的 web 场景中，如 ASP.NET 中，Internet
    Information Services (IIS) 进程会不可预测地回收，并建议开发人员不要依赖静态变量。这种情况不同，因为如果回收清除了 `invoiceCategories`，使其为
    `null`，下一个查询将重新填充它。'
- en: The `Main` method uses IoC to instantiate `InvoiceRepository` and performs a
    query for the `InvoiceCategory` collection.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法使用 IoC 实例化 `InvoiceRepository` 并对 `InvoiceCategory` 集合执行查询。'
- en: See Also
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Recipe 1.2, “Removing Explicit Dependencies”](ch01.xhtml#removing_explicit_dependencies)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 1.2 节，“移除显式依赖”](ch01.xhtml#removing_explicit_dependencies)'
- en: 2.9 Delaying Type Instantiation
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.9 延迟类型实例化
- en: Problem
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: A class has heavy instantiation requirements, and you can save on resource usage
    by delaying the instantiation to only when necessary.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类具有大量的实例化要求，通过延迟实例化只在必要时节省资源使用。
- en: Solution
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s the data we’ll work with:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要处理的数据：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is the repository interface:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这是存储库接口：
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This is the repository that we delay instantiation of:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们延迟实例化的存储库：
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This program shows a few ways to perform lazy initialization of the repository:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序展示了几种延迟初始化存储库的方法：
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Discussion
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Sometimes you have objects with heavy startup overhead. They might need some
    initial calculations or have to wait on data that takes a while to get because
    of network latency or dependencies on poorly performing external systems. This
    can have serious negative consequences, especially on application startup. Imagine
    an app that is losing potential customers during trial because it starts too slow,
    or even enterprise users whose work is impacted by wait times. Although you may
    or may not be able to fix the root cause of the performance bottleneck, another
    option might be to delay instantiation of that object until you need it. For example,
    what if you really don’t need that object immediately and can show a start screen
    right away?
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您会遇到启动开销大的对象。它们可能需要一些初始计算，或者需要等待一段时间才能获取数据，因为网络延迟或依赖性于性能不佳的外部系统。这可能会对应用程序启动速度造成严重的负面影响。想象一下，一个应用程序由于启动太慢而失去潜在客户，甚至是企业用户因等待时间而受到影响。虽然您可能无法修复性能瓶颈的根本原因，但另一种选择可能是将该对象的实例化延迟到需要时。例如，如果您真的不需要立即使用该对象，可以立即显示启动屏幕。
- en: The solution demonstrates how to use `Lazy<T>` to delay object instantiation.
    The object in question is the `InvoiceRepository`, and we’re assuming it has a
    problem in its constructor logic that causes a delay in instantiation.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案演示了如何使用 `Lazy<T>` 延迟对象实例化。所涉及的对象是 `InvoiceRepository`，我们假设它在构造函数逻辑上有问题，导致延迟实例化。
- en: '`Program` has three fields whose type is `Lazy<InvoiceRepository>`, showing
    three different ways to instantiate. The first field, `InvoiceRep`, instantiates
    a `Lazy<Invoice​Re⁠pository>` with no parameters. It assumes that `InvoiceRepository`
    has a default constructor (parameterless) and will be called to create a new instance
    when the code accesses the `Value` property.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`Program` 有三个字段，其类型为 `Lazy<InvoiceRepository>`，展示了三种不同的实例化方式。第一个字段 `InvoiceRep`，实例化一个没有参数的
    `Lazy<Invoice​Re⁠pository>`。它假设 `InvoiceRepository` 有一个默认构造函数（无参数），并在代码访问 `Value`
    属性时调用它来创建一个新实例。'
- en: The `InvoiceRepFactory` field instance references the `CreateInvoiceRepository​In⁠stance`
    method. When code accesses this field, it calls the `CreateInvoiceRepositor⁠y​Instance`
    to construct the object. Since it’s a method, you have a lot of flexibility in
    building the object.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`InvoiceRepFactory` 字段实例引用了 `CreateInvoiceRepository​In⁠stance` 方法。当代码访问此字段时，它调用
    `CreateInvoiceRepositor⁠y​Instance` 来构造对象。由于它是一个方法，你在构建对象时有很大的灵活性。'
- en: In addition to the other two options, the `InvoiceRepIoC` field shows how you
    can use lazy instantiation with IoC. Notice that the `Main` method builds an IoC
    container, as described in [Recipe 1.2](ch01.xhtml#removing_explicit_dependencies).
    The `CreateInvoiceRepositoryFromIoC` method uses that IoC container to request
    an instance of `InvoiceRepository`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其他两个选项之外，`InvoiceRepIoC` 字段显示了如何在 IoC 中使用延迟实例化。注意，`Main` 方法构建了一个 IoC 容器，如[第
    1.2 节](ch01.xhtml#removing_explicit_dependencies)中所述。`CreateInvoiceRepositoryFromIoC`
    方法使用该 IoC 容器请求 `InvoiceRepository` 的实例。
- en: Finally, the `Run` method shows how to access the fields through the `Lazy<T>.Value`
    property.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Run` 方法展示如何通过 `Lazy<T>.Value` 属性访问字段。
- en: See Also
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Recipe 1.2, “Removing Explicit Dependencies”](ch01.xhtml#removing_explicit_dependencies)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[菜谱 1.2，“移除显式依赖关系”](ch01.xhtml#removing_explicit_dependencies)'
- en: 2.10 Parsing Data Files
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.10 解析数据文件
- en: Problem
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: The application needs to extract data from a custom external format, and string
    type operations lead to complex and less efficient code.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序需要从自定义外部格式中提取数据，而字符串类型操作导致代码复杂且效率低下。
- en: Solution
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s the data types we’ll be working with:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要处理的数据类型：
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This method returns the raw string data that we want to extract and convert
    to invoices:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回我们要提取并转换为发票的原始字符串数据：
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'These are utility methods for building and saving invoices:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是用于构建和保存发票的实用方法：
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This method uses regular expressions to extract values from raw string data:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用正则表达式从原始字符串数据中提取值：
- en: '[PRE36]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `Main` method runs the demo:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法运行演示：'
- en: '[PRE37]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Discussion
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Sometimes, we’ll encounter textual data that doesn’t fit standard data formats.
    It might come from existing document files, log files, or external and legacy
    systems. Often, we need to ingest that data and process it for storage in a DB.
    This section explains how to do that with regular expressions.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们会遇到不符合标准数据格式的文本数据。它可能来自现有的文档文件、日志文件或外部和遗留系统。通常，我们需要接收这些数据并处理以便存储到数据库中。本节将解释如何使用正则表达式进行处理。
- en: The solution shows the data format we want to generate is an `Invoice` with
    a collection of `InvoiceItem`. The `GetInvoiceTransferFile` method shows the format
    of the data. The demo suggests that the data might come from a legacy system that
    already produced that format, and it’s easier to write C# code to ingest that
    than to add code in that system for a better-supported format. The specific data
    we’re interested in extracting are the `created` date, invoice `items`, and `customer`
    name. Notice that newlines (`\n`) separate records, double colons (`::`) separate
    invoice fields, and tabs (`\t`) separate invoice item fields.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案展示了我们想要生成的数据格式是一个带有 `InvoiceItem` 集合的 `Invoice`。`GetInvoiceTransferFile`
    方法展示了数据的格式。演示表明数据可能来自已经生成了该格式的遗留系统，使用 C# 代码来接收比在该系统中添加支持更好的格式更容易。我们要提取的具体数据是 `created`
    日期、发票 `items` 和 `customer` 名称。注意换行符 (`\n`) 分隔记录，双冒号 (`::`) 分隔发票字段，制表符 (`\t`) 分隔发票项字段。
- en: The `GetInvoice` and `GetLineItems` methods construct the objects from extracted
    data and serve to separate object construction from the regular expression extraction
    logic.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetInvoice` 和 `GetLineItems` 方法从提取的数据构造对象，并用于将对象构建与正则表达式提取逻辑分离。'
- en: The `ParseInvoices` method uses regular expressions to extract values from the
    input string. The `RegEx` constructor parameter contains the regular expression
    string used to extract values.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParseInvoices` 方法使用正则表达式从输入字符串中提取数值。`RegEx` 构造函数参数包含用于提取数值的正则表达式字符串。'
- en: 'While an entire discussion of regular expressions is out of scope, here’s what
    this string does:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然讨论整个正则表达式的内容超出了范围，但这里是该字符串的功能：
- en: '`^` says to start at the beginning of the string.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^` 表示从字符串的开头开始。'
- en: '`.+?::` matches all characters, up to the next invoice field separator (`::`).
    That said, it ignores the contents that were matched.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.+?::` 匹配所有字符，直到下一个发票字段分隔符 (`::`)。换句话说，它忽略了匹配的内容。'
- en: '`(?<created>.+?)::`, `(?<items>.+?)::`, and `(?<customer>.+?)::` are similar
    to `.+?)::` but go a step further by extracting values into groups based on the
    given name. For example, `(?<created>.+?)::` means that it will extract all matched
    data and put the data in a group named “created.”'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(?<created>.+?)::`、`(?<items>.+?)::` 和 `(?<customer>.+?)::` 类似于 `.+?)::`，但进一步通过给定名称提取值到组中。例如，`(?<created>.+?)::`
    表示将提取所有匹配的数据并放入名为“created”的组中。'
- en: '`.+` matches all remaining characters.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.+` 匹配所有剩余字符。'
- en: The `foreach` loop relies on the `\n` separator in the string to work with each
    invoice. The `Match` method executes the regular expression match, extracting
    values. If the match was successful, the code extracts values from groups, calls
    `GetInvoice`, and adds the new invoice to the `invoices` collection.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach` 循环依赖于字符串中的 `\n` 分隔符来处理每个发票。`Match` 方法执行正则表达式匹配，提取数值。如果匹配成功，代码从组中提取数值，调用
    `GetInvoice` 方法，并将新发票添加到 `invoices` 集合中。'
- en: You might have noticed that we’re using `GetLineItems` to extract data from
    the `matchItems` parameter, from the regular expression `items` field. We could
    have used a more sophisticated regular expression to take care of that too. However,
    this was intentional for contrast in demonstrating how regular expression processing
    is a more elegant solution in this situation.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我们使用`GetLineItems`从`matchItems`参数中提取数据，来自正则表达式`items`字段。我们本可以使用更复杂的正则表达式来处理这个问题。然而，这是有意为之，用来对比展示在这种情况下正则表达式处理更为优雅的解决方案。
- en: Tip
  id: totrans-235
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: As an enhancement, you might log any situations where `match.Success` is `false`
    if you’re concerned about losing data and/or want to know if there’s a bug in
    the regular expression or original data formatting.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 作为增强功能，如果您关心数据丢失或者想知道正则表达式或原始数据格式中是否存在 bug，可以记录任何`match.Success`为`false`的情况。
- en: Finally, the application returns the new line items to the calling code, `Main`,
    so it can save them.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，应用程序将新的行项目返回给调用代码`Main`，以便保存它们。
