- en: Chapter 24\. Native and COM Interoperability
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第24章 本地和COM互操作性
- en: This chapter describes how to integrate with native (unmanaged) Dynamic-Link
    Libraries (DLLs) and Component Object Model (COM) components. Unless otherwise
    stated, the types mentioned in this chapter exist in either the `System` or the
    `System.Runtime.InteropServices` namespace.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述如何与本地（非托管）动态链接库（DLL）和组件对象模型（COM）组件集成。除非另有说明，本章提到的类型存在于`System`或`System.Runtime.InteropServices`命名空间中。
- en: Calling into Native DLLs
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用本地DLL
- en: '*P/Invoke*, short for *Platform Invocation Services*, allows you to access
    functions, structs, and callbacks in unmanaged DLLs (*shared libraries* on Unix).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*P/Invoke*，简称*平台调用服务*，允许您访问非托管DLL中的函数、结构和回调（Unix上的共享库）。'
- en: 'For example, consider the `MessageBox` function, defined in the Windows DLL
    *user32.dll*, as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑在Windows DLL *user32.dll* 中定义的`MessageBox`函数如下：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can call this function directly by declaring a static method of the same
    name, applying the `extern` keyword, and adding the `DllImport` attribute:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过声明同名的静态方法、应用`extern`关键字并添加`DllImport`属性来直接调用此函数：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `MessageBox` classes in the `System.Windows` and `System.Windows.Forms`
    namespaces themselves call similar unmanaged methods.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Windows`和`System.Windows.Forms`命名空间中的`MessageBox`类本身调用类似的非托管方法。'
- en: 'Here’s a `DllImport` example for Ubuntu Linux:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Ubuntu Linux的一个`DllImport`示例：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The CLR includes a marshaler that knows how to convert parameters and return
    values between .NET types and unmanaged types. In the Windows example, the `int`
    parameters translate directly to four-byte integers that the function expects,
    and the string parameters are converted into null-terminated arrays of Unicode
    characters (encoded in UTF-16). `IntPtr` is a struct designed to encapsulate an
    unmanaged handle; it’s 32 bits wide on 32-bit platforms and 64 bits wide on 64-bit
    platforms. A similar translation happens on Unix. (From C# 9, you can also use
    the `nint` type, which maps to `IntPtr`.)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: CLR包含一个编组器，知道如何在.NET类型和非托管类型之间转换参数和返回值。在Windows示例中，`int`参数直接转换为函数期望的四字节整数，字符串参数转换为以UTF-16编码的空终止Unicode字符数组。`IntPtr`是一个设计用来封装非托管句柄的结构体；在32位平台上宽度为32位，在64位平台上宽度为64位。在Unix上也会进行类似的转换。（从C#
    9开始，您还可以使用`nint`类型，它映射到`IntPtr`。）
- en: Type and Parameter Marshaling
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型和参数编组
- en: Marshaling Common Types
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编组常见类型
- en: 'On the unmanaged side, there can be more than one way to represent a given
    data type. A string, for instance, can contain single-byte ANSI characters or
    UTF-16 Unicode characters, and can be length prefixed, null terminated, or of
    fixed length. With the `MarshalAs` attribute, you can specify to the CLR marshaler
    the variation in use, so it can provide the correct translation. Here’s an example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在非托管端，可以有多种方式来表示给定的数据类型。例如，字符串可以包含单字节的ANSI字符或UTF-16 Unicode字符，并且可以是长度前缀、空终止或固定长度。使用`MarshalAs`属性，您可以指定CLR编组器正在使用的变体，以便它提供正确的转换。以下是一个示例：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `UnmanagedType` enumeration includes all the Win32 and COM types that the
    marshaler understands. In this case, the marshaler was told to translate to `LPStr`,
    which is a null-terminated single-byte ANSI string.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnmanagedType`枚举包括编组器了解的所有Win32和COM类型。在本例中，编组器被告知转换为`LPStr`，这是一个以null结尾的单字节ANSI字符串。'
- en: On the .NET side, you also have some choice as to what data type to use. Unmanaged
    handles, for instance, can map to `IntPtr`, `int`, `uint`, `long`, or `ulong`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET端，您也可以选择使用哪种数据类型。例如，非托管句柄可以映射到`IntPtr`、`int`、`uint`、`long`或`ulong`。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Most unmanaged handles encapsulate an address or pointer and so must be mapped
    to `IntPtr` for compatibility with both 32- and 64-bit operating systems. A typical
    example is HWND.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数非托管句柄封装了一个地址或指针，因此必须映射到`IntPtr`以兼容32位和64位操作系统。典型示例是HWND。
- en: Quite often with Win32 and POSIX functions, you come across an integer parameter
    that accepts a set of constants, defined in a C++ header file such as *WinUser.h*.
    Rather than defining these as simple C# constants, you can define them within
    an enum instead. Using an enum can make for tidier code as well as increase static
    type safety. We provide an example in [“Shared Memory”](#shared_memory).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Win32和POSIX函数中，经常会遇到接受一组常量的整数参数，这些常量在C++头文件（如*WinUser.h*）中定义。您可以选择将其定义为简单的C#常量，也可以将其定义为枚举。使用枚举可以使代码更整洁，同时增加静态类型安全性。我们在[“共享内存”](#shared_memory)中提供了一个示例。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When installing Microsoft Visual Studio, be sure to install the C++ header files—even
    if you choose nothing else in the C++ category. This is where all the native Win32
    constants are defined. You can then locate all header files by searching for **.h*
    in the Visual Studio program directory.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装Microsoft Visual Studio时，请确保安装C++头文件——即使在C++类别中未选择其他任何选项。这是定义所有本机Win32常量的地方。然后，可以通过在Visual
    Studio程序目录中搜索**.h*来定位所有头文件。
- en: On Unix, the POSIX standard defines names of constants, but individual implementations
    of POSIX-compliant Unix systems may assign different numeric values to these constants.
    You must use the correct numeric value for your operating system of choice. Similarly,
    POSIX defines a standard for structs used in interop calls. The ordering of fields
    in the struct is not fixed by the standard, and a Unix implementation might add
    additional fields. C++ header files defining functions and types are often installed
    in */usr/include* or */usr/local/include*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix上，POSIX标准定义了常量的名称，但符合POSIX的Unix系统的各个实现可能为这些常量分配不同的数值。你必须使用所选操作系统的正确数值。类似地，POSIX定义了在互操作调用中使用的结构体的标准。结构体中字段的顺序不由标准固定，Unix实现可能会添加额外的字段。定义函数和类型的C++头文件通常安装在*/usr/include*或*/usr/local/include*中。
- en: 'Receiving strings from unmanaged code back to .NET requires that some memory
    management take place. The marshaler automatically performs this work if you declare
    the external method with a `StringBuilder` rather than a `string`, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从非托管代码接收字符串返回到.NET需要进行一些内存管理。如果你使用`StringBuilder`而不是`string`声明外部方法，封送程序会自动执行这项工作，如下所示：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'On Unix, it works similarly. The following calls `getcwd` to return the current
    directory:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix上，工作方式类似。以下调用`getcwd`以返回当前目录：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Although `StringBuilder` is convenient to use, it’s somewhat inefficient in
    that the CLR must perform additional memory allocations and copying. In performance
    hotspots, you can avoid this overhead by using `char[]` instead:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`StringBuilder`使用方便，但CLR在执行时需要进行额外的内存分配和复制，效率略低。在性能热点处，可以通过使用`char[]`来避免这种开销：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Notice that you must specify a `CharSet` in the `DllImport` attribute. You
    must also trim the output string to length after calling the function. You can
    achieve this while minimizing memory allocations with the use of array pooling
    (see [“Array Pooling”](ch12.html#array_pooling)), as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你必须在`DllImport`属性中指定`CharSet`。调用函数后还必须将输出字符串修剪到指定长度。你可以通过使用数组池（参见[“数组池”](ch12.html#array_pooling)）来实现这一点，同时最小化内存分配，如下所示：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: (Of course, this example is contrived in that you can obtain the Windows directory
    via the built-in `Environment.GetFolderPath` method.)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: （当然，这个例子有些刻意，因为你可以通过内置的`Environment.GetFolderPath`方法获取Windows目录。）
- en: Note
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you are unsure how to call a particular Win32 or Unix method, you will usually
    find an example on the internet if you search for the method name and *DllImport*.
    For Windows, the site [*http://www.pinvoke.net*](http://www.pinvoke.net) is a
    wiki that aims to document all Win32 signatures.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定如何调用特定的Win32或Unix方法，通常可以在互联网上搜索方法名称和*DllImport*来找到示例。对于Windows，网站[*http://www.pinvoke.net*](http://www.pinvoke.net)是一个旨在记录所有Win32签名的维基。
- en: Marshaling Classes and Structs
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理类和结构体
- en: 'Sometimes, you need to pass a struct to an unmanaged method. For example, `GetSystemTime`
    in the Win32 API is defined as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要将结构体传递给非托管方法。例如，Win32 API中的`GetSystemTime`定义如下：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`LPSYSTEMTIME` conforms to this C struct:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`LPSYSTEMTIME`符合此C结构：'
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To call `GetSystemTime`, we must define a .NET class or struct that matches
    this C struct:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用`GetSystemTime`，我们必须定义一个与此C结构体匹配的.NET类或结构体：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `StructLayout` attribute instructs the marshaler how to map each field to
    its unmanaged counterpart. `LayoutKind.Sequential` means that we want the fields
    aligned sequentially on *pack-size* boundaries (you’ll see what this means shortly),
    just as they would be in a C struct. The field names here are irrelevant; it’s
    the ordering of fields that’s important.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`StructLayout`属性指示封送程序如何将每个字段映射到其非托管对应项。`LayoutKind.Sequential`表示我们希望字段按*pack-size*边界依次对齐（你很快就会明白这是什么意思），就像它们在C结构体中一样。这里字段名不重要；字段顺序才是重要的。'
- en: 'Now we can call `GetSystemTime`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以调用`GetSystemTime`：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Similarly, on Unix:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在Unix上：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In both C and C#, fields in an object are located at *n* number of bytes from
    the address of that object. The difference is that in a C# program, the CLR finds
    this offset by looking it up using the field token; C field names are compiled
    directly into offsets. For instance, in C, `wDay` is just a token to represent
    whatever is at the address of a `SystemTime` instance plus 24 bytes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 和 C# 中，对象的字段位于该对象地址加上 *n* 字节的位置。不同之处在于，在 C# 程序中，CLR 通过查找字段标记来找到偏移量；而 C 中的字段名直接编译为偏移量。例如，在
    C 中，`wDay` 只是一个标记，用于表示 `SystemTime` 实例地址加上 24 字节处的内容。
- en: 'For access speed, each field is placed at an offset that is a multiple of the
    field’s size. That multiplier, however, is restricted to a maximum of *x* bytes,
    where *x* is the *pack size*. In the current implementation, the default pack
    size is 8 bytes, so a struct comprising an `sbyte` followed by an (8-byte) `long`
    occupies 16 bytes, and the 7 bytes following the `sbyte` are wasted. You can lessen
    or eliminate this wastage by specifying a *pack size* via the `Pack` property
    of the `StructLayout` attribute: this makes the fields align to offsets that are
    multiples of the specified pack size. So, with a pack size of 1, the struct just
    described would occupy just 9 bytes. You can specify pack sizes of 1, 2, 4, 8,
    or 16 bytes.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问速度，每个字段都被放置在其大小的倍数的偏移量处。然而，该乘数受到 *x* 字节的限制，其中 *x* 是*包大小*。在当前实现中，默认的包大小是
    8 字节，因此由一个 `sbyte` 和一个（8 字节）`long` 组成的结构体占据 16 字节，并且 `sbyte` 后面的 7 字节被浪费了。您可以通过
    `StructLayout` 属性的 `Pack` 属性指定一个*包大小*来减少或消除这种浪费：这使得字段对齐到指定包大小的倍数的偏移量上。因此，使用包大小为
    1，刚刚描述的结构体将仅占用 9 字节。可以指定包大小为 1、2、4、8 或 16 字节。
- en: The `StructLayout` attribute also lets you specify explicit field offsets (see
    [“Simulating a C Union”](#simulating_a_c_union)).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`StructLayout` 属性还允许您指定显式字段偏移量（参见[“模拟 C 联合”](#simulating_a_c_union)）。'
- en: In and Out Marshaling
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进出传递
- en: 'In the previous example, we implemented `SystemTime` as a class. We could have
    instead chosen a struct—provided that `GetSystemTime` was declared with a `ref`
    or `out` parameter:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们将 `SystemTime` 实现为一个类。我们也可以选择使用结构体——前提是 `GetSystemTime` 声明为具有 `ref`
    或 `out` 参数：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In most cases, C#’s directional parameter semantics work the same with external
    methods. Pass-by-value parameters are copied in, C# ref parameters are copied
    in/out, and C# out parameters are copied out. However, there are some exceptions
    for types that have special conversions. For instance, array classes and the `StringBuilder`
    class require copying when coming out of a function, so they are in/out. It is
    occasionally useful to override this behavior, with the `In` and `Out` attributes.
    For example, if an array should be read-only, the `in` modifier indicates to copy
    only the array going into the function, not coming out of it:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，C# 的参数传递语义与外部方法相同。按值传递的参数被复制进去，C# 的 ref 参数是传入/传出的，C# 的 out 参数则是传出的。然而，对于具有特殊转换的类型，存在一些例外情况。例如，数组类和
    `StringBuilder` 类在从函数中输出时需要复制，因此它们是传入/传出的。偶尔会有覆盖此行为的情况，可以使用 `In` 和 `Out` 属性。例如，如果数组应该是只读的，`in`
    修饰符表示仅在进入函数时复制数组，而不是在离开函数时复制：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Calling Conventions
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用约定
- en: Unmanaged methods receive arguments and return values via the stack and (optionally)
    CPU registers. Because there’s more than one way to accomplish this, a number
    of different protocols have emerged. These protocols are known as *calling conventions*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 非托管方法通过堆栈和（可选地）CPU 寄存器接收参数和返回值。由于有多种实现方式，因此出现了多种不同的协议。这些协议称为*调用约定*。
- en: 'The CLR currently supports three calling conventions: StdCall, Cdecl, and ThisCall.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当前 CLR 支持三种调用约定：StdCall、Cdecl 和 ThisCall。
- en: By default, the CLR uses the *platform default* calling convention (the standard
    convention for that platform). On Windows, it’s StdCall, and on Linux x86, it’s
    Cdecl.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，CLR 使用*平台默认*调用约定（该平台的标准约定）。在 Windows 上是 StdCall，在 Linux x86 上是 Cdecl。
- en: 'Should an unmanaged method not follow this default, you can explicitly state
    its calling convention as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果非托管方法不遵循此默认设置，可以明确声明其调用约定如下：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The somewhat misleadingly named `CallingConvention.WinApi` refers to the platform
    default.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有些颇具误导性的命名为 `CallingConvention.WinApi` 实际上指的是平台默认。
- en: Callbacks from Unmanaged Code
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从非托管代码的回调
- en: 'C# also allows external functions to call C# code, via callbacks. There are
    two ways to accomplish callbacks:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: C# 还允许外部函数通过回调调用 C# 代码。有两种方法可以实现回调：
- en: Via function pointers
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过函数指针
- en: Via delegates
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过委托
- en: 'To illustrate, we will call the following Windows function in *User32.dll*,
    which enumerates all top-level window handles:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明问题，我们将调用以下位于 *User32.dll* 中的 Windows 函数，该函数枚举所有顶级窗口句柄：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`WNDENUMPROC` is a callback that is fired with the handle of each window in
    sequence (or until the callback returns `false`). Here is its definition:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`WNDENUMPROC` 是一个回调函数，按顺序触发每个窗口的句柄（或直到回调返回 `false`）。以下是其定义：'
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Callbacks with Function Pointers
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用函数指针的回调
- en: 'From C# 9, the simplest and most performant option—when your callback is a
    static method—is to use a *function pointer*. In the case of the `WNDENUMPROC`
    callback, we can use the following function pointer:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 9 开始，当您的回调是静态方法时，最简单且性能最佳的选项是使用 *函数指针*。对于 `WNDENUMPROC` 回调，我们可以使用以下函数指针：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This denotes a function that accepts two `IntPtr` arguments and returns a `bool`.
    You can then use the `&` operator to feed it a static method:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示一个接受两个 `IntPtr` 参数并返回 `bool` 的函数。然后，您可以使用 `&` 运算符将静态方法传递给它：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With function pointers, the callback must be a static method (or a static local
    function, as in this example).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于函数指针，回调必须是静态方法（或者是本示例中的静态局部函数）。
- en: UnmanagedCallersOnly
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UnmanagedCallersOnly
- en: 'You can improve performance by applying the `unmanaged` keyword to the function
    pointer declaration, and the `[UnmanagedCallersOnly]` attribute to the callback
    method:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在函数指针声明中应用 `unmanaged` 关键字，以及在回调方法上应用 `[UnmanagedCallersOnly]` 属性来提高性能：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This attribute flags the `PrintWindow` method such that it can be called *only*
    from unmanaged code, allowing the runtime to take shortcuts. Notice that we’ve
    also changed the method’s return type from `bool` to `byte`: this is because methods
    to which you apply `[UnmanagedCallersOnly]` can use only *blittable* value types
    in the signature. Blittable types are those that don’t require any special marshalling
    logic because they’re represented identically in the managed and unmanaged worlds.
    These include the primitive integral types, `float`, `double`, and structs that
    contain only blittable types. The `char` type is also blittable, if part of a
    struct with a `StructLayout` attribute specifying `CharSet.Unicode`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性标记 `PrintWindow` 方法，以便它只能从未管理的代码中调用，从而允许运行时采取捷径。请注意，我们还将方法的返回类型从 `bool` 更改为
    `byte`：这是因为您应用 `[UnmanagedCallersOnly]` 的方法只能在签名中使用 *可平铺* 的值类型。可平铺类型是那些在托管和未托管世界中都以相同方式表示的类型，因此不需要任何特殊的编组逻辑。这些包括原始整数类型、`float`、`double`，以及仅包含可平铺类型的结构体。如果位于具有指定
    `CharSet.Unicode` 的 `StructLayout` 属性的结构体中，则 `char` 类型也是可平铺的：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Nondefault calling conventions
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非默认的调用约定
- en: 'By default, the compiler assumes that the unmanaged callback follows the platform-default
    calling convention. Should this not be so, you can explicitly state its calling
    convention via the `CallConvs` parameter of the `[UnmanagedCallersOnly]` attribute:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，编译器假定未管理的回调遵循平台默认的调用约定。如果情况不是这样，您可以通过 `[UnmanagedCallersOnly]` 属性的 `CallConvs`
    参数显式指定其调用约定：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You must also update the function pointer type by inserting a special modifier
    after the `unmanaged` keyword:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您还必须通过在 `unmanaged` 关键字后插入特殊修饰符来更新函数指针类型：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-86
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The compiler lets you put any identifier (such as `XYZ`) inside the square brackets,
    as long as there’s a .NET type called `CallConv**XYZ**` (that’s understood by
    the runtime and matches what you specified when applying the `[UnmanagedCallersOnly]`
    attribute). This makes it easier for Microsoft to add new calling conventions
    in the future.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器允许您在方括号内放置任何标识符（例如 `XYZ`），只要有一个名为 `CallConv**XYZ**` 的.NET类型（这是由运行时理解的，并且与您在应用
    `[UnmanagedCallersOnly]` 属性时指定的匹配）。这样做可以使微软在未来更容易添加新的调用约定。
- en: 'In this case, we specified StdCall, which is the platform default for Windows
    (Cdecl is the default for Linux x86). Here are all the options that are currently
    supported:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们指定了 StdCall，这是 Windows 平台的默认值（Cdecl 是 Linux x86 的默认值）。以下是当前支持的所有选项：
- en: '| Name | unmanaged modifier | Supporting type |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 未管理的修饰符 | 支持的类型 |'
- en: '| --- | --- | --- |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Stdcall | `unmanaged[Stdcall]` | `CallConvStdcall` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| Stdcall | `unmanaged[Stdcall]` | `CallConvStdcall` |'
- en: '| Cdecl | `unmanaged[Cdecl]` | `CallConvCdecl` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| Cdecl | `unmanaged[Cdecl]` | `CallConvCdecl` |'
- en: '| ThisCall | `unmanaged[Thiscall]` | `CallConvThiscall` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| ThisCall | `unmanaged[Thiscall]` | `CallConvThiscall` |'
- en: Callbacks with Delegates
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用委托的回调
- en: Unmanaged callbacks can also be accomplished with delegates. This approach works
    in all versions of C#, and allows for callbacks that reference instance methods.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 未管理的回调也可以通过委托来完成。这种方法适用于所有版本的 C#，并允许引用实例方法的回调。
- en: 'To proceed, first declare a delegate type with a signature that matches the
    callback. Then you can pass a delegate instance to the external method:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要继续进行，首先声明一个与回调匹配的委托类型。然后，您可以将委托实例传递给外部方法：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Using delegates for unmanaged callbacks is ironically unsafe, because it’s
    easy to fall into the trap of allowing a callback to occur after the delegate
    instance falls out of scope (at which point the delegate becomes eligible for
    garbage collection). This can result in the worst kind of runtime exception—one
    with no useful stack trace. In the case of static method callbacks, you can avoid
    this by assigning the delegate instance to a read-only static field (as we did
    in this example). With instance method callbacks, this pattern won’t help, so
    you must code carefully to ensure that you maintain at least one reference to
    the delegate instance for the duration of any potential callback. Even then, if
    there’s a bug on the unmanaged side—whereby it invokes a callback after you’ve
    told it not to—you may still have to deal with an untraceable exception. A workaround
    is to define a unique delegate type per unmanaged function: this helps diagnostically
    because the delegate type is reported in the exception.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于未管理的回调，使用委托具有讽刺意味，因为很容易陷入陷阱，允许在委托实例超出范围后发生回调（在这种情况下，委托变得符合垃圾收集）。这可能导致最糟糕的运行时异常之一——没有有用的堆栈跟踪。对于静态方法回调，您可以通过将委托实例分配给只读静态字段（就像我们在这个例子中所做的那样）来避免这种情况。对于实例方法回调，这种模式将无法帮助，因此您必须小心编码，以确保在任何潜在的回调期间至少保持对委托实例的一个引用。即使如此，如果未管理的一侧存在错误——它在您告诉它不要后继续调用回调——您可能仍然需要处理无法跟踪的异常。一个解决方法是为每个未管理的函数定义一个唯一的委托类型：这有助于诊断，因为异常中报告了委托类型。
- en: 'You can change the callback’s calling convention from the platform default
    by applying the `[UnmanagedFunctionPointer]` attribute to the delegate:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将 `[UnmanagedFunctionPointer]` 属性应用于委托来更改回调的调用约定，从而使其不同于平台默认值：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Simulating a C Union
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟 C 联合
- en: Each field in a `struct` is given enough room to store its data. Consider a
    `struct` containing one `int` and one `char`. The `int` is likely to start at
    an offset of `0` and is guaranteed at least four bytes. So, the `char` would start
    at an offset of at least `4`. If, for some reason, the `char` started at an offset
    of `2`, you’d change the value of the `int` if you assigned a value to the `char`.
    Sounds like mayhem, doesn’t it? Strangely enough, the C language supports a variation
    on a struct called a *union* that does exactly this. You can simulate this in
    C# by using `LayoutKind.Explicit` and the `FieldOffset` attribute.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct` 中的每个字段都有足够的空间来存储其数据。考虑一个包含一个 `int` 和一个 `char` 的 `struct`。`int` 可能从偏移量
    `0` 开始，并且保证至少有四个字节。因此，`char` 将至少从偏移量 `4` 开始。如果由于某种原因 `char` 从偏移量 `2` 开始，如果给 `char`
    赋值，则会更改 `int` 的值。听起来像混乱，不是吗？奇怪的是，C 语言支持一个称为 *union* 的结构体变体，正是做到了这一点。您可以通过使用 `LayoutKind.Explicit`
    和 `FieldOffset` 属性在 C# 中模拟这一点。'
- en: 'It might be challenging to think of a case in which this would be useful. However,
    suppose that you want to play a note on an external synthesizer. The Windows Multimedia
    API provides a function for doing just this via the MIDI protocol:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个这种方法会有用的情况可能会有些挑战。但是，假设您想在外部合成器上播放一个音符。Windows 多媒体 API 通过 MIDI 协议提供了一个可以做到这一点的函数：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The second argument, `message`, describes what note to play. The problem is
    in constructing this 32-bit unsigned integer: it’s divided internally into bytes,
    representing a MIDI channel, note, and velocity at which to strike. One solution
    is to shift and mask via the bitwise `<<`, `>>`, `&`, and `|` operators to convert
    these bytes to and from the 32-bit “packed” message. Far simpler, though, is to
    define a struct with explicit layout:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数 `message` 描述要播放的音符。问题在于构造这个 32 位无符号整数：它在内部被分成字节，表示 MIDI 通道、音符以及打击时的速度。一个解决方案是通过位移和掩码操作符
    `<<`、`>>`、`&` 和 `|` 将这些字节转换为和从 32 位“打包”消息。尽管更简单的方法是定义一个具有显式布局的结构体：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `Channel`, `Note`, and `Velocity` fields deliberately overlap with the
    32-bit packed message. This allows you to read and write using either. No calculations
    are required to keep other fields in sync:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Channel`、`Note`和`Velocity`字段故意与32位打包消息重叠。这允许您使用任一字段进行读取和写入。无需计算即可保持其他字段同步：'
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Shared Memory
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享内存
- en: Memory-mapped files, or *shared memory*, is a feature in Windows that allows
    multiple processes on the same computer to share data. Shared memory is extremely
    fast and, unlike pipes, offers *random* access to the shared data. We saw in [Chapter 15](ch15.html#streams_and_isoliduso)
    how you can use the `MemoryMappedFile` class to access memory-mapped files; bypassing
    this and calling the Win32 methods directly is a good way to demonstrate P/Invoke.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 内存映射文件，或*共享内存*，是Windows中的一项功能，允许同一台计算机上的多个进程共享数据。共享内存非常快速，并且与管道不同，提供对共享数据的*随机*访问。我们在[第15章](ch15.html#streams_and_isoliduso)中看到，您可以使用`MemoryMappedFile`类访问内存映射文件；绕过这一点，直接调用Win32方法是演示P/Invoke的好方法。
- en: The Win32 `CreateFileMapping` function allocates shared memory. You tell it
    how many bytes you need and the name with which to identify the share. Another
    application can then subscribe to this memory by calling `OpenFileMapping` with
    the same name. Both methods return a *handle*, which you can convert to a pointer
    by calling `MapViewOfFile`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Win32的`CreateFileMapping`函数分配共享内存。您告诉它需要多少字节以及用于标识共享的名称。然后，另一个应用程序可以通过使用相同名称调用`OpenFileMapping`来订阅这个内存。这两种方法都返回一个*句柄*，您可以通过调用`MapViewOfFile`将其转换为指针。
- en: 'Here’s a class that encapsulates access to shared memory:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个封装对共享内存访问的类：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this example, we set `SetLastError=true` on the `DllImport` methods that
    use the `SetLastError` protocol for emitting error codes. This ensures that the
    `Win32Exception` is populated with details of the error when that exception is
    thrown. (It also allows you to query the error explicitly by calling `Marshal.GetLastWin32Error`.)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们在使用`SetLastError`协议发出错误代码的`DllImport`方法上设置了`SetLastError=true`。这确保当抛出异常时，`Win32Exception`中填充了错误的详细信息。（它还允许您通过调用`Marshal.GetLastWin32Error`显式查询错误。）
- en: 'To demonstrate this class, we need to run two applications. The first one creates
    the shared memory, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要演示这个类，我们需要运行两个应用程序。第一个应用程序创建共享内存如下：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The second application subscribes to the shared memory by constructing a `SharedMem`
    object of the same name, with the `existing` argument `true`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个应用程序订阅共享内存，通过构造同名的`SharedMem`对象，使用`existing`参数设置为`true`：
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The net result is that each program has an `IntPtr`—a pointer to the same unmanaged
    memory. The two applications now need somehow to read and write to memory via
    this common pointer. One approach is to write a class that encapsulates all the
    shared data and then serialize (and deserialize) the data to the unmanaged memory
    using an `UnmanagedMemoryStream`. This is inefficient, however, if there’s a lot
    of data. Imagine if the shared memory class had a megabyte of data, and just one
    integer needed to be updated. A better approach is to define the shared data construct
    as a struct and then map it directly into shared memory. We discuss this in the
    following section.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，每个程序都有一个`IntPtr`——指向同一非托管内存的指针。现在，这两个应用程序需要以某种方式通过这个共享指针读取和写入内存。一种方法是编写一个类来封装所有共享数据，然后使用`UnmanagedMemoryStream`将数据（反）序列化到非托管内存中。然而，如果数据量很大，这种方法效率低下。想象一下，如果共享内存类有一兆字节的数据，而只需更新一个整数。更好的方法是将共享数据结构定义为结构体，然后直接映射到共享内存中。我们将在接下来的部分讨论这个问题。
- en: Mapping a Struct to Unmanaged Memory
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将结构体映射到非托管内存
- en: 'You can directly map a struct with a `StructLayout` of `Sequential` or `Explicit`
    into unmanaged memory. Consider the following struct:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接将带有`Sequential`或`Explicit`的`StructLayout`映射到非托管内存中。考虑以下结构体：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `fixed` directive allows us to define fixed-length value-type arrays inline,
    and it is what takes us into the `unsafe` realm. Space in this struct is allocated
    inline for 50 floating-point numbers. Unlike with standard C# arrays, `Numbers`
    is not a *reference* to an array—it *is* the array. If we run the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`fixed`指令允许我们在内联中定义固定长度的值类型数组，并将我们带入`unsafe`领域。这个结构体中为50个浮点数分配了内联空间。与标准的C#数组不同，`Numbers`不是一个指向数组的引用——它*就是*数组。如果我们运行以下代码：'
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'the result is 208: 50 four-byte floats, plus the four bytes for the `Value`
    integer, plus two bytes for the `Letter` character. The total, 206, is rounded
    to 208 due to the `floats` being aligned on four-byte boundaries (four bytes being
    the size of a `float`).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是208：50个四字节浮点数，加上`Value`整数的四个字节，加上`Letter`字符的两个字节。总计206，由于`floats`在四字节边界上对齐（四个字节是`float`的大小），所以四舍五入为208。
- en: 'We can demonstrate `MySharedData` in an `unsafe` context, most simply, with
    stack-allocated memory:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`unsafe`上下文中展示`MySharedData`，最简单的方法是使用栈分配的内存：
- en: '[PRE34]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Of course, we’re not demonstrating anything that couldn’t otherwise be achieved
    in a managed context. Suppose, however, that we want to store an instance of `MySharedData`
    on the *unmanaged heap*, outside the realm of the CLR’s garbage collector. This
    is where pointers become really useful:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们并没有展示任何在受控上下文中无法实现的事情。然而，假设我们想要将`MySharedData`的一个实例存储在*不受CLR垃圾收集器管理的非托管堆*上。这时指针变得非常有用：
- en: '[PRE35]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`Marshal.AllocHGlobal` allocates memory on the unmanaged heap. Here’s how to
    later free the same memory:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Marshal.AllocHGlobal`在非托管堆上分配内存。以下是如何稍后释放相同内存的方法：'
- en: '[PRE36]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: (The result of forgetting to free the memory is a good old-fashioned memory
    leak.)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: （忘记释放内存的结果是一个老式的内存泄漏。）
- en: Note
  id: totrans-133
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: From .NET 6, you can instead use the `NativeMemory` class for allocating and
    freeing unmanaged memory. `NativeMemory` uses a newer (and better) underlying
    API than `AllocHGlobal` and also includes methods for performing aligned allocations.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从.NET 6开始，您可以使用`NativeMemory`类来分配和释放非托管内存。`NativeMemory`使用比`AllocHGlobal`更新（更好）的底层API，并且还包括执行对齐分配的方法。
- en: 'In keeping with its name, here we use `MySharedData` in conjunction with the
    `SharedMem` class we wrote in the preceding section. The following program allocates
    a block of shared memory, and then maps the `MySharedData` struct into that memory:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，在这里我们使用`MySharedData`与我们在前一节中编写的`SharedMem`类结合使用。以下程序分配了一块共享内存块，然后将`MySharedData`结构映射到该内存中：
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-137
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can use the built-in `MemoryMappedFile` class instead of `SharedMem`, as
    follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用内置的`MemoryMappedFile`类来替代`SharedMem`，如下所示：
- en: '[PRE38]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here’s a second program that attaches to the same shared memory, reading the
    values written by the first program (it must be run while the first program is
    waiting on the `ReadLine` statement because the shared memory object is disposed
    upon leaving its `using` statement):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二个程序，它附加到相同的共享内存中，读取由第一个程序写入的值（必须在第一个程序在等待`ReadLine`语句时运行，因为共享内存对象在离开其`using`语句时被释放）：
- en: '[PRE39]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output from each of these programs is as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这些程序的输出如下：
- en: '[PRE40]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Don’t be put off by the pointers: C++ programmers use them throughout whole
    applications and are able to get everything working. At least most of the time!
    This sort of usage is fairly simple by comparison.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被指针吓到：C++程序员在整个应用程序中都在使用它们，并且大多数时候都能使其正常工作！这种用法相对简单。
- en: As it happens, our example is unsafe—quite literally—for another reason. We’ve
    not considered the thread-safety (or more precisely, process-safety) issues that
    arise with two programs accessing the same memory at once. To use this in a production
    application, we’d need to add the `volatile` keyword to the `Value` and `Letter`
    fields in the `MySharedData` struct to prevent fields from being cached by the
    Just-in-Time (JIT) compiler (or by the hardware in CPU registers). Furthermore,
    as our interaction with the fields grew beyond the trivial, we would most likely
    need to protect their access via a cross-process `Mutex`, just as we would use
    `lock` statements to protect access to fields in a multithreaded program. We discussed
    thread safety in detail in [Chapter 21](ch21.html#advanced_threadin).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如发生的那样，我们的示例因为另一个原因而不安全——字面上来说。我们没有考虑到两个程序同时访问同一内存时出现的线程安全（或更准确地说，进程安全）问题。要在生产应用程序中使用这一点，我们需要在`MySharedData`结构的`Value`和`Letter`字段中添加`volatile`关键字，以防止这些字段被即时（JIT）编译器（或硬件CPU寄存器）缓存。此外，随着我们与字段的交互超出了琐碎的范围，我们很可能需要通过跨进程的`Mutex`来保护它们的访问，就像我们在多线程程序中使用`lock`语句来保护对字段的访问一样。我们在[第21章](ch21.html#advanced_threadin)中详细讨论了线程安全性。
- en: fixed and fixed {...}
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: fixed and fixed {...}
- en: 'One limitation of mapping structs directly into memory is that the struct can
    contain only unmanaged types. If you need to share string data, for instance,
    you must use a fixed-character array instead. This means manual conversion to
    and from the `string` type. Here’s how to do it:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 直接将结构体映射到内存的一个限制是结构体只能包含未管理的类型。例如，如果你需要共享字符串数据，必须使用固定长度的字符数组。这意味着需要手动转换到和从`string`类型。以下是如何做到的：
- en: '[PRE41]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-149
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There’s no such thing as a reference to a fixed array; instead, you get a pointer.
    When you index into a fixed array, you’re actually performing pointer arithmetic!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 没有指向固定数组的引用；相反，你得到一个指针。当你索引固定数组时，实际上在进行指针算术运算！
- en: 'With the first use of the `fixed` keyword, we allocate space, inline, for 200
    characters in the struct. The same keyword (somewhat confusingly) has a different
    meaning when used later in the property definition. It instructs the CLR to *pin*
    an object so that should it decide to perform a garbage collection inside the
    `fixed` block, it will not move the underlying struct about on the memory heap
    (because its contents are being iterated via direct memory pointers). Looking
    at our program, you might wonder how `MySharedData` could ever shift in memory,
    given that it resides not on the heap but in the unmanaged world, where the garbage
    collector has no jurisdiction. The compiler doesn’t know this, however, and is
    concerned that we *might* use `MySharedData` in a managed context, so it insists
    that we add the `fixed` keyword to make our `unsafe` code safe in managed contexts.
    And the compiler does have a point—here’s all it would take to put `MySharedData`
    on the heap:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fixed`关键字首次使用时，我们在结构体中为 200 个字符分配了空间。然而，同一关键字在后续属性定义中有不同的含义。它指示 CLR *固定*
    一个对象，以便如果它决定在`fixed`块内部执行垃圾收集，它将不会移动内存堆上的底层结构（因为其内容通过直接内存指针进行迭代）。看看我们的程序，你可能会想知道`MySharedData`如何在内存中移动，因为它位于不受管理的世界中，垃圾收集器在那里无权利。然而，编译器并不知道这一点，并且担心我们*可能*在托管上下文中使用`MySharedData`，因此坚持我们添加`fixed`关键字，以使我们的`unsafe`代码在托管上下文中安全。编译器确实有一点道理——只需要将`MySharedData`放到堆上：
- en: '[PRE42]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This results in a boxed `MySharedData`—on the heap and eligible for transit
    during garbage collection.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致`MySharedData`在堆上装箱，并且在垃圾收集期间可以传输。
- en: This example illustrates how a string can be represented in a struct mapped
    to unmanaged memory. For more complex types, you also have the option of using
    existing serialization code. The one proviso is that the serialized data must
    never exceed, in length, its allocation of space in the struct; otherwise, the
    result is an unintended union with subsequent fields.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本例说明了如何在映射到未管理内存的结构体中表示字符串。对于更复杂的类型，你也可以使用现有的序列化代码。唯一的注意是序列化数据的长度绝不要超过结构体分配的空间；否则，结果将是与后续字段意外联合。
- en: COM Interoperability
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: COM 互操作性
- en: The .NET runtime provides special support for COM, enabling COM objects to be
    used from .NET, and vice versa. COM is available only on Windows.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 运行时为 COM 提供了特殊支持，使得可以从.NET使用 COM 对象，反之亦然。COM 仅在 Windows 上可用。
- en: The Purpose of COM
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: COM 的目的
- en: 'COM is an acronym for Component Object Model, a binary standard for interfacing
    with libraries, released by Microsoft in 1993\. The motivation for inventing COM
    was to enable components to communicate with each other in a language-independent
    and version-tolerant manner. Before COM, the approach in Windows was to publish
    DLLs that declared structures and functions using the C programming language.
    Not only is this approach language specific, but it’s also brittle. The specification
    of a type in such a library is inseparable from its implementation: even updating
    a structure with a new field means breaking its specification.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: COM 是 Component Object Model 的缩写，是一种与库进行接口交互的二进制标准，由微软在 1993 年发布。发明 COM 的动机是使组件能够以语言无关和版本宽容的方式相互通信。在
    COM 出现之前，Windows 的方法是发布声明使用 C 编程语言的结构和函数的 DLL。这种方法不仅特定于语言，而且很脆弱。在这样的库中，类型的规范与其实现是不可分割的：即使更新具有新字段的结构也意味着破坏其规范。
- en: The beauty of COM was to separate the specification of a type from its underlying
    implementation through a construct known as a *COM interface*. COM also allowed
    for the calling of methods on stateful *objects*—rather than being limited to
    simple procedure calls.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: COM 的优点在于通过称为*COM接口*的结构从其底层实现中分离出类型的规范。COM 还允许在有状态*对象*上调用方法，而不仅仅限于简单的过程调用。
- en: Note
  id: totrans-160
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'In a way, the .NET programming model is an evolution of the principles of COM
    programming: the .NET platform also facilitates cross-language development and
    allows binary components to evolve without breaking applications that depend on
    them.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，.NET 编程模型是 COM 编程原则的进化：.NET 平台也促进跨语言开发，并允许二进制组件在不破坏依赖于它们的应用程序的情况下演变。
- en: The Basics of the COM Type System
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: COM 类型系统的基础知识
- en: 'The COM type system revolves around interfaces. A COM interface is rather like
    a .NET interface, but it’s more prevalent because a COM type exposes its functionality
    *only* through an interface. In the .NET world, for instance, we could declare
    a type simply, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: COM 类型系统围绕接口展开。COM 接口与 .NET 接口类似，但更常见，因为 COM 类型仅通过接口公开其功能。在 .NET 世界中，例如，我们可以简单地声明一个类型，如下所示：
- en: '[PRE43]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Consumers of that type can use `Foo` directly. And if we later changed the
    *implementation* of `Test()`, calling assemblies would not require recompilation.
    In this respect, .NET separates interface from implementation—without requiring
    interfaces. We could even add an overload without breaking callers:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 类型的消费者可以直接使用 `Foo`。如果以后我们更改了 `Test()` 的*实现*，调用方不需要重新编译。在这方面，.NET 将接口与实现分离——而无需接口。我们甚至可以添加一个重载而不会破坏调用者：
- en: '[PRE44]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the COM world, `Foo` exposes its functionality through an interface to achieve
    this same decoupling. So, in `Foo`’s type library, an interface such as this would
    exist:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 COM 世界中，`Foo` 通过接口公开其功能以实现同样的解耦。因此，在 `Foo` 的类型库中，可能存在这样的接口：
- en: '[PRE45]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: (We’ve illustrated this by showing a C# interface—not a COM interface. The principle,
    however, is the same—although the plumbing is different.)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: （我们通过展示一个 C# 接口（而不是 COM 接口）来说明这一点。然而，原理是相同的——尽管具体实现方式不同。）
- en: Callers would then interact with `IFoo` rather than `Foo`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 调用方随后将与 `IFoo` 交互，而不是 `Foo`。
- en: 'When it comes to adding the overloaded version of `Test`, life is more complicated
    with COM than with .NET. First, we would avoid modifying the `IFoo` interface
    because this would break binary compatibility with the previous version (one of
    the principles of COM is that interfaces, once published, are *immutable*). Second,
    COM doesn’t allow method overloading. The solution is to instead have `Foo` implement
    a *second interface*:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及添加 `Test` 的重载版本时，使用 COM 比使用 .NET 更复杂。首先，我们将避免修改 `IFoo` 接口，因为这将破坏与前一个版本的二进制兼容性（COM
    的原则之一是一旦发布，接口就是*不可变*的）。其次，COM 不允许方法重载。解决方案是让 `Foo` 实现*第二个接口*：
- en: '[PRE46]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: (Again, we’ve transliterated this into a .NET interface for familiarity.)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: （同样，我们将其转译为 .NET 接口以便熟悉。）
- en: Supporting multiple interfaces is of key importance in making COM libraries
    versionable.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 支持多个接口对于使 COM 库具有版本化能力至关重要。
- en: IUnknown and IDispatch
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IUnknown 和 IDispatch
- en: All COM interfaces are identified with a Globally Unique Identifier (GUID).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 COM 接口都使用全局唯一标识符（GUID）来标识。
- en: 'The root interface in COM is `IUnknown`—all COM objects must implement it.
    This interface has three methods:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: COM 中的根接口是 `IUnknown`——所有 COM 对象必须实现它。该接口有三个方法：
- en: '`AddRef`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddRef`'
- en: '`Release`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Release`'
- en: '`QueryInterface`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QueryInterface`'
- en: '`AddRef` and `Release` are for lifetime management given that COM uses reference
    counting rather than automatic garbage collection (COM was designed to work with
    unmanaged code, where automatic garbage collection isn’t feasible). The `Quer⁠y​Interface`
    method returns an object reference that supports that interface, if it can do
    so.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddRef` 和 `Release` 用于生命周期管理，因为 COM 使用引用计数而不是自动垃圾回收（COM 设计用于与不可管理代码一起工作，其中自动垃圾回收不可行）。`Quer⁠y​Interface`
    方法返回一个支持该接口的对象引用，如果可以的话。'
- en: To enable dynamic programming (e.g., scripting and automation), a COM object
    can also implement `IDispatch`. This enables dynamic languages to call COM objects
    in a late-bound manner—rather like `dynamic` in C# (although only for simple invocations).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现动态编程（例如脚本和自动化），COM 对象还可以实现 `IDispatch`。这使得动态语言可以以后期绑定的方式调用 COM 对象——有点像 C#
    中的 `dynamic`（尽管仅限于简单调用）。
- en: Calling a COM Component from C#
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 C# 调用 COM 组件
- en: The CLR’s built-in support for COM means that you don’t work directly with `IUnknown`
    and `IDispatch`. Instead, you work with CLR objects, and the runtime marshals
    your calls to the COM world via Runtime-Callable Wrappers (RCWs). The runtime
    also handles lifetime management by calling `AddRef` and `Release` (when the .NET
    object is finalized) and takes care of the primitive type conversions between
    the two worlds. Type conversion ensures that each side sees, for example, the
    integer and string types in their familiar forms.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: CLR 对 COM 的内置支持意味着你不直接使用 `IUnknown` 和 `IDispatch`。相反，你使用 CLR 对象，并且运行时通过 Runtime-Callable
    Wrappers (RCWs) 将你的调用封送到 COM 世界。运行时还通过调用 `AddRef` 和 `Release`（在 .NET 对象被终结时）来处理生命周期管理，并且处理两个世界之间的原始类型转换。类型转换确保每一方以熟悉的形式看到整数和字符串类型等。
- en: Additionally, there needs to be some way to access RCWs in a statically typed
    fashion. This is the job of *COM interop types*. COM interop types are automatically
    generated proxy types that expose a .NET member for each COM member. The type
    library importer tool (*tlbimp.exe*) generates COM interop types from the command
    line, based on a COM library that you choose, and compiles them into a *COM interop
    assembly*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，需要一种以静态类型方式访问 RCW 的方法。这是*COM 互操作类型*的任务。 COM 互操作类型是自动生成的代理类型，每个 COM 成员都暴露一个
    .NET 成员。类型库导入工具（*tlbimp.exe*）基于你选择的 COM 库从命令行生成 COM 互操作类型，并将它们编译成*COM 互操作程序集*。
- en: Note
  id: totrans-186
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If a COM component implements multiple interfaces, the *tlbimp.exe* tool generates
    a single type that contains a union of members from all interfaces.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个 COM 组件实现多个接口，则 *tlbimp.exe* 工具会生成一个包含所有接口成员并集的单一类型。
- en: 'You can create a COM interop assembly in Visual Studio by going to the Add
    Reference dialog box and choosing a library from the COM tab. For example, if
    you have Microsoft Excel installed, adding a reference to the Microsoft Excel
    Object Library allows you to interoperate with Excel’s COM classes. Here’s the
    C# code to create and show a workbook, and then populate a cell in that workbook:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Visual Studio 中通过转到“添加引用”对话框框，并从 COM 选项卡中选择一个库来创建 COM 互操作程序集。例如，如果安装了 Microsoft
    Excel，则添加对 Microsoft Excel 对象库的引用允许你与 Excel 的 COM 类互操作。以下是创建和显示工作簿，然后在该工作簿中填充单元格的
    C# 代码：
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'It is currently necessary to embed interop types in your application (otherwise,
    the runtime won’t locate them at runtime). Either click the COM reference in Visual
    Studio’s Solution Explorer and set the Embed Interop Types property to true in
    the Properties window, or open your *.csproj* file and add the following line
    (in boldface):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当前需要在应用程序中嵌入互操作类型（否则，运行时无法在运行时找到它们）。可以在 Visual Studio 的解决方案资源管理器中单击 COM 引用，然后在属性窗口中将
    Embed Interop Types 属性设置为 true，或者打开 *.csproj* 文件并添加以下行（**加粗**）：
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `Excel.Application` class is a COM interop type whose runtime type is an
    RCW. When we access the `Workbooks` and `Cells` properties, we get back more interop
    types.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`Excel.Application` 类是一个 COM 互操作类型，其运行时类型是一个 RCW。当我们访问 `Workbooks` 和 `Cells`
    属性时，会得到更多的互操作类型。'
- en: Optional Parameters and Named Arguments
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选参数和命名参数
- en: 'Because COM APIs don’t support function overloading, it’s very common to have
    functions with numerous parameters, many of which are optional. For instance,
    here’s how you might call an Excel workbook’s `Save` method:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 COM API 不支持函数重载，所以经常有函数具有许多参数，其中许多是可选的。例如，这是如何调用 Excel 工作簿的 `Save` 方法的方式：
- en: '[PRE49]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The good news is that the C#’s support for optional parameters is COM-aware,
    so we can just do this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，C# 对可选参数的支持是 COM 感知的，所以我们可以这样做：
- en: '[PRE50]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: (As we stated in [Chapter 3](ch03.html#creating_types_in_chash), optional parameters
    are “expanded” by the compiler into the full verbose form.)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: （正如我们在 [第 3 章](ch03.html#creating_types_in_chash) 中所述，可选参数由编译器“展开”为完整的冗长形式。）
- en: 'Named arguments allow you to specify additional arguments, regardless of their
    position:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 命名参数允许你指定额外的参数，而不管它们的位置如何：
- en: '[PRE51]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Implicit ref Parameters
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式 ref 参数
- en: Some COM APIs (Microsoft Word, in particular) expose functions that declare
    *every* parameter as pass-by-reference—whether or not the function modifies the
    parameter value. This is because of the perceived performance gain from not copying
    argument values (the *real* performance gain is negligible).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 COM API（特别是 Microsoft Word）公开的函数将*每一个*参数声明为按引用传递，无论函数是否修改参数值。这是因为认为不复制参数值会带来性能提升（*实际*性能提升微乎其微）。
- en: 'Historically, calling such methods from C# has been clumsy because you must
    specify the `ref` keyword with every argument, and this prevents the use of optional
    parameters. For instance, to open a Word document, we used to have to do this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，从 C# 调用这样的方法一直很笨拙，因为您必须对每个参数指定 `ref` 关键字，这会阻止使用可选参数。例如，要打开 Word 文档，我们过去必须这样做：
- en: '[PRE52]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Thanks to implicit ref parameters, you can omit the `ref` modifier on COM function
    calls, allowing the use of optional parameters:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于隐式引用参数，您可以省略 COM 函数调用中的 `ref` 修饰符，从而允许使用可选参数：
- en: '[PRE53]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The caveat is that you will get neither a compile-time nor a runtime error if
    the COM method you’re calling actually does mutate an argument value.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点是，如果调用的 COM 方法实际上会改变参数值，您既不会得到编译时错误，也不会得到运行时错误。
- en: Indexers
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引器
- en: 'The ability to omit the `ref` modifier has another benefit: it makes COM indexers
    with `ref` parameters accessible via ordinary C# indexer syntax. This would otherwise
    be forbidden because `ref`/`out` parameters are not supported with C# indexers.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 省略 `ref` 修饰符的能力还有另一个好处：它使带有 `ref` 参数的 COM 索引器可通过普通的 C# 索引器语法访问。否则，这将被禁止，因为 `ref`/`out`
    参数在 C# 索引器中不受支持。
- en: 'You can also call COM properties that accept arguments. In the following example,
    `Foo` is a property that accepts an integer argument:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以调用接受参数的 COM 属性。在以下示例中，`Foo` 是一个接受整数参数的属性：
- en: '[PRE54]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Writing such properties yourself in C# is still prohibited: a type can expose
    an indexer only on itself (the “default” indexer). Therefore, if you wanted to
    write code in C# that would make the preceding statement legal, `Foo` would need
    to return another type that exposed a (default) indexer.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中自己编写这样的属性仍然是被禁止的：类型只能在自身上（“默认”索引器）公开索引器。因此，如果您想在 C# 中编写使前述语句合法的代码，`Foo`
    需要返回另一种公开了（默认）索引器的类型。
- en: Dynamic Binding
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态绑定
- en: There are two ways that dynamic binding can help when calling COM components.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 动态绑定在调用 COM 组件时有两种帮助方式。
- en: 'The first way is in allowing access to a COM component without a COM interop
    type. To do this, call `Type.GetTypeFromProgID` with the COM component name to
    obtain a COM instance, and then use dynamic binding to call members from then
    on. Of course, there’s no IntelliSense, and compile-time checks are impossible:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方式是允许访问不使用 COM 互操作类型的 COM 组件。为此，请调用 `Type.GetTypeFromProgID` 以获取 COM 实例的
    COM 组件名称，然后使用动态绑定从此调用成员。当然，这没有 IntelliSense，并且无法进行编译时检查：
- en: '[PRE55]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: (The same thing can be achieved, much more clumsily, with reflection instead
    of dynamic binding.)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: （可以用反射而不是动态绑定实现相同的功能，但更加笨拙。）
- en: Note
  id: totrans-219
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A variation of this theme is calling a COM component that supports *only* `IDispatch`.
    Such components are quite rare, however.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此主题的一个变种是调用仅支持 `IDispatch` 的 COM 组件。但是，这样的组件非常罕见。
- en: Dynamic binding can also be useful (to a lesser extent) in dealing with the
    COM `variant` type. For reasons due more to poor design than necessity, COM API
    functions are often peppered with this type, which is roughly equivalent to `object`
    in .NET. If you enable “Embed Interop Types” in your project (more on this soon),
    the runtime will map `variant` to `dynamic`, instead of mapping `variant` to `object`,
    avoiding the need for casts. For instance, you could legally do
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 动态绑定在处理 COM `variant` 类型时也可能有用（程度较低）。由于设计不良而非必要原因，COM API 函数经常会用到这种类型，它在 .NET
    中大致相当于 `object`。如果在项目中启用了“嵌入互操作类型”（稍后详述），运行时会将 `variant` 映射为 `dynamic`，而不是映射为
    `object`，从而避免了需要进行强制类型转换。例如，您可以合法地执行以下操作：
- en: '[PRE56]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'instead of:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是：
- en: '[PRE57]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The disadvantage of working in this way is that you lose autocompletion, so
    you must know that a property called `Font` happens to exist. For this reason,
    it’s usually easier to *dynamically* assign the result to its known interop type:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式工作的缺点是，您会失去自动完成功能，因此您必须知道名为 `Font` 的属性存在。因此，通常更容易*动态地*将结果分配给其已知的互操作类型：
- en: '[PRE58]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As you can see, this saves only five characters over the old-fashioned approach!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，与老式方法相比，这仅节省了五个字符！
- en: The mapping of `variant` to `dynamic` is the default, and is a function of enabling
    Embed Interop Types on a reference.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `variant` 映射为 `dynamic` 是默认设置，并且是启用引用时的一个功能。
- en: Embedding Interop Types
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入互操作类型
- en: We said previously that C# ordinarily calls COM components via interop types
    that are generated by calling the *tlbimp.exe* tool (directly or via Visual Studio).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前说过，C# 通常通过调用 *tlbimp.exe* 工具（直接或通过 Visual Studio）生成的互操作类型来调用 COM 组件。
- en: Historically, your only option was to *reference* interop assemblies just as
    you would with any other assembly. This could be troublesome because interop assemblies
    can get quite large with complex COM components. A tiny add-in for Microsoft Word,
    for instance, requires an interop assembly that is orders of magnitude larger
    than itself.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，你唯一的选择是像对待任何其他程序集一样*引用*互操作程序集。这可能会麻烦，因为互操作程序集可以因复杂的COM组件而变得相当庞大。例如，微软Word的一个小插件需要一个比其自身大几个数量级的互操作程序集。
- en: Rather than *referencing* an interop assembly, you have the option of embedding
    the portions that you use. The compiler analyzes the assembly to work out precisely
    the types and members that your application requires, and embeds definitions for
    (just) those types and members directly in your application. This avoids bloat
    as well as the need to ship an additional file.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是*引用*互操作程序集，你可以选择嵌入你使用的部分。编译器会分析程序集，精确确定应用程序所需的类型和成员，并直接在应用程序中嵌入这些类型和成员的定义。这样既避免了臃肿，又避免了需要额外传送文件。
- en: To enable this feature, either select the COM reference in Visual Studio’s Solution
    Explorer and then set Embed Interop Types to true in the Properties window, or
    edit your *.csproj* file as we described earlier (see [“Calling a COM Component
    from C#”](#calling_a_com_component_from_chash)).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用此功能，可以在Visual Studio的解决方案资源管理器中选择COM引用，然后在属性窗口中将“嵌入互操作类型”设置为true，或者像我们之前描述的那样编辑*.csproj*文件（参见[“从C#调用COM组件”](#calling_a_com_component_from_chash)）。
- en: Type Equivalence
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型等价性
- en: The CLR supports *type equivalence* for linked interop types. This means that
    if two assemblies each link to an interop type, those types will be considered
    equivalent if they wrap the same COM type. This holds true even if the interop
    assemblies to which they linked were generated independently.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: CLR支持链接互操作类型的*类型等价性*。这意味着如果两个程序集分别链接到一个互操作类型，那么即使这些链接到的互操作程序集是独立生成的，这些类型也会被视为等效，只要它们包装了相同的COM类型。
- en: Note
  id: totrans-236
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Type equivalence relies on the `TypeIdentifierAttribute` attribute in the `System.Runtime.InteropServices`
    namespace. The compiler automatically applies this attribute when you link to
    interop assemblies. COM types are then considered equivalent if they have the
    same GUID.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 类型等价性依赖于`System.Runtime.InteropServices`命名空间中的`TypeIdentifierAttribute`特性。当链接到互操作程序集时，编译器会自动应用此特性。如果COM类型具有相同的GUID，则这些类型被认为是等效的。
- en: Exposing C# Objects to COM
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将C#对象公开给COM
- en: It’s also possible to write classes in C# that can be consumed in the COM world.
    The CLR makes this possible through a proxy called a *COM-Callable Wrapper* (CCW).
    A CCW marshals types between the two worlds (as with an RCW) and implements `IUnknown`
    (and optionally `IDispatch`) as required by the COM protocol. A CCW is lifetime-controlled
    from the COM side via reference counting (rather than through the CLR’s garbage
    collector).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以在C#中编写可以在COM世界中消耗的类。CLR通过称为*COM-Callable Wrapper*（CCW）的代理实现了这一点。CCW在两个世界之间进行类型的封送（与RCW类似），并根据COM协议实现了`IUnknown`（和可选的`IDispatch`）。CCW通过引用计数从COM侧进行生命周期控制（而不是通过CLR的垃圾收集器）。
- en: 'You can expose any public class to COM (as an “in-proc” server). To do so,
    first create an interface, assign it a unique GUID (in Visual Studio, you can
    use Tools > Create GUID), declare it visible to COM, and then set the interface
    type:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将任何公共类公开给COM（作为“进程内”服务器）。要实现此功能，首先创建一个接口，分配一个唯一的GUID（在Visual Studio中，你可以使用工具
    > 创建GUID），声明其对COM可见，然后设置接口类型：
- en: '[PRE59]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Next, provide an implementation of your interface, assigning a unique GUID
    to that implementation:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，提供一个接口的实现，并为该实现分配一个唯一的GUID：
- en: '[PRE60]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Edit your .*csproj* file, adding the following line:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑你的.*csproj*文件，添加以下行：
- en: '[PRE61]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, when you build your project, an additional file is generated, *MyCom​.com⁠host.dll*,
    which can be registered for COM interop. (Keep in mind that the file will always
    be 32 bit or 64 bit depending on your project configuration: there’s no such thing
    as “Any CPU” in this scenario.) From an *elevated* command prompt, switch to the
    directory holding your DLL and run *regsvr32 MyCom.comhost.dll*.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你构建你的项目时，会生成一个额外的文件，*MyCom​.com⁠host.dll*，可以注册为COM互操作。（请记住，该文件始终是32位或64位，取决于你的项目配置：在这种情况下不存在“任何CPU”选项。）从*提升的*命令提示符中，切换到保存DLL的目录，并运行*regsvr32
    MyCom.comhost.dll*。
- en: 'You can then consume your COM component from most COM-capable languages. For
    example, you can create this Visual Basic Script in a text editor and run it by
    double-clicking the file in Windows Explorer, or by starting it from a command
    prompt as you would a program:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以从大多数支持 COM 的语言中消费您的 COM 组件。例如，您可以在文本编辑器中创建此 Visual Basic 脚本，并通过在 Windows
    资源管理器中双击该文件或从命令提示符中启动它来运行它，就像运行程序一样：
- en: '[PRE62]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note that .NET Framework cannot be loaded into the same process as .NET 5+ or
    .NET Core. Therefore, a .NET 5+ COM server cannot be loaded into a .NET Framework
    COM client process, or vice versa.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，.NET Framework 不能加载到与 .NET 5+ 或 .NET Core 相同的进程中。因此，.NET 5+ COM 服务器无法加载到
    .NET Framework COM 客户端进程中，反之亦然。
- en: Enabling Registry-Free COM
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用无注册表 COM
- en: 'Traditionally, COM adds type information to the registry. Registry-free COM
    uses a manifest file instead of the registry to control object activation. To
    enable this feature, add the following line (in boldface) to your *.csproj* file:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，COM 将类型信息添加到注册表中。无注册表 COM 使用一个清单文件而不是注册表来控制对象的激活。要启用此功能，请将以下行（加粗）添加到您的 *.csproj*
    文件中：
- en: '[PRE63]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Your build will then generate *MyCom.X.manifest*.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您的构建将生成 *MyCom.X.manifest*。
- en: Note
  id: totrans-254
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There is no support in .NET 5+ for generating a COM type library (*.tlb). You
    can manually write an IDL (Interface Definition Language) file or C++ header for
    the native declarations in your interface.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 5+ 中不支持生成 COM 类型库 (*.tlb)。您可以手动编写一个 IDL（接口定义语言）文件或者 C++ 头文件来定义接口中的本地声明。
