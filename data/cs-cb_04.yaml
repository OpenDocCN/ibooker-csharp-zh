- en: Chapter 4\. Querying with LINQ
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章\. 使用 LINQ 进行查询
- en: LINQ has been around since C# 3\. It gives developers a means to query data
    sources, using syntax with accents of SQL. Because LINQ is part of the language,
    you experience features like syntax highlighting and IntelliSense in IDEs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 自 C# 3 开始就已经存在。它为开发人员提供了一种查询数据源的方式，使用带有 SQL 风格的语法。因为 LINQ 是语言的一部分，您可以在
    IDE 中体验到语法高亮和智能感知等功能。
- en: LINQ is popularly known as a tool for querying databases, with the goal of reducing
    what is called *impedance mismatch*, which is the difference between database
    representation of data and C# objects. Really, we can build LINQ providers for
    any data technology. In fact, the author wrote an open source provider for the
    Twitter API named [LINQ to Twitter](https://oreil.ly/1YEZ8).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 通常被认为是一个用于查询数据库的工具，其目标是减少所谓的 *阻抗不匹配*，即数据库数据表示与 C# 对象之间的差异。事实上，我们可以为任何数据技术构建
    LINQ 提供程序。事实上，作者为 Twitter API 编写了一个开源提供程序，名为 [LINQ to Twitter](https://oreil.ly/1YEZ8)。
- en: The examples in this chapter take a different approach. Instead of an external
    data source, they use a provider that specifically focuses on in-memory data sources
    referred to as LINQ to Objects. While any in-memory data manipulation can be performed
    with C# loops and imperative logic, using LINQ instead can often simplify the
    code because of its declarative nature—specifying what to do rather than how to
    do it. Each section has a unique representation of one or more entities (objects
    to be queried) and an `InMemoryContext` that sets up the in-memory data to be
    queried.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例采用了一种不同的方法。它们不使用外部数据源，而是使用专门针对内存数据源的提供程序，称为 LINQ to Objects。尽管可以使用 C# 循环和命令式逻辑执行任何内存数据操作，但通常使用
    LINQ 可以简化代码，因为它具有声明性的特性——指定要做什么而不是如何做。每个部分都有一个或多个实体（要查询的对象）的独特表示，以及设置了用于查询的 `InMemoryContext`
    的内存数据。
- en: A couple of recipes in this chapter are simple, such as transforming object
    shape and simplifying queries. However, there are important points to be made
    that also clarify and simplify your code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中有几个简单的示例，如转换对象形状和简化查询。然而，也有一些重要的观点可以澄清和简化您的代码。
- en: Pulling together code from different data sources can result in confusing code.
    The sections on joins, left joins, and grouping describe how you can simplify
    these scenarios. There’s also a related section for operating on sets.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 从不同数据源中汇集代码可能导致混乱的代码。关于连接、左连接和分组的部分描述了如何简化这些场景。还有一个相关的部分用于处理集合操作。
- en: A huge security problem with search forms and queries appears when developers
    build their queries with concatenated strings. While that might sound like a quick
    and easy solution, the cost is often too high. This chapter has a couple of sections
    that show how LINQ deferred execution lets you build queries dynamically. Another
    section explains an important technique for search queries and how they give you
    the ability to use expression trees for dynamic clause generation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员在构建带有连接字符串的查询时，会出现搜索表单和查询的严重安全问题。虽然这听起来可能是一个快速简单的解决方案，但通常代价过高。本章包含几节，展示了
    LINQ 延迟执行如何让您动态构建查询。另一节解释了一种重要的搜索查询技术，以及它如何让您能够使用表达树生成动态子句。
- en: 4.1 Transforming Object Shape
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.1 转换对象形状
- en: Problem
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want data in a custom shape that differs from the original data source.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望数据呈现自定义形状，与原始数据源不同。
- en: Solution
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s the entity to reshape:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是需要重塑的实体：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is the data source:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数据源：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This code performs the projection that reshapes the data:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码执行了重新塑形数据的投影：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Discussion
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Transforming object shape is referred to as a *projection* in LINQ. A few common
    reasons you might want to do this is to create lookup lists, create a view or
    view model object, or translate data transfer objects (DTOs) to something your
    app works with better.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LINQ 中，将对象形状转换称为 *投影*。您可能希望这样做的几个常见原因包括创建查找列表、创建视图或视图模型对象，或将数据传输对象（DTO）转换为您的应用更好处理的格式。
- en: When doing database queries using LINQ to Entities (a different provider for
    databases), or consuming DTOs, data often arrives in a format representing the
    original data source. However, if you want to work with domain data or bind to
    UIs, the pure data representation doesn’t have the right shape. Moreover, data
    representation often has attributes and semantics of the object-relational model
    (ORM) or data access library. Some developers try to bind these data objects to
    their UI because they don’t want to create a new object type. While that’s understandable,
    because no one wants to do more work than is necessary, problems occur because
    UI code often requires a different shape of the data and requires its own validation
    and attributes. So, the problem here is that you’re using one object for two different
    purposes. Ideally, an object should have a single responsibility, and mixing it
    up like this often results in confusing code that’s not as easy to maintain.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 LINQ to Entities 进行数据库查询（一种不同于数据库的提供程序）或使用 DTOs 消费数据时，数据通常以表示原始数据源的格式到达。然而，如果你想要处理领域数据或绑定到
    UI，纯数据表示形式可能不具有正确的形状。此外，数据表示通常具有对象关系模型（ORM）或数据访问库的属性和语义。一些开发人员试图将这些数据对象绑定到他们的
    UI，因为他们不想创建新的对象类型。尽管这可以理解，因为没有人愿意比必要工作更多，但问题是 UI 代码通常需要不同形状的数据，并且需要自己的验证和属性。因此，问题在于你为两种不同目的使用一个对象。理想情况下，一个对象应该具有单一职责，而这样混合使用通常会导致代码混乱，难以维护。
- en: Another scenario that the solution demonstrates is the case where you only want
    a lookup list, with an ID and displayable value. This is useful when populating
    UI elements such as checkbox lists, radio button groups, combo boxes, or dropdowns.
    Querying entire entities is wasteful and slow (in the case of an out-of-process
    or cross-network database connection) when you only need the ID and something
    to display to the user.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案展示的另一种场景是仅需查找列表的情况，带有 ID 和可显示值。当填充 UI 元素如复选框列表、单选按钮组、组合框或下拉框时，这非常有用。如果需要的只是
    ID 和一些显示给用户的内容，查询整个实体将会很浪费且慢（尤其是在跨进程或跨网络的数据库连接中）。
- en: The `Main` method of the solution demonstrates this. It queries the `SalesPeople`
    property of `InMemoryContext`, which is a list of `SalesPerson`, and the `select`
    clause re-shapes the result into a tuple of `ID` and `Name`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案的 `Main` 方法展示了这一点。它查询了 `InMemoryContext` 的 `SalesPeople` 属性，这是一个 `SalesPerson`
    列表，而 `select` 子句重新将结果重新塑形为 `ID` 和 `Name` 的元组。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `select` clause in the solution uses a tuple. However, you could project
    (only the requested fields) into an anonymous type, a `SalesPerson` type, or a
    new custom type.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案中的 `select` 子句使用了一个元组。然而，你也可以将请求的字段投影（仅投影请求的字段）到一个匿名类型、一个 `SalesPerson`
    类型或一个新的自定义类型中。
- en: Although this was an in-memory operation, the benefit of this technique comes
    when querying a database with a library like LINQ to Entities. In that case, LINQ
    to Entities translates the LINQ query into a database query that only requests
    the fields specified in the select clause.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个内存操作，但这种技术的好处在于使用 LINQ to Entities 这样的库查询数据库时体现出来。在这种情况下，LINQ to Entities
    将 LINQ 查询转换为仅请求 select 子句中指定的字段的数据库查询。
- en: 4.2 Joining Data
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.2 数据连接
- en: Problem
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to pull data from different sources into one record.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要从不同的源中提取数据到一条记录中。
- en: Solution
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here are the entities to join:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是要连接的实体：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is the data source:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数据源：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is the code that joins the entities:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是连接实体的代码：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Discussion
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: LINQ joins are useful when data comes from more than one source. A company might
    have merged and you need to pull in data from each of their databases, you might
    be using a microservice architecture where the data comes from different services,
    or some of the data was created in-memory and you need to correlate it with database
    records.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据来自多个源时，LINQ 连接非常有用。一个公司可能已经合并，你需要从每个数据库中提取数据，你可能正在使用微服务架构，数据来自不同的服务，或者一些数据是在内存中创建的，你需要将其与数据库记录关联起来。
- en: Often, you can’t use an ID because if the data comes from different sources,
    they’ll never match anyway. The best you can hope for is that some of the fields
    line up. That said, if you have a single field that matches, that’s great. The
    `Main` method of the solution uses a composite key of `Region` and `ProductType`,
    relying on the value equality inherent in tuples.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，无法使用 ID，因为如果数据来自不同的源，它们永远不会匹配。你唯一能期望的是一些字段能够对应上。话虽如此，如果有单个字段匹配，那就太好了。解决方案的
    `Main` 方法使用了 `Region` 和 `ProductType` 的组合键，并依赖于元组中的值相等性。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `select` clause uses an anonymous type for a custom projection. Another
    example of shaping object data is discussed in [Recipe 4.1](#transforming_object_shape).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`select`子句使用匿名类型进行自定义投影。关于形状化对象数据的另一个示例在[Recipe 4.1](#transforming_object_shape)中讨论。'
- en: Even though this example uses a tuple for the composite key, you could use an
    anonymous type for the same results. The tuple uses slightly less syntax.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 即使此示例使用元组作为复合键，您也可以使用匿名类型获得相同的结果。元组使用稍少的语法。
- en: See Also
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 4.1, “Transforming Object Shape”](#transforming_object_shape)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 4.1，“形状化对象形状”](#transforming_object_shape)'
- en: 4.3 Performing Left Joins
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.3 执行左连接
- en: Problem
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need a join on two data sources, but one of those data sources doesn’t have
    a matching record.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在两个数据源上进行连接，但其中一个数据源没有匹配记录。
- en: Solution
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here are the entities to perform a left join with:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是要执行左连接的实体：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is the data source:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数据源：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following code performs the left join operation:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码执行左连接操作：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And here’s the output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Discussion
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: This solution is similar to the `join`, discussed in [Recipe 4.3](#performing_left_joins).
    The difference is in the LINQ query in the `Main` method. Notice the `into prodPersonTemp`
    clause. This is a temporary holder for the joined data. The second `from` clause
    (below `into`) queries `prodPersonTemp.DefaultIfEmpty()`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此解决方案类似于在[Recipe 4.3](#performing_left_joins)中讨论的`join`，不同之处在于`Main`方法的LINQ查询。注意`into
    prodPersonTemp`子句。这是联接数据的临时持有者。第二个`from`子句（`into`下方）查询`prodPersonTemp.DefaultIfEmpty()`。
- en: The `DefaultIfEmpty()` causes the left join, where the `prodPerson` range variable
    receives all of the product objects and only the matching person objects.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefaultIfEmpty()`导致左连接，其中`prodPerson`范围变量接收所有产品对象和仅匹配的人员对象。'
- en: The first `from` clause specifies the left side of the query, `Products`. The
    `join` clause specifies the right side of the query, `SalesPeople`, which might
    not have matching values.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`from`子句指定查询的左侧，`Products`。`join`子句指定查询的右侧，`SalesPeople`，这些可能没有匹配值。
- en: Notice how the `select` clause checks `prodPerson?.Name` for `null` and replaces
    it with `(none)`. This ensures the output indicates that there wasn’t a match,
    rather than relying on later code to check for null.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`select`子句如何检查`prodPerson?.Name`是否为`null`，并将其替换为`(none)`。这样确保输出指示没有匹配项，而不是依赖后续代码来检查null。
- en: Demonstrating left join results in the solution output. Notice that output for
    Product 1 and Product 4 have a Person entry. However, there wasn’t a matching
    Person, showing as `(none)`, for Products 2 and 3.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 展示左连接结果在解决方案输出中。注意，产品1和产品4的输出有一个人员条目。然而，产品2和产品3没有匹配的人员，显示为`(none)`。
- en: 4.4 Grouping Data
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.4 数据分组
- en: Problem
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to aggregate data into custom groups.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将数据聚合到自定义组中。
- en: Solution
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s the entity to group:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是要分组的实体：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is the data source:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数据源：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following code groups the data:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码对数据进行分组：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Discussion
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Grouping is useful when you need a hierarchy of data. It creates a parent/children
    relationship between data where the parent is the main category and the children
    are objects (representing data records) in that category.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 分组在需要数据层次结构时很有用。它在数据的父/子关系中创建一个父类别和子对象（表示该类别中的数据记录）之间的关系。
- en: In the solution, each `SalesPerson` has a `Region` property, whose values are
    repeated in the `InMemoryContext` data source. This helps show how multiple `SalesPerson`
    entities can be grouped into a single region.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中，每个`SalesPerson`都有一个`Region`属性，其值在`InMemoryContext`数据源中重复。这有助于显示如何将多个`SalesPerson`实体分组到单个区域中。
- en: In the `Main` method query, there’s a `group by` clause, specifying the range
    variable, `person`, to group and the key, `Region`, to group by. The `personGroup`
    holds the result. In this example, the `select` clause uses the entire `personGroup`,
    rather than doing a custom projection.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Main`方法查询中，有一个`group by`子句，指定范围变量`person`进行分组，以及键`Region`进行分组。`personGroup`保存结果。在这个例子中，`select`子句使用整个`personGroup`，而不是进行自定义投影。
- en: 'Inside of `salesPeopleByRegion` is a set of top-level objects, representing
    each group. Each of those groups has a collection of objects belonging to that
    group, like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`salesPeopleByRegion`中是一组顶级对象，代表每个组。每个组都有属于该组的对象集合，如下所示：'
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-77
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: LINQ providers targeting databases, such as LINQ to Entities for SQL Server,
    return `IQueryable<T>`, for nonmaterialized queries. Materialization occurs when
    you use an operator, such as `Count()` or `ToList()`, that actually executes the
    query and returns an `int` or `List<T>`, respectively. In contrast, the nonmaterialized
    type returned by LINQ to Objects is `IEnumerable<T>`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 针对数据库的 LINQ 提供程序，如针对 SQL Server 的 LINQ to Entities，返回非物化查询的 `IQueryable<T>`。物化发生在您使用
    `Count()` 或 `ToList()` 等运算符时，实际执行查询并返回 `int` 或 `List<T>`。相比之下，LINQ to Objects
    返回的非物化类型是 `IEnumerable<T>`。
- en: The `foreach` loop demonstrates this group structure and how it could be used.
    At the top level, each object has a `Key` property. Because the original query
    was by `Region`, that key will have the name of the `Region`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach` 循环演示了此组结构及其如何使用。在顶层，每个对象都有一个 `Key` 属性。因为原始查询是按 `Region` 进行的，所以该键将具有
    `Region` 的名称。'
- en: The nested `foreach` loop iterates on the group, reading each `SalesPerson`
    instance in that group. You can see where it prints out the `Name` of each `SalesPerson`
    instance in that group.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套的 `foreach` 循环在组上迭代，读取该组中的每个 `SalesPerson` 实例。您可以看到它打印出该组中每个 `SalesPerson`
    实例的 `Name`。
- en: 4.5 Building Incremental Queries
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.5 构建增量查询
- en: Problem
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to customize a query based on a user’s search criteria but don’t want
    to concatenate strings.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要根据用户的搜索条件定制查询，但不希望串联字符串。
- en: Solution
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This is the type to query:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是要查询的类型：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here’s the data source:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数据源：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This code builds a dynamic query:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码构建动态查询：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Discussion
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: One of the worst things a developer can do from a security perspective is to
    build a concatenated string from user input to send as a SQL statement to a database.
    The problem is that string concatenation allows the user’s input to be interpreted
    as part of the query. In most cases, people just want to perform a search. However,
    there are malicious users who intentionally probe systems for this type of vulnerability.
    They don’t have to be professional hackers as there are plenty of novices (often
    referred to as *script kiddies*) who want to practice and have fun. In the worst
    case, hackers can access private or proprietary information or even take over
    a machine. Once into one machine on a network, the hacker is on the inside and
    can monkey bar into other computers and take over your network. This particular
    problem is called a *SQL injection attack* and this section explains how to avoid
    it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全的角度来看，开发人员可以做的最糟糕的事情之一就是从用户输入构建一个串联的字符串，以此作为 SQL 语句发送到数据库。问题在于字符串串联允许用户的输入被解释为查询的一部分。在大多数情况下，人们只想执行搜索。然而，有恶意用户有意地探测系统的这种漏洞。他们不必是专业黑客，因为有很多初学者（通常被称为*脚本小子*）想要练习并玩得开心。在最糟糕的情况下，黑客可以访问私人或专有信息，甚至接管一台机器。一旦进入网络中的一台机器，黑客就在内部，并且可以攀爬到其他计算机并接管您的网络。这个特定问题被称为*SQL
    注入攻击*，本节解释了如何避免这种情况。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: From a security point of view, no computer is theoretically 100% secure because
    there’s always a level of effort, either physical or virtual, where a computer
    can be broken into. In practice, security efforts can grow to a point that they
    become prohibitively expensive to build, purchase, and maintain. Your goal is
    to perform a threat assessment of a system (outside the scope of this book) that’s
    strong enough to deter potential hackers. In most cases, having not been able
    to perform the typical attacks, like SQL injection, a hacker will assess their
    own costs of attacking your system and move on to a different system that is less
    time consuming or expensive. This section offers a low-cost option to solve a
    high-cost security disaster.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来看，理论上没有一台计算机可以百分之百安全，因为总有一定程度的努力，无论是物理的还是虚拟的，都可以破解计算机。实际上，安全措施可能会增长到一个成本高得无法承受的程度，包括建设、购买和维护。你的目标是对系统进行威胁评估（超出本书范围），足以阻止潜在的黑客。在大多数情况下，如果未能执行典型的攻击，如
    SQL 注入，黑客将评估攻击你的系统的成本，然后转向耗时或成本更低的其他系统。本节提供了解决高成本安全灾难的低成本选项。
- en: The scenario for this section imagines a situation where the user can perform
    a search. They fill in the data and the application dynamically builds a query,
    based on the criteria the user entered.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的场景设想了一个用户可以执行搜索的情况。他们填写数据，应用程序根据用户输入的条件动态构建查询。
- en: In the solution, the `Program` class has a method named `GetCriteriaFromUser`.
    The purpose of this method is to ask for a matching value for each field inside
    of `SalesPerson`. This becomes the criteria for building a dynamic query. Any
    fields left blank aren’t included in the final query.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中，`Program` 类有一个名为 `GetCriteriaFromUser` 的方法。此方法的目的是为 `SalesPerson` 内的每个字段询问匹配值。这些值成为构建动态查询的标准。如果任何字段为空，则不会包含在最终查询中。
- en: The `QuerySalesPeople` method starts with a LINQ query for `ctx.SalesPeople`.
    However, notice that this isn’t in parentheses or calling the `ToList` operator,
    like previous sections. Calling `ToList` would have materialized the query, causing
    it to execute. However, we aren’t doing that here—the code is just building a
    query. That’s why the `salesPersonQuery` has the `IEnumerable<SalesPerson>` type,
    indicating that it’s a LINQ to Objects result, rather than a `List<SalesPerson>`
    we would have gotten back via a call to `ToList`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`QuerySalesPeople` 方法从 `ctx.SalesPeople` 开始一个 LINQ 查询。然而，请注意，这不像前几节那样放在括号中或调用
    `ToList` 操作符。调用 `ToList` 会实现查询，导致其执行。但是，在这里我们没有这样做 - 代码只是在构建查询。这就是为什么 `salesPersonQuery`
    具有 `IEnumerable<SalesPerson>` 类型，表示它是 LINQ 到对象的结果，而不是通过调用 `ToList` 获得的 `List<SalesPerson>`。'
- en: Note
  id: totrans-98
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This recipe takes advantage of a feature of LINQ, known as *deferred query execution*,
    which allows you to build the query that won’t execute until you tell it to. In
    addition to facilitating dynamic query construction, deferred execution is also
    efficient because there’s only a single query sent to the database, rather than
    each time the algorithm calls a specific LINQ operator.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方利用了 LINQ 的一项功能，称为 *延迟查询执行*，它允许您构建查询，直到您告诉它执行。除了促进动态查询构建外，延迟执行还非常高效，因为仅发送一个查询到数据库，而不是每次算法调用特定的
    LINQ 操作符时都发送查询。
- en: With the `salesPersonQuery` reference, the code checks each `SalesPerson` field
    for a value. If the user did enter a value for that field, the code uses a `Where`
    operator to check for equality with what the user entered.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `salesPersonQuery` 引用，代码检查每个 `SalesPerson` 字段是否有值。如果用户为该字段输入了值，则代码使用 `Where`
    操作符检查与用户输入的值是否相等。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You’ve seen LINQ queries with language syntax in previous sections. However,
    this section takes advantage of another way to use LINQ via a fluent interface,
    called *method syntax*. This is much like the builder pattern you learned about
    in [Recipe 1.10](ch01.xhtml#constructing_objects_with_complex_configuration).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几节中，您已经看到了使用语言语法的 LINQ 查询。但是，本节利用了另一种使用 LINQ 的方式，即通过流畅接口称为 *方法语法*。这与您在 [Recipe
    1.10, “Constructing Objects with Complex Configuration”](ch01.xhtml#constructing_objects_with_complex_configuration)
    中了解到的建造者模式非常相似。
- en: So far, the only thing that has happened is that we’ve dynamically built a LINQ
    query and, because of deferred execution, the query hasn’t run yet. Finally, the
    code calls `ToList` on `salesPersonQuery`, materializing the query. As the return
    type of this method indicates, this returns a `List<SalesPerson>`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，唯一发生的事情是我们动态构建了一个 LINQ 查询，并且由于延迟执行的原因，该查询尚未运行。最后，代码在 `salesPersonQuery`
    上调用 `ToList`，实现了查询。由于此方法的返回类型，这将返回一个 `List<SalesPerson>`。
- en: Now, the algorithm has built and executed a dynamic query, protected from SQL
    injection attack. This protection comes from the fact that the LINQ provider always
    parameterizes user input so it will be treated as parameter data, rather than
    as part of the query. As a side benefit, you also have a method with strongly
    typed code, where you don’t have to worry about inadvertent and hard-to-find typos.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，算法已经构建并执行了一个动态查询，从 SQL 注入攻击中受到保护。这种保护来自于 LINQ 提供程序始终将用户输入参数化，因此它将被视为参数数据，而不是查询的一部分。作为一个副作用，您还拥有一个强类型代码的方法，不必担心意外和难以找到的拼写错误。
- en: See Also
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 1.10, “Constructing Objects with Complex Configuration”](ch01.xhtml#constructing_objects_with_complex_configuration)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 1.10, “构建具有复杂配置的对象”](ch01.xhtml#constructing_objects_with_complex_configuration)'
- en: 4.6 Querying Distinct Objects
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.6 查询不同对象
- en: Problem
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have a list of objects with duplicates and need to transform that into a
    distinct list of unique objects.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您有一个对象列表，其中包含重复项，并且需要将其转换为唯一对象的不同列表。
- en: Solution
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s an object that won’t support distinct queries:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不支持不同查询的对象：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here’s how to fix that object to support distinct queries:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何修复该对象以支持不同查询的方法：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here’s the data source:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数据源：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This code filters by distinct objects:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码按独特对象进行过滤：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Discussion
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Sometimes you have a list of entities with duplicates, either because of some
    application processing or the type of database query that results in duplicates.
    Often, you need a list of unique objects. For instance, you’re materializing into
    a `Dictionary` collection that doesn’t allow duplicates.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你会有一个包含重复实体的列表，可能是因为某些应用程序处理或数据库查询类型导致的。通常，你需要一个唯一对象的列表。例如，你正在使用不允许重复的 `Dictionary`
    集合进行实体化。
- en: The LINQ `Distinct` operator helps get a list of unique objects. At first glance,
    this is easy, as shown in the first query of the `Main` method that uses the `Distinct()`
    operator. Notice that it doesn’t have parameters. However, an inspection of the
    results shows that you still have the same duplicates in the data that you started
    with.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 的 `Distinct` 运算符帮助获取唯一对象的列表。乍一看，这很容易，就像 `Main` 方法的第一个查询所示，使用了 `Distinct()`
    运算符。请注意，它没有参数。然而，检查结果会显示，数据中仍然存在与开始时相同的重复项。
- en: The problem, and subsequent solution, might not be immediately obvious because
    it relies on combining a few different C# concepts. First, think about how `Distinct`
    should be able to tell the difference between objects—it has to perform a comparison.
    Next, consider that the type of `SalesPerson` is class. That’s important because
    classes are reference types, which have reference equality. When `Distinct` does
    a reference comparison, no two object references are the same because each object
    has a unique reference. Finally, you need to write code to compare `SalesPerson`
    instances to see if they’re equal and tell `Distinct` about that code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 问题及随后的解决方案可能不会立即显而易见，因为它依赖于结合了几个不同的 C# 概念。首先，考虑一下 `Distinct` 应该如何区分对象之间的差异——它必须执行比较。接下来，考虑到
    `SalesPerson` 的类型是 `class`。这很重要，因为类是引用类型，具有引用相等性。当 `Distinct` 进行引用比较时，没有两个对象引用是相同的，因为每个对象都有一个唯一的引用。最后，你需要编写代码来比较
    `SalesPerson` 实例，以确定它们是否相等，并告诉 `Distinct` 这段代码。
- en: The `SalesPerson` class is a basic class with properties and doesn’t contain
    any syntax to indicate how to perform equality. In contrast, `SalesPersonComparer`
    implements `IEqualityComparer<SalesPerson>`. The `SalesPerson` class doesn’t work
    because it has reference equality. However the `SalesPersonComparer` class that
    implements `IEqualityComparer<SalesPerson>` compares properly because it has an
    `Equals` method. In this case, checking `ID` is sufficient to determine that instances
    are equal, assuming that each entity comes from the same data source with unique
    `ID` fields.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`SalesPerson` 类是一个基本类，具有属性，并且不包含任何指示如何执行相等性的语法。相反，`SalesPersonComparer` 实现了
    `IEqualityComparer<SalesPerson>`。`SalesPerson` 类不起作用，因为它具有引用相等性。然而，实现了 `IEqualityComparer<SalesPerson>`
    的 `SalesPersonComparer` 类能够正确比较，因为它具有一个 `Equals` 方法。在这种情况下，检查 `ID` 是否足以确定实例是否相等，假设每个实体来自具有唯一
    `ID` 字段的同一数据源。'
- en: '`SalesPersonComparer` knows how to compare `SalesPerson` instances, but that
    isn’t the end of the story because there isn’t anything tying it to the query.
    If you ran the first query in `Main` with `Distinct()` (no parameter), the results
    will still have duplicates. The problem is that `Distinct` doesn’t know how to
    compare the objects so it defaults to the instance type, `class`, which, as explained
    earlier, is a reference type.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`SalesPersonComparer` 知道如何比较 `SalesPerson` 实例，但这并不是问题的终点，因为它与查询没有任何关联。如果你在
    `Main` 中运行第一个没有参数的查询 `Distinct()`，结果仍然会有重复。问题在于 `Distinct` 不知道如何比较对象，因此默认使用实例类型
    `class`，正如前面解释的那样，它是引用类型。'
- en: The solution is to use the second query in `Main` that uses the call to `Distinct(new
    SalesPersonComparer())` (with parameter). This uses the `Distinct` operator’s
    overload with the `IEqualityComparer<T>` overload parameter. Since `SalesPerson​Com⁠parer`
    implements `IEqualityComparer<SalesPerson>`, this works.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是在 `Main` 中使用第二个带有 `Distinct(new SalesPersonComparer())` 调用的查询。这使用了带有 `IEqualityComparer<T>`
    参数的 `Distinct` 运算符的重载。由于 `SalesPersonComparer` 实现了 `IEqualityComparer<SalesPerson>`，这个方法可以实现。
- en: See Also
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 2.5, “Checking for Type Equality”](ch02.xhtml#checking_for_type_equality)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2.5节，“检查类型相等性”](ch02.xhtml#checking_for_type_equality)'
- en: 4.7 Simplifying Queries
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.7 简化查询
- en: Problem
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: A query has become too complex and you need to make it more readable.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 查询变得过于复杂，需要使其更易读。
- en: Solution
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s the entity to query:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是要查询的实体：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is the data source:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数据源：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following shows how to simplify a query projection:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了如何简化查询投影：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Discussion
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Sometimes LINQ queries get complex. If the code is still hard to read, it’s
    also hard to maintain. One option is to go imperative and rewrite the query as
    a loop. Another is to use the `let` clause for simplification.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有时 LINQ 查询会变得复杂。如果代码仍然难以阅读，那么维护也很困难。一种选择是转为命令式语言并将查询重写为循环。另一种选择是使用 `let` 子句进行简化。
- en: In the solution, the `Main` method has a query with a custom projection into
    an anonymous type. Sometimes queries are complex because they have subqueries,
    or other logic, inside of the projection. For example, look at `FullAddress`,
    being built in a `let` clause. Without that simplification, the code would have
    ended up inside the projection.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中，`Main` 方法具有一个查询，该查询将投影到匿名类型中。有时查询会因为在投影中有子查询或其他逻辑，例如在 `let` 子句中构建的 `FullAddress`，而变得复杂。如果没有这种简化，代码可能会完全进入投影中。
- en: Another scenario you might face is when parsing object input from string. The
    example uses a `TryParse` in a `let` clause, which is impossible to put in the
    projection. This is a little tricky because the `out` parameter, `TotalSales`,
    is outside of the query. We ignore the results of `TryParse` but can now assign
    `TotalSales` in the projection.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能遇到的情景是解析来自字符串的对象输入。示例中使用了 `TryParse` 在 `let` 子句中，这在投影中是不可能的。这有点棘手，因为 `out`
    参数 `TotalSales` 是在查询之外的。我们忽略 `TryParse` 的结果，但现在可以在投影中分配 `TotalSales`。
- en: 4.8 Operating on Sets
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.8 操作集合
- en: Problem
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to combine two sets of objects without duplication.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要将两组对象组合在一起，避免重复。
- en: Solution
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s the entity to query:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是要查询的实体：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here’s the data source:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数据源：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This code shows how to perform set operations:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了如何执行集合操作：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Discussion
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: In [Recipe 4.2](#joining_data), we discussed the concept of joining data from
    two separate data sources. The examples operate in that same spirit and show different
    manipulations, based on sets.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在[配方 4.2](#joining_data)中，我们讨论了从两个不同数据源中连接数据的概念。示例在相同的精神中操作，并展示了基于集合的不同操作。
- en: The first method, `DoUnion`, gets two sets of data, intentionally filtering
    by `ID` to ensure overlap. From the reference of the first data source, the code
    calls the `Union` operator with the second data source as the parameter. This
    results in a set of data from both data sources, including duplicates.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法 `DoUnion` 获取两组数据，并通过 `ID` 进行有意义的过滤以确保重叠。从第一个数据源的引用中，代码调用 `Union` 运算符并以第二个数据源作为参数。这将导致从两个数据源获取的数据集，包括重复数据。
- en: The `DoExcept` method is similar to `DoUnion` but uses the `Except` operator.
    This results in a set of all the objects in the first data source. However, any
    objects in the second data source, even if they were in the first, won’t appear
    in the results.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`DoExcept` 方法类似于 `DoUnion`，但使用 `Except` 运算符。这将导致第一个数据源中所有对象的集合。然而，任何在第二个数据源中的对象，即使它们曾经在第一个数据源中，也不会出现在结果中。'
- en: Finally, `DoIntersect` is similar in structure to `DoUnion` and `DoExcept`.
    However, it queries objects that are only in both data sources. If any object
    is in one data source, but not the other, it won’t appear in the result. This
    operation is called *difference in set theory*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`DoIntersect` 在结构上类似于 `DoUnion` 和 `DoExcept`。然而，它查询的对象只存在于两个数据源中。如果某个对象只存在于一个数据源中而不在另一个数据源中，则不会出现在结果中。这种操作称为*集合理论中的差异*。
- en: LINQ has many standard operators that, just like the set operators, are very
    powerful. Before performing any complex operation in a LINQ query, it’s good practice
    to review standard operators to see if something exists that will simplify your
    task.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 具有许多标准运算符，就像集合运算符一样，非常强大。在执行 LINQ 查询中的任何复杂操作之前，最好查看标准运算符，看看是否存在可以简化任务的内容。
- en: See Also
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 4.2, “Joining Data”](#joining_data)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[配方 4.2，“连接数据”](#joining_data)'
- en: '[Recipe 4.3, “Performing Left Joins”](#performing_left_joins)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[配方 4.3，“执行左连接”](#performing_left_joins)'
- en: 4.9 Building a Query Filter with Expression Trees
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.9 用表达式树构建查询过滤器
- en: Problem
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: The LINQ `where` clause combines via `AND` conditions, but you need a dynamic
    `where` that works as an `OR` condition.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 的 `where` 子句通过 `AND` 条件组合，但您需要一个动态的 `where`，它作为 `OR` 条件工作。
- en: Solution
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s the entity to query:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是要查询的实体：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This is the data source:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数据源：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here’s an extension method for a filtered `OR` operation:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个过滤的 `OR` 操作的扩展方法：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here’s the code that consumes the new extension method:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是消耗新扩展方法的代码：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Discussion
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '[Recipe 4.5](#building_incremental_queries) showed the power of dynamic queries
    in LINQ. However, that isn’t the end of what you can do. With expression trees,
    you can leverage LINQ for any type of query. If the standard operators don’t provide
    something you need, you can use expression trees. This section does just that,
    showing how to use expression trees to run a dynamic `WhereOr` operation.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 4.5](#building_incremental_queries) 展示了在 LINQ 中动态查询的强大功能。然而，这并不是你可以做的全部。使用表达式树，您可以利用
    LINQ 进行任何类型的查询。如果标准运算符不能提供您需要的内容，您可以使用表达式树。本节正是如此，展示了如何使用表达式树来运行动态的 `WhereOr`
    操作。'
- en: The motivation for `WhereOr` comes from the fact that the standard `Where` operator
    combines in an `AND` comparison. In [Recipe 4.5](#building_incremental_queries),
    all of those `Where` operators had an implicit `AND` relationship between them.
    This means that a given entity must have a value equal to each of the fields (that
    the user specified in the criteria) to get a match. With the `WhereOr` in this
    section, all of the fields have an `OR` relationship, and a match on only one
    of the fields is necessary for inclusion in results.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`WhereOr` 的动机源于标准的 `Where` 运算符组合为 `AND` 比较的事实。在 [Recipe 4.5](#building_incremental_queries)
    中，所有这些 `Where` 运算符都具有隐式的 `AND` 关系。这意味着给定实体必须具有与用户在标准中指定的每个字段相等的值才能匹配。在本节中，通过 `WhereOr`，所有字段都具有
    `OR` 关系，仅需要匹配一个字段即可包含在结果中。'
- en: In the solution, the `GetCriteriaFromUser` method gets the values for each `SalesPerson`
    property. `QuerySalesPeople` starts a query for deferred execution, as explained
    in [Recipe 4.5](#building_incremental_queries), and builds a `Dictionary<string,
    string>` of filters.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中，`GetCriteriaFromUser` 方法获取每个 `SalesPerson` 属性的值。`QuerySalesPeople` 启动了一个延迟执行的查询，正如
    [Recipe 4.5](#building_incremental_queries) 中所解释的那样，并构建了一个 `Dictionary<string,
    string>` 类型的过滤器。
- en: The `CookbookExtensions` class has the `WhereOr` extension method that accepts
    the filters. The high-level description of what `WhereOr` is trying to accomplish
    comes from the fact that it needs to return an `IEnumerable<SalesPerson>` for
    the caller to complete a LINQ query.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`CookbookExtensions` 类有一个接受过滤器的 `WhereOr` 扩展方法。`WhereOr` 要完成的高级描述来自于它需要为调用者返回一个
    `IEnumerable<SalesPerson>`，以完成 LINQ 查询。'
- en: 'First, go to the bottom of `WhereOr` and notice that it returns the query with
    the `Where` operator and has a parameter named `compiledQuery`. Remember that
    the LINQ `Where` operator takes a C# lambda expression with a parameter and a
    predicate. We want a filter that returns an object if any one field of an object
    matches, based on the input criteria. Therefore, `compiledQuery` must evaluate
    to a lambda of the following form:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，转到 `WhereOr` 的底部，注意它返回带有 `Where` 运算符的查询，并且有一个名为 `compiledQuery` 的参数。请记住，LINQ
    的 `Where` 运算符接受一个带有参数和谓词的 C# lambda 表达式。我们希望一个过滤器，如果对象的任何一个字段匹配基于输入条件，则 `compiledQuery`
    必须评估为以下形式的 lambda：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: That’s a lambda with `OR` operators for each value in the `Dictionary<string,
    string> criteria` parameter. To get from the top of this algorithm to the bottom,
    we need to build an expression tree that evaluates to this form of lambda. [Figure 4-1](#where_or)
    illustrates what this code does.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个带有 `OR` 运算符的 lambda 表达式，它使用 `Dictionary<string, string> criteria` 参数的每个值。为了从算法的顶部到底部，我们需要构建一个表达式树，该树评估为此形式的
    lambda。[Figure 4-1](#where_or) 显示了此代码的作用。
- en: '![Building a Where expression with clauses separated by OR operators](Images/cscb_0401.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![使用 OR 运算符分隔子句构建 Where 表达式](Images/cscb_0401.png)'
- en: Figure 4-1\. Building a `Where` expression with clauses separated by `OR` operators
  id: totrans-182
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-1\. 使用 `OR` 运算符分隔子句构建 `Where` 表达式
- en: '[Figure 4-1](#where_or) shows the expression tree that the solution creates.
    Here, we assume that the user wants to query four values: `City`, `Name`, `ProductType`,
    and `Region`. Expression trees read depth-first, from left to right, where each
    box represents a node. Therefore, LINQ follows the tree down the left side until
    it finds a leaf node, which is the `City` expression. Then it moves back up the
    tree to find the `OR`, moves to the right and finds the `Name` expression, and
    builds the `OR` expression. So far, LINQ has built the following clause:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[Figure 4-1](#where_or) 展示了解决方案创建的表达式树。在这里，我们假设用户想要查询四个值：`City`、`Name`、`ProductType`
    和 `Region`。表达式树按深度优先、从左到右的方式读取，每个框表示一个节点。因此，LINQ 沿着左侧向下遍历树，直到找到叶子节点，即 `City` 表达式。然后它向上移动到找到
    `OR`，再向右移动找到 `Name` 表达式，并构建 `OR` 表达式。到目前为止，LINQ 已构建了以下子句：'
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'LINQ continues reading the expression tree up and to the right until it finally
    builds the following clause:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 继续读取表达式树，直到最终构建以下子句：
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Back to the solution code, the first thing `WhereOr` does is create a `ParameterExpression`.
    This is the `person` parameter in the lambda. It’s the parameter to every comparison
    expression because it represents the `TParameter`, which is an instance of `SalesPerson`
    in this example.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 回到解决方案代码，`WhereOr` 首先创建了一个 `ParameterExpression`。这是 lambda 中的 `person` 参数。它是每个比较表达式的参数，因为它表示
    `TParameter`，在本例中是 `SalesPerson` 的实例。
- en: Note
  id: totrans-188
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This example is called the `ParameterExpression` `person`. However, if this
    is a generic reusable extension method, you might give it a more general name,
    like `parameterTerm` because `TParameter` could be any type. The choice of `person`
    in this example is there to clarify that the `ParameterExpression` represents
    a `SalesPerson` instance in this example.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例称为 `ParameterExpression` 的 `person`。但是，如果这是一个通用的可重用扩展方法，您可能会给它一个更一般的名称，例如
    `parameterTerm`，因为 `TParameter` 可以是任何类型。在此示例中选择 `person` 是为了澄清 `ParameterExpression`
    在本例中表示一个 `SalesPerson` 实例。
- en: The `Expression` `accumulatorExpr`, as its name suggests, gathers all of the
    clauses for the lambda body.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`Expression` `accumulatorExpr`，正如其名称所示，收集 lambda 主体的所有子句。'
- en: The `foreach` statement loops through the `Dictionary` collection, which returns
    `KeyValuePair` instances, which have `Key` and `Value` properties. As shown in
    the `QuerySalesPeople` method, the `Key` property is the name of the `SalesPerson`
    property, and the `Value` property is what the user entered.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach` 语句循环遍历 `Dictionary` 集合，返回 `KeyValuePair` 实例，这些实例具有 `Key` 和 `Value`
    属性。如 `QuerySalesPeople` 方法所示，`Key` 属性是 `SalesPerson` 属性的名称，而 `Value` 属性是用户输入的内容。'
- en: For each clause of the lambda, the left-hand side is a reference to the property
    on the `SalesPerson` instance (e.g., `person.Name`). To create that, the code
    instantiates the `paramMbr` using the `paramExpr` (which is `person`). That becomes
    a parameter of `leftExpr`. The `rightExpr` expression is a constant that holds
    the value to compare and its type. Then we need to complete the expression with
    an `Equals` expression for the left and right expressions (`leftExpr` and `rightExpr`,
    respectively).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 lambda 的每个子句，左侧是对 `SalesPerson` 实例上属性的引用（例如 `person.Name`）。为了创建这个，代码使用 `paramExpr`
    实例化了 `paramMbr`（即 `person`）。这成为 `leftExpr` 的参数。`rightExpr` 表达式是一个常量，它保存了要比较的值及其类型。然后，我们需要使用左侧和右侧表达式（分别是
    `leftExpr` 和 `rightExpr`）完成表达式与 `Equals` 表达式。
- en: Finally, we need to `OR` that expression with any others. The first time through
    the `foreach` loop, `accumulatorExpr` will be `null`, so we just assign the first
    expression. On subsequent expressions, we use an `OR` expression to append the
    new `Equals` expression to `accumulatorExpr`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将该表达式与其他表达式进行 `OR` 运算。在 `foreach` 循环的第一次迭代中，`accumulatorExpr` 将为 `null`，因此我们只分配第一个表达式。在后续表达式中，我们使用
    `OR` 表达式将新的 `Equals` 表达式附加到 `accumulatorExpr`。
- en: After iterating through each input field, we form the final `LambdaExpression`
    that adds the parameter that was used in the left side of each `Equals` expression.
    Notice that the result is an `Expression<Func<TParameter, bool>>`, which has a
    parameter type matching the lambda delegate type for the original query, which
    is `Func<SalesPerson, bool>`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历每个输入字段后，我们形成了最终的 `LambdaExpression`，它添加了在每个 `Equals` 表达式左侧使用的参数。请注意，结果是一个
    `Expression<Func<TParameter, bool>>`，它的参数类型与原始查询的 lambda 委托类型匹配，即 `Func<SalesPerson,
    bool>`。
- en: We now have a dynamically built expression tree ready to convert into runnable
    code, which is a task for the `Expression.Compile` method. This gives us a compiled
    lambda that we can pass to the `Where` clause.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个动态构建的表达式树，准备转换为可运行的代码，这是 `Expression.Compile` 方法的任务。这给了我们一个编译的 lambda，我们可以传递给
    `Where` 子句。
- en: The calling code receives the `IEnumerable<SalesPerson>` from the `WhereOr`
    method and materializes the query with a call to `ToList`. This produces a list
    of `SalesPerson` objects that match at least one of the user’s specified criteria.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 调用代码从 `WhereOr` 方法接收 `IEnumerable<SalesPerson>`，并通过调用 `ToList` 材料化查询。这产生了一个
    `SalesPerson` 对象的列表，这些对象至少匹配用户指定的一个条件。
- en: See Also
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 4.5, “Building Incremental Queries”](#building_incremental_queries)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 4.5, “Building Incremental Queries”](#building_incremental_queries)'
- en: 4.10 Querying in Parallel
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.10 并行查询
- en: Problem
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to improve performance, and your query could benefit from multithreading.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望提高性能，您的查询可能会从多线程中获益。
- en: Solution
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s the entity to query:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是要查询的实体：
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This is the data source:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数据源：
- en: '[PRE35]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This code shows how to perform a parallel query:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码显示如何执行并行查询：
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Discussion
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: This section considers queries that can benefit from concurrency. Imagine you
    have a LINQ to Objects query, where the data is in memory. Perhaps work on each
    instance requires intensive processing, the code runs on a multithreaded/multicore
    CPU, and/or takes a nontrivial amount of time. Running the query in parallel might
    be an option.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 本节考虑可以从并发中受益的查询。想象一下，您有一个 LINQ 到对象的查询，其中数据存储在内存中。也许每个实例的工作需要密集处理，代码在多线程/多核 CPU
    上运行，并且/或者需要花费相当大的时间。在并行中运行查询可能是一个选择。
- en: The `Main` method performs a query, similar to any other query, except for the
    `AsParallel` operator on the data source. What this does is let LINQ figure out
    how to split up the work and operate on each range variable in parallel. [Figure 4-2](#plinq)
    illustrates what this query is doing.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法执行一个查询，与任何其他查询类似，除了在数据源上使用 `AsParallel` 操作符。这样做的效果是让 LINQ 确定如何分割工作并并行操作每个范围变量。[图 4-2](#plinq)
    显示了这个查询在做什么。'
- en: '![PLINQ runs members of a collection in parallel](Images/cscb_0402.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![PLINQ 在集合成员中并行运行](Images/cscb_0402.png)'
- en: Figure 4-2\. PLINQ runs members of a collection in parallel
  id: totrans-213
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-2\. PLINQ 在集合成员中并行运行
- en: '[Figure 4-2](#plinq) shows the `salesPeople` collection on the left. When the
    query runs, it takes multiple collection objects to process in parallel, indicated
    by the split arrows from `salesPeople` pointing to each instance of `SalesPerson`.
    After processing, the query combines the responses from processing each object
    into a new collection, named `result`.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-2](#plinq) 显示了左侧的 `salesPeople` 集合。当查询运行时，它会并行处理多个集合对象，这些对象由从 `salesPeople`
    指向每个 `SalesPerson` 实例的分割箭头表示。处理完成后，查询将每个对象的处理响应组合成一个名为 `result` 的新集合。'
- en: Note
  id: totrans-215
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This example uses a LINQ technology known as Parallel LINQ (PLINQ). Behind the
    scenes, PLINQ evaluates the query for various runtime optimizations such as degree
    of parallelism. It’s even smart enough to figure out when running synchronously
    is faster than the overhead of starting new threads on a given machine.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用一种名为并行 LINQ (PLINQ) 的 LINQ 技术。在幕后，PLINQ 对查询进行评估，进行各种运行时优化，如并行度。它甚至足够智能，可以判断在给定机器上启动新线程的开销是否比同步运行更快。
- en: This example also demonstrates another type of projection that uses a method
    to return an object. The assumption here is that the intensive processing occurs
    in `ProcessPerson`, which has a `Thread.Sleep` to simulate nontrivial processing.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例还演示了另一种使用方法返回对象的投影类型。这里的假设是密集处理发生在 `ProcessPerson` 中，该方法使用 `Thread.Sleep`
    模拟非平凡处理。
- en: In practice, you would want to do some testing to see if you’re really benefiting
    from parallelism. [Recipe 3.10](ch03.xhtml#measuring_performance) shows how to
    measure performance with the `System.Diagnostics.StopWatch` class. If successful,
    this could be an easy way to boost the performance of your application.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，您需要进行一些测试，以确定您是否真正从并行性中受益。[配方 3.10](ch03.xhtml#measuring_performance) 展示了如何使用
    `System.Diagnostics.StopWatch` 类来测量性能。如果成功，这可能是提升应用程序性能的一种简单方式。
- en: See Also
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 3.10, “Measuring Performance”](ch03.xhtml#measuring_performance)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[配方 3.10，“性能测量”](ch03.xhtml#measuring_performance)'
