- en: Chapter 10\. LINQ
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章 LINQ
- en: Language Integrated Query (LINQ) is a powerful collection of C# language features
    for working with sets of information. It is useful in any application that needs
    to work with multiple pieces of data (i.e., almost any application). Although
    one of its original goals was to provide straightforward access to relational
    databases, LINQ is applicable to many kinds of information. For example, it can
    also be used with in-memory object models, HTTP-based information services, JSON,
    and XML documents. And as we’ll see in [Chapter 11](ch11.xhtml#ch_reactive_extensions),
    it can work with live streams of data too.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 语言集成查询（LINQ）是一组强大的 C# 语言功能，用于处理信息集合。它在任何需要处理多个数据片段的应用程序中都很有用（即几乎所有应用程序）。尽管其最初的目标之一是提供对关系数据库的简单访问，但
    LINQ 适用于许多类型的信息。例如，它还可以与内存中的对象模型、基于 HTTP 的信息服务、JSON 和 XML 文档一起使用。正如我们将在 [第 11
    章](ch11.xhtml#ch_reactive_extensions) 中看到的那样，它还可以与实时数据流一起使用。
- en: LINQ is not a single feature. It relies on several language elements that work
    together. The most conspicuous LINQ-related language feature is the *query expression*,
    a form of expression that loosely resembles a database query but that can be used
    to perform queries against any supported source, including plain old objects.
    As you’ll see, query expressions rely heavily on some other language features
    such as lambdas, extension methods, and expression object models.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 不是单一的功能。它依赖于多个语言元素共同工作。与LINQ相关的最显著的语言特性是*查询表达式*，这是一种类似数据库查询的表达形式，但可以用来对任何支持的源执行查询，包括普通的旧对象。正如你将看到的那样，查询表达式在很大程度上依赖于一些其他语言特性，例如
    lambda 表达式、扩展方法和表达式对象模型。
- en: Language support is only half the story. LINQ needs class libraries to implement
    a set of querying primitives called *LINQ operators*. Each different kind of data
    requires its own implementation, and a set of operators for any particular type
    of information is referred to as a *LINQ provider*. (These can also be used from
    Visual Basic and F#, by the way, because those languages support LINQ too.) Microsoft
    supplies several providers, some built into the runtime libraries and some available
    as separate NuGet packages. There is a provider for Entity Framework Core for
    example, an object/relational mapping system for working with databases. The Cosmos
    DB cloud database (a feature of Microsoft Azure) offers a LINQ provider. And the
    Reactive Extensions for .NET (Rx) described in [Chapter 11](ch11.xhtml#ch_reactive_extensions)
    provide LINQ support for live streams of data. In short, LINQ is a widely supported
    idiom in .NET, and it’s extensible, so you will also find open source and other
    third-party providers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 语言支持只是故事的一半。LINQ 需要类库来实现一组查询原语，称为*LINQ 操作符*。每种不同类型的数据都需要其自己的实现，而某种类型信息的一组操作符被称为*LINQ
    提供者*。（顺便说一句，这些也可以从 Visual Basic 和 F# 中使用，因为这些语言也支持 LINQ。）Microsoft 提供了几个提供者，其中一些内置于运行库中，一些作为独立的
    NuGet 包提供。例如，Entity Framework Core 就提供了一个 LINQ 提供者，这是一个用于与数据库交互的对象/关系映射系统。Cosmos
    DB 云数据库（Microsoft Azure 的一个特性）也提供了一个 LINQ 提供者。还有在 [.NET 反应式扩展](ch11.xhtml#ch_reactive_extensions)
    中描述的反应式扩展，提供了对数据实时流的 LINQ 支持。简而言之，LINQ 是.NET 中广泛支持的习语，并且它是可扩展的，因此你也会发现开源和其他第三方提供者。
- en: Most of the examples in this chapter use LINQ to Objects. This is partly because
    it avoids cluttering the examples with extraneous details such as database or
    service connections, but there’s a more important reason. LINQ’s introduction
    in 2007 significantly changed the way I write C#, and that’s entirely because
    of LINQ to Objects. Although LINQ’s query syntax makes it look like it’s primarily
    a data access technology, I have found it to be far more valuable than that. Having
    LINQ’s services available on any collection of objects makes it useful in every
    part of your code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章大部分示例使用 LINQ to Objects。这部分是因为它避免了示例中的额外细节，例如数据库或服务连接，但还有一个更重要的原因。LINQ 的引入在
    2007 年显著改变了我编写 C# 代码的方式，这完全是由于 LINQ to Objects。尽管 LINQ 的查询语法使它看起来主要是一种数据访问技术，但我发现它远比那更有价值。在任何对象集合上都可以使用
    LINQ 的服务使其在代码的每个部分中都非常有用。
- en: Query Expressions
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询表达式
- en: The most visible feature of LINQ is the query expression syntax. It’s not the
    most important—as we’ll see later, it’s entirely possible to use LINQ productively
    without ever writing a query expression. However, it’s a very natural syntax for
    many kinds of queries.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 最显著的特点是查询表达式语法。这并非最重要——我们稍后会看到，完全可以在不编写查询表达式的情况下有效地使用 LINQ。但是，对于许多类型的查询来说，这是一种非常自然的语法。
- en: At first glance, a query expression loosely resembles a relational database
    query, but the syntax works with any LINQ provider. [Example 10-1](#a_linq_query_expression)
    shows a query expression that uses LINQ to Objects to search for certain `CultureInfo`
    objects. (A `CultureInfo` object provides a set of culture-specific information,
    such as the symbol used for the local currency, what language is spoken, and so
    on. Some systems call this a *locale*.) This particular query looks at the character
    that denotes what would, in English, be called the decimal point. Many countries
    actually use a comma instead of a period, and in those countries, 100,000 would
    mean the number 100 written out to three decimal places; in English-speaking cultures,
    we would normally write this as 100.000\. The query expression searches all the
    cultures known to the system and returns those that use a comma as the decimal
    separator.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，查询表达式大致类似于关系数据库查询，但语法适用于任何LINQ提供程序。[示例 10-1](#a_linq_query_expression)展示了一个使用LINQ
    to Objects搜索特定`CultureInfo`对象的查询表达式。（`CultureInfo`对象提供了一组特定于文化的信息，如本地货币使用的符号、使用的语言等。有些系统称其为*区域设置*。）这个特定的查询查看了表示英文中所谓的小数点的字符。许多国家实际上使用逗号而不是句点，而在这些国家中，100,000意味着将数字100写成三位小数；在英语文化中，我们通常将其写作100.000\.
    查询表达式搜索系统中所有已知的文化，并返回那些使用逗号作为小数分隔符的文化。
- en: Example 10-1\. A LINQ query expression
  id: totrans-8
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-1\. LINQ查询表达式
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `foreach` loop in this example shows the results of the query. On my system,
    this lists the names of 354 cultures, indicating that slightly under half of the
    813 available cultures use a comma, not a decimal point. Of course, I could easily
    have achieved this without using LINQ. [Example 10-2](#the_non-linq_equivalent)
    will produce the same results.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`foreach`循环显示了查询的结果。在我的系统上，这列出了354个文化的名称，表明大约813个可用文化中有一半使用逗号而不是小数点。当然，我完全可以不使用LINQ来轻松实现这一点。[示例 10-2](#the_non-linq_equivalent)将产生相同的结果。
- en: Example 10-2\. The non-LINQ equivalent
  id: totrans-11
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-2\. 非LINQ等效方法
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Both examples have eight nonblank lines of code, although if you ignore lines
    that contain only braces, [Example 10-2](#the_non-linq_equivalent) contains just
    four, two fewer than [Example 10-1](#a_linq_query_expression). Then again, if
    we count statements, the LINQ example has just three, compared to four in the
    loop-based example. So it’s difficult to argue convincingly that either approach
    is simpler than the other.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 两个示例都有八行非空代码，尽管如果忽略只包含括号的行，[示例 10-2](#the_non-linq_equivalent)只包含四行，比[示例 10-1](#a_linq_query_expression)少两行。另一方面，如果我们计算语句，LINQ示例只有三个，而循环示例有四个。因此很难有说服力地论证哪种方法比另一种更简单。
- en: 'However, [Example 10-1](#a_linq_query_expression) has a significant advantage:
    the code that decides which items to choose is well separated from the code that
    decides what to do with those items. [Example 10-2](#the_non-linq_equivalent)
    intermingles these two concerns: the code that picks the objects is half outside
    and half inside the loop.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，[示例 10-1](#a_linq_query_expression)有一个显著的优势：决定选择哪些项的代码与决定如何处理这些项的代码有很好的分离。[示例 10-2](#the_non-linq_equivalent)把这两个问题搞混了：选择对象的代码一半在循环外部，一半在循环内部。
- en: 'Another difference is that [Example 10-1](#a_linq_query_expression) has a more
    declarative style: it focuses on what we want, not how to get it. The query expression
    describes the items we’d like, without mandating that this be achieved in any
    particular way. For this very simple example, that doesn’t matter much, but for
    more complex examples, and particularly when using a LINQ provider for database
    access, it can be very useful to allow the provider a free hand in deciding exactly
    how to perform the query. [Example 10-2](#the_non-linq_equivalent)’s approach
    of iterating over everything in a `foreach` loop and picking the item it wants
    would be a bad idea if we were talking to a database—you generally want to let
    the server do this sort of filtering work.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个区别是，[示例 10-1](#a_linq_query_expression)具有更声明性的风格：它关注我们想要的内容，而不是如何获得它。查询表达式描述了我们想要的项，而不强制规定以任何特定方式实现。对于这个非常简单的例子，这并不重要，但对于更复杂的例子，特别是在使用LINQ提供程序进行数据库访问时，允许提供程序自由决定如何执行查询非常有用。[示例 10-2](#the_non-linq_equivalent)的方法遍历`foreach`循环中的所有内容并选择它想要的项，如果我们在与数据库交互，这种做法通常是不好的——通常希望服务器来处理这种过滤工作。
- en: The query in [Example 10-1](#a_linq_query_expression) has three parts. All query
    expressions are required to begin with a `from` clause, which specifies the source
    of the query. In this case, the source is an array of type `CultureInfo[]`, returned
    by the `CultureInfo` class’s `GetCultures` method. As well as defining the source
    for the query, the `from` clause contains a name, which here is `culture`. This
    is called the *range variable*, and we can use it in the rest of the query to
    represent a single item from the source. Clauses can run many times—the `where`
    clause in [Example 10-1](#a_linq_query_expression) runs once for every item in
    the collection, so the range variable will have a different value each time. This
    is reminiscent of the iteration variable in a `foreach` loop. In fact, the overall
    structure of the `from` clause is similar—we have the variable that will represent
    an item from a collection, then the `in` keyword, then the source for which that
    variable will represent individual items. Just as a `foreach` loop’s iteration
    variable is in scope only inside the loop, the range variable `culture` is meaningful
    only inside this query expression.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10-1](#a_linq_query_expression) 中的查询有三个部分。所有查询表达式都必须以 `from` 子句开头，该子句指定查询的源。在本例中，源是由
    `CultureInfo` 类的 `GetCultures` 方法返回的 `CultureInfo[]` 类型的数组。除了为查询定义源外，`from` 子句还包含一个名称，在这里是
    `culture`。这称为*范围变量*，我们可以在查询的其余部分中使用它来代表源中的单个项目。子句可以多次运行——在 [示例 10-1](#a_linq_query_expression)
    中的 `where` 子句会针对集合中的每个项运行一次，因此范围变量每次都会有不同的值。这与 `foreach` 循环中的迭代变量类似。事实上，`from`
    子句的整体结构相似——我们有一个将代表集合中的项目的变量，然后是 `in` 关键字，然后是该变量将代表单个项的源。正如 `foreach` 循环中的迭代变量仅在循环内部有效一样，范围变量
    `culture` 仅在此查询表达式内部有效。'
- en: Note
  id: totrans-17
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Although analogies with `foreach` can be helpful for understanding the intent
    of LINQ queries, you shouldn’t take this too literally. For example, not all providers
    directly execute the expressions in a query. Some LINQ providers convert query
    expressions into database queries, in which case the C# code in the various expressions
    inside the query does not run in any conventional sense. So, although it is true
    to say that the range variable represents a single value from the source, it’s
    not always true to say that clauses will execute once for every item they process,
    with the range value taking that item’s value. It happens to be true for [Example 10-1](#a_linq_query_expression)
    because it uses LINQ to Objects, but it’s not so for all providers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管与 `foreach` 的类比有助于理解 LINQ 查询的意图，但不应该过于字面化。例如，并非所有的提供程序直接执行查询中的表达式。一些 LINQ
    提供程序将查询表达式转换为数据库查询，在这种情况下，查询中各种表达式中的 C# 代码并不以传统意义上的方式运行。因此，虽然可以说范围变量表示源中的单个值，但并不总是可以说各个子句会针对其处理的每个项执行一次，并且范围值取该项的值。这在
    [示例 10-1](#a_linq_query_expression) 中是正确的，因为它使用的是 LINQ to Objects，但并非所有提供程序都是如此。
- en: The second part of the query in [Example 10-1](#a_linq_query_expression) is
    a `where` clause. This clause is optional, or if you want, you can have several
    in one query. A `where` clause filters the results, and the one in this example
    states that I want only the `CultureInfo` objects with a `NumberFormat` that indicates
    that the decimal separator is a comma.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 查询的第二部分在 [示例 10-1](#a_linq_query_expression) 中是一个 `where` 子句。此子句是可选的，或者您也可以在一个查询中有多个。`where`
    子句用于过滤结果，在本示例中说明，我只希望具有指示小数分隔符为逗号的 `NumberFormat` 的 `CultureInfo` 对象。
- en: The final part of the query is a `select` clause. All query expressions end
    with either a `select` clause or a `group` clause. This determines the final output
    of the query. This example indicates that we want each `CultureInfo` object that
    was not filtered out by the query. The `foreach` loop in [Example 10-1](#a_linq_query_expression)
    that shows the results of the query uses only the `Name` property, so I could
    have written a query that extracted only that. As [Example 10-3](#extracting_just_one_property_in_a_query)
    shows, if I do this, I also need to change the loop, because the resulting query
    now produces strings instead of `CultureInfo` objects.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 查询的最后部分是 `select` 子句。所有查询表达式都以 `select` 子句或 `group` 子句结尾。这确定查询的最终输出。这个示例表明，我们希望保留未被查询过滤掉的每个
    `CultureInfo` 对象。在 [示例 10-1](#a_linq_query_expression) 中展示查询结果的 `foreach` 循环仅使用
    `Name` 属性，因此我可以编写一个仅提取该属性的查询。如 [示例 10-3](#extracting_just_one_property_in_a_query)
    所示，如果我这样做，还需要更改循环，因为生成的查询现在会生成字符串而不是 `CultureInfo` 对象。
- en: Example 10-3\. Extracting just one property in a query
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-3\. 在查询中提取单个属性
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This raises a question: in general, what type do query expressions have? In
    [Example 10-1](#a_linq_query_expression), `commaCultures` is an `IEnumerable<CultureInfo>`;
    in [Example 10-3](#extracting_just_one_property_in_a_query), it’s an `IEnumerable<string>`.
    The output item type is determined by the final clause of the query—the `select`
    or, in some cases, the `group` clause. However, not all query expressions result
    in an `IEnumerable<T>`. It depends on which LINQ provider you use—I’ve ended up
    with `IEnumerable<T>` because I’m using LINQ to Objects.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了一个问题：一般来说，查询表达式有什么类型？在[示例 10-1](#a_linq_query_expression)中，`commaCultures`是`IEnumerable<CultureInfo>`；在[示例 10-3](#extracting_just_one_property_in_a_query)中，它是`IEnumerable<string>`。输出项的类型由查询的最后一个子句确定——`select`或者在某些情况下是`group`子句。然而，并非所有的查询表达式都会得到`IEnumerable<T>`。这取决于你使用的LINQ提供程序——我最终得到了`IEnumerable<T>`，因为我使用的是LINQ
    to Objects。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'It’s very common to use the `var` keyword when declaring variables that hold
    LINQ queries. This is necessary if a `select` clause produces instances of an
    anonymous type, because there is no way to write the name of the resulting query’s
    type. Even if anonymous types are not involved, `var` is still widely used, and
    there are two reasons. One is just a matter of consistency: some people feel that
    because you have to use `var` for some LINQ queries, you should use it for all
    of them. Another argument is that LINQ query types often have verbose and ugly
    names, and `var` results in less cluttered code. This can be a particularly pressing
    concern in the strictly limiting confines of a book’s layout, so in many examples
    in this chapter I have departed from my usual preference for explicit types and
    have used `var` to make things fit.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明用于保存LINQ查询的变量时，通常使用`var`关键字是非常常见的。如果`select`子句生成匿名类型的实例，则这是必需的，因为没有办法编写结果查询类型的名称。即使不涉及匿名类型，`var`仍然被广泛使用，有两个原因。一个原因是一致性问题：一些人认为，因为你必须对某些LINQ查询使用`var`，所以应该对所有LINQ查询都使用它。另一个论点是，LINQ查询类型通常具有冗长和丑陋的名称，而`var`可以使代码更清晰。在书籍布局的严格限制环境中，这可能是一个特别迫切的问题，因此在本章的许多示例中，我离开了我通常偏爱显式类型的偏好，而是使用了`var`来使事物更协调。
- en: How did C# know that I wanted to use LINQ to Objects? It’s because I used an
    array as the source in the `from` clause. More generally, LINQ to Objects will
    be used when you specify any `IEnumerable<T>` as the source, unless a more specialized
    provider is available. However, this doesn’t really explain how C# discovers the
    existence of providers in the first place and how it chooses between them. To
    understand that, you need to know what the compiler does with a query expression.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: C#如何知道我想要使用LINQ to Objects？这是因为我在`from`子句中使用了数组作为源。更普遍地说，当你指定任何`IEnumerable<T>`作为源时，LINQ
    to Objects将被使用，除非存在更专门的提供程序。然而，这并不能真正解释C#如何首先发现提供程序的存在以及如何在它们之间进行选择。要理解这一点，你需要知道编译器如何处理查询表达式。
- en: How Query Expressions Expand
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询表达式的扩展方式
- en: The compiler converts all query expressions into one or more method calls. Once
    it has done that, the LINQ provider is selected through exactly the same mechanisms
    that C# uses for any other method call. The compiler does not have any built-in
    concept of what constitutes a LINQ provider. It just relies on convention. [Example 10-4](#the_effect_of_a_query_expression)
    shows what the compiler does with the query expression in [Example 10-3](#extracting_just_one_property_in_a_query).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将所有的查询表达式转换成一个或多个方法调用。一旦这样做了，LINQ提供程序通过与C#用于任何其他方法调用相同的机制来选择。编译器没有任何内置的概念来定义什么是LINQ提供程序。它仅仅依赖于约定。[示例 10-4](#the_effect_of_a_query_expression)展示了编译器如何处理[示例 10-3](#extracting_just_one_property_in_a_query)中的查询表达式。
- en: Example 10-4\. The effect of a query expression
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-4\. 查询表达式的影响
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Where` and `Select` methods are examples of LINQ operators. A LINQ operator
    is nothing more than a method that conforms to one of the standard patterns. I’ll
    describe these patterns later, in [“Standard LINQ Operators”](#standard_linq_operators).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`Where`和`Select`方法是LINQ操作符的示例。LINQ操作符实际上就是符合标准模式的方法。我稍后将在[“标准LINQ操作符”](#standard_linq_operators)中描述这些模式。'
- en: The code in [Example 10-4](#the_effect_of_a_query_expression) is all one statement,
    and I’m chaining method calls together—I call the `Where` method on the return
    value of `GetCultures`, and I call the `Select` method on the return value of
    `Where`. The formatting looks a little peculiar, but it’s too long to go on one
    line; and, even though it’s not terribly elegant, I prefer to put the `.` at the
    start of the line when splitting chained calls across multiple lines, because
    it makes it much easier to see that each new line continues from where the last
    one left off. Leaving the period at the end of the preceding line looks neater
    but also makes it much easier to misread the code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10-4](#the_effect_of_a_query_expression) 中的代码都是一个语句，并且我正在链接方法调用——我在 `GetCultures`
    的返回值上调用 `Where` 方法，并在 `Where` 的返回值上调用 `Select` 方法。格式看起来有点奇怪，但它太长了，无法一行展示；尽管这不是特别优雅，但我更喜欢在多行上拆分链式调用时在每一行的开头放置
    `.`，因为这样更容易看出每一行是从上一行的哪里继续的。把句点留在前一行的末尾看起来更整洁，但也更容易误读代码。'
- en: The compiler has turned the `where` and `select` clauses’ expressions into lambdas.
    Notice that the range variable ends up as a parameter in each lambda. This is
    one example of why you should not take the analogy between query expressions and
    `foreach` loops too literally. Unlike a `foreach` iteration variable, the range
    variable does not exist as a single conventional variable. In the query, it is
    just an identifier that represents an item from the source, and in expanding the
    query into method calls, C# may end up creating multiple real variables for a
    single range variable, like it has with the arguments for the two separate lambdas
    here.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器已将 `where` 和 `select` 子句的表达式转换为 lambda 表达式。注意，范围变量最终成为每个 lambda 的参数。这是一个例子，说明为什么不应过于字面地将查询表达式与
    `foreach` 循环类比。与 `foreach` 迭代变量不同，范围变量并不存在作为单个常规变量。在查询中，它只是一个表示源中项的标识符，在扩展查询为方法调用时，C#
    可能会为单个范围变量创建多个实际变量，就像在这里为两个分离的 lambda 的参数创建的那样。
- en: 'All query expressions boil down to this sort of thing—chained method calls
    with lambdas. (This is why we don’t strictly need the query expression syntax—you
    could write any query using method calls instead.) Some are more complex than
    others. The expression in [Example 10-1](#a_linq_query_expression) ends up with
    a simpler structure despite looking almost identical to [Example 10-3](#extracting_just_one_property_in_a_query).
    [Example 10-5](#how_trivial_select_clauses_expand) shows how it expands. It turns
    out that when a query’s `select` clause just passes the range variable straight
    through, the compiler interprets that as meaning that we want to pass the results
    of the preceding clause straight through without further processing, so it doesn’t
    add a call to `Select`. (There is one exception to this: if you write a query
    expression that contains nothing but a `from` and a `select` clause, it will generate
    a call to `Select` even if the `select` clause is trivial.)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所有查询表达式归结为这种形式——带有 lambda 的链式方法调用。（这就是为什么我们不严格需要查询表达式语法——你可以使用方法调用来写任何查询。）有些比其他的更复杂。尽管看起来几乎相同，[示例 10-1](#a_linq_query_expression)
    中的表达式最终具有更简单的结构。[示例 10-5](#how_trivial_select_clauses_expand) 展示了它是如何展开的。原来，当查询的
    `select` 子句直接传递范围变量时，编译器解释为我们希望直接传递前一个子句的结果，而无需进一步处理，因此不会添加 `Select` 调用。（这有一个例外：如果编写一个查询表达式，其中只包含
    `from` 和 `select` 子句，它将生成一个 `Select` 调用，即使 `select` 子句是微不足道的。）
- en: Example 10-5\. How trivial `select` clauses expand
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-5\. `select` 子句如何展开
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The compiler has to work harder if you introduce multiple variables within the
    query’s scope. You can do this with a `let` clause. [Example 10-6](#query_with_a_let_clause)
    performs the same job as [Example 10-3](#extracting_just_one_property_in_a_query),
    but I’ve introduced a new variable called `numFormat` to refer to the number format.
    This makes my `where` clause shorter and easier to read, and in a more complex
    query that needed to refer to that format object multiple times, this technique
    could remove a lot of clutter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在查询的范围内引入多个变量，编译器将需要更多工作。可以使用 `let` 子句来实现这一点。[示例 10-6](#query_with_a_let_clause)
    执行与 [示例 10-3](#extracting_just_one_property_in_a_query) 相同的作业，但我引入了一个名为 `numFormat`
    的新变量来引用数字格式。这使得我的 `where` 子句更短更易读，在需要多次引用该格式对象的更复杂查询中，这种技术可以减少很多混乱。
- en: Example 10-6\. Query with a `let` clause
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-6\. 带有 `let` 子句的查询
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When you write a query that introduces additional variables like this, the compiler
    automatically generates a hidden class with a field for each of the variables
    so that it can make them all available at every stage. To get the same effect
    with ordinary method calls, we’d need to do something similar, and an easy way
    to do that is to introduce an anonymous type to contain them, as [Example 10-7](#multivariable_query_expressions_expand)
    shows.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写引入额外变量的查询时，编译器会自动生成一个隐藏类，为每个变量创建一个字段，以便在每个阶段都能使它们可用。为了在普通的方法调用中达到同样的效果，我们需要做类似的事情，引入一个匿名类型来包含它们，就像
    [示例 10-7](#multivariable_query_expressions_expand) 中展示的那样。
- en: Example 10-7\. How multivariable query expressions expand (approximately)
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-7\. 多变量查询表达式如何扩展（近似）
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: No matter how simple or complex they are, query expressions are nothing more
    than a specialized syntax for method calls. This suggests how we might go about
    writing a custom source for a query expression.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 无论查询表达式多么简单或复杂，它们都不过是方法调用的一种特殊语法。这表明了我们编写自定义查询表达式源的方法。
- en: Supporting Query Expressions
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持查询表达式
- en: Because the C# compiler just converts the various clauses of a query expression
    into method calls, we can write a type that participates in these expressions
    by defining some suitable methods. To illustrate that the C# compiler really doesn’t
    care what these methods do, [Example 10-8](#nonsensical_where_and_select) shows
    a class that makes absolutely no sense but nonetheless keeps C# happy when used
    from a query expression. The compiler just mechanically converts a query expression
    into a series of method calls, so if suitable-looking methods exist, the code
    will compile successfully.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 C# 编译器只是将查询表达式的各个子句转换为方法调用，所以我们可以编写一个类型来参与这些表达式，定义一些合适的方法。为了说明 C# 编译器实际上并不关心这些方法做了什么，[示例 10-8](#nonsensical_where_and_select)
    展示了一个完全没有意义的类，但在从查询表达式中使用时，仍然能让 C# 保持愉快。编译器只是机械地将查询表达式转换为一系列方法调用，因此如果存在合适的方法，代码将成功编译。
- en: Example 10-8\. Nonsensical `Where` and `Select`
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-8\. 毫无意义的 `Where` 和 `Select`
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: I can use an instance of this class as the source of a query expression. That’s
    crazy because this class does not in any way represent a collection of data, but
    the compiler doesn’t care. It just needs certain methods to be present, so if
    I write the code in [Example 10-9](#a_meaningless_query), the compiler will be
    perfectly happy even though the code doesn’t make any sense.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用这个类的实例作为查询表达式的源。这太疯狂了，因为这个类根本不代表数据的集合，但编译器不关心。它只需要某些方法存在，所以如果我在 [示例 10-9](#a_meaningless_query)
    中编写代码，尽管代码毫无意义，编译器仍会完全满意。
- en: Example 10-9\. A meaningless query
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-9\. 一个无意义的查询
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The compiler converts this into method calls in exactly the same way that it
    did with the more sensible query in [Example 10-1](#a_linq_query_expression).
    [Example 10-10](#how_the_compiler_transforms_the_meaningl) shows the result. If
    you’re paying close attention, you’ll have noticed that my range variable actually
    changes type partway through—my `Where` method requires a delegate that takes
    a string, so in that first lambda, `x` is of type `string`. But my `Select` method
    requires its delegate to take a `DateTime`, so that’s the type of `x` in that
    lambda. (And it’s all ultimately irrelevant, because my `Where` and `Select` methods
    don’t even use these lambdas.) Again, this is nonsense, but it shows how mechanically
    the C# compiler converts queries to method calls.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将这些内容转换为方法调用的方式与[示例 10-1](#a_linq_query_expression)中更合理的查询完全相同。[示例 10-10](#how_the_compiler_transforms_the_meaningl)
    展示了结果。如果你注意到了，你会发现我的范围变量在中间实际上改变了类型——我的 `Where` 方法需要一个接受字符串的委托，所以在第一个 Lambda 中，`x`
    的类型是 `string`。但是我的 `Select` 方法要求它的委托接受一个 `DateTime`，所以在那个 Lambda 中，`x` 的类型就是 `DateTime`。
    （而这些都不重要，因为我的 `Where` 和 `Select` 方法甚至根本不使用这些 Lambda。）再次强调，这是无意义的，但它展示了 C# 编译器如何机械地将查询转换为方法调用。
- en: Example 10-10\. How the compiler transforms the meaningless query
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-10\. 编译器如何转换这个无意义的查询
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Obviously, it’s not useful to write code that makes no sense. The reason I’m
    showing you this is to demonstrate that the query expression syntax knows nothing
    about semantics—the compiler has no particular expectation of what any of the
    methods it invokes will do. All that it requires is that they accept lambdas as
    arguments and return something other than `void`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，编写毫无意义的代码是没有用的。我展示这个的原因是为了演示查询表达式语法不了解语义——编译器对其调用的任何方法都没有特定的期望。它所要求的只是它们接受
    lambda 作为参数并返回非`void`。
- en: Clearly, the real work is happening elsewhere. It’s the LINQ providers themselves
    that make things happen. So now I’ll outline what we would need to write to make
    the queries I showed in the first couple of examples work if LINQ to Objects didn’t
    exist.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 明显，真正的工作是在别处进行的。正是 LINQ 提供程序自己使事情发生。现在我将概述，如果没有 LINQ to Objects，我们需要编写什么来使我在前面的几个示例中显示的查询工作。
- en: 'You’ve seen how LINQ queries are transformed into code such as that shown in
    [Example 10-4](#the_effect_of_a_query_expression), but this isn’t the whole story.
    The `where` clause becomes a call to the `Where` method, but we’re calling it
    on an array of type `CultureInfo[]`, a type that does not in fact have a `Where`
    method. This works only because LINQ to Objects defines an appropriate extension
    method. As I showed in [Chapter 3](ch03.xhtml#ch_types), it’s possible to add
    new methods to existing types, and LINQ to Objects does that for `IEnumerable<T>`.
    (Since most collections implement `IEnumerable<T>`, this means LINQ to Objects
    can be used on almost any kind of collection.) To use these extension methods,
    you need a `using` directive for the `System.Linq` namespace; in .NET 6.0, newly
    created projects enable the *implicit global usings* feature (described in [“Namespaces”](ch01.xhtml#namespaces)),
    which automatically generates a suitable global `using` directive for `System.Linq`,
    so unless you’ve disabled that feature, or your project was created before .NET
    6.0 and has not subsequently enabled that setting, you won’t need to write the
    directive yourself. (The extension methods are all defined by a static class in
    that namespace called `Enumerable`, by the way.) If you attempted to use LINQ
    without that directive, the compiler would produce this error for the query expression
    for [Example 10-1](#a_linq_query_expression) or [Example 10-3](#extracting_just_one_property_in_a_query):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了 LINQ 查询如何转换为像[示例 10-4](#the_effect_of_a_query_expression)中显示的代码，但这并不是全部故事。`where`
    子句变成了对 `Where` 方法的调用，但我们是在 `CultureInfo[]` 类型的数组上调用它，这种类型实际上没有 `Where` 方法。这只能工作，因为
    LINQ to Objects 定义了一个适当的扩展方法。就像我在[第 3 章](ch03.xhtml#ch_types)中展示的那样，可以向现有类型添加新方法，LINQ
    to Objects 就是为 `IEnumerable<T>` 定义这些方法的。（由于大多数集合实现了 `IEnumerable<T>`，这意味着几乎可以在任何类型的集合上使用
    LINQ to Objects。）要使用这些扩展方法，您需要为 `System.Linq` 命名空间添加一个 `using` 指令；在 .NET 6.0 中，新创建的项目启用了*隐式全局
    using*功能（在[“命名空间”](ch01.xhtml#namespaces)中描述），它会自动生成适合的全局 `using` 指令，因此，除非您禁用了该功能，或者您的项目是在
    .NET 6.0 之前创建的并且之后未启用该设置，否则您不需要自己编写指令。（顺便说一下，所有这些扩展方法都由该命名空间中名为 `Enumerable` 的静态类定义。）如果您尝试在没有该指令的情况下使用
    LINQ，编译器会为 [示例 10-1](#a_linq_query_expression) 或 [示例 10-3](#extracting_just_one_property_in_a_query)
    的查询表达式生成以下错误：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In general, that error message’s suggestion would be helpful, but in this case,
    I want to write my own LINQ implementation. [Example 10-11](#a_custom_linq_provider_for_cultureinfo)
    does this, and I’ve shown the whole source file because extension methods are
    sensitive to the use of namespaces and `using` directives. (If you download the
    examples, you’ll also find that I’ve not enabled implicit global usings for this
    particular project, just so it’s completely clear what’s happening.) The contents
    of the `Main` method should look familiar—this is similar to [Example 10-3](#extracting_just_one_property_in_a_query),
    but this time, instead of using the LINQ to Objects provider, it will use the
    extension methods from my `CustomLinqProvider` class. (Normally, you make extension
    methods available with a `using` directive, but because `Cus⁠tom⁠Linq​Pro⁠vid⁠er`
    is in the same namespace as the `Program` class, all of its extension methods
    are automatically available to `Main`.)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，该错误消息的建议可能很有帮助，但在这种情况下，我想编写自己的LINQ实现。[示例 10-11](#a_custom_linq_provider_for_cultureinfo)
    就是这样做的，我展示了整个源文件，因为扩展方法对命名空间和`using`指令的使用很敏感。（如果你下载这些示例，你会发现我没有为这个特定项目启用隐式全局`using`，这样就完全清楚发生了什么。）`Main`方法的内容应该看起来很熟悉——这类似于[示例 10-3](#extracting_just_one_property_in_a_query)，但这一次，它将使用我的`CustomLinqProvider`类的扩展方法，而不是使用LINQ到对象提供程序。（通常情况下，你可以通过`using`指令使扩展方法可用，但由于`CustomLinqProvider`与`Program`类在同一个命名空间中，它的所有扩展方法都会自动对`Main`可用。）
- en: Warning
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Although [Example 10-11](#a_custom_linq_provider_for_cultureinfo) behaves as
    intended, you should not take this as an example of how a LINQ provider normally
    executes its queries. This does illustrate how LINQ providers put themselves in
    the picture, but as I’ll show later, there are some issues with how this code
    goes on to perform the query. Also, it’s rather minimalistic—there’s more to LINQ
    than `Where` and `Select`, and most real providers offer more than just these
    two operators.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然[示例 10-11](#a_custom_linq_provider_for_cultureinfo)表现如预期，但你不应将其视为LINQ提供程序通常执行其查询的示例。这确实展示了LINQ提供程序如何置身事外，但正如我稍后将展示的那样，这段代码在执行查询时存在一些问题。而且，它相当简约——LINQ不仅仅是`Where`和`Select`，大多数真实的提供程序提供的不仅仅是这两个操作符。
- en: Example 10-11\. A custom LINQ provider for `CultureInfo[]`
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-11\. 一个用于`CultureInfo[]`的自定义LINQ提供程序
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you’re now well aware, the query expression in `Main` will first call `Where`
    on the source and will then call `Select` on whatever `Where` returns. As before,
    the source is the return value of `GetCultures`, which is an array of type `CultureInfo[]`.
    That’s the type for which `CustomLinqProvider` defines extension methods, so this
    will invoke `CustomLinqProvider.Where`. That uses the `Array` class’s `FindAll`
    method to find all of the elements in the source array that match the predicate.
    The `Where` method passes its own argument straight through to `FindAll` as the
    predicate, and as you know, when the C# compiler calls `Where`, it passes a lambda
    based on the expression in the LINQ query’s `where` clause. That predicate will
    match the cultures that use a comma as their decimal separator, so the `Where`
    clause returns an array of type `CultureInfo[]` that contains only those cultures.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你现在很清楚的那样，在`Main`中的查询表达式将首先在源上调用`Where`，然后在`Where`的返回值上调用`Select`。与之前一样，源是`GetCultures`的返回值，它是一个`CultureInfo[]`类型的数组。这是`CustomLinqProvider`定义的扩展方法的类型，因此这将调用`CustomLinqProvider.Where`。它使用`Array`类的`FindAll`方法来查找源数组中与谓词匹配的所有元素。`Where`方法将自己的参数直接传递给`FindAll`作为谓词，正如你所知道的，当C#编译器调用`Where`时，它会传递一个基于LINQ查询中`where`子句表达式的lambda表达式。该谓词将匹配使用逗号作为其小数分隔符的区域设置，因此`Where`子句返回一个仅包含这些区域设置的`CultureInfo[]`类型的数组。
- en: Next, the code that the compiler created for the query will call `Select` on
    the `CultureInfo[]` array returned by `Where`. Arrays don’t have a `Select` method,
    so the extension method in `CustomLinqProvider` will be used. My `Select` method
    is generic, so the compiler will need to work out what the type argument should
    be, and it can infer this from the expression in the `select` clause.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编译器为查询创建的代码将在`Where`返回的`CultureInfo[]`数组上调用`Select`。数组没有`Select`方法，因此将使用`CustomLinqProvider`中的扩展方法。我的`Select`方法是泛型的，因此编译器将需要推断类型参数，它可以从`select`子句中的表达式中推断出来。
- en: 'First, the compiler transforms it into a lambda: `culture => culture.Name`.
    Because this becomes the second argument for `Select`, the compiler knows that
    we require a `Func<CultureInfo, T>`, so it knows that the `culture` parameter
    must be of type `CultureInfo`. This enables it to infer that `T` must be `string`,
    because the lambda returns `culture.Name`, and that `Name` property’s type is
    `string`. So the compiler knows that it is invoking `CustomLinqProvider.Select<string>`.
    (The deduction I just described is not specific to query expressions, by the way.
    The type inference takes place after the query has been transformed into method
    calls. The compiler would have gone through exactly the same process if we had
    started with the code in [Example 10-4](#the_effect_of_a_query_expression).)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，编译器将其转换为一个 lambda 表达式：`culture => culture.Name`。因为这成为 `Select` 的第二个参数，编译器知道我们需要一个
    `Func<CultureInfo, T>`，因此它知道 `culture` 参数必须是 `CultureInfo` 类型。这使它能够推断 `T` 必须是
    `string`，因为 lambda 返回 `culture.Name`，而 `Name` 属性的类型是 `string`。所以编译器知道它正在调用 `CustomLinqProvider.Select<string>`。（顺便说一句，我刚刚描述的推断并不特定于查询表达式。类型推断发生在查询被转换为方法调用之后。如果我们从
    [Example 10-4](https://wiki.example.org/the_effect_of_a_query_expression) 中的代码开始，编译器将经历完全相同的过程。）
- en: The `Select` method will now produce an array of type `string[]` (because `T`
    is `string` here). It populates that array by iterating through the elements in
    the incoming `CultureInfo[]`, passing each `CultureInfo` as the argument to the
    lambda that extracts the `Name` property. So we end up with an array of strings,
    containing the name of each culture that uses a comma as its decimal separator.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Select` 方法将生成一个 `string[]` 类型的数组（因为这里的 `T` 是 `string`）。它通过迭代传入的 `CultureInfo[]`
    中的元素，将每个 `CultureInfo` 作为参数传递给提取 `Name` 属性的 lambda 表达式来填充该数组。因此，我们最终得到一个包含每个使用逗号作为其十进制分隔符的文化的名称的字符串数组。
- en: That’s a slightly more realistic example than my `SillyLinqProvider`, because
    this does now provide the expected behavior. However, although the query produces
    the same strings as it did when using the real LINQ to Objects provider, the mechanism
    by which it does so is somewhat different. My `CustomLinqProvider` performed each
    operation immediately—the `Where` and `Select` methods both returned fully populated
    arrays. LINQ to Objects does something quite different. In fact, so do most LINQ
    providers.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子比我的 `SillyLinqProvider` 稍微现实一些，因为它现在提供了预期的行为。然而，虽然查询产生了与使用真正的 LINQ to Objects
    提供程序时相同的字符串，但它所采用的机制有些不同。我的 `CustomLinqProvider` 立即执行了每个操作——`Where` 和 `Select`
    方法都返回完全填充的数组。LINQ to Objects 做了完全不同的事情。实际上，大多数 LINQ 提供程序也是如此。
- en: Deferred Evaluation
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟评估
- en: If LINQ to Objects worked in the same way as my custom provider in [Example 10-11](#a_custom_linq_provider_for_cultureinfo),
    it would not cope well with [Example 10-12](#query_with_an_infinite_source_sequence).
    This has a `Fibonacci` method that returns a never-ending sequence—it will keep
    providing numbers from the Fibonacci series for as long as the code keeps asking
    for them. I have used the `IEn⁠ume⁠rab⁠le​<Big⁠Inte⁠ger>` returned by this method
    as the source for a query expression. Since we have a `using` directive for `System.Linq`
    in place near the start, I’m back to using LINQ to Objects here. (In the downloadable
    examples, I’ve disabled implicit global `using` directives for this project to
    make it clear exactly which namespaces are in use.)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 LINQ to Objects 的工作方式与我在 [Example 10-11](https://wiki.example.org/a_custom_linq_provider_for_cultureinfo)
    中的自定义提供程序相同，它将无法很好地处理 [Example 10-12](https://wiki.example.org/query_with_an_infinite_source_sequence)。这有一个
    `Fibonacci` 方法，返回一个永无止境的序列——只要代码继续请求，它将继续提供斐波那契数列中的数字。我已经使用这个方法返回的 `IEnumerable<BigInteger>`
    作为查询表达式的源。由于我们在开头附近放置了 `System.Linq` 的 `using` 指令，我现在回到使用 LINQ to Objects。 （在可下载的示例中，我已禁用了该项目的隐式全局
    `using` 指令，以清楚地了解使用了哪些命名空间。）
- en: Example 10-12\. Query with an infinite source sequence
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 10-12\. 具有无限源序列的查询
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will use the `Where` extension method that LINQ to Objects provides for
    `IEnumerable<T>`. If that worked the same way as my `CustomLinqExtension` class’s
    `Where` method for `CultureInfo[]` in [Example 10-11](#a_custom_linq_provider_for_cultureinfo),
    this program would never make it as far as displaying a single number. My `Where`
    method did not return until it had filtered the whole of its input and produced
    a fully populated array as its output. If the LINQ to Objects `Where` method tried
    that with my infinite Fibonacci enumerator, it would never finish.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里将使用 LINQ to Objects 为 `IEnumerable<T>` 提供的 `Where` 扩展方法。如果它的工作方式与我在 [示例 10-11](#a_custom_linq_provider_for_cultureinfo)
    中为 `CultureInfo[]` 编写的 `CustomLinqExtension` 类的 `Where` 方法相同，那么这个程序将永远无法显示单个数字。我的
    `Where` 方法在未过滤其整个输入并生成完全填充的数组作为输出之前不会返回。如果 LINQ to Objects 的 `Where` 方法尝试对我的无限斐波那契枚举器进行相同的操作，它将永远无法完成。
- en: In fact, [Example 10-12](#query_with_an_infinite_source_sequence) works perfectly—it
    produces a steady stream of output consisting of the Fibonacci numbers that are
    divisible by 2\. This means it can’t be attempting to perform all of the filtering
    when we call `Where`. Instead, its `Where` method returns an `IEnumerable<T>`
    that filters items on demand. It won’t try to fetch anything from the input sequence
    until something asks for a value, at which point it will start retrieving one
    value after another from the source until the filter delegate says that a match
    has been found. It then produces that and doesn’t try to retrieve anything more
    from the source until it is asked for the next item. [Example 10-13](#a_custom_deferred_where_operator)
    shows how you could implement this behavior by taking advantage of C#’s `yield
    return` feature.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，[示例 10-12](#query_with_an_infinite_source_sequence) 运行完美——它产生了一系列由2整除的斐波那契数输出。这意味着在我们调用
    `Where` 时它不会尝试执行所有的过滤工作。相反，它的 `Where` 方法返回一个 `IEnumerable<T>`，按需过滤项目。它不会尝试从输入序列获取任何内容，直到某些东西要求一个值，此时它将从源中一个接一个地检索值，直到过滤委托说找到匹配项。然后它会生成该匹配项，并在被要求下一个项目之前不会再从源中检索任何内容。[示例 10-13](#a_custom_deferred_where_operator)
    展示了如何利用 C# 的 `yield return` 特性实现这种行为。
- en: Example 10-13\. A custom deferred `Where` operator
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-13\. 自定义延迟 `Where` 操作符
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The real LINQ to Objects implementation of `Where` is somewhat more complex.
    It detects certain special cases, such as arrays and lists, and it handles them
    in a way that is slightly more efficient than the general-purpose implementation
    that it falls back to for other types. However, the principle is the same for
    `Where` and all of the other operators: these methods do not perform the specified
    work. Instead, they return objects that will perform the work on demand. It’s
    only when you attempt to retrieve the results of a query that anything really
    happens. This is called *deferred evaluation*, or sometimes *lazy evaluation*.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的 LINQ to Objects 的 `Where` 实现要复杂一些。它检测到某些特殊情况，比如数组和列表，并以略微比通用实现更高效的方式处理它们。然而，对于
    `Where` 和所有其他操作符来说，原则都是一样的：这些方法不执行指定的工作。相反，它们返回将按需执行工作的对象。只有在尝试检索查询结果时才会真正发生任何事情。这被称为*延迟评估*，有时也称为*惰性评估*。
- en: Deferred evaluation has the benefit of not doing work until you need it, and
    it makes it possible to work with infinite sequences. However, it also has disadvantages.
    You may need to be careful to avoid evaluating queries multiple times. [Example 10-14](#accidental_deferred_reevaluation)
    makes this mistake, causing it to do much more work than necessary. This loops
    through several different numbers and writes out each one using the currency format
    of each culture that uses a comma as a decimal separator.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟评估的好处是在需要时才执行工作，并且可以处理无限序列。然而，它也有缺点。您可能需要小心避免多次评估查询。[示例 10-14](#accidental_deferred_reevaluation)
    犯了这个错误，导致执行比必要做的工作多得多。这段代码循环遍历几个不同的数字，并使用每个使用逗号作为小数分隔符的文化的货币格式写出每一个数字。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you run this on Windows, you may find that most of the lines this code displays
    will contain `?` characters, indicating that the console cannot display most of
    the currency symbols. In fact, it can—it just needs permission. By default, the
    Windows console uses an 8-bit code page for backward-compatibility reasons. If
    you run the command `chcp 65001` from a Command Prompt, it will switch that console
    window into a UTF-8 code page, enabling it to show any Unicode characters supported
    by your chosen console font. You might want to configure the console to use a
    font with comprehensive support for uncommon characters—Consolas or Lucida Console,
    for example—to take best advantage of that.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Windows上运行此代码，则可能会发现大多数行显示的是包含`?`字符的行，表示控制台无法显示大多数货币符号。实际上，它可以——只是需要权限。默认情况下，Windows控制台出于向后兼容性的原因使用8位代码页。如果您从命令提示符运行命令`chcp
    65001`，它将将该控制台窗口切换到UTF-8代码页，从而使其能够显示您选择的控制台字体支持的任何Unicode字符。您可能希望配置控制台使用具有对不常见字符全面支持的字体——例如Consolas或Lucida
    Console，以充分利用它。
- en: Example 10-14\. Accidental reevaluation of a deferred query
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-14\. 延迟查询的意外重新评估
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The problem with this code is that even though the `commaCultures` variable
    is initialized outside of the number loop, we iterate through it for each number.
    And because LINQ to Objects uses deferred evaluation, that means that the actual
    work of running the query is redone every time around the outer loop. So, instead
    of evaluating that `where` clause once for each culture (813 times on my system),
    it ends up running four times for each culture (3,252 times) because the whole
    query is evaluated once for each of the four items in the `numbers` array. It’s
    not a disaster—the code still works correctly. But if you do this in a program
    that runs on a heavily loaded server, it will harm your throughput.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的问题在于，即使`commaCultures`变量在数字循环外部初始化，我们也会为每个数字迭代它。由于LINQ to Objects使用延迟评估，这意味着每次外部循环周围都会重新执行查询的实际工作。因此，而不是为每种文化（在我的系统上为813次）评估一次`where`子句，它最终为每种文化执行四次（3,252次），因为整个查询针对`numbers`数组的四个项之一每次都会评估。这并不是灾难性的——代码仍然能正常工作。但是，如果您在运行在负载较重的服务器上的程序中执行此操作，它将损害您的吞吐量。
- en: If you know you will need to iterate through the results of a query multiple
    times, consider using either the `ToList` or `ToArray` extension methods provided
    by LINQ to Objects. These immediately evaluate the whole query once, producing
    an `IList<T>` or a `T[]` array, respectively (so you shouldn’t use these methods
    on infinite sequences, obviously). You can then iterate through that as many times
    as you like without incurring any further costs (beyond the minimal cost inherent
    in reading array or list elements). But in cases where you iterate through a query
    only once, it is usually better not to use these methods, as they’ll consume more
    memory than necessary.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您知道您将需要多次迭代查询的结果，请考虑使用LINQ to Objects提供的`ToList`或`ToArray`扩展方法之一。这些方法立即评估整个查询一次，分别生成`IList<T>`或`T[]`数组（因此显然不应在无限序列上使用这些方法）。然后，您可以随意多次迭代它，而不会产生进一步的成本（除了读取数组或列表元素所固有的最小成本）。但在只迭代一次查询的情况下，通常最好不要使用这些方法，因为它们将比必要的消耗更多内存。
- en: LINQ, Generics, and IQueryable<T>
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LINQ、泛型和IQueryable<T>
- en: Most LINQ providers use generic types. Nothing enforces this, but it is very
    common. LINQ to Objects uses `IEnumerable<T>`. Several of the database providers
    use a type called `IQueryable<T>`. More broadly, the pattern is to have some generic
    type `*Source*<T>`, where `*Source*` represents some source of items, and `T`
    is the type of an individual item. A source type with LINQ support makes operator
    methods available on `*Source*<T>` for any `T`, and those operators also typically
    return `*Source*<TResult>`, where `TResult` may or may not be different than `T`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数LINQ提供程序使用泛型类型。虽然没有强制要求这样做，但这种做法非常普遍。LINQ to Objects使用`IEnumerable<T>`。几个数据库提供程序使用称为`IQueryable<T>`的类型。更广泛地说，模式是具有某种泛型类型`*Source*<T>`，其中`*Source*`表示某些项目的来源，而`T`是单个项目的类型。具有LINQ支持的源类型使得操作方法在`*Source*<T>`上对任何`T`都可用，并且这些操作符通常还返回`*Source*<TResult>`，其中`TResult`可能与`T`不同。
- en: '`IQueryable<T>` is interesting because it is designed to be used by multiple
    providers. This interface, its base `IQueryable`, and the related `IQueryProvider`
    are shown in [Example 10-15](#iqueryable_and_iqueryable_of_t).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`IQueryable<T>`很有趣，因为它设计用于多个提供程序使用。在[示例 10-15](#iqueryable_and_iqueryable_of_t)中显示了这个接口、它的基本`IQueryable`和相关的`IQueryProvider`。'
- en: Example 10-15\. `IQueryable` and `IQueryable<T>`
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-15\. `IQueryable` 和 `IQueryable<T>`
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The most obvious feature of `IQueryable<T>` is that it adds no members to its
    bases. That’s because it’s designed to be used entirely via extension methods.
    The `Sys⁠tem.​Li⁠nq` namespace defines all of the standard LINQ operators for
    `IQueryable<T>` as extension methods provided by the `Queryable` class. However,
    all of these simply defer to the `Provider` property defined by the `IQueryable`
    base. So, unlike LINQ to Objects, where the extension methods on `IEnumerable<T>`
    define the behavior, an `IQueryable<T>` implementation is able to decide how to
    handle queries because it gets to supply the `IQueryProvider` that does the real
    work.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`IQueryable<T>` 最明显的特点是，它不向其基类添加任何成员。这是因为它完全通过扩展方法来使用。`Sys⁠tem.​Li⁠nq` 命名空间定义了所有标准
    LINQ 操作符，这些操作符是由 `Queryable` 类提供的扩展方法，适用于 `IQueryable<T>`。然而，所有这些操作符都简单地推迟到由 `IQueryable`
    基类定义的 `Provider` 属性。因此，与 LINQ to Objects 不同，在那里，`IEnumerable<T>` 上的扩展方法定义了行为，`IQueryable<T>`
    的实现能够决定如何处理查询，因为它可以提供执行实际工作的 `IQueryProvider`。'
- en: 'However, all `IQueryable<T>`-based LINQ providers have one thing in common:
    they interpret the lambdas as expression objects, not delegates. [Example 10-16](#enumerable_versus_queryable)
    shows the declaration of the `Where` extension methods defined for `IEnumerable<T>`
    and `IQueryable<T>`. Compare the `predicate` parameters.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，所有基于 `IQueryable<T>` 的 LINQ 提供程序有一个共同点：它们将 lambda 解释为表达式对象，而不是委托。[Example 10-16](#enumerable_versus_queryable)
    展示了为 `IEnumerable<T>` 和 `IQueryable<T>` 定义的 `Where` 扩展方法的声明。比较 `predicate` 参数。
- en: Example 10-16\. `Enumerable` versus `Queryable`
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-16\. `Enumerable` versus `Queryable`
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `Where` extension for `IEnumerable<T>` (LINQ to Objects) takes a `Func<TSource,
    bool>`, and as you saw in [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events),
    this is a delegate type. But the `Where` extension method for `IQueryable<T>`
    (used by numerous LINQ providers) takes `Exp⁠res⁠sion​<Fu⁠nc<T⁠Sou⁠rce,⁠ bool>>`,
    and as you also saw in [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events), this
    causes the compiler to build an object model of the expression and pass that as
    the argument.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<T>` 的 `Where` 扩展方法（LINQ to Objects）接受 `Func<TSource, bool>`，如您在
    [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events) 中所见，这是一种委托类型。但是 `IQueryable<T>`
    的 `Where` 扩展方法（许多 LINQ 提供程序使用）接受 `Exp⁠res⁠sion​<Fu⁠nc<T⁠Sou⁠rce,⁠ bool>>`，正如您在
    [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events) 中也看到的，这会导致编译器构建表达式的对象模型并将其作为参数传递。'
- en: A LINQ provider typically uses `IQueryable<T>` if it wants these expression
    trees. And that’s usually because it’s going to inspect your query and convert
    it into something else, such as a SQL query.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 LINQ 提供程序需要这些表达式树，通常会使用 `IQueryable<T>`。这通常是因为它将检查您的查询并将其转换为其他形式，例如 SQL 查询。
- en: There are some other common generic types that crop up in LINQ. Some LINQ features
    guarantee to produce items in a certain order, and some do not. More subtly, a
    handful of operators produce items in an order that depends upon the order of
    their input. This can be reflected in the types for which the operators are defined
    and the types they return. LINQ to Objects defines `IOrderedEnumerable<T>` to
    represent ordered data, and there’s a corresponding `IOrderedQueryable<T>` type
    for `IQueryable<T>`-based providers. (Providers that use their own types tend
    to do something similar—Parallel LINQ, described in [Chapter 16](ch16.xhtml#ch_multithreading),
    defines an `Ord⁠ered​Par⁠all⁠elQ⁠uery<T>`, for example.) These interfaces derive
    from their unordered counterparts, such as `IEnumerable<T>` and `IQueryable<T>`,
    so all the usual operators are available, but they make it possible to define
    operators or other methods that need to take the existing order of their input
    into account. For example, in [“Ordering”](#ordering), I will show a LINQ operator
    called `ThenBy`, which is available only on sources that are already ordered.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LINQ 中还有一些其他常见的泛型类型。一些 LINQ 特性保证按特定顺序生成项目，而另一些则不保证。更微妙的是，一些运算符生成的项目顺序取决于其输入的顺序。这可以反映在定义运算符的类型和它们返回的类型中。LINQ
    to Objects 定义了 `IOrderedEnumerable<T>` 来表示有序数据，而对于基于 `IQueryable<T>` 的提供程序，则有相应的
    `IOrderedQueryable<T>` 类型。（使用自己类型的提供程序往往会做类似的事情——例如，Parallel LINQ 在 [Chapter 16](ch16.xhtml#ch_multithreading)
    中定义了 `Ord⁠ered​Par⁠all⁠elQ⁠uery<T>`。）这些接口从它们的无序对应接口派生，如 `IEnumerable<T>` 和 `IQueryable<T>`，因此所有常见的运算符都是可用的，但它们使得定义需要考虑其输入顺序的运算符或其他方法成为可能。例如，在
    [“Ordering”](#ordering) 中，我将展示一个称为 `ThenBy` 的 LINQ 运算符，该运算符仅在已经有序的源上可用。
- en: When looking at LINQ to Objects, this ordered/unordered distinction may seem
    unnecessary, because `IEnumerable<T>` always produces items in some sort of order.
    But some providers do not necessarily do things in any particular order, perhaps
    because they parallelize query execution, or because they get a database to execute
    the query for them, and databases reserve the right to meddle with the order in
    certain cases if it enables them to work more efficiently.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看 LINQ to Objects 时，有序/无序的区分可能看起来是不必要的，因为 `IEnumerable<T>` 总是以某种顺序生成项目。但某些提供程序并不一定以任何特定的顺序进行操作，也许是因为它们并行执行查询，或者因为它们让数据库为它们执行查询，并且在某些情况下，数据库保留在启用更有效地工作时干预顺序的权利。
- en: Standard LINQ Operators
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准 LINQ 操作符
- en: In this section, I will describe the standard operators that LINQ providers
    can supply. Where applicable, I will also describe the query expression equivalent,
    although many operators do not have a corresponding query expression form. Some
    LINQ features are available only through explicit method invocation. This is even
    true with certain operators that can be used in query expressions, because most
    operators are overloaded, and query expressions can’t use some of the more advanced
    overloads.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将描述 LINQ 提供程序可以提供的标准操作符。在适用的情况下，我还将描述查询表达式的等效形式，尽管许多操作符没有相应的查询表达式形式。一些
    LINQ 功能只能通过显式方法调用来使用。即使在某些可以在查询表达式中使用的操作符中也是如此，因为大多数操作符都是重载的，而查询表达式无法使用一些更高级的重载形式。
- en: Note
  id: totrans-99
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: LINQ operators are not operators in the usual C# sense—they are not symbols
    such as `+` or `&&`. LINQ has its own terminology, and for this chapter, an operator
    is a query capability offered by a LINQ provider. In C#, it looks like a method.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 操作符不是通常 C# 中的符号运算符，它们不是如 `+` 或 `&&` 的符号。LINQ 有自己的术语，对于本章而言，操作符是 LINQ 提供程序提供的查询功能。在
    C# 中，它看起来像是一个方法。
- en: 'All of these operators have something in common: they have all been designed
    to support composition. This means that you can combine them in almost any way
    you like, making it possible to build complex queries out of simple elements.
    To enable this, operators not only take some type representing a set of items
    (e.g., an `IEnumerable<T>`) as their input, but most of them also return something
    representing a set of items. As already mentioned, the item type is not always
    the same—an operator might take some `IEnumerable<T>` as input, and produce `IEnumerable<TResult>`
    as output, where `TResult` does not have to be the same as `T`. Even so, you can
    still chain the things together in any number of ways. Part of the reason this
    works is that LINQ operators are like mathematical functions in that they do not
    modify their inputs; rather, they produce a new result that is based on their
    operands. (Functional programming languages typically have the same characteristic.)
    This means that not only are you free to plug operators together in arbitrary
    combinations without fear of side effects, but you are also free to use the same
    source as the input to multiple queries, because no LINQ query will ever modify
    its input. Each operator returns a new query based on its input.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作符都有一个共同点：它们都设计用于支持组合。这意味着您几乎可以以任何方式组合它们，从而能够从简单元素构建复杂查询。为了实现这一点，操作符不仅接受某种类型的项目集合（例如
    `IEnumerable<T>`）作为它们的输入，而且大多数操作符还返回某种代表项目集合的结果。如前所述，项目类型并不总是相同的——一个操作符可能会以某种
    `IEnumerable<T>` 作为输入，并生成 `IEnumerable<TResult>` 作为输出，其中 `TResult` 不必与 `T` 相同。尽管如此，您仍然可以以任意数量的方式将它们链接在一起。这样做的部分原因是
    LINQ 操作符类似于数学函数，它们不会修改它们的输入；相反，它们会基于它们的操作数产生一个新的结果。 （函数式编程语言通常具有相同的特征。）这意味着不仅您可以自由地以任意组合方式连接操作符，而且您还可以自由地将同一源用作多个查询的输入，因为没有任何
    LINQ 查询会修改其输入。每个操作符都返回基于其输入的新查询。
- en: Nothing enforces this functional style. As you saw with my `SillyLinqProvider`,
    the compiler doesn’t care what a method representing a LINQ operator does. However,
    the convention is that operators are functional, in order to support composition.
    The built-in LINQ providers all work this way.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何东西强制执行这种函数式风格。就像您在我的 `SillyLinqProvider` 中看到的那样，编译器并不关心表示 LINQ 操作符的方法做了什么。但是，约定是操作符应该是函数式的，以支持组合。内置的
    LINQ 提供程序都是这样工作的。
- en: Not all providers offer complete support for all operators. The main providers
    Microsoft supplies—such as LINQ to Objects or the LINQ support in Entity Framework
    Core and Rx—are as comprehensive as they can be, but there are some situations
    in which certain operators will not make sense.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有提供商都全面支持所有操作符。微软提供的主要支持包括 LINQ to Objects 或 Entity Framework Core 和 Rx 中的
    LINQ 支持，尽可能全面，但某些情况下，某些操作符可能无意义。
- en: To demonstrate the operators in action, I need some source data. Many of the
    examples in the following sections will use the code in [Example 10-17](#sample_input_data_for_linq_queries).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示操作符的作用，我需要一些源数据。以下部分的许多示例将使用 [示例 10-17](#sample_input_data_for_linq_queries)
    中的代码。
- en: Example 10-17\. Sample input data for LINQ queries
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-17\. LINQ 查询的示例输入数据
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Filtering
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤器
- en: One of the simplest operators is `Where`, which filters its input. You provide
    a predicate, which is a function that takes an individual item and returns a `bool`.
    `Where` returns an object representing the items from the input for which the
    predicate is true. (Conceptually, this is very similar to the `FindAll` method
    available on `List<T>` and array types, but using deferred execution.)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的操作符之一是 `Where`，它用于过滤其输入。你提供一个谓词，即一个接受单个项目并返回 `bool` 的函数。`Where` 返回一个表示输入中谓词为
    true 的项目的对象。（从概念上讲，这与 `List<T>` 和数组类型上可用的 `FindAll` 方法非常相似，但使用延迟执行。）
- en: 'As you’ve already seen, query expressions represent this with a `where` clause.
    However, there’s an overload of the `Where` operator that provides an additional
    feature not accessible from a query expression. You can write a filter lambda
    that takes two arguments: an item from the input and an index representing that
    item’s position in the source. [Example 10-18](#where_operator_with_index) uses
    this form to remove every second number from the input, and it also removes courses
    shorter than three hours.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你已经看到的，查询表达式使用 `where` 子句表示这一点。然而，`Where` 操作符有一种重载，提供了一个从查询表达式中无法访问的额外功能。你可以编写一个过滤器
    lambda，它接受两个参数：输入中的一个项目和表示该项目在源中位置的索引。[示例 10-18](#where_operator_with_index) 使用此形式从输入中移除每隔一个数字，并且还移除长度小于三小时的课程。
- en: Example 10-18\. `Where` operator with index
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-18\. 带索引的 `Where` 操作符
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Indexed filtering is meaningful only for ordered data. It always works with
    LINQ to Objects, because that uses `IEnumerable<T>`, which produces items one
    after another, but not all LINQ providers process items in sequence. For example,
    with the Entity Framework Core (EF Core), the LINQ queries you write in C# will
    be handled on the database. Unless a query explicitly requests some particular
    order, a database is usually free to process items in whatever order it sees fit,
    possibly in parallel. In some cases, a database may have optimization strategies
    that enable it to produce the results a query requires using a process that bears
    little resemblance to the original query. So it might not even be meaningful to
    talk about, say, the 14th item handled by a `WHERE` clause. Consequently, if you
    were to write a query similar to [Example 10-18](#where_operator_with_index) using
    EF Core, executing the query would cause an exception, complaining that the indexed
    `Where` operator is not applicable. If you’re wondering why the overload is even
    present if the provider doesn’t support it, it’s because EF Core uses `IQueryable<T>`,
    so all the standard operators are available at compile time; providers that choose
    to use `IQueryable<T>` can only report the nonavailability of operators at runtime.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 带索引的过滤只对有序数据有意义。它在 LINQ to Objects 中总是有效，因为它使用的是 `IEnumerable<T>`，会一个接一个地生成项目，但并非所有
    LINQ 提供程序都按顺序处理项目。例如，使用 Entity Framework Core (EF Core)，你在 C# 中编写的 LINQ 查询将在数据库上处理。除非查询明确要求特定顺序，否则数据库通常可以自由地按照它认为合适的顺序处理项目，甚至可能并行处理。在某些情况下，数据库可能有优化策略，使其能够使用与原始查询极为不同的过程生成查询所需的结果。因此，说“由
    `WHERE` 子句处理的第 14 个项目”可能并无意义。因此，如果你像 [示例 10-18](#where_operator_with_index) 类似的查询在
    EF Core 中执行，将会引发异常，指出索引的 `Where` 操作符不适用。如果你想知道为什么提供程序不支持却还存在重载，因为 EF Core 使用 `IQueryable<T>`，所以所有标准操作符在编译时都是可用的；选择使用
    `IQueryable<T>` 的提供程序只能在运行时报告操作符的不可用性。
- en: Note
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: LINQ providers that implement some or all of the query logic on the server side
    usually limit what you can do in a query’s lambdas. Conversely, LINQ to Objects
    runs queries in process, so it lets you invoke any method from inside a filter
    lambda—if you want to call `Console.WriteLine` or read data from a file in your
    predicate, LINQ to Objects can’t stop you. But only a very limited selection of
    methods is available in providers for databases. These providers need to be able
    to translate your lambdas into something the server can process, and they will
    reject expressions that attempt to invoke methods that have no server-side equivalent.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 实现部分或全部查询逻辑在服务器端的LINQ提供程序通常限制您可以在查询的Lambda中执行的操作。相反，LINQ到对象在进程中运行查询，因此允许您在过滤Lambda中调用任何方法—如果您想在谓词中调用`Console.WriteLine`或从文件中读取数据，LINQ到对象无法阻止您。但是数据库提供程序仅提供非常有限的方法选择。这些提供程序需要能够将您的Lambda表达式转换为服务器可以处理的内容，并且会拒绝尝试调用没有服务器端等效方法的表达式。
- en: Even so, you might have expected the exception to emerge when you invoke `Where`,
    instead of when you try to execute the query (i.e., when you first try to retrieve
    one or more items). However, providers that convert LINQ queries into some other
    form, such as a SQL query, typically defer all validation until you execute the
    query. This is because some operators may be valid only in certain scenarios,
    meaning that the provider may not know whether any particular operator will work
    until you’ve finished building the whole query. It would be inconsistent if errors
    caused by nonviable queries sometimes emerged while building the query and sometimes
    when executing it, so even in cases where a provider could determine earlier that
    a particular operator will fail, it will usually wait until you execute the query
    to tell you.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，您可能期望异常在调用`Where`时出现，而不是在尝试执行查询时（即当您首次尝试检索一个或多个项目时）。然而，将LINQ查询转换为其他形式（例如SQL查询）的提供程序通常会推迟所有验证直到您执行查询。这是因为某些操作符可能仅在特定情况下有效，这意味着提供程序可能不知道任何特定操作符是否有效，直到您完成整个查询的构建。如果由于不可行查询而导致的错误有时在构建查询时出现，有时在执行时出现，这将是不一致的，因此即使在提供程序可以较早确定特定操作符将失败的情况下，通常也会等到执行查询时才告知您。
- en: The filter lambda you supply to the `Where` operator must take an argument of
    the item type (the `T` in `IEnumerable<T>`, for example), and it must return a
    `bool`. You may remember from [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events)
    that the runtime libraries define a suitable delegate type called `Predicate<T>`,
    but I also mentioned in that chapter that LINQ avoids this, and we can now see
    why. The indexed version of the `Where` operator cannot use `Predicate<T>`, because
    there’s an additional argument, so that overload uses `Func<T, int, bool>`. There’s
    nothing stopping the unindexed form of `Where` from using `Predicate<T>`, but
    LINQ providers tend to use `Func` across the board to ensure that operators with
    similar meanings have similar-looking signatures. Most providers therefore use
    `Func<T, bool>` instead, to be consistent with the indexed version. (C# doesn’t
    care which you use—query expressions still work if the provider uses `Predicate<T>`,
    as my custom `Where` operator in [Example 10-11](#a_custom_linq_provider_for_cultureinfo)
    shows, but none of Microsoft’s providers do this.)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您提供给`Where`操作符的过滤Lambda必须接受项目类型的参数（例如`IEnumerable<T>`中的`T`），并且必须返回`bool`类型。您可能还记得[第9章](ch09.xhtml#ch_delegates_lambdas_events)中运行时库定义了一个称为`Predicate<T>`的适当委托类型，但我在该章节中还提到LINQ避免使用它，现在我们可以看到原因了。`Where`操作符的索引版本不能使用`Predicate<T>`，因为有额外的参数，因此该重载使用`Func<T,
    int, bool>`。没有什么阻止非索引形式的`Where`使用`Predicate<T>`，但LINQ提供程序倾向于全面使用`Func`以确保具有类似意义的操作符具有类似的签名。因此，大多数提供程序使用`Func<T,
    bool>`，以与索引版本保持一致。（C#不在乎您使用哪个—如果提供程序使用`Predicate<T>`，查询表达式仍然有效，如我在[示例10-11](#a_custom_linq_provider_for_cultureinfo)中展示的自定义`Where`操作符，但微软的提供程序没有这样做。）
- en: Warning
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'The C# compiler’s nullability analysis doesn’t understand LINQ operators. If
    you have an `IEnumerable<string?>`, you could write `xs.Where(s => s is not null)`
    to remove any null items, but `Where` will still return an `IEnumerable<string?>`.
    The compiler has no expectations around what `Where` will do, so it doesn’t understand
    that the output is effectively an `IEnumerable<string>`. Arguably it would be
    a mistake for the compiler to make that inference: as [Example 10-8](#nonsensical_where_and_select)
    showed, it’s perfectly possible to supply a `Where` that defies expectations.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: C# 编译器的空值分析并不理解 LINQ 运算符。如果你有一个 `IEnumerable<string?>`，你可以写 `xs.Where(s => s
    is not null)` 来移除任何空值，但是 `Where` 仍然会返回一个 `IEnumerable<string?>`。编译器对 `Where` 的行为没有预期，因此它不理解输出实际上是一个
    `IEnumerable<string>`。可以说让编译器做这样的推断可能是一个错误：就像 [示例 10-8](#nonsensical_where_and_select)
    中展示的那样，可以提供一个违反预期的 `Where`。
- en: 'LINQ defines another filtering operator: `OfType<T>`. This is useful if your
    source contains a mixture of different item types—perhaps the source is an `IEnumerable<object>`
    and you’d like to filter this down to only the items of type `string`. [Example 10-19](#the_oftype_operator)
    shows how the `OfType<T>` operator can do this.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 定义了另一个过滤运算符：`OfType<T>`。如果您的源包含不同类型的项目混合——可能源是 `IEnumerable<object>`，您想将其过滤为仅为
    `string` 类型的项目。 [示例 10-19](#the_oftype_operator) 展示了 `OfType<T>` 运算符如何实现这一点。
- en: Example 10-19\. The `OfType<T>` operator
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-19\. `OfType<T>` 运算符
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When you use the `OfType<T>` operator with a reference type, it will filter
    out any `null` values. If you’ve enabled nullable reference types, `OfType` avoids
    the problems that `Where(s => s is not null)` encounters: if you call `OfType<string>`
    on a sequence of type `IEnumerable<string?>`, the resulting type will be `IEnumerable<string>`.
    But that’s not because `OfType` was designed with nullable reference types in
    mind. On the contrary, it effectively ignores the nullability when you use a reference
    type as the type argument. It happens to do what we want in this case because
    it’s always looking for a positive match. (It effectively performs the same test
    as patterns like `o is string`.) The surprising corollary is that `OfType<string?>`
    will also filter out `null` items, with the slightly peculiar result that it returns
    an `IEnumerable<string?>` that will never produce a `null`.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `OfType<T>` 运算符与引用类型一起使用时，它将过滤掉任何 `null` 值。如果你启用了可空引用类型，`OfType` 避免了 `Where(s
    => s is not null)` 遇到的问题：如果你在 `IEnumerable<string?>` 上调用 `OfType<string>`，结果类型将是
    `IEnumerable<string>`。但这并不是因为 `OfType` 被设计时考虑了可空引用类型。相反，它在使用引用类型作为类型参数时有效地忽略了空值。它之所以在这种情况下做我们想要的事情，是因为它总是寻找积极的匹配（它实际上执行与
    `o is string` 类似的测试）。令人惊讶的推论是 `OfType<string?>` 也会过滤掉 `null` 项，稍微奇怪的是，它返回一个 `IEnumerable<string?>`，但永远不会产生
    `null`。
- en: Both `Where` and `OfType<T>` will produce empty sequences if none of the objects
    in the source meet the requirements. This is not considered to be an error—empty
    sequences are quite normal in LINQ. Many operators can produce them as output,
    and most operators can cope with them as input.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果源中没有任何对象符合要求，`Where` 和 `OfType<T>` 都会产生空序列。这不被视为错误——在 LINQ 中，空序列非常正常。许多运算符可以产生它们作为输出，大多数运算符可以处理它们作为输入。
- en: Select
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Select
- en: When writing a query, we may want to extract only certain pieces of data from
    the source items. The `select` clause at the end of most queries lets us supply
    a lambda that will be used to produce the final output items, and there are a
    couple of reasons we might want to make our `select` clause do more than simply
    pass each item straight through. We might want to pick just one specific piece
    of information from each item, or we might want to transform it into something
    else entirely.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写查询时，我们可能只想从源项目中提取特定的数据片段。大多数查询末尾的 `select` 子句允许我们提供一个 lambda 表达式，用于生成最终的输出项，我们可能希望使我们的
    `select` 子句不仅仅是直接传递每个项。我们可能只想从每个项中挑选一个特定的信息片段，或者我们可能希望将其转换为完全不同的东西。
- en: You’ve seen several `select` clauses already, and I showed in [Example 10-3](#extracting_just_one_property_in_a_query)
    that the compiler turns them into a call to `Select`. However, as with many LINQ
    operators, the version accessible through a query expression is not the only option.
    There’s one other overload, which provides not just the input item from which
    to generate the output item but also the index of that item. [Example 10-20](#select_operator_with_index)
    uses this to generate a numbered list of course titles.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了几个 `select` 子句，并且我在 [Example 10-3](#extracting_just_one_property_in_a_query)
    中展示了编译器如何将它们转换为对 `Select` 的调用。然而，与许多LINQ操作符一样，通过查询表达式访问的版本并不是唯一的选择。还有另一种重载形式，不仅提供用于生成输出项的输入项，还提供该项的索引。[Example 10-20](#select_operator_with_index)
    使用这一点生成了一个课程标题的编号列表。
- en: Example 10-20\. `Select` operator with index
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-20\. 带有索引的 `Select` 操作符
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Be aware that the zero-based index passed into the lambda will be based on what
    comes into the `Select` operator and will not necessarily represent the item’s
    original position in the underlying data source. This might not produce the results
    you were hoping for in code such as [Example 10-21](#indexed_select_downstream_of_where_opera).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，传入 lambda 表达式的从零开始的索引将基于进入 `Select` 操作符的内容，并且不一定代表底层数据源中项的原始位置。这可能不会产生您在诸如
    [Example 10-21](#indexed_select_downstream_of_where_opera) 中编写的代码中所期望的结果。
- en: Example 10-21\. Indexed `Select` downstream of `Where` operator
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-21\. `Where` 操作符下游的索引化 `Select`
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code will select the courses found at indexes 2, 3, and 5, respectively,
    in the `Course.Catalog` array, because those are the courses whose `Number` property
    satisfies the `Where` expression. However, this query will number the three courses
    as 0, 1, and 2, because the `Select` operator sees only the items the `Where`
    clause let through. As far as it is concerned, there are only three items, because
    the `Select` clause never had access to the original source. If you wanted the
    indexes relative to the original collection, you’d need to extract those upstream
    of the `Where` clause, as [Example 10-22](#indexed_select_upstream_of_where_operato)
    shows.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将选择在`Course.Catalog`数组中分别位于索引2、3和5的课程，因为这些课程的`Number`属性满足`Where`表达式。然而，此查询将会将这三门课程编号为0、1和2，因为`Select`操作符只能看到`Where`子句允许通过的项目。就它而言，只有三个项目，因为`Select`子句从未访问过原始来源。如果您希望相对于原始集合提取索引，您需要在`Where`子句上游进行提取，就像
    [Example 10-22](#indexed_select_upstream_of_where_operato) 中展示的那样。
- en: Example 10-22\. Indexed `Select` upstream of `Where` operator
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-22\. `Where` 操作符上游的索引化 `Select`
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You may be wondering why I’ve used an anonymous type here and not a tuple. I
    could replace `new { course, index }` with just `(course, index)`, and the code
    would work equally well. (It might even be more efficient, because tuples are
    value types, but anonymous types are reference types. Tuples would create less
    work for the GC here.) However, in general, tuples will not always work in LINQ.
    The lightweight tuple syntax was introduced in C# 7.0, so they weren’t around
    when expression trees were added back in C# 3.0\. The expression object model
    has not been updated to support this language feature, so if you try to use a
    tuple with an `IQueryable<T>`-based LINQ provider, you will get compiler error
    CS8143, telling you that `An expression tree may not contain a tuple literal`.^([1](ch10.xhtml#idm45884806145536))
    So I tend to use anonymous types in this chapter because they work with query-based
    providers. But if you’re using a purely local LINQ provider (e.g., Rx or LINQ
    to Objects), feel free to use tuples.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想为什么我在这里使用了匿名类型而不是元组。我可以用`(course, index)`替换`new { course, index }`，代码同样可以工作。
    （甚至可能更有效，因为元组是值类型，而匿名类型是引用类型。元组在这里会给GC带来更少的工作）。然而，一般来说，在LINQ中元组并不总是有效的。轻量级元组语法是在C#
    7.0引入的，因此在C# 3.0引入表达式树时它们并不存在。表达式对象模型尚未更新以支持此语言特性，因此如果您尝试在基于`IQueryable<T>`的LINQ提供程序中使用元组，您将收到编译器错误CS8143，提示`An
    expression tree may not contain a tuple literal`。^([1](ch10.xhtml#idm45884806145536))
    因此，在这一章中我倾向于使用匿名类型，因为它们与基于查询的提供程序兼容。但是，如果您使用的是纯本地LINQ提供程序（例如Rx或LINQ到对象），请随意使用元组。
- en: The indexed `Select` operator is similar to the indexed `Where` operator. So,
    as you would probably expect, not all LINQ providers support it in all scenarios.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 索引化的 `Select` 操作符与索引化的 `Where` 操作符类似。因此，正如您可能期望的那样，并非所有的LINQ提供程序都在所有情况下都支持它。
- en: Data shaping and anonymous types
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据塑形和匿名类型
- en: If you are using a LINQ provider to access a database, the `Select` operator
    can offer an opportunity to reduce the quantity of data you fetch, which could
    reduce the load on your servers. When you use a data access technology such as
    EF Core to execute a query that returns a set of objects representing persistent
    entities, there’s a trade-off between doing too much work up front and having
    to do lots of extra deferred work. Should those frameworks fully populate all
    of the object properties that correspond to columns in various database tables?
    Should they also load related objects? In general, it’s more efficient not to
    fetch data you’re not going to use, and data that is not fetched up front can
    always be loaded later on demand. However, if you try to be too frugal in your
    initial request, you may ultimately end up making a lot of extra requests to fill
    in the gaps, which could outweigh any benefit from avoiding unnecessary work.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 LINQ 提供程序来访问数据库，`Select` 运算符可以提供一个减少获取数据量的机会，这可能会减少服务器的负载。当你使用像 EF Core
    这样的数据访问技术来执行返回表示持久化实体集合的查询时，存在着一种在一开始做过多工作和需要执行大量额外延迟工作之间的权衡。这些框架是否应完全填充与各个数据库表中列对应的对象属性？它们是否还应加载相关对象？通常来说，不获取你不会使用的数据更有效率，而未在一开始获取的数据随时可以后续按需加载。然而，如果你在初始请求中过于节约，最终可能会导致需要大量额外请求来填补空白，这可能会抵消避免不必要工作带来的任何好处。
- en: When it comes to related entities, EF Core allows you to configure which related
    entities should be prefetched and which should be loaded on demand, but for any
    particular entity that gets fetched, all properties relating to columns are typically
    fully populated. This means queries that request whole entities end up fetching
    all the columns for any row that they touch.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到相关实体时，EF Core 允许你配置哪些相关实体应预取，哪些应按需加载，但对于获取的任何特定实体，通常会完全填充与列相关的所有属性。这意味着请求整个实体的查询最终会获取它们所触及的任何行的所有列。
- en: If you needed to use only one or two columns, fetching them all is relatively
    expensive. [Example 10-23](#fetching_more_data_than_is_needed) uses this somewhat
    inefficient approach. It shows a fairly typical EF Core query.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要使用一两列，获取它们所有都是相对昂贵的。[示例 10-23](#fetching_more_data_than_is_needed) 使用了这种效率较低的方法。它展示了一个相当典型的
    EF Core 查询。
- en: Example 10-23\. Fetching more data than is needed
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-23\. 获取比所需更多的数据
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This LINQ provider translates the `where` clause into an efficient SQL equivalent.
    However, the SQL `SELECT` clause retrieves all the columns from the table. Compare
    that with [Example 10-24](#a_select_clause_with_an_anonymous_type). This modifies
    only one part of the query: the LINQ `select` clause now returns an instance of
    an anonymous type that contains only those properties we require. (The loop that
    follows the query can remain the same. It uses `var` for its iteration variable,
    which will work fine with the anonymous type, which provides the three properties
    that loop requires.)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 LINQ 提供程序将 `where` 子句翻译为一个高效的 SQL 等价物。然而，SQL `SELECT` 子句从表中检索所有列。与 [示例 10-24](#a_select_clause_with_an_anonymous_type)
    对比一下。这只修改了查询的一部分：LINQ `select` 子句现在返回一个匿名类型的实例，该实例仅包含我们需要的那些属性。（随后的循环仍然可以保持不变。它使用
    `var` 作为其迭代变量，这对于匿名类型来说可以正常工作，因为匿名类型提供了循环所需的三个属性。）
- en: Example 10-24\. A `select` clause with an anonymous type
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-24\. 匿名类型的 `select` 子句
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The code produces exactly the same results, but it generates a much more compact
    SQL query that requests only the `Name`, `ListPrice`, and `Size` columns. If you’re
    using a table with many columns, this will produce a significantly smaller response
    because it’s no longer dominated by data we don’t need. This reduces the load
    on the network connection to the database server and also results in faster processing
    because the data will take less time to arrive. This technique is called *data
    shaping*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 代码产生了完全相同的结果，但生成了一个更加紧凑的 SQL 查询，仅请求`Name`、`ListPrice` 和 `Size` 列。如果你正在使用具有许多列的表，这将产生一个显著较小的响应，因为它不再被我们不需要的数据所主导。这减少了与数据库服务器的网络连接负载，并且由于数据到达时间更短，还会导致更快的处理。这种技术称为*数据整形*。
- en: This approach will not always be an improvement. For one thing, it means you
    are working directly with data in the database instead of using entity objects.
    This might mean working at a lower level of abstraction than would be possible
    if you use the entity types, which might increase development costs. Also, in
    some environments, database administrators do not allow ad hoc queries, forcing
    you to use stored procedures, in which case you won’t have the flexibility to
    use this technique.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法并不总是一种改进。首先，这意味着你直接在数据库中使用数据，而不是使用实体对象。这可能意味着你在抽象级别上工作的比使用实体类型时更低，这可能会增加开发成本。另外，在某些环境中，数据库管理员不允许使用即席查询，强制你使用存储过程，在这种情况下，你将无法使用这种技术来获得灵活性。
- en: Projecting the results of a query into an anonymous type is not limited to database
    queries, by the way. You are free to do this with any LINQ provider, such as LINQ
    to Objects. It can sometimes be a useful way to get structured information out
    of a query without needing to define a class specially. (As I mentioned in [Chapter 3](ch03.xhtml#ch_types),
    anonymous types can be used outside of LINQ, but this is one of the main scenarios
    for which they were designed. Grouping by composite keys is another, as I’ll describe
    in [“Grouping”](#grouping).)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 将查询结果投影到匿名类型并不限于数据库查询。你可以在任何 LINQ 提供程序（如 LINQ to Objects）中自由使用这个功能。有时这是一种在不需要专门定义类的情况下从查询中获取结构化信息的有用方式。（正如我在
    [第三章](ch03.xhtml#ch_types) 中提到的，匿名类型可以在 LINQ 之外使用，但这是它们设计的主要场景之一。按复合键分组是另一个场景，我将在
    [“分组”](#grouping) 中描述。）
- en: Projection and mapping
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 投影和映射
- en: The `Select` operator is sometimes referred to as *projection*, and it is the
    same operation that many languages call *map*, which provides a slightly different
    way to think about the `Select` operator. So far, I’ve presented `Select` as a
    way to choose what comes out of a query, but you can also look at it as a way
    to apply a transformation to every item in the source. [Example 10-25](#using_select_to_transform_numbers)
    uses `Select` to produce modified versions of a list of numbers. It variously
    doubles the numbers, squares them, and turns them into strings.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`Select` 操作符有时被称为*投影*，它与许多语言称为*映射*的操作相同，提供了一种略有不同的看待 `Select` 操作符的方式。到目前为止，我已经介绍了
    `Select` 作为选择查询结果的一种方式，但你也可以把它看作是将变换应用到源中的每个项的一种方式。[示例 10-25](#using_select_to_transform_numbers)
    使用 `Select` 生成修改后的数字列表。它分别将数字加倍、求平方，并将它们转换为字符串。'
- en: Example 10-25\. Using `Select` to transform numbers
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-25\. 使用 `Select` 转换数字
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: SelectMany
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SelectMany
- en: The `SelectMany` LINQ operator is used in query expressions that have multiple
    `from` clauses. It’s called `SelectMany` because, instead of selecting a single
    output item for each input item, you provide it with a lambda that produces a
    whole collection for each input item. The resulting query produces all of the
    objects from all of these collections, as though all of the collections your lambda
    returns were merged into one. (This won’t remove duplicates. Sequences can contain
    duplicates in LINQ. You can remove them with the `Distinct` operator described
    in [“Set Operations”](#set_operations).) There are a couple of ways of thinking
    about this operator. One is that it provides a means of flattening two levels
    of hierarchy—a collection of collections—into a single level. Another way to look
    at it is as a Cartesian product—that is, a way to produce every possible combination
    from some input sets.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectMany` LINQ 操作符用于具有多个 `from` 子句的查询表达式。它之所以被称为 `SelectMany`，是因为它不是为每个输入项选择单个输出项，而是为每个输入项提供一个生成整个集合的
    lambda 表达式。生成的查询将来自所有这些集合的对象，就好像你的 lambda 返回的所有集合被合并成一个一样。（这不会移除重复项。在 LINQ 中，序列可以包含重复项。你可以使用
    [“集合操作”](#set_operations) 中描述的 `Distinct` 操作符来移除它们。）有几种思考这个操作符的方式。一种是它提供了将两个层次结构（集合的集合）展平为单一级别的方法。另一种看待它的方式是作为笛卡尔积——即从一些输入集合中生成每一种可能的组合的方法。'
- en: '[Example 10-26](#selectmany_query_expression) shows how to use this operator
    in a query expression. This code highlights the Cartesian-product-like behavior.
    It shows every combination of the letters A, B, and C with a single digit from
    1 to 5—that is, A1, B1, C1, A2, B2, C2, etc. (If you’re wondering about the apparent
    incompatibility of the two input sequences, the `select` clause of this query
    relies on the fact that if you use the `+` operator to add a `string` and some
    other type, C# generates code that calls `ToString` on the nonstring operand for
    you.)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10-26](#selectmany_query_expression)展示了如何在查询表达式中使用此运算符。此代码突出显示了类似于笛卡尔积的行为。它显示了字母A、B和C与数字1到5的每个组合，即A1、B1、C1、A2、B2、C2等（如果您对这两个输入序列的表现不兼容感到疑惑，此查询的`select`子句依赖于一个事实，即如果您使用`+`运算符将一个`string`和某种其他类型相加，C#会为您生成调用非string操作数的`ToString`的代码）。'
- en: Example 10-26\. Using `SelectMany` from a query expression
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-26\. 使用查询表达式中的`SelectMany`
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[Example 10-27](#selectmany_operator) shows how to invoke the operator directly.
    This is equivalent to the query expression in [Example 10-26](#selectmany_query_expression).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10-27](#selectmany_operator)展示了如何直接调用运算符。这相当于[示例 10-26](#selectmany_query_expression)中的查询表达式。'
- en: Example 10-27\. `SelectMany` operator
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-27\. `SelectMany`运算符
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[Example 10-26](#selectmany_query_expression) uses two fixed collections—the
    second `from` clause returns the same `letters` collection every time. However,
    you can make the expression in the second `from` clause return a value based on
    the current item from the first `from` clause. You can see in [Example 10-27](#selectmany_operator)
    that the first lambda passed to `SelectMany` (which actually corresponds to the
    second `from` clause’s final expression) receives the current item from the first
    collection through its `number` argument, so you can use that to choose a different
    collection for each item from the first collection. I can use this to exploit
    `SelectMany`’s flattening behavior.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10-26](#selectmany_query_expression)使用了两个固定集合——第二个`from`子句每次返回相同的`letters`集合。然而，您可以使第二个`from`子句中的表达式基于第一个`from`子句的当前项返回一个值。您可以在[示例 10-27](#selectmany_operator)中看到，`SelectMany`的第一个Lambda表达式（实际上对应第二个`from`子句的最终表达式）通过其`number`参数接收第一个集合的当前项，因此您可以用它来选择每个第一个集合项的不同集合。我可以利用这一点来利用`SelectMany`的展平行为。'
- en: I’ve copied a jagged array from [Example 5-16](ch05.xhtml#creating_a_jagged_array)
    in [Chapter 5](ch05.xhtml#ch_collections) into [Example 10-28](#flattening_a_jagged_array),
    which then processes it with a query containing two `from` clauses. Note that
    the expression in the second `from` clause is now `row`, the range variable of
    the first `from` clause.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经从[示例 5-16](ch05.xhtml#creating_a_jagged_array)在[第 5 章](ch05.xhtml#ch_collections)中复制了一个嵌套数组到[示例 10-28](#flattening_a_jagged_array)，然后使用包含两个`from`子句的查询处理它。请注意，第二个`from`子句中的表达式现在是`row`，即第一个`from`子句的范围变量。
- en: Example 10-28\. Flattening a jagged array
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-28\. 展平嵌套数组
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first `from` clause asks to iterate over each item in the top-level array.
    Each of these items is also an array, and the second `from` clause asks to iterate
    over each of these nested arrays. This nested array’s type is `int[]`, so the
    range variable of the second `from` clause, `number`, represents an `int` from
    that nested array. The `select` clause just returns each of these `int` values.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`from`子句要求迭代顶层数组中的每个项。这些项中的每一个也是一个数组，第二个`from`子句要求迭代每个嵌套数组。这个嵌套数组的类型是`int[]`，因此第二个`from`子句的范围变量`number`表示来自该嵌套数组的一个`int`。`select`子句只是返回每个这些`int`值。
- en: The resulting sequence provides every number in the arrays in turn. It has flattened
    the jagged array into a simple linear sequence of numbers. This behavior is conceptually
    similar to writing a nested pair of loops, one iterating over the outer `int[][]`
    array, and an inner loop iterating over the contents of each individual `int[]`
    array.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 结果序列依次提供数组中的每个数字。它将嵌套数组展平为简单的线性数字序列。这种行为在概念上类似于编写一个嵌套的循环对，一个循环遍历外部`int[][]`数组，另一个内部循环遍历每个单独的`int[]`数组的内容。
- en: The compiler uses the same overload of `SelectMany` for [Example 10-28](#flattening_a_jagged_array)
    as it does for [Example 10-27](#selectmany_operator), but there’s an alternative
    in this case. The final `select` clause is simpler in [Example 10-28](#flattening_a_jagged_array)—it
    just passes on items from the second collection unmodified, which means the simpler
    overload shown in [Example 10-29](#selectmany_without_item_projection) does the
    job equally well. With this overload, we just provide a single lambda, which chooses
    the collection that `SelectMany` will expand for each of the items in the input
    collection.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器对于 [示例 10-28](#flattening_a_jagged_array) 和 [示例 10-27](#selectmany_operator)
    使用相同的 `SelectMany` 重载，但在这种情况下存在另一种选择。在 [示例 10-28](#flattening_a_jagged_array)
    中，最终的 `select` 子句更简单—它仅传递来自第二个集合的项目，这意味着 [示例 10-29](#selectmany_without_item_projection)
    中显示的更简单的重载同样能胜任。使用这种重载，我们只需提供一个 lambda，它选择 `SelectMany` 将为输入集合中的每个项目扩展的集合。
- en: Example 10-29\. `SelectMany` without item projection
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-29\. 没有项目投影的 `SelectMany`
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: That’s a somewhat terse bit of code, so in case it’s not clear quite how that
    could end up flattening the array, [Example 10-30](#one_implementation_of_selectmany)
    shows how you might implement `SelectMany` for `IEnumerable<T>` if you had to
    write it yourself.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段略显简洁的代码，因此如果不太清楚它如何最终展平数组，[示例 10-30](#one_implementation_of_selectmany)
    展示了如果必须自己编写的话，您可能如何为 `IEnumerable<T>` 实现 `SelectMany`。
- en: Example 10-30\. One implementation of `SelectMany`
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-30\. `SelectMany` 的一个实现
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Why does the compiler not use the simpler option shown in [Example 10-29](#selectmany_without_item_projection)?
    The C# language specification defines how query expressions are translated into
    method calls, and it mentions only the overload shown in [Example 10-26](#selectmany_query_expression).
    Perhaps the reason the specification doesn’t mention the simpler overload is to
    reduce the demands C# makes of types that want to support this double-`from` query
    form—you’d need to write only one method to enable this syntax for your own types.
    However, .NET’s various LINQ providers are more generous, providing this simpler
    overload for the benefit of developers who choose to use the operators directly.
    In fact, some providers define two more overloads: there are versions of both
    the `SelectMany` forms we’ve seen so far that also pass an item index to the first
    lambda. (The usual caveats about indexed operators apply, of course.)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器为什么不使用在 [示例 10-29](#selectmany_without_item_projection) 中展示的更简单的选项？C# 语言规范定义了查询表达式如何转换为方法调用，并且仅提到了
    [示例 10-26](#selectmany_query_expression) 中显示的重载。也许规范之所以没有提及更简单的重载，是为了减少 C# 对想要支持这种双
    `from` 查询形式的类型的要求—您只需编写一个方法即可启用此语法。然而，.NET 的各种 LINQ 提供程序更为慷慨，为选择直接使用运算符的开发人员提供了这种更简单的重载。事实上，一些提供程序定义了另外两个重载版本：迄今为止我们看到的
    `SelectMany` 的这两种形式也会将项目索引传递给第一个 lambda。当然，对于索引运算符，通常的警告仍然适用。
- en: Although [Example 10-30](#one_implementation_of_selectmany) gives a reasonable
    idea of what LINQ to Objects does in `SelectMany`, it’s not the exact implementation.
    There are optimizations for special cases. Moreover, other providers may use very
    different strategies. Databases often have built-in support for Cartesian products,
    so some providers may implement `SelectMany` in terms of that.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 [示例 10-30](#one_implementation_of_selectmany) 给出了 LINQ to Objects 在 `SelectMany`
    中的一个合理想法，但这并不是确切的实现。对于特殊情况，存在优化。此外，其他提供程序可能使用非常不同的策略。数据库通常内置支持笛卡尔积，因此某些提供程序可能会基于此实现
    `SelectMany`。
- en: Chunking
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Chunking
- en: Whereas `SelectMany` flattens multiple sequences into one, LINQ’s `Chunk` operator
    (added in .NET 6.0) works in the opposite direction, turning a single sequence
    into a series of fixed-size sequences. This can be useful in cases where it’s
    more efficient to process multiple items in a batch than handling them one at
    a time. That’s often true when I/O is involved—there are fixed minimum costs for
    writing data to disk or sending it over the network, which can often mean that
    the cost of writing or sending a single record is only slightly smaller than a
    single operation that writes or sends 10 records.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 而 `SelectMany` 将多个序列展平为一个，LINQ 的 `Chunk` 操作符（在 .NET 6.0 中添加）则朝相反方向工作，将单个序列转换为一系列固定大小的序列。在涉及到
    I/O 的情况下，这可能更有效，因为写入数据到磁盘或通过网络发送数据通常具有固定的最低成本，这往往意味着写入或发送单个记录的成本仅比写入或发送 10 条记录稍微低一点。
- en: '[Example 10-31](#chunking_numbers) uses the `Range` method (described later
    in [“Sequence Generation”](#sequence_generation)) to create a sequence of numbers
    from 1 to 50, and then asks `Chunk` to split these into chunks of 15 numbers each.
    While `Range` produced an `IEnumerable<int>`—a sequence of `int` values—`Chunk`
    returns a sequence of *arrays* of type `int[]`.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10-31](#chunking_numbers) 使用 `Range` 方法（稍后在 [“序列生成”](#sequence_generation)
    中描述）创建了一个从 1 到 50 的数字序列，然后要求 `Chunk` 将其分成每个包含 15 个数字的块。虽然 `Range` 生成了一个 `IEnumerable<int>`—一系列
    `int` 值—`Chunk` 返回了一个 *数组* 序列，类型为 `int[]`。'
- en: Example 10-31\. Splitting a sequence into batches with `Chunk`
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-31\. 使用 `Chunk` 将序列分成批次
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Looking at the output of [Example 10-31](#chunking_numbers), we can see that
    `Chunk` hands us all of the numbers in order, just split into chunks:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [示例 10-31](#chunking_numbers) 的输出，我们可以看到 `Chunk` 将所有数字按顺序分割成了块：
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this example, the source sequence wasn’t an exact multiple of the chunk size.
    `Chunk` dealt with this by making the final chunk smaller.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，源序列的长度不是块大小的精确倍数。`Chunk` 通过使最后一个块更小来处理这个问题。
- en: Note
  id: totrans-183
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Some LINQ providers use a different name for this operator: `Buffer`. The Rx
    library described in [Chapter 11](ch11.xhtml#ch_reactive_extensions) chose that
    name when it introduced an operator of this kind about 10 years earlier. .NET
    6.0 has chosen the name `Chunk` instead, but libraries that were written before
    this typically followed Rx’s lead, calling their version of this operator `Buffer`.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 LINQ 提供程序使用不同的名称来表示此操作符：`Buffer`。在约10年前，Rx 库在介绍这种类型的操作符时选择了这个名称。.NET 6.0
    选择了 `Chunk` 这个名称，但在此之前编写的库通常遵循了 Rx 的先例，将其版本的这个操作符称为 `Buffer`。
- en: Ordering
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序
- en: In general, LINQ queries do not guarantee to produce items in any particular
    order unless you explicitly define the order you require. You can do this in a
    query expression with an `orderby` clause. As [Example 10-32](#query_expression_with_orderby_clause)
    shows, you specify the expression that defines how to order the items and a direction—so
    this will produce a collection of courses ordered by ascending publication date.
    As it happens, `ascending` is the default, so you can leave off that qualifier
    without changing the meaning. As you’ve probably guessed, you can specify `descending`
    to reverse the order.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，LINQ 查询不保证按任何特定顺序生成项目，除非您明确定义所需的顺序。您可以在查询表达式中使用 `orderby` 子句来实现这一点。正如 [示例 10-32](#query_expression_with_orderby_clause)
    所示，您可以指定定义项目顺序及其方向的表达式—因此，这将生成按发布日期升序排列的课程集合。恰巧的是，默认情况下是 `ascending`，因此您可以省略该限定词而不改变含义。正如您可能已经猜到的那样，您可以指定
    `descending` 来反转顺序。
- en: Example 10-32\. Query expression with `orderby` clause
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-32\. 带有 `orderby` 子句的查询表达式
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The compiler transforms the `orderby` clause in [Example 10-32](#query_expression_with_orderby_clause)
    into a call to the `OrderBy` method, and it would use `OrderByDescending` if you
    had specified a `descending` sort order. With source types that make a distinction
    between ordered and unordered collections, these operators return the ordered
    type (for example, `IOrderedEnumerable<T>` for LINQ to Objects, and `IOrderedQueryable<T>`
    for `IQueryable<T>`-based providers).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将 [示例 10-32](#query_expression_with_orderby_clause) 中的 `orderby` 子句转换为对 `OrderBy`
    方法的调用，如果指定了 `descending` 排序顺序，它将使用 `OrderByDescending`。对于那些区分有序和无序集合的源类型，这些操作符返回有序类型（例如，LINQ
    to Objects 返回 `IOrderedEnumerable<T>`，而基于 `IQueryable<T>` 的提供程序返回 `IOrderedQueryable<T>`）。
- en: Warning
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: With LINQ to Objects, these operators have to retrieve every element from their
    input before they can produce any output elements. An ascending `OrderBy` can
    determine which item to return first only once it has found the lowest item, and
    it won’t know for certain which is the lowest until it has seen all of them. It
    still uses deferred evaluation—it won’t do anything until you ask it for the first
    item. But as soon as you do ask it for something, it has to do all the work at
    once. Some providers will have additional knowledge about the data that can enable
    more efficient strategies. (For example, a database may be able to use an index
    to return values in the order required.)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 LINQ to Objects，这些操作符必须从输入中检索每个元素，然后才能生成任何输出元素。升序的 `OrderBy` 只有在找到最低项之后才能确定要返回哪个项，并且直到看到所有项之后才能确定最低项。它仍然使用延迟评估—直到您请求第一个项目时才会执行任何操作。但是一旦您请求了某些内容，它必须立即完成所有工作。某些提供程序可能对数据具有额外的知识，从而能够实现更有效的策略（例如，数据库可以使用索引按照所需的顺序返回值）。
- en: LINQ to Objects’ `OrderBy` and `OrderByDescending` operators each have two overloads,
    only one of which is available from a query expression. If you invoke the methods
    directly, you can supply an additional parameter of type `IComparer<TKey>`, where
    `TKey` is the type of the expression by which the items are being sorted. This
    is likely to be important if you sort based on a `string` property, because there
    are several different orderings for text, and you may need to choose one based
    on your application’s locale, or you may want to specify a culture-invariant ordering
    to ensure consistency across all environments.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ to Objects的`OrderBy`和`OrderByDescending`运算符各有两个重载，其中只有一个可以从查询表达式中使用。如果直接调用这些方法，您可以提供一个额外的`IComparer<TKey>`类型的参数，其中`TKey`是正在排序的表达式的类型。如果您基于`string`属性进行排序，这可能很重要，因为文本有几种不同的排序方式，您可能需要根据应用程序的区域设置选择其中一种，或者您可能希望指定一个与文化无关的排序方式，以确保在所有环境中保持一致性。
- en: The expression that determines the order in [Example 10-32](#query_expression_with_orderby_clause)
    is very simple—it just retrieves the `PublicationDate` property from the source
    item. You can write more complex expressions if you want to. If you’re using a
    provider that translates a LINQ query into something else, there may be limitations.
    If the query runs on the database, you may be able to refer to other tables—the
    provider might be able to convert an expression such as `product.ProductCategory.Name`
    into a suitable join. However, you will not be able to run any old code in that
    expression, because it must be something that the database can execute. But LINQ
    to Objects just invokes the expression once for each object, so you really can
    put in there whatever code you like.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10-32](#query_expression_with_orderby_clause)中确定顺序的表达式非常简单—它只是从源项目中检索`PublicationDate`属性。如果您愿意，可以编写更复杂的表达式。如果您使用将LINQ查询转换为其他内容的提供程序，可能会有一些限制。如果查询在数据库上运行，您可能可以引用其他表—提供程序可能能够将诸如`product.ProductCategory.Name`之类的表达式转换为适当的连接。但是，您无法在该表达式中运行任何旧代码，因为它必须是数据库可以执行的内容。但是，LINQ
    to Objects只是为每个对象调用一次表达式，因此您确实可以在其中放入任何代码。'
- en: You may want to sort by multiple criteria. You should *not* do this by writing
    multiple `orderby` clauses. [Example 10-33](#how_not_to_apply_multiple_ordering_crite)
    makes this mistake.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望按多个标准进行排序。您*不应该*通过编写多个`orderby`子句来实现这一点。[示例 10-33](#how_not_to_apply_multiple_ordering_crite)犯了这个错误。
- en: Example 10-33\. How not to apply multiple ordering criteria
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-33\. 如何不应用多个排序标准
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This code orders the items by publication date and then by duration but does
    so as two separate and unrelated steps. The second `orderby` clause guarantees
    only that the results will be in the order specified in that clause and does not
    guarantee to preserve anything about the order in which the elements originated.
    If what you actually wanted was for the items to be in order of publication date,
    and for any items with the same publication date to be ordered by descending duration,
    you would need to write the query in [Example 10-34](#multiple_ordering_criteria_query_expr).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码按发布日期和持续时间对项目进行排序，但是将其作为两个独立且不相关的步骤进行。第二个`orderby`子句仅保证结果将按照该子句中指定的顺序排列，并不保证保留有关元素原始顺序的任何信息。如果您实际上想要项目按发布日期顺序排列，并且具有相同发布日期的项目按持续时间降序排列，您需要编写[示例 10-34](#multiple_ordering_criteria_query_expr)中的查询。
- en: Example 10-34\. Multiple ordering criteria in a query expression
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-34\. 查询表达式中的多个排序标准
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'LINQ defines separate operators for this multilevel ordering: `ThenBy` and
    `The⁠nBy​Des⁠cen⁠ding`. [Example 10-35](#multiple_ordering_criteria_linq_ops)
    shows how to achieve the same effect as the query expression in [Example 10-34](#multiple_ordering_criteria_query_expr)
    by invoking the LINQ operators directly. For LINQ providers whose types make a
    distinction between ordered and unordered collections, the `ThenBy` and `ThenByDescending`
    operators will be available only on the ordered form, such as `IOrderedQueryable<T>`
    or `IOrderedEnumerable<T>`. If you were to try to invoke `ThenBy` directly on
    `Course.Catalog`, the compiler would report an error.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ为这种多级排序定义了单独的运算符：`ThenBy`和`The⁠nBy​Des⁠cen⁠ding`。[示例 10-35](#multiple_ordering_criteria_linq_ops)展示了如何通过直接调用LINQ运算符来实现与[示例 10-34](#multiple_ordering_criteria_query_expr)中查询表达式相同的效果。对于那些类型区分有序和无序集合的LINQ提供程序，`ThenBy`和`ThenByDescending`运算符仅在有序形式上可用，例如`IOrderedQueryable<T>`或`IOrderedEnumerable<T>`。如果您尝试直接在`Course.Catalog`上调用`ThenBy`，编译器将报告错误。
- en: Example 10-35\. Multiple ordering criteria with LINQ operators
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-35\. 使用 LINQ 操作符进行多重排序标准
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You will find that some LINQ operators preserve some aspects of ordering even
    if you do not ask them to. For example, LINQ to Objects will typically produce
    items in the same order in which they appeared in the input unless you write a
    query that causes it to change the order. But this is simply an artifact of how
    LINQ to Objects works, and you should not rely on it in general. In fact, even
    when you are using that particular LINQ provider, you should check with the documentation
    to see whether the order you’re getting is guaranteed or is just an accident of
    implementation. In most cases, if you care about the order, you should write a
    query that makes that explicit.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现，即使您没有要求，一些 LINQ 操作符也会保留某些排序方面。例如，LINQ to Objects 通常会按照它们在输入中出现的顺序生成项目，除非您编写了一个引起顺序改变的查询。但这只是
    LINQ to Objects 工作方式的副产品，您不应该普遍依赖它。事实上，即使在使用该特定 LINQ 提供程序时，您也应该查看文档，以了解您得到的顺序是有保证的还是仅仅是实现的偶然。在大多数情况下，如果您关心顺序，应该编写一个明确表达这一点的查询。
- en: Containment Tests
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包含性测试
- en: LINQ defines various standard operators for discovering things about what the
    collection contains. Some providers may be able to implement these operators without
    needing to inspect every item. (For example, a database-based provider might use
    a `WHERE` clause, and the database could be able to use an index to evaluate that
    without needing to look at every element.) However, there are no restrictions—you
    can use these operators however you like, and it’s up to the provider to discover
    whether it can exploit a shortcut.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 定义了各种用于发现集合内容的标准操作符。一些提供程序可能能够实现这些操作符而无需检查每个项目。（例如，基于数据库的提供程序可能使用 `WHERE`
    子句，数据库可以使用索引来评估，而无需查看每个元素。）但没有限制 - 您可以按自己的喜好使用这些操作符，以及提供程序发现是否可以利用快捷方式。
- en: Note
  id: totrans-206
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Unlike most LINQ operators, in the majority of providers these return neither
    a collection nor an item from their input. They generally just return `true` or
    `false`, or in some cases, a count. Rx is a notable exception: its implementations
    of these operators wrap the `bool` or `int` in a single-element `IObservable<T>`
    that produces the result. It does this to preserve the reactive nature of processing
    in Rx.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 不同于大多数 LINQ 操作符，在大多数提供程序中，它们既不返回集合也不返回输入中的项目。它们通常只返回 `true` 或 `false`，或者在某些情况下返回一个计数。Rx
    是一个显著的例外：它这些操作符的实现将 `bool` 或 `int` 包装在产生结果的单元素 `IObservable<T>` 中。它这样做是为了保持 Rx
    中处理的响应式特性。
- en: The simplest operator is `Contains`. You pass an item, and some providers (including
    LINQ to Objects) provide an overload that also takes an `IEqualityComparer<T>`
    so that you can customize how the operator determines whether an item in the source
    is the same as the specified item. `Contains` returns `true` if the source contains
    the specified item and `false` if it does not. If you use the single-argument
    version with a collection that implements `ICollection<T>` (which includes all
    `IList<T>` and `ISet<T>` implementations), LINQ to Objects will detect that, and
    its implementation of `Contains` just defers to the collection. If you use a non-`ICollection<T>`
    collection, or you provide a custom equality comparer, it will have to examine
    every item in the collection.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的操作符是 `Contains`。您传递一个项目，一些提供程序（包括 LINQ to Objects）提供了一个重载，还接受一个 `IEqualityComparer<T>`，以便您可以自定义操作符如何确定源中的项目与指定项目是否相同。`Contains`
    如果源包含指定的项目则返回 `true`，如果不包含则返回 `false`。如果您使用具有 `ICollection<T>` 实现的集合的单参数版本（其中包括所有
    `IList<T>` 和 `ISet<T>` 实现），LINQ to Objects 将检测到这一点，并且其 `Contains` 的实现只是将其延迟到集合。如果您使用非
    `ICollection<T>` 集合，或者提供自定义的相等性比较器，它将不得不检查集合中的每个项目。
- en: If, instead of looking for a particular value, you want to know whether a collection
    contains any values that satisfy some particular criteria, you can use the `Any`
    operator. This takes a predicate, and it returns `true` if the predicate is true
    for at least one item in the source. If you want to know how many items match
    some criteria, you can use the `Count` operator. This also takes a predicate,
    and instead of returning a `bool`, it returns an `int`. If you are working with
    very large collections, the range of `int` may be insufficient, in which case
    you can use the `LongCount` operator, which returns a 64-bit count. (This is likely
    to be overkill for most LINQ to Objects applications, but it could matter when
    the collection lives in a database.)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不是在寻找特定的值，而是想知道一个集合是否包含任何满足某些特定条件的值，你可以使用`Any`运算符。它接受一个谓词，并且在源中至少有一个项满足谓词时返回`true`。如果你想知道有多少项满足某些条件，你可以使用`Count`运算符。它也接受一个谓词，而不是返回`bool`，而是返回一个`int`。如果你正在处理非常大的集合，`int`的范围可能不够，这时你可以使用`LongCount`运算符，它返回一个64位的计数。（在大多数LINQ
    to Objects应用程序中，这可能过于复杂，但在集合存在于数据库中时可能很重要。）
- en: The `Any`, `Count`, and `LongCount` operators have overloads that do not take
    any arguments. For `Any`, this tells you whether the source contains at least
    one element, and for `Count` and `LongCount`, these overloads tell you how many
    elements the source contains.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`Any`、`Count`和`LongCount`运算符有些重载不接受任何参数。对于`Any`来说，这告诉你源序列是否至少包含一个元素，而对于`Count`和`LongCount`，这些重载告诉你源序列包含多少元素。'
- en: You should be wary of code such as `if (q.Count() > 0)`. Calculating the exact
    count may require the entire source query (`q` in this case) to be evaluated,
    and in any case, it is likely to require more work than simply answering the question,
    *Is this empty?* If `q` refers to a LINQ query, writing `if (q.Any())` is likely
    to be more efficient. That said, outside of LINQ, this is not the case for list-like
    collections, where retrieving an element count is cheap and may actually be more
    efficient than the `Any` operator.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该警惕像`if (q.Count() > 0)`这样的代码。计算确切的计数可能需要评估整个源查询（在这种情况下是`q`），而且通常比简单地回答“它是空的吗？”更耗费功夫。如果`q`是LINQ查询，写成`if
    (q.Any())`可能更有效率。话虽如此，在LINQ之外，对于类似列表的集合来说，并不是这样，那里获取元素计数是廉价的，而且实际上可能比`Any`运算符更有效率。
- en: There are some situations in which you might want to use a count only if one
    can be calculated efficiently. (For example, a user interface might want to show
    the total number of items available if this is easy to determine, but could easily
    choose not to show it for cases where that would be too expensive.) For these
    scenarios, .NET 6.0 added a new `TryGetNonEnumeratedCount` method. This will return
    `true` if the count can be determined without having to iterate through the whole
    collection, and `false` if not. When it returns `true`, it passes the count back
    through its single argument of type `out int`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，你可能只希望在能够高效计算时才使用计数。（例如，用户界面可能希望在可以轻松确定的情况下显示可用项的总数，但在计算成本太高时可能选择不显示。）对于这些情况，.NET
    6.0添加了一个新的`TryGetNonEnumeratedCount`方法。它将在可以在不必迭代整个集合的情况下确定计数时返回`true`，否则返回`false`。当它返回`true`时，通过`out
    int`类型的单个参数将计数传递回去。
- en: 'A close relative to the `Any` operator is the `All` operator. This one is not
    overloaded—it takes a predicate, and it returns `true` if and only if the source
    contains no items that do not match the predicate. I used an awkward double negative
    in the preceding sentence for a reason: `All` returns `true` when applied to an
    empty sequence, because an empty sequence certainly doesn’t contain any elements
    that fail to match the predicate for the simple reason that it doesn’t contain
    any elements at all.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Any`运算符密切相关的是`All`运算符。这个运算符没有重载——它接受一个谓词，并且仅当源序列不包含任何不匹配谓词的项时返回`true`。在上述句子中我使用了尴尬的双重否定是有原因的：`All`应用于空序列时返回`true`，因为空序列显然不包含任何元素无法匹配谓词，简单来说，它根本没有任何元素。
- en: 'This may seem like a curiously pig-headed form of logic. It’s reminiscent of
    the child who, when asked, “Have you eaten your vegetables?” unhelpfully replies,
    “I ate all the vegetables I put on my plate,” neglecting to mention that he didn’t
    put any vegetables on his plate in the first place. It’s not technically untrue,
    but it fails to provide the information the parent was looking for. Nonetheless,
    the operators work this way for a reason: they correspond to some standard mathematical
    logical operators. `Any` is the *existential quantifier*, usually written as a
    backward E (∃) and pronounced “there exists,” and `All` is the *universal quantifier*,
    usually written as an upside-down A (∀) and pronounced “for all.” Mathematicians
    long ago agreed on a convention for statements that apply the universal quantifier
    to an empty set. For example, defining 𝕍 as the set of all vegetables, I can assert
    that ∀{v : (v ∈ 𝕍) ∧ putOnPlateByMe(v)} eatenByMe(v), or, in English, “For each
    vegetable that I put on my plate, it is true to say that I ate that vegetable.”
    This statement is deemed to be true if the set of vegetables I put on my plate
    is empty. (Perhaps mathematicians don’t like vegetables either.) Rather pleasingly,
    the proper term for such a statement is a *vacuous truth*.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '这可能看起来像一种顽固的逻辑形式。这让人想起了一个孩子的情形，当问到“你吃了你的蔬菜吗？”时，他无助地回答道：“我吃了我放在盘子上的所有蔬菜”，却忽略了他根本没把任何蔬菜放在盘子上这一事实。从技术上讲，这并不是不真实的，但它未能提供父母寻找的信息。尽管如此，这些运算符之所以工作如此，是有其原因的：它们对应一些标准的数学逻辑运算符。`Any`是*存在量词*，通常写作倒立的E
    (∃)，读作“存在”，而`All`是*全称量词*，通常写作倒置的A (∀)，读作“对于所有”。数学家们很久以前就对适用于空集的全称量词陈述达成了一致的约定。例如，定义𝕍为所有蔬菜的集合，我可以断言
    ∀{v : (v ∈ 𝕍) ∧ putOnPlateByMe(v)} eatenByMe(v)，或者用英语说，“对于我放在盘子上的每一个蔬菜，我吃了那个蔬菜。”
    如果我放在盘子上的蔬菜集合是空的，这个陈述被认为是真实的。（也许数学家也不喜欢蔬菜。）令人愉悦的是，这种陈述的正式术语是*空真*。'
- en: Specific Items and Subranges
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特定项目和子范围
- en: It can be useful to write a query that produces just a single item. Perhaps
    you’re looking for the first object in a list that meets certain criteria, or
    maybe you want to fetch information in a database identified by a particular key.
    LINQ defines several operators that can do this and some related ones for working
    with a subrange of the items a query might return.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 编写仅产生单个项目的查询可能很有用。也许你正在寻找满足某些条件的列表中的第一个对象，或者你想通过特定键标识的数据库获取信息。LINQ定义了几个可以实现此目的的运算符，以及一些处理查询可能返回的子范围的相关运算符。
- en: Use the `Single` operator when you have a query that you believe should produce
    exactly one result. [Example 10-36](#appling_the_single_operator_to_a_query) shows
    just such a query—it looks up a course by its category and number, and in my sample
    data, this uniquely identifies a course.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Single`运算符时，你认为应该只生成一个结果的查询。[示例 10-36](#appling_the_single_operator_to_a_query)展示了这样的一个查询—它通过类别和编号查找课程，在我的样本数据中，这唯一确定了一个课程。
- en: Example 10-36\. Applying the `Single` operator to a query
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-36\. 将`Single`运算符应用于查询
- en: '[PRE37]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Because LINQ queries are built by chaining operators together, we can take the
    query built by the query expression and add on another operator—the `Single` operator,
    in this case. While most operators would return an object representing another
    query (an `IEnumerable<T>` here, since we’re using LINQ to Objects), `Single`
    is different. Like `ToArray` and `ToList`, the `Single` operator evaluates the
    query immediately, but it then returns the one and only object that the query
    produced. If the query fails to produce exactly one object—perhaps it produces
    no items, or two—this will throw an `InvalidOperationException`. (Since this is
    another of the operators that produces a result immediately, some providers offer
    `SingleAsync` as described in the sidebar [“Asynchronous Immediate Evaluation”](#immediate_evaluation_and_async).)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 因为LINQ查询是通过链接操作符构建的，我们可以取出由查询表达式构建的查询，然后添加另一个运算符—在这种情况下是`Single`运算符。虽然大多数运算符会返回代表另一个查询的对象（这里是`IEnumerable<T>`，因为我们使用LINQ来处理对象），但`Single`不同。像`ToArray`和`ToList`一样，`Single`运算符立即评估查询，然后返回查询产生的唯一对象。如果查询未能产生正好一个对象—可能没有生成任何项，或者生成了两个—这将引发`InvalidOperationException`。（由于这是另一个立即产生结果的运算符，一些提供程序提供了`SingleAsync`，如侧边栏[“即时评估和异步”](#immediate_evaluation_and_async)中所述。）
- en: There’s an overload of the `Single` operator that takes a predicate. As [Example 10-37](#single_operator_with_predicate)
    shows, this allows us to express the same logic as the whole of [Example 10-36](#appling_the_single_operator_to_a_query)
    more compactly. (As with the `Where` operator, all the predicate-based operators
    in this section use `Func<T, bool>`, not `Predicate<T>`.)
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`Single` 操作符还有一个带有谓词的重载。正如 [示例 10-37](#single_operator_with_predicate) 所示，这使我们能够更紧凑地表达与
    [示例 10-36](#applying_the_single_operator_to_a_query) 整体相同的逻辑。（与 `Where` 操作符一样，本节中所有基于谓词的操作符都使用
    `Func<T, bool>`，而不是 `Predicate<T>`。）'
- en: Example 10-37\. The `Single` operator with predicate
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-37\. 带有谓词的 `Single` 操作符
- en: '[PRE38]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `Single` operator is unforgiving: if your query does not return exactly
    one item, it will throw an exception. There’s a slightly more flexible variant
    called `Sin⁠gle⁠Or​Def⁠ault`, which allows a query to return either one item or
    no items. If the query returns nothing, this method returns the default value
    for the item type (i.e., `null` if it’s a reference type, `0` if it’s a numeric
    type, etc.). Multiple matches still cause an exception. As with `Single`, there
    are two overloads: one with no arguments for use on a source that you believe
    contains no more than one object, and one that takes a predicate lambda.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`Single` 操作符是严格的：如果你的查询没有精确返回一个项，它会抛出异常。还有一个略微更灵活的变体叫做 `SingleOrDefault`，允许查询返回一个或零个项。如果查询没有结果，这个方法会返回该项类型的默认值（比如引用类型返回
    `null`，数值类型返回 `0` 等）。多个匹配项仍会引发异常。和 `Single` 一样，它们有两个重载：一个不带参数，用于你认为源中不会有多个对象的情况；另一个带有谓词
    lambda。'
- en: 'LINQ defines two related operators, `First` and `FirstOrDefault`, each of which
    offers overloads taking no arguments or a predicate. For sequences containing
    zero or one matching items, these behave in exactly the same way as `Single` and
    `Sin⁠gle⁠Or​Def⁠ault`: they return the item if there is one; if there isn’t, `First`
    will throw an exception, while `FirstOrDefault` will return `null` or an equivalent
    value. However, these operators respond differently when there are multiple results—instead
    of throwing an exception, they just pick the first result and return that, discarding
    the rest. This might be useful if you want to find the most expensive item in
    a list—you could order a query by descending price and then pick the first result.
    [Example 10-38](#using_first_to_select_the_longest_course) uses a similar technique
    to pick the longest course from my sample data.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 定义了两个相关的操作符 `First` 和 `FirstOrDefault`，它们分别提供了不带参数或带有谓词的重载。对于包含零个或一个匹配项的序列，它们的行为与
    `Single` 和 `SingleOrDefault` 完全相同：如果存在一个项，则返回该项；如果没有，`First` 会抛出异常，而 `FirstOrDefault`
    会返回 `null` 或等效值。然而，当存在多个结果时，这些操作符的响应不同——它们会选择第一个结果并返回，忽略其余结果。如果你想从列表中找出最昂贵的物品，这可能会很有用——你可以按价格降序排序查询，然后选择第一个结果。[示例
    10-38](#using_first_to_select_the_longest_course) 使用了类似的技术来从我的示例数据中选择最长的课程。
- en: Example 10-38\. Using `First` to select the longest course
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-38\. 使用 `First` 选择最长的课程
- en: '[PRE39]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If you have a query that doesn’t guarantee any particular order for its results,
    these operators will pick one item arbitrarily.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的查询结果没有特定的顺序保证，这些操作符会任意选择一个项。
- en: Tip
  id: totrans-229
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Do not use `First` or `FirstOrDefault` unless you expect there to be multiple
    matches and you want to process only one of them. Some developers use these when
    they expect only a single match. The operators will work, of course, but the `Single`
    and `Sin⁠gle⁠Or​Def⁠ault` operators more accurately express your expectations.
    They will let you know when your expectations were misplaced, throwing an exception
    when there are multiple matches. If your code embodies incorrect assumptions,
    it’s usually best to know about it instead of plowing on regardless.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用 `First` 或 `FirstOrDefault`，除非你期望有多个匹配项并且只想处理其中一个。有些开发者在期望只有一个匹配项时也使用这些操作符。当然，这些操作符可以工作，但
    `Single` 和 `SingleOrDefault` 操作符更准确地表达了你的期望。它们会在有多个匹配项时抛出异常，让你知道你的期望是错误的。如果你的代码存在错误的假设，通常最好是知道而不是无视它们继续执行。
- en: 'The existence of `First` and `FirstOrDefault` raises an obvious question: Can
    I pick the last item? The answer is yes; there are also `Last` and `LastOrDefault`
    operators, and again, each offers two overloads—one taking no arguments and one
    taking a predicate.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`First` 和 `FirstOrDefault` 的存在引出了一个明显的问题：我能选出最后一项吗？答案是肯定的；还有 `Last` 和 `LastOrDefault`
    操作符，同样，每个都提供两个重载——一个不带参数，一个带有谓词。'
- en: .NET 6.0 adds a refinement to `SingleOrDefault`, `FirstOrDefault`, and `Las⁠tOr​Def⁠ault`.
    These get new overloads enabling you to supply a value to return as the default,
    instead of the usual zero-like value. This could be useful if you have a collection
    of `int` elements in which zero is a valid value. [Example 10-39](#single_or_default_explicit_default)
    shows how to use the new `SingleOrDefault` overload to get a value of −1 when
    the list is empty. This makes it possible to distinguish between an empty list
    and a list containing a single zero value. Of course, if all possible values for
    `int` are valid in your application, this doesn’t help you, and you’d need to
    detect an empty collection in some other way. But in cases where you can designate
    some special value to represent *not here* (e.g., −1 in this case), these new
    overloads are a helpful addition.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 6.0 对`SingleOrDefault`、`FirstOrDefault`和`LastOrDefault`进行了优化。这些方法新增了重载，使你能够提供一个返回默认值的值，而不是通常的零值。如果你有一个包含整数元素的集合，其中零是有效值，这可能非常有用。[示例 10-39](#single_or_default_explicit_default)展示了如何使用新的`SingleOrDefault`重载，在列表为空时获取一个值为-1的结果。这样可以区分空列表和只包含单个零值的列表。当然，如果你的应用程序中所有可能的整数值都是有效的，这就不起作用了，你需要用其他方式检测空集合。但是，在你可以指定一些特殊值来表示“不在这里”的情况时（例如，在这种情况下是-1），这些新的重载是一个有用的补充。
- en: Example 10-39\. `SingleOrDefault` with explicit default value
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-39\. 使用显式默认值的`SingleOrDefault`
- en: '[PRE40]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The next obvious question is: What if I want a particular element that’s neither
    the first nor the last? Your wish is, in this particular instance, LINQ’s command,
    because it offers `ElementAt` and `ElementAtOrDefault` operators, both of which
    take just an index. This provides a way to access elements of any `IEnumerable<T>`
    by index. You can specify the index as an `int`. Alternatively, .NET 6.0 adds
    overloads taking an `Index`, which, as you may recall from [“Addressing Elements
    with Index and Range Syntax”](ch05.xhtml#index_and_range), enables the use of
    end-relative positions. For example, `^2` denotes the second-from-last element.
    (Oddly, `ElementAtOrDefault` didn’t get a new overload for specifying the default
    value, unlike the three operators discussed in the preceding paragraph.)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个显而易见的问题是：如果我想要一个既不是第一个也不是最后一个的特定元素怎么办？在这种情况下，LINQ的指令非常实用，因为它提供了`ElementAt`和`ElementAtOrDefault`操作符，两者都只接受一个索引。这提供了一种通过索引访问任何`IEnumerable<T>`元素的方式。你可以指定索引为一个`int`。另外，.NET
    6.0 添加了使用`Index`的重载，正如你可能从[“使用索引和范围语法访问元素”](ch05.xhtml#index_and_range)了解到的那样，它允许使用相对末尾的位置。例如，`^2`表示倒数第二个元素。（奇怪的是，`ElementAtOrDefault`没有新增重载来指定默认值，不像上一段讨论的三个操作符。）
- en: You need to be careful with `ElementAt` and `ElementAtOrDefault` because they
    can be surprisingly expensive. If you ask for the 10,000th element, these operators
    may need to request and discard the first 9,999 elements to get there. If you
    specify an end-relative position by writing, say, `source.ElementAt(^500)`, the
    operator may need to read every single element to find out which is the last,
    and with that particular example, it may also have to hang onto the last 500 elements
    it has seen because until it gets to the end, it doesn’t know which element will
    be the one it ultimately has to return.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要小心使用`ElementAt`和`ElementAtOrDefault`，因为它们可能会出乎意料地昂贵。如果你要求第10,000个元素，这些操作符可能需要请求并丢弃前9,999个元素才能到达那里。如果你通过写`source.ElementAt(^500)`来指定一个相对末尾的位置，操作符可能需要读取每一个元素才能找到最后一个元素，并且对于这个特定的示例，它还可能需要保持已经看到的最后500个元素，因为直到到达末尾时，它才知道最终需要返回哪个元素。
- en: As it happens, LINQ to Objects detects when the source object implements `IList<T>`,
    in which case it uses the indexer to retrieve the element directly instead of
    going the slow way around. But not all `IEnumerable<T>` implementations support
    random access, so these operators can be very slow. In particular, even if your
    source implements `IList<T>`, once you’ve applied one or more LINQ operators to
    it, the output of those operators will typically not support indexing. So it would
    be particularly disastrous to use `ElementAt` in a loop of the kind shown in [Example 10-40](#how_not_to_use_elementat).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 正如情况所示，LINQ to Objects会检测源对象是否实现了`IList<T>`接口，如果是，则直接使用索引器来直接获取元素，而不是绕一个慢速的方式。但并不是所有的`IEnumerable<T>`实现都支持随机访问，因此这些操作符可能会非常慢。特别是，即使你的源实现了`IList<T>`，一旦你对其应用了一个或多个LINQ操作符，这些操作符的输出通常就不支持索引访问了。因此，在像[示例 10-40](#how_not_to_use_elementat)中展示的循环中使用`ElementAt`将会特别灾难性。
- en: Example 10-40\. How not to use `ElementAt`
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-40\. 不正确使用`ElementAt`的例子
- en: '[PRE41]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Even though `Course.Catalog` is an array, I’ve filtered its contents with the
    `Where` operator, which returns a query of type `IEnumerable<Course>` that does
    not implement `IList<Course>`. The first iteration won’t be too bad—I’ll be passing
    `ElementAt` an index of `0`, so it just returns the first match, and with my sample
    data, the very first item `Where` inspects will match. But the second time around
    the loop, we’re calling `ElementAt` again. The query that `mathsCourses` refers
    to does not keep track of where we got to in the previous loop—it’s an `IEnumerable<T>`,
    not an `IEnumerator<T>`—so this will start again. `ElementAt` will ask that query
    for the first item, which it will promptly discard, and then it will ask for the
    next item, and that becomes the return value. So the `Where` query has now been
    executed twice—the first time, `ElementAt` asked it for only one item, and then
    the second time it asked it for two, so it has processed the first course twice
    now. The third time around the loop (which happens to be the final time), we do
    it all again, but this time, `ElementAt` will discard the first two matches and
    will return the third, so now it has looked at the first course three times, the
    second one twice, and the third and fourth courses once. (The third course in
    my sample data is not in the `MAT` category, so the `Where` query will skip over
    this when asked for the third item.) So, to retrieve three items, I’ve evaluated
    the `Where` query three times, causing it to evaluate my filter lambda seven times.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`Course.Catalog`是一个数组，我已经用`Where`运算符过滤了它的内容，返回了一个类型为`IEnumerable<Course>`的查询，该类型不实现`IList<Course>`接口。第一次迭代不会太糟糕——我将`ElementAt`的索引设为`0`，因此它只返回第一个匹配项，在我的样本数据中，`Where`检查的第一个项目将匹配。但是在循环的第二次迭代中，我们再次调用`ElementAt`。`mathsCourses`引用的查询并不跟踪我们在上一个循环中的位置——它是一个`IEnumerable<T>`，而不是`IEnumerator<T>`——因此这将重新开始。`ElementAt`会要求该查询返回第一个项目，它会立即丢弃它，然后请求下一个项目，这将成为返回值。因此，`Where`查询现在已经执行了两次——第一次，`ElementAt`只要求它返回一个项目，然后第二次它要求它返回两个项目，因此它现在已经处理了第一个课程两次。第三次循环（也是最后一次），我们再次重复这一过程，但这次，`ElementAt`将丢弃前两个匹配项，并返回第三个匹配项，因此现在它已经查看了第一个课程三次，第二个课程两次，第三和第四个课程各一次。（在我的样本数据中，第三个课程不属于`MAT`类别，因此当要求第三个项目时，`Where`查询会跳过它。）因此，为了检索三个项目，我已经评估了`Where`查询三次，导致它评估我的过滤lambda函数七次。
- en: In fact, it’s worse than that, because the `for` loop will also invoke that
    `Count` method each time, and with a nonindexable source such as the one returned
    by `Where`, `Count` has to evaluate the entire sequence—the only way the `Where`
    operator can tell you how many items match is to look at all of them. So this
    code fully evaluates the query returned by `Where` three times in addition to
    the three partial evaluations performed by `ElementAt`. We get away with it here
    because the collection is small, but if I had an array with 1,000 elements, all
    of which turned out to match the filter, we’d be fully evaluating the `Where`
    query 1,000 times and performing partial evaluations another 1,000 times. Each
    full evaluation calls the filter predicate 1,000 times, and the partial evaluations
    here will do so on average 500 times, so the code would end up executing the filter
    1,500,000 times. Iterating through the `Where` query with the `foreach` loop would
    evaluate the query just once, executing the filter expression 1,000 times, and
    would produce the same results.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，情况比这更糟，因为`for`循环每次还会调用`Count`方法，而对于像`Where`返回的非可索引源，`Count`必须评估整个序列——`Where`运算符告诉你有多少项匹配的唯一方法就是查看所有这些项。因此，这段代码除了`ElementAt`进行的三次部分评估外，还完全评估了`Where`返回的查询三次。在这里我们得以侥幸，因为集合很小，但如果我有一个包含1,000个元素的数组，所有元素都匹配过滤器，我们将完全评估`Where`查询1,000次，并进行另外1,000次部分评估。每次完全评估都会调用过滤器谓词1,000次，而这里的部分评估平均会这样做500次，因此代码最终会执行1,500,000次过滤。通过`foreach`循环迭代`Where`查询只会评估一次查询，执行1,000次过滤表达式，结果将会是一样的。
- en: So be careful with both `Count` and `ElementAt`. If you use them in a loop that
    iterates over the collection on which you invoke them, the resulting code will
    have O(*n*²) complexity (i.e., the cost of running the code rises proportionally
    to the number of items squared).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在使用`Count`和`ElementAt`时要小心。如果你在迭代调用它们的集合的循环中使用它们，结果代码的复杂度将会是O(*n*²)（即，运行代码的成本与项目数量的平方成正比增长）。
- en: 'All of the operators I’ve just described return a single item from the source.
    There are four more operators that also get selective about which items to use
    but can return multiple items: `Skip`, `Take`, `SkipLast`, and `TakeLast`. Each
    of these takes a single `int` argument. As the name suggests, `Skip` discards
    the specified number of elements from the beginning of the sequence and then returns
    everything else from its source. `Take` returns the specified number of elements
    from the start of the sequence and then discards the rest (so it is similar to
    `TOP` in SQL). `SkipLast` and `TakeLast` do the same except they work at the end,
    e.g., you could use `TakeLast` to get the final 5 items from the source, or `SkipLast`
    to omit the final 5 items.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 所有我刚刚描述的操作符都从源中返回单个项目。还有四个操作符也会有选择地使用项目，但可以返回多个项目：`Skip`、`Take`、`SkipLast` 和
    `TakeLast`。这些操作符每个接受一个 `int` 参数。顾名思义，`Skip` 丢弃序列开头指定数量的元素，然后返回源中的所有其他元素。`Take`
    从序列开头返回指定数量的元素，然后丢弃其余部分（因此类似于 SQL 中的 `TOP`）。`SkipLast` 和 `TakeLast` 作用于序列末尾，例如，您可以使用
    `TakeLast` 获取源中的最后 5 个项目，或者使用 `SkipLast` 跳过最后 5 个项目。
- en: .NET 6.0 adds an overload to `Take` that accepts a `Range`, enabling the use
    of the range syntax described in [“Addressing Elements with Index and Range Syntax”](ch05.xhtml#index_and_range).
    For example, `source.Take(10..^10)` skips the first 10 and also the last 10 items
    (so it is equivalent to `source.Skip(10).SkipLast(10)`). Since the range syntax
    lets you use either start- or end-relative indexes for both the start and end
    of the range, we can express other combinations with this overload of `Take`.
    For example, `source.Take(10..20)` has the same effect as `source.Skip(10).Take(10)`;
    `source.Take(^10..^2)` is equivalent to `source.TakeLast(10).SkipLast(2)`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 6.0 添加了一个重载的 `Take` 方法，接受一个 `Range`，使得可以使用在[“使用索引和范围语法访问元素”](ch05.xhtml#index_and_range)中描述的范围语法。例如，`source.Take(10..^10)`
    跳过了前 10 个和最后 10 个项目（因此等效于 `source.Skip(10).SkipLast(10)`）。由于范围语法允许您在范围的起始和结束位置使用起始或结束相对索引，我们可以使用这个
    `Take` 的重载来表示其他组合。例如，`source.Take(10..20)` 的效果与 `source.Skip(10).Take(10)` 相同；`source.Take(^10..^2)`
    相当于 `source.TakeLast(10).SkipLast(2)`。
- en: There are also predicate-driven versions, `SkipWhile` and `TakeWhile`. `SkipWhile`
    will discard items from the sequence until it finds one that matches the predicate,
    at which point it will return that and every item that follows for the rest of
    the sequence (whether or not the remaining items match the predicate). Conversely,
    `TakeWhile` returns items until it encounters the first item that does not match
    the predicate, at which point it discards that and the remainder of the sequence.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 还有基于条件的版本，`SkipWhile` 和 `TakeWhile`。`SkipWhile` 将丢弃序列中的项目，直到找到与谓词匹配的项目，此时它将返回该项目及其后续项目直至序列结束（无论剩余项目是否匹配谓词）。相反，`TakeWhile`
    将返回项目，直到遇到第一个不匹配谓词的项目，此时它将丢弃该项目及其后续序列。
- en: Although `Skip`, `Take`, `SkipLast`, `TakeLast`, `SkipWhile`, and `TakeWhile`
    are all clearly order-sensitive, they are not restricted to just the ordered types,
    such as `IOr⁠der⁠ed​Enu⁠mer⁠abl⁠e<T>`. They are also defined for `IEnumerable<T>`,
    which is reasonable, because even though there may be no particular order guaranteed,
    an `IEnumerable<T>` always produces elements in some order. (The only way you
    can extract items from an `IEnumerable<T>` is one after another, so there will
    always be an order, even if it’s arbitrary. It might not be the same every time
    you enumerate the items, but for any single evaluation, the items must come out
    in some order.) Moreover, `IOrderedEnumerable<T>` is not widely implemented outside
    of LINQ, so it’s quite common to have non-LINQ-aware objects that produce items
    in a known order but that implement only `IEnumerable<T>`. These operators are
    useful in these scenarios, so the restriction is relaxed. Slightly more surprisingly,
    `IQueryable<T>` also supports these operations, but that’s consistent with the
    fact that many databases support `TOP` (roughly equivalent to `Take`) even on
    unordered queries. As always, individual providers may choose not to support individual
    operations, so in scenarios where there’s no reasonable interpretation of these
    operators, they will just throw an exception.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `Skip`、`Take`、`SkipLast`、`TakeLast`、`SkipWhile` 和 `TakeWhile` 显然都是有序敏感的，但它们并不限于仅限于有序类型，比如
    `IOr⁠der⁠ed​Enu⁠mer⁠abl⁠e<T>`。它们也适用于 `IEnumerable<T>`，这是合理的，因为即使没有特定的顺序保证，`IEnumerable<T>`
    总是以某种顺序产生元素。（你可以从 `IEnumerable<T>` 中逐个提取项，因此总会有一种顺序，即使是任意的。每次枚举项时可能不会相同，但对于单个评估，项必须以某种顺序出现。）此外，`IOrderedEnumerable<T>`
    在 LINQ 之外并没有广泛实现，因此通常有些不了解 LINQ 的对象，虽然它们以已知的顺序产生项目，但仅实现了 `IEnumerable<T>`。这些运算符在这些场景中非常有用，因此限制得以放宽。更令人惊讶的是，`IQueryable<T>`
    也支持这些操作，但这与许多数据库支持对无序查询应用 `TOP`（大致相当于 `Take`）是一致的。正如以往一样，单个提供程序可能选择不支持某些操作，因此在没有这些运算符合理解释的情况下，它们将引发异常。
- en: Aggregation
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚合
- en: 'The `Sum` and `Average` operators add together the values of all the source
    items. `Sum` returns the total, and `Average` returns the total divided by the
    number of items. LINQ providers that support these typically make them available
    for collections of items of these numeric types: `decimal`, `double`, `float`,
    `int`, and `long`. There are also overloads that work with any item type in conjunction
    with a lambda that takes an item and returns one of those numeric types. That
    allows us to write code such as [Example 10-41](#average_operator_with_projection),
    which works with a collection of `Course` objects and calculates the average of
    a particular value extracted from the object: the course length in hours.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sum` 和 `Average` 运算符将所有源项的值相加。`Sum` 返回总和，`Average` 返回总和除以项数。通常支持这些运算符的 LINQ
    提供程序会使它们适用于这些数值类型的项目集合：`decimal`、`double`、`float`、`int` 和 `long`。还有一些重载版本，与 lambda
    表达式一起工作，该 lambda 接受一个项目并返回其中一个这些数值类型，这使得我们可以编写像 [示例 10-41](#average_operator_with_projection)
    这样的代码，它处理 `Course` 对象集合，并计算从对象中提取的特定值的平均值：课程时长（以小时计算）。'
- en: Example 10-41\. `Average` operator with projection
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-41\. 带有投影的 `Average` 运算符
- en: '[PRE42]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: LINQ also defines `Min` and `Max` operators. You can apply these to any type
    of sequence, although it is not guaranteed to succeed—the particular provider
    you’re using may report an error if it doesn’t know how to compare the types you’ve
    used. For example, LINQ to Objects requires the objects in the sequence to implement
    `IComparable`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 还定义了 `Min` 和 `Max` 运算符。你可以将它们应用于任何类型的序列，尽管不能保证一定成功——你使用的特定提供程序可能在不知道如何比较你使用的类型时报告错误。例如，LINQ
    to Objects 要求序列中的对象实现 `IComparable`。
- en: '`Min` and `Max` both have overloads that accept a lambda that gets the value
    to use from the source item. [Example 10-42](#max_with_projection) uses this to
    find the date on which the most recent course was published.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`Min` 和 `Max` 都有重载版本，接受一个从源项目获取值的 lambda 表达式。[示例 10-42](#max_with_projection)
    使用这一特性来找出最近发布的课程的日期。'
- en: Example 10-42\. `Max` with projection
  id: totrans-253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-42\. `Max` 与投影
- en: '[PRE43]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Notice that this does not return the course with the most recent publication
    date; it returns that course’s publication date. If you want to select the object
    for which a particular property has the maximum value, you can use `MaxBy`. [Example 10-43](#max_by_projection)
    will find the course with the highest `PublicationDate`, but unlike [Example 10-42](#max_with_projection),
    it returns the relevant course, instead of the date. (As you might expect, there’s
    also a `MinBy`.)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此方法并不返回最近发布日期的课程；它返回的是该课程的发布日期。如果您想选择某个属性具有最大值的对象，可以使用`MaxBy`。[示例 10-43](#max_by_projection)
    将找到具有最高`PublicationDate`的课程，但与[示例 10-42](#max_with_projection) 不同，它返回相关课程而不是日期。（正如您所预料的那样，还有一个`MinBy`。）
- en: Example 10-43\. `Max` with projection for criteria but not for result
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-43\. 用于标准的投影`Max`但不用于结果
- en: '[PRE44]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You may have spotted the `?` in that example, indicating that `MaxBy` might
    return a `null` result. This happens with both `Max` and `MaxBy` in cases where
    the input collection is empty and the output type is either a reference type or
    a nullable form of one of the supported numeric types (e.g., `int?` or `double?`).
    When the output is a non-nullable struct (e.g., `DateOnly`, as with [Example 10-42](#max_with_projection)),
    these operators cannot return `null` and will throw an `InvalidOperationException`
    instead. If you are working with a reference type and you want an exception for
    an empty input like you would get if the output were a value type, the only way
    to do that is to check for a `null` result yourself and throw an exception. [Example 10-44](#max_by_projection_no_null)
    shows one way to do this.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经在示例中注意到了`?`，表示`MaxBy`可能返回一个`null`结果。在输入集合为空且输出类型是引用类型或其支持的支持的数值类型的可空形式（例如`int?`或`double?`）的情况下，`Max`和`MaxBy`会发生这种情况。当输出是非空的结构（例如`DateOnly`，如[示例 10-42](#max_with_projection)）时，这些运算符无法返回`null`，并且会抛出`InvalidOperationException`。如果您使用的是引用类型，并且希望像值类型输出那样在输入为空时引发异常，唯一的方法是自行检查是否存在`null`结果并抛出异常。[示例 10-44](#max_by_projection_no_null)
    展示了一种实现方式。
- en: Example 10-44\. `Max` with projection for criteria but not for result with error
    on empty input
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-44\. 用于标准的投影`Max`但不用于结果，输入为空时出错
- en: '[PRE45]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: LINQ to Objects defines specialized overloads of `Min` and `Max` for sequences
    that return the same numeric types that `Sum` and `Average` deal with (i.e., `decimal`,
    `double`, `float`, `int`, and `long` and their nullable forms). It also defines
    similar specializations for the form that takes a lambda. These overloads exist
    to improve performance by avoiding boxing. The general-purpose form relies on
    `IComparable`, and getting an interface type reference to a value always involves
    boxing that value. For large collections, boxing every single value would put
    considerable extra pressure on the GC.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ to Objects 为返回与`Sum`和`Average`处理相同数值类型的特定序列的`Min`和`Max`定义了专用重载（即`decimal`、`double`、`float`、`int`、`long`及其可空形式）。它还为使用lambda表达式的形式定义了类似的专用化。这些重载存在是为了通过避免装箱来提高性能。通用形式依赖于`IComparable`，并且获取一个值的接口类型引用总是涉及装箱该值。对于大集合，装箱每个值会对GC造成相当大的额外压力。
- en: LINQ defines an operator called `Aggregate`, which generalizes the pattern that
    `Min`, `Max`, `Sum`, and `Average` all use, which is to produce a single result
    with a process that involves taking every source item into consideration. It’s
    possible to implement all four of these operators (and their `...By` counterparts)
    in terms of `Aggregate`. [Example 10-45](#sum_and_equivalent_with_aggregate) uses
    the `Sum` operator to calculate the total duration of all courses, and then shows
    how to use the `Aggregate` operator to perform the exact same calculation.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 定义了一个称为`Aggregate`的运算符，它泛化了`Min`、`Max`、`Sum`和`Average`所使用的模式，即使用涉及考虑每个源项的过程来生成单个结果。可以通过`Aggregate`来实现这四个运算符（及其`...By`对应运算符）。[示例 10-45](#sum_and_equivalent_with_aggregate)
    使用`Sum`运算符计算所有课程的总持续时间，然后展示如何使用`Aggregate`运算符执行完全相同的计算。
- en: Example 10-45\. `Sum` and equivalent with `Aggregate`
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-45\. `Sum` 和 `Aggregate` 的等效形式
- en: '[PRE46]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Aggregation works by building up a value that represents what we know about
    all the items inspected so far, referred to as the *accumulator*. The type we
    use depends on the knowledge we want to accumulate. Here, I’m just adding all
    the numbers together, so I’ve used a `double` (because the `TimeSpan` type’s `TotalHours`
    property is also a `double`).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合通过建立一个值来表示到目前为止检查过的所有项目的知识，称为*累加器*。我们使用的类型取决于我们要累积的知识。在这里，我只是将所有数字相加，所以我使用了一个`double`（因为`TimeSpan`类型的`TotalHours`属性也是一个`double`）。
- en: Initially we have no knowledge, because we haven’t looked at any items yet.
    We need to provide an accumulator value to represent this starting point, so the
    `Aggregate` operator’s first argument is the *seed*, an initial value for the
    accumulator. In [Example 10-45](#sum_and_equivalent_with_aggregate), the accumulator
    is just a running total, so the seed is `0.0`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最初我们没有知识，因为我们还没有查看任何项目。我们需要提供一个累加器值来表示这个起始点，因此`Aggregate`运算符的第一个参数是*seed*，累加器的初始值。在[Example 10-45](#sum_and_equivalent_with_aggregate)中，累加器只是一个运行总数，因此种子是`0.0`。
- en: The second argument is a lambda that describes how to update the accumulator
    to incorporate information for a single item. Since my goal here is simply to
    calculate the total time, I just add the duration of the current course to the
    running total.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是一个lambda表达式，描述如何更新累加器以包含单个项目的信息。由于我这里的目标只是计算总时间，所以我只是将当前课程的持续时间添加到运行总数中。
- en: Once `Aggregate` has looked at every item, this particular overload returns
    the accumulator directly. It will be the total number of hours across all courses
    in this case. We can implement `Max` if we use a different accumulation strategy.
    Instead of maintaining a running total, the value representing everything we know
    so far about the data is simply the highest value seen yet. [Example 10-46](#implementing_max_with_aggregate)
    shows the rough equivalent of [Example 10-42](#max_with_projection). (It’s not
    exactly the same, because [Example 10-46](#implementing_max_with_aggregate) makes
    no attempt to detect an empty source. `Max` will throw an exception if this source
    is empty, but this will just return the date 0/0/0000.)
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`Aggregate`查看了每个项目，这个特定的重载将直接返回累加器。在这种情况下，它将是所有课程中的总小时数。如果我们使用不同的累积策略，我们可以实现`Max`。而不是维护一个运行总数，表示到目前为止关于数据的所有知识的值只是看到的最高值。[Example 10-46](#implementing_max_with_aggregate)显示了与[Example 10-42](#max_with_projection)的大致等价物。（它不完全相同，因为[Example 10-46](#implementing_max_with_aggregate)没有尝试检测空源。如果此源为空，`Max`会抛出异常，但这只会返回日期
    0/0/0000。）
- en: Example 10-46\. Implementing `Max` with `Aggregate`
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 10-46\. 使用`Aggregate`实现`Max`
- en: '[PRE47]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This illustrates that `Aggregate` does not impose any single meaning for the
    value that accumulates knowledge—the way you use it depends on what you’re doing.
    Some operations require an accumulator with a bit more structure. [Example 10-47](#implementing_average_with_aggregate)
    calculates the average course duration with `Aggregate`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明了`Aggregate`并不对累积知识的值强加任何单一含义——你使用它的方式取决于你要做什么。一些操作需要一个稍微有结构的累加器。[Example 10-47](#implementing_average_with_aggregate)使用`Aggregate`计算了平均课程持续时间。
- en: Example 10-47\. Implementing `Average` with `Aggregate`
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 10-47\. 使用`Aggregate`实现`Average`
- en: '[PRE48]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The average duration requires us to know two things: the total duration and
    the number of items. So, in this example, my accumulator uses a type that can
    contain two values, one to hold the total and one to hold the item count. I’ve
    used an anonymous type because as already mentioned, that is sometimes the only
    option in LINQ, and I want to show the most general case. However, it’s worth
    mentioning that in this particular case, a tuple might be better. It will work
    because this is LINQ to Objects, and since lightweight tuples are value types
    whereas anonymous types are reference types, a tuple would reduce the number of
    objects being allocated.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 平均持续时间要求我们知道两件事：总持续时间和项目数。因此，在这个例子中，我的累加器使用了一个可以包含两个值的类型，一个用来保存总和，一个用来保存项目计数。我使用了匿名类型，因为正如前面提到的，在LINQ中有时这是唯一的选择，并且我想展示最一般的情况。然而，值得一提的是，在这种特定情况下，元组可能更好。它会起作用，因为这是LINQ到对象，而轻量级元组是值类型，而匿名类型是引用类型，元组会减少被分配的对象数量。
- en: Note
  id: totrans-275
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '[Example 10-47](#implementing_average_with_aggregate) relies on the fact that
    when two separate methods in the same component create instances of two structurally
    identical anonymous types, the compiler generates a single type that is used for
    both. The seed produces an instance of an anonymous type consisting of a `double`
    called `TotalHours` and an `int` called `Count`. The accumulation lambda also
    returns an instance of an anonymous type with the same member names and types
    in the same order. The C# compiler deems that these will be the same type, which
    is important, because `Aggregate` requires the lambda to accept and also return
    an instance of the accumulator type.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10-47](#implementing_average_with_aggregate) 基于同一组件中的两个独立方法创建两个结构相同的匿名类型实例时的事实，编译器会生成一个用于两者的单一类型。种子生成了一个由`TotalHours`（`double`）和`Count`（`int`）组成的匿名类型实例。累加
    lambda 也返回了一个具有相同成员名称和类型的匿名类型实例，并且顺序也相同。C# 编译器认为这些将是相同的类型，这很重要，因为`Aggregate`要求
    lambda 接受并返回累加器类型的实例。'
- en: '[Example 10-47](#implementing_average_with_aggregate) uses a different overload
    than the earlier example. It takes an extra lambda, which is used to extract the
    return value from the accumulator—the accumulator builds up the information I
    need to produce the result, but the accumulator itself is not the result in this
    example.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10-47](#implementing_average_with_aggregate) 使用了与先前示例不同的重载。它采用了额外的 lambda
    函数，用于从累加器中提取返回值—累加器积累了我需要生成结果所需的信息，但在这个示例中，累加器本身不是结果。'
- en: Of course, if all you want to do is calculate the sum, maximum, or average values,
    you wouldn’t use `Aggregate`—you’d use the specialized operators designed to do
    those jobs. Not only are they simpler, but they’re often more efficient. (For
    example, a LINQ provider for a database might be able to generate a query that
    uses the database’s built-in features to calculate the minimum or maximum value.)
    I just wanted to show the flexibility, using examples that are easily understood.
    But now that I’ve done that, [Example 10-48](#aggregating_bounding_boxes) shows
    a particularly concise example of `Aggregate` that doesn’t correspond to any other
    built-in operator. This takes a collection of rectangles and returns the bounding
    box that contains all of those rectangles.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你只想计算总和、最大值或平均值，你不会使用`Aggregate`—你会使用专门设计用于执行这些任务的操作符。它们不仅更简单，而且通常更高效。
    （例如，数据库的 LINQ 提供程序可能能够生成一个查询，使用数据库的内置功能计算最小或最大值。）我只是想展示灵活性，使用易于理解的例子。但现在我已经做到了，[示例 10-48](#aggregating_bounding_boxes)展示了一个特别简洁的`Aggregate`示例，它不对应任何其他内置操作符。它接受一个矩形集合并返回包含所有这些矩形的边界框。
- en: Example 10-48\. Aggregating bounding boxes
  id: totrans-279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-48\. 聚合边界框
- en: '[PRE49]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `Rect` structure in this example is from the `System.Windows` namespace.
    This is part of WPF, and it’s a very simple data structure that just contains
    four numbers—`X`, `Y`, `Width`, and `Height`—so you can use it in non-WPF applications
    if you like.^([2](ch10.xhtml#CHP-10-FN-1)) [Example 10-48](#aggregating_bounding_boxes)
    uses the `Rect` type’s static `Union` method, which takes two `Rect` arguments
    and returns a single `Rect` that is the bounding box of the two inputs (i.e.,
    the smallest rectangle that contains both of the input rectangles).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中的`Rect`结构来自`System.Windows`命名空间。这是 WPF 的一部分，它是一个非常简单的数据结构，只包含四个数字—`X`、`Y`、`Width`和`Height`—因此，即使你喜欢，你也可以在非
    WPF 应用中使用它。^([2](ch10.xhtml#CHP-10-FN-1)) [示例 10-48](#aggregating_bounding_boxes)
    使用了`Rect`类型的静态`Union`方法，它接受两个`Rect`参数并返回一个包含两个输入矩形的边界框的单个`Rect`（即包含两个输入矩形的最小矩形）。
- en: I’m using the simplest overload of `Aggregate` here. It does the same thing
    as the one I used in [Example 10-45](#sum_and_equivalent_with_aggregate), but
    it doesn’t require me to supply a seed—it just uses the first item in the list.
    [Example 10-49](#more_verbose_and_less_obscure_bounding_b) is equivalent to [Example 10-48](#aggregating_bounding_boxes)
    but makes the steps more explicit. I’ve provided the first `Rect` in the sequence
    as an explicit seed value, using `Skip` to aggregate over everything except that
    first element. I’ve also written a lambda to invoke the method, instead of passing
    the method itself. If you’re using this sort of lambda that just passes its arguments
    straight on to an existing method with LINQ to Objects, you can just pass the
    method name instead, and it will call the target method directly rather than going
    through your lambda. (You can’t do that with expression-based providers, because
    they require a lambda.)
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里使用`Aggregate`的最简单重载。它与我在[示例 10-45](#sum_and_equivalent_with_aggregate)中使用的方法相同，但它不需要我提供一个种子——它只使用列表中的第一项。[示例 10-49](#more_verbose_and_less_obscure_bounding_b)相当于[示例 10-48](#aggregating_bounding_boxes)，但使步骤更明确。我已经提供了序列中第一个`Rect`作为显式种子值，使用`Skip`来聚合除了第一个元素之外的所有内容。我还编写了一个lambda来调用该方法，而不是直接传递方法本身。如果你使用这种lambda，它只是将其参数直接传递给LINQ到对象的现有方法，你可以直接传递方法名称，它将直接调用目标方法，而不经过你的lambda。（你不能在基于表达式的提供程序中这样做，因为它们要求一个lambda。）
- en: Using the method directly is more succinct and marginally more efficient, but
    it also makes for slightly obscure code, which is why I’ve spelled it out in [Example 10-49](#more_verbose_and_less_obscure_bounding_b).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用该方法更为简洁和略微更有效，但也会导致代码略显晦涩，这就是为什么我在[示例 10-49](#more_verbose_and_less_obscure_bounding_b)中详细解释它的原因。
- en: Example 10-49\. More verbose and less obscure bounding box aggregation
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-49\. 更详细和不那么晦涩的边界框聚合
- en: '[PRE50]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: These two examples work the same way. They start with the first rectangle as
    the seed. For the next item in the list, `Aggregate` will call `Rect.Union`, passing
    in the seed and the second rectangle. The result—the bounding box of the first
    two rectangles—becomes the new accumulator value. And that then gets passed to
    `Union` along with the third rectangle, and so on. [Example 10-50](#the_effect_of_aggregate)
    shows what the effect of this `Aggregate` operation would be if performed on a
    collection of four `Rect` values. (I’ve represented the four values here as `r1`,
    `r2`, `r3`, and `r4`. To pass them to `Aggregate`, they’d need to be inside a
    collection such as an array.)
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个示例的工作方式相同。它们以第一个矩形作为种子。对于列表中的下一个项，`Aggregate`将调用`Rect.Union`，传递种子和第二个矩形。结果——前两个矩形的边界框——成为新的累加器值。然后将其与第三个矩形一起传递给`Union`，依此类推。[示例 10-50](#the_effect_of_aggregate)展示了在四个`Rect`值的集合上执行此`Aggregate`操作的效果。（我在这里表示四个值为`r1`、`r2`、`r3`和`r4`。要将它们传递给`Aggregate`，它们需要在像数组这样的集合内。）
- en: Example 10-50\. The effect of `Aggregate`
  id: totrans-287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-50\. `Aggregate`的效果
- en: '[PRE51]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`Aggregate` is LINQ’s name for an operation some other languages call *reduce*.
    You also sometimes see it called *fold*. LINQ went with the name `Aggregate` for
    the same reason it calls its projection operator `Select` instead of *map* (the
    more common name in functional programming languages): LINQ’s terminology is more
    influenced by SQL than it is by functional programming languages.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`Aggregate`是LINQ中对其他一些语言称为*reduce*的操作的称呼。有时你也会看到它被称为*fold*。LINQ选择使用`Aggregate`这个名字的原因与其将投影运算符称为`Select`而不是*map*（函数式编程语言中更常见的名称）相同：LINQ的术语更多受到SQL的影响，而不是函数式编程语言。'
- en: Set Operations
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合操作
- en: LINQ defines three operators that use some common set operations to combine
    two sources. `Intersect` produces a result that contains only those items that
    were in both of the input sources. `Except` includes only those items from the
    first input source that were not in the second. The output of `Union`^([3](ch10.xhtml#idm45884803901728))
    contains items that were in either (or both) of the input sources.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ定义了三个运算符，使用一些常见的集合操作来合并两个源。`Intersect`生成一个结果，其中包含仅存在于两个输入源中的项。`Except`包含仅来自第一个输入源中不在第二个输入源中的项。`Union`^([3](ch10.xhtml#idm45884803901728))的输出包含存在于任一（或两者）输入源中的项。
- en: Although LINQ defines these set operations, most LINQ source types do not correspond
    directly to the abstraction of a set. With a mathematical set, any particular
    item either belongs to a set or it does not, with no innate concept of order or
    of the number of times a particular item appears in a set. `IEnumerable<T>` is
    not like that—it’s a sequence of items, so it’s possible to have duplicates, and
    the same is true of `IQueryable<T>`. This is not necessarily a problem, because
    some collections will happen never to get into a situation where they contain
    duplicates, and in some cases, the presence of duplicates won’t cause a problem.
    However, it can sometimes be useful to take a collection that contains duplicates
    and remove them. For this, LINQ defines the `Distinct` operator, which removes
    duplicates. [Example 10-51](#removing_duplicates_with_distinct) contains a query
    that extracts the category names from all the courses and then feeds that into
    the `Distinct` operator to ensure that each unique category name appears just
    once.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 LINQ 定义了这些集合操作，大多数 LINQ 源类型并不直接对应集合的抽象。在数学集合中，任何特定项都要么属于集合，要么不属于，没有固有的顺序概念或特定项在集合中出现的次数。`IEnumerable<T>`
    不是这样的——它是一系列项，因此可能存在重复项，`IQueryable<T>` 也是如此。这并不一定是问题，因为有些集合永远不会处于包含重复项的情况中，而且在某些情况下，重复项的存在也不会导致问题。但有时，将包含重复项的集合转换为不包含重复项可能很有用。为此，LINQ
    定义了 `Distinct` 操作符，用于删除重复项。[示例 10-51](#removing_duplicates_with_distinct) 包含一个查询，从所有课程中提取类别名称，并将其传递给
    `Distinct` 操作符，以确保每个唯一的类别名称只出现一次。
- en: Example 10-51\. Removing duplicates with `Distinct`
  id: totrans-293
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-51\. 使用 `Distinct` 删除重复项
- en: '[PRE52]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: All of these set operators are available in two forms, because you can optionally
    pass any of them an `IEqualityComparer<T>`. This allows you to customize how the
    operators decide whether two items are the same thing.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些集合操作符都有两种形式可用，因为你可以选择向其中任何一个传递一个 `IEqualityComparer<T>`。这允许你定制操作符如何决定两个项是否相同。
- en: .NET 6.0 adds `IntersectBy`, `ExceptBy`, `UnionBy`, and `DistinctBy` operators.
    These serve the same basic purpose as `Intersect`, `Except`, `Union`, and `Distinct`
    but with a different mechanism for determining equivalence. You can supply a lambda
    that takes an element from the source collection as input and produces any output
    you want. Two items are considered to be the same if this lambda produces the
    same result for both. (For example, you could write `courses.DistinctBy(c => c.Title)`,
    which would treat any two courses as being the same if they have the same `Title`.)
    You could have achieved the same effect without this by writing a custom `IEq⁠ual⁠ity​Com⁠par⁠er⁠<T>`,
    but a projection is often simpler. (There are also overloads of all four of these
    methods that accept an `IEqualityComparer<T>`. This can be useful if your projection
    produces a string and you want to specify the string comparison mechanism.)
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 6.0 添加了 `IntersectBy`、`ExceptBy`、`UnionBy` 和 `DistinctBy` 操作符。它们的基本目的与
    `Intersect`、`Except`、`Union` 和 `Distinct` 相同，但用于确定等效性的机制不同。你可以提供一个 lambda，它接受源集合中的一个元素作为输入，并产生任何你想要的输出。如果这个
    lambda 对两个项产生相同的结果，则认为它们是相同的。（例如，你可以编写 `courses.DistinctBy(c => c.Title)`，如果两个课程具有相同的
    `Title`，则它们被视为相同。）你也可以通过编写自定义的 `IEq⁠ual⁠ity​Com⁠par⁠er⁠<T>` 来实现相同的效果，但使用投影通常更简单。（这四种方法的所有重载还接受一个
    `IEqualityComparer<T>`。如果你的投影产生一个字符串，并且你想指定字符串比较机制，这可能很有用。）
- en: Whole-Sequence, Order-Preserving Operations
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整个序列、保持顺序的操作
- en: LINQ defines certain operators whose output includes every item from the source,
    and that preserve or reverse the order. Not all collections necessarily have an
    order, so these operators will not always be supported. However, LINQ to Objects
    supports all of them. The simplest is `Reverse`, which reverses the order of the
    elements.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 定义了一些操作符，它们的输出包括源中的每个项，并保留或者反转顺序。并非所有集合都一定有顺序，因此这些操作符并不总是被支持。不过，LINQ 对对象支持它们全部。最简单的是
    `Reverse`，它反转了元素的顺序。
- en: The `Concat` operator combines two sequences. It returns a sequence that produces
    all of the elements from the first sequence (in whatever order that sequence returns
    them), followed by all of the elements from the second sequence (again, preserving
    the order). In cases where you need to add just a single element to the end of
    the first sequence, you can use `Append` instead. There is also `Prepend`, which
    adds a single item at the start. The `Repeat` operator effectively concatenates
    the specified number of copies of the source.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`Concat`操作符组合两个序列。它返回一个序列，该序列产生第一个序列中所有元素（以该序列返回它们的任何顺序），然后是第二个序列中所有元素（再次保持顺序）。在需要仅将单个元素添加到第一个序列末尾的情况下，可以使用`Append`。还有`Prepend`，它在开头添加单个项目。`Repeat`操作符有效地连接源的指定数量的副本。'
- en: 'The `DefaultIfEmpty` operator returns all of the elements from its source.
    However, if the source is empty, it returns a single element. There are two overloads
    of this method: you can either specify the default value to return when the source
    is empty or, if you pass no argument, it will use the default, zero-like value
    of the element type.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefaultIfEmpty`操作符返回其源的所有元素。但是，如果源为空，它将返回单个元素。这个方法有两个重载版本：您可以指定源为空时返回的默认值，或者如果不传递参数，则使用元素类型的默认值，类似于零。'
- en: The `Zip` operator can also combine two sequences, but instead of returning
    one after the other, it works with pairs of elements. So the first item it returns
    will be based on both the first item from the first sequence and the first item
    from the second sequence. The second item in the zipped sequence will be based
    on the second items from each of the sequences, and so on. The name `Zip` is meant
    to bring to mind how a zipper in an article of clothing brings two things together
    in perfect alignment. (It’s not an exact analogy. When a zipper brings together
    the two parts, the teeth from the two halves interlock in an alternating fashion.
    But the `Zip` operator does not interleave its inputs like a physical zipper’s
    teeth. It brings items from the two sources together in pairs.)
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`Zip`操作符也可以组合两个序列，但不是依次返回每个元素，它是逐对元素进行操作。因此，它返回的第一个项目将基于第一个序列和第二个序列的第一个项目。zipped序列中的第二个项目将基于每个序列的第二个项目，依此类推。名称`Zip`旨在让人联想到服装上拉链的作用，将两个物品完美对齐在一起。（这并不是一个精确的类比。当拉链将两部分连接时，两半部分的齿会交错连接。但`Zip`操作符不会像物理拉链的齿那样交错处理其输入。它将两个源的项目成对组合在一起。）'
- en: We need to tell `Zip` how to combine items. It takes a lambda with two arguments,
    and it will pass item pairs from the two sources as those arguments and produce
    whatever your lambda returns as output items. [Example 10-52](#combining_lists_with_zip)
    uses a selector that combines each pair of items using string concatenation.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要告诉`Zip`如何组合项目。它接受一个带有两个参数的lambda函数，将来自两个源的项目对作为这些参数传递，并生成你的lambda函数返回的输出项目。[示例 10-52](#combining_lists_with_zip)使用一个选择器，通过字符串连接组合每对项目。
- en: Example 10-52\. Combining lists with `Zip`
  id: totrans-303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-52\. 使用`Zip`组合列表
- en: '[PRE53]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The two lists that this example zips together contain first names and last
    names, respectively. The output looks like this:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中`Zip`组合在一起的两个列表包含名字和姓氏。输出如下：
- en: '[PRE54]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If the input sources contain different numbers of items, `Zip` will stop once
    it reaches the end of the shorter collection and will not attempt to retrieve
    any further items from the longer collection. It does not treat mismatched lengths
    as an error.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入源包含不同数量的项目，`Zip`将在达到较短集合的末尾时停止，并且不会尝试从较长的集合中获取更多项目。它不会将不匹配的长度视为错误。
- en: 'There are also overloads of `Zip` that do not require a lambda. These just
    return a sequence of tuples. There are two versions: one that combines a pair
    of sequences, producing 2-tuples, and another that takes three sequences, combining
    them into a sequence of 3-tuples. (There is no corresponding three-input lambda-based
    `Zip`.)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`Zip`还有一些不需要lambda函数的重载。这些重载只返回一个元组序列。有两个版本：一个是组合一对序列，产生2元组的版本，另一个是接受三个序列，将它们组合成3元组的版本。（没有对应的三个输入lambda-based
    `Zip`。）'
- en: The `SequenceEqual` operator bears a resemblance to `Zip` in that it works on
    two sequences and acts on pairs of items found at the same position in the two
    sequences. But, instead of passing them to a lambda to be combined, `SequenceEqual`
    just compares each pair. If this comparison process finds that the two sources
    contain the same number of items, and that for every pair, the two items are equal,
    then it returns `true`. If the sources are of different lengths, or if even just
    one pair of items is not equal, it returns `false`. `SequenceEqual` has two overloads,
    one that accepts just the list with which to compare the source and another that
    also takes an `IEqualityComparer<T>` to customize what you mean by equal.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`SequenceEqual` 运算符与 `Zip` 类似，它对两个序列进行操作，并处理两个序列中在相同位置上找到的项目对。但是，`SequenceEqual`
    只是比较每对项目是否相等，而不是将它们传递给 lambda 表达式进行组合。如果比较过程发现两个源包含相同数量的项，并且对于每一对，两个项目都相等，则返回
    `true`。如果源长度不同，或者仅有一对项目不相等，则返回 `false`。`SequenceEqual` 有两个重载，一个只接受用于与源比较的列表，另一个还接受一个
    `IEqualityComparer<T>` 以自定义相等的含义。'
- en: Grouping
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分组
- en: Sometimes you will want to process all items that have something in common as
    a group. [Example 10-53](#grouping_query_expression) uses a query to group courses
    by category, writing out a title for each category before listing all the courses
    in that category.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你会想要将具有共同特点的所有项目作为一组进行处理。[示例 10-53](#grouping_query_expression) 使用查询按类别对课程进行分组，在列出该类别下的所有课程之前写出每个类别的标题。
- en: Example 10-53\. Grouping query expression
  id: totrans-312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-53\. 分组查询表达式
- en: '[PRE55]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: A `group` clause takes an expression that determines group membership—in this
    case, any courses whose `Category` properties return the same value will be deemed
    to be in the same group. A `group` clause produces a collection in which each
    item implements a type representing a group. Since I am using LINQ to Objects,
    and I am grouping by category string, the type of the `subjectGroup` variable
    in [Example 10-53](#grouping_query_expression) will be `IEnumerable<IGrouping<string,
    Course>>`. This particular example produces three group objects, depicted in [Figure 10-1](#result_of_evaluating_a_grouping_query).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`group` 子句接受一个表达式，用于确定组成员资格——在本例中，任何返回相同值的 `Category` 属性的课程都将被视为同一组的成员。 `group`
    子句生成一个集合，其中每个项实现表示组的类型。由于我正在使用 LINQ 对象，且按类别字符串进行分组，在 [示例 10-53](#grouping_query_expression)
    中 `subjectGroup` 变量的类型将为 `IEnumerable<IGrouping<string, Course>>`。此特定示例生成了三个组对象，如
    [图 10-1](#result_of_evaluating_a_grouping_query) 所示。'
- en: 'Each of the `IGrouping<string, Course>` items has a `Key` property, and because
    the query groups items by the course’s `Category` property, each key contains
    a string value from that property. There are three different category names in
    the sample data in [Example 10-17](#sample_input_data_for_linq_queries): `MAT`,
    `BIO`, and `CSE`, so these are the `Key` values for the three groups.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `IGrouping<string, Course>` 项都有一个 `Key` 属性，由于查询通过课程的 `Category` 属性对项进行分组，每个键包含来自该属性的字符串值。在
    [示例 10-17](#sample_input_data_for_linq_queries) 中的示例数据中有三个不同的类别名称：`MAT`、`BIO`
    和 `CSE`，因此这些是三个组的 `Key` 值。
- en: The `IGrouping<TKey, TItem>` interface derives from `IEnumerable<TItem>`, so
    each group object can be enumerated to find the items it contains. So in [Example 10-53](#grouping_query_expression),
    the outer `foreach` loop iterates over the three groups returned by the query,
    and then the inner `foreach` loop iterates over the `Course` objects in each of
    the groups.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`IGrouping<TKey, TItem>` 接口派生自 `IEnumerable<TItem>`，因此可以枚举每个组对象以查找它包含的项。因此，在
    [示例 10-53](#grouping_query_expression) 中，外部 `foreach` 循环遍历查询返回的三个组，然后内部 `foreach`
    循环遍历每个组中的 `Course` 对象。'
- en: '![](assets/pc10_1001.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/pc10_1001.png)'
- en: Figure 10-1\. Result of evaluating a grouping query
  id: totrans-318
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-1\. 评估分组查询的结果
- en: The query expression turns into the code in [Example 10-54](#expanding_a_simple_grouping_query).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 查询表达式变成了 [示例 10-54](#expanding_a_simple_grouping_query) 中的代码。
- en: Example 10-54\. Expanding a simple grouping query
  id: totrans-320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-54\. 扩展简单分组查询
- en: '[PRE56]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Query expressions offer some variations on the theme of grouping. With a slight
    modification to the original query, we can arrange for the items in each group
    to be something other than the original `Course` objects. In [Example 10-55](#group_query_with_item_projection),
    I’ve changed the expression immediately after the `group` keyword from just `course`
    to `course.Title`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 查询表达式在分组主题上提供了一些变体。通过对原始查询进行轻微修改，我们可以安排每个组中的项目不再是原始的`Course`对象。在[示例 10-55](#group_query_with_item_projection)中，我已将`group`关键字后面的表达式从`course`改为了`course.Title`。
- en: Example 10-55\. Group query with item projection
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-55\. 使用项目投影的分组查询
- en: '[PRE57]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This still has the same grouping expression, `course.Category`, so this produces
    three groups as before, but now it’s of type `IGrouping<string, string>`. If you
    were to iterate over the contents of one of the groups, you’d find each group
    offers a sequence of strings, containing the course names. As [Example 10-56](#expanding_a_group_query_with_an_item_pro)
    shows, the compiler expands this query into a different overload of the `GroupBy`
    operator.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然具有相同的分组表达式`course.Category`，因此仍然会生成三个组，但现在它的类型是`IGrouping<string, string>`。如果您迭代其中一个组的内容，您会发现每个组提供了一个字符串序列，其中包含课程名称。正如[示例
    10-56](#expanding_a_group_query_with_an_item_pro)所示，编译器会将此查询扩展为`GroupBy`操作符的另一个重载。
- en: Example 10-56\. Expanding a group query with an item projection
  id: totrans-326
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-56\. 使用项目投影扩展的分组查询
- en: '[PRE58]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Query expressions are required to have either a `select` or a `group` as their
    final clause. However, if a query contains a `group` clause, that doesn’t have
    to be the last clause. In [Example 10-55](#group_query_with_item_projection),
    I modified how the query represents each item within a group (i.e., the boxes
    on the right of [Figure 10-1](#result_of_evaluating_a_grouping_query)), but I’m
    also free to customize the objects representing each group (the items on the left).
    By default, I get the `IGrouping<TKey, TItem>` objects (or the equivalent for
    whichever LINQ provider the query is using), but I can change this. [Example 10-57](#group_query_with_group_projection)
    uses the optional `into` keyword in its `group` clause. This introduces a new
    range variable, which iterates over the group objects, which I can go on to use
    in the rest of the query. I could follow this with other clause types, such as
    `orderby` or `where`, but in this case, I’ve chosen to use a `select` clause.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 查询表达式要求其最后一个子句必须是`select`或`group`之一。然而，如果一个查询包含`group`子句，它不必是最后一个子句。在[示例 10-55](#group_query_with_item_projection)中，我修改了查询如何表示每个组内的每个项目（即[图
    10-1](#result_of_evaluating_a_grouping_query)右侧的框），但我也可以自定义表示每个组的对象（左侧的项目）。默认情况下，我会得到`IGrouping<TKey,
    TItem>`对象（或者对于查询使用的任何LINQ提供程序的等效对象），但我可以更改这一点。[示例 10-57](#group_query_with_group_projection)在其`group`子句中使用了可选的`into`关键字。这引入了一个新的范围变量，可以遍历组对象，我可以继续在查询的其余部分使用它。我可以跟随其他子句类型，比如`orderby`或`where`，但在这种情况下，我选择使用了一个`select`子句。
- en: Example 10-57\. Group query with group projection
  id: totrans-329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-57\. 使用组投影的分组查询
- en: '[PRE59]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The result of this query is an `IEnumerable<string>`, and if you display all
    the strings it produces, you get this:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询的结果是一个`IEnumerable<string>`，如果显示它生成的所有字符串，会得到以下内容：
- en: '[PRE60]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As [Example 10-58](#expanded_group_query_with_group_projecti) shows, this expands
    into a call to the same `GroupBy` overload that [Example 10-54](#expanding_a_simple_grouping_query)
    uses, and then uses the ordinary `Select` operator for the final clause.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如[示例 10-58](#expanded_group_query_with_group_projecti)所示，这会扩展为调用与[示例 10-54](#expanding_a_simple_grouping_query)相同的`GroupBy`重载，然后在最后一个子句中使用普通的`Select`操作符。
- en: Example 10-58\. Expanded group query with group projection
  id: totrans-334
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-58\. 扩展的组投影分组查询
- en: '[PRE61]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: LINQ to Objects defines some more overloads for the `GroupBy` operator that
    are not accessible from the query syntax. [Example 10-59](#groupby_with_key_and_group_projections)
    shows an overload that provides a slightly more direct equivalent to [Example 10-57](#group_query_with_group_projection).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ to Objects定义了一些更多的`GroupBy`操作符重载，这些重载不能从查询语法中访问。[示例 10-59](#groupby_with_key_and_group_projections)展示了一个提供稍微更直接等效于[示例
    10-57](#group_query_with_group_projection)的重载。
- en: Example 10-59\. `GroupBy` with key and group projections
  id: totrans-337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-59\. 使用键和组投影的`GroupBy`
- en: '[PRE62]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This overload takes two lambdas. The first is the expression by which items
    are grouped. The second is used to produce each group object. Unlike the previous
    examples, this does not use the `IGrouping<TKey, TItem>` interface. Instead, the
    final lambda receives the key as one argument and then a collection of the items
    in the group as the second. This is exactly the same information that `IGrouping<TKey,
    TItem>` encapsulates, but because this form of the operator can pass these as
    separate arguments, it removes the need for the operator to create objects to
    represent the groups.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 此重载采用两个lambda表达式。第一个是用于分组项目的表达式。第二个用于生成每个组对象。与之前的示例不同，这不使用`IGrouping<TKey, TItem>`接口。相反，最后一个lambda接收关键字作为一个参数，然后作为第二个参数接收组中项目的集合。这与`IGrouping<TKey,
    TItem>`封装的信息完全相同，但因为此操作符的此形式可以将它们作为单独的参数传递，所以它消除了需要创建用于表示组的对象的必要性。
- en: There’s yet another version of this operator shown in [Example 10-60](#groupby_operator_with_key_comma_item_com).
    It combines the functionality of all the other flavors.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 10-60](#groupby_operator_with_key_comma_item_com)中还展示了该操作符的另一个版本。它结合了所有其他变体的功能。
- en: Example 10-60\. `GroupBy` operator with key, item, and group projections
  id: totrans-341
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-60\. 带有键、项目和组投影的`GroupBy`操作符
- en: '[PRE63]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This overload takes three lambdas. The first is the expression by which items
    are grouped. The second determines how individual items in a group are represented—this
    time I’ve chosen to extract the course title. The third lambda is used to produce
    each group object, and as with [Example 10-59](#groupby_with_key_and_group_projections),
    this final lambda is passed the key as one argument, and its other argument gets
    the group items, as transformed by the second lambda. So, rather than the original
    `Course` items, this second argument will be an `IEnumerable<string>` containing
    the course titles, because that’s what the second lambda in this example requested.
    The result of this `GroupBy` operator is once again a collection of strings, but
    now it looks like this:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 此重载采用三个lambda表达式。第一个是用于分组项目的表达式。第二个确定如何表示组内各个项目——这次我选择提取课程标题。第三个lambda用于生成每个组对象，就像[示例 10-59](#groupby_with_key_and_group_projections)一样，最后一个lambda将关键字作为一个参数传递，并将其它参数作为组项目传递，由第二个lambda转换。因此，第二个参数不再是原始的`Course`项目，而是包含课程标题的`IEnumerable<string>`，因为这是本示例中第二个lambda请求的内容。`GroupBy`操作符的结果再次是一个字符串集合，但现在看起来像这样：
- en: '[PRE64]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: I’ve shown four versions of the `GroupBy` operator. All four take a lambda that
    selects the key to use for grouping, and the simplest overload takes nothing else.
    The others let you control the representation of individual items in the group,
    or the representation of each group, or both. There are four more versions of
    this operator. They offer all the same services as the four I’ve shown already
    but also take an `IEqualityComparer<T>`, which lets you customize the logic that
    decides whether two keys are considered to be the same for grouping purposes.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我展示了`GroupBy`操作符的四个版本。所有四个版本都接受一个lambda，用于选择用于分组的键，而最简单的重载仅接受键本身。其他版本让您控制组内各个项目的表示形式，或者每个组的表示形式，或者两者兼而有之。这个操作符还有另外四个版本，它们提供了与我已展示的四个版本完全相同的功能，但还接受一个`IEqualityComparer<T>`，让您可以自定义用于分组目的的逻辑来确定两个键是否被视为相同。
- en: Sometimes it is useful to group by more than one value. For example, suppose
    you want to group courses by both category and publication year. You could chain
    the operators, grouping first by category and then by year within the category
    (or vice versa). But you might not want this level of nesting—instead of groups
    of groups, you might want to group courses under each unique combination of `Category`
    and publication year. The way to do this is simply to put both values into the
    key, and you can do that by using an anonymous type, as [Example 10-61](#composite_group_key)
    shows.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 有时按多个值分组很有用。例如，假设您想按类别和出版年份分组课程。您可以链接操作符，首先按类别分组，然后按类别内的年份分组（或反之）。但您可能不希望这种嵌套水平——您可能希望将课程分组到每个唯一的`Category`和出版年份组合下。做法很简单，只需将两个值放入键中，可以通过使用匿名类型实现，如[示例 10-61](#composite_group_key)所示。
- en: Example 10-61\. Composite group key
  id: totrans-347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-61\. 复合组键
- en: '[PRE65]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This takes advantage of the fact that anonymous types implement `Equals` and
    `GetHashCode` for us. It works for all forms of the `GroupBy` operator. With LINQ
    providers that don’t treat their lambdas as expressions (e.g., LINQ to Objects),
    you could use a tuple instead, which would be slightly more succinct while having
    the same effect.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这利用了匿名类型为我们实现了 `Equals` 和 `GetHashCode` 的事实。它适用于所有形式的 `GroupBy` 操作符。对于不将它们的
    lambda 表达式视为表达式的 LINQ 提供程序（例如 LINQ to Objects），您可以改用元组，这样会更加简洁，但效果相同。
- en: There is one other operator that groups its outputs, called `GroupJoin`, but
    it does so as part of a join operation, and we’ll look at the simpler joins first.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个分组输出的运算符称为 `GroupJoin`，但它作为联接操作的一部分执行，我们将先看一些更简单的联接。
- en: Joins
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 联接操作
- en: 'LINQ defines a `Join` operator that enables a query over one source to use
    related data from some other source, much as a database query can join information
    from one table with data in another table. Suppose our application stored a list
    of which students had signed up for which courses. If you stored that information
    in a file, you wouldn’t want to copy the full details for either the course or
    the student out into every line—you’d want just enough information to identify
    a student and a particular course. In my example data, courses are uniquely identified
    by the combination of the category and the number. To track who’s signed up for
    what, we’d need records containing three pieces of information: the course category,
    the course number, and something to identify the student. The record type in [Example 10-62](#type_associating_student_with_course)
    shows how we might represent this association in memory.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 定义了一个 `Join` 操作符，使得查询可以使用来自其他源的相关数据，就像数据库查询可以将一张表中的信息与另一张表中的数据联接一样。假设我们的应用程序存储了哪些学生报名了哪些课程的列表。如果将该信息存储在文件中，您不希望将课程或学生的完整详细信息复制到每一行中，而是只希望有足够的信息来识别学生和特定的课程。在我的示例数据中，课程通过类别和编号的组合唯一标识。为了跟踪谁报名了什么课程，我们需要记录包含三个信息：课程类别、课程编号以及用于识别学生的某些信息。在
    [示例 10-62](#type_associating_student_with_course) 中的记录类型显示了我们可以如何在内存中表示这种关联。
- en: Example 10-62\. Record type associating a student with a course
  id: totrans-353
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 10-62\. 记录类型关联学生和课程
- en: '[PRE66]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Once our application has loaded this information into memory, we may want access
    to the `Course` objects, rather than just the information identifying the course.
    We can get this with a `join` clause, as shown in [Example 10-63](#query_with_join_clause)
    (which also supplies some additional sample data using the `CourseChoice` class
    so that the query has something to work with).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的应用程序将这些信息加载到内存中，我们可能希望访问 `Course` 对象，而不仅仅是识别课程的信息。我们可以通过 `join` 子句实现这一点，如
    [示例 10-63](#query_with_join_clause) 所示（它还使用 `CourseChoice` 类提供了一些额外的示例数据，以便查询有可用的数据）。
- en: Example 10-63\. Query with `join` clause
  id: totrans-356
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 10-63\. 使用 `join` 子句查询
- en: '[PRE67]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This displays one line for each entry in the `choices` array. It shows the title
    for each course, because even though that was not available in the input collection,
    the `join` clause located the relevant item in the course catalog. [Example 10-64](#using_the_join_operator_directly)
    shows how the compiler translates the query in [Example 10-63](#query_with_join_clause).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了 `choices` 数组中每个条目的一行。它显示了每门课程的标题，因为尽管在输入集合中未提供该信息，但 `join` 子句定位了课程目录中的相关条目。[示例 10-64](#using_the_join_operator_directly)
    展示了编译器如何将 [示例 10-63](#query_with_join_clause) 中的查询转换。
- en: Example 10-64\. Using the `Join` operator directly
  id: totrans-359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 10-64\. 直接使用 `Join` 操作符
- en: '[PRE68]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `Join` operator’s job is to find an item in the second sequence that corresponds
    to the item in the first. This correspondence is determined by the first two lambdas;
    items from the two sources will be considered to correspond to one another if
    the values returned by these two lambdas are equal. This example uses an anonymous
    type and depends on the fact that two structurally identical anonymously typed
    instances in the same assembly share the same type. In other words, those two
    lambdas both produce objects with the same type. The compiler generates an `Equals`
    method for any anonymous type that compares each member in turn, so the effect
    of this code is that two rows are considered to correspond if their `Category`
    and `Number` properties are equal. (Once again, with `IQueryable<T>`-based providers,
    we have to use anonymous types, not tuples, because these lambdas will be turned
    into expression trees. But since this example uses a non-expression-based provider,
    LINQ to Objects, you could simplify this code slightly by using tuples instead.)
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`Join`操作符的作用是查找第二个序列中与第一个项目对应的项目。这种对应关系由前两个lambda表达式决定；如果这两个lambda返回的值相等，则来自两个源的项目将被视为相互对应。本示例使用匿名类型，并依赖于同一程序集中两个结构上相同的匿名类型实例具有相同类型的事实。换句话说，这两个lambda都生成具有相同类型的对象。编译器为任何匿名类型生成一个`Equals`方法，逐个比较每个成员，因此该代码的效果是，如果它们的`Category`和`Number`属性相等，则认为两行相对应。（再次强调，对于基于`IQueryable<T>`的提供程序，我们必须使用匿名类型，而不是元组，因为这些lambda将转换为表达式树。但由于此示例使用非表达式的提供程序，LINQ到对象，您可以稍微简化此代码，改用元组。）'
- en: I’ve set up this example so that there can be only one match, but what would
    happen if the course category and number did not uniquely identify a course for
    some reason? If there are multiple matches for any single input row, the `Join`
    operator will produce one output item for each match, so in that case, we’d get
    more output items than there were entries in the `choices` array. Conversely,
    if an item in the first source has no corresponding item in the second collection,
    `Join` will not produce any output for the item—it effectively ignores that input
    item.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经设置了这个示例，以便只能有一个匹配项，但如果课程类别和编号由于某种原因不能唯一标识课程会发生什么？如果任何单个输入行有多个匹配项，`Join`操作符将为每个匹配项生成一个输出项，因此在这种情况下，输出项数量将超过`choices`数组中的条目数。相反，如果第一个源中的项目在第二个集合中没有对应的项目，`Join`将不会为该项目生成任何输出项——它实际上会忽略该输入项。
- en: LINQ offers an alternative join type that handles input rows with either zero
    or multiple corresponding rows differently than the `Join` operator. [Example 10-65](#a_grouped_join)
    shows the modified query expression. (The difference is the addition of `into
    courses` on the end of the `join` clause, and the final `select` clause refers
    to that instead of the `course` range variable.) This produces output in a different
    form, so I’ve also modified the code that writes out the results.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ提供了一种替代的连接类型，用于处理具有零个或多个相应行的输入行，其方式与`Join`操作符不同。[示例 10-65](#a_grouped_join)展示了修改后的查询表达式。（区别在于`join`子句末尾添加了`into
    courses`，最终的`select`子句引用该子句而不是`course`范围变量。）这会以不同的形式生成输出，因此我还修改了编写结果的代码。
- en: Example 10-65\. A grouped join
  id: totrans-364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-65\. 分组连接
- en: '[PRE69]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: As [Example 10-66](#groupjoin_operator) shows, this causes the compiler to generate
    a call to the `GroupJoin` operator instead of `Join`.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如[示例 10-66](#groupjoin_operator)所示，这导致编译器生成对`GroupJoin`操作符的调用，而不是`Join`。
- en: Example 10-66\. `GroupJoin` operator
  id: totrans-367
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-66\. `GroupJoin`操作符
- en: '[PRE70]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This form of join produces one result for each item in the input collection
    by invoking the final lambda. Its first argument is the input item, and its second
    argument will be a collection of all the corresponding objects from the second
    collection. (Compare this with `Join`, which invokes its final lambda once for
    each match, passing the corresponding items one at a time.) This provides a way
    to represent an input item that has no corresponding items in the second collection:
    the operator can just pass an empty collection.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这种连接形式通过调用最终的lambda为输入集合中的每个项目生成一个结果。它的第一个参数是输入项，第二个参数将是来自第二个集合的所有相应对象的集合。（与`Join`相比，后者为每个匹配项调用最终的lambda一次，逐个传递相应的项目。）这提供了一种表示第二个集合中没有相应项目的输入项的方法：操作符可以简单地传递一个空集合。
- en: Both `Join` and `GroupJoin` also have overloads that accept an `IEqualityComparer<T>`
    so that you can define a custom meaning for equality for the values returned by
    the first two lambdas.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`Join`和`GroupJoin`还有重载，接受`IEqualityComparer<T>`以便您可以为前两个lambda返回的值定义自定义的相等性意义。'
- en: Conversion
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换
- en: Sometimes you will need to convert a query of one type to some other type. For
    example, you might have ended up with a collection where the type argument specifies
    some base type (e.g., `object`), but you have good reason to believe that the
    collection actually contains items of some more specific type (e.g., `Course`).
    When dealing with individual objects, you can just use the C# cast syntax to convert
    the reference to the type you believe you’re dealing with. Unfortunately, this
    doesn’t work for types such as `IEnumerable<T>` or `IQueryable<T>`.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您需要将一个类型的查询转换为另一种类型。例如，您可能已经得到一个集合，其中类型参数指定了某个基本类型（例如`object`），但您有充分理由相信该集合实际上包含某些更具体类型的项目（例如`Course`）。在处理单个对象时，您可以使用C#的转型语法将引用转换为您认为正在处理的类型。不幸的是，这对于诸如`IEnumerable<T>`或`IQueryable<T>`之类的类型并不适用。
- en: Although covariance means that an `IEnumerable<Course>` is implicitly convertible
    to an `IEnumerable<object>`, you cannot convert in the other direction even with
    an explicit downcast. If you have a reference of type `IEnumerable<object>`, attempting
    to cast that to `IEnumerable<Course>` will succeed only if the object implements
    `IEnumerable<Course>`. It’s quite possible to end up with a sequence that consists
    entirely of `Course` objects but that does not implement `IEnumerable<Course>`.
    Note that [Example 10-67](#how_not_to_cast_a_sequence) creates just such a sequence,
    and it will throw an exception when it tries to cast to `IEnumerable<Course>`.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然协变意味着`IEnumerable<Course>`可以隐式转换为`IEnumerable<object>`，但即使使用显式向下转换也不能反向转换。如果您有一个类型为`IEnumerable<object>`的引用，试图将其转换为`IEnumerable<Course>`将仅在对象实现`IEnumerable<Course>`时成功。很可能最终得到一个完全由`Course`对象组成但不实现`IEnumerable<Course>`的序列。注意，[示例 10-67](#how_not_to_cast_a_sequence)创建了这样的序列，当试图转换为`IEnumerable<Course>`时将抛出异常。
- en: Example 10-67\. How not to cast a sequence
  id: totrans-374
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-67\. 如何避免对序列进行强制转换
- en: '[PRE71]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This is a contrived example, of course. I forced the creation of an `IEnumerable<object>`
    by casting the `Select` lambda’s return type to `object`. However, it’s easy enough
    to end up in this situation for real, in only slightly more complex circumstances.
    Fortunately, there’s an easy solution. You can use the `Cast<T>` operator, shown
    in [Example 10-68](#how_to_cast_a_sequence).
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个刻意设计的示例。我通过将`Select` lambda的返回类型强制转换为`object`来强制创建一个`IEnumerable<object>`。然而，在稍微复杂的情况下，很容易陷入这种情况。幸运的是，有一个简单的解决方案。您可以使用`Cast<T>`运算符，如[示例 10-68](#how_to_cast_a_sequence)所示。
- en: Example 10-68\. How to cast a sequence
  id: totrans-377
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-68\. 如何对序列进行强制转换
- en: '[PRE72]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This returns a query that produces every item in its source in order, but it
    casts each item to the specified target type as it does so. This means that although
    the initial `Cast<T>` might succeed, it’s possible that you’ll get an `InvalidCastException`
    some point later when you try to extract values from the sequence. After all,
    in general, the only way the `Cast<T>` operator can verify that the sequence you’ve
    given it really does only ever produce values of type `T` is to extract all those
    values and attempt to cast them. It can’t evaluate the whole sequence up front
    because you might have supplied an infinite sequence. If the first billion items
    your sequence produces will be of the right type, but after that you return one
    of an incompatible type, the only way `Cast<T>` can discover this is to try casting
    items one at a time.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回一个查询，按顺序产生其来源中的每个项目，但在执行此操作时将每个项目转换为指定的目标类型。这意味着尽管最初的`Cast<T>`可能成功，但在稍后尝试从序列中提取值时可能会得到`InvalidCastException`。毕竟，通常来说，`Cast<T>`运算符能够验证您提供的序列确实只产生类型为`T`的值的唯一方法是提取所有这些值并尝试转换它们。它无法预先评估整个序列，因为您可能提供了一个无限序列。如果您的序列首次产生的十亿个项目是正确类型的，但之后返回一个不兼容类型的项目，那么`Cast<T>`发现这一点的唯一方法就是逐个尝试转换项目。
- en: Tip
  id: totrans-380
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: '`Cast<T>` and `OfType<T>` look similar, and developers sometimes use one when
    they should have used the other (usually because they didn’t know both existed).
    `OfType<T>` does almost the same thing as `Cast<T>`, but it silently filters out
    any items of the wrong type instead of throwing an exception. If you expect and
    want to ignore items of the wrong type, use `OfType<T>`. If you do not expect
    items of the wrong type to be present at all, use `Cast<T>`, because if you turn
    out to be wrong, it will let you know by throwing an exception, reducing the risk
    of allowing a potential bug to remain hidden.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cast<T>` 和 `OfType<T>` 看起来相似，有时开发人员在应该使用另一个时使用了一个（通常是因为他们不知道两者都存在）。`OfType<T>`
    几乎与 `Cast<T>` 做的事情一样，但它会静默地过滤掉任何错误类型的项目，而不是抛出异常。如果您期望并希望忽略错误类型的项目，请使用 `OfType<T>`。如果您不期望错误类型的项目出现，请使用
    `Cast<T>`，因为如果您错了，它会通过抛出异常来告诉您，减少隐藏潜在 bug 的风险。'
- en: LINQ to Objects defines an `AsEnumerable<T>` operator. This just returns the
    source without modification—it has no effect at runtime. Its purpose is to force
    the use of LINQ to Objects even if you are dealing with something that might have
    been handled by a different LINQ provider. For example, suppose you have something
    that implements `IQueryable<T>`. That interface derives from `IEnumerable<T>`,
    but the extension methods that work with `IQueryable<T>` will take precedence
    over the LINQ to Objects ones. If your intention is to execute a particular query
    on a database, and then use further client-side processing of the results with
    LINQ to Objects, you can use `AsEnumerable<T>` to draw a line that says, “This
    is where we move things to the client side.”
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ to Objects 定义了一个 `AsEnumerable<T>` 运算符。它只是返回源而没有任何修改——在运行时没有任何效果。其目的是即使处理可能由不同的
    LINQ 提供程序处理的内容，也强制使用 LINQ to Objects。例如，假设您有一个实现了 `IQueryable<T>` 的东西。该接口从 `IEnumerable<T>`
    派生，但是适用于 `IQueryable<T>` 的扩展方法将优先于 LINQ to Objects。如果您的意图是在数据库上执行特定查询，然后使用 LINQ
    to Objects 进行进一步的客户端处理结果，您可以使用 `AsEnumerable<T>` 来划定界限，表示“这是我们将事务移到客户端的地方”。
- en: Conversely, there’s also `AsQueryable<T>`. This is designed to be used in scenarios
    where you have a variable of static type `IEnumerable<T>` that you believe might
    contain a reference to an object that also implements `IQueryable<T>`, and you
    want to ensure that any queries you create use that instead of LINQ to Objects.
    If you use this operator on a source that does not in fact implement `IQueryable<T>`,
    it returns a wrapper that implements `IQueryable<T>` but uses LINQ to Objects
    under the covers.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，还有 `AsQueryable<T>`。它设计用于具有静态类型 `IEnumerable<T>` 变量的场景，您认为该变量可能包含对也实现 `IQueryable<T>`
    的对象的引用，并且您希望任何创建的查询都使用该引用而不是 LINQ to Objects。如果您在一个实际上不实现 `IQueryable<T>` 的源上使用此运算符，则返回一个实现
    `IQueryable<T>` 的包装器，但在内部使用 LINQ to Objects。
- en: Yet another operator for selecting a different flavor of LINQ is `AsParallel`.
    This returns a `ParallelQuery<T>`, which lets you build queries to be executed
    by Parallel LINQ, a LINQ provider that can execute certain operations in parallel
    to improve performance when multiple CPU cores are available.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择不同 LINQ 口味的运算符是 `AsParallel`。它返回 `ParallelQuery<T>`，允许您构建由并行 LINQ 执行的查询，这是一个能够利用多个
    CPU 核心并行执行某些操作以提高性能的 LINQ 提供程序。
- en: There are some operators that convert the query to other types and also have
    the effect of executing the query immediately rather than building a new query
    chained off the back of the previous one. `ToArray`, `ToList`, and `ToHashSet`
    return an array, list, or hash set, respectively, containing the complete results
    of executing the input query. `ToDictionary` and `ToLookup` do the same, but rather
    than producing a straightforward list of the items, they both produce results
    that support associative lookup. `ToDictionary` returns a `Dictionary<TKey, TValue>`,
    so it is intended for scenarios where a key corresponds to exactly one value.
    `ToLookup` is designed for scenarios where a key may be associated with multiple
    values, so it returns a different type, `ILookup<TKey, TValue>`.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些运算符可以将查询转换为其他类型，同时也会立即执行查询，而不是在先前查询的基础上构建新的查询链。`ToArray`，`ToList` 和 `ToHashSet`
    分别返回包含执行输入查询完整结果的数组、列表或哈希集合。`ToDictionary` 和 `ToLookup` 同样如此，但它们不是产生简单的项目列表，而是生成支持关联查找的结果。`ToDictionary`
    返回 `Dictionary<TKey, TValue>`，因此适用于键对应于唯一值的场景。`ToLookup` 设计用于键可能关联多个值的场景，因此返回不同类型
    `ILookup<TKey, TValue>`。
- en: I did not mention this lookup interface in [Chapter 5](ch05.xhtml#ch_collections)
    because it is specific to LINQ. It is essentially the same as a read-only dictionary
    interface, except the indexer returns an `IEnumerable<TValue>` instead of a single
    `TValue`.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 [Chapter 5](ch05.xhtml#ch_collections) 中没有提及此查找接口，因为它特定于 LINQ。它与只读字典接口本质上相同，只是索引器返回
    `IEnumerable<TValue>` 而不是单个 `TValue`。
- en: While the array and list conversions take no arguments, the dictionary and lookup
    conversions need to be told what value to use as the key for each source item.
    You tell them by passing a lambda, as [Example 10-69](#creating_a_lookup) shows.
    This uses the course’s `Category` property as the key.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 数组和列表转换不需要参数，但字典和查找转换需要告诉每个源项要使用的键值。正如 [Example 10-69](#creating_a_lookup) 所示，通过传递
    lambda 来告诉它们。这里使用课程的 `Category` 属性作为键。
- en: Example 10-69\. Creating a lookup
  id: totrans-388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 10-69\. 创建查找
- en: '[PRE73]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `ToDictionary` operator offers an overload that takes the same argument
    but returns a dictionary instead of a lookup. It would throw an exception if you
    called it in the same way that I called `ToLookup` in [Example 10-69](#creating_a_lookup),
    because multiple course objects share categories, so they would map to the same
    key. `ToDictionary` requires each object to have a unique key. To produce a dictionary
    from the course catalog, you’d either need to group the data by category first
    and have each dictionary entry refer to an entire group or need a lambda that
    returned a composite key based on both the course category and number, because
    that combination is unique to a course.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToDictionary` 操作符提供了一个重载，参数与 `ToLookup` 相同，但返回字典而不是查找表。如果你像在 [Example 10-69](#creating_a_lookup)
    中调用 `ToLookup` 一样调用它，会抛出异常，因为多个课程对象共享类别，它们会映射到相同的键。`ToDictionary` 要求每个对象具有唯一的键。要从课程目录生成字典，你需要首先按类别分组数据，并使每个字典条目引用整个组，或者需要一个
    lambda 返回基于课程类别和编号的复合键，因为该组合对于课程是唯一的。'
- en: Both operators also offer an overload that takes a pair of lambdas—one that
    extracts the key and a second that chooses what to use as the corresponding value
    (you are not obliged to use the source item as the value). Finally, there are
    overloads that also take an `IEqualityComparer<T>`.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个操作符还提供了一个重载，接受一对 lambda 表达式——一个提取键，另一个选择用作相应值的内容（您无需使用源项作为值）。最后，还有接受 `IEqualityComparer<T>`
    的重载。
- en: You’ve now seen all of the standard LINQ operators, but since that has taken
    quite a few pages, you may find it useful to have a concise summary. [Table 10-1](#summary_of_linq_operators)
    lists the operators and describes briefly what each is for.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到所有标准 LINQ 操作符，但由于这占据了相当多的页面，您可能会发现具有简洁摘要很有用。[Table 10-1](#summary_of_linq_operators)
    列出了这些操作符，并简要描述了每个操作符的用途。
- en: Table 10-1\. Summary of LINQ operators
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: Table 10-1\. LINQ 操作符摘要
- en: '| Operator | Purpose |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| 操作符 | 目的 |'
- en: '| --- | --- |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Aggregate` | Combines all items through a user-supplied function to produce
    a single result. |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| `Aggregate` | 通过用户提供的函数组合所有项以产生单个结果。 |'
- en: '| `All` | Returns `true` if the predicate supplied is false for no items. |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| `All` | 如果对所有项条件均不满足，返回`true`。 |'
- en: '| `Any` | Returns `true` if the predicate supplied is true for at least one
    item. |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| `Any` | 如果对至少一个项满足条件，返回`true`。 |'
- en: '| `Append` | Returns a sequence with all the items from its input sequence
    with one item added to the end. |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| `Append` | 返回具有所有输入序列中的项及末尾添加的一项的序列。 |'
- en: '| `AsEnumerable` | Returns the sequence as an `IEnumerable<T>`. (Useful for
    forcing use of LINQ to Objects.) |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| `AsEnumerable` | 将序列作为 `IEnumerable<T>` 返回。（强制使用 LINQ to Objects 很有用。） |'
- en: '| `AsParallel` | Returns a `ParallelQuery<T>` for parallel query execution.
    |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| `AsParallel` | 返回用于并行查询执行的`ParallelQuery<T>`。 |'
- en: '| `AsQueryable` | Ensures use of `IQueryable<T>` handling where available.
    |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| `AsQueryable` | 确保在可用时使用 `IQueryable<T>` 处理。 |'
- en: '| `Average` | Calculates the arithmetic mean of the items. |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| `Average` | 计算项的算术平均值。 |'
- en: '| `Cast` | Casts each item in the sequence to the specified type. |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| `Cast` | 将序列中的每个项转换为指定类型。 |'
- en: '| `Chunk` | Splits a sequence into equal-sized batches. |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| `Chunk` | 将序列分割成相等大小的批次。 |'
- en: '| `Concat` | Forms a sequence by concatenating two sequences. |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| `Concat` | 通过连接两个序列形成一个新序列。 |'
- en: '| `Contains` | Returns `true` if the specified item is in the sequence. |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| `Contains` | 如果序列中包含指定的项，则返回`true`。 |'
- en: '| `Count`, `LongCount` | Return the number of items in the sequence. |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| `Count`, `LongCount` | 返回序列中的项数。 |'
- en: '| `DefaultIfEmpty` | Produces the source sequence’s elements, unless there
    are none, in which case it produces a single element with a default value. |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| `DefaultIfEmpty` | 生成源序列的元素，除非没有元素，此时生成一个具有默认值的单个元素。 |'
- en: '| `Distinct` | Removes duplicate values. |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| `Distinct` | 删除重复值。 |'
- en: '| `DistinctBy` | Removes values for which a projection produces duplicate values.
    |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| `DistinctBy` | 删除投影生成重复值的值。 |'
- en: '| `ElementAt` | Returns the element at the specified position (throwing an
    exception if out of range). |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| `ElementAt` | 返回指定位置的元素（如果超出范围则抛出异常）。 |'
- en: '| `ElementAtOr​Default` | Returns the element at the specified position (producing
    the element type’s default value if out of range). |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| `ElementAtOrDefault` | 返回指定位置的元素（如果超出范围则生成元素类型的默认值）。 |'
- en: '| `Except` | Filters out items that are in the other collection provided. |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| `Except` | 过滤掉在另一个提供的集合中的项目。 |'
- en: '| `First` | Returns the first item, throwing an exception if there are no items.
    |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| `First` | 返回第一个项目，如果没有项目则抛出异常。 |'
- en: '| `FirstOrDefault` | Returns the first item, or a default value if there are
    no items. |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| `FirstOrDefault` | 如果没有项目，则返回第一个项目或默认值。 |'
- en: '| `GroupBy` | Gathers items into groups. |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| `GroupBy` | 将项目分组。 |'
- en: '| `GroupJoin` | Groups items in another sequence by how they relate to items
    in the input sequence. |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| `GroupJoin` | 根据它们与输入序列中项目的关系，对另一个序列中的项目进行分组。 |'
- en: '| `Intersect` | Filters out items that are not in the other collection provided.
    |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| `Intersect` | 过滤掉不在另一个提供的集合中的项目。 |'
- en: '| `IntersectBy` | Same as `Intersect` but using a projection for comparison.
    |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| `IntersectBy` | 使用投影进行比较的`Intersect`。 |'
- en: '| `Join` | Produces an item for each matching pair of items from the two input
    sequences. |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| `Join` | 对两个输入序列中每个匹配对的项目生成一个项目。 |'
- en: '| `Last` | Returns the final item, throwing an exception if there are no items.
    |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| `Last` | 返回最后一个项目，如果没有项目则抛出异常。 |'
- en: '| `LastOrDefault` | Returns the final item, or a default value if there are
    no items. |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| `LastOrDefault` | 如果没有项目，则返回最后一个项目或默认值。 |'
- en: '| `Max` | Returns the highest value. |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| `Max` | 返回最高值。 |'
- en: '| `MaxBy` | Returns the item for which a projection produces the highest value.
    |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| `MaxBy` | 返回投影产生最高值的项目。 |'
- en: '| `Min` | Returns the lowest value. |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| `Min` | 返回最低值。 |'
- en: '| `MinBy` | Returns the item for which a projection produces the lowest value.
    |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| `MinBy` | 返回投影产生最低值的项目。 |'
- en: '| `OfType` | Filters out items that are not of the specified type. |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| `OfType` | 过滤掉不是指定类型的项目。 |'
- en: '| `OrderBy` | Produces items in an ascending order. |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| `OrderBy` | 以升序生成项目。 |'
- en: '| `Ord⁠erBy​Des⁠cen⁠ding` | Produces items in a descending order. |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '| `OrderByDescending` | 以降序生成项目。 |'
- en: '| `Prepend` | Returns a sequence starting with a specified single item, followed
    by all the items from its input sequence. |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| `Prepend` | 返回以指定单个项目开始，后跟其输入序列中所有项目的序列。 |'
- en: '| `Reverse` | Produces items in the opposite order than the input. |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| `Reverse` | 以与输入相反的顺序生成项目。 |'
- en: '| `Select` | Projects each item through a function. |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '| `Select` | 通过函数对每个项目进行投影。 |'
- en: '| `SelectMany` | Combines multiple collections into one. |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '| `SelectMany` | 将多个集合合并为一个。 |'
- en: '| `SequenceEqual` | Returns `true` only if all items are equal to those in
    the other sequence provided. |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '| `SequenceEqual` | 仅当所有项目与另一个提供的序列中的项目相等时返回`true`。 |'
- en: '| `Single` | Returns the only item, throwing an exception if there are no items
    or more than one item. |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| `Single` | 返回唯一项目，如果没有项目或多于一个项目则抛出异常。 |'
- en: '| `SingleOr​Default` | Returns the only item, or a default value if there are
    no items; throws an exception if there is more than one item. |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '| `SingleOrDefault` | 返回唯一项目或默认值（如果没有项目则抛出异常）；如果存在多个项目则抛出异常。 |'
- en: '| `Skip` | Filters out the specified number of items from the start. |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| `Skip` | 从开头过滤指定数量的项目。 |'
- en: '| `SkipLast` | Filters out the specified number of items from the end. |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| `SkipLast` | 从末尾过滤掉指定数量的项目。 |'
- en: '| `SkipWhile` | Filters out items from the start for as long as the items match
    a predicate. |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| `SkipWhile` | 从开头开始过滤项目，直到项目不匹配为止。 |'
- en: '| `Sum` | Returns the result of adding all the items together. |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| `Sum` | 返回所有项目相加的结果。 |'
- en: '| `Take` | Produces the specified number or range of items, discarding the
    rest. |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '| `Take` | 生成指定数量或范围的项目，丢弃其余项目。 |'
- en: '| `TakeLast` | Produces the specified number of items from the end of the input
    (discarding all items before that). |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| `TakeLast` | 从输入的末尾生成指定数量的项目（丢弃之前的所有项目）。 |'
- en: '| `TakeWhile` | Produces items as long as they match a predicate, discarding
    the rest of the sequence as soon as one fails to match. |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '| `TakeWhile` | 只要项目匹配谓词，就生成项目；一旦有一个项目不匹配，就丢弃其余序列。 |'
- en: '| `ToArray` | Returns an array containing all of the items. |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| `ToArray` | 返回包含所有项目的数组。 |'
- en: '| `ToDictionary` | Returns a dictionary containing all of the items. |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '| `ToDictionary` | 返回包含所有项目的字典。 |'
- en: '| `ToHashSet` | Returns a `HashSet<T>` containing all of the items. |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '| `ToHashSet` | 返回包含所有项目的`HashSet<T>`。 |'
- en: '| `ToList` | Returns a `List<T>` containing all of the items. |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '| `ToList` | 返回包含所有项目的`List<T>`。 |'
- en: '| `ToLookup` | Returns a multivalue associative lookup containing all of the
    items. |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '| `ToLookup` | 返回包含所有项目的多值关联查找。 |'
- en: '| `Union` | Produces all items that are in either or both of the inputs. |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '| `Union` | 生成位于任一输入中或两者中的所有项目。 |'
- en: '| `UnionBy` | Same as `Union` but using a projection for comparison. |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '| `UnionBy` | 与`Union`相同，但使用投影进行比较。 |'
- en: '| `Where` | Filters out items that do not match the predicate provided. |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '| `Where` | 过滤掉不符合提供的谓词的项目。 |'
- en: '| `Zip` | Combines items at the same position from two or three inputs. |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '| `Zip` | 将来自两个或三个输入的相同位置的项目组合在一起。 |'
- en: Sequence Generation
  id: totrans-454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列生成
- en: The `Enumerable` class defines the extension methods for `IEnumerable<T>` that
    constitute LINQ to Objects. It also offers a few additional (nonextension) static
    methods that can be used to create new sequences. `Enumerable.Range` takes two
    `int` arguments and returns an `IEnumerable<int>` that produces a sequentially
    increasing series of numbers, starting from the value of the first argument and
    containing as many numbers as the second argument. For example, `Enumerable.Range(15,
    10)` produces a sequence containing the numbers 15 to 24 (inclusive).
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enumerable`类定义了扩展方法，用于`IEnumerable<T>`，构成了LINQ to Objects。它还提供了一些额外的（非扩展）静态方法，用于创建新的序列。`Enumerable.Range`接受两个`int`参数，并返回一个`IEnumerable<int>`，产生从第一个参数值开始的连续递增数字系列，包含第二个参数指定的数字个数。例如，`Enumerable.Range(15,
    10)`生成包含数字15到24（包括）的序列。'
- en: '`Enumerable.Repeat<T>` takes a value of type `T` and a count. It returns a
    sequence that will produce that value the specified number of times.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enumerable.Repeat<T>`接受类型为`T`的值和计数。它返回一个序列，该序列将产生指定次数的该值。'
- en: '`Enumerable.Empty<T>` returns an `IEnumerable<T>` that contains no elements.
    This may not sound very useful, because there’s a much less verbose alternative.
    You could write `new T[0]`, which creates an array that contains no elements.
    (Arrays of type `T` implement `IEnumerable<T>`.) However, the advantage of `Enumerable.Empty<T>`
    is that for any given `T`, it returns the same instance every time. This means
    that if for any reason you end up needing an empty sequence repeatedly in a loop
    that executes many iterations, `Enumerable.Empty<T>` is more efficient, because
    it puts less pressure on the GC.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enumerable.Empty<T>`返回一个不包含任何元素的`IEnumerable<T>`。这听起来可能不是很有用，因为有一个更简洁的替代方案。你可以写`new
    T[0]`，它创建一个不包含任何元素的数组（类型为`T`的数组实现了`IEnumerable<T>`）。然而，`Enumerable.Empty<T>`的优点在于，对于任何给定的`T`，它每次返回相同的实例。这意味着如果由于任何原因你需要在执行许多迭代的循环中重复使用空序列，`Enumerable.Empty<T>`更高效，因为它对GC的压力较小。'
- en: Other LINQ Implementations
  id: totrans-458
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他LINQ实现
- en: Most of the examples I’ve shown in this chapter have used LINQ to Objects, except
    for a handful that have referred to EF Core. In this final section, I will provide
    a quick description of some other LINQ-based technologies. This is not a comprehensive
    list, because anyone can write a LINQ provider.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中大多数我展示的示例都使用了LINQ to Objects，除了少数几个引用了EF Core。在这最后一节中，我将快速描述一些其他基于LINQ的技术。这并不是一个详尽的列表，因为任何人都可以编写LINQ提供程序。
- en: Entity Framework Core
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体框架核心
- en: The database examples I have shown have used the LINQ provider that is part
    of Entity Framework Core (EF Core). EF Core is a data access technology that ships
    in a NuGet package, `Microsoft.EntityFrameworkCore`. (EF Core’s predecessor, the
    Entity Framework, is still built into .NET Framework but not in newer versions
    of .NET.) EF Core can map between a database and an object layer. It supports
    multiple database vendors.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 我展示的数据库示例使用了Entity Framework Core（EF Core）的LINQ提供程序。EF Core是一种数据访问技术，以NuGet包`Microsoft.EntityFrameworkCore`的形式提供。（EF
    Core的前身，Entity Framework，仍内置于.NET Framework中，但不包括在较新版本的.NET中。）EF Core可以在数据库和对象层之间进行映射。它支持多个数据库供应商。
- en: EF Core relies on `IQueryable<T>`. For each persistent entity type in a data
    model, the EF can provide an object that implements `IQueryable<T>` and that can
    be used as the starting point for building queries to retrieve entities of that
    type and of related types. Since `IQueryable<T>` is not unique to the EF, you
    will be using the standard set of extension methods provided by the `Queryable`
    class in the `System.Linq` namespace, but that mechanism is designed to allow
    each provider to plug in its own behavior.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 依赖于 `IQueryable<T>`。对于数据模型中的每个持久化实体类型，EF 可以提供一个实现 `IQueryable<T>` 的对象，作为构建检索该类型和相关类型实体查询的起点。由于
    `IQueryable<T>` 不仅仅适用于 EF，您将使用 `System.Linq` 命名空间中提供的标准扩展方法集，但该机制设计用于允许每个提供程序插入其自己的行为。
- en: Because `IQueryable<T>` defines the LINQ operators as methods that accept `Expression<T>`
    arguments and not plain delegate types, any expressions you write in either query
    expressions or as lambda arguments to the underlying operator methods will turn
    into compiler-generated code that creates a tree of objects representing the structure
    of the expression. The EF relies on this to be able to generate database queries
    that fetch the data you require. This means that you are obliged to use lambdas;
    unlike with LINQ to Objects, you cannot use anonymous methods or delegates with
    an EF query.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `IQueryable<T>` 将 LINQ 操作符定义为接受 `Expression<T>` 参数的方法，而不是普通的委托类型，所以您在查询表达式或作为底层操作符方法的
    lambda 参数中编写的任何表达式都将转换为由编译器生成的代码，创建表示表达式结构的对象树。EF 依赖于此能力来生成检索所需数据的数据库查询。这意味着您必须使用
    lambda；与 LINQ to Objects 不同，您不能在 EF 查询中使用匿名方法或委托。
- en: Warning
  id: totrans-464
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Because `IQueryable<T>` derives from `IEnumerable<T>`, it’s possible to use
    LINQ to Objects operators on any EF source. You can do this explicitly with the
    `AsEnumerable<T>` operator, but it could also happen accidentally if you used
    an overload that’s supported by LINQ to Objects and not `IQueryable<T>`. For example,
    if you attempt to use a delegate instead of a lambda as, say, the predicate for
    the `Where` operator, this will fall back to LINQ to Objects. The upshot here
    is that EF will end up downloading the entire contents of the table and then evaluating
    the `Where` operator on the client side. This is unlikely to be a good idea.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `IQueryable<T>` 派生自 `IEnumerable<T>`，所以可以在任何 EF 源上使用 LINQ to Objects 操作符。您可以通过
    `AsEnumerable<T>` 操作符明确地执行此操作，但如果使用的重载支持 LINQ to Objects 而不支持 `IQueryable<T>`，也可能会发生意外情况。例如，如果尝试使用委托而不是
    lambda 作为 `Where` 操作符的谓词，这将回退到 LINQ to Objects。这里的要点是，EF 最终会下载整个表的内容，然后在客户端上评估
    `Where` 操作符。这不太可能是一个好主意。
- en: Parallel LINQ (PLINQ)
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行 LINQ（PLINQ）
- en: Parallel LINQ is similar to LINQ to Objects in that it is based on objects and
    delegates rather than expression trees and query translation. But when you start
    asking for results from a query, it will use multithreaded evaluation where possible,
    using the thread pool to try to use the available CPU resources efficiently. [Chapter 16](ch16.xhtml#ch_multithreading)
    will show multithreading in action.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 并行 LINQ 与 LINQ to Objects 相似，因为它基于对象和委托，而不是表达式树和查询翻译。但是，当您开始从查询请求结果时，它将尽可能使用多线程评估，利用线程池来有效地使用可用的
    CPU 资源。[第 16 章](ch16.xhtml#ch_multithreading) 将展示多线程操作的实际效果。
- en: LINQ to XML
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XML 的 LINQ
- en: 'LINQ to XML is not a LINQ provider. I’m mentioning it here because its name
    makes it sound like one. It’s really an API for creating and parsing XML documents.
    It’s called *LINQ to XML* because it was designed to make it easy to execute LINQ
    queries against XML documents, but it achieves this by presenting XML documents
    through a .NET object model. The runtime libraries provide two separate APIs that
    do this: as well as LINQ to XML, it also offers the XML Document Object Model
    (DOM). The DOM is based on a platform-independent standard, and thus, it’s not
    a brilliant match for .NET idioms and feels unnecessarily quirky compared with
    most of the runtime libraries. LINQ to XML was designed purely for .NET, so it
    integrates better with normal C# techniques. This includes working well with LINQ,
    which it does by providing methods that extract features from the document in
    terms of `IEnumerable<T>`. This enables it to defer to LINQ to Objects to define
    and execute the queries.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ to XML 不是一个 LINQ 提供程序。我在这里提到它，因为它的名称听起来像一个。它真正是一个用于创建和解析 XML 文档的 API。它被称为*LINQ
    to XML*，因为它旨在通过 .NET 对象模型轻松执行对 XML 文档的 LINQ 查询，但它通过 .NET 对象模型来呈现 XML 文档来实现这一点。运行库提供了两个单独的
    API 来实现这一点：除了 LINQ to XML 外，它还提供了 XML 文档对象模型（DOM）。DOM 基于一个平台无关的标准，因此与 .NET 习惯用法不太匹配，并且与大多数运行库相比感觉不必要地古怪。LINQ
    to XML 纯粹是为 .NET 设计的，因此它与普通的 C# 技术集成得更好。这包括与 LINQ 良好地配合工作，它通过提供从文档中提取特性的方法来推迟到
    LINQ to Objects 来定义和执行查询。
- en: IAsyncEnumerable<T>
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`IAsyncEnumerable<T>`'
- en: As [Chapter 5](ch05.xhtml#ch_collections) described, .NET defines the `IAsyncEnumerable<T>`
    interface, which is an asynchronous equivalent to `IEnumerable<T>`. [Chapter 17](ch17.xhtml#ch_asynchronous_language_features)
    will describe the language features that enable you to use this. A full set of
    LINQ operators is available, although they are not built into the .NET runtime
    libraries. They are available in a NuGet package called `System.Linq.Async`.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[第5章](ch05.xhtml#ch_collections)所述，.NET 定义了`IAsyncEnumerable<T>`接口，这是`IEnumerable<T>`的异步等价物。[第17章](ch17.xhtml#ch_asynchronous_language_features)将描述语言特性，使您能够使用这个接口。虽然
    .NET 运行库中没有内置完整的 LINQ 操作符集，但它们在一个名为`System.Linq.Async`的 NuGet 包中可用。
- en: Reactive Extensions
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应式扩展
- en: The Reactive Extensions for .NET (or Rx, as they’re often abbreviated) are the
    subject of the next chapter, so I won’t say too much about them here, but they
    are a good illustration of how LINQ operators can work on a variety of types.
    Rx inverts the model shown in this chapter where we ask a query for items once
    we’re good and ready. So, instead of writing a `foreach` loop that iterates over
    a query, or calling one of the operators that evaluates the query such as `ToArray`
    or `SingleOrDefault`, an Rx source calls us when it’s ready to supply data.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 的响应式扩展（或简称为 Rx）是下一章的主题，因此我不会在这里过多介绍它们，但它们很好地说明了 LINQ 操作符如何在各种类型上工作。Rx 反转了本章展示的模型，我们可以在准备好并且需要数据时调用一个
    Rx 源，而不是编写一个`foreach`循环来迭代查询，或者调用诸如`ToArray`或`SingleOrDefault`等评估查询的运算符。
- en: Despite this inversion, there is a LINQ provider for Rx that supports most of
    the standard LINQ operators.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，Rx 有一个 LINQ 提供程序，支持大多数标准的 LINQ 操作符。
- en: Summary
  id: totrans-475
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, I showed the query syntax that supports some of the most commonly
    used LINQ features. This lets us write queries in C# that resemble database queries
    but can query any LINQ provider, including LINQ to Objects, which lets us run
    queries against our object models. I showed the standard LINQ operators for querying,
    all of which are available with LINQ to Objects, and most of which are available
    with database providers. I also provided a quick roundup of some of the common
    LINQ providers for .NET applications.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我展示了支持一些最常用的 LINQ 特性的查询语法。这使我们能够在 C# 中编写类似于数据库查询的查询，但可以查询任何 LINQ 提供程序，包括
    LINQ to Objects，使我们能够针对我们的对象模型运行查询。我展示了用于查询的标准 LINQ 操作符，所有这些操作符都可以在 LINQ to Objects
    中使用，大多数可以在数据库提供程序中使用。我还提供了一些常见的 .NET 应用程序的 LINQ 提供程序的快速概述。
- en: The last provider I mentioned was Rx. But before we look at Rx’s LINQ provider,
    the next chapter will begin by looking at how Rx itself works.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到的最后一个提供程序是 Rx。但在我们查看 Rx 的 LINQ 提供程序之前，下一章将从如何使用 Rx 本身开始。
- en: ^([1](ch10.xhtml#idm45884806145536-marker)) As I write this, the tentative feature
    set for .NET 7.0 includes fixing this, so there’s some hope that this might improve.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch10.xhtml#idm45884806145536-marker)) 当我写这篇文章时，.NET 7.0 的初步功能集包括修复这个问题，因此有一些希望这可能会得到改善。
- en: ^([2](ch10.xhtml#CHP-10-FN-1-marker)) If you do so, be careful not to confuse
    it with another WPF type, `Rectangle`. That’s an altogether more complex beast
    that supports animation, styling, layout, user input, databinding, and various
    other WPF features. Do not attempt to use `Rectangle` outside of a WPF application.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch10.xhtml#CHP-10-FN-1-marker)) 如果你这样做，请注意不要将其与另一种WPF类型`Rectangle`混淆。那是一个更为复杂的实体，支持动画、样式、布局、用户输入、数据绑定以及其他各种WPF功能。请勿在WPF应用程序之外尝试使用`Rectangle`。
- en: ^([3](ch10.xhtml#idm45884803901728-marker)) This is unrelated to the `Rect.Union`
    method used in the preceding example.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch10.xhtml#idm45884803901728-marker)) 这与在前面示例中使用的`Rect.Union`方法无关。
