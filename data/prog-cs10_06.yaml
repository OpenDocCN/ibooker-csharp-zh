- en: Chapter 6\. Inheritance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 继承
- en: C# classes support *inheritance*, a popular object-oriented code reuse mechanism.
    When you write a class, you can optionally specify a base class. Your class will
    derive from this, meaning that everything in the base class will be present in
    your class, as well as any members you add.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C#类支持*继承*，这是一种流行的面向对象代码重用机制。当你编写一个类时，可以选择性地指定一个基类。你的类将从这个基类派生，这意味着基类中的所有内容将出现在你的类中，以及你添加的任何成员。
- en: 'Classes and class-based record types support only single inheritance (so you
    can only specify one base class). Interfaces offer a form of multiple inheritance.
    Value types, including `record struct` types, do not support inheritance at all.
    One reason for this is that value types are not normally used by reference, which
    removes one of the main benefits of inheritance: runtime polymorphism. Inheritance
    is not necessarily incompatible with value-like behavior—some languages manage
    it—but it often has problems. For example, assigning a value of some derived type
    into a variable of its base type ends up losing all of the fields that the derived
    type added, a problem known as *slicing*. C# sidesteps this by restricting inheritance
    to reference types. When you assign a variable of some derived type into a variable
    of a base type, you’re copying a reference, not the object itself, so the object
    remains intact. Slicing is an issue only if the base class offers a method that
    clones the object and doesn’t provide a way for derived classes to extend that
    (or it does, but some derived class fails to extend it).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 类和基于类的记录类型仅支持单一继承（因此只能指定一个基类）。接口提供了一种多重继承的形式。值类型，包括`record struct`类型，根本不支持继承。其中一个原因是值类型通常不通过引用使用，这就移除了继承的主要好处之一：运行时多态性。继承与值类型的行为不一定不兼容——某些语言可以处理它——但通常存在问题。例如，将某个派生类型的值赋给其基类型的变量将导致丢失派生类型添加的所有字段，这是一个被称为*slicing*的问题。C#通过将继承限制为引用类型来避免这个问题。当你将某个派生类型的变量赋给基类型的变量时，你复制的是一个引用，而不是对象本身，因此对象保持完整。Slicing仅在基类提供了克隆对象的方法且未提供派生类扩展它的方法时出现问题（或者提供了，但某个派生类未扩展它）。
- en: Classes specify a base class using the syntax shown in [Example 6-1](#specifying_a_base_class)—the
    base type appears after a colon that follows the class name. This example assumes
    that a class called `SomeClass` has been defined elsewhere in the project, or
    one of the libraries it uses.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 类使用在[示例6-1](#specifying_a_base_class)中展示的语法来指定基类——基类型出现在紧随类名后的冒号之后。本示例假设在项目的其他地方或其使用的库中已经定义了一个名为`SomeClass`的类。
- en: Example 6-1\. Specifying a base class
  id: totrans-4
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-1 指定一个基类
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you saw in [Chapter 3](ch03.xhtml#ch_types), if the class implements any
    interfaces, these are also listed after the colon. If you want to derive from
    a class, and you want to implement interfaces as well, the base class must appear
    first, as the second class in [Example 6-1](#specifying_a_base_class) illustrates.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如同你在[第3章](ch03.xhtml#ch_types)看到的那样，如果类实现了任何接口，这些接口也会在冒号后列出。如果你想要从一个类派生，并且还想实现接口，基类必须首先出现，正如[示例6-1](#specifying_a_base_class)所示。
- en: You can derive from a class that in turn derives from another class. The `MoreDerived`
    class in [Example 6-2](#inheritance_chain) derives from `Derived`, which in turn
    derives from `Base`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从一个又从另一个类派生的类派生。[示例6-2](#inheritance_chain)中的`MoreDerived`类派生自`Derived`，后者又派生自`Base`。
- en: Example 6-2\. Inheritance chain
  id: totrans-8
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-2 继承链
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This means that `MoreDerived` technically has multiple base classes: it derives
    from both `Derived` (directly) and `Base` (indirectly, via `Derived`). This is
    not multiple inheritance because there is only a single chain of inheritance—any
    single class derives directly from at most one base class. (All classes derive
    either directly or indirectly from `object`, which is the default base class if
    you do not specify one.)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`MoreDerived`从技术上讲具有多个基类：它直接从`Derived`派生，间接从`Base`派生（通过`Derived`）。这不是多重继承，因为只有一个继承链——任何单个类最多直接从一个基类派生。（所有类都直接或间接地从`object`派生，如果你没有指定基类，则默认为基类。）
- en: Since a derived class inherits everything the base class has—all its fields,
    methods, and other members, both public and private—an instance of the derived
    class can do anything an instance of the base class could do. This is the classic
    *is a* relationship that inheritance implies in many languages. Any instance of
    `MoreDerived` is a `Derived` and also a `Base`. C#’s type system recognizes this
    relationship.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于派生类继承了基类的所有内容——包括所有字段、方法和其他成员，无论是公有的还是私有的——因此，派生类的一个实例可以执行基类实例可以执行的所有操作。这是许多语言中继承所暗示的经典的*是一个*关系。任何`MoreDerived`的实例都是`Derived`的实例，也是`Base`的实例。C#的类型系统认识到这种关系。
- en: Inheritance and Conversions
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承与转换
- en: 'C# provides various built-in implicit conversions. In [Chapter 2](ch02.xhtml#ch_basic_coding),
    we saw the conversions for numeric types, but there are also ones for reference
    types. If some type `D` derives from `B` (either directly or indirectly), then
    a reference of type `D` can be converted implicitly to a reference of type `B`.
    This follows from the *is a* relationship I described in the preceding section—any
    instance of `D` is a `B`. This implicit conversion enables polymorphism: code
    written to work in terms of `B` will be able to work with any type derived from
    `B`.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: C# 提供了各种内置的隐式转换。在[第 2 章](ch02.xhtml#ch_basic_coding)中，我们看到数字类型的转换，但引用类型也有转换。如果某个类型`D`从`B`派生（直接或间接），那么类型`D`的引用可以隐式地转换为类型`B`的引用。这是基于我在前一节中描述的*是一个*关系——任何`D`的实例都是`B`。这种隐式转换使多态成为可能：编写的针对`B`的代码将能够与任何从`B`派生的类型一起工作。
- en: Implicit reference conversions are special. Unlike other conversions, they do
    not change the value in any way. (The built-in implicit numeric conversions all
    create a new value from their input, often involving a change of representation.
    The binary representation of the integer 1 looks different for the `float` and
    `int` types, for example.) In effect, they convert the interpretation of the reference,
    rather than converting the reference itself or the object it refers to. As you’ll
    see later in this chapter, there are various places where the CLR will take the
    availability of an implicit reference conversion into account but will not consider
    other forms of conversion.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式引用转换是特殊的。与其他转换不同，它们不会以任何方式改变值。（所有内置的隐式数字转换都会从其输入创建一个新值，通常涉及表示的变化。例如，整数 1 的二进制表示对于`float`和`int`类型是不同的。）实际上，它们转换的是引用的解释，而不是引用本身或它所引用的对象。正如你将在本章后面看到的，CLR
    在考虑隐式引用转换的可用性时，会考虑到这些地方，但不会考虑其他形式的转换。
- en: Warning
  id: totrans-15
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: A custom implicit conversion between two reference types doesn’t count as an
    implicit reference conversion for these purposes, because a method needs to be
    invoked to effect such a conversion. The cases in which implicit reference conversions
    are special rely on the fact that the “conversion” requires no work at runtime.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 两个引用类型之间的自定义隐式转换不算作这些目的的隐式引用转换，因为需要调用方法来实现这样的转换。在隐式引用转换的特殊情况中，依赖于“转换”在运行时无需工作这一事实。
- en: There is no implicit conversion in the opposite direction—although a variable
    of type `B` could refer to an object of type `D`, there’s no guarantee that it
    will. There could be any number of types derived from `B`, and a `B` variable
    could refer to an instance of any of them. Nevertheless, you will sometimes want
    to attempt to convert a reference from a base type to a derived type, an operation
    sometimes referred to as a *downcast*. Perhaps you know for a fact that a particular
    variable holds a reference of a certain type. Or perhaps you’re not sure and would
    like your code to provide additional services for specific types. C# offers three
    ways to do this.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 反向没有隐式转换——虽然一个类型为`B`的变量可以引用类型为`D`的对象，但不能保证它会这样做。可能有任意数量从`B`派生的类型，一个`B`变量可以引用它们中的任何一个实例。然而，有时你可能希望尝试将引用从基类型转换为派生类型，这种操作有时称为*下转型*。也许你知道某个变量确实持有某种类型的引用。或者你不确定，希望你的代码为特定类型提供额外的服务。C#
    提供了三种方法来执行此操作。
- en: We can attempt a downcast using the cast syntax. This is the same syntax we
    use for performing nonimplicit numeric conversions, as [Example 6-3](#feeling_downcast)
    shows.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用强制转换语法尝试进行下转型。这是我们用于执行非隐式数字转换的相同语法，如[示例 6-3](#feeling_downcast)所示。
- en: Example 6-3\. Feeling downcast
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-3\. 感觉下转型
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This conversion is not guaranteed to succeed—that’s why we can’t use an implicit
    conversion. If you try this when the `baseArg` argument refers to something that’s
    neither an instance of `Derived` nor something derived from `Derived`, the conversion
    will fail, throwing an `InvalidCastException`. (Exceptions are described in [Chapter 8](ch08.xhtml#ch_exceptions).)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这种转换不能保证成功——这就是为什么我们不能使用隐式转换。如果在`baseArg`参数引用的对象既不是`Derived`的实例，也不是`Derived`的派生类时尝试这样做，转换将失败，抛出`InvalidCastException`（异常在[第 8 章](ch08.xhtml#ch_exceptions)中描述）。
- en: A cast is therefore appropriate only if you’re confident that the object really
    is of the type you expect, and you would consider it to be an error if it turned
    out not to be. This is useful when an API accepts an object that it will later
    give back to you. Many asynchronous APIs do this, because in cases where you launch
    multiple operations concurrently, you need some way of working out which particular
    one finished when you get a completion notification (although, as we’ll see in
    later chapters, there are various ways to tackle that problem). Since these APIs
    don’t know what sort of data you’ll want to associate with an operation, they
    usually just take a reference of type `object`, and you would typically use a
    cast to turn it back into a reference of the required type when the reference
    is eventually handed back to you.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当你确信对象确实是你期望的类型时，才适合使用转换。如果对象类型不符合预期，你将认为这是一个错误。当API接受一个稍后将返回给你的对象时，这很有用。许多异步API会这样做，因为在同时启动多个操作的情况下，当你收到完成通知时，需要一种方法来确定哪个操作已经完成（尽管正如我们将在后面的章节中看到的，有各种方法来解决这个问题）。由于这些API不知道你将要关联到操作的数据类型，它们通常只接受`object`类型的引用，当引用最终交还给你时，你通常会使用转换将其转换回所需类型的引用。
- en: Sometimes, you will not know for certain whether an object has a particular
    type. In this case, you can use the `as` operator instead, as shown in [Example 6-4](#the_as_operator).
    This allows you to attempt a conversion without risking an exception. If the conversion
    fails, this operator just returns `null`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你不能确定一个对象是否具有特定类型。在这种情况下，你可以使用`as`运算符，如[示例 6-4](#the_as_operator)所示。这允许你尝试转换而不会引发异常。如果转换失败，该运算符将返回`null`。
- en: Example 6-4\. The `as` operator
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-4\. `as`运算符
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Although this technique is quite common in existing code, the introduction
    of patterns back in C# 7.0 provided a more succinct alternative. [Example 6-5](#is_operator_with_declaration_pattern)
    has the same effect as [Example 6-4](#the_as_operator): the body of the `if` runs
    only if `b` refers to an instance of `Derived`, in which case it can be accessed
    through the variable `d`. The `is` keyword here indicates that we want to test
    `b` against a pattern. In this case we’re using a declaration pattern, which performs
    the same runtime type test as the `as` operator. An expression that applies a
    pattern with `is` produces a `bool` indicating whether the pattern matches. We
    can use this as the `if` statement’s condition expression, removing the need to
    compare with `null`. And since declaration patterns incorporate variable declaration
    and initialization, the work that needed two statements in [Example 6-4](#the_as_operator)
    can all be rolled into the `if` statement in [Example 6-5](#is_operator_with_declaration_pattern).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种技术在现有代码中非常常见，但在C# 7.0中引入的模式提供了一种更简洁的替代方法。[示例 6-5](#is_operator_with_declaration_pattern)与[示例 6-4](#the_as_operator)具有相同的效果：只有在`b`引用`Derived`的实例时，`if`语句的主体才会执行，并且可以通过变量`d`访问它。此处的`is`关键字表示我们想要对`b`进行模式测试。在这种情况下，我们使用的是声明模式，它执行与`as`运算符相同的运行时类型测试。应用带有`is`的模式的表达式生成一个`bool`，指示模式是否匹配。我们可以将此用作`if`语句的条件表达式，无需与`null`进行比较。由于声明模式包含变量声明和初始化，[示例 6-4](#the_as_operator)中需要两个语句的工作都可以合并到[示例 6-5](#is_operator_with_declaration_pattern)的`if`语句中。
- en: Example 6-5\. The `is` operator with a declaration pattern
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-5\. 带有声明模式的`is`运算符
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In addition to being more compact, the `is` operator also has the benefit of
    working in one scenario where `as` does not: you can test whether a reference
    of type `object` refers to an instance of a value type such as an `int`. (This
    may seem like a contradiction—how could you have a reference to something that
    is not a reference type? [Chapter 7](ch07.xhtml#ch_object_lifetime) will show
    how this is possible.) The `as` operator wouldn’t work because it returns `null`
    when the instance is not of the specified type, but of course it cannot do that
    for a value type—there’s no such thing as a `null` of type `int`. Since the declaration
    pattern eliminates the need to test for `null`—we just use the `bool` result that
    the `is` operator produces—we are free to use value types.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更紧凑外，`is`运算符还有一个好处，即在`as`不起作用的一个情况下也可以起作用：您可以测试类型为`object`的引用是否引用值类型的实例，例如`int`。（这可能看起来有些矛盾——您怎么可能有一个指向不是引用类型的东西的引用？[第7章](ch07.xhtml#ch_object_lifetime)将展示这是可能的。）`as`运算符不起作用，因为当实例不是指定类型时它返回`null`，但是当然它不能对值类型执行此操作——没有`int`类型的`null`。由于声明模式消除了对`null`的测试的需要——我们只使用`is`运算符生成的`bool`结果——我们可以自由使用值类型。
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Occasionally you may want to detect when a particular type is present without
    needing to perform a conversion. Since `is` can be followed by any pattern, you
    can use a type pattern, e.g., `is Derived`. This performs the same test as a declaration
    pattern, without going on to introduce a new variable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔您可能希望检测特定类型是否存在，而无需执行转换。由于`is`可以跟随任何模式，因此您可以使用类型模式，例如，`is Derived`。这执行与声明模式相同的测试，而无需引入新变量。
- en: When converting with the techniques just described, you don’t necessarily need
    to specify the exact type. These operations will succeed as long as an implicit
    reference conversion exists from the object’s real type to the type you’re looking
    for. For example, given the `Base`, `Derived`, and `MoreDerived` types that [Example 6-2](#inheritance_chain)
    defines, suppose you have a variable of type `Base` that currently contains a
    reference to an instance of `MoreDerived`. Obviously, you could cast the reference
    to `MoreDerived` (and both `as` and `is` would also succeed for that type), but
    as you’d probably expect, converting to `Derived` would work too.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用刚才描述的技术进行转换时，不一定需要指定确切的类型。只要对象的真实类型到您要查找的类型之间存在隐式引用转换，这些操作就会成功。例如，假设您有一个类型为`Base`的变量，当前包含对`MoreDerived`实例的引用。显然，您可以将引用转换为`MoreDerived`（对于该类型，`as`和`is`也会成功），但正如您可能期望的那样，转换为`Derived`也可以工作。
- en: These four mechanisms also work for interfaces. When you try to convert a reference
    to an interface type reference (or test for an interface type with a type pattern),
    it will succeed if the object referred to implements the relevant interface.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这四种机制也适用于接口。当您尝试将引用转换为接口类型的引用（或使用类型模式测试接口类型）时，如果所引用的对象实现了相关接口，则转换将成功。
- en: Interface Inheritance
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口继承
- en: Interfaces support inheritance, but it’s not quite the same as class inheritance.
    The syntax is similar, but as [Example 6-6](#interface_inheritance-id1) shows,
    an interface can specify multiple base interfaces. While .NET offers only single
    implementation inheritance, this limitation does not apply to interfaces because
    most of the complications and potential ambiguities that can arise with multiple
    inheritance do not apply to purely abstract types. The most vexing problems are
    around handling of fields, which means that even interfaces with default implementations
    support multiple inheritance, because those don’t get to add either fields or
    public members to the implementing type. (When a class uses a default implementation
    for a member, that member is accessible only through references of the interface’s
    type.)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接口支持继承，但与类继承并不完全相同。语法类似，但正如[示例 6-6](#interface_inheritance-id1)所示，接口可以指定多个基接口。虽然.NET仅提供单一实现继承，但这种限制不适用于接口，因为大多数可能导致多重继承的复杂性和潜在歧义都不适用于纯抽象类型。最棘手的问题围绕着字段的处理，这意味着即使具有默认实现的接口也支持多重继承，因为这些接口不能向实现类型添加字段或公共成员。（当类使用成员的默认实现时，该成员只能通过接口类型的引用访问。）
- en: Example 6-6\. Interface inheritance
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-6\. 接口继承
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Although *interface inheritance* is the official name for this feature, it is
    a misnomer—whereas derived classes inherit all members from their base, derived
    interfaces do not. It may appear that they do—given a variable of type `IBoth`,
    you can invoke the `Base1Method` and `Base2Method` methods defined by its bases.
    However, the true meaning of interface inheritance is that any type that implements
    an interface is obliged to implement all inherited interfaces. So a class that
    implements `IBoth` must also implement `IBase1` and `IBase2`. It’s a subtle distinction,
    especially since C# does not require you to list the base interfaces explicitly.
    The class in [Example 6-7](#implementing_a_derived_interface) only declares that
    it implements `IBoth`. However, if you were to use .NET’s reflection API, to inspect
    the type definition, you would find that the compiler has added `IBase1` and `IBase2`
    to the list of interfaces the class implements as well as the explicitly declared
    `IBoth`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 *接口继承* 是这个特性的官方名称，但这是一个误称——尽管派生类从它们的基类继承所有成员，派生接口却不是这样。看起来它们似乎是这样的——给定类型为
    `IBoth` 的变量，你可以调用由其基类定义的 `Base1Method` 和 `Base2Method` 方法。然而，接口继承的真正含义是，实现一个接口的任何类型都有义务实现所有继承的接口。因此，实现
    `IBoth` 的类必须同时实现 `IBase1` 和 `IBase2`。这是一个微妙的区别，特别是因为 C# 不要求你显式列出基接口。在 [示例 6-7](#implementing_a_derived_interface)
    中的类仅声明它实现了 `IBoth`。然而，如果你使用 .NET 的反射 API 来检查类型定义，你会发现编译器已将 `IBase1` 和 `IBase2`
    添加到类实现的接口列表中，以及显式声明的 `IBoth`。
- en: Example 6-7\. Implementing a derived interface
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-7\. 实现一个派生接口
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Since implementations of a derived interface must implement all base interfaces,
    C# lets you access bases’ members directly through a reference of a derived type,
    so a variable of type `IBoth` provides access to `Base1Method` and `Base2Method`,
    as well as that interface’s own `Method3`. Implicit reference conversions exist
    from derived interface types to their bases. For example, a reference of type
    `IBoth` can be assigned to variables of type `IBase1` and `IBase2`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于派生接口的实现必须实现所有基接口，C# 允许你通过派生类型的引用直接访问基类的成员，因此类型为 `IBoth` 的变量提供了对 `Base1Method`
    和 `Base2Method` 的访问，以及该接口自身的 `Method3`。从派生接口类型到它们的基类存在隐式引用转换。例如，类型为 `IBoth` 的引用可以分配给类型为
    `IBase1` 和 `IBase2` 的变量。
- en: Generics
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型
- en: If you derive from a generic class, you must supply the type arguments it requires.
    If your derived type is also generic, it can use its own type parameters as arguments
    if you wish, as long as they meet any constraints the base class defines. [Example 6-8](#deriving_from_a_generic_base_class)
    shows both techniques and also illustrates that when deriving from a class with
    multiple type parameters, you can use a mixture, specifying one type argument
    directly and punting on the other.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从一个泛型类派生，你必须提供它所需的类型参数。如果你的派生类型也是泛型的，你可以选择使用自己的类型参数作为参数，只要它们符合基类定义的任何约束。[示例
    6-8](#deriving_from_a_generic_base_class) 展示了这两种技术，并且还说明了当从具有多个类型参数的类派生时，你可以使用混合方法，直接指定一个类型参数，对另一个类型参数则放任不管。
- en: Example 6-8\. Deriving from a generic base class
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-8\. 从泛型基类派生
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Although you are free to use any of your type parameters as type arguments for
    a base class, you cannot derive from a type parameter. This is a little disappointing
    if you are used to languages that permit such things, but the C# language specification
    simply forbids it. However, you are allowed to use your own type as a type argument
    to your base class. And you can also specify a constraint on a type argument,
    requiring it to derive from your own type. [Example 6-9](#curious_patterns) shows
    each of these.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以自由地将任何类型参数用作基类的类型参数，但你不能从类型参数派生。如果你习惯于允许这样做的语言，这可能有点令人失望，但是 C# 语言规范明确禁止这样做。然而，你可以使用自己的类型作为基类的类型参数。你还可以为类型参数指定约束，要求它必须从你自己的类型派生。[示例
    6-9](#curious_patterns) 展示了这些情况。
- en: Example 6-9\. Self-referential type arguments
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-9\. 自引用类型参数
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Covariance and Contravariance
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协变性和逆变性
- en: In [Chapter 4](ch04.xhtml#ch_generics), I mentioned that generic types have
    special rules for type compatibility, referred to as *covariance* and *contravariance*.
    These rules determine whether references of certain generic types are implicitly
    convertible to one another when implicit conversions exist between their type
    arguments.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 4 章](ch04.xhtml#ch_generics) 中，我提到泛型类型有特殊的类型兼容规则，称为 *协变性* 和 *逆变性*。这些规则确定了当类型参数之间存在隐式转换时，某些泛型类型的引用是否可以相互隐式转换。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注：
- en: Covariance and contravariance are applicable only to the generic type arguments
    of interfaces and delegates. (Delegates are described in [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events).)
    You cannot define a covariant or contravariant class, struct, or record.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 协变和逆变仅适用于接口和委托的泛型类型参数。（委托在[第9章](ch09.xhtml#ch_delegates_lambdas_events)中描述。）你不能定义协变或逆变的类、结构体或记录。
- en: Consider the simple `Base` and `Derived` classes shown earlier in [Example 6-2](#inheritance_chain),
    and look at the method in [Example 6-10](#a_method_accepting_any_base), which
    accepts any `Base`. (It does nothing with it, but that’s not relevant here—what
    matters is what its signature says it can use.)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑前面[示例 6-2](#inheritance_chain)中展示的简单的 `Base` 和 `Derived` 类，并查看接受任何 `Base`
    的方法[示例 6-10](#a_method_accepting_any_base)。 （它对它什么都不做，但这里重要的是它的签名说它可以使用什么。）
- en: Example 6-10\. A method accepting any `Base`
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-10\. 接受任何 `Base` 的方法
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We already know that as well as accepting a reference to any `Base`, this can
    also accept a reference to an instance of any type derived from `Base`, such as
    `Derived`. Bearing that in mind, consider the method in [Example 6-11](#a_method_accepting_any_ienumerable_base).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道，除了接受任何 `Base` 的引用外，这也可以接受任何从 `Base` 派生的类型的实例，比如 `Derived`。考虑一下[示例 6-11](#a_method_accepting_any_ienumerable_base)
    中的方法。
- en: Example 6-11\. A method accepting any `IEnumerable<Base>`
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-11\. 接受任何 `IEnumerable<Base>` 的方法
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This requires an object that implements the `IEnumerable<T>` generic interface
    described in [Chapter 5](ch05.xhtml#ch_collections), where `T` is `Base`. What
    would you expect to happen if we attempted to pass an object that did not implement
    `IEnumerable<Base>` but did implement `IEnumerable<Derived>`? [Example 6-12](#passing_an_ienumerable_of_a_derived_t)
    does this, and it compiles just fine.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一个实现了[第5章](ch05.xhtml#ch_collections)中描述的 `IEnumerable<T>` 泛型接口的对象，其中 `T`
    是 `Base`。如果我们尝试传递一个未实现 `IEnumerable<Base>` 但实现了 `IEnumerable<Derived>` 的对象，你认为会发生什么？[示例 6-12](#passing_an_ienumerable_of_a_derived_t)
    就这样做了，并且编译通过。
- en: Example 6-12\. Passing an `IEnumerable<T>` of a derived type
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-12\. 传递一个派生类型的 `IEnumerable<T>`
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Intuitively, this makes sense. The `AllYourBase` method is expecting an object
    that can supply a sequence of objects that are all of type `Base`. An `IEnumerable<Derived>`
    fits the bill because it supplies a sequence of `Derived` objects, and any `Derived`
    object is also a `Base`. However, what about the code in [Example 6-13](#method_accepting_any_icollectionofbase)?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 从直觉上讲，这是有道理的。`AllYourBase` 方法期望一个能够提供类型为 `Base` 的对象序列的对象。`IEnumerable<Derived>`
    符合要求，因为它提供了 `Derived` 对象的序列，而任何 `Derived` 对象也都是 `Base`。但是，关于[示例 6-13](#method_accepting_any_icollectionofbase)中的代码呢？
- en: Example 6-13\. A method accepting any `ICollection<Base>`
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-13\. 接受任何 `ICollection<Base>` 的方法
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Recall from [Chapter 5](ch05.xhtml#ch_collections) that `ICollection<T>` derives
    from `IEnumerable<T>`, and it adds the ability to modify the collection in certain
    ways. This particular method exploits that by adding a new `Base` object to the
    collection. That would mean trouble for the code in [Example 6-14](#error_trying_to_pass_an_icollection).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第5章](ch05.xhtml#ch_collections)中提到的 `ICollection<T>` 派生自 `IEnumerable<T>`，并且它添加了以某些方式修改集合的能力。这个特定的方法通过向集合中添加一个新的
    `Base` 对象来利用这一点。对于[示例 6-14](#error_trying_to_pass_an_icollection) 中的代码来说，这将是个麻烦。
- en: 'Example 6-14\. Error: trying to pass an `ICollection<T>` with a derived type'
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-14\. 错误：尝试传递一个带有派生类型的 `ICollection<T>`
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Code that uses the `derivedList` variable will expect every object in that list
    to be of type `Derived` (or something derived from it, such as the `MoreDerived`
    class from [Example 6-2](#inheritance_chain)). But the `AddBase` method in [Example 6-13](#method_accepting_any_icollectionofbase)
    attempts to add a plain `Base` instance. That cannot be correct, and the compiler
    does not allow it. The call to `AddBase` will produce a compiler error complaining
    that references of type `ICollection<Derived>` cannot be converted implicitly
    to references of type `ICollection<Base>`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `derivedList` 变量的代码将期望该列表中的每个对象都是 `Derived` 类型（或者从中派生的类型，比如[示例 6-2](#inheritance_chain)中的
    `MoreDerived` 类）。但是 [示例 6-13](#method_accepting_any_icollectionofbase) 中的 `AddBase`
    方法尝试添加一个普通的 `Base` 实例。这是不正确的，编译器也不允许这样做。调用 `AddBase` 将产生编译器错误，指出 `ICollection<Derived>`
    类型的引用不能隐式转换为 `ICollection<Base>` 类型的引用。
- en: How does the compiler know that it’s not OK to do this, while the very similar-looking
    conversion from `IEnumerable<Derived>` to `IEnumerable<Base>` is allowed? It’s
    not because [Example 6-13](#method_accepting_any_icollectionofbase) contains code
    that would cause a problem, by the way. You’d get the same compiler error even
    if the `AddBase` method were completely empty. The reason we don’t get an error
    in [Example 6-12](#passing_an_ienumerable_of_a_derived_t) is that the `IEnumerable<T>`
    interface declares its type argument `T` as covariant. You saw the syntax for
    this in [Chapter 5](ch05.xhtml#ch_collections), but I didn’t draw attention to
    it, so [Example 6-15](#covariant_type_parameter) shows the relevant part from
    that interface’s definition again.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器是如何知道这是不允许的，而非常相似的从`IEnumerable<Derived>`到`IEnumerable<Base>`的转换却是允许的？顺便说一句，并不是因为[示例 6-13](#method_accepting_any_icollectionofbase)包含可能引起问题的代码。即使`AddBase`方法完全为空，你仍然会得到相同的编译器错误。之所以在[示例 6-12](#passing_an_ienumerable_of_a_derived_t)中没有错误，是因为`IEnumerable<T>`接口将其类型参数`T`声明为协变。你在[第五章](ch05.xhtml#ch_collections)中看到了这种语法，但我并没有特别强调，因此[示例 6-15](#covariant_type_parameter)再次展示了该接口定义中相关的部分。
- en: Example 6-15\. Covariant type parameter
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-15\. 协变类型参数
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'That `out` keyword does the job. (Again, C# keeps up the C-family tradition
    of giving each keyword multiple jobs—we first saw this keyword in the context
    of method parameters that can return information to the caller.) Intuitively,
    describing the type argument `T` as “out” makes sense, in that the `IEnumerable<T>`
    interface only ever *provides* a `T`—it does not define any members that *accept*
    a `T`. (The interface uses this type parameter in just one place: its read-only
    `Current` property.)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 那个`out`关键字完成了任务。（同样，C#延续了C家族传统，为每个关键字赋予多种功能——我们首次在方法参数返回信息给调用者的情境中见到此关键字。直观地说，将类型参数`T`描述为“out”是有意义的，因为`IEnumerable<T>`接口只*提供*了`T`—它并不定义任何*接受*`T`的成员。（该接口仅在一个地方使用了这个类型参数：它的只读`Current`属性。
- en: Compare that with `ICollection<T>`. This derives from `IEnumerable<T>`, so clearly
    it’s possible to get a `T` out of it, but it’s also possible to pass a `T` into
    its `Add` method. So `ICollection<T>` cannot annotate its type argument with `out`.
    (If you were to try to write your own similar interface, the compiler would produce
    an error if you declared the type argument as being covariant. Rather than just
    taking your word for it, it checks to make sure you really can’t pass a `T` in
    anywhere.)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与`ICollection<T>`进行比较。这个接口从`IEnumerable<T>`派生，因此显然可以从中获取`T`，但也可以将`T`传递给其`Add`方法。因此，`ICollection<T>`不能使用`out`注释其类型参数。（如果您尝试编写自己的类似接口，如果您声明类型参数为协变，编译器将产生错误。它不仅仅是凭您的话，而是检查确实不能在任何地方传递`T`。）
- en: 'The compiler rejects the code in [Example 6-14](#error_trying_to_pass_an_icollection)
    because `T` is not covariant in `ICollection<T>`. The terms *covariant* and *contravariant*
    come from a branch of mathematics called *category theory*. The parameters that
    behave like `IEnumerable<T>`’s `T` are called covariant because implicit reference
    conversions for the generic type work in the same direction as conversions for
    the type argument: `Derived` is implicitly convertible to `Base`, and since `T`
    is covariant in `IEnumerable<T>`, `IEnumerable<Derived>` is implicitly convertible
    to `IEnumerable<Base>`.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器拒绝[示例 6-14](#error_trying_to_pass_an_icollection)中的代码，因为`ICollection<T>`中的`T`不是协变的。术语*协变*和*逆变*来自数学中的*范畴论*分支。类似`IEnumerable<T>`的`T`行为的参数被称为协变，因为泛型类型的隐式引用转换与类型参数的转换方向相同：`Derived`可以隐式转换为`Base`，并且由于`IEnumerable<T>`中的`T`是协变的，`IEnumerable<Derived>`隐式转换为`IEnumerable<Base>`。
- en: Contravariance works the other way around, and as you might guess, we denote
    it with the `in` keyword. It’s easiest to see this in action with code that uses
    members of types, so [Example 6-16](#class_hierarchy_with_actual_members) shows
    a marginally more interesting pair of classes than the earlier examples.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 逆变工作方式相反，并且你可能会猜到，我们用`in`关键字表示它。使用类型成员的代码最容易看到它的实际作用，因此[示例 6-16](#class_hierarchy_with_actual_members)展示了一对稍微有趣的类，比之前的示例稍有不同。
- en: Example 6-16\. Class hierarchy with actual members
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-16\. 带有实际成员的类层次结构
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Example 6-17](#comparing_shapes) defines two classes that use these shape
    types. Both implement `IComparer<T>`, which I introduced in [Chapter 4](ch04.xhtml#ch_generics).
    The `BoxAreaComparer` compares two shapes based on the area of their bounding
    box—the shape whose bounding box covers the greater area will be deemed the larger
    by this comparison. The `CornerSharpnessComparer`, on the other hand, compares
    rounded rectangles by looking at how pointy their corners are.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-17](#comparing_shapes) 定义了两个使用这些形状类型的类。它们都实现了我在[第 4 章](ch04.xhtml#ch_generics)中介绍的
    `IComparer<T>`。`BoxAreaComparer` 根据其边界框的面积比较两个形状 —— 边界框覆盖面积较大的形状将被认为比较大。另一方面，`CornerSharpnessComparer`
    比较圆角矩形，看它们的角有多尖。'
- en: Example 6-17\. Comparing shapes
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-17\. 比较形状
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: References of type `RoundedRectangle` are implicitly convertible to `Shape`,
    so what about `IComparer<T>`? Our `BoxAreaComparer` can compare any shapes and
    declares this by implementing `IComparer<Shape>`. The comparer’s type argument
    `T` is only ever used in the `Compare` method, and that is happy to be passed
    any `Shape`. It will not be fazed if we pass it a pair of `RoundedRectangle` references,
    so our class is a perfectly adequate `IComparer<RoundedRectangle>`. An implicit
    conversion from `IComparer<Shape>` to `IComparer<RoundedRectangle>` therefore
    makes sense, and is in fact allowed. However, the `CornerSharpnessComparer` is
    fussier. It uses the `CornerRadius` property, which is available only on rounded
    rectangles, not on any old `Shape`. Therefore, no implicit conversion exists from
    `IComparer<RoundedRectangle>` to `IComparer<Shape>`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`RoundedRectangle` 类型的引用隐式转换为 `Shape`，那么`IComparer<T>`呢？我们的 `BoxAreaComparer`
    可以比较任何形状，并通过实现 `IComparer<Shape>` 声明了这一点。比较器的类型参数 `T` 只在 `Compare` 方法中使用，它可以接受任何
    `Shape`。如果我们传递一对 `RoundedRectangle` 引用，它也不会感到困惑，因此我们的类完全可以作为 `IComparer<RoundedRectangle>`。因此，从
    `IComparer<Shape>` 到 `IComparer<RoundedRectangle>` 的隐式转换是有意义的，并且实际上是允许的。然而，`CornerSharpnessComparer`
    更挑剔。它使用 `CornerRadius` 属性，该属性仅在圆角矩形上可用，而不是在任何旧的 `Shape` 上。因此，从 `IComparer<RoundedRectangle>`
    到 `IComparer<Shape>` 不存在隐式转换。'
- en: 'This is the reverse of what we saw with `IEnumerable<T>`. Implicit conversion
    is available between `IEnumerable<T1>` and `IEnumerable<T2>` when an implicit
    reference conversion from `T1` to `T2` exists. But implicit conversion between
    `IComparer<T1>` and `IComparer<T2>` is available when an implicit reference conversion
    exists in the other direction: from `T2` to `T1`. That reversed relationship is
    called contravariance. [Example 6-18](#contravariant_type_parameter) is an excerpt
    of the definition for `IComparer<T>` showing this contravariant type parameter.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在`IEnumerable<T>`中看到的情况正好相反。当存在从 `T1` 到 `T2` 的隐式引用转换时，`IEnumerable<T1>`
    和 `IEnumerable<T2>` 之间可以进行隐式转换。但是在 `IComparer<T>` 和 `IComparer<T2>` 之间的隐式转换则是在另一个方向上存在隐式引用转换：从
    `T2` 到 `T1`。这种反向关系称为逆变。[示例 6-18](#contravariant_type_parameter) 是 `IComparer<T>`
    的定义摘录，显示了这种逆变类型参数。
- en: Example 6-18\. Contravariant type parameter
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-18\. 逆变类型参数
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Most generic type parameters are neither covariant nor contravariant. (They
    are *invariant*.) `ICollection<T>` cannot be variant, because it contains some
    members that accept a `T` and some that return one. An `ICollection<Shape>` might
    contain shapes that are not `RoundedRectangles`, so you cannot pass it to a method
    expecting an `ICollection<RoundedRectangle>`, because such a method would expect
    every object it retrieves from the collection to be a rounded rectangle. Conversely,
    an `ICollection<RoundedRectangle>` cannot be expected to allow shapes other than
    rounded rectangles to be added, and so you cannot pass an `ICo⁠lle⁠cti⁠on<⁠Rou⁠nde⁠d​Rec⁠tan⁠gle>`
    to a method that expects an `ICollection<Shape>` because that method may try to
    add other kinds of shapes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数泛型类型参数既不是协变也不是逆变（它们是*不变*的）。`ICollection<T>` 不能是变体，因为它包含一些接受 `T` 的成员和一些返回
    `T` 的成员。`ICollection<Shape>` 可能包含不是 `RoundedRectangles` 的形状，所以你不能将它传递给一个期望 `ICollection<RoundedRectangle>`
    的方法，因为这样的方法会期望从集合检索到的每个对象都是圆角矩形。相反，`ICollection<RoundedRectangle>` 不能期望允许添加除了圆角矩形之外的形状，所以你不能将
    `ICollection<RoundedRectangle>` 传递给一个期望 `ICollection<Shape>` 的方法，因为该方法可能尝试添加其他类型的形状。
- en: Arrays are covariant, just like `IEnumerable<T>`. This is rather odd, because
    we can write methods like the one in [Example 6-19](#changing_an_element_in_an_array).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是协变的，就像`IEnumerable<T>`一样。这很奇怪，因为我们可以编写像[示例 6-19](#changing_an_element_in_an_array)中的方法一样。
- en: Example 6-19\. Changing an element in an array
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-19\. 修改数组中的元素
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If I were to call this with the code in [Example 6-20](#passing_an_array_with_derived_element_ty),
    I would be making the same mistake as I did in [Example 6-14](#error_trying_to_pass_an_icollection),
    where I attempted to pass an `ICollection<Derived>` to a method that wanted to
    put something that was not `Derived` into the collection. But while [Example 6-14](#error_trying_to_pass_an_icollection)
    does not compile, [Example 6-20](#passing_an_array_with_derived_element_ty) does,
    due to the surprising covariance of arrays.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我试图使用[Example 6-20](#passing_an_array_with_derived_element_ty)中的代码调用此方法，我将犯与[Example 6-14](#error_trying_to_pass_an_icollection)相同的错误，那里我试图将`ICollection<Derived>`传递给一个试图将不是`Derived`的东西放入集合中的方法。但是，虽然[Example 6-14](#error_trying_to_pass_an_icollection)不能编译，[Example 6-20](#passing_an_array_with_derived_element_ty)却可以，这归因于数组的令人惊讶的协变性。
- en: Example 6-20\. Passing an array with derived element type
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 6-20\. 传递一个具有派生元素类型的数组
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This makes it look as though we could sneakily make this array accept a reference
    to an object that is not an instance of the array’s element type—in this case,
    putting a reference to a non-`Derived` object, `Base`, in `Derived[]`. But that
    would be a violation of the type system. Does this mean the sky is falling?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得看起来我们可以偷偷地让这个数组接受一个不是数组元素类型实例的引用——在这种情况下，将一个`Base`的引用放入`Derived[]`中。但这将违反类型系统。这是否意味着天要塌下来了？
- en: In fact, C# correctly forbids such a violation, but it relies on the CLR to
    enforce this at runtime. Although a reference to an array of type `Derived[]`
    can be implicitly converted to a reference of type `Base[]`, any attempt to set
    an array element in a way that is inconsistent with the type system will throw
    an `ArrayTypeMismatchException`. So [Example 6-19](#changing_an_element_in_an_array)
    would throw that exception when it tried to assign a reference to a `Base` into
    the `Derived[]` array.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，C#正确禁止这种违规行为，但依赖CLR在运行时执行此操作。尽管类型为`Derived[]`的数组的引用可以隐式转换为类型为`Base[]`的引用，但任何试图将不符合类型系统的数组元素设置的尝试都会抛出`ArrayTypeMismatchException`异常。因此，当试图将一个`Base`的引用分配给`Derived[]`数组时，[Example 6-19](#changing_an_element_in_an_array)会抛出该异常。
- en: The runtime check ensures that type safety is maintained, and this enables a
    convenient feature. If we write a method that takes an array and only reads from
    it, we can pass arrays of some derived element type. The downside is that the
    CLR has to do extra work at runtime when you modify array elements to ensure that
    there is no type mismatch. It may be able to optimize the code to avoid having
    to check every single assignment, but there is still some overhead, meaning that
    arrays are not quite as efficient as they might be.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时检查确保了类型安全的维护，并且这使得一个便利特性得以实现。如果我们编写一个仅从数组中读取的方法，我们可以传递一些派生元素类型的数组。但缺点是CLR在运行时需要额外工作，当修改数组元素时，以确保没有类型不匹配。它可以优化代码以避免每次赋值都进行检查，但仍然会有一些开销，这意味着数组并不像可能的那么高效。
- en: This somewhat peculiar arrangement dates back to the time before .NET had formalized
    concepts of covariance and contravariance—these came in with generics, which were
    introduced in .NET 2.0\. Perhaps if generics had been around from the start, arrays
    would be less odd, although having said that, even after .NET 2.0 their peculiar
    form of covariance was for many years the only mechanism built into the framework
    that provided a way to pass a collection covariantly to a method that wanted to
    read from it using indexing. Until .NET 4.5 introduced `IReadOnlyList<T>` (for
    which `T` is covariant), there was no read-only indexed collection interface in
    the framework, and therefore no standard indexed collection interface with a covariant
    type parameter. (`IList<T>` is read/write, so just like `ICollection<T>`, it cannot
    offer variance.)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这种有些奇特的安排可以追溯到.NET在正式化协变和逆变的概念之前的时期——这些概念是随着泛型引入.NET 2.0而引入的。也许如果从一开始就有泛型，数组将不会如此奇怪，尽管说了这些，即使在.NET
    2.0之后，它们特有的协变形式多年来仍是框架中唯一内建的通过索引读取集合协变传递到方法的机制。直到.NET 4.5引入了`IReadOnlyList<T>`（其中`T`是协变的），框架中才有只读索引集合接口，因此没有带有协变类型参数的标准索引集合接口（`IList<T>`是读/写的，因此像`ICollection<T>`一样，它不能提供协变）。
- en: 'While we’re on the subject of type compatibility and the implicit reference
    conversions that inheritance makes available, there’s one more type we should
    look at: `object`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论类型兼容性和继承带来的隐式引用转换时，还有一个类型需要我们关注：`object`。
- en: System.Object
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: System.Object
- en: 'The `System.Object` type, or `object`, as we usually call it in C#, is useful
    because it can act as a sort of universal container: a variable of this type can
    hold a reference to almost anything. I’ve mentioned this before, but I haven’t
    yet explained why it’s true. The reason this works is that almost everything derives
    from `object`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，`System.Object`类型，或者我们通常称之为`object`，非常有用，因为它可以充当一种通用容器：这种类型的变量可以持有几乎任何东西的引用。我之前提到过这一点，但我还没有解释为什么它是真的。这能行得通的原因是几乎所有东西都从`object`派生。
- en: If you do not specify a base class when writing a class or record, the C# compiler
    automatically uses `object` as the base. As we’ll see shortly, it chooses different
    bases for certain kinds of types such as structs, but even those derive from `object`
    indirectly. (As ever, pointer types are an exception—these do not derive from
    `object`.)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在编写一个类或记录时没有指定基类时，C# 编译器会自动将`object`作为基类。稍后我们会看到，对于某些类型，如结构体，它会选择不同的基类，但即使这些类型间接地从`object`派生。（作为例外，指针类型是一个例外——它们不从`object`派生。）
- en: 'The relationship between interfaces and objects is slightly more subtle. Interfaces
    do not derive from `object`, because an interface can specify only other interfaces
    as its bases. However, a reference of any interface type is implicitly convertible
    to a reference of type `object`. This conversion will always be valid, because
    all types that are capable of implementing interfaces ultimately derive from `object`.
    Moreover, C# chooses to make the `object` class’s members available through interface
    references even though they are not, strictly speaking, members of the interface.
    This means that references of any kind always offer the following methods defined
    by `object`: `ToString`, `Equals`, `GetHashCode`, and `GetType`.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接口和对象之间的关系稍微复杂一些。接口不从`object`派生，因为接口只能指定其他接口作为其基类。然而，任何接口类型的引用都可以隐式转换为`object`类型的引用。这种转换总是有效的，因为能够实现接口的所有类型最终都从`object`派生。此外，即使严格来说，这些方法并不是接口的成员，C#
    选择通过接口引用使`object`类的成员可用。这意味着任何类型的引用始终提供了由`object`定义的以下方法：`ToString`、`Equals`、`GetHashCode`
    和 `GetType`。
- en: The Ubiquitous Methods of System.Object
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**System.Object 的普遍方法**'
- en: I’ve used `ToString` in a few examples already. The default implementation returns
    the object’s type name, but many types provide their own implementation of `ToString`,
    returning a more useful textual representation of the object’s current value.
    The numeric types return a decimal representation of their value, for example,
    while `bool` returns either `"True"` or `"False"`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在几个例子中使用了`ToString`。默认实现返回对象的类型名称，但许多类型提供了它们自己的`ToString`实现，返回对象当前值的更有用的文本表示。例如，数值类型返回其值的十进制表示，而`bool`返回`"True"`或`"False"`。
- en: I discussed `Equals` and `GetHashCode` in [Chapter 3](ch03.xhtml#ch_types),
    but I’ll provide a quick recap here. `Equals` allows an object to be compared
    with any other object. The default implementation just performs an identity comparison—that
    is, it returns `true` only when an object is compared with itself. Many types
    provide an `Equals` method that performs value-like comparison—for example, two
    distinct `string` objects may contain identical text, in which case they will
    report being equal to each other. (Should you need to perform an identity-based
    comparison of objects that provide value-based comparison, you can use the `object`
    class’s static `ReferenceEquals` method.) Incidentally, `object` also defines
    a static version of `Equals` that takes two arguments. This checks whether the
    arguments are `null`, returning `true` if both are `null` and `false` if only
    one is `null`; otherwise, it defers to the first argument’s `Equals` method. And,
    as discussed in [Chapter 3](ch03.xhtml#ch_types), `GetHashCode` returns an integer
    that is a reduced representation of the object’s value, which is used by hash-based
    mechanisms such as the `Dictionary<TKey, TValue>` collection class. Any pair of
    objects for which `Equals` returns `true` must return the same hash codes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 [第 3 章](ch03.xhtml#ch_types) 中讨论了 `Equals` 和 `GetHashCode` 方法，但我会在这里简要回顾一下。`Equals`
    允许将一个对象与任何其他对象进行比较。默认实现只执行标识比较，即只有当对象与自身比较时返回 `true`。许多类型提供了一个 `Equals` 方法，执行类似值的比较——例如，两个不同的
    `string` 对象可能包含相同的文本，这种情况下它们将报告彼此相等。（如果需要对提供值比较的对象执行基于标识的比较，可以使用 `object` 类的静态
    `ReferenceEquals` 方法。）顺便说一句，`object` 还定义了一个接受两个参数的静态版本的 `Equals` 方法。这检查参数是否为 `null`，如果两个参数都为
    `null` 则返回 `true`，如果只有一个参数为 `null` 则返回 `false`；否则，它将委托给第一个参数的 `Equals` 方法。正如在
    [第 3 章](ch03.xhtml#ch_types) 中讨论的那样，`GetHashCode` 返回一个整数，它是对象值的简化表示，被哈希机制（例如 `Dictionary<TKey,
    TValue>` 集合类）使用。任何两个 `Equals` 返回 `true` 的对象必须返回相同的哈希码。
- en: The `GetType` method provides a way to discover things about the object’s type.
    It returns a reference of type `Type`. That’s part of the reflection API, which
    is the subject of [Chapter 13](ch13.xhtml#ch_reflection).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetType` 方法提供了一种发现对象类型信息的方式。它返回一个 `Type` 类型的引用。这是反射 API 的一部分，是 [第 13 章](ch13.xhtml#ch_reflection)
    的主题。'
- en: Besides these public members, available through any reference, `object` defines
    two more members that are not universally accessible. An object has access to
    these members only on itself. They are `Finalize` and `MemberwiseClone`. The CLR
    calls the `Finalize` method to notify you that your object is no longer in use
    and the memory it occupies is about to be reclaimed. In C# we do not normally
    work directly with the `Finalize` method, because C# presents this mechanism through
    destructors, as I’ll show in [Chapter 7](ch07.xhtml#ch_object_lifetime). `MemberwiseClone`
    creates a new instance of the same type as your object, initialized with copies
    of all of your object’s fields. If you need a way to create a clone of an object,
    this may be easier than writing code that copies all the contents across by hand,
    although it is not very fast.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些可以通过任何引用访问的公共成员外，`object` 还定义了另外两个不是普遍可访问的成员。对象只能在自身上访问这些成员。它们是 `Finalize`
    和 `MemberwiseClone`。CLR 调用 `Finalize` 方法来通知你的对象不再使用，并且它占用的内存即将被回收。在 C# 中，我们通常不直接使用
    `Finalize` 方法，因为 C# 通过析构函数（我将在 [第 7 章](ch07.xhtml#ch_object_lifetime) 中展示）来呈现这一机制。`MemberwiseClone`
    创建一个与你的对象相同类型的新实例，其初始化为你的对象所有字段的副本。如果需要一种方式来创建对象的克隆，这可能比手动复制所有内容的代码更简单，尽管它不是非常快速。
- en: The reason these last two methods are available only from inside the object
    is that you might not want other people cloning your object, and it would be unhelpful
    if external code could call the `Finalize` method, fooling your object into thinking
    that it was about to be freed if in fact it wasn’t. The `object` class limits
    the accessibility of these members. But they’re not private—that would mean that
    only the `object` class itself could access them, because private members are
    not visible even to derived classes. Instead, `object` makes theses members *protected*,
    an accessibility specifier designed for inheritance scenarios.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个方法之所以只能从对象内部访问，是因为你可能不希望其他人克隆你的对象，而且如果外部代码能调用 `Finalize` 方法，让你的对象误以为即将释放内存，这将毫无帮助。`object`
    类限制了这些成员的可访问性。但它们不是私有的——这意味着只有 `object` 类本身才能访问它们，因为私有成员甚至对派生类也不可见。相反，`object`
    将这些成员设置为 *protected*，这是为继承场景设计的访问限定符。
- en: Accessibility and Inheritance
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问权限和继承
- en: By now, you will already be familiar with most of the accessibility levels available
    for types and their members. Elements marked as `public` are available to all,
    `private` members are accessible only from within the type that declared them,
    and `internal` members are available to code defined in the same component.^([1](ch06.xhtml#CHP-6-FN-1))
    But with inheritance, we get three other accessibility options.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经熟悉了大多数可用于类型及其成员的访问级别。标记为 `public` 的元素对所有人可见，`private` 成员仅能从声明它们的类型内部访问，而
    `internal` 成员对同一组件中定义的代码可见。^([1](ch06.xhtml#CHP-6-FN-1)) 但是通过继承，我们还可以获得其他三种访问权限选项。
- en: A member marked as `protected` is available inside the type that defined it
    and also inside any derived types. But for code using an instance of your type,
    `protected` members are not accessible, just like `private` members.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `protected` 标记的成员在定义它的类型内部和任何派生类型内部都可用。但是对于使用你的类型实例的代码而言，`protected` 成员是不可访问的，就像
    `private` 成员一样。
- en: 'The next protection level for type members is `protected internal`. (You can
    write `internal protected` if you prefer; the order makes no difference.) This
    makes the member more accessible than either `protected` or `internal` on its
    own: the member will be accessible to all derived types *and* to all code that
    shares an assembly.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 类型成员的下一个保护级别是 `protected internal`。（如果你喜欢，也可以写成 `internal protected`；顺序没有影响。）这使得成员比单独的
    `protected` 或 `internal` 更容易访问：成员将对所有派生类型和共享同一个程序集的所有代码可见。
- en: The third protection level that inheritance adds is `protected private`. Members
    marked with this (or the equivalent `private protected`) are available only to
    types that are both derived from *and* defined in the same component as the defining
    type.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 继承增加的第三个保护级别是 `protected private`。使用此标记的成员（或等效的 `private protected`）仅对从定义类型派生且位于同一组件中的类型可用。
- en: You can use `protected`, `protected internal`, or `protected private` for any
    member of a type, and not just methods. You can even define nested types with
    these accessibility specifiers.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `protected`、`protected internal` 或 `protected private` 来修饰类型的任何成员，而不仅仅是方法。你甚至可以使用这些访问权限修饰符来定义嵌套类型。
- en: While `protected` and `protected internal` (although not `protected private`)
    members are not available through an ordinary variable of the defining type, they
    are still part of the type’s public API, in the sense that anyone who has access
    to your classes will be able to use these members. As with most languages that
    support a similar mechanism, `protected` members in C# are typically used to provide
    services that derived classes might find useful. If you write a `public` class
    that supports inheritance, then anyone can derive from it and gain access to its
    `protected` members. Removing or changing `protected` members would therefore
    risk breaking code that depends on your class just as surely as removing or changing
    `public` members would.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `protected` 和 `protected internal`（尽管不包括 `protected private`）成员不能通过定义类型的普通变量访问，它们仍然是类型公共
    API 的一部分，这意味着任何有权访问你的类的人都能够使用这些成员。与大多数支持类似机制的语言一样，C# 中的 `protected` 成员通常用于提供派生类可能找到有用的服务。如果你编写了一个支持继承的
    `public` 类，那么任何人都可以从它派生，并且能够访问其 `protected` 成员。因此，删除或更改 `protected` 成员会像删除或更改
    `public` 成员一样，可能会破坏依赖于你的类的代码。
- en: When you derive from a class, you cannot make your class more visible than its
    base. If you derive from an `internal` class, for example, you cannot declare
    your class to be `public`. Your base class forms part of your class’s API, so
    anyone wishing to use your class will also in effect be using its base class;
    this means that if the base is inaccessible, your class will also be inaccessible,
    which is why C# does not permit a class to be more visible than its base. If you
    derive from a `protected` nested class, your derived class could be `protected`,
    `private`, or `protected private` but not `public`, `internal`, or `protected
    internal`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从一个类派生时，不能使你的类比其基类更可见。例如，如果你从一个 `internal` 类派生，你不能将你的类声明为 `public`。你的基类形成了你的类
    API 的一部分，因此任何希望使用你的类的人实际上也在使用其基类；这意味着如果基类不可访问，你的类也将不可访问，这就是为什么 C# 不允许一个类比其基类更可见的原因。如果你从一个
    `protected` 的嵌套类派生，你的派生类可以是 `protected`、`private` 或 `protected private`，但不能是 `public`、`internal`
    或 `protected internal`。
- en: Note
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: 'This restriction does not apply to the interfaces you implement. A `public`
    class is free to implement `internal` or `private` interfaces. However, it does
    apply to an interface’s bases: a `public` interface cannot derive from an `internal`
    interface.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个限制不适用于你实现的接口。`public`类可以自由实现`internal`或`private`接口。但是，它适用于接口的基接口：`public`接口不能从`internal`接口派生。
- en: 'When defining methods, there’s another keyword you can add for the benefit
    of derived types: `virtual`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义方法时，还有另一个关键字可以为派生类型增加效果：`virtual`。
- en: Virtual Methods
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟方法
- en: 'A *virtual method* is one that a derived type can replace. Several of the methods
    defined by `object` are virtual: the `ToString`, `Equals`, `GetHashCode`, and
    `Finalize` methods are all designed to be replaced. The code required to produce
    a useful textual representation of an object’s value will differ considerably
    from one type to another, as will the logic required to determine equality and
    produce a hash code. Types typically define a finalizer only if they need to do
    some specialized cleanup work when they go out of use.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚方法*是派生类型可以替换的方法。`object`定义的几种方法都是虚拟的：`ToString`、`Equals`、`GetHashCode`和`Finalize`方法都被设计为可替换的。用于生成对象值的有用文本表示所需的代码会因类型不同而大不相同，判断相等性和生成哈希码所需的逻辑也会不同。类型通常仅在需要在其不再使用时执行一些专门的清理工作时定义终结器。'
- en: Not all methods are virtual. In fact, C# makes methods nonvirtual by default.
    The `object` class’s `GetType` method is not virtual, so you can always trust
    the information it returns to you because you know that you’re calling the `GetType`
    method supplied by .NET, and not some type-specific substitute designed to fool
    you. To declare that a method should be virtual, use the `virtual` keyword, as
    [Example 6-21](#a_class_with_a_virtual_method) shows.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有方法都是虚方法。事实上，C#默认情况下使方法为非虚方法。`object`类的`GetType`方法不是虚方法，因此您可以始终信任它返回的信息，因为您知道您调用的是.NET提供的`GetType`方法，而不是某种特定类型的替代品，旨在愚弄您。要声明方法应为虚方法，请使用`virtual`关键字，如[示例 6-21](#a_class_with_a_virtual_method)所示。
- en: Example 6-21\. A class with a virtual method
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-21\. 带有虚方法的类
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can also apply the `virtual` keyword to properties. Properties are just
    methods under the covers, so this has the effect of making the accessor methods
    virtual. The same is true for events, which are discussed in [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将`virtual`关键字应用于属性。属性在底层只是方法，因此这会使访问器方法变为虚方法。事件也是如此，这在[第 9 章](ch09.xhtml#ch_delegates_lambdas_events)中有讨论。
- en: There’s nothing unusual about the syntax for invoking a virtual method. As [Example 6-22](#using_a_virtual_method)
    shows, it looks just like calling any other method.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 调用虚方法的语法并无特殊之处。如[示例 6-22](#using_a_virtual_method)所示，它看起来就像调用任何其他方法一样。
- en: Example 6-22\. Using a virtual method
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-22\. 使用虚方法
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The difference between virtual and nonvirtual method invocations is that a virtual
    method call decides at runtime which method to invoke. The code in [Example 6-22](#using_a_virtual_method)
    will, in effect, inspect the object passed in, and if the object’s type supplies
    its own implementation of `ShowMessage`, it will call that instead of the one
    defined in `BaseWithVirtual`. The method is chosen based on the actual type the
    target object turns out to have at runtime, and not the static type (determined
    at compile time) of the expression that refers to the target object.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 虚方法调用与非虚方法调用的区别在于，虚方法调用会在运行时决定调用哪个方法。在[示例 6-22](#using_a_virtual_method)中的代码实际上会检查传入的对象，如果对象的类型提供了自己的`ShowMessage`实现，那么会调用那个实现，而不是在`BaseWithVirtual`中定义的实现。方法的选择基于目标对象在运行时的实际类型，而不是在编译时确定的表达式的静态类型。
- en: Note
  id: totrans-129
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Since virtual method invocation selects the method based on the type of the
    object on which you invoke the method, static methods cannot be virtual.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于虚方法调用是基于调用方法的对象的类型选择方法，静态方法不能是虚方法。
- en: Derived types are not obliged to replace virtual methods. [Example 6-23](#overriding_virtual_methods)
    shows two classes that derive from the one in [Example 6-21](#a_class_with_a_virtual_method).
    The first leaves the base class’s implementation of `ShowMessage` in place. The
    second overrides it. Note the `override` keyword—C# requires us to state explicitly
    that we are intending to override a virtual method.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 派生类型不必替换虚方法。[示例 6-23](#overriding_virtual_methods)展示了两个从[示例 6-21](#a_class_with_a_virtual_method)派生的类。第一个保留了基类对`ShowMessage`的实现。第二个对其进行了重写。请注意`override`关键字——C#要求我们明确声明我们打算重写虚方法。
- en: Example 6-23\. Overriding virtual methods
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-23\. 重写虚方法
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can use these types with the method in [Example 6-22](#using_a_virtual_method).
    [Example 6-24](#exploiting_virtual_methods) calls it three times, passing in a
    different type of object each time.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些类型与[示例 6-22](#using_a_virtual_method)中的方法一起使用。[示例 6-24](#exploiting_virtual_methods)调用它三次，每次传入不同类型的对象。
- en: Example 6-24\. Exploiting virtual methods
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-24\. 利用虚方法
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This produces the following output:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了以下输出：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Obviously, when we pass an instance of the base class, we get the output from
    the base class’s `ShowMessage` method. We also get that with the derived class
    that has not supplied an override. It is only the final class, which overrides
    the method, that produces different output. This shows that virtual methods provide
    a way to write polymorphic code: [Example 6-22](#using_a_virtual_method) can use
    a variety of types.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，当我们传递基类的实例时，我们会得到基类的`ShowMessage`方法的输出。对于未提供重写的派生类，我们也会得到相同的输出。只有最终重写了该方法的类才会产生不同的输出。这表明虚方法提供了编写多态代码的一种方式：[示例 6-22](#using_a_virtual_method)可以使用多种类型。
- en: When overriding a method, the method name and its parameter types must be an
    exact match. In most cases, the return type will also be identical, but it doesn’t
    always need to be. If the `virtual` method’s return type is not `void`, and is
    not a `ref` return, the overriding method may have a different type as long as
    an implicit reference conversion from that type to the `virtual` method’s return
    type exists. To put that more informally, an override is allowed to be more specific
    about its return type. This means that examples such as [Example 6-25](#override_covariant_return_type)
    are legal.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当重写一个方法时，方法名和其参数类型必须完全匹配。在大多数情况下，返回类型也会相同，但并非总是如此。如果`virtual`方法的返回类型不是`void`，并且不是`ref`返回，则重写方法的返回类型可以不同，只要存在从该类型到`virtual`方法返回类型的隐式引用转换。简而言之，重写方法允许在返回类型上更为具体。这意味着像[示例 6-25](#override_covariant_return_type)这样的例子是合法的。
- en: Example 6-25\. An override that narrows the return type
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-25\. 缩小返回类型的重写
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that the return type of the override of `Get` is `Book`, even though the
    `virtual` method it overrides returns a `Product`. This is fine because anything
    that invokes this method through a reference of type `ProductSourceBase` will
    expect to get back a reference of type `Product`, and thanks to inheritance, a
    `Book` is a `Product`. So users of the `ProductSourceBase` type will be unaware
    of and unaffected by the change. This feature can sometimes be useful in cases
    where code working directly with a derived type needs to know the specific type
    that will be returned.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Get`的重写的返回类型是`Book`，即使它重写的`virtual`方法返回`Product`也是如此。这是可以接受的，因为通过`ProductSourceBase`类型的引用调用此方法的任何东西都将期望得到一个`Product`类型的引用，并且由于继承关系，`Book`是`Product`的一种。因此，`ProductSourceBase`类型的用户将不会察觉到或受到此更改的影响。在直接处理派生类型的代码需要知道将返回的具体类型的情况下，此功能有时会很有用。
- en: You might be wondering why we need virtual methods, given that interfaces also
    enable polymorphic code. Prior to C# 8.0 one major advantage of virtual methods
    over interfaces was that the base class could provide an implementation that derived
    classes would acquire by default, supplying their own implementation only if they
    really needed something different. The addition of default interface implementations
    to the language means that interfaces can now do the same thing, although a default
    interface member implementation cannot define or access nonstatic fields, so it
    is somewhat limited compared to a class that defines a virtual function. (And
    since default interface implementations require runtime support, they are unavailable
    to code that needs to be able to run on .NET Framework, which includes any library
    targeting .NET Standard 2.0 or older.) However, there is a more subtle advantage
    available to virtual methods, but before we can look at it, we need to explore
    a feature of virtual methods that at first glance even more closely resembles
    the way interfaces work.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会想知道为什么我们需要虚方法，考虑到接口也能实现多态代码。在C# 8.0之前，虚方法相对于接口的一个主要优势是，基类可以提供一个默认实现，派生类将默认获取这个实现，并仅在真正需要不同实现时提供自己的实现。语言中添加默认接口实现的功能意味着接口现在也可以做到这一点，尽管默认接口成员实现不能定义或访问非静态字段，因此与定义虚函数的类相比受到一定限制。
    （由于默认接口实现需要运行时支持，对于需要在.NET Framework上运行的代码是不可用的，这包括任何目标为.NET Standard 2.0或更早版本的库。）但是，虚方法还有一个更微妙的优势，但在我们能够看到它之前，我们需要探索虚方法的一个特性，即乍一看更像接口工作方式的东西。
- en: Abstract Methods
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象方法
- en: You can define a virtual method without providing a default implementation.
    C# calls this an *abstract method*. If a class contains one or more abstract methods,
    the class is incomplete, because it doesn’t provide all of the methods it defines.
    Classes of this kind are also described as being abstract, and it is not possible
    to construct instances of an abstract class; attempting to use the `new` operator
    with an abstract class will cause a compiler error. Sometimes when discussing
    classes, it’s useful to make clear that some particular class is *not* abstract,
    for which we normally use the term *concrete class*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义一个虚方法而不提供默认实现。在C#中，这称为*抽象方法*。如果一个类包含一个或多个抽象方法，则该类是不完整的，因为它未提供所有定义的方法。这种类也被描述为抽象类，无法创建抽象类的实例；尝试使用`new`运算符与抽象类将导致编译器错误。有时在讨论类时，明确某个特定类*不是*抽象类是有用的，我们通常使用术语*具体类*。
- en: If you derive from an abstract class, then unless you provide implementations
    for all the abstract methods, your derived class will also be abstract. You must
    state your intention to write an abstract class with the `abstract` keyword; if
    this is absent from a class that has unimplemented abstract methods (either ones
    it has defined itself or ones it has inherited from its base class), the C# compiler
    will report an error. [Example 6-26](#an_abstract_class) shows an abstract class
    that defines a single abstract method. Abstract methods are virtual by definition;
    there wouldn’t be much use in defining a method that has no body if there were
    no way for derived classes to supply a body.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从抽象类派生，那么除非你为所有抽象方法提供实现，否则你的派生类也将是抽象的。你必须使用`abstract`关键字声明你要写的抽象类；如果一个类有未实现的抽象方法（无论是自己定义的还是继承的），而没有使用`abstract`关键字声明为抽象类，C#编译器将报错。[示例 6-26](#an_abstract_class)展示了定义单个抽象方法的抽象类。抽象方法在定义上是虚的；如果没有办法让派生类提供方法体，定义一个没有方法体的方法也就没有多大用处。
- en: Example 6-26\. An abstract class
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-26\. 一个抽象类
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Abstract method declarations just define the signature and do not contain a
    body. Unlike with interfaces, each abstract member has its own accessibility—you
    can declare abstract methods as `public`, `internal`, `protected internal`, `protected
    private`, or `protected`. (It makes no sense to make an abstract or virtual method
    `private`, because the method will be inaccessible to derived types and therefore
    impossible to override.)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象方法声明只定义了签名，不包含方法体。与接口不同的是，每个抽象成员都有自己的可访问性——可以将抽象方法声明为`public`、`internal`、`protected
    internal`、`protected private`或`protected`。（将抽象或虚方法声明为`private`没有意义，因为该方法对派生类型是不可访问的，因此无法重写。）
- en: Note
  id: totrans-151
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Although classes that contain abstract methods are required to be abstract,
    the converse is not true. It is legal, albeit unusual, to define a class as abstract
    even if it would be a viable concrete class. This prevents the class from being
    constructed. A class that derives from this will be concrete without needing to
    override any abstract methods.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然包含抽象方法的类必须是抽象的，但反之并非如此。尽管不寻常，将一个本来可以作为具体类的类定义为抽象是合法的。这样可以防止该类被实例化。从这种类派生的类将是具体类，而无需重写任何抽象方法。
- en: Abstract classes have the option to declare that they implement an interface
    without needing to provide a full implementation. You can’t just omit the unimplemented
    members, though. You must explicitly declare all of its members, marking any that
    you want to leave unimplemented as being abstract, as [Example 6-27](#abstract_interface_implementation)
    shows. This forces concrete derived types to supply the implementation.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类有选择地声明它们实现接口，而无需提供完整的实现。但是，不能只省略未实现的成员。您必须显式声明其所有成员，并将您希望保留未实现的任何成员标记为抽象，就像[示例6-27](#abstract_interface_implementation)所示的那样。这迫使具体派生类型提供实现。
- en: Example 6-27\. Abstract interface implementation
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例6-27. 抽象接口实现
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There’s clearly some overlap between abstract classes and interfaces. Both provide
    a way to define an abstract type that code can use without needing to know the
    exact type that will be supplied at runtime. Each option has its pros and cons.
    Interfaces have the advantage that a single type can implement multiple interfaces,
    whereas a class gets to specify only a single base class. But abstract classes
    can define fields and can use these in any default member implementations they
    supply, and they also provide a way to supply default implementations that will
    work on .NET Framework. However, there’s a more subtle advantage available to
    virtual methods that comes into play when you release multiple versions of a library
    over time.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类和接口之间显然存在一些重叠。两者都提供了一种定义抽象类型的方式，使得代码在运行时无需知道确切的类型即可使用。每种选项都有其利弊。接口的优势在于单个类型可以实现多个接口，而类只能指定一个基类。但是抽象类可以定义字段，并且可以在其提供的任何默认成员实现中使用这些字段，并且它们还提供了一种在.NET
    Framework上提供默认实现的方式。然而，在发布多个版本的库时，虚方法可以发挥出更为微妙的优势。
- en: Inheritance and Library Versioning
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承和库版本控制
- en: Imagine what would happen if you had written and released a library that defined
    some public interfaces and abstract classes, and in the second release of the
    library, you decided that you wanted to add some new members to one of the interfaces.
    It’s conceivable that this might not cause a problem for customers using your
    code. Certainly, any place where they use a reference of that interface type will
    be unaffected by the addition of new features. However, what if some of your customers
    have written types that implement your interface? Suppose, for example, that in
    a future version of .NET, Microsoft decided to add a new member to the `IEnumerable<T>`
    interface.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果您编写并发布了一个定义了一些公共接口和抽象类的库，并且在该库的第二个版本中，您决定向其中一个接口添加一些新成员，会发生什么情况。这可能对使用您的代码的客户不会造成问题。当然，他们在使用接口类型的引用的任何地方都不会受到新功能添加的影响。但是，如果您的某些客户已编写了实现您接口的类型，会怎么样呢？例如，假设在未来的.NET版本中，Microsoft决定向`IEnumerable<T>`接口添加一个新成员。
- en: 'If the interface were not to supply a default implementation for the new member,
    it would be a disaster. This interface is widely used but also widely implemented.
    Classes that already implement `IEnumerable<T>` would become invalid because they
    would not provide this new member, so old code would fail to compile, and code
    already compiled would throw `MissingMethodException` errors at runtime. C#’s
    support for default member implementations in interfaces mitigates this: in the
    unlikely event that Microsoft did add a new member to `IEnumerable<T>`, it could
    supply a default implementation preventing these errors. This doesn’t help anyone
    using .NET Framework, which does not support this feature, but for newer runtimes,
    it makes modification of existing interface definitions seem viable. However,
    there’s a more subtle problem. Some classes might by chance already have had a
    member with the same name and signature as the newly added method. If that code
    is recompiled against the new interface definition, the compiler would treat that
    existing member as part of the implementation of the interface, even though the
    developer who wrote the method did not write it with that intention. So unless
    the existing code coincidentally happens to do exactly what the new member requires,
    we’d have a problem, and we wouldn’t get compiler errors or warnings to alert
    us.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果接口不为新成员提供默认实现，那将是一场灾难。这个接口被广泛使用，但也被广泛实现。已经实现`IEnumerable<T>`的类将变得无效，因为它们不会提供这个新成员，因此旧代码将无法编译，已经编译的代码将在运行时抛出`MissingMethodException`错误。C#
    对接口中的默认成员实现的支持可以减轻这一问题：如果微软确实向`IEnumerable<T>`添加了新成员，它可以提供一个默认实现以防止这些错误。这对于使用
    .NET Framework 的人没有帮助，因为它不支持这个功能，但对于较新的运行时环境，这使得修改现有接口定义似乎是可行的。然而，还有一个更微妙的问题。一些类可能碰巧已经具有与新添加方法相同名称和签名的成员。如果该代码针对新的接口定义重新编译，编译器将将该现有成员视为接口实现的一部分，即使编写该方法的开发人员并没有这样的意图。因此，除非现有代码碰巧确实执行了新成员所需的操作，否则我们将遇到问题，并且我们不会收到编译器错误或警告来提醒我们。
- en: Consequently, the widely accepted rule is that you do not alter interfaces once
    they have been published. If you have complete control over all of the code that
    uses and implements an interface, you can get away with modifying the interface,
    because you can make any necessary modifications to the affected code. But once
    the interface has become available for use in codebases you do not control—that
    is, once it has been published—it’s no longer possible to change it without risking
    breaking someone else’s code. Default interface implementations mitigate this
    risk, but they cannot eliminate the problem of existing methods accidentally being
    misinterpreted when they get recompiled against the updated interface.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，广泛接受的规则是一旦接口发布后就不要更改接口。如果您完全控制使用和实现接口的所有代码，那么您可以修改接口，因为您可以对受影响的代码进行任何必要的修改。但一旦接口可用于您无法控制的代码库中——也就是说，一旦它被发布——就不可能在不冒破坏其他人代码风险的情况下更改它。默认接口实现可以减轻这种风险，但它们无法消除现有方法在重新编译时被错误解释的问题。
- en: Abstract base classes do not have to suffer from this problem. Obviously, introducing
    new abstract members would cause exactly the same `MissingMethodException` failures,
    but introducing new virtual methods does not. (And since virtual methods have
    been in C# since v1, this enables you to target .NET Framework, where default
    interface implementation support is unavailable.)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象基类不必遭受这个问题的困扰。显然，引入新的抽象成员将导致完全相同的`MissingMethodException`失败，但引入新的虚拟方法则不会。（而且自从
    C# v1 开始就有虚拟方法，这使您可以针对 .NET Framework，其中不支持默认接口实现支持。）
- en: But what if, after releasing version 1.0 of a component, you add a new virtual
    method in version 1.1 that turns out to have the same name and signature as a
    method that one of your customers happens to have added in a derived class? Perhaps
    in version 1.0, your component defines the rather uninteresting base class shown
    in [Example 6-28](#base_type_version_1.0).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果在发布版本 1.0 的组件之后，在版本 1.1 中添加了一个新的虚拟方法，结果发现该方法与某个客户恰好在派生类中添加的方法具有相同的名称和签名呢？也许在版本
    1.0 中，您的组件定义了示例 [Example 6-28](#base_type_version_1.0) 中显示的相当无趣的基类。
- en: Example 6-28\. Base type version 1.0
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-28\. 基类版本 1.0
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you release this library, perhaps on the [NuGet package management website](https://nuget.org),
    or maybe as part of some Software Development Kit (SDK) for your application,
    a customer might write a derived type such as the one in [Example 6-29](#class_derived_from_version_1.0_base).
    The `Start` method they have written is clearly not meant to override anything
    in the base class.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发布此库，可能会在[NuGet软件包管理网站](https://nuget.org)上，或作为应用程序的某个软件开发工具包（SDK）的一部分。客户可能会编写一个派生类型，比如[示例 6-29](#class_derived_from_version_1.0_base)中的一个。他们编写的`Start`方法显然不意图覆盖基类中的任何内容。
- en: Example 6-29\. Class derived from version 1.0 base
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-29\. 从版本 1.0 基础派生的类
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Since you won’t necessarily get to see every line of code that your customers
    write, you might be unaware of this `Start` method. So in version 1.1 of your
    component, you might decide to add a new virtual method, also called `Start`,
    as [Example 6-30](#base_type_version_1.1) shows.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您可能无法看到客户编写的每一行代码，因此您可能不知道这个`Start`方法。因此，在您组件的 1.1 版本中，您可能决定添加一个新的虚方法，也叫做`Start`，正如[示例 6-30](#base_type_version_1.1)所示。
- en: Example 6-30\. Base type version 1.1
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-30\. 基础类型版本 1.1
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Imagine that your system calls this method as part of an initialization procedure
    introduced in v1.1\. You’ve defined a default empty implementation so that types
    derived from `LibraryBase` that don’t need to take part in that procedure don’t
    have to do anything. Types that wish to participate will override this method.
    But what happens with the class in [Example 6-29](#class_derived_from_version_1.0_base)?
    Clearly the developer who wrote that did not intend to participate in your new
    initialization mechanism, because that didn’t exist when the code was written.
    It could be bad if your code calls the `CustomerDerived` class’s `Start` method,
    because the developer presumably expects it to be called only when their code
    decides to call it. Fortunately, the compiler will detect this problem. If the
    customer attempts to compile [Example 6-29](#class_derived_from_version_1.0_base)
    against version 1.1 of your library ([Example 6-30](#base_type_version_1.1)),
    the compiler will warn them that something is not right:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您的系统作为引入 v1.1 版本初始化过程的一部分调用了这个方法。您定义了一个默认的空实现，这样从`LibraryBase`派生的类型如果不需要参与该过程，则无需执行任何操作。希望参与的类型将覆盖此方法。但是在[示例 6-29](#class_derived_from_version_1.0_base)中的类会发生什么呢？显然，编写此代码的开发人员并不打算参与您的新初始化机制，因为在编写代码时它并不存在。如果您的代码调用了`CustomerDerived`类的`Start`方法，则可能会出现问题，因为开发人员可能期望仅在他们的代码决定调用时才调用它。幸运的是，编译器会检测到此问题。如果客户尝试使用版本
    1.1 的库编译[示例 6-29](#class_derived_from_version_1.0_base)，编译器会警告他们存在某些问题：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is why the C# compiler requires the `override` keyword when we replace
    virtual methods. It wants to know whether we were intending to override an existing
    method, so that if we weren’t, it can warn us about naming collisions. (The absence
    of any equivalent keyword signifying the intention to implement an interface member
    is why the compiler cannot detect the same problem with default interface implementation.
    And the reason for this absence is that default interface implementation didn’t
    exist prior to C# 8.0.)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么当我们替换虚拟方法时，C#编译器要求使用`override`关键字的原因。它想知道我们是否打算覆盖现有的方法，以便如果我们没有打算这样做，它可以警告我们可能出现的命名冲突。（没有任何等效的关键字表示意图实现接口成员，这也是编译器无法检测到默认接口实现问题的原因。而这种缺失的原因是在C#
    8.0之前不存在默认接口实现。）
- en: We get a warning rather than an error, because the compiler provides a behavior
    that is likely to be safe when this situation has arisen due to the release of
    a new version of a library. The compiler guesses—correctly, in this case—that
    the developer who wrote the `CustomerDerived` type didn’t mean to override the
    `LibraryBase` class’s `Start` method. So rather than having the `CustomerDerived`
    type’s `Start` method override the base class’s virtual method, it *hides* it.
    A derived type is said to hide a member of a base class when it introduces a new
    member with the same name.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一个警告而不是错误，因为编译器在这种由于库的新版本发布而产生的情况下提供了一个可能是安全的行为。编译器推测——在这种情况下是正确的——编写`CustomerDerived`类型的开发人员并不打算覆盖`LibraryBase`类的`Start`方法。因此，与其让`CustomerDerived`类型的`Start`方法覆盖基类的虚方法，它*隐藏*了它。当派生类型引入一个与基类同名的新成员时，称为派生类型隐藏基类成员。
- en: 'Hiding methods is quite different than overriding them. When hiding occurs,
    the base method is not replaced. [Example 6-31](#hidden_versus_virtual_method)
    shows how the hidden `Start` method remains available. It creates a `CustomerDerived`
    object and places a reference to that object in two variables of different types:
    one of type `CustomerDerived` and one of type `LibraryBase`. It then calls `Start`
    through each of these.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏方法与重写方法有很大不同。当发生隐藏时，基础方法不会被替换。[示例 6-31](#hidden_versus_virtual_method)展示了如何保留隐藏的`Start`方法。它创建了一个`CustomerDerived`对象，并将该对象的引用放入两个不同类型的变量中：一个是`CustomerDerived`类型，另一个是`LibraryBase`类型。然后通过每个变量分别调用`Start`方法。
- en: Example 6-31\. Hidden versus virtual method
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-31\. 隐藏与虚方法
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When we use the `d` variable, the call to `Start` ends up calling the derived
    type’s `Start` method, the one that has hidden the base member. But the `b` variable’s
    type is `LibraryBase`, so that invokes the base `Start` method. If `CustomerDerived`
    had overridden the base class’s `Start` method instead of hiding it, both of those
    method calls would have invoked the override.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用变量`d`时，调用`Start`方法实际上调用了派生类型的`Start`方法，即隐藏了基类成员的方法。但变量`b`的类型是`LibraryBase`，所以会调用基类的`Start`方法。如果`CustomerDerived`类重写了基类的`Start`方法而不是隐藏它，那么这两个方法调用都会调用重写的方法。
- en: When name collisions occur because of a new library version, this hiding behavior
    is usually the right thing to do. If the customer’s code has a variable of type
    `CustomerDerived`, then that code will want to invoke the `Start` method specific
    to that derived type. However, the compiler produces a warning, because it doesn’t
    know for certain that this is the reason for the problem. It might be that you
    *did* mean to override the method, and you just forgot to write the `override`
    keyword.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当由于新库版本而发生名称冲突时，通常隐藏行为是正确的做法。如果客户代码有一个`CustomerDerived`类型的变量，则该代码将希望调用特定于该派生类型的`Start`方法。然而，编译器会产生警告，因为它不能确定这是否是问题的原因。可能是你确实想要重写方法，只是忘记写`override`关键字了。
- en: Like many developers, I don’t like to see compiler warnings, and I try to avoid
    committing code that produces them. But what should you do if a new library version
    puts you in this situation? The best long-term solution is probably to change
    the name of the method in your derived class so that it doesn’t clash with the
    method in the new version of the library. However, if you’re up against a deadline,
    you may want a more expedient solution. So C# lets you declare that you know that
    there’s a name clash and that you definitely want to hide the base member, not
    override it. As [Example 6-32](#avoiding_warnings_when_hiding_members) shows,
    you can use the `new` keyword to state that you’re aware of the issue and definitely
    want to hide the base class member. The code will still behave in the same way,
    but you’ll no longer get the warning, because you’ve assured the compiler that
    you know what’s going on. But this is an issue you should fix at some point, because
    sooner or later the existence of two methods with the same name on the same type
    that mean different things is likely to cause confusion.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 像许多开发人员一样，我不喜欢看到编译器警告，并且尽量避免提交产生警告的代码。但是如果新的库版本让你处于这种情况下，你应该怎么办？最好的长期解决方案可能是在派生类中更改方法的名称，以避免与新版本库中的方法冲突。然而，如果你面临截止日期，可能需要一个更快的解决方案。因此，C#允许您声明您知道存在名称冲突，并且您绝对想要隐藏基类成员，而不是重写它。正如[示例 6-32](#avoiding_warnings_when_hiding_members)所示，您可以使用`new`关键字声明您已经意识到这个问题，并且绝对要隐藏基类成员。代码仍将以相同的方式工作，但您将不再收到警告，因为您已向编译器保证您知道发生了什么。但这是您应该在某个时候解决的问题，因为
    sooner or later，在同一类型上存在两个意义不同但名称相同的方法很可能会导致混淆。
- en: Example 6-32\. Avoiding warnings when hiding members
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-32\. 隐藏成员时避免警告
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-183
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'C# does not let you use the `new` keyword to deal with the equivalent problem
    that arises with default interface implementations. There is no way to retain
    the default implementation supplied by an interface and also declare a public
    method with the same signature. This is slightly frustrating because it’s possible
    at the binary level: it’s the behavior you get if you do not recompile the code
    that implements an interface after adding a new member with a default implementation.
    You can still have separate implementations of, say, `ILibrary.Start` and `CustomerDerived.Start`,
    but you have to use explicit interface implementation.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: C#不允许你使用`new`关键字来处理默认接口实现带来的等价问题。没有办法保留接口提供的默认实现并声明具有相同签名的公共方法。这稍微让人沮丧，因为在二进制级别是可能的：如果在添加新成员并未重新编译实现接口的代码时，这就是你会得到的行为。你仍然可以拥有`ILibrary.Start`和`CustomerDerived.Start`的单独实现，但必须使用显式接口实现。
- en: Just occasionally, you may see the `new` keyword used in this way for reasons
    other than handling library versioning issues. For example, the `ISet<T>` interface
    that I showed in [Chapter 5](ch05.xhtml#ch_collections) uses it to introduce a
    new `Add` method. `ISet<T>` derives from `ICollection<T>`, an interface that already
    provides an `Add` method, which takes an instance of `T` and has a `void` return
    type. `ISet<T>` makes a subtle change to this, shown in [Example 6-33](#hiding_to_change_the_signature).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔你可能会看到`new`关键字以这种方式使用，而不是处理库版本问题。例如，我在第[5章](ch05.xhtml#ch_collections)中展示的`ISet<T>`接口使用它来引入一个新的`Add`方法。`ISet<T>`派生自`ICollection<T>`，一个已经提供了接受`T`实例并具有`void`返回类型的`Add`方法的接口。`ISet<T>`对此进行了微妙的更改，如[示例6-33](#hiding_to_change_the_signature)所示。
- en: Example 6-33\. Hiding to change the signature
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-33\. 隐藏以更改签名
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `ISet<T>` interface’s `Add` method tells you whether the item you just added
    was already in the set, something the base `ICollection<T>` interface’s `Add`
    method doesn’t support. `ISet<T>` needs its `Add` to have a different return type—`bool`
    instead of `void`—so it defines `Add` with the `new` keyword to indicate that
    it should hide the `ICollection<T>` one. Both methods are still available—if you
    have two variables, one of type `ICollection<T>` and the other of type `ISet<T>`,
    both referring to the same object, you’ll be able to access the `void Add` through
    the former and the `bool Add` through the latter.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`ISet<T>`接口的`Add`方法告诉你刚刚添加的项目是否已经存在于集合中，而基本的`ICollection<T>`接口的`Add`方法不支持这一点。`ISet<T>`需要其`Add`方法具有不同的返回类型——`bool`而不是`void`——因此它使用`new`关键字来隐藏`ICollection<T>`的方法。这两种方法仍然可用——如果你有两个变量，一个类型为`ICollection<T>`，另一个类型为`ISet<T>`，两者都引用同一个对象，你将能够通过前者访问`void
    Add`，通过后者访问`bool Add`。'
- en: Microsoft didn’t have to do this. It could have called the new `Add` method
    something else—`AddIfNotPresent`, for example. But it’s arguably less confusing
    just to have the one method name for adding things to a collection, particularly
    since you’re free to ignore the return value, at which point the new `Add` looks
    indistinguishable from the old one. And most `ISet<T>` implementations will implement
    the `ICo⁠lle⁠cti⁠on<⁠T>.​Add` method by calling straight through to the `ISet<T>.Add`
    method, so it makes sense that they have the same name.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 微软本可以不这样做。它本可以将新的`Add`方法命名为其他名称，比如`AddIfNotPresent`。但只有一个方法名称用于向集合中添加事物可能会更少引起混淆，尤其是当你可以忽略返回值时，此时新的`Add`看起来与旧的`Add`无法区分。而大多数`ISet<T>`实现将通过直接调用`ISet<T>.Add`方法来实现`ICollection<T>.​Add`方法，因此它们具有相同的名称是有道理的。
- en: Aside from the preceding example, so far I’ve discussed method hiding only in
    the context of compiling old code against a new version of a library. What happens
    if you have old code *already compiled* against an old library but that ends up
    *running* against a new version? That’s a scenario you are highly likely to run
    into when the library in question is the .NET runtime libraries. Suppose you are
    using third-party components that you have only in binary form (e.g., ones you’ve
    licensed from a company that does not supply source code). The supplier will have
    built these to use some particular version of .NET. If you upgrade your application
    to run with a new version of .NET, you might not be able to get hold of newer
    versions of the third-party components—maybe the vendor hasn’t released them yet,
    or perhaps it has gone out of business.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述示例之外，到目前为止，我只讨论了在编译旧代码以针对新版本库的情况下进行方法隐藏。如果您有已经编译但最终在新版本下运行的旧代码呢？当涉及的库是.NET运行时库时，这是一个您极有可能遇到的情景。假设您正在使用第三方组件，这些组件只有二进制形式（例如，您从不提供源代码的公司购买了许可的组件）。供应商将这些组件构建为使用某个特定版本的.NET。如果您升级应用程序以与新版本的.NET一起运行，您可能无法获取到更新的第三方组件版本——也许供应商尚未发布它们，或者可能已经停业。
- en: If the components you’re using were compiled for, say, .NET Standard 1.2, and
    you use them in a project built for .NET 6.0, all of those older components will
    end up using the .NET 6.0 versions of the runtime libraries. .NET has a versioning
    policy that arranges for all the components that a particular program uses to
    get the same version of the runtime libraries, regardless of which version any
    individual component may have been built for. So it’s entirely possible that some
    component, *OldControls.dll*, contains classes that derive from classes in .NET
    Standard 1.2, and that define members that collide with the names of members newly
    added in .NET 6.0.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的组件是为.NET Standard 1.2编译的，而您将它们用于为.NET 6.0构建的项目中，所有这些旧组件将最终使用.NET 6.0版本的运行时库。.NET有一个版本策略，确保特定程序使用的所有组件都使用相同版本的运行时库，而不管每个组件可能是为哪个版本构建的。因此，完全有可能某些组件，如*OldControls.dll*，包含从.NET
    Standard 1.2派生的类，并定义与.NET 6.0中新增成员名称相冲突的成员。
- en: This is more or less the same scenario as I described earlier, except that the
    code that was written for an older version of a library is not going to be recompiled.
    We’re not going to get a compiler warning about hiding a method, because that
    would involve running the compiler, and we have only the binary for the relevant
    component. What happens now?
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上与我之前描述的情景相同，只是针对旧版本库编写的代码不会重新编译。我们不会收到关于隐藏方法的编译器警告，因为那需要运行编译器，而我们只有相关组件的二进制文件。现在会发生什么呢？
- en: Fortunately, we don’t need the old component to be recompiled. The C# compiler
    sets various flags in the compiled output for each method it compiles, indicating
    things like whether the method is virtual or not and whether the method was intended
    to override some method in the base class. When you put the `new` keyword on a
    method, the compiler sets a flag indicating that the method is not meant to override
    anything. The CLR calls this the *newslot* flag. When C# compiles a method such
    as the one in [Example 6-29](#class_derived_from_version_1.0_base), which does
    not specify either `override` or `new`, it also sets this same newslot flag for
    that method, because at the time the method was compiled, there was no method
    of the same name on the base class. As far as both the developer and the compiler
    were concerned, the `CustomerDerived` class’s `Start` was written as a brand-new
    method that was not connected to anything on the base class.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不需要重新编译旧组件。C#编译器会为每个编译的方法设置各种标志，指示诸如方法是否虚拟，方法是否打算覆盖基类中的某个方法等内容。当您在方法上放置`new`关键字时，编译器会设置一个标志，指示该方法不打算覆盖任何东西。CLR将其称为*newslot*标志。当C#编译一个像[示例
    6-29](#class_derived_from_version_1.0_base)中的方法时，该方法既不指定`override`也不指定`new`，编译器也会为该方法设置相同的newslot标志，因为在编译该方法时，基类上没有同名方法。对于开发人员和编译器而言，`CustomerDerived`类的`Start`方法就像是一个全新的方法，与基类上的任何内容都没有关联。
- en: So when this old component gets loaded in conjunction with a new version of
    the library defining the base class, the CLR can see what was intended—it can
    see that, as far as the author of the `CustomerDerived` class was concerned, `Start`
    is not meant to override anything. It therefore treats `CustomerDerived.Start`
    as a distinct method from `LibraryBase.Start`—it hides the base method just like
    it did when we were able to recompile.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当旧组件与定义基类的新版本库一起加载时，CLR 可以看到作者在 `CustomerDerived` 类中的意图——即使没有重新编译，CLR 也可以看到作者认为
    `Start` 并不意味着要覆盖任何东西。因此，它将 `CustomerDerived.Start` 视为与 `LibraryBase.Start` 不同的方法——就像我们重新编译时一样隐藏基础方法。
- en: By the way, everything I’ve said about virtual methods can also apply to properties,
    because a property’s accessors are just methods. So you can define virtual properties,
    and derived classes can override or hide these in exactly the same way as with
    methods. I won’t be getting to events until [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events),
    but those are also methods in disguise, so they can also be virtual.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，我提到的关于虚方法的一切也适用于属性，因为属性的访问器只是方法。因此，您可以定义虚属性，并且派生类可以以与方法完全相同的方式重写或隐藏这些属性。在
    [第 9 章](ch09.xhtml#ch_delegates_lambdas_events) 中我不会讲事件，但它们也是方法的一种形式，所以它们也可以是虚的。
- en: Just occasionally, you may want to write a class that overrides a virtual method
    and then prevents derived classes from overriding it again. For this, C# defines
    the `sealed` keyword, and in fact, it’s not just methods that can be sealed.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，您可能希望编写一个类来重写虚方法，然后阻止派生类再次重写它。对此，C# 定义了 `sealed` 关键字，事实上，不仅仅是方法可以被标记为 sealed。
- en: Sealed Methods and Classes
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sealed Methods and Classes
- en: 'Virtual methods are deliberately open to modification through inheritance.
    A sealed method is the opposite—it is one that cannot be overridden. Methods are
    sealed by default in C#: methods cannot be overridden unless declared virtual.
    But when you override a virtual method, you can seal it, closing it off for further
    modification. [Example 6-34](#a_sealed_method) uses this technique to provide
    a custom `ToString` implementation that cannot be further overridden by derived
    classes.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 虚方法故意通过继承来修改。而 sealed 方法则是相反的——它是一个不可重写的方法。在 C# 中，默认情况下方法是 sealed 的：方法不能被重写，除非声明为
    virtual。但是当您重写虚方法时，可以使用 sealed 关键字将其封闭，阻止进一步修改。[示例 6-34](#a_sealed_method) 使用这种技术提供了一个自定义的
    `ToString` 实现，不能被派生类进一步重写。
- en: Example 6-34\. A sealed method
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-34\. 一个 sealed 方法
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You can also seal an entire class, preventing anyone from deriving from it.
    [Example 6-35](#a_sealed_class) shows a class that not only does nothing but also
    prevents anyone from extending it to do something useful. (You’d normally seal
    only a class that does something. This example is just to illustrate where the
    keyword goes.)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以封闭整个类，防止任何人从中派生。[示例 6-35](#a_sealed_class) 展示了一个不仅仅是什么都不做，还防止任何人扩展它以做一些有用事情的类。（通常您只会封闭做某些事情的类。这个例子只是为了说明关键字的使用位置。）
- en: Example 6-35\. A sealed class
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-35\. 一个 sealed 类
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Some types are inherently sealed. Value types, for example, do not support inheritance,
    so structs, record structs, and enums are effectively sealed. The built-in `string`
    class is also sealed.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一些类型本质上是 sealed 的。例如，值类型不支持继承，因此结构体、记录结构体和枚举实际上是 sealed。内置的 `string` 类也是 sealed
    的。
- en: There are two normal reasons for sealing either classes or methods. One is that
    you want to guarantee some particular invariant, and if you leave your type open
    to modification, you will not be able to guarantee that invariant. For example,
    instances of the `string` type are immutable. The `string` type itself does not
    provide a way to modify an instance’s value, and because nobody can derive from
    `string`, you can guarantee that if you have a reference of type `string`, you
    have a reference to an immutable object. This makes it safe for you to use in
    scenarios where you do not want the value to change—for example, when you use
    an object as a key to a dictionary (or anything else that relies on a hash code),
    you need the value not to change, because if the hash code changes while the item
    is in use as a key, the container will malfunction.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 密封类或方法通常有两个正常的原因。一是你希望保证某个特定不变量，如果你将类型开放以进行修改，将无法保证该不变量。例如，`string`类型的实例是不可变的。`string`类型本身不提供修改实例值的方法，因此由于无法从`string`派生，你可以保证如果你有一个`string`类型的引用，你就拥有一个不可变对象的引用。这使得在你不希望值改变的场景中使用它变得安全——例如，当你将对象作为字典的键（或任何依赖哈希码的其他东西）时，你需要值不变，因为如果在项目作为键使用时哈希码发生变化，容器将发生故障。
- en: The other usual reason for leaving things sealed is that designing types that
    can successfully be modified through inheritance is hard, particularly if your
    type will be used outside of your own organization. Simply opening things up for
    modification is not sufficient—if you decide to make all your methods virtual,
    it might make it easy for people using your type to modify its behavior, but you
    will have made a rod for your back when it comes to maintaining the base class.
    Unless you control all of the code that derives from your class, it will be almost
    impossible to change anything in the base, because you will never know which methods
    may have been overridden in derived classes, making it hard to ensure that your
    class’s internal state is consistent at all times. Developers writing derived
    types will doubtless do their best not to break things, but they will inevitably
    rely on aspects of your class’s behavior that are undocumented. So in opening
    up every aspect of your class for modification through inheritance, you rob yourself
    of the freedom to change your class.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 留下事物密封的另一个通常原因是，设计能够通过继承成功修改的类型很难，特别是如果你的类型将在你自己组织之外使用。简单地打开事物以进行修改是不够的——如果你决定使所有方法都虚拟化，这可能会使使用你的类型的人修改其行为变得容易，但当你维护基类时，你将会给自己找麻烦。除非你控制所有从你的类派生的代码，否则几乎不可能更改基类中的任何内容，因为你永远不会知道哪些方法可能已在派生类中被覆盖，这使得难以确保你类的内部状态始终一致。编写派生类型的开发人员无疑会尽力避免破坏事物，但他们将不可避免地依赖于未记录的你类行为的某些方面。因此，在通过继承开放你类的每个方面以供修改时，你剥夺了自己改变类的自由。
- en: You should be very selective about which methods, if any, you make virtual.
    And you should also document whether callers are allowed to replace the method
    completely or whether they are required to call the base implementation as part
    of their override. Speaking of which, how do you do that?
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于哪些方法（如果有的话）你应该非常谨慎地选择使其虚拟化。你还应该记录调用者是否允许完全替换方法，或者是否要求调用基本实现作为其覆盖的一部分。说到这一点，你该如何做到呢？
- en: Accessing Base Members
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问基类成员
- en: Everything that is in scope in a base class and is not private will also be
    in scope and accessible in a derived type. If you want to access some member of
    the base class, you typically just access it as if it were a normal member of
    your class. You can either access members through the `this` reference or just
    refer to them by name without qualification.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在基类中范围内的所有内容，只要不是私有的，也将在派生类型中范围内，并且可访问。如果你想访问基类的某个成员，通常只需像访问自己类的普通成员一样访问即可。你可以通过`this`引用访问成员，或者直接按名称访问，而无需限定符。
- en: However, there are some situations in which you need to state explicitly that
    you mean to refer to a base class member. In particular, if you have overridden
    a method, calling that method by name will invoke your override recursively. If
    you want to call back to the original method that you overrode, there’s a special
    keyword for that, shown in [Example 6-36](#calling_the_base_method_after_overriding).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些情况下你需要明确表示你打算引用基类成员。特别是，如果你重写了一个方法，用名称调用该方法将递归调用你的重写。如果你想调用原始的你重写的方法，有一个特殊的关键字用于这个，如[Example 6-36](#calling_the_base_method_after_overriding)中所示。
- en: Example 6-36\. Calling the base method after overriding
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 6-36\. 覆盖后调用基类方法
- en: '[PRE37]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: By using the `base` keyword, we are opting out of the normal virtual method
    dispatch mechanism. If we had written just `Start()`, that would have been a recursive
    call, which would be undesirable here. By writing `base.Start()`, we get the method
    that would have been available on an instance of the base class, the method we
    overrode.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`base`关键字，我们选择了不使用正常的虚方法分发机制。如果我们只写了`Start()`，那将是一个递归调用，在这里是不希望的。通过写`base.Start()`，我们获得了在基类实例上可用的方法，也就是我们重写的方法。
- en: What if the inheritance chain is deeper? Suppose `CustomerDerived` derives from
    `IntermediateBase` and that `IntermediateBase` derives from `LibraryBase` and
    also overrides the `Start` method. In that case, writing `base.Start()` in our
    `Cus⁠tom⁠er​Der⁠iv⁠ed` type will call the override defined by `IntermediateBase`.
    There’s no way to bypass that and call the original `LibraryBase.Start` directly.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果继承链更深呢？假设`CustomerDerived`派生自`IntermediateBase`，而`IntermediateBase`又派生自`LibraryBase`并重写了`Start`方法。在这种情况下，在我们的`Cus⁠tom⁠er​Der⁠iv⁠ed`类型中写`base.Start()`将调用`IntermediateBase`定义的重写。没有办法绕过这一点直接调用原始的`LibraryBase.Start`。
- en: In this example, I have called the base class’s implementation after completing
    my work. C# does not care when you call the base—you could call it as the first
    thing the method does, as the last, or halfway through the method. You could even
    call it several times, or not at all. It is up to the author of the base class
    to document whether and when the base class implementation of the method should
    be called by an override.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我在完成我的工作后调用了基类的实现。C#并不关心你什么时候调用基类——你可以在方法开始时调用它，在最后调用它，或者在方法中间的任何地方调用它。你甚至可以多次调用它，或者根本不调用它。调用基类方法的时间由基类的作者来决定，他需要文档化方法的重写是否应该调用基类实现。
- en: You can use the `base` keyword for other members too, such as properties and
    events. However, access to base constructors works a bit differently.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以对其他成员使用`base`关键字，如属性和事件。但是，对基类构造函数的访问方式略有不同。
- en: Inheritance and Construction
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承和构造
- en: Although a derived class inherits all the members of its base class, this does
    not mean the same thing for constructors as it does for everything else. With
    other members, if they are public in the base class, they will be public members
    of the derived class too, accessible to anyone who uses your derived class. But
    constructors are special, because someone using your class cannot construct it
    by using one of the constructors defined by the base class.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管派生类继承了其基类的所有成员，但这对构造函数的意义与其他所有成员并不相同。对于其他成员，如果它们在基类中是公共的，它们也将成为派生类的公共成员，可供任何使用你的派生类的人访问。但构造函数是特殊的，因为使用你的类的人无法通过使用基类定义的构造函数来构造它。
- en: 'There is a straightforward reason for this: if you want an instance of some
    type `D`, then you’ll want it to be a full-fledged `D` with everything in it properly
    initialized. Suppose that `D` derives from `B`. If you were able to use one of
    `B`’s constructors directly, it wouldn’t do anything to the parts specific to
    `D`. A base class’s constructor won’t know about any of the fields defined by
    a derived class, so it cannot initialize them. If you want a `D`, you’ll need
    a constructor that knows how to initialize a `D`. So with a derived class, you
    can use only the constructors offered by that derived class, regardless of what
    constructors the base class might provide.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个很简单的原因：如果你想要一个某种类型`D`的实例，那么你会希望它是一个完整的`D`，包含了所有适当初始化的内容。假设`D`派生自`B`。如果你能直接使用`B`的其中一个构造函数，它将不会对`D`特有的部分进行任何操作。基类的构造函数不会知道任何由派生类定义的字段，因此无法对其进行初始化。如果你想要一个`D`，你只能使用知道如何初始化`D`的构造函数。因此，对于派生类，你只能使用由该派生类提供的构造函数，不管基类提供了哪些构造函数。
- en: In the examples I’ve shown so far in this chapter, I’ve been able to ignore
    this because of the default constructor that C# provides. As you saw in [Chapter 3](ch03.xhtml#ch_types),
    if you don’t write a constructor, C# writes one for you that takes no arguments.
    It does this for derived classes too, and the generated constructor will invoke
    the no-arguments constructor of the base class. But this changes if I start writing
    my own constructors. [Example 6-37](#no_default_constructor_in_derived_class)
    defines a pair of classes, where the base defines an explicit no-arguments constructor,
    and the derived class defines one that requires an argument.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我展示的示例中，我之所以能忽略这一点，是因为C#提供的默认构造函数。如你在[第三章](ch03.xhtml#ch_types)中看到的，如果你不写一个构造函数，C#会为你写一个不带参数的构造函数。对于派生类也是如此，生成的构造函数将调用基类的无参数构造函数。但是如果我开始编写自己的构造函数，情况就会改变。[示例 6-37](#no_default_constructor_in_derived_class)定义了一对类，其中基类定义了一个显式的无参数构造函数，派生类定义了一个需要参数的构造函数。
- en: Example 6-37\. No default constructor in derived class
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-37\. 派生类中没有默认构造函数
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Because the base class has a zero-argument constructor, I can construct it
    with `new BaseWithZeroArgCtor()`. But I cannot do this with the derived type:
    I can construct that only by passing an argument—for example, `new DerivedNoDefaultCtor(123)`.
    So as far as the publicly visible API of `DerivedNoDefaultCtor` is concerned,
    the derived class appears not to have inherited its base class’s constructor.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 因为基类有一个零参数构造函数，我可以用`new BaseWithZeroArgCtor()`来构造它。但是对于派生类型，我不能这样做：我只能通过传递一个参数来构造它——例如，`new
    DerivedNoDefaultCtor(123)`。因此，就`DerivedNoDefaultCtor`的公开可见API而言，派生类似乎没有继承其基类的构造函数。
- en: 'However, it has in fact inherited it, as you can see by looking at the output
    you get if you construct an instance of the derived type:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实际上它确实已经继承了它，你可以通过构造派生类型的实例来看到得到的输出：
- en: '[PRE39]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When constructing an instance of `DerivedNoDefaultCtor`, the base class’s constructor
    runs immediately before the derived class’s constructor. Since the base constructor
    ran, clearly it was present. All of the base class’s constructors are available
    to a derived type, but they can be invoked only by constructors in the derived
    class. [Example 6-37](#no_default_constructor_in_derived_class) invoked the base
    constructor implicitly: all constructors are required to invoke a constructor
    on their base class, and if you don’t specify which to invoke, the compiler invokes
    the base’s zero-argument constructor for you.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造`DerivedNoDefaultCtor`的实例时，基类的构造函数会立即在派生类的构造函数之前运行。由于基类构造函数已运行，显然它是存在的。所有基类的构造函数都对派生类型可用，但只能由派生类中的构造函数调用。[示例 6-37](#no_default_constructor_in_derived_class)隐式调用了基类构造函数：所有构造函数都要求在其基类上调用一个构造函数，如果你没有指定调用哪一个，编译器将为你调用基类的零参数构造函数。
- en: What if the base doesn’t define a parameterless constructor? In that case, you’ll
    get a compiler error if you derive a class that does not specify which constructor
    to call. [Example 6-38](#invoking_a_base_constructor_explicitly) shows a base
    class without a zero-argument constructor. (The presence of explicit constructors
    disables the compiler’s normal generation of a default constructor, and since
    this base class supplies only a constructor that takes arguments, this means there
    is no zero-argument constructor.) It also shows a derived class with two constructors,
    both of which call into the base constructor explicitly, using the `base` keyword.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果基类没有定义一个无参构造函数怎么办？在这种情况下，如果你派生一个不指定调用哪个构造函数的类，你将会得到一个编译器错误。[示例 6-38](#invoking_a_base_constructor_explicitly)展示了一个没有零参数构造函数的基类。（显式构造函数的存在禁用了编译器正常生成默认构造函数的机制，因此，这个基类只提供了一个带参数的构造函数。）它同时展示了一个派生类有两个构造函数，它们都使用`base`关键字显式调用基类的构造函数。
- en: Example 6-38\. Invoking a base constructor explicitly
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-38\. 显式调用基类构造函数
- en: '[PRE40]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The derived class here decides to supply a parameterless constructor even though
    the base class doesn’t have one—it supplies a constant value for the argument
    the base requires. The second just passes its argument through to the base.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的派生类决定提供一个无参构造函数，尽管基类没有这样的构造函数——它为基类需要的参数提供了一个常量值。第二个则直接将其参数传递给基类。
- en: Note
  id: totrans-231
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Here’s a frequently asked question: *How do I provide all the same constructors
    as my base class, just passing the arguments straight through?* The answer is:
    *write all the constructors by hand*. There is no way to get the C# compiler to
    generate a set of constructors in a derived class that look identical to the ones
    that the base class offers. You need to do it the long-winded way.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个经常被问到的问题：*如何提供与我的基类完全相同的所有构造函数，只需直接传递参数？* 答案是：*手动编写所有构造函数*。没有办法让C#编译器生成一个看起来与基类提供的构造函数完全相同的构造函数集。您需要用比较冗长的方式来完成。
- en: At least Visual Studio, VS Code, or JetBrains Rider can generate the code for
    you—if you click on a class declaration, and then click the Quick Actions icon
    that appears, it will offer to generate constructors with the same arguments as
    any nonprivate constructor in the base class, automatically passing all the arguments
    through for you.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 至少Visual Studio、VS Code或JetBrains Rider可以为您生成代码——如果您点击类声明，然后点击出现的快速操作图标，它将提供生成与基类中任何非私有构造函数具有相同参数的构造函数的选项，并自动为您传递所有参数。
- en: 'As [Chapter 3](ch03.xhtml#ch_types) showed, a class’s field initializers run
    before its constructor. The picture is more complicated once inheritance is involved,
    because there are multiple classes and multiple constructors. The easiest way
    to predict what will happen is to understand that although instance field initializers
    and constructors have separate syntax, C# ends up compiling all the initialization
    code for a particular class into the constructor. This code performs the following
    steps: first, it runs field initializers specific to this class (so this step
    does not include base field initializers—the base class will take care of itself);
    next, it calls the base class constructor; and finally, it runs the body of the
    constructor. The upshot of this is that in a derived class, your instance field
    initializers will run before base class construction has occurred—not just before
    the base constructor body but even before the base’s instance fields have been
    initialized. [Example 6-39](#exploring_construction_order) illustrates this.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[第3章](ch03.xhtml#ch_types)所示，类的字段初始化器在其构造函数之前运行。一旦涉及继承，情况就变得更加复杂，因为涉及多个类和多个构造函数。预测将会发生什么最简单的方法是理解，尽管实例字段初始化器和构造函数具有不同的语法，但C#最终将所有特定类的初始化代码编译到构造函数中。此代码执行以下步骤：首先，运行特定于此类的字段初始化器（因此此步骤不包括基类字段初始化器——基类将自己照顾好）；接下来，调用基类构造函数；最后，运行构造函数体。这意味着在派生类中，您的实例字段初始化器将在基类构造之前运行——不仅仅是在基类构造函数体之前，甚至在基类的实例字段初始化之前。[示例6-39](#exploring_construction_order)说明了这一点。
- en: Example 6-39\. Exploring construction order
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例6-39。探索构造顺序
- en: '[PRE41]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'I’ve put the field initializers on either side of the constructor just to show
    that their position relative to nonfield members is irrelevant. The order of the
    fields matters, but only with respect to one another. Constructing an instance
    of the `DerivedInit` class produces this output:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我把字段初始化放在构造函数的两侧，只是为了表明它们相对于非字段成员的位置无关紧要。字段的顺序很重要，但只涉及彼此。构造`DerivedInit`类的实例会产生以下输出：
- en: '[PRE42]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This verifies that the derived type’s field initializers run first, and then
    the base field initializers, followed by the base constructor, and then finally
    the derived constructor. In other words, although constructor bodies start with
    the base class, instance field initialization happens in reverse.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这证实了派生类型的字段初始化器首先运行，然后是基类的字段初始化器，接着是基类构造函数，最后是派生类构造函数。换句话说，虽然构造函数体始于基类，但实例字段的初始化是反向进行的。
- en: That’s why you don’t get to invoke instance methods in field initializers. Static
    methods are available, but instance methods are not, because the class is a long
    way from being ready. It could be problematic if one of the derived type’s field
    initializers were able to invoke a method on the base class, because the base
    class has performed no initialization at all at that point—not only has its constructor
    body not run, but its field initializers haven’t run either. If instance methods
    were available during this phase, we’d have to write all of our code to be very
    defensive, because we could not assume that our fields contain anything useful.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么你不能在字段初始化器中调用实例方法的原因。静态方法是可用的，但实例方法不是，因为类远未准备就绪。如果派生类型的一个字段初始化器能够在基类上调用方法，可能会有问题，因为此时基类根本没有进行任何初始化——不仅其构造函数体尚未运行，而且其字段初始化器也尚未运行。如果实例方法在此阶段可用，我们将不得不编写所有的代码非常谨慎，因为我们不能假设我们的字段包含任何有用的内容。
- en: 'As you can see, the constructor bodies run relatively late in the process,
    which is why we are allowed to invoke methods from them. But there’s still potential
    danger here. What if the base class defines a virtual method and invokes that
    method on itself in its constructor? If the derived type overrides that, we’ll
    be invoking the method before the derived type’s constructor body has run. (Its
    field initializers will have run at that point, though. In fact, this is the main
    reason field initializers run in what seems to be reverse order—it means that
    derived classes have a way of performing some initialization before the base class’s
    constructor has a chance to invoke a virtual method.) If you’re familiar with
    C++, you might hazard a guess that when the base constructor invokes a virtual
    method, it’ll run the base implementation. But C# does it differently: a base
    class’s constructor will invoke the derived class’s override in that case. This
    is not necessarily a problem, and it can occasionally be useful, but it means
    you need to think carefully and document your assumptions clearly if you want
    your object to invoke virtual methods on itself during construction.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，构造函数体在进程中运行较晚，这就是我们可以在其中调用方法的原因。但这里仍然存在潜在的危险。如果基类定义了一个虚方法，并在其构造函数中调用该方法，如果派生类型覆盖了该方法，我们将在派生类型的构造函数体运行之前调用该方法。（在那时，它的字段初始化器将已经运行。实际上，这是字段初始化器以看似相反顺序运行的主要原因——这意味着派生类有一种在基类构造函数调用虚方法之前执行一些初始化的方式。）如果你熟悉C++，你可能会猜想，当基类构造函数调用虚方法时，它将运行基本实现。但C#的做法不同：基类的构造函数将在这种情况下调用派生类的重写方法。这不一定是问题，而且偶尔会很有用，但这意味着如果你希望你的对象在构造过程中调用自身的虚方法，你需要仔细思考并清楚地记录你的假设。
- en: Record Types
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录类型
- en: When you define a `record` type (or you use the more explicit but functionally
    identical `record class` syntax), the resulting record type is, from the runtime’s
    perspective, still a class. Record types can do most of the things that normal
    classes can—although they’re typically all about the properties, you can add other
    members such as methods and constructors. And it turns out that class-based records
    also support inheritance. (Naturally, since `record struct` types are value types,
    those do not support inheritance.)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义一个`record`类型（或者你使用更明确但功能上相同的`record class`语法），从运行时的角度来看，生成的记录类型仍然是一个类。记录类型可以做大多数普通类能做的事情——尽管它们通常关注属性，你还可以添加其他成员，如方法和构造函数。事实证明，基于类的记录类型也支持继承。（自然地，由于`record
    struct`类型是值类型，它们不支持继承。）
- en: There are some constraints on inheritance with record types. An ordinary class
    is not allowed to inherit from a record type—only record types can derive from
    record types. Similarly, a record type can inherit only from either another record
    type or the usual `object` base type. But within these constraints, inheritance
    with records works much as it does for classes. [Example 6-40](#record_inheritance)
    shows a base record and a couple of derived types.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 记录类型存在一些继承约束。普通类不允许从记录类型继承——只有记录类型可以从记录类型派生。同样，记录类型只能从另一个记录类型或通常的`object`基类型继承。但在这些约束条件下，记录类型的继承工作方式与类相似。[示例 6-40](#record_inheritance)展示了一个基本记录和几个派生类型。
- en: Example 6-40\. Record inheritance
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-40\. 记录继承
- en: '[PRE43]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'As this shows, we can define a record type as `abstract`. When a record is
    not using the positional syntax, the way we inherit from a base type (abstract
    or not) looks the same as for a class: as `OptionallyLabeledItem` shows, we put
    a colon after the type name, followed by the base type name. If our derived type
    wants to use the positional syntax, the colon and base type come after the parameter
    list, as the `Product` type shows. [Example 6-41](#initializing_derived_records)
    shows how to instantiate the two derived types defined in [Example 6-40](#record_inheritance).'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这显示的，我们可以将记录类型定义为`abstract`。当记录不使用位置语法时，我们从基类型（抽象或非抽象）继承的方式与类的方式相同：如`OptionallyLabeledItem`所示，我们在类型名称后放置一个冒号，后跟基类型名称。如果我们的派生类型想使用位置语法，则在参数列表后放置冒号和基类型，如`Product`类型所示。[示例 6-41](#initializing_derived_records)展示了如何实例化在[示例 6-40](#record_inheritance)中定义的两种派生类型。
- en: Example 6-41\. Instantiating derived record types
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-41\. 实例化派生记录类型
- en: '[PRE44]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Since the base class’s `Label` property does not need to be set, we’re free
    to construct either of the derived types without setting it. But if we do want
    to set it, we use exactly the same object initializer syntax as we would have
    done if that `Label` property were defined directly by `OptionallyLabeledItem`
    or `Product`. But what if the base type uses the positional syntax to define properties
    that are not optional? As [Example 6-42](#record_inheritance_positional) shows,
    the record inheritance syntax allows us to supply an argument list to the base
    class.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于基类的`Label`属性不需要设置，我们可以自由地构造两种派生类型中的任意一种而不设置它。但是如果我们确实想设置它，我们使用的对象初始化语法与如果`Label`属性直接由`OptionallyLabeledItem`或`Product`定义的方式完全相同。但是如果基类型使用位置语法定义非可选属性，那么怎么办？正如[示例 6-42](#record_inheritance_positional)所示，记录继承语法允许我们向基类提供参数列表。
- en: Example 6-42\. Deriving from a positional record
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-42\. 从位置记录派生
- en: '[PRE45]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`LightBulb` uses the positional syntax itself and uses one of its two constructor
    arguments as the value for the `Color` property that the base class requires.
    But in some cases, you might not want to pass a value through like this: sometimes
    a derived type will know what value to pass to the base record type, as [Example 6-43](#record_inheritance_base_ctor_constant)
    shows.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`LightBulb`本身使用位置语法，并使用其两个构造参数之一作为基类要求的`Color`属性的值。但在某些情况下，您可能不想这样传递值：有时派生类型将知道要传递给基记录类型的值，就像[示例 6-43](#record_inheritance_base_ctor_constant)所示的那样。'
- en: Example 6-43\. Passing a constant to a positional base record
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-43\. 将常量传递给位置基记录
- en: '[PRE46]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: So in this case, although the base `Colorful` record uses the positional syntax,
    requiring the `Color` property to be supplied, this derived type does not pass
    that requirement on. The popular story is that Ford’s early car, the Model T,
    was only available in one color, so this particular derived type can just set
    the `Color` itself. Users of the `FordModelT` record do not need to supply the
    `Color`, even though it’s a mandatory argument for the base `Colorful` type. Pedants
    will by now be itching to point out that this paint constraint applied only for
    12 of the 19 years for which the Model T was produced. I would draw their attention
    to [Example 6-44](#record_constructing_modelt), which shows that although the
    `FordModelT` type does not require the `Color` property to be passed during construction,
    it can still be set with an object initializer. So this record type enables the
    color to be specified just as it could with early and late Model Ts, but the default
    is aligned with the fact that the overwhelming majority of these cars were indeed
    black.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，尽管基`Colorful`记录使用位置语法，要求提供`Color`属性，但这个派生类型不传递该要求。流行的故事是，福特早期的汽车Model
    T只有一种颜色可供选择，因此这个特定的派生类型可以直接设置`Color`本身。`FordModelT`记录的用户无需提供`Color`，尽管这对于基`Colorful`类型是强制性参数。书呆子们现在可能渴望指出，这种油漆约束只适用于Model
    T生产的19年中的12年。我想吸引他们注意[示例 6-44](#record_constructing_modelt)，它显示了尽管`FordModelT`类型在构建过程中不需要传递`Color`属性，但仍可以使用对象初始化设置。因此，这种记录类型使得可以像早期和晚期Model
    T一样指定颜色，但默认与这种汽车绝大多数确实是黑色的事实保持一致。
- en: Example 6-44\. Using a derived record that has made a mandatory base property
    optional
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-44\. 使用一个将强制基属性变为可选的派生记录
- en: '[PRE47]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: To be able to use the syntax shown in Examples [6-42](#record_inheritance_positional)
    and [6-43](#record_inheritance_base_ctor_constant), where we put a positional
    argument list directly after the base class’s name, a record must itself use the
    positional syntax. If you look closely at [Example 6-43](#record_inheritance_base_ctor_constant),
    you’ll see that after the `FordModelT` type name, there’s an empty argument list.
    Although this may seem redundant, in this case it needs to be here, because without
    it, we wouldn’t be allowed to write `Colorful("Black")` after the colon.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够使用示例 [6-42](#record_inheritance_positional) 和 [6-43](#record_inheritance_base_ctor_constant)
    中显示的语法，在记录本身必须使用位置语法。 如果您仔细观察[示例 6-43](#record_inheritance_base_ctor_constant)，您会发现在
    `FordModelT` 类型名称之后有一个空参数列表。 虽然这可能看起来多余，但在这种情况下，需要将其放在这里，因为如果没有它，我们将不允许在冒号后直接写
    `Colorful("Black")`。
- en: There are other ways to pass arguments to a positional base record. As [Chapter 3](ch03.xhtml#ch_types)
    described, when we use the positional syntax, we are just defining a constructor,
    so an alternative would be to use the normal syntax for invoking the base constructor,
    as [Example 6-45](#invoke_base_record_ctor) shows.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他方法可以将参数传递给位置基础记录。 正如[第 3 章](ch03.xhtml#ch_types)所述，当我们使用位置语法时，我们只是定义一个构造函数，因此另一种方法是使用常规语法来调用基类构造函数，正如[示例 6-45](#invoke_base_record_ctor)所示。
- en: Example 6-45\. Passing positional base record arguments with an ordinary constructor
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-45\. 通过普通构造函数传递位置基础记录参数
- en: '[PRE48]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The last few examples have dealt with cases where a base class uses the positional
    syntax but where its derived type does not. But what about the converse, where
    the base type is not positional but a derived type wants to be? If the derived
    type just wants to add one or more of its own properties, this is straightforward.
    In fact, we’ve already seen it—the product type in [Example 6-40](#record_inheritance)
    does exactly this. However, what if the base type defines an optional property
    (such as `OptionallyLabeled.Label`) but the derived type wants to make that mandatory?
    You can do it, but you can’t use the positional syntax. You have to write the
    constructor in full, as [Example 6-46](#making_optional_base_prop_positional)
    shows.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最近几个示例处理了基类使用位置语法但派生类型不使用的情况。 但如果反过来，基类型不是位置的，而派生类型想要是位置的怎么办？ 如果派生类型只想添加一个或多个自己的属性，这很简单。
    实际上，我们已经看到了产品类型在[示例 6-40](#record_inheritance)中确实如此。 但是，如果基类型定义了一个可选属性（例如 `OptionallyLabeled.Label`），而派生类型想要将其变为强制性的，您可以这样做，但不能使用位置语法。
    您必须像[示例 6-46](#making_optional_base_prop_positional)所示一样完全编写构造函数。
- en: Example 6-46\. Making an optional base property class positional
  id: totrans-264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-46\. 使可选基本属性类位置性
- en: '[PRE49]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Although this doesn’t use the positional syntax, it has a similar effect, because
    the positional syntax works by defining a constructor. The presence of the constructor
    in [Example 6-46](#making_optional_base_prop_positional) will prevent the compiler
    from generating a default zero-argument constructor, meaning that code using `LabeledDemographic`
    will be obliged to provide the `Label` property during construction, just as if
    the positional syntax were in use. You automatically get a deconstructor when
    using the positional syntax, but I’ve had to write my own here. The compiler doesn’t
    generate one because deconstruction ends up being a little odd when attempting
    to impose positional behavior in a type deriving from a nonpositional record.
    The base class defines `Label` as optional, and even though we’ve defined a constructor
    that requires a non-null argument, it would be possible to follow the constructor
    with an object initializer that sets it back to `null`. (That would be weird but
    not illegal.) So our deconstructor ends up not quite matching our constructor.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这不使用位置语法，但它具有类似的效果，因为位置语法通过定义构造函数起作用。在[示例 6-46](#making_optional_base_prop_positional)中构造函数的存在将阻止编译器生成默认的零参数构造函数，这意味着使用
    `LabeledDemographic` 的代码在构造时必须提供 `Label` 属性，就像使用位置语法一样。在使用位置语法时，自动获得析构函数，但我这里不得不自己写。当试图对非位置记录派生类型强加位置行为时，编译器不生成析构函数会导致析构有点奇怪。基类将
    `Label` 定义为可选，尽管我们定义了需要非空参数的构造函数，但在构造函数后可以使用对象初始化程序将其设置回 `null`。 （这看起来很奇怪但不违法）。所以我们的析构函数最终与构造函数不完全匹配。
- en: Records, Inheritance, and the with Keyword
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录、继承和`with`关键字
- en: '[Chapter 3](ch03.xhtml#ch_types) showed how you can create modified copies
    of record types using a `with` expression. This builds a new instance that has
    all the same properties as the original except for any new property values you
    specify in the braces following the `with` keyword. This mechanism has been designed
    with inheritance in mind: the instance produced by the `with` keyword will always
    have the same type as its input, even in cases where the code is written in terms
    of the base type, like [Example 6-47](#base_record_with_expression).'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3章](ch03.xhtml#ch_types)展示了如何使用`with`表达式创建记录类型的修改副本。这会构建一个新实例，该实例除了在`with`关键字后面的大括号中指定的新属性值外，其他所有属性与原始实例相同。这种机制考虑了继承：`with`关键字生成的实例总是与其输入具有相同的类型，即使代码是以基础类型编写的，如[示例6-47](#base_record_with_expression)。'
- en: Example 6-47\. Using `with` on a base record type
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例6-47\. 在基础记录类型上使用`with`
- en: '[PRE50]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This uses the abstract `OptionallyLabeled` record type from [Example 6-40](#record_inheritance).
    We can call this passing in any concrete type derived from that abstract base.
    [Example 6-48](#with_inheritance_test) calls it twice with two different types.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用了从[示例6-40](#record_inheritance)中的抽象`OptionallyLabeled`记录类型。我们可以传递任何从该抽象基类派生的具体类型。[示例6-48](#with_inheritance_test)两次调用它，并传入两种不同的类型。
- en: Example 6-48\. Testing how `with` interacts with inheritance
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例6-48\. 测试`with`如何与继承交互
- en: '[PRE51]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Running that code produces this output:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该代码会产生以下输出：
- en: '[PRE52]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`Console.WriteLine` calls `ToString` on its input, and record types implement
    this by reporting their name and then their property values. So you can see from
    this that when the `Discount` method produced modified copies of its inputs, it
    successfully preserved the type. So even though `Discount` knows nothing about
    the `Product` record type or its `Name` property, when it created a copy with
    the new `Label` value, that `Name` property was correctly carried over.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`Console.WriteLine`在其输入上调用`ToString`，而记录类型通过报告其名称及其属性值来实现此方法。因此，您可以从中看到，当`Discount`方法生成其输入的修改副本时，它成功地保留了类型信息。因此，即使`Discount`对`Product`记录类型或其`Name`属性一无所知，当它创建一个带有新`Label`值的副本时，`Name`属性也被正确地保留了下来。'
- en: This works because of code that the compiler generates for record types. I already
    described the copy constructor in [Chapter 3](ch03.xhtml#ch_types), but that alone
    would not make this possible—the `Discount` method doesn’t know about the `OptionallyLabeledItem`
    or `Product` types, so it wouldn’t know to invoke their copy constructors. So
    records also get a hidden `virtual` method with an unspeakable name, `<Clone>$`.
    The `with` expression in [Example 6-47](#base_record_with_expression) invokes
    this (before going on to set the `Label` property). The compiler-generated `<Clone>$`
    method invokes its own copy constructor. Since derived record types override `<Clone>$`,
    a `with` expression will always get a full copy of the input record no matter
    what its type is, even when the code is written in terms of a base type.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由编译器为记录类型生成的代码所能够实现的。我已经在[第3章](ch03.xhtml#ch_types)中描述了复制构造函数，但光是这个还不够——`Discount`方法并不知道`OptionallyLabeledItem`或`Product`类型，因此它不会调用它们的复制构造函数。因此，记录类型还会得到一个隐藏的`virtual`方法，名为`<Clone>$`。在[示例6-47](#base_record_with_expression)中的`with`表达式会调用这个方法（然后继续设置`Label`属性）。由编译器生成的`<Clone>$`方法会调用自己的复制构造函数。由于派生的记录类型会重写`<Clone>$`，所以`with`表达式无论输入的类型如何，都会获得一个完全复制的记录。
- en: Special Base Types
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊的基础类型
- en: The .NET runtime libraries define a few base types that have special significance
    in C#. The most obvious is `System.Object`, which I’ve already described in some
    detail.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: .NET运行时库在C#中定义了几种具有特殊意义的基础类型。其中最明显的是`System.Object`，我已经对其进行了详细描述。
- en: 'There’s also `System.ValueType`. This is the abstract base type of all value
    types, so any `struct` or `record struct` you define—and also all of the built-in
    value types, such as `int` and `bool`—derive from `ValueType`. Ironically, `ValueType`
    itself is a reference type; only types that derive from `ValueType` are value
    types. Like most types, `ValueType` derives from `System.Object`. There is an
    obvious conceptual difficulty here: in general, derived classes are everything
    their base class is, plus whatever functionality they add. So, given that `object`
    and `ValueType` are both reference types, it may seem odd that types derived from
    `ValueType` are not. And for that matter, it’s not obvious how an `object` variable
    can hold a reference to an instance of something that’s not a reference type.
    I will resolve all of these issues in [Chapter 7](ch07.xhtml#ch_object_lifetime).'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`System.ValueType`。这是所有值类型的抽象基类型，因此你定义的任何`struct`或`record struct`，以及所有内置的值类型，如`int`和`bool`，都派生自`ValueType`。讽刺的是，`ValueType`本身是一个引用类型；只有从`ValueType`派生的类型才是值类型。像大多数类型一样，`ValueType`也派生自`System.Object`。在这里存在一个明显的概念上的困难：通常情况下，派生类包含其基类的所有功能，以及它们添加的任何功能。因此，考虑到`object`和`ValueType`都是引用类型，从`ValueType`派生的类型不是值类型似乎有些奇怪。而且，一个`object`变量如何能够持有一个不是引用类型的实例的引用，这也不是很明显。我将在[第7章](ch07.xhtml#ch_object_lifetime)中解决所有这些问题。
- en: C# does not permit you to write a type that derives explicitly from `ValueType`.
    If you want to write a type that derives from `ValueType`, that’s what the `struct`
    keyword is for. You can declare a variable of type `ValueType`, but since the
    type doesn’t define any public members, a `ValueType` reference doesn’t enable
    anything you can’t do with an `object` reference. The only observable difference
    is that with a variable of that type, you can assign instances of any value type
    into it but not instances of a reference type. Aside from that, it’s identical
    to `object`. Consequently, it’s fairly rare to see `ValueType` mentioned explicitly
    in C# code.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，不允许你编写一个明确从`ValueType`派生的类型。如果你想要编写一个从`ValueType`派生的类型，`struct`关键字就是为此而设计的。你可以声明一个`ValueType`类型的变量，但由于该类型未定义任何公共成员，`ValueType`引用不允许你做任何`object`引用做不到的事情。唯一显著的区别是，使用该类型的变量可以分配任何值类型的实例，但不能分配引用类型的实例。除此之外，它与`object`完全相同。因此，在C#代码中明确提到`ValueType`相对比较少见。
- en: 'Enumeration types also all derive from a common abstract base type: `System.Enum`.
    Since enums are value types, you won’t be surprised to find out that `Enum` derives
    from `ValueType`. As with `ValueType`, you would never derive from `Enum` explicitly—you
    use the `enum` keyword for that. Unlike `ValueType`, `Enum` does add some useful
    members. For example, its static `GetValues` method returns an array of all the
    enumeration’s values, while `GetNames` returns an array with all those values
    converted to strings. It also offers `Parse`, which converts from the string representation
    back to the enumeration value.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 所有枚举类型也都派生自一个共同的抽象基类型：`System.Enum`。由于枚举是值类型，你不会感到意外的是，`Enum`派生自`ValueType`。与`ValueType`类似，你永远不会明确从`Enum`派生——你使用`enum`关键字来定义枚举类型。与`ValueType`不同的是，`Enum`添加了一些有用的成员。例如，它的静态方法`GetValues`返回该枚举所有值的数组，而`GetNames`返回将所有值转换为字符串的数组。它还提供了`Parse`方法，用于从字符串表示转换回枚举值。
- en: As [Chapter 5](ch05.xhtml#ch_collections) described, arrays all derive from
    a common base class, `System.Array`, and you’ve already seen the features that
    offers.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第5章](ch05.xhtml#ch_collections)所述，所有的数组都源于一个共同的基类，`System.Array`，你已经看到了它所提供的特性。
- en: 'The `System.Exception` base class is special: when you throw an exception,
    C# requires that the object you throw be of this type or a type that derives from
    it. (Exceptions are the topic of [Chapter 8](ch08.xhtml#ch_exceptions).)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Exception`基类非常特殊：当你抛出异常时，C#要求抛出的对象必须是这种类型或者从它派生的类型。（异常是[第8章](ch08.xhtml#ch_exceptions)的主题。）'
- en: Delegate types all derive from a common base type, `System.MulticastDelegate`,
    which in turn derives from `System.Delegate`. I’ll discuss these in [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 委托类型都源于一个共同的基类型，`System.MulticastDelegate`，后者又从`System.Delegate`派生。我将在[第9章](ch09.xhtml#ch_delegates_lambdas_events)中讨论这些内容。
- en: Those are all the base types that the CTS treats as being special. There’s one
    more base type to which the C# compiler assigns particular significance, and that’s
    `Sys⁠tem.​Att⁠rib⁠ute`. In [Chapter 1](ch01.xhtml#ch_introducing_csharp), I applied
    certain annotations to methods and classes to tell the unit test framework to
    treat them specially. These attributes all correspond to types, so when I applied
    the `[TestClass]` attribute to a class, I was using a type called `TestClassAttribute`.
    Types designed to be used as attributes are all required to derive from `System.Attribute`.
    Some of them are recognized by the compiler—for example, there are some that control
    the version numbers that the compiler puts into the file headers of the EXE and
    DLL files it produces. I’ll show all of this in [Chapter 14](ch14.xhtml#ch_attributes).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是CTS视为特殊的基本类型。还有一种基本类型被C#编译器赋予特殊意义，那就是`Sys⁠tem.​Att⁠rib⁠ute`。在[第1章](ch01.xhtml#ch_introducing_csharp)中，我为方法和类应用了某些注解，以告诉单元测试框架将它们视为特殊处理。这些属性都对应于类型，因此当我将`[TestClass]`属性应用于一个类时，我使用了名为`TestClassAttribute`的类型。设计用作属性的类型都需要派生自`System.Attribute`。其中一些被编译器识别—例如，有些控制编译器将其生成的EXE和DLL文件的文件头中的版本号。我将在[第14章](ch14.xhtml#ch_attributes)中展示所有这些内容。
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: C# supports single implementation inheritance, and only with classes or reference
    type records—you cannot derive from a struct at all. However, interfaces can declare
    multiple bases, and a class can implement multiple interfaces. Implicit reference
    conversions exist from derived types to base types, and generic interfaces and
    delegates can choose to offer additional implicit reference conversions using
    either covariance or contravariance. All types derive from `System.Object`, guaranteeing
    that certain standard members are available on all variables. We saw how virtual
    methods allow derived classes to modify selected members of their bases, and how
    sealing can disable that. We also looked at the relationship between a derived
    type and its base when it comes to accessing members, and constructors in particular.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: C#支持单一实现继承，仅限于类或引用类型记录—你无法从结构体派生。然而，接口可以声明多个基类，类可以实现多个接口。从派生类型到基类型存在隐式引用转换，并且泛型接口和委托可以选择使用协变或逆变来提供额外的隐式引用转换。所有类型都派生自`System.Object`，确保所有变量都可用某些标准成员。我们看到虚方法如何允许派生类修改其基类的选定成员，以及如何使用封闭禁用该功能。我们还探讨了派生类型在访问成员时与其基类之间的关系，特别是构造函数。
- en: Our exploration of inheritance is complete, but it has raised some new issues,
    such as the relationship between value types and references and the role of finalizers.
    So, in the next chapter, I’ll talk about the connection between references and
    an object’s life cycle, along with the way the CLR bridges the gap between references
    and value types.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对继承的探索已经完成，但是它引发了一些新问题，比如值类型和引用之间的关系以及终结器的作用。因此，在下一章中，我将讨论引用与对象生命周期之间的关系，以及CLR如何弥合引用和值类型之间的差距。
- en: ^([1](ch06.xhtml#CHP-6-FN-1-marker)) More precisely, the same assembly, and
    also friend assemblies. [Chapter 12](ch12.xhtml#ch_assemblies) describes assemblies.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch06.xhtml#CHP-6-FN-1-marker)) 更准确地说，同一个程序集，还有友元程序集。[第12章](ch12.xhtml#ch_assemblies)描述了程序集。
