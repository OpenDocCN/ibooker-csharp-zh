- en: Chapter 5\. Containerization of .NET
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章\. .NET的容器化
- en: One way to think about containers is as a technology revolution. Think about
    the internal combustion engine, which went a long way toward transforming the
    way society used transportation. But now, a new transformation is taking place
    with the popularity of electric vehicles. They are creating a new way to drive!
    The same idea applies to the subject of containers when compared to virtual machines—you’ll
    see what we mean in a moment.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 认识容器的一种方式是将其视为技术革命。想象一下内燃机，它在改变社会对交通方式使用的方式上取得了长足进步。但现在，随着电动汽车的普及，正在发生一场新的变革！与虚拟机相比，容器也是如此。您一会儿就会明白我们的意思。
- en: Machines used for transportation have undergone multiple shifts throughout the
    centuries as technology has improved.^([1](ch05.xhtml#idm45599652783696)) Currently,
    the next wave of innovation in engines is around electric vehicles. Electric vehicles
    are faster, have more torque, more range, and allow for new ways of fueling that
    do not require access to fuel depots since they can charge by the sun or the electric
    grid. Electric vehicles create a new way to fuel a car, like charging while parked
    at home, at work, or on a road trip. Deeply coupled with electric vehicles is
    work on building autonomous or semiautonomous cars. New technologies enable new
    ways to work.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着技术的进步，用于交通的机器经历了多次变革。^([1](ch05.xhtml#idm45599652783696)) 目前，引擎创新的下一波浪潮围绕电动汽车展开。电动汽车更快、扭矩更大、续航更长，并且允许新的加油方式，无需访问燃料库，因为它们可以通过太阳或电网充电。电动汽车创造了一种新的汽车加油方式，例如在家中、工作中或在旅途中停车时充电。电动汽车的发展紧密结合着自动驾驶或半自动驾驶汽车的建设。新技术促使了新的工作方式。
- en: A similar progression has occurred with computing over the decades, as shown
    in [Figure 5-1](#Figure-5-1-2).^([2](ch05.xhtml#idm45599652781312)) Computing
    has morphed into smaller and more portable computing units, currently manifested
    as containers. In turn, these new computing units enable new ways to work. Containers
    provide a standard way to package your application’s code, configurations, and
    dependencies into a single entity. Containers run within the host operating system
    but run as lightweight, resource-isolated processes, ensuring quick, reliable,
    reproducible, and consistent deployments.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年来，计算机的发展经历了类似的进展，如[图5-1](#Figure-5-1-2)所示。^([2](ch05.xhtml#idm45599652781312))
    计算机已经演变成更小、更便携的计算单元，目前体现为容器。这些新的计算单元为新的工作方式铺平了道路。容器提供了将应用程序的代码、配置和依赖项打包成单一实体的标准方式。容器在主机操作系统中运行，但作为轻量级、资源隔离的进程运行，确保快速、可靠、可重复和一致的部署。
- en: '![doac 0501](assets/doac_0501.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0501](assets/doac_0501.png)'
- en: Figure 5-1\. Technological progression of compute
  id: totrans-5
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-1\. 计算技术的技术进步
- en: Before we can dig into using container services on AWS, we first need to discuss
    containers a bit more, starting with an overview of both containers and Docker,
    an open platform for designing, delivering, and executing applications. First,
    let’s look at containers in more depth.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论如何在AWS上使用容器服务之前，我们首先需要更详细地讨论容器，从容器和Docker的概述开始，后者是一个用于设计、交付和执行应用程序的开放平台。首先，让我们更深入地了解容器。
- en: Introduction to Containers
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器简介
- en: The key innovation of a container is the ability to package the runtime needed
    for the software solution alongside the code. As a result of modern container
    technology, a user can run a `docker run` command to run a solution and not worry
    about installing any software. Similarly, a developer can look inside a `git`
    repository and inspect the code and the runtime necessary to run it by looking
    at the `Dockerfile` as shown in [Figure 5-2](#Figure-5-0-1-container-deploy).
    In this example, GitHub serves as the central “source of truth” where each component
    necessary to deploy an application is in the repository. The `Dockerfile` defines
    the runtime. The Infrastructure as Code (IaC) describes the cloud configuration,
    such as networking and loadbalancing. The build system config file specifies the
    process for software project builds and deploys.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的关键创新在于能够将软件解决方案所需的运行时与代码一起打包。由于现代容器技术，用户可以运行`docker run`命令来执行解决方案，而不必担心安装任何软件。同样，开发人员可以查看`Dockerfile`，查看需要运行代码和运行时的详细信息，如[图5-2](#Figure-5-0-1-container-deploy)所示。在此示例中，GitHub作为中央的“真相源”，存储了部署应用程序所需的每个组件。`Dockerfile`定义了运行时。基础设施即代码（IaC）描述了云配置，如网络和负载均衡。构建系统配置文件指定了软件项目构建和部署的过程。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'A great example of the advantage of containers is using a Docker one-liner
    to run [Docker Hub SQL Server](https://oreil.ly/OuNbY). The following example
    shows how to start an `mssql-server` instance running as the SQL Express edition:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 容器优势的一个很好的例子是使用Docker单行命令运行[Docker Hub SQL Server](https://oreil.ly/OuNbY)。以下示例展示了如何启动运行SQL
    Express版本的`mssql-server`实例：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![doac 0502](assets/doac_0502.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0502](assets/doac_0502.png)'
- en: Figure 5-2\. Reproducible container-based deployment
  id: totrans-13
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-2\. 可复现的基于容器的部署
- en: A virtual machine inherits the legacy of the physical data center. In one sense,
    a virtual machine is a copy of the physical data center compute technology. But
    if you look at a container, it’s an entirely new way of thinking and working.
    The infrastructure definition, the runtime definition, source code, and build
    server configuration can all be in the same project. As a result of this new way
    of working, there is new transparency for the lifecycle of a software development
    project.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机继承了物理数据中心的遗产。从某种意义上说，虚拟机是物理数据中心计算技术的复制。但是如果你看看容器，它是一种全新的思考和工作方式。基础设施定义、运行时定义、源代码和构建服务器配置可以全部在同一个项目中。由于这种新的工作方式，软件开发项目的生命周期有了新的透明度。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Not all projects keep the IaC, build configuration, Dockerfile, and source code
    in the same repository. These assets can live in multiple repositories as well
    as a single repo.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有项目都将IaC、构建配置、Dockerfile和源代码保存在同一个存储库中。这些资产可以存在于多个仓库，也可以存在于单个仓库中。
- en: If you look at a virtual machine, it’s opaque what is inside it in terms of
    installed software and configuration. Another considerable downside of the virtual
    machine is start-up time, as it can take several minutes to start up a virtual
    machine.^([3](ch05.xhtml#idm45599652743104)) If you’re going to deploy a microservice
    or a web app using load balancers and virtual machines, you have to design around
    these limitations. With a container-based service, you can count on deploying
    thousands of container instances in seconds with ECS,^([4](ch05.xhtml#idm45599652740480))
    so there’s a considerable advantage to deploying things via containers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看看虚拟机，就不清楚它内部安装了什么软件和配置。虚拟机的另一个显著缺点是启动时间长，因为启动虚拟机可能需要几分钟时间。^([3](ch05.xhtml#idm45599652743104))如果你要部署微服务或使用负载均衡器和虚拟机的Web应用程序，你必须设计解决这些限制。通过基于容器的服务，您可以依靠使用ECS在几秒钟内部署成千上万个容器实例，^([4](ch05.xhtml#idm45599652740480))因此通过容器部署事物有相当大的优势。
- en: Let’s look at another way of getting started with containers—the desktop versus
    the cloud. The Docker environment is an ideal environment for local experimentation
    with the desktop. It allows you to upload or download containers that will enable
    you to start using standalone containers or use Kubernetes workflows, as shown
    in [Figure 5-3](#Figure-5-0-2-container-workflow). The Dockerfile uses a base,
    read-only image stored in the container registry. The local development workflow
    involves building a writeable new container where a developer will build, test,
    run, and finally deploy the container to a container registry by pushing it there.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看另一种启动容器的方式——桌面与云的对比。Docker环境是桌面上进行本地实验的理想环境。它允许你上传或下载容器，从而使你能够开始使用独立容器或使用Kubernetes工作流程，如[图5-3](#Figure-5-0-2-container-workflow)所示。Dockerfile使用存储在容器注册表中的基础只读镜像。本地开发工作流程涉及构建一个可写新容器，开发人员将在其中构建、测试、运行，并最终通过将其推送到容器注册表来部署容器。
- en: '![doac 0503](assets/doac_0503.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0503](assets/doac_0503.png)'
- en: Figure 5-3\. Container workflow
  id: totrans-20
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-3\. 容器工作流程
- en: It’s a great place to play around with your ideas before moving to the cloud.
    Similarly, a developer can download containers built by the domain experts at
    AWS and execute them in their local environment.^([5](ch05.xhtml#idm45599652735200))
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在转向云之前，这是一个很好的地方，可以在此处玩弄你的想法。同样，开发人员可以下载由AWS的领域专家构建的容器，并在本地环境中执行它们。^([5](ch05.xhtml#idm45599652735200))
- en: Once you’ve decided what you want to do and toyed around a bit locally, naturally,
    you can move into an AWS environment and start interacting with these containers
    in a cloud native manner. Starting with AWS Cloud9 is a great way to experiment
    with containers. You can build the containers in the cloud development environment,
    save the environment, and then deploy that container to ECR. You can also experiment
    with containers by launching a virtual machine and then doing the build process
    on that virtual machine.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您决定要做什么并在本地进行了一些实验后，自然而然地，您可以进入 AWS 环境，并开始以云原生方式与这些容器进行交互。从 AWS Cloud9 开始是一个很好的实验容器的方法。您可以在云开发环境中构建容器，保存环境，然后将该容器部署到
    ECR。您还可以通过启动虚拟机来实验容器，然后在该虚拟机上进行构建过程。
- en: Yet another option is to develop locally using Docker tools and Visual Studio.
    Let’s discuss Docker next.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用 Docker 工具和 Visual Studio 在本地进行开发。让我们接下来讨论 Docker。
- en: Introduction to Docker
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 简介
- en: Docker is an open source platform for managing the lifecycle of containers.
    It allows a developer to package and develop applications into Docker container
    images, defined by Dockerfiles, and run containerized applications developed externally
    or locally. One of the more popular aspects of Docker is its container registry,
    Docker Hub, which allows collaboration with containers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 是一个用于管理容器生命周期的开源平台。它允许开发人员将应用程序打包并开发为 Docker 容器镜像，由 Dockerfile 定义，并运行在外部或本地开发的容器化应用程序。Docker
    的一个更受欢迎的方面是其容器注册表 Docker Hub，它允许与容器进行协作。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There are container image formats beyond the [Docker container image format](https://oreil.ly/IsKxP).
    Another container image format is [Open Container Initiative (OCI) Specification](https://oreil.ly/IetNb).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 [Docker 容器镜像格式](https://oreil.ly/IsKxP) 外，还有其他容器镜像格式，比如 [Open Container Initiative
    (OCI) 规范](https://oreil.ly/IetNb)。
- en: What problem do [Docker containers](https://oreil.ly/HF9zX) solve? The OS, runtime,
    and code package together in the built container image. This action solves an
    incredibly complicated problem with a long history. A famous meme goes, “It works
    on my machine!” While this is often said as a joke to illustrate the complexity
    of deploying software, it is also true that without containers packaging the runtime
    together with the code, it is tough to verify a local development solution will
    behave the same when distributed to production. Containers solve this exact problem.
    If the code works in a container, the container configuration file checks in as
    any other type of code into the source code repository.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 容器解决了什么问题？操作系统、运行时和代码包装在构建的容器镜像中。这一行动解决了一个历史悠久的非常复杂的问题。有一个著名的段子说，“在我的机器上可以运行！”虽然这经常被当作一个玩笑来说明部署软件的复杂性，但没有容器将运行时与代码一起打包，很难验证本地开发解决方案在分发到生产环境时是否会表现相同。容器解决了这个确切的问题。如果代码在容器中运行良好，那么容器配置文件将像任何其他类型的代码一样检查源代码库。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It is common for modern application best practices to include IaC that provisions
    the environment alongside the container. In this [blog post about Amazon internal
    best practices](https://oreil.ly/dPm35), the author notes that for containerized
    applications, it is considered the best practice to deploy code changes and microservice
    infrastructure changes through the same CI/CD release pipeline.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用程序最佳实践通常包括 IaC，它会同时配置环境和容器。在这篇关于亚马逊内部最佳实践的[博文](https://oreil.ly/dPm35)中，作者指出对于容器化应用程序，通过相同的
    CI/CD 发布流水线部署代码更被认为是最佳实践。
- en: Containers have been around for quite some time but in different forms. One
    of the modern forms of containers was Solaris Containers, released in 2004\. It
    allowed you to telnet to a powered-off machine capable of responding to commands
    through a Lights Out Management (LOM) card, which told it to boot. It would then
    “kickstart” a machine with no operating system into booting from the network,
    then via ssh and through the vim text editor, create new containers, which also
    booted off the network.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 容器已经存在了相当长的时间，但是以不同的形式存在。现代容器的一种形式是 Solaris Containers，于 2004 年发布。它允许您 telnet
    到一个关机的机器，通过 Lights Out Management (LOM) 卡片响应命令，告诉它启动。然后它会从网络启动一个没有操作系统的机器，并通过
    ssh 和 vim 文本编辑器创建新的容器，这些容器也从网络引导启动。
- en: 'Since then, containers have continued to improve and enable additional workflows,
    such as continuous delivery and packaging code and runtime together. Docker is
    the most popular container format. In [Figure 5-4](#Figure-5-1), notice how the
    ecosystem plays out in practice. There are two primary components of Docker: [Docker
    Desktop](https://oreil.ly/gfcmt) and [Docker Hub](https://oreil.ly/iNGPb). With
    Docker Desktop, the local development workflow includes access to a Linux container
    runtime, developer tools, the Docker app itself, and an optional Kubernetes installation.
    In the case of Docker Hub, there is both private and public container repository,
    automated build of container images, collaboration features like teams and organizations,
    and certified images.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，容器继续改进并支持额外的工作流程，如持续交付和将代码与运行时打包在一起。Docker 是最流行的容器格式。在 [图 5-4](#Figure-5-1)
    中，注意生态系统在实践中的运作方式。Docker 的两个主要组成部分是 [Docker Desktop](https://oreil.ly/gfcmt) 和
    [Docker Hub](https://oreil.ly/iNGPb)。对于 Docker Desktop，本地开发工作流程包括访问 Linux 容器运行时、开发工具、Docker
    应用程序本身以及可选的 Kubernetes 安装。对于 Docker Hub，有私有和公共容器仓库、容器镜像的自动构建、团队和组织等协作功能，以及认证镜像。
- en: '![doac 0504](assets/doac_0504.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0504](assets/doac_0504.png)'
- en: Figure 5-4\. Docker ecosystem
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-4\. Docker 生态系统
- en: Note
  id: totrans-35
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A further innovation with modern containers is the concept of inheriting from
    a *base image*. A base image allows you to leverage developers’ expertise from
    many different domains such as Python, .NET, or Linux to build your container
    on top of their base image. Additionally, they save a developer time and effort
    in putting an entire image together from scratch.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现代容器的另一个创新是从*基础镜像*继承的概念。基础镜像允许您利用开发人员在各种领域（如 Python、.NET 或 Linux）的专业知识来构建您的容器。此外，它们节省了开发人员从头开始组装整个镜像的时间和精力。
- en: Next, let’s dive a bit deeper into the Docker ecosystem.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们深入了解 Docker 生态系统。
- en: Docker Ecosystem
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 生态系统
- en: Docker operates by providing a definitive way to run your code. Multiple AWS
    services [work with Docker](https://aws.amazon.com/docker) container images. These
    services include [Amazon ECS (Amazon Elastic Container Service)](https://aws.amazon.com/ecs),
    and [Amazon ECR (Elastic Container Registry)](https://aws.amazon.com/ecr), a secure
    container image repository. Also worth noting is [Amazon EKS (Elastic Kubernetes
    Service)](https://aws.amazon.com/eks), a managed container service that enables
    Kubernetes applications, and AWS App Runner, a PaaS for containerized applications,
    which is discussed later in the chapter, and finally AWS Lambda.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 的运作方式是通过提供一个确定的方法来运行你的代码。多个 AWS 服务与 [Docker](https://aws.amazon.com/docker)
    容器镜像配合工作。这些服务包括 [Amazon ECS（Amazon 弹性容器服务）](https://aws.amazon.com/ecs)，以及 [Amazon
    ECR（弹性容器注册表）](https://aws.amazon.com/ecr)，一个安全的容器镜像仓库。值得注意的还有 [Amazon EKS（弹性 Kubernetes
    服务）](https://aws.amazon.com/eks)，这是一个托管的容器服务，支持 Kubernetes 应用，以及 AWS App Runner，一个用于容器化应用程序的
    PaaS，在本章节后面会详细讨论，最后还有 AWS Lambda。
- en: The desktop application contains the container runtime, which allows containers
    to execute. It also orchestrates the local development workflow, including the
    ability to use [Kubernetes](https://github.com/kubernetes/kubernetes), which is
    an open source system for managing containerized applications that came out of
    Google.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面应用程序包含容器运行时，允许容器执行。它还编排本地开发工作流程，包括使用 [Kubernetes](https://github.com/kubernetes/kubernetes)，这是一个来自
    Google 的用于管理容器化应用程序的开源系统。
- en: Next, let’s discuss how Docker Hub interacts with Docker Desktop and other container
    development environments. Just as the [`git`](https://git-scm.com) source code
    ecosystem has local developer tools like [Vim](https://www.vim.org), [eMacs](https://www.gnu.org/software/emacs),
    [Visual Studio Code](https://code.visualstudio.com), or [Xcode](https://developer.apple.com/xcode)
    that work with it, Docker Desktop works with Docker containers and allows for
    local use and development.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论 Docker Hub 如何与 Docker Desktop 和其他容器开发环境交互。就像 [`git`](https://git-scm.com)
    源代码生态系统有本地开发工具如 [Vim](https://www.vim.org)，[eMacs](https://www.gnu.org/software/emacs)，[Visual
    Studio Code](https://code.visualstudio.com)，或者 [Xcode](https://developer.apple.com/xcode)
    与之配合一样，Docker Desktop 与 Docker 容器一起工作，支持本地使用和开发。
- en: When collaborating with `git` outside of the local environment, developers often
    use platforms like [GitHub](https://github.com) or [GitLab](https://about.gitlab.com)
    to communicate with other parties and share code. [Docker Hub](https://hub.docker.com)
    works similarly. Docker Hub allows developers to share Docker containers that
    can serve as the base image for building new solutions and pull down complete
    solutions like a SQL server image.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发人员在本地环境之外使用`git`进行协作时，通常会使用类似[GitHub](https://github.com)或[GitLab](https://about.gitlab.com)等平台与其他方沟通并共享代码。[Docker
    Hub](https://hub.docker.com)的工作方式类似。Docker Hub允许开发人员共享Docker容器，这些容器可以作为构建新解决方案和下载完整解决方案（如SQL服务器镜像）的基础映像。
- en: These base images, built by experts, are certified to be high quality, i.e.,
    the [official ASP.NET Core Runtime](https://oreil.ly/nx7Qm) from Microsoft. This
    process allows a developer to leverage the right expert’s expertise on a particular
    software component and improve their container’s overall quality. This concept
    is similar to using a library developed by another developer versus writing it
    yourself.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些由专家构建的基础映像已经获得高质量认证，例如来自Microsoft的[官方ASP.NET Core Runtime](https://oreil.ly/nx7Qm)。这个过程允许开发人员利用特定软件组件的专家知识，并改进其容器的整体质量。这个概念类似于使用另一位开发者开发的库而不是自己编写它。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Like a software library, a Dockerfile allows you to bind your implementation
    to an existing version with the additional capability of running in an encapsulated
    environment.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 就像一个软件库，Dockerfile允许您将实现绑定到现有版本，并在封装的环境中运行。
- en: Next, let’s dig a little deeper into how Docker containers compare to virtual
    machines.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们深入探讨Docker容器与虚拟机的比较。
- en: Containers Versus Virtual Machines?
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器与虚拟机？
- en: '[Table 5-1](#containers_vs_virtual_machines) provides a high-level breakdown
    of the differences between a container and a virtual machine.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 5-1](#containers_vs_virtual_machines) 提供了容器和虚拟机之间差异的高级分解。'
- en: Table 5-1\. Containers versus virtual machines
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-1\. 容器与虚拟机
- en: '| Category | Container | Virtual machine |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | 容器 | 虚拟机 |'
- en: '| --- | --- | --- |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Size | MBs | GBs |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 大小 | MB | GB |'
- en: '| Speed | Boot in milliseconds | Boot in minutes |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 速度 | 几毫秒启动 | 几分钟启动 |'
- en: '| Composability | Source code as file | Image-based build process |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 可组合性 | 源代码作为文件 | 基于映像的构建过程 |'
- en: Note
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Note that there are other containers besides Docker containers, including Windows
    and Linux alternatives. Docker is the most popular format and for the sake of
    this chapter, assume all references to containers going forward will be Docker
    containers.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意除了Docker容器外，还有其他容器，包括Windows和Linux的替代品。Docker是最流行的格式，为了本章的目的，假设所有对容器的引用都将是Docker容器。
- en: 'The core advantage of containers is that they are smaller, composable, and
    faster to launch. Where virtual machines do well is in scenarios that require
    a copy of the paradigms of the physical data center. An example of this workflow
    would be moving a web application running in a physical data center without changing
    the code to a cloud-based virtual machine. Let’s look at some real-world examples
    where containers helped a project run smoothly:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的核心优势在于它们更小、可组合且启动更快。虚拟机在需要复制物理数据中心范例的场景中表现出色。例如，将运行在物理数据中心中的Web应用程序移动到基于云的虚拟机中而不改变代码。让我们看一些真实世界的例子，容器如何帮助项目顺利运行：
- en: Developer shares local project
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员分享本地项目
- en: A developer can work on a .NET web application that uses `Blazor` (an example
    covered later in the chapter). The Docker container image handles the installation
    and configuration of the underlying operating system. Another team member can
    check out the code and use `docker run` to run the project. This process eliminates
    what could be a multiday problem of configuring a laptop correctly to run a software
    project.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员可以使用`.NET` Web应用程序进行开发，使用`Blazor`（稍后在本章中讨论的一个示例）。Docker容器镜像处理了底层操作系统的安装和配置。另一位团队成员可以检出代码并使用`docker
    run`来运行项目。这个过程消除了配置笔记本电脑以正确运行软件项目可能需要数天的问题。
- en: Data scientist shares Jupyter notebook with a researcher at another university
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学家与另一所大学的研究人员分享Jupyter笔记本
- en: A data scientist working with [Jupyter-style notebooks](https://jupyter.org)
    wants to share a complex data science project with multiple dependencies on C,
    Julia, Fortran, R, and Python code. They package up the runtime as a Docker container
    image and eliminate the back-and-forth over several weeks when sharing a project
    like this.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一位与[Jupyter风格笔记本](https://jupyter.org)一起工作的数据科学家希望与多个依赖于C、Julia、Fortran、R和Python代码的复杂数据科学项目分享。他们将运行时打包为Docker容器镜像，消除了在分享此类项目时几周来回的问题。
- en: A machine learning engineer load tests a production machine learning model
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一位机器学习工程师在生产机器学习模型中进行负载测试
- en: A machine learning engineer builds a new ML model and deploys it to production.
    Previously, they were concerned about accurately testing the new model’s accuracy
    before committing to it. The model recommends products to paying customers to
    purchase additional products they may like. If the model is inaccurate, it could
    cost the company a lot of revenue. Using containers to deploy the ML model in
    this example, it is possible to deploy the model to a fraction of the customers.
    They can start at only 10% at first, and if there are problems, the model is quickly
    reverted. If the model performs well, it can promptly replace the existing models.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一位机器学习工程师构建了一个新的机器学习模型，并将其部署到生产环境中。此前，他们担心在承诺之前准确测试新模型的准确性。该模型推荐产品给付费客户以购买可能喜欢的额外产品。如果模型不准确，可能会给公司带来大量收入损失。在此示例中使用容器部署ML模型，可以将模型部署到一小部分客户。一开始可以从只有10%开始，并且如果出现问题，可以快速回滚模型。如果模型表现良好，可以迅速替换现有模型。
- en: Finally, other scenarios for containers include building microservices, doing
    continuous integration, data processing, and containers as a service (CaaS). Let’s
    dive into some of these topics in the next section.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，容器的其他场景包括构建微服务、进行持续集成、数据处理以及作为服务的容器（CaaS）。让我们在下一节中深入探讨其中一些主题。
- en: Developing with AWS Container Compatible Services
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS容器兼容服务进行开发
- en: There are multiple ways a .NET developer can deploy containers on AWS, including
    AWS Lambda, Amazon ECS, Amazon EKS, and AWS App Runner. A good starter point to
    dive deeper into the latest container services is the [AWS containers documentation](https://aws.amazon.com/containers).
    Among other things, it covers a high-level overview of current container services
    offered at AWS and everyday use cases.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: .NET开发人员可以通过多种方式在AWS上部署容器，包括AWS Lambda、Amazon ECS、Amazon EKS和AWS App Runner。深入了解最新容器服务的一个好的起点是[AWS容器文档](https://aws.amazon.com/containers)。除其他内容外，它还涵盖了AWS提供的当前容器服务的高级概述和日常使用案例。
- en: Which abstraction is best depends on what level of the shared responsibility
    model a developer wants.^([6](ch05.xhtml#idm45599652651680)) Next, let’s dive
    into these container scenarios using a fully cloud native workflow with Cloud9
    and AWS container services.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 选择最佳的抽象取决于开发人员希望在共享责任模型的哪个级别[^6]。接下来，让我们使用完全云原生的工作流程与Cloud9和AWS容器服务深入探讨这些容器场景。
- en: Using AWS Container Services for .NET with Cloud9
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Cloud9和AWS容器服务进行.NET开发
- en: A space station is a spaceship that sits in the Earth’s low orbit and allows
    astronauts to spend time in space, do research in labs, or recover for a future
    trip to a new destination. Similarly, if you are a cloud developer, the best place
    to develop for the cloud is the cloud!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 空间站是一艘停留在地球低轨道的太空飞船，允许宇航员在太空中度过时间、在实验室进行研究或为前往新目的地的未来旅行做准备。同样，如果你是云开发人员，为云开发的最佳地方就是云！
- en: Cloud9 is a cloud-based development that includes deep integration with AWS
    and works in a browser. This technology radically departs from traditional software
    engineering development practices since it opens up many new ways to work.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud9是一种基于云的开发工具，与AWS深度集成，并在浏览器中运行。这项技术从传统的软件工程开发实践中彻底出发，因为它开启了许多新的工作方式。
- en: 'Here are a few reasons why Cloud9 is so good for cloud development:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Cloud9在云开发中如此出色的几个原因：
- en: Close proximity to AWS resources
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 靠近AWS资源
- en: If you are in a coffee shop, it could be challenging to copy files back and
    forth to the cloud, but if you use a web browser IDE, the response time doesn’t
    matter since the IDE is sitting next to the servers it communicates with within
    AWS. This advantage comes in handy with building containers because you can quickly
    push container images to the Amazon ECR.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在咖啡店里，复制文件到云中或从云中复制文件可能会很有挑战性，但是如果您使用Web浏览器IDE，响应时间并不重要，因为IDE就在与AWS内的服务器通信的旁边。这个优势在构建容器时非常有用，因为您可以快速地推送容器映像到Amazon
    ECR。
- en: Near-identical development environment to production
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与生产环境几乎相同的开发环境
- en: Something else that comes in handy is the ability to develop code in the same
    operating system as it runs in. Cloud9 runs the latest version of Amazon Linux,
    so there are no deployment surprises.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件方便的事情是能够在与运行环境相同的操作系统中开发代码。Cloud9运行最新版本的Amazon Linux，因此没有部署上的意外。
- en: Specialized Cloud IDE
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 专门的云IDE
- en: Cloud9 has specialized IDE functionality that only exists in the AWS Cloud IDE.
    Examples include the ability to navigate S3 buckets, invoke AWS Lambda functions,
    and pair programs with other developers who have access to your AWS account.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud9具有专门的IDE功能，这些功能只存在于AWS云IDE中。例如，能够浏览S3存储桶，调用AWS Lambda函数，并与其他具有对AWS账户访问权限的开发者进行配对编程。
- en: To get started, create a new Cloud9 environment by searching for it in the AWS
    Console, selecting the service, and giving the instance’s name a helpful description,
    as shown in [Figure 5-5](#Figure-5-2). It is worth pointing out that underneath
    the hood, an EC2 instance runs Cloud9, and you can access it via the AWS EC2 Console
    to make modifications like increasing storage size or changing networking.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请在AWS控制台中搜索并创建一个新的Cloud9环境，选择该服务，并为实例的名称提供一个有用的描述，如[图 5-5](#Figure-5-2)所示。值得注意的是，在幕后，EC2实例运行Cloud9，您可以通过AWS
    EC2控制台访问它，以进行像增加存储大小或更改网络设置的修改。
- en: '![doac 0505](assets/doac_0505.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0505](assets/doac_0505.png)'
- en: Figure 5-5\. Launch Cloud9
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-5\. 启动Cloud9
- en: Next, configure a machine with a decent amount of power since you build containers
    with this environment as shown in [Figure 5-6](#Figure-5-3).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，配置一台性能足够的机器，因为您将使用这个环境构建容器，如[图 5-6](#Figure-5-3)所示。
- en: Note
  id: totrans-82
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It is worth mentioning that because Cloud9 [has no additional cost](https://oreil.ly/LVHeF),
    the cost driver is EC2\. Choose an appropriate instance size to save on costs.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，因为Cloud9[没有额外费用](https://oreil.ly/LVHeF)，成本驱动因素是EC2。选择一个适当的实例大小以节省成本。
- en: 'Once the Cloud9 environment loads next, you need to [install .NET 6](https://oreil.ly/8JRNY):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Cloud9环境加载完成，接下来需要[安装.NET 6](https://oreil.ly/8JRNY)：
- en: '[PRE1]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![doac 0506](assets/doac_0506.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0506](assets/doac_0506.png)'
- en: Figure 5-6\. Select Cloud9 instance
  id: totrans-87
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-6\. 选择Cloud9实例
- en: 'Next, it is good to test the environment by creating a simple Console Application:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过创建一个简单的控制台应用程序来测试环境是很有必要的：
- en: '[PRE2]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This test command works using the `dotnet` command-line interface, which allows
    for a new “Console App” without Visual Studio.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试命令是使用`dotnet`命令行界面工作的，允许创建一个新的“控制台应用程序”，无需使用Visual Studio。
- en: Containerized .NET 6 on Lambda
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Lambda上容器化.NET 6
- en: Another service supported by containers is AWS Lambda. A good reference point
    is an [AWS Lambda Dockerfile](https://gallery.ecr.aws/lambda/dotnet). This document
    contains instructions on how to build AWS Lambda that targets the .NET 6 runtime.
    Another great resource is the [official .NET 6 support on AWS](https://oreil.ly/BSuv3).
    Check out the chapter on serverless for more insights into building AWS Lambda.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 容器支持的另一个服务是AWS Lambda。一个很好的参考点是[AWS Lambda Dockerfile](https://gallery.ecr.aws/lambda/dotnet)。此文档包含了如何构建目标为.NET
    6运行时的AWS Lambda的指令。另一个很好的资源是[官方.NET 6在AWS上的支持](https://oreil.ly/BSuv3)。查看无服务器章节，获取更多关于构建AWS
    Lambda的见解。
- en: To build containers, first, the Cloud9 environment needs resizing. Let’s tackle
    that next.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建容器，首先需要调整Cloud9环境的大小。让我们接下来解决这个问题。
- en: Resizing
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调整大小
- en: AWS Cloud9, when provisioned, has a minimal disk, and it can quickly get full
    when working with containers. It is good to resize your environment and clean
    up old container images you don’t need. You can refer to the Bash script by AWS
    that allows you to resize [Cloud9](https://oreil.ly/kcDFE) easily.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Cloud9在被配置时有一个最小的磁盘空间，当与容器一起工作时，磁盘空间可能会迅速填满。调整环境大小并清理不需要的旧容器映像是很有必要的。您可以参考AWS提供的Bash脚本，轻松地调整[Cloud9的大小](https://oreil.ly/kcDFE)。
- en: 'You can find a [copy of the script here](https://oreil.ly/m4wgR). To run it,
    you execute the following command, which resizes the instance to 50 GB:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[这里找到脚本的副本](https://oreil.ly/m4wgR)。要运行它，请执行以下命令，它将实例的大小调整为50 GB：
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After running this on your system, you’ll see the following output. Notice
    that the mount point `/dev/nvme0n1p1` now has `41G` free:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的系统上运行后，您将看到以下输出。请注意，挂载点`/dev/nvme0n1p1`现在有`41G`可用空间：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Next, let’s build a containerized .NET 6 API.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们构建一个容器化的.NET 6 API。
- en: Containerized .NET 6 API
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器化的.NET 6 API
- en: 'Another way to develop .NET 6 is to build a microservice that deploys with
    a container service like AWS ECS or AWS App Runner. Both methods offer an efficient
    way to deploy an API with minimal effort. To get started, first create a new web
    API project in Cloud9:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种开发.NET 6的方法是构建一个使用像AWS ECS或AWS App Runner这样的容器服务部署的微服务。这两种方法都提供了一种高效的方式来部署API，几乎不费吹灰之力。要开始，请首先在Cloud9中创建一个新的Web
    API项目：
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Running this in your Cloud9 environment generates the following output:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在Cloud9环境中运行此代码将生成以下输出：
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s change the default code generated from the `dotnet` tool by adding a
    slightly fancier route to understand further the process of building containerized
    APIs. You can find more information about routing at ASP.NET Core [here](https://oreil.ly/bkU8x).
    Note how similar this code looks to other high-level languages like Node, Ruby,
    Python, or Swift in the following example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加稍微复杂的路由来改变从`dotnet`工具生成的默认代码，以进一步理解构建容器化API的过程。你可以在ASP.NET Core[这里](https://oreil.ly/bkU8x)找到更多关于路由的信息。请注意，这段代码与其他高级语言如Node、Ruby、Python或Swift非常相似：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now you can run this code by changing it into the directory using `dotnet run`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以通过进入目录并使用`dotnet run`来运行此代码：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output looks something like this in AWS Cloud9\. Note how helpful it is
    to see the full content root path for your Cloud9 environment, making it easy
    to host multiple projects and switch back and forth between working on them:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在AWS Cloud9中输出看起来像这样。请注意，看到Cloud9环境的完整内容根路径是多么有帮助，这样可以轻松地托管多个项目并在它们之间切换：
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can see the output in [Figure 5-7](#Figure-5-4-cloud9-aspnet); note how
    you can toggle terminals side-by-side alongside the code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[图5-7](#Figure-5-4-cloud9-aspnet)中看到输出；请注意，您可以在代码旁边并排切换终端。
- en: 'This test works using the `dotnet` command-line interface. There are two separate
    `curl` commands: the first `curl` command invokes the homepage, and the second
    `curl` command invokes the route `/hello/aws`.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`dotnet`命令行界面进行此测试。有两个独立的`curl`命令：第一个`curl`命令调用主页，第二个`curl`命令调用路由`/hello/aws`。
- en: Note
  id: totrans-114
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The “HTTP” URL works in both `curl` commands, but “HTTPS” would return an invalid
    certificate issue.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: “HTTP”URL在两个`curl`命令中都可以工作，但“HTTPS”将返回无效的证书问题。
- en: '![doac 0507](assets/doac_0507.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0507](assets/doac_0507.png)'
- en: Figure 5-7\. Cloud9 with ASP.NET
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-7\. Cloud9与ASP.NET
- en: With the project working locally, let’s move on to containerizing our code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 项目在本地工作后，让我们继续将代码容器化。
- en: Containerize the Project
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为项目容器化
- en: 'Now let’s convert our project to using a container registered with the Amazon
    ECR. Once in the registry, our code is deployed to services that support containers.
    Our example is AWS App Runner, but it could also be Amazon ECS, Amazon EKS, or
    Amazon Batch, among the many container services on AWS. To do this, create a Dockerfile
    in the project folder:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将项目转换为使用注册到Amazon ECR的容器。一旦注册到服务支持容器的地方，我们的代码将部署到服务上。我们的示例是AWS App Runner，但也可以是Amazon
    ECS、Amazon EKS或Amazon Batch等AWS上的许多容器服务。为此，请在项目文件夹中创建一个Dockerfile：
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](assets/1.png)](#co_containerization_of__net_CO1-1)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_containerization_of__net_CO1-1)'
- en: Note how this container pulls in a .NET 6 runtime, configures the correct ports,
    and builds the project.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此容器拉取了.NET 6运行时，配置了正确的端口并构建了项目。
- en: '[![2](assets/2.png)](#co_containerization_of__net_CO1-2)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_containerization_of__net_CO1-2)'
- en: Finally, it creates an entry point for the `.dll`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为`.dll`创建一个入口点。
- en: 'Now build this container with the following command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用以下命令构建此容器：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can look at the container by using `docker image ls`. The output should
    look something like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`docker image ls`查看容器。输出应该类似于以下内容：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To run it, do the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行它，请执行以下操作：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output should be similar to the following result:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下结果：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now invoke it via `curl`: `curl http://localhost:8080/hello/aws` as shown in
    [Figure 5-8](#Figure-5-5-containerized-dotnet). Note how AWS Cloud9 provides a
    simple yet powerful cloud-based development environment with specialized features
    for developing on the AWS platform.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过 `curl` 调用它：`curl http://localhost:8080/hello/aws` 如 [图 5-8](#Figure-5-5-containerized-dotnet)
    所示。请注意，AWS Cloud9 提供了一个简单但功能强大的云开发环境，具有专门为在 AWS 平台上开发而设计的特色功能。
- en: '![doac 0508](assets/doac_0508.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0508](assets/doac_0508.png)'
- en: Figure 5-8\. Containerized .NET 6 Web API
  id: totrans-136
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-8\. 容器化的 .NET 6 Web API
- en: Next, let’s discuss ECR and how it enables many new workflows on AWS.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论 ECR 及其如何在 AWS 上启用许多新的工作流程。
- en: Amazon Elastic Container Registry
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Amazon Elastic Container Registry
- en: An essential component in the new world of containers is a container registry
    optimized for the cloud you use. It securely allows the speedy deployment of deeply
    integrated cloud services. Amazon Elastic Container Registry (ECR) has the core
    services necessary for robust container strategies, as shown in [Figure 5-9](#Figure-5-6-ecr).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器新世界的一个关键组成部分是一个针对您使用的云进行优化的容器注册表。它安全地允许快速部署深度集成的云服务。Amazon Elastic Container
    Registry（ECR）具有强大的容器策略所需的核心服务，如 [图 5-9](#Figure-5-6-ecr) 所示。
- en: '![doac 0509](assets/doac_0509.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0509](assets/doac_0509.png)'
- en: Figure 5-9\. Amazon ECR
  id: totrans-141
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-9\. Amazon ECR
- en: ECR enables workflows like developing in Cloud9 (or CloudShell), then automatically
    pushing a container to ECR (Elastic Container Registry) through AWS CodeBuild.
    This build process triggers a continuous delivery pipeline to AWS App Runner,
    as shown in [Figure 5-10](#Figure-5-10-ecr-workflow).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ECR 使得像在 Cloud9（或 CloudShell）中开发，然后通过 AWS CodeBuild 自动推送容器到 ECR（Elastic Container
    Registry）这样的工作流程成为可能。这个构建过程触发了一个连续交付管道到 AWS App Runner，如 [图 5-10](#Figure-5-10-ecr-workflow)
    所示。
- en: '![doac 0510](assets/doac_0510.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0510](assets/doac_0510.png)'
- en: Figure 5-10\. Amazon ECR to App Runner architecture
  id: totrans-144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-10\. Amazon ECR 到 App Runner 架构
- en: Create a new ECR repo by navigating to the AWS Console and searching for ECR.
    You can then create a new repo as shown in [Figure 5-11](#Figure-5-6-2-ecr-create)
    to use this ECR service.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过转到 AWS 控制台并搜索 ECR 创建一个新的 ECR 仓库。您可以如 [图 5-11](#Figure-5-6-2-ecr-create) 所示创建一个新的仓库来使用此
    ECR 服务。
- en: '![doac 0511](assets/doac_0511.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0511](assets/doac_0511.png)'
- en: Figure 5-11\. Create ECR repo
  id: totrans-147
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-11\. 创建 ECR 仓库
- en: Next, click on the repo (located in the top-right corner of the web-service-aws
    repo page) to find the command necessary to push this container to ECR, as shown
    in [Figure 5-12](#Figure-5-6-3-ecr-push).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，点击仓库（位于 web-service-aws 仓库页面右上角），查找推送此容器到 ECR 所需的命令，如 [图 5-12](#Figure-5-6-3-ecr-push)
    所示。
- en: Note
  id: totrans-149
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: These commands can easily integrate into an AWS CodeBuild pipeline for continuous
    delivery later by adding them to a *buildspec.yml* file and creating a new AWS
    CodeBuild pipeline that communicates with a source repo such as GitHub or AWS
    CodeCommit.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令可以轻松集成到 AWS CodeBuild 管道中，以供稍后进行持续交付，方法是将它们添加到 *buildspec.yml* 文件，并创建一个新的
    AWS CodeBuild 管道，该管道与 GitHub 或 AWS CodeCommit 等源仓库通信。
- en: Next, run the ECR push commands in your local AWS Cloud9 environment. They will
    look similar to [Figure 5-12](#Figure-5-6-3-ecr-push). We named this repository
    web-service-aws, which then reflected in the build commands to push to ECR.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在您的本地 AWS Cloud9 环境中运行 ECR 推送命令。它们会与 [图 5-12](#Figure-5-6-3-ecr-push) 类似。我们将此仓库命名为
    web-service-aws，在推送到 ECR 的构建命令中反映出来。
- en: '![doac 0512](assets/doac_0512.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0512](assets/doac_0512.png)'
- en: Figure 5-12\. Push to ECR repo
  id: totrans-153
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-12\. 推送到 ECR 仓库
- en: Now check out the image as shown in [Figure 5-13](#Figure-5-6-4-ecr-image).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如 [图 5-13](#Figure-5-6-4-ecr-image) 所示检查镜像。
- en: '![doac 0513](assets/doac_0513.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0513](assets/doac_0513.png)'
- en: Figure 5-13\. Check out the image created
  id: totrans-156
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-13\. 检查创建的镜像
- en: Note
  id: totrans-157
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the AWS App Runner service name is not required to link to either
    the container’s name or the repository in ECR.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，AWS App Runner 服务名称无需链接到容器名称或 ECR 中的存储库。
- en: With ECR hosting our container, let’s discuss using a service that can deploy
    it automatically.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有了 ECR 托管我们的容器，让我们讨论使用能够自动部署的服务。
- en: App Runner
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: App Runner
- en: AWS App Runner is a compelling PaaS offering because it takes a complex problem,
    creates a secure microservice, and trivializes it, as shown in [Figure 5-14](#Figure-5-7-app-runner).
    It makes it convenient for the developer by allowing a developer to deploy a container
    directly from ECR. Further, it will listen to the ECR repository, and when a new
    image deploys there, it triggers the deployment of a new version of AWS App Runner.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: AWS App Runner 是一种引人注目的PaaS服务，它解决了一个复杂的问题，创建了一个安全的微服务，并将其简单化，如[图 5-14](#Figure-5-7-app-runner)所示。它通过允许开发人员直接从ECR部署容器，为开发人员提供了便利。此外，它将监听ECR存储库，当在那里部署了新映像时，会触发AWS
    App Runner的新版本部署。
- en: '![doac 0514](assets/doac_0514.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0514](assets/doac_0514.png)'
- en: Figure 5-14\. AWS App Runner
  id: totrans-163
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-14\. AWS App Runner
- en: It requires very little work to take a containerized .NET 6 web API that lives
    in Amazon ECR and deploy it as a microservice with AWS App Runner. First, open
    the AWS App Runner and select the container image you built earlier, as shown
    in [Figure 5-15](#Figure-5-7-2-app-runner-container).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个容器化的.NET 6 Web API从Amazon ECR部署为AWS App Runner微服务只需要很少的工作。首先，打开AWS App Runner，并选择您之前构建的容器映像，如[图 5-15](#Figure-5-7-2-app-runner-container)所示。
- en: '![doac 0515](assets/doac_0515.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0515](assets/doac_0515.png)'
- en: Figure 5-15\. Select ECR image
  id: totrans-166
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-15\. 选择 ECR 映像
- en: Next, select the deployment process, either manual or automatic, as shown in
    [Figure 5-16](#Figure-5-7-3-app-runner-deploy). Automatic is typically what a
    developer building a production application wants because it will set up continuous
    delivery using ECR as the source of truth. Manual deployment may be the best option
    when initially trying the service out.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，选择部署过程，可以是手动或自动，如[图 5-16](#Figure-5-7-3-app-runner-deploy)所示。通常，开发生产应用程序的开发人员会选择自动部署，因为它将使用ECR作为真实数据源设置持续交付。当初次尝试服务时，手动部署可能是最佳选择。
- en: '![doac 0516](assets/doac_0516.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0516](assets/doac_0516.png)'
- en: Figure 5-16\. Select App Runner deployment process
  id: totrans-169
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-16\. 选择 App Runner 部署过程
- en: Note
  id: totrans-170
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that there is an existing App Runner that we use in the deployment process
    that gives App Runner the ability to pull images from ECR. If you haven’t set
    up an IAM role yet, you will need to create a new service role by selecting that
    checkbox instead. You can refer to the [official App Runner documentation](https://oreil.ly/EEHs2)
    for a detailed walk-through of your setup options.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在部署过程中使用了现有的App Runner，它赋予了App Runner从ECR拉取映像的能力。如果您尚未设置IAM角色，请选择该复选框以创建新的服务角色。您可以参考[官方App
    Runner文档](https://oreil.ly/EEHs2)详细了解您的设置选项。
- en: Now select the port the container exposes; this will match the port of the .NET
    6 application Dockerfile configuration. In our case, it is `8080`, as shown in
    [Figure 5-17](#Figure-5-7-4-app-runner-ports).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在选择容器公开的端口；这将与.NET 6应用程序的Dockerfile配置的端口匹配。在我们的案例中，这是`8080`，如[图 5-17](#Figure-5-7-4-app-runner-ports)所示。
- en: '![doac 0517](assets/doac_0517.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0517](assets/doac_0517.png)'
- en: Figure 5-17\. Select App Runner port
  id: totrans-174
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-17\. 选择 App Runner 端口
- en: Note
  id: totrans-175
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that this configuration used the default settings. You may want to configure
    many options, including setting environmental variables, health check configurations,
    and autoscaling configurations. You can refer to the [latest documentation](https://oreil.ly/q6zg8)
    for detailed information on how to do these actions.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此配置使用了默认设置。您可能希望配置许多选项，包括设置环境变量、健康检查配置和自动缩放配置。您可以参考[最新文档](https://oreil.ly/q6zg8)了解如何执行这些操作的详细信息。
- en: Finally, observe the service after creating it as shown in [Figure 5-18](#Figure-5-7-five-app-runner-service).
    This step shows us that the service is deploying, and we can watch step by step
    as it becomes active by observing the event log.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在创建服务后，请如[图 5-18](#Figure-5-7-five-app-runner-service)所示观察服务。这一步显示了服务正在部署，我们可以通过观察事件日志逐步查看其激活过程。
- en: '![doac 0518](assets/doac_0518.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0518](assets/doac_0518.png)'
- en: Figure 5-18\. Observe AWS App Runner service
  id: totrans-179
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-18\. 观察 AWS App Runner 服务
- en: Note
  id: totrans-180
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: After the service has initially deployed, you can “re-deploy” the application
    manually by selecting the deploy button. In the case of ECR, this will manually
    deploy the latest image in the repository. Likewise, any new push to ECR will
    trigger a redeployment of that image because of the automatic deployment configuration
    enablement.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 服务首次部署后，您可以通过选择部署按钮手动“重新部署”应用程序。在ECR的情况下，这将手动部署存储库中的最新映像。同样，任何对ECR的新推送将由于自动部署配置的启用而触发该映像的重新部署。
- en: Once the service runs, hop over to AWS CloudShell and run the following `curl`
    command in a CloudShell or Cloud9 terminal to invoke the API as shown in [Figure 5-19](#Figure-5-7-6-app-runner-curl).
    You can also invoke the API from any terminal that supports the `curl` command
    and a web browser.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 服务运行后，切换到 AWS CloudShell 并在 CloudShell 或 Cloud9 终端中运行以下 `curl` 命令来调用 API，如 [图 5-19](#Figure-5-7-6-app-runner-curl)
    所示。您还可以从支持 `curl` 命令和 Web 浏览器的任何终端调用 API。
- en: '![doac 0519](assets/doac_0519.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0519](assets/doac_0519.png)'
- en: Figure 5-19\. `curl` running service
  id: totrans-184
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-19\. `curl` 运行服务
- en: Note
  id: totrans-185
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can also watch a walk-through of a containerized .NET 6 application from
    scratch on [YouTube](https://oreil.ly/qdD9B) or [O’Reilly](https://oreil.ly/K7GHw).
    The source code for this project in [this repo](https://github.com/noahgift/dot-net-6-aws).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以观看从零开始容器化 .NET 6 应用程序的演示，链接在 [YouTube](https://oreil.ly/qdD9B) 或 [O’Reilly](https://oreil.ly/K7GHw)。该项目的源代码位于
    [此存储库](https://github.com/noahgift/dot-net-6-aws)。
- en: Managed Container Services with Amazon ECS
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Amazon ECS 管理容器服务
- en: An important consideration when dealing with containers is where they run. In
    the case of your desktop or a cloud development environment like Cloud9, it is
    simple enough to launch a container and experiment with it using tools like Docker
    Desktop. Deployment gets more complex, though, in the real world, and this is
    where AWS-managed container services play a considerable role in creating robust
    deployment targets.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 处理容器时的一个重要考虑因素是它们运行的位置。例如，在您的桌面或像 Cloud9 这样的云开发环境中，启动容器并使用 Docker Desktop 等工具进行实验非常简单。然而，在现实世界中，部署变得更加复杂，这正是
    AWS 托管容器服务在创建强大的部署目标中发挥重要作用的地方。
- en: The two options on the AWS platform that provide a comprehensive end-to-end
    solution for managing containers at scale are Amazon Elastic Kubernetes Service
    (Amazon EKS) and Amazon Elastic Container Service (Amazon ECS). Let’s discuss
    the homegrown Amazon solution, ECS, in detail next.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AWS 平台上提供的两种全面的端到端解决方案，用于管理规模化容器的选项是 Amazon 弹性 Kubernetes 服务（Amazon EKS）和
    Amazon 弹性容器服务（Amazon ECS）。接下来让我们详细讨论自家研发的 Amazon 解决方案 ECS。
- en: Amazon ECS is a fully managed container orchestration service and a central
    hub of compute options, as shown in [Figure 5-20](#Figure-5-9-ecs). Starting with
    ECR, which stores built container images, the ECS service allows for application
    definition using container images coupled with compute options. Finally, ECS scales
    your application seamlessly using AWS best practices like elasticity and availability.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon ECS 是一个完全托管的容器编排服务，是计算选项的中心枢纽，如 [图 5-20](#Figure-5-9-ecs) 所示。从存储构建的容器镜像的
    ECR 开始，ECS 服务允许使用容器镜像定义应用程序，并结合计算选项。最后，ECS 根据 AWS 最佳实践无缝扩展您的应用程序，例如弹性和可用性。
- en: '![doac 0520](assets/doac_0520.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0520](assets/doac_0520.png)'
- en: Figure 5-20\. ECS
  id: totrans-192
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-20\. ECS
- en: There are two common ways of deploying to ECS for .NET developers. The first
    is [AWS Copilot](https://oreil.ly/LYFrv) and the second is the [AWS .NET deployment
    tool](https://oreil.ly/uBdJZ). The newer .NET deployment tool has the advantage
    that it can also deploy to App Runner and Beanstalk.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 .NET 开发人员，有两种常见的 ECS 部署方式。第一种是 [AWS Copilot](https://oreil.ly/LYFrv)，第二种是
    [AWS .NET 部署工具](https://oreil.ly/uBdJZ)。较新的 .NET 部署工具的优势在于它还可以部署到 App Runner 和
    Beanstalk。
- en: 'Further, ECS supports three essential use cases. Let’s spell these out:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，ECS 支持三个关键用例。让我们详细解释一下：
- en: Hybrid scenario
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 混合场景
- en: Build a container anywhere and run it anywhere with Amazon ECS Anywhere.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Amazon ECS Anywhere 构建容器，并在任何地方运行。
- en: Batch processing scenario
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 批处理场景
- en: Orchestrate batch processing across AWS services, including EC2, Fargate, and
    Spot Instances.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AWS 服务中协调批处理，包括 EC2、Fargate 和 Spot 实例。
- en: Scale web scenario
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 Web 场景
- en: Build and deploy scalable web applications built with Amazon best practices.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Amazon 最佳实践构建和部署可扩展的 Web 应用程序。
- en: Note
  id: totrans-201
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Amazon ECS supports Linux as well as [Windows containers](https://oreil.ly/BehOC).
    Note the following essentials on Windows containers: First, they support tasks
    that use the EC2 and Fargate launch types. Also, not all task definition parameters
    for Linux containers are available. Finally, Windows container instances require
    more storage space than Linux containers.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon ECS 支持 Linux 以及 [Windows 容器](https://oreil.ly/BehOC)。请注意以下关于 Windows
    容器的要点：首先，它们支持使用 EC2 和 Fargate 启动类型的任务。此外，并非所有适用于 Linux 容器的任务定义参数都适用于 Windows 容器。最后，Windows
    容器实例所需的存储空间比 Linux 容器多。
- en: 'The best possible way to get started with ECS is through the .NET deployment
    tool [AWS .NET deployment tool for the .NET CLI](https://oreil.ly/IdeWu). Let’s
    enumerate the key features of this tool:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用 ECS 的最佳方式是通过 .NET 部署工具 [AWS .NET deployment tool for the .NET CLI](https://oreil.ly/IdeWu)。让我们列举此工具的关键功能：
- en: Serverless deploy
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器部署
- en: This tool creates a deployment to AWS Elastic Beanstalk or Amazon ECS via [AWS
    Fargate](https://aws.amazon.com/fargate).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此工具通过 [AWS Fargate](https://aws.amazon.com/fargate) 部署到 AWS Elastic Beanstalk
    或 Amazon ECS。
- en: Cloud native to Linux deploy
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生 Linux 部署
- en: This implementation deploys cloud-native .NET applications built on .NET Core
    2.1 and later targeting Linux.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现部署基于 .NET Core 2.1 及更高版本并面向 Linux 的云原生 .NET 应用程序。
- en: Deploys utility .NET applications
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 部署实用 .NET 应用程序
- en: Many .NET utilities have deployment capabilities, including ASP.NET Core web
    apps, Blazor WebAssembly apps, long-running service apps, and scheduled tasks.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 .NET 实用程序具有部署功能，包括 ASP.NET Core Web 应用程序、Blazor WebAssembly 应用程序、长时间运行的服务应用程序和定时任务。
- en: Note
  id: totrans-210
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: AWS Fargate is a technology that you can use with Amazon ECS to run containers
    without managing servers or clusters of Amazon EC2 instances. With this technology,
    you no longer have to provision, configure, or scale clusters of virtual machines
    to run containers.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Fargate 是一种技术，您可以与 Amazon ECS 一起使用，无需管理服务器或 Amazon EC2 实例的集群即可运行容器。有了这项技术，您不再需要为运行容器而提供、配置或扩展虚拟机集群。
- en: 'Let’s use `dotnet aws deploy` to deploy to ECS Fargate. We can leverage both
    AWS Cloud9 and [Blazor](https://oreil.ly/5W2FA) for this. First, let’s update
    the tool to ensure the latest version of the deployment tool is enabled. Since
    this tool is under active development, it is a best practice to update it often
    using the following command:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `dotnet aws deploy` 部署到 ECS Fargate。我们可以利用 AWS Cloud9 和 [Blazor](https://oreil.ly/5W2FA)
    进行这项工作。首先，让我们更新工具，确保启用最新版本的部署工具。由于此工具正在积极开发中，经常使用以下命令进行更新是最佳实践：
- en: '[PRE15]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now observe the entire software development lifecycle as shown in [Figure 5-21](#Figure-5-10-ecs-deploy).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在观察完整的软件开发生命周期，如 [图 5-21](#Figure-5-10-ecs-deploy) 所示。
- en: '![doac 0521](assets/doac_0521.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0521](assets/doac_0521.png)'
- en: Figure 5-21\. ECS and Cloud9 software development lifecycle
  id: totrans-216
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-21\. ECS 和 Cloud9 软件开发生命周期
- en: 'To create a new Blazor application, use the following command:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新的 Blazor 应用程序，请使用以下命令：
- en: '[PRE16]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, change into the Blazor directory:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，进入 Blazor 目录：
- en: '[PRE17]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can run the application on port 8080 via the following `dotnet` command:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下 `dotnet` 命令在端口 8080 上运行应用程序：
- en: '[PRE18]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Select the preview functionality with the application running as shown in [Figure 5-22](#Figure-5-11-blazer)
    to view it as a web page in the IDE.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 选择在应用程序运行时如 [图 5-22](#Figure-5-11-blazer) 所示的预览功能，以在 IDE 中作为网页查看它。
- en: '![doac 0522](assets/doac_0522.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0522](assets/doac_0522.png)'
- en: Figure 5-22\. Blazor in Cloud9
  id: totrans-225
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-22\. Cloud9 中的 Blazor
- en: Note
  id: totrans-226
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Note that AWS Cloud9 uses ports 8080, 8081, or 8082 for [preview](https://oreil.ly/bZQi8).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 AWS Cloud9 使用端口 8080、8081 或 8082 进行 [预览](https://oreil.ly/bZQi8)。
- en: 'Now that we know the application works locally, let’s change the Index.razor
    page to the following content before deploying to AWS by editing in the Cloud9
    IDE:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道应用程序在本地运行正常，让我们在部署到 AWS 之前通过 Cloud9 IDE 编辑 Index.razor 页面为以下内容：
- en: '[PRE19]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Additionally, create a Dockerfile in the project directory with the following
    content. This step allows for customization of the runtime for ECS:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，在项目目录中创建一个包含以下内容的 Dockerfile。此步骤允许自定义 ECS 运行时：
- en: '[PRE20]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, with these steps out of the way, it is time to deploy to ECS Fargate
    using the following command in a new Cloud9 terminal:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在完成这些步骤之后，现在是时候在新的 Cloud9 终端中使用以下命令部署到 ECS Fargate：
- en: '[PRE21]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When prompted, you will see several options and should select the number associated
    with ASP.NET Core App to Amazon ECS using Fargate, as shown in the following (truncated)
    code output. The numbers could be different depending on the conditions of your
    environment, so select the number associated with Fargate.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示时，您会看到几个选项，应选择与 ASP.NET Core App to Amazon ECS using Fargate 相关的数字，如下面（截断）的代码输出所示。根据您环境的条件，数字可能会有所不同，因此请选取与
    Fargate 相关的数字。
- en: '[PRE22]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For the following prompts, you should select “Enter” to use the default options
    except `Desired Task Count: 3`, which you should change to a single task or 1\.
    This process will initiate the container push to ECR and the subsequent deployment
    to ECS.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '对于接下来的提示，您应选择“Enter”以使用除 `Desired Task Count: 3` 外的默认选项，应将其更改为单个任务或 1\. 此过程将启动容器推送到
    ECR 并随后部署到 ECS。'
- en: Note
  id: totrans-237
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Note a common problem when working with containers in a cloud-based development
    environment is running out of space. One brute force way of solving this problem
    is periodically deleting all local container images using the command `docker
    rmi -f $(docker images -aq)`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当在云端开发环境中使用容器时，常见问题之一是容器空间不足。解决这个问题的一个简单粗暴的方法是定期使用命令`docker rmi -f $(docker
    images -aq)`删除所有本地容器镜像。
- en: Once the deployment finishes, we can test the application using the URL generated
    from the `deploy` command, as shown in [Figure 5-23](#Figure-5-12-deploy-blazor).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 部署完成后，我们可以使用从`deploy`命令生成的 URL 测试应用程序，如[图 5-23](#Figure-5-12-deploy-blazor)所示。
- en: '![doac 0523](assets/doac_0523.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0523](assets/doac_0523.png)'
- en: Figure 5-23\. Blazor deployed to ECS Fargate
  id: totrans-241
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-23\. Blazor 部署到 ECS Fargate
- en: Note
  id: totrans-242
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can watch a complete walk-through of this deployment process on [YouTube](https://youtu.be/Xs9vGM3U2Ek)
    or [the O’Reilly Platform](https://oreil.ly/ScFrj). The source code for the example
    is available on [GitHub](https://oreil.ly/v9O1N).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[YouTube](https://youtu.be/Xs9vGM3U2Ek)或[O'Reilly 平台](https://oreil.ly/ScFrj)上观看完整的部署过程演示。示例的源代码可以在[GitHub](https://oreil.ly/v9O1N)上找到。
- en: 'With the deployment successfully tested, it would be good to clean up your
    stack by first listing the deployments with the following command: `dotnet aws
    list-deployments`. Next, you can delete the stack `dotnet aws delete-deployment
    *<stack-name>*`.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 部署成功测试后，最好先列出部署信息，使用以下命令：`dotnet aws list-deployments`。接下来，您可以删除堆栈`dotnet aws
    delete-deployment *<stack-name>*`来清理您的堆栈。
- en: Note
  id: totrans-245
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'One item to be aware of in deploying to Blazor to Fargate is that you will
    need to make one of the following changes to deploy without errors:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 Blazor 部署到 Fargate 时需要注意的一点是，您需要进行以下一项更改以避免出现错误：
- en: Create a single task instead of three (which is the default).
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个单一任务，而不是默认的三个任务。
- en: Turn on [stickiness in the EC2 Target Group](https://oreil.ly/vELfc).
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 EC2 目标组中打开[粘性](https://oreil.ly/vELfc)。
- en: Now that our ECS example is complete, let’s wrap up the chapter and discuss
    the next steps.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的 ECS 示例已经完成，让我们结束本章并讨论接下来的步骤。
- en: Conclusion
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: New technology opens up new ways to solve problems. Cloud computing enables
    near-infinite computing and storage through virtualization, allowing more sophisticated
    technologies to build on it. One of those technologies is containers, and it has
    many advanced service integrations available on AWS.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 新技术为解决问题开辟了新的途径。云计算通过虚拟化提供了近乎无限的计算和存储能力，允许更复杂的技术在其上构建。其中之一就是容器技术，并且在 AWS 上有许多先进的服务集成。
- en: Nonintuitively, new technologies often open up new ways to work. We covered
    how AWS Cloud9 offers a new and exciting way to work with containers due to deep
    integration with the AWS ecosystem. This deep integration includes access to highly
    performant compute, storage, and networking beyond what a typical home or work
    desktop offering can provide. You may find that Cloud9 is a trusty complement
    to a traditional Visual Studio workflow and allows you to do some development
    tasks more efficiently.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 新技术常常以非直观的方式打开新的工作方式。我们介绍了 AWS Cloud9 如何通过与 AWS 生态系统的深度集成，为使用容器提供了一种新而激动人心的工作方式。这种深度集成包括访问高性能的计算、存储和网络，超出了典型家庭或工作桌面提供的能力。您可能会发现
    Cloud9 是传统 Visual Studio 工作流程的可靠补充，使您能够更高效地完成一些开发任务。
- en: There is no better investment for a .NET developer than mastering containers.
    This chapter went through the foundations of containers and serves as a foundation
    for building more complex solutions later in the book. In the next chapter, we
    expand on many of these topics by tackling DevOps on AWS. DevOps topics covered
    include AWS Code Build, AWS Code Pipeline, and how to integrate with third-party
    servers like GitHub Actions, TeamCity, and Jenkins. Before reading that chapter,
    you may want to go through the critical thinking discussions and exercise discussions.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 .NET 开发者来说，掌握容器技术是最好的投资之一。本章介绍了容器的基础知识，并作为后续建立更复杂解决方案的基础。在下一章中，我们将进一步扩展这些主题，探讨在
    AWS 上的 DevOps。涉及的 DevOps 主题包括 AWS Code Build、AWS Code Pipeline，以及如何与 GitHub Actions、TeamCity
    和 Jenkins 等第三方服务器集成。在阅读该章之前，您可能需要通过批判性思维讨论和练习讨论。
- en: Critical Thinking Discussion Questions
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 批判性思维讨论问题
- en: How can you manage the size of container images?
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何管理容器镜像的大小？
- en: What is the best AWS container service for small start-ups?
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于小型初创公司，哪种 AWS 容器服务是最好的选择？
- en: What is the best AWS container service for large companies that use containers
    extensively for batch computing?
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于大量使用容器进行批量计算的大型公司来说，最佳的AWS容器服务是什么？
- en: What is the advantage of using Amazon Linux 2 to deploy .NET 6?
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Amazon Linux 2部署.NET 6的优势是什么？
- en: What is the disadvantage of using Amazon Linux 2 to deploy .NET 6?
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Amazon Linux 2部署.NET 6的劣势是什么？
- en: Exercises
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Take the containerized project built in this chapter and deploy it via continuous
    delivery through AWS CodeBuild.^([7](ch05.xhtml#idm45599651843520))
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将本章中构建的容器化项目通过AWS CodeBuild进行持续交付部署。^([7](ch05.xhtml#idm45599651843520))
- en: Build your own AWS Lambda container that targets .NET 6 and deploy it to AWS.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个目标为.NET 6的AWS Lambda容器，并将其部署到AWS。
- en: Use Cloud9 to invoke an AWS Lambda function you deploy.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Cloud9调用您部署的AWS Lambda函数。
- en: Build another container that uses .NET 6 and Amazon Linux 2 and push it to ECR.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建另一个使用.NET 6和Amazon Linux 2的容器，并将其推送到ECR。
- en: Build a Console App command-line tool that targets .NET 6 and uses the AWS SDK
    to call AWS Comprehend and push this to a public ECR repo.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个Console App命令行工具，目标为.NET 6，并使用AWS SDK调用AWS Comprehend，并将其推送到公共ECR仓库。
- en: '^([1](ch05.xhtml#idm45599652783696-marker)) In his book *How Innovation Works:
    And Why It Flourishes in Freedom* (HarperCollins), Matt Ridley makes the point
    that “The story of the internal-combustion engine displays the usual features
    of an innovation: a long and deep prehistory characterized by failure; a shorter
    period marked by an improvement in affordability characterized by simultaneous
    patenting and rivalries.”'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '^([1](ch05.xhtml#idm45599652783696-marker)) 在他的书 *How Innovation Works: And
    Why It Flourishes in Freedom*（HarperCollins）中，Matt Ridley指出：“内燃机的故事展示了创新的典型特征：长期且深刻的前史，以失败为特征；短期则以经济性改进为特征，同时伴随专利和竞争。”'
- en: '^([2](ch05.xhtml#idm45599652781312-marker)) Isaacson points out that an enormous
    driver for the creation of personal computers was the desire for more time on
    a mainframe. (Walter Isaacson. *The Innovators: How a Group of Hackers, Geniuses,
    and Geeks Created the Digital Revolution*. New York: Simon & Schuster, 2014.)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '^([2](ch05.xhtml#idm45599652781312-marker)) Isaacson指出，个人计算机创造的一个巨大推动力是对主机上更多时间的渴望。（Walter
    Isaacson. *The Innovators: How a Group of Hackers, Geniuses, and Geeks Created
    the Digital Revolution*. New York: Simon & Schuster, 2014.）'
- en: ^([3](ch05.xhtml#idm45599652743104-marker)) [According to AWS](https://oreil.ly/zuKS9),
    it typically takes “a few minutes for an instance reboot to complete.”
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch05.xhtml#idm45599652743104-marker)) 根据[AWS的说法](https://oreil.ly/zuKS9)，一个实例重新启动通常需要“几分钟完成”。
- en: ^([4](ch05.xhtml#idm45599652740480-marker)) You can learn more about advanced
    capabilities of container launch times in this [AWS blog post](https://oreil.ly/tmh5o).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch05.xhtml#idm45599652740480-marker)) 您可以在这篇[AWS博客文章](https://oreil.ly/tmh5o)中了解有关容器启动时间高级功能的更多信息。
- en: ^([5](ch05.xhtml#idm45599652735200-marker)) An excellent example of this workflow
    is the [AWS Lambda Runtime Interface Emulator](https://oreil.ly/17yhY). According
    to AWS, “The Lambda Runtime Interface Emulator is a proxy for Lambda’s Runtime
    and Extensions APIs, which allows customers to locally test their Lambda function
    packaged as a container image.”
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch05.xhtml#idm45599652735200-marker)) 一个很好的例子是[AWS Lambda Runtime Interface
    Emulator](https://oreil.ly/17yhY)工作流程。根据AWS的说法，“Lambda Runtime Interface Emulator是Lambda运行时和扩展API的代理，允许客户以容器映像打包的方式在本地测试他们的Lambda函数。”
- en: ^([6](ch05.xhtml#idm45599652651680-marker)) AWS offers multiple levels of [shared
    responsibility](https://oreil.ly/MEQRN) depending on the service.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch05.xhtml#idm45599652651680-marker)) AWS根据服务提供多个级别的[共享责任](https://oreil.ly/MEQRN)。
- en: ^([7](ch05.xhtml#idm45599651843520-marker)) You can refer to the [*buildspec.yml*
    file](https://github.com/noahgift/dot-net-6-aws) for ideas.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch05.xhtml#idm45599651843520-marker)) 您可以参考[*buildspec.yml*文件](https://github.com/noahgift/dot-net-6-aws)获取想法。
