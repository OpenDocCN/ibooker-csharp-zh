- en: 'Chapter 5\. Encapsulation: *Keep your Privates… Private*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章。封装：*保护您的私人信息……私密*
- en: '![Images](assets/227fig01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/227fig01.png)'
- en: '**Ever wished for a little more privacy?**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**是否曾经希望拥有更多的隐私？**'
- en: Sometimes your objects feel the same way. Just like you don’t want anybody you
    don’t trust reading your journal or paging through your bank statements, good
    objects don’t let ***other*** objects go poking around their fields. In this chapter,
    you’re going to learn about the power of **encapsulation**, a way of programming
    that helps you make code that’s flexible, easy to use, and difficult to misuse.
    You’ll **make your objects’ data private**, and add **properties** to protect
    how that data is accessed.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你的对象也有同样的感受。就像你不希望任何你不信任的人读你的日记或翻阅你的银行对账单一样，好的对象不让***其他***对象查看它们的字段。在本章中，您将学习到**封装**的力量，这是一种编程方式，可以帮助您编写灵活、易于使用且难以被误用的代码。您将**使您对象的数据私有**，并添加**属性**以保护数据的访问方式。
- en: Let’s help Owen roll for damage
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们帮助Owen掷骰子计算伤害
- en: Owen was so happy with his ability score calculator that he wanted to create
    more C# programs he can use for his games, and you’re going to help him. In the
    game he’s currently running, any time there’s a sword attack he rolls dice and
    uses a formula that calculates the damage. Owen wrote down how the **sword damage
    formula** works in his game master notebook.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Owen对他的能力分数计算器感到非常满意，他想要创建更多他可以用于游戏的C#程序，而你将帮助他。在他目前玩的游戏中，每次有剑攻击时，他会掷骰子并使用一个计算伤害的公式。Owen在他的游戏主控笔记本中记录了剑伤害公式的工作方式。
- en: Here’s **a class called SwordDamage** that does the calculation. Read through
    the code carefully—you’re about to create an app that uses it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个名为**SwordDamage**的类，用于进行计算。仔细阅读代码——你即将创建一个应用程序来使用它。
- en: '![Images](assets/228fig001.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/228fig001.png)'
- en: Create a console app to calculate damage
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个控制台应用程序来计算伤害
- en: 'Let’s build a console app for Owen that uses the SwordDamage class. It will
    print a prompt to the console asking the user to specify whether the sword is
    magic and/or flaming, then it will do the calculation. Here’s an example of the
    output of the app:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为Owen构建一个控制台应用程序，使用SwordDamage类。它将在控制台上打印一个提示，询问用户是否指定剑是魔法的和/或燃烧的，然后进行计算。以下是应用程序的输出示例：
- en: '![Images](assets/229fig01.png)![Images](assets/229fig02.png)![Images](assets/230fig01.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/229fig01.png)![图片](assets/229fig02.png)![图片](assets/230fig01.png)'
- en: '**Yes! We can build a WPF app that uses the same class.**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**是的！我们可以构建一个使用相同类的WPF应用程序。**'
- en: Let’s find a way to **reuse** the SwordDamage class in a WPF app. The first
    challenge for us is how to provide an *intuitive* user interface. A sword can
    be magic, flaming, both, or none, so we need to figure out how we want to handle
    that in a GUI—and there are a lot of options. We could have a radio button or
    dropdown list with four options, just like the console app gave four options.
    However, we think it would be cleaner and more visually obvious to use **checkboxes**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找一个方法来在一个WPF应用程序中**重用**SwordDamage类。对我们来说，第一个挑战是如何提供一个*直观*的用户界面。一把剑可以是魔法的、燃烧的、两者兼有，或者都不是，所以我们需要弄清楚如何在GUI中处理这个问题——而且有很多选择。我们可以使用四个选项的单选按钮或下拉列表，就像控制台应用程序提供了四个选项一样。但是，我们认为使用**复选框**会更清晰、更明显。
- en: In WPF, CheckBox uses the Content property to display the label to the right
    of the box, just like a Button uses the Content property for the text that it
    displays. We have SetMagic and SetFlaming methods, so we can use the CheckBox
    control’s **Checked** **and Unchecked events**, which let you specify methods
    that get called when the user checks or unchecks the box.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在WPF中，CheckBox使用Content属性在框的右侧显示标签，就像Button使用Content属性显示文本一样。我们有SetMagic和SetFlaming方法，因此我们可以使用CheckBox控件的**Checked和Unchecked事件**，让您指定在用户选中或取消选中框时调用的方法。
- en: '**Go to the Visual Studio for Mac Learner’s Guide for the Mac version of this
    project.**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**前往Visual Studio for Mac学习指南，查看该项目的Mac版本。**'
- en: Design the XAML for a WPF version of the damage calculator
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计一个WPF版本的伤害计算器的XAML
- en: '**Create a new WPF app**, and set the main window’s title to `**Sword Damage**`,
    height to `**175**`, and width to `**300**`. Add three rows and two columns to
    the grid. The top row should have two CheckBox controls labeled Flaming and Magic,
    the middle row a Button control labeled “Roll for damage” that spans both columns,
    and the bottom row a TextBlock control that spans both columns.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建一个新的WPF应用程序**，并将主窗口标题设置为`**剑伤害**`，高度设置为`**175**`，宽度设置为`**300**`。向网格添加三行两列。顶部行应包含两个标签为Flaming和Magic的CheckBox控件，中间行应包含一个标签为“掷骰子计算伤害”的Button控件，该按钮跨越两列，底部行应包含一个跨越两列的TextBlock控件。'
- en: Note
  id: totrans-17
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '***Do this!***'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '***做这个！***'
- en: '![Images](assets/231fig01.png)![Images](assets/231fig02.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/231fig01.png)![图片](assets/231fig02.png)'
- en: 'Here’s the XAML—you can definitely use the designer to build your form, but
    you should also feel comfortable editing the XAML by hand:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是XAML——你肯定可以使用设计师来构建你的表单，但你也应该学会手动编辑XAML：
- en: '![Images](assets/231fig03.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/231fig03.png)'
- en: Note
  id: totrans-22
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Name the CheckBox controls `magic` and `flaming`, and the TextBlock control
    `damage`. Make sure the names appear in the XAML correctly in the `x:Name` properties.**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**将CheckBox控件的名称命名为`magic`和`flaming`，将TextBlock控件的名称命名为`damage`。确保这些名称在XAML中的`x:Name`属性中正确显示。**'
- en: The code-behind for the WPF damage calculator
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WPF伤害计算器的代码后台
- en: '**Add this code-behind** to your WPF app. It creates instances of SwordDamage
    and Random, and makes the checkboxes and button calculate damage:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**将这段代码后台添加到你的WPF应用中。它创建了SwordDamage和Random的实例，并使CheckBox和按钮计算伤害：**'
- en: '***Do this!***'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '***做这个！***'
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Read through this code very carefully.Can you spot any bugs before you run
    it?**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**仔细阅读这段代码。在运行之前，你能发现任何错误吗？**'
- en: Tabletop talk (or maybe…dice discussion?)
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 桌游谈话（或许是…骰子讨论？）
- en: It’s game night! Owen’s entire gaming party is over, and he’s about to unveil
    his brand-new sword damage calculator. Let’s see how that goes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏之夜！欧文的整个游戏派对来了，他即将展示他全新的剑伤害计算器。让我们看看效果如何。
- en: '![Images](assets/233fig01.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/233fig01.png)'
- en: '**Jayden:** Owen, what are you talking about?'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**杰登：** 欧文，你在说什么？'
- en: '**Owen:** I’m talking about this new app that will calculate sword damage…***automatically***.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**欧文：** 我在说这个新应用将会自动计算剑的伤害…'
- en: '**Matthew:** Because rolling dice is so very, very hard.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**马修：** 因为掷骰子实在是太，太难了。'
- en: '**Jayden:** Come on, people, no need for sarcasm. Let’s give it a chance.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**杰登：** 别开玩笑了，大家。让我们给它一个机会。'
- en: '**Owen:** Thank you, Jayden. This is a perfect time, too, because Brittany
    just attacked the rampaging were-cow with her flaming magic sword. Go ahead, B.
    Give it a shot.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**欧文：** 谢谢，杰登。这正是个完美的时机，因为布兰妮刚刚用她的火焰魔法剑攻击了狂暴的牛人。来吧，布兰妮。试试看。'
- en: '**Brittany:** OK. We just started the app. I checked the Magic box. Looks like
    it’s got an old roll in there, let me click roll to do it again, and…'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**布兰妮：** 好的。我们刚刚启动了这个应用。我勾选了“魔法”框框。看起来它保存了一个旧掷骰子结果，让我再次点击“掷骰子”来重新计算，然后…'
- en: '**Jayden:** Wait, that’s not right. Now you rolled 14, but it still says 3
    HP. Click it again. Rolled 11 for 3 HP. Click it some more. 9, 10, 5, all give
    3 HP. Owen, what’s the deal?'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**杰登：** 等等，这不对。现在你掷了14点，但仍显示3点HP。再点击一次。掷了11点，造成3点HP。再多点几次。9点、10点、5点，都只给3点HP。欧文，怎么回事？'
- en: '**Brittany:** Hey, it sort of works. If you click roll, then check the boxes
    a few times, eventually it gives the right answer. Looks like I rolled 10 for
    22 HP.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**布兰妮：** 嘿，它有点儿用。如果你点击“掷骰子”，然后多次勾选框框，最终会给出正确的答案。看起来我掷了10点，造成22点HP损伤。'
- en: '**Jayden:** You’re right. We just have to click things in a **really specific
    order**. *First* we click roll, *then* we check the right boxes, and *just to
    be sure* we check the Flaming box twice.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**杰登：** 你说得对。我们只需按照一个**非常具体的顺序**点击。*首先*点击掷骰子，*然后*勾选正确的框框，*最好*两次检查“Flaming”框框。'
- en: '**Owen:** You’re right. If we do things in **exactly that order**, the program
    works. But if we do it in any other order, it breaks. OK, we can work with this.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**欧文：** 你说得对。如果我们**完全按照这个顺序**做，程序就能正常运行。但如果我们按其他顺序做，它就会出错。好吧，我们可以处理这个。'
- en: '**Matthew:** Or…maybe we can just do things the normal way, with real dice?'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**马修：** 或者…也许我们可以用真正的骰子来做事情呢？'
- en: '![Images](assets/233fig02.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/233fig02.png)'
- en: Let’s try to fix that bug
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们试着修复这个bug
- en: 'When you run the program, what’s the first thing that it does? Let’s take a
    closer look at this method at the very top of the MainWindow class with the code-behind
    for the window:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，它做的第一件事是什么？让我们仔细看看MainWindow类顶部的这个方法与窗口的代码后台：
- en: '![Images](assets/234fig01.png)![Images](assets/234fig02.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/234fig01.png)![图片](assets/234fig02.png)'
- en: 'When a class has a constructor, it’s the very first thing that gets run when
    a new instance of that class is created. When your app starts up and creates an
    instance of MainWindow, first it initializes the fields—including creating a new
    SwordDamage object—and then it calls the constructor. So the program calls RollDice
    just before showing you the window, and we see the problem every time we click
    roll, so maybe we can fix this by hacking a solution into the RollDice method.
    **Make these changes to the RollDice method**:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类有构造函数时，当创建该类的新实例时，它是第一件被运行的事情。当你的应用程序启动并创建 MainWindow 的一个实例时，首先初始化字段，包括创建一个新的
    SwordDamage 对象，然后调用构造函数。所以程序在显示窗口之前就调用了 RollDice，并且每次点击 roll 时我们都会看到问题，所以也许我们可以通过在
    RollDice 方法中插入一个解决方案来修复这个问题。**对 RollDice 方法进行以下更改**：
- en: '![Images](assets/234fig03.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/234fig03.png)'
- en: Now **test your code**. Run your program and click the button a few times. So
    far so good—the numbers look correct. Now **check the Magic box** and click the
    button a few more times. OK, it looks like our fix worked! There’s just one more
    thing to test. **Check the Flaming box** and click the button and…***oops!***
    It’s still not working. When you click the button, it does the 1.75 magic multiplier,
    but it doesn’t add the extra 3 HP for flaming. You still need to check and uncheck
    the Flaming checkbox to get the right number. So the program’s still broken.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在**测试你的代码**。运行程序并点击按钮几次。到目前为止一切顺利——数字看起来是正确的。现在**选中“魔法”复选框**并再次点击按钮几次。好的，看起来我们的修复起作用了！还有一件事需要测试。**选中“燃烧”复选框**并点击按钮，然后……***糟糕！***还是不起作用。点击按钮时，它执行了1.75的魔法倍增器，但没有增加额外的3点HP用于燃烧。你仍然需要勾选和取消勾选“燃烧”复选框才能得到正确的数字。所以程序仍然有问题。
- en: '![Images](assets/234fig04.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/234fig04.png)'
- en: '**Always think about what caused a bug before you try to fix it.**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**在尝试修复 bug 之前，始终思考是什么导致了 bug。**'
- en: When something goes wrong in your code, it’s ***really tempting*** ***to jump
    right in*** and immediately start writing more code to try to fix it. It may feel
    like you’re taking action quickly, but it’s way too easy to just add more buggy
    code. It’s always safer to take the time to figure out what really caused the
    bug, rather than just try to stick in a quick fix.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码出现问题时，**立即开始编写更多代码来尝试修复**确实非常诱人。这样做可能会让你觉得自己在迅速采取行动，但很容易只是添加更多有错误的代码。花点时间弄清楚真正引起
    bug 的原因总是更安全的，而不是仅仅尝试插入一个快速修复。
- en: Use Debug.WriteLine to print diagnostic information
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Debug.WriteLine 打印诊断信息
- en: In the last few chapters you used the debugger to track down bugs, but that’s
    not the only way developers find problems in their code. In fact, when professional
    developers are trying to track down bugs in their code, one of the most common
    things they’ll do first is to **add statements that print lines of output**, and
    that’s exactly what we’ll do to track down this bug.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几章中，你使用调试器来追踪错误，但这并不是开发人员发现代码问题的唯一方法。事实上，当专业开发人员试图追踪其代码中的错误时，他们最常做的事情之一是**添加打印输出行的语句**，这正是我们将要做的，用来追踪这个
    bug。
- en: '**Open the Output window** in Visual Studio by choosing Output (Ctrl+O W) from
    the View menu. Any text that you print by calling Console.WriteLine from a WPF
    app is displayed in this window. You should only use Console.WriteLine for *displaying
    output your users should see*. Instead, any time you want to print output lines
    just for debugging purposes you should use **Debug.WriteLine**. The Debug class
    is in the System.Diagnostics namespace, so start by adding a `using` line to the
    top of your SwordDamage class file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择“视图”菜单中的“输出”（Ctrl+O W），在 Visual Studio 中**打开输出窗口**。从 WPF 应用程序中调用 Console.WriteLine
    所打印的任何文本将显示在此窗口中。你应该仅在*用户应该看到的显示输出*时使用 Console.WriteLine。而在仅为调试目的打印输出行时，应使用**Debug.WriteLine**。Debug
    类位于 System.Diagnostics 命名空间中，因此首先在 SwordDamage 类文件的顶部添加一个 `using` 行：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, **add a Debug.WriteLine statement** to the end of the CalculateDamage
    method:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 CalculateDamage 方法的末尾**添加一个 Debug.WriteLine 语句**：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now add another Debug.WriteLine statement to the end of the SetMagic method,
    and one more to the end of the SetFlaming method. They should be identical to
    the one in CalculateDamage, except that they print “SetMagic” or “SetFlaming”
    instead of “CalculateDamage” to the output:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在 SetMagic 方法的末尾再添加一个 Debug.WriteLine 语句，并在 SetFlaming 方法的末尾再添加一个。它们应该与 CalculateDamage
    中的语句相同，只是在输出时打印“SetMagic”或“SetFlaming”，而不是“CalculateDamage”：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-62
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Now your program will print useful diagnostic information to the Output window.**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**现在你的程序将向输出窗口打印有用的诊断信息。**'
- en: Note
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can sleuth out this bug without setting any breakpoints. That’s something
    developers do all the time... so you should learn how to do it, too!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要设置任何断点，您可以追踪此错误。这是开发人员经常做的事情……所以你也应该学会这样做！
- en: Note
  id: totrans-66
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Debug.WriteLine** **is one of the most basic—and useful!—debugging tools
    in your developer toolbox. Sometimes the quickest way to sleuth out a bug in your
    code is to strategically add Debug.WriteLine statements to give you important
    clues that help you crack the case.**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**Debug.WriteLine** **是你开发工具箱中最基本且最有用的调试工具之一！有时，在代码中找出错误的最快方法是策略性地添加Debug.WriteLine语句，以提供重要线索，帮助你破解问题。**'
- en: '![Images](assets/237fig01.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/237fig01.png)'
- en: '**People won’t always use your classes in exactly the way you expect.**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**人们不会总是按照你的预期方式使用你的类。**'
- en: And most of the time those “people” who are using your classes are you! You
    might be writing a class today that you’ll be using tomorrow, or next month. Luckily,
    C# gives you a powerful technique to make sure your program always works correctly—even
    when people do things you never thought of. It’s called **encapsulation** and
    it’s really helpful for working with objects. The goal of encapsulation is to
    restrict access to the “guts” of your classes so that all of the class members
    are ***safe*** ***to use and difficult to misuse***. This lets you design classes
    that are much more difficult to use incorrectly—and that’s a ***great way to prevent
    bugs*** like the one you sleuthed out in your sword damage calculator.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候使用你的类的“人”是你自己！今天你可能正在编写一个类，明天或下个月你就会使用它。幸运的是，C#为你提供了一种强大的技术，确保你的程序始终正确运行——即使人们做了你从未想过的事情。它被称为**封装**，对于处理对象非常有帮助。封装的目标是限制对类“内部”数据的访问，以便所有类成员都**安全**且**难以误用**。这使你能够设计类，使其更难以被错误使用——这是预防像你在剑伤害计算器中追查出的错误的***绝佳方法***。
- en: It’s easy to accidentally misuse your objects
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 很容易意外地误用你的对象
- en: Owen’s app ran into problems because we assumed that the CalculateDamage method
    would, well, calculate the damage. It turned out that **it wasn’t safe to call
    that method directly** because it replaced the Damage value and erased any calculations
    that were already done. Instead, we needed to let the SetFlaming method call CalculateDamage
    for us—but **even that wasn’t enough**, because we *also* had to make sure that
    SetMagic was always called first. So even though the SwordDamage class *technically*
    works, it causes problems when code calls it in an unexpected way.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Owen的应用程序遇到问题，因为我们假设CalculateDamage方法会计算伤害。事实证明直接调用该方法是**不安全的**，因为它会替换Damage值并擦除已经完成的任何计算。相反，我们需要让SetFlaming方法为我们调用CalculateDamage——但**甚至这也不够**，因为我们还必须确保先始终调用SetMagic。因此，尽管SwordDamage类在技术上**可以**工作，但是当代码以意外的方式调用它时会引发问题。
- en: '**How the SwordDamage class ***expected to be used*****'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**SwordDamage类的** ***预期使用方式*****'
- en: The SwordDamage class gave the app a good method to calculate the total damage
    for a sword. All it had to do was set the roll, then call the SetMagic method,
    and finally call the SetFlaming method. If things are done in that order, the
    Damage field is updated with the calculated damage. But that’s not what the app
    did.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: SwordDamage类为应用程序提供了一种良好的方法来计算剑的总伤害。它所需做的就是设置Roll，然后调用SetMagic方法，最后调用SetFlaming方法。如果按照这个顺序进行操作，Damage字段将被计算后更新。但这不是应用程序做的事情。
- en: '![Images](assets/238fig01.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/238fig01.png)'
- en: '**How the SwordDamage class ***was actually used*****'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**SwordDamage类的** ***实际使用方式*****'
- en: Instead, it set the Roll field, then it called SetFlaming, which added the extra
    damage for the flaming sword to the Damage field. Then it called SetMagic, and
    finally it called CalculateDamage, which reset the Damage field and discarded
    the extra flaming damage.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，它设置了Roll字段，然后调用了SetFlaming，将火焰剑的额外伤害添加到Damage字段中。然后调用SetMagic，最后调用CalculateDamage，这将重置Damage字段并丢弃额外的火焰伤害。
- en: '![Images](assets/238fig02.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/238fig02.png)'
- en: Encapsulation means keeping some of the data in a class private
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装意味着将类中的一些数据保持私有
- en: 'There’s a way to avoid the problem of misusing your objects: make sure that
    there’s only one way to use your class. C# helps you do that by letting you declare
    some of your fields as `**private**`. So far, you’ve only seen public fields.
    If you’ve got an object with a public field, any other object can read or change
    that field. If you make it a private field, then **that field can only be accessed
    from inside that** **object** (or by another instance *of the same class*).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种方法可以避免滥用对象的问题：确保只有一种方法可以使用你的类。C#通过让你将一些字段声明为`**private**`来帮助你做到这一点。到目前为止，你只看到了公共字段。如果你有一个具有公共字段的对象，任何其他对象都可以读取或更改该字段。如果将其设置为私有字段，那么**该字段只能从该**
    **对象内部访问**（或者由同一类的另一个实例*访问*）。
- en: '![Images](assets/239fig01.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/239fig01.png)'
- en: Note
  id: totrans-82
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**By making the CalculateDamage method ***private***, we prevent the app from
    accidentally calling it and resetting the Damage field. Changing the fields involved
    in the calculation to make them private keeps an app from interfering with the
    calculation. When you make some data private and then write code to use that data,
    it’s called *encapsulation*. When a class protects its data and provides members
    that are safe to use and difficult to misuse, we say that it’s *well-encapsulated*.**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过将CalculateDamage方法***私有化***，我们防止应用程序意外调用它并重置Damage字段。将参与计算的字段更改为私有，可以防止应用程序干扰计算。当你将一些数据私有化，然后编写代码来使用这些数据时，这被称为*封装*。当一个类保护其数据并提供安全使用且难以滥用的成员时，我们称其为*良好封装*。**'
- en: Use encapsulation to control access to your class’s methods and fields
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用封装来控制对类方法和字段的访问
- en: When you make all of your fields and methods public, any other class can *access*
    them. Everything your class does and knows about becomes an open book for every
    other class in your program…and you just saw how that can cause your program to
    behave in ways you never expected.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将所有字段和方法都设置为公共时，任何其他类都可以*访问*它们。你的类所做的一切以及所知道的一切都成为程序中每个其他类的开放书籍……你刚刚看到这可能导致你的程序以你从未预料过的方式运行。
- en: 'That’s why the `public` and `private` keywords are called **access modifiers**:
    they modify access to class members. Encapsulation lets you control what you share
    and what you keep private inside your class. Let’s see how this works.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么`public`和`private`关键字被称为**访问修饰符**：它们修改对类成员的访问。封装让你控制在类内部分享什么和保留什么私有。让我们看看这是如何工作的。
- en: Super-spy Herb Jones is a ***secret agent object in a 1960s spy game*** defending
    life, liberty, and the pursuit of happiness as an undercover agent in the USSR.
    His object is an instance of the SecretAgent class.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 超级间谍赫伯特·琼斯是一位***1960年代间谍游戏中的秘密特工对象***，在苏联作为卧底特工捍卫生命、自由和追求幸福。他的对象是SecretAgent类的一个实例。
- en: '![Images](assets/240fig01.png)![Images](assets/240fig02.png)'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/240fig01.png)![图片](assets/240fig02.png)'
- en: Agent Jones has a plan to help him evade the enemy agent object. He added an
    AgentGreeting method that takes a password as its parameter. If he doesn’t get
    the right password, he’ll only reveal his alias, Dash Martin.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 约翰斯特工有一个计划，可以帮助他躲避敌方特工。他添加了一个AgentGreeting方法，该方法以密码作为参数。如果他没有得到正确的密码，他只会透露他的化名，Dash
    Martin。
- en: '![Images](assets/240fig03.png)'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/240fig03.png)'
- en: Seems like a foolproof way to protect the agent’s identity, right? As long as
    the agent object that calls it doesn’t have the right password, the agent’s name
    is safe.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看起来这是保护特工身份的绝佳方法，对吧？只要调用它的特工对象没有正确的密码，特工的姓名就是安全的。
- en: '![Images](assets/240fig04.png)'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/240fig04.png)'
- en: But is the RealName field REALLY protected?
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 但是RealName字段真的受到保护吗？
- en: So as long as the enemy doesn’t know any SecretAgent object passwords, the agents’
    real names are safe. Right? But that doesn’t do any good if that data’s kept in
    public fields.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 只要敌人不知道任何SecretAgent对象的密码，特工的真实姓名就是安全的。对吧？但如果这些数据被保存在公共字段中，那就没有任何好处。
- en: '![Images](assets/241fig01.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/241fig01.png)'
- en: Private fields and methods can only be accessed from instances of the same class
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私有字段和方法只能从同一类的实例中访问
- en: 'There’s only one way that an object can get at the data stored inside another
    object’s private fields: by using the public fields and methods that return the
    data. EnemyAgent and AlliedAgent agents need to use the AgentGreeting method,
    but friendly spies that are also SecretAgent instances can see everything…because
    **any class can** **see private fields in other instances of the** ***same class***.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象可以访问另一个对象的私有字段存储的数据的唯一方法是使用公共字段和方法来返回数据。敌对特工和盟友特工需要使用`AgentGreeting`方法，但是友好的间谍，也就是`SecretAgent`的实例，可以看到一切……因为**任何类都可以**
    **看到同一类的其他实例中的私有字段**。
- en: '![Images](assets/242fig01.png)![Images](assets/242fig02.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/242fig01.png)![图像](assets/242fig02.png)'
- en: '**The only way that one object can get to data stored in a private field inside
    another object of a different class is by using public methods that return the
    data.**'
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**一个对象可以访问另一个不同类对象中的私有字段存储的数据的唯一方法是使用返回数据的公共方法。**'
- en: '**![Images](assets/245fig01.png)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**![图像](assets/245fig01.png)**'
- en: '**Because sometimes you want your class to hide information from the rest of
    the program.**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**因为有时候你希望你的类把信息隐藏起来不让程序的其他部分看到。**'
- en: A lot of people find encapsulation a little odd the first time they come across
    it because the idea of hiding one class’s fields, properties, or methods from
    another class is a little counterintuitive. There are some very good reasons that
    you’ll want to think about what information should be exposed to the rest of the
    program.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人第一次接触封装时可能会觉得有点奇怪，因为隐藏一个类的字段、属性或方法不让另一个类看到这个概念有些违反直觉。有一些非常好的理由让你考虑应该向程序的其他部分公开什么信息。
- en: Encapsulation means having one class hide information from another. It helps
    you prevent bugs in your programs.**  **# Why encapsulation? Think of an object
    as a black box…
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 封装意味着一个类隐藏信息不让另一个类看到。它帮助你预防程序中的错误。** **# 为什么要封装？想象一个对象就像是一个黑盒子……
- en: Sometimes you’ll hear a programmer refer to an object as a “black box,” and
    that’s a pretty good way of thinking about them. When we say something is a black
    box, we’re saying that we can see how it behaves, but we have no way of knowing
    how it actually works.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你会听到程序员把一个对象称为“黑盒子”，这是一个很好的思考方式。当我们说某物是黑盒子时，我们的意思是我们可以看到它的行为，但我们无法知道它是如何运作的。
- en: When you call an object’s method, you don’t really care how that method works—at
    least, not right now. All you care about is that it takes the inputs you gave
    it and does the right thing.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用一个对象的方法时，你并不真正关心这个方法是如何工作的——至少现在不关心。你关心的是它能够接受你给出的输入并做正确的事情。
- en: '![Images](assets/247fig01.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/247fig01.png)'
- en: You *could* include a lot more controls, like a window that shows you what’s
    going on inside the box, and knobs and dials that let you muck with its internals.
    But if they don’t actually do anything that your system needs, then they don’t
    do you any good and can only cause problems.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你*可以*包含更多的控件，比如显示盒子内部情况的窗口，以及能够操纵它内部的旋钮和开关。但如果它们对你的系统没有任何用处，那它们对你毫无好处，只会带来问题。
- en: Encapsulation makes your classes…
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装使你的类……
- en: '**Easier to use**'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更易于使用**'
- en: You already know that classes use fields to keep track of their state. Many
    of them use methods to keep those fields up to date—methods that no other class
    will ever call. It’s pretty common to have a class that has fields, methods, and
    properties that will never be called by any other class. If you make those members
    private, then they won’t show up in the IntelliSense window later when you need
    to use that class. Less clutter in the IDE will make your class easier to use.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你已经知道类使用字段来跟踪它们的状态。许多类使用方法来更新这些字段——其他类永远不会调用的方法。有一个类有字段、方法和属性，其他类永远不会调用。如果你把这些成员设为私有，那么当你需要使用这个类时，它们就不会显示在
    IntelliSense 窗口中。IDE 中减少杂乱将使你的类更易于使用。
- en: '**Less prone to bugs**'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更不容易出错**'
- en: That bug in Owen’s program happened because the app accessed a method directly
    rather than letting the other methods in the class call it. If that method had
    been private, we could have avoided that bug.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Owen 的程序中出现的 bug 就是因为应用程序直接访问一个方法而不是让类中的其他方法调用它。如果那个方法是私有的，我们本可以避免这个 bug。
- en: '**Flexible**'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活**'
- en: A lot of times, you’ll want to go back and add features to a program you wrote
    a while ago. If your classes are well-encapsulated, then you’ll know exactly how
    to use them and add on to them later.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 许多时候，你会想回头去添加一些你之前写的程序的功能。如果你的类被良好封装，那么以后你就会准确知道如何使用它们并在其上添加功能。
- en: A few ideas for encapsulating classes
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于封装类的几个想法。
- en: '**Is everything in your class public?**If your class has nothing but public
    fields and methods, you probably need to spend a little more time thinking about
    encapsulation.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你的类中所有东西都是公开的吗？** 如果你的类除了公共字段和方法外什么都没有，你可能需要多花点时间考虑封装。'
- en: '**Think about ways fields and methods can be misused.**What can go wrong if
    they’re not set or called properly?'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**思考字段和方法被错误使用的可能性。** 如果它们没有被正确设置或调用会出现什么问题？'
- en: '**What fields require some processing or calculation to happen when they’re
    set?**Those are prime candidates for encapsulation. If someone writes a method
    later that changes the value in any one of them, it could cause problems for the
    work your program is trying to do.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**哪些字段在设置时需要进行处理或计算？** 这些是封装的首选对象。如果以后有人编写了一个方法来更改其中任何一个值，可能会对程序正在尝试完成的工作造成问题。'
- en: '![Images](assets/248fig01.png)'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/248fig01.png)'
- en: '**Only make fields and methods public if you need to.**If you don’t have a
    reason to declare something public, don’t—you could make things really messy for
    yourself by making all of the fields in your program public. But don’t just go
    making everything private, either. Spending a little time up front thinking about
    which fields really need to be public and which don’t can save you a lot of time
    later.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**只有在需要时才将字段和方法设为公开。** 如果你没有理由声明某些东西为公开，就别声明 —— 通过将程序中的所有字段设为公开，你可能会使事情变得非常混乱。但也不要仅仅将所有东西设为私有。花点时间前期考虑哪些字段确实需要公开，哪些不需要，可以为你节省后续大量的时间。'
- en: '![Images](assets/249fig01.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/249fig01.png)'
- en: '**Exactly! The difference is that the well-encapsulated one is built in a way
    that prevents bugs and is easier to use.**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**确实！区别在于良好封装的类设计方式可以防止 bug 并且更易于使用。**'
- en: 'It’s easy to take a well-encapsulated class and turn it into a poorly encapsulated
    class: do a search and replace to change every occurrence of `private` to `public`.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个封装良好的类变成封装不良的类很容易：执行搜索并替换，将每个`private`改为`public`。
- en: 'And that’s a funny thing about the `private` keyword: you can generally take
    any program and do that search and replace, and it will still compile and work
    in exactly the same way. That’s one reason that encapsulation can be a little
    difficult for some programmers to really “get” when they first see it.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`private`关键字有个有趣的地方：你通常可以对任何程序执行搜索并替换，它仍然能够编译并以完全相同的方式工作。这就是为什么当一些程序员刚开始接触封装时，会感到有点困难的原因之一。
- en: '***When you come back to code that you haven’t looked at in a long time, it’s
    easy to forget how you intended it to be used. Tha t’s where encapsulation can
    make your life a lot easier!***'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '***当你回头看那些很久没碰的代码时，很容易忘记最初的使用意图。这就是封装可以极大简化你生活的地方！***'
- en: 'This book so far has been about making programs **do things**—perform certain
    behaviors. Encapsulation is a little different. It doesn’t change the way your
    program behaves. It’s more about the “chess game” side of programming: by hiding
    certain information in your classes when you design and build them, you set up
    a strategy for how they’ll interact later. The better the strategy, the **more
    flexible and maintainable** your programs will be, and the more bugs you’ll avoid.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这本书一直在讲述如何使程序**做事情** —— 执行某些行为。封装有些不同。它不会改变你的程序行为方式。它更多地关注编程的“国际象棋”方面：通过在设计和构建类时隐藏某些信息，你为它们以后的互动设定了一种策略。策略越好，你的程序**越灵活和可维护**，也能避免更多的
    bug。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: And just like chess, there are an almost unlimited number of possible encapsulation
    strategies!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 就像国际象棋一样，封装策略几乎是无穷无尽的！
- en: If you encapsulate your classes well today, that makes them a lot easier to
    reuse tomorrow.
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你今天很好地封装了你的类，那么明天重用它们将变得更加容易。
- en: '![Images](assets/250fig01.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/250fig01.png)'
- en: Let’s use encapsulation to improve the SwordDamage class
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用封装来改进 SwordDamage 类。
- en: We just covered some great ideas for encapsulating classes. Let’s see if we
    can start to apply those ideas to the SwordDamage class to keep it from being
    confused, misused, and abused by any app that we include it in.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚讨论了一些关于封装类的好主意。让我们看看是否可以开始将这些想法应用到 SwordDamage 类中，以防止它在任何包含它的应用程序中被混淆、误用和滥用。
- en: Is every member of the SwordDamage class public?
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SwordDamage 类的每个成员都是公开的吗？
- en: Yes, indeed. The four fields (Roll, MagicMultiplier, FlamingDamage, and Damage)
    are public, and so are the three methods (CalculateDamage, SetMagic, and SetFlaming).
    We could stand to think about encapsulation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，确实如此。四个字段（Roll、MagicMultiplier、FlamingDamage和Damage）是公共的，还有三个方法（CalculateDamage、SetMagic和SetFlaming）。我们应该考虑一下封装的问题。
- en: Are fields or methods being misused?
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段或方法是否被误用？
- en: Absolutely. In the first version of the damage calculator app, we called CalculateDamage
    when we should have just let the SetFlaming method call it. Even our attempt to
    fix it failed because we misused the methods by calling them in the wrong order.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当然。在伤害计算器应用程序的第一个版本中，我们在应该只让SetFlaming方法调用它时调用了CalculateDamage。即使我们试图修复它，也因为调用顺序错误而失败。
- en: Is there calculation required after setting a field?
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在设置字段后是否需要进行计算？
- en: Certainly. After setting the Roll field, we really want the instance to calculate
    damage immediately.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当然。在设置Roll字段后，我们真的希望实例立即计算伤害。
- en: So what fields and methods really need to be public?
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么哪些字段和方法确实需要是公共的？
- en: That’s a great question. Take some time to think about the answer. We’ll tackle
    it at the end of the chapter.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很棒的问题。花点时间思考答案。我们会在本章末尾解决这个问题。
- en: '**Making members of a class private can prevent bugs caused by other classes
    calling its public methods or updating its public fields in unexpected ways.**'
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**将类的成员设置为私有可以防止其他类以意外的方式调用其公共方法或更新其公共字段导致的错误。**'
- en: Encapsulation keeps your data safe
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装可以保护你的数据安全
- en: We’ve seen how the `private` keyword **protects class members from being accessed
    directly**, and how that can prevent bugs caused by other classes calling methods
    or updating fields in ways we didn’t expect—like how your GetPot method in the
    Hi-Lo game gave read-only access to the private pot field, and only the Guess
    or Hint methods could modify it. This next class works in exactly the same way.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`private`关键字**保护了类成员不被直接访问**，这可以防止其他类以我们未预料的方式调用方法或更新字段—就像你在Hi-Lo游戏中的GetPot方法只给了私有的pot字段只读访问权限，而只有Guess或Hint方法可以修改它一样。下一个类的工作方式完全相同。
- en: Let’s use encapsulation in a class
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让我们在一个类中使用封装
- en: '**Let’s build a PaintballGun class** for a paintball arena video game. The
    player can pick up magazines of paintballs and reload at any time, so we want
    the class to keep track of the total number of balls the player has *and* the
    number of balls currently loaded. We’ll add a method to check if the gun is empty
    and needs to be reloaded. We also want it to keep track of the magazine size.
    Any time the player gets more ammo we want the gun to automatically reload a full
    magazine, so we’ll make sure that always happens by providing a method to set
    the number of balls that calls the Reload method.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**让我们为一个彩弹枪类创建一个PaintballGun**，用于彩弹竞技场视频游戏。玩家可以随时拿起彩弹弹夹并重新装弹，因此我们希望这个类能够跟踪玩家拥有的总弹球数*以及*当前加载的弹球数。我们将添加一个方法来检查枪是否已空并需要重新装弹。我们还希望它能够跟踪弹夹的大小。任何时候玩家获得更多弹药，我们希望枪能自动重新装满弹夹，因此我们会提供一个设置弹球数量并调用Reload方法的方法来确保始终发生这种情况。'
- en: '![Images](assets/252fig01.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/252fig01.png)'
- en: Write a console app to test the PaintballGun class
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个控制台应用程序来测试PaintballGun类
- en: '***Do this!***'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '***要做这件事！***'
- en: 'Let’s try out our new PaintballGun class. **Create a new console app** and
    add the PaintballGun class to it. Here’s the Main method—it uses a loop to call
    the various methods in the class:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下我们的新PaintballGun类。**创建一个新的控制台应用程序**并将PaintballGun类添加到其中。这是Main方法—它使用一个循环调用类中的各种方法：
- en: '[PRE4]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-151
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A console app with a loop that tests an instance of a class should be really
    familiar by now. Make sure you can read the code and understand how it works.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该非常熟悉了，一个带有循环的控制台应用程序测试一个类的实例。确保你能阅读代码并理解其工作原理。
- en: Our class is well-encapsulated, but...
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的类封装得很好，但是……
- en: 'The class works, and we encapsulated it pretty well. The **balls field is protected**:
    it doesn’t let you set a negative number of balls, and it stays in sync with the
    ballsLoaded field. The Reload and Shoot methods work as expected, and there don’t
    seem to be any *obvious* ways we could accidentally misuse this class.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类运行良好，我们封装得也很好。**balls字段是受保护的**：它不允许设置负数的球，并且与ballsLoaded字段保持同步。Reload和Shoot方法的工作正常，看起来没有明显的*显而易见的*方法我们可能会意外地误用这个类。
- en: 'But have a closer look at this line from the Main method:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 但是请仔细看一下Main方法中的这一行：
- en: '[PRE5]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let’s be honest—that’s a downgrade from a field. If we still had a field, we
    could use the += operator to increase it by the magazine size. Encapsulation is
    great, but we don’t want it to make our class annoying or difficult to use.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 坦率地说，这比一个字段要逊色。如果还有一个字段，我们可以使用+=运算符将其增加到弹匣大小。封装很棒，但我们不希望它让我们的类变得烦人或难以使用。
- en: '***Is there a way to keep the balls field protected but still get the convenience
    of +=?***'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '***有没有办法保持balls字段受保护，但仍然能方便地使用+=？***'
- en: Properties make encapsulation easier
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性使封装更容易
- en: 'So far you’ve learned about two kinds of class members, methods and fields.
    There’s a third kind of class member that helps you encapsulate your classes:
    they **property**. A property is a class member that ***looks like a field***
    when it’s used, but it ***acts like a method*** when it runs.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学到了两种类成员，方法和字段。还有第三种类成员可以帮助你封装类：它们是**属性**。属性是一个类成员，在使用时看起来像字段，但在运行时像方法一样工作。
- en: 'A property is declared just like a field, with a type and a name, except instead
    of ending with a semicolon it’s followed by curly brackets. Inside those brackets
    are **property accessors**, or methods that either return or set the property
    value. There are two types of accessors:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 声明属性的方式与字段相同，具有类型和名称，但不是以分号结束，而是后跟花括号。在这些花括号内是**属性访问器**，或者返回或设置属性值的方法。有两种类型的访问器：
- en: A **get property accessor**, usually just referred to as a **get accessor**
    or **getter**, that returns the value of the property. It starts with the `**get**`
    keyword, followed by a method inside curly brackets. The method must return a
    value that matches the type in the property declaration.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**获取属性访问器**，通常简称为**get访问器**或**getter**，用于返回属性的值。它以`**get**`关键字开头，后跟着一个花括号内的方法。该方法必须返回与属性声明中类型匹配的值。
- en: A **set property accessor**, usually just referred to as a **set accessor**
    or **setter**, that sets the value of the property. It starts with the `**set**`
    keyword, followed by a method inside curly brackets. Inside the method, the `**value**`
    keyword is a read-only variable that contains the value being set.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**设置属性访问器**，通常简称为**set访问器**或**setter**，用于设置属性的值。它以`**set**`关键字开头，后跟着一个花括号内的方法。在方法内部，`**value**`关键字是一个只读变量，包含正在设置的值。
- en: It is very common for a property to get or set a **backing field**, which is
    what we call a private field that’s encapsulated by restricting access to it through
    a property.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 属性通常会获取或设置一个**后备字段**，这是我们通过属性来限制访问的私有字段。
- en: Replace the GetBalls and SetBalls methods with a property
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用属性替换GetBalls和SetBalls方法
- en: '***Replace this!***'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '***替换这个！***'
- en: 'Here are the GetBalls and SetBalls methods from your PaintballGun class:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自你的PaintballGun类的GetBalls和SetBalls方法：
- en: '[PRE6]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s replace them with a property. **Delete both methods**. Then **add this
    Balls property**:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个属性替换它们。**删除两个方法**。然后**添加这个Balls属性**：
- en: '![Images](assets/254fig01.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/254fig01.png)'
- en: Modify your Main method to use the Balls property
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改你的Main方法以使用Balls属性
- en: Now that you’ve replaced the GetBalls and SetBalls methods with a single property
    called Balls, your code won’t build anymore. You need to update the Main method
    to use the Balls property instead of the old methods.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经用一个名为Balls的单一属性替换了GetBalls和SetBalls方法，你的代码将无法再构建。你需要更新Main方法以使用Balls属性而不是旧的方法。
- en: 'The GetBalls method was called in this Console.WriteLine statement:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个Console.WriteLine语句中调用了GetBalls方法：
- en: '***Update this!***'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '***更新这个！***'
- en: '[PRE7]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can fix that by **replacing** `**GetBalls()**` **with** `**Balls**`—when
    you do this, the statement will work just like before. Let’s have a look at the
    other place where GetBalls and SetBalls were used:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**替换** `**GetBalls()**` **为** `**Balls**`——这样做后，这条语句将像以前一样工作。让我们来看看使用了GetBalls和SetBalls的另一个地方：'
- en: '[PRE8]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This was that messy line of code that looked ugly and clunky. Properties are
    really useful because they work like methods but you use them like fields. So
    let’s use the Balls property like a field—**replace that line** with this statement
    that uses the += operator exactly like it would if Balls were a field:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 那是一行混乱且笨拙的代码。属性真的很有用，因为它们像方法一样工作，但你可以像使用字段一样使用它们。所以让我们像使用字段一样使用Balls属性——**用使用+=运算符的这条语句替换那行代码**：
- en: '![Images](assets/255fig01.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/255fig01.png)'
- en: 'Here’s the updated Main method:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是更新后的Main方法：
- en: '[PRE9]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Debug your PaintballGun class to understand how the property works
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试你的PaintballGun类以理解属性的工作原理
- en: 'Use the debugger to really get a good sense of how your new Ball property works:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用调试器真正了解您的新Ball属性的工作方式：
- en: Place a breakpoint inside the curly brackets of the get accessor (`return balls;`).
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在get访问器的大括号内部（`return balls;`）放置一个断点。
- en: Place another breakpoint on the first line of the set accessor (`if (value >
    0)`).
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在set访问器的第一行（`if (value > 0)`）上再放一个断点。
- en: Place a breakpoint at the top of the Main method and start debugging. Step over
    each statement.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Main方法的顶部放置一个断点并开始调试。逐个跳过每个语句。
- en: When you step over Console.WriteLine, the debugger will hit the breakpoint in
    the getter.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您跳过Console.WriteLine时，调试器将在getter中断点处停止。
- en: Keep stepping over methods. When you execute the += statement, the debugger
    will hit the breakpoint in the setter. Add a watch for the backing field **balls**
    and the `**value**` keyword.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续逐步执行方法。当您执行+=语句时，调试器将在setter中断点处停止。为背景字段**balls**和`**value**`关键字添加一个监视器。
- en: Auto-implemented properties simplify your code
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动实现的属性简化了您的代码
- en: '***Add this!***'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '***添加这个！***'
- en: 'A very common way to use a property is to create a backing field and provide
    get and set accessors for it. Let’s create a new BallsLoaded property that **uses
    the existing ballsLoaded field** as a backing field:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性的一个非常常见的方法是创建一个背景字段并为其提供get和set访问器。让我们创建一个新的BallsLoaded属性，**使用现有的ballsLoaded字段**作为背景字段：
- en: '[PRE10]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-193
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**This property uses a private** backing field**. Its getter returns the value
    in the field, and its setter updates the field.**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**此属性使用私有**背景字段**。其getter返回字段中的值，其setter更新字段。**'
- en: 'Now you can **delete the GetBallsLoaded method** and modify your Main method
    to use the property:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以**删除GetBallsLoaded方法**并修改您的Main方法以使用属性：
- en: '[PRE11]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run your program again. It should still work exactly the same way.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行您的程序。它应该仍然以完全相同的方式工作。
- en: Use the prop snippet to create an auto-implemented property
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用prop代码片段创建自动实现的属性
- en: 'An **auto-implemented property**—sometimes called an **automatic property**
    or **auto-property**—is a property that has a getter that returns the value of
    the backing field, and a setter that updates it. In other words, it works just
    like the BallsLoaded property that you just created. There’s one important difference:
    when you create an automatic property ***you don’t define the backing field***.
    Instead, the C# compiler creates the backing field for you, and the only way to
    update it is to use the get and set accessors.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**自动实现的属性**——有时称为**自动属性**或**自动化属性**——是一个具有返回背景字段值的getter和更新它的setter的属性。换句话说，它的工作原理就像您刚刚创建的BallsLoaded属性一样。有一个重要的区别：当您创建自动属性***时，不需要定义背景字段***。相反，C#编译器会为您创建背景字段，更新它的唯一方法是使用get和set访问器。
- en: 'Visual Studio gives you a really useful tool for creating automatic properties:
    a **code snippet**, or a small, reusable block of code that the IDE inserts automatically.
    Let’s use it to create a BallsLoaded auto-property.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio为创建自动属性提供了一个非常有用的工具：一个**代码片段**，或者说是一个小型、可重用的代码块，IDE会自动插入它。让我们用它来创建一个名为BallsLoaded的自动属性。
- en: '**Remove the BallsLoaded property and backing field.** Delete the BallsLoaded
    property you added, because we’re going to replace it with an auto-implemented
    property. Then delete the ballsLoaded backing field (`private int ballsLoaded
    = 0;`) too, because any time you create an automatic property the C# compiler
    generates a hidden backing field for you.'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**删除BallsLoaded属性和背景字段。** 删除您添加的BallsLoaded属性，因为我们将用自动实现的属性替换它。然后删除ballsLoaded背景字段（`private
    int ballsLoaded = 0;`），因为每次创建自动属性时，C#编译器都会为您生成一个隐藏的背景字段。'
- en: '**Tell the IDE to start the prop snippet.** Put your cursor where the field
    used to be, and then **type** `**prop**` **and** **press the Tab key twice** to
    tell the IDE to start a snippet. It will add this line to your code:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**告诉IDE启动prop代码片段。** 将光标放在字段原来的位置，然后**键入** `**prop**` **并** **按两次Tab键**告诉IDE启动代码片段。它会将以下行添加到您的代码中：'
- en: '![Images](assets/256fig01.png)'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/256fig01.png)'
- en: The snippet is a template that lets you edit parts of it—the prop snippet lets
    you edit the type and the property name. Press the Tab key once to switch to the
    property name, then **change the name to** `**BallsLoaded**` and press Enter to
    finalize the snippet
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该片段是一个模板，允许您编辑其部分——prop片段允许您编辑类型和属性名称。按一次Tab键切换到属性名称，然后**将名称更改为** `**BallsLoaded**`
    并按Enter键以完成片段
- en: '[PRE12]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**You don’t have to declare a backing field for an automatic property because
    the C# compiler creates it automatically.**'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**你不必为自动属性声明后备字段，因为 C# 编译器会自动创建它。**'
- en: '**Fix the rest of the class.** Since you removed the ballsLoaded field, your
    PaintballGun class doesn’t compile anymore. That has a quick fix—the **b**allsLoaded
    field appears five times in the code (once in the IsEmpty method, and twice in
    the Reload and Shoot methods). Change them to **B**allsLoaded—now your program
    works again.'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**修复类的其余部分。** 由于你移除了 ballsLoaded 字段，你的 PaintballGun 类不再编译。这有一个快速的修复方案——代码中
    ballsLoaded 字段出现了五次（一次在 IsEmpty 方法中，两次在 Reload 和 Shoot 方法中）。将它们改为 **B**allsLoaded——现在你的程序又可以工作了。'
- en: Use a private setter to create a read-only property
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用私有 setter 来创建一个只读属性
- en: 'Let’s take another look at the auto-implemented property that you just created:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再来看一下你刚刚创建的自动属性：
- en: '[PRE13]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is definitely a great replacement for a property with get and set accessors
    that just update a backing field. It’s more readable and has less code than the
    ballsLoaded field and GetBallsLoaded method. So that’s an improvement, right?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对是一个很好的替代方案，用一个带有 get 和 set 访问器的属性来更新后备字段。它比 ballsLoaded 字段和 GetBallsLoaded
    方法更易读，并且代码更少。所以这是一种进步，对吧？
- en: 'But there’s one problem: ***we’ve broken the encapsulation***. The whole point
    of the private field and public method was to make the number of balls loaded
    read-only. The Main method could easily set the BallsLoaded property. We made
    the field private and created a public method to get the value so that it could
    only be modified from inside the PaintballGun class.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有一个问题：***我们破坏了封装性***。私有字段和公共方法的整个目的是使装载的球数只读。Main 方法很容易设置 BallsLoaded 属性。我们将字段设为私有，并创建了一个公共方法来获取值，以便只能从
    PaintballGun 类内部进行修改。
- en: Make the BallsLoaded setter private
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 BallsLoaded 的 setter 设为 private
- en: Luckily, there’s a quick way to make our PaintballGun class well-encapsulated
    again. When you use a property, you can put an access modifier in front of the
    `get` or `set` keyword.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们有一个快速的方法来重新使 PaintballGun 类良好封装。当你使用属性时，你可以在 `get` 或 `set` 关键字前放置一个访问修饰符。
- en: You can make a **read-only property** that can’t be set by another class by
    making its set accessor `**private**`. In fact, you can leave out the set accessor
    entirely for normal properties—but not automatic properties, which *must* have
    a set accessor or your code won’t compile.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个**只读属性**，通过将其 set 访问器设为 `**private**`，使其不能被其他类设置。事实上，对于普通属性，你可以完全省略 set
    访问器，但对于自动属性来说不行，否则你的代码将无法编译。
- en: 'So let’s **make the set accessor private**:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们 **将 set 访问器设为 private**：
- en: '[PRE14]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-219
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can make your automatic property read-only by making its setter private.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将其 setter 设为 private 来将自动属性设为只读。
- en: Now the BallsLoaded field is a **read-only property**. It can be read anywhere,
    but it can only be updated from inside the PaintballGun class. The PaintballGun
    class is well-encapsulated again.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 BallsLoaded 字段是一个**只读属性**。它可以在任何地方读取，但只能从 PaintballGun 类内部更新。PaintballGun
    类再次良好封装。
- en: What if we want to change the magazine size?
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果我们想要改变弹夹大小怎么办？
- en: 'Right now the PaintballGun class uses a `const` for the magazine size:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，PaintballGun 类使用一个 `const` 来表示弹夹大小：
- en: '[PRE15]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***Replace this!***'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '***替换这个！***'
- en: What if we want the game to set the magazine size when it instantiates the gun?
    Let’s **replace it with a property**.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望游戏在实例化枪支时设置弹夹大小怎么办？让我们 **用属性来替换它**。
- en: '**Remove the MAGAZINE_SIZE constant and replace it with a read-only property.**'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**移除 MAGAZINE_SIZE 常量并用一个只读属性来替换它。**'
- en: '[PRE16]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Modify the Reload method to use the new property.**'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**修改 Reload 方法以使用新的属性。**'
- en: '[PRE17]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Fix the line in the Main method that adds the ammo.**'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**修复在 Main 方法中添加弹药的那一行。**'
- en: '[PRE18]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: But there’s a problem…how do we initialize MagazineSize?
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 但是有一个问题……我们如何初始化 MagazineSize？
- en: 'The MAGAZINE_SIZE constant used to be set to 16\. Now we’ve replaced it with
    an auto-property, and if we want, we can initialize it to 16 just like a field
    by **adding an assignment to the end of the declaration**:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，MAGAZINE_SIZE 常量设置为 16。现在我们用自动属性替换它了，如果需要，我们可以像字段一样在声明的末尾添加赋值来初始化为 16：
- en: '[PRE19]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: But what if we want the game to be able to specify the number of balls in the
    magazine? Maybe most guns are spawned loaded, but in some rapid onslaught levels
    we want some guns to spawn unloaded so the player needs to reload before firing.
    ***How do we do that?***
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果我们希望游戏能够指定弹夹中的球数呢？也许大多数枪支都是生成时已经装载好的，但在某些快速袭击级别中，我们希望某些枪支生成时未装载，这样玩家需要在开火前进行装填。***我们该怎么做？***
- en: Use a constructor with parameters to initialize properties
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用带参数的构造函数来初始化属性
- en: You saw earlier in the chapter that you can initialize an object with a constructor,
    or a special method that’s called when the object is first instantiated. Constructors
    are just like any other method—which means they can have **parameters**. We’ll
    use a constructor with parameters to initialize the properties.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面你看到，可以用构造函数或对象首次实例化时调用的特殊方法来初始化对象。构造函数就像任何其他方法一样——这意味着它们可以有**参数**。我们将使用带参数的构造函数来初始化属性。
- en: 'The constructor you just created in the Q&A answer looks like this: `**public
    ConstructorTest()**`. That’s a **parameterless constructor**, so just like any
    other method without parameters the declaration ends with `()`. Now let’s **add
    a constructor with parameters** to the PaintballGun class. Here’s the constructor
    to add:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚才在问答环节中创建的构造函数看起来是这样的：`**public ConstructorTest()**`。那是一个**无参数构造函数**，所以就像任何没有参数的方法一样，声明以`()`结尾。现在让我们向
    PaintballGun 类添加一个带参数的构造函数。以下是要添加的构造函数：
- en: '![Images](assets/259fig01.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/259fig01.png)'
- en: 'Uh-oh—there’s a problem. As soon as you add the constructor, the IDE will tell
    you that the Main method has an error:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 出问题了—一旦你添加了构造函数，IDE 就会告诉你 Main 方法出错了：
- en: '![Images](assets/259fig02.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/259fig02.png)'
- en: '***What do you think we need to do to fix this error?***'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '***你认为我们需要做什么来修复这个错误？***'
- en: Specify arguments when you use the “new” keyword
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当你使用“new”关键字时，需要指定参数。
- en: 'When you added the constructor, the IDE told you that the Main method has an
    error on the `**new**` statement (`**PaintballGun gun = new PaintballGun()**`).
    Here’s what that error looks like:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当你添加了构造函数，IDE 告诉你 Main 方法在`**new**`语句（`**PaintballGun gun = new PaintballGun()**`）上有错误。以下是该错误的样子：
- en: '![Images](assets/260fig01.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/260fig01.png)'
- en: 'Read the text of the error—it’s telling you exactly what’s wrong. Your constructor
    now takes arguments, so it needs parameters. Start typing the `new` statement
    again, and the IDE will tell you exactly what you need to add:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读错误文本——它告诉你出了什么问题。现在你的构造函数接受参数，因此需要参数。重新输入`new`语句，IDE 将精确告知你需要添加的内容：
- en: '![Images](assets/260fig02.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/260fig02.png)'
- en: You’ve been using `new` to create instances of classes. So far, all of your
    classes have had parameterless constructors, so you never needed to provide any
    arguments.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直在使用`new`来创建类的实例。到目前为止，你所有的类都有无参数构造函数，因此你从未需要提供任何参数。
- en: Now you have a constructor with parameters, and like any method with parameters,
    it requires you to specify arguments with types that match those parameters.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个带参数的构造函数，像任何带参数的方法一样，它要求你指定与这些参数匹配的类型的参数。
- en: Let’s modify your Main method to **pass parameters to the PaintballGun constructor**.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改你的 Main 方法，**向 PaintballGun 构造函数传递参数**。
- en: '***Modify this!***'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '***修改这个！***'
- en: '**Add the ReadInt method that you wrote for Owen’s ability score calculator
    in [#types_and_references_getting_the_referen](ch04.html#types_and_references_getting_the_referen).**'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加你在 [#types_and_references_getting_the_referen](ch04.html#types_and_references_getting_the_referen)
    为 Owen 的能力得分计算器编写的 ReadInt 方法。**'
- en: You need to get the arguments for the constructor from somewhere. You already
    have a perfectly good method that prompts the user for int values, so it makes
    sense to reuse it here.
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你需要从某处获取构造函数的参数。你已经有一个非常好的方法提示用户输入 int 值，所以在这里重用它是有道理的。
- en: '**Add code to read values from the console input.**'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加代码以从控制台输入读取值。**'
- en: 'Now that you’ve added the ReadInt method from [#types_and_references_getting_the_referen](ch04.html#types_and_references_getting_the_referen),
    you can use it to get two int values. Add these four lines of code to the top
    of your Main method:'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在你已经从 [#types_and_references_getting_the_referen](ch04.html#types_and_references_getting_the_referen)
    添加了 ReadInt 方法，可以使用它来获取两个 int 值。将以下四行代码添加到你的 Main 方法顶部：
- en: '[PRE20]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**If TryParse can’t parse the line, it will leave isLoaded with the default
    value, which for a bool is false.**'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**如果 TryParse 无法解析该行，它将使用默认值留下 isLoaded，对于布尔值，默认值是 false。**'
- en: '**Update the new statement to add arguments.**'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**更新新语句以添加参数。**'
- en: 'Now that you have values in variables with types that match the parameters
    in the constructor, you can update the `**new**` statement to pass them to the
    constructor as arguments:'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在你已经有了与构造函数参数类型匹配的变量值，可以更新`**new**`语句将它们作为参数传递给构造函数：
- en: PaintballGun gun = new PaintballGun(`**numberOfBalls, magazineSize, isLoaded**`);
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: PaintballGun gun = new PaintballGun(`**numberOfBalls, magazineSize, isLoaded**`);
- en: '**Run your program.**'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行你的程序。**'
- en: Now run your program. It will prompt you for the number of balls, the magazine
    size, and whether or not the gun is loaded. Then it will create a new instance
    of PaintballGun, passing arguments to its constructor that match your choices.
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在运行你的程序。它将提示你输入球的数量、弹夹大小以及枪是否装载。然后它将创建一个新的 PaintballGun 实例，将你的选择作为参数传递给它的构造函数。
- en: A few useful facts about methods and properties
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些关于方法和属性的有用事实
- en: '**Every method in your class has a unique signature.**'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你的类中每个方法都有一个独特的签名。**'
- en: The first line of a method, which contains the access modifier, return value,
    name, and parameters is called the method’s **signature**. Properties have signatures,
    too—they consist of the access modifier, type, and name.
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 方法的第一行包含访问修饰符、返回值、名称和参数，称为方法的 **签名**。属性也有签名——由访问修饰符、类型和名称组成。
- en: '**You can initialize properties in an object initializer.**'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你可以在对象初始化器中初始化属性。**'
- en: 'You used object initializers before:'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你之前使用过对象初始化器：
- en: '[PRE21]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can also specify properties in an object initializer. If you do, the constructor
    is run first, then the properties are set. And you can only initialize public
    fields and properties in the object initializer.
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以在对象初始化器中指定属性。如果这样做，构造函数会首先运行，然后设置属性。并且你只能在对象初始化器中初始化公共字段和属性。
- en: '**Every class has a constructor, even if you didn’t add one yourself.**'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每个类都有一个构造函数，即使你没有自己添加。**'
- en: The CLR needs a constructor to instantiate an object—it’s part of the behind-the-scenes
    mechanics of how .NET works. So if you don’t add a constructor to your class,
    the C# compiler automatically adds a parameterless constructor for you.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: CLR 需要一个构造函数来实例化一个对象——这是 .NET 工作幕后机制的一部分。所以如果你的类中没有添加构造函数，C# 编译器会自动为你添加一个无参构造函数。
- en: '**You can keep a class from being instantiated by other classes by adding a
    private constructor.**'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你可以通过添加私有构造函数阻止其他类实例化这个类。**'
- en: 'Sometimes you need to have really careful control over how your objects are
    created. One way to do that is to make your constructor private—then it can only
    be called from inside the class. Take a minute and try it out:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要非常谨慎地控制对象的创建方式。一种方法是将构造函数设为私有——这样它只能从类的内部调用。花点时间试试：
- en: '[PRE22]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Add that NoNew class to a console app. If you try to add new NoNew(); to your
    Main method, the C# compiler gives you an error (’*NoNew.NoNew()’ is inaccessible
    due to its protection level*), but the **NoNew.CreateInstance** method creates
    a new instance just fine.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 将 NoNew 类添加到控制台应用程序中。如果你尝试在 Main 方法中添加 new NoNew();，C# 编译器会给出错误（"*NoNew.NoNew()
    由于其保护级别而不可访问*"），但 NoNew.CreateInstance 方法可以正常创建一个新实例。
- en: Note
  id: totrans-278
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This is a really good time to talk about aesthetics in video games. If you think
    about it, encapsulation doesn’t really give you a way to do anything that you
    couldn’t before. You could still write the same programs without properties, constructors,
    and private methods—but they would sure look really different. That’s because
    not everything in programming is about making your code do something different.
    Often, it’s about making your code do the same thing but in a better way. Think
    about that when you read about aesthetics. They don’t change the way your game
    behaves, they change the way the player thinks and feels about the game.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是讨论视频游戏美学的好时机。如果你仔细想想，封装其实并没有给你提供一种你以前不能做到的方法。没有属性、构造函数和私有方法，你仍然可以写出相同的程序——但它们看起来会完全不同。因为编程并不全是让你的代码做些不同的事情。通常，它是让你的代码以更好的方式做同样的事情。当你思考美学时，请考虑这一点。它们不会改变游戏的行为方式，但会改变玩家对游戏的思考和感受。
- en: Note
  id: totrans-280
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Some developers are really skeptical when they read about aesthetics because
    they assume that only the mechanics of the game matter. Here’s a quick thought
    experiment to show how important aesthetics can be. Say you have two games with
    identical mechanics. There’s just one very tiny difference between them. In one
    game you’re kicking boulders out of the way to save a village. In the other game,
    you’re kicking puppies and kittens because you are a horrible person. Even if
    every other aspect of those games is identical, those are two very different games.
    That’s the power of aesthetics.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者在阅读有关美学的内容时确实持怀疑态度，因为他们认为只有游戏的机制才重要。这里有一个快速的思维实验来展示美学有多么重要。假设你有两款具有完全相同机制的游戏。它们之间只有一个微小的差异。在一个游戏中，你要踢开巨石来拯救一个村庄。在另一个游戏中，你要踢开小狗和小猫，因为你是一个可怕的人。即使这两款游戏在其他方面完全相同，它们也是两款非常不同的游戏。这就是美学的力量。
- en: Note
  id: totrans-282
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Go to the** Visual Studio for Mac Learner’s Guide **for the Mac version of
    this exercise.****'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**前往** Visual Studio for Mac 学习指南 **查看此练习的 macOS 版本。**'
