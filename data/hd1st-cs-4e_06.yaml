- en: 'Chapter 4\. Types and References: *Getting the Reference*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章\. 类型和引用：*获取引用*
- en: '![Images](assets/155fig01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/155fig01.png)'
- en: '**What would your apps be without data?** Think about it for a minute. Without
    data, your programs are…well, it’s actually hard to imagine writing code without
    data. You need **information** from your users, and you use that to look up or
    produce new information to give back to them. In fact, almost everything you do
    in programming involves **working with data** in one way or another. In this chapter,
    you’ll learn the ins and outs of C#’s **data types** and **references**, see how
    to work with data in your program, and even learn a few more things about **objects**
    (*guess what…objects are data, too!*)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**没有数据，你的应用程序还能是什么？** 想想看。没有数据，你的程序……嗯，实际上很难想象没有数据写代码。你需要**用户提供的信息**，然后用它来查找或生成新信息返回给他们。事实上，编程中几乎所有的工作都涉及以某种方式**处理数据**。在本章中，你将深入了解C#的**数据类型**和**引用**，看看如何在程序中处理数据，甚至学习更多关于**对象**的知识（*猜猜看……对象也是数据！*）'
- en: Owen could use our help!
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 欧文需要我们的帮助！
- en: Owen is a game master—a really good one. He hosts a group that meets at his
    place every week to play different role-playing games (or RPGs), and like any
    good game master, he really works hard to keep things interesting for the players.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 欧文是一名游戏主持人——一个非常出色的游戏主持人。他每周在自己家里组织一群人玩各种不同的角色扮演游戏（或者RPG），像所有优秀的游戏主持人一样，他非常努力地为玩家们保持趣味性。
- en: '![Images](assets/156fig01.png)![Images](assets/156fig02.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/156fig01.png)![图片](assets/156fig02.png)'
- en: Storytelling, fantasy, and mechanics
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 叙事、幻想和机制
- en: Owen is a particularly good storyteller. Over the last few months he’s created
    an intricate fantasy world for his party, but he’s not so happy with the mechanics
    of the game that they’ve been playing.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 欧文是一个特别优秀的叙述者。在过去几个月里，他为他的队伍创造了一个复杂的幻想世界，但他对他们正在玩的游戏机制并不满意。
- en: '***Can we find a way to help Owen improve his RPG?***'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '***我们能找到一种方法帮助欧文改进他的角色扮演游戏吗？***'
- en: '![Images](assets/156fig03.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/156fig03.png)'
- en: Character sheets store different types of data on paper
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色卡在纸上存储不同类型的数据
- en: 'If you’ve ever played an RPG, you’ve seen character sheets: a page with details,
    statistics, background information, and any other notes you might see about a
    character. If you wanted to make a class to hold a character sheet, what types
    would you use for the fields?'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你玩过角色扮演游戏，你一定见过角色卡：一张详细记录角色细节、统计数据、背景信息以及其他任何关于角色的笔记的页面。如果你想制作一个类来保存角色卡，你会使用什么类型作为字段？
- en: '![Images](assets/157fig01.png)![Images](assets/157fig02.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/157fig01.png)![图片](assets/157fig02.png)'
- en: A variable’s type determines what kind of data it can store
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量的类型决定了它可以存储什么类型的数据。
- en: There are many **types** built into C#, and you’ll use them to store many different
    kinds of data. You’ve already seen some of the most common ones, like int, string,
    bool, and float. There are a few others that you haven’t seen, and they can really
    come in handy, too.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: C#内置了许多**类型**，你会用它们来存储许多不同种类的数据。你已经见过一些最常见的，比如int、string、bool和float。还有一些你还没见过的，它们也会非常有用。
- en: Here are some types you’ll use a lot.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你会经常使用的类型。
- en: '![Images](assets/158fig01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/158fig01.png)'
- en: '**int** can store any **integer** from –2,147,483,648 to 2,147,483,647\. Integers
    don’t have decimal points.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**int** 可以存储从–2,147,483,648到2,147,483,647的任何**整数**。整数没有小数点。'
- en: '![Images](assets/158fig02.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/158fig02.png)'
- en: '**float** can store **real** numbers from ±1.5 × 10^(–45) to ±3.4 × 10^(38)
    with up to 8 significant digits.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**float** 可以存储从±1.5 × 10^(–45)到±3.4 × 10^(38)的**实数**，精度高达8位有效数字。'
- en: '![Images](assets/158fig03.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/158fig03.png)'
- en: '**string** can hold text of any length (including the empty string `""`).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**string** 可以存储任意长度的文本（包括空字符串`""`）。'
- en: '![Images](assets/158fig05.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/158fig05.png)'
- en: '**double** can store **real** numbers from ±5.0 × 10^(–324) to ±1.7 × 10^(308)
    with up to 16 significant digits. It’s a really common type when you’re working
    with XAML properties.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**double** 可以存储从±5.0 × 10^(–324)到±1.7 × 10^(308)的**实数**，精度高达16位有效数字。当你在处理XAML属性时，这是一个非常常见的类型。'
- en: '![Images](assets/158fig04.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/158fig04.png)'
- en: '**bool** is a Boolean value—it’s either true or false. You’ll use it to represent
    anything that only has two options: it can either be one thing or another, but
    nothing else.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**bool** 是布尔值——它只能是true或false。你会用它来表示只有两种选项的任何东西：它要么是一种东西，要么是另一种东西，但没有其他的选项。'
- en: C# has several types for storing integers
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#有几种用于存储整数的类型
- en: C# has several different types for integers, as well as int. This may seem a
    little odd (pun intended). Why have so many types for numbers without decimals?
    For most of the programs in this book, it won’t matter if you use an int or a
    long. If you’re writing a program that has to keep track of millions and millions
    of integer values, then choosing a smaller integer type like byte instead of a
    bigger type like long can save you a lot of memory.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: C# 有几种不同的整数类型，以及 int。这可能看起来有点奇怪（双关）。为什么有这么多不带小数点的数字类型？对于本书中的大多数程序来说，使用 int 还是
    long 并不重要。如果你要编写一个必须跟踪成千上万个整数值的程序，那么选择像 byte 这样的较小整数类型而不是像 long 这样的更大类型可以节省大量内存。
- en: '***byte*** can store any **integer** between 0 and 255.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***byte*** 可以存储介于 0 到 255 之间的任何**整数**。'
- en: '***sbyte*** can store any **integer** from –128 to 127.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***sbyte*** 可以存储从 –128 到 127 的任何**整数**。'
- en: '***short*** can store any **integer** from –32,768 to 32,767.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***short*** 可以存储从 –32,768 到 32,767 的任何**整数**。'
- en: '***long*** can store any **integer** from –9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***long*** 可以存储从 –9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 的任何**整数**。'
- en: Note
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Notice how we’re saying “integer” and not “whole number” ? We’re trying to be
    really careful—our high school math teachers always told us that integers are
    any numbers that can be written without a fraction, while whole numbers are integers
    starting at 0, and do not include negative numbers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们说的是“整数”，而不是“整数”？我们尽量小心——我们的高中数学老师总是告诉我们，整数是可以不带分数写出来的任何数字，而整数从 0 开始，不包括负数。
- en: '![Images](assets/159fig02.png)![Images](assets/159fig03.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/159fig02.png)![图像](assets/159fig03.png)'
- en: 'Did you notice that byte only stores positive numbers, while sbyte stores negative
    numbers? They both have 256 possible values. The difference is that, like short
    and long, sbyte can have a negative sign—which is why those are called **signed**
    types, (the “s” in sbyte stands for signed). Just like byte is the **unsigned**
    version of sbyte, there are unsigned versions of short, int, and long that start
    with “u” :'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到 byte 只存储正数，而 sbyte 存储负数了吗？它们都有 256 个可能的值。区别在于，像 short 和 long 一样，sbyte 可以有一个负号——这就是为什么它们被称为**有符号**类型（sbyte
    中的“s”表示有符号）。就像 byte 是 sbyte 的**无符号**版本一样，还有以“u”开头的 short、int 和 long 的无符号版本：
- en: '***ushort*** can store any **whole number** from 0 to 65,535.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***ushort*** 可以存储从 0 到 65,535 的任何**整数**。'
- en: '***uint*** can store any **whole number** from 0 to 4,294,967,295.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***uint*** 可以存储从 0 到 4,294,967,295 的任何**整数**。'
- en: '***ulong*** can store any **whole number** from 0 to 18,446,744,073,709,551,615.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***ulong*** 可以存储从 0 到 18,446,744,073,709,551,615 的任何**整数**。'
- en: '![Images](assets/159fig04.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/159fig04.png)'
- en: Types for storing really HUGE and really tiny numbers
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于存储非常巨大和非常微小数字的类型
- en: 'Sometimes float just isn’t precise enough. Believe it or not, sometimes 10^(38)
    isn’t big enough and 10^(–45) isn’t small enough. A lot of programs written for
    finance or scientific research run into these problems all the time, so C# gives
    us different **floating-point types** to handle huge and tiny values:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有时浮点数并不够精确。信不信由你，有时候 10^(38) 不够大，而 10^(-45) 不够小。很多为金融或科学研究编写的程序经常遇到这些问题，所以 C#
    提供了不同的**浮点类型**来处理巨大和微小的值：
- en: '***float*** can store any number from ±1.5 × 10^(–45) to ±3.4 × 10^(38) with
    6–9 significant digits.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***float*** 可以存储从 ±1.5 × 10^(-45) 到 ±3.4 × 10^(38) 的任何数字，具有 6–9 个有效数字。'
- en: '***double*** can store any number from ±5.0 × 10^(–324) to ±1.7 × 10^(308)
    with 15–17 significant digits.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***double*** 可以存储从 ±5.0 × 10^(-324) 到 ±1.7 × 10^(308) 的任何数字，具有 15–17 个有效数字。'
- en: '***decimal*** can store any number from ±1.0 × 10^(–28) to ±7.9 × 10^(28) with
    28–29 significant digits. When your program **needs to deal with money or currency**,
    you always want to use a decimal to store the number.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***decimal*** 可以存储从 ±1.0 × 10^(-28) 到 ±7.9 × 10^(28) 的任何数字，具有 28–29 个有效数字。当你的程序**需要处理货币或货币**时，始终应该使用
    decimal 来存储数字。'
- en: Note
  id: totrans-45
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The decimal type has a lot more precision (way more significant digits) which
    is why it’s appropriate for financial calculations.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**decimal** 类型具有更高的精度（更多有效数字），这就是为什么它适用于金融计算。'
- en: Let’s talk about strings
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们来谈谈字符串
- en: You’ve written code that works with **strings**. So what, exactly, is a string?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经写了处理**字符串**的代码。那么，字符串到底是什么？
- en: In any .NET app, a string is an object. Its full class name is System.String—in
    other words, the class name is String and it’s in the System namespace (just like
    the Random class you used earlier). When you use the C# `**string**` keyword,
    you’re working with System.String objects. In fact, you can replace `**string**`
    with `**System.String**` in any of the code you’ve written so far and it will
    still work! (The `**string**` keyword is called an *alias*—as far as your C# code
    is concerned, `**string**` and `**System.String**` mean the same thing.)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何.NET应用程序中，字符串都是一个对象。它的完整类名是System.String——换句话说，类名是String，它位于System命名空间中（就像你之前使用的Random类一样）。当你使用C#的**string**关键字时，你正在使用System.String对象。实际上，你可以在到目前为止你写的任何代码中用**System.String**替换**string**关键字，它仍然能够工作！（**string**关键字称为*别名*——在你的C#代码中，**string**和**System.String**意味着相同的东西。）
- en: 'There are also two special values for strings: an empty string, “” (or a string
    with no characters), and a null string, or a string that isn’t set to anything
    at all. We’ll talk more about null later in the chapter.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字符串还有两个特殊值：一个空字符串，“”（或者一个没有字符的字符串），和一个null字符串，或者一个根本没有设置为任何值的字符串。我们将在本章后面更多地讨论null。
- en: Strings are made up of characters—specifically, Unicode characters (which you’ll
    learn a lot more about later in the book). Sometimes you need to store a single
    character like `**Q**` or `**j**` or `**$**`, and when you do you’ll use the **char**
    type. Literal values for char are always inside single quotes ('`**x**``'`, `'``**3**``'`).
    You can include **escape sequences** in the quotes, too (`'``**\n**``'` is a line
    break, `'``**\t**``'` is a tab). You can write an escape sequence in your C# code
    using two characters, but your program stores each escape sequence as a single
    character in memory.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串由字符组成——具体来说，是Unicode字符（你将在本书后面学到更多）。有时候你需要存储单个字符，比如`**Q**`或`**j**`或`**$**`，这时你会使用**char**类型。char的字面值总是在单引号内（'`**x**``'`，'`**3**``'`）。你也可以在引号内包含**转义序列**（例如`'`**\n**`'`表示换行，`'`**\t**`'`表示制表符）。你可以在C#代码中使用两个字符来编写转义序列，但是你的程序会将每个转义序列存储为单个字符在内存中。
- en: 'And finally, there’s one more important type: **object**. If a variable has
    object as its type, ***you can assign any value to it***. The `**object**` keyword
    is also an alias—it’s the same as `**System.Object**`.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一个重要的类型：**object**。如果一个变量的类型是object，***你可以给它赋任何值***。**object**关键字也是一个别名——它和**System.Object**是一样的。
- en: A literal is a value written directly into your code
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字面值是直接写入你的代码中的值
- en: 'A **literal** is a number, string, or other fixed value that you include in
    your code. You’ve already used plenty of literals—here are some examples of numbers,
    strings, and other literals that you’ve used:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**字面值**是你在代码中直接写入的数值、字符串或其他固定值。你已经使用了大量的字面值——这里是你使用的一些数字、字符串和其他字面值的例子：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-56
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Can you spot all of the literals in these statements from code you’ve written
    in previous chapters? The last statement has two literals.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你能在你之前章节中编写的代码中找到所有的字面值吗？最后一条语句有两个字面值。
- en: So when you type `**int i = 5;**`, the `**5**` is a literal.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所以当你键入**int i = 5;**时，**5**是一个字面值。
- en: Use suffixes to give your literals types
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用后缀为你的字面值指定类型
- en: 'When you added statements like this in Unity, you may have wondered about the
    **F**:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在Unity中添加了像这样的语句时，你可能会对**F**感到困惑：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Did you notice that your program won’t build if you leave off the F in the
    literals 1.5F and 0.75F? That’s because **literals have types**. Every literal
    is automatically assigned a type, and C# has rules about how you can combine different
    types. You can see for yourself how that works. Add this line to any C# program:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到，如果在字面值1.5F和0.75F中不加上F，你的程序将无法构建？这是因为**字面值有类型**。每个字面值都会自动分配一个类型，而C#有关于如何组合不同类型的规则。你可以亲自看看它是如何工作的。将以下行添加到任何C#程序中：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When you try to build your program, the IDE will show you this error in the
    Error List:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试构建你的程序时，IDE会在错误列表中显示这个错误：
- en: '![Images](assets/162fig02.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/162fig02.png)'
- en: The IDE is telling you is that the literal 14.7 has a type—it’s a double. You
    can use a suffix to change its type—try changing it to a float by sticking an
    F on the end (14.7F) or a decimal by adding M (14.7M—the M actually stands for
    “money” ). The error message now says it can’t convert float or decimal. Add a
    D (or leave off the suffix entirely) and the error goes away.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: IDE告诉你的是字面值14.7有一个类型——它是double类型。你可以使用后缀来改变它的类型——尝试在末尾加上F将其改为float（14.7F），或者加上M将其改为decimal（14.7M——M实际上代表“货币”）。错误信息现在说无法转换为float或decimal。添加D（或者完全不加后缀）错误就消失了。
- en: '**C# assumes that an integer literal without a suffix (like 371) is an int,
    and one with a decimal point (like 27.4) is a double.**'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**C#假设没有后缀的整数字面值（例如371）是int类型，带有小数点的（例如27.4）是double类型。**'
- en: Note
  id: totrans-68
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you really want to use a reserved keyword as a variable name, put @ in front
    of it, but that’s as close as the compiler will let you get to the reserved word.
    You can also do that with nonreserved names, if you want to.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您真的想使用保留的关键字作为变量名，请在其前面加上@，但这是编译器允许您接近保留字的最近方式。如果您愿意，也可以用非保留名称做这个。
- en: A variable is like a data to-go cup
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量就像一个带走的数据杯
- en: All of your data takes up space in memory. (Remember the heap from the last
    chapter?) So part of your job is to think about how *much* space you’re going
    to need whenever you use a string or a number in your program. That’s one of the
    reasons you use variables. They let you set aside enough space in memory to store
    your data.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您的所有数据都占用内存空间。（还记得上一章的堆吗？）因此，每当在程序中使用字符串或数字时，您都需要考虑需要多少空间。这就是您使用变量的原因之一。它们让您在内存中预留足够的空间来存储数据。
- en: Note
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Not all data ends up on the heap. Value types usually keep their data in another
    part of memory called the stack. You’ll learn all about that later in the book.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有数据最终都会在堆上结束。值类型通常将其数据保存在称为堆栈的内存的另一个部分中。您将在本书后面详细了解这一点。
- en: Think of a variable like a cup that you keep your data in. C# uses a bunch of
    different kinds of cups to hold different kinds of data. Just like the different
    sizes of cups at a coffee shop, there are different sizes of variables, too.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个变量就像是一个杯子，你把数据放进去。C#使用各种不同类型的杯子来存储不同类型的数据。就像咖啡店里不同大小的杯子一样，变量也有不同大小。
- en: '![Images](assets/165fig01.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/165fig01.png)'
- en: Use the Convert class to explore bits and bytes
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Convert类来探索位和字节
- en: '***Convert this!***'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '***转换这个！***'
- en: You’ve always heard that programming is about 1s and 0s. .NET has a **static
    Convert class** that converts between different numeric data types. Let’s use
    it to see an example of how bits and bytes work.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您一直听说编程是关于1和0。.NET有一个**静态Convert类**，用于在不同的数值数据类型之间进行转换。让我们使用它来看看位和字节如何工作的示例。
- en: 'A bit is a single 1 or 0\. A byte is 8 bits, so a byte variable holds an 8-bit
    number, which means it’s a number that can be represented with up to 8 bits. What
    does that look like? Let’s use the Convert class to convert some binary numbers
    to bytes:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 位是单个的1或0。字节是8位，所以字节变量存储一个8位数，这意味着它是一个可以用最多8位表示的数字。这是什么样子？让我们使用Convert类将一些二进制数转换为字节：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-81
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The first argument to Convert.ToByte is the number to convert, and the second
    is its base. Binary numbers are base 2.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Convert.ToByte的第一个参数是要转换的数字，第二个是其进制。二进制数是基数2。
- en: Bytes can hold numbers between 0 and 255 because they use 8 bits of memory—an
    8-bit number is a binary number between 0 and 11111111 binary (or 0 and 255 decimal).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 字节可以存储0到255之间的数字，因为它们使用8位内存——8位数字是二进制数0到11111111（或十进制0到255）。
- en: 'A short is a 16-bit value. Let’s use Convert.ToInt16 to convert the binary
    value 111111111111111 (15 1s) to a short. An int is a 32-bit value, so we’ll use
    Convert.ToInt32 to convert the 31 1s to an int:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: short是一个16位值。让我们使用Convert.ToInt16将二进制值111111111111111（15个1）转换为short。int是一个32位值，所以我们将使用Convert.ToInt32将31个1转换为int：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Other types come in different sizes, too
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他类型也有不同的大小
- en: Numbers that have decimal places are stored differently than integers, and the
    different floating-point types take up different amounts of memory. You can handle
    most of your numbers that have decimal places using **float**, the smallest data
    type that stores decimals. If you need to be more precise, use a **double**. If
    you’re writing a financial application where you’ll be storing currency values,
    you’ll always want to use the **decimal** type.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 具有小数位的数字与整数存储方式不同，不同的浮点类型占用不同数量的内存。您可以使用**float**处理大多数具有小数位的数字，它是存储小数的最小数据类型。如果需要更精确，请使用**double**。如果您编写的是一个存储货币值的财务应用程序，您应该始终使用**decimal**类型。
- en: 'Oh, and one more thing: ***don’t use double for money or currency, only use
    decimal***.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，还有一件事：***不要用double来处理货币或货币，只用decimal***。
- en: '![Images](assets/166fig01.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/166fig01.png)'
- en: We’ve talked about strings, so you know that the C# compiler also can handle
    **characters and non-numeric types**. The char type holds one character, and string
    is used for lots of characters “strung” together. There’s no set size for a string
    object—it expands to hold as much data as you need to store in it. The bool data
    type is used to store true or false values, like the ones you’ve used for your
    `**if**` statements.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经谈到字符串，所以你知道 C# 编译器还可以处理**字符和非数字类型**。char 类型用于存储一个字符，而 string 用于“串”在一起的多个字符。字符串对象没有固定大小——它会扩展以容纳所需存储的数据量。布尔数据类型用于存储
    true 或 false 值，就像你为你的 `**if**` 语句使用的那样。
- en: '![Images](assets/166fig02.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/166fig02.png)'
- en: 'The different floating-point types take up different amounts of memory: float
    is smallest, and decimal is largest.'
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不同的浮点类型占用不同的内存：float 最小，decimal 最大。
- en: 10 pounds of data in a 5-pound bag
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 磅的袋子装下了 10 磅的数据
- en: '![Images](assets/167fig01.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/167fig01.png)'
- en: 'When you declare your variable as one type, the C# compiler **allocates** (or
    reserves) all of the memory it would need to store the maximum value of that type.
    Even if the value is nowhere near the upper boundary of the type you’ve declared,
    the compiler will see the cup it’s in, not the number inside. So this won’t work:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将变量声明为一种类型时，C# 编译器**分配**（或保留）所有存储最大值所需的内存。即使值远远不接近你声明的类型的上界，编译器也会看到它的杯子，而不是内部的数字。因此，这不会起作用：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 20,000 would fit into a `short`, no problem. But because `**leaguesUnderTheSea**`
    is declared as an int, C# sees it as int-sized and considers it too big to put
    in a short container. The compiler won’t make those translations for you on the
    fly. You need to make sure that you’re using the right type for the data you’re
    working with.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 20,000 可以毫无问题地放入一个 `short` 类型中。但是因为 `**leaguesUnderTheSea**` 被声明为一个 int，C# 会看到它是一个
    int 大小，并认为它太大，无法放入一个 short 容器。编译器不会在你飞行时进行这些转换。你需要确保你使用正确的类型来处理数据。
- en: '![Images](assets/167fig02.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/167fig02.png)'
- en: Casting lets you copy values that C# can’t automatically convert to another
    type
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制转换允许你复制那些 C# 不能自动转换为另一种类型的值
- en: Let’s see what happens when you try to assign a decimal value to an int variable.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当你尝试将一个小数值分配给一个整型变量时会发生什么。
- en: '***Do this!***'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '***这样做！***'
- en: 'Create a new Console App project and add this code to the Main method:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序项目，并将此代码添加到 Main 方法中：
- en: '[PRE6]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Implicit conversion means C# has a way to automatically convert a value to
    another type without losing information.**'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**隐式转换意味着 C# 有一种方式可以自动将一个值转换为另一种类型而不丢失信息。**'
- en: 'Try building your program. You should get the same CS0266 error you saw earlier:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 试着编译你的程序。你应该会遇到与之前看到的相同的 CS0266 错误：
- en: '![Images](assets/168fig02.png)'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图像](assets/168fig02.png)'
- en: 'Look closely at the last few words of the error message: “are you missing a
    cast?” That’s the C# compiler giving you a really useful hint about how to fix
    the problem.'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 仔细观察错误消息的最后几句话：“你缺少一个强制转换？”这是 C# 编译器为你提供的非常有用的提示，告诉你如何解决这个问题。
- en: 'Make the error go away by **casting** the decimal to an int. You do this by
    adding the type that you want to convert to in parentheses: `**(int)**`. Once
    you change the second line so it looks like this, your program will compile and
    run:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过**强制转换**将小数转换为整型来消除错误。你这样做的方法是添加你想要转换的类型的括号：`**(int)**`。一旦你将第二行更改为看起来像这样，你的程序就会编译并运行：
- en: '![Images](assets/168fig03.png)'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图像](assets/168fig03.png)'
- en: Note
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**When you cast a floating-point value to an int, it rounds the value down
    to the nearest integer.**'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**当你将一个浮点值强制转换为整型时，它会将值向下取整到最接近的整数。**'
- en: So what happened?
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发   那么，发生了什么？
- en: The C# compiler won’t let you assign a value to a variable if it’s the wrong
    type—even if that variable can hold the value just fine! It turns out that a LOT
    of bugs are caused by type problems, and **the compiler is helping** by nudging
    you in the right direction. When you use casting, you’re essentially saying to
    the compiler that you know the types are different, and promising that in this
    particular instance it’s OK for C# to cram the data into the new variable.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: C# 编译器不会允许你将一个值分配给一个变量，如果它的类型错误——即使这个变量可以很好地容纳这个值！事实证明，大量的错误都是由于类型问题引起的，而**编译器正在帮助**通过引导你朝正确方向迈进。当你使用强制转换时，你基本上是在告诉编译器，你知道类型不同，并承诺在这个特定实例中，将数据塞入新的变量是可以的。
- en: When you cast a value that’s too big,C# adjusts it to fit its new container
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当你强制转换一个值太大的时候，C# 会调整它以适应它的新容器
- en: You’ve already seen that a decimal can be cast to an int. It turns out that
    *any* number can be cast to *any other* number. That doesn’t mean the ***value***
    stays intact through the casting, though. Say you have an int variable set to
    365\. If you cast it to a byte variable (max value 255), instead of giving you
    an error, the value will just **wrap around**. 256 cast to a byte will have a
    value of 0, 25 will be converted to 1, 258 to 2, etc., up to 365, which will end
    up being **109**. Once you get back to 255 again, the conversion value “wraps”
    back to zero.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了十进制可以转换为整数。其实*任何*数字都可以转换为*任何其他*数字。但这并不意味着***数值***在转换过程中保持不变。假设你有一个整数变量设置为365。如果你将它转换为字节变量（最大值为255），不会报错，而是将数值**环绕**。256转换为字节将具有值为0，25将转换为1，258为2，以此类推，直到365，最终变为**109**。一旦再次达到255，转换值将“环绕”回零。
- en: 'If you use + (or `*****`, `**/**`, or `**-**`) with two different numeric types,
    the operator **automatically converts** the smaller type to the bigger one. Here’s
    an example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用+（或`*****`，`**/**`或`**-**`）来连接两种不同的数值类型，运算符会**自动将**较小的类型转换为较大的类型。这里有一个例子：
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Since an int can fit into a float but a float can’t fit into an int, the + operator
    converts `**myInt**` to a float before adding it to `**myFloat**`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于整数可以容纳在浮点数中，但浮点数不能容纳在整数中，因此+运算符在将`**myInt**`添加到`**myFloat**`之前将`**myInt**`转换为浮点数。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**You can read a lot more about the different C# value types here—it’s worth
    taking a look:** [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types).'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**您可以在此处阅读有关不同C#值类型的更多信息——这值得一看：** [https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/value-types](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/value-types)。'
- en: '![Images](assets/170fig01.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/170fig01.png)'
- en: '**Yes! When you concatenate strings, C# converts values.**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**是的！当您连接字符串时，C#会转换值。**'
- en: When you use the + operator to combine a string with another value, it’s called
    **concatenation**. When you concatenate a string with an int, bool, float, or
    another value type, it automatically converts the value. This kind of conversion
    is different from casting, because under the hood it’s really calling the ToString
    method for the value…and one thing that .NET guarantees is that **every object
    has a ToString method** that converts it to a string (but it’s up to the individual
    class to determine if that string makes sense).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用+运算符将字符串与另一个值组合时，称为**连接**。当您将字符串与int、bool、float或其他值类型连接时，它会自动转换该值。这种转换与强制转换不同，因为在底层它实际上调用了值的ToString方法……并且.NET保证的一件事情是**每个对象都有一个ToString方法**，用于将其转换为字符串（但这取决于各个类是否能够产生有意义的字符串）。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Wrap it yourself!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请自行**测试**！
- en: There’s no mystery to how casting “wraps” the numbers—you can do it yourself.
    Just open up any calculator app that has a Mod button (which does a modulus calculation—sometimes
    in a Scientific mode), and calculate 365 Mod 256.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如何“环绕”转换数字并没有什么神秘的——您可以自己做。只需打开任何带有Mod按钮的计算器应用程序（执行模数计算——有时在科学模式下），并计算365 Mod
    256。
- en: C# does some conversions automatically
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#会自动进行一些转换
- en: 'There are two important conversions that don’t require you to do casting. The
    first is the automatic conversion that happens any time you use arithmetic operators,
    like in this example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个重要的转换不需要您进行强制转换。第一个是在使用算术运算符时自动进行的转换，就像这个例子中所示：
- en: '![Images](assets/171fig01.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/171fig01.png)'
- en: 'The other way C# converts types for you automatically is when you use the +
    operator to **concatenate** strings (which just means sticking one string on the
    end of another, like you’ve been doing with message boxes). When you use + to
    concatenate a string with something that’s another type, it automatically converts
    the numbers to strings for you. Here’s an example—try adding these lines to any
    C# program. The first two lines are fine, but the third one won’t compile:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: C#另一种自动为您转换类型的方式是当您使用+运算符**连接**字符串（这意味着将一个字符串粘贴到另一个字符串的末尾，就像您一直在使用的消息框一样）。当您使用+将字符串与另一种类型连接时，它会自动为您转换数字为字符串。这里有一个例子——尝试将这些行添加到任何C#程序中。前两行没问题，但第三行无法编译：
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The C# compiler gives you this error on the third line:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三行上，C#编译器会给您报错：
- en: '![Images](assets/171fig03.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/171fig03.png)'
- en: ScoreText.text is a string field, so when you used the + operator to concatenate
    a string it assigned the value just fine. But when you try to assign `**x**` to
    it directly, it doesn’t have a way to automatically convert the long value to
    a string. You can convert it to a string by calling its ToString method.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ScoreText.text 是一个字符串字段，因此当你使用 + 运算符连接一个字符串时，它会正常分配值。但是当你尝试直接将`**x**`赋给它时，它无法自动将长整型值转换为字符串。你可以通过调用它的
    ToString 方法将其转换为字符串。
- en: When you call a method, the arguments need to be compatible with the types of
    the parameters
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用方法时，参数需要与参数类型兼容
- en: 'In the last chapter, you used the Random class to choose a random number from
    1 up to (but not including) 5, which you used to pick a suit for a playing card:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你使用 Random 类来从 1 到（但不包括）5 中选择一个随机数，用来选择一张扑克牌的花色：
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Try changing the first argument from `**1**` to `**1.0**`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将第一个参数从`**1**`更改为`**1.0**`：
- en: '![Images](assets/172fig01a.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/172fig01a.png)'
- en: 'You’re passing a double literal to a method that’s expecting an int value.
    So it shouldn’t surprise you that the compiler won’t build your program—instead,
    it shows an error:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在向一个期望接收整数值的方法传递一个双精度浮点数文字。所以你不应该对编译器无法构建你的程序感到惊讶——相反，它会显示一个错误：
- en: '![Images](assets/172fig01.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/172fig01.png)'
- en: 'Sometimes C# can do the conversion automatically. It doesn’t know how to convert
    a double to an int (like converting 1.0 to 1), but it does know how to convert
    an int to a double (like converting 1 to 1.0). More specifically:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候 C# 可以自动进行转换。它不知道如何将双精度浮点数转换为整数（例如将 1.0 转换为 1），但它确实知道如何将整数转换为双精度浮点数（例如将 1
    转换为 1.0）。更具体地说：
- en: The C# compiler knows how convert an integer to a floating-point type.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 编译器知道如何将整数转换为浮点类型。
- en: And it knows how to convert an integer type to another integer type, or a floating-point
    type to another floating-point type.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它知道如何将一个整数类型转换为另一个整数类型，或将一个浮点类型转换为另一个浮点类型。
- en: But it can only do those conversions if the type it’s converting from is the
    same size as or smaller than the type it’s converting to. So, it can convert an
    int to a long or a float to a double, but it can’t convert a long to an int or
    a double to a float.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是它只能在要转换的类型大小与或小于要转换为的类型时进行这些转换。因此，它可以将整数转换为长整数或浮点数转换为双精度浮点数，但它无法将长整数转换为整数或双精度浮点数转换为浮点数。
- en: 'But Random.Next isn’t the only method that will give you compiler errors if
    you try to pass it a variable whose type doesn’t match the parameter. *All* methods
    will do that, ***even the ones you write yourself***. Add this method to a console
    app:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但 Random.Next 并不是唯一一个如果你试图向其传递类型与参数不匹配的变量将会得到编译器错误的方法。*所有*方法都会这样做，***甚至是你自己写的方法***。将此方法添加到控制台应用程序：
- en: '[PRE10]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**When the compiler gives you an “invalid argument” error, it means that you
    tried to call a method with variables whose types didn’t match the method’s parameters.**'
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**当编译器给出“无效参数”错误时，意味着你试图调用一个方法，并且变量类型与方法参数不匹配。**'
- en: 'Try passing it a string or long—you’ll get one of those CS1503 errors telling
    you it can’t convert the argument to a bool. Some folks have trouble remembering
    **the difference between parameter and an argument**. So just to be clear:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试传递一个字符串或长整数给它——你将会得到一个 CS1503 错误，告诉你它无法将参数转换为布尔值。有些人很难记住**参数和参数的区别**。因此，为了明确起见：
- en: '**A parameter is what you define in your method. An argument is what you pass
    to it. You can pass a byte argument to a method with an int parameter.**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数是你在方法中定义的内容。参数是你传递给它的内容。你可以将一个字节参数传递给具有整数参数的方法。**'
- en: Owen is constantly improving his game…
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 欧文不断改进他的游戏…
- en: Good game masters are dedicated to creating the best experience they can for
    their players. Owen’s players are about to embark on a new campaign with a brand-new
    set of characters, and he thinks a few tweaks to the formula that they use for
    their ability scores could make things more interesting.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的游戏主持人致力于为玩家创造最佳体验。欧文的玩家们即将开始一场全新的战役，使用全新的角色，他认为对他们的能力值分配公式进行一些调整可能会让事情更有趣。
- en: '![Images](assets/174fig01.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/174fig01.png)'
- en: …but the trial and error can be time-consuming
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: …但是试错方法可能会耗费时间。
- en: Owen’s been experimenting with ways to tweak the ability score calculation.
    He’s pretty sure that he has the formula mostly right—but he’d really like to
    tweak the numbers.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 欧文一直在尝试调整能力值计算的方法。他相当确定自己的公式大部分是正确的——但他真的很想调整这些数字。
- en: '![Images](assets/175fig01.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/175fig01.png)'
- en: 'Owen likes the overall formula: 4d6 roll, divide, subtract, round down, use
    a minimum value…but he’s not sure that the actual numbers are right.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Owen 喜欢总体公式：4d6 掷骰、除法、减法、向下取整、使用最小值……但他不确定实际数字是否正确。
- en: '![Images](assets/175fig02.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/175fig02.png)'
- en: Let’s help Owen experiment with ability scores
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们帮助 Owen 实验能力分数
- en: 'In this next project, you’ll build a .NET Core console app that Owen can use
    to test his ability score formula with different values to see how they affect
    the resulting score. The formula has **four inputs**: the *starting 4d6 roll*,
    the *divide by* value that the roll result is divided by, the *add amount* value
    to add to the result of that division, and the *minimum* to use if the result
    is too small.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个项目中，你将构建一个 .NET Core 控制台应用程序，Owen 可以使用它测试不同值的能力分数公式，以查看它们如何影响结果分数。这个公式有**四个输入**：*起始的
    4d6 掷骰结果*，被这个结果除的*除数*值，要加到这个除法结果的*添加量*值，以及如果结果太小要使用的*最小值*。
- en: Owen will enter each of the four inputs into the app, and it will calculate
    the ability score using those inputs. He’ll probably want to test a bunch of different
    values, so we’ll make the app easier by to use by asking for new values over and
    over again until he quits the app, keeping track of the values he used in each
    iteration and using those previous inputs as **default values** for the next iteration.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Owen 将每个四个输入都输入到应用程序中，并且应用程序将使用这些输入计算能力分数。他可能希望测试一系列不同的值，因此我们将通过重复要求新值来使用应用程序，直到他退出应用程序为止，同时跟踪每次迭代中使用的值，并使用这些先前的输入作为下一次迭代的**默认值**。
- en: 'This is what it looks like when Owen runs the app:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Owen 运行应用程序时，它看起来是这样的：
- en: '![Images](assets/176fig01.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/176fig01.png)'
- en: '**This project is a little larger than the previous console apps that you’ve
    built, so we’ll tackle it in a few steps. First you’ll Sharpen your pencil to
    understand the code to calculate the ability score, then you’ll do an Exercise
    to write the rest of the code for the app, and finally you’ll Sleuth out a bug
    in the code. *Let’s get started!***'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**这个项目比你之前构建的控制台应用程序要大一点，因此我们将分几步来解决它。首先，你将磨一磨你的铅笔，理解计算能力分数的代码，然后进行一个练习，为应用程序编写其余的代码，最后你将揭开代码中的一个错误。*让我们开始吧！***'
- en: Use the C# compiler to find the problematic line of code
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 C# 编译器找到有问题的代码行
- en: 'Create a new .NET Core Console App project called AbilityScoreTester. Then
    **add the AbilityScoreCalculator class** with the code from the “Sharpen your
    pencil” exercise. If you entered the code correctly, you should see a C# compiler
    error:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 AbilityScoreTester 的新 .NET Core 控制台应用程序项目。然后**添加 AbilityScoreCalculator
    类**并使用“磨笔刀”练习中的代码。如果你正确输入了代码，你应该会看到一个 C# 编译器错误：
- en: '![Images](assets/178fig01.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/178fig01.png)'
- en: 'Any time the C# compiler gives you an error, read it carefully. It usually
    has a hint that can help you track down the problem. In this case, it’s telling
    us exactly what went wrong: it can’t convert a double to an int without a cast.
    The `**divided**` variable is declared as a double, but C# won’t allow you to
    add it to an int field like AddAmount because it doesn’t know how to convert it.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 每当 C# 编译器给出错误时，请仔细阅读。它通常会有一个提示，可以帮助你找到问题的根源。在这种情况下，它确切地告诉我们出了什么问题：它无法在没有强制转换的情况下将
    double 转换为 int。`**divided**`变量被声明为 double，但是 C# 不允许你将其添加到像 AddAmount 这样的 int 字段中，因为它不知道如何进行转换。
- en: When the C# compiler asks “are you missing a cast?” it’s giving you a huge hint
    that you need to explicitly cast the double variable `**divided**` before you
    can add it to the int field AddAmount.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当 C# 编译器询问“你是否缺少一个强制类型转换？”时，它实际上是在提示你，在将双精度变量`**divided**`加到整型字段 AddAmount 之前，你需要显式地进行强制类型转换。
- en: Add a cast to get the AbilityScoreCalculator class to compile...
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加一个强制类型转换以使 AbilityScoreCalculator 类编译通过...
- en: 'Now that you know what the problem is, you can **add a cast** to fix the problematic
    line of code in AbilityScoreCalculator. Here’s the line that generated the “Cannot
    implicitly convert type” error:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道问题出在哪里了，你可以**添加一个强制类型转换**来修复 AbilityScoreCalculator 中有问题的代码行。这是生成“无法隐式转换类型”错误的代码行：
- en: '[PRE11]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It caused that error because `**AddAmount += divided**` ***returns a double
    value***, which can’t be assigned to the int variable `**added**`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 它导致该错误，因为`**AddAmount += divided**`***返回一个 double 值***，无法赋给 int 变量`**added**`。
- en: 'You can fix it by **casting** `**divided**` **to an int**, so adding it to
    AddAmount returns another int. Modify that line of code to change `**divided**`
    to `**(int)**``**divided**`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将`**divided**`**强制转换为一个 int**来修复它，这样将它添加到 AddAmount 就会返回另一个 int。修改代码行以将`**divided**`更改为`**(int)**``**divided**`：
- en: '![Images](assets/178fig02.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/178fig02.png)'
- en: 'Adding that cast also addresses the missing part of Owen’s ability score formula:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 添加该转换还解决了欧文能力评分公式的缺失部分：
- en: '** ROUND DOWN TO THE NEAREST WHOLE NUMBER*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**向最近的整数舍入*'
- en: When you cast a double to an int C# rounds it down—so for example `**(int)19.7431D**`
    gives us `**19**`. By adding that cast, you’re adding the step from the ability
    score formula that was missing from the class.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将双精度数强制转换为整数时，C# 会将其向下舍入——例如 `**(int)19.7431D**` 给了我们 `**19**`。通过添加该转换，你正在添加能力评分公式中缺失的步骤。
- en: …but there’s still a bug!
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: …但是仍然存在一个 bug！
- en: We’re not quite done yet! You fixed the compiler error, so now the project builds.
    But even though the C# compiler will accept it, ***there’s still a problem***.
    Can you spot the bug in that line of code?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成！你解决了编译器错误，所以现在项目可以构建了。但是尽管 C# 编译器会接受它，***仍然存在一个问题***。你能发现那行代码中的 bug
    吗？
- en: Note
  id: totrans-182
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Looks like we can’t fill in the “Sharpen your pencil” answer just yet!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们还不能填写“磨你的铅笔”答案！
- en: '![Images](assets/180fig02.png)![Images](assets/181fig01.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/180fig02.png)![图片](assets/181fig01.png)'
- en: '**You’re right, Owen. There’s a bug in the code.**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**欧文，你是对的。代码中有一个 bug。**'
- en: Owen wants to try out different values to use in his ability score formula,
    so we used a loop to make the app ask for those values over and over again.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 欧文想尝试不同的值来使用他的能力评分公式，所以我们使用循环使应用程序一遍又一遍地请求这些值。
- en: To make it easier for Owen to just change one value at a time, we included a
    feature in the app that remembers the last values he entered and presents them
    as default options. We implemented that feature by keeping an instance of the
    AbilityScoreCalculator class in memory, and updating its fields in each iteration
    of the `**while**` loop.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让欧文更容易一次只更改一个值，我们在应用程序中包含了一个功能，记住他输入的最后值，并将它们作为默认选项呈现出来。我们通过在内存中保持 AbilityScoreCalculator
    类的实例，并在每次`**while**`循环的迭代中更新其字段来实现该功能。
- en: But something’s gone wrong with the app. It remembers most of the values just
    fine, but it remembers the wrong number for the “add amount” default value. In
    the first iteration Owen entered 5, but it gave him 10 as a default option. Then
    he entered 7, but it gave a default of 12\. What’s going on?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 但是应用程序出了些问题。它记住了大部分的值，但对于“添加数量”的默认值记住了错误的数字。在第一次迭代中，欧文输入了 5，但它给了他 10 作为默认选项。然后他输入了
    7，但它给了 12 作为默认值。出了什么问题？
- en: And now we can finally fix Owen’s bug
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现在我们终于可以修复欧文的 bug
- en: 'Now that you know what’s happening, you can **fix the bug**—and it turns out
    to be a pretty small change. You just need to change the statement to use + instead
    of +=:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道发生了什么，你可以**修复 bug**——结果证明只需要做一个非常小的改变。你只需将语句更改为使用 + 而不是 +=：
- en: '[PRE12]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-192
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Change the += to a + to keep this line of code from updating the “added” variable
    and fix the bug. Like Sherlock would say, “It’s elementary.”
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 将 += 更改为 + 以防止这行代码更新“添加”的变量并修复 bug。就像福尔摩斯会说的，“这是基本的。”
- en: Note
  id: totrans-194
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Now that we’ve found the problem, we can finally give the “Sharpen your pencil”
    solution.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们找到了问题，我们终于可以提供“磨你的铅笔”解决方案了。
- en: '![Images](assets/184fig01.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/184fig01.png)'
- en: Note
  id: totrans-197
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Try this!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 试试这个！
- en: 'Try adding this `**if/else**` statement to a console app:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将这个 `**if/else**` 语句添加到控制台应用程序中：
- en: '![Images](assets/184fig02.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/184fig02.png)'
- en: 'Next, **change the float literals to doubles** (remember, literals like 0.1
    default to double):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，**将浮点文字更改为双精度数**（记住，诸如 0.1 的文字默认为双精度数）：
- en: '![Images](assets/184fig03.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/184fig03.png)'
- en: That’s really strange. The warning moved to the first line of the `**if**` statement.
    Try running the program. Hold on, that can’t be right! It printed `**They aren't
    equal**` to the console. How is 0.1 + 0.2 not equal to 0.3?
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这真的很奇怪。警告移到了`**if**`语句的第一行。尝试运行程序。等等，那不可能对！它向控制台打印了 `**They aren't equal**`。0.1
    + 0.2 怎么会不等于 0.3？
- en: Now do one more thing. Change 0.3 to 0.30000000000000004 (with 15 zeros between
    the 3 and 4). Now it prints `**They’re equal**` again. So apparently 0.1D plus
    0.2D equals 0.30000000000000004D.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再做一件事。将 0.3 更改为 0.30000000000000004（在 3 和 4 之间有 15 个零）。现在它再次打印 `**They’re
    equal**`。所以显然 0.1D 加上 0.2D 等于 0.30000000000000004D。
- en: Note
  id: totrans-205
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Wait, what?!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，什么？！
- en: '![Images](assets/184fig04.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/184fig04.png)'
- en: Note
  id: totrans-208
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Exactly. Decimal has a lot more precision than double or float, so it avoids
    the 0.30000000000000004 problem.**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**没错。十进制比双精度数或浮点数具有更高的精度，因此它避免了 0.30000000000000004 问题。**'
- en: Some floating-point types—not just in C#, but in most programming languages!—can
    give you ***rare*** weird errors. This is so strange! How can 0.1 + 0.2 be 0.30000000000000004?
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一些浮点数类型——不仅在C#中，在大多数编程语言中！——可能会给你带来***罕见***的奇怪错误。这太奇怪了！0.1 + 0.2 怎么会是0.30000000000000004呢？
- en: It turns out that there are some numbers that just can’t be exactly represented
    as a double—it has to do with how they’re stored as binary data (0s and 1s in
    memory). For example, .1D is not *exactly* .1\. Try multiplying `**.1D * .1D**`—you
    get 0.010000000000000002, not 0.01\. But `**.1M * .1M**` gives you the right answer.
    That’s why floats and doubles are really useful for a lot of things (like positioning
    a GameObject in Unity). If you need more rigid precision—like for a financial
    app that deals with money—decimal is the way to go.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，有一些数字无法被双精度浮点数准确表示——这与它们以二进制数据（在内存中的0和1）存储方式有关。例如，`.1D`并不是*确切*的`.1`。尝试将`**.1D
    * .1D**`相乘——你得到的是0.010000000000000002，而不是0.01。但是`**.1M * .1M**`会得到正确的答案。这就是为什么浮点数和双精度浮点数在许多场景中非常有用（比如在Unity中定位游戏对象）。如果你需要更严格的精度——比如财务应用程序处理金钱——那么应该使用十进制类型。
- en: Use reference variables to access your objects
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用引用变量来访问你的对象
- en: 'When you create a new object, you use a `**new**` statement to instantiate
    it, like `**new Guy()**` in your program at the end of the last chapter—the `**new**`
    statement created a new Guy object on the heap. You still needed a way to *access*
    that object, and that’s where a variable like `**joe**` came in: `**Guy joe =
    new Guy()**`. Let’s dig a little deeper into exactly what’s going on there.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个新对象时，你使用`**new**`语句来实例化它，比如在上一章的程序末尾中使用的`**new Guy()**`——`**new**`语句在堆上创建了一个新的Guy对象。但是你仍然需要一种方式来*访问*该对象，这就是`**joe**`这样的变量发挥作用的地方：`**Guy
    joe = new Guy()**`。让我们深入了解一下这其中的具体情况。
- en: 'The `**new**` statement creates the instance, but just creating that instance
    isn’t enough. ***You need a reference to the object***. So you created a **reference
    variable**: a variable of type Guy with a name, like `**joe**`. So `**joe**` is
    a reference to the new Guy object you created. Any time you want to use that particular
    Guy, you can reference it with the reference variable called `**joe**`.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`**new**`语句创建实例，但仅仅创建实例是不够的。***你需要一个对象的引用***。因此，你创建了一个**引用变量**：一个Guy类型的变量，例如`**joe**`。因此，`**joe**`是你创建的新Guy对象的一个引用。每当你想使用特定的Guy时，你可以通过名为`**joe**`的引用变量来引用它。'
- en: 'When you have a variable that’s an object type, it’s a reference variable:
    a reference to a particular object. Let’s just make sure we get the terminology
    right since we’ll be using it a lot. We’ll use the first two lines of the “Joe
    and Bob” program from the last chapter:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个对象类型的变量时，它是一个引用变量：指向特定对象的引用。我们来确保术语使用正确，因为我们会经常用到。我们将使用上一章节“Joe和Bob”程序的前两行：
- en: '![Images](assets/186fig01.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/186fig01.png)'
- en: References are like sticky notes for your objects
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用就像对象的便利贴
- en: In your kitchen, you probably have containers of salt and sugar. If you switched
    their labels, it would make for a pretty disgusting meal—even though you changed
    the labels, the contents of the containers stayed the same. ***References are
    like labels.*** You can move labels around and point them at different things,
    but it’s the **object** that dictates what methods and data are available, not
    the reference itself—and you can **copy references** just like you copy values.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的厨房里，你可能有盐和糖的容器。如果你交换它们的标签，可能会让人觉得很恶心——尽管你改变了标签，但容器里的内容还是一样的。***引用就像标签。***
    你可以移动标签并将其指向不同的东西，但真正决定方法和数据可用性的是**对象**本身，而不是引用本身——你可以像复制值一样**复制引用**。
- en: '![Images](assets/187fig01.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/187fig01.png)'
- en: '**A reference is like a label that your code uses to talk about a specific
    object. You use it to access fields and call methods on an object that it points
    to.**'
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**引用就像是你的代码用来谈论特定对象的标签。你可以用它来访问字段和调用对象的方法。**'
- en: We stuck a lot of sticky notes on that object! In this particular case, there
    are a lot of different references to this same Guy object—because a lot of different
    methods use it for different things. Each reference has a different name that
    makes sense in its context.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在那个对象上贴了很多便利贴！在这种情况下，有很多不同的引用指向同一个Guy对象——因为很多不同的方法用它来做不同的事情。每个引用在其上下文中都有一个不同的名称，这是有意义的。
- en: That’s why it can be really useful to have ***multiple references pointing to
    the same instance***. So you could say `**Guy dad = joe**`, and then call `**dad.GiveCash()**`
    (that’s what Joe’s kid does every day). If you want to write code that works with
    an object, you need a reference to that object. If you don’t have that reference,
    you have no way to access the object.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么有***多个引用指向同一个实例***非常有用。所以你可以说`**Guy dad = joe**`，然后调用`**dad.GiveCash()**`（这是Joe的孩子每天都在做的事）。如果你想编写与对象一起工作的代码，你需要一个指向该对象的引用。如果没有这个引用，你就无法访问对象。
- en: If there aren’t any more references,your object gets garbage-collected
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果没有更多的引用，你的对象将被垃圾回收
- en: If all of the labels come off of an object, programs can no longer access that
    object. That means C# can mark the object for **garbage collection**. That’s when
    C# gets rid of any unreferenced objects and reclaims the memory those objects
    took up for your program’s use.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个对象的所有标签都被移除，程序将无法再访问该对象。这意味着C#可以标记该对象进行**垃圾回收**。这时，C#会清除任何未被引用的对象，并回收这些对象占用的内存，以便程序使用。
- en: '**Here’s some code that creates an object.**'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**这里有一些创建对象的代码。**'
- en: 'Just to recap what we’ve been talking about: when you use the `**new**` statement,
    you’re telling C# to create an object. When you take a reference variable like
    `**joe**` and assign it to that object, it’s like you’re slapping a new sticky
    note on it.'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 简要回顾一下我们讨论的内容：当使用`**new**`语句时，你在告诉C#创建一个对象。当你把像`**joe**`这样的引用变量赋给该对象时，就像是在它上面贴了一张新的便签。
- en: '[PRE13]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![Images](assets/188fig01.png)'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/188fig01.png)'
- en: '**Now let’s create our second object.**'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**现在让我们创建我们的第二个对象。**'
- en: 'Once we do this we’ll have two Guy object instances and two reference variables:
    one variable (`**joe**`) for the first Guy object, and another variable (`**bob**`)
    for the second.'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦我们这样做了，我们将有两个Guy对象实例和两个引用变量：一个变量（`**joe**`）指向第一个Guy对象，另一个变量（`**bob**`）指向第二个。
- en: '[PRE14]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![Images](assets/188fig02.png)'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/188fig02.png)'
- en: '**Let’s take the reference to the first Guy object and change it to point to
    the second Guy object.**'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**让我们把对第一个Guy对象的引用改为指向第二个Guy对象。**'
- en: Take a really close look at what you’re doing when you create a new Guy object.
    You’re taking a variable and using the = assignment operator to set it—in this
    case, to a reference that’s returned by the `**new**` statement. That assignment
    works because **you can copy a reference just like you copy a value**.
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 仔细看看当你创建一个新的Guy对象时你在做什么。你正在取一个变量，并使用=赋值运算符来设置它——在这种情况下，设置为`**new**`语句返回的引用。这种赋值之所以有效，是因为**你可以像复制值一样复制引用**。
- en: 'So let’s go ahead and copy that value:'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所以让我们继续复制那个值：
- en: '[PRE15]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That tells C# to take make `**joe**` point to the same object that `**bob**`
    does. Now the `**joe**` and `**bob**` variables **both point to the same object**.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这告诉C#让`**joe**`指向与`**bob**`指向的同一个对象。现在`**joe**`和`**bob**`变量**都指向同一个对象**。
- en: '![Images](assets/189fig01.png)'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/189fig01.png)'
- en: '**There’s no longer a reference to the first Guy object…so it gets garbage-collected.**'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**再也没有指向第一个Guy对象的引用了……所以它被垃圾回收了。**'
- en: Now that joe is pointing to the same object as bob, there’s no longer a reference
    to the Guy object it used to point to. So what happens? C# marks the object for
    garbage collection, and ***eventually*** trashes it. Poof—it’s gone!
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在`joe`指向与`bob`相同的对象，不再有指向原来的`Guy`对象的引用了。那么会发生什么？C#标记该对象进行垃圾回收，并***最终***将其销毁。噗——它消失了！
- en: Note
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The CLR keeps track of all of the references to each object, and when the last
    reference disappears it marks it for removal. But it might have other things to
    do right now, so the object could stick around for a few milliseconds—or even
    longer!
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: CLR跟踪每个对象的所有引用，当最后一个引用消失时，它标记为可删除。但它可能有其他事情要做，所以对象可能会保留几毫秒甚至更长时间！
- en: '![Images](assets/189fig02.png)'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/189fig02.png)'
- en: '**For an object to stay in the heap, it has to be referenced. Some time after
    the last reference to the object disappears, so does the object.**'
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**要使对象保留在堆中，必须引用它。当对对象的最后一个引用消失后一段时间，该对象也会消失。**'
- en: '![Images](assets/190fig01z.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/190fig01z.png)'
- en: Multiple references and their side effects
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个引用及其副作用
- en: 'You’ve got to be careful when you start moving reference variables around.
    Lots of times, it might seem like you’re simply pointing a variable to a different
    object. You could end up removing all references to another object in the process.
    That’s not a bad thing, but it may not be what you intended. Take a look:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始移动引用变量时，你必须小心。很多时候，看起来你只是将一个变量指向一个不同的对象。在这个过程中，你可能会移除对另一个对象的所有引用。这不是件坏事，但可能不是你打算的。看一看：
- en: '[PRE16]'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![Images](assets/190fig01.png)'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/190fig01.png)'
- en: '[PRE17]'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![Images](assets/190fig02.png)'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/190fig02.png)'
- en: '[PRE18]'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![Images](assets/190fig03.png)'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/190fig03.png)'
- en: Two references mean TWO variables that can change the same object’s data
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 两个引用意味着可以改变同一个对象的数据的两个变量
- en: Besides losing all the references to an object, when you have multiple references
    to an object, you can unintentionally change the object. In other words, one reference
    to an object may ***change*** that object, while another reference to that object
    has ***no idea*** that something has changed. Let’s see how that works.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 除了失去对象的所有引用外，当你有多个引用指向一个对象时，你可能会无意中改变该对象。换句话说，一个引用可能会***改变***该对象，而另一个引用则***不知道***发生了什么变化。让我们看看这是如何工作的。
- en: '***Do this!***'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '***做这个！***'
- en: '![Images](assets/197fig01.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/197fig01.png)'
- en: 'Now go ahead and run your program. Here’s what you’ll see:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，继续运行你的程序。这是你将看到的：
- en: '[PRE19]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-260
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The program acts normally... until you press 4\. Once you do that, pressing
    either 1 or 2 prints the same output—and pressing 3 to swap the references doesn’t
    do anything anymore.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 程序正常运行... 直到按下4。一旦这样做，按1或2打印相同的输出 - 按3交换引用不再起作用。
- en: After you press 4 and run the new code that you added, both the `**lloyd**`
    and lucinda variables **contain the same reference** to the second Elephant object.
    Pressing 1 to call lloyd.WhoAmI prints exactly the same message as pressing 2
    to call `**lucinda**`.WhoAmI. Swapping them makes no difference because you’re
    swapping two identical references.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在按下4并运行你添加的新代码之后，`**lloyd**`和lucinda变量都**包含对第二只大象对象的相同引用**。按1调用lloyd.WhoAmI将打印与按2调用`**lucinda**`.WhoAmI完全相同的消息。交换它们不会有任何差别，因为你在交换两个相同的引用。
- en: Objects use references to talk to each other
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象使用引用来彼此交谈
- en: So far, you’ve seen forms talk to objects by using reference variables to call
    their methods and check their fields. Objects can call one another’s methods using
    references, too. In fact, there’s nothing that a form can do that your objects
    can’t do, because **your form is just another object**. When objects talk to each
    other, one useful keyword that they have is `**this**`. Any time an object uses
    the `**this**` keyword, it’s referring to itself—it’s a reference that points
    to the object that calls it. Let’s see what that looks like by modifying the Elephant
    class so instances can call each other’s methods.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到表单通过使用引用变量调用它们的方法和检查它们的字段来与对象交谈。对象也可以使用引用调用彼此的方法。事实上，没有什么是表单可以做而你的对象不能做的，因为**你的表单只是另一个对象**。当对象彼此交谈时，它们拥有的一个有用关键字是`**this**`。任何时候一个对象使用`**this**`关键字，它都在引用自己
    - 它是一个指向调用它的对象的引用。让我们通过修改大象类以便实例可以调用彼此的方法来看看它是什么样子。
- en: '![Images](assets/198fig02.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/198fig02.png)'
- en: '**Add a method that lets an Elephant hear a message.**'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加一个让大象听到消息的方法。**'
- en: 'Let’s add a method to the Elephant class. Its first parameter is a message
    from another Elephant object. Its second parameter is the Elephant object that
    sent the message:'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们向大象类添加一个方法。它的第一个参数是另一个大象对象发送的消息。第二个参数是发送消息的大象对象：
- en: '***Do this!***'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '***做这个！***'
- en: '[PRE20]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here’s what it looks like when it’s called:'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当它被调用时，它看起来是这样的：
- en: '[PRE21]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We called `**lloyd’s**` HearMessage method, and passed it two parameters: the
    string `**"Hi"**` and a reference to Lucinda’s object. The method uses its `**whoSaidIt**`
    parameter to access the Name field of whatever elephant was passed in.'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们调用了`**lloyd's**` HearMessage方法，并传递了两个参数：字符串`**"Hi"**`和Lucinda对象的引用。该方法使用其`**whoSaidIt**`参数来访问传入的任何大象的Name字段。
- en: '**Add a method that lets an Elephant send a message.**'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加一个让大象发送消息的方法。**'
- en: 'Now let’s add a SpeakTo method to the Elephant class. It uses a special keyword:
    `**this**`. That’s a reference that **lets an object get a reference to itself**.'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在让我们向大象类添加一个SpeakTo方法。它使用一个特殊的关键字：`**this**`。这是一个让对象获取对自己的引用的关键字。
- en: '[PRE22]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: An Elephant’s SpeakTo method uses the “this” keyword to send a reference to
    itself to another Elephant.
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 大象的SpeakTo方法使用“this”关键字将自己的引用发送给另一个大象。
- en: Let’s take a closer look at what’s going on.
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看发生了什么。
- en: 'When we call the Lucinda object’s SpeakTo method:'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们调用卢辛达对象的 SpeakTo 方法时：
- en: '[PRE23]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It calls the Lloyd object’s HearMessage method like this:'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它这样调用了 Lloyd 对象的 HearMessage 方法：
- en: '[PRE24]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Lucinda uses whoToTalkTo (which has a reference to Lloyd) to call HearMessage.
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 卢辛达使用 whoToTalkTo（它引用了 Lloyd）来调用 HearMessage。
- en: Note
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: this is replaced with a reference to Lucinda’s object.
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: this 被替换为对卢辛达对象的引用。
- en: Note
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE25]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Call the new methods.**'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**调用新方法。**'
- en: 'Add one more `**else if**` block to the Main method to make the Lucinda object
    send a message to the Lloyd object:'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Main 方法中再添加一个 `**else if**` 块，让卢辛达对象向 Lloyd 对象发送一条消息：
- en: '[PRE26]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now run your program and press 5\. You should see this output:'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在运行你的程序并按 5\. 你应该看到以下输出：
- en: '[PRE27]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Use the debugger to understand what’s going on.**'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用调试器理解正在发生的事情。**'
- en: 'Place a breakpoint on the statement that you just added to the Main method:'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在你刚刚添加到 Main 方法的语句上设置一个断点：
- en: '![Images](assets/199fig01.png)'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图像](assets/199fig01.png)'
- en: Run your program and press 5.
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的程序并按 5。
- en: When it hits the breakpoint, use Debug >> Step Into (F11) to step into the SpeakTo
    method.
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当它触发断点时，使用调试 >> 逐步进入（F11）来进入 SpeakTo 方法。
- en: Add a watch for Name to show you which Elephant object you’re inside. You’re
    currently inside the Lucinda object—which makes sense because the Main method
    called lucinda.SpeakTo.
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个监视器来显示你所处的“大象”对象的名称。你当前位于“卢辛达”对象内部，这是有道理的，因为主方法调用了 lucinda.SpeakTo。
- en: Hover over the `**this**` keyword at the end of the line and expand it. It’s
    a reference to the Lucinda object.
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 悬停在行尾的 `**this**` 关键字上并展开它。这是对卢辛达对象的引用。
- en: '![Images](assets/199fig02.png)'
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图像](assets/199fig02.png)'
- en: Hover over `**whoToTalkTo**` and expand it—it’s a reference to the Lloyd object.
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 悬停在 `**whoToTalkTo**` 上并展开它 —— 它是对 Lloyd 对象的引用。
- en: The SpeakTo method has one statement—it calls whoToTalkTo.HearMessage. Step
    into it.
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: SpeakTo 方法只有一条语句 —— 它调用 whoToTalkTo.HearMessage。进入它。
- en: You should now be inside the HearMessage method. Check your watch again—now
    the value of the Name field is “Lloyd” —the Lucinda object called the Lloyd object’s
    HearMessage method.
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你应该位于 HearMessage 方法内部。再次检查你的监视器 —— 现在 Name 字段的值是“Lloyd” —— 卢辛达对象调用了 Lloyd
    对象的 HearMessage 方法。
- en: Hover over `**whoSaidIt**` and expand it. It’s a reference to the Lucinda object.
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 悬停在 `**whoSaidIt**` 上并展开它。这是对卢辛达对象的引用。
- en: Finish stepping through the code. Take a few minutes to really understand what’s
    going on.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 完成代码的逐步执行。花几分钟真正理解发生了什么。
- en: '**The “this” keyword lets an object get a reference to itself.**'
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**“this” 关键字让对象获得对自身的引用。**'
- en: Arrays hold multiple values
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组保存多个值
- en: Note
  id: totrans-309
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Strings and arrays are different from the other data types you’ve seen in this
    chapter because they’re the only ones without a set size (think about that for
    a bit).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串和数组不同于本章中看到的其他数据类型，因为它们是唯一没有固定大小的数据类型（想一想这个）。
- en: 'If you have to keep track of a lot of data of the same type, like a list of
    prices or a group of dogs, you can do it in an **array**. What makes an array
    special is that it’s a **group of variables** that’s treated as one object. An
    array gives you a way of storing and changing more than one piece of data without
    having to keep track of each variable individually. When you create an array,
    you declare it just like any other variable, with a name and a type—except **the
    type is followed by square brackets**:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须跟踪大量相同类型的数据，比如价格列表或一组狗，你可以用一个 **数组**。数组的特殊之处在于它是作为一个对象对待的**一组变量**。数组为你提供了一种存储和修改多个数据而无需单独跟踪每个变量的方法。当你创建一个数组时，你像声明任何其他变量一样，使用一个名称和一个类型
    —— 但是 **类型后面跟着方括号**：
- en: '[PRE28]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Use the `**new**` keyword to create an array. Let’s create an array with 15
    bool elements:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `**new**` 关键字创建数组。让我们创建一个有 15 个布尔元素的数组：
- en: '[PRE29]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Use square brackets to set one of the values in the array. This statement sets
    the value of the fifth element of `**myArray**` to `**true**` by using square
    brackets and specifying the **index** 4\. It’s the fifth one because the first
    is `**myArray[0]**`, the second is `**myArray[1]**`, etc.:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方括号设置数组中的一个值。该语句通过使用方括号并指定 **索引** 4，将 `**myArray**` 的第五个元素的值设置为 `**true**`。它是第五个，因为第一个是
    `**myArray[0]**`，第二个是 `**myArray[1]**`，依此类推：
- en: '[PRE30]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Use each element in an array like it’s a normal variable
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 像普通变量一样使用数组中的每个元素
- en: Note
  id: totrans-318
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**You use the `new` keyword to create an array because it’s an object—so an
    array variable is a kind of reference variable. In C#, arrays are zero-based,
    which means the first element has index 0.**'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用`new`关键字来创建数组，因为它是一个对象——所以数组变量是一种引用变量。在C#中，数组是从零开始的，这意味着第一个元素的索引是0。**'
- en: When you use an array, first you need to **declare a reference variable** that
    points to the array. Then you need to **create the array object** using the `**new**`
    statement, specifying how big you want the array to be. Then you can **set the
    elements** in the array. Here’s an example of code that declares and fills up
    an array—and what’s happening in the heap when you do it. The first element in
    the array has an **index** of 0.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用数组时，首先需要**声明一个引用变量**指向数组。然后你需要使用`**new**`语句**创建数组对象**，指定你想要的数组大小。然后你可以**设置数组中的元素**。下面是一个声明并填充数组的示例代码——以及在执行时堆上的情况。数组中的第一个元素的**索引**是0。
- en: '[PRE31]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![Images](assets/200fig01.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/200fig01.png)'
- en: Arrays can contain reference variables
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组可以包含引用变量
- en: You can create an **array of object references** just like you create an array
    of numbers or strings. Arrays don’t care what type of variable they store; it’s
    up to you. So you can have an array of ints, or an array of Duck objects, with
    no problem.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你创建数字或字符串数组一样，你也可以创建一个**对象引用的数组**。数组并不关心它们存储的变量类型；这由你决定。所以你可以有一个int数组，或者一个Duck对象数组，都没有问题。
- en: Here’s code that creates an array of seven Dog variables. The line that initializes
    the array only creates reference variables. Since there are only two `**new Dog()**`
    lines, only two actual instances of the Dog class are created.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是创建七个Dog变量数组的代码。初始化数组的行仅创建引用变量。由于只有两行`**new Dog()**`，实际只创建了两个Dog类的实例。
- en: '**When you set or retrieve an element from an array, the number inside the
    brackets is called the index. The first element in the array has an index of 0.**'
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**当你设置或检索数组中的元素时，方括号中的数字称为索引。数组中的第一个元素的索引是0。**'
- en: '![Images](assets/201fig01.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/201fig01.png)'
- en: Note
  id: totrans-328
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: An array’s length
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的长度
- en: You can find out how many elements are in an array using its Length property.
    So if you’ve got an array called “prices”, then you can use prices.Length to find
    out how long it is. If there are seven elements in the array, that’ll give you
    7—which means the array elements are numbered 0 to 6.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用数组的Length属性来查找数组中的元素数量。所以如果你有一个名为“prices”的数组，那么你可以使用prices.Length来查找它的长度。如果数组中有七个元素，那么它将给出7——这意味着数组元素从0到6编号。
- en: null means a reference points to nothing
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: null意味着引用指向空值
- en: 'There’s another important keyword that you’ll use with objects. When you create
    a new reference and don’t set it to anything, it has a value. It starts off set
    to `**null**`, which means **it’s not pointing to any object at all**. Let’s have
    a closer look at this:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个重要的关键字，你会在处理对象时使用它。当你创建一个新的引用并且没有设置它时，它有一个值。它最初被设置为`**null**`，这意味着**它没有指向任何对象**。让我们仔细看看这个：
- en: '![Images](assets/203fig01.png)![Images](assets/203fig02.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/203fig01.png)![图片](assets/203fig02.png)'
- en: Note
  id: totrans-334
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Yes. The null keyword can be very useful.**'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '**是的。null关键字非常有用。**'
- en: 'There are a few ways you see `**null**` used in typical programs. The most
    common way is making sure a reference points to an object:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型程序中，你会看到`**null**`被使用的几种方式。最常见的方式是确保一个引用指向一个对象：
- en: '[PRE32]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: That test will return `**true**` if the `**lloyd**` reference is set to `**null**`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`**lloyd**`引用被设置为`**null**`，那个测试将返回`**true**`。
- en: Another way you’ll see the `**null**` keyword used is when you ***want*** your
    object to get garbage-collected. If you’ve got a reference to an object and you’re
    finished with the object, setting the reference to `**null**` will immediately
    mark it for collection (unless there’s another reference to it somewhere).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种你会看到`**null**`关键字的用法是当你***希望***你的对象被垃圾收集时。如果你有一个对象的引用并且你完成了对对象的使用，将引用设置为`**null**`将立即将其标记为可回收（除非它在其他地方有其他引用）。
- en: Note
  id: totrans-340
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you’ve never played Go Fish, take a few minutes and read the rules. We’ll
    use them later in the book!
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未玩过Go Fish，请花几分钟阅读规则。我们稍后会用到它们！
- en: '**Even if we’re not writing code for video games, there’s a lot we can learn
    from tabletop games.**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**即使我们不为视频游戏编写代码，我们仍然可以从桌面游戏中学到很多。**'
- en: A lot of our programs depend on **random numbers**. For example, you’ve already
    used the Random class to create random numbers for several of your apps. Most
    of us don’t actually have a lot of real-world experience with genuine random numbers…except
    when we play games. Rolling dice, shuffling cards, spinning spinners, flipping
    coins…these are all great examples of **random number generators**. The Random
    class is .NET’s random number generator—you’ll use it in many of your programs,
    and your experience using random numbers when playing tabletop games will make
    it a lot easier for you to understand what it does.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 很多我们的程序依赖于**随机数**。例如，你已经使用了Random类为几个应用程序生成随机数。我们大多数人在真实世界中并没有太多真正的随机数经验……除非我们玩游戏。掷骰子、洗牌、旋转转盘、抛硬币……这些都是**随机数生成器**的绝佳示例。Random类是.NET的随机数生成器——你将在许多程序中使用它，而你在玩桌面游戏时积累的随机数使用经验将使你更容易理解它的工作原理。
- en: '![Images](assets/206fig02.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/206fig02.png)'
- en: '**Create a new console app**—all of this code will go in the Main method. Start
    by creating a new instance of Random, generating a random int, and writing it
    to the console:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个新的控制台应用**—所有这些代码都将放在Main方法中。首先创建一个Random的新实例，生成一个随机整数，并将其写入控制台：'
- en: '[PRE33]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Specify a **maximum value** to get random numbers from 0 up to—but not including—the
    maximum value. A maximum of 10 generates random numbers from 0 to 9:'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 指定一个**最大值**来获取从0到最大值（但不包括最大值）的随机数。最大值为10将生成从0到9的随机数：
- en: '[PRE34]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now **simulate the roll of a die**. You can specify a minimum and maximum value.
    A minimum of 1 and maximum of 7 generates random numbers from 1 to 6:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在**模拟掷骰子**。你可以指定一个最小值和一个最大值。最小值为1，最大值为7将生成从1到6的随机数：
- en: '[PRE35]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '![Images](assets/207fig02.png)'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/207fig02.png)'
- en: 'The **NextDouble method** generates random double values. Hover over the method
    name to see a tooltip—it generates a floating-point number from 0.0 up to 1.0:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**NextDouble方法**生成随机的双精度值。将鼠标悬停在方法名上可以看到工具提示——它生成从0.0到1.0的浮点数：'
- en: '[PRE36]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![Images](assets/207fig03.png)'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/207fig03.png)'
- en: 'You can use **multiply a random double** to generate much larger random numbers.
    So if you want a random double value from 1 to 100, multiply the random double
    by 100:'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以使用**乘以一个随机双精度数**来生成更大的随机数。所以，如果你想要一个从1到100的随机双精度值，就将随机双精度数乘以100：
- en: '[PRE37]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Use **casting** to convert the random double to other types. Try running this
    code a bunch of times—you’ll see tiny precision differences in the float and decimal
    values.
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用**强制类型转换**将随机双精度数转换为其他类型。试着运行这段代码多次——你会看到浮点数和十进制值之间的微小精度差异。
- en: '[PRE38]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Use a maximum value of 2 to **simulate a coin toss**. That generates a random
    value of either 0 or 1\. Use the special **Convert class**, which has a static
    ToBoolean method that will convert it to a Boolean value:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用最大值为2来**模拟抛硬币**。这将生成一个随机值，要么是0，要么是1。使用特殊的**Convert类**，它有一个静态的ToBoolean方法，可以将其转换为布尔值：
- en: '[PRE39]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Welcome to Sloppy Joe’s Budget House o’ Discount Sandwiches!
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 欢迎来到Sloppy Joe's Budget House o' Discount Sandwiches！
- en: Sloppy Joe has a pile of meat, a whole lotta bread, and more condiments than
    you can shake a stick at. What he doesn’t have is a menu! Can you build a program
    that makes a new *random* menu for him every day? You definitely can…with a **new
    WPF app**, some arrays, and a couple of useful new techniques.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: Sloppy Joe有一堆肉、大量面包和比你能摇动的棍子更多的调味品。但他没有菜单！你能建立一个每天为他制作新的*随机*菜单的程序吗？当然可以……借助**新的WPF应用**、一些数组和几种有用的新技术。
- en: Note
  id: totrans-363
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Do this!
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 去做这件事！
- en: '**Add a new MenuItem class to your project and add its fields.**'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**向项目添加一个新的MenuItem类，并添加其字段。**'
- en: 'Have a look at the class diagram. It has four fields: an instance of Random
    and three arrays to hold the various sandwich parts. The array fields use **collection
    initializers**, which let you define the items in an array by putting them inside
    curly braces.'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看一下类图。它有四个字段：一个Random的实例和三个数组，用来保存各种三明治的部分。这些数组字段使用了**集合初始化器**，通过将项放在大括号内来定义数组中的项目。
- en: '![Images](assets/208fig01.png)'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/208fig01.png)'
- en: '[PRE40]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**Add the GenerateMenuItem method to the MenuItem class.**'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将GenerateMenuItem方法添加到MenuItem类中。**'
- en: This method uses the same Random.Next method you’ve seen many times to pick
    random items from the arrays in the Proteins, Condiments, and Breads fields and
    concatenate them together into a string.
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法使用了你已经多次见过的Random.Next方法，从Proteins、Condiments和Breads字段的数组中随机选择项目，并将它们连接成一个字符串。
- en: '[PRE41]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-372
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**This method makes a random price between 2.01 and 5.97 by converting two
    random ints to decimals. Have a close look at the last line—it returns** `**price.ToString("c")**`.
    **The parameter to the ToString method is a format. In this case, the** `**"c"**`
    **format tells ToString to format the value with the local currency: if you’re
    in the United States you’ll see a $; in the UK you’ll get a £, in the EU you’ll
    see €, etc.**'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**该方法通过将两个随机整数转换为小数，生成介于2.01和5.97之间的随机价格。仔细看看最后一行——它返回** `**price.ToString("c")**`。ToString
    方法的参数是一个格式。在这种情况下，`**"c"**` **格式告诉 ToString 使用本地货币格式化值：如果你在美国，你会看到$；在英国，你会得到£；在欧盟，你会看到€等。**'
- en: Note
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Go to the Visual Studio for Mac Learner’s Guide for the Mac version of this
    project.**'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**前往 Visual Studio for Mac 学习者指南，了解该项目的 macOS 版本。**'
- en: '**Create the XAML to lay out the window.**'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建 XAML 以布局窗口。**'
- en: Your app will display random menu items in a window with two columns, a wide
    one for the menu item and a narrow one for the price. Each cell in the grid has
    a TextBlock control with its FontSize set to `**18px**`—except for the bottom
    row, which just has a single right-aligned TextBlock that spans both columns.
    The window’s title is “Welcome to Sloppy Joe’s Budget House o’ Discount Sandwiches!”
    and it’s got a height of `**350**` and width of `**550**`. The grid has a margin
    of `**20**`.
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的应用程序将在窗口中显示随机菜单项，其中包含两列：一列宽的用于菜单项，一列窄的用于价格。网格中的每个单元格都有一个 TextBlock 控件，其 FontSize
    设置为`**18px**`，除了底部行，它只有一个右对齐的 TextBlock，跨越了两列。窗口的标题是“欢迎来到 Sloppy Joe's Budget
    House o’ Discount Sandwiches！”它的高度为`**350**`，宽度为`**550**`。网格有一个边距为`**20**`。
- en: We’re building on the XAML you learned in the last two WPF projects. You can
    lay it out in the designer, type it in by hand, or do some of each.
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在前两个 WPF 项目中学到的 XAML 基础上构建。您可以在设计器中布局它，手动输入它，或者两者兼而有之。
- en: '![Images](assets/209fig01.png)'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/209fig01.png)'
- en: '**Add the code-behind for your XAML window.**'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为您的 XAML 窗口添加代码后台。**'
- en: The menu is generated by a method called MakeTheMenu, which your window calls
    right after it calls InitializeComponent. It uses an array of MenuItem classes
    to generate each item in the menu. We want the first three items to be normal
    menu items. The next two are only served on bagels. The last is a special item
    with its own set of ingredients.
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 菜单是由一个名为 MakeTheMenu 的方法生成的，你的窗口在调用 InitializeComponent 后立即调用它。它使用一个 MenuItem
    类的数组来生成菜单中的每一项。我们希望前三个项目是普通菜单项。接下来的两个只在贝果上提供。最后一个是特殊项目，具有自己的一套成分。
- en: '![Images](assets/210fig01.png)'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/210fig01.png)'
- en: '![Images](assets/in_five.png) **Run your program and behold the new randomly
    generated menu.**'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![图片](assets/in_five.png) **运行您的程序，看看新生成的随机菜单。**'
- en: Uh…something’s wrong. The prices on the menu are all the same, and the menu
    items are weird—the first three are the same, so are the next two, and they all
    seem to have the same protein. What’s going on?
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 哦...出了点问题。菜单上的价格都一样，并且菜单项很奇怪——前三个都一样，接下来两个也是，而且它们似乎都有相同的蛋白质。出了什么问题？
- en: Note
  id: totrans-385
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If your computer is fast enough, your program may not run into this problem.
    If you run it on a much slower computer, you’ll see it.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的计算机速度足够快，则您的程序可能不会遇到此问题。如果在较慢的计算机上运行它，您将看到它。
- en: It turns out that the .NET Random class is actually a **pseudo-random number**
    generator, which means that it uses a mathematical formula to generate a sequence
    of numbers that can pass certain statistical tests for randomness. That makes
    them good enough to use in any app we’ll build (but don’t use it as part of a
    security system that depends on truly random numbers!). That’s why the method
    is called Next—you’re getting the next number in the sequence. The formula starts
    with a “seed value” —it uses that value to find the next one in the sequence.
    When you create a new instance of Random, it uses the system clock to “seed” the
    formula, but you can provide your own seed. Try using the C# Interactive window
    to call `**new**` `**Random(12345).Next();**` a bunch of times. You’re telling
    it to create a new instance of Random with the same seed value (12345), so the
    Next method will give you the same “random” number each time.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 的 Random 类实际上是一个**伪随机数**生成器，这意味着它使用数学公式生成一系列数字，可以通过特定的统计测试来验证其随机性。这使得它们足够好用于我们构建的任何应用（但不要将其作为依赖真正随机数的安全系统的一部分！）。这就是为什么这个方法叫做
    Next —— 你得到的是序列中的下一个数字。公式从一个“种子值”开始——它使用该值找到序列中的下一个值。当你创建 Random 的一个新实例时，它使用系统时钟来“种子”公式，但你也可以提供自己的种子。试试使用
    C# 交互窗口多次调用 `**new**` `**Random(12345).Next();**`。你告诉它使用相同的种子值（12345）创建一个新的 Random
    实例，因此 Next 方法每次都会给你相同的“随机”数。
- en: 'When you see a bunch of different instances of Random give you the same value,
    it’s because they were all seeded close enough that the system clock didn’t change
    time, so they all have the same seed value. So how do we fix this? Use a single
    instance of Random by making the Randomizer field static so all MenuItems share
    a single Random instance:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到一堆不同的 Random 实例给出相同的值时，那是因为它们的种子值接近，系统时钟没有改变时间，所以它们都有相同的种子值。那么我们怎么解决这个问题呢？通过将
    Randomizer 字段设置为静态，这样所有的 MenuItem 就共享一个 Random 实例：
- en: '[PRE42]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Run your program again—now the menu will be randomized.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行你的程序——现在菜单将被随机化。
- en: '![Images](assets/211fig02.png)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/211fig02.png)'
