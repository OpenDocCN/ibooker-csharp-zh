- en: Chapter 4\. Generics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章\. 泛型
- en: In [Chapter 3](ch03.xhtml#ch_types), I showed how to write types and described
    the various kinds of members they can contain. However, there’s an extra dimension
    to classes, structs, interfaces, and methods that I did not show. They can define
    *type parameters*, placeholders that let you plug in different types at compile
    time. This allows you to write just one type and then produce multiple versions
    of it. A type that does this is called a *generic type*. For example, the runtime
    libraries define a generic class called `List<T>` that acts as a variable-length
    array. `T` is a type parameter here, and you can use almost any type as an argument,
    so `List<int>` is a list of integers, `List<string>` is a list of strings, and
    so on.^([1](ch04.xhtml#idm45884826015216)) You can also write a *generic method*,
    which is a method that has its own type arguments, independently of whether its
    containing type is generic.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第三章](ch03.xhtml#ch_types) 中，我展示了如何编写类型，并描述了它们可以包含的各种成员。然而，关于类、结构体、接口和方法还有一个额外的维度我没有展示。它们可以定义*类型参数*，这些占位符让你在编译时可以插入不同的类型。这使得你只需编写一个类型，然后就可以生成多个版本。执行此操作的类型称为*泛型类型*。例如，运行时库定义了一个名为
    `List<T>` 的泛型类，它充当可变长度数组。这里的 `T` 是一个类型参数，你可以几乎使用任何类型作为参数，因此 `List<int>` 是一个整数列表，`List<string>`
    是一个字符串列表，依此类推。^([1](ch04.xhtml#idm45884826015216)) 你也可以编写*泛型方法*，它是一种具有自己类型参数的方法，与其包含的类型是否是泛型无关。
- en: 'Generic types and methods are visually distinctive because they always have
    angle brackets (`<` and `>`) after the name. These contain a comma-separated list
    of parameters or arguments. The same parameter/argument distinction applies here
    as with methods: the declaration specifies a list of parameters, and then when
    you come to use the method or type, you supply arguments for those parameters.
    So `List<T>` defines a single type parameter, `T`, and `List<int>` supplies a
    *type argument*, `int`, for that parameter.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型和方法在视觉上是有区别的，因为它们的名称后面总是有尖括号 (`<` 和 `>`)。这些尖括号包含一个逗号分隔的参数或参数列表。与方法一样，这里也有参数/参数列表的区分：声明时指定参数列表，然后在使用方法或类型时为这些参数提供参数。因此，`List<T>`
    定义了一个单一的类型参数 `T`，而 `List<int>` 提供了一个*类型参数* `int`。
- en: You can use any name you like for type parameters, within the usual constraints
    for identifiers in C#, but there are some popular conventions. It’s common (but
    not universal) to use `T` when there’s only one parameter. For multiparameter
    generics, you tend to see slightly more descriptive names. For example, the runtime
    libraries define the `Dictionary<TKey, TValue>` collection class. Sometimes you
    will see a descriptive name like that even when there’s just one parameter, but
    in any case, you will tend to see a `T` prefix so that the type parameters stand
    out when you use them in your code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类型参数，你可以使用任何喜欢的名称，只需符合C#中标识符的通常约束即可，但有一些流行的约定。当只有一个参数时，通常（但不是普遍）使用 `T`。对于多参数泛型，你倾向于看到稍微更具描述性的名称。例如，运行时库定义了
    `Dictionary<TKey, TValue>` 集合类。有时即使只有一个参数，你也会看到像这样的描述性名称，但无论如何，你通常会看到以 `T` 为前缀，这样在你的代码中使用它们时类型参数就会显眼。
- en: Generic Types
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型类型
- en: Classes, structs, records, and interfaces can all be generic, as can delegates,
    which we’ll be looking at in [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events).
    [Example 4-1](#defining_a_generic_class) shows how to define a generic class.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 类、结构体、记录和接口都可以是泛型，委托也可以，我们将在 [第九章](ch09.xhtml#ch_delegates_lambdas_events) 中详细讨论它们。
    [示例 4-1](#defining_a_generic_class) 展示了如何定义一个泛型类。
- en: Example 4-1\. Defining a generic class
  id: totrans-6
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-1\. 定义泛型类
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The syntax for structs, records, and interfaces is much the same: the type
    name is followed immediately by a type parameter list. [Example 4-2](#defining_a_generic_record)
    shows how to write a generic record similar to the class in [Example 4-1](#defining_a_generic_class).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: structs（结构体）、records（记录）和interfaces（接口）的语法基本相同：类型名称紧跟着类型参数列表。 [示例 4-2](#defining_a_generic_record)
    展示了如何编写类似于 [示例 4-1](#defining_a_generic_class) 中类的泛型记录。
- en: Example 4-2\. Defining a generic record
  id: totrans-9
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-2\. 定义泛型记录
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Inside the definition of a generic type, I can use the type parameter `T` anywhere
    you would normally see a type name. In the first example, I’ve used it as the
    type of a constructor argument, and in both examples as the `Item` property’s
    type. I could define fields of type `T` too. (In fact I have, albeit not explicitly.
    Automatic properties generate hidden fields, so my `Item` property will have an
    associated hidden field of type `T`.) You can also define local variables of type
    `T`. And you’re free to use type parameters as arguments for other generic types.
    My `NamedContainer<T>` could declare members of type `List<T>`, for example.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在通用类型的定义内部，我可以在通常会看到类型名称的任何地方使用类型参数`T`。在第一个示例中，我已将其用作构造函数参数的类型，在两个示例中都用作`Item`属性的类型。我也可以定义类型为`T`的字段。（实际上我已经这样做了，尽管不是显式地。自动属性会生成隐藏字段，因此我的`Item`属性将有一个关联的类型为`T`的隐藏字段。）你还可以定义类型为`T`的局部变量。并且你可以自由地将类型参数作为其他通用类型的参数。例如，我的`NamedContainer<T>`可以声明类型为`List<T>`的成员。
- en: The types that Examples [4-1](#defining_a_generic_class) and [4-2](#defining_a_generic_record)
    define are, like any generic type, not complete types. A generic type declaration
    is *unbound*, meaning that there are type parameters that must be filled in to
    produce a complete type. Basic questions, such as how much memory a `NamedContainer<T>`
    instance will require, cannot be answered without knowing what `T` is—the hidden
    field for the `Item` property would need 4 bytes if `T` were an `int` but 16 bytes
    if it were a `decimal`. The CLR cannot produce executable code for a type if it
    does not know how the contents will be arranged in memory. So to use this, or
    any other generic type, we must provide type arguments. [Example 4-3](#using_a_generic_class)
    shows how. When type arguments are supplied, the result is sometimes called a
    *constructed type*. (This has nothing to do with constructors, the special kind
    of member we looked at in [Chapter 3](ch03.xhtml#ch_types). In fact, [Example 4-3](#using_a_generic_class)
    uses those too—it invokes the constructors of a couple of constructed types.)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 示例[4-1](#defining_a_generic_class)和[4-2](#defining_a_generic_record)定义的类型，像任何通用类型一样，都不是完整的类型。通用类型声明是*未绑定*的，意味着必须填入类型参数才能生成完整的类型。基本问题，例如`NamedContainer<T>`实例需要多少内存，无法在不知道`T`是什么的情况下回答——如果`T`是`int`，那么`Item`属性的隐藏字段将需要4字节，但如果是`decimal`，则需要16字节。如果CLR不知道如何安排内存中的内容，就不能为类型生成可执行代码。因此，为了使用这个或任何其他通用类型，我们必须提供类型参数。[示例 4-3](#using_a_generic_class)展示了如何做到这一点。当提供类型参数时，结果有时被称为*构造类型*。（这与构造函数无关，我们在[第3章](ch03.xhtml#ch_types)中看过的一种特殊的成员类型。事实上，[示例 4-3](#using_a_generic_class)也使用了它们——它调用了几个构造类型的构造函数。）
- en: Example 4-3\. Using a generic class
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-3\. 使用通用类
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can use a constructed generic type anywhere you would use a normal type.
    For example, you can use them as the types for method parameters and return values,
    properties, or fields. You can even use one as a type argument for another generic
    type, as [Example 4-4](#constructed_generic_types_as_type_argume) shows.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何普通类型可以使用的地方使用构造的通用类型。例如，你可以将它们用作方法参数和返回值的类型，属性或字段的类型。你甚至可以将一个作为另一个通用类型的类型参数，就像[示例 4-4](#constructed_generic_types_as_type_argume)所示的那样。
- en: Example 4-4\. Constructed generic types as type arguments
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-4\. 作为类型参数的构造通用类型
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Each different type I supply as an argument to `NamedContainer<T>` constructs
    a distinct type. (And for generic types with multiple type arguments, each distinct
    combination of type arguments would construct a distinct type.) This means that
    `NamedContainer<int>` is a different type than `NamedContainer<string>`. That’s
    why there’s no conflict in using `NamedContainer<int>` as the type argument for
    another `NamedContainer`, as the final line of [Example 4-4](#constructed_generic_types_as_type_argume)
    does—there’s no infinite recursion here.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我向`NamedContainer<T>`提供不同的类型作为参数，都会构造一个不同的类型。（对于具有多个类型参数的通用类型，每个不同的类型参数组合将构造一个不同的类型。）这意味着`NamedContainer<int>`是一种不同于`NamedContainer<string>`的类型。这就是为什么在将`NamedContainer<int>`用作另一个`NamedContainer`的类型参数时不存在冲突的原因，正如[示例 4-4](#constructed_generic_types_as_type_argume)的最后一行所示——这里没有无限递归。
- en: Because each different set of type arguments produces a distinct type, in most
    cases there is no implied compatibility between different forms of the same generic
    type. You cannot assign a `NamedContainer<int>` into a variable of type `Nam⁠ed​Con⁠tai⁠ner⁠<str⁠ing>`
    or vice versa. It makes sense that those two types are incompatible, because `int`
    and `string` are quite different types. But what if we used `object` as a type
    argument? As [Chapter 2](ch02.xhtml#ch_basic_coding) described, you can put almost
    anything in an `object` variable. If you write a method with a parameter of type
    `object`, it’s OK to pass a `string`, so you might expect a method that takes
    a `NamedContainer<object>` to be happy with a `NamedContainer<string>`. That won’t
    work, but some generic types (specifically, interfaces and delegates) can declare
    that they want this kind of compatibility relationship. The mechanisms that support
    this (called *covariance* and *contravariance*) are closely related to the type
    system’s inheritance mechanisms. [Chapter 6](ch06.xhtml#ch_inheritance) is all
    about inheritance and type compatibility, so I will discuss this aspect of generic
    types there.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每组不同的类型参数产生不同的类型，所以在大多数情况下，同一通用类型的不同形式之间并没有隐含的兼容性。你不能将`NamedContainer<int>`赋给类型为`Nam⁠ed​Con⁠tai⁠ner⁠<str⁠ing>`的变量，反之亦然。这两种类型不兼容是有道理的，因为`int`和`string`是完全不同的类型。但如果我们使用`object`作为类型参数呢？正如[第2章](ch02.xhtml#ch_basic_coding)所述，几乎可以将任何东西放入一个`object`变量中。如果你写了一个参数类型为`object`的方法，传递一个`string`是可以的，因此你可能期望一个接受`NamedContainer<object>`的方法也接受`NamedContainer<string>`。然而这是行不通的，但某些通用类型（特别是接口和委托）可以声明它们希望具有这种兼容关系。支持这一点的机制（称为*协变*和*逆变*）与类型系统的继承机制密切相关。[第6章](ch06.xhtml#ch_inheritance)详细讨论了继承和类型兼容性的这一方面，因此我将在那里讨论通用类型的这一方面。
- en: The number of type parameters forms part of an unbound generic type’s identity.
    This makes it possible to introduce multiple types with the same name as long
    as they have different numbers of type parameters. (The technical term for number
    of type parameters is *arity*.)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 类型参数的数量构成了未绑定通用类型的一部分身份。这使得可以引入具有相同名称但具有不同类型参数数量的多个类型。（类型参数数量的技术术语是*arity*。）
- en: So you could define a generic class called, say, `Operation<T>`, and then another
    class, `Operation<T1, T2>`, and also `Operation<T1, T2, T3>`, and so on, all in
    the same namespace, without introducing any ambiguity. When you are using these
    types, it’s clear from the number of arguments which type was meant—`Operation<int>`
    clearly uses the first, while `Operation<string, double>` uses the second, for
    example. And for the same reason, a nongeneric `Operation` class would be distinct
    from generic types of the same name.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以定义一个名为，比如说，`Operation<T>`的通用类，然后是另一个类，`Operation<T1, T2>`，还有`Operation<T1,
    T2, T3>`等等，都在同一命名空间中，而不会引入任何歧义。当你使用这些类型时，通过参数数量清楚地表明了使用的是哪种类型——例如，`Operation<int>`明显使用第一个，而`Operation<string,
    double>`使用第二个。出于同样的原因，一个非通用的`Operation`类会与具有相同名称的通用类型不同。
- en: My `NamedContainer<T>` example doesn’t do anything to instances of its type
    argument, `T`—it never invokes any methods or uses any properties or other members
    of `T`. All it does is accept a `T` as a constructor argument, which it stores
    away for later retrieval. This is also true of many generic types in the runtime
    libraries—I’ve mentioned some collection classes, which are all variations on
    the same theme of containing data for later retrieval.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我的`NamedContainer<T>`示例对其类型参数`T`的实例不做任何操作——它从不调用任何方法或使用任何属性或其他成员的`T`。它所做的只是接受一个`T`作为构造函数参数，并将其存储以便稍后检索。运行时库中许多通用类型也是如此——我提到过一些集合类，它们都是对包含数据以便稍后检索这一主题的变体。
- en: 'There is a reason for this: a generic class can find itself working with any
    type, so it can presume little about its type arguments. However, it doesn’t have
    to be this way. You can specify *constraints* for your type arguments.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有原因的：通用类能够处理任何类型，因此对其类型参数的假设很少。然而，并非只能这样。你可以为你的类型参数指定*约束*。
- en: Constraints
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 约束
- en: C# allows you to state that a type argument must fulfill certain requirements.
    For example, suppose you want to be able to create new instances of the type on
    demand. [Example 4-5](#creating_a_new_instance_of_a_parameteriz) shows a simple
    class that provides deferred construction—it makes an instance available through
    a static property but does not attempt to construct that instance until the first
    time you read the property.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: C#允许您声明类型实参必须满足某些要求。例如，假设您希望能够根据需要创建类型的新实例。[示例 4-5](#creating_a_new_instance_of_a_parameteriz)展示了一个简单的类，提供了延迟构造的功能——它通过静态属性提供了一个实例，但只有在第一次读取属性时才会尝试构造该实例。
- en: Example 4-5\. Creating a new instance of a parameterized type
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-5\. 创建参数化类型的新实例
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Warning
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: You wouldn’t write a class like this in practice, because the runtime libraries
    offer `Lazy<T>`, which does the same job but with more flexibility. `Lazy<T>`
    can work correctly in multithreaded code, which [Example 4-5](#creating_a_new_instance_of_a_parameteriz)
    will not. [Example 4-5](#creating_a_new_instance_of_a_parameteriz) is just to
    illustrate how constraints work. Don’t use it!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，您不会编写这样的类，因为运行时库提供了`Lazy<T>`，它能够以更灵活的方式完成相同的工作。`Lazy<T>`可以在多线程代码中正确工作，而[示例 4-5](#creating_a_new_instance_of_a_parameteriz)则不行。[示例 4-5](#creating_a_new_instance_of_a_parameteriz)只是为了说明约束的工作原理。不要使用它！
- en: For this class to do its job, it needs to be able to construct an instance of
    whatever type is supplied as the argument for `T`. The `get` accessor uses the
    `new` keyword, and since it passes no arguments, it clearly requires `T` to provide
    a parameterless constructor. But not all types do, so what happens if we try to
    use a type without a suitable constructor as the argument for `Deferred<T>`?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个类能够完成它的工作，它需要能够构造一个供`T`类型实参使用的实例。`get`访问器使用了`new`关键字，由于没有传递参数，显然需要`T`提供无参构造函数。但并非所有类型都提供这样的构造函数，那么如果我们尝试使用一个没有适当构造函数的类型作为`Deferred<T>`的实参会发生什么？
- en: The compiler will reject it, because it violates a constraint that this generic
    type has declared for `T`. Constraints appear just before the class’s opening
    brace, and they begin with the `where` keyword. The `new()` constraint in [Example 4-5](#creating_a_new_instance_of_a_parameteriz)
    states that `T` is required to supply a zero-argument constructor.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会拒绝这样做，因为它违反了这个泛型类型为`T`声明的约束条件。约束条件出现在类的开放大括号之前，并以`where`关键字开始。在[示例 4-5](#creating_a_new_instance_of_a_parameteriz)中的`new()`约束声明了`T`必须提供一个无参数的构造函数。
- en: If that constraint had not been present, the class in [Example 4-5](#creating_a_new_instance_of_a_parameteriz)
    would not compile—you would get an error on the line that attempts to construct
    a new `T`. A generic type (or method) is allowed to use only features of its type
    parameters that it has specified through constraints, or that are defined by the
    base `object` type. (The `object` type defines a `ToString` method, for example,
    so you can invoke that on instances of any type without needing to specify a constraint.)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有这个约束条件，[示例 4-5](#creating_a_new_instance_of_a_parameteriz)中的类将无法编译——在尝试构造`T`的新实例时会出错。泛型类型（或方法）只能使用通过约束指定的类型参数的特性，或者基本`object`类型定义的特性。（例如，`object`类型定义了`ToString`方法，因此您可以在任何类型的实例上调用它，而无需指定约束。）
- en: 'C# offers only a very limited suite of constraints. You cannot demand a constructor
    that takes arguments, for example. In fact, C# supports only six kinds of constraints
    on a type argument: a type constraint, a reference type constraint, a value type
    constraint, `notnull`, `unmanaged`, and the `new()` constraint. We just saw that
    last one, so let’s look at the rest.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: C#仅提供了一套非常有限的约束条件。例如，您不能要求带有参数的构造函数。事实上，C#仅支持六种类型参数的约束：类型约束、引用类型约束、值类型约束、`notnull`、`unmanaged`以及`new()`约束。我们刚刚看到了最后一种，现在让我们来看看其他几种。
- en: Type Constraints
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型约束
- en: You can constrain the argument for a type parameter to be compatible with a
    particular type. For example, you could use this to demand that the argument type
    implements a certain interface. [Example 4-6](#using_a_type_constraint) shows
    the syntax.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以约束类型参数的实参与特定类型兼容。例如，您可以使用这个特性要求实参类型实现特定接口。[示例 4-6](#using_a_type_constraint)展示了相应的语法。
- en: Example 4-6\. Using a type constraint
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-6\. 使用类型约束
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I’ll just explain the purpose of this example before describing how it takes
    advantage of a type constraint. This class provides a bridge between two styles
    of value comparison that you’ll find in .NET. Some data types provide their own
    comparison logic, but at times, it can be more useful for comparison to be a separate
    function implemented in its own class. These two styles are represented by the
    `IComparable<T>` and `IComparer<T>` interfaces, which are both part of the runtime
    libraries. (They are in the `System` and `System.Collections.Generics` namespaces,
    respectively.) I showed `IComparer<T>` in [Chapter 3](ch03.xhtml#ch_types)—an
    implementation of this interface can compare two objects or values of type `T`.
    The interface defines a single `Compare` method that takes two arguments and returns
    either a negative number, 0, or a positive number if the first argument is, respectively,
    less than, equal to, or greater than the second. `IComparable<T>` is very similar,
    but its `CompareTo` method takes just a single argument, because with this interface,
    you are asking an instance to compare *itself* to some other instance.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述如何利用类型约束之前，我将简要解释此示例的目的。这个类提供了.NET中两种值比较风格之间的桥梁。某些数据类型提供它们自己的比较逻辑，但有时将比较作为独立函数实现在其自己的类中可能更有用。这两种风格分别由`IComparable<T>`和`IComparer<T>`接口代表，它们都是运行时库的一部分（分别位于`System`和`System.Collections.Generic`命名空间中）。我在[第3章](ch03.xhtml#ch_types)展示了`IComparer<T>`——这个接口的实现可以比较两个类型为`T`的对象或值。该接口定义了一个`Compare`方法，接受两个参数，根据第一个参数分别小于、等于或大于第二个参数时返回负数、0或正数。`IComparable<T>`非常相似，但其`CompareTo`方法只接受一个参数，因为使用此接口时，你要求一个实例比较*它自己*与另一个实例。
- en: Some of the runtime libraries’ collection classes require you to provide an
    `IComparer<T>` to support ordering operations such as sorting. They use the model
    in which a separate object performs the comparison, because this offers two advantages
    over the `IComparable<T>` model. First, it enables you to use data types that
    don’t implement `IComparable<T>`. Second, it allows you to plug in different sorting
    orders. (For example, suppose you want to sort some strings with a case-insensitive
    order. The `string` type implements `IComparable<string>`, but it provides a case-sensitive,
    locale-specific order.) So `IComparer<T>` is the more flexible model. However,
    what if you are using a data type that implements `IComparable<T>`, and you’re
    perfectly happy with the order that provides? What would you do if you’re working
    with an API that demands an `IComparer<T>`?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时库的某些集合类要求你提供一个`IComparer<T>`来支持排序等操作。它们使用这种模式，其中一个单独的对象执行比较，因为这比`IComparable<T>`模式有两个优点。首先，它使你能够使用不实现`IComparable<T>`的数据类型。其次，它允许你插入不同的排序顺序。（例如，假设你希望使用不区分大小写的顺序对一些字符串进行排序。`string`类型实现了`IComparable<string>`，但它提供了区分大小写、具有特定区域设置的顺序。）因此，`IComparer<T>`是更灵活的模式。但是，如果你使用实现了`IComparable<T>`的数据类型，并且你对其提供的顺序非常满意，那么当你在使用要求`IComparer<T>`的API时，你会怎么做呢？
- en: 'Actually, the answer is that you’d probably just use the .NET feature designed
    for this very scenario: `Comparer<T>.Default`. If `T` implements `IComparable<T>`,
    that property will return an `IComparer<T>` that does precisely what you want.
    So in practice you wouldn’t need to write the code in [Example 4-6](#using_a_type_constraint),
    because Microsoft has already written it for you. However, it’s instructive to
    see how you’d write your own version, because it illustrates how to use a type
    constraint.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，答案是你可能只需使用.NET专为这种情况设计的功能：`Comparer<T>.Default`。如果`T`实现了`IComparable<T>`，该属性将返回一个精确满足你需求的`IComparer<T>`。因此，在实践中，你不需要编写[示例4-6](#using_a_type_constraint)中的代码，因为Microsoft已经为你编写了。然而，看到如何编写自己版本仍然很有教育意义，因为它展示了如何使用类型约束。
- en: The line starting with the `where` keyword states that this generic class requires
    the argument for its type parameter `T` to implement `IComparable<T>`. Without
    this addition, the `Compare` method would not compile—it invokes the `CompareTo`
    method on an argument of type `T`. That method is not present on all objects,
    and the C# compiler allows this only because we’ve constrained `T` to be an implementation
    of an interface that does offer such a method.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以`where`关键字开头的那行声明，说明这个泛型类要求其类型参数`T`实现`IComparable<T>`。如果没有这个限制，`Compare`方法将无法编译——它在类型为`T`的参数上调用`CompareTo`方法。该方法并不适用于所有对象，C#编译器之所以允许这样做，只是因为我们约束`T`必须实现提供这种方法的接口。
- en: 'Interface constraints are somewhat odd: at first glance, it may look like we
    really shouldn’t need them. If a method needs a particular argument to implement
    a particular interface, you would normally just use that interface as the argument’s
    type. However, [Example 4-6](#using_a_type_constraint) can’t do this. You can
    demonstrate this by trying [Example 4-7](#will_not_compile_colon_interface_not_imp).
    It won’t compile.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接口约束有点奇怪：乍一看，似乎我们真的不应该需要它们。如果一个方法需要特定的参数来实现特定的接口，你通常会将该接口作为参数的类型。然而，[示例 4-6](#using_a_type_constraint)无法做到这一点。你可以通过尝试[示例 4-7](#will_not_compile_colon_interface_not_imp)来证明这一点。它将无法编译通过。
- en: 'Example 4-7\. Will not compile: interface not implemented'
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-7\. 编译失败：未实现接口
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The compiler will complain that I’ve not implemented the `IComparer<T>` interface’s
    `Compare` method. [Example 4-7](#will_not_compile_colon_interface_not_imp) has
    a `Compare` method, but its signature is wrong—that first argument should be a
    `T`. I could also try the correct signature without specifying the constraint,
    as [Example 4-8](#will_not_compile_colon_missing_constrain) shows.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会抱怨我没有实现`IComparer<T>`接口的`Compare`方法。[示例 4-7](#will_not_compile_colon_interface_not_imp)有一个`Compare`方法，但其签名是错误的——第一个参数应该是`T`。我也可以尝试不指定约束的正确签名，就像[示例 4-8](#will_not_compile_colon_missing_constrain)所示。
- en: 'Example 4-8\. Will not compile: missing constraint'
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-8\. 编译失败：缺少约束
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That will also fail to compile, because the compiler can’t find that `CompareTo`
    method I’m trying to use. It’s the constraint for `T` in [Example 4-6](#using_a_type_constraint)
    that enables the compiler to know what that method really is.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这也无法通过编译，因为编译器找不到我试图使用的`CompareTo`方法。在[示例 4-6](#using_a_type_constraint)中对`T`的约束使编译器能够了解该方法的真正含义。
- en: Type constraints don’t have to be interfaces, by the way. You can use any type.
    For example, you can require a particular type argument to derive from a particular
    base class. More subtly, you can also define one parameter’s constraint in terms
    of another type parameter. [Example 4-9](#constraining_one_argument_to_derive_from)
    requires the first type argument to derive from the second, for example.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，类型约束不一定是接口。你可以使用任何类型。例如，你可以要求特定类型参数派生自特定基类。更微妙的是，你还可以根据另一个类型参数来定义一个参数的约束。例如，[示例 4-9](#constraining_one_argument_to_derive_from)要求第一个类型参数派生自第二个类型参数。
- en: Example 4-9\. Constraining one argument to derive from another
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-9\. 将一个参数约束为从另一个派生
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Type constraints are fairly specific—they require either a particular inheritance
    relationship, or the implementation of certain interfaces. However, you can define
    slightly less specific constraints.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 类型约束非常具体——它们要求特定的继承关系或实现某些接口。然而，你可以定义稍微不那么具体的约束。
- en: Reference Type Constraints
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用类型约束
- en: 'You can constrain a type argument to be a reference type. As [Example 4-10](#constraint_requiring_a_reference_type)
    shows, this looks similar to a type constraint. You just put the keyword `class`
    instead of a type name. If you are in an enabled nullable annotation context,
    the meaning of this annotation changes: it requires the type argument to be a
    non-nullable reference type. If you specify `class?`, that allows the type argument
    to be either a nullable or a non-nullable reference type.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将类型参数约束为引用类型。如[示例 4-10](#constraint_requiring_a_reference_type)所示，这看起来类似于类型约束。你只需使用关键字`class`而不是类型名称。如果你处于启用的可空注解上下文中，此注解的含义会发生变化：它要求类型参数为非空引用类型。如果指定`class?`，则允许类型参数为可空或非空引用类型。
- en: Example 4-10\. Constraint requiring a reference type
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-10\. 要求引用类型的约束
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This constraint prevents the use of value types such as `int`, `double`, or
    any `struct` as the type argument. Its presence enables your code to do three
    things that would not otherwise be possible. First, it means that you can write
    code that tests whether variables of the relevant type are `null`.^([2](ch04.xhtml#idm45884825181168))
    If you’ve not constrained the type to be a reference type, there’s always a possibility
    that it’s a value type, and those can’t have `null` values. The second capability
    is that you can use it as the target type of the `as` operator, which we’ll look
    at in [Chapter 6](ch06.xhtml#ch_inheritance). This is really just a variation
    on the first feature—the `as` keyword requires a reference type because it can
    produce a `null` result.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个约束会阻止将值类型，如 `int`、`double` 或任何 `struct`，用作类型参数。其存在使得你的代码能够做三件否则不可能做到的事情。首先，它意味着你可以编写测试相关类型变量是否为
    `null` 的代码。^([2](ch04.xhtml#idm45884825181168)) 如果你没有将类型约束为引用类型，它始终有可能是值类型，而这些类型不能有
    `null` 值。第二个能力是你可以将其用作 `as` 运算符的目标类型，我们将在[第 6 章](ch06.xhtml#ch_inheritance)中讨论这一点。这实际上只是第一个特性的变体——`as`
    关键字需要一个引用类型，因为它可能产生一个 `null` 结果。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A `class` constraint prevents the use of nullable types such as `int?` (or `Nullable<int>`,
    as the CLR calls it). Although you can test an `int?` for `null` and use it with
    the `as` operator, the compiler generates quite different code for nullable types
    for both operations than it does for a reference type. It cannot compile a single
    method that can cope with both reference types and nullable types if you use these
    features.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`class` 约束会阻止使用可空类型，如 `int?`（或 CLR 中称为 `Nullable<int>`）。虽然你可以测试 `int?` 是否为
    `null` 并使用 `as` 运算符，但编译器对可空类型和引用类型在这两个操作上生成的代码完全不同。如果你使用这些特性，它就不能编译一个可以处理引用类型和可空类型的单个方法。'
- en: The third feature that a reference type constraint enables is the ability to
    use certain other generic types. It’s often convenient for generic code to use
    one of its type arguments as an argument for another generic type, and if that
    other type specifies a constraint, you’ll need to put the same constraint on your
    own type parameter. So if some other type specifies a class constraint, this might
    require you to constrain one of your own arguments in the same way.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型约束的第三个功能是能够使用某些其他泛型类型。对于泛型代码来说，将其中一个类型参数用作另一个泛型类型的参数通常很方便，如果另一个类型指定了约束，你需要在自己的类型参数上放置相同的约束。因此，如果其他某个类型指定了类约束，这可能要求你以相同的方式约束自己的某个参数。
- en: Of course, this does raise the question of why the type you’re using needs the
    constraint in the first place. It might be that it simply wants to test for `null`
    or use the `as` operator, but there’s another reason for applying this constraint.
    Sometimes, you just need a type argument to be a reference type—there are situations
    in which a generic method might be able to compile without a `class` constraint,
    but it will not work correctly if used with a value type. To illustrate this,
    I’ll describe a scenario in which I sometimes find myself needing to use this
    kind of constraint.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这确实引出了为什么你正在使用的类型首先需要这个约束的问题。也许它只是想要测试 `null` 或使用 `as` 运算符，但应用这个约束还有另一个原因。有时候，你只需要一个类型参数是引用类型——有些泛型方法可能能够在没有
    `class` 约束的情况下编译，但如果与值类型一起使用，它将无法正确工作。为了说明这一点，我将描述我有时发现自己需要使用这种约束的场景。
- en: I regularly write tests that create an instance of the class I’m testing and
    that also need one or more fake objects to stand in for real objects with which
    the object under test wants to interact. Using these stand-ins reduces the amount
    of code any single test has to exercise and can make it easier to verify the behavior
    of the object being tested. For example, my test might need to verify that my
    code sends messages to a server at the right moment, but I don’t want to have
    to run a real server during a unit test, so I provide an object that implements
    the same interface as the class that would transmit the message but that won’t
    really send the message. This combination of an object under test plus a fake
    is such a common pattern that it might be useful to put the code into a reusable
    base class. Using generics means that the class can work for any combination of
    the type being tested and the type being faked. [Example 4-11](#constrained_by_another_constraint)
    shows a simplified version of a kind of helper class I sometimes write in these
    situations.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常编写测试，创建被测试类的实例，并且也需要一个或多个虚拟对象来替代真实对象，以便与被测试对象交互。使用这些替身减少了每个单独测试需要执行的代码量，并且可以更轻松地验证被测试对象的行为。例如，我的测试可能需要验证我的代码在正确的时机向服务器发送消息，但我不想在单元测试期间运行真实服务器，因此我提供了一个对象，它实现了与负责传输消息的类相同的接口，但实际上并不会发送消息。被测试对象加上一个虚拟对象的组合是一种常见的模式，可能有助于将代码放入可重用的基类中。使用泛型意味着该类可以适用于被测试的类型和虚拟类型的任意组合。[示例
    4-11](#constrained_by_another_constraint) 展示了我在这些情况下有时编写的一种辅助类的简化版本。
- en: Example 4-11\. Constrained by another constraint
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-11\. 受另一个约束的限制
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There are various ways to build fake objects for test purposes. You could just
    write new classes that implement the same interface as your real objects, but
    there are also third-party libraries that can generate them. One such library
    is called Moq (an [open source project available for free](https://github.com/Moq)),
    and that’s where the `Mock<T>` class in [Example 4-11](#constrained_by_another_constraint)
    comes from. It’s capable of generating a fake implementation of any interface
    or of any nonsealed class. ([Chapter 6](ch06.xhtml#ch_inheritance) describes the
    `sealed` keyword.) It will provide empty implementations of all members by default,
    and you can configure more interesting behaviors if necessary. You can also verify
    whether the code under test used the fake object in the way you expected.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以构建用于测试目的的虚拟对象。您可以编写实现与您的真实对象相同接口的新类，但也有第三方库可以生成它们。一个这样的库称为 Moq（一个 [免费提供的开源项目](https://github.com/Moq)），`Mock<T>`
    类就是来自于这里，在 [示例 4-11](#constrained_by_another_constraint) 中。它能够生成任何接口或任何未密封类的虚拟实现。([第
    6 章](ch06.xhtml#ch_inheritance) 描述了 `sealed` 关键字。) 它默认提供所有成员的空实现，并且如果需要，您还可以配置更有趣的行为。您还可以验证代码在使用虚拟对象时是否按预期进行了使用。
- en: 'How is that relevant to constraints? The `Mock<T>` class specifies a reference
    type constraint on its own type argument, `T`. This is due to the way in which
    it creates dynamic implementations of types at runtime; it’s a technique that
    can work only for reference types. Moq generates a type at runtime, and if `T`
    is an interface, that generated type will implement it, whereas if `T` is a class,
    the generated type will derive from it.^([3](ch04.xhtml#CHP-4-FN-1)) There’s nothing
    useful it can do if `T` is a struct, because you cannot derive from a value type.
    That means that when I use `Mock<T>` in [Example 4-11](#constrained_by_another_constraint),
    I need to make sure that whatever type argument I pass is not a struct (i.e.,
    it must be a reference type). But the type argument I’m using is one of my class’s
    type parameters: `TFake`. So I don’t know what type that will be—that’ll be up
    to whoever is using my class.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这与约束有什么关系？`Mock<T>` 类在其自身类型参数 `T` 上指定了引用类型约束。这是因为它在运行时创建类型的动态实现的方式；这种技术仅适用于引用类型。Moq
    在运行时生成类型，如果 `T` 是一个接口，则生成的类型将实现它；而如果 `T` 是一个类，则生成的类型将从它派生。^([3](ch04.xhtml#CHP-4-FN-1))
    如果 `T` 是一个结构体，它将无法执行任何有用的操作，因为不能从值类型派生。这意味着当我在 [示例 4-11](#constrained_by_another_constraint)
    中使用 `Mock<T>` 时，我需要确保传递的任何类型参数不是结构体（即必须是引用类型）。但是，我使用的类型参数是我的类的类型参数之一：`TFake`。因此，我不知道那将是什么类型——这将取决于谁在使用我的类。
- en: For my class to compile without error, I have to ensure that I have met the
    constraints of any generic types that I use. I have to guarantee that `Mock<TFake>`
    is valid, and the only way to do that is to add a constraint on my own type that
    requires `TFake` to be a reference type. And that’s what I’ve done on the third
    line of the class definition in [Example 4-11](#constrained_by_another_constraint).
    Without that, the compiler would report errors on the two lines that refer to
    `Mock<TFake>`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我的类能够编译而不报错，我必须确保已满足我使用的任何泛型类型的约束。我必须保证`Mock<TFake>`是有效的，而唯一的方法就是在自己的类型上添加一个要求`TFake`为引用类型的约束。这就是在类定义的第三行中做的事情，在[示例 4-11](#constrained_by_another_constraint)中。如果没有这个，编译器会在引用`Mock<TFake>`的两行上报错。
- en: To put it more generally, if you want to use one of your own type parameters
    as the type argument for a generic that specifies a constraint, you’ll need to
    specify the same constraint on your own type parameter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，如果你想使用自己的类型参数作为泛型的类型参数，并指定一个约束条件，你需要在自己的类型参数上也指定相同的约束条件。
- en: Value Type Constraints
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值类型约束
- en: Just as you can constrain a type argument to be a reference type, you can also
    constrain it to be a value type. As shown in [Example 4-12](#constraint_requiring_a_value_type),
    the syntax is similar to that for a reference type constraint but with the `struct`
    keyword.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你可以约束一个类型参数为引用类型一样，你也可以约束它为值类型。如[示例 4-12](#constraint_requiring_a_value_type)所示，语法与引用类型约束类似，但使用`struct`关键字。
- en: Example 4-12\. Constraint requiring a value type
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-12\. 要求值类型的约束
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Before now, we’ve seen the `struct` keyword only in the context of custom value
    types, but despite how it looks, this constraint permits `bool`, `enum` types,
    and any of the built-in numeric types such as `int`, as well as custom structs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只在自定义值类型的上下文中看到过`struct`关键字，但尽管它的外观如此，此约束允许`bool`、`enum`类型以及任何内置数值类型（如`int`），以及自定义结构体。
- en: .NET’s `Nullable<T>` type imposes this constraint. Recall from [Chapter 3](ch03.xhtml#ch_types)
    that `Nullable<T>` provides a wrapper for value types that allows a variable to
    hold either a value or no value. (We normally use the special syntax C# provides,
    so we’d write, say, `int?` instead of `Nullable<int>`.) The only reason this type
    exists is to provide nullability for types that would not otherwise be able to
    hold a null value. So it only makes sense to use this with a value type—reference
    type variables can already be set to `null` without needing this wrapper. The
    value type constraint prevents you from using `Nullable<T>` with types for which
    it is unnecessary.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: .NET的`Nullable<T>`类型施加了这个约束。从[第3章](ch03.xhtml#ch_types)回忆起，`Nullable<T>`为值类型提供了一个包装器，允许变量既可以持有一个值，也可以没有值。（通常我们使用C#提供的特殊语法，例如，我们会写`int?`而不是`Nullable<int>`。）这种类型存在的唯一理由是为不能持有null值的类型提供可空性。因此，只有将此类型用于值类型才有意义——引用类型变量已经可以被设置为`null`而不需要这个包装器。值类型约束阻止你将`Nullable<T>`用于不需要它的类型。
- en: Value Types All the Way Down with Unmanaged Constraints
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用非托管约束实现全面的值类型
- en: You can specify `unmanaged` as a constraint, which requires that the type argument
    be a value type but also that it contains no references. All of the type’s fields
    must be value types, and if any of those fields is not a built-in primitive type,
    then its type must in turn contain only fields that are value types, and so on
    all the way down. In practice this means that all the actual data needs to be
    either one of a fixed set of built-in types (essentially, all the numeric types,
    `bool`, or a pointer) or an `enum` type. This is mainly of interest in interop
    scenarios, because types that match the `unmanaged` constraint can be passed safely
    and efficiently to unmanaged code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以指定`unmanaged`作为约束条件，这要求类型参数是一个值类型，但也要求它不包含引用。该类型的所有字段必须是值类型，如果任何字段不是内置基元类型，则其类型必须进一步仅包含值类型字段，以此类推直到底部。实际上，这意味着所有实际数据必须是固定集合中的一种内置类型（基本上是所有数值类型、`bool`或指针）或`enum`类型。这主要在互操作场景中非常重要，因为符合`unmanaged`约束的类型可以安全高效地传递给非托管代码。
- en: Not Null Constraints
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非空约束
- en: If you use the nullable references feature described in [Chapter 3](ch03.xhtml#ch_types)
    (which is enabled by default when you create new projects), you can specify a
    `notnull` constraint. This allows either value types or non-nullable reference
    types but not nullable reference types.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用了第[3](ch03.xhtml#ch_types)章描述的可空引用特性（在创建新项目时默认启用），则可以指定`notnull`约束。这允许值类型或非可空引用类型，但不允许可空引用类型。
- en: Other Special Type Constraints
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他特殊类型约束
- en: '[Chapter 3](ch03.xhtml#ch_types) described various special kinds of types,
    including enumeration types (`enum`) and delegate types (covered in detail in
    [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events)). It is sometimes useful to
    constrain type arguments to be one of these kinds of types. There’s no special
    trick to this, though: you can just use type constraints. All delegate types derive
    from `System.Delegate`, and all enumeration types derive from `System.Enum`. As
    [Example 4-13](#constraint_requiring_delegate_or_enum) shows, you can just write
    a type constraint requiring a type argument to derive from either of these.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第[3](ch03.xhtml#ch_types)章描述了各种特殊类型，包括枚举类型（`enum`）和委托类型（在第[9](ch09.xhtml#ch_delegates_lambdas_events)章中详细介绍）。有时将类型参数约束为这些类型之一是很有用的。不过，这没有什么特别的技巧：你只需使用类型约束即可。所有委托类型都派生自`System.Delegate`，所有枚举类型都派生自`System.Enum`。正如[示例 4-13](#constraint_requiring_delegate_or_enum)所示，你可以编写一个约束类型参数必须派生自其中任何一个的类型约束。
- en: Example 4-13\. Constraints requiring delegate and `enum` types
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-13\. 要求委托和`enum`类型的约束
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Multiple Constraints
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多重约束
- en: If you’d like to impose multiple constraints for a single type argument, you
    can just put them in a list, as [Example 4-14](#multiple_constraints-id1) shows.
    There are some restrictions. You cannot combine the `class`, `struct`, `notnull`,
    or `unmanaged` constraints—these are mutually exclusive. If you do use one of
    these keywords, it must come first in the list. If the `new()` constraint is present,
    it must be last.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望对单个类型参数施加多重约束，可以将它们放在一个列表中，正如[示例 4-14](#multiple_constraints-id1)所示。有一些限制。你不能结合使用`class`、`struct`、`notnull`或`unmanaged`约束
    —— 这些是互斥的。如果使用了其中一个关键字，必须将其放在列表的最前面。如果存在`new()`约束，则必须放在最后。
- en: Example 4-14\. Multiple constraints
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-14\. 多重约束
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When your type has multiple type parameters, you write one `where` clause for
    each type parameter you wish to constrain. In fact, we saw this earlier—[Example 4-11](#constrained_by_another_constraint)
    defines constraints for both of its parameters.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的类型具有多个类型参数时，需要为每个想要约束的类型参数编写一个`where`子句。实际上，我们在前面看到了这一点 —— [示例 4-11](#constrained_by_another_constraint)为其两个参数定义了约束。
- en: Zero-Like Values
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 零值类似的值
- en: There are certain features that all types support and that therefore do not
    require a constraint. This includes the set of methods defined by the `object`
    base class, covered in Chapters [3](ch03.xhtml#ch_types) and [6](ch06.xhtml#ch_inheritance).
    But there’s a more basic feature that can sometimes be useful in generic code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类型都支持的某些特性，因此不需要约束。这包括由`object`基类定义的方法集，详见第[3](ch03.xhtml#ch_types)章和第[6](ch06.xhtml#ch_inheritance)章。但在泛型代码中有时可以使用更基本的特性。
- en: Variables of any type can be initialized to a default value. As you have seen
    in the preceding chapters, there are some situations in which the CLR does this
    for us. For example, all the fields in a newly constructed object will have a
    known value even if we don’t write field initializers and don’t supply values
    in the constructor. Likewise, a new array of any type will have all of its elements
    initialized to a known value. The CLR does this by filling the relevant memory
    with zeros. The exact meaning of this depends on the data type. For any of the
    built-in numeric types, the value will quite literally be the number `0`, but
    for nonnumeric types, it’s something else. For `bool`, the default is `false`,
    and for a reference type, it is `null`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类型的变量都可以初始化为默认值。正如在前面章节中所看到的，有些情况下CLR会为我们做这件事。例如，新构造对象中的所有字段将具有已知值，即使我们没有编写字段初始化器并且没有在构造函数中提供值。同样，任何类型的新数组将所有元素初始化为已知值。CLR通过填充相关内存区域为零来完成此操作。这的确切含义取决于数据类型。对于任何内置数值类型，该值将几乎肯定是数字`0`，但对于非数值类型，情况则不同。对于`bool`，默认值是`false`，对于引用类型，则为`null`。
- en: Sometimes, it can be useful for generic code to be able to set a variable to
    this initial default zero-like value. But you cannot use a literal expression
    to do this in most situations. You cannot assign `null` into a variable whose
    type is specified by a type parameter unless that parameter has been constrained
    to be a reference type. And you cannot assign the literal `0` into any such variable,
    because there is currently no way to constrain a type argument to be a numeric
    type.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，对于通用代码而言，能够将变量设置为这种初始默认的零值可能非常有用。但在大多数情况下，您无法使用文字表达式来完成这一点。您不能将`null`赋给一个由类型参数指定的变量，除非该参数已被约束为引用类型。并且您也不能将字面量`0`赋给任何此类变量，因为当前没有一种方法来约束类型参数为数值类型。
- en: 'Instead, you can request the zero-like value for any type using the `default`
    keyword. (This is the same keyword we saw inside a `switch` statement in [Chapter 2](ch02.xhtml#ch_basic_coding)
    but used in a completely different way. C# keeps up the C-family tradition of
    defining multiple, unrelated meanings for each keyword.) If you write `default(*SomeType*)`,
    where `*SomeType*` is either a specific type or a type parameter, you will get
    the default initial value for that type: `0` if it is a numeric type, and the
    equivalent for any other type. For example, the expression `default(int)` has
    the value `0`, `default(bool)` is `false`, and `default(string)` is `null`. You
    can use this with a generic type parameter to get the default value for the corresponding
    type argument, as [Example 4-15](#getting_the_default_open_parenthesis_zer) shows.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您可以使用`default`关键字请求任何类型的零值。（这与我们在[第2章](ch02.xhtml#ch_basic_coding)中在`switch`语句内部看到的相同关键字，但用法完全不同。C#保持了C家族传统，为每个关键字定义多个不相关的含义。）如果您编写`default(*SomeType*)`，其中`*SomeType*`可以是特定类型或类型参数，则会获得该类型的默认初始值：如果是数值类型，则为`0`，对于任何其他类型，则为其等效值。例如，表达式`default(int)`的值为`0`，`default(bool)`为`false`，`default(string)`为`null`。您可以将其与泛型类型参数一起使用，以获取相应类型参数的默认值，如[示例 4-15](#getting_the_default_open_parenthesis_zer)所示。
- en: Example 4-15\. Getting the default (zero-like) value of a type argument
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-15\. 获取类型参数的默认（类似零值）值
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Inside a generic type or method that defines a type parameter `T`, the expression
    `default(T)` will produce the default, zero-like value for `T`—whatever `T` may
    be—without requiring constraints. So you could use the generic method in [Example 4-15](#getting_the_default_open_parenthesis_zer)
    to verify that the defaults for `int`, `bool`, and `string` are the values I stated.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义类型参数`T`的泛型类型或方法内部，表达式`default(T)`将产生类型`T`的默认零值——无论`T`是什么——而无需约束。因此，您可以使用[示例 4-15](#getting_the_default_open_parenthesis_zer)中的泛型方法来验证我所述的`int`、`bool`和`string`的默认值。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When the nullable references feature (described in [Chapter 3](ch03.xhtml#ch_types))
    is enabled, the compiler will consider a `default(T)` to be a potentially null
    value, unless you’ve ruled out the use of reference types by applying the `struct`
    constraint.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用了可空引用功能（在[第3章](ch03.xhtml#ch_types)中描述）时，编译器将考虑`default(T)`作为一个可能为空的值，除非您通过应用`struct`约束来排除引用类型的使用。
- en: In cases where the compiler is able to infer what type is required, you can
    use a simpler form. Instead of writing `default(T)`, you can just write `default`.
    That wouldn’t work in [Example 4-15](#getting_the_default_open_parenthesis_zer)
    because `Console.WriteLine` can accept pretty much anything, so the compiler can’t
    narrow it down to one option, but it will work in [Example 4-16](#default_literal_inferred)
    because the compiler can see that the generic method’s return type is `T`, so
    this must need a `default(T)`. Since it can infer that, it’s enough for us to
    write just `default`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译器能够推断所需类型的情况下，您可以使用更简单的形式。而不是编写`default(T)`，您只需编写`default`。这在[示例 4-15](#getting_the_default_open_parenthesis_zer)中是行不通的，因为`Console.WriteLine`几乎可以接受任何东西，所以编译器无法缩小到一个选项，但在[示例 4-16](#default_literal_inferred)中可以正常工作，因为编译器可以看到泛型方法的返回类型是`T`，所以这必须需要一个`default(T)`。由于它可以推断出来，我们只需写`default`。
- en: Example 4-16\. Getting the default (zero-like) value of an inferred type
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-16\. 获取推断类型的默认（类似零值）
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: And since I’ve just shown you an example of one, this seems like a good time
    to talk about generic methods.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，既然我刚刚向您展示了一个示例，这似乎是一个谈论泛型方法的好时机。
- en: Generic Methods
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型方法
- en: As well as generic types, C# also supports generic methods. In this case, the
    generic type parameter list follows the method name and precedes the method’s
    normal parameter list. [Example 4-17](#a_generic_method) shows a method with a
    single type parameter. It uses that parameter as its return type and also as the
    element type for an array to be passed in as the method’s argument. This method
    returns the final element in the array, and because it’s generic, it will work
    for any array element type.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 除了泛型类型，C# 还支持泛型方法。在这种情况下，泛型类型参数列表位于方法名之后，并且在方法的普通参数列表之前。[示例 4-17](#a_generic_method)展示了一个具有单个类型参数的方法。它将该参数用作其返回类型，并将其用作将传递给方法的数组的元素类型。该方法返回数组中的最后一个元素，并且因为它是泛型的，所以对于任何数组元素类型都有效。
- en: Example 4-17\. A generic method
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-17\. 泛型方法
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-106
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can define generic methods inside either generic types or nongeneric types.
    If a generic method is a member of a generic type, all of the type parameters
    from the containing type are in scope inside the method, as well as the type parameters
    specific to the method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在泛型类型或非泛型类型中定义泛型方法。如果泛型方法是泛型类型的成员，则包含类型的所有类型参数都在方法内部有效，以及方法特定的类型参数。
- en: Just as with a generic type, you can use a generic method by specifying its
    name along with its type arguments, as [Example 4-18](#invoking_a_generic_method)
    shows.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与泛型类型类似，您可以通过指定方法名和类型参数来使用泛型方法，如[示例 4-18](#invoking_a_generic_method)所示。
- en: Example 4-18\. Invoking a generic method
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-18\. 调用泛型方法
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Generic methods work in a similar way to generic types but with type parameters
    that are only in scope within the method declaration and body. You can specify
    constraints in much the same way as with generic types. The constraints appear
    after the method’s parameter list and before its body, as [Example 4-19](#a_generic_method_with_a_constraint)
    shows.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型方法与泛型类型类似，但类型参数仅在方法声明和方法体内有效。您可以像处理泛型类型那样指定约束条件。如[示例 4-19](#a_generic_method_with_a_constraint)所示，约束条件出现在方法参数列表后和方法体前。
- en: Example 4-19\. A generic method with a constraint
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-19\. 具有约束条件的泛型方法
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There’s one significant way in which generic methods differ from generic types,
    though: you don’t always need to specify a generic method’s type arguments explicitly.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，泛型方法与泛型类型有一个显著的区别：您不必总是显式指定泛型方法的类型参数。
- en: Type Inference
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型推断
- en: The C# compiler is often able to infer the type arguments for a generic method.
    I can modify [Example 4-18](#invoking_a_generic_method) by removing the type argument
    list from the method invocation, as [Example 4-20](#generic_method_type_argument_inference)
    shows. This doesn’t change the meaning of the code in any way.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: C# 编译器通常能够推断出泛型方法的类型参数。例如，我可以通过从方法调用中移除类型参数列表来修改[示例 4-18](#invoking_a_generic_method)，如[示例 4-20](#generic_method_type_argument_inference)所示。这并不改变代码的含义。
- en: Example 4-20\. Generic method type argument inference
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-20\. 泛型方法类型参数推断
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When presented with this sort of ordinary-looking method call, if there’s no
    nongeneric method of that name available, the compiler starts looking for suitable
    generic methods. If the method in [Example 4-17](#a_generic_method) is in scope,
    it will be a candidate, and the compiler will attempt to deduce the type arguments.
    This is a pretty simple case. The method expects an array of some type `T`, and
    we’ve passed an array with elements of type `int`, so it’s not a massive stretch
    to work out that this code should be treated as a call to `GetLast<int>`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到这种普通的方法调用时，如果没有同名的非泛型方法可用，编译器会开始寻找合适的泛型方法。如果[示例 4-17](#a_generic_method)中的方法在作用域内，则它将是一个候选项，并且编译器将尝试推断类型参数。这是一个相当简单的情况。该方法期望一个类型为`T`的数组，而我们传递了一个元素类型为`int`的数组，因此很容易推断出这段代码应该被视为对`GetLast<int>`的调用。
- en: 'It gets more complex with more intricate cases. The C# specification has about
    six pages dedicated to the type inference algorithm, but it’s all to support one
    goal: letting you leave out type arguments when they would be redundant. By the
    way, type inference is always performed at compile time, so it’s based on the
    static type of the method arguments.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 随着更复杂的案例的出现，情况变得更加复杂。C# 规范大约有六页专门讨论类型推断算法，但它的目标始终是：在类型参数冗余时让您可以省略类型参数。顺便说一句，类型推断始终在编译时进行，因此它基于方法参数的静态类型。
- en: With APIs that make extensive use of generics (such as LINQ, which is the topic
    of [Chapter 10](ch10.xhtml#ch_linq)), explicitly listing every type argument can
    make the code very hard to follow, so it is common to rely on type inference.
    And if you use anonymous types, then type argument inference becomes essential
    because it is not possible to supply the type arguments explicitly.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于广泛使用泛型的 API（例如 LINQ，这是[第 10 章](ch10.xhtml#ch_linq)的主题），显式列出每个类型参数可能会使代码非常难以理解，因此通常依赖类型推断。如果使用匿名类型，则类型参数推断变得至关重要，因为无法显式提供类型参数。
- en: Generics and Tuples
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型和元组
- en: C#’s lightweight tuples have a distinctive syntax, but as far as the runtime
    is concerned, there is nothing special about them. They are all just instances
    of a set of generic types. Look at [Example 4-21](#tuple_usual_declaration). This
    uses `(int, int)` as the type of a local variable to indicate that it is a tuple
    containing two `int` values.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: C# 的轻量级元组具有独特的语法，但在运行时看来，它们并没有什么特别之处。它们都只是一组通用类型的实例。看看[示例 4-21](#tuple_usual_declaration)。这里使用
    `(int, int)` 作为局部变量的类型，表示它是一个包含两个 `int` 值的元组。
- en: Example 4-21\. Declaring a tuple variable in the normal way
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-21\. 正常方式声明元组变量
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now look at [Example 4-22](#tuple_underlying_type). This uses the `ValueTuple<int,
    int>` type in the `System` namespace. But this is exactly equivalent to the declaration
    in [Example 4-21](#tuple_usual_declaration). In Visual Studio or VS Code, if you
    hover the mouse over the `p2` variable, it will report its type as `(int, int)`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看[示例 4-22](#tuple_underlying_type)。这里使用了位于 `System` 命名空间中的 `ValueTuple<int,
    int>` 类型。但这与[示例 4-21](#tuple_usual_declaration)中的声明完全等效。在 Visual Studio 或 VS Code
    中，如果你将鼠标悬停在 `p2` 变量上，它将报告其类型为 `(int, int)`。
- en: Example 4-22\. Declaring a tuple variable with its underlying type
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-22\. 声明带有其底层类型的元组变量
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'One thing that C#’s special syntax for tuples adds is the ability to name the
    tuple elements. The `ValueTuple` family names its elements `Item1`, `Item2`, `Item3`,
    etc., but in C# we can pick other names. When you declare a local variable with
    named tuple elements, those names are a fiction maintained by C#—they have no
    runtime representation at all. However, when a method returns a tuple, as in [Example 4-23](#tuple_return),
    it’s different: the names need to be visible so that code consuming this method
    can use the same names. Even if this method is in some library component that
    my code has referenced, I want to be able to write `Pos().X`, instead of having
    to use `Pos().Item1`.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: C# 的特殊语法允许给元组元素命名，这是其特有的一点。`ValueTuple` 系列为其元素命名为 `Item1`、`Item2`、`Item3` 等，但在
    C# 中我们可以选择其他名称。当你声明一个带有命名元组元素的局部变量时，这些名称在 C# 中实际上是虚构的——在运行时完全没有表现。但是，当一个方法返回一个元组时，例如在[示例 4-23](#tuple_return)中，情况就不同了：这些名称需要可见，以便消费此方法的代码可以使用相同的名称。即使此方法位于我代码已引用的某个库组件中，我也希望能够编写
    `Pos().X`，而不是必须使用 `Pos().Item1`。
- en: Example 4-23\. Returning a tuple
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-23\. 返回一个元组
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To make this work, the compiler applies an attribute named `TupleElementNames`
    to the method’s return value, and this contains an array listing the property
    names to use. ([Chapter 14](ch14.xhtml#ch_attributes) describes attributes.) You
    can’t actually write code that does this yourself: if you write a method that
    returns a `ValueTuple<int, int>` and you try to apply the `TupleElementNamesAttribute`
    as a `return` attribute, the compiler will produce an error telling you not to
    use this attribute directly and to use the tuple syntax instead. But that attribute
    is how the compiler reports the tuple element names.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这一点实现，编译器将一个名为 `TupleElementNames` 的属性应用于方法的返回值，其中包含一个列出要使用的属性名称的数组。([第 14 章](ch14.xhtml#ch_attributes)描述了属性。)
    你实际上不能自己编写能够执行此操作的代码：如果你编写一个返回 `ValueTuple<int, int>` 的方法，并尝试将 `TupleElementNamesAttribute`
    作为 `return` 属性应用，编译器将生成错误消息，告诉你不要直接使用此属性，而是使用元组语法。但是编译器正是通过该属性来报告元组元素的名称。
- en: Be aware that there’s another family of tuple types in the runtime libraries,
    `Tuple<T>`, `Tuple<T1, T2>`, and so on. These look almost identical to the `ValueTuple`
    family. The difference is that the `Tuple` family of generic types are all classes,
    whereas all the `ValueTuple` types are structs. The C# lightweight tuple syntax
    only uses the `ValueTuple` family. The `Tuple` family has been around in the runtime
    libraries for much longer, though, so you often see them used in older code that
    needed to bundle a set of values together without defining a new type just for
    that job.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，运行库中还有另一组元组类型，`Tuple<T>`、`Tuple<T1, T2>`等。这些几乎与`ValueTuple`系列看起来相同。不同之处在于，`Tuple`系列的泛型类型都是类，而所有`ValueTuple`类型都是结构体。C#的轻量级元组语法仅使用`ValueTuple`系列。尽管如此，`Tuple`系列在运行库中已经存在很长时间了，因此在旧代码中经常看到它们，这些代码需要将一组值捆绑在一起而不需要为此定义新类型。
- en: Inside Generics
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在泛型内部
- en: If you are familiar with C++ templates, you will by now have noticed that C#
    generics are quite different than templates. Superficially, they have some similarities
    and can be used in similar ways—both are suitable for implementing collection
    classes, for example. However, there are some template-based techniques that simply
    won’t work in C#, such as the code in [Example 4-24](#template_technique_wont_work_in_cs).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉C++模板，现在应该已经注意到C#泛型与模板有很大不同。表面上看，它们有一些相似之处，并且可以用类似的方式使用——例如，都适用于实现集合类。然而，有些基于模板的技术在C#中根本行不通，比如[示例 4-24](#template_technique_wont_work_in_cs)中的代码。
- en: Example 4-24\. A template technique that doesn’t work in C# generics
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-24\. C# 泛型中无法工作的模板技术
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can do this sort of thing in a C++ template but not in C#, and you cannot
    fix it completely with a constraint. You could add a type constraint requiring
    `T` to derive from some type or implement some interface that defines a custom
    `+` operator, which would get this to compile, but it would be pretty limited—it
    would work only for types derived from that base type. In C++, you can write a
    template that will add together two items of any type that supports addition,
    whether that is a built-in type or a custom one. Moreover, C++ templates don’t
    need constraints; the compiler is able to work out for itself whether a particular
    type will work as a template argument.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++模板中可以做这种事情，但在C#中不行，并且无法通过约束完全修复。你可以添加一个类型约束，要求`T`从某个类型派生或实现某个定义了自定义`+`运算符的接口，这样就可以编译通过，但这相当有限——它只适用于从该基类型派生的类型。在C++中，你可以编写一个模板，它将任何支持加法的类型的两个项相加在一起，无论是内置类型还是自定义类型。此外，C++模板不需要约束；编译器能够自行判断特定类型是否适用作为模板参数。
- en: This issue is not specific to arithmetic. The fundamental problem is that because
    generic code relies on constraints to know what operations are available on its
    type parameters, it can use only features represented as members of interfaces
    or shared base classes. If arithmetic in .NET were interface-based, it would be
    possible to define a constraint that requires it. But operators are all static
    methods, and although interfaces can contain static members,^([4](ch04.xhtml#idm45884824373280))
    there’s no supported way for individual types to supply their own implementation—the
    dynamic dispatch mechanism that enables each type to supply its own interface
    implementation only works for instance members.^([5](ch04.xhtml#idm45884824371344))
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题并非特定于算术运算。根本问题在于，由于泛型代码依赖于约束来确定其类型参数上可用的操作，它只能使用作为接口成员或共享基类的特性。如果.NET中的算术运算是基于接口的，那么可以定义一个需要该接口的约束。但是操作符都是静态方法，尽管接口可以包含静态成员，^([4](ch04.xhtml#idm45884824373280))
    但没有支持的方法让各个类型提供自己的实现——允许每个类型提供自己接口实现的动态调度机制仅适用于实例成员。^([5](ch04.xhtml#idm45884824371344))
- en: The limitations of C# generics are an upshot of how they are designed to work,
    so it’s useful to understand the mechanism. (These limitations are not specific
    to any particular CLR implementation, by the way. They are an inevitable result
    of how generics fit into the design of the .NET runtime.)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: C# 泛型的限制是由其设计原理决定的，因此理解其机制非常有用。（顺便说一下，这些限制并不特定于任何特定的CLR实现。它们是泛型如何融入.NET运行时设计的必然结果。）
- en: Generic methods and types are compiled without knowing which types will be used
    as arguments. This is the fundamental difference between C# generics and C++ templates—in
    C++, the compiler gets to see every instantiation of a template. But with C#,
    you can instantiate generic types without access to any of the relevant source
    code, long after the code has been compiled. After all, Microsoft wrote the generic
    `List<T>` class years ago, but you could write a brand-new class today and plug
    that in as the type argument just fine. (You might point out that the C++ standard
    library’s `std::vector` has been around even longer. However, the C++ compiler
    has access to the source file that defines the class, which is not true of C#
    and `List<T>`. C# sees only the compiled library.)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通用方法和类型在编译时并不知道将用作参数的具体类型。这是C#泛型与C++模板之间的根本区别——在C++中，编译器可以看到模板的每个实例化。但在C#中，你可以在编译代码很久之后，实例化泛型类型，而无需访问任何相关源代码。毕竟，微软多年前就写了通用的`List<T>`类，但你今天完全可以写一个全新的类，并作为类型参数嵌入其中。
    （你可能会指出C++标准库的`std::vector`存在更久。然而，C++编译器可以访问定义类的源文件，而对于C#和`List<T>`来说则不然。C#只看到已编译的库。）
- en: The upshot of this is that the C# compiler needs to have enough information
    to be able to generate type-safe code at the point at which it compiles generic
    code. Take [Example 4-24](#template_technique_wont_work_in_cs). It cannot know
    what the + operator means here, because it would be different for different types.
    With the built-in numeric types, that code would need to compile to the specialized
    intermediate language (IL) instructions for performing addition. If that code
    were in a checked context (i.e., using the `checked` keyword shown in [Chapter 2](ch02.xhtml#ch_basic_coding)),
    we’d already have a problem, because the code for adding integers with overflow
    checking uses different IL opcodes for signed and unsigned integers. Furthermore,
    since this is a generic method, we may not be dealing with the built-in numeric
    types at all—perhaps we are dealing with a type that defines a custom `+` operator,
    in which case the compiler would need to generate a method call. (Custom operators
    are just methods under the covers.) Or if the type in question turns out not to
    support addition, the compiler should generate an error.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，C#编译器需要足够的信息来在编译泛型代码时生成类型安全的代码。看看[示例 4-24](#template_technique_wont_work_in_cs)。它无法知道这里的+运算符具体是什么意思，因为对于不同的类型它可能是不同的。对于内置数值类型，该代码需要编译为执行加法的特定中间语言（IL）指令。如果该代码位于检查上下文中（即使用[第 2
    章](ch02.xhtml#ch_basic_coding)中显示的`checked`关键字），我们可能已经遇到问题，因为使用溢出检查的整数加法代码会为有符号和无符号整数使用不同的IL操作码。此外，由于这是一个泛型方法，我们可能根本不处理内置数值类型——也许我们正在处理定义了自定义`+`运算符的类型，在这种情况下，编译器需要生成一个方法调用。（自定义运算符实际上就是方法。）或者如果相关类型不支持加法操作，编译器应该生成一个错误。
- en: There are several possible outcomes for compiling a simple addition expression,
    depending on the actual types involved. That is fine when the types are known
    to the compiler, but it has to compile the code for generic types and methods
    without knowing which types will be used as arguments.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于编译简单的加法表达式，存在几种可能的结果，这取决于实际涉及的类型。当编译器知道类型时，这很好，但它必须在不知道将用作参数的类型的情况下编译泛型类型和方法的代码。
- en: You might argue that perhaps Microsoft could have supported some sort of tentative
    semicompiled format for generic code, and in a sense, it did. When introducing
    generics, Microsoft modified the type system, file format, and IL instructions
    to allow generic code to use placeholders representing type parameters to be filled
    in when the type is fully constructed. So why not extend it to handle operators?
    Why not let the compiler generate errors at the point at which you compile code
    that attempts to use a generic type instead of insisting on generating errors
    when the generic code itself is compiled? Well, it turns out that you can plug
    in new sets of type arguments at runtime—the reflection API that we’ll look at
    in [Chapter 13](ch13.xhtml#ch_reflection) lets you construct generic types. There
    isn’t necessarily a compiler available at the point at which an error would become
    apparent, since not all versions of .NET ship with a copy of the C# compiler.
    In any case, what should happen if a generic class was written in C# but consumed
    by a completely different language, perhaps one that didn’t support operator overloading?
    Which language’s rules should apply when it comes to working out what to do with
    that `+` operator? Should it be the language in which the generic code was written
    or the language in which the type argument was written? (What if there are multiple
    type parameters, and for each argument, you use a type written in a different
    language?) Or perhaps the rules should come from the language that decided to
    plug the type arguments into the generic type or method, but what about cases
    where one piece of generic code passes its arguments through to some other generic
    entity? Even if you could decide which of these approaches would be best, it supposes
    that the rules used to determine what a line of code actually means are available
    at runtime, a presumption that once again founders on the fact that the relevant
    compilers will not necessarily be installed on the machine running the code.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 或许你会认为微软可以支持一种类似于泛型代码的暂定半编译格式，从某种意义上说，它确实做到了。在引入泛型时，微软修改了类型系统、文件格式和 IL 指令，允许泛型代码使用代表类型参数的占位符，以便在类型完全构造时填充。那么为什么不扩展以处理运算符？为什么不让编译器在编译试图使用泛型类型的代码时生成错误，而不是坚持在编译泛型代码本身时生成错误呢？好吧，事实证明，你可以在运行时插入新的类型参数集合——我们将在[第13章](ch13.xhtml#ch_reflection)看到的反射
    API 允许你构造泛型类型。在明显出现错误的时间点可能没有可用的编译器，因为并非所有 .NET 版本都提供了 C# 编译器的副本。无论如何，如果一个泛型类是用
    C# 编写的，但被完全不同的语言消费，也许这种语言不支持操作符重载，那么该使用哪种语言的规则来决定对`+`操作符的处理呢？应该是编写泛型代码的语言还是编写类型参数的语言呢？（如果有多个类型参数，并且每个参数使用不同语言编写的类型，那又该怎么办呢？）或者规则应该来自于决定将类型参数插入泛型类型或方法的语言，但是如果一段泛型代码将其参数传递给其他泛型实体呢？即使你能决定哪种方法最好，这也假设在运行时确定一行代码的含义所使用的规则是可用的，这一假设再次因为运行代码的机器上可能没有相关的编译器而遇到困难。
- en: .NET generics solve this problem by requiring the meaning of generic code to
    be fully defined when the generic code is compiled, using the rules of the language
    in which the generic code was written. If the generic code involves using methods
    or other members, they must be resolved statically (i.e., the identity of those
    members must be determined precisely at compile time). Critically, that means
    compile time for the generic code itself, not for the code consuming the generic
    code. These requirements explain why C# generics are not as flexible as the consumer-compile-time
    substitution model that C++ uses. The payoff is that you can compile generics
    into libraries in binary form, and they can be used by any .NET language that
    supports generics, with completely predictable behavior.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 泛型通过在泛型代码编译时使用编写泛型代码的语言的规则，要求完全定义泛型代码的含义来解决这个问题。如果泛型代码涉及使用方法或其他成员，它们必须在编译时静态解析（即这些成员的标识必须在编译时精确确定）。关键在于，这意味着泛型代码本身的编译时间，而不是消费泛型代码的代码的编译时间。这些要求解释了为什么
    C# 泛型不像 C++ 使用的消费者编译时替换模型那样灵活。回报是，你可以将泛型编译成二进制形式的库，并且它们可以被支持泛型的任何 .NET 语言使用，具有完全可预测的行为。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Generics enable us to write types and methods with type arguments, which can
    be filled in at compile time to produce different versions of the types or methods
    that work with particular types. One of the most important use cases for generics
    back when they were first introduced was to make it possible to write type-safe
    collection classes such as `List<T>`. We’ll look at some of these collection types
    in the next chapter.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型使我们能够编写带有类型参数的类型和方法，在编译时可以填充这些参数，从而生成适用于特定类型的不同版本的类型或方法。在它们首次引入时，泛型的最重要用例之一是使得编写类型安全的集合类成为可能，比如`List<T>`。我们将在下一章节中查看一些这样的集合类型。
- en: ^([1](ch04.xhtml#idm45884826015216-marker)) When saying the names of generic
    types, the convention is to use the word *of* as in “List of T” or “List of int.”
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch04.xhtml#idm45884826015216-marker)) 在说泛型类型名称时，惯例是使用“of”这个词，比如“List of
    T”或“List of int”。
- en: ^([2](ch04.xhtml#idm45884825181168-marker)) This is permitted even if you used
    the plain `class` constraint in an enabled nullable annotation context. The nullable
    references feature does not provide watertight guarantees of non-null-ness, so
    it permits comparison with `null`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch04.xhtml#idm45884825181168-marker)) 即使在启用了可空注解上下文中使用了普通的`class`约束，也是允许的。可空引用特性并不能完全保证非空性，因此允许与`null`进行比较。
- en: ^([3](ch04.xhtml#CHP-4-FN-1-marker)) Moq relies on the *dynamic proxy* feature
    from the Castle Project to generate this type. If you would like to use something
    similar in your code, you can find this at [the Castle Project](http://castleproject.org).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch04.xhtml#CHP-4-FN-1-marker)) Moq依赖于Castle项目的*动态代理*功能来生成这种类型。如果您想在您的代码中使用类似的东西，可以在[Castle项目](http://castleproject.org)找到它。
- en: ^([4](ch04.xhtml#idm45884824373280-marker)) Static interface members are not
    available in .NET Framework.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch04.xhtml#idm45884824373280-marker)) 静态接口成员在.NET Framework中不可用。
- en: ^([5](ch04.xhtml#idm45884824371344-marker)) A proposal exists for adding dynamic
    dispatch for static interface members. Although it is not officially part of C#
    10.0, the .NET 6.0 SDK includes a preview implementation. You can try it out by
    setting the `EnablePreviewFeatures` project property to true. If this becomes
    supported in a future version, perhaps we will see an `IAddable<T>`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch04.xhtml#idm45884824371344-marker)) 已经有一个提案用于为静态接口成员添加动态调度。尽管它不是官方的C#
    10.0的一部分，但.NET 6.0 SDK包含了一个预览实现。您可以通过将`EnablePreviewFeatures`项目属性设置为true来尝试它。如果在未来版本中得到支持，也许我们会看到一个`IAddable<T>`。
