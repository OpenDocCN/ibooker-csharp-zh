- en: Chapter 5\. .NET Overview
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章 .NET 概述
- en: Almost all of the capabilities of the .NET 8 runtime are exposed via a vast
    set of managed types. These types are organized into hierarchical namespaces and
    packaged into a set of assemblies.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有 .NET 8 运行时的功能都通过大量的托管类型暴露出来。这些类型按层次结构命名空间进行组织，并打包到一组程序集中。
- en: Some of the .NET types are used directly by the CLR and are essential for the
    managed hosting environment. These types reside in an assembly called *System.Private.CoreLib.dll*
    (*mscorlib.dll* in .NET Framework) and include C#’s built-in types as well as
    the basic collection classes, and types for stream processing, serialization,
    reflection, threading, and native interoperability.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 .NET 类型由 CLR 直接使用，并且对托管托管环境至关重要。这些类型位于一个名为 *System.Private.CoreLib.dll*（在
    .NET Framework 中为 *mscorlib.dll*）的程序集中，包括 C# 的内置类型以及基本的集合类、用于流处理、序列化、反射、线程处理和本地互操作的类型。
- en: At a level above this are additional types that “flesh out” the CLR-level functionality,
    providing features such as XML, JSON, networking, and Language-Integrated Query.
    These comprise the Base Class Library (BCL). Sitting above this are *application
    layers*, which provide APIs for developing particular kinds of applications such
    as web or rich client.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之上是补充类型，这些类型“丰富”了 CLR 级别的功能，提供 XML、JSON、网络和语言集成查询等功能。它们构成了基础类库（BCL）。在其上层是*应用程序层*，为开发特定类型的应用程序（如
    Web 或丰富客户端）提供 API。
- en: 'In this chapter, we provide the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们提供以下内容：
- en: An overview of the BCL (which we cover in the rest of the book)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书其余部分中会详细介绍 BCL 概述。
- en: A high-level summary of the application layers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序层的高级摘要
- en: Runtime Targets and TFMs
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时目标和 TFMs
- en: 'Within a project file, the `<TargetFramework>` element determines which runtime
    the project is built against (its *framework target* or *runtime target*) and
    is denoted by a *Target Framework Moniker* (TFM). Valid values include `net8.0`,
    `net7.0`, `net6.0`, `net5.0` (for .NET versions 8, 7, 6, and 5), `netcoreapp3.1`
    (for .NET Core 3.1), `net48` (for .NET Framework 4.8), and `netstandard2.0` (which
    we cover in the following section). For example, this is how you target .NET 8:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目文件中，`<TargetFramework>` 元素确定项目构建的运行时目标（其*框架目标*或*运行时目标*），并由*目标框架标识符*（TFM）表示。有效值包括
    `net8.0`、`net7.0`、`net6.0`、`net5.0`（用于 .NET 版本 8、7、6 和 5）、`netcoreapp3.1`（用于 .NET
    Core 3.1）、`net48`（用于 .NET Framework 4.8）和 `netstandard2.0`（我们将在接下来的部分中介绍）。例如，以下是如何针对
    .NET 8 进行目标设置的：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can target multiple runtimes by instead specifying a `<TargetFrameworks>`
    element (plural). Each TFM is separated by a semicolon:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过指定 `<TargetFrameworks>` 元素（复数形式）来针对多个运行时。每个 TFM 由分号分隔：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When you multitarget, the compiler generates a separate output assembly for
    each target.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当您进行多目标时，编译器会为每个目标生成单独的输出程序集。
- en: The runtime target is encoded into the output assembly via the `TargetFramework`
    attribute. An assembly can run on a newer (but not older) runtime than its target.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时目标通过 `TargetFramework` 属性编码到输出程序集中。一个程序集可以在比其目标更高的（但不是更低的）运行时上运行。
- en: .NET Standard
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Standard
- en: 'The wealth of public libraries that are available on NuGet wouldn’t be as valuable
    if they supported only .NET 8\. When writing a library, you’ll often want to support
    a variety of platforms and runtime versions. To achieve that goal without creating
    a separate build for each runtime (multitargeting), you must target the lowest
    common denominator. This is relatively easy if you wish to support only .NET 8’s
    direct predecessors: for example, if your project targets .NET 6 (`net6.0`), your
    library will run on .NET 6, .NET 7, and .NET 8.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 公共图书馆的丰富资源（位于 NuGet 上）如果只支持 .NET 8 将不会那么有价值。编写库时，通常需要支持多种平台和运行时版本。为了在不为每个运行时版本创建单独的构建（多目标）的情况下实现该目标，必须以最低公分母为目标。如果您的项目针对
    .NET 6 (`net6.0`)，则您的库将在 .NET 6、.NET 7 和 .NET 8 上运行。
- en: The situation becomes messier if you also want to support .NET Framework (or
    legacy runtimes such as Xamarin). The reason is that each of these runtimes has
    a CLR and BCL with overlapping features—no one runtime is a pure subset of the
    others.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还希望支持 .NET Framework（或 Xamarin 等旧版运行时），情况将变得更加混乱。原因是每个运行时都具有 CLR 和 BCL，其功能有重叠—没有一个运行时是其他运行时的纯子集。
- en: '*.NET Standard* solves this problem by defining artificial subsets that work
    across an entire range of runtimes. By targeting .NET Standard, you can easily
    write libraries with extensive reach.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*.NET Standard* 通过定义跨多个运行时工作的人工子集来解决此问题。通过针对 .NET Standard，您可以轻松编写具有广泛覆盖范围的库。'
- en: Note
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '.NET Standard is not a runtime; it’s merely a specification describing a minimum
    baseline of functionality (types and members) that guarantees compatibility with
    a certain set of runtimes. The concept is similar to C# interfaces: .NET Standard
    is like an interface that concrete types (runtimes) can implement.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Standard 不是运行时；它仅仅是描述一组运行时兼容性所需的最低基线功能（类型和成员）的规范。这个概念类似于 C# 接口：.NET Standard
    就像一个接口，具体类型（运行时）可以实现它。
- en: .NET Standard 2.0
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET Standard 2.0
- en: The most useful version is *.NET Standard 2.0*. A library that targets .NET
    Standard 2.0 instead of a specific runtime will run without modification on both
    modern .NET (.NET 8/7/6/5, down to .NET Core 2) and .NET Framework (4.6.1+). It
    also supports the legacy UWP (from 10.0.16299+) and Mono 5.4+ (the CLR/BCL used
    by older versions of Xamarin).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最有用的版本是 *.NET Standard 2.0*。一个针对 .NET Standard 2.0 而不是特定运行时的库将在现代 .NET（.NET
    8/7/6/5，以及 .NET Core 2 至 4.6.1+）和 .NET Framework（4.6.1+）上无需修改即可运行。它还支持传统的 UWP（从
    10.0.16299+ 开始）和 Mono 5.4+（老版本 Xamarin 使用的 CLR/BCL）。
- en: 'To target .NET Standard 2.0, add the following to your *.csproj* file:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要将目标设置为 .NET Standard 2.0，请将以下内容添加到您的 *.csproj* 文件中：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Most of the APIs described in this book are supported by .NET Standard 2.0 (and
    of those that are not, most are available as NuGet packages).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本书描述的大多数 API 都受 .NET Standard 2.0 的支持（那些不支持的大多数可以作为 NuGet 包提供）。
- en: Other .NET Standards
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他 .NET 标准
- en: 'NET Standard 2.1 is a superset of .NET Standard 2.0 that supports (only) the
    following platforms:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Standard 2.1 是 .NET Standard 2.0 的超集，仅支持以下平台：
- en: .NET Core 3+
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core 3+
- en: Mono 6.4+
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mono 6.4+
- en: .NET Standard 2.1 is not supported by any version of .NET Framework, making
    it much less useful than .NET Standard 2.0.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Standard 2.1 不受任何 .NET Framework 版本支持，因此比 .NET Standard 2.0 要不实用得多。
- en: There are also older .NET Standards such as 1.1, 1.2, 1.3, and 1.6, whose compatibility
    extends to archaic runtimes such as .NET Core 1.0 or .NET Framework 4.5\. The
    1.x standards lack thousands of APIs that are present in 2.0 (including much of
    what we describe in this book) and are effectively defunct.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 还有旧版的 .NET Standard，如 1.1、1.2、1.3 和 1.6，其兼容性延伸到古老的运行时，如 .NET Core 1.0 或 .NET
    Framework 4.5。1.x 标准缺少成千上万的 API，在 2.0 中都有（包括本书中描述的大部分内容），因此已基本废弃。
- en: .NET Framework and .NET 8 Compatibility
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET Framework 和 .NET 8 的兼容性
- en: 'Because .NET Framework has existed for so long, it’s not uncommon to encounter
    libraries that are available *only* for .NET Framework (with no .NET Standard,
    .NET Core, or .NET 8 equivalent). To help mitigate this situation, .NET 5+ and
    .NET Core projects are permitted to reference .NET Framework assemblies, with
    the following provisos:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 .NET Framework 存在时间很长，遇到仅适用于 .NET Framework（没有 .NET Standard、.NET Core 或
    .NET 8 等同等版本）的库并不罕见。为了帮助缓解这种情况，.NET 5+ 和 .NET Core 项目被允许引用 .NET Framework 程序集，但必须注意以下几点：
- en: An exception is thrown should the .NET Framework assembly call an API that’s
    unsupported.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 .NET Framework 程序集调用了不受支持的 API，则会抛出异常。
- en: Nontrivial dependencies might (and often do) fail to resolve.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂的依赖关系可能（并经常）无法解析。
- en: In practice, it’s most likely to work in simple cases, such as an assembly that
    wraps an unmanaged DLL.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，它最有可能在简单情况下起作用，例如包装非托管 DLL 的程序集。
- en: Reference Assemblies
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用程序集
- en: When you target .NET Standard, your project implicitly references an assembly
    called *netstandard.dll*, which contains all of the allowable types and members
    for your chosen version of .NET Standard. This is called a *reference assembly*
    because it exists only for the benefit of the compiler and contains no compiled
    code. At runtime, the “real” assemblies are identified through assembly redirection
    attributes (the choice of assemblies will depend on which runtime and platform
    the assembly eventually runs on).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当您目标 .NET Standard 时，您的项目隐式引用了一个名为 *netstandard.dll* 的程序集，其中包含您选择版本的 .NET Standard
    中允许的所有类型和成员。这称为 *引用程序集*，因为它仅存在于编译器的利益中，不包含任何编译代码。在运行时，通过程序集重定向属性来识别“真实”的程序集（选择的程序集取决于最终运行的运行时和平台）。
- en: Interestingly, a similar thing happens when you target .NET 8\. Your project
    implicitly references a set of reference assemblies whose types mirror what’s
    in the runtime assemblies for the chosen .NET version. This helps with versioning
    and cross-platform compatibility, and also allows you to target a different .NET
    version than what is installed on your machine.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，当您的目标是 .NET 8 时，您的项目隐式引用了一组引用程序集，其类型镜像了所选 .NET 版本的运行时程序集。这有助于版本控制和跨平台兼容性，并允许您将目标设置为与您的机器上安装的
    .NET 版本不同的 .NET 版本。
- en: Runtime and C# Language Versions
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时和C#语言版本
- en: 'By default, your project’s runtime target determines which C# language version
    is used:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，项目的运行时目标决定使用的C#语言版本：
- en: '| Runtime target | C# version |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 运行时目标 | C# 版本 |'
- en: '| --- | --- |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| .NET 8 | C# 12 |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| .NET 8 | C# 12 |'
- en: '| .NET 7 | C# 11 |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| .NET 7 | C# 11 |'
- en: '| .NET 6 | C# 10 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| .NET 6 | C# 10 |'
- en: '| .NET 5 | C# 9 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| .NET 5 | C# 9 |'
- en: '| .NET Core 3.x & 2.x | C# 8 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| .NET Core 3.x & 2.x | C# 8 |'
- en: '| .NET Framework | C# 7.3 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| .NET Framework | C# 7.3 |'
- en: '| .NET Standard 2.0 | C# 7.3 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| .NET Standard 2.0 | C# 7.3 |'
- en: This is because later versions of C# include features that rely on types that
    were introduced in later runtimes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为后续版本的C#包含依赖于后续运行时中引入的类型的功能。
- en: You can override the language version in your project file with the `<LangVersion>`
    element. Using an older runtime (such as .NET Framework) with a later language
    version (such as C# 12) means that the language features that rely on newer .NET
    types will not work (although in some cases, you can define those types yourself,
    or import them from a NuGet package).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过`<LangVersion>`元素在项目文件中覆盖语言版本。在使用较旧的运行时（如.NET Framework）和较新的语言版本（如C# 12）时，依赖于较新.NET类型的语言特性将不起作用（尽管在某些情况下，您可以自定义这些类型，或从NuGet包导入）。
- en: The CLR and BCL
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CLR和BCL
- en: 'Note to the indexer: Please skip everything in this section (apart from the
    Level 1 heading). Everything in this section is covered in more detail later in
    the book.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 索引器请注意：请跳过本节中的所有内容（除了一级标题）。本节的所有内容在书中的后续部分中有更详细的涵盖。
- en: System Types
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统类型
- en: The most fundamental types live directly in the `System` namespace. These include
    C#’s built-in types; the `Exception` base class; the `Enum`, `Array`, and `Delegate`
    base classes; and `Nullable`, `Type`, `DateTime`, `TimeSpan`, and `Guid`. The
    `System` namespace also includes types for performing mathematical functions (`Math`),
    generating random numbers (`Random`), and converting between various types (`Convert`
    and `BitConverter`).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的类型直接位于`System`命名空间中。这些包括C#内置类型；`Exception`基类；`Enum`、`Array`和`Delegate`基类；以及`Nullable`、`Type`、`DateTime`、`TimeSpan`和`Guid`。`System`命名空间还包括执行数学函数（`Math`）、生成随机数（`Random`）以及类型转换（`Convert`和`BitConverter`）的类型。
- en: '[Chapter 6](ch06.html#dotnet_fundamentals) describes these types as well as
    the interfaces that define standard protocols used across .NET for such tasks
    as formatting (`IFormattable`) and order comparison (`IComparable`).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[第6章](ch06.html#dotnet_fundamentals)还描述了这些类型，以及定义跨.NET用于格式化（`IFormattable`）和顺序比较（`IComparable`）等任务的标准协议的接口。'
- en: The `System` namespace also defines the `IDisposable` interface and the `GC`
    class for interacting with the garbage collector, which we cover in [Chapter 12](ch12.html#disposal_and_garbage_collection).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`System`命名空间还定义了与垃圾回收器交互的`IDisposable`接口和`GC`类，我们在[第12章](ch12.html#disposal_and_garbage_collection)中进行了详细讨论。'
- en: Text Processing
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本处理
- en: The `System.Text` namespace contains the `StringBuilder` class (the editable
    or *mutable* cousin of `string`) and the types for working with text encodings,
    such as UTF-8 (`Encoding` and its subtypes). We cover this in [Chapter 6](ch06.html#dotnet_fundamentals).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Text`命名空间包含`StringBuilder`类（`string`的可编辑或*可变*版本）以及用于处理文本编码（如UTF-8的`Encoding`及其子类型）的类型。我们在[第6章](ch06.html#dotnet_fundamentals)中进行了详细介绍。'
- en: The `System.Text.RegularExpressions` namespace contains types that perform advanced
    pattern-based search-and-replace operations; we describe these in [Chapter 25](ch25.html#regular_expressions-id00102).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Text.RegularExpressions`命名空间包含执行高级基于模式的搜索和替换操作的类型；我们在[第25章](ch25.html#regular_expressions-id00102)中描述了这些功能。'
- en: Collections
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: '.NET offers a variety of classes for managing collections of items. These include
    both list- and dictionary-based structures; they work in conjunction with a set
    of standard interfaces that unify their common characteristics. All collection
    types are defined in the following namespaces, covered in [Chapter 7](ch07.html#collections-id00055):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: .NET提供了多种用于管理项集合的类。这些包括基于列表和字典的结构；它们与一组标准接口结合工作，统一它们的共同特征。所有集合类型均定义在以下命名空间中，我们在[第7章](ch07.html#collections-id00055)中进行了涵盖：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Querying
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询
- en: 'Language-Integrated Query (LINQ) allows you to perform type-safe queries over
    local and remote collections (e.g., SQL Server tables) and is described in Chapters
    [8](ch08.html#linq_queries), [9](ch09.html#linq_operators), and [10](ch10.html#linq_to_xml).
    A big advantage of LINQ is that it presents a consistent querying API across a
    variety of domains. The essential types reside in the following namespaces:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 语言集成查询（LINQ）允许您在本地和远程集合（例如SQL Server表）上执行类型安全的查询，详细介绍见第[8章](ch08.html#linq_queries)、[9章](ch09.html#linq_operators)和[10章](ch10.html#linq_to_xml)。LINQ的一个重要优势是它在各种领域提供了一致的查询API。关键类型位于以下命名空间中：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: XML and JSON
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XML和JSON
- en: 'XML and JSON are widely supported in .NET. [Chapter 10](ch10.html#linq_to_xml)
    focuses entirely on LINQ to XML—a lightweight XML Document Object Model (DOM)
    that can be constructed and queried through LINQ. [Chapter 11](ch11.html#other_xml_and_json_technologies)
    covers the performant low-level XML reader/writer classes, XML schemas and stylesheets,
    and types for working with JSON:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: XML和JSON在.NET中得到了广泛支持。[第10章](ch10.html#linq_to_xml)专注于LINQ to XML——一种轻量级的XML文档对象模型（DOM），可以通过LINQ构建和查询。[第11章](ch11.html#other_xml_and_json_technologies)涵盖了高性能的低级XML读取器/写入器类、XML模式和样式表，以及处理JSON的类型：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the online supplement at [*http://www.albahari.com/nutshell*](http://www.albahari.com/nutshell),
    we cover the JSON serializer.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在在线补充材料中[*http://www.albahari.com/nutshell*](http://www.albahari.com/nutshell)，我们讨论了JSON序列化器。
- en: Diagnostics
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 诊断
- en: In [Chapter 13](ch13.html#diagnostic), we cover logging and assertion and describe
    how to interact with other processes, write to the Windows event log, and handle
    performance monitoring. The types for this are defined in and under `System.Diagnostics`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第13章](ch13.html#diagnostic)中，我们涵盖了日志记录和断言，并描述了如何与其他进程交互，写入Windows事件日志以及处理性能监控。相关类型在`System.Diagnostics`中定义和使用。
- en: Concurrency and Asynchrony
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发与异步
- en: Many modern applications need to deal with more than one thing happening at
    a time. Since C# 5.0, this has become easier through asynchronous functions and
    high-level constructs such as tasks and task combinators. [Chapter 14](ch14.html#concurrency_and_asynchron)
    explains all of this in detail, after starting with the basics of multithreading.
    Types for working with threads and asynchronous operations are in the `System.Threading`
    and `System.Threading.Tasks` namespaces.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代应用程序需要同时处理多个事务。自C# 5.0以来，通过异步函数和任务等高级结构变得更加容易。[第14章](ch14.html#concurrency_and_asynchron)详细解释了这些内容，从多线程基础开始讲起。与线程和异步操作相关的类型位于`System.Threading`和`System.Threading.Tasks`命名空间中。
- en: Streams and Input/Output
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流和输入/输出
- en: .NET provides a stream-based model for low-level input/output (I/O). Streams
    are typically used to read and write directly to files and network connections,
    and can be chained or wrapped in decorator streams to add compression or encryption
    functionality. [Chapter 15](ch15.html#streams_and_isoliduso) describes the stream
    architecture as well as the specific support for working with files and directories,
    compression, pipes, and memory-mapped files. The `Stream` and I/O types are defined
    in and under the `System.IO` namespace.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: .NET提供了基于流的低级输入/输出（I/O）模型。流通常用于直接读写文件和网络连接，并且可以通过链式或包装流添加压缩或加密功能。[第15章](ch15.html#streams_and_isoliduso)描述了流架构以及特定支持文件和目录处理、压缩、管道和内存映射文件的I/O。`Stream`和I/O类型在`System.IO`命名空间中定义。
- en: Networking
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络
- en: 'You can directly access most standard network protocols such as HTTP, TCP/IP,
    and SMTP via the types in `System.Net`. In [Chapter 16](ch16.html#networking-id00041),
    we demonstrate how to communicate using each of these protocols, starting with
    simple tasks such as downloading from a web page and finishing with using TCP/IP
    directly to retrieve POP3 email. Here are the namespaces we cover:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`System.Net`中的类型，您可以直接访问大多数标准网络协议，如HTTP、TCP/IP和SMTP。在[第16章](ch16.html#networking-id00041)中，我们展示了如何使用每个协议进行通信，从简单的任务如从网页下载开始，到直接使用TCP/IP检索POP3电子邮件为止。以下是我们涵盖的命名空间：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Assemblies, Reflection, and Attributes
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序集、反射和属性
- en: The assemblies into which C# programs compile comprise executable instructions
    (stored as IL) and metadata, which describes the program’s types, members, and
    attributes. Through reflection, you can inspect this metadata at runtime and do
    such things as dynamically invoke methods. With `Reflection.Emit`, you can construct
    new code on the fly.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: C#程序编译生成的程序集包含可执行指令（存储为IL）和元数据，描述程序的类型、成员和属性。通过反射，您可以在运行时检查这些元数据，并动态调用方法。使用`Reflection.Emit`，您可以动态生成新的代码。
- en: 'In [Chapter 17](ch17.html#assemblies), we describe the makeup of assemblies
    and how to dynamically load and isolate them. In [Chapter 18](ch18.html#reflection_and_metadata),
    we cover reflection and attributes—describing how to inspect metadata, dynamically
    invoke functions, write custom attributes, emit new types, and parse raw IL. The
    types for using reflection and working with assemblies reside in the following
    namespaces:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第17章](ch17.html#assemblies)中，我们描述了程序集的组成及如何动态加载和隔离它们。在[第18章](ch18.html#reflection_and_metadata)中，我们涵盖了反射和属性，描述了如何检查元数据、动态调用函数、编写自定义属性、生成新类型以及解析原始IL。用于反射和处理程序集的类型位于以下命名空间中：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Dynamic Programming
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态规划
- en: In [Chapter 19](ch19.html#dynamic_programming), we look at some of the patterns
    for dynamic programming and utilizing the Dynamic Language Runtime (DLR). We describe
    how to implement the *Visitor* pattern, write custom dynamic objects, and interoperate
    with IronPython. The types for dynamic programming are in `System.Dynamic`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第19章](ch19.html#dynamic_programming)中，我们研究了一些动态编程模式，并利用了动态语言运行时（DLR）。我们描述了如何实现*Visitor*模式、编写自定义动态对象以及与IronPython进行互操作。动态编程的类型位于`System.Dynamic`中。
- en: Cryptography
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密码学
- en: '.NET provides extensive support for popular hashing and encryption protocols.
    In [Chapter 20](ch20.html#cryptography-id00013), we cover hashing, symmetric and
    public-key encryption, and the Windows Data Protection API. The types for this
    are defined in:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: .NET为流行的哈希和加密协议提供了广泛的支持。在[第20章](ch20.html#cryptography-id00013)，我们涵盖了哈希、对称和公钥加密以及Windows数据保护API。这些类型的定义如下：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Advanced Threading
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级线程
- en: C#’s asynchronous functions make concurrent programming significantly easier
    because they lessen the need for lower-level techniques. However, there are still
    times when you need signaling constructs, thread-local storage, reader/writer
    locks, and so on. [Chapter 21](ch21.html#advanced_threadin) explains this in depth.
    Threading types are in the `System.Threading` namespace.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: C#的异步函数显著简化了并发编程，因为它们减少了对低级技术的需求。然而，在某些情况下，仍然需要信号构造、线程本地存储、读者/写者锁等。[第21章](ch21.html#advanced_threadin)深入解释了这些内容。线程类型位于`System.Threading`命名空间中。
- en: Parallel Programming
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行编程
- en: In [Chapter 22](ch22.html#parallel_programming-id00071), we cover in detail
    the libraries and types for leveraging multicore processors, including APIs for
    task parallelism, imperative data parallelism, and functional parallelism (PLINQ).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第22章](ch22.html#parallel_programming-id00071)，我们详细介绍了利用多核处理器的库和类型，包括任务并行性的API、命令式数据并行性以及函数并行性（PLINQ）。
- en: Span<T> and Memory<T>
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Span<T>`和`Memory<T>`'
- en: To help with micro-optimizing performance hotspots, the CLR provides a number
    of types to help you program in such a way as to reduce the load on the memory
    manager. Two of the key types are `Span<T>` and `Memory<T>`, which we describe
    in [Chapter 23](ch23.html#spanless_thantgreater_than_and-id00089).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助微调性能热点，CLR提供了许多类型，帮助您以减少内存管理器负担的方式编程。其中两个关键类型是`Span<T>`和`Memory<T>`，我们在[第23章](ch23.html#spanless_thantgreater_than_and-id00089)中进行了介绍。
- en: Native and COM Interoperability
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地和COM互操作性
- en: You can interoperate with both native and Component Object Model (COM) code.
    Native interoperability allows you to call functions in unmanaged DLLs, register
    callbacks, map data structures, and interoperate with native data types. COM interoperability
    allows you to call COM types (on Windows machines) and expose .NET types to COM.
    The types that support these functions are in `System.Runtime.InteropServices`,
    and we cover them in [Chapter 24](ch24.html#native_and_com_interoperabilit).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以与本地代码和组件对象模型（COM）代码进行互操作。本地互操作性允许您调用未管理的DLL中的函数，注册回调，映射数据结构，并与本地数据类型进行互操作。COM互操作性允许您调用COM类型（在Windows机器上）并将.NET类型暴露给COM。支持这些功能的类型位于`System.Runtime.InteropServices`中，我们在[第24章](ch24.html#native_and_com_interoperabilit)中进行了详细介绍。
- en: Regular Expressions
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则表达式
- en: In [Chapter 25](ch25.html#regular_expressions-id00102), we cover how you can
    use regular expressions to match character patterns in strings.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 25 章](ch25.html#regular_expressions-id00102)，我们讨论了如何使用正则表达式在字符串中匹配字符模式。
- en: Serialization
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列化
- en: '.NET providers several systems for saving and restoring objects to a binary
    or text representation. Such systems can be used for communication as well as
    saving and restoring objects to a file. In the online supplement at [*http://www.albahari.com/nutshell*](http://www.albahari.com/nutshell),
    we cover all four serialization engines: the binary serializer, the (newly updated)
    JSON serializer, the XML serializer, and the data contract serializer.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 提供了多个系统，用于将对象保存和恢复为二进制或文本表示。这些系统可用于通信以及将对象保存和恢复为文件。在在线补充资料[*http://www.albahari.com/nutshell*](http://www.albahari.com/nutshell)，我们涵盖了所有四个序列化引擎：二进制序列化器，（新更新的）JSON
    序列化器，XML 序列化器和数据合同序列化器。
- en: The Roslyn Compiler
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Roslyn 编译器
- en: The C# compiler itself is written in C#—the project is called “Roslyn,” and
    the libraries are available as NuGet packages. With these libraries, you can utilize
    the compiler’s functionality in many ways besides compiling source code to an
    assembly, such as writing code analysis and refactoring tools. We cover Roslyn
    in the online supplement, at [*http://www.albahari.com/nutshell*](http://www.albahari.com/nutshell).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: C# 编译器本身是用 C# 编写的 —— 这个项目称为“Roslyn”，并且这些库可以作为 NuGet 包提供。利用这些库，您可以以多种方式使用编译器的功能，例如编写代码分析和重构工具。我们在在线补充资料中介绍了
    Roslyn，网址为[*http://www.albahari.com/nutshell*](http://www.albahari.com/nutshell)。
- en: Application Layers
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序层
- en: 'User interface (UI)–based applications can be divided into two categories:
    *thin client*, which amounts to a website, and *rich client*, which is a program
    the end user must download and install on a computer or mobile device.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面（UI）应用程序可以分为两类：*轻客户端*，相当于网站，和*丰富客户端*，用户必须在计算机或移动设备上下载和安装的程序。
- en: For writing thin-client applications in C#, there’s ASP.NET Core, which runs
    on Windows, Linux, and macOS. ASP.NET Core is also designed for writing web APIs.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 C# 中编写轻客户端应用程序，可以使用 ASP.NET Core，在 Windows、Linux 和 macOS 上运行。ASP.NET Core
    还专为编写 Web API 而设计。
- en: 'For rich-client applications, there is a choice of APIs:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于丰富客户端应用程序，有多种 API 可供选择：
- en: The Windows Desktop layer includes the popular WPF and Windows Forms APIs, and
    runs on Windows 7/8/10/11 desktop.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 桌面层包括流行的 WPF 和 Windows Forms API，在 Windows 7/8/10/11 桌面上运行。
- en: WinUI 3 (Windows App SDK) is a successor to UWP that runs (only) on Windows
    10+ desktop.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WinUI 3（Windows App SDK）是 UWP 的继任者，仅在 Windows 10+ 桌面上运行。
- en: UWP lets you write Windows Store apps that run on Windows 10+ desktop and devices
    such as Xbox or HoloLens.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UWP 允许您编写运行在 Windows 10+ 桌面以及 Xbox 或 HoloLens 等设备上的 Windows Store 应用程序。
- en: MAUI (formerly Xamarin) runs on iOS and Android mobile devices. MAUI also allows
    for cross-platform desktop applications that target macOS (via Catalyst) and Windows
    (via Windows App SDK).
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MAUI（前身为 Xamarin）运行在 iOS 和 Android 移动设备上。MAUI 还允许跨平台桌面应用程序，目标是 macOS（通过 Catalyst）和
    Windows（通过 Windows App SDK）。
- en: There are also third-party cross-platform UI libraries such as Avalonia. Unlike
    MAUI, Avalonia also runs on Linux and does not rely on a Catalyst/WinUI indirection
    layer for desktop platforms, simplifying development and debugging.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 还有第三方跨平台 UI 库，如 Avalonia。与 MAUI 不同，Avalonia 还可以在 Linux 上运行，并且不依赖于 Catalyst/WinUI
    间接层用于桌面平台，简化了开发和调试。
- en: ASP.NET Core
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ASP.NET Core
- en: 'ASP.NET Core is a lightweight modular successor to ASP.NET and is suitable
    for creating web sites, REST-based web APIs, and microservices. It can also run
    in conjunction with two popular single-page-application frameworks: React and
    Angular.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 是 ASP.NET 的轻量模块化后继者，适用于创建网站、基于 REST 的 Web API 和微服务。它还可以与两个流行的单页应用程序框架一起运行：React
    和 Angular。
- en: ASP.NET supports the popular *Model-View-Controller* (MVC) pattern, as well
    as a newer technology called Blazor, where client-side code is written in C# instead
    of JavaScript.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET 支持流行的*模型-视图-控制器*（MVC）模式，以及一种名为 Blazor 的新技术，在其中客户端代码用 C# 编写而不是 JavaScript。
- en: ASP.NET Core runs on Windows, Linux, and macOS and can self-host in a custom
    process. Unlike its .NET Framework predecessor (ASP.NET), ASP.NET Core is not
    dependent on `System.Web` and the historical baggage of web forms.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 在 Windows、Linux 和 macOS 上运行，并且可以自托管在自定义进程中。与其 .NET Framework 前身（ASP.NET）不同，ASP.NET
    Core 不依赖于 `System.Web` 和 Web Forms 的历史包袱。
- en: 'As with any thin-client architecture, ASP.NET Core offers the following general
    advantages over rich clients:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何轻客户端架构一样，ASP.NET Core 相对于丰富客户端提供以下一般优势：
- en: There is zero deployment at the client end.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端端没有零部署。
- en: The client can run on any platform that supports a web browser.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端可以在支持Web浏览器的任何平台上运行。
- en: Updates are easily deployed.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新可以轻松部署。
- en: Windows Desktop
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows桌面
- en: 'The Windows Desktop application layer offers a choice of two UI APIs for writing
    rich-client applications: WPF and Windows Forms. Both APIs run on Windows Desktop/Server
    7 through 11.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Windows桌面应用层提供了两种UI API选择，用于编写丰富客户端应用程序：WPF和Windows Forms。这两种API都可以在Windows桌面/服务器7到11上运行。
- en: WPF
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WPF
- en: 'WPF was introduced in 2006, and has been enhanced ever since. Unlike its predecessor,
    Windows Forms, WPF explicitly renders controls using DirectX, with the following
    benefits:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: WPF于2006年推出，并且自那时以来一直在增强。与其前身Windows Forms不同，WPF明确使用DirectX渲染控件，带来以下好处：
- en: It supports sophisticated graphics, such as arbitrary transformations, 3D rendering,
    multimedia, and true transparency. Skinning is supported through styles and templates.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持复杂的图形，如任意变换、3D渲染、多媒体和真正的透明度。通过样式和模板支持皮肤定制。
- en: Its primary measurement unit is not pixel based, so applications display correctly
    at any DPI setting.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其主要测量单位不是基于像素的，因此应用程序可以在任何DPI设置下正确显示。
- en: It has extensive and flexible layout support, which means that you can localize
    an application without danger of elements overlapping.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有广泛和灵活的布局支持，这意味着可以本地化应用程序而无需担心元素重叠的问题。
- en: Its use of DirectX makes rendering fast and able to take advantage of graphics
    hardware acceleration.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其使用DirectX使得渲染快速，并能利用图形硬件加速。
- en: It offers reliable data binding.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供可靠的数据绑定。
- en: UIs can be described declaratively in XAML files that can be maintained independent
    of the “code-behind” files—this helps to separate appearance from functionality.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在XAML文件中声明性地描述UI，这些文件可以独立于“代码后台”文件进行维护，有助于将外观与功能分离。
- en: WPF takes some time to learn due to its size and complexity. The types for writing
    WPF applications are in the `System.Windows` namespace and all subnamespaces except
    for `System.Windows.Forms`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其规模和复杂性，学习WPF需要一些时间。用于编写WPF应用程序的类型位于`System.Windows`命名空间及其所有子命名空间中，除了`System.Windows.Forms`。
- en: Windows Forms
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows Forms
- en: 'Windows Forms is a rich-client API that shipped with the first version of .NET
    Framework in 2000\. Compared to WPF, Windows Forms is a relatively simple technology
    that provides most of the features you need in writing a typical Windows application.
    It also has significant relevancy in maintaining legacy applications. But compared
    to WPF, it has numerous drawbacks, most of which stem from it being a wrapper
    over GDI+ and the Win32 control library:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Windows Forms是一个富客户端API，随着2000年第一个.NET Framework版本一同发布。与WPF相比，Windows Forms是一种相对简单的技术，提供了编写典型Windows应用程序所需的大多数功能。它在维护遗留应用程序方面也具有重要意义。但与WPF相比，它有许多缺点，大部分源于其作为GDI+和Win32控件库包装器的特性：
- en: Although Windows Forms provides mechanisms for DPI-awareness, it’s still too
    easy to write applications that break on clients whose DPI settings differ from
    the developer’s.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然Windows Forms提供了DPI感知机制，但仍然很容易编写在客户端DPI设置与开发者不同的应用程序，从而导致应用程序崩溃。
- en: The API for drawing nonstandard controls is GDI+, which, although reasonably
    flexible, is slow in rendering large areas (and without double buffering, might
    flicker).
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于绘制非标准控件的API是GDI+，虽然相对灵活，但在渲染大面积时速度较慢（并且没有双缓冲，可能会闪烁）。
- en: Controls lack true transparency.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控件缺乏真正的透明度。
- en: Most controls are noncompositional. For instance, you can’t put an image control
    inside a tab control header. Customizing list views, combo boxes, and tab controls
    in a way that would be trivial with WPF is time consuming and painful in Windows
    Forms.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数控件都是非组合的。例如，您不能将图像控件放在选项卡控件标题中。在Windows Forms中以一种对WPF来说微不足道的方式自定义列表视图、组合框和选项卡控件是耗时且痛苦的。
- en: Dynamic layout is difficult to correctly implement reliably.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态布局很难正确可靠地实现。
- en: The last point is an excellent reason to favor WPF over Windows Forms—even if
    you’re writing a business application that needs just a UI and not a “user experience.”
    The layout elements in WPF, such as `Grid`, make it easy to assemble labels and
    text boxes such that they always align—even after language-changing localization—without
    messy logic and without any flickering. Further, you don’t need to bow to the
    lowest common denominator in screen resolution—WPF layout elements have been designed
    from the outset to adapt properly to resizing.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点是支持 WPF 而不是 Windows Forms 的绝佳理由，即使你只编写需要 UI 而不是“用户体验”的业务应用程序。WPF 中的布局元素，如
    `Grid`，使得组合标签和文本框变得简单，即使在语言更改后的本地化中，它们始终对齐，无需混乱的逻辑和任何闪烁。此外，你不需要迎合屏幕分辨率的最低公分母——WPF
    布局元素从一开始就被设计为能够正确调整大小。
- en: On the positive side, Windows Forms is relatively simple to learn and still
    has a good number of third-party controls.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正面看，Windows Forms 相对简单易学且仍有大量第三方控件。
- en: The Windows Forms types are in the `System.Windows.Forms` (in *System.Windows.Forms.dll*)
    and `System.Drawing` (in *System.Drawing.dll*) namespaces. The latter also contains
    the GDI+ types for drawing custom controls.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Windows Forms 类型位于 `System.Windows.Forms`（在 *System.Windows.Forms.dll* 中）和 `System.Drawing`（在
    *System.Drawing.dll* 中）命名空间中。后者还包含用于绘制自定义控件的 GDI+ 类型。
- en: UWP and WinUI 3
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UWP 和 WinUI 3
- en: UWP is a rich-client API for writing touch-first UIs that target Windows 10+
    desktop and devices. The word “Universal” refers to its ability to run on a range
    of Windows 10 devices, including Xbox, Surface Hub, HoloLens, and (at the time)
    Windows Phone.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: UWP 是为编写面向触摸优先的 UI 的富客户端 API，目标是 Windows 10+ 桌面和设备。词汇“Universal”指其能够在一系列 Windows
    10 设备上运行，包括 Xbox、Surface Hub、HoloLens 和（当时）Windows Phone。
- en: 'The UWP API uses XAML and is somewhat similar to WPF. Here are its key differences:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: UWP API 使用 XAML 并且在某种程度上类似于 WPF。以下是其主要区别：
- en: The primary mode of distribution for UWP apps is the Windows Store.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UWP 应用程序的主要分发模式是 Windows Store。
- en: UWP apps run in a sandbox to lessen the threat of malware, which means that
    they cannot perform tasks such as reading or writing arbitrary files, and they
    cannot run with administrative elevation.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UWP 应用程序在沙盒中运行，以减少恶意软件的威胁，这意味着它们不能执行诸如读取或写入任意文件之类的任务，并且不能以管理员权限运行。
- en: UWP relies on WinRT types that are part of the operating system (Windows), not
    the managed runtime. This means that when writing apps, you must nominate a Windows
    *version range* (such as Windows 10 build 17763 to Windows 10 build 18362). This
    means that you either need to target an old API or require that your customers
    install the latest Windows update.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UWP 依赖于操作系统（Windows）中的 WinRT 类型，而不是托管运行时。这意味着在编写应用程序时，你必须指定一个 Windows *版本范围*（例如
    Windows 10 版本 17763 到 Windows 10 版本 18362）。这意味着你必须要么针对旧的 API，要么要求客户安装最新的 Windows
    更新。
- en: Because of the limitations created by these differences, UWP never succeeded
    in matching the popularity of WPF and Windows Forms. To address this, Microsoft
    has morphed UWP into a new technology called Windows App SDK (with a UI layer
    called WinUI 3).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些差异所带来的限制，UWP 从未成功地匹配 WPF 和 Windows Forms 的流行度。为了解决这个问题，Microsoft 将 UWP 转变为一种名为
    Windows App SDK 的新技术（具有称为 WinUI 3 的 UI 层）。
- en: 'The Windows App SDK transfers the WinRT APIs from the operating system to the
    runtime, thereby exposing a fully managed interface and removing the necessity
    to target a specific operating system version range. It also does the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Windows App SDK 将 WinRT API 从操作系统传输到运行时，从而暴露出完全托管的接口，并且不需要针对特定操作系统版本范围进行目标设定。它还执行以下操作：
- en: Integrates better with the Windows Desktop APIs (Windows Forms and WPF)
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Windows 桌面 API（Windows Forms 和 WPF）更好地集成
- en: Allows you to write applications that run outside the Windows Store sandbox
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许你编写在 Windows Store 沙箱之外运行的应用程序
- en: Runs atop the latest .NET (instead of being tied to .NET Core 2.2, as is the
    case with UWP)
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行在最新的 .NET 之上（而不是像 UWP 那样绑定于 .NET Core 2.2）
- en: Despite these improvements, WinUI 3 hasn’t gained the widespread popularity
    of the classic Windows Desktop APIs. Windows App SDK also does not support Xbox
    or HoloLens at the time of writing, and requires a separate end-user download.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有这些改进，WinUI 3 在经典 Windows 桌面 API 中并没有获得广泛的流行。截至撰写本文时，Windows App SDK 也不支持
    Xbox 或 HoloLens，并且需要单独的最终用户下载。
- en: MAUI
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MAUI
- en: MAUI (formerly Xamarin) lets you develop mobile apps in C# that target iOS and
    Android (as well as cross-platform desktop apps that target macOS and Windows
    via Catalyst and Windows App SDK).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: MAUI（前身为Xamarin）允许您使用C#开发针对iOS和Android的移动应用（以及通过Catalyst和Windows App SDK针对macOS和Windows的跨平台桌面应用）。
- en: The CLR/BCL that runs on iOS and Android is called Mono (a derivation of the
    open-source Mono runtime). Historically, Mono hasn’t been fully compatible with
    .NET, and libraries that ran on both Mono and .NET would target .NET Standard.
    From .NET 6, however, Mono’s public interface merged with .NET, making Mono, in
    effect, an *implementation* of .NET.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 运行在iOS和Android上的CLR/BCL被称为Mono（开源Mono运行时的一个派生）。历史上，Mono与.NET并不完全兼容，能在Mono和.NET上运行的库通常会选择目标为.NET
    Standard。然而，从.NET 6开始，Mono的公共接口与.NET合并，使得Mono实际上成为了.NET的一个*实现*。
- en: MAUI includes a unified project interface, hot reloading, and support for Blazor
    Desktop and hybrid apps. See [*https://github.com/dotnet/maui*](https://github.com/dotnet/maui)
    for more information.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: MAUI包括统一的项目接口、热重载功能，以及对Blazor桌面和混合应用的支持。详细信息请参阅[*https://github.com/dotnet/maui*](https://github.com/dotnet/maui)。
