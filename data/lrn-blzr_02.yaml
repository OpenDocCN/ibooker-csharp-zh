- en: Chapter 1\. Blazing into Blazor
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 闪耀进入Blazor
- en: Node.js reshaped the world of modern web app development. Its success is attributed
    in part to the popularity of JavaScript, of course. JavaScript now runs on both
    the client and the server alike, thanks to Node. This is why Blazor will be so
    successful—C# is now capable of running in the browser with WebAssembly. To .NET
    developers, there is a huge potential because there are a great many C# server
    apps in existence today. There are many opportunities for .NET developers to create
    amazing user experiences with Blazor.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js重塑了现代Web应用程序开发的世界。它的成功部分归功于JavaScript的流行，当然还有JavaScript现在在客户端和服务器上的运行，这都要归功于Node。这也是为什么Blazor会如此成功——现在使用WebAssembly，C#可以在浏览器中运行。对于.NET开发者来说，这是一个巨大的潜力，因为今天已经存在许多C#服务器应用程序。对于.NET开发者来说，有很多机会使用Blazor创建令人惊叹的用户体验。
- en: For the first time, .NET developers can use their existing C# skills to build
    all sorts of apps on the web. This blurs the lines between backend and frontend
    developers and expands app development for the web. With modern web app development,
    you want your apps to be responsive on both desktop and mobile browsers. Modern
    web apps are much more sophisticated and rich in content than their predecessors
    and boast real-time web functionality, progressive web app (PWA) capabilities,
    and beautifully orchestrated user interactions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次，.NET开发者可以利用他们现有的C#技能来构建各种Web应用程序。这模糊了后端和前端开发者之间的界限，并扩展了Web应用程序的开发。在现代Web应用程序开发中，您希望您的应用程序在桌面和移动浏览器上都具有响应性。现代Web应用程序比其前身更加复杂和内容丰富，并拥有实时Web功能、渐进式Web应用（PWA）功能以及精美编排的用户交互。
- en: In this chapter, you’ll learn about the origins of .NET web app development
    and the birth of Blazor. You’ll explore the variations of single-page application
    (SPA) frameworks and see how .NET solidified its place in the web ecosystem. I’ll
    answer many of the questions you may have about *why* Blazor is a viable option
    and discuss its hosting models. Finally, you’ll get your first look at the Learning
    Blazor sample application. This sample application will be used throughout the
    book, with each chapter demonstrating various features of Blazor and using the
    app to follow along.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解.NET Web应用程序开发的起源以及Blazor的诞生。您将探索单页应用程序（SPA）框架的变体，并了解.NET如何在Web生态系统中巩固其地位。我将回答您可能会有的许多关于*为什么*Blazor是一个可行选项的问题，并讨论其托管模型。最后，您将首次了解Learning
    Blazor示例应用程序。本书将使用此示例应用程序，在每章中演示Blazor的各种功能并使用该应用程序进行跟随学习。
- en: The Origin of Blazor
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Blazor的起源
- en: In 1996, Active Server Pages (ASP) from Microsoft offered the first server-side
    scripting language and engine for dynamic web pages. As .NET Framework evolved,
    ASP.NET was born, and with it emerged ASP.NET Web Forms (WebForms). WebForms was
    (and still is) used by many who enjoy what .NET was capable of.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 1996年，微软的Active Server Pages（ASP）首次提供了用于动态Web页面的服务器端脚本语言和引擎。随着.NET Framework的发展，诞生了ASP.NET，并随之出现了ASP.NET
    Web Forms（WebForms）。WebForms被许多人使用，他们享受.NET所能实现的一切。
- en: When ASP.NET Model View Controller (MVC) was first released in 2006, it made
    WebForms look sluggish in comparison. MVC brought ASP.NET developers closer to
    less-abstracted web development. By having a closer alignment to web standards,
    MVC introduced the model-view-controller pattern of ASP.NET, which helped to address
    the issue of managing ASP.NET post-back state. At the time, this was a sore point
    in the developer community. Developers didn’t like the fact that WebForms carried
    the additional state for all the controls on the page along with `<form>` post
    data. WebForms fabricated statefulness with View State and other state mechanisms
    that contradicted the nature of HTTP. MVC focused on testability, emphasizing
    to developers the importance of sustainability. This was a paradigm shift from
    WebForms.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当ASP.NET模型视图控制器（MVC）于2006年首次发布时，它使WebForms显得迟缓。MVC使ASP.NET开发者更接近少抽象的Web开发。通过更接近Web标准，MVC引入了ASP.NET的模型-视图-控制器模式，帮助解决了管理ASP.NET后台状态的问题。当时，这是开发者社区的一大痛点。开发者不喜欢WebForms为页面上所有控件以及`<form>`提交数据带来的额外状态。WebForms通过ViewState和其他状态机制制造了状态保持，这与HTTP的本质相矛盾。MVC专注于可测试性，强调开发的可持续性。这是从WebForms到MVC的范式转变。
- en: In 2010, the Razor view engine was introduced to serve as one of several view
    engine options to use with ASP.NET MVC. Razor is a markup syntax that melds HTML
    and C# and is used for templating. As a side-product of MVC, ASP.NET Web API grew
    in popularity, and developers embraced the power of .NET. Web API started being
    accepted as the standard for building .NET-based HTTP services. All the while,
    the Razor view engine was evolving, strengthening, and maturing.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 2010年，Razor视图引擎被引入作为ASP.NET MVC中多种视图引擎选项之一。Razor是一种将HTML和C#融合的标记语法，用于模板化。作为MVC的附带产品，ASP.NET
    Web API因其强大的功能而受到欢迎，开发者们也开始接受将其作为构建基于.NET的HTTP服务的标准。与此同时，Razor视图引擎在演化、加强和成熟。
- en: Eventually, with the Razor view engine using MVC as a basis, Razor Pages took
    to the stage. Innovations from ASP.NET Core made a lot of this possible. The team’s
    eager push for *performance as a feature* is evident with the [TechEmpower benchmark
    results](https://oreil.ly/Ff8lV), where ASP.NET Core continues to climb ahead.
    Kestrel is the cross-platform web server that’s included and enabled by default
    in ASP.NET Core project templates. It’s one of the fastest web servers in existence
    as of 2022—capable of serving more than 4 million requests per second.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，基于MVC作为基础的Razor视图引擎进入了舞台。ASP.NET Core的创新使这一切成为可能。团队对*性能作为特性*的迫切推动在[TechEmpower基准结果](https://oreil.ly/Ff8lV)中可见，ASP.NET
    Core继续领先。Kestrel是跨平台的Web服务器，已默认包含在ASP.NET Core项目模板中。截至2022年，它是目前速度最快的Web服务器之一，能够每秒处理超过400万次请求。
- en: ASP.NET Core offers first-class citizenship to all of the fundamentals you’d
    expect in modern development, such as (but not limited to) dependency injection,
    strongly typed configurations, feature-rich logging, localization, authentication,
    authorization, and hosting. Razor Pages lean more toward true components and build
    on Web API infrastructure.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core为现代开发中所期望的所有基本要素（但不限于依赖注入、强类型配置、功能丰富的日志记录、本地化、身份验证、授权和托管）提供了一流的支持。Razor页面更加倾向于真正的组件，并构建在Web
    API基础设施之上。
- en: After Razor Pages came Blazor, a name inspired by combining “browser” and “Razor.”
    Blazor (clever name, isn’t it?) is the first of its kind for .NET, a SPA framework.
    Blazor takes advantage of WebAssembly (Wasm), which is a binary instruction format
    for a stack-based virtual machine. [WebAssembly](https://webassembly.org) is designed
    as a portable compilation target for programming languages, enabling deployment
    on the web for client and server applications. WebAssembly allows .NET web apps
    to truly compete with JavaScript-based SPA frameworks. It’s C# running in the
    client browser with WebAssembly and the Mono .NET runtime.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在Razor页面之后，出现了Blazor，这个名称是通过结合“browser”和“Razor”得到灵感而起。Blazor（是不是个聪明的名字？）是.NET的首个单页面应用（SPA）框架。Blazor利用WebAssembly（Wasm），这是一种面向堆栈的虚拟机的二进制指令格式。[WebAssembly](https://webassembly.org)被设计为编程语言的可移植编译目标，能够在客户端和服务器应用程序中部署。WebAssembly使得.NET
    Web应用能够与基于JavaScript的SPA框架真正竞争。这是C#在客户端浏览器中运行，利用WebAssembly和Mono .NET运行时。
- en: According to Steve Sanderson, he created Blazor because he was inspired to get
    .NET running on WebAssembly. He had a breakthrough when he discovered Dot Net
    Anywhere (DNA), an alternative .NET runtime that could easily be compiled to Web­Assembly
    with [Emscripten](https://emscripten.org), a complete compiler toolchain to WebAssembly,
    with a special focus on speed, size, and the web platform.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Steve Sanderson的说法，他创建Blazor是因为他受到在WebAssembly上运行.NET的启发。当他发现了Dot Net Anywhere
    (DNA)，一个可轻松编译为Web­Assembly的替代.NET运行时，并且使用了[Emscripten](https://emscripten.org)，这是一个专注于速度、体积和Web平台的完整编译器工具链时，他有了突破。
- en: This was the path that led to the creation of one of the first working prototypes
    of .NET running in the browser without a plug-in. After Steve Sanderson delivered
    an amazing demonstration of this functioning .NET app in the browser, other Microsoft
    stakeholders started supporting the idea. This took .NET a step further as an
    ecosystem and a step closer to what we know as Blazor today.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是引导.NET在浏览器中运行而无需插件的首个工作原型之一的路径。在Steve Sanderson展示了这个在浏览器中运行的令人惊叹的.NET应用程序后，其他微软利益相关者开始支持这个想法。这将.NET推向生态系统的一个更高级别，并使其更接近我们今天所知的Blazor。
- en: Now that we’ve discussed how Blazor came to be, let’s talk about how it’s able
    to bring apps to life and the different ways they can be hosted.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了Blazor的产生过程，让我们谈谈它如何使应用程序焕发生机以及它们可以被托管的不同方式。
- en: Blazor Hosting
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Blazor的托管方式
- en: 'There are three primary Blazor hosting models: Blazor Server, Blazor WebAssembly,
    and Blazor Hybrid. While this book covers Blazor WebAssembly, Blazor Server and
    Blazor Hybrid are valid alternative approaches in their own right.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor有三种主要的托管模型：Blazor Server、Blazor WebAssembly和Blazor Hybrid。虽然本书涵盖了Blazor
    WebAssembly，但Blazor Server和Blazor Hybrid也是其有效的替代方法。
- en: Blazor Server
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Blazor Server
- en: With Blazor Server, when a client browser makes the initial request to the web
    server, the server executes .NET code to generate an HTML response dynamically.
    HTML is returned and subsequent requests are made to fetch CSS and JavaScript
    as specified in the HTML document. Once the scripts are loaded and running, client-side
    routing and other UI updates are made possible with an ASP.NET Core SignalR connection.
    ASP.NET Core SignalR offers bidirectional communication between client and server,
    sending messages in real time. This technology is used to communicate changes
    to the Document Object Model (DOM) on the client browser—without a page refresh.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Blazor Server时，当客户端浏览器向Web服务器发出初始请求时，服务器执行.NET代码以动态生成HTML响应。返回HTML并根据HTML文档中指定的内容进行后续请求以获取CSS和JavaScript。一旦脚本加载并运行，使用ASP.NET
    Core SignalR连接实现客户端路由和其他UI更新。ASP.NET Core SignalR提供客户端和服务器之间的双向通信，实时发送消息。此技术用于在客户端浏览器上更新文档对象模型（DOM）而无需页面刷新。
- en: 'There are advantages to using Blazor Server as a hosting model over Blazor
    WebAssembly:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Blazor Server作为主机模型的优势远远超过Blazor WebAssembly：
- en: The download size is smaller than Blazor WebAssembly because the app is rendered
    on the server.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于应用程序在服务器上呈现，下载大小比Blazor WebAssembly小。
- en: The component code isn’t served to clients, only the resulting HTML and some
    JavaScript to talk to the server.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件代码不会提供给客户端，只提供生成的HTML和一些用于与服务器通信的JavaScript。
- en: Server capabilities are present with the Blazor Server hosting model because
    the app technically runs on the server.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Blazor Server主机模型中存在服务器功能，因为应用程序在技术上在服务器上运行。
- en: For additional information on Blazor Server, see Microsoft’s [“ASP.NET Core
    Blazor Hosting Models” documentation](https://oreil.ly/rwMaU).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有关Blazor Server的更多信息，请参阅微软的[“ASP.NET Core Blazor Hosting Models”文档](https://oreil.ly/rwMaU)。
- en: '[Figure 1-1](#blazor_server_hosting) shows the server and the client. The server
    is where Blazor code runs, and it is comprised of Razor components running on
    .NET. The client is responsible for rendering HTML. The client JavaScript communicates
    user interactions to the server, which then performs logic before sending a list
    of HTML changes (deltas) back to the client to update its view.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-1](#blazor_server_hosting)显示了服务器和客户端。服务器是Blazor代码运行的地方，由运行在.NET上的Razor组件组成。客户端负责呈现HTML。客户端JavaScript向服务器通信用户交互，服务器执行逻辑后发送一系列HTML更改（增量）列表返回客户端以更新其视图。'
- en: '![lblz 0101](assets/lblz_0101.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![lblz 0101](assets/lblz_0101.png)'
- en: Figure 1-1\. Blazor Server hosting model
  id: totrans-25
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-1\. Blazor Server主机模型
- en: Blazor WebAssembly
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Blazor WebAssembly
- en: With Blazor WebAssembly, when a client browser makes the initial request to
    the web server, the server returns a static HTML view of what the app would display
    to the user if already running; this gives users a faster time-to-first render
    and allows search engines to crawl your app’s content. As the user views the statically
    rendered content, the resources needed to run the app within the client are downloaded
    in the background. As part of a Blazor WebAssembly app’s HTML, there will be a
    `<link>` element that requests the *blazor.webassembly.js* file. This file executes
    and starts loading WebAssembly, which acts as a bootstrap that requests .NET binaries
    from the server. Once your app is downloaded locally and running inside the browser,
    changes to the DOM, such as updating data values on the page, occur as new data
    is retrieved from API calls. This is covered in detail in [“App Startup and Bootstrapping”](ch02.html#app_startup).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Blazor WebAssembly时，当客户端浏览器向Web服务器发出初始请求时，服务器返回一个静态HTML视图，显示应用程序如果已运行时将显示给用户的内容；这使用户能更快地看到首次渲染，并允许搜索引擎爬取应用程序的内容。当用户查看静态渲染的内容时，用于在客户端内运行应用程序所需的资源会在后台下载。作为Blazor
    WebAssembly应用程序的HTML的一部分，会有一个请求*blazor.webassembly.js*文件的`<link>`元素。该文件执行并开始加载WebAssembly，充当从服务器请求.NET二进制文件的引导程序。一旦您的应用程序在本地下载并在浏览器内运行，对DOM的更改（例如从API调用检索新数据值）会导致页面更新。这在[“App
    Startup and Bootstrapping”](ch02.html#app_startup)中有详细描述。
- en: Warning
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Being mindful of the hosting model is important. With Blazor WebAssembly hosting,
    all of your C# code is executed on the client. This means that you should avoid
    using any code that requires server-side functionality, and you should avoid sensitive
    data such as passwords, API keys, or other confidential information.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意托管模型是很重要的。使用Blazor WebAssembly托管时，所有的C#代码都在客户端执行。这意味着应避免使用任何需要服务器端功能的代码，也应避免使用密码、API密钥或其他机密信息。
- en: When using the Blazor WebAssembly hosting model, you can choose to create a
    Blazor ASP.NET Core-hosted application or a standalone application that can be
    published as just a set of static files (obviously, this will not support server-side
    pre-rendering for search engines and improved UX). With the ASP.NET Core *hosted*
    solution, ASP.NET Core is responsible for serving the app as well as providing
    a Web API in a client/server architecture. The application for this book uses
    the *standalone* model and is deployed to Azure Static Web Apps. In other words,
    the application is served as a set of static files. The data used to drive the
    app is available as several Web API endpoints that are deployed either as containers
    or as simple fault-tolerant pass-thru APIs with monitoring. We’re also using Azure
    Functions as a serverless architecture for local, current, and up-to-date weather
    data.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Blazor WebAssembly托管模型时，可以选择创建Blazor ASP.NET Core托管应用程序或作为一组静态文件发布的独立应用程序（显然，这不支持服务器端预渲染以及改进的用户体验）。使用ASP.NET
    Core *托管* 解决方案，ASP.NET Core负责为应用程序提供服务，并在客户端/服务器架构中提供Web API。本书的应用程序采用*独立*模型，并部署到Azure
    Static Web Apps。换句话说，该应用程序作为一组静态文件提供服务。用于驱动应用程序的数据可作为几个Web API端点使用，这些端点可以部署为容器或具有监控的简单容错传递API。我们还使用Azure
    Functions作为本地、当前和最新天气数据的无服务器架构。
- en: '[Figure 1-2](#blazor_webassembly_hosting) shows only the client. The client
    is responsible for everything in this scenario, and the site can be served statically.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-2](#blazor_webassembly_hosting) 仅显示客户端。在这种情况下，客户端负责所有内容，站点可以静态提供服务。'
- en: '![lblz 0102](assets/lblz_0102.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![lblz 0102](assets/lblz_0102.png)'
- en: Figure 1-2\. Blazor WebAssembly hosting model
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-2\. Blazor WebAssembly托管模型
- en: With the standalone approach, the ability to leverage serverless cloud functionality
    with Azure Functions is helpful. Microservice capabilities such as this work great
    together with ASP.NET Core Web APIs and Blazor WebAssembly standalone scenarios
    and together serve as a desirable target for deployment with Azure Static Web
    Apps. Static web servers deliver static files, which is less computationally expensive
    than computing a request that then has to dynamically render HTML to then return
    as a response.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用独立方法，利用Azure Functions的无服务器云功能非常有帮助。微服务功能，例如ASP.NET Core Web API和Blazor WebAssembly独立场景，能够很好地协同工作，并一起作为Azure
    Static Web Apps部署的理想目标。静态网页服务器提供静态文件，这比计算请求并动态渲染HTML再返回响应要少计算成本。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: While this book is focused on developing a Blazor WebAssembly application that
    is hosted as static files, it’s important to note that this is not the only option.
    I prefer to develop Blazor WebAssembly applications that are statically hosted.
    For additional information on the hosting model, see Microsoft’s [“ASP.NET Core
    Blazor Hosting Models” documentation](https://oreil.ly/xuL8J).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本书专注于开发以静态文件托管的Blazor WebAssembly应用程序，但重要的是要注意这并不是唯一的选择。我更倾向于开发以静态方式托管的Blazor
    WebAssembly应用程序。有关托管模型的更多信息，请参阅微软的[“ASP.NET Core Blazor Hosting Models”文档](https://oreil.ly/xuL8J)。
- en: With the Blazor WebAssembly hosting model, you can write C# that runs inside.
    With WebAssembly, a “binary instruction format” means that we’re talking about
    byte code. WebAssembly sits atop a “stack-based virtual machine.” Instructions
    are added (pushed) into the stack, while results are removed (popped) from the
    stack. WebAssembly is a “portable compilation target.” This means it’s possible
    to take C, C++, Rust, C#, and other nontraditional web programming languages and
    target WebAssembly for their compilation. This results in WebAssembly binaries,
    which are web-runnable based on open standards but from programming languages
    other than JavaScript.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Blazor WebAssembly 托管模型，您可以编写在其中运行的 C# 代码。使用 WebAssembly，“二进制指令格式”意味着我们在讨论字节码。WebAssembly
    位于“基于堆栈的虚拟机”之上。指令被添加（推入）到堆栈中，而结果则从堆栈中移除（弹出）。WebAssembly 是一个“可移植的编译目标”。这意味着可以使用
    C、C++、Rust、C# 和其他非传统的 web 编程语言，将它们编译为 WebAssembly。这导致了基于 WebAssembly 的二进制文件，这些文件符合开放标准，但来自于
    JavaScript 以外的编程语言。
- en: Blazor Hybrid
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Blazor 混合模式
- en: Blazor Hybrid is beyond the scope of this book. Its purpose is geared toward
    creating native client experiences for desktop and mobile devices, and it works
    well with .NET Multiplatform App UI (MAUI). For more information about Blazor
    Hybrid, see Microsoft’s [“ASP.NET Core Blazor Hybrid” documentation](https://oreil.ly/pubzs).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 混合模式超出了本书的范围。它的目的是为桌面和移动设备创建本地客户端体验，并且与 .NET 多平台应用程序 UI（MAUI）兼容良好。有关
    Blazor 混合模式的更多信息，请参阅 Microsoft 的[“ASP.NET Core Blazor 混合”文档](https://oreil.ly/pubzs)。
- en: Single-Page Applications, Redefined
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新定义单页面应用程序
- en: 'Blazor is the only .NET-based SPA framework in existence. The fact that we
    can use .NET to write SPAs cannot be overstated. There are many popular JavaScript
    SPA frameworks including (but not limited to) the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 是目前唯一基于 .NET 的单页面应用程序框架。不能过分强调可以使用 .NET 来编写单页面应用程序的事实。还有许多流行的 JavaScript
    单页面应用程序框架，包括（但不限于）以下内容：
- en: '[Angular](https://angular.io)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Angular](https://angular.io)'
- en: '[React](https://reactjs.org)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[React](https://reactjs.org)'
- en: '[VueJS](https://vuejs.org)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[VueJS](https://vuejs.org)'
- en: '[Svelte](https://svelte.dev)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Svelte](https://svelte.dev)'
- en: These are *all* based on JavaScript, whereas Blazor isn’t. The list is nonexhaustive—there
    are many more JavaScript-based SPA frameworks and even more non-SPA JavaScript
    frameworks, for that matter! JavaScript has ruled the browser as the exclusive
    programming language of the web for well over 20 years. It’s a very flexible programming
    language and is among the most popular in the world. In its infancy, the language
    was prototyped in a few weeks by Brendan Eich—it’s amazing how far it’s come since
    then.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些*都*基于 JavaScript，而 Blazor 则不是。这个列表是不详尽的——还有许多基于 JavaScript 的单页面应用程序框架，甚至还有更多非单页面应用程序的
    JavaScript 框架！JavaScript 已经统治着浏览器作为 Web 的唯一编程语言超过20年了。它是一种非常灵活的编程语言，也是世界上最受欢迎的语言之一。在其初期，这种语言是由
    Brendan Eich 在几周内原型化的——自那以后，它的进展令人惊讶。
- en: Stack Overflow manages a professional developer annual survey, and in 2021,
    over 58,000 professional developers and more than 83,000 total developers voted
    JavaScript as the most commonly used programming language. That marked the ninth
    year in a row that JavaScript was the most commonly used programming language.^([1](ch01.html#idm46365042441744))
    The close second was HTML/CSS. If you combine these totals, the web app platform
    has a solid future.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Stack Overflow 进行了一项专业开发者年度调查，在2021年，超过58,000名专业开发者和超过83,000名总开发者投票，JavaScript
    被选为最常用的编程语言。这标志着 JavaScript 连续第九年成为最常用的编程语言。^([1](ch01.html#idm46365042441744))
    紧随其后的是 HTML/CSS。如果将这些总数结合起来，Web 应用平台有着坚实的未来。
- en: One perceived disadvantage of JavaScript is that without definitive types, developers
    have to either code defensively or face the potential consequences of runtime
    errors. One way to help address this is by using TypeScript.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的一个认为的劣势是缺乏明确的类型，开发人员必须要么进行防御性编码，要么面对运行时错误的潜在后果。帮助解决这个问题的一种方法是使用
    TypeScript。
- en: TypeScript was created by Anders Hejlsberg (who was also the lead architect
    of C#, chief engineer of Turbo Pascal, and chief architect of Delphi—he’s a programming
    language genius!). TypeScript provides a type system that enables language services
    to reason about the intent of your code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 是由 Anders Hejlsberg 创建的（他也是 C# 的首席架构师、Turbo Pascal 的首席工程师和 Delphi
    的首席架构师——他是一位编程语言天才！）。TypeScript 提供了一种类型系统，使语言服务能够推断出您代码的意图。
- en: With TypeScript, you write generic type-safe code using all of the latest ECMAScript
    standards and prototyped features. The best part is that your code is backward
    compatible to ES3\. TypeScript is a superset of JavaScript, meaning that any valid
    JavaScript is also valid TypeScript. TypeScript provides static typing (type system)
    and a powerful language service that provides features to your favorite IDEs.
    This makes programming with JavaScript less error-prone, which cannot be understated.
    TypeScript is more like a developer tool than it is a programming language, but
    it has incredible language features. When it compiles, all your types go away,
    and you’re left with just JavaScript. Try to think of TypeScript as a way to make
    debugging and refactoring substantially easier and more reliable. With TypeScript,
    you have one of the most advanced flow analysis tools in the world, and far more
    advanced language features than JavaScript alone. All web developers know that
    Angular rivals React in the popularity of JavaScript-based SPAs—this is no surprise.
    I believe a lot of Angular’s competitive edge was directly correlated to adopting
    TypeScript far sooner than React did.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 TypeScript，您可以使用所有最新的 ECMAScript 标准和原型功能编写通用类型安全代码。最棒的部分是，您的代码向后兼容到 ES3。TypeScript
    是 JavaScript 的超集，这意味着任何有效的 JavaScript 也是有效的 TypeScript。TypeScript 提供静态类型（类型系统）和强大的语言服务，为您喜爱的
    IDE 提供功能。这使得使用 JavaScript 编程更少出错，这一点不能被低估。TypeScript 更像是一种开发工具，而不是一种编程语言，但它拥有令人难以置信的语言特性。当它编译时，所有的类型都消失了，你只剩下
    JavaScript。试着把 TypeScript 看作是一种使调试和重构变得更加轻松和可靠的方式。使用 TypeScript，您拥有全球最先进的流分析工具之一，以及比单独使用
    JavaScript 更先进的语言特性。所有的 Web 开发人员都知道，Angular 在基于 JavaScript 的单页面应用的流行度上与 React
    不相上下，这一点不足为奇。我认为 Angular 的许多竞争优势直接与更早采用 TypeScript 有关，比 React 更早。
- en: Blazor, unlike JavaScript-based SPAs, is built atop .NET. While TypeScript might
    help developers to be more productive with JavaScript, one of the primary reasons
    that Blazor has a bright future is its interoperability with C#. C# has long had
    most of the benefits that TypeScript offered to JavaScript development and more.
    Not only does C# also have an excellent type system, but it is even better at
    catching errors at compile time. TypeScript’s static type system is “duck typed”
    (if it looks like a duck and sounds like a duck, then treat it like a duck), whereas
    C# has a strict type system that ensures the object you are passing is an instance
    of a duck type. C# has always prioritized the developer experience with flow analysis,
    statement completion, a feature-full ecosystem, and reliable refactoring. C# is
    a modern, object-oriented first, and type-safe programming language that is constantly
    evolving and maturing, further expanding its capabilities. It is open source,
    and new features are often inspired and influenced, and sometimes even developed,
    by the developer community.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 不同于基于 JavaScript 的单页面应用（SPA），它建立在 .NET 之上。尽管 TypeScript 可以帮助开发人员更高效地使用
    JavaScript，但 Blazor 未来光明的一个主要原因是其与 C# 的互操作性。长期以来，C# 提供了大部分 TypeScript 提供给 JavaScript
    开发的优点，并且更多。C# 不仅拥有出色的类型系统，而且在编译时更擅长捕获错误。TypeScript 的静态类型系统是“鸭子类型”的（如果看起来像鸭子、听起来像鸭子，那就像鸭子一样对待），而
    C# 则拥有严格的类型系统，确保传递的对象是鸭子类型的实例。C# 一直优先考虑开发者体验，包括流分析、语句完成、功能丰富的生态系统和可靠的重构。C# 是一种现代的、面向对象的、类型安全的编程语言，不断发展和成熟，进一步扩展其能力。它是开源的，新功能经常受到开发者社区的启发和影响，有时甚至是由其开发。
- en: All that being said, Blazor provides interop with JavaScript as well. You can
    call JavaScript from your Blazor code, and you can call .NET code from your JavaScript
    code. This is a useful feature to leverage existing JavaScript utilitarian functionality
    and JavaScript APIs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，Blazor 也能与 JavaScript 进行互操作。您可以从 Blazor 代码调用 JavaScript，也可以从 JavaScript
    代码调用 .NET 代码。这是一个利用现有 JavaScript 实用功能和 JavaScript API 的有用特性。
- en: Why Adopt Blazor
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择 Blazor
- en: There are interesting new scenarios specific to WebAssembly that were not realistically
    achievable with JavaScript alone. It’s easy to imagine applications being delivered
    over the web to your browser, powered by WebAssembly for more elaborate and resource-intensive
    use cases. If you haven’t heard of AutoCAD before, it’s computer-aided design
    software that architects, engineers, and construction professionals rely on to
    create 2D and 3D drawings. It’s a desktop application, but imagine being able
    to run a program like this natively in a web browser. Imagine audio and video
    editing, running or playing robust and resource-taxing games all in the browser.
    Web­Assembly does allow us to reimagine the web a bit. The web app platform holistically
    might be the next delivery mechanism for a generation of software development.
    The web app development platform continues to evolve, grow, and mature. Internet-based
    data processing and ingestion systems thrive because of their connectivity to
    the world. The web app development platform serves as the median that bridges
    a developer’s imagination and a user’s desire.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些有趣的新场景是特定于 WebAssembly 的，这些场景仅仅依靠 JavaScript 是无法实现的。很容易想象，通过 WebAssembly，应用程序可以通过网络传输到您的浏览器，用于更复杂和资源密集型的使用场景。如果您之前没有听说过
    AutoCAD，它是一款建筑师、工程师和建筑专业人士依赖的计算机辅助设计软件，用于创建二维和三维图纸。它是一个桌面应用程序，但想象一下能够在网页浏览器中本地运行这样的程序。想象一下音频和视频编辑，在浏览器中运行或播放强大且资源消耗大的游戏。WebAssembly
    确实让我们重新想象了一下网络。整体上，Web 应用程序平台可能是下一代软件开发的交付机制。Web 应用程序开发平台在互联网数据处理和摄入系统方面表现出色，因为它们与世界的连接性。Web
    应用程序开发平台作为一种媒介，连接了开发者的想象力和用户的需求。
- en: Developers can continue to extend their C# and Razor skills into SPA development
    rather than having to learn an additional language and rendering framework. C#
    developers who previously weren’t inclined to write SPA apps are now switching
    from MVC to SPA simply because “it’s just more C#.” Additionally, the code-sharing
    potential is great. Rather than ensuring your C# API contracts on the server are
    manually kept in sync with your TypeScript definitions, you can simply use the
    same contracts file, along with all the `DataAnnotation` validators too.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以继续将他们的 C# 和 Razor 技能扩展到单页应用程序开发中，而不必学习额外的语言和渲染框架。之前不太愿意编写单页应用程序的 C# 开发者现在转而从
    MVC 到单页应用程序，仅仅是因为“这更像是 C#”。此外，代码共享的潜力也很大。与其确保您的 C# API 合同在服务器上与您的 TypeScript 定义手动保持同步，不如简单地使用同一个合同文件，以及所有的
    `DataAnnotation` 验证器。
- en: I believe that in the coming years, we will start seeing more and more WebAssembly-powered
    applications. Blazor WebAssembly will be .NET’s solution of choice.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来几年，我相信我们将会看到越来越多基于 WebAssembly 的应用程序。Blazor WebAssembly 将成为 .NET 的首选解决方案。
- en: .NET’s Potential in the Browser
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET 在浏览器中的潜力
- en: At my first developer job out of college, I was the most junior developer on
    a team of developer leads or architects. I vividly recall being seated in a cube
    farm alone; neighboring cubes were empty. But all the surrounding offices were
    filled with the rest of the team.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在大学毕业后的第一份开发者工作中，我是一个团队中最初级的开发者，其他团队成员都是开发主管或架构师。我清楚地记得自己独自坐在一个立方体农场中，周围的立方体都是空的，但周围的办公室都是满的。
- en: 'I was working in the automotive industry, and we were implementing a low-level
    communication standard known as the onboard diagnostics (OBD) protocols. We were
    doing so with the .NET `SerialPort` class. We were writing applications that performed
    state testing for vehicle emissions. In the US, most states mandate that vehicles
    of a certain age have annual emissions tests to ensure their ability to be registered.
    The idea is rather simple: evaluate the vehicle’s various conditions. For example,
    a vehicle could have hardware triggering state changes, which propagate through
    the firmware, each wire transmitting information as it happens. The OBD system
    sits in the onboard vehicle computers, which can relay this information to interested
    parties. Your “check engine” light, for example, is a diagnostic code from the
    OBD system.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾在汽车行业工作，我们正在实施一种称为车载诊断（OBD）协议的低级通信标准。我们使用 .NET 的 `SerialPort` 类来完成这项工作。我们正在编写应用程序，用于对车辆排放进行状态测试。在美国，大多数州要求一定年龄的车辆进行年度排放测试，以确保其能够注册。其核心思想相当简单：评估车辆的各种状态。例如，车辆可能具有硬件触发状态变化，这些状态通过固件传播，每根导线传输信息随其发生。OBD
    系统位于车载计算机中，可以将此信息传递给相关方。例如，您的“发动机故障”指示灯就是来自 OBD 系统的诊断代码。
- en: The apps were primarily built as Windows Forms (WinForms) applications, and
    there were a few web service apps too. But this meant the app was limited to the
    .NET Framework and Windows at the time—in other words, it wasn’t cross-platform.
    The application had to communicate with various web services to persist the data
    and pull lookup data points. At the time, it would have been unimaginable to write
    something like this and deploy it as a web app; it had to be WinForms on Windows.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应用程序主要是作为Windows Forms（WinForms）应用程序构建的，也有一些Web服务应用程序。但这意味着该应用程序仅限于.NET Framework和Windows系统，换句话说，它不是跨平台的。当时，应用程序必须与各种Web服务通信以持久化数据并获取查找数据点。在当时，想象将这样的应用程序编写并部署为Web应用程序是不可想象的；它必须是Windows上的WinForms应用程序。
- en: Now, however, it is very easy to imagine this application being rewritten as
    a web app with Blazor WebAssembly. The Mono .NET runtime is what makes writing
    cross-platform .NET apps possible.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，然而，很容易想象这个应用程序会被重写为一个使用Blazor WebAssembly的Web应用程序。Mono .NET运行时使得编写跨平台的.NET应用程序成为可能。
- en: Try to imagine how it might be straightforward to implement the same .NET `SerialPort`
    object that we were using in WinForms in Blazor WebAssembly instead. The corresponding
    implementation could hypothetically rely on WebAssembly interop with the native
    JavaScript Web Serial APIs. This kind of cross-platform functionality already
    exists with other implementations, such as the .NET `HttpClient` in Blazor WebAssembly.
    With Blazor WebAssembly, our compilation target is WebAssembly, and the Mono runtime’s
    implementation is the `fetch` Web API. You see, .NET has the entire web as its
    playground now.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试想象一下，如何可能在Blazor WebAssembly中实现与我们在WinForms中使用的相同的.NET `SerialPort`对象。相应的实现可以假设依赖于WebAssembly与本地JavaScript
    Web Serial API的交互操作。这种跨平台功能已经在其他实现中存在，比如在Blazor WebAssembly中的.NET `HttpClient`。通过Blazor
    WebAssembly，我们的编译目标是WebAssembly，而Mono运行时的实现是`fetch` Web API。您看，.NET现在将整个Web作为其游乐场。
- en: .NET Is Here to Stay
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET就在这里
- en: WebAssembly is supported in all major browsers and covers nearly 95% of all
    users according to the [“Can I Use *WebAssembly*?” web page](https://oreil.ly/ixdKk).
    It’s the future of the web, and you’ll continue to see developers building applications
    using this technology.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly受到所有主要浏览器的支持，覆盖了近95%的用户，根据[“Can I Use *WebAssembly*？”网页](https://oreil.ly/ixdKk)。这是Web的未来，您将继续看到开发者使用这项技术构建应用程序。
- en: .NET isn’t going anywhere either. Microsoft continues to move forward at staggering
    speeds, with release cadences that are predictable and profound. The web developer
    community is extremely strong, and the software development industry as a whole
    recognizes ASP.NET Core as one of the best options for modern and enterprise-friendly
    web app dev platforms. JavaScript is still a necessity, but it’s de­em⁠pha­sized
    from your perspective because WebAssembly relies on it today and they play very
    nicely together. The [WebAssembly website states](https://oreil.ly/EKjC7), “It
    is expected that JavaScript and WebAssembly will be used together in several configurations.”
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: .NET并没有消失。微软继续以令人惊讶的速度前进，发布节奏可预测且深远。Web开发者社区非常强大，整个软件开发行业都认为ASP.NET Core是现代和企业友好的Web应用程序开发平台之一。JavaScript仍然是必不可少的，但从您的角度来看，它被弱化了，因为WebAssembly今天依赖于它们并且它们之间的配合非常好。[WebAssembly网站声明](https://oreil.ly/EKjC7)：“预计JavaScript和WebAssembly将以多种配置一起使用。”
- en: Familiarity
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 熟悉度
- en: If you’re a C# developer, great! If you’re a JavaScript developer, awesome!
    Bring these existing skills to the table, and Blazor will feel very familiar with
    both sets of lenses. This way, you can keep using your HTML and CSS skills and
    your favorite CSS libraries, and you’re free to work smoothly with existing JavaScript
    packages. JavaScript development is deemphasized, however, as you’ll code in C#.
    C# is from Microsoft and is heavily influenced by the .NET developer community.
    In my opinion, C# is one of the best programming languages.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是C#开发者，太好了！如果您是JavaScript开发者，太棒了！把这些现有技能带到桌面上，Blazor将与这两组镜头感觉非常熟悉。这样，您可以继续使用您的HTML和CSS技能以及您喜爱的CSS库，并且可以自由地与现有的JavaScript包顺畅工作。但是JavaScript开发在您的视角中被弱化了，因为您将会用C#编码。C#来自微软，并且深受.NET开发者社区的影响。在我看来，C#是最好的编程语言之一。
- en: If you’re coming from a web development background, you’re more than likely
    used to client-side routing, event handling, HTML templating of some sort, and
    component authoring. Everything that you’ve grown to love about web development
    is still at the forefront of Blazor development. Blazor development is easy and
    intuitive. Additionally, Blazor provides various isolation models for both JavaScript
    and CSS. You can scope JavaScript and CSS to individual components. You can continue
    to use your favorite CSS preprocessor too. You’re entirely free to pick whichever
    CSS framework you prefer.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自 Web 开发背景，你很可能已经习惯了客户端路由、事件处理、某种形式的 HTML 模板化以及组件编写。你所热爱的关于 Web 开发的一切依然是
    Blazor 开发的重点。Blazor 开发是简单且直观的。此外，Blazor 为 JavaScript 和 CSS 提供了各种隔离模型。你可以将 JavaScript
    和 CSS 限定到单独的组件中。你也可以继续使用你喜爱的 CSS 预处理器。你完全可以选择任何你喜欢的 CSS 框架。
- en: Safe and Secure
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全和可靠
- en: 'Long before WebAssembly, there was another web-based technology that I’d be
    remiss not to mention. Microsoft Silverlight was a plug-in powered by the .NET
    Framework. Silverlight was an app framework designed for writing and running rich
    web applications. Silverlight relied on the Netscape Plugin Application Programming
    Interface (NPAPI), which has long since been deprecated. The plug-in architecture
    proved to be a security concern, and all of the major browsers started phasing
    out support of NPAPI. This led to the demise of Silverlight, but rest assured:
    Web­Assembly *is not* a plug-in-based architecture.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WebAssembly 出现之前很久以前，还有另一种基于 Web 的技术我不得不提及。Microsoft Silverlight 是由 .NET Framework
    提供支持的插件。Silverlight 是一种用于编写和运行丰富 Web 应用程序的应用程序框架。Silverlight 依赖于已经废弃的 Netscape
    插件应用程序接口（NPAPI）。插件架构证明是一个安全问题，所有主流浏览器开始逐步停止支持 NPAPI。这导致了 Silverlight 的衰落，但请放心：WebAssembly
    *不是* 基于插件的架构。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: WebAssembly is every bit as secure as JavaScript. WebAssembly plays within the
    same security sandbox as all browser-based JavaScript execution environments.
    Because of this, WebAssembly’s security context is identical to that of JavaScript.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 的安全性与 JavaScript 一样可靠。WebAssembly 在与所有基于浏览器的 JavaScript 执行环境相同的安全沙箱中运行。因此，WebAssembly
    的安全上下文与 JavaScript 完全相同。
- en: Code Reuse
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码重用
- en: SPA developers have been fighting an uphill battle for years. These developers
    consume web API endpoints that define a payload in a certain shape. The consuming
    client-side code (the SPA app) has to model the same shape; however, this is error-prone
    as the API can change the shape of the response whenever it needs to. The client
    would have to know when these changes are made and then adapt, and this is tedious!
    Blazor can alleviate that concern by sharing models from .NET Web APIs with the
    Blazor client app. I cannot stress the importance of this enough. Sharing the
    models from a class library with both the server and the client is like having
    your cake and eating it too.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: SPA 开发者多年来一直在与困难作斗争。这些开发者使用定义特定形状负载的 Web API 端点。消费端代码（SPA 应用程序）必须模拟相同的形状；然而，由于
    API 可以随时更改响应的形状，这是容易出错的。客户端需要知道这些更改何时发生，并做出调整，这是一件很繁琐的事情！Blazor 可以通过将 .NET Web
    API 中的模型与 Blazor 客户端应用程序共享来缓解这一问题。我无法过分强调这一点的重要性。通过从类库中与服务器和客户端共享模型，就像是一举两得。
- en: As a developer who has played on both sides of the development experience, from
    building APIs to consuming them on client apps, I think the act of synchronizing
    model definitions carries with it a great sense of tedium. I refer to this as
    “synchronization fatigue.” Synchronization fatigue wears hard on developers, who
    grow frustrated with manually mapping server and client models. This is especially
    true when you have to map type systems from different languages—that’s never fun.
    This problem existed in backend development too, reading data from a storage medium,
    such as the file system or database. Mapping the shape of something stored in
    a database to match a .NET object is a solved problem; object-relational mappers
    (ORMs) do this for us.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个既构建 API 又在客户端应用程序中使用它们的开发者，我认为同步模型定义的行为带来了极大的烦恼。我称之为“同步疲劳”。同步疲劳严重影响开发者，他们对手动映射服务器和客户端模型感到沮丧。当你不得不映射不同语言的类型系统时，这一点尤为明显——那绝对不是一件有趣的事情。这个问题也存在于后端开发中，从存储介质（如文件系统或数据库）读取数据。将数据库中存储的内容的形状映射为与
    .NET 对象匹配的形状是一个已解决的问题；对象关系映射器（ORM）为我们做到了这一点。
- en: For years and years, I leaned on tooling to help catch common errors, where
    the server would change the shape of an API endpoint’s data structure and the
    client app would break. Sure, you could try to use API versioning—but if we’re
    honest with each other, that has its own set of complexities. Tooling simply wasn’t
    enough, and it was very difficult to prevent synchronization fatigue. Occasionally,
    wild ideas would emerge to combat these concerns, but you have to ask yourself,
    “Is there a better way?” The answer is “Yes, with Blazor, there is!”
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，我依赖工具帮助捕捉常见错误，例如服务器改变 API 端点数据结构的形式导致客户端应用程序崩溃。当然，你可以尝试使用 API 版本控制，但坦率地说，这也有其自身的复杂性。工具支持显然是不够的，防止同步疲劳非常困难。偶尔会出现一些奇思妙想来应对这些问题，但你必须问自己：“有没有更好的方法？”答案是：“有，在
    Blazor 中有！”
- en: Entire .NET libraries can be shared and consumed in both server-side and client-side
    scenarios. Making use of existing logic, functionality, and capabilities allows
    developers to focus on innovating more because they’re not required to reinvent
    the wheel. Also, developers don’t have to waste time maintaining two different
    languages, manually mapping models delivered over from a server to a client browser.
    You can make use of common extension methods, models, and utilitarian functions
    that can all be easily encapsulated, tested, and shared. This alone actually has
    an implicit and perhaps less obvious quality. You see, a single team can write
    the client, the server, and the abstraction together. This allows for rapid innovation
    in your app development process because there will be so much common code that
    can be reused and shared. Think of this as tons of apps being written all around
    the world by multiple teams, where at least one team is relying on another team.
    It’s a common development problem domain, where one team takes a dependency of
    the output from another. But it’s not a necessity with Blazor, because it’s all
    C#!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 整个 .NET 库可以在服务器端和客户端场景中共享和使用。利用现有的逻辑、功能和能力使开发者能够更专注于创新，因为他们不需要重新发明轮子。开发者也不必浪费时间在服务器和客户端浏览器之间手动映射模型。你可以利用通用的扩展方法、模型和实用函数，这些都可以轻松封装、测试和共享。单单这一点就有一个隐含的、可能不太明显的优点。你看，一个团队可以同时编写客户端、服务器和抽象层。这使得应用开发过程中的快速创新成为可能，因为有如此多的通用代码可以重复使用和共享。可以把这看作是全球各地多个团队编写大量应用的情况，其中至少一个团队依赖另一个团队的输出。这是一个常见的开发问题领域，在这个领域中一个团队依赖于另一个团队的输出是不必要的，因为
    Blazor 就是全部由 C# 编写的！
- en: Tooling
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具支持
- en: 'As developers, we have many options when it comes to tooling. Choosing the
    right tool for the job is just as important as the job itself. You wouldn’t use
    a screwdriver to hammer in a nail, would you? The development team’s productivity
    is always a major concern for application development. If your team fumbles about
    or struggles to get common programming tasks done, the entire project can and
    will eventually fail. With Blazor development, you can use proven developer tooling
    such as the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，在选择工具时我们有很多选择。选择正确的工具与完成工作本身同样重要。你不会用螺丝刀去敲钉子，对吧？开发团队的生产力始终是应用开发中的一个重要关注点。如果你的团队在完成常见编程任务时手忙脚乱或者遇到困难，整个项目最终可能会失败。在
    Blazor 开发中，你可以使用如下经过验证的开发工具：
- en: Visual Studio
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio
- en: Visual Studio for Mac
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio for Mac
- en: Visual Studio Code
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: 'Mileage may vary based on your OS. On Windows, Visual Studio is great. On macOS,
    it’s probably easier to use Visual Studio Code. JetBrains’ Rider is another amazing
    .NET development environment. The point is that as a developer, you have plenty
    of really good options. Whichever IDE you decide on, it needs to work well with
    the .NET ecosystem. Modern IDEs power developers to be their most productive.
    C# is powered by Roslyn (the .NET Compiler Platform), and while it’s opaque to
    you, the developer, we’re spoiled with features such as these:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 依据你的操作系统可能会有所不同。在 Windows 上，Visual Studio 是非常好的。在 macOS 上，使用 Visual Studio Code
    可能会更容易些。JetBrains 的 Rider 是另一个出色的 .NET 开发环境。关键在于作为开发者，你有很多非常好的选择。无论你选择哪个集成开发环境（IDE），它都需要与
    .NET 生态系统良好配合。现代化的集成开发环境（IDE）提升了开发者的生产力。C# 由 Roslyn（.NET 编译平台）支持，虽然这些对开发者来说是不透明的，但我们享受到了诸如以下特性的便利：
- en: Statement completion (IntelliSense)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 语句完成（IntelliSense）
- en: As you type, the IDE shows pick lists of all the applicable and contextual members,
    providing semantic guidelines and more rapid code discoverability. Developer documentation
    enabled by triple-slash comments further advances code comprehension and readability.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当您输入时，IDE 显示所有适用且上下文相关的成员的选择列表，提供语义指南和更快速的代码发现能力。通过三斜杠注释启用的开发者文档进一步促进代码理解和可读性。
- en: AI-assisted IntelliSense (AI, IntelliCode)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: AI 辅助的 IntelliSense（AI、IntelliCode）
- en: As you type, the IDE offers suggestions to complete your code based on model-driven
    predictions, which are learned from all 100+ star open source code repositories
    on GitHub.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当您输入时，IDE 根据从 GitHub 上所有 100+ 星级开源代码库学习到的模型驱动预测为您提供代码完成建议。
- en: GitHub Copilot (AI pair programmer)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Copilot（AI 配对程序员）
- en: As you type, the IDE suggests entire lines or functions, trained by billions
    of lines of public code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当您输入时，IDE 建议整行或函数，其训练基于数十亿行公共代码。
- en: Refactoring
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 重构
- en: Quickly and reliably ensure consuming references downstream are appropriately
    updated, from changing method signatures, member names, and types across projects
    within a solution to adding C# modernization efforts that enhance source code
    execution, performance, readability, and the latest C# features.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 快速可靠地确保消费引用的更新，在解决方案中更改方法签名、成员名称和类型，以及添加增强源代码执行、性能、可读性和最新 C# 特性的 C# 现代化工作。
- en: Built-in and extensible code analyzers
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 内置和可扩展的代码分析器
- en: Detect common pitfalls or missteps in source code, and quickly light up the
    developer experience with warnings, suggestions, and even errors. In other words,
    write cool code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 检测源代码中的常见陷阱或错误，并迅速通过警告、建议甚至错误点亮开发者体验。换句话说，写出优秀的代码。
- en: Code generators
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 代码生成器
- en: One code generator example is auto equality implementations with record types;
    this technology has allowed for the reimagining of what’s possible.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一个代码生成器的例子是使用记录类型自动生成相等性实现；这项技术使得重新想象可能性成为了现实。
- en: You can also utilize the .NET CLI, which is a cross-platform toolchain for developing
    .NET workloads. It exposes many commands, such as `new` (templating), `build`,
    `restore`, `publish`, `run`, `test`, `pack`, and `migrate`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以利用 .NET CLI，这是一个用于开发 .NET 工作负载的跨平台工具链。它公开了许多命令，如 `new`（模板化）、`build`、`restore`、`publish`、`run`、`test`、`pack`
    和 `migrate`。
- en: Open Source Software
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开源软件
- en: Blazor is entirely developed in the open, as part of the [ASP.NET Core GitHub
    repository](https://oreil.ly/4YS3Z).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 完全是在开放中开发的，作为 [ASP.NET Core GitHub 仓库](https://oreil.ly/4YS3Z) 的一部分。
- en: Open source software development is the future of software engineering in modern-day
    development. The reality is that it’s not *really* new; it’s just new to .NET
    as of March 2014\. With the birth of the .NET Foundation, developers collaborate
    openly with negotiated open standards and best practices. Innovation is the only
    path forward, especially when projects undergo public scrutiny and natural order
    prevails.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 开源软件开发是现代软件工程的未来。事实上，这并不是真的 *全新*；只是自 2014 年 3 月起对 .NET 新鲜。随着 .NET 基金会的诞生，开发者们在公开协商的开放标准和最佳实践下进行协作。创新是唯一前进的道路，尤其是在项目经历公众审查和自然秩序的情况下。
- en: To me, it’s not enough to simply describe .NET as open source. Let me share
    with you a bit more perspective about the true value proposition and why this
    is so important. I’ve witnessed .NET APIs being developed, from their inception
    to fruition—the process is very mature and well established. This applies to Blazor
    as well because it’s part of the .NET family of open source projects.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，仅仅将 .NET 描述为开源是不够的。让我与你分享更多关于真正价值主张的见解，以及为什么这一点如此重要。我见证了 .NET API 的开发，从最初的构想到最终成果——这个过程非常成熟且已被充分确立。这同样适用于
    Blazor，因为它是 .NET 开源项目族的一部分。
- en: 'Unlike typical projects, open source projects are developed entirely out in
    the open for the public to see. With .NET, it starts with early discussions, and
    then an idea emerges. A GitHub issue is used to draft an [ASP.NET Core `api-suggestion`
    label](https://oreil.ly/0zKRz). From a suggestion, after it’s been discussed and
    vetted, it moves into a proposal. The issue containing the proposal transitions
    to an [ASP.NET Core `api-ready-for-review` label](https://oreil.ly/ajkuM). The
    issue captures everything you’d expect for the proposal: the problem statement,
    use cases, reference syntax, suggested API surface area, example usage, and even
    links to the comments from the original discussion and idea.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与典型项目不同，开源项目完全在公开环境中开发供公众查看。在 .NET 中，它始于早期讨论，然后一个想法浮出水面。使用 GitHub 问题起草一个 [ASP.NET
    Core `api-suggestion` label](https://oreil.ly/0zKRz)。从建议开始，在经过讨论和审核后，它转变为提议。包含提议的问题过渡到
    [ASP.NET Core `api-ready-for-review` label](https://oreil.ly/ajkuM)。该问题记录了提议所期望的一切内容：问题陈述、使用案例、参考语法、建议的
    API 表面区域、示例用法，甚至链接到原始讨论和想法的评论。
- en: The potential API usually includes bargaining, reasoning, and negotiation. After
    everyone agrees it’s a good proposal, a draft is finalized with a group of people
    who participate in the public API design review meeting. The official .NET API
    design review meeting follows a weekly schedule, streams live on YouTube, and
    invites developer community members to share their thoughts. As part of the review,
    notes are captured and GitHub labels applied, and assuming it receives a stamp
    of approval, the .NET API in question is codified as a snippet. Finally, it moves
    to [ASP.NET Core `api-approved` label](https://oreil.ly/TYc05).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 潜在的 API 通常包括讨价还价、推理和谈判。在每个人都认为这是一个好提议之后，一份草案将与参加公共 API 设计审查会议的一组人员最终确定。官方的 .NET
    API 设计审查会议按照每周的日程安排进行直播，同时邀请开发者社区成员分享他们的想法。作为审查的一部分，会记录笔记并应用 GitHub 标签，假设它获得通过，相关的
    .NET API 将被编码为代码片段。最后，它移动到 [ASP.NET Core `api-approved` label](https://oreil.ly/TYc05)。
- en: From there, the issue serves as a point of reference for pull requests that
    aim to satisfy the proposal. A developer takes the issue, implements the API,
    writes unit tests, and creates a pull request (PR). The PR undergoes review, and
    when it’s merged, the API has to be documented, communicated, breaking changes
    captured and reported, promoted, shared, analyzed, and so on.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，这个问题作为满足提议的拉取请求的参考点。一个开发者拿起这个问题，实现 API，编写单元测试，并创建一个拉取请求（PR）。PR 经过审查后合并，API
    必须进行文档化、传播、捕捉和报告破坏性更改、推广、分享、分析等。
- en: All of this is for a single .NET API, and there are tens of thousands of .NET
    APIs. You’re in good hands with the strength of all the .NET contributors who
    are building the best platforms in modern app dev today.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是为了单个 .NET API，而 .NET API 的数量达到数万个。凭借所有构建现代应用程序开发最佳平台的 .NET 贡献者的力量，您可以放心！
- en: The software development industry is rather fond of open source software development.
    To me, being able to see how a feature is architected, designed, and implemented
    is a game-changer. The ability to post issues, propose features, carry on open
    discussions, maintain Kanban-style projects with automated status updates, collaborate
    with the dev team and others, and create pull requests are all capabilities that
    make this software *community-centric*. This ultimately makes for a better product,
    without question!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发行业对开源软件开发非常青睐。对我来说，能够看到一个功能是如何被架构化、设计和实现的是一个改变游戏规则的能力。发布问题、提议功能、进行开放讨论、维护自动状态更新的看板式项目、与开发团队和其他人合作，以及创建拉取请求等能力，使这款软件变得*以社区为中心*。这最终无疑会使产品更加出色！
- en: Your First Blazor App with the .NET CLI
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 .NET CLI 创建你的第一个 Blazor 应用程序
- en: 'Enough talk. Let’s jump in and have you make your very first Blazor app using
    the .NET CLI. The .NET CLI is cross-platform and works on Windows, Linux, and
    macOS. Install the .NET SDK, which includes the .NET CLI and runtime—[available
    as a free download](https://oreil.ly/zWMCk). Install .NET 6.0 because it’s an
    LTS version. With the .NET CLI, you’re able to create many .NET workloads. To
    create a new Blazor WebAssembly application, open a terminal and run the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 言归正传，让我们跳入并让你使用 .NET CLI 制作你的第一个 Blazor 应用程序。.NET CLI 跨平台，在 Windows、Linux 和
    macOS 上均可使用。安装 .NET SDK，其中包括 .NET CLI 和运行时 - [可以免费下载](https://oreil.ly/zWMCk)。安装
    .NET 6.0，因为这是一个 LTS 版本。使用 .NET CLI，你可以创建许多 .NET 工作负载。要创建新的 Blazor WebAssembly
    应用程序，请打开终端并运行以下命令：
- en: '[PRE0]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `dotnet new` command will have created a new Blazor WebAssembly application
    based on the template.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`dotnet new`命令将基于模板创建一个新的Blazor WebAssembly应用程序。'
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: There are many other templates available to you. .NET is free, open source,
    and amazing. For additional templates, see Microsoft’s list of [.NET default templates
    for `dotnet new`](https://oreil.ly/Lg1Nk).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用许多其他模板。.NET是免费的、开源的，并且非常棒。有关其他模板，请参阅Microsoft的[.NET默认模板列表 `dotnet new`](https://oreil.ly/Lg1Nk)。
- en: 'It will output the project to a newly created *FirstApp* directory. You should
    see command output similar to the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 它将输出项目到新创建的*FirstApp*目录。您应该会看到类似以下的命令输出：
- en: '[PRE1]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The template application comprises a single C# file, several Razor files, CSS
    files, and an index.html. This application has a few pages, basic navigation,
    data binding, event handling, and a few other common aspects of typical Blazor
    application development. Next, you’ll need to change directories. Use the `cd`
    command and pass the directory name:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 该模板应用程序包括一个单独的C#文件、几个Razor文件、CSS文件和一个index.html文件。此应用程序具有一些页面、基本导航、数据绑定、事件处理和典型Blazor应用程序开发的其他常见方面。接下来，您需要更改目录。使用`cd`命令并传递目录名称：
- en: '[PRE2]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Build the App
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建应用程序
- en: 'Once you’re in your new application’s directory, the template can be compiled
    using the following command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您进入新应用程序的目录，模板可以使用以下命令编译：
- en: '[PRE3]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After the app is compiled (has a successful `build`), you should see command
    output similar to the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序编译完成（成功执行`build`）后，您应该会看到类似以下的命令输出：
- en: '[PRE4]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Install Dev-cert
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装开发者证书
- en: 'If this is your first time building and running an ASP.NET Core application,
    you’ll need to trust the developer self-signed certificate for `localhost`. This
    can be done by running the following command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是您第一次构建和运行ASP.NET Core应用程序，您需要信任`localhost`的开发者自签名证书。可以通过运行以下命令来完成此操作：
- en: '[PRE5]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When prompted, answer “Yes” to install the cert.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当提示时，回答“是”来安装证书。
- en: Tip
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you don’t install and trust the dev-certs, you’ll get a warning that you’ll
    have to accept due to the site not being secured. If you’re running on a macOS,
    you’ll likely have to enter your password (twice) to accept the certificate.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有安装和信任开发者证书，您将收到一个警告，因为该站点未受保护而必须接受。如果您在macOS上运行，您可能需要输入密码（两次）来接受该证书。
- en: Run the App
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'To run the template app, use the following command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行模板应用程序，请使用以下命令：
- en: '[PRE6]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The command output will look similar to the following, and one of the first
    output lines will show where the app is hosted:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 命令输出将类似于以下内容，并且其中一行输出将显示应用程序托管的位置：
- en: '[PRE7]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `localhost` URL is the current device hostname with a randomly available
    port number. Navigate to the URL with the `https://` scheme: in my example, `https://localhost:7024`
    (yours will likely be different). The app will launch, and you’ll be able to interact
    with a fully functional Blazor WebAssembly app template as shown in [Figure 1-3](#first_template_app).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`localhost` URL是当前设备主机名加上一个随机可用的端口号。使用`https://`协议导航到该URL：在我的示例中，`https://localhost:7024`（您的可能会有所不同）。应用程序将启动，并且您将能够与完全功能的Blazor
    WebAssembly应用程序模板进行交互，如[图1-3](#first_template_app)所示。'
- en: '![lblz 0103](assets/lblz_0103.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![lblz 0103](assets/lblz_0103.png)'
- en: Figure 1-3\. First Blazor template app
  id: totrans-134
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-3\. 第一个Blazor模板应用程序
- en: To stop the app from running, end the terminal session. You can close your IDE
    after you’ve stopped the app from running. This Blazor WebAssembly template is
    [very well documented](https://oreil.ly/qVd9M) and limited in what it shows off.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止应用程序运行，请结束终端会话。在停止应用程序运行后，您可以关闭您的IDE。这个Blazor WebAssembly模板是[非常完善文档化](https://oreil.ly/qVd9M)，并且展示了其所示功能的局限性。
- en: Now that you know how to start creating your app, you might ask, “Where am I
    supposed to put my code?” I’m glad you asked.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何开始创建您的应用程序了，您可能会问：“我应该把我的代码放在哪里？” 我很高兴您问到了。
- en: The Code Must Live On
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码必须存活下去
- en: Code is only as good as where it is stored. If your code lives on your machine,
    and yours alone, that’s where it will stay forever. It won’t go anywhere else,
    and that’s a shame. GitHub provides a hosted solution for version control using
    Git, and it’s the best of its kind. Call me biased.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 代码只有在存储位置良好时才能发挥作用。如果您的代码只存在于您的计算机上，那么它将永远留在那里。它不会去任何其他地方，这真是一件遗憾的事情。GitHub提供了使用Git进行版本控制的托管解决方案，它是其类别中的最佳选择。请原谅我有所偏见。
- en: 'All of the source code for this book can be found on [GitHub](https://oreil.ly/learning-blazor-code).
    If you want to follow along in the code itself, you can clone the repository locally
    on your machine with the following [git CLI](https://oreil.ly/7AMOX) command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的所有源代码都可以在[GitHub](https://oreil.ly/learning-blazor-code)找到。如果您想在代码中跟随阅读，可以使用以下[git
    CLI](https://oreil.ly/7AMOX)命令在本地机器上克隆存储库：
- en: '[PRE8]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-141
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: This command will clone the repository into a new directory named *learning-blazor*.
    The new directory is from the root of where this command was executed. For more
    information about cloning a repository, see Git’s [`git clone` documentation](https://oreil.ly/fdnIo).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将克隆存储库到名为*learning-blazor*的新目录中。新目录是从执行此命令的根目录开始的。有关克隆存储库的更多信息，请参阅Git的[`git
    clone`文档](https://oreil.ly/fdnIo)。
- en: Once you’ve cloned the repository, you can open the solution file or the root
    directory in your favorite IDE. You can run the app locally if you’d like to explore
    it before you start the book. You’ll need to read through the [Getting Started](https://oreil.ly/jPOjv)
    markdown file.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆仓库后，您可以在您喜欢的IDE中打开解决方案文件或根目录。您可以在开始阅读书籍之前本地运行应用程序以便进行探索。您需要阅读[入门](https://oreil.ly/jPOjv)
    Markdown文件。
- en: Alternatively, you can visit the live site to explore its functionality. Using
    your favorite web browser, navigate to [*https://webassemblyof.net*](https://webassemblyof.net).
    If you have a Twitter, Google, or GitHub account, you could log in to the site
    and explore the app. If you don’t have one of those kinds of accounts, or if you’d
    rather not log in with them, you can register for an account. The only requirement
    is a valid email address that can be verified. A verification email will be sent
    to the address you provide, and you’ll create a password to use when logging in.
    In the next section, you’ll learn how this code is version-controlled.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问实时站点以探索其功能。使用您喜欢的Web浏览器导航到[*https://webassemblyof.net*](https://webassemblyof.net)。如果您有Twitter、Google或GitHub帐户，您可以登录到站点并探索应用程序。如果您没有这些帐户之一，或者您不愿意使用它们登录，您可以注册一个帐户。唯一的要求是您提供一个可以验证的有效电子邮件地址。将发送验证电子邮件到您提供的地址，并创建一个在登录时使用的密码。在下一节中，您将了解如何对这些代码进行版本控制。
- en: 'For code to live on, we need to have version control. Our Blazor application
    can use GitHub Actions to build, test, analyze, source generate, package, and
    deploy anything we require. GitHub Actions are explored a bit more in Chapters
    [5](ch05.html#chapter-five) and [9](ch09.html#chapter-nine). GitHub Actions are
    available for free for up to 2,000 minutes a month and 500 MB of storage. GitHub
    Actions are enjoyable to create and powerful for automating processes. With the
    GitHub Action Marketplace, you can discover published actions that you can consume
    in workflows. A GitHub Action workflow is defined as a YAML file that contains
    the instructions to run your composed GitHub Actions. For example, whenever code
    is pushed to the `main` branch in my GitHub repo, a build validation is triggered.
    The build validation is defined in a YAML file called *.github/workflows/build-validation.yml*:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了代码的持续存在，我们需要版本控制。我们的Blazor应用可以使用GitHub Actions构建、测试、分析、源代码生成、打包和部署我们需要的任何内容。GitHub
    Actions在第[5](ch05.html#chapter-five)章和第[9](ch09.html#chapter-nine)章中更详细地探讨。GitHub
    Actions每月免费提供高达2,000分钟和500 MB的存储空间。GitHub Actions的创建非常有趣，对于自动化流程非常强大。通过GitHub
    Action Marketplace，您可以发现发布的操作，可以在工作流中使用。GitHub Action工作流定义为包含运行组合GitHub Actions的指令的YAML文件。例如，每当代码推送到我的GitHub仓库的`main`分支时，将触发构建验证。构建验证定义在名为*.github/workflows/build-validation.yml*的YAML文件中：
- en: '[PRE9]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: From the perspective of continuous integration and continuous deployment (CI/CD),
    this is very powerful.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从持续集成和持续部署（CI/CD）的角度来看，这非常强大。
- en: 'The preceding GitHub workflow has the following characteristics:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 上述GitHub工作流具有以下特点：
- en: Its `name` is “Build.”
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其`name`为“Build”。
- en: It is triggered `on` a `push` to `main`, when any file in the changeset ends
    with *.cs*, *.css*, *.json*, *.razor*, or *.csproj*.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在将任何文件更改集中的文件以*.cs*、*.css*、*.json*、*.razor*或*.csproj*结尾时触发`main`分支上的`push`事件。
- en: 'It defines a single `build` job, which runs on the latest version of Ubuntu.
    The `build` job defines several `steps`:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了一个单一的`build`作业，运行在最新版本的Ubuntu上。`build`作业定义了几个`steps`：
- en: Check out the repo at the specific commit that triggered the run.
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查触发运行的特定提交的存储库。
- en: Set up .NET 6.0 within the context of the execution environment.
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行环境的上下文中设置.NET 6.0。
- en: Install dependencies via `dotnet restore`.
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`dotnet restore`安装依赖项。
- en: Compile the code using `dotnet build`.
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`dotnet build`编译代码。
- en: Test the code using `dotnet test`.
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`dotnet test`测试代码。
- en: It’s cool getting to see a simple Blazor app running, but what if I told you
    that you could learn more about Blazor using the [Telerik REPL for Blazor](https://oreil.ly/y22J4).
    The Blazor REPL (read-eval-print-loop) is an online program that allows you to
    write Blazor code in the browser and immediately compile and run it. It’s a great
    way to learn about Blazor, as it provides an interactive way to explore the code
    and tighten the feedback loop for rapid development.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 能看到一个简单的 Blazor 应用程序运行是很酷的，但如果我告诉你，你可以使用[Telerik Blazor REPL](https://oreil.ly/y22J4)来更深入地了解
    Blazor，你会怎么想呢？Blazor REPL（读取-求值-打印-循环）是一个在线程序，允许你在浏览器中编写 Blazor 代码并立即编译和运行它。这是学习
    Blazor 的一个很好的方式，因为它提供了一个交互式的方式来探索代码，并加快了快速开发的反馈循环。
- en: This is but one example among several within the application’s GitHub repo.
    As a developer who is onboarding with the sample application, it is important
    to understand all of the moving pieces involved. You’ll learn all that there is
    to know about the source code. Along the way, you’ll also learn how the code is
    deployed and hosted and the general flow of data. Next, we’re going to get a high-level
    overview of the application’s architecture.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是应用程序 GitHub 存储库中的几个示例之一。作为与示例应用程序同步的开发人员，了解涉及的所有移动部件非常重要。您将了解源代码的所有内容。在此过程中，您还将学习代码如何部署和托管以及数据流的一般流程。接下来，我们将高层次地概述应用程序的架构。
- en: Perusing the “Learning Blazor” Sample App
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览“学习 Blazor”示例应用程序
- en: Throughout this book, we’ll be working with the Learning Blazor model app. The
    best way to learn is to see things in action and get your hands dirty. The app
    will teach by providing examples of how to solve various problems. The Learning
    Blazor model app leverages a microservice architecture. The application wouldn’t
    be very exciting without some sort of meaningful or practical data. And while
    it’s thrilling to discuss all the bleeding-edge technologies, it’s much less engaging
    when the sample source code lacks real-world appeal.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将与学习 Blazor 模型应用程序一起工作。学习的最佳方法是亲自动手并实际操作。该应用程序将通过提供解决各种问题的示例来进行教学。学习
    Blazor 模型应用程序利用微服务架构。如果没有某种有意义或实际数据，该应用程序将毫无吸引力。虽然讨论所有尖端技术非常令人兴奋，但如果示例源代码缺乏现实世界的吸引力，则远不及此。
- en: As I said, we’ll go through each of these projects in the coming chapters, but
    let’s take a high-level look at what these projects do and how they’re put together.
    This should also give you an idea of all the different things you can do with
    Blazor and inspire you to write your own apps.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所说的，我们将在接下来的章节中逐个项目进行介绍，但是让我们先大致了解一下这些项目是如何运作和组合在一起的。这也应该让你对 Blazor 的各种可能有个概念，并激发你编写自己的应用程序。
- en: As shown in [Figure 1-4](#architecture-diagram), the app is architected such
    that all clients must request access to all APIs through an authentication provider.
    Once authenticated, the client can access the Web.Api and the Web.PwnedApi. These
    APIs rely on other services and APIs such as Twitter, ASP.NET Core SignalR, Logic
    Apps, and in-memory cache. They’re all part of the shared resource group, along
    with the Azure Static Web App. As a developer, when you push changes to the GitHub
    repository, various GitHub Actions are conditionally triggered that will deploy
    the latest code to the corresponding Azure resources. For more information on
    the various projects, see the [Appendix](app01.html#appendix). The sample application
    targets .NET 6 and uses C# 10.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 1-4](#architecture-diagram)所示，该应用程序的架构设计如下：所有客户端必须通过认证提供程序请求访问所有 API。一旦认证成功，客户端就可以访问
    Web.Api 和 Web.PwnedApi。这些 API 依赖于其他服务和 API，如 Twitter、ASP.NET Core SignalR、逻辑应用和内存缓存。它们都是共享资源组的一部分，还包括
    Azure 静态 Web 应用程序。作为开发人员，当您将更改推送到 GitHub 存储库时，将有条件触发各种 GitHub Actions，这些操作将最新代码部署到相应的
    Azure 资源中。有关各项目的更多信息，请参阅[附录](app01.html#appendix)。示例应用程序针对 .NET 6 并使用 C# 10。
- en: '![lblz 0104](assets/lblz_0104.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![lblz 0104](assets/lblz_0104.png)'
- en: Figure 1-4\. Architecture diagram
  id: totrans-164
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-4\. 架构图
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We’ve covered a lot of ground in this chapter. We discussed the origins of Blazor
    and .NET web app development. From a language standpoint, we’ve compared JavaScript
    SPAs to those of .NET. I’ve gone over why you’d use Blazor over any other SPA.
    You created your first Blazor app from a template, and you were introduced to
    the overall architecture of the Learning Blazor model app for this book. In the
    next chapter, we’re going to dive into the source code of this app and start talking
    about Blazor app startup.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章涵盖了大量内容。我们讨论了Blazor和.NET Web应用开发的起源。从语言的角度来看，我们比较了JavaScript单页应用和.NET的差异。我解释了为什么你会选择Blazor而不是其他任何单页应用。你从模板创建了你的第一个Blazor应用，并且介绍了本书中Learning
    Blazor模型应用的整体架构。在下一章中，我们将深入探讨该应用的源代码，并开始讨论Blazor应用的启动过程。
- en: ^([1](ch01.html#idm46365042441744-marker)) “Stack Overflow Developer Survey
    2021,” Stack Overflow, [*https://oreil.ly/bngvt*](https://oreil.ly/bngvt).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch01.html#idm46365042441744-marker)) “Stack Overflow Developer Survey
    2021,” Stack Overflow, [*https://oreil.ly/bngvt*](https://oreil.ly/bngvt).
