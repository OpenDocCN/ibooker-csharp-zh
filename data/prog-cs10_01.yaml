- en: Chapter 1\. Introducing C#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章 介绍 C#
- en: The C# programming language (pronounced “see sharp”) is used for many kinds
    of applications, including websites, cloud-based systems, IoT devices, machine
    learning, desktop applications, embedded controllers, mobile apps, games, and
    command-line utilities. C#, along with the supporting runtime, libraries, and
    tools known collectively as .NET, has been center stage for Windows developers
    for over 20 years. Today, .NET is cross-platform and open source, enabling applications
    and services written in C# to run on operating systems including Android, iOS,
    macOS, and Linux, as well as on Windows.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C# 编程语言（发音为 “see sharp”）用于许多类型的应用程序，包括网站、基于云的系统、物联网设备、机器学习、桌面应用程序、嵌入式控制器、移动应用程序、游戏和命令行实用程序。C#
    和相关的运行时、库和工具被称为 .NET，已经在 Windows 开发者中心舞台上超过 20 年。如今，.NET 是跨平台和开源的，使得用 C# 编写的应用程序和服务可以在包括
    Android、iOS、macOS 和 Linux 在内的操作系统上运行，以及 Windows。
- en: 'The release of C# 10.0 and its corresponding runtime, .NET 6.0, marks an important
    milestone: C#’s journey to becoming a fully cross-platform, open source language
    is now complete. Although open source implementations have existed for most of
    C#’s history, a sea change began in 2016 when Microsoft released .NET Core 1.0,
    the first platform fully supported by Microsoft for running C# on Linux and macOS
    as well as Windows. Library and tool support for .NET Core was initially patchy,
    so Microsoft continued to ship new versions of its older runtime, the closed-source,
    Windows-only .NET Framework, but six years on, that old runtime is effectively
    being retired,^([1](ch01.xhtml#idm45884866324192)) now that the cross-platform
    version has comprehensively overtaken it. .NET 5.0 dropped the “Core” from its
    name to signify that it is now the main event, but it is with .NET 6.0 that the
    cross-platform version has really arrived, because this version enjoys full *Long
    Term Support* (LTS) status. For the first time, the platform-independent version
    of C# and .NET has superseded the old .NET Framework.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: C# 10.0 的发布及其对应的运行时 .NET 6.0 标志着一个重要的里程碑：C# 成为完全跨平台、开源语言的旅程现已完成。尽管在 C# 的大部分历史中都存在开源实现，但在
    2016 年，微软发布了 .NET Core 1.0，这是第一个由微软全面支持在 Linux 和 macOS 以及 Windows 上运行 C# 的平台。最初
    .NET Core 的库和工具支持并不完善，因此微软继续发布其较旧的运行时版本，即仅限 Windows 的封闭源 .NET Framework，但六年后，这个旧运行时版本实际上已经退出，^([1](ch01.xhtml#idm45884866324192))
    现在跨平台版本全面超越了它。.NET 5.0 删除了其名称中的 “Core”，表明它现在是主要版本，但是在 .NET 6.0 中，跨平台版本才真正到来，因为这个版本享有完整的
    *长期支持* (LTS) 状态。首次，这个与平台无关的 C# 和 .NET 版本已经取代了旧的 .NET Framework。
- en: C# and .NET are open source projects, although it didn’t start out that way.
    In C#’s early history, Microsoft guarded all of its source code closely, but in
    2014, the [.NET Foundation](https://oreil.ly/vYiMY) was created to foster the
    development of open source projects in the .NET world. Many of Microsoft’s most
    important C# and .NET projects are now under the foundation’s governance (in addition
    to many non-Microsoft projects). This includes [Microsoft’s C# compiler](https://github.com/dotnet/roslyn)
    and also the [.NET runtime and libraries](https://github.com/dotnet/runtime).
    Today, pretty much everything surrounding C# is developed in the open, with code
    contributions from outside of Microsoft being welcome. New language feature proposals
    are managed on GitHub, enabling community involvement from the earliest stages.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: C# 和 .NET 是开源项目，尽管最初并非如此。在 C# 的早期历史中，微软严格保护其所有源代码，但在 2014 年创建了 [.NET Foundation](https://oreil.ly/vYiMY)
    来促进 .NET 世界中开源项目的发展。现在，微软许多重要的 C# 和 .NET 项目都在该基金会的管理下（除了许多非微软项目）。这包括 [微软的 C# 编译器](https://github.com/dotnet/roslyn)
    和 [.NET 运行时与库](https://github.com/dotnet/runtime)。如今，几乎围绕 C# 的所有内容都是在公开开发的，欢迎外部人员贡献代码。新的语言特性提案在
    GitHub 上进行管理，从最早的阶段就能够进行社区参与。
- en: Why C#?
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择 C#？
- en: Although there are many ways you can use C#, other languages are always an option.
    Why might you choose C# over those? It will depend on what you need to do and
    what you like and dislike in a programming language. I find that C# provides considerable
    power, flexibility, and performance and works at a high enough level of abstraction
    that I don’t expend vast amounts of effort on little details not directly related
    to the problems my programs are trying to solve.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以使用多种方式使用C#，其他语言始终是一个选择。为什么你会选择C#而不是其他语言？这取决于您需要做什么，以及您在编程语言中喜欢和不喜欢的方面。我发现C#提供了相当大的力量、灵活性和性能，并且以足够高的抽象级别工作，以至于我不会在程序试图解决的问题的细节上花费大量精力。
- en: Much of C#’s power comes from the range of programming techniques it supports.
    For example, it offers object-oriented features, generics, and functional programming.
    It supports both dynamic and static typing. It provides powerful list- and set-oriented
    features, thanks to Language Integrated Query (LINQ). It has intrinsic support
    for asynchronous programming. Moreover, the various development environments that
    support C# all offer a wide range of productivity-enhancing features.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: C#的强大之处在于它支持的多种编程技术。例如，它提供面向对象的特性、泛型和函数式编程。它支持动态和静态类型。由于语言集成查询（LINQ），它提供了强大的列表和集合操作功能。它还具有异步编程的内在支持。此外，支持C#的各种开发环境都提供了广泛的增强生产力的功能。
- en: C# provides options for balancing ease of development against performance. The
    runtime has always provided a garbage collector (GC) that frees developers from
    much of the work associated with recovering memory that the program is no longer
    using. A GC is a common feature in modern programming languages, and while it
    is a boon for most programs, there are some specialized scenarios where its performance
    implications are problematic, so C# enables more explicit memory management, giving
    you the option to trade ease of development for runtime performance but without
    the loss of type safety. This makes C# suitable for certain performance-critical
    applications that for years were the preserve of less safe languages such as C
    and C++.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: C#提供了在开发便捷性与性能之间取得平衡的选项。运行时一直提供垃圾回收器（GC），使开发人员不必过多地处理程序不再使用的内存回收工作。GC在现代编程语言中是一项常见功能，虽然对大多数程序有益，但在某些特定场景下其性能影响可能成问题，因此C#支持更显式的内存管理方式，使您可以在不丧失类型安全性的前提下，在开发便捷性与运行时性能之间进行权衡。这使得C#适用于多年来一直是较不安全语言（如C和C++）所独有的某些对性能要求极高的应用场景。
- en: Languages do not exist in a vacuum—high-quality libraries with a broad range
    of features are essential. Some elegant and academically beautiful languages are
    glorious right up until you want to do something prosaic, such as talking to a
    database or determining where to store user settings. No matter how powerful a
    set of programming idioms a language offers, it also needs to provide full and
    convenient access to the underlying platform’s services. C# is on very strong
    ground here, thanks to its runtime, built-in class libraries, and extensive third-party
    library support.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言并非孤立存在，具备广泛特性的高质量库至关重要。一些优雅而学术美观的语言在处理平凡任务时仍显光辉，例如与数据库交互或确定用户设置存储位置。无论语言提供了多么强大的编程习语，它还需要提供对底层平台服务的完整便捷访问。在这方面，C#表现非常强大，归功于其运行时、内置类库以及广泛的第三方库支持。
- en: .NET encompasses both the runtime and the main class libraries that C# programs
    use. The runtime part is called the *Common Language Runtime* (usually abbreviated
    to CLR) because it supports not just C# but any .NET language. Microsoft also
    offers Visual Basic, F#, and .NET extensions for C++, for example. The CLR has
    a *Common Type System* (CTS) that enables code from multiple languages to interoperate
    freely, which means that .NET libraries can normally be used from any .NET language—F#
    can consume libraries written in C#, C# can use Visual Basic libraries, and so
    on.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: .NET包括C#程序使用的运行时和主要类库。运行时部分称为*公共语言运行时*（通常缩写为CLR），因为它不仅支持C#，还支持任何.NET语言。例如，Microsoft还提供Visual
    Basic、F#以及C++的.NET扩展。CLR具有*公共类型系统*（CTS），它使来自多种语言的代码可以自由互操作，这意味着.NET库通常可以从任何.NET语言中使用——F#可以使用用C#编写的库，C#可以使用Visual
    Basic库，等等。
- en: There is an extensive set of class libraries built into .NET. These have gone
    by a few names over the years, including Base Class Library (BCL), Framework Class
    Library, and framework libraries, but Microsoft now seems to have settled on *runtime
    libraries* as the name for this part of .NET. These libraries provide wrappers
    for many features of the underlying operating system (OS), but they also provide
    a considerable amount of functionality of their own, such as collection classes
    and JSON processing.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中内置了一套庞大的类库集合。多年来，这些类库曾用过几个名称，包括基础类库 (BCL)、框架类库和框架库，但是微软现在似乎已经将 *运行时类库*
    定为 .NET 这一部分的名称。这些类库为许多底层操作系统 (OS) 功能提供了包装器，同时它们本身也提供了大量的功能，例如集合类和 JSON 处理等。
- en: The .NET runtime class libraries are not the whole story—many other systems
    provide their own .NET libraries. For example, there are libraries that enable
    C# programs to use popular cloud services. As you’d expect, Microsoft provides
    comprehensive .NET libraries for working with services in its Azure cloud platform.
    Likewise, Amazon provides a fully featured development kit for using Amazon Web
    Services (AWS) from C# and other .NET languages. And libraries do not have to
    be associated with particular services. There’s a large ecosystem of .NET libraries,
    some commercial and some free, including mathematical utilities, parsing libraries,
    and user interface (UI) components, to name just a few. Even if you get unlucky
    and need to use an OS feature that doesn’t have any .NET library wrappers, C#
    offers various mechanisms for working with other kinds of APIs, such as the C-style
    APIs available in Win32, macOS, and Linux, or APIs based on the Component Object
    Model (COM) in Windows.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 运行时类库并非全部内容——许多其他系统也提供了它们自己的 .NET 类库。例如，有些类库使得 C# 程序可以使用流行的云服务。正如你所预期的那样，Microsoft
    提供了全面的 .NET 类库，用于与其 Azure 云平台上的服务进行交互。同样，亚马逊提供了一个功能完备的开发工具包，供使用 C# 和其他 .NET 语言访问
    Amazon Web Services (AWS)。并且，类库并不一定要与特定服务相关联。有一个庞大的 .NET 类库生态系统，其中既有商业产品，也有免费产品，包括数学工具、解析类库以及用户界面
    (UI) 组件等等。即使你不幸需要使用一个没有任何 .NET 类库包装器的操作系统特性，C# 也提供了各种机制，用于与其他类型的 API 进行交互，例如在
    Win32、macOS 和 Linux 上可用的 C 风格 API，或者在 Windows 上基于组件对象模型 (COM) 的 API。
- en: In addition to libraries, there are also numerous applications frameworks. .NET
    has built-in frameworks for creating web apps and web APIs, desktop applications,
    and mobile applications. There are also open source frameworks for various styles
    of distributed systems development, such as high-volume event processing with
    [Reaqtor](https://reaqtive.net) or high-availability globally distributed systems
    with [Orleans](https://oreil.ly/kxaEg).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 除了类库之外，还有许多应用框架。.NET 内置了用于创建 Web 应用程序和 Web API、桌面应用程序以及移动应用程序的框架。还有针对各种分布式系统开发风格的开源框架，例如高容量事件处理的
    [Reaqtor](https://reaqtive.net) 或者全球分布式高可用系统的 [Orleans](https://oreil.ly/kxaEg)。
- en: Finally, with .NET having been around for over two decades, many organizations
    have invested extensively in technology built on this platform. So C# is often
    the natural choice for reaping the rewards of these investments.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，随着 .NET 已经存在了二十多年，许多组织已经大量投资于基于这一平台构建的技术。因此，C# 往往是获得这些投资回报的自然选择。
- en: In summary, with C# we get a strong set of abstractions built into the language,
    a powerful runtime, and easy access to an enormous amount of library and platform
    functionality.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，使用 C# 我们得到了一组内置的强大抽象，一个强大的运行时，以及轻松访问大量的类库和平台功能。
- en: Managed Code and the CLR
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 托管代码和 CLR
- en: C# was the first language designed to be a native in the world of the CLR. This
    gives C# a distinctive feel. It also means that if you want to understand C#,
    you need to understand the CLR and the way in which it runs code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: C# 是第一种旨在成为 CLR 世界中本地语言的语言。这赋予了 C# 独特的感觉。这也意味着，如果你想理解 C#，你需要了解 CLR 及其运行代码的方式。
- en: For years, the most common way for a compiler to work was to process source
    code and to produce output in a form that could be executed directly by the computer’s
    CPU. Compilers would produce *machine code*—a series of instructions in whatever
    binary format was required by the kind of CPU the computer had. Many compilers
    still work this way, but the C# compiler does not. Instead, it uses a model called
    *managed code*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，编译器处理源代码并生成可由计算机 CPU 直接执行的输出形式，一直是最常见的工作方式。编译器会生成*机器码* ——符合计算机 CPU 所需的二进制格式的一系列指令。许多编译器仍然采用这种方式工作，但
    C# 编译器不是这样。它使用一种称为*托管代码*的模型。
- en: With managed code, the compiler does not generate the machine code that the
    CPU executes. Instead, the compiler produces a form of binary code called the
    *intermediate language* (IL). The executable binary is produced later, usually,
    although not always, at runtime. The use of IL enables features that are hard
    or even impossible to provide under the more traditional model.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在托管代码中，编译器不会生成 CPU 执行的机器码。相反，编译器生成一种称为*中间语言*（IL）的二进制代码形式。可执行二进制通常在运行时生成，虽然不总是如此。使用
    IL 使得在传统模型下难以或者甚至不可能提供的功能成为可能。
- en: Perhaps the most visible benefit of the managed model is that the compiler’s
    output is not tied to a single CPU architecture. For example, the CPUs used in
    most modern computers support both 32-bit and 64-bit instruction sets (known,
    respectively, for historical reasons as *x86* and *x64*). With the old model of
    compiling source code into machine language, you’d need to choose which of these
    to support, building multiple versions of your component if you need target more
    than one. But with .NET, you can build a single component that can run without
    modification in either 32-bit or 64-bit processes. The same component could even
    run on completely different architectures such as ARM (a processor architecture
    widely used in mobile phones, newer Macs, and also in tiny devices such as the
    Raspberry Pi). With a language that compiles directly to machine code, you’d need
    to build different binaries for each of these, or in some cases you might build
    a single file that contains multiple copies of the code, one for each supported
    architecture. With .NET, you can compile a single component that contains just
    one version of the code, and it can run on any of them. It would even be able
    to run on platforms that weren’t supported at the time you compiled the code if
    a suitable runtime became available in the future. (For example, .NET components
    written years before Apple released its first ARM-based Macs can run natively,
    without relying on the [*Rosetta*](https://oreil.ly/MO6W1) translation technology
    that normally enables older code to work on the newer processors.) More generally,
    any kind of improvement to the CLR’s code generation—whether that’s support for
    new CPU architectures or just performance improvements for existing ones—is instantly
    of benefit to all .NET languages. For example, older versions of the CLR did not
    take advantage of the vector processing extensions available on modern x86 and
    x64 processors, but the current versions will now often exploit these when generating
    code for loops. All code running on current versions of .NET benefits from this,
    including components that were built years before this enhancement was added.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 可能托管模型最明显的好处是，编译器的输出不与单一的 CPU 架构绑定。例如，大多数现代计算机使用的 CPU 支持32位和64位指令集（分别因历史原因而称为*x86*和*x64*）。在旧模型下将源代码编译成机器语言时，您需要选择要支持的指令集之一，并且在需要目标多个指令集时，需要构建多个版本的组件。但是在
    .NET 中，您可以构建一个单一的组件，无需修改即可在32位或64位进程中运行。同一组件甚至可以在完全不同的架构上运行，例如 ARM（一种广泛用于手机、较新的
    Mac 和树莓派等小型设备的处理器架构）。如果使用直接编译为机器码的语言，则需要为每种架构构建不同的二进制文件，或者在某些情况下，可能会构建一个包含多个代码副本的单一文件，每个副本针对每种支持的架构。在
    .NET 中，您可以编译一个只包含一个代码版本的单一组件，它可以在任何架构上运行。即使在编译代码时未支持的平台未来提供了合适的运行时，这些组件也可以本地运行，而不依赖于通常用于使旧代码在新处理器上工作的[*Rosetta*](https://oreil.ly/MO6W1)翻译技术。更一般地说，CLR
    代码生成的任何改进——无论是对新 CPU 架构的支持还是对现有架构的性能改进——都会立即使所有 .NET 语言受益。例如，早期版本的 CLR 没有利用现代
    x86 和 x64 处理器上可用的向量处理扩展，但当前版本通常在生成循环代码时会利用这些扩展。所有运行在当前 .NET 版本上的代码都从中受益，包括在此增强功能添加之前构建的组件。
- en: The exact moment at which the CLR generates executable machine code can vary.
    Typically, it uses an approach called *just-in-time* (JIT) compilation, in which
    each individual function’s machine code is generated the first time it runs. However,
    it doesn’t have to work this way. One of the runtime implementations, called Mono,
    is able to interpret IL directly without ever converting it to runnable machine
    language, which is useful on platforms such as iOS where legal constraints may
    prevent JIT compilation. The .NET Software Development Kit (SDK) also provides
    a tool called *crossgen*, which enables you to build precompiled code alongside
    the IL. This *ahead-of-time* (AoT) compilation can improve an application’s startup
    time. There’s also a whole separate runtime called .NET Native that only supports
    precompilation and which is used by Windows Store Apps built for the Universal
    Windows Platform (UWP). (Be aware that Microsoft has announced that the Windows-only
    .NET Native runtime is likely to be phased out and replaced by NativeAOT, its
    cross-platform successor.)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: CLR生成可执行机器代码的确切时机可能会有所不同。通常情况下，它使用一种称为*即时*（JIT）编译的方法，即每个单独函数的机器代码在第一次运行时生成。但它不一定非得这样工作。运行时实现之一称为Mono，能够直接解释IL，而不必将其转换为可运行的机器语言，这在诸如iOS这样的平台上非常有用，因为法律约束可能阻止JIT编译。.NET软件开发工具包（SDK）还提供了一个名为*crossgen*的工具，它使你能够在IL旁边构建预编译代码。这种*提前编译*（AoT）可以提高应用程序的启动时间。还有一个完全独立的运行时称为.NET
    Native，它仅支持预编译，并且被用于为通用Windows平台（UWP）构建的Windows Store应用程序。（请注意，微软已宣布Windows专用的.NET
    Native运行时可能会被其跨平台后继者NativeAOT所取代，逐步淘汰。）
- en: Note
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: Even when you precompile code with crossgen, generation of executable code can
    still happen at runtime. The CLR’s *tiered compilation* feature may choose to
    recompile a method dynamically to optimize it better for the ways it is being
    used at runtime, and it can do this whether you’re using JIT or AoT.^([2](ch01.xhtml#idm45884864958992))
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 即使使用crossgen预编译代码，仍然可能在运行时生成可执行代码。CLR的*分层编译*功能可以选择动态重新编译方法，以优化其在运行时的使用方式，无论您使用JIT还是AoT，它都可以做到这一点。^([2](ch01.xhtml#idm45884864958992))
- en: Managed code has ubiquitous type information. The .NET runtime requires this
    to be present, because it enables certain runtime features. For example, .NET
    offers various automatic serialization services, in which objects can be converted
    into binary or textual representations of their state, and those representations
    can later be turned back into objects, perhaps on a different machine. This sort
    of service relies on a complete and accurate description of an object’s structure,
    something that’s guaranteed to be present in managed code. Type information can
    be used in other ways. For example, unit test frameworks can use it to inspect
    code in a test project and discover all of the unit tests you have written. This
    relies on the CLR’s *reflection* services, which are the topic of [Chapter 13](ch13.xhtml#ch_reflection).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 托管代码具有普遍存在的类型信息。.NET 运行时需要这些信息存在，因为它启用了某些运行时特性。例如，.NET 提供各种自动序列化服务，可以将对象转换为其状态的二进制或文本表示，并且稍后可以将这些表示再转换回对象，甚至可能在不同的计算机上。这种服务依赖于对象结构的完整和准确描述，在托管代码中是有保证的。类型信息还可以用于其他方面。例如，单元测试框架可以使用它来检查测试项目中的代码，并发现你编写的所有单元测试。这依赖于CLR的*反射*服务，这是[第13章](ch13.xhtml#ch_reflection)的主题。
- en: Although C#’s close connection with the runtime is one of its main defining
    features, it’s not the only one. There’s a certain philosophy underpinning C#’s
    design.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管C#与运行时的紧密连接是其主要的定义特征之一，但这并不是唯一的特征。C#的设计背后有一定的哲学支持。
- en: C# Prefers Generality to Specialization
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#更偏向于泛化而不是特化
- en: C# favors general-purpose language features over specialized ones. C# is now
    on its 10th major version, and with every release, the language’s designers had
    specific scenarios in mind when designing new features. However, they have always
    tried hard to ensure that each element they add is useful beyond these primary
    scenarios.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: C#更倾向于通用语言特性而不是专用特性。C#现在已经是其第10个主要版本，并且每次发布时，语言的设计者都在设计新功能时考虑了特定的场景。然而，他们始终努力确保每个添加的元素在超出这些主要场景时也是有用的。
- en: For example, a few years ago, the C# language designers decided to add features
    to C# to make database access feel well integrated with the language. The resulting
    technology, Language Integrated Query (LINQ, described in [Chapter 10](ch10.xhtml#ch_linq)),
    certainly supports that goal, but they achieved this without adding any direct
    support for data access to the language. Instead, the design team introduced a
    series of quite diverse-seeming capabilities. These included better support for
    functional programming idioms, the ability to add new methods to existing types
    without resorting to inheritance, support for anonymous types, the ability to
    obtain an object model representing the structure of an expression, and the introduction
    of query syntax. The last of these has an obvious connection to data access, but
    the rest are harder to relate to the task at hand. Nonetheless, these can be used
    collectively in a way that makes certain data access tasks significantly simpler.
    But the features are all useful in their own right, so as well as supporting data
    access, they enable a much wider range of scenarios. For example, these additions
    made it much easier to process lists, sets, and other groups of objects, because
    the new features work for collections of things from any origin, not just databases.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，几年前，C# 语言设计师决定向 C# 添加功能，使数据库访问与语言紧密集成。由此产生的技术，即语言集成查询（LINQ，详见 [第10章](ch10.xhtml#ch_linq)），确实支持了这一目标，但他们在不向语言直接添加数据访问支持的情况下实现了这一点。设计团队引入了一系列看似差异很大的能力，包括更好地支持函数式编程习惯用法，能够在不使用继承的情况下向现有类型添加新方法，支持匿名类型，能够获取表示表达式结构的对象模型，并引入了查询语法。其中最后一个与数据访问有明显的关联，但其他的与当前任务的关联则较为困难。尽管如此，这些能力可以集体使用，显著简化某些数据访问任务。这些功能在其自身权威上都很有用，因此除了支持数据访问外，它们还能够支持更广泛的场景。例如，这些添加使得处理列表、集合和其他对象组变得更加容易，因为新功能适用于来自任何来源的事物集合，而不仅仅是数据库。
- en: One illustration of this philosophy of generality was a language feature that
    was prototyped for C# but which its designers ultimately chose not to go ahead
    with. The feature would have enabled you to write XML directly in your source
    code, embedding expressions to calculate values for certain bits of content at
    runtime. The prototype compiled this into code that generated the completed XML
    at runtime. Microsoft Research demonstrated this publicly, but this feature didn’t
    ultimately make it into C#, although it did later ship in another .NET language,
    Visual Basic, which also got some specialized query features for extracting information
    from XML documents. Embedded XML expressions are a relatively narrow facility,
    only useful when you’re creating XML documents. As for querying XML documents,
    C# supports this functionality through its general-purpose LINQ features, without
    needing any XML-specific language features. XML’s star has waned since this language
    concept was mooted, having been usurped in many cases by JSON (which will doubtless
    be eclipsed by something else in years to come). Had embedded XML made it into
    C#, it would by now feel like a slightly anachronistic curiosity.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种通用性哲学的一个例证是为 C# 原型化但最终设计师们选择不继续推进的语言功能。该功能将允许您直接在源代码中编写 XML，在运行时嵌入表达式以计算特定内容的值。该原型将其编译为在运行时生成完成的
    XML 的代码。微软研究部门公开展示了这一功能，但这一特性最终没有进入 C#，尽管它后来在另一种 .NET 语言 Visual Basic 中推出，并为从
    XML 文档中提取信息提供了一些专门的查询功能。嵌入式 XML 表达式是一个相对狭窄的功能，只在创建 XML 文档时有用。至于查询 XML 文档，C# 通过其通用的
    LINQ 功能支持此功能，而无需任何特定于 XML 的语言功能。自从提出这个语言概念以来，XML 的星光已经逐渐黯淡，在许多情况下已被 JSON 取代（毫无疑问，这些年后将被其他东西所取代）。如果嵌入式
    XML 最终进入了 C#，那么现在它可能会感觉像一个略显过时的奇特现象。
- en: The new features added in subsequent versions of C# continue in the same vein.
    For example, the deconstruction and pattern-matching features added across the
    last few versions of C# are aimed at making life easier in subtle but useful ways
    and are not limited to any particular application area.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续版本的 C# 中添加的新功能继续沿着同样的思路发展。例如，跨过去几个版本添加的解构和模式匹配功能旨在以微妙但有用的方式简化生活，并且不限于任何特定的应用领域。
- en: C# Standards and Implementations
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 标准与实现
- en: 'Before we can get going with some actual code, we need to know which implementation
    of C# and the runtime we are targeting. The standards body Ecma has written specifications
    that define language and runtime behavior (ECMA-334 and ECMA-335, respectively)
    for C# implementations. This has made it possible for multiple implementations
    of C# and the runtime to emerge. At the time of writing, there are four in widespread
    use: Mono, .NET Native, .NET (formerly known as .NET Core), and .NET Framework.
    Somewhat confusingly, Microsoft is behind all of these, although it didn’t start
    out that way.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以开始编写实际代码之前，我们需要知道我们正在目标化哪个 C# 实现和运行时。Ecma 标准化机构编写了定义 C# 语言和运行时行为的规范（分别是
    ECMA-334 和 ECMA-335）。这使得多个 C# 实现和运行时得以出现。目前，广泛使用的有四种：Mono、.NET Native、.NET（之前称为
    .NET Core）和 .NET Framework。有些令人困惑的是，微软背后支持了所有这些项目，尽管最初并非如此。
- en: Many .NETs
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 许多 .NET 实现
- en: The Mono project was launched in 2001 and did not originate from Microsoft.
    (This is why it doesn’t have .NET in its name—it can use the name C# because that’s
    what the standards call the language, but back in the pre-.NET Foundation days,
    the .NET brand was exclusively used by Microsoft.) Mono started out with the goal
    of enabling Linux desktop application development in C#, but it went on to add
    support for iOS and Android. That crucial move helped Mono find its niche, because
    it is now mainly used to create cross-platform mobile device applications in C#.
    Mono now also supports targeting WebAssembly (also known as WASM) and includes
    an implementation of the CLR that can run in any standards-compliant web browser,
    enabling C# code to run on the client side in web applications. This is often
    used in conjunction with a .NET application framework called Blazor, which enables
    you to build HTML-based user interfaces while using C# to implement behavior.
    The Blazor-with-WASM combination also makes C# a viable language for working with
    platforms such as Electron, which use web client technologies to create cross-platform
    desktop applications. (Blazor doesn’t require WASM—it can also work with C# code
    compiled normally and running on the .NET runtime; this is the basis for .NET’s
    Multi-platform App UI (MAUI), which makes it possible to write a single application
    that can run on Android, iOS, macOS, and Windows.)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Mono 项目于 2001 年启动，并非起源于微软。（这就是为什么它的名字中没有 .NET，它可以使用 C# 这个名称，因为标准称该语言为 C#，但在
    .NET 基金会成立前，.NET 品牌专门由微软使用。）Mono 最初的目标是在 Linux 上支持使用 C# 进行桌面应用程序开发，但后来它增加了对 iOS
    和 Android 的支持。这一重要举措帮助 Mono 找到了自己的市场定位，因为它现在主要用于开发跨平台移动设备应用程序的 C#。现在，Mono 还支持目标
    WebAssembly（也称为 WASM），并包括一个可以在任何符合标准的 Web 浏览器中运行的 CLR 实现，使得 C# 代码能够在 Web 应用程序的客户端上运行。这通常与一个名为
    Blazor 的 .NET 应用程序框架一起使用，Blazor 允许您构建基于 HTML 的用户界面，同时使用 C# 实现行为。Blazor 与 WASM
    的组合还使得 C# 成为与 Electron 等使用 Web 客户端技术创建跨平台桌面应用程序的平台合作的一种可行语言。（Blazor 不需要 WASM，它也可以使用正常编译的
    C# 代码在 .NET 运行时上运行；这是 .NET 的多平台应用程序用户界面（MAUI）的基础，它使得编写可以在 Android、iOS、macOS 和
    Windows 上运行的单一应用程序成为可能。）
- en: 'Mono was open source from the start and has been supported by a variety of
    companies over its existence. In 2016, Microsoft acquired the company that had
    stewardship of Mono: Xamarin. For now, Microsoft retains Xamarin as a distinct
    brand, positioning it as the way to write cross-platform C# applications that
    can run on mobile devices. Mono’s core technology has been merged into Microsoft’s
    .NET runtime codebase. This was the endpoint of several years of convergence in
    which Mono gradually shared more and more in common with .NET. Initially Mono
    provided its own implementations of everything: C# compiler, libraries, and the
    CLR. But when Microsoft released an open source version of its own compiler, the
    Mono tools moved over to that. Mono used to have its own complete implementation
    of the .NET runtime libraries, but ever since Microsoft first released the open
    source .NET Core, Mono has been depending increasingly on that. Today, Mono is
    effectively one of two CLR implementations in the main .NET runtime repository,
    enabling support for mobile and WebAssembly runtime environments.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Mono从一开始就是开源的，并且在其存在的整个过程中得到了多家公司的支持。2016年，微软收购了拥有Mono管理权的公司：Xamarin。目前，微软将Xamarin作为一个独立的品牌保留下来，并将其定位为编写可在移动设备上运行的跨平台C#应用程序的方式。Mono的核心技术已经并入了微软的.NET运行时代码库。这是多年融合的终点，其中Mono逐渐与.NET共享越来越多的共同点。最初，Mono提供了自己的一套实现：C#编译器、库和CLR。但是当微软发布了其自己的开源编译器时，Mono工具就转移到了那里。Mono曾经有自己完整的.NET运行时库实现，但自从微软首次发布开源.NET
    Core以来，Mono越来越依赖于它。如今，Mono实际上是主要.NET运行时库中两个CLR实现之一，支持移动和WebAssembly运行时环境。
- en: 'What about the other three implementations, all of which seem to be called
    .NET? There is .NET Native, used in UWP apps, and as the preceding section discussed,
    this is a specialized version of .NET that supports only AoT compilation. However,
    .NET Native is slated to be replaced by NativeAOT, which will effectively be a
    feature of .NET instead of a completely separate implementation, so in practice
    we have just two current, non-doomed versions: .NET Framework (Windows only, closed-source)
    and .NET (cross-platform, open source; previously called .NET Core). However,
    as mentioned earlier, Microsoft is not planning to add any new features to the
    Windows-only .NET Framework, so this leaves .NET 6.0 as effectively the only current
    version.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 其他三种实现是什么情况呢？它们似乎都被称为.NET？其中之一是.NET Native，用于UWP应用程序，正如前文所述，这是.NET的一种专门版本，仅支持AoT编译。然而，.NET
    Native计划被NativeAOT取代，后者将有效地成为.NET的一个特性，而不是完全独立的实现，因此在实际应用中，我们现在只有两个当前的、非注定失败的版本：.NET
    Framework（仅限Windows，闭源）和.NET（跨平台，开源；以前称为.NET Core）。然而，正如前面提到的，微软不打算向仅限Windows的.NET
    Framework添加任何新功能，因此这使得.NET 6.0实际上是唯一的当前版本。
- en: This convergence back to one major current version was one of the primary goals
    of .NET 6, making it a particularly significant release. However, it’s useful
    to know about the other versions because you may well come across live systems
    that continue to run on them. One reason for .NET Framework’s continued popularity
    is that there are a handful of things it can do that .NET 6.0 cannot. .NET Framework
    only runs on Windows, whereas .NET 6.0 supports Windows, macOS, and Linux, and
    although this makes .NET Framework less widely usable, it means it can support
    some Windows-specific features. For example, there is a section of the .NET Framework
    Class Library dedicated to working with COM+ Component Services, a Windows feature
    for hosting components that integrate with Microsoft Transaction Server. This
    isn’t possible on the newer, cross-platform versions of .NET because code might
    be running on Linux, where equivalent features either don’t exist or are too different
    to be presented through the same .NET API.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 6的一个主要目标是回归到一个主要的当前版本，这使得它成为一个特别重要的版本。然而，了解其他版本也是有用的，因为你可能会遇到继续在这些版本上运行的实时系统。.NET
    Framework继续流行的一个原因是它可以做一些.NET 6.0无法做到的事情。.NET Framework仅在Windows上运行，而.NET 6.0支持Windows、macOS和Linux，尽管这使得.NET
    Framework的可用性较小，但它可以支持一些Windows特定的功能。例如，.NET Framework类库中有一个部分专门用于与COM+组件服务一起工作，这是一个用于托管与Microsoft事务服务器集成的组件的Windows特性。这在新的跨平台.NET版本上是不可能的，因为代码可能在Linux上运行，那里的等效功能要么不存在，要么与通过相同的.NET
    API呈现的方式有太大不同。
- en: The number of .NET-Framework-only features has dropped dramatically over the
    last couple of releases, because Microsoft has been working to enable even Windows-only
    applications to use the latest version of .NET 6.0\. For example, the `System.Speech`
    .NET library used to be available only on .NET Framework because it provides access
    to Windows-specific speech recognition and synthesis functionality, but there
    is now a .NET 6.0 version of this library. That library only works on Windows,
    but its availability means that application developers relying on it are now free
    to move from .NET Framework to .NET. The remaining .NET Framework features that
    have not been brought forward are those that are not used extensively enough to
    justify the engineering effort. COM+ support was not just a library—it had implications
    for how the CLR executed code, so supporting it in modern .NET would have had
    costs that were not justifiable for what is now a rarely used feature.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几个版本中，仅限于.NET Framework的特性数量已经大幅减少，因为微软一直致力于使即使是仅限Windows的应用程序也能使用最新版本的.NET
    6.0。例如，`System.Speech` .NET库过去仅在.NET Framework上可用，因为它提供对Windows特定的语音识别和合成功能的访问，但现在有了.NET
    6.0版本的这个库。该库仅在Windows上工作，但其可用性意味着依赖它的应用程序开发人员现在可以自由地从.NET Framework转移到.NET。未能迁移的剩余.NET
    Framework特性是那些使用不足以证明工程投入的特性。COM+支持不仅仅是一个库——它对CLR执行代码的方式有影响，因此在现代.NET中支持它会带来难以接受的成本，这现在已经是一个很少使用的功能了。
- en: The cross-platform .NET is where most of the new development of .NET has occurred
    for the last few years. .NET Framework is still supported but has been falling
    behind for some time. For example, Microsoft’s web application framework, ASP.NET
    Core, dropped support for .NET Framework back in 2019\. So .NET Framework’s retirement,
    and .NET 6.0’s arrival as the one true .NET, is the inevitable conclusion of a
    process that has been underway for a few years.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 跨平台的.NET是过去几年中大部分.NET新开发发生的地方。.NET Framework仍然得到支持，但已经落后了一段时间。例如，微软的Web应用程序框架ASP.NET
    Core在2019年就停止了对.NET Framework的支持。因此，.NET Framework的退役和.NET 6.0作为唯一真正的.NET的到来，是一个已经进行了几年的过程的不可避免的结论。
- en: Release Cycles and Long Term Support
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布周期和长期支持
- en: Microsoft currently releases a new version of .NET every year, normally around
    November or December, but not all versions are created equal. Alternate releases
    get Long Term Support (LTS), meaning that Microsoft commits to supporting the
    release for at least three years. Throughout that period, the tools, libraries,
    and runtime will be updated regularly with security patches. .NET 6.0, released
    in November 2021, is an LTS release. The preceding LTS release was .NET Core 3.1,
    which was released in December 2019 and therefore remains in support until December
    2022; the LTS release before that was .NET Core 2.1, which went out of support
    in August 2021.^([3](ch01.xhtml#idm45884866256160))
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 微软目前每年发布一个新版本的.NET，通常在11月或12月左右发布，但并非所有版本都是平等的。备用版本会得到长期支持（LTS），这意味着微软承诺至少支持该版本三年。在此期间，工具、库和运行时将定期更新以提供安全补丁。.NET
    6.0在2021年11月发布，是一个LTS版本。之前的LTS版本是.NET Core 3.1，于2019年12月发布，因此支持将持续到2022年12月；再早之前的LTS版本是.NET
    Core 2.1，在2021年8月停止支持。
- en: What about non-LTS releases? These are supported from release but go out of
    support six months after the next LTS release comes out. For example, .NET 5.0
    was supported when it was released in December 2020, but support ended in May
    2022, six months after .NET 6.0 shipped. Microsoft of course could choose to extend
    support, but for planning purposes it is wise to assume that non-LTS versions
    effectively become unusable within about 18 months.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 那么非LTS版本呢？这些版本在发布时得到支持，但在下一个LTS版本发布六个月后就会停止支持。例如，.NET 5.0在2020年12月发布时得到了支持，但在.NET
    6.0发布后的2022年5月支持就结束了。当然，微软可以选择延长支持，但为了规划目的，假设非LTS版本在大约18个月内基本上就无法使用了是明智的。
- en: 'It often takes a few months for the ecosystem to catch up with a new release.
    You might not be able to use a new version of .NET on the day of its release in
    practice, because your cloud platform provider might not support it yet, or there
    may be incompatibilities with libraries that you need to use. This significantly
    shortens the effective useful lifetime of non-LTS releases, and it can leave you
    with an uncomfortably narrow window in which to upgrade when the next LTS version
    appears. If it takes a few months for the tools, platforms, and libraries you
    depend on to align with the new release, you will have very little time to move
    on before it falls out of support. In extreme situations, this window of opportunity
    might not even exist: .NET Core 2.2 reached the end of its supported life before
    Azure Functions offered full support for either .NET Core 3.0 or 3.1, so developers
    who had used the non-LTS .NET Core 2.2 on Azure Functions found themselves in
    a situation where the latest supported version actually went backward: they had
    to choose between either downgrading back to .NET Core 2.1 or using an unsupported
    runtime in production for a few months. For this reason, some developers look
    at the non-LTS versions as previews—you can experimentally target new features
    in anticipation of using them in production once they arrive in an LTS release.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 生态系统通常需要几个月的时间才能跟上新版本的发布。实际上，在发布当天可能还不能使用新版本的 .NET，因为你的云平台提供商可能还不支持，或者可能存在你需要使用的库的不兼容性。这显著缩短了非
    LTS 版本的有效使用寿命，并可能导致在下一个 LTS 版本出现时，升级的时间窗口非常狭窄而令人不安。如果工具、平台和依赖的库需要几个月才能与新版本对齐，那么在它退出支持之前，你将有很少的时间可以升级。在极端情况下，这个升级的机会甚至可能不存在：.NET
    Core 2.2 在 Azure Functions 完全支持 .NET Core 3.0 或 3.1 之前已经到了支持结束的生命周期，因此那些在 Azure
    Functions 上使用非 LTS .NET Core 2.2 的开发者发现自己处于一个最新支持版本实际上倒退的情况：他们不得不选择要么回退到 .NET
    Core 2.1，要么在生产中使用不支持的运行时几个月。因此，一些开发者把非 LTS 版本看作预览版本：你可以试验性地针对新功能，预期它们会在 LTS 版本中使用。
- en: Target Multiple .NET Versions with .NET Standard
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[使用 .NET Standard 针对多个 .NET 版本](https://nuget.org)的目标'
- en: 'The multiplicity of runtimes, each with its own different version of the runtime
    libraries, has long presented a challenge for anyone who wants to make their C#
    code available to other developers. Although the convergence we’re finally seeing
    with .NET 6.0 can make this less of an issue, it will be common to want to continue
    to support systems that run on the old .NET Framework. This means that it will
    be useful to produce components that target multiple .NET runtimes for the foreseeable
    future. There’s a [package repository for .NET components](https://nuget.org),
    which is where Microsoft publishes all of the .NET libraries it produces that
    are not built into .NET itself, and it is also where most .NET developers publish
    libraries they’d like to share. But which version should you build for? This is
    a two-dimensional question: there is the runtime implementation (.NET, .NET Framework)
    and also the version (for example, .NET Core 3.1 or .NET 6.0; .NET Framework 4.7.2
    or 4.8). Many authors of popular open source packages distributed through NuGet
    support a plethora of versions, old and new.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 长期以来，每个运行时版本的多样性，每个都有其自己不同的运行时库版本，对于希望将其 C# 代码提供给其他开发者的人来说一直是一个挑战。尽管我们最终看到的
    .NET 6.0 的收敛可以减少这种问题，但想要继续支持运行在旧 .NET Framework 上的系统将是常见的。这意味着，为了可预见的未来，生产目标多个
    .NET 运行时的组件将是有用的。有一个[.NET 组件的包存储库](https://nuget.org)，微软发布所有不属于 .NET 本身的 .NET
    库的地方，也是大多数 .NET 开发者发布他们想要分享的库的地方。但是，你应该为哪个版本构建呢？这是一个二维的问题：有运行时实现（.NET、.NET Framework）和版本（例如，.NET
    Core 3.1 或 .NET 6.0；.NET Framework 4.7.2 或 4.8）。许多通过 NuGet 分发的热门开源软件包的作者支持多个新旧版本。
- en: Component authors often used to support multiple runtimes by building multiple
    variants of their libraries. When you distribute .NET libraries via NuGet, you
    can embed several sets of binaries in the package, each targeting different flavors
    of .NET. However, one major problem with this is that as new forms of .NET have
    appeared over the years, existing libraries wouldn’t run on all newer runtimes.
    A component written for .NET Framework 4.0 would work on all subsequent versions
    of .NET Framework but not on, say, .NET 6.0\. Even if the component’s source code
    was entirely compatible with the newer runtime, you would need a separate version
    compiled to target that platform. And if the author of a library that you use
    hadn’t provided explicit support for .NET,^([4](ch01.xhtml#idm45884866053648))
    that would stop you from using it. This was bad for everyone. Various versions
    of .NET have come and gone over the years (such as Silverlight and several Windows
    Phone variants), meaning that component authors found themselves on a treadmill
    of having to churn out new variants of their component, and since that relies
    on those authors having the inclination and time to do this work, component consumers
    might find that not all of the components they want to use are available on their
    chosen platform.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 组件作者过去常常通过构建多个库的变体来支持多个运行时。当通过 NuGet 分发 .NET 库时，你可以在包中嵌入多组二进制文件，每组针对不同的 .NET
    变体。然而，其中一个主要问题是，随着多年来出现了新形式的 .NET，现有库可能无法在所有新的运行时上运行。为 .NET Framework 4.0 编写的组件将适用于所有后续版本的
    .NET Framework，但不适用于比如说 .NET 6.0。即使组件的源代码与较新的运行时完全兼容，你也需要编译一个针对该平台的单独版本。如果你使用的库的作者没有为
    .NET 提供明确的支持，这将阻止你使用它。这对每个人都是不利的。多年来出现了各种版本的 .NET（比如 Silverlight 和几个 Windows Phone
    变体），这意味着组件作者发现自己不得不不断推出其组件的新变体，并且因为这依赖于那些作者是否有这样做的意愿和时间，组件的消费者可能会发现并非所有他们想要使用的组件都在他们选择的平台上可用。
- en: To avoid this, Microsoft introduced .NET Standard, which defines common subsets
    of the .NET runtime libraries’ API surface area. If a NuGet package targets, say,
    .NET Standard 1.0, this guarantees that it will be able to run on .NET Framework
    versions 4.5 or later, .NET Core 1.0 or later, .NET 5.0 and later, or Mono 4.6
    or later. And critically, if yet another variant of .NET emerges, then as long
    as it too supports .NET Standard 1.0, existing components will be able to run
    without modification, even though that new platform didn’t even exist when they
    were written.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，微软推出了 .NET Standard，它定义了 .NET 运行时库 API 表面的常见子集。如果一个 NuGet 包的目标是，比如说，.NET
    Standard 1.0，这就保证它能在 .NET Framework 版本 4.5 或更高版本、.NET Core 1.0 或更高版本、.NET 5.0
    及更高版本，或者 Mono 4.6 及更高版本上运行。至关重要的是，如果出现了另一个 .NET 的变种，只要它也支持 .NET Standard 1.0，现有的组件就能够在不需修改的情况下运行，即使在编写这些组件时，那个新平台还不存在。
- en: Today, .NET Standard 2.0 is likely to be the best choice for component authors
    wishing to support a wide range of platforms, because all recently released versions
    of .NET support it, and it provides access to a very broad set of features. However,
    the number of different flavors of .NET that Microsoft still supports today is
    much lower than it was when .NET Standard was first introduced, so .NET Standard
    is arguably less important than it once was. Today, the main benefit of targeting
    .NET Standard is that your code will run on .NET Framework as well as .NET Core
    and .NET. If you don’t need to support .NET Framework, it would make more sense
    to target .NET Core 3.1 or .NET 6.0 instead. [Chapter 12](ch12.xhtml#ch_assemblies)
    describes some of the considerations around .NET Standard in more detail.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，.NET Standard 2.0 很可能是希望支持广泛平台的组件作者的最佳选择，因为所有最近发布的 .NET 版本都支持它，并且它提供了非常广泛的功能集。然而，微软今天支持的
    .NET 变体数量远低于 .NET Standard 首次推出时的水平，因此 .NET Standard 的重要性可能不如过去。如今，将代码目标设置为 .NET
    Standard 的主要好处是你的代码将在 .NET Framework 以及 .NET Core 和 .NET 上运行。如果你不需要支持 .NET Framework，将代码目标设置为
    .NET Core 3.1 或 .NET 6.0 可能更合理。[第 12 章](ch12.xhtml#ch_assemblies) 详细描述了围绕 .NET
    Standard 的一些考虑。
- en: Microsoft provides more than just a language and the various runtimes with its
    associated class libraries. There are also development environments that can help
    you write, test, debug, and maintain your code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 微软不仅提供语言和各种运行时及其相关的类库，还提供可以帮助你编写、测试、调试和维护代码的开发环境。
- en: Visual Studio, Visual Studio Code, and JetBrains Rider
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio、Visual Studio Code 和 JetBrains Rider
- en: 'Microsoft offers three desktop development environments: Visual Studio Code,
    Visual Studio, and Visual Studio for Mac. All three provide the basic features—such
    as a text editor, build tools, and a debugger—but Visual Studio provides the most
    extensive support for developing C# applications, whether those applications will
    run on Windows or other platforms. It has been around the longest—for as long
    as C#—so it comes from the pre–open source days and continues to be a closed-source
    product. The various editions available range from free to eye-wateringly expensive.
    Microsoft is not the only option: the developer productivity company JetBrains
    sells a fully-fledged .NET IDE called Rider, which runs on Windows, Linux, and
    macOS.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 微软提供了三种桌面开发环境：Visual Studio Code、Visual Studio和Visual Studio for Mac。这三款产品都提供了基本功能，如文本编辑器、构建工具和调试器，但是Visual
    Studio为开发C#应用程序提供了最全面的支持，无论这些应用程序是在Windows还是其他平台上运行。Visual Studio已经存在很长时间——从C#诞生之时起，因此它来自于开源之前的时代，并继续作为闭源产品存在。各种可用的版本从免费到价格高昂都有。微软并不是唯一的选择：开发者生产力公司JetBrains销售一款名为Rider的完整的.NET
    IDE，它能在Windows、Linux和macOS上运行。
- en: Visual Studio is an Integrated Development Environment (IDE), so it takes an
    “everything included” approach. In addition to a fully featured text editor, it
    offers visual editing tools for UIs. There is deep integration with source control
    systems such as Git and with online systems providing source repositories, issue
    tracking, and other Application Lifecycle Management (ALM) features such as GitHub
    and Microsoft’s Azure DevOps system. Visual Studio offers built-in performance
    monitoring and diagnostic tools. It has various features for working with applications
    developed for and deployed to Microsoft’s Azure cloud platform. It has the most
    extensive set of refactoring features out of the three Microsoft environments
    described here. Note that Visual Studio runs only on Windows.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio是一种集成开发环境（IDE），因此采用“一切包含”的方式。除了功能齐全的文本编辑器外，它还提供了用于UI可视化编辑的工具。它与Git等源代码控制系统以及提供源代码库、问题跟踪和其他应用生命周期管理（ALM）功能的在线系统（例如GitHub和Microsoft的Azure
    DevOps系统）深度集成。Visual Studio提供内置的性能监控和诊断工具。它具有多种特性，用于处理开发和部署到Microsoft的Azure云平台的应用程序。它是这三个Microsoft环境中拥有最广泛重构功能集的产品之一。请注意，Visual
    Studio仅在Windows上运行。
- en: In 2017 Microsoft released Visual Studio for Mac. This is not a port of the
    Windows version. It grew out of a platform called Xamarin, a Mac-based development
    environment specializing in building mobile apps in C# that run on the Mono runtime.
    Xamarin was originally an independent technology, but when, as discussed earlier,
    Microsoft acquired the company that wrote it, Microsoft integrated various features
    from the Windows version of Visual Studio when it moved the product under the
    Visual Studio brand.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 2017年，微软发布了适用于Mac的Visual Studio。这不是Windows版本的简单移植。它起源于一个名为Xamarin的平台，这是一个专门用于在Mac上构建运行在Mono运行时上的C#移动应用程序的开发环境。Xamarin最初是一项独立技术，但在微软收购了开发它的公司后，微软将Windows版Visual
    Studio的各种功能整合到了这个产品中，并将其纳入Visual Studio品牌。
- en: The JetBrains Rider IDE is a single product that runs on three operating systems.
    It is more focused than Visual Studio, in that it was designed purely to support
    .NET application development. (Visual Studio also supports C++.) It has a similar
    “everything included” approach, and it offers a particularly powerful range of
    refactoring tools.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: JetBrains Rider IDE是一款能在三个操作系统上运行的单一产品。它比Visual Studio更专注，因为它专门设计用于支持.NET应用程序开发（Visual
    Studio也支持C++）。它采用了类似的“一切包含”方式，并提供了特别强大的重构工具。
- en: 'Visual Studio Code (often shortened to VS Code) was first released in 2015\.
    It is open source and cross platform, supporting Linux as well as Windows and
    Mac. It is based on the Electron platform and is written predominantly in TypeScript.
    (This means that unlike Visual Studio, VS Code really is the same program on all
    operating systems.) VS Code is a more lightweight product than Visual Studio:
    a basic installation of VS Code has little more than text editing support. However,
    as you open up files, it will discover downloadable extensions that, if you choose
    to install them, can add support for C#, F#, TypeScript, PowerShell, Python, and
    a wide range of other languages. (The extension mechanism is open, so anyone who
    wants to can publish an extension.) So although in its initial form it is less
    of an IDE and more like a simple text editor, its extensibility model makes it
    pretty powerful. The wide range of extensions has led to VS Code becoming remarkably
    popular outside of the world of Microsoft languages, and this in turn has encouraged
    a virtuous cycle of even greater growth in the range of extensions.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code（通常缩写为VS Code）于2015年首次发布。它是开源且跨平台的，支持Linux以及Windows和Mac操作系统。它基于Electron平台，并主要使用TypeScript编写。（这意味着与Visual
    Studio不同，VS Code在所有操作系统上确实是同一个程序。）VS Code比Visual Studio更加轻量级：基本安装仅支持文本编辑。然而，当您打开文件时，它会发现可下载的扩展程序，如果选择安装，可以为C＃、F＃、TypeScript、PowerShell、Python和许多其他语言添加支持。（扩展机制是开放的，因此任何愿意的人都可以发布扩展。）因此，尽管在初始形式上它更像是一个简单的文本编辑器而不是一个集成开发环境（IDE），其可扩展性模型使其非常强大。广泛的扩展程序范围使得VS
    Code在微软语言以外的世界中非常流行，进而促进了扩展程序范围更大的增长的良性循环。
- en: Visual Studio and JetBrains Rider offer the most straightforward path to getting
    started in C#—you don’t need to install any extensions or modify any configuration
    to get up and running. However, Visual Studio Code is available to a wider audience,
    so I’ll be using that in the quick introduction to working with C# that follows.
    The same basic concepts apply to all environments, though, so if you will be using
    Visual Studio or Rider, most of what I describe here still applies.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio和JetBrains Rider提供了最简单的路径来开始使用C＃ - 您无需安装任何扩展程序或修改任何配置即可启动并运行。但是，由于Visual
    Studio Code面向更广泛的受众，因此我将在接下来的快速介绍中使用它来进行C＃的工作。尽管如此，所有环境都适用于相同的基本概念，因此如果您将使用Visual
    Studio或Rider，则我在这里描述的大部分内容仍然适用。
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You can download [Visual Studio Code for free](https://oreil.ly/m0vaY). You
    will also need to [install the .NET SDK](https://oreil.ly/8Ok2Z).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以免费下载[Visual Studio Code](https://oreil.ly/m0vaY)。您还需要[安装.NET SDK](https://oreil.ly/8Ok2Z)。
- en: If you are using Windows and would prefer to use Visual Studio, you can download
    the free version of Visual Studio, called [Visual Studio Community](https://oreil.ly/3RUGS).
    This will install the .NET SDK for you, as long as you select at least one .NET
    *workload* during installation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Windows并希望使用Visual Studio，您可以下载免费版本的Visual Studio，称为[Visual Studio Community](https://oreil.ly/3RUGS)。在安装期间，只要选择至少一个.NET
    *工作负载*，它将为您安装.NET SDK。
- en: 'Any nontrivial C# project will have multiple source code files, and these will
    belong to a *project*. Each project builds a single output, or *target*. The build
    target might be as simple as a single file—a C# project could produce an executable
    file or a library, for example—but some projects produce more complicated outputs.
    For instance, some project types build websites. A website will normally contain
    multiple files, but collectively, these files represent a single entity: one website.
    Each project’s output will be deployed as a unit, even if it consists of multiple
    files.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 任何非平凡的C＃项目都将具有多个源代码文件，并且这些文件将属于一个*项目*。每个项目构建一个单一的输出，或称为*目标*。构建目标可能会很简单，比如一个单文件
    - 例如，一个C＃项目可以生成可执行文件或库 - 但某些项目会生成更复杂的输出。例如，某些项目类型会构建网站。网站通常包含多个文件，但总体而言，这些文件代表一个单一的实体：一个网站。每个项目的输出将作为一个单元部署，即使它由多个文件组成。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Executables typically have a *.exe* file extension in Windows, while libraries
    use *.dll* (historically short for *dynamic link library*). With .NET, however,
    all code goes into *.dll* files. The SDK can also generate a bootstrapping executable
    (with a *.exe* extension on Windows), but this just starts the runtime and then
    loads the *.dll* containing the main compiled output. (It’s slightly different
    if you target .NET Framework: that compiles the application directly into a self-bootstrapping
    *.exe* with no separate *.dll*.) In any case, the only difference between the
    main compiled output of an application and a library is that the former specifies
    an application entry point. Both file types can export features to be consumed
    by other components. These are both examples of *assemblies*, the subject of [Chapter 12](ch12.xhtml#ch_assemblies).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，可执行文件通常具有*.exe*文件扩展名，而库使用*.dll*（历史上简称为动态链接库）。然而，使用.NET，所有的代码都放在*.dll*文件中。SDK还可以生成引导执行文件（在Windows上具有*.exe*扩展名），但这只是启动运行时，然后加载包含主要编译输出的*.dll*文件。（如果你的目标是.NET
    Framework，则稍有不同：它会将应用程序直接编译为自我引导的*.exe*，而不是分开的*.dll*。）无论如何，应用程序的主要编译输出和库的唯一区别在于前者指定了应用程序的入口点。这两种文件类型都可以导出供其他组件消费的功能。这些都是*程序集*的例子，是[第12章](ch12.xhtml#ch_assemblies)的主题。
- en: C# project files have a *.csproj* extension, and if you examine these files
    with a text editor, you’ll find that they contain XML. A *.csproj* file describes
    the contents of the project and configures how it should be built. These files
    are recognized by both Visual Studio and the .NET extensions for VS Code. They
    are also understood by various command-line build utilities such as the `dotnet`
    command-line tool installed by the .NET SDK, and also Microsoft’s older MSBuild
    tool. (MSBuild supports numerous languages and targets, not just .NET. In fact,
    when you build a C# project with the .NET SDK’s `dotnet build` command, it is
    effectively a wrapper around MSBuild.)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: C#项目文件使用*.csproj*扩展名，如果你使用文本编辑器查看这些文件，你会发现它们包含XML。*.csproj*文件描述了项目的内容并配置了项目的构建方式。这些文件可以被Visual
    Studio和VS Code的.NET扩展识别。它们也可以被各种命令行构建工具识别，例如.NET SDK安装的`dotnet`命令行工具，以及微软的旧版MSBuild工具。（MSBuild支持多种语言和目标，不仅仅是.NET。实际上，当你使用.NET
    SDK的`dotnet build`命令构建C#项目时，它实际上是MSBuild的一个包装。）
- en: You will often want to work with groups of projects. For example, it is good
    practice to write tests for your code, but most test code does not need to be
    deployed as part of the application, so you would typically put automated tests
    into separate projects. And you may want to split up your code for other reasons.
    Perhaps the system you’re building has a desktop application and a website, and
    you have common code you’d like to use in both applications. In this case, you’d
    need one project that builds a library containing the common code, another producing
    the desktop application executable, another to build the website, and three more
    projects containing the tests for each of the main projects.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你会希望处理一组项目。例如，为你的代码编写测试是一个良好的实践，但大多数测试代码不需要作为应用程序的一部分部署，因此你通常会将自动化测试放入单独的项目中。你可能也想因其他原因拆分代码。也许你正在构建的系统有一个桌面应用程序和一个网站，而你希望在这两个应用程序中使用相同的通用代码。在这种情况下，你需要一个项目来构建包含通用代码的库，另一个生成桌面应用程序可执行文件，另一个构建网站，以及另外三个项目分别包含每个主项目的测试。
- en: The build tools and IDEs that understand .NET help you work with multiple related
    projects through what they call a *solution*. A solution is a file with a *.sln*
    extension, defining a collection of projects. While the projects in a solution
    are usually related, they don’t have to be.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 理解.NET的构建工具和IDE帮助你通过所谓的*解决方案*来处理多个相关项目。解决方案是一个带有*.sln*扩展名的文件，定义了一组项目。尽管解决方案中的项目通常是相关的，但它们不一定非要相关。
- en: If you’re using Visual Studio, be aware that it requires projects to belong
    to a solution, even if you have only one project. Visual Studio Code is happy
    to open a single project if you want, but its .NET extensions also recognize solutions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用Visual Studio，请注意，即使只有一个项目，它也要求项目属于一个解决方案。Visual Studio Code可以愉快地打开单个项目，但其.NET扩展也可以识别解决方案。
- en: A project can belong to more than one solution. In a large codebase, it’s common
    to have multiple *.sln* files with different combinations of projects. You would
    typically have a main solution that contains every single project, but not all
    developers will want to work with all the code all of the time. Someone working
    on the desktop application in our hypothetical example will also want the shared
    library but probably has no interest in loading the web project.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一个项目可以属于多个解决方案。在一个大型代码库中，通常会有多个带有不同项目组合的*.sln*文件。你通常会有一个包含每个项目的主解决方案，但并非所有开发人员都希望一直处理所有代码。在我们的假设示例中，处理桌面应用程序的人还会想要共享库，但可能对加载Web项目不感兴趣。
- en: I’ll show how to create a new project, open it in Visual Studio Code, and run
    it. I’ll then walk through the various features of a new C# project as an introduction
    to the language. I’ll also show how to add a unit test project and how to create
    a solution containing both.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我将展示如何创建一个新项目，在Visual Studio Code中打开它并运行它。然后我将逐步介绍一个新的C#项目的各种特性，作为语言介绍的一部分。我还会展示如何添加一个单元测试项目，以及如何创建一个包含两者的解决方案。
- en: Anatomy of a Simple Program
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单程序的解剖
- en: 'Once you’ve installed the .NET 6.0 SDK either directly or by installing an
    IDE, you can create a new .NET program. Start by creating a new directory called
    *HelloWorld* on your computer to hold the code. Open up a command prompt and ensure
    that its current directory is set to that, and then run this command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你安装了.NET 6.0 SDK，可以直接安装或者通过安装一个IDE来创建一个新的.NET程序。首先在计算机上创建一个名为*HelloWorld*的新目录来保存代码。打开命令提示符，并确保当前目录设置为该目录，然后运行以下命令：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This makes a new C# console application by creating two files. It creates a
    project file with a name based on the parent directory: *HelloWorld.csproj* in
    this case. And there will be a *Program.cs* file containing the code. If you open
    that file up in a text editor, you’ll see it’s pretty simple, as [Example 1-1](#our_first_program)
    shows.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过创建两个文件创建了一个新的C#控制台应用程序。它创建一个基于父目录命名的项目文件：在这种情况下是*HelloWorld.csproj*。还会有一个包含代码的*Program.cs*文件。如果你在文本编辑器中打开这个文件，你会看到它非常简单，正如[示例 1-1](#our_first_program)所示。
- en: Example 1-1\. Our first program
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-1\. 我们的第一个程序
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can compile and run this program with the following command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令编译并运行此程序：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you’ve probably already guessed, this will display the text `Hello, World!`
    as output.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的那样，这将显示文本`Hello, World!`作为输出。
- en: If you already have some experience with C#, and are reading this book to learn
    what’s new in C# 10.0, this example might come as a bit of a surprise. In earlier
    versions of the language, the classic “Hello, World!” example that all programming
    books are required by law to open with was significantly larger. This looks so
    different that the .NET SDK authors felt it necessary to provide an explanation—over
    half of this example is just a comment with a link to a web page explaining where
    the rest of the code went. The second line here is all you need.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有一些C#经验，并且正在阅读本书以了解C# 10.0中的新内容，这个例子可能会让你感到惊讶。在语言的早期版本中，所有编程书籍必须以经典的“Hello,
    World!”示例开头，而它要大得多。这看起来如此不同，以至于.NET SDK的作者们认为有必要提供一个解释——这个例子的一半以上只是一个带有链接到网页的注释，解释其余代码的位置。这里的第二行就是你所需的全部内容。
- en: 'This illustrates one of the changes that C# 10.0 introduces: it aims to enable
    applications to get straight to the point by reducing the amount of *boilerplate*.
    Boilerplate is the name used to describe code that needs to be present to satisfy
    certain rules or conventions but that looks more or less the same in any project.
    For example, C# requires code to be defined inside a *method*, and a method must
    always be defined inside a *type*. You can see evidence of these rules in [Example 1-1](#our_first_program).
    To produce output, it relies on the .NET runtime’s ability to display text, which
    is embodied in a method called `WriteLine`. But we don’t just say `WriteLine`
    because C# methods always belong to types, which is why the code qualifies this
    as `Console.WriteLine`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了C# 10.0引入的变化之一：它旨在通过减少*样板代码*的数量使应用程序直奔主题。样板代码是指需要存在以满足某些规则或约定的代码，但在任何项目中看起来多少都是一样的。例如，C#要求代码在*方法*内定义，而方法必须始终在*类型*内定义。你可以在[示例 1-1](#our_first_program)中看到这些规则的证据。为了产生输出，它依赖于.NET运行时显示文本的能力，这体现在一个名为`WriteLine`的方法中。但我们不只是说`WriteLine`，因为C#方法总是属于类型，这就是为什么代码将其标记为`Console.WriteLine`的原因。
- en: 'Any C# that we write is subject to the rules, of course, so our code that invokes
    the `Console.WriteLine` method must itself live inside a method inside a type.
    And in the majority of C# code, this would be explicit: in most cases, you’ll
    see something a bit more like [Example 1-2](#hello_world_with_everything_visible).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们编写的任何 C# 代码都受到规则的约束，因此我们调用`Console.WriteLine`方法的代码本身必须存在于一个类型内的方法中。在大多数
    C# 代码中，这是显式的：在大多数情况下，您将看到类似[示例 1-2](#hello_world_with_everything_visible)的代码。
- en: Example 1-2\. “Hello, World!” with visible boilerplate
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-2\. 可见样板的“Hello, World!”
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There’s still only one line here that defines the behavior of the application,
    and it’s the same as in [Example 1-1](#our_first_program). The obvious advantage
    of the first example is that it lets us focus on what our program actually does,
    although the downside is that quite a lot of what’s going becomes invisible. With
    the explicit style in [Example 1-2](#hello_world_with_everything_visible), nothing
    is hidden. With [Example 1-1](#our_first_program), the compiler still puts the
    code in a method defined inside a type called `Program`; it’s just that you can’t
    see that from the code. With [Example 1-2](#hello_world_with_everything_visible),
    the method and type are clearly visible.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里仍然只有一行定义应用程序行为的代码，与[示例 1-1](#our_first_program)中相同。第一个示例的明显优势在于它让我们集中精力在程序实际做什么上，尽管缺点是很多东西都会变得看不见。在[示例 1-2](#hello_world_with_everything_visible)中采用显式风格，没有任何隐藏。在[示例 1-1](#our_first_program)中，编译器仍然会将代码放在一个名为`Program`的类型内定义的方法中；只是从代码中看不出来而已。在[示例 1-2](#hello_world_with_everything_visible)中，方法和类型都是清晰可见的。
- en: In practice, most C# code looks more like [Example 1-2](#hello_world_with_everything_visible)
    than [Example 1-1](#our_first_program), because some of C# 10.0’s boilerplate
    reduction measures are just for the program entry point. When you’re writing the
    code you want to execute whenever your program starts, you don’t need to define
    a containing class or method. But a program has only one entry point, and for
    everything else, you still need to spell it out.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，大多数 C# 代码看起来更像[示例 1-2](#hello_world_with_everything_visible)而不是[示例 1-1](#our_first_program)，因为
    C# 10.0 的大部分样板减少措施只是为了程序入口点。当您编写希望在程序启动时执行的代码时，您不需要定义一个包含类或方法。但是一个程序只有一个入口点，对于其他所有内容，您仍然需要详细说明。
- en: 'Since real projects involve multiple files, and usually multiple projects,
    let’s move on to a slightly more realistic example. I’m going to create a program
    that calculates the average (the arithmetic mean, to be precise) of some numbers.
    I will also create a second project that will automatically test our first one.
    Since I’ve got two projects, this time I’ll need a solution. I’ll create a new
    directory called *Averages*. If you’re following along, it doesn’t matter where
    it goes, although it’s a good idea *not* to put it inside your first project’s
    directory. I’ll open a command prompt in that directory and run this command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于实际项目涉及多个文件，通常还涉及多个项目，让我们进入一个稍微现实的例子。我将创建一个计算一些数字平均值（确切地说是算术平均值）的程序。我还将创建第二个项目来自动测试我们的第一个项目。由于我有两个项目，这次我将需要一个解决方案。我将创建一个名为*Averages*的新目录。如果您在跟着做，无论放在哪里都没有关系，尽管最好不要将其放在第一个项目的目录内。我将在该目录中打开命令提示符并运行以下命令：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will create a new solution file named *Averages.sln*. (By default, `dotnet
    new` usually names new projects and solutions after their containing directories,
    although you can specify other names.) Now I’ll add the two projects I need with
    these two commands:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为*Averages.sln*的新解决方案文件。（默认情况下，`dotnet new`通常根据其包含目录的名称命名新项目和解决方案，尽管您可以指定其他名称。）现在我将使用以下两个命令添加我需要的两个项目：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `-o` option here (short for `output`) indicates that I want each of these
    new projects to be created in new subdirectories—when you have multiple projects,
    each needs its own directory.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`-o`选项（缩写为`output`）表示我希望每个新项目都在新的子目录中创建——当您有多个项目时，每个项目都需要其自己的目录。
- en: 'I now need to add these to the solution:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我需要将它们添加到解决方案中：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'I’m going to use that second project to define some tests that will check the
    code in the first project (which is why I specified a project type of `mstest`—this
    project will use Microsoft’s unit test framework). For that to work, the second
    project will need access to the code in the first project. To enable that, I run
    this command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用第二个项目来定义一些测试，检查第一个项目中的代码（这就是为什么我指定了`mstest`项目类型——这个项目将使用微软的单元测试框架）。为了使其工作，第二个项目将需要访问第一个项目中的代码。为了实现这一点，我运行以下命令：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '(I’ve split this over two lines to make it fit, but it needs to be run as a
    single command.) Finally, to edit the project, I can launch VS Code in the current
    directory with this command:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: (我把它分成两行以便适应，但需要作为单个命令运行。) 最后，为了编辑项目，我可以使用以下命令在当前目录中启动 VS Code：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you’re following along, and if this is the first time you’ve run VS Code,
    it will ask you to make some decisions, such as choosing a color scheme. You might
    be tempted to ignore its questions, but one of the things it offers to do at this
    point is install extensions for language support. People use VS Code with all
    sorts of languages, and the installer makes no assumptions about which you will
    be using, so you have to install an extension to get C# support. But if you follow
    VS Code’s instructions to browse for language extensions, it will offer Microsoft’s
    C# extension. Don’t panic if VS Code does not offer to do this. Maybe you already
    had it installed, so it no longer asks these introductory questions, or perhaps
    there has a been a change to Code’s first-run behavior since I wrote this. You
    can still find the extension very easily. Click the Extensions icon on the bar
    on the lefthand side, and it will show a set of extensions it thinks might be
    relevant. If you’ve opened VS code in a directory with a *.csproj* file in it,
    this will include the C# extension. And if all else fails, you can search for
    the extensions you need. [Figure 1-1](#vscode_cs_extension) shows VS Code’s extensions
    panel—you can go to this by clicking the icon in the bar on the lefthand side.
    It’s the one shown at the bottom here, with four squares.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在跟着做，并且这是你第一次运行 VS Code，它会要求你做一些决策，比如选择一个配色方案。你可能会忽略它的问题，但此时它提供的其中一个选项是安装语言支持的扩展。人们使用
    VS Code 来处理各种语言，安装程序不会假设你将使用哪种语言，所以你必须安装一个扩展来获取 C# 支持。但是如果你按照 VS Code 的指示浏览语言扩展，它会提供微软的
    C# 扩展。如果 VS Code 没有提供这样做，请不要惊慌。也许你已经安装了它，所以它不再询问这些入门问题，或者自从我写这篇文章以来，Code 的首次运行行为发生了变化。你仍然可以非常容易地找到这个扩展。点击左侧栏上的
    Extensions 图标，它将显示一组它认为可能相关的扩展。如果你在一个包含 *.csproj* 文件的目录中打开了 VS Code，这将包括 C# 扩展。如果其他方法都失败了，你可以搜索你需要的扩展。[图
    1-1](#vscode_cs_extension) 显示了 VS Code 的扩展面板——你可以通过点击左侧栏上的图标进入这个面板。这里底部显示的是四个方块的那一个。
- en: '![Visual Studio Code''s C# Extension](assets/pc10_0101.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Visual Studio Code 的 C# 扩展](assets/pc10_0101.png)'
- en: Figure 1-1\. Visual Studio Code’s C# extension
  id: totrans-97
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-1\. Visual Studio Code 的 C# 扩展
- en: As you can see, I’ve typed *C#* into the search text box at the top, and the
    first result here is Microsoft’s C# extension. A few other results also appear.
    If you’re following along, make sure you get the right one. If you click the search
    result, it will show more detailed information, which should show its full name
    as “C# for Visual Studio Code (powered by OmniSharp),” and it will show “Microsoft”
    as the publisher. Click the Install button to install the extension.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我在顶部的搜索框中输入了*C#*，这里的第一个结果是微软的C#扩展。还有几个其他结果也显示出来。如果你在跟着做，请确保选择正确的结果。如果你点击搜索结果，它将显示更详细的信息，其中应该显示其全名为“C#
    for Visual Studio Code (powered by OmniSharp)”，并且显示“Microsoft”作为发布者。点击安装按钮来安装这个扩展。
- en: It might take a few minutes to download and install the C# extension, but once
    that’s done, at the bottom left of the window the status bar should look similar
    to [Figure 1-2](#vscode_cs_status), showing the name of the solution file and
    a flame icon that indicates that OmniSharp, the system that provides C# support
    in VS Code, is ready. It’s possible that a project picker will appear at the top
    of the window—the C# extension will have scanned the solution directory and found
    the two C# projects and also their containing solution. Normally it will just
    open the solution file, but depending on how your system is configured, it might
    ask which you want to use. I will be working across both of the projects in the
    solution, so I will select the *Averages.sln* entry.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 C# 扩展可能需要几分钟时间，但一旦完成，窗口左下角的状态栏应该类似于 [图 1-2](#vscode_cs_status)，显示解决方案文件的名称和一个火焰图标，表示
    OmniSharp 已准备好，这是在 VS Code 中提供 C# 支持的系统。可能会在窗口顶部出现一个项目选择器——C# 扩展已扫描解决方案目录并找到两个
    C# 项目及其所在的解决方案。通常它会直接打开解决方案文件，但根据你的系统配置，它可能会询问你想使用哪个。我将在解决方案的两个项目中进行工作，所以我将选择
    *Averages.sln* 条目。
- en: '![Visual Studio Code''s status bar showing the OmniSharp icon and the name
    of the solution file](assets/pc10_0102.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![Visual Studio Code 的状态栏显示 OmniSharp 图标和解决方案文件的名称](assets/pc10_0102.png)'
- en: Figure 1-2\. Visual Studio Code status bar
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 1-2\. Visual Studio Code 状态栏
- en: The C# extension will now inspect all of the source code in all of the projects
    in the solution. Obviously there’s not much in these yet, but it will continue
    to analyze code as I type, enabling it to identify problems and make helpful suggestions.
    During this process, it will notice that there isn’t yet any configuration for
    building and debugging the projects. It will show a dialog at the bottom right
    of the window offering to add these, as [Figure 1-3](#ch01_vscode_add_assets)
    shows. It’s a good idea to click the Yes button, and when it asks you which project
    to launch, to select the main program, *Averages.csproj*, so that VS Code knows
    which one to use when asked to run or debug the code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 C# 扩展将检查解决方案中所有项目的所有源代码。显然，这些项目中目前没有太多内容，但随着我输入代码，它将继续分析，帮助我识别问题并提出建议。在此过程中，它会注意到尚未为项目配置构建和调试设置。如
    [Figure 1-3](#ch01_vscode_add_assets) 所示，它会在窗口右下角显示一个对话框，提供添加这些设置的选项。建议点击“是”按钮，并在询问你要启动哪个项目时选择主程序
    *Averages.csproj*，以便 VS Code 在运行或调试代码时知道要使用哪一个。
- en: '![A dialog with this text: Required assets to build and debug are missing from
    Averages. Add them?](assets/pc10_0103.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![对话框显示以下文本：构建和调试所需的资源在 Averages 中缺失。是否添加？](assets/pc10_0103.png)'
- en: Figure 1-3\. C# Extension offering to add build and debug assets
  id: totrans-104
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 1-3\. C# 扩展提供添加构建和调试资产的选项
- en: I can take a look at the code by switching to the Explorer view, by clicking
    the button at the top of the toolbar on the left. As [Figure 1-4](#ch01_vscode_explorer)
    shows, it displays the directories and files. I’ve expanded the *Averages.Test*
    directory and have selected its *UnitTest1.cs* file.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以通过切换到资源管理器视图来查看代码，方法是点击左侧工具栏顶部的按钮。正如 [Figure 1-4](#ch01_vscode_explorer)
    所示，它显示目录和文件。我已展开 *Averages.Test* 目录并选择了其 *UnitTest1.cs* 文件。
- en: '![Visual Studio Code''s Explorer, with the Averages.Test project expanded,
    and the UnitTest1.cs file selected](assets/pc10_0104.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![Visual Studio Code 的资源管理器，展开了 Averages.Test 项目，并选择了 UnitTest1.cs 文件](assets/pc10_0104.png)'
- en: Figure 1-4\. Visual Studio Code’s Explorer
  id: totrans-107
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 1-4\. Visual Studio Code 的资源管理器
- en: Tip
  id: totrans-108
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If you single-click a file in the Explorer panel, VS Code shows it in a *preview
    tab*, meaning that it won’t stay open for long: as soon as you click some other
    file, that displaces the one you had open before. This is designed to avoid ending
    up with hundreds of open tabs, but if you’re working back and forth across two
    files, this can be annoying. You can avoid this by double-clicking the file when
    you open it—that opens a nonpreview tab, which will remain open until you deliberately
    close it. Alternatively, if you already have a file open in a preview tab, you
    can double-click the tab to turn it into an ordinary tab. VS Code shows the filename
    in italics in preview tabs, and you’ll see it change to nonitalic when you double-click.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在资源管理器面板中单击文件，VS Code 将在*预览标签*中显示它，这意味着它不会长时间保持打开状态：一旦你单击其他文件，它就会被替换。这样设计是为了避免打开数百个标签页，但如果你需要频繁在两个文件之间切换，这可能有些烦人。你可以通过双击文件来避免这种情况，这样会打开一个非预览标签，直到你有意关闭它为止。另外，如果你已经在预览标签中打开了一个文件，你可以双击标签将其转换为普通标签。VS
    Code 在预览标签中以斜体显示文件名，当你双击时，它将变为非斜体。
- en: You might be wondering why I expanded the *Averages.Tests* directory. The purpose
    of this test project will be to ensure that the main project does what it’s supposed
    to. I happen to prefer the style of development where you write your tests before
    you write the code being tested, so I’ll start with the test project.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我展开了 *Averages.Tests* 目录。这个测试项目的目的是确保主项目的功能正常。我偏好在编写代码之前编写测试的开发风格，因此我会从测试项目开始。
- en: Writing a Unit Test
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: 'When I ran the command to create this project earlier, I specified a project
    type of `mstest`. This project template has provided me with a test class to get
    me started, in a file called *UnitTest1.cs*. I want to pick a more informative
    name. There are various schools of thought as to how you should structure your
    unit tests. Some developers advocate one test class for each class you wish to
    test, but I like the style where you write a class for each *scenario* in which
    you want to test a particular class, with one method for each of the things that
    should be true about your code in that scenario. This program will only have one
    behavior: it will calculate the arithmetic mean of its inputs. So I’ll rename
    the *UnitTest1.cs* source file to *WhenCalculatingAverages.cs*. (You can rename
    a file by right-clicking it in VS Code’s Explorer panel and selecting the Rename
    entry.) This test should verify that we get the expected results for a few representative
    inputs. [Example 1-3](#unit_test_class_for_our_first_program) shows a complete
    source file that does this; there are two tests here, shown in bold.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当我之前运行命令创建这个项目时，我指定了一个`mstest`项目类型。这个项目模板为我提供了一个测试类来启动我的工作，在一个名为*UnitTest1.cs*的文件中。我想选择一个更具信息性的名称。有多种关于如何组织单元测试的思路。一些开发人员主张为每个要测试的类编写一个测试类，但我喜欢的风格是为您想要测试特定类的每个*场景*编写一个类，并为该场景中您的代码应该正确的每个事物编写一个方法。此程序只有一种行为：计算其输入的算术平均值。因此，我将*UnitTest1.cs*源文件重命名为*WhenCalculatingAverages.cs*。（您可以通过右键单击VS
    Code的Explorer面板中的文件，并选择Rename条目来重命名文件。）此测试应验证我们对几个代表性输入得到了预期结果。[示例 1-3](#unit_test_class_for_our_first_program)展示了一个完成此任务的完整源文件；这里有两个测试，用粗体显示。
- en: Example 1-3\. A unit test class for our first program
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-3\. 我们第一个程序的单元测试类
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: I will explain each of the features in this file once I’ve shown the program
    itself. For now, the most interesting parts of this example are the two methods.
    First, we have the `SingleInputShouldProduceSameValueAsResult` method, which checks
    that our program correctly handles the case where there is a single input. The
    first line inside this method describes the input—a single number. (Slightly surprisingly,
    this test represents the numbers as strings. This is because our inputs will ultimately
    come as command-line arguments, so our test needs to reflect that.) The second
    line executes the code under test (which I’ve not actually written yet). And the
    third line states that the calculated average should be equal to the one and only
    input. If it’s not, this test will report a failure. The second method, `MultipleInputsShouldProduceAverageAsResult`,
    checks a slightly more complex case, in which there are three inputs, but has
    the same basic shape as the first.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦展示了程序本身，我将解释该文件中的每个特性。目前，这个示例中最有趣的部分是两个方法。首先是`SingleInputShouldProduceSameValueAsResult`方法，它检查我们的程序是否正确处理只有一个输入的情况。此方法内的第一行描述了输入——一个数字。（有点令人惊讶的是，这个测试将数字表示为字符串。这是因为我们的输入最终将作为命令行参数，所以我们的测试需要反映这一点。）第二行执行了待测试的代码（实际上我还没有写）。第三行说明计算出的平均值应该等于唯一的输入。如果不是，则此测试将报告失败。第二个方法`MultipleInputsShouldProduceAverageAsResult`检查了稍微复杂一些的情况，其中有三个输入，但基本形状与第一个相同。
- en: Note
  id: totrans-116
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We’re working with C#’s `double` type here, a double-precision floating-point
    number, to be able to handle results that are not whole numbers. I’ll be describing
    C#’s built-in data types in more detail in the next chapter, but be aware that
    as with most programming languages, floating-point arithmetic in C# has limited
    precision. The `Assert.AreEqual` method I’m using to check the results here takes
    this into account and lets me specify maximum tolerance for imprecision. The final
    argument of `1E-14` in each case denotes the number 1 divided by 10 raised to
    the power of 14, so these tests are stating that they require the answer to be
    correct to 14 decimal places.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用了C#的`double`类型，即双精度浮点数，以便能够处理不是整数的结果。在下一章中，我将更详细地描述C#的内置数据类型，但要注意，与大多数编程语言一样，C#中的浮点运算精度有限。我在这里使用的`Assert.AreEqual`方法考虑到了这一点，并允许我指定最大的误差容限。每种情况下的最后一个参数`1E-14`表示数字1除以10的14次方，因此这些测试表明结果需要正确到小数点后14位。
- en: 'Let’s focus on one particular line from these tests: the one that runs the
    code I want to test. [Example 1-4](#calling_a_method) shows the relevant line
    from [Example 1-3](#unit_test_class_for_our_first_program). This is how you invoke
    a method that returns a result in C#. This line starts by declaring a variable
    to hold the result. (The `double` indicates the data type, and `result` is the
    variable’s name.) All methods in C# need to be defined inside a type, and so just
    as we saw earlier with the `Console.WriteLine` example, we have the same form
    here: a type name, then a period, then a method name. And then, in parentheses,
    the input to the method.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注这些测试中的一个特定行：运行我想测试的代码的那一行。[示例 1-4](#calling_a_method) 显示了从 [示例 1-3](#unit_test_class_for_our_first_program)
    中相关的行。这是在 C# 中调用返回结果的方法。这行代码首先声明一个变量来保存结果（`double` 表示数据类型，`result` 是变量的名称）。所有的
    C# 方法都需要在一个类型内定义，就像我们之前在 `Console.WriteLine` 示例中看到的一样，在这里也是相同的形式：类型名称，然后是一个句点，然后是方法名称。然后在括号内是方法的输入。
- en: Example 1-4\. Calling a method
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-4\. 调用一个方法
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you are following along by typing the code in as you read, then first: well
    done. But second, if you were to look at the two places this line of code appears
    (once in each test method), you might notice that VS Code has drawn a squiggly
    line underneath `AverageCalculator`. Hovering the mouse over this kind of squiggly
    shows an error message, as [Figure 1-5](#ch01_vscode_unknown_type) shows.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在阅读时同时输入代码，首先：做得好。但是第二，如果你查看这行代码出现的两个地方（每个测试方法中一次），你可能会注意到 VS Code 在 `AverageCalculator`
    下面画了一条波浪线。将鼠标悬停在这种波浪线上会显示一个错误消息，就像 [图 1-5](#ch01_vscode_unknown_type) 所示的那样。
- en: '![Visual Studio Code showing the AverageCalculator symbol underlined, and an
    error popup containing this text: The name AverageCalculator does not exist in
    the current context Averages.Tests](assets/pc10_0105.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![Visual Studio Code 显示 AverageCalculator 符号下划线，并显示一个错误弹出窗口包含这段文字：当前上下文中不存在
    AverageCalculator 名称 Averages.Tests](assets/pc10_0105.png)'
- en: Figure 1-5\. An unrecognized type
  id: totrans-123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-5\. 一个未识别的类型
- en: 'This is telling us something we already knew: I haven’t yet written the code
    that this test aims to test. Let’s fix that. I need to add a new file, which I
    can do in VS Code’s Explorer view by clicking the *Averages* directory and then,
    with that selected, clicking the leftmost button on the toolbar near the top of
    the Explorer. [Figure 1-6](#ch01_vscode_new_file) shows that when you hover the
    mouse over this button, it shows a tooltip confirming its purpose. After clicking
    it, I can type in *AverageCalculator.cs* as the name for the new file.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们一些我们已经知道的事情：我还没有编写这个测试的代码。让我们解决这个问题。我需要添加一个新文件，在 VS Code 的资源管理器视图中，通过点击
    *Averages* 目录，然后在选择了它之后，点击资源管理器顶部附近的最左侧按钮。当你将鼠标悬停在此按钮上时，会显示一个工具提示确认其用途。点击后，我可以输入
    *AverageCalculator.cs* 作为新文件的名称。
- en: '![Visual Studio Code''s Explorer view, with the New File button highlighter,
    and a tooltip saying ''New File''](assets/pc10_0106.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![Visual Studio Code 的资源管理器视图，高亮显示“新建文件”按钮，并显示工具提示说“新建文件”](assets/pc10_0106.png)'
- en: Figure 1-6\. Adding a new file
  id: totrans-126
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-6\. 添加一个新文件
- en: VS Code will create a new, empty file. I’ll add the smallest amount of code
    I can to fix the error reported in [Figure 1-5](#ch01_vscode_unknown_type). [Example 1-5](#minimal_implementation)
    will satisfy the C# compiler. It’s not complete yet—it doesn’t perform the necessary
    calculations, but we’ll come to that.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 将创建一个新的空文件。我将添加尽可能少的代码来修复 [图 1-5](#ch01_vscode_unknown_type) 中报告的错误。[示例
    1-5](#minimal_implementation) 将满足 C# 编译器。它还不完整——它还没有执行必要的计算，但我们会解决这个问题。
- en: Example 1-5\. A simple class
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-5\. 一个简单的类
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Since the code will now compile, I can run the tests with this command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现在代码可以编译，我可以用以下命令运行测试：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This produces the following output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As expected, we get failures because I’ve not written a proper implementation
    yet. But first, I want to explain each element of [Example 1-5](#minimal_implementation)
    in turn, as it provides a useful introduction to some important elements of C#
    syntax and structure. The very first thing in this file is a *namespace declaration*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，由于我还没有编写一个合适的实现，我们会得到失败的结果。但首先，我想逐个解释 [示例 1-5](#minimal_implementation)
    的每个元素，因为它对 C# 语法和结构的一些重要元素提供了一个有用的介绍。这个文件的第一件事就是一个 *命名空间声明*。
- en: Namespaces
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间
- en: Namespaces bring order and structure to what would otherwise be a horrible mess.
    The .NET runtime libraries contain a large number of types, and there are many
    more out there in third-party libraries, not to mention the classes you will write
    yourself. There are two problems that can occur when dealing with this many named
    entities. First, it becomes hard to guarantee uniqueness. Second, it can become
    challenging to discover the API you need; unless you know or can guess the right
    name, it’s difficult to find what you need from an unstructured list of tens of
    thousands of things. Namespaces solve both of these problems.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间为本应混乱不堪的事物带来了秩序和结构。.NET运行时库包含大量类型，还有许多第三方库中的类型，更不用说你自己编写的类了。在处理这么多命名实体时会出现两个问题。首先，保证唯一性变得困难。其次，在未经组织的数万个事物中找到你需要的API可能会变得具有挑战性；除非你知道或能猜出正确的名称，否则很难找到所需的内容。命名空间解决了这两个问题。
- en: Most .NET types are defined in a namespace. There are certain conventions for
    namespaces that you’ll see a lot. For example, types in .NET’s runtime libraries
    are in namespaces that start with `System`. Additionally, Microsoft has made a
    wide range of useful libraries available that are not a core part of .NET, and
    these usually begin with `Microsoft`, or, if they are for use only with some particular
    technology, they might be named for that. (For example, there are libraries for
    using Microsoft’s Azure cloud platform that define types in namespaces that start
    with `Azure`.) Libraries from other vendors tend to start with the company name
    or a product name, while open source libraries often use their project name. You
    are not forced to put your own types into namespaces, but it’s recommended that
    you do. C# does not treat `System` as a special namespace, so nothing’s stopping
    you from using that for your own types, but unless you’re writing a contribution
    to the .NET runtime libraries that you will be submitting as a pull request to
    [the .NET runtime source repository](https://github.com/dotnet/runtime), then
    it’s a bad idea because it will tend to confuse other developers. You should pick
    something more distinctive for your own code, such as your company or project
    name. As you can see from the first line of [Example 1-5](#minimal_implementation),
    I’ve chosen to define our `AverageCalculator` class inside a namespace called
    `Averages`, matching our project name.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数.NET类型都定义在一个命名空间中。关于命名空间有一些约定，你会经常看到。例如，.NET运行时库中的类型在以`System`开头的命名空间中。此外，微软提供了许多有用的库，虽然它们不是.NET核心的一部分，但通常以`Microsoft`开头；或者，如果仅用于某些特定技术，它们可能以此命名。例如，有一些用于使用微软Azure云平台的库，它们在以`Azure`开头的命名空间中定义类型。来自其他供应商的库通常以公司名称或产品名称开头，而开源库通常使用其项目名称。你不必把自己的类型放入命名空间中，但建议这样做。C#并不把`System`作为特殊的命名空间，所以没有什么能阻止你将其用于自己的类型，但除非你正在编写将作为拉取请求提交给[.NET运行时源代码库](https://github.com/dotnet/runtime)的.NET运行时库贡献，否则这是一个坏主意，因为它会导致其他开发者混淆。你应该为自己的代码选择更具有特色的名称，比如你的公司或项目名称。正如你可以从[示例 1-5](#minimal_implementation)的第一行看到的那样，我选择在名为`Averages`的命名空间中定义我们的`AverageCalculator`类，与我们的项目名称相匹配。
- en: The style of namespace declaration in [Example 1-5](#minimal_implementation)
    is new to C# 10.0\. Today, the majority of code you will come across is likely
    to use the older, slightly more verbose style shown in [Example 1-6](#pre_cs10_namespace_declaration).
    The difference is that the namespace declaration is followed by braces (`{}`),
    and its effect applies only to the contents of those braces. This makes it possible
    for a single file to contain multiple namespace declarations. But in practice,
    the overwhelming majority of C# files contain exactly one namespace declaration.
    With the old syntax, this means that the majority of the contents of each file
    has to sit inside a pair of braces, indented by one tab stop. The new style shown
    in [Example 1-5](#minimal_implementation) applies to all types declared in the
    file without needing to wrap them explicitly. This is part of C# 10.0’s drive
    to reduce unproductive clutter in our source files.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 1-5](#minimal_implementation) 中展示的命名空间声明风格是 C# 10.0 的新特性。如今，你可能会遇到的大多数代码都采用稍显冗长的旧式风格，如
    [示例 1-6](#pre_cs10_namespace_declaration) 所示。两者的区别在于命名空间声明后跟着大括号 (`{}`)，其作用仅限于大括号内的内容。这使得单个文件可以包含多个命名空间声明。但实际上，绝大多数
    C# 文件只包含一个命名空间声明。在旧语法中，这意味着每个文件的绝大部分内容必须位于一对大括号内，缩进一个制表符。而 [示例 1-5](#minimal_implementation)
    中展示的新风格适用于文件中声明的所有类型，无需显式包裹。这是 C# 10.0 旨在减少源文件中无效冗余的一部分。
- en: Example 1-6\. Pre-C# 10.0 namespace declaration
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-6\. C# 10.0 之前的命名空间声明
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The namespace usually gives a clue as to the purpose of a type. For example,
    all the runtime library types that relate to file handling can be found in the
    `Sys⁠tem.​IO` namespace, while those concerned with networking are under `System.Net`.
    Namespaces can form a hierarchy. So the framework’s `System` namespace contains
    types and also other namespaces, such as `System.Net`, and these often contain
    yet more namespaces, such as `System.Net.Sockets` and `System.Net.Mail`. These
    examples show that namespaces act as a sort of description, which can help you
    navigate the library. If you were looking for regular expression handling, for
    example, you might look through the available namespaces and notice the `System.Text`
    namespace. Looking in there, you’d find a `System.Text.RegularExpressions` namespace,
    at which point you’d be pretty confident that you were looking in the right place.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间通常提示类型的用途。例如，所有与文件处理相关的运行库类型都可以在 `System.IO` 命名空间中找到，而与网络相关的则位于 `System.Net`
    下。命名空间可以形成层次结构。因此，框架的 `System` 命名空间包含类型以及其他命名空间，如 `System.Net`，而这些通常还包含更多的命名空间，如
    `System.Net.Sockets` 和 `System.Net.Mail`。这些示例显示，命名空间充当一种描述，有助于你浏览库。例如，如果你在寻找正则表达式处理功能，你可能会浏览可用的命名空间，并注意到
    `System.Text` 命名空间。在那里查找，你会找到一个 `System.Text.RegularExpressions` 命名空间，这时你会相当有信心你找对了地方。
- en: Namespaces also provide a way to ensure uniqueness. The namespace in which a
    type is defined is part of that type’s full name. This lets libraries use short,
    simple names for things. For example, the regular expression API includes a `Capture`
    class that represents the results from a regular expression capture. If you are
    working on software that deals with images, the term *capture* is commonly used
    to mean the acquisition of some image data, and you might feel that `Capture`
    is the most descriptive name for a class in your own code. It would be annoying
    to have to pick a different name just because the best one is already taken, particularly
    if your image acquisition code has no use for regular expressions, meaning that
    you weren’t even planning to use the existing `Capture` type.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间还提供了确保唯一性的一种方式。类型定义所在的命名空间是其完整名称的一部分。这使得库可以为事物使用短小的简单名称。例如，正则表达式 API 包含一个
    `Capture` 类，用于表示正则表达式捕获的结果。如果你正在开发处理图像的软件，术语 *capture* 通常用于表示获取某些图像数据，你可能认为在你自己的代码中
    `Capture` 是描述最为准确的类名。如果你的图像获取代码根本不使用正则表达式，意味着你根本没有打算使用现有的 `Capture` 类型，那么因为最佳名称已经被使用而不得不选择其他名称会很令人恼火。
- en: But in fact, it’s fine. Both types can be called `Capture`, and they will still
    have different names. The full name of the regular expression `Capture` class
    is effectively `System.Text.RegularExpressions.Capture`, and likewise, your class’s
    full name would include its containing namespace (for example, `Spi⁠ffi⁠ngS⁠oft⁠wor⁠ks.​Ima⁠gin⁠g.Ca⁠ptu⁠re`).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 但事实上，这样也没问题。这两种类型都可以称为`Capture`，它们仍然会有不同的名称。正则表达式`Capture`类的完整名称实际上是`System.Text.RegularExpressions.Capture`，同样地，您类的完整名称将包括其所在的命名空间（例如，`Spi⁠ffi⁠ngS⁠oft⁠wor⁠ks.​Ima⁠gin⁠g.Ca⁠ptu⁠re`）。
- en: If you really want to, you can write the fully qualified name of a type every
    time you use it, but most developers don’t want to do anything quite so tedious,
    which is where the `using` directives you can see at the start of Examples [1-2](#hello_world_with_everything_visible)
    and [1-3](#unit_test_class_for_our_first_program) come in. It’s common to see
    a list of directives at the top of each source file, stating the namespaces of
    the types that file intends to use. You will normally edit this list to match
    your file’s requirements. In this example, the `dotnet` command-line tool added
    `using Microsoft.VisualStudio.TestTools.UnitTesting;` when it created the test
    project. You’ll see different sets in different contexts. If you add a class representing
    a UI element, for example, Visual Studio would include various UI-related namespaces
    in the list.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果确实希望，您可以每次使用类型时都写出完全限定的名称，但大多数开发人员不想做这样单调乏味的事情，这就是我们在示例 [1-2](#hello_world_with_everything_visible)
    和 [1-3](#unit_test_class_for_our_first_program) 开头看到的`using`指令的用处。在每个源文件的顶部看到一列指令是很常见的，它声明了该文件意图使用的类型的命名空间。在此示例中，`dotnet`命令行工具在创建测试项目时添加了`using
    Microsoft.VisualStudio.TestTools.UnitTesting;`。您会在不同的上下文中看到不同的集合。例如，如果添加一个代表UI元素的类，Visual
    Studio会在列表中包含各种与UI相关的命名空间。
- en: 'Projects that target C# 10.0 or later typically have fewer `using` directives
    than you will see if you look at projects written for older versions (which, at
    the time of writing, is almost all of them) because of a new language feature:
    *global using directives*. If we put the `global` keyword in front of the directive,
    as [Example 1-7](#global_using_directive) does, the directive applies to all files
    in a project. The .NET SDK then takes this a step further, by generating a hidden
    file in your project with a set of these `global using` directives to ensure that
    commonly used namespaces such as `System` and `System.Collections.Generic` are
    available. (The exact set of namespaces added as implicit global imports varies
    by project type—web projects get a few extra, for example. If you’re wondering
    why unit test projects don’t already do what [Example 1-7](#global_using_directive)
    does, it’s because the .NET SDK doesn’t have a specific project type for test
    projects—it considers them to be just a kind of class library.)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 针对 C# 10.0 或更高版本的项目通常比您在为旧版本编写的项目中看到的`using`指令要少，这是因为有了一个新的语言特性：*全局 using 指令*。如果我们在指令前加上`global`关键字，如示例
    [1-7](#global_using_directive) 所示，该指令适用于项目中的所有文件。然后，.NET SDK进一步采取了措施，在您的项目中生成了一个隐藏文件，并使用一组这些`global
    using`指令来确保常用的命名空间，例如`System`和`System.Collections.Generic`可用。（隐式全局导入的确切命名空间集合因项目类型而异——例如，Web项目会额外获取几个。如果您想知道为什么单元测试项目不会像示例
    [1-7](#global_using_directive) 那样自动进行全局 using 指令，原因是.NET SDK没有针对测试项目的特定项目类型——它认为它们只是一种类库。）
- en: Example 1-7\. A `global using` directive
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-7\. 全局`using`指令
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With `using` declarations like these (either per-file or global) in place, you
    can just use the short, unqualified name for a class. The line of code that enables
    [Example 1-1](#our_first_program) to do its job uses the `System.Console` class,
    but because the SDK adds an implicit `global using` directive for the `System`
    namespace, it can refer to it as just `Console`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的`using`声明（可以是每个文件或全局），您可以仅使用类的简短、未限定的名称。使得[示例 1-1](#our_first_program)中的代码行能够发挥作用的代码行使用了`System.Console`类，但由于SDK为`System`命名空间添加了一个隐式的`global
    using`指令，因此它可以简称为`Console`。
- en: Note
  id: totrans-149
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Earlier, I used the `dotnet` CLI to add a reference from our `Averages.Tests`
    project to our `Averages` project. You might think that references are redundant—can’t
    the compiler work out which external libraries we are using from the namespaces?
    It could if there was a direct correspondence between namespaces and either libraries
    or packages, but there isn’t. There is sometimes an apparent connection—the popular
    `Newtonsoft.Json` NuGet package contains a *Newtonsoft.Json.dll* file that contains
    classes in the `Newtonsoft.Json` namespace, for example. But often there’s no
    such connection—the .NET runtime libraries include a *Sys⁠tem.​Pri⁠vat⁠e.C⁠ore⁠Lib⁠.dll*
    file, but there is no `System.Private.CoreLib` namespace. So it is necessary to
    tell the compiler which libraries your project depends on, and also which namespaces
    it uses. We will look at the nature and structure of library files in more detail
    in [Chapter 12](ch12.xhtml#ch_assemblies).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我使用`dotnet` CLI从我们的`Averages.Tests`项目向我们的`Averages`项目添加了一个引用。你可能会认为引用是多余的
    — 编译器不能从命名空间中推断出我们正在使用的外部库吗？如果命名空间与库或包直接对应，那么它可能可以，但实际上并非如此。有时候会有表面上的关联 — 流行的`Newtonsoft.Json`
    NuGet 包含一个*Newtonsoft.Json.dll*文件，其中包含`Newtonsoft.Json`命名空间的类，例如。但通常情况下并没有这样的对应关系
    — .NET 运行时库包括一个*Sys⁠tem.​Pri⁠vat⁠e.C⁠ore⁠Lib⁠.dll*文件，但却没有`System.Private.CoreLib`命名空间。因此，有必要告诉编译器你的项目依赖哪些库，以及使用了哪些命名空间。我们将在[第12章](ch12.xhtml#ch_assemblies)中更详细地讨论库文件的性质和结构。
- en: 'Even with namespaces, there’s potential for ambiguity. A single source file
    might use two namespaces that both happen to define a class of the same name.
    If you want to use that class, then you will need to be explicit, referring to
    it by its full name. If you need to use such classes a lot in the file, you can
    still save yourself some typing: you only need to use the full name once because
    you can define an *alias*. [Example 1-8](#resolving_ambiguity_with_aliases) uses
    aliases to resolve a clash that I’ve run into a few times: .NET’s desktop UI framework,
    the Windows Presentation Foundation (WPF), defines a `Path` class for working
    with Bézier curves, polygons, and other shapes, but there’s also a `Path` class
    for working with filesystem paths, and you might want to use both types together
    to produce a graphical representation of the contents of a file. Just adding `using`
    directives for both namespaces would make the simple name `Path` ambiguous if
    unqualified. But as [Example 1-8](#resolving_ambiguity_with_aliases) shows, you
    can define distinctive aliases for each.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 即使使用了命名空间，仍然存在潜在的歧义。单个源文件可能使用两个命名空间，这两个命名空间恰好都定义了同名的类。如果要使用这个类，就需要显式地引用它的完整名称。如果在文件中经常需要使用这些类，你仍然可以节省些打字：只需使用完整名称一次，因为你可以定义一个别名。[示例
    1-8](#resolving_ambiguity_with_aliases) 使用别名来解决我遇到过几次的冲突：.NET 的桌面 UI 框架，Windows
    Presentation Foundation（WPF），定义了一个用于处理贝塞尔曲线、多边形和其他形状的`Path`类，但也有一个用于处理文件系统路径的`Path`类，你可能想要同时使用这两种类型来生成文件内容的图形表示。如果不加任何`using`指令直接使用这两个命名空间，简单名称`Path`会存在歧义。但正如[示例
    1-8](#resolving_ambiguity_with_aliases)所示，你可以为每个类定义不同的别名。
- en: Example 1-8\. Resolving ambiguity with aliases
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-8\. 使用别名消除歧义
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With these aliases in place, you can use `IoPath` as a synonym for the file-related
    `Path` class, and `WpfPath` for the graphical one.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些别名，你可以使用`IoPath`作为文件相关的`Path`类的同义词，而使用`WpfPath`作为图形化类的同义词。
- en: By the way, you can refer to types in your own namespace without qualification,
    without needing a `using` directive. That’s why the test code in [Example 1-3](#unit_test_class_for_our_first_program)
    doesn’t have a `using Averages;` directive. However, you might be wondering how
    this works, since the test code declares a different namespace, `Averages.Tests`.
    To understand this, we need to look at namespace nesting.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，你可以在自己的命名空间中引用类型而无需限定符，也不需要`using`指令。这就是为什么[示例 1-3](#unit_test_class_for_our_first_program)中的测试代码没有`using
    Averages;`指令的原因。不过，也许你会想知道这是如何工作的，因为测试代码声明了一个不同的命名空间`Averages.Tests`。要理解这一点，我们需要看看命名空间的嵌套。
- en: Nested namespaces
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌套命名空间
- en: As you’ve already seen, the .NET runtime libraries nest their namespaces, sometimes
    quite extensively, and you will often want to do the same. There are two ways
    you can do this. You can nest namespace declarations, as [Example 1-9](#nesting_namespace_declarations)
    shows.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你已经看到的，.NET 运行时库会对其命名空间进行嵌套，有时候相当深入，你也经常会想要做同样的事情。你可以通过两种方式来实现这一点。你可以像[示例
    1-9](#nesting_namespace_declarations)所示那样嵌套命名空间声明。
- en: Example 1-9\. Nesting namespace declarations
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-9\. 嵌套命名空间声明
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Alternatively, you can just specify the full namespace in a single declaration,
    as [Example 1-10](#nested_namespace_with_a_single_declarati) shows. This is the
    more commonly used style. This single-declaration style works with either the
    new C# 10.0-style declaration shown in [Example 1-10](#nested_namespace_with_a_single_declarati)
    or with the older style using braces.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以在单个声明中指定完整的命名空间，正如 [示例 1-10](#nested_namespace_with_a_single_declarati)
    所示。这是更常用的风格。这种单一声明样式适用于新的 C# 10.0 样式声明或使用大括号的旧样式。
- en: Example 1-10\. Nested namespace with a single declaration
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-10\. 单个声明的嵌套命名空间
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Any code you write in a nested namespace will be able to use types not just
    from that namespace but also from its containing namespaces without qualification.
    Code in Examples [1-9](#nesting_namespace_declarations) or [1-10](#nested_namespace_with_a_single_declarati)
    would not need explicit qualification or `using` directives to use types either
    in the `MyApp.Storage` namespace or the `MyApp` namespace. This is why in [Example 1-3](#unit_test_class_for_our_first_program)
    I didn’t need to add a `using Averages;` directive to be able to access the `AverageCalculator`
    in the `Averages` namespace: the test was declared in the `Averages.Tests` namespace,
    and since that is nested in the `Averages` namespace, the code automatically has
    access to that outer namespace.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 任何您在嵌套命名空间中编写的代码都可以使用不仅来自该命名空间的类型，还可以使用其包含命名空间的类型而无需限定符。示例 [1-9](#nesting_namespace_declarations)
    或 [1-10](#nested_namespace_with_a_single_declarati) 中的代码不需要显式限定或 `using` 指令来使用
    `MyApp.Storage` 命名空间或 `MyApp` 命名空间中的类型。这就是为什么在 [示例 1-3](#unit_test_class_for_our_first_program)
    中，我不需要添加 `using Averages;` 指令来访问 `Averages` 命名空间中的 `AverageCalculator`：测试被声明在
    `Averages.Tests` 命名空间中，因此自动具有对该外部命名空间的访问权限。
- en: When you define nested namespaces, the convention is to create a matching directory
    hierarchy. Some tools expect this. Although VS Code doesn’t currently have any
    particular expectations here, Visual Studio does follow this convention. If your
    project is called `MyApp`, it will put new classes in the `MyApp` namespace when
    you add them to the project. But if you create a new directory in the project
    called, say, *Storage*, Visual Studio will put any new classes you create in that
    directory into the `MyApp.Storage` namespace. Again, you’re not required to keep
    this—Visual Studio just adds a namespace declaration when creating the file, and
    you’re free to change it. The compiler does not need the namespace to match your
    directory hierarchy. But since the convention is supported by various tools, including
    Visual Studio, life will be easier if you follow it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当您定义嵌套命名空间时，惯例是创建匹配的目录层次结构。一些工具期望如此。虽然 VS Code 目前在此方面没有特别的期望，但 Visual Studio
    遵循此惯例。如果您的项目叫做 `MyApp`，那么当您向项目中添加新类时，它们将放在 `MyApp` 命名空间中。但如果您在项目中创建一个名为 *Storage*
    的新目录，Visual Studio 将把您创建的任何新类放入 `MyApp.Storage` 命名空间中。再次强调，您并不需要保持这一点 —— Visual
    Studio 在创建文件时只是添加一个命名空间声明，您可以自由更改它。编译器不需要命名空间与目录层次结构匹配。但由于许多工具（包括 Visual Studio）支持这种约定，如果您遵循这种约定，生活会更轻松。
- en: Classes
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: After the namespace declaration, our *AverageCalculator.cs* file defines a *class*.
    [Example 1-11](#class_with_a_method) shows this part of the file. This starts
    with the `public` keyword, which enables this class to be accessed by other components.
    Next is the `static` keyword, which indicates that this class is not meant to
    be instantiated—it offers only class-level operations and no per-instance features.
    Then comes the `class` keyword followed by the name, and of course the full name
    of the type is effectively `Averages.AverageCalculator`, because of the namespace
    declaration. As you can see, C# uses braces ({}) to delimit all sorts of things—we
    already saw this in the older (but still widely used) namespace declaration syntax,
    and here you can see the same thing with the class, as well as the method it contains.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名空间声明之后，我们的 *AverageCalculator.cs* 文件定义了一个 *class*。 [示例 1-11](#class_with_a_method)
    展示了文件的这一部分。它以 `public` 关键字开始，这使得该类可以被其他组件访问。接下来是 `static` 关键字，表明此类不应该被实例化 —— 它仅提供类级别的操作而没有每个实例的特性。然后是
    `class` 关键字，后跟名称，当然，该类型的完整名称实际上是 `Averages.AverageCalculator`，因为有了命名空间声明。正如您所见，C#
    使用大括号（{}）来界定各种内容 —— 我们已经在旧的（但仍广泛使用的）命名空间声明语法中看到了这一点，这里您可以看到类似的情况，还有它包含的方法。
- en: Example 1-11\. A class with a method
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-11\. 带有方法的类
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Classes are C#’s mechanism for defining entities that combine state and behavior,
    a common object-oriented idiom. But this class contains nothing more than a single
    method. C# does not support global methods—all code has to be written as a member
    of some type. So this particular class isn’t very interesting—its only job is
    to act as the container for the method that will do the actual work. We’ll see
    some more interesting uses for classes in [Chapter 3](ch03.xhtml#ch_types).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 类是C#中定义结合状态和行为实体的机制，这是一种常见的面向对象习语。但这个类只包含一个方法。C#不支持全局方法——所有代码都必须作为某种类型的成员编写。因此，这个特定的类并不是很有趣——它的唯一作用是作为执行实际工作的方法的容器。在[第3章](ch03.xhtml#ch_types)中，我们将看到一些更有趣的类的用法。
- en: As with the class, I’ve marked the method as `public` to enable access from
    other components. I’ve also declared this to be a *static method*, meaning that
    it is not necessary to create an instance of the containing type (`AverageCalculator`,
    in this case) in order to invoke the method. The `double` keyword that follows
    indicates that the type of data this method returns is a double-precision floating-point
    number.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 与类一样，我将方法标记为`public`，以便从其他组件访问。我还声明了这是一个*静态方法*，这意味着不需要创建包含类型（在本例中为`AverageCalculator`）的实例即可调用该方法。后面跟随的`double`关键字表示此方法返回的数据类型是双精度浮点数。
- en: The method declaration is followed by the method body, which in this example
    contains code that returns a placeholder value, so all that remains is to modify
    the code inside the braces delimiting the method body. [Example 1-12](#calculating_the_average)
    shows code that calculates the average instead of just returning 1.0.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 方法声明后跟着方法体，例如本例中包含返回占位值的代码，因此剩下的工作就是修改方法体边界括号内的代码。[示例 1-12](#calculating_the_average)展示了计算平均值的代码，而不仅仅返回1.0。
- en: Example 1-12\. Calculating the average
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-12\. 计算平均值
- en: '[PRE20]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This relies on library functions for working with collections that are part
    of the set of features collectively known as LINQ, which is the subject of [Chapter 10](ch10.xhtml#ch_linq).
    But just to describe quickly what’s going on here, the `Select` method lets us
    apply an operation to every single item in a collection, and in this case, the
    operation I’m applying is the `double.Parse` method, a .NET runtime library function
    that converts a textual string containing a number into the native double-precision
    floating-point type. And then we push these transformed results through the `Average`
    method, which does the calculation for us.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这依赖于处理集合的库函数，这些函数是作为LINQ功能集的一部分，即语言集成查询的一部分。这是[第10章](ch10.xhtml#ch_linq)的主题。但是，简单描述一下这里发生的情况，`Select`方法允许我们对集合中的每个项应用操作，在这种情况下，我应用的操作是`double.Parse`方法，它是一个.NET运行时库函数，用于将包含数字的文本字符串转换为本机双精度浮点类型。然后我们通过`Average`方法将这些转换后的结果推送，该方法为我们执行计算。
- en: 'With this in place, if I run `dotnet test` again, it reports that all tests
    have passed. So apparently the code is working. However, I see a problem if I
    try to verify that informally by running the program, which I can do with this
    command:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好这些之后，如果再次运行`dotnet test`，它将报告所有测试都已通过。因此，显然代码是有效的。但是，如果我试图通过运行程序来非正式验证它，我会遇到一个问题，我可以用这个命令来执行：
- en: '[PRE21]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This just writes out `Hello, World!` to the screen. I’ve written and tested
    the code that performs the required calculation, but I’ve not yet connected that
    up to the program’s entry point. The code that runs when the program starts lives
    in *Program.cs*, although there’s nothing special about that filename. The program
    entry point can live in any file. In older versions of C#, you denoted the entry
    point by defining a `static` method called `Main`, as [Example 1-2](#hello_world_with_everything_visible)
    showed. But starting with C# 10.0, you can instead add a file that contains executable
    statements without putting them explicitly inside a method in a type, and the
    C# compiler will treat that as the entry point. (You’re only allowed to have one
    file in your project written that way, because your program can have only one
    entry point.) If I replace the entire contents of *Program.cs* with the code shown
    in [Example 1-13](#entry_point_calculating_average), it will have the desired
    effect.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是将`Hello, World!`输出到屏幕上。我已经编写并测试了执行所需计算的代码，但尚未将其连接到程序的入口点。程序启动时运行的代码位于*Program.cs*中，尽管该文件名并不特殊。程序入口点可以位于任何文件中。在较早版本的C#中，您通过定义一个名为`Main`的`static`方法来表示入口点，就像[示例
    1-2](#hello_world_with_everything_visible)所示。但从C# 10.0开始，您可以添加一个包含可执行语句的文件，而无需显式将它们放在类型的方法中，C#编译器将其视为入口点。（您只允许在项目中有一个以这种方式编写的文件，因为程序只能有一个入口点。）如果我用[示例
    1-13](#entry_point_calculating_average)中显示的代码替换*Program.cs*的整个内容，它将产生预期的效果。
- en: Example 1-13\. Program entry point with arguments
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-13\. 带参数的程序入口点
- en: '[PRE22]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that I’ve had to add a `using` directive—when you use C# 10.0’s new stripped-down
    program entry point syntax, the code in that file is not in any namespace by default,
    so I need to state that I want to use the class I defined in the `Averages` namespace.
    After that, this code invokes the method I wrote earlier, passing `args` as an
    argument, and then calls `Console.WriteLine` to display the result. When you use
    this style of program entry point, `args` is a special name—it’s effectively an
    implicitly defined local variable that provides access to the command-line arguments.
    This will be an array of strings, with one entry for each argument. If you want
    to run the program again with the same arguments as before, run the `dotnet build`
    command first to rebuild it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当您使用C# 10.0的新简化程序入口点语法时，该文件中的代码默认不属于任何命名空间，因此我需要声明我想要使用在`Averages`命名空间中定义的类。之后，这段代码调用我之前编写的方法，并将`args`作为参数传递，然后调用`Console.WriteLine`来显示结果。当您使用这种程序入口点样式时，`args`是一个特殊名称——它实际上是一个隐式定义的本地变量，提供对命令行参数的访问。这将是一个字符串数组，每个参数对应一个条目。如果您希望再次使用相同的参数运行程序，请先运行`dotnet
    build`命令重新构建它。
- en: Tip
  id: totrans-181
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Some C-family languages include the filename of the program itself as the first
    argument, on the grounds that it’s part of what the user typed at the command
    prompt. C# does not follow this convention. If the program is launched without
    arguments, the array’s length will be 0\. You might have noticed that the code
    does not cope well with that. Feel free to add a new test scenario that defines
    the relevant behavior, and to modify the program to match.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一些C家族语言将程序本身的文件名作为第一个参数包含在内，因为它是用户在命令提示符下键入的一部分。C#不遵循这种约定。如果程序在没有参数的情况下启动，数组的长度将为0。您可能已经注意到，该代码在这种情况下处理得不好。请随意添加一个定义相关行为的新测试场景，并修改程序以匹配。
- en: Unit Tests
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'Now that the program is working, I want to return to the tests, because they
    illustrate some C# features that the main program does not. If you go back to
    [Example 1-3](#unit_test_class_for_our_first_program), it starts in a pretty ordinary
    way: we have a `using` directive and then a namespace declaration, for `Averages.Tests`
    this time, matching the test project name. But the class looks different. [Example 1-14](#test_class_with_attribute)
    shows the relevant part of [Example 1-3](#unit_test_class_for_our_first_program).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在程序已经运行正常，我想回到测试，因为它们展示了一些主程序中没有的C#特性。如果你回顾一下[示例 1-3](#unit_test_class_for_our_first_program)，它从一个相当普通的方式开始：我们有一个`using`指令，然后是一个命名空间声明，这次是为`Averages.Tests`，与测试项目名称匹配。但这个类看起来有些不同。[示例
    1-14](#test_class_with_attribute)展示了[示例 1-3](#unit_test_class_for_our_first_program)中相关的部分。
- en: Example 1-14\. Test class with attribute
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 1-14\. 具有属性的测试类
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Immediately before the class declaration is the text `[TestClass]`. This is
    an *attribute*. Attributes are annotations you can apply to classes, methods,
    and other features of the code. Most of them do nothing on their own—the compiler
    records the fact that the attribute is present in the compiled output, but that
    is all. Attributes are useful only when something goes looking for them, so they
    tend to be used by frameworks. In this case, I’m using Microsoft’s unit testing
    framework, and it goes looking for classes annotated with this `TestClass` attribute.
    It will ignore classes that do not have this annotation. Attributes are typically
    specific to a particular framework, and you can define your own, as we’ll see
    in [Chapter 14](ch14.xhtml#ch_attributes).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在类声明之前的文本是 `[TestClass]`。这是一个 *属性*。属性是你可以应用于类、方法和代码的其他特性的注解。它们中的大多数本身什么都不做——编译器只会在编译输出中记录属性的存在。属性只有在某些情况下才有用，因此它们倾向于被框架使用。在这种情况下，我使用的是微软的单元测试框架，它会寻找带有
    `TestClass` 属性的类。它会忽略没有此注解的类。属性通常特定于特定的框架，你也可以定义自己的属性，正如我们将在 [第 14 章](ch14.xhtml#ch_attributes)
    中看到的。
- en: The two methods in the class are also annotated with attributes. [Example 1-15](#annotated_methods)
    shows the relevant excerpts from [Example 1-3](#unit_test_class_for_our_first_program).
    The test runner will execute any methods marked with the `[TestMethod]` attribute.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的两个方法也标有属性。[示例 1-15](#annotated_methods) 展示了来自 [示例 1-3](#unit_test_class_for_our_first_program)
    的相关摘录。测试运行器将执行任何标记有 `[TestMethod]` 属性的方法。
- en: Example 1-15\. Annotated methods
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-15\. 标记方法
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: And with that, we’ve examined every element of a program and the test project
    that verifies that it works as intended.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经检查了程序的每个元素以及验证其正常工作的测试项目。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You’ve now seen the basic structure of C# programs. I created a solution containing
    two projects, one for tests and one for the program itself. This was a simple
    example, so each project had only one or two source files of interest. Where necessary,
    these files began with `using` directives indicating which types the file uses.
    The program’s entry point used C# 10.0’s new stripped-down style, but the other
    two used a more conventional structure, containing a namespace declaration stating
    the namespace that the file populates, and a class containing one or more methods
    or other members, such as fields.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了 C# 程序的基本结构。我创建了一个包含两个项目的解决方案，一个用于测试，一个用于程序本身。这是一个简单的例子，因此每个项目只有一个或两个感兴趣的源文件。必要时，这些文件以
    `using` 指令开头，指示文件使用的类型。程序的入口点使用了 C# 10.0 的新精简样式，但另外两个项目使用了更传统的结构，包含一个声明命名空间的命名空间声明，以及包含一个或多个方法或其他成员（如字段）的类。
- en: We will look at types and their members in much more detail in [Chapter 3](ch03.xhtml#ch_types),
    but first, [Chapter 2](ch02.xhtml#ch_basic_coding) will deal with the code that
    lives inside methods, where we express what we want our programs to do.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [第 3 章](ch03.xhtml#ch_types) 中更详细地讨论类型及其成员，但首先，[第 2 章](ch02.xhtml#ch_basic_coding)
    将处理位于方法内部的代码，其中我们表达了我们的程序想要做什么。
- en: ^([1](ch01.xhtml#idm45884866324192-marker)) The old .NET Framework will be supported
    for many years to come, but Microsoft has stated that it will not get any new
    features.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch01.xhtml#idm45884866324192-marker)) 旧的 .NET Framework 将继续得到支持很多年，但微软已经表示它将不会获得任何新功能。
- en: '^([2](ch01.xhtml#idm45884864958992-marker)) .NET Native and NativeAOT don’t
    do this: they are designed specifically to avoid any runtime JIT, so they do not
    offer tiered compilation.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch01.xhtml#idm45884864958992-marker)) .NET Native 和 NativeAOT 并不这样做：它们专为避免任何运行时
    JIT 而设计，因此它们不提供分层编译。
- en: ^([3](ch01.xhtml#idm45884866256160-marker)) If you’re wondering how these version
    numbers and dates square with yearly, alternating releases, the current schedule
    was introduced with .NET Core 3.1, and there was no .NET Core 4\. When .NET Core
    was rebranded as plain .NET, it skipped from 3.1 to 5.0 to emphasize that this
    was moving on from .NET Framework, the latest version of which is 4.8.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch01.xhtml#idm45884866256160-marker)) 如果你想知道这些版本号和日期如何与年度交替发布相符，当前的时间表是从
    .NET Core 3.1 开始介绍的，没有 .NET Core 4。当 .NET Core 被重新命名为纯粹的 .NET 时，它从 3.1 跳到了 5.0，以强调这一点是从
    .NET Framework 转移，其最新版本为 4.8。
- en: ^([4](ch01.xhtml#idm45884866053648-marker)) Or .NET Core. The name changes can
    cause confusion here. A component supporting .NET Core 3.1 will work on .NET 5.0
    and .NET 6.0, because these are later versions of the same runtime; it just dropped
    the word *Core* and skipped a version number when .NET 5.0 shipped.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch01.xhtml#idm45884866053648-marker)) 或者 .NET Core。这里的名称变更可能会引起混淆。支持 .NET
    Core 3.1 的组件将在 .NET 5.0 和 .NET 6.0 上运行，因为它们是同一运行时的更新版本；在 .NET 5.0 发布时，它只是去掉了 *Core*
    这个词，并跳过了一个版本号。
