- en: Chapter 7\. Logging, Monitoring, and Instrumentation for .NET
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章\. 用于.NET的日志记录、监控和仪器设备
- en: Back in 2007, when people were setting up their Nintendo Wii and dreaming of
    owning Apple’s revolutionary new touchscreen cellphone, James was working his
    first job as a graduate software engineer. Not in web-based SaaS applications
    where he works today, however, but starting an engineering career writing industrial
    control software for production lines, oil rigs, cruise liners, and the military.
    Of all the weird and exciting projects James had a chance to work on back then,
    the most fun was designing the control system software for a roller coaster. Let
    us tell you how that worked.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 回到2007年，当人们正在安装他们的任天堂Wii并梦想拥有苹果革命性的新触摸屏手机时，詹姆斯作为一名毕业软件工程师开始了他的第一份工作。然而，当时他并不是在今天工作的基于Web的SaaS应用程序中工作，而是开始了一段为生产线、油井、游轮和军事编写工业控制软件的工程师职业生涯。在当时詹姆斯有机会参与的所有奇怪和令人兴奋的项目中，最有趣的是为过山车设计控制系统软件。让我们告诉你那是如何工作的。
- en: This was a theme park ride with several cars on wheels going around a typical
    roller coaster track. Each car carried four people and there were between three
    and five cars going around the track simultaneously at any one time. The cars
    would be sent off from the station, making their way up the chain-driven incline
    to the top of the track, then rolling down under gravity to make an intense, exciting,
    and most importantly *safe* ride.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个主题公园游乐设施，有多辆装有四个人的汽车沿着典型的过山车轨道行驶。每辆汽车从车站发出，沿着链条驱动的斜坡爬升到轨道顶部，然后在重力作用下滚下来，形成激烈而令人兴奋，最重要的是*安全*的乘车体验。
- en: 'The code that operated the roller coaster was incredibly simple: the software
    read an input for the “GO” button being pressed by a ride operator. This then
    commanded the brakes to release, sending the car from the station into the starting
    blocks of the incline. There, with no further control inputs from the software,
    the car would be picked up by the chain-lift mechanism, carried up to the top
    of the ramp, and then sent off around the track. The brakes, hidden under the
    track along the platform, would then be re-armed, ready to catch the car and stop
    it gently on return.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 操控过山车的代码非常简单：软件读取由乘车操作员按下的“GO”按钮的输入。然后，这会命令刹车释放，将车辆从车站发送到斜坡的起始区块。在那里，软件不再需要进一步的控制输入，车辆会被链条升降机制抓住，带到斜坡顶部，然后在轨道上发车。隐藏在轨道下的刹车则会重新装备，准备在车辆返回时轻轻停车。
- en: With multiple cars hurtling around a roller coaster track at the same time,
    however, it is not hard to see what could go wrong. What if one of them got stuck?
    What if a car didn’t have enough momentum to make it to the top of an incline
    or a fault on the track caused it to slow down or stop? With multiple cars on
    the track this can present a very real danger, potentially even risking human
    life. If one car stopped, we had to stop all the cars on the ride until an engineer
    could be sent out to fix the issue. For this reason, we had sensors and emergency
    brakes all over the track. We had code to detect cars entering “blocks” around
    the track in the same way a railroad signaling system works to prevent collisions.
    We had multiple sensors placed in a row to measure the speed of the cars at multiple
    points around the track.^([1](ch07.xhtml#idm45599651192176)) Every speed sensor,
    motion detector, emergency brake, *backup* emergency brake, all of this had to
    be coded in the software. The volume of all this code greatly surpassed that which
    we had to actually operate the ride. Ninety-five percent of the code that runs
    on the control system of a roller coaster is monitoring, logging, alarming, and
    triggering emergency brakes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，多辆汽车同时在过山车轨道上飞驰，很容易看出可能出现的问题。如果其中一辆卡住了呢？如果一辆车没有足够的动力爬到顶端，或者轨道上的故障导致它减速或停止了呢？多辆车在轨道上行驶可能会带来实际的危险，甚至可能危及人类生命。如果一辆车停下来，我们就必须停止所有的乘车，直到工程师被派出去修理问题。因此，我们在整个轨道上都安装了传感器和紧急制动装置。我们编写了代码来检测车辆进入轨道周围的“区块”，就像铁路信号系统防止碰撞那样运作。我们在一排中放置了多个传感器，以在轨道周围的多个点测量车辆的速度。^([1](ch07.xhtml#idm45599651192176))
    每个速度传感器、运动检测器、紧急制动装置、*备用*紧急制动装置，所有这些都必须在软件中编码。所有这些代码的量远远超过了我们实际操作乘车所需的代码量。过山车控制系统上运行的代码中，95%
    是监控、记录、报警和触发紧急制动。
- en: Your distributed cloud-based system is a roller coaster. The amount of code
    you need to perform the main function may be small, but the number and variety
    of things that can go wrong is large, and you may end up adding a lot more complexity
    into your system to account for the rare instances of something going wrong, in
    order to maintain a high level of service to your users.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 您的分布式基于云的系统就像过山车一样。执行主要功能可能需要的代码量很少，但是可能出错的事情种类繁多，您可能需要为了维护对用户的高级别服务而将更多复杂性加入系统中。
- en: 'In this chapter, we are going to look at what we can build, configure, or simply
    enable in AWS that will improve our ability to monitor a cloud-based application.
    The majority of the services we will visit are not .NET specific; however, AWS
    does provide .NET SDKs for many of the tools we are about to cover. This helps
    you dig deep into your C# source code to identify the cause of an error or performance
    bottleneck. We will start by introducing the most important page you will visit
    on the Management Console when it comes to logging and monitoring: CloudWatch.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论在 AWS 中可以构建、配置或简单启用的内容，这些内容将提高我们监控基于云的应用程序的能力。我们将访问的大多数服务并非特定于 .NET；然而，AWS
    为我们即将涵盖的许多工具提供了 .NET SDK。这有助于您深入挖掘 C# 源代码，以识别错误或性能瓶颈的原因。我们将从介绍在管理控制台上最重要的页面开始，当涉及到日志记录和监控时：CloudWatch。
- en: AWS CloudWatch
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS CloudWatch
- en: '[AWS CloudWatch](https://aws.amazon.com/cloudwatch) is a service (or rather
    a collection of services) from AWS that allow you to monitor, analyze, and act
    on events generated by your AWS resources. If you have some code deployed to and
    running on AWS, you will probably be able to monitor it using CloudWatch. [Figure 7-1](#Figure-7-1)
    shows the four core pillars of AWS CloudWatch: Collect, Monitor, Act, and Analyze.
    These pillars work together to allow you to iteratively improve the availability
    and scalability of your system.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[AWS CloudWatch](https://aws.amazon.com/cloudwatch) 是 AWS 提供的一个允许您监控、分析和响应由您的
    AWS 资源生成的事件的服务（或者说一系列服务）。如果您在 AWS 上部署了一些代码并运行它们，您可能会使用 CloudWatch 进行监控。[图 7-1](#Figure-7-1)
    展示了 AWS CloudWatch 的四个核心支柱：收集、监控、响应和分析。这些支柱共同工作，使您能够迭代地提高系统的可用性和可伸缩性。'
- en: '![doac 0701](assets/doac_0701.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0701](assets/doac_0701.png)'
- en: Figure 7-1\. The four pillars of AWS CloudWatch
  id: totrans-10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-1. AWS CloudWatch 的四个支柱
- en: You *Collect* log events emitted by your AWS services, *Monitor* them with dashboards
    and metrics, *Act* on exceptional cases using alarms, and periodically *Analyze*
    your application(s) in order to make architectural improvements. These four pillars
    are shown in a line in [Figure 7-1](#Figure-7-1); however, it is more accurately
    thought of as a feedback loop. Analysis of your logs and metrics will allow you
    to improve what logs are collected and fine-tune when to trigger alarms, thus
    guiding you to make changes to your resources. The benefit of this is to ensure
    your system is running with the most efficient amount of headroom. You will be
    able to allocate enough resources to keep your performance within a desired range,
    but not so much that it becomes unnecessarily expensive to run.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以*收集* AWS 服务发出的日志事件，通过仪表板和指标*监控*它们，通过警报*响应*异常情况，并定期*分析*您的应用程序，以进行架构改进。这四个支柱在
    [图 7-1](#Figure-7-1) 中以一行显示；然而，更准确地说它是一个反馈循环。对日志和指标的分析将允许您改进收集日志的内容，并精调何时触发警报，从而引导您对资源进行更改。这样做的好处是确保系统在最有效的资源余量下运行。您将能够分配足够的资源以保持性能在期望范围内，但不会过度增加成本。
- en: Collecting CloudWatch Logs
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 收集 CloudWatch 日志
- en: CloudWatch collects and stores log messages from the services you have deployed
    to AWS. Many AWS services natively publish CloudWatch log messages with information
    about the execution of that service. You can also manually set up log collection
    or, as we will demonstrate in this chapter, you can programmatically post log
    messages using the AWS .NET SDK.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: CloudWatch 从您部署到 AWS 的服务中收集和存储日志消息。许多 AWS 服务会原生地发布包含有关该服务执行信息的 CloudWatch 日志消息。您也可以手动设置日志收集，或者如本章所示，可以使用
    AWS .NET SDK 程序化地发布日志消息。
- en: 'Some of the AWS services that natively publish logs to CloudWatch include:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一些原生发布日志到 CloudWatch 的 AWS 服务包括：
- en: API Gateway
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: API 网关
- en: Can be configured to send errors, request and response parameters, payloads,
    and execution traces.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 可配置为发送错误、请求和响应参数、载荷和执行跟踪。
- en: Elastic Beanstalk
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性 Beanstalk
- en: Application and system log files from your Elastic Beanstalk application can
    be read in CloudWatch.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 Elastic Beanstalk 应用程序的应用程序和系统日志文件可以在 CloudWatch 中读取。
- en: AWS CodeBuild
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CodeBuild
- en: Sends full verbose build logs for all your cloud builds.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 发送所有云构建的完整详细构建日志。
- en: Amazon Cognito
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon Cognito
- en: Authentication and user management metrics can be sent to CloudWatch.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 认证和用户管理指标可以发送到 CloudWatch。
- en: Route 53
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Route 53
- en: Amazon’s Domain Name System (DNS) service can be configured to log DNS queries,
    amongst other things.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊的域名系统（Domain Name System，DNS）服务可配置记录 DNS 查询等内容。
- en: AWS Lambda
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda
- en: Lambda functions are automatically set up to send metrics and execution logs
    to CloudWatch.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 函数会自动设置发送指标和执行日志到 CloudWatch。
- en: Simple Notification Service (SNS)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 简单通知服务（Simple Notification Service，SNS）
- en: Mobile text messaging (SMS) deliveries from SNS are automatically logged.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SNS 发送的手机短信（SMS）会自动记录。
- en: These are just a few examples; a vast majority of AWS services do publish log
    messages, either completely automatically, or with a little configuration. For
    a full list of AWS services that can publish logs to CloudWatch, visit the AWS
    documentation page [“AWS services that publish logs to CloudWatch”](https://oreil.ly/dlbYK).
    Next we are going to explore logging from some of these services in more detail.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是一些示例；AWS 的绝大多数服务都会发布日志消息，要么完全自动，要么稍作配置。要查看可以发布日志到 CloudWatch 的 AWS 服务的完整列表，请访问
    AWS 文档页面 [“AWS services that publish logs to CloudWatch”](https://oreil.ly/dlbYK)。接下来，我们将详细探讨其中一些服务的日志记录。
- en: Logs from AWS Lambda functions
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 来自 AWS Lambda 函数的日志
- en: 'In the example for [“Developing with AWS Lambda and C#”](ch04.xhtml#4-developing-with-lambda),
    we created a new AWS Lambda function using the .NET CLI:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [“使用 AWS Lambda 和 C# 开发”](ch04.xhtml#4-developing-with-lambda) 的示例中，我们使用 .NET
    CLI 创建了一个新的 AWS Lambda 函数：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you followed this you may have noticed that as well as creating the function,
    the CLI also creates an IAM execution role under which the Lambda function will
    execute. If you navigate to this execution role in the IAM Management Console,
    you can see that one of the default permissions policies added to the role is
    called AWSLambdaBasicExecutionRole.^([2](ch07.xhtml#idm45599651136560)) This role
    is managed by AWS and is there to grant any new Lambda function the permission
    to be able to create a log group, create a stream, and then post log messages
    to CloudWatch. [Figure 7-2](#Figure-7-2) shows the policy JSON that is included
    in this policy.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循这个步骤，你可能已经注意到，除了创建函数外，CLI 还创建了一个 IAM 执行角色，Lambda 函数将在该角色下执行。如果你在 IAM 管理控制台导航到这个执行角色，你会看到默认权限策略之一是
    AWSLambdaBasicExecutionRole.^([2](ch07.xhtml#idm45599651136560)) 这个角色由 AWS 管理，旨在为任何新的
    Lambda 函数授予权限，以创建日志组、创建流并将日志消息发布到 CloudWatch。[Figure 7-2](#Figure-7-2) 展示了此策略中包含的策略
    JSON。
- en: Any service that posts log messages to AWS CloudWatch must be running under
    an IAM role that grants these permissions. Through their names, these permissions
    introduce us to three important concepts in CloudWatch logging.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 任何发布日志消息到 AWS CloudWatch 的服务必须在授予这些权限的 IAM 角色下运行。通过它们的名称，这些权限向我们介绍了 CloudWatch
    日志记录中的三个重要概念。
- en: '![doac 0702](assets/doac_0702.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0702](assets/doac_0702.png)'
- en: Figure 7-2\. CloudWatch permissions that are added to every new Lambda function
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-2\. 每个新 Lambda 函数添加的 CloudWatch 权限
- en: Groups, streams, and events
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组、流和事件
- en: CloudWatch stores log messages (or “events”) in streams, and then groups each
    set of streams by the service or instance that sent them. For example, if we were
    logging messages from the execution of a Lambda function, then each stream of
    events on one Lambda invocation will be written to the same *log stream*. Multiple
    concurrent invocations of the Lambda function would create separate log streams;
    however, these would still be grouped under the same *log group*. The log group
    corresponds, in this case, to the individual Lambda function. So in your CloudWatch
    console you will have a log group for each Lambda, EC2 instance, S3 bucket, CodeBuild
    project, or any service you are logging from. Under each log group will be multiple
    streams, each containing multiple messages. [Figure 7-3](#Figure-7-3) shows the
    log messages from one invocation of an AWS Lambda function. You can browse the
    groups, streams, and logs through the Logs section in the CloudWatch Management
    Console. It is also possible to view CloudWatch logs directly in Visual Studio
    if you have the AWS Toolkit for Visual Studio installed. Navigate to CloudWatch
    Logs in the AWS Explorer window, right-click on a log group, and select View Log
    Stream.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: CloudWatch 将日志消息（或“事件”）存储在流中，然后按发送它们的服务或实例对每组流进行分组。例如，如果我们记录来自 Lambda 函数执行的消息，则每次
    Lambda 调用的事件流将写入同一个 *日志流*。多个并发的 Lambda 函数调用将创建单独的日志流；然而，这些流仍将被分组在同一个 *日志组* 下。在这种情况下，日志组对应于单个
    Lambda 函数。因此，在 CloudWatch 控制台中，您将为每个 Lambda、EC2 实例、S3 存储桶、CodeBuild 项目或任何您正在记录的服务拥有一个日志组。在每个日志组下将有多个流，每个流包含多条消息。[图 7-3](#Figure-7-3)
    展示了 AWS Lambda 函数调用的日志消息。您可以通过 CloudWatch 管理控制台中的“日志”部分浏览组、流和日志。如果安装了 AWS Toolkit
    for Visual Studio，还可以直接在 Visual Studio 中查看 CloudWatch 日志。在 AWS Explorer 窗口中导航到
    CloudWatch Logs，右键单击日志组，然后选择“查看日志流”。
- en: '![doac 0703](assets/doac_0703.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0703](assets/doac_0703.png)'
- en: Figure 7-3\. (1) CloudWatch log groups, (2) log stream, and (3) log event messages
  id: totrans-40
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-3\. (1) CloudWatch 日志组，(2) 日志流，和 (3) 日志事件消息
- en: Now we have a bit of familiarity with how CloudWatch log events are stored and
    accessed, let’s see how we can take advantage of this to use CloudWatch to save
    custom log messages from our application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 CloudWatch 日志事件的存储和访问有了一些了解，让我们看看如何利用这一点来使用 CloudWatch 保存应用程序中的自定义日志消息。
- en: Sending Logs from C#
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送 C# 日志
- en: Out of the box AWS Lambda will forward any calls made to `Console.WriteLine()`
    to CloudWatch, but you can also push logs directly to CloudWatch from our C# application
    with the help of the AWSSDK.CloudWatchLogs NuGet package, part of the AWS SDK
    for .NET. With the package installed, create a new .NET 6 Console Application
    to log a test message, as shown in [Example 7-1](#ex_7-1).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，AWS Lambda 将转发对 `Console.WriteLine()` 的所有调用到 CloudWatch，但是您还可以通过 AWSSDK.CloudWatchLogs
    NuGet 包直接从我们的 C# 应用程序向 CloudWatch 推送日志，该包是 AWS SDK for .NET 的一部分。安装该包后，创建一个新的
    .NET 6 控制台应用程序来记录测试消息，如 [示例 7-1](#ex_7-1) 所示。
- en: Example 7-1\. Program.cs
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-1\. Program.cs
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since we haven’t yet created the `TestCloudWatchLogPublishing.CloudWatchLogger`
    class, this will fail to compile, but you can see all we are doing here is creating
    a new instance of a logger and writing a couple of log lines. The `using` block
    in this example is there as a handy way of scoping our logger instance over a
    few lines of code. The messages will be batched up and then flushed (sent to CloudWatch)
    when the `DisposeAsync()` method is called on the last line.^([3](ch07.xhtml#idm45599651054496))
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们尚未创建 `TestCloudWatchLogPublishing.CloudWatchLogger` 类，因此编译将失败，但是您可以看到我们在这里所做的一切只是创建一个新的日志记录器实例并写入几行日志。此示例中的
    `using` 块作为一种方便的方式，用于将我们的日志记录器实例限定在几行代码中。消息将被批处理，然后在调用最后一行的 `DisposeAsync()` 方法时刷新（发送到
    CloudWatch）。^([3](ch07.xhtml#idm45599651054496))
- en: 'Here is the code for our `TestCloudWatchLogPublishing.CloudWatchLogger` class
    that batches up and sends the log messages to AWS CloudWatch:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的 `TestCloudWatchLogPublishing.CloudWatchLogger` 类的代码，它将日志消息批处理并发送到 AWS
    CloudWatch：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_logging__monitoring__and___span_class__keep_together__instrumentation_for__net__span__CO1-1)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_logging__monitoring__and___span_class__keep_together__instrumentation_for__net__span__CO1-1)'
- en: The log group name in our example is simply hardcoded. We will most likely want
    to create a new log group during the deployment of this code to AWS, reading it
    perhaps through an environment variable.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，日志组名称只是硬编码的。在部署此代码到 AWS 期间，我们很可能希望通过环境变量来创建一个新的日志组。
- en: '[![2](assets/2.png)](#co_logging__monitoring__and___span_class__keep_together__instrumentation_for__net__span__CO1-2)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_logging__monitoring__and___span_class__keep_together__instrumentation_for__net__span__CO1-2)'
- en: Log messages will be written to this list and then “flushed” when the class
    is disposed.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 日志消息将写入此列表，然后在类被销毁时“刷新”。
- en: '[![3](assets/3.png)](#co_logging__monitoring__and___span_class__keep_together__instrumentation_for__net__span__CO1-3)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_logging__monitoring__and___span_class__keep_together__instrumentation_for__net__span__CO1-3)'
- en: Log streams should have a unique name. We are prefixing this with the date so
    it can be easily sorted.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 日志流应具有唯一的名称。我们在前面加上日期前缀，以便于排序。
- en: '[![4](assets/4.png)](#co_logging__monitoring__and___span_class__keep_together__instrumentation_for__net__span__CO1-4)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_logging__monitoring__and___span_class__keep_together__instrumentation_for__net__span__CO1-4)'
- en: A new log stream is created for each instance of our logger class.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每个日志记录器类的实例都会创建一个新的日志流。
- en: '[![5](assets/5.png)](#co_logging__monitoring__and___span_class__keep_together__instrumentation_for__net__span__CO1-5)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_logging__monitoring__and___span_class__keep_together__instrumentation_for__net__span__CO1-5)'
- en: All batched log messages are sent to CloudWatch here, using the `P⁠u⁠t⁠L⁠o⁠g⁠E⁠v⁠e⁠n⁠t⁠s​A⁠s⁠y⁠n⁠c⁠(⁠)`
    method from the AWS SDK.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所有批量日志消息都会使用 AWS SDK 中的`P⁠u⁠t⁠L⁠o⁠g⁠E⁠v⁠e⁠n⁠t⁠s​A⁠s⁠y⁠n⁠c⁠(⁠)`方法发送到 CloudWatch。
- en: Running this Console App gives the output shown back in [Figure 7-3](#Figure-7-3)
    when we view the logs in the [AWS Management Console](https://oreil.ly/067XH).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此控制台应用程序时，查看 [AWS 管理控制台](https://oreil.ly/067XH) 中的日志，将显示 [图 7-3](#Figure-7-3)
    中的输出。
- en: Tip
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: When running .NET applications locally, the AWS SDK will look for your AWS credentials
    in a series of places in order to connect to AWS and post the log messages to
    CloudWatch. On Windows environments there is a JSON file called the *SDK Store*
    located in *%USERPROFILE%\AppData\Local\AWSToolkit\RegisteredAccounts.json* or
    you can use the shared AWS credentials file. For information on all the available
    options for configuring your local connection to AWS visit [this documentation
    page](https://oreil.ly/O57Zy).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地运行 .NET 应用程序时，AWS SDK 会在一系列位置查找您的 AWS 凭据，以便连接到 AWS 并将日志消息发布到 CloudWatch。在
    Windows 环境中，有一个名为*SDK Store*的 JSON 文件，位于*%USERPROFILE%\AppData\Local\AWSToolkit\RegisteredAccounts.json*，或者您可以使用共享的
    AWS 凭据文件。有关配置本地连接到 AWS 的所有可用选项的信息，请访问[此文档页面](https://oreil.ly/O57Zy)。
- en: In the preceding example, we used `CloudWatchLogger` directly but, due to AWS
    Lambda’s ability to forward calls to `Console.WriteLine()` to CloudWatch, we can
    also use any of the popular logging packages for .NET that write to the console,
    and then allow AWS Lambda to forward that to CloudWatch for us.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们直接使用了`CloudWatchLogger`，但是由于 AWS Lambda 能够将对`Console.WriteLine()`的调用转发到
    CloudWatch，因此我们还可以使用任何流行的 .NET 日志包写入控制台，然后允许 AWS Lambda 为我们转发到 CloudWatch。
- en: 'For example, here is a configuration for Serilog that adds a `Serilog.Sinks.Console`
    logging sink, which AWS Lambda will send to CloudWatch:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是一个 Serilog 的配置，添加了一个`Serilog.Sinks.Console`日志汇，AWS Lambda 将发送到 CloudWatch：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can save this JSON to our *appsettings.json* file and with Serilog and the
    Serilog.Sinks.Console package installed, our Lambda function will send logs to
    CloudWatch.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将此 JSON 保存到我们的*appsettings.json*文件中，并且通过安装了 Serilog 和 Serilog.Sinks.Console
    包，我们的 Lambda 函数将向 CloudWatch 发送日志。
- en: You can find plugins for using other popular third-party logging libraries on
    the GitHub repository for [AWS Logging .NET0](https://oreil.ly/PYPL1).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [AWS Logging .NET0](https://oreil.ly/PYPL1) 的 GitHub 仓库中找到用于使用其他流行的第三方日志库的插件。
- en: Metrics
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指标
- en: So far we have only looked at log messages that capture a single event in time.
    This is great for debugging the execution of your application and capturing specific
    events, but for long-term monitoring and analysis of your system, we need to also
    capture metrics.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只查看了捕获单个事件的日志消息。这对于调试应用程序的执行和捕获特定事件非常有用，但是为了长期监视和分析系统，我们还需要捕获指标。
- en: A *metric* is the measure of a specific data point over a given period of time.
    For example, you might have an application that logs the response time for each
    HTTP request it processes, and you decide to measure the *average* response time
    *per minute*. This measure of average HTTP response time per minute is a metric,
    and it allows you to plot a time-series like the example shown in [Figure 7-4](#Figure-7-4).
    You can create and explore suggested metrics in the CloudWatch Management Console
    under Metrics → All Metrics.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*度量*是在一定时间内对特定数据点的测量。例如，您可能有一个记录每个 HTTP 请求响应时间的应用程序，并决定测量*每分钟*的*平均*响应时间。每分钟平均
    HTTP 响应时间的度量是一个指标，它允许您绘制类似于[图 7-4](#Figure-7-4)的时间序列。您可以在 CloudWatch 管理控制台的指标
    → 所有指标下创建和探索建议的指标。'
- en: It is also possible to publish custom metric data points from your C# code using
    the `AmazonCloudWatchClient` class, found in the AWSSDK.CloudWatch NuGet package.^([4](ch07.xhtml#idm45599650581152))
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用 AWSSDK.CloudWatch NuGet 包中的 `AmazonCloudWatchClient` 类从您的 C# 代码中发布自定义度量数据点。^([4](ch07.xhtml#idm45599650581152))
- en: '![doac 0704](assets/doac_0704.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0704](assets/doac_0704.png)'
- en: Figure 7-4\. API Gateway average latency metric
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-4\. API 网关平均延迟度量
- en: '[Example 7-2](#ex_7-2) sends the number of processes currently running on your
    local machine to CloudWatch:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7-2](#ex_7-2)将当前在您的本地计算机上运行的进程数发送到 CloudWatch：'
- en: Example 7-2\. Program.cs
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-2\. Program.cs
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can see the results of repeatedly running this in [Figure 7-5](#Figure-7-5).
    Note that CloudWatch automatically created the namespace “MyApplication” and the
    metric “ProcessCount” for us.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[图 7-5](#Figure-7-5)中看到重复运行此操作的结果。请注意，CloudWatch 自动为我们创建了命名空间“MyApplication”和度量“ProcessCount”。
- en: '![doac 0705](assets/doac_0705.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0705](assets/doac_0705.png)'
- en: Figure 7-5\. (1) Results of sending a custom metric with namespace, (2) metric
    name, and (3) the number of running processes
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-5\. (1) 发送带有命名空间的自定义度量结果，(2) 度量名称，以及 (3) 运行进程数
- en: So now that we have metrics going into CloudWatch, where do we go from here?
    Next, we are going to look at how we can build CloudWatch dashboards to visually
    monitor our system at a glance. Following on from that, we will look at how we
    can set up alarms to trigger when a metric passes a certain threshold.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的度量数据进入 CloudWatch，接下来我们将看看如何构建 CloudWatch 仪表板以便一目了然地监视我们的系统。随后，我们将看看如何设置警报，以在度量超过一定阈值时触发。
- en: Monitoring with CloudWatch Dashboards
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 CloudWatch 仪表板监控
- en: Dashboards allow you to monitor your AWS resources at a glance. You can monitor
    multiple resources across your entire AWS account at once by creating custom dashboards,
    picking out key metrics that you want to be able to monitor quickly and efficiently.
    CloudWatch generates *automatic* dashboards for your AWS services, and you can
    use these as a starting point to create your own.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板允许您一目了然地监视您的 AWS 资源。您可以通过创建自定义仪表板，选择要快速高效监视的关键指标，一次监视整个 AWS 帐户中的多个资源。CloudWatch
    为您的 AWS 服务生成*自动*仪表板，您可以将其用作创建自己仪表板的起点。
- en: Navigate to CloudWatch → Dashboards → Automatic Dashboards in the Management
    Console to view the available automatic dashboards. You can add widgets from the
    automatic dashboards onto a new, custom dashboard, or you can view and tweak the
    underlying metrics query by selecting “view in metrics” in the context menu of
    each widget. [Figure 7-6](#Figure-7-6) shows the custom dashboard generated for
    our Simple Storage Service (S3) buckets. You can see trends for bucket size and
    number of objects.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 转到管理控制台中的 CloudWatch → 仪表板 → 自动仪表板，查看可用的自动仪表板。您可以从自动仪表板中将小部件添加到新的自定义仪表板，或者通过选择每个小部件的上下文菜单中的“查看指标”来查看和调整底层指标查询。[图 7-6](#Figure-7-6)显示了为我们的简单存储服务
    (S3) 存储桶生成的自定义仪表板。您可以查看存储桶大小和对象数量的趋势。
- en: '![doac 0706](assets/doac_0706.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0706](assets/doac_0706.png)'
- en: Figure 7-6\. Automatic CloudWatch dashboard for Simple Storage Service (S3)
    buckets
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-6\. 简单存储服务 (S3) 存储桶的自动 CloudWatch 仪表板
- en: Dashboards allow you to visualize changes to your metrics over time, but what
    about if you want to actually perform some action when a metric hits a certain
    value? In [Figure 7-6](#Figure-7-6), you can see the `BucketSizeBytes` value for
    one of our S3 buckets was creeping up slowly over a long period of time (the sawtoothed
    line that drops suddenly on the first chart). Well, if we wanted we could set
    an upper limit to how many bytes we are comfortable storing in this S3 bucket,
    for cost reasons perhaps, and then perform some action if the bucket size exceeds
    this limit. For that, we use CloudWatch alarms.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板允许您随时间可视化指标的变化，但如果您希望在指标达到某个值时实际执行一些操作呢？在[图 7-6](#Figure-7-6)中，您可以看到我们的一个S3存储桶的`BucketSizeBytes`值在长时间内缓慢增长（第一个图表上突然下降的锯齿线）。如果我们希望的话，我们可以设置一个上限，即在这个S3存储桶中存储的字节数上限，可能出于成本考虑，然后在存储桶大小超过此限制时执行某些操作。为此，我们使用CloudWatch告警。
- en: CloudWatch alarms
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 云监控告警
- en: We introduced this chapter by talking about the monitoring software that keeps
    a roller coaster running safely. In industrial control software, such as with
    roller coasters, if an input is read outside some predetermined threshold for
    more than a set number of seconds, it will trigger an alarm. In an industrial
    application, these alarms will be connected to physical alarms that emit a loud
    audible tone alerting nearby operators to the condition being out of bounds. This
    could be a temperature setpoint being too low or too high for several seconds,
    or a discrete input such as a laser beam being broken. In the context of your
    distributed AWS system, you can configure alarms to trigger when your metrics
    go outside of the limits you have deemed “normal.” Alarms are there to trigger
    actions, either manually by a systems administrator, or automatically by triggering
    a function inside your system.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中介绍了监控软件，它保证了过山车的安全运行。在工业控制软件中，例如过山车，如果某个输入读取值在预定的阈值之外超过一定秒数，它将触发告警。在工业应用中，这些告警将连接到发出响亮的听得见的警报声的物理警报，通知附近的操作员条件超出正常范围。例如，可能是温度设定点低于或高于几秒钟，或者是离散输入，如激光束被切断。在您的分布式AWS系统中，您可以配置告警以在您认为“正常”的限制之外时触发。告警的目的是触发操作，可以是系统管理员手动操作，也可以是通过触发系统内功能自动执行。
- en: 'In CloudWatch, you can configure an alarm on any single metric, an expression
    derived from multiple metrics, or even other alarms. An alarm can be in one of
    three possible states:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在CloudWatch中，您可以为任何单个指标、从多个指标派生的表达式甚至其他告警配置告警。告警可以处于三种可能的状态之一：
- en: OK
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: OK
- en: The metric for this alarm is within the defined bounds, and the alarm is not
    triggered.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此告警的指标在定义的范围内，并且未触发。
- en: IN ALARM
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: IN ALARM
- en: The metric is outside the defined bounds, and the alarm is triggered.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 指标超出定义的范围，告警被触发。
- en: INSUFFICIENT_DATA
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: INSUFFICIENT_DATA
- en: There is not enough data (yet) to determine the alarm state.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 目前没有足够的数据来确定告警状态。
- en: Let’s add an alarm to the custom metric we created in [Figure 7-5](#Figure-7-5).
    To do this, navigate to CloudWatch in the Management Console and create the alarm,
    selecting MyApplication → Metrics with no dimensions → ProcessCount as the metric
    to monitor. In the example in [Figure 7-5](#Figure-7-5), we had between 287 and
    292 processes being reported in our custom metric, so we could set our alarm threshold
    to 290, which will make it easy to test. On the next screen select “Create a new
    topic” to have AWS create a new Simple Notification Service (SNS) topic. We introduced
    SNS in [“Developing with SQS and SNS”](ch04.xhtml#4-sqs-and-sns); it is a service
    that allows publishers and subscribers to create and listen to events, respectively.
    For the purposes of this alarm, we will be publishing a message to SNS when the
    alarm is triggered, that is, when the `ProcessCount` metric goes above our threshold
    of 290.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们在[图 7-5](#Figure-7-5)中创建的自定义指标添加一个告警。为此，请在管理控制台中导航至CloudWatch并创建告警，选择MyApplication
    → Metrics with no dimensions → ProcessCount作为要监视的指标。在[图 7-5](#Figure-7-5)的示例中，我们的自定义指标报告了287到292个进程，因此我们可以将告警阈值设置为290，这将使测试变得容易。在下一个屏幕上选择“创建新主题”，以便AWS创建一个新的简单通知服务（SNS）主题。我们在[“使用SQS和SNS进行开发”](ch04.xhtml#4-sqs-and-sns)中介绍了SNS；它是一个允许发布者和订阅者分别创建和侦听事件的服务。对于此告警的目的，当`ProcessCount`指标超过我们的290阈值时，我们将向SNS发布一条消息，触发告警。
- en: '[Figure 7-7](#Figure-7-7) shows this alarm after we have created it and waited
    a few minutes for it to have enough data to leave the *INSUFFICIENT_DATA* state.
    You can see from this graph that we have a horizontal line at 290, indicating
    this is the threshold above which our alarm will trigger.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-7](#Figure-7-7)显示了我们创建并等待几分钟以使其具有足够数据以退出*INSUFFICIENT_DATA*状态后的警报。从这个图表可以看出，我们在290处有一条水平线，表示这是我们将触发警报的阈值。'
- en: '![doac 0707](assets/doac_0707.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0707](assets/doac_0707.png)'
- en: Figure 7-7\. CloudWatch alarm monitoring our custom metric
  id: totrans-98
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-7\. CloudWatch警报监控我们的自定义指标
- en: We said at the start of this section that you can also configure an alarm to
    trigger on multiple metrics. That can be achieved with metric math, which we dig
    into next.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节开头提到，您还可以配置警报以触发多个指标。这可以通过指标数学来实现，我们将在接下来详细讨论。
- en: Metric math
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指标数学
- en: Metrics are data points that change over time and, as such, you can perform
    arithmetic operations on them over the same time period. CloudWatch enables a
    whole host of different expressions you can use to combine multiple metrics into
    one. There are too many to cover in this book; however, a full list of functions
    and expressions can be found [here](https://oreil.ly/2oYRC).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 指标是随时间变化的数据点，因此您可以在相同的时间段内对它们执行算术运算。CloudWatch使您能够使用多种表达式将多个指标组合成一个。在本书中无法涵盖所有内容；然而，您可以在[这里](https://oreil.ly/2oYRC)找到所有函数和表达式的完整列表。
- en: Using these arithmetic functions on our metrics, we can create *new* metrics
    that can be both added to a dashboard and used to trigger alarms. In [Figure 7-8](#Figure-7-8),
    we have created a new expression by combining the `ProcessCount` from our earlier
    example, with another custom metric that records the CPU usage of our local machine.
    This allows us to create a new metric for *Average CPU Per Process*, entered into
    the customizable “Label” field in the table in [Figure 7-8](#Figure-7-8).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这些算术函数对我们的指标进行操作，我们可以创建*新*的指标，这些指标既可以添加到仪表板中，也可以用于触发警报。在[图 7-8](#Figure-7-8)中，我们通过将我们早期示例中的`ProcessCount`与另一个记录本地机器CPU使用率的自定义指标相结合，创建了一个新的表达式。这允许我们为*每个进程的平均CPU*创建一个新指标，输入到[图 7-8](#Figure-7-8)中表格中可自定义的“标签”字段。
- en: '![doac 0708](assets/doac_0708.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0708](assets/doac_0708.png)'
- en: Figure 7-8\. Average CPU per process metric created using metric math
  id: totrans-104
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-8\. 使用指标数学创建的平均每个进程CPU指标
- en: We created this expression from the Add Math context menu option above the metrics
    table and selected “Start with empty expression.” The expression in this example
    is `m2 / m1` where `m1` and `m2` are the default identifiers given to our two
    custom metrics in the list. You can view/change this metric ID by editing the
    “ID” field in the table in [Figure 7-8](#Figure-7-8).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从上面的添加数学上下文菜单选项中创建了这个表达式，并选择了“以空表达式开始”。在这个例子中，表达式是 `m2 / m1`，其中 `m1` 和 `m2`
    是列表中我们两个自定义指标的默认标识符。您可以通过编辑表格中的“ID”字段查看/更改此指标ID，如[图 7-8](#Figure-7-8)中所示。
- en: By using metric math, we can create complex graphs and alarm conditions to monitor
    any parameter inside our system we like. There is even an `IF(condition, trueValue,
    falseValue)` condition available in metric math that allows us to do things such
    as filter out data points from a time series. Perhaps we want to filter out the
    first 10 minutes of data points after a system reboot, or during a software update.
    This is possible by building up new metric expressions using metric math in AWS
    CloudWatch.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用指标数学，我们可以创建复杂的图表和警报条件，以监控系统内部的任何参数。在指标数学中甚至有一个`IF(condition, trueValue,
    falseValue)`条件，允许我们执行诸如过滤时间序列中的数据点等操作。也许我们想要在系统重新启动后或软件更新期间过滤掉前10分钟的数据点，这是可能的，通过在AWS
    CloudWatch中使用指标数学构建新的指标表达式。
- en: CloudWatch anomaly detection
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CloudWatch异常检测
- en: It is also possible to trigger CloudWatch alarms using a feature called *anomaly
    detection*. This is a machine learning algorithm that continuously monitors your
    metric and determines a normal baseline by means of a range of *expected values*.
    The alarm can then be triggered if the metric deviates too far outside this range.
    The model used by CloudWatch’s anomaly detection can asses hourly, daily, and
    weekly patterns using the historical values of your metric. This allows it to
    generate a range of expected values even for metrics that naturally change to
    follow a regular pattern over time—such as metrics related to usage patterns of
    your application. To create a CloudWatch alarm based on anomaly detection, look
    out for the Anomaly detection option under the Alarm → Graphed Metrics → Conditions
    section of the alarm configuration in the [CloudWatch console](https://oreil.ly/Ag1Tq).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用称为*异常检测*的功能触发CloudWatch警报。这是一种机器学习算法，持续监视您的度量，并通过一系列*预期值*确定正常基线。如果度量超出此范围太远，就可以触发警报。CloudWatch异常检测使用您的度量的历史值来评估每小时、每日和每周模式。这使其能够生成预期值范围，即使是那些随着时间自然变化以遵循正常模式的度量，例如与应用程序使用模式相关的度量。要基于异常检测创建CloudWatch警报，请查看警报配置中的“云监控控制台”下的“异常检测”选项（https://oreil.ly/Ag1Tq）。
- en: Next, we are going to move on from metrics and look at tracing the execution
    path of your code using a service from AWS called X-Ray.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从度量指标转移到使用名为X-Ray的AWS服务跟踪代码执行路径。
- en: Distributed Tracing with X-Ray
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用X-Ray进行分布式跟踪
- en: AWS X-Ray is a service that offers end-to-end tracing for your cloud-hosted
    applications, giving you insights into the way your code is executing. You can
    set up X-Ray tracing for HTTP requests for example, and view the execution path
    through any downstream service calls this HTTP request results in. This gives
    you the ability to debug your application as it is running in the cloud, helping
    you understand the root causes of any issues. You can also use AWS X-Ray to find
    performance bottlenecks in the execution path of your code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: AWS X-Ray是一个为您的云托管应用程序提供端到端跟踪的服务，使您能够深入了解代码执行方式。例如，您可以为HTTP请求设置X-Ray跟踪，并查看该HTTP请求导致的任何下游服务调用的执行路径。这使您能够在云中运行应用程序时调试应用程序，帮助您理解任何问题的根本原因。您还可以使用AWS
    X-Ray查找代码执行路径中的性能瓶颈。
- en: In order to leverage the tools AWS X-Ray provides, you need to set up your services
    to publish trace events to X-Ray. X-Ray tracing events can be configured automatically
    for a lot of native AWS services such as AWS Lambda and DynamoDB. Enabling tracing
    on a Lambda function is a simple case of toggling the “Active tracing” switch
    in the Management Console for any Lambda function (shown in [Figure 7-9](#Figure-7-9)).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用AWS X-Ray提供的工具，您需要设置您的服务以发布跟踪事件到X-Ray。X-Ray跟踪事件可以自动配置为许多本地AWS服务，如AWS Lambda和DynamoDB。在Lambda函数上启用跟踪只需在管理控制台中为任何Lambda函数切换“Active
    tracing”开关（显示在[图 7-9](#Figure-7-9)）。
- en: '![doac 0709](assets/doac_0709.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0709](assets/doac_0709.png)'
- en: Figure 7-9\. X-Ray can be enabled in the configuration settings for many native
    AWS services
  id: totrans-114
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-9\. 可以在许多本地AWS服务的配置设置中启用X-Ray
- en: 'If you have your infrastructure controlled by an Infrastructure as Code (IaC)
    framework such as [“Serverless Application Model (SAM)”](ch04.xhtml#4-serverless-application-model),
    you can enable active tracing in your configuration so it is set when you deploy
    changes to your resources. Here is the SAM configuration to enable X-Ray on a
    Lambda function; we have added `Tracing:Active` to the properties object:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的基础架构由Infrastructure as Code（IaC）框架控制，例如[“无服务器应用程序模型（SAM）”](ch04.xhtml#4-serverless-application-model)，则可以在配置中启用活动跟踪，以便在部署资源更改时设置。以下是启用Lambda函数上X-Ray的SAM配置；我们在属性对象中添加了`Tracing:Active`：
- en: '[PRE5]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Not all AWS services can be enabled like this; however, for these we do have
    options to use the SDK for .NET.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的AWS服务都可以像这样启用；然而，对于这些服务，我们有使用.NET SDK的选项。
- en: Setting Up X-Ray Using the SDK for .NET
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用.NET SDK设置X-Ray
- en: While enabling X-Ray for native services such as AWS Lambda is a simple case
    of toggling a switch (as shown in [Figure 7-9](#Figure-7-9)), if your code is
    instead running inside an EC2 container (including Elastic Beanstalk) or on App
    Runner, then you will need to configure some things yourself. You will need to
    install or enable the X-Ray daemon, which runs in the background on your EC2 instance
    collecting X-Ray trace messages, batching them up, and forwarding them on to AWS
    X-Ray. You will also need to use the X-Ray SDK for .NET in your C# code to send
    traces to the daemon.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用像 AWS Lambda 这样的本地服务的 X-Ray 时，只需切换一个开关即可（如 [图 7-9](#Figure-7-9) 所示）。但是，如果你的代码运行在
    EC2 容器中（包括 Elastic Beanstalk）或者 App Runner 上，则需要手动配置一些内容。你需要安装或启用 X-Ray 守护程序，该守护程序在后台运行于你的
    EC2 实例上，收集 X-Ray 跟踪消息，并将它们批量处理并发送到 AWS X-Ray。此外，你还需要在你的 C# 代码中使用 X-Ray SDK 来将跟踪消息发送给守护程序。
- en: 'On an EC2 instance, you can download and install the X-Ray daemon to run automatically
    when you launch the instance by running:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 EC2 实例上，你可以通过以下命令下载并安装 X-Ray 守护程序，以便在启动实例时自动运行：
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you are using Elastic Beanstalk, you can enable it in the Management Console
    under Configuration → Software Settings → X-Ray daemon. There is also an option
    on the publish page in the AWS Toolkit for Visual Studio. Check “Enable AWS X-Ray
    Tracing Support” when publishing your application to Elastic Beanstalk and the
    AWS Toolkit will enable the daemon for you.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Elastic Beanstalk，你可以在管理控制台的配置 → 软件设置 → X-Ray 守护程序下启用它。在使用 AWS Toolkit
    for Visual Studio 发布应用程序时，在发布页面上也有一个选项。在发布应用程序到 Elastic Beanstalk 时勾选“启用 AWS X-Ray
    跟踪支持”，AWS Toolkit 将会为你启用守护程序。
- en: You can also run the X-Ray daemon process locally on your development machine.
    You can find instructions for running the daemon locally on Windows, Linux, Mac
    OS, and even in a Docker container by visiting [the X-Ray setup guide](https://oreil.ly/Spc0P).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在本地开发机上运行 X-Ray 守护程序进程。你可以通过访问 [X-Ray 设置指南](https://oreil.ly/Spc0P) 来获取在
    Windows、Linux、Mac OS 甚至 Docker 容器中本地运行守护程序的指南。
- en: 'Once the daemon is installed on your EC2 instance, you will be able to use
    the X-Ray SDK in your application to send trace messages to X-Ray. To do this,
    start by installing the NuGet package AWSXRayRecorder, then add the following
    three lines to the *Program.cs* of your .NET 6 web application:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了守护程序后，你就可以在应用程序中使用 X-Ray SDK 将跟踪消息发送到 X-Ray。要做到这一点，请首先安装 NuGet 包 AWSXRayRecorder，然后将以下三行代码添加到你的
    .NET 6 Web 应用程序的 *Program.cs* 文件中：
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_logging__monitoring__and___span_class__keep_together__instrumentation_for__net__span__CO2-1)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_logging__monitoring__and___span_class__keep_together__instrumentation_for__net__span__CO2-1)'
- en: Initializes the AWS X-Ray recorder for this application.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为这个应用程序初始化 AWS X-Ray 记录器。
- en: '[![2](assets/2.png)](#co_logging__monitoring__and___span_class__keep_together__instrumentation_for__net__span__CO2-2)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_logging__monitoring__and___span_class__keep_together__instrumentation_for__net__span__CO2-2)'
- en: Add this line if you are using the AWS SDK to make calls to other AWS services
    inside your application. This will allow X-Ray to trace requests through these
    downstream services.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在应用程序中使用 AWS SDK 调用其他 AWS 服务，请添加此行代码。这将允许 X-Ray 通过这些下游服务跟踪请求。
- en: '[![3](assets/3.png)](#co_logging__monitoring__and___span_class__keep_together__instrumentation_for__net__span__CO2-3)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_logging__monitoring__and___span_class__keep_together__instrumentation_for__net__span__CO2-3)'
- en: Add X-Ray tracing to the routes in your web application. The name “ElasticBeanstalkAppExample”
    will be used to identify this application in X-Ray.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 Web 应用程序路由中添加 X-Ray 跟踪。名称“ElasticBeanstalkAppExample”将用于在 X-Ray 中标识此应用程序。
- en: Adding these three lines will send trace messages to X-Ray for each HTTP request
    that comes into your web application. You will be able to measure the duration
    of the request, including any synchronous calls to downstream AWS services. X-Ray
    has a concept it calls “segments,” which are measurable portions of the execution
    path of your code. The entire HTTP request is the parent “segment,” and any downstream
    calls that are made as a part of this request will be “subsegments” inside. You
    can also configure your own subsegments using the X-Ray SDK, allowing you to measure
    timings for custom parts of your code. In the following example, we have set a
    subsegment for the duration of the code inside the controller action. We are then
    invoking an AWS Lambda function from our code called `TracedLambdaFunction`. X-Ray
    will also create a subsegment for that Lambda invocation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这三行代码将为进入您的 Web 应用程序的每个 HTTP 请求发送跟踪消息到 X-Ray。您将能够测量请求的持续时间，包括任何对下游 AWS 服务的同步调用。X-Ray
    有一个称为 “segments” 的概念，它们是代码执行路径的可测量部分。整个 HTTP 请求是父 “segment”，而此请求作为其一部分进行的任何下游调用将作为
    “subsegments”。您还可以使用 X-Ray SDK 配置自己的子段，以测量代码的自定义部分的时间。在下面的示例中，我们为控制器动作内代码的持续时间设置了一个子段。然后我们从我们的代码中调用了一个名为
    `TracedLambdaFunction` 的 AWS Lambda 函数。X-Ray 也将为该 Lambda 调用创建一个子段。
- en: Example 7-3\. Program.cs
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-3\. Program.cs
- en: '[PRE8]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We will be able to view the trace results for this example in the X-Ray traces
    section of the CloudWatch Management Console. [Figure 7-10](#Figure-7-10) shows
    the trace results for this controller method. You can see the Lambda function
    execution took 2.45 seconds to return. The controller action subsegment we set
    up with `AWSXRayRecorder.Instance.BeginSubsegment(...)` took 2.67 seconds, and
    the entire HTTP request was 2.76 seconds.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将能够在 CloudWatch 管理控制台的 X-Ray traces 部分查看此示例的跟踪结果。图 7-10\. 展示了此控制器方法的跟踪结果。您可以看到
    Lambda 函数执行花费了 2.45 秒返回。我们在控制器动作中设置的子段，使用 `AWSXRayRecorder.Instance.BeginSubsegment(...)`，花费了
    2.67 秒，整个 HTTP 请求花费了 2.76 秒。
- en: '![doac 0710](assets/doac_0710.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0710](assets/doac_0710.png)'
- en: Figure 7-10\. Trace view of our web application controller call
  id: totrans-137
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-10\. 我们 Web 应用程序控制器调用的跟踪视图
- en: With X-Ray tracing you can quickly find performance bottlenecks in your code
    and refactor or rearchitect your code paths accordingly. There is another feature
    of X-Ray that is enabled by adding tracing to your applications and services,
    and that is the *Service Map*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 X-Ray 追踪，您可以快速找出代码中的性能瓶颈，并相应地重构或重新设计代码路径。通过为您的应用程序和服务添加跟踪功能，X-Ray 还启用了另一个功能，即
    *服务映射*。
- en: X-Ray Service Map
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: X-Ray 服务映射
- en: The Service Map is now found under the X-Ray traces section of the AWS CloudWatch
    Management Console, and it is a visualization of all your X-Ray enabled services
    and how they interact.^([5](ch07.xhtml#idm45599650100960)) [Figure 7-11](#Figure-7-11)
    shows the Service Map for the previous example. You can see we have our web application
    ElasticBeanstalkAppExample that makes a call off to the Lambda function `TracedLambdaFunction`.
    Because we used the X-Ray SDK and called `AWSSDKHandler.RegisterXRayForAllServices()`
    in our web application, X-Ray was able to determine that this Lambda invocation
    was called from within the .NET web application we deployed to Elastic Beanstalk.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，服务映射位于 AWS CloudWatch 管理控制台的 X-Ray traces 部分，它是所有启用了 X-Ray 的服务及其交互的可视化展示。^([5](ch07.xhtml#idm45599650100960))
    [Figure 7-11](#Figure-7-11) 展示了先前示例的服务映射。你可以看到，我们有我们的 Web 应用 ElasticBeanstalkAppExample，它调用了名为
    `TracedLambdaFunction` 的 Lambda 函数。因为我们在 Web 应用中使用了 X-Ray SDK，并调用了 `AWSSDKHandler.RegisterXRayForAllServices()`，X-Ray
    能够确定此 Lambda 调用来自我们部署到 Elastic Beanstalk 的 .NET Web 应用程序内部。
- en: '![doac 0711](assets/doac_0711.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0711](assets/doac_0711.png)'
- en: Figure 7-11\. X-Ray can be enabled in the configuration settings for many native
    AWS services
  id: totrans-142
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-11\. X-Ray 可以在许多原生 AWS 服务的配置设置中启用
- en: You can click on the services in the Service Map interface to trace the execution
    path(s) through them and see performance metrics such as latency and 5xx error
    rates. In [Figure 7-11](#Figure-7-11), we have the “ElasticBeanstalkAppExample”
    selected.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在服务映射界面中单击服务，跟踪它们的执行路径，并查看延迟和 5xx 错误率等性能指标。在 [Figure 7-11](#Figure-7-11)
    中，我们选择了 “ElasticBeanstalkAppExample”。
- en: Next we are going to look at using X-Ray with OpenTelemetry, an open source
    observability framework that provides a common framework for instrumentation across
    multiple cloud providers, including AWS.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 下面我们将看看如何在 OpenTelemetry 中使用 X-Ray，这是一个开源的可观测性框架，为跨多个云提供商（包括 AWS）提供了一个通用的工具框架。
- en: OpenTelemetry and App Runner
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenTelemetry 和 App Runner
- en: For all the previous services we have been using the X-Ray SDK and/or simply
    taking advantage of built in X-Ray tracing functionality, such as with AWS Lambda.
    It is also possible to use X-Ray with OpenTelemetry to send tracing information
    to X-Ray without as much vendor lock-in. This is the solution if you want to take
    advantage of X-Ray tracing from within a containerized application, such as one
    running on Amazon ECS or Amazon EKS.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于之前使用的所有服务，我们一直在使用 X-Ray SDK 和/或简单地利用内置的 X-Ray 追踪功能，例如在 AWS Lambda 中。还可以使用
    OpenTelemetry 与 X-Ray 一起发送跟踪信息，以减少供应商锁定。如果您希望从容器化应用程序（例如在 Amazon ECS 或 Amazon
    EKS 上运行的应用程序）中利用 X-Ray 追踪，则可以采用此解决方案。
- en: With the OpenTelemetry SDK added in your codebase, the [AWS Distro for OpenTelemetry](https://aws.amazon.com/otel)
    can be used to then instrument your .NET application and send the metrics to X-Ray.
    You can find more information about setting up OpenTelemetry for your .NET Core/6+
    application by visiting [Getting Started with the .NET SDK on Traces Instrumentation](https://oreil.ly/xGe4T).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的代码库中添加了 OpenTelemetry SDK 后，可以使用[AWS OpenTelemetry 发行版](https://aws.amazon.com/otel)来仪器化您的
    .NET 应用程序并将指标发送到 X-Ray。您可以通过访问[开始使用 .NET SDK 进行跟踪仪器化](https://oreil.ly/xGe4T)了解有关为您的
    .NET Core/6+ 应用程序设置 OpenTelemetry 的更多信息。
- en: Resource Health and Synthetics Canaries
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源健康和合成金丝雀
- en: 'If you have explored around the CloudWatch Management Console by now, you may
    have visited the Application monitoring section. Under this topic are several
    services from AWS that help us monitor our resources. Let’s take a quick look
    at two of these: Resource Health and Synthetics Canaries.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经在 CloudWatch 管理控制台周围探索过，那么您可能已经访问了应用程序监控部分。在这个主题下，有几项来自 AWS 的服务帮助我们监控资源。让我们快速浏览其中的两项：资源健康和合成金丝雀。
- en: 'The Resource Health view was previously a part of ServiceLens and shows you
    health and performance data for all your running EC2 hosts. You can customize
    your view by selecting from three dimensions: CPU Utilization, Memory Utilization,
    and Status Check. The Management Console window will show blocks of colored squares
    for each EC2 host in the current region. This gives you an easy-to-read and accessible
    view of the alarm status of most or all of your hosts.^([6](ch07.xhtml#idm45599650082128))'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 资源健康视图以前是 ServiceLens 的一部分，显示您所有运行中 EC2 主机的健康和性能数据。您可以通过从三个维度选择来自定义视图：CPU 利用率、内存利用率和状态检查。管理控制台窗口将为当前区域中的每个
    EC2 主机显示彩色方块块。这为您提供了一个易于阅读和访问的视图，显示大多数或所有主机的警报状态。^([6](ch07.xhtml#idm45599650082128))
- en: Synthetics Canaries is another great tool tucked away under the Application
    monitoring section of CloudWatch. A “canary” in systems monitoring is an active
    monitoring technique that uses a script or other scheduled task to regularly probe
    the status of a system.^([7](ch07.xhtml#idm45599650080256))
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 合成金丝雀是 CloudWatch 应用程序监控部分中的另一个强大工具。在系统监控中，“金丝雀”是一种活跃的监控技术，它使用脚本或其他定期任务定期探测系统的状态。^([7](ch07.xhtml#idm45599650080256))
- en: 'You can create several types of canary in AWS using the templates (or “blueprints”)
    provided:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用提供的模板（或“蓝图”）在 AWS 中创建多种类型的金丝雀：
- en: Heartbeat monitoring
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 心跳监控
- en: API canary
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 金丝雀
- en: Broken link checker
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坏链检查器
- en: Canary recorder
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 金丝雀记录器
- en: GUI workflow builder
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GUI 工作流构建器
- en: Visual monitoring
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化监控
- en: The idea behind a synthetic canary is to replicate behavior that approximates
    the real usage your application will be asked to perform for its users. So, for
    example, an API canary can be configured to make series requests to your API that
    mirror what a frontend would do under normal operation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 合成金丝雀的理念是复制模拟您的应用程序将要为用户执行的实际使用情况。例如，API 金丝雀可以配置为对您的 API 进行系列请求，模拟前端在正常操作下执行的操作。
- en: Synthetics can be easily integrated with X-Ray by selecting “Trace my service
    with AWS X-Ray” when creating your canary. Refer back to [“Distributed Tracing
    with X-Ray”](#7-x-ray) for configuration and familiarity with X-Ray.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建您的金丝雀时，可以通过选择“使用 AWS X-Ray 追踪我的服务”轻松集成合成与 X-Ray。有关配置和熟悉 X-Ray，请参阅[“使用 X-Ray
    进行分布式追踪”](#7-x-ray)。
- en: Using AWS CloudTrail for Security Auditing
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AWS CloudTrail 进行安全审计
- en: So far in this chapter we have been looking at AWS CloudWatch for logging monitoring
    of your deployed services in order to find and fix issues. Before we leave the
    topic of logging and monitoring, however, let’s just have a quick look at what
    AWS has to offer for the auditing of your account itself.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在AWS CloudWatch中查看日志，监视您部署的服务以查找并修复问题。然而，在我们离开日志记录和监视主题之前，让我们简要了解一下AWS为账户审计提供的功能。
- en: CloudTrail is a service from AWS that records all requests to the AWS APIs in
    your account and logs them against the user that made the request. These API requests
    can be made from anywhere, including through the AWS CLI, the Management Console,
    or from an SDK such as the AWS SDK for .NET (see [“AWS SDK for .NET documentation”](ch01.xhtml#one-aws-sdk)).
    You can even monitor requests made by another AWS service in CloudTrail. CloudTrail
    has its own section in the AWS Management Console, so to access it and view your
    audit logs, search for “CloudTrail” in the search bar.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: CloudTrail是AWS的一个服务，记录您账户中对AWS API的所有请求，并记录下发出请求的用户。这些API请求可以从任何地方进行，包括通过AWS
    CLI、管理控制台或来自AWS SDK（例如AWS SDK for .NET）的SDK。您甚至可以在CloudTrail中监视另一个AWS服务发出的请求。CloudTrail在AWS管理控制台中有其自己的部分，因此要访问它并查看您的审计日志，请在搜索栏中搜索“CloudTrail”。
- en: Tip
  id: totrans-164
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: For Google Chrome users, you can move focus to the search bar at any time while
    navigating the AWS Management Console by using ALT+S (Option+S on a Mac). Another
    handy feature of the Management Console is the favorites “star” next to each service
    in the search results. Clicking this causes a link to that service to appear permanently
    in the header bar of the Management Console window and persists as you navigate
    around the various AWS services.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Google Chrome用户，您可以使用ALT+S（Mac上的Option+S）随时将焦点移动到AWS管理控制台中的搜索栏。管理控制台的另一个方便的功能是搜索结果中每个服务旁边的收藏夹“星号”。单击此按钮将导致指向该服务的链接永久显示在管理控制台窗口的标题栏中，并且在您浏览各种AWS服务时保持不变。
- en: 'To get started with CloudTrail, click “Create a Trail” and run through the
    setup to configure attributes for your trail, primarily a name and S3 bucket in
    which to store the logs. You can choose to monitor any or all of these event types:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用CloudTrail，请点击“创建跟踪”，并进行设置以配置跟踪的属性，主要是名称和用于存储日志的S3存储桶。您可以选择监视任何或所有这些事件类型：
- en: Management events
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 管理事件
- en: Operations performed on your AWS resources, for example attaching a policy to
    an IAM role or creating a subnet in EC2.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的AWS资源上执行的操作，例如将策略附加到IAM角色或在EC2中创建子网。
- en: Data events
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 数据事件
- en: Actions performed on an instance of a resource. Data events include deleting,
    creating, or updating S3 objects, DynamoDB records, and executing Lambda functions.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对资源实例执行的操作。数据事件包括删除、创建或更新S3对象、DynamoDB记录和执行Lambda函数。
- en: Insights events
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 洞察事件
- en: AWS logs these events when it detects unusual activity on your account. They
    monitor write operations on the AWS API and use mathematical models to spot abnormal
    levels of operations and/or errors.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当AWS检测到您帐户上的异常活动时，AWS会记录这些事件。它们监视AWS API上的写操作，并使用数学模型来检测操作和/或错误的异常水平。
- en: Once you have created a trail, AWS will begin logging records to the S3 bucket
    and you will be able to view and analyze your audit logs in the Management Console.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 创建跟踪后，AWS将开始向S3存储桶记录日志，并且您可以在管理控制台中查看和分析您的审计日志。
- en: 'Practical Example: A CloudWatch Circuit Breaker'
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际示例：一个CloudWatch断路器
- en: In this chapter, we have explored some of the features available in AWS CloudWatch.
    We have looked at collecting logs, metrics, tracing, and sending custom metric
    data from your C# application to CloudWatch. We have also looked at monitoring
    dashboards and setting up alarms to trigger when a metric goes outside a predetermined
    threshold. Let’s tie all this together with an example that spans many of the
    concepts covered in this chapter. For this example, we will be implementing the
    circuit breaker pattern using serverless AWS components and CloudWatch.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经探讨了AWS CloudWatch中的一些可用功能。我们已经研究了从C#应用程序向CloudWatch收集日志、指标、跟踪和发送自定义指标数据。我们还研究了监控仪表板，并设置当指标超出预定阈值时触发警报的功能。让我们通过一个跨越本章涵盖的多个概念的示例来将所有这些联系起来。在此示例中，我们将使用无服务器AWS组件和CloudWatch实现熔断器模式。
- en: Note
  id: totrans-176
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The circuit breaker is a well-established architectural pattern for handling
    failures in one part of your application, introducing logic to fall back to a
    secondary behavior when a failure is detected. This has the benefit of preventing
    a failure from propagating to downstream components and allows you to maintain
    a certain level of service to your application users even in the event of one
    component failing. You can watch an animated example of how this pattern is implemented
    on [YouTube](https://youtu.be/e5pnfD0rudY).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器是一个处理应用程序某部分故障的成熟架构模式，引入逻辑来在检测到故障时回退到次要行为。这有助于防止故障传播到下游组件，并允许您即使在一个组件失败时也能维持一定级别的服务向应用程序用户提供。您可以观看一个关于如何实施这种模式的动画示例，链接在[YouTube](https://youtu.be/e5pnfD0rudY)。
- en: In order to implement the circuit breaker pattern on AWS, we will first need
    an application in which we might have a failure. For this example, we have a website
    that wants to display the latest currency exchange rate to all our visitors. The
    exchange rate, in this case from USD to GBP, will come from an external API that
    we will call every time somebody loads our web page. Exchange rates fluctuate
    as currencies are traded around the world, so by making this API call every time
    the page loads we can be sure we are showing our website visitors the most up-to-date
    rate. [Figure 7-12](#Figure-7-12) shows how we make this exchange-rate lookup
    call from our website. The call is proxied through an instance of API Gateway
    that we control and passed directly through to the third-party service we are
    using to retrieve the latest rate.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 AWS 上实施断路器模式，我们首先需要一个可能出现故障的应用程序。在此示例中，我们有一个网站希望向所有访问者显示最新的货币兑换率。在这种情况下，从
    USD 到 GBP 的汇率将来自一个外部 API，我们将每次有人加载我们的网页时调用该 API。由于货币在全球范围内交易，汇率会波动，因此通过每次页面加载时调用此
    API，我们可以确保向我们的网站访问者展示最新的汇率。[图 7-12](#Figure-7-12)展示了我们如何从网站进行这种汇率查询调用。该调用通过我们控制的
    API Gateway 实例代理，并直接传递到我们用于检索最新汇率的第三方服务。
- en: '![doac 0712](assets/doac_0712.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0712](assets/doac_0712.png)'
- en: Figure 7-12\. External API calls being proxied through API Gateway to our website
  id: totrans-180
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-12\. 外部 API 调用通过 API Gateway 代理到我们的网站
- en: 'The CloudFormation template to set up a simple API Gateway proxy to a third-party
    API like this would be:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个简单的 API Gateway 代理到第三方 API 的 CloudFormation 模板将是：
- en: '[PRE9]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: What Could Go Wrong?
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 会发生什么问题？
- en: Calling this third-party API every time a visitor loads our web page is great
    for displaying the most up-to-date value; however, we are now heavily dependent
    on the availability of an API we do not own or control. What happens if this third-party
    service goes down or begins to respond slowly? As it stands, the response time
    of our API call is directly proportional to the response time of the external
    API. If this external API begins responding incredibly slowly, so will our API
    gateway call, and our users will have to wait for their exchange rate to appear
    on the website. Perhaps they will even end up seeing a timeout error instead of
    the USD to GBP rate that they expect. So what can we do?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 每次访问者加载我们的网页时调用此第三方 API，可以很好地显示最新的值；但是，我们现在严重依赖于一个我们不拥有或控制的 API 的可用性。如果这个第三方服务崩溃或开始响应缓慢会发生什么？目前，我们
    API 调用的响应时间与外部 API 的响应时间成正比。如果这个外部 API 开始响应非常缓慢，我们的 API 网关调用也将如此，我们的用户将不得不等待他们期望的汇率出现在网站上。也许他们最终会看到一个超时错误，而不是他们预期的
    USD 到 GBP 汇率。那我们该怎么办呢？
- en: Using CloudWatch we can monitor the latency of this endpoint, and set up an
    alarm to trigger when the external API begins to respond slowly. Head over to
    the CloudWatch Management Console and create a new alarm for the *latency* metric
    on our API Gateway resource, as shown in [Figure 7-13](#Figure-7-13).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CloudWatch 我们可以监控此端点的延迟，并设置一个警报，在外部 API 开始响应缓慢时触发。转到 CloudWatch 管理控制台，并为我们
    API 网关资源上的*延迟*指标创建一个新警报，如[图 7-13](#Figure-7-13)所示。
- en: Warning
  id: totrans-186
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: You may need to enable “Detailed route metrics” in API Gateway to get the latency
    for each route as shown in [Figure 7-13](#Figure-7-13).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 API 网关中启用“详细路由指标”，以获取每个路由的延迟时间，如[图 7-13](#Figure-7-13)所示。
- en: '![doac 0713](assets/doac_0713.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0713](assets/doac_0713.png)'
- en: Figure 7-13\. Configuring a new alarm on the latency of our API Gateway resource
  id: totrans-189
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-13\. 配置我们 API 网关资源延迟的新警报
- en: For the notification action of our alarm, we will set up an SNS topic and link
    it to a Lambda function called `TriggerCircuitBreaker`. We will create this Lambda
    function next.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的警报通知动作，我们将设置一个 SNS 主题，并将其链接到名为 `TriggerCircuitBreaker` 的 Lambda 函数。接下来我们将创建这个
    Lambda 函数。
- en: Breaking the Circuit
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 断开电路
- en: Now we have a way to detect the external API’s latency increasing, we need to
    decide what to do to keep our application running. For our example website, we
    have made the business decision that in the event that the exchange rate lookup
    API is not responding quickly enough we will return a *cached* exchange rate from
    our distributed memory cache. Perhaps we have another Lambda function that runs
    on a schedule and saves the current exchange rate to this cache periodically.
    For our distributed cache we can use [Amazon ElastiCache](https://aws.amazon.com/elasticache),
    which allows us to use both Redis and Memcached, two extremely popular open source
    in-memory stores. In [Figure 7-14](#Figure-7-14), you can see we have configured
    our API Gateway with a second “fallback” integration that invokes a Lambda function
    to retrieve the most recent exchange rate from the cache.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一种方法来检测外部 API 的延迟增加，我们需要决定如何保持我们的应用程序运行。对于我们的示例网站，我们已经做出了业务决策，即如果汇率查找
    API 的响应不够快，我们将从我们的分布式内存缓存中返回一个 *缓存* 汇率。也许我们有另一个 Lambda 函数定期运行并将当前汇率保存到此缓存中。对于我们的分布式缓存，我们可以使用
    [Amazon ElastiCache](https://aws.amazon.com/elasticache)，它允许我们同时使用 Redis 和 Memcached，这两种极其流行的开源内存存储。在
    [图 7-14](#Figure-7-14) 中，您可以看到我们已经配置了我们的 API 网关，使用了第二个“备用”集成，该集成调用一个 Lambda 函数从缓存中检索最新的汇率。
- en: '![doac 0714](assets/doac_0714.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0714](assets/doac_0714.png)'
- en: Figure 7-14\. Additional AWS Lambda integration added into API Gateway as a
    fallback
  id: totrans-194
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-14\. 将额外的 AWS Lambda 集成添加到 API 网关作为备用
- en: Our circuit breaker could operate by detecting high latency on the third-party
    API and switching our API Gateway to use this fallback integration. This would
    not affect our website as the API calls from the frontend are still coming into
    the gateway, but instead of proxying those calls to our third-party service, we
    will be sending them to the Lambda function `GetCachedExchangeRate`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的断路器可以通过检测第三方 API 的高延迟并将我们的 API 网关切换到使用此备用集成来运行。这不会影响我们的网站，因为前端的 API 调用仍然进入网关，但我们不再将这些调用代理到我们的第三方服务，而是发送到
    Lambda 函数 `GetCachedExchangeRate`。
- en: 'Making this switch in API Gateway can be done from a simple C# Lambda function,
    using the `AmazonApiGatewayV2Client` from the NuGet package AWSSDK.ApiGatewayV2:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在 API 网关中进行这种切换可以通过一个简单的 C# Lambda 函数完成，使用 NuGet 包 AWSSDK.ApiGatewayV2 中的 `AmazonApiGatewayV2Client`：
- en: '[PRE10]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here we have hardcoded the IDs for our API Gateway instance, route, and integration;
    however, these could of course be read in from environment variables or looked
    up at runtime using methods on the `AmazonApiGatewayV2Client`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经为我们的 API 网关实例、路由和集成硬编码了 ID；然而，当然可以从环境变量中读取或者在运行时使用 `AmazonApiGatewayV2Client`
    的方法查找它们。
- en: Resetting the Tripped State
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重置触发状态
- en: What we have achieved here through switching the integration in API Gateway
    is we have provided our users with *some* information on the website. It may not
    be the latest exchange rate but it should be recent enough and, crucially, we
    have guarded against an unpredictably slow third-party API. The next thing to
    consider is how we reset our circuit breaker when the API is no longer experiencing
    high latency.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 API 网关中切换集成，我们已经为用户在网站上提供了一些信息。这可能不是最新的汇率，但应该足够新，关键是，我们已经防范了一个不可预测的慢第三方
    API。接下来要考虑的是，当 API 不再经历高延迟时，我们如何重置我们的断路器。
- en: 'The circuit breaker pattern offers a solution for resetting once the initial
    condition has been resolved, and that is by periodically testing our external
    API in what the pattern calls a “half open state.” We can create yet another Lambda
    function to do this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器模式提供了一种解决方案，一旦初始条件得到解决，就会定期测试我们的外部 API，这是通过“半开放状态”进行的。我们可以创建另一个 Lambda 函数来执行此操作：
- en: '[PRE11]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here we have a function that makes the API call to our third-party exchange
    rate API and measures the response time. This is then sent back to CloudWatch
    as a custom metric called “ExchangeRateProbeLatency.” We can then set up a second
    alarm to track this new metric using a *Lower than* threshold. In the alarm configuration
    window in CloudWatch, there is also a “Datapoints to alarm” setting that we can
    take advantage of. Setting this (shown in [Figure 7-15](#Figure-7-15)) will result
    in our alarm being triggered if 10 API calls to our probe fall below our maximum
    allowed latency.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个函数，它调用我们的第三方汇率 API 并测量响应时间。然后将其作为名为“ExchangeRateProbeLatency”的自定义指标发送回
    CloudWatch。然后，我们可以设置第二个警报来跟踪这个新的指标，使用*低于*阈值。在 CloudWatch 的警报配置窗口中，还有一个“数据点到警报”的设置，我们可以利用它。设置这个（在
    [图 7-15](#Figure-7-15) 中显示）将导致我们的警报在我们的探测 API 的 10 次调用中有超过允许的最大延迟时被触发。
- en: '![doac 0715](assets/doac_0715.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0715](assets/doac_0715.png)'
- en: Figure 7-15\. Datapoints to alarm configuration
  id: totrans-205
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-15\. 数据点到报警配置
- en: Finally, here is our entire example as a flow diagram in [Figure 7-16](#Figure-7-16).
    We are using an EventBridge rule to schedule calling the `ProbeExchangeRateEndpoint`
    Lambda function until the latency has reduced back down to an acceptable level.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 [图 7-16](#Figure-7-16) 中，这是我们整个示例作为流程图的呈现。我们正在使用 EventBridge 规则来调度调用 `ProbeExchangeRateEndpoint`
    Lambda 函数，直到延迟降低到可接受水平。
- en: '![doac 0716](assets/doac_0716.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![doac 0716](assets/doac_0716.png)'
- en: Figure 7-16\. Flowchart of our circuit breaker with probing and reset
  id: totrans-208
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-16\. 带有探测和重置的断路器流程图
- en: Conclusion
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: No system is architected or configured to perfection. Systems evolve over time
    and as the scale of your application changes you will need to make changes to
    the way your services talk to each other. This is especially true for growing
    systems that start small with only a handful of users, and grow, sometimes exponentially,
    to serve thousands of users all across the world. Architectural decisions that
    made sense when an application was small can end up hindering performance as adoption
    increases. You will also learn more about the usage patterns of your services
    as you scale as more users provide more detailed insight into how your application
    is used and where the bottlenecks will emerge.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 没有系统是完美设计或配置的。系统随时间演化，并且随着应用规模的变化，您将需要修改服务间通信的方式。对于从只有少数用户开始，有时以指数方式增长到全球服务数千用户的增长系统来说，这一点尤其重要。当应用程序规模小的时候做出的架构决策可能会在采用增加时阻碍性能。随着用户规模的扩展，您还将更多地了解服务的使用模式，因为更多的用户提供了关于应用程序使用情况和瓶颈出现位置的详细见解。
- en: It is therefore vitally important to have logging, monitoring, and instrumentation
    in place so you can observe these changes happening and respond to them quickly,
    efficiently, and with the greatest amount of useful data at your disposal. For
    operations engineers, site reliability engineers, DevOps, and security engineers,
    AWS CloudWatch is an extremely powerful set of tools that can give you the data
    you need if some time is invested in getting the most out of it.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，非常重要的是要有日志记录、监控和仪表化，以便您可以观察这些变化并迅速、高效地响应，并且在您的处置中拥有最大量的有用数据。对于运维工程师、站点可靠性工程师、DevOps
    和安全工程师来说，AWS CloudWatch 是一组非常强大的工具，可以为您提供所需的数据，如果投入足够的时间来充分利用它。
- en: For the final chapter of this book, we are going to be jumping back into our
    application code and exploring more deeply the AWS SDK for .NET. We will also
    be looking at some of the tooling for Visual Studio that can make interacting
    with AWS feel much more natural and integrated with your development workflow.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书的最后一章，我们将回到应用程序代码中，深入探讨 AWS SDK for .NET。我们还将查看一些能够使与 AWS 交互更加自然和与开发工作流程更加集成的
    Visual Studio 工具。
- en: Critical Thinking Discussion Questions
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 批判性思维讨论问题
- en: Why would an engineering manager say logging, monitoring, and instrumentation
    are essential to software engineering?
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工程经理为什么会说日志记录、监控和仪表化对软件工程至关重要？
- en: What is another way to describe the four pillars of AWS CloudWatch?
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述 AWS CloudWatch 的四大支柱的另一种方式是什么？
- en: What are the three of four most important metrics you should look at when building
    and deploying AWS Lambda services?
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建和部署 AWS Lambda 服务时，您应该关注的三个或四个最重要的度量指标是什么？
- en: What real-world problems does a service like X-Ray solve?
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似 X-Ray 这样的服务解决了哪些现实世界的问题？
- en: How could security auditing using AWS CloudTrail help prevent a ransomware attack
    at your company?
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 AWS CloudTrail 进行安全审计以帮助防止公司遭受勒索软件攻击？
- en: Exercises
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Build a C# Console App that queries AWS CloudTrail.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个 C# 控制台应用程序，查询 AWS CloudTrail。
- en: Write custom CloudWatch logging into an AWS CodeBuild job that builds a .NET
    project.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将自定义 CloudWatch 日志写入构建 .NET 项目的 AWS CodeBuild 作业中。
- en: Log the incoming API Gateway `POST` requests for a .NET web service to AWS CloudTrail.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录进入 API Gateway 的 `POST` 请求到一个 .NET Web 服务的 AWS CloudTrail。
- en: Log the incoming Elastic Beanstalk `POST` requests for a .NET web service to
    AWS CloudTrail.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录进入 Elastic Beanstalk 的 `POST` 请求到一个 .NET Web 服务的 AWS CloudTrail。
- en: Build a C# Console App that finds anomalies in AWS CloudTrail events.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个 C# 控制台应用程序，用于查找 AWS CloudTrail 事件中的异常情况。
- en: ^([1](ch07.xhtml#idm45599651192176-marker)) The weight of the riders can greatly
    affect the speed of a roller coaster car under gravity. If you see four grown
    adults in a kiddie roller coaster car it might look funny, but the increased momentum
    that car will have coming back into the station can really test the strength of
    the braking system.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch07.xhtml#idm45599651192176-marker)) 乘客的体重会极大地影响重力下过山车车辆的速度。如果你看到四个成年人坐在儿童过山车的车里可能会看起来很有趣，但这辆车进站时增加的动量确实可以测试制动系统的强度。
- en: ^([2](ch07.xhtml#idm45599651136560-marker)) Despite being called “AWSLambdaBasicExecutionRole,”
    this is actually not a role but a *policy*—a permissions set that can be applied
    to a role to grant or deny access to certain resources.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch07.xhtml#idm45599651136560-marker)) 尽管被称为 “AWSLambdaBasicExecutionRole”，但实际上这不是一个角色，而是一个
    *策略* —— 一组权限设置，可以应用于角色以授予或拒绝对某些资源的访问。
- en: ^([3](ch07.xhtml#idm45599651054496-marker)) The IAsyncDisposable interface was
    introduced in C# 8.0 and allows us to call asynchronous code in a `DisposeAsync()`
    method by adding “await” before our “using” statement.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch07.xhtml#idm45599651054496-marker)) IAsyncDisposable 接口是在 C# 8.0 中引入的，允许我们通过在
    “using” 语句之前添加 “await” 来调用异步代码中的 `DisposeAsync()` 方法。
- en: ^([4](ch07.xhtml#idm45599650581152-marker)) AWSSDK.CloudWatch and AWSSDK.CloudWatchLogs
    are two different packages with different clients; you will need both of these
    packages if you need to publish custom log messages *and* custom metric data points
    to CloudWatch.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch07.xhtml#idm45599650581152-marker)) AWSSDK.CloudWatch 和 AWSSDK.CloudWatchLogs
    是两个不同的包，具有不同的客户端；如果您需要向 CloudWatch 发布自定义日志消息 *和* 自定义指标数据点，则需要这两个包。
- en: ^([5](ch07.xhtml#idm45599650100960-marker)) Service Map was previously accessed
    through a product AWS calls “Service Lens,” so you may find it referenced as a
    part of that in documentation online.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch07.xhtml#idm45599650100960-marker)) Service Map 以前是通过 AWS 称为 “Service
    Lens” 的产品访问的，因此您可能会在在线文档中找到它作为该产品的一部分的引用。
- en: ^([6](ch07.xhtml#idm45599650082128-marker)) You can view up to 500 hosts in
    one view using the Resource Health window.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch07.xhtml#idm45599650082128-marker)) 您可以使用资源健康窗口在一个视图中查看多达 500 个主机。
- en: ^([7](ch07.xhtml#idm45599650080256-marker)) The term “canary” has a rather dark
    past. In the days before electronic gas detectors, and indeed also before animal
    welfare rights, canary birds would be taken into coal mines in a cage and hung
    up in the area being worked in. If the bird succumbed to toxic fumes down in the
    mine, the workers would notice the expiry of the poor bird and take it as a sign
    to raise the alarm and evacuate.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch07.xhtml#idm45599650080256-marker)) “Canary” 这个术语有着相当阴暗的历史。在电子气体探测器出现之前的日子里，以及动物福利权利出现之前，金丝雀会被放进煤矿的笼子里挂在正在作业的区域。如果这只鸟在矿井中受到有毒气体的影响而死亡，工人们会注意到可怜鸟的死亡，并将其视为发出警报并撤离的信号。
