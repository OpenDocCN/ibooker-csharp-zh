- en: Chapter 2\. What Can We Do Already?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 什么我们已经可以做了？
- en: Some of the code and concepts discussed in this chapter may seem trivial to
    some, but bear with me. I don’t want to introduce too much too soon. More experienced
    developers might like to skip ahead to Chapter 3, in which I talk about the more
    recent developments in C# for Functional progammers, or Chapter 4 where I demonstrate
    some novel ways to use features you might already be familiar with to achive some
    Functional features.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的一些代码和概念可能对某些人来说显得微不足道，但请耐心等待。更有经验的开发人员可能想跳到第3章，我在其中讨论C#为函数式程序员提供的最新发展，或者跳到第4章，我在其中展示了一些使用你可能已经熟悉的特性来实现一些函数式特性的新颖方法。
- en: In this chapter, I’m going to look at the Functional Programming features that
    are possible in just about every C# codebase in use in production today. I’m going
    to assume at least .NET Framework 3.5, and with some minor alterations, all of
    the code samples provided in this chapter will work in that environment. Even
    if you work in a more recent version of .NET, but are unfamiliar with Functional
    Programming, I still recommend reading this chapter, as it should give you a decent
    starting point in programming with the Functional Paradigm.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将探讨几乎在今天所有使用中的C#代码库中可能出现的函数式编程特性。我将假设至少.NET Framework 3.5，并且通过一些微小的修改，本章提供的所有代码示例都将在该环境中工作。即使你在更新版本的.NET中工作，但对函数式编程不熟悉，我仍然建议阅读本章，因为它应该为你在函数式编程中提供一个很好的起点。
- en: Those of you familiar already with Functional code, and just want to see what’s
    available in the latest versions of .NET, it might be best to skip ahead to the
    next chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 那些对函数式代码已经很熟悉，只想看看在最新版本的.NET中有什么可用的人，最好跳到下一章。
- en: Getting Started
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: Functional Programming is easy, really it is! Despite what many people think,
    it’s easier to learn than Object-Oriented progrmanning. There are fewer concepts
    to learn, and actually less to get your head around.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程真的很简单！尽管许多人认为它比面向对象编程难学，但实际上学起来更简单。需要学习的概念更少，而且你实际上要考虑的东西也更少。
- en: If you don’t believe me, try explaining Polymorphism to a non-technical member
    of your family! Those of us that are comfortable with Object Orientation have
    often been doing it so long that we’ve forgotten how hard it may have been to
    get our heads around it at the beginning.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不相信我，试着向你家庭中的非技术人员解释多态性！那些对面向对象编程感到舒适的人往往已经做了很长时间，以至于可能已经忘记了刚开始时有多难理解。
- en: Functional programming isn’t hard to understand at all, just different. I’ve
    spoken to plenty of students coming out of university that embrace it with enthusiasm.
    So, if *they* can manage it…​
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程并不难理解，只是不同而已。我曾经与许多刚从大学毕业的学生交流过，他们对此充满热情。所以，如果*他们*可以做到...​
- en: The myth does seem to persist though, that to get into Functional Programming,
    there’s a whole load of stuff that needs learning first. What if I told you though,
    that if you’ve been doing C# for any length of time, you’ve already most likely
    been writing Functional code for a while? Let me show you what I mean…​
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，关于学习函数式编程需要学习很多东西的传言似乎仍在流传。但如果我告诉你，如果你已经用C#写了一段时间，你很可能已经在写函数式代码了呢？让我告诉你我的看法...​
- en: Your First Functional Code
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的第一个函数式代码
- en: Before we start with some functional code, let’s look at a bit of non-functional.
    A style you most likely learned somewhere very near the beginning of your C# career.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写一些功能性代码之前，让我们先看看一些非功能性的内容。这是你在你的C#职业生涯开始不久就可能学到的一种风格。
- en: A Non-Functional Film Query
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个非功能性的电影查询
- en: In my quick, made-up example, I’m getting a list of all films from my imaginary
    data store and creating a new list, copied from the first, but only those items
    in the Action genre^([1](ch02.html#idm45400885975216))
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我快速编造的例子中，我从我的想象数据存储中获取了所有电影的列表，并创建了一个新的列表，从第一个列表复制过来，但只包含动作类型的项目^([1](ch02.html#idm45400885975216))。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What’s wrong with this code? At the very least, it’s not very elegant. That’s
    a lot we’ve written to do something fairly simple.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有什么问题？至少，它不够优雅。我们写了很多代码来完成一些相对简单的事情。
- en: We’ve also instantiated a new object that’s going to stay in scope for as long
    as this function is running. If there’s nothing more to the whole function than
    this, then there’s not much to worry about. But, what if this were just a short
    excerpt from a very long function? In that instance, the allFilms and actionFilms
    variables would both remain in scope, and thus in memory all that time, even if
    they aren’t in use.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个新对象，只要这个函数在运行，它就会保持在作用域内。如果整个函数只是这么一小段代码，那就没什么好担心的了。但是，如果这只是一个非常长的函数的一部分呢？在那种情况下，allFilms和actionFilms变量都会保持在作用域内，因此在内存中占据位置，即使它们没有被使用。
- en: There may not necessarily be copies of all of the data held within the item
    that’s being replicated, depending on whether it’s a class, a struct or whatever
    else. At the very least though, there’s a duplicate set of references being held
    unnecessarily in memory for as long as both items are in scope. That’s still more
    memory than we strictly need to hold.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 可能并不一定有所有数据的副本保留在正在复制的项目中，这取决于它是类、结构体还是其他类型。但至少，对于这两个项目在作用域内的时间，会不必要地在内存中保留一组重复的引用。这仍然比我们严格需要保留的内存更多。
- en: We’re also forcing the order of operations. We’ve specified when to loop, when
    to add, etc. Both where and when each step should be carried out. If there were
    any intermediate steps in the data transformations to be carried out, we’d be
    specifying them too, and holding them in yet more potentially long-life variables.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还强制执行操作的顺序。我们指定了循环的时机，添加的时机等等。每个步骤的执行位置和时间都已经明确。如果数据转换中有任何中间步骤需要执行，我们也会指定它们，并将它们保存在更长寿的变量中。
- en: 'I could solve a few problems with a `yield` return like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以像这样用`yield`返回解决一些问题：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This hasn’t done more than shave a few lines off, however.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，这并没有减少多少行代码。
- en: What if there were a more optimal order of operations than the one we’ve decided
    on? What if a later bit of code actually meant that we don’t end up returning
    the contents of actionFilms? We’d have done the work unnecessarily.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有比我们已经决定的更优化的操作顺序呢？如果稍后的代码实际上意味着我们最终并不返回actionFilms的内容呢？我们会不必要地做了这些工作。
- en: This is the eternal problem of procedural code. Everything has to be spelled
    out. One of our major aims with Functional Programming is to move away from all
    that. Stop being so specific about every little thing. Relax a little, and embrace
    declaritive code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是过程式代码的永恒问题。一切都必须一一列举。我们在函数式编程中的主要目标之一是远离这一点。不要对每件小事都如此具体。放松一点，接受声明性的代码。
- en: A Functional Film Query
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个函数式的电影查询
- en: So, what would that code sample above look like written in a Functional style?
    I’d hope many of you might already guess at how you would re-write it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，上面的代码样本如果按照函数式风格编写会是什么样子？我希望你们中的许多人已经猜到了如何重新编写它。
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If anyone at this point is saying “isn’t that just LINQ?”, then yes. Yes, it
    is. I’ll let you all in on a little secret - LINQ follows the Functional paradigm.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此时有人说“这不就是LINQ吗？”，是的。没错。我会告诉你们一个小秘密 - LINQ遵循函数式范式。
- en: Just quickly, for anyone that’s not yet familiar with the awesomeness of LINQ.
    It’s a library that’s been part of C# since the early days, and provides a rich
    set of functions for filtering, altering and extending collections of data. Functions
    like `Select`, `Where` and `All` are from LINQ and commonly used around the world.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 只是快速地，对于还不熟悉LINQ强大之处的人来说。这是一个自C#早期就存在的库，为数据集合提供了丰富的过滤、修改和扩展功能。像`Select`、`Where`和`All`这样的函数来自LINQ，在全球范围内广泛使用。
- en: Think back for a moment to the list of features of Functional Programming, and
    see how many LINQ implements…​
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下函数式编程特性的列表，看看LINQ实现了多少……
- en: Higher-order Functions - The lambda expressions passed to LINQ functions are
    all functions, being passed in as parameter variables.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数 - 传递给LINQ函数的Lambda表达式都是函数，作为参数变量传入。
- en: Immutability - LINQ doesn’t change the source array, it returns a new `Enumerable`
    based on the old one.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不变性 - LINQ不会改变源数组，它返回基于旧数组的新的`Enumerable`。
- en: Expressions instead of Statements - We’ve eliminated the use of a `ForEach`
    and an `If`
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式而非语句 - 我们已经消除了`ForEach`和`If`的使用。
- en: Referential Transparency - The Lambda Expression I’ve written here does actually
    conform to Referential Transparency (I.e. “no side effects”), though there’s nothing
    enforcing that. I could easily have referenced a string variable outside the Lambda.
    By requiring that the source data be passed in as a parameter, I’m also making
    it easier to test without requiring the creation & setup of a Mock of some kind
    to represent the data store connection. Everything the function needs is provided
    by its own parameters.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用透明性 - 我在这里写的 Lambda 表达式实际上确实符合引用透明性（即“无副作用”），尽管没有强制执行。我很容易可以引用 Lambda 外部的字符串变量。通过要求将源数据作为参数传入，我还使得测试更加容易，而不需要创建和设置某种
    Mock 来代表数据存储连接。函数所需的一切都由其自己的参数提供。
- en: The iteration could well be done by recursion too, for all I know, but I have
    no idea what the source code of the Where function looks like. In the absence
    of evidence to the contrary, I’m just going to go on believing that it does.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代也可以通过递归完成，至少我不知道 Where 函数的源代码是什么样的。在没有相反证据的情况下，我只是相信它这样做。
- en: This tiny little one-line code sample is a perfect example of the Functional
    approach in many ways. We’re passing around functions to perform operations against
    a collection of data, creating a new collection based on the old one.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个微小的一行代码示例在很多方面是函数式方法的完美例子。我们传递函数来对一组数据执行操作，根据旧数据创建新的数据集。
- en: What we’ve ended up with by following the Functional paradigm is something more
    concise, easier to read and therefore far easier to maintain.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循函数式范式，我们最终得到了更简洁、更易读，因此更易于维护的东西。
- en: Results-Oriented Programming
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结果导向编程
- en: A common feature of Functional code is that it focuses much more heavily on
    the end result, rather than on the process of getting there. An entirely Procedural
    method of building a complex object would be to instantiate it empty at the beginning
    of the code block, then fill in each property as we go along.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式代码的一个共同特征是，它更加专注于最终结果，而不是达到结果的过程。构建复杂对象的完全过程化方法是在代码块开始时将其空实例化，然后在过程中逐步填充每个属性。
- en: 'Something like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The problem with this approach is that it’s very open to abuse. This silly little
    imaginary codeblock I’ve created here is short and easy to maintain. What often
    happens with production code however, is that the code can end up becoming incredibly
    long, with multiple data sources that all have to be pre-processed, joined, re-processed,
    etc. You can end up with long blocks of If-statements nested in If-statements,
    to the point that the code starts resembling the shape of a Family Tree.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的问题在于，它很容易被滥用。我在这里创建的这个虚构的小代码块短小且易于维护。然而，在实际的生产代码中经常发生的情况是，代码可能变得非常长，有多个数据源需要预处理、连接、重新处理等。你可能会看到长长的嵌套的
    If 语句块，使得代码开始类似家谱的形状。
- en: For each nested If-statement, the complexity effectively doubles. This is especially
    true if there are multiple return statements scattered around the codebase. The
    risk increases of inadvertently ending up with a Null or some other unexpected
    value if the increasingtly complex codebase isn’t thought through in detail. Functional
    Programming discourages structures like this, and isn’t prone to this level of
    complexity, or of the potential unexpected consequences.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个嵌套的 If 语句，复杂性实际上是成倍增加的。如果代码库中散布着多个返回语句，情况尤其如此。如果不仔细考虑逐渐复杂的代码库，很容易出现意外结束为
    Null 或其他意外值的风险。函数式编程不鼓励这样的结构，并且不容易出现这种复杂性或潜在的意外后果。
- en: In our code sample above, we have PropertyC and PropertyD defined in 2 different
    places. It’s not too hard to work with here, but I’ve seen examples where the
    same property is defined in around half a dozen places across multiple classes
    and sub-classes^([2](ch02.html#idm45400886839824)).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们上面的代码示例中，我们在两个不同的地方定义了 PropertyC 和 PropertyD。在这里处理起来并不太难，但我见过一些例子，其中同一个属性在多个类和子类中定义了大约半打地方^([2](ch02.html#idm45400886839824))。
- en: I don’t know whether you’ve ever had to work with code like this? It’s happened
    to me an awful lot.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道你是否曾经不得不处理过这样的代码？我却经历过很多次。
- en: These sorts of large, unweildy codebases only ever get harder to work with over
    time. With each addition, the actual speed at which the developers can do the
    work goes down, and the business can end up getting frustrated because they don’t
    understand why their “simple” update is taking so long.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这类庞大而笨重的代码库随着时间的推移只会变得更难处理。随着每次增加，开发人员实际完成工作的速度会下降，业务可能会感到沮丧，因为他们不明白为什么他们的“简单”更新会花费如此之长时间。
- en: Functional code should ideally be written into small, concise blocks, focusing
    entirely on the end product. The expressions it prefers are modelled on mathematical
    working, so you really want to write it like small formulas, each precisely defining
    a value and all of the variables that make it up. There shouldn’t be any hunting
    up and down the codebase to work out where a value comes from.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式代码理想情况下应该写成小而简洁的块，完全专注于最终产品。它偏好的表达式是基于数学工作的，所以你真的希望像小公式一样写，精确地定义一个值及其所有组成变量。不应该在代码库中上下搜索以找出值的来源。
- en: 'Something like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 类似这样的东西：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: I know I’m now repeating the AlternateTuesday flag, but it means that all of
    the variables that determine a returned property are defined in a single place.
    It makes it much simpler to work with in the future.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道我现在在重复交替星期二标志，但这意味着所有决定返回属性的变量都在一个地方定义。这样将来处理起来会简单得多。
- en: In the event that a property is so complicated that it will either need multiple
    lines of code, or a series of Linq operations that takes up a lot of space, then
    I’d create a break-out function to contain that complex logic. I’d still have
    my central, result-based return at the heart of it all, though.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个属性非常复杂，需要多行代码，或者一系列占用大量空间的 Linq 操作，那么我会创建一个独立的函数来包含这些复杂逻辑。尽管如此，我仍然会保留中心的、基于结果的返回在所有代码的核心位置。
- en: A few words about Enumerables
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于枚举的几句话
- en: I sometimes think Enumerables are one of the most under-used and least understood
    features of C#. An Enumerable is the most abstract representation of a collection
    of data - so abstract that it doesn’t contain any data itself, it’s actually just
    a description held in memory of how to go about getting the data. An Enumerable
    doesn’t even know how many items there are available until it iterates through
    everything - all it knows is where the current item is, and how to iterate to
    the next.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我有时候觉得枚举是 C# 中最被低估和最不被理解的功能之一。一个枚举是数据集合的最抽象表示形式 - 如此抽象，以至于它本身不包含任何数据，实际上只是一个在内存中描述如何获取数据的说明。一个枚举甚至不知道有多少个可用项，直到遍历了所有内容
    - 它只知道当前项在哪里，以及如何迭代到下一个。
- en: This is called *Lazy Evaluation* or *deferred Execution*. Being lazy is a good
    thing in development. Don’t let anyone tell you otherwise^([3](ch02.html#idm45400886206224)).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为 *惰性求值* 或 *延迟执行*。在开发中，偷懒是件好事情。不要让任何人告诉你相反^([3](ch02.html#idm45400886206224))。
- en: In fact, you can even write your own entire customised behaviour for an Enumerable
    if you wanted. Under the surface, there’s an object called an Enumerator. Interacting
    with that can be used to either get the current item, or iterate on to the next.
    You can’t use it to determine the length of the list, and the iteration only works
    in a single direction.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果你想的话，甚至可以为枚举编写自定义行为。在表面下，有一个叫做 Enumerator 的对象。与其交互可以用来获取当前项，或者迭代到下一个。你不能用它确定列表的长度，迭代只能单向进行。
- en: 'Have a look at this code sample:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这段代码示例：
- en: 'First a set of simple logging functions that pop a message in a List of strings:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是一组简单的日志记录函数，它们将消息放入一个字符串列表中：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Then a bit of code that calls each of those “DoSomething” functions in turn
    with different data.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是一小段代码，依次调用每个“DoSomething”函数，使用不同的数据。
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What do you think the order of operations is? You might think that the runtime
    would take the original input array, apply DoSomethingOne to all 3 elements to
    create a second array, then again with all three elements into DoSomethingTwo,
    and so on.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为操作的顺序是什么？你可能会认为运行时会拿到原始输入数组，对所有 3 个元素应用 DoSomethingOne 来创建第二个数组，然后再对所有三个元素进行
    DoSomethingTwo，依此类推。
- en: 'If I were to examine the content of that List of strings, I’d find something
    like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我要检查那个字符串列表的内容，我会找到这样的东西：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It’s almost the exact same as you might get if you were running this through
    a `For`/`ForEach` loop, but we’ve effectively handed over control of the order
    of operations to the runtime. We’re not concerned with the nitty-gritty of temporary
    holding variables, what goes where and when. Instead we’re just describing the
    operations we want, and expecting a single answer back at the end.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，它几乎与通过`For`/`ForEach`循环运行的效果相同，但我们已经有效地将操作顺序控制权交给了运行时。我们不关心临时变量的琐碎细节，不关心什么时候把什么放在哪里。相反，我们只是描述我们想要的操作，并期望在最后得到一个单一的答案。
- en: It might not always look exactly like that, it depends on what the code that
    calls it looks like. But the intent always remains, that Enumerables only actually
    produce their data at the precise moment it’s needed. It doesn’t matter where
    they’re defined, it’s when they’re *used* that makes a difference.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能不总是看起来完全一样，这取决于调用它的代码是什么样的。但意图始终保持不变，即可枚举对象只在实际需要数据时才会产生数据。它们的定义位置并不重要，关键是它们何时被*使用*会有所不同。
- en: Using Enumerables instead of solid arrays, we’ve actually managed to implement
    some of the behaviors we need to write Declarative code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用可枚举而不是固定数组，我们实际上已经成功实现了一些需要编写声明性代码的行为。
- en: 'Incredibly, the log file I wrote above would still look the same if I were
    to re-write the code like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 令人难以置信的是，如果我像这样重写代码，我上面写的日志文件仍然会看起来一样：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: temp1, temp2 and finalAnswer are all Enumerables, and none of them will contain
    any data until iterated.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: temp1、temp2和finalAnswer都是可枚举的，除非被迭代，否则它们都不包含任何数据。
- en: Here’s an experiment for you to try. Write some code like this sample. Don’t
    copy it exactly, maybe something simpler like a series of selects amending an
    integer value somehow. Put a break point in and move the operation pointer on
    until final answer has been passed, then hover over finalAnswer in Visual Studio.
    What you’ll most likely find is that it can’t display any data to you, even though
    the line has been passed. That’s beause it hasn’t actually performed any of the
    operations yet.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个你可以尝试的实验。写一些类似这个示例的代码。不要完全复制，可能简单一些，比如一系列选择操作修改整数值。在Visual Studio中设置一个断点，移动操作指针直到finalAnswer被传递，然后悬停在finalAnswer上。你很可能会发现，即使已经通过了这一行，它也无法向你显示任何数据。因为它实际上还没有执行任何操作。
- en: 'Things would change if I did something like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 'Things would change if I did something like this:'
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Because I’m specifically now calling `ToArray()` to force an enumeration of
    each intermediate step, then we really will call DoSomethingOne for each item
    in input before moving onto the next stop.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我现在明确调用`ToArray()`来强制执行每个中间步骤的枚举，那么我们确实会在移动到下一个停止之前为输入中的每个项目调用DoSomethingOne。
- en: 'The log file would look something like this now:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在日志文件看起来是这样的：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For this reason, I nearly always advocate for waiting as long as possible before
    using `ToArray()` or `ToList()` ^([4](ch02.html#idm45400883250816)), because this
    way we can leave the operations unperformed for as long as possible. And potentially
    even never performed if later logic prevents the enumeration from occurring at
    all.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我几乎总是建议在使用`ToArray()`或`ToList()` ^([4](ch02.html#idm45400883250816))之前尽可能等待，因为这样我们可以尽可能地保持操作未执行。如果后续逻辑完全阻止枚举操作发生，甚至可能根本不执行。
- en: There are some exceptions. Either for performance, or for avoiding multiple
    iterations. While the Enumerable remains un-enumerated it doesn’t have any data,
    but the operation itself remains in memory. If you pile too many of them on top
    of each other - especially if you start performing recursive operations, then
    you might find that you fill up far too much memory and performance takes a hit,
    and possibly even end up with a stack overflow.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况例外。要么是为了性能，要么是为了避免多次迭代。当Enumerable保持未枚举状态时，它没有任何数据，但操作本身仍然保留在内存中。如果你将过多的这些操作叠加在一起
    - 特别是如果开始执行递归操作，那么你可能会发现内存消耗过大，性能受到影响，甚至可能导致堆栈溢出。
- en: Prefer Expressions to Statements
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更倾向于使用表达式而不是语句。
- en: In the rest of this chapter, I’m going to give more examples of how Linq can
    be used more effectively to avoid the need to use statements like If, Where, For,
    etc. or to mutate state (i.e. change the value of a variable).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我将提供更多例子，展示如何更有效地使用Linq，避免使用诸如If、Where、For等语句或改变状态（即改变变量的值）的需要。
- en: There will be cases that aren’t possible, or aren’t ideal. But, that’s what
    the rest of this book is for.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 会有一些不可能或不理想的情况。但这正是本书其余部分要解决的问题。
- en: The Humble Select
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谦卑的选择
- en: If you’ve read this far in the book, you’re most likely aware of Select statements,
    and how to use them. There are a few features though, that most people I speak
    to don’t seem to be aware of, and they’re all things that can be used to make
    our code a little more functional.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经读到了本书的这一部分，你很可能已经意识到了 Select 语句以及如何使用它们。不过，大多数我谈话的人似乎并不知道一些功能，它们都是可以用来使我们的代码更加函数式的东西。
- en: The first thing was something I’ve already shown in the previous section - you
    can chain them. Either as a series of Select function calls - literally one after
    the other, or in a single code line; or else you can store the results of each
    Select in a different local variable. Functionally these two approaches are identical.
    It doesn’t even matter if you call ToArray after each one. So long as you don’t
    modify any resulting arrays or the object contained within them, you’re following
    the Functional paradigm.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件事情是我在前一节已经展示过的 - 你可以将它们链接起来。可以作为一系列的 Select 函数调用 - 一个接一个地，或者在一行代码中；或者你可以将每个
    Select 的结果存储在不同的本地变量中。从功能上讲，这两种方法是相同的。甚至在每次调用 ToArray 之后都不重要。只要你不修改任何结果数组或其中包含的对象，你就遵循了函数式范式。
- en: The important thing is to get away from is the Imperative practice of defining
    a List, looping through the source objects with a ForEach and then adding each
    new item to the List. This is long-winded, harder to read, and honestly quite
    tedious. Why do things the hard way? Just use a nice, simple Select statement.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要摆脱的是命令式的做法，即定义一个 List，通过 ForEach 循环遍历源对象，然后将每个新项目添加到 List 中。这样做冗长，阅读起来更困难，老实说相当乏味。为什么要走弯路呢？只需使用一个漂亮简单的
    Select 语句。
- en: Passing working values via tuples
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过元组传递工作值
- en: Tuples were introduced in C#7\. Nuget packages do exist to allow some of the
    older versions of C# to use them too. They’re basically a way to throw together
    a quick-and-dirty collection of properties, without having to create and maintain
    a class.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是在 C#7 中引入的。Nuget 包确实存在，允许一些较旧版本的 C# 使用它们。它们基本上是一种快速而肮脏地收集属性的方式，而无需创建和维护一个类。
- en: If you’ve got a few properties you want to hold onto for a minute in one place,
    then dispose of immediately, Tuples are great for that.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一些属性想要在一个地方保留一会儿，然后立即处理掉，元组对于这个很棒。
- en: If you have multiple objects you want to pass between Selects, or multiple items
    you want to pass in or out of one, then you can use a Tuple.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有多个对象想要在 Select 之间传递，或者想要在一个 Select 中传入或传出多个项目，那么你可以使用元组。
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In my example, above, I use a Tuple to pair up data from two look-up functions
    for each given film Id, meaning I can run a subsequent Select to simplify the
    pair of objects into a single return value.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的示例中，我使用一个元组来配对每个给定电影 Id 的两个查找函数的数据，这意味着我可以运行一个后续的 Select 来简化这对对象为一个单一的返回值。
- en: Iterator value is required
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 需要迭代器值
- en: 'Som what if you’re Select-ing an Enumerable into a new form, and you need the
    iterator as part of the transformation? Something like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在将一个 Enumerable 选择成一个新形式，而且你需要迭代器作为转换的一部分，该怎么办呢？
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can use a feature of Select statements that surprisingly few people know
    about - that it has an override that allows us access to the iterator as part
    of the Select. All you have to do is provide a Lambda expression with 2 parameters,
    the second being an integer which represents the index position of the current
    item.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Select 语句的一个令人惊讶的少有人知道的特性 - 它有一个重载，允许我们访问迭代器作为 Select 的一部分。你所要做的就是提供一个带有
    2 个参数的 Lambda 表达式，第二个参数是一个整数，表示当前项目的索引位置。
- en: 'This is how our functional version of the code looks:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们代码的函数式版本的样子：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using these techniques, there’s nearly no circumstance that could exist where
    you need to use `ForEach` loop with a List. Thanks to C#’s support for the Functional
    paradigm, there are nearly always Declaritive methods available to solve problems.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些技巧，几乎不存在需要在 List 上使用 `ForEach` 循环的情况。由于 C# 对函数式范式的支持，几乎总是有声明性方法可用来解决问题。
- en: The two different methods of getting the “i” index position variable are a great
    example of Imperative vs Delarative code. The Imperative, Object-Oriented method
    has the developer manually creating a variable to hold the value of i, and also
    explicitly set the place for the variable to be incremented. The declaritive code
    isn’t concerned with where the variable is defined, or in how each index value
    is determined.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 获取“i”索引位置变量的两种不同方法是命令式与声明式代码的一个很好的例子。命令式、面向对象的方法是开发者手动创建一个变量来保存i的值，并显式设置变量递增的位置。声明式代码不关心变量的定义位置，也不关心每个索引值是如何确定的。
- en: N.b - Notice that I used `string.Join` to link the strings together. This is
    not only another one of those hidden gems of the C# language, but it’s also an
    example of Aggregation, that is - converting a list of things into a single thing.
    That’s what we’ll walk through in the next few sections.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 - 我使用了`string.Join`将字符串链接在一起。这不仅是C#语言中的另一个隐藏宝石，而且也是聚合的一个例子，即将一组东西转换为单一的东西。我们将在接下来的几节中详细介绍。
- en: No Starting Array
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 没有起始数组
- en: The last trick for getting the value of i for each iteration is great if there’s
    an array - or collection of some other kind - available in the first place. What
    if there isn’t an array? What if you need to arbitrarily iterate for a set number
    of times?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每次迭代获取i值的最后一个技巧非常适用于首先有一个数组 - 或者其他某种集合 - 的情况。如果没有数组呢？如果需要任意迭代一定次数呢？
- en: These are the situations - somewhat rare - where you need a good, old-fashioned
    `For` loop instead of a `ForEach`. How do you create an array from nothing?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这些情况 - 有点罕见 - 你需要一个老式的`For`循环而不是`ForEach`。如何从无中创建一个数组呢？
- en: Your two best friends in this case are two static methods - `Enumerable.Range`
    and `Enumerable.Repeat`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你的两个最好的朋友是两个静态方法 - `Enumerable.Range` 和 `Enumerable.Repeat`。
- en: Range creates an array from a starting integer value, and requires you to tell
    it how many elements the array you want should have. It then creates an array
    of integers based on those specifications.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Range从一个起始整数值创建一个数组，并要求你告诉它数组应该有多少元素。然后根据这些规格创建一个整数数组。
- en: 'For example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Having whipped up an array, we can then apply LINQ operations to get our final
    result. Let’s imagine I was preparing a description of the 9 times table for one
    of my daughters^([5](ch02.html#idm45400882823232)).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 制作好一个数组后，我们可以应用LINQ操作来得到我们的最终结果。让我们想象我正在为我女儿们准备九乘表的描述^([5](ch02.html#idm45400882823232))。
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here’s another example for you, what if I wanted to get all of the values from
    a grid of some kind, where an x and y value are required to get each value. I’ll
    imagine there’s a grid repository of some kind that I can use to get values.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 再举一个例子，如果我想从某种类型的网格中获取所有值，其中需要x和y值来获取每个值。我想象有一个网格存储库，我可以用来获取值。
- en: 'Imagining that the grid is a 5x5, this is how I’d get every value:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下网格是一个5x5的，这是我如何获得每一个值的方式：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The first line here is generating an array of integers with the values `[1,
    2, 3, 4, 5]`. I then use another `Select` to convert each of these integers into
    another array using another call to `Enumerable.Range`. This meant I now have
    an array of 5 elements, each of which was iteself an array of 5 integers. Using
    a Select on that nested array, I converted each of those sub-elements into a tuple
    which took one value from the parent array (x) and one from the sub-array (y).
    SelectMany is used to flatten the whole thing out to a simple list of all of the
    possible coordinates, which would look something like this: `(1, 1), (1, 2), (1,
    3), (1, 4), (1, 5), (2, 1), (2, 2)`…​and so on.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第一行生成一个整数数组，值为`[1, 2, 3, 4, 5]`。然后我使用另一个`Select`将这些整数转换为另一个数组，使用`Enumerable.Range`的另一个调用。这意味着我现在有一个包含5个元素的数组，每个元素本身都是一个包含5个整数的数组。在嵌套数组上使用Select，我将这些子元素中的每一个转换为一个元组，该元组从父数组（x）和子数组（y）中取一个值。使用SelectMany来将整个结构展平为所有可能坐标的简单列表，看起来像这样：`(1,
    1), (1, 2), (1, 3), (1, 4), (1, 5), (2, 1), (2, 2)`…等等。
- en: Values can be obtained by Selecting this array of coordinates into a set of
    calls to the repository’s GetVal function, passing in the values of X and Y from
    the tuple of coordinates I created on the previous line.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将坐标数组选择到存储库的GetVal函数的一组调用中获取值，从我在上一行创建的坐标元组中传递X和Y的值。
- en: Another situation we might be in is needing the same starting value in each
    case, but needing to transform it in different ways, depending on the position
    within the array. This is where `Enumerable.Repeat` comes in.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会遇到的另一种情况是需要在每种情况下使用相同的起始值，但需要根据数组中的位置以不同方式进行转换。这就是 `Enumerable.Repeat`
    的用武之地。
- en: '`Enumerable.Repeat` creates where each value is exactly the same, and you can
    specify exactly how many repeat elements you want.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enumerable.Repeat` 创建每个值都完全相同的元素，您可以指定要重复的元素数量。'
- en: 'You can’t use `Enumerable.Range` to count backwards. What if we wanted to do
    the previous example, but start at (5,5) and move backwards to (1,1). Here’s an
    example of how you’d do it:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您无法使用 `Enumerable.Range` 逆向计数。如果我们想做前面的例子，但从 (5,5) 开始向后移动到 (1,1)，这里是如何做的示例：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This looks a lot more complicated, but it isn’t really. What I’ve done is swap
    out the `Enumerable.Range` call for a 2-step operation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来更复杂了，但实际上并非如此。我所做的是将 `Enumerable.Range` 调用替换为一个两步操作。
- en: 'First a call to `Enumerable.Repeat` which is repeating the integer value of
    5 - 5 times. This results in an array like this: `[5, 5, 5, 5, 5]`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先调用 `Enumerable.Repeat`，它重复整数值 5 - 5 次。结果得到这样一个数组：`[5, 5, 5, 5, 5]`。
- en: Having done that, I’m then selecting using the overloaded version of `Select`
    which includes the value of i, then deducting that i value from the current value
    in the array. This means that in the first iteration, the return value is the
    current value i the array (5) minus the value of i (0 for the first iteration),
    this gives simply 5 back. In the next iteration, the value of i is 1, so 5-1 means
    4 is returned. And so on.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一步后，我使用了 `Select` 的重载版本，其中包括了 i 的值，然后从数组的当前值中减去了该 i 的值。这意味着在第一次迭代中，返回值是数组中的当前值
    i（5）减去 i 的值（第一次迭代为 0），因此简单地返回 5。在下一次迭代中，i 的值为 1，所以 5-1 就返回 4。依此类推。
- en: 'At the end of it we get back an array that looks something like this: `(5,
    5), (5, 4), (5, 3), (5, 2), (5, 1), (4, 5), (4, 4)` …​etc.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们得到了一个看起来像这样的数组：`(5, 5), (5, 4), (5, 3), (5, 2), (5, 1), (4, 5), (4, 4)`
    …​等等。
- en: There are ways to take this further still, but for this chapter I’m sticking
    to the relatively simple cases, ones that don’t require hacking around with C#.
    This is all out-of-the-box functionality that anyone can use right away.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更进一步的方法，但在本章中，我将专注于相对简单的情况，这些情况不需要对 C# 进行调试。这些都是每个人都可以立即使用的开箱即用功能。
- en: Many to One - The subtle art of Aggregation
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多对一 - 聚合的微妙艺术
- en: We’ve looked at loops for converting one thing into another, X items in → X
    new items out. That sort’ve thing. There’s another use case for loops that I’d
    like to cover - reducing many items into a single value.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过用于将一种东西转换为另一种东西的循环，X 项进入 → X 项新出。这样的事情。还有一个循环的用例我想要涵盖 - 将许多项减少为单个值。
- en: This could be making a total count, calculating Averages, Means or other statistical
    data, or other more complex aggregations.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是进行总计、计算平均值、均值或其他统计数据，或者进行其他更复杂的聚合操作。
- en: 'In Procedural code, we’d have a loop, a state tracking value and inside the
    loop we’d update the state constantly, based on each item from our array. Here’s
    a very simple example of what I’m talking about:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在过程化代码中，我们会有一个循环，一个状态跟踪值，并在循环内基于数组中的每个项不断更新状态。这里有一个我所说的简单示例：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There’s actually an in-built Linq method for doing this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，LINQ 中有一个内置的方法可以做到这一点：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There really shouldn’t ever be a need to do this sort of operation “long-hand”.
    Even if we’re creating the sum of a particular property from an array of Objects,
    Linq still has us covered:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，根本不应该有必要手动执行这种“长手计算”。即使我们要从对象数组中创建特定属性的总和，LINQ 也能够帮助我们完成：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There’s another function for calculating Means in the same manner called Average.
    There’s nothing for calculating Median, so far as I’m aware.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于计算均值同样有一个函数，称为 Average。至少据我所知，没有计算中位数的函数。
- en: 'I could calculate the Median with a quick bit of functional style code, however.
    It would look like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以用一小段函数式风格的代码来计算中位数，看起来像这样：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There are more complex aggregations that are required sometimes. What if we
    wanted - for example - a sum of two different values from an Enumerable of complex
    objects?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候需要更复杂的聚合。例如，如果我们想从一个包含复杂对象的 Enumerable 中获取两个不同值的总和会怎样？
- en: 'Procedural code might look like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 过程化代码可能如下所示：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We could use two separate Sum function calls, but then we’d be iterating twice
    through the Enumerable, hardly an efficient way to get our information. Instead,
    we can use another strangely little-known feature of Linq - the aggregate function.
    This consists of the following components:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用两个单独的Sum函数调用，但那么我们将两次迭代Enumerable，这绝对不是获取信息的有效方式。相反，我们可以使用Linq的另一个奇特而不为人知的特性
    - 聚合函数。它包括以下组件：
- en: Seed - a starting value for the final value.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 种子 - 最终值的起始值。
- en: An Aggregator function, this has two parameters - the current item from the
    Enumerable we’re aggregating down, and the current running total.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个聚合函数，它有两个参数 - 我们正在聚合的Enumerable中的当前项，和当前的累计值。
- en: The seed doesn’t have to be a primitive type, like an integer or whatever, it
    can just as easily be a complex object. In order to re-write the code sample,
    above, in a Functional style, however, we just need a simple Tuple.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 种子不一定是原始类型，比如整数或其他东西，它同样可以是一个复杂对象。然而，为了以函数式风格重写上面的代码示例，我们只需要一个简单的元组。
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the right place, Aggregate is an incredibly powerful feature of C#, and one
    worth taking the time to explore and understand properly.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确的位置，Aggregate是C#中一个非常强大的功能，值得花时间去探索和正确理解。
- en: It’s also an example of another concept important to Functional Programming
    - recursion.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 它还是函数式编程中另一个重要概念的示例 - 递归。
- en: Customised Iteration Behavior
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制化迭代行为
- en: Recursion sits at the back of a lot of Functional versions of Iteration. For
    the benefit of anyone that doesn’t know, it’s a function that calls itself repeatedly
    until some condition or other is met.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 递归存在于许多迭代的函数式版本中。为了不了解的人好处，它是一个重复调用自身的函数，直到满足某些条件为止。
- en: 'It’s a very powerful technique, but has some limitations to bear in mind in
    C#. The most important two being:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常强大的技术，但在C#中有一些需要记住的限制。最重要的两个是：
- en: 'If developed improperly, it can lead to infinite loops, which will literally
    run until the user terminates the application, or all available space on the stack
    is consumed. As Treguard, the legendary Dungeon Master of the popular British
    Fantasy RPG gameshow *Knightmare* would put it: “Oooh, Nasty”^([6](ch02.html#idm45400882090672)).'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果开发不当，可能导致无限循环，这会一直运行直到用户终止应用程序，或者堆栈上的所有可用空间被消耗完。正如著名英国奇幻RPG游戏秀《Knightmare》的传奇地下城主Treguard所说：“哦，那真是个恶心的事情”^([6](ch02.html#idm45400882090672))。
- en: In C# they tend to be consume a lot of memory compared to other forms of iteration.
    There are ways around this, but that’s a topic for another chapter.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C#中，它们倾向于消耗比其他形式的迭代更多的内存。虽然有办法解决这个问题，但那是另一个章节的话题。
- en: I have a lot more to say about recursion, and we’ll get to that shortly, but
    this for the purposes of this chapter, I’ll give the simplest example I can think
    of.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我对递归还有很多话要说，我们很快会讨论到这一点，但是对于这一章节的目的，我将给出我能想到的最简单的例子。
- en: Let’s say that you want to iterate through an Enumerable but you don’t know
    how long for. Let’s say you have a list of delta values for an integer (i.e. the
    amount to add or subtract each time) and you want to find out how many steps it
    is until you get from the starting value (whatever that might be) to 0.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要遍历一个Enumerable但是你不知道要遍历多久。假设你有一个整数的增量值列表（即每次添加或减少的量），你想找出从起始值（无论是什么）到0需要多少步。
- en: You could quite easily get the final value with an Aggregate call, but we don’t
    want the final value. We’re interested in all of the intermediate values, and
    we want to stop prematurely through the iteration. This is a simple arithmetic
    operation, but if complex objects were involved in a real-world scenario, there
    might be a significant performance saving from the ability to terminate the process
    early.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以很容易地通过一个Aggregate调用获得最终值，但我们不想要最终值。我们对所有中间值感兴趣，并且希望通过迭代提前停止。这是一个简单的算术操作，但如果涉及到复杂对象在真实场景中，提前终止过程可能会显著节省性能。
- en: 'In Procedural code, you’d probably write something like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在过程式代码中，你可能会写成这样：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this example I’m returning -1 to say that the starting value is already the
    one we’re looking for, otherwise I’m returning the zero-based index of the array
    that resulted in 0 being reached.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我返回-1来表明起始值已经是我们要找的值，否则我返回导致达到0的数组的基于零的索引。
- en: 'This is how I’d do it recursively:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我递归地完成它的方式：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is Functional now, but it’s not really ideal. Nested functions have their
    place, but I don’t personally find the way it has to be used here as readable
    as the code could be. Delightfully recursive, but I think it could be made clearer.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这已经是函数式的了，但实际上并不是理想的。嵌套函数有其存在的必要性，但我个人认为它在这里的使用方式并不像代码本可以那样可读。虽然递归很美妙，但我认为可以更清晰些。
- en: The other major problem is that this won’t scale up well if the list of deltas
    is large. I’ll show you what I mean.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个主要问题是，如果delta列表很大，这种方法将无法很好地扩展。我会给你展示一下我的意思。
- en: 'Let’s imagine there are only 3 values for the Deltas: 2, -12 & 9\. In this
    case we’d expect our answer to come back as 1, because the second position (i.e.
    index=1) of the array resulted in a zero (10+2-12). We would also expect that
    the 9 will never be evaluated. That’s the efficiency saving we’re looking for
    from our code here.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设Deltas只有3个值：2，-12和9。在这种情况下，我们期望答案返回1，因为数组的第二个位置（即索引=1）导致了0（10+2-12）。我们也期望9永远不会被评估。这就是我们在这里寻找代码效率的节约。
- en: What was actually happening with the recursive code, though.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 不过实际上递归代码的情况是这样的。
- en: First, it called GetFirstPositionWithValueZero with a current value of 10 (i.e.
    the starting value) and i was allowed to be the default of -1.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它以当前值为10（即起始值）调用GetFirstPositionWithValueZero，并允许i为默认值-1。
- en: The body of the function is a ternary if statement. If zero has been reached,
    return i, otherwise call the function again but with updated values for current
    and i.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的主体是一个三元if语句。如果达到了零，返回i，否则再次调用函数，但使用更新后的当前值和i。
- en: This is what’ll happen with the first delta (i.e. i=0, i.e. 2), so GetFirstPositionWithValueZero
    is called again with the current value now updated to 12 and i as 0.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是第一个delta（即i=0，即2）时会发生的情况，所以GetFirstPositionWithValueZero现在被调用，当前值更新为12，并且i为0。
- en: The new value is not 0, so the second call to GetFirstPositionWithValueZero
    will call itself again, this time with the current value updated with delta[1]
    and i incremented to 1\. delta[1] is -12, which would mean the third call results
    in a 0, which means that i can simply be returned.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 新值不是0，所以第二次调用GetFirstPositionWithValueZero将再次调用自身，这次当前值更新为delta[1]并且i增加到1。delta[1]为-12，这意味着第三次调用会返回0，因此i可以简单地被返回。
- en: Here’s the problem though…​
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，问题来了……
- en: The third call got an answer, but the first two calls are still open in memory
    and stored on the stack. The third call returns 1, which is passed up a level
    to the second call to GetFirstPositionWithValueZero, which now also returns 1,
    and so on…​ Until finally the original first call to GetFirstPositionWithValueZero
    returns the 1.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第三次调用得到了一个答案，但前两次调用仍然保留在内存中并存储在堆栈上。第三次调用返回1，这个值传递到第二次调用GetFirstPositionWithValueZero，现在它也返回1，依此类推……直到最初的第一次调用GetFirstPositionWithValueZero返回1。
- en: 'If you want to see that a little graphically, imagine it looking something
    like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想稍微图形化地看一下，可以想象它看起来像这样：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: That’s fine with 3 items in our array, but what if there are hundreds!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这在我们的数组中有3个项目时是可以接受的，但如果有数百个呢！
- en: Recursion, as I’ve said, is a powerful tool, but it comes with a cost in C#.
    Purer Functional languages (including F#) have a feature called *Tail Call Optimised
    Recursion* which allows the use of recursion without this memory usage problem.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 递归，正如我所说的，是一个强大的工具，但在C#中会有成本。更纯粹的函数式语言（包括F#）有一个称为*尾递归优化*的特性，允许使用递归而不会出现内存使用问题。
- en: Tail Recursion is an important concept, and one I’m going to return to later
    in a whole chapter dedicated to it, so I’m not going to dwell on it in any further
    detail here.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尾递归是一个重要的概念，我将在后面专门的一章中回到它，所以我不会在这里进一步详细讨论它。
- en: As it stands, out-of-the-box C# doesn’t permit Tail Recursion, even though it’s
    available in the .NET Common Language Runtime (CLR). There are a few tricks we
    can try to make it available to us, but they’re a little too complex for this
    chapter, so I’ll talk about them at a later juncture.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 就目前而言，C#的默认设置不允许尾递归，尽管在.NET公共语言运行时（CLR）中是可用的。我们可以尝试一些技巧来使其对我们可用，但这些技巧对本章来说有点复杂，所以我会在稍后的某个时候再谈论它们。
- en: For now, consider recursion as it’s described here, and keep in mind that you
    might want to be careful where and when you use it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时，按照这里描述的方式考虑递归，并记住您可能希望在何时何地使用它时要小心。
- en: Immutability
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性
- en: There’s more to Functional Programming in C# than just Linq. Another important
    feature I’d like to discuss is Immutability (i.e. a variable may not change value
    once declared). To what extent is it possible in C#?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程在 C# 中不仅仅是 Linq。我想讨论的另一个重要特性是不可变性（即一旦声明，变量的值不会改变）。在 C# 中可能达到何种程度？
- en: Firstly, there are some newer developments with regards to Immutability in C#
    8 and upwards. See the next chapter for that. For this chapter, I’m restricting
    myself to what is true of just about any version of .NET.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，关于 C# 8 及更高版本的不可变性有一些新的发展。请参阅下一章了解更多内容。对于本章来说，我限制自己只讨论.NET的几乎所有版本都适用的内容。
- en: 'To begin, let’s consider this little C# snippet:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑一下这个小的 C# 片段：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Is this immutable? It very much is not. Any of those properties can be replaced
    with new values via the setter. The IList also provides a set of functions that
    allows its underlying array to be added to or removed from.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不可变的吗？非常不是。任何这些属性都可以通过设置器替换为新值。IList 也提供一组函数，允许其底层数组进行添加或删除操作。
- en: 'We could make the setters private, meaning we’d have to instantiate the class
    via a detailed contructor:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将设置器设为私有，这意味着我们必须通过详细的构造函数来实例化类：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Is it immutable now? No, honestly it’s not. It’s true that you can’t outright
    replace any of the properties with new objects outside ClassA, which is great.
    The properties can be replaced inside the class, but the developer can ensure
    that no such code is ever added. You should hopefully have some sort of code review
    system to ensure that, as well.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是不是不可变的？不，老实说不是。确实，你不能在 ClassA 外部直接替换任何属性，这很好。属性可以在类内部替换，但开发人员可以确保永远不会添加这样的代码。希望你有某种代码审查系统来确保这一点。
- en: PropA and PropC are fine - strings and DateTime are both immutable in C#. The
    int value of PropB is fine too - ints don’t have anything you can change except
    its value.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: PropA 和 PropC 都很好 - 字符串和 DateTime 在 C# 中都是不可变的。PropB 的 int 值也没问题 - int 类型除了其值外无法更改任何内容。
- en: There are still several problems, however.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然而还存在一些问题。
- en: PropE is a List, which can still have values added, removed and replaced, even
    though we can’t replace the entire object. If we didn’t actually need to hold
    a mutable copy of PropE, we could easily replace it with an IEnumerable or IReadOnlyList.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: PropE 是一个列表，即使我们不能替换整个对象，仍然可以添加、删除和替换值。如果我们实际上不需要持有 PropE 的可变副本，我们可以轻松地将其替换为
    IEnumerable 或 IReadOnlyList。
- en: The `IEnumerable<double>` value of PropD seems fine at first glance, but what
    if it was passed to the constructor as a `List<double` which is still referenced
    by that type in the outside world? It would still be possible to alter its contents
    that way.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<double>` 类型的 PropD 乍一看似乎没问题，但如果作为一个 `List<double>` 传递给构造函数，而外部仍然引用这种类型，那么它仍然可以通过这种方式改变其内容。'
- en: 'There’s also the possibility of introducing something like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 还有可能引入类似于这样的东西：
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: All properties of PropF are also potentially going to be mutable - unless this
    same structure with private setters is followed there too.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: PropF 的所有属性可能也会是可变的 - 除非在那里也遵循具有私有设置器的相同结构。
- en: What about classes from outside your codebase? What about Microsoft classes,
    or those from a 3rd party Nuget package? There’s no way to enforce immutability.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 从外部代码库中获取的类有什么不同呢？微软的类或第三方NuGet包中的类呢？没有办法强制不可变性。
- en: Unfortunately there simply isn’t any way to enforce universal immutability,
    not even in the most recent versions of C#. I would assume that for backwards
    compatibility reasons, there is never going to be.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，根本没有办法强制通用的不可变性，即使在最新版本的 C# 中也是如此。出于向后兼容的原因，我认为永远都不会有。
- en: It would be lovely to have a native C# method of ensuring immutability by default,
    but there isn’t one - and isn’t ever likely to be for reasons of backwards compatibility.
    My own solution is that when coding, I simply *pretend* that Immutability exists
    in the project, and never change any object. There’s nothing in C# that provides
    any level of enforcement whatsoever, so you’d simply have to make a decision for
    yourself, or within your team, to act as if it does.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一种本地化的 C# 方法可以默认确保不可变性，那将会很棒，但实际上并没有 - 也不太可能因为向后兼容的原因。我的解决方案是，在编码时，我简单地 *假装*
    项目中存在不可变性，从不改变任何对象。在 C# 中，没有任何形式的强制执行，因此你只能自己或团队内部做出决定。
- en: Putting it all Together - a Complete Functional Flow
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起 - 完整的功能流程
- en: I’ve talked a lot about some simple techniques you can use to make your code
    more functional right away. Now, I’d like to show a complete, if minute, application
    written to demonstrate an end-to-end functional process.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经谈了很多关于如何立即使用一些简单技术使你的代码更具功能性。现在，我想展示一个完整的、虽小但完整的应用程序，用于展示一个端到端的功能流程。
- en: I’m going to write a very simple CSV parser. In my example, I want to read in
    the complete text of a CSV file containing data about the first few series of
    Doctor Who^([7](ch02.html#idm45400881422624)). I want to read the data, parse
    it into a Plain Old C# Object (POCO, i.e. a class containing only data and no
    logic) and then aggregate it into a report which counts the number of episodes,
    and the number of episodes known to be lost for each season. ^([8](ch02.html#idm45400881421904)).
    I’m simplifying CSV parsing for the purposes of this example. I’m not worrying
    about quotes around string fields, commas in field values or any values requiring
    additional parsing. There are 3rd party libraries for all of that! I’m just proving
    a point.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我将编写一个非常简单的CSV解析器。在我的示例中，我想要读取包含有关《Doctor Who》前几个系列数据的完整CSV文件的文本^([7](ch02.html#idm45400881422624))。我想要读取数据，将其解析为普通的C#对象（POCO，即仅包含数据而没有逻辑的类），然后将其聚合成一个报告，该报告计算每个季度的剧集数以及已知丢失的剧集数。^([8](ch02.html#idm45400881421904))。为了这个示例的目的，我简化了CSV解析。我不会担心字符串字段周围的引号，字段值中的逗号或需要额外解析的任何值。对于所有这些都有第三方库！我只是在证明一个观点。
- en: This complete process represents a nice, typical functional flow. Take a single
    item, break it up into a list, apply list operations, then aggregate back down
    into a single value again.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个完整的过程代表了一个很好的、典型的功能流。将单个项拆分成列表，应用列表操作，然后再次聚合为单个值。
- en: 'This is the structure of my CSV file:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我的CSV文件的结构：
- en: '[0] - Season Number. Integer value between 1 and 39\. I’m running the risk
    of dating this book now, but there are 39 seasons to date.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[0] - 季节数。整数值介于1和39之间。现在看起来我有点冒险，因为到目前为止已经有39个季度了。'
- en: '[1] - Story Name - a string field I don’t care about'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[1] - 故事名称 - 我不关心的字符串字段'
- en: '[2] - Writer - ditto'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2] - 编剧 - 同上'
- en: '[3] - Director - ditto'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3] - 导演 - 同上'
- en: '[4] - Number of Episodes - in Doctor Who, all stories comprise between 1 and
    14 episodes. Until 1989, all stories were multi-part serials.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4] - 剧集数 - 在《Doctor Who》中，所有故事包含1到14集。直到1989年，所有故事都是多集连续剧。'
- en: '[5] - Number of Missing Episodes - the number of episodes of this serial not
    known to exist. Any non-zero number is too many for me, but such is life.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[5] - 缺失剧集数 - 这部连续剧中不知道存在的集数。任何非零数目对我来说都太多了，但这就是生活。'
- en: 'I want to end up with a report that has just these fields:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我想最终得到的报告只包括以下字段：
- en: Season Number
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 季节数
- en: Total Episodes
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总剧集数
- en: Total Missing Episodes
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总缺失剧集数
- en: Percentage Missing
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺失百分比
- en: Let’s crack on with some code…​.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续编写一些代码……。
- en: '[PRE30]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In case you’re curious, the results would look something like this (the “\t”
    characters are tabs, which make it a bit more readable):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣，结果看起来会像这样（“\t”字符是制表符，使其更易读）：
- en: '[PRE31]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Note, I could have made the code sample more concise and written just about
    all of this together in one long, continuous fluent expression like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我本可以使代码示例更简洁，并且像这样将所有内容写在一个长长的连贯表达式中：
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'There’s nothing wrong with that sort of approach, but I like splitting it out
    into individual lines for a couple of reasons:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法没有错，但我喜欢将其拆分成单独的行，原因有几个：
- en: The variable names provide some insight into what your code is doing. We’re
    sort’ve semi-enforcing a form of code commenting.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名提供了一些关于你的代码正在做什么的见解。我们有点像是在半强制性地进行代码注释。
- en: It’s possible to inspect the intermediate variables, to see what’s in them at
    each step. This makes debugging easier, because like I said in the previous chapter
    - it’s like being able to look back on your working in a mathematics answer, to
    see which step it was that you went wrong on.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以检查中间变量，查看每个步骤中的内容。这使得调试更容易，因为正如我在前一章中所说的那样——就像在数学答案中回顾你的工作，看看哪一步错了。
- en: There isn’t any ultimate functional difference, nothing that would be noticed
    by the end user, so which style you adopt is more a matter of personal taste.
    Write in whatever way it seems best to you. Do try and keep it readable, and easy
    for everyone to follow, though.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 没有最终的功能差异，没有任何会被最终用户注意到的地方，所以采用哪种风格更多是个人品味的问题。无论你以何种方式写作，都要保持可读性和易于跟踪。
- en: Taking it Further - Develop Your Functional Skills
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更进一步 - 发展你的函数式编程技能
- en: Here’s a challenge for you. If some or all of the techniques described to you
    here were new, then go off and have fun with them for a bit.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个挑战给你。如果这里描述的一些或全部技术对你来说是新的，那就去尝试一下，享受一番吧。
- en: 'Challenge yourself to writing code with the following rules:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战自己按照以下规则编写代码：
- en: Treat all variables as immutable - do not change any variable value once set.
    Basically treat everything as if it were a constant.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有变量视为不可变的 - 一旦设置，不要更改任何变量值。基本上把所有东西都当作常量对待。
- en: 'None of the following statements are permitted - `If`, `For`, `ForEach`, `While`.
    `If` is acceptable only in a Ternary expression - i.e. the single-line expression
    in the style: someBoolean ? valueOne : valueTwo.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '不允许使用以下语句 - `If`、`For`、`ForEach`、`While`。只有在三元表达式中可以接受`If` - 例如：someBoolean
    ? valueOne : valueTwo。'
- en: Where possible write as many functions as small, concise arrow functions (a.k.a.
    Lambda Expressions).
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能写尽可能多的函数，简洁的箭头函数（也称为Lambda表达式）。
- en: Either do this as part of your production code, or else go out and look for
    a code challenge site, something like [The Advent of Code (https://adventofcode.com)](https://adventofcode.com/)
    or [Project Euler (https://projecteuler.net)](https://projecteuler.net/). Something
    you can get your teeth into.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要么将其作为你的生产代码的一部分，要么去寻找一个代码挑战网站，比如[The Advent of Code (https://adventofcode.com)](https://adventofcode.com/)或[Project
    Euler (https://projecteuler.net)](https://projecteuler.net/)。找些你感兴趣的事情来做。
- en: If you don’t want to go through the bother of creating an entire solution for
    these exercises in Visual Studio, there’s always LINQPad ([*https://www.linqpad.net/*](https://www.linqpad.net/))
    for a quick and easy way to rattle off some C# code.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在Visual Studio中为这些练习创建整个解决方案，总还有LINQPad（[*https://www.linqpad.net/*](https://www.linqpad.net/)）可以快速轻松地编写一些C#代码。
- en: After you’ve got the hang of this, you’ll be ready to move onto the next step.
    I hope you’re having fun so far!
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当你掌握了这些之后，你就准备好迈向下一步了。希望你到目前为止玩得开心！
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at a variety of simple Linq-based techniques for
    writing Functional-style code immediately in any C# codebase using at least .NET
    Framework 3.5, because these features are ever-green and have been in place for
    all of those years in every subsequent version of .NET without needing to be updated
    or replaced.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了一些基于简单Linq技术的方法，可立即在任何C#代码库中使用至少.NET Framework 3.5编写函数式风格的代码，因为这些功能是永恒的，并且在.NET的每个后续版本中都无需更新或替换。
- en: We discussed the more advanced features of Select statements, some of the less
    well-known features of Linq and methods for Aggregating and Recursion.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了Select语句的更高级特性，Linq的一些较少知名的特性以及聚合和递归方法。
- en: In the next chapter, I’ll look at some of the most recent developments in C#
    that can be used in more up-to-date codebases.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将探讨一些最新的C#开发进展，可以在更新的代码库中使用。
- en: ^([1](ch02.html#idm45400885975216-marker)) I’m more of an SF (or Sci-fi, if
    you prefer) fan, truth be told.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.html#idm45400885975216-marker)) 说实话，我更喜欢科幻。
- en: ^([2](ch02.html#idm45400886839824-marker)) And in one example, a couple of definitions
    were also outside the codebase in Database Stored Procedures
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch02.html#idm45400886839824-marker)) 并且在一个例子中，一些定义也在数据库存储过程之外。
- en: ^([3](ch02.html#idm45400886206224-marker)) Except your employer. They pay your
    bills. They hopefully send you birthday cards once a year too, if they’re nice.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch02.html#idm45400886206224-marker)) 除了你的雇主。他们支付你的账单。如果他们很好的话，每年还会送你一张生日卡。
- en: ^([4](ch02.html#idm45400883250816-marker)) As a Functional programmer, and a
    believer in exposing the most abstract interface possible, I literally **never**
    use `ToList()`. Only ever `ToArray()`, even if `ToList` is every so slightly faster.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch02.html#idm45400883250816-marker)) 作为一名函数式程序员，我坚信应尽可能暴露最抽象的接口，因此我从来不使用`ToList()`。即使`ToList`稍微快一点，我也只用`ToArray()`。
- en: ^([5](ch02.html#idm45400882823232-marker)) No, Sophie. It’s not good enough
    to just use your fingers!
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch02.html#idm45400882823232-marker)) 不行，Sophie。仅仅用手指操作是不够的！
- en: ^([6](ch02.html#idm45400882090672-marker)) Check out the man himself [here (https://www.youtube.com/watch?v=OISR3al5Bnk)](https://www.youtube.com/watch?v=OISR3al5Bnk)
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch02.html#idm45400882090672-marker)) 看看他本人的视频 [这里 (https://www.youtube.com/watch?v=OISR3al5Bnk)](https://www.youtube.com/watch?v=OISR3al5Bnk)
- en: ^([7](ch02.html#idm45400881422624-marker)) For those of you unacquainted, this
    is a British SF series that has been running on-and-off since 1963\. It is, in
    my own opinion, the greatest TV series ever made. I’m not taking any arguments
    on that
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch02.html#idm45400881422624-marker)) 对于那些不熟悉的人来说，这是一部自 1963 年以来断断续续播放的英国科幻系列。在我看来，这是有史以来最伟大的电视系列。关于这一点，我不接受任何异议。
- en: ^([8](ch02.html#idm45400881421904-marker)) Sad to say, the BBC junked many episodes
    of the series in the 1970s. If you have any of those, please do hand them back.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch02.html#idm45400881421904-marker)) 令人遗憾的是，BBC 在 1970 年代销毁了许多该系列的剧集。如果你有其中的任何剧集，请归还给我。
