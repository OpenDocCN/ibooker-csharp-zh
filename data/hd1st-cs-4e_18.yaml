- en: 'Chapter 12\. Exception Handling: *Putting out Fires Gets old*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章\. 异常处理：*处理异常开始变得老套*
- en: '![Images](assets/pg623.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg623.png)'
- en: '**Programmers aren’t meant to be firefighters.**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序员不应该成为消防员。**'
- en: You’ve worked your tail off, wading through technical manuals and a few engaging
    *Head First* books, and you’ve reached the pinnacle of your profession. But you’re
    still getting panicked phone calls in the middle of the night from work because
    **your program crashes**, or **doesn’t behave like it’s supposed to**. Nothing
    pulls you out of the programming groove like having to fix a strange bug...but
    with **exception handling**, you can write code to **deal with problems** that
    come up. Better yet, you can even plan for those problems, and **keep things running**
    when they happen.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你努力工作，浏览技术手册和一些引人入胜的*Head First*图书，最终成为你职业生涯的顶峰。但你仍然在半夜因为**程序崩溃**或**行为不符合预期**而接到恐慌的电话。没有什么能像修复一个奇怪的错误那样让你从编程状态中脱颖而出...但是通过**异常处理**，你可以编写代码来**处理出现的问题**。更重要的是，你甚至可以为这些问题做好准备，并在问题发生时**保持系统运行**。
- en: Your hex dumper reads a filename from the command line
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的十六进制转储程序从命令行读取文件名
- en: At the end of [#reading_and_writing_files_save_the_last](ch10.html#reading_and_writing_files_save_the_last)
    you built a hex dumper that uses command-line arguments to dump any file. You
    used the project properties in the IDE to set the arguments for the debugger,
    and you saw how to call it from a Windows command prompt or macOS Terminal window.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [#reading_and_writing_files_save_the_last](ch10.html#reading_and_writing_files_save_the_last)
    结尾，你构建了一个十六进制转储程序，该程序使用命令行参数转储任何文件。你使用 IDE 中的项目属性设置调试器的参数，并学习了如何从 Windows 命令提示符或
    macOS Terminal 窗口调用它。
- en: '![Images](assets/pg624-1.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg624-1.png)'
- en: But what happens if you give HexDump an invalid filename?
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 但是如果你给 HexDump 一个无效的文件名会发生什么？
- en: When you modified your HexDump app to use command-line arguments, we asked you
    to be careful to specify a valid filename. What happens when you give it an invalid
    filename? Try running your app again from the command line, but this time give
    it the argument **`invalid-filename`**. Now it ***throws an exception.***
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当你修改你的 HexDump 应用程序以使用命令行参数时，我们要求你务必指定一个有效的文件名。当你提供一个无效的文件名时会发生什么？尝试再次从命令行运行你的应用程序，但这次给它传递参数
    **`invalid-filename`**。现在它***抛出一个异常***。
- en: '![Images](assets/pg624-2.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg624-2.png)'
- en: Use the project settings to set the program’s argument to an invalid filename
    and run the app in the IDE’s debugger. Now you’ll see it throw an exception with
    the same class name (System.IO.FileNotFoundException) and a similar “Could not
    find file” message.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用项目设置将程序的参数设置为一个无效的文件名，并在 IDE 的调试器中运行应用程序。现在你会看到它抛出一个异常，类名相同（System.IO.FileNotFoundException），并显示类似的“找不到文件”的消息。
- en: '![Images](assets/pg624-3.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg624-3.png)'
- en: Note
  id: totrans-12
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**You’d never actually get all these exceptions in a row—the program would
    throw the first exception and then halt. You’d only get to the second exception
    if you fixed the first.**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**实际上，你不会连续遇到所有这些异常 —— 程序会抛出第一个异常然后停止。只有在修复第一个异常后才会遇到第二个异常。**'
- en: When your program throws an exception, the CLR generates an Exception object
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当你的程序抛出一个异常时，CLR 会生成一个异常对象
- en: 'You’ve been looking at the CLR’s way of telling you something went wrong in
    your program: an **exception**. When an exception occurs in your code, an object
    is created to represent the problem. It’s called—no surprise here—Exception.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你一直在研究 CLR 在程序中告诉你出了问题的方式：一个**异常**。当你的代码中发生异常时，会创建一个对象来表示这个问题。这就是——毫不奇怪——异常。
- en: 'For example, suppose you have an array with four items, and you try to access
    the 16th item (index 15, since we’re zero-based here):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个包含四个项目的数组，然后你尝试访问第16个项目（由于我们是以零为基础的，所以索引是15）：
- en: '![Images](assets/pg628.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg628.png)'
- en: Note
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: ex-cep-tion, noun.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ex-cep-tion，名词。
- en: a person or thing that is excluded from a general statement or does not follow
    a rule. *While Jamie usually hates peanut butter, they made an **exception** for
    Parker’s peanut butter fudge.*
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个被排除在一般声明之外或不遵循规则的人或物。*尽管杰米通常讨厌花生酱，他们对帕克的花生酱夹心薄片**做了个例外**。*
- en: When the IDE halts because the code threw an exception, you can see the details
    of the exception by **expanding** **`$exception`** **in the Locals window**. The
    Locals window shows you all of the variables currently ***in scope*** (which means
    the current statement has access to them).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当IDE因为代码抛出异常而停止时，你可以通过在Locals窗口中**展开`$exception`**来查看异常的详细信息。Locals窗口显示当前范围内的所有变量（这意味着当前语句可以访问它们）。
- en: The CLR goes to the trouble of creating an object because it wants to give you
    all the information it has about what caused the exception. You may have code
    to fix, or you may just need to make some changes to how you handle a particular
    situation in your program.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: CLR会创建一个对象，因为它想要提供有关引发异常的所有信息。你可能需要修复代码，或者只需对程序中的特定情况进行一些更改。
- en: 'This particular exception is an **IndexOutOfRangeException**, which gives you
    an idea of what the problem is: you’re trying to access an index in the array
    that’s out of range. You’ve also got information about exactly where in the code
    the problem occurred, making it easier to track down and solve (even if you’ve
    got thousands of lines of code).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的异常是**IndexOutOfRangeException**，它告诉你问题所在：你正在尝试访问数组中超出范围的索引。你还可以获取有关问题发生位置的详细信息，这使得跟踪和解决问题变得更容易（即使你的代码有数千行）。
- en: All Exception objects inherit from System.Exception
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有的异常对象都继承自System.Exception
- en: .NET has lots of different exceptions it may need to report. Since many of these
    have a lot of similar features, inheritance comes into play. .NET defines a base
    class, called Exception, that all specific exception types inherit from.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: .NET有许多不同的异常可能需要报告。由于许多异常具有许多相似的特征，因此继承起了作用。.NET定义了一个基类叫做Exception，所有特定的异常类型都从这个基类继承。
- en: The Exception class has a couple of useful members. The Message property stores
    an easy-to-read message about what went wrong. StackTrace tells you what code
    was being executed when the exception occurred, and what led up to the exception.
    (There are others, too, but we’ll use those first.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Exception类有几个有用的成员。Message属性存储了关于出错原因的易读信息。StackTrace告诉你在异常发生时正在执行的代码以及导致异常的过程。（还有其他的，但我们首先使用这些。）
- en: '![Images](assets/pg629.png)![Images](assets/pg631.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/pg629.png)![图像](assets/pg631.png)'
- en: '**That’s right. Exceptions are a really useful tool that you can use to find
    places where your code acts in ways you don’t expect.**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**没错。异常是一个非常有用的工具，可以帮助你找到代码行为不符合预期的地方。**'
- en: 'A lot of programmers get frustrated the first time they see an exception. But
    exceptions are really useful, and you can use them to your advantage. When you
    see an exception, it’s giving you a lot of clues to help you figure out why your
    code is reacting in a way that you didn’t anticipate. That’s good for you: it
    lets you know about a new scenario that your program has to handle, and it gives
    you an opportunity to **do something about it.**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 很多程序员第一次看到异常时会感到沮丧。但是异常是非常有用的，你可以利用它们来优化你的程序。当你看到异常时，它提供了很多线索，帮助你找出代码为什么会以你意料之外的方式反应。这对你有好处：它让你知道程序必须处理的新情况，并为你提供了**解决问题的机会**。
- en: '**Exceptions are all about helping you find and fix situations where your code
    behaves in ways you didn’t expect.**'
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**异常主要是帮助你找到并修复代码表现出意料之外行为的情况。**'
- en: There are some files you just can’t dump
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有一些文件你是无法转储的
- en: In [#linq_and_lambdas_get_control_of_your_dat](ch09.html#linq_and_lambdas_get_control_of_your_dat)
    we talked about making your code **robust** so that it can deal with bad data,
    malformed input, user errors, and other unexpected situations. Dumping stdin if
    no file is passed on the command line or if the file doesn’t exist is a great
    start to making the hex dumper robust.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在[#linq_and_lambdas_get_control_of_your_dat](ch09.html#linq_and_lambdas_get_control_of_your_dat)中，我们讨论了如何使你的代码更加**健壮**，以便处理不良数据、格式错误的输入、用户错误和其他意外情况。如果没有通过命令行传递文件或文件不存在，则倒置stdin是使十六进制转储器更加健壮的一个很好的起点。
- en: 'But are there still some cases that we need to handle? For example, what if
    the file exists but it’s not readable? Let’s see what happens if we remove read
    access from a file, then try to read it:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 但是还有一些情况需要我们处理吗？例如，如果文件存在但不可读怎么办？让我们看看如果我们移除文件的读取权限，然后尝试读取会发生什么：
- en: '***On Windows:*** Right-click the file in the Windows Explorer, go to the Security
    tab, and click Edit to change the permissions. Check all of the Deny boxes.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***在Windows上：*** 在Windows资源管理器中右键点击文件，转到安全选项卡，然后点击编辑以修改权限。勾选所有的拒绝框。'
- en: '![Images](assets/pg632-1.png)'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg632-1.png)'
- en: '***On a Mac:*** In a Terminal window, change to the folder with the file you
    want to dump, and run this command, replacing `binarydata.dat` with the name of
    your file): `chmod 000 binarydata.dat.`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***在Mac上：*** 在终端窗口中，切换到包含要转储文件的文件夹，并运行以下命令，将`binarydata.dat`替换为你的文件名：`chmod
    000 binarydata.dat.`'
- en: Now that you’ve removed read permissions from your file, try running your app
    again, either in the IDE or from the command line.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经从文件中删除了读取权限，尝试再次运行你的应用程序，可以在IDE中或从命令行中执行。
- en: 'You’ll see an exception—the stack trace shows that the **`using` statement
    called the GetInputStream method**, which eventually caused the FileStream to
    throw a System.UnauthorizedAccessException:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到一个异常—堆栈跟踪显示**`using`语句调用了GetInputStream方法**，最终导致FileStream抛出了System.UnauthorizedAccessException异常：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Images](assets/pg632-2.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg632-2.png)'
- en: '**Actually, there *is* something you can do about it.**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**实际上，对此是*有*办法的。**'
- en: Yes, users do, indeed, screw up all the time. They’ll give you bad data, weird
    input, click on things you didn’t even know existed. That’s a fact of life, but
    that doesn’t mean you can’t do anything about it. C# gives you really useful **exception
    handling tools** to help you make your programs more robust. Because while you
    *can’t* control what your users do with your app, you *can* make sure that your
    app doesn’t crash when they do it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，用户确实经常出错。他们会向你的程序提供糟糕的数据，奇怪的输入，点击你甚至不知道存在的东西。这是生活的一部分，但这并不意味着你无法应对。C#为你提供了非常有用的**异常处理工具**，帮助你使程序更加健壮。因为虽然你*不能*控制用户如何使用你的应用程序，但你*可以*确保他们这样做时你的应用程序不会崩溃。
- en: What happens when a method you want to call is risky?
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当你想调用的方法存在风险时会发生什么？
- en: Users are unpredictable. They feed all sorts of weird data into your program,
    and click on things in ways you never expected. That’s just fine, because you
    can deal with exceptions that your code throws by adding **exception handling**,
    which lets you write special code that gets executed any time an exception is
    thrown.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 用户是不可预测的。他们会将各种奇怪的数据输入到你的程序中，并以你意想不到的方式点击东西。这没问题，因为你可以通过添加**异常处理**来处理代码抛出的异常，从而执行特殊的代码。
- en: '**Let’s say a method called in your program takes input from a user.**'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**假设你的程序中调用的方法接受用户输入。**'
- en: '![Images](assets/pg633-1.png)'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg633-1.png)'
- en: '**That method could do something risky that might not work at runtime.**'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**那个方法可能会在运行时出现风险。**'
- en: '![Images](assets/pg633-2.png)![Images](assets/pg633-3.png)'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg633-2.png)![图片](assets/pg633-3.png)'
- en: '**You need to know that the method you’re calling is risky.**'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你需要知道你调用的方法是有风险的。**'
- en: '![Images](assets/pg633-4.png)'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg633-4.png)'
- en: Note
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you can come up with a way to do a less risky thing that avoids throwing
    the exception, that’s the best possible outcome! But some risks just can’t be
    avoided, and that’s when you want to do this.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你能想出一种避免抛出异常的风险较小的方法，那就是最好的结果！但有些风险是无法避免的，这时候你就需要这样做。
- en: '**You can then write code that can *handle* the exception if it does happen.
    You need to be prepared, just in case.**'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**然后，如果异常发生，你可以编写代码来*处理*异常。务必做好准备，以防万一。**'
- en: '![Images](assets/pg633-5.png)'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg633-5.png)'
- en: Handle exceptions with try and catch
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用try和catch处理异常
- en: When you add exception handling to your code, you’re using the `try` and `catch`
    keywords to create a block of code that gets run if an exception is thrown.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在代码中添加异常处理时，你会使用`try`和`catch`关键字创建一个代码块，该代码块在抛出异常时执行。
- en: 'Your *try/catch* code basically tells the C# compiler: “**Try** this code,
    and if an exception occurs, **catch** it with this *other* bit of code.” The part
    of the code you’re trying is the `try` **block**, and the part where you deal
    with exceptions is called the `catch` **block**. In the `catch` block, you can
    do things like print a friendly error message instead of letting your program
    come to a halt.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你的*try/catch*代码基本上告诉C#编译器：“**试试**这段代码，如果出现异常，**用**这段*其他*代码**捕获**它。”你试图的代码部分是`try`**块**，处理异常的部分称为`catch`**块**。在`catch`块中，你可以做一些事情，比如打印友好的错误消息，而不是让程序停止运行。
- en: 'Let’s have another look at the last three lines of the stack trace in our HexDump
    scenario to help us figure out where to put our exception handling code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再来看看HexDump场景中堆栈跟踪的最后三行，帮助我们确定在哪里放置我们的异常处理代码：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The UnauthorizedAccessException is caused by the line in GetInputStream that
    calls File.OpenRead. Since we can’t prevent that exception, let’s modify GetInputStream
    to use a *try/catch* block:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnauthorizedAccessException`是由调用`File.OpenRead`的`GetInputStream`中的那一行引起的。由于我们无法阻止该异常，让我们修改`GetInputStream`以使用*try/catch*块：'
- en: '![Images](assets/pg634.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg634.png)'
- en: We kept things simple in our exception handler. First we used Console.Error
    to write a line to the error output (stderr) letting the user know that an error
    occurred, then we fell back to reading data from standard input so the program
    still did something. Notice how **the `catch` block has a `return` statement**.
    The method returns a Stream, so if it handles an exception it still needs to return
    a Stream; otherwise you’ll get the “not all code paths return a value” compiler
    error.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的异常处理程序中保持简单。首先，我们使用Console.Error写入了一行到错误输出(stderr)，告知用户发生了错误，然后我们回退到从标准输入读取数据，以便程序仍然执行某些操作。注意`catch`块中有一个`return`语句。该方法返回一个流，因此如果处理异常，则仍需要返回一个流；否则，您将会得到“not
    all code paths return a value”编译器错误。
- en: Use the debugger to follow the try/catch flow
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用调试器跟踪try/catch流程
- en: An important part of exception handling is that when a statement in your `try`
    block throws an exception, the rest of the code in the block gets **short-circuited**.
    The program’s execution immediately jumps to the first line in the `catch` block.
    Let’s use the IDE’s debugger to explore how this works.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理的重要部分是，当`try`块中的语句抛出异常时，块中的其余代码会被**短路**。程序立即跳转到`catch`块中的第一行。让我们使用IDE的调试器来探索这是如何工作的。
- en: '***Debug this!***'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '***调试这个！***'
- en: Replace the GetInputStream method in your HexDump app with the one that we just
    showed you to handle an UnauthorizedAccessException.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的HexDump应用程序中的GetInputStream方法替换为我们刚刚展示的方法，以处理UnauthorizedAccessException。
- en: Modify your project options to set the argument so that it contains the path
    to an unreadable file.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改项目选项，将参数设置为包含不可读文件的路径。
- en: Place a breakpoint on the first statement in GetInputStream, then start debugging
    your project.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GetInputStream的第一条语句上设置断点，然后开始调试您的项目。
- en: When it hits the breakpoint, step over the next few statements until you get
    to File.OpenRead. Step over it—the app jumps to the first line in the `catch`
    block.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当程序运行到断点时，跳过接下来的几个语句，直到到达`File.OpenRead`。继续执行——应用程序跳转到`catch`块的第一行。
- en: '![Images](assets/pg635.png)'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg635.png)'
- en: Keep stepping through the rest of the `catch` block. It will write the line
    to the console, then return Console.OpenStandardInput and resume the Main method.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续逐步执行`catch`块的其余部分。它将向控制台写入一行，然后返回Console.OpenStandardInput并恢复Main方法。
- en: If you have code that ALWAYS needs to run, use a finally block
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果您有代码始终需要运行，请使用finally块
- en: When your program throws an exception, a couple of things can happen. If the
    exception ***isn’t*** handled, your program will stop processing and crash. If
    the exception ***is*** handled, your code jumps to the `catch` block. What about
    the rest of the code in your `try` block? What if you were closing a stream, or
    cleaning up important resources? That code needs to run, even if an exception
    occurs, or you’re going to make a mess of your program’s state. That’s where you’ll
    use a `**finally block**`. It’s a block of code that comes after the `try` and
    `catch`. The `**finally**` block always runs, whether or not an exception was
    thrown. Let’s use the debugger to explore how the `finally` block works.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序抛出异常时，可能会发生几件事情。如果异常***未***被处理，程序将停止处理并崩溃。如果异常***被***处理，代码将跳转到`catch`块。那么`try`块中的其余代码呢？如果您正在关闭流或清理重要资源怎么办？该代码需要运行，即使发生异常，否则程序状态将混乱。这就是您将使用`**finally块**`的地方。它位于`try`和`catch`之后。`**finally**`块始终运行，无论是否抛出异常。让我们使用调试器来探索`finally`块的工作原理。
- en: '***Debug this!***'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '***调试这个！***'
- en: '**Create a new Console App project.**'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个新的控制台应用程序项目。**'
- en: 'Add `using System.IO;` to the top of the file, then add this Main method:'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在文件顶部添加`using System.IO;`，然后添加以下`Main`方法：
- en: '![Images](assets/pg636.png)'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg636.png)'
- en: Note
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You’ll see the exception in the Locals window, just like you did earlier.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您将在Locals窗口中看到异常，就像您之前看到的那样。
- en: '**Add a breakpoint to the first line of the Main method.**'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在Main方法的第一行添加断点。**'
- en: Debug your app and step through it. The first line in the `try` block tries
    to access `args[0]`, but since you didn’t specify any command-line arguments the
    `args` array is empty and it throws an exception—specifically, a System.**IndexOutOfRangeException**,
    with the message *“Index was outside the bounds of the array.”* After it prints
    the message, it **executes the** `**finally**` **block**, and then the program
    exits.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调试你的应用程序并逐步执行它。`try`块中的第一行尝试访问`args[0]`，但由于您没有指定任何命令行参数，`args`数组为空，它会抛出一个异常——具体来说，是`System.IndexOutOfRangeException`，并显示消息*“Index
    was outside the bounds of the array.”* 在打印消息后，它**执行** `**finally**` **块**，然后程序退出。
- en: '**Set a command-line argument with the path of a valid file.**'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置一个带有有效文件路径的命令行参数。**'
- en: Use the project properties to pass a command-line argument to the app. Give
    it the full path of a valid file. Make sure there are no spaces in the filename,
    otherwise the app will interpret it as two arguments. Debug your app again—after
    it finishes the `try` block, it **executes the** `**finally**` **block.**
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用项目属性向应用程序传递命令行参数。给它一个有效文件的完整路径。确保文件名中没有空格，否则应用程序会将其解释为两个参数。再次调试你的应用程序——在完成`try`块后，它**执行**
    `**finally**` **块**。
- en: '**Set a command-line argument with an invalid file path.**'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置一个带有无效文件路径的命令行参数。**'
- en: 'Go back to the project properties and change the command-line argument to pass
    the app the name of a file that does not exist. Run your app again. This time
    it catches a different exception: a System.IO.**FileNotFoundException**. Then
    it **executes the `finally` block.**'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回到项目属性，更改命令行参数，将应用程序命名为不存在的文件。再次运行你的应用程序。这次它捕获了不同的异常：`System.IO.FileNotFoundException`。然后它**执行**
    `**finally**` **块**。
- en: Catch-all exceptions handle System.Exception
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用异常捕获处理System.Exception
- en: 'You just made your console app throw two different kinds of exception—an IndexOutOfRangeException
    and a FileNotFoundException—and they were both handled. Take a closer look at
    the `catch` block:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚让你的控制台应用程序抛出了两种不同类型的异常——一个是**IndexOutOfRangeException**，另一个是**FileNotFoundException**，它们都被处理了。仔细看一下`catch`块：
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is a **catch-all exception**: the type after the `catch` block indicates
    what type of exception to handle, and since all exceptions extend the System.Exception
    class, specifying `Exception` as the type tells the `try/catch` block to catch
    any exception.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个**通用异常捕获**：`catch`块后的类型指示要处理的异常类型，由于所有异常都扩展自`System.Exception`类，指定`Exception`作为类型告诉`try/catch`块捕获任何异常。
- en: Avoid catch-all exception with multiple catch blocks
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免使用多个`catch`块来捕获所有异常
- en: 'It’s always better to try to anticipate the specific exceptions that your code
    will throw and handle them. For example, we know that this code can throw an IndexOutOfRange
    exception if no filename is specified, or a FileNotFound exception if an invalid
    file is found. We also saw earlier in the chapter that trying to read an unreadable
    file causes the CLR to throw an UnauthorizedAccessException. You can handle these
    different kinds of exceptions by adding **multiple `catch` blocks** to your code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量预料代码可能抛出的具体异常并处理它们是更好的做法。例如，我们知道如果没有指定文件名，此代码可能抛出`IndexOutOfRangeException`异常，如果找到无效文件，则可能抛出`FileNotFoundException`异常。我们还在本章的前面看到，尝试读取一个不可读文件会导致CLR抛出`UnauthorizedAccessException`。您可以通过在代码中添加多个`catch`块来处理这些不同类型的异常：
- en: '![Images](assets/pg637.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg637.png)'
- en: Now your app will write different error messages depending on which exception
    is handled. Notice that the first two `catch` blocks **did not specify a variable
    name** (like `ex`). You only need to specify a variable name if you’re going to
    use the Exception object.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的应用程序会根据处理的异常不同写入不同的错误消息。注意，前两个`catch`块**未指定变量名**（如`ex`）。只有在需要使用异常对象时才需要指定变量名。
- en: Pool Puzzle
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 池谜题
- en: Your ***job*** is to take code snippets from the pool and place them into the
    blank lines in the program. You can use the same snippet more than once, and you
    won’t need to use all the snippets. Your ***goal*** is to make the program produce
    the output below.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你的***任务***是从池中取出代码片段，并将它们放入程序中的空白行中。你可以多次使用相同的片段，而且不需要使用所有的片段。你的***目标***是使程序产生下面的输出。
- en: '![Images](assets/pg639.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg639.png)'
- en: Pool Puzzle Solution
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 池谜题解决方案
- en: '![Images](assets/pg640.png)![Images](assets/pg641-1.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg640.png)![图片](assets/pg641-1.png)'
- en: '**Unhandled exceptions bubble up.**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**未处理的异常会上升。**'
- en: 'Believe it or not, it can be really useful to leave exceptions unhandled. Real-life
    programs have complex logic, and it’s often difficult to recover correctly when
    something goes wrong, especially when a problem occurs very far down in the program.
    By only handling specific exceptions and avoiding catch-all exception handlers,
    you let unexpected exceptions ***bubble up***: instead of being handled in the
    current method, they’re caught by the next statement up the call stack. Anticipating
    and handling the exceptions that you expect and letting unhandled exceptions bubble
    up is a great way to build more robust apps.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，留下未处理的异常确实非常有用。现实生活中的程序具有复杂的逻辑，当程序出现问题时，特别是在程序深处发生问题时，正确恢复通常很困难。通过仅处理特定异常并避免使用捕获所有异常的处理程序，你可以让意外的异常“冒泡上浮”：而不是在当前方法中处理它们，它们会被调用堆栈中下一个语句捕获。预期和处理你期望的异常，并让未处理的异常冒泡上浮，是构建更健壮应用程序的一个很好方法。
- en: 'Sometimes it’s useful to **rethrow** an exception, which means that you handle
    an exception in a method but *still bubble it up* to the statement that called
    it. All you need to do to rethrow an exception is call `throw;` inside a `catch`
    block, and the exception that it caught will immediately bubble up:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候重新抛出异常是有用的，这意味着你在方法中处理异常但仍然将其上抛给调用它的语句。重新抛出异常只需在`catch`块中调用`throw;`，它捕获的异常将立即上抛：
- en: '![Images](assets/pg641-2.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg641-2.png)'
- en: Note
  id: totrans-103
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Here’s a career tip: a lot of C# programming job interviews include a question
    about how you deal with exceptions in a constructor.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 职业提示：许多C#编程工作面试都会问到你如何在构造函数中处理异常。
- en: Use the right exception for the situation
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用合适的异常处理情况
- en: 'When you use the IDE to generate a method, it adds code that looks like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用集成开发环境（IDE）生成一个方法时，它会添加以下代码：
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The **NotImplementedException** is used any time you have an operation or method
    that hasn’t been implemented. It’s a great way to add a placeholder—as soon as
    you see one you know there’s code that you need to write. That’s just one of the
    many exceptions that .NET provides.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**NotImplementedException** 用于任何未实现的操作或方法。它是一种很好的方法来添加占位符 —— 一旦你看到它，你就知道有需要编写的代码。这只是.NET提供的众多异常之一。'
- en: 'Choosing the right exception can make your code easier to read, and make exception
    handling cleaner and more robust. For example, code in a method that validates
    its parameters can throw an ArgumentException, which has an overloaded constructor
    with a parameter to specify which argument caused the problem. Consider the Guy
    class back in [#objectshellipget_orientedexclamation_mar](ch03.html#objectshellipget_orientedexclamation_mar),
    had a ReceiveCash method that checked the `amount` parameter to make sure it was
    receiving a positive amount. This is a good opportunity to throw an ArgumentException:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的异常可以使你的代码更易读，并使异常处理更清晰和更健壮。例如，一个验证其参数的方法中的代码可以抛出ArgumentException，它有一个重载的构造函数，用于指定造成问题的参数。考虑一下Guy类，它在[#objectshellipget_orientedexclamation_mar](ch03.html#objectshellipget_orientedexclamation_mar)中返回，具有一个ReceiveCash方法，检查`amount`参数以确保接收到正数金额。这是一个很好的机会来抛出ArgumentException：
- en: '![Images](assets/pg642-1.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg642-1.png)'
- en: 'Take a minute and look over the list of exceptions that are part of the .NET
    API—you can throw any of them in your code: [https://docs.microsoft.com/en-us/dotnet/api/system.systemexception](https://docs.microsoft.com/en-us/dotnet/api/system.systemexception).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间查看一下.NET API中的异常列表 —— 你可以在代码中抛出其中任何一个：[https://docs.microsoft.com/en-us/dotnet/api/system.systemexception](https://docs.microsoft.com/en-us/dotnet/api/system.systemexception)。
- en: Catch custom exceptions that extend System.Exception
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获扩展自System.Exception的自定义异常
- en: 'Sometimes you want your program to throw an exception because of a special
    condition that could happen when it runs. Let’s go back to the Guy class from
    [#objectshellipget_orientedexclamation_mar](ch03.html#objectshellipget_orientedexclamation_mar).
    Suppose you’re using it in an app that absolutely depended on a Guy always having
    a positive amount of cash. You could add a custom exception that **extends System.Exception**:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你希望程序因为运行时可能发生的特殊情况而抛出异常。让我们回到从[#objectshellipget_orientedexclamation_mar](ch03.html#objectshellipget_orientedexclamation_mar)开始的Guy类。假设你在一个应用程序中使用它，这个应用程序绝对依赖于Guy始终具有正数金额。你可以添加一个扩展自System.Exception的自定义异常：
- en: '![Images](assets/pg642-2.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg642-2.png)'
- en: 'Now you can throw that new exception, and catch it exactly like you’d catch
    any other exception:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以抛出这个新异常，并像处理任何其他异常一样捕获它：
- en: '![Images](assets/pg642-3.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg642-3.png)'
- en: Exception Magnets
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常磁铁
- en: '![Images](assets/Common-11.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/Common-11.png)'
- en: 'Arrange the magnets so the application writes the following output to the console:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 安排磁铁，使应用程序将以下输出写入控制台：
- en: '**when it thaws it throws.**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**当它解冻时它抛出。**'
- en: '[PRE4]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![Images](assets/pg643.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg643.png)'
- en: Exception Magnets Solution
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常磁铁解决方案
- en: '![Images](assets/Common-11.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/Common-11.png)'
- en: 'Arrange the magnets so the application writes the following output to the console:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 安排磁铁，使应用程序将以下输出写入控制台：
- en: '**when it thaws it throws.**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**当它解冻时它抛出。**'
- en: '[PRE5]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![Images](assets/pg644.png)![Images](assets/pg645-2.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg644.png)![图片](assets/pg645-2.png)'
- en: Exception filters help you create precise handlers
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常过滤器帮助你创建精确的处理程序
- en: Let’s say we’re building a game set in classic 1930s mafia gangland, and we’ve
    got a LoanShark class that needs to collect cash from instances of Guy using the
    Guy.GiveCash method, and that handles any OutOfCashException with a good old gangland-style
    lesson.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在建立一个设定在20世纪30年代经典黑手党犯罪地带的游戏，我们有一个LoanShark类需要使用Guy.GiveCash方法从Guy的实例中收集现金，并且使用老式黑手党风格的方式处理任何OutOfCashException。
- en: 'The thing is, every loan shark knows the golden rule: don’t try to collect
    money from the big mob boss. That’s where **exception filters** can come in really
    handy. An exception filter uses the `when` keyword to tell your exception handler
    to catch an exception only under specific conditions.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，每个放高利贷的人都知道一个黄金法则：不要试图向大黑手党老板收钱。这就是**异常过滤器**可以派上用场的地方。异常过滤器使用`when`关键字告诉你的异常处理程序仅在特定条件下捕获异常。
- en: 'Here’s an example of how an exception filter works:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个异常过滤器如何工作的示例：
- en: '![Images](assets/pg646-1.png)![Images](assets/pg646-2.png)![Images](assets/pg646-3.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg646-1.png)![图片](assets/pg646-2.png)![图片](assets/pg646-3.png)'
- en: '**It’s always better to build the most precise exception handlers that we can.**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建尽可能精确的异常处理程序总是更好的。**'
- en: There’s more to exception handling than just printing out a generic error message.
    Sometimes you want to handle different exceptions differently—like how the hex
    dumper handled a FileNotFoundException differently from an UnauthorizedAccessException.
    Planning for exceptions always involves ***unexpected situations***. Sometimes
    those situations can be prevented, sometimes you want to handle them, and sometimes
    you want the exceptions to bubble up. A big lesson to learn here is that there’s
    no “one-size-fits-all” approach to dealing with the unexpected, which is why the
    IDE doesn’t just wrap everything in a `try/catch` block.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理远不止打印通用错误消息那么简单。有时你希望对不同的异常做不同的处理——就像十六进制转储器从FileNotFoundException和UnauthorizedAccessException中不同处理一样。总是要为***意外情况***做计划。有时可以预防这些情况，有时希望处理它们，有时希望异常上升至上层。这里的一个重要教训是，处理意外情况没有一种“一刀切”的方法，这也是为什么IDE不只是在`try/catch`块中包裹所有内容。
- en: Note
  id: totrans-136
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: This is why there are so many classes that inherit from Exception, and why you
    may even want to write your own classes to inherit from Exception.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么有那么多继承自Exception的类，也是为什么你甚至可能想要编写自己的类来继承Exception的原因。
- en: 'The worst catch block EVER: catch-all plus comments'
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 史上最糟糕的catch块：万能加注释
- en: A `catch` block will let your program keep running if you want it to. An exception
    gets thrown, you catch the exception, and instead of shutting down and giving
    an error message, you keep going. But sometimes, that’s not such a good thing.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，`catch`块会让你的程序继续运行。异常被抛出，你捕捉异常，而不是关闭并给出错误消息，你继续进行。但有时候，这并不是件好事。
- en: Take a look at this `Calculator` class, which seems to be acting funny all the
    time. What’s going on?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个`Calculator`类，它似乎总是表现得很奇怪。发生了什么？
- en: '![Images](assets/pg648.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg648.png)'
- en: You should handle your exceptions, not bury them
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应该处理你的异常，而不是掩埋它们
- en: Just because you can keep your program running doesn’t mean you’ve *handled*
    your exceptions. In the code above, the calculator won’t crash...at least, not
    in the Divide method. What if some other code calls that method, and tries to
    print the results? If the divisor was zero, then the method probably returned
    an incorrect (and unexpected) value.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅因为你可以让程序继续运行，并不意味着你已经*处理*了你的异常。在上面的代码中，计算器不会崩溃……至少在Divide方法中不会。如果其他代码调用了该方法，并尝试打印结果呢？如果除数为零，那么该方法可能返回一个不正确（且意外的）值。
- en: Instead of just adding a comment and burying the exception, you need to **handle
    the exception**. If you’re not able to handle the problem, ***don’t leave empty
    or commented `catch` blocks!*** That just makes it harder for someone else to
    track down what’s going on. It’s better to let the program continue to throw exceptions,
    because then it’s easier to figure out what’s going wrong.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 不要仅仅添加评论并隐藏异常，你需要**处理异常**。如果你无法处理问题，***不要留下空的或注释掉的`catch`块！***那只会让其他人更难追踪问题所在。最好让程序继续抛出异常，因为这样更容易找出问题所在。
- en: Note
  id: totrans-145
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Remember, when your code doesn’t handle an exception, the exception bubbles
    up the call stack. Letting an exception bubble up is a perfectly valid way of
    dealing with an exception, and in some cases it makes more sense to do that than
    to use an empty catch block to bury the exception.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当你的代码无法处理异常时，异常会沿调用堆栈向上冒泡。让异常冒泡是一种完全有效的处理异常的方式，在某些情况下，这比使用空的catch块来隐藏异常更合理。
- en: Temporary solutions are OK (temporarily)
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 临时解决方案是可以接受的（暂时的）
- en: Sometimes you find a problem, and know it’s a problem, but aren’t sure what
    to do about it. In these cases, you might want to log the problem and note what’s
    going on. That’s not as good as handling the exception, but it’s better than doing
    nothing.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你会发现问题，并且知道这是一个问题，但不确定该怎么办。在这些情况下，你可能希望记录问题并注明正在发生的情况。虽然这不如处理异常好，但比什么都不做要好。
- en: 'Here’s a temporary solution to the calculator problem:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是计算器问题的临时解决方案：
- en: Note
  id: totrans-150
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '...but in real life, “temporary” solutions have a nasty habit of becoming permanent.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '...但在现实生活中，“临时”解决方案往往会变成永久性解决方案的不良习惯。'
- en: Note
  id: totrans-152
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Take a minute and think about this `catch` block. What happens if the `StreamWriter`
    can’t write to the C:\Logs\ folder? You can nest another `try/catch` block inside
    it to make it less risky. Can you think of a better way to do this?**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**花点时间思考一下这个`catch`块。如果`StreamWriter`无法写入到C:\Logs\文件夹会发生什么？你可以嵌套另一个`try/catch`块来减少风险。你能想到更好的解决方案吗？**'
- en: '![Images](assets/pg649-1.png)![Images](assets/pg649-2.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/pg649-1.png)![Images](assets/pg649-2.png)'
- en: '**Handling exceptions doesn’t always mean the same thing as FIXING exceptions.**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**处理异常并不总是意味着修复异常。**'
- en: It’s never good to have your program bomb out. It’s way worse to have no idea
    why it’s crashing or what it’s doing to users’ data. That’s why you need to be
    sure that you’re always dealing with the errors you can predict and logging the
    ones you can’t. While logs can be useful for tracking down problems, preventing
    those problems in the first place is a better, more permanent solution.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让程序崩溃永远不是好事。更糟糕的是，如果不知道程序为何崩溃或它对用户数据造成了什么影响。这就是为什么你需要确保始终处理你能预测到的错误，并记录你无法预测到的错误。虽然日志对于追踪问题很有用，但在首次出现问题之前预防问题是更好、更永久的解决方案。
