- en: Chapter 2\. Basic Coding in C#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章\. C# 基本编码
- en: All programming languages have to provide certain capabilities. It must be possible
    to express the calculations and operations that our code should perform. Programs
    need to be able to make decisions based on their input. Sometimes we will need
    to perform tasks repeatedly. These fundamental features are the very stuff of
    programming, and this chapter will show how these things work in C#.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 所有编程语言都必须提供一定的功能。我们必须能够表达代码应执行的计算和操作。程序需要能够根据输入做出决策。有时我们需要重复执行任务。这些基本功能是编程的基础，本章将展示这些功能在
    C# 中的工作原理。
- en: Depending on your background, some of this chapter’s content may seem very familiar.
    C# is said to be from the “C family” of languages. C is a hugely influential programming
    language, and numerous languages have borrowed much of its syntax. There are direct
    descendants, such as C++ and Objective-C. There are also more distantly related
    languages, including Java, JavaScript, and C# itself, that have no compatibility
    with C but that still copy many aspects of its syntax. If you are familiar with
    any of these languages, you will recognize many of the language features we are
    about to explore.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的背景，本章的部分内容可能非常熟悉。C# 被称为“C家族”语言的一员。C 是一种极具影响力的编程语言，许多语言借鉴了其语法。有直接的后继者，如 C++
    和 Objective-C。还有更远的关联语言，包括 Java、JavaScript 和 C# 本身，它们没有与 C 的兼容性，但仍然复制了其语法的许多方面。如果你熟悉这些语言中的任何一种，你将会认识到我们即将探讨的许多语言特性。
- en: 'We saw the basic elements of a program in [Chapter 1](ch01.xhtml#ch_introducing_csharp).
    In this chapter, we will be looking just at code inside methods. As you’ve seen,
    C# requires a certain amount of structure: code is made up of statements that
    live inside a method, which belongs to a type, which is typically inside a namespace,
    all inside a file that is part of a project, typically contained by a solution.
    (In the special case of a program’s entry point, the containing method and type
    might be hidden thanks to C# 10.0’s clutter reduction features, but they’re visible
    in most files.) For clarity, most of the examples in this chapter will show the
    code of interest in isolation, as in [Example 2-1](#codecomma_and_nothing_but_the_code).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第 1 章](ch01.xhtml#ch_introducing_csharp)中看到了程序的基本要素。在本章中，我们将仅关注方法内的代码。正如你所见，C#
    需要一定的结构：代码由位于方法内的语句组成，该方法属于一个类型，通常位于一个命名空间内，所有这些都在一个项目的文件中，通常包含在一个解决方案中。（在程序入口点的特殊情况下，由于
    C# 10.0 的简化特性，包含的方法和类型可能会隐藏起来，但在大多数文件中它们是可见的。）为了清晰起见，本章的大多数示例将单独显示感兴趣的代码，例如[示例
    2-1](#codecomma_and_nothing_but_the_code)。
- en: Example 2-1\. The code and nothing but the code
  id: totrans-4
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-1\. 代码及其余无余地
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: And although C# 10.0 will accept that shorter example as the entirety of the
    program, any program larger than a single file (i.e., almost any useful program)
    will need to include the other elements explicitly. So unless I say otherwise,
    this kind of extract is shorthand for showing the code in context inside a suitably
    structured file. Examples such as [Example 2-1](#codecomma_and_nothing_but_the_code)
    are equivalent to something more like [Example 2-2](#whole_code).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 C# 10.0 接受更短的示例作为程序的全部内容，但任何大于单个文件的程序（即几乎所有有用的程序）都需要明确包含其他元素。因此，除非我另有说明，这种摘录是为了在合适结构化的文件内显示上下文中的代码。例如，像[示例
    2-1](#codecomma_and_nothing_but_the_code)这样的示例相当于更像[示例 2-2](#whole_code)。
- en: Example 2-2\. The whole code
  id: totrans-7
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-2\. 整段代码
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Although I’ll be introducing fundamental elements of the language in this section,
    this book is for people who are already familiar with at least one programming
    language, so I’ll be relatively brief with the most ordinary features of the language
    and will go into more detail on those aspects that are particular to C#.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我会在本节介绍语言的基本要素，但这本书是给那些已经熟悉至少一种编程语言的人看的，所以我会相对简短地介绍语言的最常见特性，并会更详细地讲解那些特别适用于
    C# 的方面。
- en: Local Variables
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 局部变量
- en: 'The inevitable “Hello, World!” example is missing a vital element: it doesn’t
    really deal with information. Useful programs normally fetch, process, and produce
    data, so the ability to define and identify it is one of the most important features
    of a language. Like most languages, C# lets you define *local variables*, which
    are named elements inside a method that each hold a piece of information.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 不可避免的“Hello, World!”示例缺少一个重要元素：它实际上并未处理信息。有用的程序通常会获取、处理和生成数据，因此定义和标识数据的能力是语言中最重要的功能之一。与大多数语言一样，C#
    允许您定义*本地变量*，这些是方法内的命名元素，每个都包含一部分信息。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In the C# specification, the term *variable* can refer to local variables but
    also to fields in objects and array elements. This section is concerned entirely
    with local variables, but it gets tiring to keep reading the *local* prefix. So,
    from now on in this section, *variable* means a local variable.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 规范中，术语*变量*可以指本地变量，也可以指对象中的字段和数组元素。本节完全涉及本地变量，但是继续阅读*本地*前缀会有点累。因此，在本节中，*变量*指的是本地变量。
- en: C# is a *statically typed* language, which is to say that any element of code
    that represents or produces information, such as a variable or an expression,
    has a data type determined at compile time. This is different than *dynamically
    typed* languages, such as JavaScript, in which types are determined at runtime.^([1](ch02.xhtml#fn05))
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: C# 是一种*静态类型*语言，这意味着代码中任何代表或产生信息的元素（如变量或表达式）在编译时都有确定的数据类型。这与*动态类型*语言（如 JavaScript）不同，后者在运行时确定类型。^([1](ch02.xhtml#fn05))
- en: The easiest way to see C#’s static typing in action is with simple variable
    declarations, such as the ones in [Example 2-3](#variable_declarations). Each
    of these starts with the data type—the first two variables are of type `string`,
    followed by two `int` variables. These types represent text strings and 32-bit
    signed integers, respectively.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 看到 C# 的静态类型在简单变量声明中的实际运行方式最简单的方法是，例如在[示例 2-3](#variable_declarations)中的简单变量声明。每个变量声明以数据类型开头，前两个变量是`string`类型，接着两个是`int`类型。这些类型分别表示文本字符串和32位有符号整数。
- en: Example 2-3\. Variable declarations
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-3\. 变量声明
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The data type is followed immediately by the variable’s name. The name must
    begin with either a letter or an underscore, which can be followed by any combination
    of letters, decimal digits, and underscores. (At least, those are the options
    if you stick to ASCII. C# supports Unicode, so if you save your file in UTF-8
    or UTF-16 format, anything after the first character in an identifier can be any
    of the characters described in the “Identifier and Pattern Syntax” annex of the
    Unicode specification. This includes various accents, diacritics, and numerous
    punctuation marks but only characters intended for use *within* words—characters
    that Unicode identifies as being intended for *separating* words cannot be used.)
    These same rules determine what constitutes a legal identifier for any user-defined
    entity in C#, such as a class or a method.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型紧跟变量名之后。变量名必须以字母或下划线开头，后面可以跟任意字母、十进制数字和下划线的组合。（至少在 ASCII 码情况下是这样。C# 支持 Unicode，因此如果您以
    UTF-8 或 UTF-16 格式保存文件，标识符中第一个字符后面的字符可以是 Unicode 规范“标识符和模式语法”附录中描述的任何字符。这包括各种重音符号、变音符号和许多标点符号，但只有
    Unicode 标识为用于*单词内部*的字符可以用于*分隔*单词的字符不能用。）这些规则同样适用于 C# 中任何用户定义实体的合法标识符，如类或方法。
- en: '[Example 2-3](#variable_declarations) shows that there are a couple of forms
    of variable declarations. The first three variables include an *initializer*,
    which provides the variable’s initial value, but as the final variable shows,
    this is optional. That’s because you can assign new values into variables at any
    point. [Example 2-4](#assigning_values_to_previously_declared) continues on from
    [Example 2-3](#variable_declarations) and shows that you can assign a new value
    into a variable regardless of whether it had an initial value.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 2-3](#variable_declarations)显示了几种变量声明的形式。前三个变量包括一个*初始化器*，提供变量的初始值，但是如最后一个变量所示，这是可选的。这是因为您可以在任何时候将新值赋给变量。[示例 2-4](#assigning_values_to_previously_declared)继续自[示例 2-3](#variable_declarations)，展示了不管变量是否有初始值，都可以向变量赋新值。'
- en: Example 2-4\. Assigning values to previously declared variables
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-4\. 为先前声明的变量赋值
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Because variables have a static type, the compiler will reject attempts to assign
    the wrong kind of data. So if we were to follow on from [Example 2-3](#variable_declarations)
    with the code in [Example 2-5](#error_the_wrong_type), the compiler would complain.
    It knows that the variable called `theAnswer` has a type of `int`, which is a
    numeric type, so it will report an error if we attempt to assign a text string
    into it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因为变量具有静态类型，所以编译器将拒绝尝试分配错误类型的数据。因此，如果我们从[示例2-3](#variable_declarations)继续使用[示例2-5](#error_the_wrong_type)中的代码，编译器将会抱怨。它知道名为`theAnswer`的变量具有`int`类型，这是一个数值类型，因此如果我们尝试将文本字符串分配给它，它将报告一个错误。
- en: 'Example 2-5\. An error: the wrong type'
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例2-5。一个错误：错误的类型
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You’d be allowed to do this in dynamic languages such as JavaScript, because
    in those languages, a variable doesn’t have its own type—all that matters is the
    type of the value it contains, and that can change as the code runs. It’s possible
    to do something similar in C# by declaring a variable with type `dynamic` or `object`
    (which I’ll describe later in [“Dynamic”](#dynamic) and [“Object”](#object)).
    However, the most common practice in C# is for variables to have a more specific
    type.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript等动态语言中，您允许这样做，因为在这些语言中，变量没有自己的类型 - 所有的一切都取决于它包含的值的类型，并且随着代码运行，它可以改变。在C#中，可以通过声明具有类型`dynamic`或`object`的变量来执行类似的操作（稍后在[“动态”](#dynamic)和[“对象”](#object)中描述）。但是，在C#中最常见的做法是使变量具有更具体的类型。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The static type doesn’t always provide a complete picture, thanks to inheritance.
    I’ll be discussing this in [Chapter 6](ch06.xhtml#ch_inheritance), but for now,
    it’s enough to know that some types are open to extension through inheritance,
    and if a variable uses such a type, then it’s possible for it to refer to some
    object of a type derived from the variable’s static type. Interfaces, described
    in [Chapter 3](ch03.xhtml#ch_types), provide a similar kind of flexibility. However,
    the static type always determines what operations you are allowed to perform on
    the variable. If you want to use additional members specific to some derived type,
    you won’t be able to do so through a variable of the base type.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型并不能始终提供完整的图片，多亏了继承。我会在[第6章](ch06.xhtml#ch_inheritance)中讨论这个问题，但现在知道一些类型可以通过继承来扩展就足够了，如果一个变量使用了这样的类型，那么它可能引用从变量的静态类型派生的类型的某些对象。接口，在[第3章](ch03.xhtml#ch_types)中描述，提供了一种类似的灵活性。但是，静态类型总是决定您可以对变量执行哪些操作。如果您想使用一些特定派生类型的附加成员，您将无法通过基础类型的变量来执行。
- en: You don’t have to state the variable type explicitly. You can let the compiler
    work it out for you by using the keyword `var` in place of the data type. [Example 2-6](#implicit_variable_types_with_the_var_key)
    shows the first three variable declarations from [Example 2-3](#variable_declarations)
    but using `var` instead of explicit data types.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必明确声明变量类型。您可以使用关键字`var`代替数据类型，让编译器为您完成。[示例2-6](#implicit_variable_types_with_the_var_key)显示了来自[示例2-3](#variable_declarations)的前三个变量声明，但使用`var`代替显式数据类型。
- en: Example 2-6\. Implicit variable types with the `var` keyword
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例2-6。使用`var`关键字的隐式变量类型
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code often misleads people who know some JavaScript, because that also
    has a `var` keyword that you can use in a similar-looking way. But `var` does
    not work the same way in C# as in JavaScript: these variables are still all statically
    typed. All that’s changed is that we haven’t said what the type is—we’re letting
    the compiler deduce it for us. It looks at the initializers and can see that the
    first two variables are strings, whereas the third is an integer. (That’s why
    I left out the fourth variable from [Example 2-3](#variable_declarations), `andAnotherThing`.
    That doesn’t have an initializer, so the compiler would have no way of inferring
    its type. If you try to use the `var` keyword without an initializer, you’ll get
    a compiler error.)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码经常会误导那些了解一些JavaScript的人，因为JavaScript中也有一个`var`关键字，可以以类似的方式使用。但是`var`在C#中的工作方式与JavaScript不同：这些变量仍然都是静态类型的。改变的只是我们没有说类型是什么
    - 我们让编译器为我们推断。它查看初始化程序，并可以看到前两个变量是字符串，而第三个是整数。（这就是为什么我从[示例2-3](#variable_declarations)中省略了第四个变量`andAnotherThing`。它没有初始化程序，所以编译器无法推断其类型。如果尝试在没有初始化程序的情况下使用`var`关键字，会收到编译器错误。）
- en: You can demonstrate that variables declared with `var` are statically typed
    by attempting to assign something of a different type into them. We could repeat
    the same thing we tried in [Example 2-5](#error_the_wrong_type) but this time
    with a `var`-style variable. [Example 2-7](#error_the_wrong_type_left_parenthesisaga)
    does this, and it will produce exactly the same compiler error, because it’s the
    same mistake—we’re trying to assign a text string into a variable of an incompatible
    type. That variable, `theAnswer`, has a type of `int` here, even though we didn’t
    say so explicitly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以证明使用 `var` 声明的变量是静态类型的，通过尝试将不同类型的东西分配给它们。我们可以重复在 [示例 2-5](#error_the_wrong_type)
    中尝试的相同事情，但这次使用 `var` 样式的变量。[示例 2-7](#error_the_wrong_type_left_parenthesisaga)
    这样做，它会产生完全相同的编译器错误，因为这是相同的错误——我们试图将文本字符串分配给不兼容类型的变量。这里的变量 `theAnswer` 在这里的类型是
    `int`，尽管我们没有明确说明。
- en: 'Example 2-7\. An error: the wrong type (again)'
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-7\. 错误：错误的类型（再次）
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Opinion is divided on how and when to use the `var` keyword, as the following
    sidebar [“To var, or Not to var?”](#to_varcomma_or_not_to_varquestion_mark) describes.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于何时以及如何使用 `var` 关键字，意见分歧很大，后面的边栏 [“To var, or Not to var?”](#to_varcomma_or_not_to_varquestion_mark)
    描述了这一点。
- en: One last thing worth knowing about declarations is that you can declare and
    optionally initialize multiple variables in a single line. If you want multiple
    variables of the same type, this may reduce clutter in your code. [Example 2-8](#multiple_variables_in_a_single_declarati)
    declares three variables of the same type in a single declaration and initializes
    two of them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 声明的最后一个值得知道的是，你可以在一行中声明并选择性地初始化多个变量。如果你需要多个相同类型的变量，这可能会减少代码的混乱。在 [示例 2-8](#multiple_variables_in_a_single_declarati)
    中，它声明了三个相同类型的变量，并初始化了其中的两个。
- en: Example 2-8\. Multiple variables in a single declaration
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-8\. 单次声明中的多个变量
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Regardless of how you declare it, a variable holds some piece of information
    of a particular type, and the compiler prevents us from putting data of an incompatible
    type into that variable. Variables are useful only because we can refer back to
    them later in our code. [Example 2-9](#using_variables) starts with the variable
    declarations we saw in earlier examples, then goes on to use the values of those
    variables to initialize some more variables, and then displays the results.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你如何声明它，变量都保存特定类型的某些信息，并且编译器会阻止我们将不兼容类型的数据放入该变量中。变量之所以有用，仅仅是因为我们稍后可以在代码中引用它们。[示例 2-9](#using_variables)
    从我们之前看到的变量声明开始，然后继续使用这些变量的值来初始化更多变量，并显示结果。
- en: Example 2-9\. Using variables
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-9\. 使用变量
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'By the way, this code relies on the fact that C# defines a couple of meanings
    for the `+` operator when it’s used with strings. First, when you “add” two strings
    together, it concatenates them. Second, when you “add” something other than a
    string to the end of a string (as the initializer for `answerText` does—it adds
    `theAnswer`, which is a number), C# generates code that converts the value to
    a string before appending it. So [Example 2-9](#using_variables) produces this
    output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，这段代码依赖于 C# 对 `+` 运算符的几种含义的定义，当它与字符串一起使用时。首先，当你将两个字符串“相加”在一起时，它们会连接起来。其次，当你将不是字符串的东西添加到字符串的末尾（正如
    `answerText` 的初始化器所做的那样——它添加了一个数字 `theAnswer`），C# 会生成将值转换为字符串然后附加它的代码。因此，[示例 2-9](#using_variables)
    会产生如下输出：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In this book, text longer than 80 characters is wrapped across multiple lines
    to fit the page. If you try these examples, they will look different if your console
    windows are configured for a different width.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，超过 80 个字符的文本会被换行以适应页面。如果您尝试这些示例，如果您的控制台窗口配置为不同的宽度，则它们将看起来不同。
- en: When you use a variable, its value is whatever you last assigned to it. If you
    attempt to use a variable before you have assigned a value, as [Example 2-10](#error_using_an_unassigned_variable)
    does, the C# compiler will report an error.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用一个变量时，它的值就是你最后分配给它的值。如果你尝试在分配值之前使用一个变量，正如 [示例 2-10](#error_using_an_unassigned_variable)
    所做的那样，C# 编译器将报告一个错误。
- en: 'Example 2-10\. Error: using an unassigned variable'
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-10\. 错误：使用未赋值的变量
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Compiling that produces this error for the second line:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，第二行会产生以下错误：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The compiler uses a slightly pessimistic system (which it calls the *definite
    assignment* rules) for determining whether a variable has a value yet. It’s not
    possible to create an algorithm that can determine such things for certain in
    every possible situation.^([2](ch02.xhtml#fn06)) Since the compiler has to err
    on the side of caution, there are some situations in which the variable will have
    a value by the time the offending code runs, and yet the compiler still complains.
    The solution is to write an initializer so that the variable always contains something,
    perhaps using `0` for numeric values and `false` for Boolean variables. In [Chapter 3](ch03.xhtml#ch_types),
    I’ll introduce reference types, and as the name suggests, a variable of such a
    type can hold a reference to an instance of the type. If you need to initialize
    such a variable before you’ve got something for it to refer to, you can use the
    keyword `null`, a special value signifying a reference to nothing. Alternatively,
    you can initialize a variable of any type with the keyword `default`, which denotes
    a value of zero, `false`, or `null`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器使用一种稍微悲观的系统（称为*明确的赋值*规则）来确定变量是否已经有值。在每种可能的情况下都无法创建能够确定这些事情的算法。^([2](ch02.xhtml#fn06))
    由于编译器必须谨慎处理，有些情况下变量在执行相关代码时已经有值，但编译器仍会抱怨。解决方案是编写一个初始化器，以便变量始终包含某些内容，例如对于数值使用`0`，对于布尔变量使用`false`。在[第三章](ch03.xhtml#ch_types)中，我将介绍引用类型，顾名思义，这种类型的变量可以保存对类型实例的引用。如果需要在有东西可以引用之前初始化这样的变量，可以使用关键字`null`，表示一个指向无内容的引用。或者，您可以使用关键字`default`来初始化任何类型的变量，它表示零、`false`或`null`的值。
- en: The definite assignment rules determine the parts of your code in which the
    compiler considers a variable to contain a valid value and will therefore let
    you read from it. Writing into a variable is less restricted, but as you might
    expect, any given variable is accessible only from certain parts of the code.
    Let’s look at the rules that govern this.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 明确的赋值规则决定了编译器认为变量包含有效值的代码部分，并因此允许您从中读取。写入变量的操作不受限制，但正如您可能预料的那样，任何给定变量只能从代码的某些部分访问。让我们看看控制这些规则的细则。
- en: Scope
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范围
- en: 'A variable’s *scope* is the range of code in which you can refer to that variable
    by its name. Variables are not the only things with scope. Methods, properties,
    types, and, in fact, anything with a name all have scope. These require broadening
    the definition of scope: it’s the parts of your code where you can refer to the
    entity by its name without needing additional qualification. When I write `Console.WriteLine`,
    I am referring to the method by its name (`WriteLine`), but I need to qualify
    it with a class name (`Console`), because the method is not in scope. But with
    a local variable, scope is absolute: either it’s accessible without qualification,
    or it’s not accessible at all.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的*作用域*是您可以通过其名称引用该变量的代码范围。变量并非唯一具有作用域的事物。方法、属性、类型，实际上，所有具有名称的东西都有作用域。这些需要扩展作用域的定义：它是您可以在代码中通过名称引用实体而无需额外限定的部分。当我写`Console.WriteLine`时，我是通过其名称(`WriteLine`)引用方法，但我需要使用类名(`Console`)加以限定，因为该方法不在作用域内。但对于局部变量，作用域是绝对的：要么可以无需限定就可以访问，要么根本无法访问。
- en: Broadly speaking, a variable’s scope starts at its declaration and finishes
    at the end of its containing *block*. (Some statements, such as loops, complicate
    this by putting variable declarations ahead of the block in which they are in
    scope.) A block is a region of code delimited by a pair of braces ({}). A method
    body is a block, so a variable defined in one method is not visible in a separate
    method, because it is out of scope. If you attempt to compile [Example 2-11](#error_out_of_scope),
    you’ll get an error complaining that `The name 'thisWillNotWork' does not exist
    in the current context`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 广义上讲，变量的作用域从其声明开始，到其所在的*块*结束。（某些语句，如循环，通过将变量声明放在其所在作用域之前来使此过程复杂化。）块是由一对大括号（{}）界定的代码区域。方法体就是一个块，因此在一个方法中定义的变量在另一个方法中是不可见的，因为它超出了作用域。如果尝试编译[示例
    2-11](#error_out_of_scope)，将会收到一个错误，指出`当前上下文中不存在名称'thisWillNotWork'`。
- en: 'Example 2-11\. Error: out of scope'
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 2-11\. 错误：超出范围
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Methods often contain nested blocks, particularly when you work with the loop
    and flow control constructs we’ll be looking at later in this chapter. At the
    point where a nested block starts, everything that is in scope in the outer block
    continues to be in scope inside that nested block. [Example 2-12](#variable_declared_outside_blockcomma_use)
    declares a variable called `someValue` and then introduces a nested block as part
    of an `if` statement. The code inside this block is able to access that variable
    declared in the containing block.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 方法通常包含嵌套块，特别是当你使用本章稍后将介绍的循环和流控制结构时。在嵌套块开始的地方，外部块中的所有作用域继续在该嵌套块内部有效。[示例 2-12](#variable_declared_outside_blockcomma_use)
    声明了一个名为 `someValue` 的变量，然后在 `if` 语句的一部分中引入了一个嵌套块。此块内的代码能够访问在包含块中声明的该变量。
- en: Example 2-12\. Variable declared outside block, used within block
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-12\. 在块外声明变量，在块内使用
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The converse is not true. If you declare a variable in a nested block, its scope
    does not extend outside of that block. So [Example 2-13](#error_trying_to_use_a_variable_not_in_sc)
    will fail to compile, because the `willNotWork` variable is only in scope within
    the nested block. The final line of code will produce a compiler error because
    it tries to use that variable outside of that block.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 逆否命题并不成立。如果你在嵌套块中声明一个变量，其作用域不会延伸到该块外部。因此，[示例 2-13](#error_trying_to_use_a_variable_not_in_sc)
    编译将失败，因为 `willNotWork` 变量只在嵌套块内部有效。由于试图在该块外部使用该变量，最后一行代码将产生编译器错误。
- en: 'Example 2-13\. Error: trying to use a variable not in scope'
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-13\. 错误：尝试使用不在作用域内的变量
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This might seem fairly straightforward, but things get a bit more complex when
    it comes to potential naming collisions. C# sometimes catches people by surprise
    here.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来相当简单，但当涉及到潜在的命名冲突时情况会变得更加复杂。在这里，C#有时会让人感到意外。
- en: Variable Name Ambiguity
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量名称的歧义
- en: Consider the code in [Example 2-14](#error_surprising_name_collision). This
    declares a variable called `anotherValue` inside a nested block. As you know,
    that variable is only in scope to the end of that nested block. After that block
    ends, we try to declare another variable with the same name.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 [示例 2-14](#error_surprising_name_collision) 中的代码。这里声明了一个名为 `anotherValue`
    的变量在一个嵌套块内。正如你所知，该变量仅在该嵌套块的末尾处于作用域内。在该块结束后，我们尝试声明另一个同名变量。
- en: 'Example 2-14\. Error: surprising name collision'
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-14\. 错误：令人惊讶的名称冲突
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This causes a compiler error on the first of the lines to declare `anotherValue`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了在第一行声明 `anotherValue` 时的编译器错误：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This seems odd. At the final line, the supposedly conflicting earlier declaration
    is not in scope, because we’re outside of the nested block in which it was declared.
    Furthermore, the second declaration is not in scope within that nested block,
    because the declaration comes after the block. The scopes do not overlap, but
    despite this, we’re having problems with C#’s rules for avoiding name conflicts.
    To see why this example fails, we first need to look at a less surprising example.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎有些奇怪。在最后一行，所谓的冲突早期声明已经不在作用域内，因为我们已经超出了它所声明的嵌套块。此外，第二个声明在该嵌套块内也不在作用域内，因为声明发生在块之后。尽管作用域不重叠，但尽管如此，我们仍然在处理C#避免名称冲突规则时遇到问题。要了解为什么此示例失败，首先需要看一个不那么令人意外的示例。
- en: C# tries to prevent ambiguity by disallowing code where one name might refer
    to more than one thing. [Example 2-15](#error_hiding_a_variable) shows the sort
    of problem it aims to avoid. Here we’ve got a variable called `errorCount`, and
    the code starts to modify this as it progresses,^([3](ch02.xhtml#idm45884862601824))
    but partway through, it introduces a new variable in a nested block, also called
    `errorCount`. It is possible to imagine a language that allowed this—you could
    have a rule that says that when multiple items of the same name are in scope,
    you just pick the one whose declaration happened last.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: C# 试图通过不允许一个名称可能指代多个东西的代码来避免歧义。[示例 2-15](#error_hiding_a_variable) 展示了它旨在避免的问题类型。这里我们有一个名为
    `errorCount` 的变量，并且代码在进展过程中开始修改它，^([3](ch02.xhtml#idm45884862601824)) 但在中途，它在一个嵌套块中引入了一个新的同名变量，也叫
    `errorCount`。可以想象一种允许这种情况的语言——你可以有一个规则，即当多个同名项处于作用域内时，只选择最后声明的那个。
- en: 'Example 2-15\. Error: hiding a variable'
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-15\. 错误：隐藏一个变量
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: C# chooses not to allow this, because code that did this would be easy to misunderstand.
    This is an artificially short method because it’s a contrived example in a book,
    making it easy to see the duplicate names, but if the code were a bit longer,
    it would be very easy to miss the nested variable declaration. Then, we might
    not realize that `errorCount` refers to something different at the end of the
    method than it did earlier on. C# simply disallows this to avoid misunderstanding.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: C#选择不允许这种情况，因为这样的代码很容易误解。这是一个人为缩短的方法，因为它是书中的一个假设示例，所以很容易看到重复的名称，但如果代码再长一点，很容易忽略嵌套变量声明。那么，在方法结束时，我们可能意识不到`errorCount`的含义与之前不同。C#简单地禁止这种情况以避免误解。
- en: But why does [Example 2-14](#error_surprising_name_collision) fail? The scopes
    of the two variables don’t overlap. Well, it turns out that the rule that outlaws
    [Example 2-15](#error_hiding_a_variable) is not based on scopes. It is based on
    a subtly different concept called a *declaration space*. A declaration space is
    a region of code in which a single name must not refer to two different entities.
    Each method introduces a declaration space for variables. Nested blocks also introduce
    declaration spaces, and it is illegal for a nested declaration space to declare
    a variable with the same name as one in its parent’s declaration space. And that’s
    the rule we’ve contravened here—the outermost declaration space in [Example 2-15](#error_hiding_a_variable)
    contains a variable named `errorCount`, and a nested block’s declaration space
    tries to introduce another variable of the same name.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 但是为什么[示例 2-14](#error_surprising_name_collision)会失败呢？这两个变量的作用域并不重叠。嗯，事实证明，禁止[示例 2-15](#error_hiding_a_variable)的规则并不基于作用域。它基于一个微妙不同的概念，叫做*声明空间*。声明空间是代码中的一个区域，在这个区域中，一个名称不能指代两个不同的实体。每个方法为变量引入一个声明空间。嵌套块也会引入声明空间，而在嵌套声明空间中声明与其父声明空间中同名变量是非法的。这就是我们在这里违反的规则——[示例 2-15](#error_hiding_a_variable)中最外层的声明空间包含一个名为`errorCount`的变量，而嵌套块的声明空间试图引入另一个同名变量。
- en: If that all seems a bit dry or arbitrary, it may be helpful to know *why* there’s
    a whole separate set of rules for name collisions instead of basing it on scopes.
    The intent of the declaration space rules is that it mostly shouldn’t matter where
    you put the declaration. If you were to move all of the variable declarations
    in a block to the start of that block—and some organizations have coding standards
    that mandate this sort of layout—the idea of these rules is that this shouldn’t
    change what the code means. This wouldn’t be possible if [Example 2-15](#error_hiding_a_variable)
    were legal. And this explains why [Example 2-14](#error_surprising_name_collision)
    is illegal. Although the scopes don’t overlap, they would if you moved all variable
    declarations to the tops of their containing blocks.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一切看起来有点枯燥或武断，了解*为什么*有一个完全独立的名称冲突规则集合可能会有所帮助，而不是基于作用域。声明空间规则的意图大部分情况下不应受到声明放置位置的影响。如果你将一个块中的所有变量声明移动到该块的开头——某些组织有规范要求这种布局——这些规则的理念就是这不应该改变代码的含义。如果[示例 2-15](#error_hiding_a_variable)是合法的，这将是不可能的。这也解释了为什么[示例 2-14](#error_surprising_name_collision)是非法的。虽然作用域不重叠，但如果你将所有变量声明移动到包含块的顶部，它们将会重叠。
- en: Local Variable Instances
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局部变量实例
- en: 'Variables are features of the source code, so each particular variable has
    a distinct identity: it is declared in exactly one place in the source code and
    goes out of scope at exactly one well-defined place. However, that doesn’t mean
    that it corresponds to a single storage location in memory. It is possible for
    multiple invocations of a single method to be in progress simultaneously, through
    recursion, multithreading, or asynchronous execution.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是源代码的特征，因此每个特定变量都有一个独特的身份：它在源代码中只声明一次，并且在一个明确定义的地方超出作用域。但这并不意味着它对应于内存中的单个存储位置。通过递归、多线程或异步执行，可能会同时存在单个方法的多个调用。
- en: Each time a method runs, it gets a distinct set of storage locations to hold
    the local variables’ values. This enables multiple threads to execute the same
    method simultaneously without problems, because each has its own set of local
    variables. Likewise, in recursive code, each nested call gets its own set of locals
    that will not interfere with any of its callers. The same goes for multiple concurrent
    invocations of a method. To be strictly accurate, each execution of a particular
    *scope* gets its own set of variables. This distinction matters when you use anonymous
    functions, described in [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events). As
    an optimization, C# reuses storage locations when it can, so it will only allocate
    new memory for each scope’s execution when it really has to. (For example, it
    won’t allocate new memory for variables declared in the body of a loop for each
    iteration unless you put it into a situation where it has no choice.) But the
    effect is as though it allocated new space each time.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每次方法运行时，它都会获得一组独特的存储位置来保存局部变量的值。这使得多个线程可以同时执行同一个方法而不会出现问题，因为每个线程都有自己的局部变量集合。同样，在递归代码中，每个嵌套调用都会获得自己的局部变量集合，不会干扰任何调用它的方法。对于同一方法的多个并发调用也是如此。严格来说，每个特定*作用域*的执行都有自己的变量集合。当您使用匿名函数时，这一区别很重要，详见[第9章](ch09.xhtml#ch_delegates_lambdas_events)中的描述。作为优化，C#
    在可能的情况下会重用存储位置，因此只有在真正需要时才会为每个作用域的执行分配新内存。（例如，除非您将其置于必须这样做的情况中，否则不会为循环体内声明的变量每次迭代分配新内存。）但其效果就像每次都分配了新空间一样。
- en: Be aware that the C# compiler does not make any particular guarantee about where
    variables live (except for some special cases, as we’ll see in [Chapter 18](ch18.xhtml#ch_memory_efficiency)).
    They might well live on the stack, but sometimes they don’t. When we look at anonymous
    functions in later chapters, you’ll see that variables sometimes need to outlive
    the method that declares them, because they remain in scope for nested methods
    that will run as callbacks after the containing method has returned.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，C# 编译器对于变量存放位置并没有特别的保证（除了一些特殊情况，我们将在[第18章](ch18.xhtml#ch_memory_efficiency)中看到）。它们可能存在于堆栈上，但有时并非如此。当我们在后面的章节中看匿名函数时，您将看到有时变量需要超出声明它们的方法的生存期，因为它们在嵌套方法中仍处于作用域中，这些嵌套方法将在包含方法返回后作为回调运行。
- en: By the way, before we move on, be aware that just as variables are not the only
    things to have scope, they are also not the only things to which declaration space
    rules apply. Other language features that we’ll be looking at later, including
    classes, methods, and properties, also have scoping and name uniqueness rules.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，在我们继续之前，请注意，变量不是唯一具有作用域的事物，还有适用于声明空间的规则的其他语言特性，我们稍后会看到，包括类、方法和属性等。
- en: Statements and Expressions
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语句和表达式
- en: Variables give us somewhere to put the information that our code works with,
    but to do anything with those variables, we will need to write some code. This
    will mean writing *statements* and *expressions*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 变量为我们提供了一个存放代码处理信息的地方，但要对这些变量进行任何操作，我们需要编写一些代码。这意味着编写*语句*和*表达式*。
- en: Statements
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语句
- en: When we write a C# method, we are writing a sequence of statements. Informally,
    the statements in a method describe the actions we want the method to perform.
    Each line in [Example 2-16](#some_statements) is a statement. It might be tempting
    to think of a statement as an instruction to do one thing (such as initializing
    a variable or invoking a method). Or you might take a more lexical view, where
    anything ending in a semicolon is a statement. (And it’s the semicolons that are
    significant here, not the line breaks, by the way. I could have written this as
    one long line of code and it would have exactly the same meaning.) However, both
    descriptions are simplistic, even though they happen to be true for this particular
    example.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写一个 C# 方法时，我们实际上是在编写一系列语句。非正式地说，方法中的语句描述了我们希望方法执行的操作。[示例2-16](#some_statements)中的每一行都是一个语句。也许有些诱人的想法认为语句是一个指令（例如初始化变量或调用方法）。或者您可能采用更词法化的观点，认为任何以分号结尾的东西都是语句。（顺便说一句，这里重要的是分号，而不是换行。我本可以将其写成一行长代码，它的意义完全相同。）然而，这两种描述都过于简单化，尽管它们在这个特定示例中恰好是正确的。
- en: Example 2-16\. Some statements
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例2-16\. 一些语句
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: C# recognizes many different kinds of statements. The first three lines of [Example 2-16](#some_statements)
    are *declaration statements*, statements that declare and optionally initialize
    a variable. The fourth and fifth lines are *expression statements*. But some statements
    have more structure than the ones in this example.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: C#识别许多不同类型的语句。 [示例 2-16](#some_statements) 的前三行是*声明语句*，用于声明并可选地初始化变量。第四和第五行是*表达式语句*。但是有些语句比这个例子中的更有结构。
- en: When you write a loop, that’s an *iteration statement*. When you use the `if`
    or `switch` mechanisms described later in this chapter to choose between various
    possible actions, those are *selection statements*. In fact, the C# specification
    distinguishes between 13 categories of statements. Most fit broadly into the scheme
    of describing either what the code should do next or, for features such as loops
    or conditional statements, describing how it should decide what to do next. Statements
    of the second kind usually contain one or more embedded statements describing
    the action to perform in a loop, or the action to perform when an `if` statement’s
    condition is met.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写一个循环时，那是一个*迭代语句*。当你在本章后面描述的使用`if`或`switch`机制来选择各种可能操作时，那些是*选择语句*。实际上，C#规范区分了13种语句类别。大多数都可以广泛地归类为描述代码接下来应该做什么，或者对于循环或条件语句等功能，描述如何决定接下来该做什么。第二类语句通常包含一个或多个嵌入语句，描述在循环中执行的操作，或者在`if`语句的条件满足时执行的操作。
- en: There’s one special case, though. A block is a kind of statement. This makes
    statements such as loops more useful than they would otherwise be, because a loop
    iterates over just a single embedded statement. That statement can be a block,
    and since a block itself is a sequence of statements (delimited by braces), this
    enables loops to contain more than one statement.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特殊情况。块是一种语句。这使得诸如循环之类的语句比通常更有用，因为循环只是迭代一个嵌入的语句。那个语句可以是一个块，而由于块本身是一系列语句（用大括号分隔），这使得循环可以包含多于一个语句。
- en: This illustrates why the two simplistic points of view stated earlier—“statements
    are actions” and “statements are things that end in semicolons”—are wrong. Compare
    Example [2-16](#some_statements) with [2-17](#block). Both do the same thing,
    because the various actions we’ve said we want to perform remain exactly the same,
    and both contain five semicolons. However, [Example 2-17](#block) contains one
    extra statement. The first two statements are the same, but they are followed
    by a third statement, a block, which contains the final three statements from
    [Example 2-16](#some_statements). The extra statement, the block, doesn’t end
    in a semicolon, nor does it perform any action. In this particular example, it’s
    pointless, but it can sometimes be useful to introduce a nested block like this
    to avoid name ambiguity errors. So statements can be structural, rather than causing
    anything to happen at runtime.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了为什么前面提到的两种简单观点——“语句是行动”和“语句是以分号结尾的东西”——都是错误的。比较示例 [2-16](#some_statements)
    和 [2-17](#block)。两者做的事情是一样的，因为我们想要执行的各种操作保持完全一样，并且两者都包含五个分号。然而，[示例 2-17](#block)
    包含了一个额外的语句。前两个语句是相同的，但后面跟着一个第三个语句，一个块，其中包含了来自 [示例 2-16](#some_statements) 的最后三个语句。这个额外的语句，即块，既不以分号结尾，也不执行任何操作。在这个特定的例子中，它是无意义的，但有时候引入这样一个嵌套块可以避免名称歧义错误。因此，语句可以是结构性的，而不是在运行时引起任何事情发生。
- en: Example 2-17\. A block
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-17\. 一个块
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: While your code will contain a mixture of statement types, it will inevitably
    end up containing at least a few expression statements. An expression statement
    is a statement that consists of a suitable expression, followed by a semicolon.
    What’s a suitable expression? What’s an expression, for that matter? I’d better
    answer that second question before coming back to what constitutes a valid expression
    for a statement.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你的代码将包含多种类型的语句，但最终至少会包含一些表达式语句。表达式语句是由合适的表达式后跟一个分号组成的语句。什么是合适的表达式？实际上什么是表达式？在回到组成语句的有效表达式之前，我最好先回答第二个问题。
- en: Expressions
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式
- en: 'Microsoft’s official definition of a C# *expression* is rather dry: “a sequence
    of operators and operands.” Admittedly, language specifications tend to be like
    that, but in addition to this sort of formal prose, the C# specification contains
    some very readable informal explanations of the more formally expressed ideas.
    (For example, it describes statements as the means by which “the actions of a
    program are expressed” before going on to pin that down with less approachable
    but more technically precise language.) The quote at the start of this paragraph
    is from the formal definition of an expression, so we might hope that the informal
    explanation in the introduction will be more helpful. No such luck: it says that
    expressions “are constructed from operands and operators.” That’s certainly less
    precise than the other definition, but it’s no easier to understand. The problem
    is that there are several kinds of expressions, and they do different jobs, so
    there isn’t a single, general, informal description.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 微软对C# *expression*的官方定义相当枯燥：“一系列操作符和操作数。”尽管如此，语言规范往往是这样的，但除了这种形式化的散文外，C#规范还包含一些非常可读的非正式解释更正式表达的想法。
    （例如，在说明语句作为表达程序操作的手段之前，它描述了表达式的含义，然后用不太接近但技术上更精确的语言来确定。）本段开头的引语来自表达式的正式定义，所以我们可能希望在引言中的非正式解释将更有帮助。没那么幸运：它说表达式“是从操作数和操作符构造的。”这当然不如其他定义那么精确，但理解起来也不容易。问题在于，有几种类型的表达式，它们执行不同的工作，所以没有单一的、通用的、非正式的描述。
- en: It’s tempting to describe an expression as some code that produces a value.
    That’s not true for all expressions, but the majority of expressions you’ll write
    will fit this description, so I’ll focus on this for now, and I’ll come to the
    exceptions later.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 描述一个表达式为产生值的代码是很诱人的。对于所有表达式来说并非如此，但你将写的大多数表达式都符合这个描述，所以我现在将重点放在这一点上，并稍后提到例外情况。
- en: 'The simplest expressions are *literals*, where we just write the value we want,
    such as `"Hello, World!"` or `42`. You can also use the name of a variable as
    an expression. Expressions can involve operators, which describe calculations
    or other computations to be performed. Operators have some fixed number of inputs,
    called *operands*. Some take a single operand. For example, you can negate a number
    by putting a minus sign in front of it. Some take two: the `+` operator lets you
    form an expression that adds together the results of the two operands on either
    side of the `+` symbol.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的表达式是*literals*，我们只需写出我们想要的值，比如`"Hello, World!"`或`42`。你也可以使用变量的名称作为一个表达式。表达式可以涉及运算符，描述进行的计算或其他计算。运算符有固定数量的输入，称为*operands*。有些运算符只需要一个操作数。例如，你可以通过在数字前面加一个减号来对数字取反。有些运算符需要两个操作数：`+`运算符允许你形成一个表达式，将两侧操作数的结果相加。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Some symbols have different roles depending on the context. The minus sign is
    not just used for negation. It acts as a two-operand subtraction operator if it
    appears between two expressions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一些符号在不同的上下文中有不同的作用。减号不仅仅用于取反。如果它出现在两个表达式之间，则充当双操作数减法运算符。
- en: In general, operands are also expressions. So, when we write `2 + 2`, that’s
    an expression that contains two more expressions—the pair of "`2`" literals on
    either side of the `+` symbol. This means that we can write arbitrarily complicated
    expressions by nesting expressions within expressions within expressions. [Example 2-18](#expressions_within_expressions)
    exploits this to evaluate the quadratic formula (the standard way to solve quadratic
    equations).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，操作数也是表达式。所以，当我们写`2 + 2`时，这是一个包含两个更多表达式的表达式——`+`符号两侧的一对"`2`" literals。这意味着我们可以通过在表达式内部嵌套表达式来编写任意复杂的表达式。[示例 2-18](#expressions_within_expressions)利用这一点来评估二次方程的解（解二次方程的标准方法）。
- en: Example 2-18\. Expressions within expressions
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例2-18。表达式内的表达式
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Look at the declaration statement on the second line. The overall structure
    of its initializer expression is a division operation. But that division operator’s
    two operands are also expressions. Its lefthand operand is a *parenthesized expression*,
    which tells the compiler that I want that whole expression `(-b + Math.Sqrt(b
    * b - 4 * a * c))` to be the first operand of the division. This subexpression
    contains an addition, whose lefthand operand is a negation expression whose single
    operand is the variable `b`. The addition’s righthand side takes the square root
    of another, more complex expression. And the division’s righthand operand is another
    parenthesized expression, containing a multiplication. [Figure 2-1](#structure_of_an_expression)
    illustrates the full structure of the expression.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 看看第二行的声明语句。其初始化表达式的整体结构是一个除法操作。但是该除法运算符的两个操作数也是表达式。其左操作数是一个*括号表达式*，告诉编译器我希望整个表达式
    `(-b + Math.Sqrt(b * b - 4 * a * c))` 成为除法的第一个操作数。这个子表达式包含一个加法，其左操作数是一个否定表达式，其单个操作数是变量
    `b`。加法的右操作数则对另一个更复杂的表达式进行平方根运算。而除法的右操作数是另一个括号表达式，其中包含一个乘法。[图 2-1](#structure_of_an_expression)
    展示了表达式的完整结构。
- en: '![The structure of an expression](assets/pc10_0201.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![表达式的结构](assets/pc10_0201.png)'
- en: Figure 2-1\. The structure of an expression
  id: totrans-107
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-1\. 表达式的结构
- en: One important detail of this last example is that method invocations are a kind
    of expression. The `Math.Sqrt` method used in [Example 2-18](#expressions_within_expressions)
    is a .NET runtime library function that calculates the square root of its input
    and returns the result. What’s perhaps more surprising is that invocations of
    methods that don’t return a value, such as `Console.WriteLine`, are also, technically,
    expressions. And there are a few other constructs that don’t produce values but
    are still considered to be expressions, including a reference to a type (such
    as the `Console` in `Console.WriteLine`) or to a namespace. These sorts of constructs
    take advantage of a set of common rules (such as scoping, how to resolve what
    a name refers to, etc.) by virtue of being expressions. However, all the non-value-producing
    expressions can be used only in certain specific circumstances. (You can’t use
    one as an operand in another expression, for example.) So although it’s not technically
    correct to define an expression as a piece of code that produces a value, the
    ones that do are the ones we use when describing the calculations we want our
    code to perform.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个示例的一个重要细节是，方法调用是一种表达式。在[示例 2-18](#expressions_within_expressions)中使用的 `Math.Sqrt`
    方法是一个 .NET 运行时库函数，用于计算其输入的平方根并返回结果。也许更令人惊讶的是，像 `Console.WriteLine` 这样不返回值的方法调用，从技术上讲也是表达式。还有一些其他不产生值但仍被视为表达式的结构，包括对类型的引用（例如
    `Console.WriteLine` 中的 `Console`）或对命名空间的引用。这些构造利用了一套通用规则（例如作用域、如何解析名称引用等），因此被视为表达式。然而，所有不生成值的表达式只能在特定情况下使用（例如，不能将一个表达式用作另一个表达式的操作数）。因此，虽然从技术上讲定义表达式为生成值的代码片段并不完全正确，但我们在描述代码要执行的计算时确实使用这些表达式。
- en: 'We can now return to the question, What can we put in an expression statement?
    Roughly speaking, the expression has to do something; it cannot just calculate
    a value. So although `2 + 2` is a valid expression, you’ll get an error if you
    try to turn it into an expression statement by sticking a semicolon on the end.
    That expression calculates something but doesn’t do anything with the result.
    To be more precise, you can use the following kinds of expressions as statements:
    method invocation, assignment, increment, decrement, and new object creation.
    We’ll be looking at increment and decrement later in this chapter, and we’ll be
    looking at objects in later chapters, so that leaves invocation and assignment.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以回到一个问题，即在表达式语句中可以放什么？粗略来说，表达式必须执行某些操作；它不能只计算一个值。因此，虽然 `2 + 2` 是一个有效的表达式，但如果您试图在其末尾添加分号将其转换为表达式语句，您将会得到一个错误。这个表达式计算了某些东西，但没有对结果做任何事情。更准确地说，您可以将以下类型的表达式用作语句：方法调用、赋值、增量、减量以及新对象的创建。我们将在本章后面讨论增量和减量，后续章节还会讨论对象，因此留下了调用和赋值两种情况。
- en: So a method invocation is allowed to be an expression statement. This can involve
    nested expressions of other kinds, but the whole thing must be a method call.
    [Example 2-19](#invocation_expressions_as_statements) shows some valid examples.
    Notice that the C# compiler doesn’t check whether the method call really has any
    lasting effect—the `Math.Sqrt` function is a pure function, in the sense that
    it does nothing other than returning a value determined entirely by its inputs.
    So invoking it and then doing nothing with the result doesn’t really do anything
    at all—it’s no more of an action than the expression `2 + 2`. But as far as the
    C# compiler is concerned, any method call is allowed as an expression statement.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，方法调用允许作为表达式语句。这可能涉及其他类型的嵌套表达式，但整个表达式必须是一个方法调用。[示例 2-19](#invocation_expressions_as_statements)展示了一些有效的例子。请注意，C#
    编译器并不检查方法调用是否真正产生了任何持久效果——`Math.Sqrt` 函数是一个纯函数，它仅仅根据其输入返回一个值。因此调用它然后不对结果做任何操作实际上什么都没做——这不比表达式`2
    + 2`更有作用。但就 C# 编译器而言，任何方法调用都允许作为表达式语句。
- en: Example 2-19\. Method invocation expressions as statements
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-19\. 方法调用表达式作为语句
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you run this example in VS Code, the call to `ReadKey` might fail because
    of how the debugger redirects input and output by default. The [documentation
    explains](https://oreil.ly/JefbY) how to avoid this problem when debugging programs
    that need to read console input.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 VS Code 中运行此示例，则`ReadKey`的调用可能会失败，因为调试器默认会重定向输入和输出。[文档说明](https://oreil.ly/JefbY)了在调试需要读取控制台输入的程序时如何避免此问题。
- en: It seems inconsistent that C# forbids us from using an addition expression as
    a statement while allowing `Math.Sqrt`. Both perform a calculation that produces
    a result, so it makes no sense to use either in this way. Wouldn’t it be more
    consistent if C# allowed only calls to methods that return nothing to be used
    for expression statements? That would rule out the final line of [Example 2-19](#invocation_expressions_as_statements),
    which would seem like a good idea because that code does nothing useful. It would
    also be consistent with the fact that `2 + 2` also cannot form an expression statement.
    Unfortunately, sometimes you want to ignore the return value. [Example 2-19](#invocation_expressions_as_statements)
    calls `Console.ReadKey()`, which waits for a keypress and returns a value indicating
    which key was pressed. If my program’s behavior depends on which particular key
    the user pressed, I’ll need to inspect the method’s return value, but if I just
    want to wait for any key at all, it’s OK to ignore the return value. If C# didn’t
    allow methods with return values to be used as expression statements, I wouldn’t
    be able to do this. The compiler has no way to distinguish between methods that
    make for pointless statements because they have no side effects (such as `Math.Sqrt`)
    and those that might be good candidates (such as `Console.ReadKey`), so it allows
    any method.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: C# 禁止我们将加法表达式用作语句，而允许`Math.Sqrt`，看起来是不一致的。这两者都执行计算并产生结果，因此在这种方式下使用它们是毫无意义的。如果
    C# 只允许调用不返回任何内容的方法用作表达式语句，那么这会更一致吗？这将排除[示例 2-19](#invocation_expressions_as_statements)的最后一行，因为这段代码并不执行任何有用的操作。这也与`2
    + 2`不能形成表达式语句的事实一致。不幸的是，有时您希望忽略返回值。[示例 2-19](#invocation_expressions_as_statements)调用`Console.ReadKey()`，它等待按键并返回一个值，指示按下了哪个键。如果我的程序行为依赖于用户按下的特定键，我需要检查方法的返回值，但如果我只是想等待任何键，忽略返回值就可以了。如果
    C# 不允许具有返回值的方法用作表达式语句，那么我将无法这样做。编译器无法区分哪些方法会导致毫无意义的语句，因为它们没有副作用（比如`Math.Sqrt`），哪些可能是好的候选（比如`Console.ReadKey`），因此它允许任何方法。
- en: For an expression to be a valid expression statement, it is not enough merely
    to contain a method invocation. [Example 2-20](#errors_some_expressions_that_dont_work)
    shows some expressions that call methods and then go on to use those as part of
    addition expressions. Although these are valid expressions, they’re not valid
    expression statements, so these will cause compiler errors. What matters is the
    outermost expression. In both lines here, that’s an addition expression, which
    is why these are not allowed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要使表达式成为有效的表达式语句，仅仅包含方法调用是不够的。[示例 2-20](#errors_some_expressions_that_dont_work)展示了一些调用方法并将其用作加法表达式一部分的表达式。虽然这些是有效的表达式，但它们不是有效的表达式语句，因此会导致编译器错误。关键在于最外层的表达式。在这两行中，最外层都是加法表达式，这就是为什么这些是不允许的原因。
- en: 'Example 2-20\. Errors: some expressions that don’t work as statements'
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 2-20\. 错误：一些不作为语句工作的表达式
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Earlier I said that one kind of expression we’re allowed to use as a statement
    is an assignment. It’s not obvious that assignments should be expressions, but
    they are, and they do produce a value: the result of an assignment expression
    is the value being assigned to the variable. This means it’s legal to write code
    like that in [Example 2-21](#assignments_are_expressions). The second line here
    uses an assignment expression as an argument for a method invocation, which shows
    the value of that expression. The first two `WriteLine` calls both display `123`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我说过我们可以将作为语句使用的一种表达式是赋值。赋值作为表达式并不明显，但确实如此，并且它们会产生一个值：赋值表达式的结果是分配给变量的值。这意味着可以在[示例 2-21](#assignments_are_expressions)中编写这样的代码是合法的。这里的第二行使用赋值表达式作为方法调用的参数，展示了该表达式的值。前两个`WriteLine`调用都显示`123`。
- en: Example 2-21\. Assignments are expressions
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 2-21\. 赋值是表达式
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The second part of this example assigns one value into two variables in a single
    step by exploiting the fact that assignments are expressions—it assigns the value
    of the `y = 0` expression (which evaluates to `0`) into `x`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的第二部分通过利用赋值为两个变量同时分配一个值，说明了赋值作为表达式的事实——它将`y = 0`表达式的值（评估为`0`）分配给了`x`。
- en: This shows that evaluating an expression can do more than just produce a value.
    Some expressions have side effects. We’ve just seen that an assignment is an expression,
    and of course it has the effect of changing what’s in a variable. Method calls
    are expressions too, and although you can write pure functions that do nothing
    besides calculating their result from their input, like `Math.Sqrt`, many methods
    do something with lasting effects, such as writing data to the screen, updating
    a database, or triggering the demolition of a building. This means that we might
    care about the order in which the operands of an expression get evaluated.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明评估表达式不仅仅是产生一个值。一些表达式具有副作用。我们刚刚看到赋值是一个表达式，当然它有改变变量内容的效果。方法调用也是表达式，尽管可以编写仅从其输入计算结果的纯函数，比如`Math.Sqrt`，但许多方法会有一些持久的效果，例如向屏幕写入数据，更新数据库或触发建筑物的拆除。这意味着我们可能关心表达式的操作数评估顺序。
- en: An expression’s structure imposes some constraints on the order in which operators
    do their work. For example, I can use parentheses to enforce ordering. The expression
    `10 + (8 / 2)` has the value 14, while the expression `(10 + 8) / 2` has the value
    9, even though both have exactly the same literal operands and arithmetic operators.
    The parentheses here determine whether the division is performed before or after
    the subtraction.^([4](ch02.xhtml#fn07))
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式的结构对操作符完成工作的顺序施加了一些约束。例如，我可以使用括号强制执行顺序。表达式`10 + (8 / 2)`的值为14，而表达式`(10 +
    8) / 2`的值为9，尽管它们都有完全相同的文字操作数和算术运算符。这里的括号决定了除法是在减法之前还是之后执行。^([4](ch02.xhtml#fn07))
- en: 'However, while the structure of an expression imposes some ordering constraints,
    it still leaves some latitude: although both the operands of an addition need
    to be evaluated before they can be added, the addition operator doesn’t care which
    operand we evaluate first. But if the operands are expressions with side effects,
    the order could be important. For these simple expressions, it doesn’t matter
    because I’ve used literals, so we can’t really tell when they get evaluated. But
    what about an expression in which operands call some method? [Example 2-22](#operand_evaluation_order)
    contains code of this kind.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，虽然表达式的结构对操作数的评估顺序施加了一些约束，但仍然有一些余地：虽然加法的两个操作数在执行加法之前必须先评估，但加法运算符不关心我们先评估哪个操作数。但如果操作数是具有副作用的表达式，顺序可能很重要。对于这些简单的表达式，这并不重要，因为我使用了文字，所以我们无法真正知道它们何时被评估。但是，如果操作数调用了某些方法的表达式呢？[示例 2-22](#operand_evaluation_order)包含这种类型的代码。
- en: Example 2-22\. Operand evaluation order
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 2-22\. 操作数的评估顺序
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This defines a method, `X`, which takes two arguments. It displays the first
    and just returns the second. I’ve then used this a few times in an expression
    so that we can see exactly when the operands that call `X` are evaluated. Some
    languages choose not to define this order, making the behavior of such a program
    unpredictable, but C# does specify an order here. The rule is that within any
    expression, the operands are evaluated in the order in which they occur in the
    source. So, when the `Console.WriteLine` in [Example 2-22](#operand_evaluation_order)
    runs, it makes multiple calls to `X`, which calls `Console.Write` each time, so
    we see this output: `abcd4`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个方法，`X`，它接受两个参数。它显示第一个参数，并返回第二个参数。然后，我在表达式中多次使用了这个方法，这样我们就可以确切地看到调用 `X`
    的操作数何时被评估。一些语言选择不定义此顺序，使得这样的程序的行为变得不可预测，但是在 C# 中这里是有规定的。规则是在任何表达式内部，操作数按照它们在源代码中出现的顺序进行评估。因此，当
    [示例 2-22](#operand_evaluation_order) 中的 `Console.WriteLine` 运行时，它会多次调用 `X`，每次调用
    `X` 都会调用 `Console.Write`，因此我们会看到这样的输出：`abcd4`。
- en: 'However, this glosses over an important subtlety: What do we mean by the order
    of expressions when nesting occurs? The entire argument to that `Console.WriteLine`
    is one big add expression, where the first operand is `X("a", 1)`, and the second
    is another add expression, which in turn has a first operand of `X("b", 1)` and
    a second operand, which is yet another add expression, whose operands are `X("c",
    1)` and `X("d", 1)`. Taking the first of those add expressions, which constitutes
    the entire argument to `Console.WriteLine`, and does it even make sense to ask
    whether it comes before or after its first operand? Lexically, the outermost add
    expression starts at exactly the same point that its first operand starts and
    ends at the point where its second operand ends (which also happens to be at the
    exact same point that the final `X("d", 1)` ends). In this particular case, it
    doesn’t really matter because the only observable effect of the order of evaluation
    is the output the `X` method produces when invoked. None of the expressions that
    invoke `X` are nested within one another, so we can meaningfully say what order
    those expressions are in, and the output we see matches that order. However, in
    some cases, such as [Example 2-23](#operand_evaluation_order_nested), the overlapping
    of nested expressions can have a visible impact.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这忽略了一个重要的微妙之处：当嵌套发生时，我们在说表达式的顺序时到底是什么意思？`Console.WriteLine` 的整个参数是一个大的加法表达式，其中第一个操作数是
    `X("a", 1)`，第二个操作数是另一个加法表达式，它又以 `X("b", 1)` 作为第一个操作数，并且有一个第二操作数，它又是另一个加法表达式，其操作数分别是
    `X("c", 1)` 和 `X("d", 1)`。考虑这些加法表达式中的第一个，它构成了传递给 `Console.WriteLine` 的整个参数，现在问这个加法表达式的第一个操作数究竟是在其第一个操作数之前还是之后，这是否有意义？在词法上，最外层的加法表达式从其第一个操作数开始的确切点开始，并在其第二操作数结束的点结束（这也恰好是最终的
    `X("d", 1)` 结束的地方）。在这种特定情况下，真正重要的是评估顺序的唯一可观察效果是调用 `X` 方法时产生的输出。没有一个调用 `X` 的表达式是嵌套在另一个表达式中的，因此我们可以有意义地说这些表达式的顺序，并且我们看到的输出与该顺序匹配。然而，在某些情况下，如
    [示例 2-23](#operand_evaluation_order_nested)，嵌套表达式的重叠可能会产生可见的影响。
- en: Example 2-23\. Operand evaluation order with nested expressions
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-23\. 带有嵌套表达式的操作数评估顺序
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, `Console.WriteLine`’s argument adds the results of three calls to `X`;
    however, the second of those calls to `X` (first argument `"b"`) takes as its
    second argument an expression that adds the results of three more calls to `X`
    (with arguments of `"c"`, `"d"`, and `"e"`). With the final call to `X` (passing
    `"f"`), we have a total of six expressions invoking `X` in that statement. C#’s
    rule of evaluating expressions in the order in which they appear applies as always,
    but because there is overlap, the results are initially surprising. Although the
    letters appear in the source in alphabetical order, the output is `"acdebf5"`.
    If you’re wondering how on earth that can be consistent with expressions being
    evaluated in order, consider that this code starts the evaluation of each expression
    in the order in which the expressions start, and finishes the evaluation in the
    order in which the expressions finish, but that those are two different orderings.
    In particular, the expression that invokes `X` with `"b"` begins its evaluation
    before those that invoke it with `"c"`, `"d"`, and `"e"`, but it finishes its
    evaluation *after* them. And it’s that *after* ordering that we see in the output.
    If you find each closing parenthesis that corresponds to a call to `X` in this
    example, you’ll find that the order of calls exactly matches what’s displayed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`Console.WriteLine` 的参数添加了三次调用 `X` 的结果；然而，这三次 `X` 的调用中，第二次调用（第一个参数为`"b"`）的第二个参数是一个表达式，该表达式又添加了三次调用
    `X` 的结果（参数分别为`"c"`、`"d"` 和 `"e"`）。通过最后一次调用 `X`（传递`"f"`），在该语句中我们总共有六个调用 `X` 的表达式。C#
    按照表达式出现的顺序来评估表达式的规则始终适用，但由于存在重叠，结果一开始会令人惊讶。尽管字母按照字母表顺序出现在源代码中，输出却是`"acdebf5"`。如果你想知道这是如何与按顺序评估表达式保持一致，请考虑代码从表达式开始评估的顺序，以及在表达式完成评估时的顺序，这两者是不同的排序方式。特别是，使用`"b"`调用
    `X` 的表达式开始其评估比使用`"c"`、`"d"` 和 `"e"` 调用 `X` 的表达式开始评估更早，但在它们之后完成其评估。我们在输出中看到的正是这种*后续*排序。如果你在本例中找到每个与调用
    `X` 相对应的闭合括号，你会发现调用顺序与显示的内容完全一致。
- en: Comments and Whitespace
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释与空白
- en: Most programming languages allow source files to contain text that is ignored
    by the compiler, and C# is no exception. As with most C-family languages, it supports
    two styles of *comments* for this purpose. There are *single-line comments*, as
    shown in [Example 2-24](#single_line_comments), in which you write two `/` characters
    in a row, and everything from there to the end of the line will be ignored by
    the compiler.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言允许源文件包含编译器忽略的文本，C#也不例外。与大多数C家族语言一样，它支持两种用于此目的的*注释*风格。有*单行注释*，如[示例 2-24](#single_line_comments)
    中所示，其中写入两个`/`字符，从而使得从这里到行尾的所有内容都将被编译器忽略。
- en: Example 2-24\. Single-line comments
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-24\. 单行注释
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: C# also supports *delimited comments*. You start a comment of this kind with
    `/*`, and the compiler will ignore everything that follows until it encounters
    the first `*/` character sequence. This can be useful if you don’t want the comment
    to go all the way to the end of the line, as the first line of [Example 2-25](#delimited_comments)
    illustrates. This example also shows that delimited comments can span multiple
    lines.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: C# 也支持*定界注释*。你可以使用`/*`开始这种类型的注释，编译器将忽略直到遇到第一个`*/`字符序列的所有内容。如果你不希望注释一直持续到行尾，这将会很有用，正如[示例 2-25](#delimited_comments)
    的第一行所示。本例还展示了定界注释可以跨越多行。
- en: Example 2-25\. Delimited comments
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-25\. 定界注释
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There’s a minor snag you can run into with delimited comments; it can happen
    even when the comment is within a single line, but it more often occurs with multiline
    comments. [Example 2-26](#multiline_comments) shows the problem with a comment
    that begins in the middle of the first line and ends at the end of the fourth.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用定界注释可能会遇到一个小问题；即使注释在单行内，也可能会发生，但更常见的是在多行注释中出现。[示例 2-26](#multiline_comments)
    展示了从第一行中间开始到第四行末尾的注释问题。
- en: Example 2-26\. Multiline comments
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-26\. 多行注释
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice that the `/*` character sequence appears twice in this example. When
    this sequence appears in the middle of a comment, it does nothing special—comments
    don’t nest. Even though we’ve seen two `/*` sequences, the first `*/` is enough
    to end the comment. This is occasionally frustrating, but it’s the norm for C-family
    languages.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在本示例中`/*`字符序列出现了两次。当此序列出现在注释中间时，它什么特别操作也不会执行——注释不会嵌套。尽管我们看到了两个`/*`序列，但第一个`*/`就足以结束注释。这有时令人沮丧，但对于C家族语言来说，这是常态。
- en: It’s sometimes useful to take a chunk of code out of action temporarily, in
    a way that’s easy to put back. Turning the code into a comment is a common way
    to do this, and although a delimited comment might seem like the obvious thing
    to use, it becomes awkward if the region you commented out happens to include
    another delimited comment. Since there’s no support for nesting, you would need
    to add a `/*` after the inner comment’s closing `*/` to ensure that you’ve commented
    out the whole range. So it is common to use single-line comments for this purpose.
    (You can also use the `#if` directive described in the next section.)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有时临时禁用一段代码并且轻松恢复是非常有用的。将代码转换为注释是一个常见的方法，虽然一个分隔的注释看起来似乎是一个显而易见的选择，但如果你注释掉的区域恰好包含另一个分隔的注释，那么它会变得很笨拙。由于没有支持嵌套，你需要在内部注释的闭合`*/`后添加一个`/*`来确保你注释掉了整个范围。因此，通常使用单行注释来实现这一目的。（你还可以使用下一节中描述的`#if`指令。）
- en: Note
  id: totrans-145
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Visual Studio and VS Code can comment out regions of code for you. If you select
    several lines of text and type Ctrl-K followed immediately by Ctrl-C, it will
    add `//` to the start of every line in the selection. And you can uncomment a
    region with Ctrl-K, Ctrl-U. (With Visual Studio, if you chose something other
    than C# as your preferred language when you installed it, these actions may be
    bound to different key sequences, but they are also available on the Edit→Advanced
    menu, as well as on the Text Editor toolbar, one of the standard toolbars that
    Visual Studio shows by default.)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 和 VS Code 都可以帮助你注释掉代码区域。如果你选择了几行文本并按下 Ctrl-K，然后立即按下 Ctrl-C，它会在选择的每一行开头添加
    `//`。而取消注释则是通过 Ctrl-K，Ctrl-U 来实现。（在安装 Visual Studio 时，如果你选择了除了 C# 以外的首选语言，这些操作可能绑定了不同的键序列，但它们也可以在“编辑”→“高级”菜单中找到，并且在默认情况下会显示在文本编辑器工具栏中，这是
    Visual Studio 显示的标准工具栏之一。）
- en: Speaking of ignored text, C# ignores extra whitespace for the most part. Not
    all whitespace is insignificant, because you need at least some space to separate
    tokens that consist entirely of alphanumeric symbols. For example, you can’t write
    `staticvoid` as the start of a method declaration—you’d need at least one space
    (or tab, newline, or other space-like character) between `static` and `void`.
    But with nonalphanumeric tokens, spaces are optional, and in most cases, a single
    space is equivalent to any amount of whitespace and new lines. This means that
    the three statements in [Example 2-27](#insignificant_whitespace) are all equivalent.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到忽略的文本，C# 在大多数情况下忽略额外的空白。并非所有的空白都是无关紧要的，因为你至少需要一些空间来分隔完全由字母数字符号组成的标记。例如，你不能将`staticvoid`作为方法声明的开头—你需要至少一个空格（或制表符、换行符或其他类似的空格字符）来分隔`static`和`void`。但是对于非字母数字符号，空格是可选的，并且在大多数情况下，单个空格等同于任意数量的空白和换行符。这意味着
    [示例 2-27](#insignificant_whitespace) 中的三个语句都是等效的。
- en: Example 2-27\. Insignificant whitespace
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-27\. 无关紧要的空白
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'There are a couple of cases where C# is more sensitive to whitespace. Inside
    a string literal, space is significant, because whatever spaces you write will
    be present in the string value. Also, while C# mostly doesn’t care whether you
    put each element on its own line, or put all your code in one massive line, or
    (as seems more likely) something in between, there is an exception: preprocessing
    directives are required to appear on their own lines.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种情况下，C# 对空白更为敏感。在字符串文字内部，空格是有意义的，因为你写入的空格将出现在字符串值中。此外，虽然 C# 大多数情况下不关心你是否将每个元素放在自己的一行中，或者将所有代码放在一个大行中，或者（似乎更可能的是）介于两者之间，但有一个例外：预处理指令必须单独出现在它们自己的行上。
- en: Preprocessing Directives
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预处理指令
- en: If you’re familiar with the C language or its direct descendants, you may have
    been wondering if C# has a preprocessor. It doesn’t have a separate preprocessing
    stage, and it does not offer macros. However, it does have a handful of directives
    similar to those offered by the C preprocessor, although it is only a very limited
    selection. Even though C# doesn’t have a full preprocessing stage like C, these
    are known as preprocessing directives nonetheless.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 C 语言或其直接后代，你可能会想知道 C# 是否有预处理器。它没有单独的预处理阶段，也不提供宏。但是，它确实有少数与 C 预处理器提供的指令类似的指令，尽管选择非常有限。即使
    C# 没有像 C 那样的完整预处理阶段，这些仍然被称为预处理指令。
- en: Compilation Symbols
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译符号
- en: 'C# offers a `#define` directive that lets you define a *compilation symbol*.
    These symbols are commonly used in conjunction with the `#if` directive to compile
    code in different ways for different situations. For example, you might want some
    code to be present only in Debug builds, or perhaps you need to use different
    code on different platforms to achieve a particular effect. Often, you won’t use
    the `#define` directive, though—it’s more common to define compilation symbols
    through the compiler build settings. You can open up the *.csproj* file and define
    the values you want in a `<DefineConstants>` element of any `<PropertyGroup>`.
    Alternatively, Visual Studio can do this for you: right-click the project’s node
    in Solution Explorer, select Properties, and in the property page that this opens,
    go to the Build section. This UI lets you configure different symbol values for
    each build configuration (which it does by adding attributes such as `Condition="''$(Configuration)|$(Platform)''==''Debug|AnyCPU''"`
    to the `<PropertyGroup>` containing these settings).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: C# 提供了一个`#define`指令，允许你定义一个*编译符号*。这些符号通常与`#if`指令一起使用，根据不同情况编译代码。例如，你可能希望某些代码仅在调试版本中存在，或者可能需要在不同平台上使用不同的代码以达到特定效果。通常情况下，你不会直接使用`#define`指令，而是通过编译器的构建设置定义编译符号。你可以打开*.csproj*文件，在任何`<PropertyGroup>`的`<DefineConstants>`元素中定义你想要的值。另外，Visual
    Studio也可以帮助你完成这些操作：右键单击解决方案资源管理器中的项目节点，选择属性，在打开的属性页中转到“生成”部分。该界面允许你为每个构建配置配置不同的符号值（通过向包含这些设置的`<PropertyGroup>`添加像`Condition="'$(Configuration)|$(Platform)'=='Debug|AnyCPU'"`这样的属性）。
- en: Note
  id: totrans-155
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The .NET SDK defines certain symbols by default. It supports two configurations,
    Debug and Release. It defines a `DEBUG` compilation symbol in the Debug configuration,
    whereas Release will define `RELEASE` instead. It defines a symbol called `TRACE`
    in both configurations. Certain project types get additional symbols. A library
    targeting .NET Standard will have `NETSTANDARD` defined, along with a version-specific
    symbol such as `NETSTANDARD2_0`, for example. Projects that target .NET 6.0 get
    a `NET6_0` symbol.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: .NET SDK 默认定义了某些符号。它支持两种配置，Debug 和 Release。在 Debug 配置中定义了一个`DEBUG`编译符号，而 Release
    则会定义`RELEASE`。它在两种配置中都定义了一个名为`TRACE`的符号。某些项目类型会获得额外的符号。一个面向.NET Standard的库将定义`NETSTANDARD`，以及一个特定版本的符号，比如`NETSTANDARD2_0`。目标为.NET
    6.0的项目会得到一个`NET6_0`符号。
- en: Compilation symbols are typically used in conjunction with the `#if`, `#else`,
    `#elif`, and `#endif` directives (`#elif` is short for *else if*). [Example 2-28](#conditional_compilation)
    uses some of these directives to ensure that certain lines of code get compiled
    only in Debug builds. (You can also write `#if false` to prevent sections of code
    from being compiled at all. This is typically done only as a temporary measure
    and is an alternative to commenting out that sidesteps some of the lexical pitfalls
    of attempting to nest comments.)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 编译符号通常与`#if`、`#else`、`#elif`和`#endif`指令一起使用（`#elif`是*else if*的简写）。[示例 2-28](#conditional_compilation)
    使用了其中一些指令，以确保只在调试版本中编译某些代码行。（你也可以写`#if false`来完全阻止某些代码段的编译。这通常只是临时措施，是一种避免注释嵌套问题的替代方法。）
- en: Example 2-28\. Conditional compilation
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-28\. 条件编译
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: C# provides a more subtle mechanism to support this sort of thing, called a
    *conditional method*. The compiler recognizes an attribute defined by the runtime
    libraries, called `ConditionalAttribute`, for which it provides special compile-time
    behavior. You can annotate any method with this attribute. [Example 2-29](#conditional_method)
    uses it to indicate that the annotated method should be used only when the `DEBUG`
    compilation symbol is defined.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: C# 提供了一种更微妙的机制来支持这种情况，称为*条件方法*。编译器识别运行时库定义的一个称为`ConditionalAttribute`的特性，为其提供特殊的编译时行为。你可以使用这个特性注解任何方法。[示例 2-29](#conditional_method)
    使用它来指示只有在定义了`DEBUG`编译符号时才应使用注解方法。
- en: Example 2-29\. Conditional method
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-29\. 条件方法
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you write code that calls a method that has been annotated in this way, the
    C# compiler will omit that call in builds that do not define the relevant symbol.
    So if you write code that calls this `ShowDebugInfo` method, the compiler strips
    out all those calls in non-Debug builds. This means you can get the same effect
    as [Example 2-28](#conditional_compilation) but without cluttering up your code
    with directives.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您编写调用以这种方式注释的方法的代码，C# 编译器将在不定义相关符号的构建中省略该调用。因此，如果您编写调用 `ShowDebugInfo` 方法的代码，编译器将在非调试构建中剥离所有这些调用。这意味着您可以获得与
    [示例 2-28](#conditional_compilation) 相同的效果，但不会用指令使代码混乱。
- en: The runtime libraries’ `Debug` and `Trace` classes in the `System.Diagnostics`
    namespace use this feature. The `Debug` class offers various methods for generating
    diagnostic output that are conditional on the `DEBUG` compilation symbol, while
    the `Trace` class has methods conditional on `TRACE`. If you leave the default
    settings for a new C# project in place, any diagnostic output produced through
    the `Trace` class will be available in both Debug and Release builds, but any
    code that calls a method on the `Debug` class will not get compiled into Release
    builds.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时库的 `System.Diagnostics` 命名空间中的 `Debug` 和 `Trace` 类使用了这个特性。`Debug` 类提供了各种方法来生成诊断输出，这些方法在
    `DEBUG` 编译符号条件下才会生效，而 `Trace` 类的方法则在 `TRACE` 条件下才会生效。如果保留新的 C# 项目的默认设置，通过 `Trace`
    类产生的任何诊断输出将在调试和发布构建中都可用，但调用 `Debug` 类上的方法的任何代码将不会编译到发布构建中。
- en: Warning
  id: totrans-165
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'The `Debug` class’s `Assert` method is conditional on `DEBUG`, which sometimes
    catches developers out. `Assert` lets you specify a condition that must be true
    at runtime, and it throws an exception if the condition is false. There are two
    things developers new to C# often mistakenly put in a `Debug.Assert`: checks that
    should in fact occur in all builds, and expressions with side effects that the
    rest of the code depends on. This leads to bugs, because the compiler will strip
    this code out in non-Debug builds.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`Debug` 类的 `Assert` 方法在 `DEBUG` 条件下才会生效，这有时会让开发人员感到困惑。`Assert` 允许您指定必须在运行时为真的条件，如果条件为假，则会抛出异常。C#
    初学者经常错误地将两件事放入 `Debug.Assert` 中：实际上应该在所有构建中发生的检查，以及代码其余部分依赖的具有副作用的表达式。这会导致错误，因为编译器会在非调试构建中剥离此代码。'
- en: '#error and #warning'
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '#error 和 #warning'
- en: C# lets you choose to generate compiler errors or warnings with the `#error`
    and `#warning` directives. These are typically used inside conditional regions,
    as [Example 2-30](#generating_a_compiler_error) shows, although an unconditional
    `#warning` could be useful as a way to remind yourself that you’ve not written
    some particularly important bit of the code yet.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: C# 允许您使用 `#error` 和 `#warning` 指令生成编译器错误或警告。这些通常用于条件区域内，就像 [示例 2-30](#generating_a_compiler_error)
    所示的那样，尽管无条件的 `#warning` 可能会作为提醒自己尚未编写某些特别重要的代码的一种方式。
- en: Example 2-30\. Generating a compiler error
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-30\. 生成编译器错误
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '#line'
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '#line'
- en: The `#line` directive is useful in generated code. When the compiler produces
    an error or a warning, it states where the problem occurred, providing the filename,
    a line number, and an offset within that line. But if the code in question was
    generated automatically using some other file as input and if that other file
    contains the root cause of the problem, it may be more useful to report an error
    in the input file, rather than the generated file. A `#line` directive can instruct
    the C# compiler to act as though the error occurred at the line number specified
    and, optionally, as if the error were in an entirely different file. [Example 2-31](#line_directive_and_deliberate_mistake)
    shows how to use it. The error after the directive will be reported as though
    it came from line 123 of a file called *Foo.cs*. You can tell the compiler to
    revert to reporting warnings and errors without fakery by writing `#line default`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`#line` 指令在生成的代码中很有用。当编译器产生错误或警告时，它会说明问题发生的位置，提供文件名、行号和该行内的偏移量。但是，如果所讨论的代码是使用其他文件自动生成的，并且如果该其他文件包含问题的根本原因，那么将错误报告在输入文件中可能更有用，而不是在生成的文件中。`#line`
    指令可以指示 C# 编译器表现得好像错误发生在指定的行号，并且可选地，好像错误发生在完全不同的文件中。[示例 2-31](#line_directive_and_deliberate_mistake)
    展示了如何使用它。指令后的错误将被报告好像来自名为 *Foo.cs* 的文件的第 123 行。您可以通过编写 `#line default` 来告诉编译器恢复报告警告和错误而不进行伪造。'
- en: Example 2-31\. The `#line` directive and a deliberate mistake
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-31\. `#line` 指令和故意错误
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This directive also affects debugging. When the compiler emits debug information,
    it takes `#line` directives into account. This means that when stepping through
    code in the debugger, you’ll see the location that `#line` refers to.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令还影响调试。当编译器生成调试信息时，它会考虑`#line`指令。这意味着在调试器中逐步执行代码时，你将看到`#line`引用的位置。
- en: 'The filename part is optional, enabling you to fake just line numbers. Conversely,
    this pragma also accepts a more complex form in which you can supply column and
    range information for situations where generated code doesn’t have a straightforward
    line-to-line relationship with the input. The ASP.NET Core web framework uses
    this: it includes a feature called Razor, which enables C# expressions to be mixed
    with HTML. Razor works by generating C# files, but it uses `#line` directives
    so that the debugger shows the original code written by the developer in the Razor
    file, and not the generated code.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名部分是可选的，这使你可以伪造行号。相反，此编译指示还接受更复杂的形式，在其中可以提供列和范围信息，用于生成的代码与输入之间没有直接的行对行关系的情况。ASP.NET
    Core Web 框架使用此功能：它包括一个名为 Razor 的功能，允许将 C# 表达式与 HTML 混合。Razor 通过生成 C# 文件工作，但它使用`#line`指令，以便调试器显示开发人员在
    Razor 文件中编写的原始代码，而不是生成的代码。
- en: 'There’s another use for this directive. Instead of a line number (and optional
    filename), you can write just `#line hidden`. This affects only the debugger behavior:
    when single stepping, Visual Studio will run straight through all the code after
    such a directive without stopping until it encounters a non-`hidden #line` directive
    (typically `#line default`).'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '这个指令还有另外一个用法。不需要行号（和可选的文件名），你可以写`#line hidden`。这只影响调试器的行为：在单步调试时，Visual Studio
    将直接运行所有这种指令之后的代码，直到遇到非`hidden #line`指令（通常是`#line default`）为止。'
- en: '#pragma'
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '#pragma'
- en: 'The `#pragma` directive provides two features: it can be used to disable selected
    compiler warnings, and it can also be used to override the checksum values the
    compiler puts into the *.pdb* file it generates containing debug information.
    Both of these are designed primarily for code-generation scenarios, although it
    can occasionally be useful to disable warnings in ordinary code. [Example 2-32](#disabling_a_compiler_warning)
    shows how to use a `#pragma` to prevent the compiler from issuing the warning
    that would normally occur if you declare a variable that you do not then go on
    to use.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`#pragma`指令提供了两个功能：它可用于禁用选定的编译器警告，也可用于覆盖编译器放入包含调试信息的*.pdb*文件中的校验和值。这两者主要设计用于代码生成场景，尽管偶尔在普通代码中禁用警告可能也有用。[示例
    2-32](#disabling_a_compiler_warning)展示了如何使用`#pragma`防止编译器在你声明了但未使用的变量时发出的警告。'
- en: Example 2-32\. Disabling a compiler warning
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-32\. 禁用编译器警告
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You should generally avoid disabling warnings. This feature is useful in generated
    code because code generation can often end up creating items that are not always
    used, and pragmas may offer the only way to get a clean compilation. But when
    you’re writing code by hand, it should usually be possible to avoid normal compiler
    warnings in the first place.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通常应避免禁用警告。此功能在生成的代码中很有用，因为代码生成通常会创建未始终使用的项，而编译器指令可能是获得干净编译的唯一途径。但当你手动编写代码时，通常应该能够避免首先出现正常的编译器警告。
- en: Having said that, it can be useful to disable specific warnings if you have
    opted into additional diagnostics. Some components on NuGet supply *code analyzers*,
    components that get connected up to the C# compiler API and that are given the
    opportunity to inspect the code and generate their own diagnostic messages. (This
    happens at build time, and in Visual Studio, it also happens during editing, providing
    live diagnostics as you type. They also work live in Visual Studio Code if you
    install the OmniSharp C# extension and enable the `omn⁠ish⁠arp⁠.en⁠ab⁠leRos⁠lyn​Ana⁠lyz⁠ers`
    setting.) The .NET SDK also includes built-in analyzers that can check various
    aspects of your code such as adherence to naming conventions or the presence of
    common security mistakes. You can configure these at a project level with the
    `AnalysisMode` setting, but as with compiler warnings, you might want to disable
    analyzer warnings in specific cases. You can use `#pragma warning` directives
    to control warnings from code analyzers, not just ones from the C# compiler. Analyzers
    generally prefix their warning numbers with some letters to enable you to distinguish
    between them—compiler warnings all start with `CS`, and warnings from the .NET
    SDK’s analyzers start with `CA`, for example.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，如果您选择了额外的诊断，禁用特定警告可能会很有用。NuGet 上的一些组件提供*代码分析器*，这些组件连接到 C# 编译器 API 并有机会检查代码并生成自己的诊断消息。（这发生在构建时，在
    Visual Studio 中编辑时也会提供实时诊断，即您键入时。如果安装了 OmniSharp C# 扩展并启用了 `omn⁠ish⁠arp⁠.en⁠ab⁠leRos⁠lyn​Ana⁠lyz⁠ers`
    设置，它们也会在 Visual Studio Code 中实时工作。）.NET SDK 还包括内置的分析器，可以检查代码的各个方面，如遵守命名约定或常见安全错误的存在。您可以使用
    `AnalysisMode` 设置在项目级别配置这些内容，但与编译器警告一样，可能希望在特定情况下禁用分析器警告。您可以使用 `#pragma warning`
    指令来控制来自代码分析器的警告，而不仅仅是来自 C# 编译器的警告。分析器通常在其警告编号前加上一些字母以便您区分它们——例如，编译器警告全部以 `CS`
    开头，而来自.NET SDK 分析器的警告以 `CA` 开头。
- en: It’s possible that future versions of C# may add other features based on `#pragma`.
    When the compiler encounters a pragma it does not understand, it generates a warning,
    not an error, on the grounds that an unrecognized pragma might be valid for some
    future compiler version or some other vendor’s compiler.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: C# 的未来版本可能基于 `#pragma` 添加其他功能。当编译器遇到它不理解的 `#pragma` 时，它会生成一个警告而不是错误，因为未识别的 `#pragma`
    可能对未来的编译器版本或其他供应商的编译器有效。
- en: '#nullable'
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`#nullable`'
- en: The `#nullable` directive allows fine-grained control of the nullable annotation
    context and the nullable warning context. This is part of the *nullable references*
    feature. [Chapter 3](ch03.xhtml#ch_types) describes the `#nullable` directive
    in more detail.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`#nullable` 指令允许对可为空注解上下文和可为空警告上下文进行精细控制。这是*可为空引用*功能的一部分。[第 3 章](ch03.xhtml#ch_types)
    更详细地描述了 `#nullable` 指令。'
- en: '#region and #endregion'
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`#region` 和 `#endregion`'
- en: Finally, we have two preprocessing directives that do nothing. If you write
    `#region` directives, the only thing the compiler does is ensure that they have
    corresponding `#endregion` directives. Mismatches cause compiler errors, but the
    compiler ignores correctly paired `#region` and `#endregion` directives. Regions
    can be nested.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有两个什么也不做的预处理指令。如果您写 `#region` 指令，编译器唯一做的就是确保它们有相应的 `#endregion` 指令。不匹配会导致编译器错误，但编译器会忽略正确配对的
    `#region` 和 `#endregion` 指令。区域可以是嵌套的。
- en: These directives exist entirely for the benefit of text editors that choose
    to recognize them. Visual Studio, VS Code, and Rider use them to provide the ability
    to collapse sections of the code down to a single line on screen. The C# editor
    automatically allows certain features to be expanded and collapsed, such as class
    definitions, methods, and code blocks (a feature it calls *outlining*). If you
    define regions with these two directives, it will also allow those to be expanded
    and collapsed. This allows for outlining at both finer-grained (for example, within
    a single block) and coarser-grained (for example, multiple related methods) scales
    than the editor offers automatically.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令完全是为了那些选择识别它们的文本编辑器而存在。Visual Studio、VS Code 和 Rider 使用它们来提供将代码段折叠到屏幕上单行的能力。C#
    编辑器自动允许某些特性扩展和折叠，例如类定义、方法和代码块（一种称为*大纲*的功能）。如果你使用这两个指令定义区域，它也将允许这些区域进行扩展和折叠。这允许在编辑器自动提供的细粒度（例如单个块内）和粗粒度（例如多个相关方法）的大纲之间进行大纲化。
- en: If you hover the mouse over a collapsed region in Visual Studio, it displays
    a tool tip showing the region’s contents. You can put text after the `#region`
    token. When IDEs display a collapsed region, they show this text on the single
    line that remains. Although you’re allowed to omit this, it’s usually a good idea
    to include some descriptive text so that people can have a rough idea of what
    they’ll see if they expand it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Visual Studio中将鼠标悬停在折叠区域上，它会显示一个工具提示，显示该区域的内容。你可以在`#region`标记后面放置文本。当IDE显示一个折叠区域时，它将此文本显示在剩下的单行上。虽然可以省略此文本，但通常最好包含一些描述性文本，以便人们可以大致了解他们如果展开将会看到什么。
- en: Some people like to put the entire contents of a class into various regions,
    because by collapsing all regions, you can see a file’s structure at a glance.
    It might even all fit on the screen at once, thanks to the regions being reduced
    to a single line. On the other hand, some people hate collapsed regions, because
    they present speed bumps on the way to being able to look at the code and can
    also encourage people to put too much source code into one file.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一些人喜欢将类的整个内容放入不同的区域，因为通过折叠所有区域，你可以一目了然地看到文件的结构。由于区域被缩减为单行，甚至整个文件可能会一次性显示在屏幕上。另一方面，一些人讨厌折叠区域，因为它们在查看代码时会造成阻碍，并且还会鼓励人们将过多的源代码放入一个文件中。
- en: Fundamental Data Types
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础数据类型
- en: .NET defines thousands of types in its runtime libraries, and you can write
    your own, so C# can work with an unlimited number of data types. However, a handful
    of types get special handling from the compiler. You saw earlier in [Example 2-9](#using_variables)
    that if you have a string, and you try to add a number to it, the resulting code
    converts the number to a string and appends that to the first string. In fact,
    the behavior is more general than that—it’s not limited to numbers. The compiled
    code works by calling the `String.Concat` method, and if you pass to that any
    nonstring arguments, it will call their `ToString` methods before performing the
    append. All types offer a `ToString` method, so this means you can append values
    of any type to a string.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: .NET在其运行库中定义了数千种类型，你可以编写自己的类型，因此C#可以处理无限数量的数据类型。然而，一些类型从编译器中获得特殊处理。你之前在[示例2-9](#using_variables)中看到过，如果你有一个字符串，并尝试将数字添加到它，编译后的代码将把该数字转换为字符串并附加到第一个字符串上。事实上，行为比那更一般——它不仅限于数字。编译后的代码通过调用`String.Concat`方法工作，如果向其传递任何非字符串参数，它将在执行附加操作之前调用它们的`ToString`方法。所有类型都提供`ToString`方法，因此这意味着你可以将任何类型的值附加到字符串上。
- en: That’s handy, but it only works because the C# compiler knows about strings
    and provides special services for them. (There’s a part of the C# specification
    that defines the unique string handling for the `+` operator.) C# provides various
    special services not just for strings but also for certain numeric data types,
    Booleans, a family of types called tuples, and two specific types called `dynamic`
    and `object`. Most of these are special not just to C# but also to the runtime—almost
    all of the numeric types get direct support in intermediate language (IL), and
    the `bool`, `string`, and `object` types are also intrinsically understood by
    the runtime.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这很方便，但它之所以有效，是因为C#编译器了解字符串并为其提供特殊服务。（C#规范的一部分定义了`+`运算符的唯一字符串处理方式。）C#不仅为字符串提供各种特殊服务，还为某些数值数据类型、布尔值、一系列称为元组的类型以及两种特定类型——`dynamic`和`object`提供特殊服务。这些大多数不仅对C#特有，而且对运行时也是特有的——几乎所有数值类型在中间语言（IL）中都得到直接支持，而`bool`、`string`和`object`类型也被运行时本质上理解。
- en: Numeric Types
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数值类型
- en: 'C# supports integer and floating-point arithmetic. There are signed and unsigned
    integer types, and they come in various sizes, as [Table 2-1](#integer_types)
    shows. The most commonly used integer type is `int`, not least because it is large
    enough to represent a usefully wide range of values without being too large to
    work efficiently on all CPUs that support .NET. (Larger data types might not be
    handled natively by the CPU and can also have undesirable characteristics in multithreaded
    code: reads and writes are atomic for 32-bit types^([5](ch02.xhtml#fn08)) but
    may not be for larger ones.)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: C#支持整数和浮点数算术运算。有符号和无符号整数类型，它们有各种不同的大小，如[表2-1](#integer_types)所示。最常用的整数类型是`int`，因为它足够大，可以表示广泛的值范围，而且在支持.NET的所有CPU上工作效率也很高。（较大的数据类型可能不会被CPU原生支持，并且在多线程代码中可能具有不良特性：32位类型的读取和写入是原子的^([5](ch02.xhtml#fn08))，但对于较大的类型可能不是。）
- en: Table 2-1\. Integer types
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-1\. 整数类型
- en: '| **C# type** | **CLR name** | **Signed** | **Size in bits** | **Inclusive
    range** |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| **C# 类型** | **CLR 名称** | **有符号** | **位大小** | **包含范围** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `byte` | `System.Byte` | No | 8 | 0 to 255 |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | `System.Byte` | 否 | 8 | 0 到 255 |'
- en: '| `sbyte` | `System.SByte` | Yes | 8 | −128 to 127 |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `sbyte` | `System.SByte` | 是 | 8 | −128 到 127 |'
- en: '| `ushort` | `System.UInt16` | No | 16 | 0 to 65,535 |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `ushort` | `System.UInt16` | 否 | 16 | 0 到 65,535 |'
- en: '| `short` | `System.Int16` | Yes | 16 | −32,768 to 32,767 |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `short` | `System.Int16` | 是 | 16 | −32,768 到 32,767 |'
- en: '| `uint` | `System.UInt32` | No | 32 | 0 to 4,294,967,295 |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `uint` | `System.UInt32` | 否 | 32 | 0 到 4,294,967,295 |'
- en: '| `int` | `System.Int32` | Yes | 32 | −2,147,483,648 to 2,147,483,647 |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `int` | `System.Int32` | 是 | 32 | −2,147,483,648 到 2,147,483,647 |'
- en: '| `ulong` | `System.UInt64` | No | 64 | 0 to 18,446,744,073,709,551,615 |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `ulong` | `System.UInt64` | 否 | 64 | 0 到 18,446,744,073,709,551,615 |'
- en: '| `long` | `System.Int64` | Yes | 64 | −9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
    |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `long` | `System.Int64` | 是 | 64 | −9,223,372,036,854,775,808 到 9,223,372,036,854,775,807
    |'
- en: '| `nint` | `System.IntPtr` | Yes | Depends | Depends |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `nint` | `System.IntPtr` | 是 | 取决于 | 取决于 |'
- en: '| `nuint` | `System.UIntPtr` | No | Depends | Depends |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `nuint` | `System.UIntPtr` | 否 | 取决于 | 取决于 |'
- en: The second column in [Table 2-1](#integer_types) shows the name of the type
    in the CLR. Different languages have different naming conventions, and C# uses
    names from its C-family roots for numeric types, but those don’t fit with the
    naming conventions that .NET has for its data types. As far as the runtime is
    concerned, the names in the second column are the real names—there are various
    APIs that can report information about types at runtime, and they report these
    CLR names, not the C# ones. For all but the last two items, the names are synonymous
    in C# source code, so you’re free to use the runtime names if you want to, but
    the C# names are a better stylistic fit—keywords in C-family languages are all
    lowercase. Since the compiler handles these types differently than the rest, it’s
    arguably good to have them stand out.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2-1](#integer_types)中的第二列显示了 CLR 中类型的名称。不同的语言有不同的命名约定，C# 使用其 C 家族根源的名称用于数值类型，但这些名称不符合
    .NET 对其数据类型的命名约定。对于运行时来说，第二列中的名称是真正的名称——有各种 API 可以在运行时报告类型信息，它们报告这些 CLR 名称，而不是
    C# 的名称。除了最后两项外，在 C# 源代码中，名称在语义上是同义词，因此您可以自由地使用运行时名称，但 C# 的名称在风格上更合适——C 家族语言的关键字均为小写。由于编译器处理这些类型的方式与其他类型不同，因此让它们显眼可能是个好主意。'
- en: 'The `nint` and `nuint` types are odd ones out here. These are the *native-sized
    integer* types (hence the `n` prefix), and they are intended for low-level code
    that needs to deal directly with the address of data in memory. This is why they
    don’t have a fixed size—they are 32 bits wide in a 32-bit process and 64 bits
    in a 64-bit process. And unlike all the other types in [Table 2-1](#integer_types),
    different features are available depending on whether you use the C# name or the
    CLR name: C# does not currently permit arithmetic when using `System.IntPtr` or
    `System.UIntPtr`, but it supports it on `nint` and `nuint`, and it also adds various
    implicit conversions from other integer types. These are very specialized types,
    normally only used when writing wrappers for non-.NET libraries, and I’ve included
    them in this table only for completeness.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`nint` 和 `nuint` 类型在这里是特例。这些是*本地大小整数*类型（因此有 `n` 前缀），用于需要直接处理内存中数据地址的低级代码。这就是它们没有固定大小的原因——在
    32 位进程中它们是 32 位宽，在 64 位进程中是 64 位宽。与[表 2-1](#integer_types)中的所有其他类型不同，根据使用 C# 名称或
    CLR 名称的方式，可用的特性也不同：C# 当前不允许在使用 `System.IntPtr` 或 `System.UIntPtr` 时进行算术运算，但它支持
    `nint` 和 `nuint`，并且还添加了来自其他整数类型的各种隐式转换。这些是非常专业的类型，通常仅在为非 .NET 库编写包装器时使用，并且我仅出于完整性将它们包含在这个表格中。'
- en: Warning
  id: totrans-212
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Not all .NET languages support unsigned numbers, so the .NET runtime libraries
    tend to avoid them. A runtime that supports multiple languages (such as the CLR)
    faces a trade-off between offering a type system rich enough to cover most languages’
    needs and forcing an overcomplicated type system on simple languages. To resolve
    this, .NET’s type system, the CTS, is reasonably comprehensive, but languages
    don’t have to support all of it. .NET also defines the Common Language Specification
    (CLS), which identifies a relatively small subset of the CTS that all languages
    should support. Signed integers are in the CLS, but unsigned ones are not. This
    explains some surprising-looking type choices, such as the `Length` property of
    an array being `int` (rather than `uint`) despite the fact that it will never
    return a negative value.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的.NET语言都支持无符号数，因此.NET运行库倾向于避免使用它们。支持多种语言的运行时（如CLR）面临着在提供足够丰富的类型系统以涵盖大多数语言需求之间的权衡，同时又不会强加过于复杂的类型系统于简单的语言上。为解决这个问题，.NET的类型系统CTS相对而言是相当全面的，但语言并不必须支持其全部。.NET还定义了公共语言规范（CLS），它确定了所有语言应支持的相对较小的CTS子集。有符号整数在CLS中，但无符号整数不在其中。这解释了一些看起来令人惊讶的类型选择，比如数组的`Length`属性是`int`（而不是`uint`），尽管它永远不会返回负值。
- en: 'C# also supports floating-point numbers. There are two types: `float` and `double`,
    which are 32-bit and 64-bit numbers in the [standard IEEE 754 formats](https://oreil.ly/ZMz9o),
    and as the CLR names in [Table 2-2](#floating-point_types) suggest, these correspond
    to what are commonly called *single-precision* and *double-precision numbers*.
    Floating-point values do not work in the same way as integers, so this table is
    a little different than the integer types table. Floating-point numbers store
    a value and an exponent (similar in concept to scientific notation but working
    in binary instead of decimal). The Precision column shows how many bits are available
    for the value part, and then the range is expressed as the smallest nonzero value
    and the largest value that can be represented. (These can be either positive or
    negative.)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: C# 也支持浮点数。有两种类型：`float` 和 `double`，分别是32位和64位的数字，符合标准的[IEEE 754格式](https://oreil.ly/ZMz9o)，如[表2-2](#floating-point_types)中的CLR名称所示，这些通常被称为*单精度*和*双精度数*。浮点数值的工作方式与整数不同，因此这张表格与整数类型表格有所不同。浮点数存储值和指数（在概念上类似于科学计数法，但是使用二进制而不是十进制）。精度列显示了值部分有多少位可用，然后范围被表示为可以表示的最小非零值和最大值（这些可以是正数或负数）。
- en: Table 2-2\. Floating-point types
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-2\. 浮点数类型
- en: '| **C# type** | **CLR name** | **Size in bits** | **Precision** | **Range (magnitude)**
    |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| **C# 类型** | **CLR 名称** | **位大小** | **精度** | **范围（数量级）** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `float` | `System.Single` | 32 | 23 bits (~7 decimal digits) | 1.5 × 10^(−45)
    to 3.4 × 10^(38) |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `float` | `System.Single` | 32 | 23 位（约7个十进制数字） | 1.5 × 10^(−45) 到 3.4 ×
    10^(38) |'
- en: '| `double` | `System.Double` | 64 | 52 bits (~15 decimal digits) | 5.0 × 10^(−324)
    to 1.7 × 10^(308) |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `System.Double` | 64 | 52 位（约15个十进制数字） | 5.0 × 10^(−324) 到 1.7
    × 10^(308) |'
- en: C# recognizes a third noninteger numeric representation called `decimal` (or
    `Sys⁠tem.​Dec⁠im⁠al` in the CLR). This is a 128-bit value, so it can offer greater
    precision than the other formats, but it is not just a bigger version of `double`.
    It is designed for calculations that require predictable handling of decimal fractions,
    something neither `float` nor `double` can offer. If you write code that initializes
    a variable of type `float` to 0 and then adds 0.1 to it nine times in a row, you
    might expect to get a value of 0.9, but in fact you’ll get approximately 0.9000001\.
    That’s because IEEE 754 stores numbers in binary, which cannot represent all decimal
    fractions. It can handle some, such as the decimal 0.5; written in base 2, that’s
    0.1\. But the decimal 0.1 turns into a recurring number in binary. (Specifically,
    it’s 0.0 followed by the recurring sequence 0011.) This means `float` and `double`
    can represent only an approximation of the decimal value 0.1, and more generally,
    only a small subset of decimals can be represented completely accurately. This
    isn’t always instantly obvious, because when floating-point numbers are converted
    to text, they are rounded to a decimal approximation that can mask the discrepancy.
    But over multiple calculations, the inaccuracies tend to add up and eventually
    produce surprising-looking results.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: C#识别了第三种非整数数值表示，称为`decimal`（或CLR中的`Sys⁠tem.​Dec⁠im⁠al`）。这是一个128位的值，因此它可以提供比其他格式更高的精度，但它并不仅仅是`double`的扩展版本。它设计用于需要可预测处理小数部分的计算，这是`float`和`double`都无法提供的。如果你编写了这样的代码：将类型为`float`的变量初始化为0，然后连续九次加上0.1，你可能期望得到一个值为0.9，但实际上你会得到大约是0.9000001。这是因为IEEE
    754标准将数字存储为二进制，无法表示所有的十进制小数。它可以处理一些情况，比如十进制的0.5在二进制中表示为0.1。但是十进制的0.1在二进制中会变成一个循环数（具体来说，是0.0后跟一个循环序列0011）。这意味着`float`和`double`只能表示十进制值0.1的近似值，更广义地说，只有少数小数可以被完全准确地表示。这并不总是立即显而易见，因为当浮点数转换为文本时，它们会被舍入为一个可以掩盖差异的十进制近似值。但在多次计算中，这种不准确性往往会累积，最终产生看似令人惊讶的结果。
- en: For some kinds of calculations, this doesn’t really matter; in simulations or
    signal processing, for example, some noise and error is expected. But accountants
    and financial regulators tend to be less forgiving—little discrepancies like this
    can make it look like money has magically vanished or appeared. We need calculations
    that involve money to be absolutely accurate, which makes binary floating point
    a terrible choice for such work. This is why C# offers the `decimal` type, which
    provides a well-defined level of decimal precision.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些类型的计算，这并不重要；例如在模拟或信号处理中，预期会有一些噪声和误差。但是会计师和金融监管者往往不太宽容——这种小的差异可能会让人觉得钱似乎神奇地消失或出现了。我们需要涉及金钱的计算绝对精确，这使得二进制浮点数对于这样的工作来说是一个糟糕的选择。这就是为什么C#提供`decimal`类型，它提供了一个明确定义的十进制精度水平。
- en: Note
  id: totrans-222
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Most of the integer types can be handled natively by the CPU. (All of them can
    when running in a 64-bit process.) Likewise, many CPUs can work directly with
    `float` and `double` representations. However, none has intrinsic support for
    `decimal`, meaning that even simple operations, such as addition, require multiple
    CPU instructions. This means that arithmetic is significantly slower with `decimal`
    than with the other numeric types shown so far.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数整数类型可以由CPU本地处理。（在64位进程中运行时，它们全部可以处理。）同样，许多CPU可以直接处理`float`和`double`的表示。然而，没有一个CPU有内置的支持`decimal`，这意味着即使是简单的操作，如加法，也需要多个CPU指令。这意味着使用`decimal`进行算术运算比迄今为止展示的其他数值类型要慢得多。
- en: A `decimal` stores numbers as a sign bit (positive or negative) and a pair of
    integers. There’s a 96-bit integer, and the value of the `decimal` is this first
    integer (negated if the sign bit says so) divided by 10 raised to the power of
    the second integer, which is a number in the range of 0 to 28.^([6](ch02.xhtml#fn10))
    Ninety-six bits is enough to represent any 28-digit decimal integer (and some,
    but not all, 29-digit ones), so the second integer—the one representing the power
    of 10 by which the first is divided—effectively says where the decimal point goes.
    This format makes it possible to represent any decimal with 28 or fewer digits
    accurately.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`decimal`将数字存储为符号位（正或负）和一对整数。有一个96位整数，而`decimal`的值是这第一个整数（如果符号位表示如此，则取负数）除以10的第二整数次方，这是0到28之间的一个数（并不是所有的29位数，但有一些是）。
    因此，第二个整数——表示第一个整数除以的10的幂——有效地决定了小数点的位置。这种格式使得能够精确表示任何具有28个或更少数字的十进制数。'
- en: When you write a literal numeric value, you can choose the type, or you can
    let the compiler pick a suitable type for you. If you write a plain integer, such
    as `123`, its type will be `int`, `uint`, `long`, or `ulong`—the compiler picks
    the first type from that list with a range that contains the value. (So `123`
    would be an `int`, `3000000000` would be a `uint`, `5000000000` would be a `long`,
    etc.) If you write a number with a decimal point, such as `1.23`, its type is
    `double`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当您编写字面数值时，可以选择类型，也可以让编译器为您选择合适的类型。如果您写一个普通整数，比如 `123`，其类型将为 `int`、`uint`、`long`
    或 `ulong` — 编译器将从这些范围包含该值的第一个类型中进行选择（所以 `123` 将是 `int`，`3000000000` 将是 `uint`，`5000000000`
    将是 `long` 等）。如果您写一个带有小数点的数字，例如 `1.23`，其类型是 `double`。
- en: If you’re dealing with large numbers, it’s very easy to get the number of zeros
    wrong. This is usually bad and possibly very expensive or dangerous, depending
    on your application area. C# provides some mitigation by allowing you to add underscores
    anywhere in numeric literals, to break the numbers up however you please. This
    is analogous to the common practice in most English-speaking countries of using
    a comma to separate zeros into groups of three. For example, instead of writing
    5000000000, most native English speakers would write 5,000,000,000, instantly
    making it much easier to see that this is 5 billion and not, say, 50 billion,
    or 500 million. (What many native English speakers don’t know is that several
    countries around the world use a period for this and would write 5.000.000.000
    instead, using the comma where most native English speakers would put a decimal
    point. Interpreting a value such as €100.000 requires you to know which country’s
    conventions are in use if you don’t want to make a disastrous financial miscalculation.
    But I digress.) In C# we can do something similar by writing the numeric literal
    as `5_000_000_000`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您处理大数，很容易搞错零的数量。这通常是不好的，可能会非常昂贵或危险，具体取决于您的应用领域。C#通过允许在数字文字中的任何位置添加下划线来提供一些缓解，可以根据您的需求将数字分割开来。这类似于大多数讲英语的国家中常见的用逗号将零分组成三组的常见做法。例如，大多数以英语为母语的人不会写5000000000，而会写成5,000,000,000，这样一来，您能够立即看到这是50亿而不是500亿或500百万。
    （很多以英语为母语的人不知道的是，世界上有几个国家使用句号，而不是逗号。这些国家会把5,000,000,000写成5.000.000.000，而把逗号放在大多数以英语为母语的人会把小数点放的位置。要理解一个像€100.000这样的值，您需要知道正在使用哪个国家的惯例，以免犯灾难性的金融计算错误。不过，我岔开了话题。）
    在C#中，我们可以通过将数字文字写成 `5_000_000_000` 来做类似的事情。
- en: You can tell the compiler that you want a specific type by adding a suffix.
    So `123U` is a `uint`, `123L` is a `long`, and `123UL` is a `ulong`. Suffix letters
    are case- and order-independent, so instead of `123UL`, you could write `123Lu`,
    `123uL`, or any other permutation. For `double`, `float`, and `decimal`, use the
    `D`, `F`, and `M` suffixes, respectively.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加后缀，您可以告诉编译器您需要的特定类型。因此，`123U` 是 `uint`，`123L` 是 `long`，而 `123UL` 则是 `ulong`。后缀字母不区分大小写和顺序，所以您可以写成
    `123UL`，也可以写成 `123Lu`、`123uL` 或任何其他排列组合。对于 `double`、`float` 和 `decimal`，分别使用后缀
    `D`、`F` 和 `M`。
- en: These last three types all support a decimal exponential literal format for
    large numbers, where you put a decimal, then the letter `E` followed by an integer.
    The value is the first number multiplied by 10 raised to the power of the second.
    For example, the literal value `1.5E-20` is the value 1.5 multiplied by 10^(−20).
    (This happens to be of type `double`, because that’s the default for a number
    with a decimal point, regardless of whether it’s in exponential format. You could
    write `1.5E-20F` and `1.5E-20M` for `float` and `decimal` constants with equivalent
    values.)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这些最后三种类型都支持大数字的十进制指数字面量格式，其中您先放置一个小数点，然后是字母`E`，后跟一个整数。该值是第一个数字乘以10的第二个数字次方。例如，字面值`1.5E-20`是值1.5乘以10^(−20)的结果。（这恰好是`double`类型，因为这是具有小数点的数字的默认类型，无论其是否处于指数格式中。您可以写`1.5E-20F`和`1.5E-20M`来表示等效值的`float`和`decimal`常量。
- en: 'It’s often useful to be able to write integer literals in hexadecimal, because
    the digits map better onto the binary representation used at runtime. This is
    particularly important when different bit ranges of a number represent different
    things. For example, you may need to deal with a numeric error code that originated
    from a Windows system call—these occasionally crop up in exceptions. In some cases,
    these codes use the topmost bit to indicate success or failure, the next few bits
    to indicate the origin of the error, and the remaining bits to identify the specific
    error. For example, the COM error code E_ACCESSDENIED has the value −2,147,024,891\.
    It’s hard to see the structure in decimal, but in hexadecimal, it’s easier: 80070005\.
    The 8 indicates that this is an error, and the 007 that follows indicates that
    this was originally a plain Win32 error that has been translated into a COM error.
    The remaining bits indicate that the Win32 error code was 5 (ERROR_ACCESS_DENIED).
    C# lets you write integer literals in hexadecimal for scenarios like these, where
    the hex representation is more readable. You just prefix the number with `0x`;
    therefore, in this case, you would write `0x80070005`.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在十六进制中写入整数字面量通常很有用，因为数字在运行时使用的二进制表示中更好地映射到数字。当数字的不同位范围表示不同事物时，这一点尤为重要。例如，您可能需要处理来自Windows系统调用的数值错误代码——这些错误偶尔会出现在异常中。在某些情况下，这些代码使用最高位来指示成功或失败，接下来的几位表示错误的起源，剩余的位用于标识具体的错误。例如，COM错误代码E_ACCESSDENIED的值为−2,147,024,891\.
    在十进制中很难看到结构，但在十六进制中更容易：80070005\. 数字8表示这是一个错误，接下来的007表示这原本是一个普通的Win32错误，已经转换为COM错误。剩余的位表示Win32错误代码为5（ERROR_ACCESS_DENIED）。在这种情况下，C#允许您以十六进制编写整数字面量，以便更清晰地阅读。只需在数字前加上`0x`；因此，在这种情况下，您会写成`0x80070005`。
- en: 'You can also write binary literals by using the `0b` prefix. Digit separators
    can be used in hex and binary just as they can in decimals, although it’s more
    common to group binary digits by fours, like so: `0b_0010_1010`. Obviously this
    makes any binary structure in a number even more evident than hexadecimal does,
    but 32-bit binary literals are inconveniently long, which is why we often use
    hexadecimal instead.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`0b`前缀编写二进制字面量。在十六进制和二进制中可以像在十进制中一样使用数字分隔符，虽然在四位一组地分组二进制数字比十六进制更常见，如此：`0b_0010_1010`。显然，这比十六进制使数字中的任何二进制结构更加明显，但32位二进制字面量的长度令人不便，这就是为什么我们经常使用十六进制的原因。
- en: Numeric conversions
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数字转换
- en: Each of the built-in numeric types uses a different representation for storing
    numbers in memory. Converting from one form to another requires some work—even
    the number 1 looks quite different if you inspect its binary representations as
    a `float`, an `int`, and a `decimal`. However, C# is able to generate code that
    converts between formats, and it will often do so automatically. [Example 2-33](#implicit_conversions)
    shows some cases in which this will happen.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 每种内置的数字类型在内存中存储数字时使用不同的表示。从一种形式转换为另一种形式需要一些工作，即使数字1在查看其二进制表示作为`float`、`int`和`decimal`时看起来差异很大。然而，C#能够生成代码来在各种格式之间进行转换，并且通常会自动执行这些转换。[示例 2-33](#implicit_conversions)
    展示了一些会发生这种情况的案例。
- en: Example 2-33\. Implicit conversions
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-33\. 隐式转换
- en: '[PRE35]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The second line assigns the value of an `int` variable into a `double` variable.
    The C# compiler generates the necessary code to convert the integer value into
    its equivalent floating-point value. More subtly, the last two lines will perform
    similar conversions, as we can see from the output of that code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行将一个`int`变量的值赋给一个`double`变量。C#编译器会生成必要的代码，将整数值转换为其等效的浮点值。更微妙的是，最后两行将执行类似的转换，正如我们从代码的输出中可以看到的那样：
- en: '[PRE36]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This shows that the first division produced an integer result—dividing the integer
    variable `i` by the integer literal 5 caused the compiler to generate code that
    performs integer division, so the result is 8\. But the other two divisions produced
    a floating-point result. In the second case, we’ve divided the `double` variable
    `di` by an integer literal 5\. C# converts that 5 to floating point before performing
    the division. (As an optimization, in this particular case the compiler happens
    to perform that conversion at compile time, so it emits the same code for that
    expression as it would if we had written `di / 5.0`.) And in the final line, we’re
    dividing an integer variable by a floating-point literal. This time, it’s the
    variable’s value that gets turned from an integer into a floating-point value
    before the division takes place. (Since `i` is a variable, not a constant, the
    compiler emits code that performs that conversion at runtime.)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明第一次除法产生了一个整数结果——将整数变量`i`除以整数文字5导致编译器生成执行整数除法的代码，因此结果为8。但另外两个除法产生了浮点结果。在第二种情况下，我们将`double`变量`di`除以整数文字5。在执行除法之前，C#将该5转换为浮点数。
    （作为优化，在这种特定情况下，编译器恰好在编译时执行了该转换，因此它为该表达式生成了与我们写了`di / 5.0`相同的代码。）而在最后一行中，我们将整数变量除以浮点文字。这次是变量的值在执行除法之前从整数转换为浮点值。（由于`i`是一个变量，而不是常量，因此编译器会生成在运行时执行该转换的代码。）
- en: In general, when you perform arithmetic calculations that involve a mixture
    of numeric types, C# will pick the type with the largest range and *promote* values
    of types with a narrower range into that larger one before performing the calculations.
    (Arithmetic operators generally require all their operands to have the same type,
    so if you supply operands with different types, one type has to “win” for any
    particular operator.) For example, `double` can represent any value that `int`
    can, and many that it cannot, so `double` is the more expressive type.^([7](ch02.xhtml#fn11))
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一般情况下，当您执行包含不同数值类型混合的算术运算时，C#会选择具有最大范围的类型，并在执行计算之前将具有较窄范围的类型的值*提升*为该较大类型。 （算术运算符通常要求所有操作数具有相同的类型，因此如果您提供具有不同类型的操作数，则某种类型必须在任何特定的运算符中“获胜”。）例如，`double`可以表示`int`可以表示的任何值，以及许多`int`无法表示的值，因此`double`是更具表现力的类型。^([7](ch02.xhtml#fn11))
- en: C# will perform numeric conversions implicitly whenever the conversion is a
    promotion (i.e., the target type has a wider range than the source), because there
    is no possibility of the conversion failing. However, it will not implicitly convert
    in the other direction. The second and third lines of [Example 2-34](#errors_implicit_conversions_unavailable)
    will fail to compile, because they attempt to assign expressions of type `double`
    into an `int`, which is a *narrowing* conversion, meaning that the source might
    contain values that are out of the target’s range.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，当转换是升级（即目标类型比源类型范围更广）时，C#会隐式执行数值转换，因为不存在转换失败的可能性。然而，在另一个方向上，它不会隐式转换。[示例 2-34](#errors_implicit_conversions_unavailable)的第二和第三行将无法编译通过，因为它们试图将`double`类型的表达式分配给`int`，这是一种*缩小*转换，意味着源类型可能包含超出目标范围的值。
- en: 'Example 2-34\. Errors: implicit conversions not available'
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-34\. 错误：隐式转换不可用
- en: '[PRE37]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It is possible to convert in this direction, just not implicitly. You can use
    a *cast*, where you specify the name of the type to which you’d like to convert
    in parentheses. [Example 2-35](#explicit_conversions_with_casts) shows a modified
    version of [Example 2-34](#errors_implicit_conversions_unavailable), where we
    state explicitly that we want a conversion to `int`, and we either don’t mind
    that this conversion might not work correctly or we have reason to believe that,
    in this specific case, the value will be in range. Note that on the final line
    I’ve put parentheses around the expression after the cast. That makes the cast
    apply to the whole expression; otherwise, C#’s rules of precedence mean it would
    apply just to the `i` variable, and since that’s already an `int`, it would have
    no effect.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方向上是可以转换的，只是不能隐式转换。你可以使用*强制转换*，在括号中指定要转换为的类型的名称。[示例 2-35](#explicit_conversions_with_casts)展示了[示例
    2-34](#errors_implicit_conversions_unavailable)的修改版本，我们明确表示我们要转换为`int`，并且要么不介意这个转换可能不正确，要么有理由相信，在这种特定情况下，值将在范围内。请注意，在最后一行中，我在强制转换后的表达式周围加上了括号。这使得强制转换应用于整个表达式；否则，C#的优先规则意味着它只适用于`i`变量，而由于那已经是一个`int`，它将没有效果。
- en: Example 2-35\. Explicit conversions with casts
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-35\. 使用强制转换进行显式转换
- en: '[PRE38]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: So narrowing conversions require explicit casts, and conversions that cannot
    lose information occur implicitly. However, with some combinations of types, neither
    is strictly more expressive than the other. What should happen if you try to add
    an `int` to a `uint`? Or an `int` to a `float`? These types are all 32 bits in
    size, so none of them can possibly offer more than 2^(32) distinct values, but
    they have different ranges, which means that each has values it can represent
    that the other types cannot. For example, you can represent the value 3,000,000,001
    in a `uint`, but it’s too large for an `int` and can only be approximated in a
    `float`. As floating-point numbers get larger, the values that can be represented
    get farther apart—a `float` can represent 3,000,000,000 and also 3,000,001,024
    but nothing in between. So for the value 3,000,000,001, `uint` seems better than
    `float`. But what about −1? That’s a negative number, so `uint` can’t cope with
    that. Then there are very large numbers that `float` can represent that are out
    of range for both `int` and `uint`. Each of these types has its strengths and
    weaknesses, and it makes no sense to say that one of them is generally better
    than the rest.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，缩小转换需要显式转换，而不能丢失信息的转换会隐式发生。然而，对于某些类型的组合，两者都不严格比另一个更具表现力。如果尝试将`int`加到`uint`，或者将`int`加到`float`会发生什么？这些类型都是32位大小，因此它们都不可能提供超过2^(32)个不同的值，但它们具有不同的范围，这意味着每种类型都有它可以表示的值，其他类型无法表示。例如，你可以在`uint`中表示值3000000001，但对于`int`来说太大了，只能在`float`中近似表示。随着浮点数变得更大，可以表示的值之间的距离变得更远——`float`可以表示3000000000和3000001024，但中间没有任何值。因此，对于值3000000001，`uint`似乎比`float`更好。但是-1呢？那是一个负数，所以`uint`无法处理。然后有一些非常大的数字，`float`可以表示，但对于`int`和`uint`来说超出范围。每种类型都有其优势和劣势，说其中一种通常比其他类型更好是没有意义的。
- en: 'Surprisingly, C# allows some implicit conversions even in these potentially
    lossy scenarios. The rules consider only range, not precision: implicit conversions
    are allowed if the target type’s range completely contains the source type’s range.
    So you can convert from either `int` or `uint` to `float`, because although `float`
    is unable to represent some values exactly, there are no `int` or `uint` values
    that it cannot at least approximate. But implicit conversions are not allowed
    in the other direction, because there are some `float` values that are simply
    too big—unlike `float`, the integer types can’t offer approximations for bigger
    numbers.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，即使在这些潜在的有损情况下，C#也允许一些隐式转换。规则只考虑范围，而不考虑精度：如果目标类型的范围完全包含源类型的范围，则允许隐式转换。因此，你可以从`int`或`uint`转换为`float`，因为虽然`float`无法精确表示某些值，但至少没有`int`或`uint`值它无法至少近似表示。但是，不允许在另一个方向进行隐式转换，因为有些`float`值太大了——与`float`不同，整数类型无法为更大的数字提供近似值。
- en: You might be wondering what happens if you force a narrowing conversion to `int`
    with a cast, as [Example 2-35](#explicit_conversions_with_casts) does, in situations
    where the number is out of range. The answer depends on the type from which you
    are casting. Conversion from one integer type to another works differently than
    conversion from floating point to integer. In fact, the C# specification does
    not define how floating-point numbers that are too big should be converted to
    an integer type—the result could be anything. But when casting between integer
    types, the outcome is well defined. If the two types are of different sizes, the
    binary will be either truncated or padded with zeros (or ones, if the source type
    is signed and the value is negative) to make it the right size for the target
    type, and then the bits are just treated as if they are of the target type. This
    is occasionally useful but can more often produce surprising results, so you can
    choose an alternative behavior for any out-of-range cast by making it a *checked*
    conversion.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当你强制将一个数值转换为`int`类型时，可能会想知道在超出范围的情况下会发生什么，就像[示例 2-35](#explicit_conversions_with_casts)中所做的那样。答案取决于你要转换的类型。从一个整数类型到另一个整数类型的转换与从浮点数到整数的转换有所不同。事实上，C#规范并未定义如何将过大的浮点数转换为整数类型——结果可能是任何值。但是当在不同大小的整数类型之间进行转换时，结果是明确定义的。如果两种类型的大小不同，二进制数据将会被截断或填充零（或者如果源类型是有符号的且值为负，则填充为一），以使其成为目标类型的正确大小，然后这些位将被视为目标类型的位。这有时很有用，但更可能会产生令人惊讶的结果，因此你可以通过将其设置为*checked*转换来选择任何超出范围的转换的替代行为。
- en: Checked contexts
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*checked*上下文'
- en: C# defines the `checked` keyword, which you can put in front of either a block
    statement or an expression, making it a *checked context*. This means that certain
    arithmetic operations, including casts, are checked for range overflow at runtime.
    If you cast a value to an integer type in a checked context and the value is too
    high or low to fit, an error will occur—the code will throw a `System.OverflowException`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: C#定义了`checked`关键字，你可以将其放在块语句或表达式前面，使其成为*checked*上下文。这意味着某些算术操作，包括转换，会在运行时检查是否发生了范围溢出。如果在*checked*上下文中将一个值转换为整数类型，且该值过高或过低以至于无法容纳，将会导致错误——代码将抛出`System.OverflowException`。
- en: As well as checking casts, a checked context will detect range overflows in
    ordinary arithmetic. Addition, subtraction, and other operations can take a value
    beyond the range of its data type. For integers, this causes the value to “roll
    over” when unchecked, so adding 1 to the maximum value produces the minimum value,
    and vice versa for subtraction. Occasionally, this wrapping can be useful. For
    example, if you want to determine how much time has elapsed between two points
    in the code, one way to do this is to use the `Environment.TickCount` property.^([8](ch02.xhtml#fn12))
    (This is more reliable than using the current date and time, because that can
    change as a result of the clock being adjusted or when moving between time zones.
    The tick count just keeps increasing at a steady rate. That said, in real code
    you’d probably use the runtime libraries’ `Stopwatch` class.) [Example 2-36](#exploiting_unchecked_integer_overflow)
    shows one way to do this.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 除了检查转换外，*checked*上下文还将检测普通算术中的范围溢出。加法、减法和其他操作可能使一个值超出其数据类型的范围。对于整数来说，当未经检查时，这会导致数值“溢出”，因此将最大值加1会产生最小值，反之亦然。有时这种环绕操作可能很有用。例如，如果你想确定代码中两个时间点之间经过了多少时间，一种方法是使用`Environment.TickCount`属性。^([8](ch02.xhtml#fn12))（这比使用当前日期和时间更可靠，因为后者可能会因时钟调整或时区切换而改变。Tick
    count会以稳定的速率不断增加。尽管如此，在实际代码中，你可能会使用运行时库的`Stopwatch`类。）[示例 2-36](#exploiting_unchecked_integer_overflow)展示了一种实现这一点的方法。
- en: Example 2-36\. Exploiting unchecked integer overflow
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-36\. 利用未检查的整数溢出
- en: '[PRE39]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The tricky thing about `Environment.TickCount` is that it occasionally “wraps
    around.” It counts the number of milliseconds since the system last rebooted,
    and since its type is `int`, it will eventually run out of range. A span of 25
    days is 2.16 billion milliseconds—too large a number to fit in an `int`. (You
    could avoid this by using the `TickCount64` property, which is good for almost
    300 million years. But this is unavailable in .NET Framework, or any current .NET
    Standard.) Imagine the tick count is 2,147,483,637, which is 10 short of the maximum
    value for `int`. What would you expect it to be 100 ms later? It can’t be 100
    higher (2,147,483,727), because that’s too big a value for an `int`. We’d expect
    it to get to the highest possible value after 10 ms, so after 11 ms, it’ll roll
    round to the minimum value; thus, after 100 ms, we’d expect the tick count to
    be 89 above the minimum value (which would be −2,147,483,559).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`Environment.TickCount`的棘手之处在于它偶尔会“环绕”。它计算自系统上次启动以来的毫秒数，由于其类型为`int`，最终会超出范围。25天的时间跨度是21.6亿毫秒，这个数字对于`int`来说太大了。（可以通过使用`TickCount64`属性来避免这种情况，它可以支持近3亿年的时间。但在.NET
    Framework或任何当前的.NET标准中都不可用。）假设时刻数为2,147,483,637，比`int`的最大值少10。你希望它在100毫秒后是多少？它不能比之前的值高100（2,147,483,727），因为那对于`int`来说太大了。我们期望它在10毫秒后达到最大可能值，因此在11毫秒后，它将会回到最小值；因此，在100毫秒后，我们预期时刻数将比最小值高89（即−2,147,483,559）。'
- en: Warning
  id: totrans-254
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The tick count is not necessarily precise to the nearest millisecond in practice.
    It often stands still for milliseconds at a time before leaping forward in increments
    of 10 ms, 15 ms, or even more. However, the value still rolls over—you just might
    not be able to observe every possible tick value as it does so.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，时刻数并不一定精确到最近的毫秒。在跳跃前，它通常会静止几毫秒的时间，然后以10毫秒、15毫秒或更多的增量向前跳跃。然而，这个值仍然会溢出——你可能无法观察到它的每一个可能的时刻值在溢出时的情况。
- en: Interestingly, [Example 2-36](#exploiting_unchecked_integer_overflow) handles
    this perfectly. If the tick count in `start` was obtained just before the count
    wrapped, and the one in `end` was obtained just after, `end` will contain a much
    lower value than `start`, which seems upside down, and the difference between
    them will be large—larger than the range of an `int`. However, when we subtract
    `start` from `end`, the overflow rolls over in a way that exactly matches the
    way the tick count rolls over, meaning we end up getting the correct result regardless.
    For example, if the `start` contains a tick count from 10 ms before rollover,
    and `end` is from 90 ms afterward, subtracting the relevant tick counts (i.e.,
    subtracting −2,147,483,558 from 2,147,483,627) seems like it should produce a
    result of 4,294,967,185\. But because of the way the subtraction overflows, we
    actually get a result of 100, which corresponds to the elapsed time of 100 ms.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，[示例 2-36](#exploiting_unchecked_integer_overflow) 完美地处理了这个问题。如果 `start`
    中的时刻数在计数环绕之前获得，而 `end` 中的时刻数在之后获得，`end` 将包含一个比 `start` 低得多的值，这似乎有些反常，它们之间的差异将会很大——大于一个
    `int` 的范围。然而，当我们从 `start` 中减去 `end` 时，溢出会以与时刻数溢出完全匹配的方式发生，这意味着我们最终会得到正确的结果。例如，如果
    `start` 包含从溢出前10毫秒获得的时刻数，而 `end` 是从之后90毫秒获得的，减去相关的时刻数（即减去−2,147,483,558从2,147,483,627），看起来应该产生4,294,967,185的结果。但由于减法溢出的方式，我们实际上得到了一个结果为100，这对应于100毫秒的经过时间。
- en: But in most cases, this sort of integer overflow is undesirable. It means that
    when dealing with large numbers, you can get results that are completely incorrect.
    A lot of the time, this is not a big risk, because you will be dealing with fairly
    small numbers, but if there is any possibility that your calculations might encounter
    overflow, you might want to use a checked context. Any arithmetic performed in
    a checked context will throw an exception when overflow occurs. You can request
    this in an expression with the `checked` operator, as [Example 2-37](#checked_expression)
    shows. Everything inside the parentheses will be evaluated in a checked context,
    so you’ll see an `OverflowException` if the addition of `a` and `b` overflows.
    The `checked` keyword does not apply to the whole statement here, so if an overflow
    happens as a result of adding `c`, that will not cause an exception.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 但在大多数情况下，这种整数溢出是不可取的。这意味着在处理大数时，可能会得到完全不正确的结果。通常情况下，这不是一个大问题，因为你将处理的是相当小的数字，但如果你的计算可能会遇到溢出的可能性，你可能希望使用
    checked 上下文。在表达式中使用 `checked` 运算符可以请求这一点，就像[示例 2-37](#checked_expression)所示的那样。括号内的所有内容将在
    checked 上下文中进行评估，所以如果将 `a` 和 `b` 相加时发生溢出，你将看到 `OverflowException`。这里 `checked`
    关键字并不适用于整个语句，因此如果由于添加 `c` 而导致溢出，则不会引发异常。
- en: Example 2-37\. Checked expression
  id: totrans-258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-37\. Checked 表达式
- en: '[PRE40]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You can also turn on checking for an entire block of code with a `checked` statement,
    which is a block preceded by the `checked` keyword, as [Example 2-38](#checked_statement)
    shows. Checked statements always involve a block—you cannot just add the `checked`
    keyword in front of the `int` keyword in [Example 2-37](#checked_expression) to
    turn that into a checked statement. You’d also need to wrap the code in braces.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过 `checked` 语句来为整个代码块开启检查，这是一个以 `checked` 关键字开头的块，如[示例 2-38](#checked_statement)所示。`checked`
    语句总是涉及一个块 —— 你不能只在[示例 2-37](#checked_expression)中的 `int` 关键字前面添加 `checked` 关键字就将其转换为
    `checked` 语句。你还需要将代码放在大括号中。
- en: Example 2-38\. Checked statement
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-38\. Checked 语句
- en: '[PRE41]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Warning
  id: totrans-263
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: A `checked` block only affects the lines of code inside the block. If the code
    invokes any methods, those will be unaffected by the presence of the `checked`
    keyword—there isn’t some *checked* bit in the CPU that gets enabled on the current
    thread inside a `checked` block. (In other words, this keyword’s scope is lexical,
    not dynamic.)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`checked` 块只影响块内的代码行。如果代码调用任何方法，这些方法不会受到 `checked` 关键字的影响——CPU 中没有某种 *checked*
    位在 `checked` 块内启用当前线程。（换句话说，此关键字的范围是词法作用域，而非动态作用域。）'
- en: C# also has an `unchecked` keyword. You can use this inside a checked block
    to indicate that a particular expression or nested block should not be a checked
    context. This makes life easier if you want everything except for one particular
    expression to be checked—rather than having to label everything except the chosen
    part as checked, you can put all the code into a checked block and then exclude
    the one piece that wants to allow overflow without errors.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: C# 还有一个 `unchecked` 关键字。你可以在 `checked` 块内使用它来指示特定表达式或嵌套块不应处于 checked 上下文中。如果你希望除了一个特定表达式外的所有内容都要检查，而不是将所有内容标记为
    checked，你可以将所有代码放入 checked 块中，然后排除希望允许溢出而无错误的部分。
- en: You can configure the C# compiler to put everything into a checked context by
    default, so that only explicitly `unchecked` expressions and statements will be
    able to overflow silently. In Visual Studio, you can configure this by opening
    the project properties, going to the Build tab, and clicking the Advanced button.
    Or you can edit the *.csproj* file, adding `<CheckForOverflowUnderflow>true</CheckFor​Ove⁠rfl⁠owU⁠nde⁠rfl⁠ow>`
    inside a `<PropertyGroup>`. Be aware that there’s a significant cost—checking
    can make individual integer operations several times slower. The impact on your
    application as a whole will be smaller, because programs don’t spend their whole
    time performing arithmetic, but the cost may still be nontrivial. Of course, as
    with any performance matter, you should measure the practical impact. You may
    find that the performance cost is an acceptable price to pay for the guarantee
    that you will find out about unexpected overflows.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以配置C#编译器，使其默认将所有内容放入检查上下文中，以便仅显式`unchecked`表达式和语句才能在溢出时静默失败。在Visual Studio中，您可以通过打开项目属性，转到“生成”选项卡，然后单击“高级”按钮来配置此设置。或者您可以编辑*.csproj*文件，在`<PropertyGroup>`中添加`<CheckForOverflowUnderflow>true</CheckFor​Ove⁠rfl⁠owU⁠nde⁠rfl⁠ow>`。请注意，这样做会有显著的成本——检查可能会使单个整数操作变慢数倍。整体上对应用程序的影响将较小，因为程序不会花费全部时间执行算术运算，但成本可能仍然不容忽视。当然，与任何性能问题一样，您应该测量实际影响。您可能会发现，性能成本是为了保证发现意外溢出而支付的可接受代价。
- en: BigInteger
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BigInteger
- en: 'There’s one last numeric type worth being aware of: `BigInteger`. It’s part
    of the runtime libraries and gets no special recognition from the C# compiler,
    so it doesn’t strictly belong in this section of the book. However, it defines
    arithmetic operators and conversions, meaning that you can use it just like the
    built-in data types. It will compile to slightly less compact code—the compiled
    format for .NET programs can represent integers and floating-point values natively,
    but `BigInteger` has to rely on the more general-purpose mechanisms used by ordinary
    class library types. In theory it is likely to be significantly slower too, although
    in an awful lot of code, the speed at which you can perform basic arithmetic on
    small integers is not a limiting factor, so it’s quite possible that you won’t
    notice. And as far as the programming model goes, it looks and feels like a normal
    numeric type in your code.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个最后一个值得注意的数字类型：`BigInteger`。它是运行时库的一部分，并且不会受到C#编译器的特殊认可，因此严格来说不属于本书的这一部分。然而，它定义了算术运算符和转换，这意味着你可以像使用内置数据类型一样使用它。它将编译为稍微不那么紧凑的代码格式——.NET程序的编译格式可以原生地表示整数和浮点值，但是`BigInteger`必须依赖于普通类库类型使用的更通用的机制。从理论上讲，它可能会慢得多，尽管在大量代码中，你对小整数进行基本算术运算的速度并不是限制因素，所以你可能不会注意到这一点。至于编程模型，它在你的代码中看起来和感觉像是正常的数字类型。
- en: As the name suggests, a `BigInteger` represents an integer. Its unique selling
    point is that it will grow as large as is necessary to accommodate values. So
    unlike the built-in numeric types, it has no theoretical limit on its range. [Example 2-39](#using_biginteger)
    uses it to calculate values in the Fibonacci sequence, showing every 100,000th
    value. This quickly produces numbers far too large to fit into any of the other
    integer types. I’ve shown the full source of this example, including the `using`
    directive, to illustrate that this type is defined in the `System.Numerics` namespace.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，`BigInteger`代表一个整数。它的独特卖点是它将根据需要增长以容纳值。因此，与内置数值类型不同，它在范围上没有理论限制。[示例 2-39](#using_biginteger)使用它来计算斐波那契数列中的值，并显示每10万个值。这很快产生了远远超出其他整数类型范围的数字。我展示了此示例的完整源代码，包括`using`指令，以说明此类型定义在`System.Numerics`命名空间中。
- en: Example 2-39\. Using `BigInteger`
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-39\. 使用`BigInteger`
- en: '[PRE42]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Although `BigInteger` imposes no fixed limit, there are practical limits. You
    might produce a number that’s too big to fit in the available memory, for example.
    Or more likely, the numbers may grow large enough that the amount of CPU time
    required to perform even basic arithmetic becomes prohibitive. But until you run
    out of either memory or patience, `BigInteger` will grow to accommodate numbers
    as large as you like.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`BigInteger`没有固定的限制，但存在实际限制。例如，您可能会生成一个超出可用内存范围的数字。或者更有可能的是，数字可能会增长到足以使即使是基本算术所需的CPU时间变得不可接受的程度。但在耗尽内存或耐心之前，`BigInteger`将会增长以容纳任意大的数字。
- en: Booleans
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'C# defines a type called `bool`, or as the runtime calls it, `System.Boolean`.
    This offers only two values: `true` and `false`. Whereas some C-family languages
    allow numeric types to stand in for Boolean values, with conventions such as 0
    meaning false and anything else meaning true, C# will not accept a number. It
    demands that values indicating truth or falsehood be represented by a `bool`,
    and none of the numeric types is convertible to `bool`. For example, in an `if`
    statement, you cannot write `if (someNumber)` to get some code to run only when
    `someNumber` is nonzero. If that’s what you want, you need to say so explicitly
    by writing `if (someNumber != 0)`.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: C#定义了一个叫做 `bool` 的类型，或者在运行时称之为 `System.Boolean`。它只提供了两个值： `true` 和 `false`。而某些C语言家族允许数字类型代表布尔值，例如约定使用0表示假和其他任何值表示真，C#不会接受数字。它要求用
    `bool` 表示真或假，并且任何数字类型都不能转换为 `bool`。例如，在 `if` 语句中，你不能写 `if (someNumber)` 来仅在 `someNumber`
    非零时运行某些代码。如果你想要这样做，你需要明确地写成 `if (someNumber != 0)`。
- en: Strings and Characters
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串和字符
- en: The `string` type (synonymous with the CLR `System.String` type) represents
    text. A string is a sequence of values of type `char` (or `System.Char`, as the
    CLR calls it), and each `char` is a 16-bit value representing a single UTF-16
    *code unit*.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`string` 类型（与CLR `System.String` 类型同义）代表文本。字符串是一系列 `char` 类型的值（或CLR称之为 `System.Char`），每个
    `char` 是一个表示单个UTF-16 *代码单元* 的16位值。'
- en: 'A common mistake is to think that each `char` represents a character. (The
    type’s name has to share some of the blame for this.) It’s often true, but not
    always. There are two factors to bear in mind: first, something that we might
    think of as a single character can be made up from multiple Unicode *code points*.
    (The code point is Unicode’s central concept and in English at least, each character
    is represented by a single code point, but some languages are more complex.) [Example 2-40](#characters_vs_char)
    uses Unicode’s 0301 “COMBINING ACUTE ACCENT” to add an accent to a letter to form
    the text `cafés`.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的错误是认为每个 `char` 表示一个字符。（类型的名称要为此负责的一部分。）这通常是正确的，但并非总是如此。需要记住两个因素：首先，我们可能认为是单个字符的东西可以由多个Unicode
    *代码点* 组成。（代码点是Unicode的核心概念，至少在英语中，每个字符都由一个单独的代码点表示，但某些语言更复杂。）[示例 2-40](#characters_vs_char)
    使用Unicode的0301“组合重音符号”在字母上添加重音以形成文本 `cafés`。
- en: Example 2-40\. Characters versus `char`
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-40\. 字符与 `char`
- en: '[PRE43]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: So this string is a sequence of six `char` values, but it represents text that
    seems to contain just five characters. There are other ways to achieve this—I
    could have used code point 00E9 “LATIN SMALL LETTER E WITH ACUTE” to represent
    that accented character as a single code point. But either approach is valid,
    and there are plenty of scenarios in which the only way to create the exact character
    required is to use this combining character mechanism. This means that certain
    operations on the `char` values in a string can have surprising results—if you
    were to reverse the order of the values, the resulting string would not look like
    a reversed version of the text—the acute accent would now apply to the s, resulting
    in `śefac`! (If I had used 00E9 instead of combining e with 0301, reversing the
    characters would have produced the less surprising `séfac`.)
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个字符串是六个 `char` 值的序列，但它代表的文本看起来只包含五个字符。还有其他方法可以实现这一点——我可以使用代码点00E9“拉丁小写带重音的e”来表示该重音字符作为单个代码点。但任何一种方法都是有效的，并且在某些场景中，创建所需确切字符的唯一方法是使用这种组合字符机制。这意味着对字符串中的
    `char` 值执行某些操作可能会产生令人惊讶的结果——如果你颠倒值的顺序，结果字符串看起来不会像文本的颠倒版本——重音符号现在会应用于s，导致 `śefac`！（如果我使用00E9而不是组合e和0301，颠倒字符将产生不那么令人惊讶的
    `séfac`。）
- en: Unicode’s combining marks notwithstanding, there is a second factor to consider.
    The Unicode standard defines more code points than can be represented in a single
    16-bit value. (We passed that point back in 2001, when Unicode 3.1 defined 94,205
    code points.) UTF-16 represents any code point with a value higher than 65,535
    as a pair of UTF-16 code units, referred to as a *surrogate pair*. The Unicode
    standard defines rules for mapping code points to surrogate pairs in a way that
    the resulting code units have values in the range 0xD800 to 0xDFFF, a reserved
    range for which no code points will ever be defined. (For example, code point
    10C48, “OLD TURKIC LETTER ORKHON BASH,” which looks like ![](assets/pc10_02in01.png),
    would become 0xD803, followed by 0xDC48.)
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Unicode 的组合标记，还有第二个因素需要考虑。Unicode 标准定义的代码点数量多于可以用单个 16 位值表示的数量。（我们在 2001
    年超过了这一点，当时 Unicode 3.1 定义了 94,205 个代码点。）UTF-16 将任何值大于 65,535 的代码点表示为一对 UTF-16
    代码单元，称为*代理对*。Unicode 标准定义了将代码点映射到代理对的规则，以便生成的代码单元的值在 0xD800 到 0xDFFF 的范围内，这是一个保留范围，永远不会定义任何代码点。（例如，代码点
    10C48，“古代突厥文字母ORKHON BASH”，看起来像 ![](assets/pc10_02in01.png)，将变成 0xD803，后跟 0xDC48。）
- en: In summary, items that users perceive as single characters might be represented
    with multiple Unicode code points, and some single code points might be represented
    as multiple code units. Manipulating the individual `char` values that make up
    a `string` is therefore a job you should approach with caution. Often, a simple
    approach works well enough—if, for example, you want to search a string for some
    specific character that you know fits in a single code unit (such as `/`), a simple
    `char`-based search will work perfectly well. However, if you have a more complex
    scenario that requires you to detect all multi-code-unit sequences correctly,
    the runtime libraries offer some help here.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，用户视为单个字符的项可能用多个 Unicode 代码点表示，而某些单个代码点可能表示为多个代码单元。因此，操作构成字符串的单个 `char` 值是一项您应该谨慎对待的工作。通常情况下，简单的方法已经足够——例如，如果您想要搜索一个字符串以查找某些适合单个代码单元（如
    `/`）的特定字符，一个简单的基于 `char` 的搜索就足够了。但是，如果您有一个更复杂的场景需要正确检测所有多代码单元序列，运行时库在这里提供了一些帮助。
- en: The `string` type offers an `EnumerateRunes` method that effectively combines
    surrogate pairs back into the value of the code point they represent. It presents
    the string as a sequence of values of type `Rune`, and if a string contained the
    `0xD803, 0xDC48` sequence just described, this pair of `char` values would be
    presented as a single `Rune` with the value `0x10C48`. The `Rune` type still operates
    at the level of individual code points, so it won’t help you with combining characters,
    but if you need to go to that next level, the runtime libraries define a `StringInfo`
    class in the `Sys⁠tem.​Glo⁠bal⁠iza⁠ti⁠on` namespace. This interprets a string
    as a sequence of “text elements,” and in cases such as `cafés`, it will report
    the `é` as a single text element, even when it was formed with two code points
    using the combining character mechanism.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`string` 类型提供了一个 `EnumerateRunes` 方法，有效地将代理对组合成它们所表示的代码点的值。它将字符串呈现为 `Rune`
    类型值的序列，如果一个字符串包含刚刚描述的 `0xD803, 0xDC48` 序列，这对 `char` 值将被呈现为一个值为 `0x10C48` 的单个 `Rune`。`Rune`
    类型仍然在单个代码点的级别上操作，因此它不能帮助您处理组合字符，但如果您需要进一步，运行时库在 `Sys⁠tem.​Glo⁠bal⁠iza⁠ti⁠on` 命名空间中定义了一个
    `StringInfo` 类。它将字符串解释为“文本元素”的序列，在像 `cafés` 这样的情况下，它将 `é` 报告为一个单一的文本元素，即使它是使用组合字符机制形成的两个代码点。'
- en: Immutability of strings
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串的不可变性
- en: .NET strings are immutable. There are many operations that sound as though they
    will modify a string, such as concatenation, or the `ToUpper` and `ToLower` methods
    offered by instances of the `string` type, but each of these generates a new string,
    leaving the original one unmodified. This means that if you pass strings as arguments,
    even to code you didn’t write, you can be certain that it cannot change your strings.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 字符串是不可变的。有许多操作听起来似乎会修改字符串，比如连接操作，或者 `ToUpper` 和 `ToLower` 方法，但每个操作都会生成一个新的字符串，原始字符串保持不变。这意味着，如果你将字符串作为参数传递，即使是给你没有编写的代码，你也可以确保它不能改变你的字符串。
- en: The downside of immutability is that string processing can be inefficient. If
    you need to do work that performs a series of modifications to a string, such
    as building it up character by character, you will end up allocating a lot of
    memory, because you’ll get a separate string for each modification. This creates
    a lot of extra work for .NET’s garbage collector, causing your program to use
    more CPU time than necessary. In these situations, you can use a type called `StringBuilder`.
    (This type gets no special recognition from the C# compiler, unlike `string`.)
    This is conceptually similar to a `string`—it is a sequence of `char` values and
    offers various useful string manipulation methods—but it is modifiable. Alternatively,
    in extremely performance-sensitive scenarios, you might use the techniques shown
    in [Chapter 18](ch18.xhtml#ch_memory_efficiency).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性的缺点在于字符串处理可能效率低下。如果需要对字符串进行一系列修改的工作，比如逐字符构建字符串，你将会分配大量内存，因为每次修改都会生成一个新的字符串。这会给.NET的垃圾收集器增加很多额外工作，导致程序使用比必要更多的CPU时间。在这些情况下，你可以使用一种叫做`StringBuilder`的类型。（与`string`不同，这种类型在C#编译器中并未特别认可。）这在概念上类似于`string`——它是一系列`char`值，并提供各种有用的字符串操作方法——但是它是可修改的。或者，在极其性能敏感的场景中，你可能会使用[第18章](ch18.xhtml#ch_memory_efficiency)中展示的技术。
- en: String manipulation methods
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串操作方法
- en: 'The `string` type has numerous instance methods for working with strings. I
    already mentioned `ToUpper` and `ToLower`, but there are also methods for finding
    text within the string, including `IndexOf` and `LastIndexOf`. `StartsWith` and
    `EndsWith` return a `bool` indicating whether the string starts or ends with a
    particular character or string. `Split` takes one or more separator characters
    (e.g., commas or spaces) and returns an array with an entry for each substring
    between the separators. For example, `"One,two,three".Split('','')` returns an
    array containing the three strings `"One"`, `"two"`, and `"three"`. `Substring`
    takes a starting position and optional length and returns a new string containing
    all characters from the start position up to either the end of the string or the
    specified length; `Remove` does the opposite: it forms a new string by removing
    the part of the original string that `Substring` would have returned. `Insert`
    forms a new string by inserting one string into the middle of another. `Replace`
    returns a new string formed by replacing all instances of a particular character
    or string with another. `Trim` can be used to remove unwanted leading and trailing
    characters such as whitespace.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`string`类型具有许多实例方法来处理字符串。我已经提到了`ToUpper`和`ToLower`，但还有用于在字符串中查找文本的方法，包括`IndexOf`和`LastIndexOf`。`StartsWith`和`EndsWith`返回一个`bool`值，指示字符串是否以特定字符或字符串开头或结尾。`Split`接受一个或多个分隔符字符（例如逗号或空格），并返回一个数组，其中包含分隔符之间的每个子字符串。例如，`"One,two,three".Split('','')`返回一个包含三个字符串`"One"`、`"two"`和`"three"`的数组。`Substring`接受一个起始位置和可选长度，并返回一个新字符串，其中包含从起始位置开始到字符串末尾或指定长度的所有字符；`Remove`则相反：它通过删除`Substring`将返回的原始字符串的一部分形成一个新字符串。`Insert`通过在另一个字符串的中间插入一个字符串来形成一个新字符串。`Replace`返回一个通过将特定字符或字符串的所有实例替换为另一个字符或字符串而形成的新字符串。`Trim`可用于删除不需要的前导和尾随字符，如空格。'
- en: Formatting data in strings
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式化字符串中的数据
- en: C# provides a syntax that makes it easy to produce strings that contain a mixture
    of fixed text and information determined at runtime. (The official name for this
    feature is *string interpolation*.) For example, if you have local variables called
    `name` and `age`, you could use them in a string, as [Example 2-41](#expressions_in_strings)
    shows.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: C# 提供了一种语法，使得可以轻松生成包含固定文本和运行时确定信息的字符串。（这种特性的官方名称是*字符串插值*。）例如，如果你有名为`name`和`age`的局部变量，你可以在字符串中使用它们，就像[示例 2-41](#expressions_in_strings)所示。
- en: Example 2-41\. Expressions in strings
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-41\. 字符串中的表达式
- en: '[PRE44]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: When you put a `$` symbol in front of a string literal, the C# compiler looks
    for embedded expressions delimited by braces and produces code that will insert
    a textual representation of the expression at that point in the string. (So if
    `name` and `age` were `Ian` and `48`, respectively, the string’s value would be
    `"Ian is 48 years old"`.) Embedded expressions can be more complex than just variable
    names, as [Example 2-42](#more_complex_expressions_in_strings) shows.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在字符串字面量前面加上`$`符号时，C#编译器会查找由大括号分隔的嵌入表达式，并生成将表达式的文本表示插入到字符串中的代码。 （因此，如果`name`和`age`分别是`Ian`和`48`，则字符串的值将是`"Ian
    is 48 years old"`。）嵌入表达式可以比变量名更复杂，正如[示例 2-42](#more_complex_expressions_in_strings)所示。
- en: Example 2-42\. More complex expressions in strings
  id: totrans-294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-42\. 字符串中的更复杂表达式
- en: '[PRE45]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If you want to use string interpolation but you also want the resulting string
    to include opening or closing braces, you double them up. When an interpolated
    string contains either `{{` or `}}`, the compiler does not interpret them as delimiting
    embedded expressions and just produces a single `{` or `}` in the output. For
    example, `$"Brace: {{, braces: {{}}, width: {width}, braced width: {{{width}}}"`
    evaluates to `Brace: {, braces: {}, width: 3, braced width: {3}` (assuming `width`
    is `3` here).'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你想使用字符串插值，但又希望生成的字符串包含开放或关闭的大括号，则将它们加倍。当插值字符串包含`{{`或`}}`时，编译器不会将它们解释为嵌入表达式的分隔符，而只会在输出中生成单个`{`或`}`。例如，`$"Brace:
    {{, braces: {{}}, width: {width}, braced width: {{{width}}}"`评估为`Brace: {, braces:
    {}, width: 3, braced width: {3}`（假设`width`为`3`）。'
- en: The runtime libraries offer another mechanism for plugging values into a string.
    The `string` class’s `Format` method takes a string with numbered placeholders
    of the form `{0}` and `{1}`, followed by a list of arguments supplying the values
    for these placeholders. [Example 2-43](#string_format_numbered) uses this to achieve
    the same effect as Examples [2-41](#expressions_in_strings) and [2-42](#more_complex_expressions_in_strings).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时库提供了另一种将值插入字符串的机制。`string`类的`Format`方法接受一个带有形如`{0}`和`{1}`的编号占位符的字符串，后跟一系列提供这些占位符值的参数。[示例
    2-43](#string_format_numbered)使用这种方法实现了与示例[2-41](#expressions_in_strings)和[2-42](#more_complex_expressions_in_strings)相同的效果。
- en: Example 2-43\. Using `string.Format`
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-43\. 使用`string.Format`
- en: '[PRE46]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This numbered placeholder mechanism is older—it has been around since C# 1.0,
    whereas string interpolation was introduced in C# 6.0—so you will see it cropping
    up in quite a few places. `Console.WriteLine` supports it, for example. It does
    offer one advantage over string interpolation: if you want to combine a large
    number of expressions into one string, or if any of the expressions you want to
    use is large, the interpolated string syntax can become unwieldy; the ability
    to put a long constituent expression on its own line as [Example 2-43](#string_format_numbered)
    does can sometimes improve readability. However, string interpolation is much
    less error prone—`string.Format` uses position-based placeholders, making it all
    too easy to put an expression in the wrong place. It’s also tedious for anyone
    reading the code to try and work out how the numbered placeholders relate to the
    arguments that follow, particularly as the number of expressions increases. Interpolated
    strings are usually much easier to read.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编号占位符机制较旧，自C# 1.0起就存在，而字符串插值是在C# 6.0中引入的，因此你会在许多地方看到它的身影。例如，`Console.WriteLine`支持它。它确实比字符串插值有一个优点：如果你想将大量表达式组合成一个字符串，或者如果你要使用的任何表达式很大，则插值字符串语法可能变得笨拙；像[示例
    2-43](#string_format_numbered)那样将一个长的成分表达式放在自己的一行上有时可以提高可读性。但是，字符串插值要少出错得多——`string.Format`使用基于位置的占位符，很容易将表达式放在错误的位置。对于阅读代码的任何人来说，尝试弄清编号占位符与后续参数的关系尤其是在表达式数量增加时是很乏味的。插值字符串通常更容易阅读。
- en: Interpolated strings can sometimes offer performance benefits. `string.Format`
    always assembles the string at runtime, but with string interpolation, the compiler
    may be able to perform compile-time optimizations. For example, if an expression
    in an interpolated string is a `const` string ([Chapter 3](ch03.xhtml#ch_types)
    describes the `const` keyword), the compiler will insert its value into the string
    at compile time. Furthermore, C# 10.0 enables libraries to indicate that they
    want to be involved in the interpolation process, making it possible to avoid
    ever creating a string in cases where that string won’t be used. When might you
    write an interpolated string that won’t be used? Look at [Example 2-44](#unused_interpolated_string).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 插值字符串有时可以提供性能优势。`string.Format` 总是在运行时组装字符串，但是使用字符串插值时，编译器可能能够执行编译时优化。例如，如果插值字符串中的表达式是一个`const`字符串（[第3章](ch03.xhtml#ch_types)描述了`const`关键字），编译器将在编译时将其值插入到字符串中。此外，C#
    10.0 允许库表明它们希望参与插值过程，从而可以避免在不使用该字符串的情况下创建字符串。何时可能编写一个不会使用的插值字符串？请参考 [示例 2-44](#unused_interpolated_string)。
- en: Example 2-44\. A potentially unused interpolated string
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-44\. 潜在未使用的插值字符串
- en: '[PRE47]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This uses `Debug.Assert`, a diagnostic method you can add to your code to detect
    when your application has got into some unexpected state. `Debug.Assert` checks
    its first argument, and if it’s `false`, it will halt the program, displaying
    the message passed as the second argument. But if the argument is `true`, it proceeds
    without ever using the second argument. In this example, if calling `ToString()`
    on the `My⁠App⁠lic⁠ati⁠on​Mod⁠el` in the interpolated string were expensive, it
    would be bad news if that ran even in cases where everything is in fact OK—our
    program might be doing a great deal of work to create a string that gets thrown
    away. But .NET 6.0 adds a new overload of `Debug.Assert`, taking advantage of
    C# 10.0’s new string interpolation features in a way that avoids ever creating
    that string in cases where it won’t be used. This same mechanism could be used
    by logging frameworks, in which it’s common for code to be able to generate a
    lot of strings to provide detailed descriptions of what’s happening but which
    will be unused in the typical case where verbose logging has not been enabled.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用了 `Debug.Assert`，这是一个诊断方法，您可以将其添加到代码中，以检测应用程序是否进入了某些意外状态。`Debug.Assert`
    检查其第一个参数，如果为`false`，它将停止程序，并显示作为第二个参数传递的消息。但是，如果参数为`true`，它将在不使用第二个参数的情况下继续执行。在本例中，如果在插值字符串中调用
    `My⁠App⁠lic⁠ati⁠on​Mod⁠el` 的 `ToString()` 方法很昂贵，那么即使在一切正常的情况下也会很不好——我们的程序可能正在做大量工作来创建一个最终会被丢弃的字符串。但是，.NET
    6.0 添加了 `Debug.Assert` 的新重载，利用了 C# 10.0 中的新字符串插值特性，以一种避免在不使用时创建该字符串的方式。此机制也可以被日志记录框架使用，其中代码通常可以生成大量字符串以提供发生情况的详细描述，但在未启用详细日志记录的典型情况下将不会使用这些字符串。
- en: With some data types, there are choices to be made about their textual representation.
    For example, with floating-point numbers, you might want to limit the number of
    decimal places, or force the use of exponential notation. (For example, `1e6`
    instead of `1000000`.) In .NET, we control this with a *format specifier*, which
    is a string describing how to convert some data to a string. Some data types have
    only one reasonable string representation, so they do not support this, but with
    types that have multiple string forms, you can pass the format specifier as an
    argument to the `ToString` method. For example, `System.Math.PI.ToString("f4")`
    formats the `PI` constant (which is of type `double`) to four decimal places (`"3.1416"`).
    There are nine built-in formats for numbers, and if none of those suits your requirements,
    there’s also a minilanguage for defining custom formats. Moreover, different types
    use different format strings—dates work quite differently from numbers, for example—so
    the full range of available formats is too large to list here. Microsoft supplies
    extensive documentation of the details.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些数据类型，它们的文本表示方式有所选择余地。例如，对于浮点数，您可能希望限制小数位数，或者强制使用指数表示法。（例如，`1e6`代替`1000000`。）在.NET中，我们通过*格式说明符*来控制这一点，它是一个描述如何将某些数据转换为字符串的字符串。某些数据类型只有一个合理的字符串表示形式，因此它们不支持此功能，但对于具有多个字符串形式的类型，您可以将格式说明符作为参数传递给`ToString`方法。例如，`System.Math.PI.ToString("f4")`
    将`PI`常量（类型为`double`）格式化为四位小数（`"3.1416"`）。数字有九种内置格式，如果没有一种适合您的要求，还有一种用于定义自定义格式的小语言。此外，不同类型使用不同的格式字符串——例如，日期与数字的工作方式大不相同——因此，这里列出的可用格式的范围太大了。Microsoft
    提供了详尽的文档说明。
- en: When using `string.Format`, you can include a format specifier in the placeholder;
    for example, `{0:f3}` indicates that the first expression is to be formatted with
    three digits after the decimal point. You can include a format specifier in a
    similar way with string interpolation. [Example 2-45](#format_specifiers) shows
    the age with one digit after the decimal point.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`string.Format`时，您可以在占位符中包含格式说明符；例如，`{0:f3}` 表示第一个表达式应格式化为小数点后三位数。您也可以以类似的方式在字符串插值中包含格式说明符。[示例
    2-45](#format_specifiers) 展示了带有小数点后一位数的年龄。
- en: Example 2-45\. Format specifiers
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-45\. 格式说明符
- en: '[PRE48]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'There’s one wrinkle with this: with many data types, the process of converting
    to a string is culture-specific. For example, as mentioned earlier, in the US
    and the UK, decimals are typically written with a period between the whole number
    part and the fractional part, and you might use commas to group digits for readability,
    but some European countries invert this: they use periods to group digits, while
    the comma denotes the start of the fractional part. So what might be written as
    1,000.2 in one country could be written as 1.000,2 in another.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个细微的问题：对于许多数据类型，转换为字符串的过程是与文化相关的。例如，如前所述，在美国和英国，小数通常用句点分隔整数部分和小数部分，您可能使用逗号来分组数字以提高可读性，但一些欧洲国家则颠倒此习惯：他们使用句点分组数字，而逗号表示小数部分的开始。因此，在一个国家中写成1,000.2，在另一个国家可能写成1.000,2。
- en: 'As far as numeric literals in source code are concerned, this is a nonissue:
    C# uses underscores for digit grouping and always uses a period as the decimal
    point. But what about processing numbers at runtime? By default, you will get
    conventions determined by the current thread’s culture, and unless you’ve changed
    that, it will use the regional settings of the computer. Sometimes this is useful—it
    can mean that numbers, dates, and so on are correctly formatted for whatever locale
    a program runs in. However, it can be problematic: if your code relies on strings
    being formatted in a particular way (to serialize data that will be transmitted
    over a network, for example), you may need to apply a particular set of conventions.
    For this reason, you can pass the `string.Format` method a *format provider*,
    an object that controls formatting conventions. Likewise, data types with culture-dependent
    representations accept an optional format provider argument in their `ToString`
    methods. But how do you control this when using string interpolation? There’s
    nowhere to put the format provider. You can solve this with the `string` type’s
    `Create` method, as shown in [Example 2-46](#format_specifiers-culture).'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 就源代码中的数字文字而言，这是一个无关紧要的问题：C#使用下划线进行数字分组，并始终使用句点作为小数点。但是在运行时处理数字时怎么办？默认情况下，您将获得由当前线程文化确定的约定，并且除非您已更改，否则它将使用计算机的区域设置。有时这很有用——它可以意味着数字、日期等按照程序运行的任何区域设置正确格式化。但这可能会有问题：如果您的代码依赖于字符串以特定方式格式化（例如，序列化将通过网络传输的数据），则可能需要应用特定的约定集。因此，您可以向`string.Format`方法传递*格式提供程序*，这是一个控制格式约定的对象。同样，依赖于区域设置的数据类型接受其`ToString`方法中的可选格式提供程序参数。但是，在使用字符串插值时如何控制这一点呢？没有地方可以放置格式提供程序。您可以通过`string`类型的`Create`方法解决此问题，如[示例 2-46](#format_specifiers-culture)所示。
- en: Example 2-46\. Format specifiers with invariant culture
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 2-46\. 使用不变文化的格式规范
- en: '[PRE49]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This passes various different format providers to the `string.Create` method,
    but it uses the same interpolated string each time. Notice that it puts `:N` after
    the variable name in the first two lines. This asks for normal numeric formatting,
    including digit separators. The first call passes the *invariant culture*, which
    guarantees consistent formatting regardless of the locale in which the code runs,
    with the effect that `i` gets the value `"Quantity 1,234,567.654"`. The third
    line uses a `CultureInfo` object constructed with the argument `"fr"`. This tells
    it that we want it to format strings in the ways typically expected in French-speaking
    cultures, so the `f` variable gets the value `"Quantity 1.234.567,654"`. The final
    two lines use `:C`, indicating we’d like to show the value as a currency. I’ve
    passed cultures representing France and the French-speaking parts of Canada, resulting
    in Euro and dollar symbols, respectively.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这里将不同的格式提供程序传递给`string.Create`方法，但每次使用相同的插值字符串。请注意，它在前两行变量名后面加上`:N`。这要求普通数字格式，包括数字分隔符。第一次调用使用*不变文化*，这保证了无论代码在何种区域设置中运行，格式始终一致，导致`i`得到值`"Quantity
    1,234,567.654"`。第三行使用构造参数为`"fr"`的`CultureInfo`对象。这告诉它我们希望以法语文化为代表的方式格式化字符串，所以变量`f`得到值`"Quantity
    1.234.567,654"`。最后两行使用`:C`，表示我们希望以货币形式显示值。我分别传递了代表法国和加拿大法语区域的文化，结果分别为欧元和美元符号。
- en: 'It may seem odd that this works: normally, method arguments are evaluated before
    being passed into the method, so you might expect the interpolated string to be
    turned into a normal string before the call to `string.Create`, meaning it would
    be too late to apply the specified format provider. But as I said earlier, methods
    can indicate that they want to be involved in the string interpolation process.
    This `string.Create` method does exactly that, enabling it to take control of
    the process, which is how it is able to apply the format provider.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很奇怪：通常，方法参数在传递到方法之前会先进行评估，因此您可能希望插值字符串在调用`string.Create`之前变成普通字符串，这意味着应用指定的格式提供程序已经太晚了。但正如我之前所说，方法可以表明它们希望参与字符串插值过程。`string.Create`方法正是这样做的，使其能够控制该过程，这就是它能够应用格式提供程序的方式。
- en: Verbatim string literals
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始字符串字面量
- en: 'C# supports one more way of expressing a string value: you can prefix a string
    literal with the `@` symbol like so: `@"Hello"`. Strings of this form are called
    *verbatim string literals*. They are useful for two reasons: they can improve
    the readability of strings containing backslashes, and they make it possible to
    write multiline string literals.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: C# 支持一种更方便的表示字符串值的方式：你可以在字符串字面量前加上 `@` 符号，如 `@"Hello"`。这种形式的字符串被称为*逐字字符串字面量*。它们有两个优点：一是能提高包含反斜杠的字符串的可读性，二是能够编写多行字符串字面量。
- en: 'In a normal string literal, the compiler treats a backslash as an escape character,
    enabling various special values to be included. For example, in the literal `"Hello\tWorld!"`
    the `\t` denotes a single tab character (code point 9). This is a common way to
    express control characters in C-family languages. You can also use the backslash
    to include a double quote in a string—the backslash prevents the compiler from
    interpreting the character as the end of the string. Useful though this is, it
    makes including a backslash in a string a bit awkward: you have to write two of
    them. Since Windows uses backslashes in paths, this can get ugly: `"C:\\Windows\\System32\\"`.
    A verbatim string literal can be useful here, because it treats backslashes literally,
    enabling you to write just `@"C:\Windows\System32"`. (You can still include double
    quotes in a verbatim literal: just write two double quotes in a row. For example,
    `@"Hello ""World"""` produces the string value `Hello "World"`.)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在普通字符串字面量中，编译器将反斜杠视为转义字符，使得可以包含各种特殊值。例如，在字面量 `"Hello\tWorld!"` 中，`\t` 表示单个制表符（代码点
    9）。这是在 C 系列语言中表达控制字符的常见方式。你还可以使用反斜杠在字符串中包含双引号——反斜杠可以阻止编译器将字符解释为字符串结束。尽管如此，这使得在字符串中包含反斜杠有些麻烦：你必须写两个反斜杠。由于
    Windows 在路径中使用反斜杠，这可能会变得很丑陋：`"C:\\Windows\\System32\\"`。在这种情况下，逐字字符串字面量非常有用，因为它会逐字处理反斜杠，使你可以仅写
    `@"C:\Windows\System32"`。 （你仍然可以在逐字字面量中包含双引号：只需连续写两个双引号。例如，`@"Hello ""World"""`
    会产生字符串值 `Hello "World"`。）
- en: Tip
  id: totrans-318
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You can use `@` in front of an interpolated string. This combines the benefits
    of verbatim literals—straightforward use of backslashes and newlines—with support
    for embedded expressions.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在插值字符串前面使用 `@` 符号。这样做既结合了逐字字面量的好处——直接使用反斜杠和换行符，又支持嵌入表达式。
- en: Verbatim string literals also allow values to span multiple lines. With a normal
    string literal, the compiler will report an error if the closing double quote
    is not on the same line as the opening one. But with a verbatim string literal,
    the string can cover as many lines of source as you like.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 逐字字符串字面量还允许值跨多行。在普通字符串字面量中，如果结束的双引号不在同一行上，编译器将报错。但在逐字字符串字面量中，字符串可以跨越源代码的任意行数。
- en: 'The resulting string will use whichever line-ending convention your source
    code uses. Just in case you’ve not encountered this, one of the unfortunate accidents
    of computing history is that different systems use different character sequences
    to denote line endings. The predominant system in internet protocols is to use
    a pair of control codes for each line end: in either Unicode or ASCII, we use
    code points 13 and 10, denoting a *carriage return* and a *line feed*, respectively,
    often abbreviated to CR LF. This is an archaic hangover from the days before computers
    had screens, and starting a new line meant moving the teletype’s print head back
    to its start position (carriage return) and then moving the paper up by one line
    (line feed). Anachronistically, the HTTP specification requires this representation,
    as do the various popular email standards, SMTP, POP3, and IMAP. It is also the
    standard convention on Windows. Unfortunately, the Unix operating system does
    things differently, as do most of its derivatives and lookalikes such as macOS
    and Linux—the convention on these systems is to use just a single line feed character.
    The C# compiler accepts either and will not complain if a single source file even
    contains a mixture of both conventions. This introduces a potential problem for
    multiline string literals if you are using a source control system that converts
    line endings for you. For example, *Git* is a very popular source control system,
    and thanks to its origins (it was created by Linus Torvalds, who also created
    Linux), there is a widespread convention of using Unix-style line endings in its
    repositories. However, on Windows it can be configured to convert working copies
    of files to a CR LF representation, automatically converting them back to LF when
    committing changes. This means that files will appear to use different line-ending
    conventions depending on whether you’re looking at them on a Windows system or
    a Unix one. (And it might even vary from one Windows system to another, because
    the default line-ending handling is configurable. Individual users can configure
    the machine-wide default setting and can also set the configuration for their
    local clone of any repository if the repository does not specify the setting itself.)
    This in turn means that compiling a file containing a multiline verbatim string
    literal on a Windows system could produce subtly different behavior than you’d
    see with the exact same file on a Unix system, if automatic line-ending conversion
    is enabled (which it is by default on most Windows installations of Git). That
    might be fine—you typically want CR LF when running on Windows and LF on Unix—but
    it could cause surprises if you deploy code to a machine running a different OS
    than the one you built it on. So it’s important to provide a *.gitattributes*
    file in your repositories so that they can specify the required behavior, instead
    of relying on changeable local settings. If you need to rely on a particular line
    ending in a string literal, it’s best to make your *.gitattributes* disable line-ending
    conversions.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 结果字符串将使用源代码使用的换行符约定。假如你还没遇到这种情况，那么计算机历史上的一个不幸意外是不同系统使用不同的字符序列来表示换行符。互联网协议中主导的系统使用一对控制码表示每行结尾：无论是Unicode还是ASCII，我们使用代码点13和10，分别表示*回车*和*换行*，通常简称为CR
    LF。这是计算机屏幕出现之前的过时遗物，开始新行意味着将电传打印机的打印头移回起始位置（回车），然后将纸向上移动一行（换行）。时代背景下，HTTP规范和多种流行的电子邮件标准如SMTP、POP3和IMAP要求使用这种表示法。这也是Windows的标准约定。不幸的是，Unix操作系统及其大多数衍生产品如macOS和Linux的约定不同——这些系统的约定是仅使用单个换行字符。C#编译器接受任意一种约定，并且即使单个源文件混合使用了这两种约定，它也不会抱怨。这给多行字符串字面量引入了潜在问题，特别是如果你正在使用一个为你转换换行符的源代码控制系统。例如，*Git*是一个非常流行的源代码控制系统，由于它的起源（由Linux的创始人Linus
    Torvalds创建），它的仓库中广泛使用Unix风格的换行符约定。然而，在Windows上可以配置它将文件的工作副本转换为CR LF表示法，在提交更改时再将其转换回LF。这意味着，文件看起来会因为在Windows系统或Unix系统上查看它们而使用不同的换行符约定。（甚至从一个Windows系统到另一个Windows系统也可能不同，因为默认的换行符处理是可配置的。个别用户可以配置机器范围内的默认设置，也可以为他们本地克隆的任何仓库设置配置，如果该仓库未指定该设置。）这反过来意味着，在Windows系统上编译包含多行字面量字符串的文件可能会产生与在Unix系统上看到的完全相同文件产生微妙不同的行为，如果启用了自动换行符转换（在大多数Windows安装的Git上默认是这样）。这可能没问题——在Windows上运行时通常需要CR
    LF，在Unix上运行时需要LF——但如果将代码部署到与构建代码的操作系统不同的机器上可能会有意外情况发生。因此，在你的仓库中提供一个*.gitattributes*文件是非常重要的，以便指定所需的行为，而不是依赖于可变的本地设置。如果需要在字符串字面量中依赖特定的换行符，最好在*.gitattributes*中禁用换行符转换。
- en: Tuples
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组
- en: '*Tuples* let you combine multiple values into a single value. The name tuple
    (which C# shares with many other programming languages that provide a similar
    feature) is meant to be a generalized version of words like *double*, *triple*,
    *quadruple*, and so on, but we generally call them tuples even in cases where
    we don’t need the generality. For example, even if we’re talking about a tuple
    with two items in it, we still call it a tuple, not a double. [Example 2-47](#tuple_2d_coordinate)
    creates a tuple containing two `int` values and then displays them.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '*元组*让你将多个值组合成一个值。元组这个名称（与许多提供类似功能的编程语言共享）意味着它是诸如*double*、*triple*、*quadruple*等单词的泛化版本，但即使在我们不需要泛化的情况下，我们通常也称它们为元组。例如，即使我们在讨论一个包含两个项目的元组时，我们仍然称其为元组，而不是双。[示例 2-47](#tuple_2d_coordinate)创建一个包含两个`int`值的元组，然后显示它们。'
- en: Example 2-47\. Creating and using a tuple
  id: totrans-324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-47\. 创建和使用元组
- en: '[PRE50]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'That first line is a variable declaration with an initializer. It’s worth breaking
    this down, because the syntax for tuples makes for a slightly more complex-looking
    declaration than we’ve seen so far. Remember, the general pattern for statements
    of this form is as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 那第一行是一个带有初始化器的变量声明。值得详细解释一下，因为元组的语法使得声明看起来比我们到目前为止见到的稍微复杂一些。记住，这种形式语句的一般模式如下：
- en: '[PRE51]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'That means that in [Example 2-47](#tuple_2d_coordinate), the type is `(int
    X, int Y)`. So we’re saying that our variable, `point`, is a tuple containing
    two values, both of type `int`, and we want to refer to those as `X` and `Y`.
    The initializer here is `(10, 5)`. So when we run the example, it produces this
    output:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在[示例 2-47](#tuple_2d_coordinate)中，类型为`(int X, int Y)`。因此，我们说我们的变量`point`是一个包含两个`int`类型值的元组，我们希望将它们称为`X`和`Y`。这里的初始化器是`(10,
    5)`。因此，当我们运行这个示例时，它产生以下输出：
- en: '[PRE52]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If you’re a fan of `var`, you’ll be pleased to know that you can specify the
    names in the initializer using the syntax shown in [Example 2-48](#tuple_initializer_names),
    enabling you to use `var` instead of the explicit type. This is equivalent to
    [Example 2-47](#tuple_2d_coordinate).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢使用`var`，你会高兴地知道，你可以使用在[示例 2-48](#tuple_initializer_names)中展示的语法在初始化器中指定名称，从而使用`var`而不是显式类型。这相当于[示例 2-47](#tuple_2d_coordinate)。
- en: Example 2-48\. Naming tuple members in the initializer
  id: totrans-331
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-48\. 在初始化器中命名元组成员
- en: '[PRE53]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If you initialize a tuple from existing variables and you do not specify names,
    the compiler will presume that you want to use the names of those variables, as
    [Example 2-49](#tuple_inferred_names) shows.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从现有变量初始化一个元组并且没有指定名称，编译器会假定你想使用那些变量的名称，正如[示例 2-49](#tuple_inferred_names)所示。
- en: Example 2-49\. Inferring tuple member names from variables
  id: totrans-334
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-49\. 从变量推断元组成员名称
- en: '[PRE54]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This raises a stylistic question: Should tuple member names start with lowercase
    or uppercase letters? The members are similar in nature to properties, which we’ll
    be discussing in [Chapter 3](ch03.xhtml#ch_types), and conventionally those start
    with an uppercase letter. For this reason, many people believe that tuple member
    names should also be uppercase. To a seasoned .NET developer, that `point.x` in
    [Example 2-49](#tuple_inferred_names) just looks weird. However, another .NET
    convention is that local variables usually start with a lowercase name. If you
    stick to both of these conventions, tuple name inference doesn’t look very useful.
    Many developers choose to accept lowercase tuple member names for tuples used
    purely in local variables, because it enables the use of the convenient name inference
    feature, using this casing style only for tuples that are exposed outside of a
    method.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了一个风格上的问题：元组成员的名称应该以小写还是大写字母开头？这些成员在性质上类似于属性，我们将在[第三章](ch03.xhtml#ch_types)中讨论，按照传统，这些属性通常以大写字母开头。因此，许多人认为元组成员的名称也应该是大写的。对于一个经验丰富的
    .NET 开发者来说，[示例 2-49](#tuple_inferred_names)中的`point.x`看起来很奇怪。然而，另一个 .NET 的惯例是局部变量通常以小写字母开头命名。如果你遵循这两个惯例，元组名称推断看起来并不是很有用。许多开发者选择接受在纯粹用于局部变量的元组中使用小写元组成员名称，因为这样做可以使用方便的名称推断功能，仅在暴露给方法外部的元组中使用这种大小写风格。
- en: Arguably it doesn’t matter much, because tuple member names turn out to exist
    only in the eye of the beholder. First, they’re optional. As [Example 2-50](#tuple_unnamed_items)
    shows, it’s perfectly legal to omit them. The names just default to `Item1`, `Item2`,
    etc.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 可能这并不重要，因为元组成员名称实际上只存在于观察者的眼中。首先，它们是可选的。正如[示例 2-50](#tuple_unnamed_items)所示，省略它们是完全合法的。这些名称默认为`Item1`、`Item2`等。
- en: Example 2-50\. Default tuple member names
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-50\. 默认元组成员名称
- en: '[PRE55]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Second, the names are purely for the convenience of the code using the tuples
    and are not visible to the runtime. You’ll have noticed that I’ve used the same
    initializer expression, `(10, 5)`, as I did in [Example 2-47](#tuple_2d_coordinate).
    Because it doesn’t specify names, the expression’s type is `(int, int)`, which
    matches the type in [Example 2-50](#tuple_unnamed_items), but I was also able
    to assign it straight into an `(int X, int Y)` in [Example 2-47](#tuple_2d_coordinate).
    That’s because the names are essentially irrelevant—these are all the same thing
    under the covers. (As we’ll see in [Chapter 4](ch04.xhtml#ch_generics), at runtime
    these are all represented as instances of a type called `ValueTuple<int, int>`.)
    The C# compiler keeps track of the names we’ve chosen to use, but as far as the
    CLR is concerned, all these tuples just have members called `Item1` and `Item2`.
    An upshot of this is that we can assign any tuple into any variable with the same
    shape, as [Example 2-51](#tuple_structural_equivalence) shows.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，名称仅用于使用元组的代码的便利性，并不对运行时可见。您可能已经注意到，在[示例 2-47](#tuple_2d_coordinate) 中，我使用了与[示例
    2-50](#tuple_unnamed_items) 中相同的初始化表达式`(10, 5)`，因为它没有指定名称，所以表达式的类型是`(int, int)`，这与在[示例
    2-47](#tuple_2d_coordinate) 中的`(int X, int Y)`匹配。这是因为名称本质上是无关紧要的—在底层它们都是相同的东西。（正如我们将在[第
    4 章](ch04.xhtml#ch_generics) 中看到的那样，在运行时，它们都表示为类型为`ValueTuple<int, int>`的实例。）C#编译器会跟踪我们选择使用的名称，但是对于CLR来说，所有这些元组都只有称为`Item1`和`Item2`的成员。由此产生的结果是，我们可以将任何元组分配给具有相同形状的任何变量，正如[示例
    2-51](#tuple_structural_equivalence) 所示。
- en: Example 2-51\. Structural equivalence of tuples
  id: totrans-341
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-51\. 元组的结构等价性
- en: '[PRE56]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This flexibility is a double-edged sword. The assignments in [Example 2-51](#tuple_structural_equivalence)
    seem rather sketchy. It might conceivably be OK to assign something that represents
    a location into something that represents a size—there are some situations in
    which that would be valid. But to assign that same value into something apparently
    representing someone’s age and the number of children they have looks likely to
    be wrong. The compiler won’t stop us though, because it considers all tuples comprising
    a pair of `int` values to have the same type. (It’s not really any different from
    the fact that the compiler won’t stop you assigning an `int` variable named `age`
    into an `int` variable named `height`. They’re both of type `int`.)
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性是一把双刃剑。在[示例 2-51](#tuple_structural_equivalence) 中的赋值看起来相当草率。将代表位置的值赋予代表大小的值可能是可以接受的某些情况。但是将同样的值赋予看似表示某人年龄和子女数量的值似乎是错误的。尽管如此，编译器不会阻止我们，因为它认为所有包含一对`int`值的元组都具有相同的类型。（这与将一个名为`age`的`int`变量赋值给一个名为`height`的`int`变量的情况没有什么不同。它们都是`int`类型。）
- en: If you want to enforce a semantic distinction, you would be better off defining
    custom types as described in [Chapter 3](ch03.xhtml#ch_types). Tuples are really
    designed as a convenient way to package together a few values in cases where defining
    a whole new type wouldn’t really be justified.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要强制进行语义区分，最好根据[第 3 章](ch03.xhtml#ch_types) 中描述的方式定义自定义类型。元组的真正设计目的是在不真正需要的情况下方便地将几个值打包在一起。
- en: C# does require tuples to have an appropriate shape. You cannot assign an `(int,
    int)` into a `(int, string)`, nor into an `(int, int, int)`. However, all of the
    implicit conversions in [“Numeric conversions”](#numeric_conversions) work, so
    you can assign anything with an `(int, int)` shape into an `(int, double)` or
    a `(double, long)`. So a tuple is really just like having a handful of variables
    neatly contained inside another variable.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: C#确实要求元组具有适当的形状。您不能将`(int, int)`赋值给`(int, string)`，也不能赋值给`(int, int, int)`。然而，在[“数字转换”](#numeric_conversions)中的所有隐式转换都是有效的，因此您可以将具有`(int,
    int)`形状的任何内容赋给`(int, double)`或`(double, long)`。因此，元组实际上就像是在另一个变量中整齐地包含了一些变量。
- en: Tuples support comparison, so you can use the `==` and `!=` relational operators
    described later in this chapter. To be considered equal, two tuples must have
    the same shape, and each value in the first tuple must be equal to its counterpart
    in the second tuple.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 元组支持比较，因此您可以在本章后面描述的`==`和`!=`关系运算符中使用它们。为了被视为相等，两个元组必须具有相同的形状，并且第一个元组中的每个值必须等于其在第二个元组中的对应值。
- en: Tuple deconstruction
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组解构
- en: Sometimes you will want to split a tuple back into its component parts. The
    most straightforward way would be to access each item in turn by its name (or
    as `Item1`, `Item2`, etc., if you didn’t specify names), but C# provides another
    mechanism, called *deconstruction*. [Example 2-52](#tuple_deconstruction) declares
    and initializes two tuples and then shows two different ways to deconstruct them.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你会想要将一个元组分解为其组成部分。最直接的方法是按顺序访问每个项的名称（或者作为`Item1`、`Item2`等，如果你没有指定名称），但是C#提供了另一种机制，称为*解构*。[示例 2-52](#tuple_deconstruction)
    声明并初始化了两个元组，然后展示了两种不同的解构方式。
- en: Example 2-52\. Constructing then deconstructing tuples
  id: totrans-349
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-52\. 构造后解构元组
- en: '[PRE57]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Having defined `point1` and `point2`, this deconstructs `point1` into two variables,
    `x` and `y`. This particular form of deconstruction also declares the variables
    into which the tuple is being deconstructed. The alternative form is shown when
    we deconstruct `point2`—here, we’re deconstructing it into two variables that
    already exist, so there’s no need to declare them.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了`point1`和`point2`之后，这将`point1`解构为两个变量，`x`和`y`。这种特定形式的解构还声明了元组被解构到的变量。在我们解构`point2`时展示了另一种形式
    —— 在这里，我们将其解构为两个已经存在的变量，因此不需要声明它们。
- en: Until you become accustomed to this syntax, the first deconstruction example
    can seem confusingly similar to the first couple of lines, in which we declare
    and initialize new tuples. In those first couple of lines, the `(int X, int Y)`
    text signifies a tuple type with two `int` values named `X` and `Y`, but in the
    deconstruction line when we write `(int x, int y)`, we’re actually declaring two
    variables, each of type `int`. The only significant difference is that in the
    lines where we’re constructing new tuples, there’s a variable name before the
    `=` sign. (Also, we’re using uppercase names there, but that’s just a matter of
    convention. It would be entirely legal to write `(int x, int y) point3 = point1;`.
    That would declare a new tuple with two `int` values named `x` and `y`, stored
    in a variable named `point3`, initialized with the same values as are in `point1`.
    Equally, we could write `(int X, int Y) = point1;`. That would deconstruct `point`
    into two local variables called `X` and `Y`.)
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 直到你习惯了这种语法，第一个解构示例可能会令人困惑地类似于前几行，在那里我们声明并初始化了新的元组。在那些最初的几行中，`(int X, int Y)`文本表示一个具有两个名为`X`和`Y`的`int`值的元组类型，但在解构行中当我们写`(int
    x, int y)`时，我们实际上声明了两个类型为`int`的变量。唯一显著的区别是，在构造新元组的行中，在`=`符号之前有一个变量名。（此外，在那里我们使用大写名称，但这只是一种约定。完全合法的是写`(int
    x, int y) point3 = point1;`。那将声明一个名为`point3`的新元组，其中包含两个名为`x`和`y`的`int`值，初始化为与`point1`中相同的值。同样，我们可以写`(int
    X, int Y) = point1;`。那将把`point1`解构为两个名为`X`和`Y`的局部变量。）
- en: Starting with C# 10.0, you can mix the two forms of deconstruction. Before this,
    any single deconstruction of a tuple either had to declare a new variable for
    each part of the target, or every target had to be an existing variable. But as
    [Example 2-53](#tuple_mixed_deconstruction) shows, a single deconstruction can
    now contain a mixture of target types.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 10.0开始，你可以混合使用两种解构形式。在此之前，元组的任何单一解构都必须为目标的每个部分声明一个新变量，或者每个目标都必须是一个已存在的变量。但是正如[示例 2-53](#tuple_mixed_deconstruction)
    所示，现在单个解构可以包含目标类型的混合。
- en: Example 2-53\. Mixing declarations and existing variables in tuple deconstruction
  id: totrans-354
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-53\. 在元组解构中混合声明和现有变量
- en: '[PRE58]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If you don’t need every element of a tuple, you can use an underscore, as [Example 2-54](#tuple_deconstruction_discard)
    shows. This is called a *discard*.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要元组的每个元素，你可以使用下划线，正如[示例 2-54](#tuple_deconstruction_discard) 所示。这被称为*废弃*。
- en: Example 2-54\. Tuple deconstruction with discard
  id: totrans-357
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-54\. 使用废弃的元组解构
- en: '[PRE59]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The underscore character can appear in any number of places in the target, and
    it tells the compiler that we don’t need that part of the tuple to be extracted
    into a variable.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线字符可以出现在目标的任何位置，并告诉编译器我们不需要将元组的该部分提取到变量中。
- en: Dynamic
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态类型
- en: C# defines a type called `dynamic`. This doesn’t directly correspond to any
    CLR type—when we use `dynamic` in C#, the compiler presents it to the runtime
    as `object`, which is described in the next section. However, from the perspective
    of C# code, `dynamic` is a distinct type, and it enables some special behavior.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: C#定义了一种名为`dynamic`的类型。这个类型并不直接对应CLR中的任何类型 —— 当我们在C#中使用`dynamic`时，编译器将其呈现给运行时作为`object`，这在下一节中有描述。然而从C#代码的角度来看，`dynamic`是一种独特的类型，它启用了一些特殊的行为。
- en: With `dynamic`, the compiler makes no attempt at compile time to check whether
    operations performed by code are likely to succeed. In other words, it effectively
    disables the statically typed behavior that we normally get with C#. You are free
    to attempt almost any operation on a `dynamic` variable—you can use arithmetic
    operators, you can attempt to invoke methods on it, you can try to assign it into
    variables of some other type, and you can try to get or set properties on it.
    When you do this, the compiler generates code that attempts to make sense of what
    you’ve asked it to do at runtime.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dynamic` 时，编译器在编译时不会尝试检查代码执行的操作是否可能成功。换句话说，它有效地禁用了我们通常在 C# 中得到的静态类型行为。你可以自由地在
    `dynamic` 变量上尝试几乎任何操作 —— 你可以使用算术运算符，可以尝试调用其方法，可以尝试将其分配到其他类型的变量中，并且可以尝试获取或设置其属性。当你这样做时，编译器生成的代码试图在运行时理解你要求它做的事情。
- en: 'If you have come to C# from a language in which this sort of behavior is the
    norm (such as JavaScript), you might be tempted to use `dynamic` for everything
    because it works in a way you are used to. However, you should be aware that there
    are a couple of issues with it. First, it was designed with a particular scenario
    in mind: interoperability with certain pre-.NET Windows components. The Component
    Object Model (COM) in Windows is the basis for automatability of the Microsoft
    Office Suite, and many other applications, and the scripting language built into
    Office is dynamic in nature. An upshot of this is that a lot of Office’s automation
    APIs used to be hard work to use from C#. One of the big drivers behind adding
    `dynamic` to the language was a desire to improve this.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从一种这种行为是常态的语言（如 JavaScript）转到 C#，你可能会倾向于因为它符合你习惯的工作方式而将 `dynamic` 用于一切。然而，你应该意识到它存在一些问题。首先，它是为特定场景设计的：与某些早期
    .NET Windows 组件的互操作性。Windows 中的组件对象模型（COM）是自动化 Microsoft Office 套件及许多其他应用程序的基础，而
    Office 内置的脚本语言是动态的。由此带来的一个结果是，从 C# 中使用许多 Office 的自动化 API 曾经是一项艰苦的工作。将 `dynamic`
    添加到语言中的一个主要动机之一是希望改进这一点。
- en: As with all C# features, it was designed with broader applicability in mind
    and not simply as an Office interop feature. But since that was the most important
    scenario for this feature, you may find that its ability to support idioms you
    are familiar with from dynamic languages is disappointing. And the second issue
    to be aware of is that it is not an area of the language that is getting a lot
    of new work. When it was introduced, Microsoft went to considerable lengths to
    ensure that all dynamic behavior was as consistent as possible with the behavior
    you would have seen if the compiler had known at compile time what types you were
    going to be using.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 和所有 C# 特性一样，它的设计考虑了更广泛的适用性，而不仅仅是作为 Office 互操作功能。但由于这是该功能最重要的应用场景，你可能会发现它支持你从动态语言熟悉的习惯用法的能力令人失望。还需要注意的第二个问题是，它并不是语言中正在进行大量新工作的领域。在引入它时，微软竭尽全力确保所有动态行为尽可能与编译器在编译时知道你将使用的类型时所见到的行为一致。
- en: This means that the infrastructure supporting `dynamic` (which is called the
    Dynamic Language Runtime, or DLR) has to replicate significant portions of C#
    behavior. However, the DLR has not been updated much since `dynamic` was added
    in C# 4.0 back in 2010, even though the language has seen many new features since
    then. Of course, `dynamic` still works, but its capabilities reflect how the language
    looked around a decade ago.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着支持 `dynamic` 的基础架构（称为动态语言运行时或 DLR）必须复制 C# 行为的重要部分。然而，自从 `dynamic` 在 2010
    年的 C# 4.0 中添加以来，DLR 并没有得到太多更新，尽管语言自那时以来引入了许多新功能。当然，`dynamic` 仍然可用，但其功能反映了大约十年前的语言外观。
- en: Even when it first appeared, `dynamic` had some limitations. There are some
    aspects of C# that depend on the availability of static type information, meaning
    that `dynamic` has always had some problems working with delegates and also with
    LINQ. So even from the start, it was at something of a disadvantage compared to
    using C# as intended, i.e., as a statically typed language.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `dynamic` 一开始出现时就存在一些限制。C# 的某些方面依赖于静态类型信息的可用性，这意味着 `dynamic` 一直在处理委托以及 LINQ
    方面存在问题。因此，从一开始，与按照预期使用 C# 作为静态类型语言相比，它确实处于某种劣势。
- en: Object
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Object
- en: The last data type to get special recognition from the C# compiler is `object`
    (or `System.Object`, as the CLR calls it). This is the base class of almost^([9](ch02.xhtml#fn13))
    all C# types. A variable of type `object` is able to refer to a value of any type
    that derives from `object`. This includes all numeric types, the `bool` and `string`
    types, and any custom types you can define using the keywords we’ll look at in
    the next chapter, such as `class`, `record`, and `struct`. And it also includes
    all the types defined by the runtime libraries, with the exception of certain
    types that can only be stored on the stack and that are described in [Chapter 18](ch18.xhtml#ch_memory_efficiency).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: C# 编译器最后一个特别认可的数据类型是`object`（或 CLR 称之为`System.Object`）。这是几乎所有 C# 类型的基类。类型为`object`的变量能够引用任何派生自`object`的类型的值。这包括所有数值类型、`bool`和`string`类型，以及你可以使用下一章将介绍的关键字定义的任何自定义类型，例如`class`、`record`和`struct`。同时也包括运行时库定义的所有类型，除了某些只能存储在堆栈上并在[第18章](ch18.xhtml#ch_memory_efficiency)中描述的特定类型。
- en: So `object` is the ultimate general-purpose container. You can refer to almost
    anything with an `object` variable. We will return to this in [Chapter 6](ch06.xhtml#ch_inheritance)
    when we look at inheritance.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`object`是终极通用容器。你可以用`object`变量引用几乎任何东西。我们在[第6章](ch06.xhtml#ch_inheritance)中讨论继承时将回到这一点。
- en: Operators
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符
- en: Earlier you saw that expressions are sequences of operators and operands. I’ve
    shown some of the types that can be used as operands, so now it’s time to see
    what operators C# offers. [Table 2-3](#basic_arithmetic_operators) shows the ones
    that support common arithmetic operations.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前看到表达式是运算符和操作数的序列。我展示了一些可用作操作数的类型，现在是时候看看 C# 提供了哪些运算符了。[表 2-3](#basic_arithmetic_operators)展示了支持常见算术操作的运算符。
- en: Table 2-3\. Basic arithmetic operators
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-3\. 基本算术运算符
- en: '| **Name** | **Example** |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **示例** |'
- en: '| --- | --- |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Unary plus (does nothing) | `+x` |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| 一元加号（不起作用） | `+x` |'
- en: '| Negation (unary minus) | `-x` |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| 取反（一元负号） | `-x` |'
- en: '| Postincrement | `x++` |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| 后增量 | `x++` |'
- en: '| Postdecrement | `x--` |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| 后减量 | `x--` |'
- en: '| Preincrement | `++x` |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| 前增量 | `++x` |'
- en: '| Predecrement | `--x` |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| 前减量 | `--x` |'
- en: '| Addition | `x + y` |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| 加法 | `x + y` |'
- en: '| Subtraction | `x - y` |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| 减法 | `x - y` |'
- en: '| Multiplication | `x * y` |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| 乘法 | `x * y` |'
- en: '| Division | `x / y` |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| 除法 | `x / y` |'
- en: '| Remainder | `x % y` |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| 取余 | `x % y` |'
- en: 'If you’ve had much experience with any other C-family language, all of these
    should seem familiar. If not, the most peculiar ones will probably be the increment
    and decrement operators. These have side effects: they add or subtract one from
    the variable to which they are applied (meaning they can be applied only to variables).
    With the postincrement and postdecrement, although the variable gets modified,
    the containing expression ends up getting the original value. So if `x` is a variable
    containing the value 5, the value of `x++` is also 5, even though the `x` variable
    will have a value of 6 after evaluating the `x++` expression. The pre- forms return
    the modified value, so if `x` is initially 5, `++x` produces the value 6, which
    is also the value of `x` after evaluating the expression.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有其他 C 家族语言的经验，所有这些都应该很熟悉。如果不熟悉，可能最奇特的是增量和减量运算符。它们有副作用：对应用于的变量加一或减一（这意味着它们只能应用于变量）。对于后增量和后减量，尽管变量被修改，但包含的表达式最终获取原始值。因此，如果`x`是一个包含值为5的变量，则`x++`的值也是5，尽管在计算`x++`表达式后，`x`变量将具有值6。前缀形式返回修改后的值，因此如果`x`最初是5，`++x`生成值6，这也是在评估表达式后`x`的值。
- en: Although the operators in [Table 2-3](#basic_arithmetic_operators) are used
    in arithmetic, some are available on certain nonnumeric types. As you saw earlier,
    the `+` symbol represents concatenation when working with strings, and as you’ll
    see in [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events), the addition and subtraction
    operators are also used for combining and removing delegates.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管[表 2-3](#basic_arithmetic_operators)中的运算符用于算术运算，某些非数值类型也可以使用。如前所述，当处理字符串时，`+`符号表示连接，如在[第9章](ch09.xhtml#ch_delegates_lambdas_events)中所示，加法和减法运算符也用于组合和删除委托。
- en: C# also offers some operators that perform certain binary operations on the
    bits that make up a value, shown in [Table 2-4](#binary_integer_operators). These
    are not available on floating-point types.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: C# 还提供了一些运算符，在构成值的位上执行某些二进制操作，如[表 2-4](#binary_integer_operators)所示。这些运算符不适用于浮点类型。
- en: Table 2-4\. Binary integer operators
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-4\. 二进制整数运算符
- en: '| **Name** | **Example** |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **示例** |'
- en: '| --- | --- |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Bitwise negation | `~x` |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| 按位取反 | `~x` |'
- en: '| Bitwise AND | `x & y` |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| 按位 AND | `x & y` |'
- en: '| Bitwise OR | `x &#124; y` |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| 按位 OR | `x &#124; y` |'
- en: '| Bitwise XOR | `x ^ y` |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| 按位异或 | `x ^ y` |'
- en: '| Shift left | `x << y` |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| 左移 | `x << y` |'
- en: '| Shift right | `x >> y` |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| 右移 | `x >> y` |'
- en: The bitwise negation operator inverts all bits in an integer—any binary digit
    with a value of 1 becomes 0, and vice versa. The shift operators move all the
    binary digits left or right by the number of columns specified by the second operand.
    A left shift sets the bottom digits to 0\. Right shifts of unsigned integers fill
    the top digits with 0, and right shifts of signed integers leave the top digit
    as it is (i.e., negative numbers remain negative because they keep their top bit
    set, while positive numbers keep their top bit as 0, thus remaining positive).
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 按位取反运算符反转整数中的所有位数 —— 任何值为 1 的二进制数字变为 0，反之亦然。移位运算符将所有二进制位数左移或右移，移动的位数由第二个操作数指定。左移将底部数字设为
    0。对于无符号整数，右移将填充顶部数字为 0，而对于有符号整数的右移则保留顶部数字不变（即负数保持负数，因为它们保持其顶部位设置，而正数将其顶部位设为 0，因此保持正数）。
- en: The bitwise AND, OR, and XOR (exclusive OR) operators perform Boolean logic
    operations on each bit of the two operands when applied to integers. These three
    operators are also available when the operands are of type `bool`. (In effect,
    these operators treat a `bool` as a one-digit binary number.) There are some additional
    operators available for `bool` values, shown in [Table 2-5](#operators_for_bool).
    The `!` operator does to a `bool` what the `~` operator does to each bit in an
    integer.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 按位 AND、OR 和 XOR（异或）运算符在整数上执行每个位的布尔逻辑运算。当操作数为 `bool` 类型时，这三个运算符也可用。（实际上，这些运算符将
    `bool` 视为一位二进制数。）还有一些额外的 `bool` 值运算符，详见 [表 2-5](#operators_for_bool)。`!` 运算符对
    `bool` 执行与 `~` 运算符对整数位的操作相同。
- en: Table 2-5\. Operators for `bool`
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-5\. `bool` 类型运算符
- en: '| **Name** | **Example** |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **示例** |'
- en: '| --- | --- |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Logical negation (also known as NOT) | `!x` |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑取反（也称为 NOT） | `!x` |'
- en: '| Conditional AND | `x && y` |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| 条件 AND | `x && y` |'
- en: '| Conditional OR | `x &#124;&#124; y` |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| 条件 OR | `x &#124;&#124; y` |'
- en: If you have not used other C-family languages, the conditional versions of the
    AND and OR operators may be new to you. These evaluate their second operand only
    if necessary. For example, when evaluating `(a && b)`, if the expression `a` is
    `false`, the code generated by the compiler will not even attempt to evaluate
    `b`, because the result will be `false` no matter what value `b` has. Conversely,
    the conditional OR operator does not bother to evaluate its second operand if
    the first is `true`, because the result will be `true` regardless of the second
    operand’s value. This is significant if the second operand’s expression either
    contains elements that have side effects (such as method invocation) or might
    produce an error. For example, you often see code like that shown in [Example 2-55](#conditional_and_operator).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有使用其他 C 家族语言，AND 和 OR 运算符的条件版本可能对您来说是新的。它们仅在必要时评估其第二个操作数。例如，在评估 `(a && b)`
    时，如果表达式 `a` 是 `false`，编译器生成的代码甚至不会尝试评估 `b`，因为无论 `b` 的值如何，结果都将是 `false`。相反，如果第一个操作数是
    `true`，条件 OR 运算符则不会费心评估其第二个操作数，因为无论第二个操作数的值如何，结果都将是 `true`。如果第二个操作数的表达式包含具有副作用（例如方法调用）或可能产生错误的元素，则这一点非常重要。例如，您经常会看到类似
    [示例 2-55](#conditional_and_operator) 的代码。
- en: Example 2-55\. The conditional AND operator
  id: totrans-407
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例2-55\. 条件 AND 运算符
- en: '[PRE60]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This checks to see if the variable `s` contains the special value `null`, meaning
    that it doesn’t currently refer to any value. The use of the `&&` operator here
    is important, because if `s` is `null`, evaluating the expression `s.Length` would
    cause a runtime error. If we had used the `&` operator, the compiler would have
    generated code that always evaluates both operands, meaning that we would see
    a `NullReferenceException` at runtime if `s` is `null`. By using the conditional
    AND operator, we avoid that, because the second operand, `s.Length > 10`, will
    be evaluated only if `s` is not `null`.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码检查变量 `s` 是否包含特殊值 `null`，即它当前不引用任何值。此处使用 `&&` 运算符很重要，因为如果 `s` 是 `null`，评估表达式
    `s.Length` 将导致运行时错误。如果我们使用了 `&` 运算符，编译器将生成代码，总是评估两个操作数，这意味着如果 `s` 是 `null`，运行时将会看到
    `NullReferenceException`。通过使用条件 AND 运算符，我们避免了这种情况，因为第二个操作数 `s.Length > 10` 仅在
    `s` 不是 `null` 时才会被评估。
- en: Note
  id: totrans-410
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Although code of the kind shown in [Example 2-55](#conditional_and_operator)
    was once common, it has gradually become much rarer thanks to a feature introduced
    back in C# 6.0, *null-conditional operators*. If you write `s?.Length` instead
    of just `s.Length`, the compiler generates code that checks `s` for `null` first,
    avoiding the `NullReferenceException`. This means the check can become just `if
    (s?.Length > 10)`. Furthermore, C#’s optional *nullable reference types* (a relatively
    new feature, discussed in [Chapter 3](ch03.xhtml#ch_types)) can help reduce the
    need for these kinds of tests for `null`.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管像[示例 2-55](#conditional_and_operator)中所示的代码曾经很常见，但由于引入了 C# 6.0 中的一个特性——*null-conditional
    operators*，它已逐渐变得越来越少见。如果你写 `s?.Length` 而不是仅仅 `s.Length`，编译器会生成代码来首先检查 `s` 是否为
    `null`，从而避免 `NullReferenceException`。这意味着检查可以简化为 `if (s?.Length > 10)`。此外，C# 的可选*可空引用类型*（一个相对较新的特性，在[第 3
    章](ch03.xhtml#ch_types)中讨论）可以帮助减少对 `null` 测试的需求。
- en: '[Example 2-55](#conditional_and_operator) tests to see if a property is greater
    than 10 by using the `>` operator. This is one of several *relational operators*,
    which allow us to compare values. They all take two operands and produce a `bool`
    result. [Table 2-6](#relational_operators) shows these, and they are supported
    for all numeric types. Some operators are available on some other types too. For
    example, you can compare string values with the `==` and `!=` operators. (There
    is no built-in meaning for the other relational operators with `string` because
    different countries have different ideas about the order in which to sort strings.
    If you want ordered string comparison, .NET offers the `StringComparer` class,
    which requires you to select the rules by which you’d like your strings ordered.)'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 2-55](#conditional_and_operator) 通过使用 `>` 运算符测试一个属性是否大于 10。这是几种*关系运算符*之一，允许我们比较值。它们都接受两个操作数，并产生一个
    `bool` 结果。[表格 2-6](#relational_operators) 显示了这些运算符，支持所有数值类型。某些运算符也适用于其他一些类型。例如，你可以使用
    `==` 和 `!=` 运算符比较字符串值。（对于 `string`，其他关系运算符没有内置的排序含义，因为不同国家对字符串排序顺序有不同的理解。如果你想进行有序的字符串比较，.NET
    提供了 `StringComparer` 类，允许你选择排序规则。）'
- en: Table 2-6\. Relational operators
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 2-6\. 关系运算符
- en: '| **Name** | **Example** |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **示例** |'
- en: '| --- | --- |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Less than | `x < y` |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| 小于 | `x < y` |'
- en: '| Greater than | `x > y` |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| 大于 | `x > y` |'
- en: '| Less than or equal | `x <= y` |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| 小于或等于 | `x <= y` |'
- en: '| Greater than or equal | `x >= y` |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| 大于或等于 | `x >= y` |'
- en: '| Equal | `x == y` |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| 等于 | `x == y` |'
- en: '| Not equal | `x != y` |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| 不等于 | `x != y` |'
- en: 'As is usual with C-family languages, the equality operator is a pair of equals
    signs. This is because a single equals sign means something else: it’s an assignment,
    and assignments are expressions too. This can lead to an unfortunate problem:
    in some C-family languages, it’s all too easy to write `if (x = y)` when you meant
    `if (x == y)`. Fortunately, this will usually produce a compiler error in C#,
    because C# has a special type to represent Boolean values. In languages that allow
    numbers to stand in for Booleans, both pieces of code are legal even if `x` and
    `y` are numbers. (The first means to assign the value of `y` into `x`, and then
    to execute the body of the `if` statement if that value is nonzero. That’s very
    different than the second one, which doesn’t change the value of anything and
    executes the body of the `if` statement only if `x` and `y` are equal.) But in
    C#, the first example would be meaningful only if `x` and `y` were both of type
    `bool`.^([10](ch02.xhtml#fn14))'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C 语言家族语言一样，等号运算符是一对等号。这是因为单个等号表示其他东西：它是一个赋值操作，而赋值也是表达式。这可能导致一个不幸的问题：在某些 C
    语言家族语言中，当你打算写 `if (x == y)` 时却误写成 `if (x = y)`。幸运的是，在 C# 中这通常会产生编译器错误，因为 C# 有一个专门的类型来表示布尔值。在允许数字代表布尔值的语言中，即使
    `x` 和 `y` 是数字，这两段代码都是合法的。（第一段意味着将 `y` 的值赋给 `x`，然后如果该值非零，则执行 `if` 语句的主体。这与第二段代码非常不同，它并不改变任何东西的值，并且仅在
    `x` 和 `y` 相等时执行 `if` 语句的主体。）但在 C# 中，第一个示例仅在 `x` 和 `y` 都是 `bool` 类型时才有意义。^([10](ch02.xhtml#fn14))
- en: Another feature that’s common to the C family is the conditional operator. (This
    is sometimes also called the ternary operator, because it’s the only operator
    in the language that takes three operands.) It chooses between two expressions.
    More precisely, it evaluates its first operand, which must be a Boolean expression,
    and then returns the value of either the second or third operand, depending on
    whether the value of the first was `true` or `false`, respectively. [Example 2-56](#conditional_operator)
    uses this to pick the larger of two values. (This is just for illustration. In
    practice, you’d normally use .NET’s `Math.Max` method, which has the same effect
    but is rather more readable. `Math.Max` also has the benefit that if you use expressions
    with side effects, it will only evaluate each one once, something you can’t do
    with the approach shown in [Example 2-56](#conditional_operator), because we’ve
    ended up writing each expression twice.)
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: C家族常见的另一个特性是条件运算符。（有时也称为三元运算符，因为它是语言中唯一接受三个操作数的运算符。）它在两个表达式之间进行选择。更确切地说，它评估其第一个操作数，该操作数必须是布尔表达式，然后根据第一个操作数的值是`true`还是`false`返回第二个或第三个操作数的值，分别是。（这只是举例说明。在实践中，您通常会使用.NET的`Math.Max`方法，其效果相同但更易读。`Math.Max`还有一个好处，即如果使用具有副作用的表达式，它将仅评估每个表达式一次，这是您无法使用[示例
    2-56](#conditional_operator)中显示的方法做到的，因为我们最终会写两次每个表达式。）
- en: Example 2-56\. The conditional operator
  id: totrans-424
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[示例 2-56](#conditional_operator)。条件运算符'
- en: '[PRE61]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This illustrates why C and its successors have a reputation for terse syntax.
    If you are familiar with any language from this family, [Example 2-56](#conditional_operator)
    will be easy to read, but if you’re not, its meaning might not be instantly clear.
    This will evaluate the expression before the `?` symbol, which is `(x > y)` in
    this case, and that’s required to be an expression that produces a `bool`. (The
    parentheses are optional. I put them in to make the code easier to read.) If that
    is `true`, the expression between the `?` and `:` symbols is used (`x`, in this
    case); otherwise, the expression after the `:` symbol (`y` here) is used.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明了为什么C及其后继者以简洁的语法而闻名。如果您熟悉此类家族的任何语言，[示例 2-56](#conditional_operator)将很容易阅读，但如果您不熟悉，则其含义可能不会立即清晰。这将评估`?`符号之前的表达式，在本例中是`(x
    > y)`，并且它要求是产生`bool`值的表达式。（括号是可选的。我添加它们是为了使代码更易于阅读。）如果这是`true`，则使用`?`和`:`符号之间的表达式（在本例中是`x`）；否则，使用`:`符号之后的表达式（在这里是`y`）。
- en: The conditional operator is similar to the conditional AND and OR operators
    in that it will evaluate only the operands it has to. It always evaluates its
    first operand, but it will never evaluate both the second and third operands.
    That means you can handle `null` values by writing something like [Example 2-57](#exploiting_conditional_evaluation).
    This does not risk causing a `NullReferenceException`, because it will evaluate
    the third operand only if `s` is not `null`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 条件运算符类似于条件AND和OR运算符，因为它只评估必须的操作数。它总是评估其第一个操作数，但永远不会同时评估第二个和第三个操作数。这意味着您可以通过编写类似于[示例
    2-57](#exploiting_conditional_evaluation)的代码来处理`null`值。这不会因为`s`为`null`而导致`NullReferenceException`的风险，因为它只有在`s`不为`null`时才会评估第三个操作数。
- en: Example 2-57\. Exploiting conditional evaluation
  id: totrans-428
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[示例 2-57](#exploiting_conditional_evaluation)。利用条件评估'
- en: '[PRE62]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'However, in some cases, there are simpler ways of dealing with `null` values.
    Suppose you have a `string` variable, and if it’s `null`, you’d like to use the
    empty string instead. You could write `(s == null ? "" : s)`. But you could just
    use the *null coalescing* operator instead, because it’s designed for precisely
    this job. This operator, shown in [Example 2-58](#null_coalescing_operator) (it’s
    the `??` symbol), evaluates its first operand, and if that’s non-null, that’s
    the result of the expression. If the first operand is `null`, it evaluates its
    second operand and uses that instead.'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '但在某些情况下，处理`null`值的方法更简单。假设您有一个`string`变量，如果它为`null`，则希望使用空字符串代替。您可以写`(s ==
    null ? "" : s)`。但您也可以直接使用*空值合并*运算符，因为它专门设计用于此任务。这个运算符显示在[示例 2-58](#null_coalescing_operator)中（它是`??`符号），它评估其第一个操作数，如果第一个操作数非空，则结果是该表达式的结果。如果第一个操作数为`null`，则评估其第二个操作数并使用它代替。'
- en: Example 2-58\. The null coalescing operator
  id: totrans-431
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[示例 2-58](#null_coalescing_operator)。空值合并运算符'
- en: '[PRE63]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We could combine a null-conditional operator with the null coalescing operator
    to provide a more succinct alternative to [Example 2-57](#exploiting_conditional_evaluation),
    shown in [Example 2-59](#conditional_null_and_null_coalescing_ope).
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将空值条件运算符与空值合并运算符结合起来，以提供比[示例 2-57](#exploiting_conditional_evaluation)更简洁的替代方案，如[示例
    2-59](#conditional_null_and_null_coalescing_ope)所示。
- en: Example 2-59\. Null-conditional and null coalescing operators
  id: totrans-434
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-59\. 空值条件和空值合并运算符
- en: '[PRE64]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: One of the main benefits offered by the conditional, null-conditional, and null
    coalescing operators is that they often allow you to write a single expression
    in cases where you would otherwise have needed to write considerably more code.
    This can be particularly useful if you’re using the expression as an argument
    to a method, as in [Example 2-60](#conditional_expression_as_method_arg).
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 条件、空值条件和空值合并运算符提供的主要好处之一是，它们通常允许您在需要编写大量代码的情况下仅编写单个表达式。如果您将该表达式作为方法的参数使用，这将特别有用，例如在[示例
    2-60](#conditional_expression_as_method_arg)中。
- en: Example 2-60\. Conditional expression as method argument
  id: totrans-437
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-60\. 条件表达式作为方法参数
- en: '[PRE65]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Compare this with what you’d need to write if the conditional operator did not
    exist. You would need an `if` statement. (I’ll get to `if` statements in the next
    section, but since this book is not for novices, I’m assuming you’re familiar
    with the rough idea.) And you’d either need to introduce a local variable, as
    [Example 2-61](#life_without_the_conditional_operator) does, or you’d need to
    duplicate the method call in the two branches of the `if`/`else`, changing just
    the first argument. So, terse though the conditional and null coalescing operators
    are, they can remove a lot of clutter from your code.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 与如果条件运算符不存在时需要编写的代码进行比较。您将需要一个 `if` 语句。（我会在下一节讨论 `if` 语句，但由于本书不是给初学者的，我假设您对大致概念很熟悉。）您还需要引入一个本地变量，如[示例
    2-61](#life_without_the_conditional_operator)所示，或者在 `if`/`else` 的两个分支中复制方法调用，并只更改第一个参数。因此，尽管条件和空值合并运算符很简洁，但它们可以从您的代码中移除大量混乱。
- en: Example 2-61\. Life without the conditional operator
  id: totrans-440
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-61\. 没有条件运算符的生活
- en: '[PRE66]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'There is one last set of operators to look at: the *compound assignment* operators.
    These combine assignment with some other operation and are available for the `+`,
    `-`, `*`, `/`, `%`, `<<`, `>>`, `&`, `^`, `|`, and `??` operators. They enable
    you not to have to write the sort of code shown in [Example 2-62](#assignment_and_addition).'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 还有最后一组要看的运算符：*复合赋值* 运算符。这些结合赋值和其他某些操作，并适用于 `+`, `-`, `*`, `/`, `%`, `<<`, `>>`,
    `&`, `^`, `|`, 和 `??` 运算符。它们使您无需编写像[示例 2-62](#assignment_and_addition)中显示的代码。
- en: Example 2-62\. Assignment and addition
  id: totrans-443
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-62\. 赋值和加法
- en: '[PRE67]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We can write this assignment statement more compactly as the code in [Example 2-63](#compound_assignment_left_parenthesisaddi).
    All the compound assignment operators take this form—you just stick an `=` on
    the end of the original operator.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将此赋值语句更简洁地写成 [示例 2-63](#compound_assignment_left_parenthesisaddi) 中的代码。所有复合赋值运算符都采用这种形式——您只需在原始运算符的末尾加上
    `=`。
- en: Example 2-63\. Compound assignment (addition)
  id: totrans-446
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-63\. 复合赋值（加法）
- en: '[PRE68]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This is a distinctive syntax that makes it very clear that we are modifying
    the value of a variable in some particular way. So, although those two snippets
    perform identical work, many developers find the second idiomatically preferable.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种独特的语法，非常清楚地表明我们正在以某种特定方式修改变量的值。因此，尽管这两个片段执行相同的工作，许多开发人员发现第二种习惯上更可取。
- en: That’s not quite a comprehensive list of operators. There are a few more specialized
    ones that I’ll get to once we’ve looked at the areas of the language for which
    they were defined. (Some relate to classes and other types, some to inheritance,
    some to collections, and some to delegates. There are chapters coming up on all
    of these.) By the way, although I’ve been describing which operators are available
    on which types, it’s possible to write a custom type that defines its own meanings
    for most of these. That’s how .NET’s `BigInteger` type can support the same arithmetic
    operations as the built-in numeric types. I’ll show how this can be done in [Chapter 3](ch03.xhtml#ch_types).
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是运算符的全面列表。还有一些更专业的运算符，我会在我们看过为其定义的语言区域后再介绍。 （有些与类和其他类型相关，有些与继承相关，有些与集合相关，有些与委托相关。接下来的章节将讲解所有这些内容。）顺便说一句，虽然我一直在描述哪些运算符适用于哪些类型，但也可以编写自定义类型，为大多数这些运算符定义自己的含义。这就是
    .NET 的 `BigInteger` 类型如何支持与内置数值类型相同的算术运算的方式。我将展示如何在 [Chapter 3](ch03.xhtml#ch_types)
    中实现这一点。
- en: Flow Control
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流程控制
- en: Most of the code we have examined so far executes statements in the order they
    are written and stops when it reaches the end. If that were the only possible
    way in which execution could flow through our code, C# would not be very useful.
    So, as you’d expect, it has a variety of constructs for writing loops and for
    deciding which code to execute based on inputs.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所检查的大部分代码按照编写顺序执行语句，并在到达末尾时停止。如果这是代码执行流动的唯一可能方式，那么 C# 将没有多大用处。因此，正如你所期望的那样，它有多种结构来编写循环并根据输入来决定执行哪些代码。
- en: Boolean Decisions with if Statements
  id: totrans-452
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `if` 语句进行布尔决策
- en: An `if` statement decides whether or not to run some particular statement depending
    on the value of a `bool` expression. For example, the `if` statement in [Example 2-64](#simple_if_statement)
    will execute the block statement that shows a message only if the `age` variable’s
    value is less than 18.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句根据 `bool` 表达式的值决定是否运行特定语句。例如，在 [Example 2-64](#simple_if_statement)
    中的 `if` 语句将仅在 `age` 变量的值小于 18 时执行显示消息的块语句。'
- en: Example 2-64\. Simple `if` statement
  id: totrans-454
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 2-64\. 简单的 `if` 语句
- en: '[PRE69]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'You don’t have to use a block statement with an `if` statement. You can use
    any statement type as the body. A block is necessary only if you want the `if`
    statement to govern the execution of multiple statements. However, some coding
    style guidelines recommend using a block in all cases. This is partly for consistency
    but also because it avoids a possible error when modifying the code at a later
    date: if you have a nonblock statement as the body of an `if`, and then you add
    another statement after that, intending it to be part of the same body, it can
    be easy to forget to add a block around the two statements, leading to code like
    that in [Example 2-65](#probably_not_what_was_intended). The indentation suggests
    that the developer meant for the final statement to be part of the `if` statement’s
    body, but C# ignores indentation, so that final statement will always run. If
    you are in the habit of always using a block, you won’t make this mistake.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `if` 语句时不一定需要使用块语句。你可以使用任何类型的语句作为主体。只有当你希望 `if` 语句控制多个语句的执行时才需要块。然而，一些编程风格指南建议在所有情况下都使用块。这部分是为了保持一致性，同时也是因为在以后修改代码时避免可能的错误：如果你的
    `if` 语句的主体是非块语句，然后你在后面添加另一个语句，打算让它成为相同主体的一部分，很容易忘记在这两个语句周围添加块，导致像 [Example 2-65](#probably_not_what_was_intended)
    中那样的代码。缩进表明开发人员希望最后一个语句是 `if` 语句主体的一部分，但 C# 忽略缩进，因此最后一个语句将始终运行。如果你习惯于始终使用块，你就不会犯这种错误。
- en: Example 2-65\. Probably not what was intended
  id: totrans-457
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 2-65\. 可能不是预期的结果
- en: '[PRE70]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: An `if` statement can optionally include an `else` part, which is followed by
    another statement that runs only if the `if` statement’s expression evaluates
    to `false`. So [Example 2-66](#if_and_else) will write either the first or the
    second message, depending on whether the `optimistic` variable is `true` or `false`.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句还可以选择包含一个 `else` 部分，后面跟着另一个语句，仅在 `if` 语句的表达式求值为 `false` 时运行。所以 [Example 2-66](#if_and_else)
    将根据 `optimistic` 变量是 `true` 还是 `false` 写入第一条或第二条消息。'
- en: Example 2-66\. `if` and `else`
  id: totrans-460
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 2-66\. `if` 和 `else`
- en: '[PRE71]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `else` keyword can be followed by any statement, and again, this is typically
    a block. However, there’s one scenario in which most developers do not use a block
    for the body of the `else` part, and that’s when they use another `if` statement.
    [Example 2-67](#picking_one_of_several_possibilities) shows this—its first `if`
    statement has an `else` part, which has another `if` statement as its body.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '`else`关键字后可以跟随任何语句，通常这是一个代码块。但是，有一种情况大多数开发者不会为`else`部分使用代码块，那就是它们使用另一个`if`语句时。[示例 2-67](#picking_one_of_several_possibilities)展示了这一点——它的第一个`if`语句有一个`else`部分，该部分的主体是另一个`if`语句。'
- en: Example 2-67\. Picking one of several possibilities
  id: totrans-463
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-67\. 选择多个可能性
- en: '[PRE72]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This code still looks like it uses a block for that first `else`, but that block
    is actually the statement that forms the body of a second `if` statement. It’s
    that second `if` statement that is the body of the `else`. If we were to stick
    rigidly to the rule of giving each `if` and `else` body its own block, we’d rewrite
    [Example 2-67](#picking_one_of_several_possibilities) as [Example 2-68](#overdoing_the_blocks).
    This seems unnecessarily fussy, because the main risk that we’re trying to avert
    by using blocks doesn’t really apply in [Example 2-67](#picking_one_of_several_possibilities).
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管代码看起来仍然像是为第一个`else`使用了代码块，但该代码块实际上是第二个`if`语句的主体。第二个`if`语句才是`else`的主体。如果我们要严格遵循给每个`if`和`else`主体分配自己的代码块的规则，我们会将[示例 2-67](#picking_one_of_several_possibilities)重写为[示例 2-68](#overdoing_the_blocks)。这似乎过于繁琐，因为我们试图通过使用代码块来避免的主要风险在[示例 2-67](#picking_one_of_several_possibilities)中并不真正适用。
- en: Example 2-68\. Overdoing the blocks
  id: totrans-466
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-68\. 过度使用代码块
- en: '[PRE73]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Although we can chain `if` statements together as shown in [Example 2-67](#picking_one_of_several_possibilities),
    C# offers a more specialized statement that can sometimes be easier to read.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以像[示例 2-67](#picking_one_of_several_possibilities)中展示的那样将`if`语句链接在一起，但C#提供了一种更专门的语句，有时可能更易于阅读。
- en: Multiple Choice with switch Statements
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用`switch`语句进行多选
- en: A `switch` statement defines multiple groups of statements and either runs one
    group or does nothing at all, depending on the value of an input expression. As
    [Example 2-69](#switch_statement_with_strings) shows, you put the expression inside
    parentheses after the `switch` keyword, and after that, there’s a region delimited
    by braces containing a series of `case` sections, defining the behavior for each
    anticipated value for the expression.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句定义了多个语句组，并根据输入表达式的值运行其中一个组或者什么都不做。正如[示例 2-69](#switch_statement_with_strings)所示，你将表达式放在`switch`关键字后的括号内，然后是由大括号界定的区域，其中包含一系列`case`部分，为表达式的每个预期值定义行为。'
- en: Example 2-69\. A `switch` statement with strings
  id: totrans-471
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-69\. 使用字符串的`switch`语句
- en: '[PRE74]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: As you can see, a single section can serve multiple possibilities—you can put
    several different `case` labels at the start of a section, and the statements
    in that section will run if any of those cases apply. You can also write a `default`
    section, which will run if none of the cases apply. A `switch` statement does
    not have to be comprehensive, so if there is no `case` that matches the expression’s
    value and there is no `default` section, the `switch` statement simply does nothing.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，单个部分可以服务于多个可能性——你可以在部分的开头放置多个不同的`case`标签，如果任何一个情况适用，该部分中的语句将会运行。你也可以编写一个`default`部分，如果没有`case`匹配表达式的值，则运行该部分。`switch`语句不必是全面的，因此如果没有与表达式值匹配的`case`，也没有`default`部分，则`switch`语句不执行任何操作。
- en: Unlike `if` statements, which take exactly one statement for the body, a `case`
    may be followed by multiple statements without needing to wrap them in a block.
    The sections in [Example 2-69](#switch_statement_with_strings) are delimited by
    `break` statements, which causes execution to jump to the end of the `switch`
    statement. This is not the only way to finish a section—strictly speaking, the
    rule imposed by the C# compiler is that the end point of the statement list for
    each `case` must not be reachable, so anything that causes execution to leave
    the `switch` statement is acceptable. You could use a `return` statement instead,
    or throw an exception, or you could even use a `goto` statement.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 不像`if`语句需要将主体包裹在一个代码块中，`case`后面可以跟随多个语句而无需包裹它们。[示例 2-69](#switch_statement_with_strings)中的各个部分由`break`语句界定，这会导致执行跳到`switch`语句的结尾。这并非结束部分的唯一方式——严格来说，C#编译器规定每个`case`语句列表的结束点不能可达，因此任何导致执行离开`switch`语句的方式都是可接受的。你可以使用`return`语句，或者抛出异常，甚至可以使用`goto`语句。
- en: Some C-family languages (C, for example) allow *fall-through*, meaning that
    if execution is allowed to reach the end of the statements in a `case` section,
    it will continue with the next one. [Example 2-70](#c-style_fall-through_illegal_in_cs)
    shows this style, and it is not allowed in C# because of the rule that requires
    the end of a `case` statement list not to be reachable.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 一些C家族语言（例如C）允许*穿透*，意味着如果执行允许达到`case`部分语句的末尾，它将继续执行下一个。[示例 2-70](#c-style_fall-through_illegal_in_cs)展示了这种风格，但在C#中不允许，因为该规则要求`case`语句列表的末尾不可到达。
- en: Example 2-70\. C-style fall-through, illegal in C#
  id: totrans-476
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-70\. C风格的穿透，在C#中是非法的。
- en: '[PRE75]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'C# outlaws this, because the vast majority of `case` sections do not fall through,
    and when they do in languages that allow it, it’s often a mistake caused by the
    developer forgetting to write a `break` statement (or some other statement to
    break out of the `switch`). Accidental fall-through is likely to produce unwanted
    behavior, so C# requires more than the mere omission of a `break`: if you want
    fall-through, you must ask for it explicitly. As [Example 2-71](#fall-through_in_chash)
    shows, we use the unloved `goto` keyword to express that we really do want one
    case to fall through into the next one.'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: C#禁止这种做法，因为绝大多数`case`部分不会穿透，而在允许它的语言中，当开发者忘记写`break`语句（或者其他中断`switch`的语句）时，通常会导致错误。意外的穿透可能会产生不希望的行为，因此C#要求不仅仅是省略了`break`：如果你想要穿透，必须明确请求。正如[示例 2-71](#fall-through_in_chash)所示，我们使用不被喜爱的`goto`关键字来表达我们确实希望一个`case`穿透到下一个`case`。
- en: Example 2-71\. Fall-through in C#
  id: totrans-479
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-71\. C#中的穿透。
- en: '[PRE76]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This is not technically a `goto` statement. It is a `goto case` statement and
    can be used only to jump within a `switch` block. C# also supports more general
    `goto` statements—you can add labels to your code and jump around within your
    methods. However, `goto` is heavily frowned upon, so the fall-through form offered
    by `goto case` statements seems to be the only use for this keyword that is considered
    respectable in modern society.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 这在技术上不是`goto`语句。这是一个`goto case`语句，只能在`switch`块内部使用。C#还支持更一般的`goto`语句——您可以在代码中添加标签，并在方法内部跳转。但是`goto`被严重反对，因此`goto
    case`语句提供的穿透形式似乎是这个关键字唯一被认为是现代社会可接受的用法。
- en: 'These examples have all used strings. You can also use `switch` with integer
    types, `char`, and any `enum` (a kind of type discussed in the next chapter).
    But `case` labels don’t necessarily have to be constants: you can also use patterns,
    which are discussed later in this chapter.'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些示例都使用了字符串。你还可以在整数类型、`char` 类型以及任何枚举（在下一章节中讨论的一种类型）上使用`switch`。但是`case`标签不一定要是常量：你还可以使用模式，这将在本章后面讨论。
- en: 'Loops: while and do'
  id: totrans-483
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环：`while`和`do`
- en: C# supports the usual C-family loop mechanisms. [Example 2-72](#while_loop)
    shows a `while` loop. This takes a `bool` expression. It evaluates that expression,
    and if the result is `true`, it will execute the statement that follows. So far,
    this is just like an `if` statement, but the difference is that once the loop’s
    embedded statement is complete, it then evaluates the expression again, and if
    it’s `true` again, it will execute the embedded statement a second time. It will
    keep doing this until the expression evaluates to `false`. As with `if` statements,
    the body of the loop does not need to be a block, but it usually is.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: C#支持通常的C家族循环机制。[示例 2-72](#while_loop)展示了一个`while`循环。它采用一个`bool`表达式。评估该表达式，如果结果为`true`，它将执行后续的语句。到目前为止，这与`if`语句完全相同，但不同之处在于一旦嵌套语句完成，它将再次评估表达式，如果再次为`true`，它将再次执行嵌套语句。它将继续执行，直到表达式评估为`false`。与`if`语句一样，循环体不需要是一个块，但通常会是。
- en: Example 2-72\. A `while` loop
  id: totrans-485
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-72\. 一个`while`循环。
- en: '[PRE77]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The body of the loop may decide to finish the loop early with a `break` statement.
    It does not matter whether the `while` expression is `true` or `false`—executing
    a `break` statement will always terminate the loop.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 循环体可能会使用`break`语句提前结束循环。`while`表达式是`true`或`false`并不重要——执行`break`语句总是会终止循环。
- en: C# also offers the `continue` statement. Like a `break` statement, this terminates
    the current iteration, but unlike `break`, it will then reevaluate the `while`
    expression, so iteration may continue. Both `continue` and `break` jump straight
    to the end of the loop, but you could think of `continue` as jumping directly
    to the point just before the loop’s closing `}`, while `break` jumps to the point
    just after. By the way, `continue` and `break` are also available for all of the
    other loop styles I’m about to show.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: C# 还提供了`continue`语句。像`break`语句一样，它终止当前迭代，但与`break`不同的是，它然后重新评估`while`表达式，因此迭代可以继续。`continue`和`break`都直接跳转到循环的结尾，但你可以认为`continue`直接跳转到循环结束`}`之前的点，而`break`则跳转到之后的点。顺便说一下，`continue`和`break`也适用于我即将展示的所有其他循环样式。
- en: Because a `while` statement evaluates its expression before each iteration,
    it’s possible for a `while` loop not to run its body at all. Sometimes, you may
    want to write a loop that runs at least once, only evaluating the `bool` expression
    after the first iteration. This is the purpose of a `do` loop, as shown in [Example 2-73](#do_loop).
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`while`语句在每次迭代之前评估其表达式，所以`while`循环有可能根本不运行其主体。有时，您可能希望编写一个至少运行一次的循环，仅在第一次迭代后评估`bool`表达式。这就是`do`循环的目的，如[示例 2-73](#do_loop)所示。
- en: Example 2-73\. A `do` loop
  id: totrans-490
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-73\. 一个`do`循环
- en: '[PRE78]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Notice that [Example 2-73](#do_loop) ends in a semicolon, denoting the end of
    the statement. Compare this with the line containing the `while` keyword in [Example 2-72](#while_loop),
    which does not, despite otherwise looking very similar. That may look inconsistent,
    but it’s not a typo. Putting a semicolon at the end of the line with the `while`
    keyword in [Example 2-72](#while_loop) would be legal, but it would change the
    meaning—it would indicate that we want the body of the `while` loop to be an empty
    statement. The block that followed would then be treated as a brand-new statement
    to execute after the loop completes. The code would get stuck in an infinite loop
    unless the reader were already at the end of the stream. (The compiler will issue
    a warning about a “Possible mistaken empty statement” if you do that, by the way.)
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，[示例 2-73](#do_loop)以分号结尾，表示语句结束。与包含`while`关键字的[示例 2-72](#while_loop)中的行进行比较，后者尽管看起来非常相似，但没有分号。这看起来可能不一致，但这不是打字错误。在[示例 2-72](#while_loop)中带有`while`关键字的行末尾放置分号是合法的，但这会改变其含义——它将指示我们希望`while`循环的主体是一个空语句。随后的代码块将被视为一个全新的语句，在循环完成后执行。代码将陷入无限循环，除非读者已经在流的末尾。（顺便说一句，编译器会发出“可能是误写的空语句”警告。）
- en: C-Style for Loops
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C 风格的`for`循环
- en: 'Another style of loop that C# inherits from C is the `for` loop. This is similar
    to `while`, but it adds two features to that loop’s `bool` expression: it provides
    a place to declare and/or initialize one or more variables that will remain in
    scope for as long as the loop runs, and it provides a place to perform some operation
    each time around the loop (in addition to the statement that forms the body of
    the loop). So the structure of a `for` loop looks like this:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: C# 继承自 C 的另一种循环方式是`for`循环。这类似于`while`，但它为循环的`bool`表达式添加了两个特性：提供了一个声明和/或初始化一个或多个变量的位置，这些变量在循环运行期间保持在作用域内，并且提供了一个在每次循环时执行某些操作的位置（除了形成循环体的语句）。因此，`for`循环的结构如下：
- en: '[PRE79]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: A very common application of this is to do something to all the elements in
    an array. [Example 2-74](#modifying_array_elements_with_a_for_loop) shows a `for`
    loop that multiplies every element in an array by 2\. The condition part works
    in exactly the same way as in a `while` loop—it determines whether the embedded
    statement forming the loop’s body runs, and it will be evaluated before each iteration.
    Again, the body doesn’t strictly have to be a block but usually is.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 这种循环的一个非常常见的应用是对数组中的所有元素执行某些操作。[示例 2-74](#modifying_array_elements_with_a_for_loop)展示了一个`for`循环，它将数组中的每个元素乘以2。条件部分的工作方式与`while`循环完全相同——它确定嵌入语句形成的循环体是否运行，并且在每次迭代之前对其进行评估。再次强调，循环体不一定严格要求是一个块，但通常是。
- en: Example 2-74\. Modifying array elements with a `for` loop
  id: totrans-497
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-74\. 使用`for`循环修改数组元素
- en: '[PRE80]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The initializer in this example declares a variable called `i` and initializes
    it to 0\. This initialization happens just once—this wouldn’t be very useful if
    it reset the variable to 0 every time around the loop, because the loop would
    never end. This variable’s lifetime effectively begins just before the loop starts
    and finishes when the loop finishes. The initializer does not need to be a variable
    declaration—you can use any expression statement.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中的初始化器声明了一个名为`i`的变量，并将其初始化为0。此初始化仅发生一次——如果它每次循环都重置变量为0，这将毫无用处，因为循环永远不会结束。该变量的生命周期实际上是在循环开始之前开始，并在循环结束时结束。初始化器不需要是变量声明——您可以使用任何表达式语句。
- en: The iterator in [Example 2-74](#modifying_array_elements_with_a_for_loop) just
    adds 1 to the loop counter. It runs at the end of each loop iteration, after the
    body runs and before the condition is reevaluated. (So if the condition is initially
    false, not only does the body not run, the iterator will never be evaluated.)
    C# does nothing with the result of the iterator expression—it is useful only for
    its side effects. So it doesn’t matter whether you write `i++`, `++i`, `i += 1`,
    or even `i = i + 1`.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 2-74](#modifying_array_elements_with_a_for_loop)中的迭代器仅将循环计数器加1。它在每次循环迭代结束时运行，在主体运行之后和条件重新评估之前运行。（因此，如果条件最初为假，则不仅主体不运行，迭代器也永远不会被评估。）C#不对迭代器表达式的结果执行任何操作——它仅用于其副作用。因此，无论您是写`i++`、`++i`、`i
    += 1`，甚至`i = i + 1`，都没有关系。'
- en: A `for` loop doesn’t let you do anything that you couldn’t have achieved by
    writing a `while` loop and putting the initialization code before the loop and
    the iterator at the end of the loop body instead.^([11](ch02.xhtml#fn15)) However,
    there may be readability benefits. A `for` statement puts the code that defines
    how we loop in one place, separate from the code that defines what we do each
    time around the loop, which might help those reading the code to understand what
    it does. They don’t have to scan down to the end of a long loop to find the iterator
    statement (although a long loop body that trails over pages of code is generally
    considered to be bad practice, so this last benefit is a little dubious).
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环不允许您做任何通过编写`while`循环并在循环之前放置初始化代码以及在循环体末尾放置迭代器来实现的事情。^([11](ch02.xhtml#fn15))
    但是，可能存在可读性的好处。`for`语句将定义如何循环的代码放在一个地方，与定义每次循环时做什么的代码分开，这可能有助于阅读代码的人理解它的功能。他们不必扫描长循环到底部以找到迭代器语句（尽管长循环体跨越代码页通常被认为是不良实践，因此最后一个好处有些可疑）。'
- en: Both the initializer and the iterator can contain lists, as [Example 2-75](#multiple_initializers_and_iterators)
    shows, although in this particular case it isn’t terribly useful—since all the
    iterators run every time around, `i` and `j` will have the same value as each
    other throughout.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 如[示例 2-75](#multiple_initializers_and_iterators)所示，初始化器和迭代器都可以包含列表，尽管在这种特定情况下并不是非常有用——因为所有迭代器每次循环都会运行，`i`和`j`将始终具有相同的值。
- en: Example 2-75\. Multiple initializers and iterators
  id: totrans-503
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-75\. 多个初始化器和迭代器
- en: '[PRE81]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: You can’t write a single `for` loop that performs a multidimensional iteration.
    If you want that, you would nest one loop inside another, as [Example 2-76](#nested_for_loops)
    illustrates.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能编写一个单独的`for`循环来执行多维迭代。如果需要，您可以像[示例 2-76](#nested_for_loops)中所示一样将一个循环嵌套在另一个循环中。
- en: Example 2-76\. Nested `for` loops
  id: totrans-506
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-76\. 嵌套`for`循环
- en: '[PRE82]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Although [Example 2-74](#modifying_array_elements_with_a_for_loop) shows a common
    enough idiom for iterating through arrays, you will often use a different, more
    specialized construct.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管[示例 2-74](#modifying_array_elements_with_a_for_loop)展示了一个足够常见的遍历数组的习惯用法，您通常会使用不同、更专业的构造。
- en: Collection Iteration with foreach Loops
  id: totrans-509
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用foreach循环进行集合迭代
- en: 'C# offers a style of loop that is not universal in C-family languages. The
    `foreach` loop is designed for iterating through collections. A `foreach` loop
    fits this pattern:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: C#提供了一种不在C语系语言中通用的循环风格。`foreach`循环专门用于迭代集合。`foreach`循环符合以下模式：
- en: '[PRE83]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The `*collection*` is an expression whose type must match a particular pattern
    recognized by the compiler. The runtime libraries’ `IEnumerable<T>` interface,
    which we’ll be looking at in [Chapter 5](ch05.xhtml#ch_collections), matches this
    pattern, although the compiler doesn’t actually require an implementation of that
    interface—it just requires the collection to have a `GetEnumerator` method that
    resembles the one defined by that interface. [Example 2-77](#iterating_over_a_collection_with_foreach)
    uses `foreach` to show all the strings in an array. (All arrays provide the method
    that `foreach` requires.)
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '*集合* 是一个表达式，其类型必须与编译器识别的特定模式匹配。运行时库的`IEnumerable<T>`接口，我们将在[第5章](ch05.xhtml#ch_collections)中看到，符合这种模式，尽管编译器实际上并不需要实现该接口——它只需要集合有一个类似该接口定义的`GetEnumerator`方法。[示例2-77](#iterating_over_a_collection_with_foreach)使用`foreach`显示数组中的所有字符串（所有数组都提供`foreach`所需的方法）。'
- en: Example 2-77\. Iterating over a collection with `foreach`
  id: totrans-513
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例2-77\. 使用`foreach`遍历集合
- en: '[PRE84]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This loop will run the body once for each item in the array. The *iteration
    variable* (`message`, in this example) is different each time around the loop
    and will refer to the item for the current iteration.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 此循环将为数组中的每个项目运行一次主体。*迭代变量*（在本例中为`message`）每次循环都不同，并且将引用当前迭代的项目。
- en: 'In one way, this is less flexible than the `for`-based loop shown in [Example 2-74](#modifying_array_elements_with_a_for_loop):
    a `foreach` loop cannot modify the collection it iterates over. That’s because
    not all collections support modification. `IEnumerable<T>` demands very little
    of its collections—it does not require modifiability, random access, or even the
    ability to know up front how many items the collection provides. (In fact, `IEnumerable<T>`
    is able to support never-ending collections. For example, it is perfectly legal
    to write an implementation that will return random numbers for as long as you
    care to keep fetching values.)'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种角度来看，这比[示例2-74](#modifying_array_elements_with_a_for_loop)中显示的基于`for`的循环更不灵活：`foreach`循环无法修改其迭代的集合。这是因为并非所有集合都支持修改。`IEnumerable<T>`对其集合要求非常少——它不要求可修改性、随机访问，甚至不要求在前面知道集合提供的项目数量。事实上，`IEnumerable<T>`能够支持永不结束的集合。例如，可以完全合法地编写一个实现，它将返回随机数，只要你愿意继续获取值即可。
- en: 'But `foreach` offers two advantages over `for`. One advantage is subjective
    and therefore debatable: it’s a bit more readable. But significantly, it’s also
    more general. If you’re writing methods that do things to collections, those methods
    will be more broadly applicable if they use `foreach` rather than `for`, because
    you’ll be able to accept an `IEnumerable<T>`. [Example 2-78](#general-purpose_collection_iteration)
    can work with any collection that contains strings, rather than being limited
    to arrays.'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 但`foreach`比`for`提供了两个优势。一个优势是主观的，因此存在争议：它更可读。但显著的是，它也更通用。如果您正在编写对集合执行操作的方法，那么如果使用`foreach`而不是`for`，这些方法将更广泛适用，因为您将能够接受一个`IEnumerable<T>`。[示例2-78](#general-purpose_collection_iteration)可以处理包含字符串的任何集合，而不仅仅限于数组。
- en: Example 2-78\. General-purpose collection iteration
  id: totrans-518
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例2-78\. 通用集合迭代
- en: '[PRE85]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This code can work with collection types that do not support random access,
    such as the `LinkedList<T>` class described in [Chapter 5](ch05.xhtml#ch_collections).
    It can also process lazy collections that decide what items to produce on demand,
    including those produced by iterator functions, also shown in [Chapter 5](ch05.xhtml#ch_collections),
    and by certain LINQ queries, as described in [Chapter 10](ch10.xhtml#ch_linq).
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码可以处理不支持随机访问的集合类型，例如[第5章](ch05.xhtml#ch_collections)中描述的`LinkedList<T>`类。它还可以处理决定按需生成项目的惰性集合，包括迭代器函数生成的集合，同样显示在[第5章](ch05.xhtml#ch_collections)中，以及某些LINQ查询生成的集合，如[第10章](ch10.xhtml#ch_linq)中描述的那样。
- en: Patterns
  id: totrans-521
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式
- en: 'There’s one last essential mechanism to look at in C#: *patterns*. A pattern
    describes one or more criteria that a value can be tested against. You’ve already
    seen some simple patterns in action: each `case` in a `switch` specifies a pattern.
    But as we’ll now see, there are many kinds of patterns, and they aren’t just for
    `switch` statements.'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: C#中还有一个最后一个重要的机制要看一看：*模式*。模式描述了一个值可以根据其进行测试的一个或多个条件。你已经在某些简单模式中看到了它们的作用：`switch`中的每个`case`指定了一个模式。但正如我们将要看到的，有许多种类的模式，它们不仅仅适用于`switch`语句。
- en: 'The `switch` examples earlier, such as [Example 2-69](#switch_statement_with_strings),
    all used one of the simplest pattern types: they were all *constant patterns*.
    With these, you specify just a constant value, and an expression matches this
    pattern if it has that value. [Example 2-79](#declaration_patterns) shows a more
    interesting kind of pattern: it uses *declaration patterns*. An expression matches
    a declaration pattern if it has the specified type. As you saw earlier in [“Object”](#object),
    some variables are capable of holding a variety of different types. Variables
    of type `object` are an extreme case of this, since they can hold more or less
    anything. Language features such as *interfaces* (discussed in [Chapter 3](ch03.xhtml#ch_types)),
    generics ([Chapter 4](ch04.xhtml#ch_generics)), and inheritance ([Chapter 6](ch06.xhtml#ch_inheritance))
    can lead to scenarios where the static type of a variable provides more information
    than the anything-goes `object` type but still leave latitude for a range of possible
    types at runtime. Declaration patterns can be useful in these cases.'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 `switch` 示例，例如 [示例 2-69](#switch_statement_with_strings)，都使用了最简单的模式类型之一：它们都是*常量模式*。对于这些模式，只需指定一个常量值，如果表达式具有该值，则匹配此模式。[示例 2-79](#declaration_patterns)
    展示了更有趣的模式类型：它使用了*声明模式*。如果表达式具有指定类型，则匹配声明模式。正如你在 [“Object”](#object) 中看到的那样，某些变量能够保存各种不同类型的值。类型为
    `object` 的变量是这种情况的极端案例，因为它们几乎可以保存任何类型的值。语言特性如*接口*（在 [第三章](ch03.xhtml#ch_types)
    中讨论）、泛型（在 [第四章](ch04.xhtml#ch_generics) 中）和继承（在 [第六章](ch06.xhtml#ch_inheritance)
    中）可能导致变量的静态类型提供了比任意类型 `object` 更多的信息，但仍为运行时的各种可能类型留下了余地。在这些情况下，声明模式可以非常有用。
- en: Example 2-79\. Declaration patterns
  id: totrans-524
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-79\. 声明模式
- en: '[PRE86]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Declaration patterns have an interesting characteristic that constant ones
    do not: as well as the Boolean match/no-match common to all patterns, a declaration
    pattern produces an additional output. Each `case` in [Example 2-79](#declaration_patterns)
    introduces a variable, which the code for that `case` then goes on to use. This
    output is just the input but copied into a variable with the specified static
    type. So that first `case` will match if `o` turns out to be a `string`, in which
    case we can access it through the `s` variable (which is why that `s.Length` expression
    compiles correctly; `o.Length` would not if `o` is of type `object`).'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 声明模式有一个有趣的特性，常量模式没有：除了所有模式共有的布尔匹配/不匹配之外，声明模式会产生额外的输出。[示例 2-79](#declaration_patterns)
    中的每个 `case` 引入一个变量，然后该 `case` 的代码继续使用该变量。这个输出只是输入，但是复制到具有指定静态类型的变量中。因此，如果 `o`
    最终是 `string`，那么第一个 `case` 将匹配，并且我们可以通过 `s` 变量访问它（这就是为什么 `s.Length` 表达式编译正确；如果
    `o` 的类型是 `object`，`o.Length` 就不会编译通过）。
- en: 'Sometimes, you won’t actually need a declaration pattern’s output—it might
    be enough just to know that the input matched a pattern. One way to handle these
    cases is with a *discard*: if you put an underscore (`_`) in the place where the
    output variable name would normally go, that tells the C# compiler that you are
    only interested in whether the value matches the type. C# 9.0 introduced a more
    succinct alternative: *type patterns*. A type pattern looks and works like a declaration
    pattern without the variable—as [Example 2-80](#type_patterns) shows, the pattern
    consists of just the type name.'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，实际上并不需要声明模式的输出结果——知道输入是否匹配模式就足够了。处理这些情况的一种方法是使用*丢弃*：如果在通常用于输出变量名称的位置放置一个下划线
    (`_`)，那告诉 C# 编译器你只关心值是否匹配类型。C# 9.0 引入了一个更简洁的替代方案：*类型模式*。类型模式看起来和工作方式类似于声明模式，但没有变量
    —— 如 [示例 2-80](#type_patterns) 所示，模式仅由类型名称组成。
- en: Example 2-80\. Type patterns
  id: totrans-528
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-80\. 类型模式
- en: '[PRE87]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Some patterns do a little more work to produce their output. For example, [Example 2-81](#positional_pattern)
    shows a *positional pattern* that matches any tuple containing a pair of `int`
    values and extracts those values into two variables, `x` and `y`.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 有些模式需要更多工作来产生它们的输出。例如，[示例 2-81](#positional_pattern) 展示了一个*位置模式*，它匹配任何包含一对 `int`
    值的元组，并将这些值提取到两个变量 `x` 和 `y` 中。
- en: Example 2-81\. Positional pattern
  id: totrans-531
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-81\. 位置模式
- en: '[PRE88]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Positional patterns are an example of a *recursive pattern*: they are patterns
    that contain patterns. In this case, this positional pattern contains a declaration
    pattern as each of its children. But as [Example 2-82](#positional_pattern_with_constant)
    shows, we can use constant values in each position to match tuples with specific
    values.'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 位置模式是*递归模式*的一个示例：它们是包含其他模式的模式。在这种情况下，这个位置模式包含声明模式作为它的每一个子模式。但正如[示例 2-82](#positional_pattern_with_constant)展示的那样，我们可以在每个位置使用常量值来匹配具有特定值的元组。
- en: Example 2-82\. Positional patterns with constant values
  id: totrans-534
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-82\. 带有常量值的位置模式
- en: '[PRE89]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We can mix things up, because positional patterns can contain different pattern
    types in each position. [Example 2-83](#positional_pattern_constant_and_declaration)
    shows a positional pattern with a constant pattern in the first position and a
    declaration pattern in the second.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以混合使用，因为位置模式可以在每个位置包含不同的模式类型。[示例 2-83](#positional_pattern_constant_and_declaration)
    展示了一个在第一个位置使用常量模式，在第二个位置使用声明模式的位置模式。
- en: Example 2-83\. Positional pattern with constant and declaration patterns
  id: totrans-537
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-83\. 带有常量和声明模式的位置模式
- en: '[PRE90]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: If you are a fan of `var`, you might be wondering if you can write something
    like [Example 2-84](#positional_pattern_with_var). This will work, and the static
    types of the `x` and `y` variables here will depend on the type of the pattern’s
    input expression. If the compiler can determine how the expression deconstructs
    (for example, if the `switch` statement input’s static type is an `(int, int)`
    tuple), then it will use this information to determine the output variables’ static
    types. In cases where this is unknown, but it’s still conceivable that this pattern
    could match (for example, if the input is `object`), then `x` and `y` here will
    also have type `object`.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是`var`的粉丝，你可能会想知道是否可以像[示例 2-84](#positional_pattern_with_var)那样编写。这是可行的，这里的`x`和`y`变量的静态类型取决于模式输入表达式的类型。如果编译器可以确定表达式如何解构（例如，如果`switch`语句输入的静态类型是`(int,
    int)`元组），那么它将使用这些信息来确定输出变量的静态类型。在未知情况下，但仍然可以想象此模式可能匹配的情况下（例如，如果输入是`object`），那么这里的`x`和`y`也将具有类型`object`。
- en: Example 2-84\. Positional pattern with `var`
  id: totrans-540
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-84\. 带有`var`的位置模式
- en: '[PRE91]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Note
  id: totrans-542
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The compiler will reject patterns in cases where it can determine that a match
    is impossible. For example, if it knows the input type is a `(string, int, bool)`
    tuple, it cannot possibly match a positional pattern with only two child patterns,
    so C# won’t let you try.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将拒绝那些它能够确定匹配不可能发生的模式。例如，如果它知道输入类型是 `(string, int, bool)` 元组，它不可能匹配只有两个子模式的位置模式，所以
    C# 不会允许你尝试。
- en: '[Example 2-84](#positional_pattern_with_var) shows an unusual case where using
    `var` instead of an explicit type can introduce a significant change of behavior.
    These *var patterns* differ in one important respect from the *declaration patterns*
    in [Example 2-81](#positional_pattern): a *var pattern* always matches its input,
    whereas a *declaration pattern* inspects its input’s type to determine at runtime
    whether it matches. This check might be optimized away in practice—there are cases
    where a declaration pattern will always match because its input type is known
    at compile time. But the only way to express in your code that you definitely
    don’t want the child patterns in a positional pattern to perform a runtime check
    is to use `var`. So although a positional pattern containing declaration patterns
    strongly resembles the deconstruction syntax shown in [Example 2-52](#tuple_deconstruction),
    the behavior is quite different. [Example 2-81](#positional_pattern) is in effect
    performing three runtime tests: whether the value is a 2-tuple, whether the first
    value is an `int`, and whether the second value is an `int`. (So it would work
    for tuples with a static type of `(object, object)`, as long as each value is
    an `int` at runtime.) This shouldn’t really be surprising: the point of patterns
    is to test at runtime whether a value has certain characteristics. However, with
    some recursive patterns, you may find yourself wanting to express a mixture of
    runtime matching (for example, is this thing a `string`?) combined with statically
    typed deconstruction (for example, if this is a `string`, I’d like to extract
    its `Length` property, which I believe to be of type `int`, and I want a compiler
    error if that belief turns out to be wrong). Patterns are not designed to do this,
    so it’s best not to try to use them that way.'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 2-84](#positional_pattern_with_var) 展示了一个不寻常的情况，即在某些情况下，使用 `var` 而不是显式类型可能会引入显著的行为变化。这些
    *var 模式* 与 [示例 2-81](#positional_pattern) 中的 *声明模式* 在一个重要方面有所不同：*var 模式* 总是匹配其输入，而
    *声明模式* 则检查其输入的类型以确定在运行时是否匹配。实际上，这种检查可能会被优化掉——有些情况下，声明模式将始终匹配，因为其输入类型在编译时已知。但在代码中表达的唯一方法，以确保在位置模式中的子模式不执行运行时检查，是使用
    `var`。因此，尽管一个包含声明模式的位置模式与 [示例 2-52](#tuple_deconstruction) 中显示的解构语法非常相似，其行为却大不相同。[示例 2-81](#positional_pattern)
    实际上执行了三个运行时测试：值是否为 2 元组，第一个值是否为 `int`，第二个值是否为 `int`。（因此，它适用于静态类型为 `(object, object)`
    的元组，只要每个值在运行时为 `int` 即可。）这其实不应该让人感到意外：模式的目的是在运行时测试值是否具有某些特征。然而，在某些递归模式中，您可能希望表达运行时匹配的混合（例如，这个东西是
    `string` 吗？）与静态类型的解构（例如，如果这是 `string`，我想提取其 `Length` 属性，我相信它的类型是 `int`，如果这种信念被证明错误，我希望编译器报错）。模式并不设计用于这样做，所以最好不要试图以这种方式使用它们。'
- en: 'What if we don’t need to use all of the items in the tuple? You already know
    one way to handle that. Since we can use any pattern in each position, we could
    use a declaration pattern that discards its result in, say, the second position:
    `(int x, int _)`. Or we could use a type pattern: `(int x, int)`. However, [Example 2-85](#discard_pattern)
    shows a shorter alternative: instead of a type pattern, we can use just a lone
    underscore. This is a *discard pattern*. You can use it in a recursive pattern
    anyplace a pattern is required but where you want to indicate that anything will
    do in that particular position and that you don’t need to know what it was.'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不需要使用元组中的所有项怎么办？您已经知道一种处理方法。由于我们可以在每个位置使用任何模式，我们可以使用一个声明模式，在第二个位置丢弃其结果：`(int
    x, int _)`。或者我们可以使用类型模式：`(int x, int)`。然而，[示例 2-85](#discard_pattern) 显示了一个更简短的替代方案：与其使用类型模式，我们可以只使用一个孤立的下划线。这是一个
    *丢弃模式*。您可以在需要模式但希望指示该特定位置可以使用任何内容且您不需要知道其内容的任何位置使用它。
- en: Example 2-85\. Positional pattern with discard pattern
  id: totrans-546
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-85\. 带有丢弃模式的位置模式
- en: '[PRE92]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This has subtly different semantics than the discarding declaration pattern
    or the type pattern: those patterns will check at runtime that the value to be
    discarded has the specified type, and the pattern will only match if this check
    succeeds. But a discard pattern always matches, so this would match `(10, 20)`,
    `(10, "Foo")`, and `(10, (20, 30))`, for example.'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 这与丢弃声明模式或类型模式的语义略有不同：这些模式将在运行时检查要丢弃的值是否具有指定的类型，并且仅当此检查成功时，模式才会匹配。但是丢弃模式总是匹配的，因此它将匹配
    `(10, 20)`，`(10, "Foo")` 和 `(10, (20, 30))`，例如。
- en: 'Positional patterns are not the only recursive ones: you can also write a *property
    pattern*. We’ll look at properties in detail in the next chapter, but for now
    it’s enough to know that they are members of a type that provide some sort of
    information, such as the `string` type’s `Length` property, which returns an `int`
    telling you how many code units the string contains. [Example 2-86](#property_pattern)
    shows a property pattern that inspects this `Length` property.'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 位置模式不是唯一的递归模式：您还可以编写*属性模式*。我们将在下一章详细讨论属性，但现在只需知道它们是一种类型的成员，提供某种信息，例如`string`类型的`Length`属性，返回一个`int`，告诉您字符串包含多少个代码单元。[示例 2-86](#property_pattern)显示了检查此`Length`属性的属性模式。
- en: Example 2-86\. Property pattern
  id: totrans-550
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-86\. 属性模式
- en: '[PRE93]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This property pattern starts with a type name, so it effectively incorporates
    the behavior of a type pattern in addition to its property-based tests. (You can
    omit this in cases where the type of the pattern’s input is sufficiently specific
    to identify the property. For example, if the input in this case already had a
    static of type `string`, we could omit this.) This is then followed by a section
    in braces listing each of the properties that the pattern wants to inspect and
    the pattern to apply for that property. (These child patterns are what make this
    another recursive pattern.) So this example first checks to see if the input is
    a `string`. If it is, it then applies a constant pattern to the string’s `Length`,
    so this pattern matches only if the input is a `string` with `Length` of 0.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性模式以类型名称开头，因此它有效地包含了类型模式的行为，除了其基于属性的测试之外。（在类型模式的输入类型已足够具体以识别属性的情况下，可以省略此内容。例如，在这种情况下，如果输入已经是类型为`string`的静态内容，则可以省略此内容。）然后，跟随一个花括号中的部分，列出模式想要检查的每个属性及其应用的模式。（这些子模式是使其成为另一个递归模式的内容。）因此，此示例首先检查输入是否为`string`。如果是，然后将常量模式应用于字符串的`Length`，因此仅当输入为具有长度为0的`string`时，此模式匹配。
- en: Property patterns can optionally specify an output. [Example 2-86](#property_pattern)
    doesn’t do this. [Example 2-87](#property_pattern_with_output) shows the syntax,
    although in this particular case it’s not terribly useful because this pattern
    will ensure that `s` only ever refers to an empty string.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 属性模式可以选择指定输出。[示例 2-86](#property_pattern)没有这样做。[示例 2-87](#property_pattern_with_output)显示了语法，尽管在这种特定情况下，这并不是非常有用，因为此模式将确保`s`仅指向空字符串。
- en: Example 2-87\. Property pattern with output
  id: totrans-554
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-87\. 具有输出的属性模式
- en: '[PRE94]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Since each property in a property pattern contains a nested pattern, those too
    can produce outputs, as [Example 2-88](#property_pattern_with_nested_output) shows.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 由于属性模式中的每个属性都包含一个嵌套模式，因此这些模式也可以产生输出，如[示例 2-88](#property_pattern_with_nested_output)所示。
- en: Example 2-88\. Property pattern with nested pattern with output
  id: totrans-557
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-88\. 具有输出的嵌套模式的属性模式
- en: '[PRE95]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: You can nest property patterns within property patterns. [Example 2-89](#property_pattern_within_property_pattern)
    uses this to inspect the operating system version reported by `Environment.OSVersion`,
    testing whether the major version is equal to 10.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在属性模式内嵌套属性模式。[示例 2-89](#property_pattern_within_property_pattern)使用这种方式来检查由`Environment.OSVersion`报告的操作系统版本，测试其主要版本是否等于10。
- en: Example 2-89\. Property pattern with nested property pattern
  id: totrans-560
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-89\. 具有嵌套属性模式的属性模式
- en: '[PRE96]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: C# 10.0 adds a more succinct syntax for expressing the same thing. You can replace
    the `case` in [Example 2-89](#property_pattern_within_property_pattern) with [Example 2-90](#extended_property_pattern).
    It has exactly the same effect but is a more compact, and arguably more readable,
    expression of the intent.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: C# 10.0添加了一种更简洁的语法来表达相同的内容。您可以用[示例 2-90](#extended_property_pattern)替换[示例 2-89](#property_pattern_within_property_pattern)中的`case`。它具有完全相同的效果，但是表达意图更为紧凑，且可以认为更易读。
- en: Example 2-90\. Extended property pattern
  id: totrans-563
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-90\. 扩展属性模式
- en: '[PRE97]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Combining and Negating Patterns
  id: totrans-565
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合和否定模式
- en: 'C# offers three logical operations for use in patterns: `and`, `or`, and `not`.
    The simplest of these is `not`, and it lets you invert the meaning of a pattern.
    [Example 2-91](#pattern_negation_non_null) uses this to ensure it runs certain
    code only if a variable is non-null. This applies negation (`not`) to a constant
    pattern: the `null` here is interpreted as a constant pattern. If we had written
    just `null`, the pattern would match when the value is null, but with `not null`
    the pattern matches when it is not.'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: C# 提供了三种用于模式匹配的逻辑操作：`and`（与）、`or`（或）和 `not`（非）。其中最简单的是 `not`，它可以反转模式的含义。[示例 2-91](#pattern_negation_non_null)
    使用 `not` 来确保仅在变量非空时运行特定代码。这将 `not` 应用于一个常量模式：这里的 `null` 被解释为一个常量模式。如果我们仅写 `null`，那么当值为
    null 时该模式匹配，但使用 `not null` 时，该模式在值非 null 时匹配。
- en: Example 2-91\. Detecting non-nullness with pattern negation
  id: totrans-567
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-91\. 使用模式非空检测非空性
- en: '[PRE98]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We can use `and` and `or` to combine pairs of patterns. (These are officially
    called *conjunctive* and *disjunctive* patterns; apparently the C# language designers
    are fans of formal propositional logic.) If we combine two patterns with `and`,
    the result is a pattern that matches only if both of the constituent patterns
    match. For example, if you wanted to write code that had something against my
    middle name, you could use the approach shown in [Example 2-92](#pattern_conjunction).
    This also shows that you can use a mixture of these logical operations: this uses
    both `and` and `not`.'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `and` 和 `or` 来组合两个模式。（这些被官方称为 *合取* 和 *析取* 模式；显然 C# 的语言设计者们是形式逻辑的粉丝。）如果我们使用
    `and` 来组合两个模式，结果是一个仅在两个组成模式都匹配时才匹配的模式。例如，如果你想编写代码反对我的中间名，你可以使用 [示例 2-92](#pattern_conjunction)
    中展示的方法。这也展示了你可以混合使用这些逻辑操作：它同时使用了 `and` 和 `not`。
- en: Example 2-92\. Using pattern conjunction (`and`) and negation (`not`)
  id: totrans-570
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-92\. 使用模式合取 (`and`) 和非 (`not`)
- en: '[PRE99]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: We can use `or` in a similar way, and the effect is a pattern that matches its
    input if either of its constituent patterns matches. You can build up larger combinations
    through repeated use of `and` and/or `or`.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以类似地使用 `or`，其效果是当其组成模式中任何一个匹配时，该模式匹配其输入。通过重复使用 `and` 和/或 `or` 可以构建更大的组合。
- en: Relational Patterns
  id: totrans-573
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系模式
- en: Patterns can use the `<`, `<=`, `>=`, and `>` operators when the pattern’s type
    supports these kinds of comparison. [Example 2-93](#pattern_relational) shows
    a `switch` statement that includes two *relational patterns*, as patterns based
    on these operators are called.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 当模式的类型支持比较时，模式可以使用 `<`、`<=`、`>=` 和 `>` 操作符。[示例 2-93](#pattern_relational) 展示了一个包含两个
    *关系模式* 的 `switch` 语句，这些基于这些操作符的模式称为关系模式。
- en: Example 2-93\. Relational patterns
  id: totrans-575
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-93\. 关系模式
- en: '[PRE100]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: You can use relational patterns in any position that any other pattern can be
    used. So they could appear inside a positional pattern (e.g., if you wanted to
    match points on the Y axis, above the X axis you could write `(0, > 0)`). [Example 2-94](#pattern_range)
    uses two relational patterns as the constituents of a conjunction to express the
    requirement that a value falls within a particular range.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何其他模式可以使用的位置使用关系模式。因此它们可以出现在位置模式内（例如，如果你想匹配 Y 轴上方 X 轴上的点，你可以写 `(0, > 0)`）。[示例 2-94](#pattern_range)
    使用两个关系模式作为合取的组成部分，以表达一个值在特定范围内的要求。
- en: Example 2-94\. Using relational patterns in a conjunction
  id: totrans-578
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-94\. 在合取中使用关系模式
- en: '[PRE101]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Relational patterns support comparisons only with constants. You cannot replace
    the numbers in the preceding examples with variables.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 关系模式仅支持与常量的比较。你不能用变量替换前面示例中的数字。
- en: Getting More Specific with when
  id: totrans-581
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更具体的 `when` 使用
- en: Sometimes, the built-in pattern types won’t provide the level of precision you
    need. For example, with positional patterns, we’ve seen how to write patterns
    that match, say, any pair of values, or any pair of numbers, or a pair of numbers
    where one has a particular value. But what if you want to match a pair of numbers
    where the first is higher than the second? This isn’t a big conceptual leap, but
    there’s no built-in support for this—relational patterns can’t do this because
    they can compare only with constants. We could detect the condition with an `if`
    statement of course, but it would seem a shame to have to restructure our code
    from a `switch` to a series of `if` and `else` statements just to make this small
    step forward. Fortunately we don’t have to.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，内置的模式类型不能提供您所需的精度级别。例如，使用位置模式，我们已经看到如何编写匹配任何值对、任何数字对或第一个数字具有特定值的数字对的模式。但是，如果您想匹配第一个数字大于第二个数字的数字对怎么办？这不是一个大的概念性跳跃，但是没有内置支持--关系模式无法做到这一点，因为它们只能与常量进行比较。当然，我们可以用`if`语句检测条件，但是要重构我们的代码从`switch`到一系列`if`和`else`语句似乎有点可惜，仅仅为了迈出这一小步。幸运的是，我们不必这样做。
- en: Any pattern in a `case` label can be qualified by adding a `when` clause. It
    allows a Boolean expression to be included. This will be evaluated if the value
    matches the main part of the pattern, and the value will match the pattern as
    a whole only if the `when` clause is true. [Example 2-95](#case_pattern_with_when)
    shows a positional pattern with a `when` clause that matches pairs of numbers
    in which the first number is larger than the second.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '`case`标签中的任何模式都可以通过添加`when`子句来限定。它允许包含一个布尔表达式。如果值与模式的主体部分匹配，则将评估此表达式，并且仅当`when`子句为真时，该值才会作为整体模式匹配。[示例
    2-95](#case_pattern_with_when)展示了一个带有`when`子句的位置模式，该模式匹配第一个数字大于第二个数字的对。'
- en: Example 2-95\. Pattern with `when` clause
  id: totrans-584
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-95\. 带有`when`子句的模式
- en: '[PRE102]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Patterns in Expressions
  id: totrans-586
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式中的模式
- en: 'All of the patterns I’ve shown so far appear in `case` labels as part of a
    `switch` statement. This is not the only way to use patterns. They can also appear
    inside expressions. To see how this can be useful, look first at the `switch`
    statement in [Example 2-96](#switch_with_patterns_return_value). The intent here
    is to return a single value determined by the input, but it’s a little clumsy:
    I’ve had to write four separate `return` statements to express that.'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 所有到目前为止我展示的模式都出现在`switch`语句的`case`标签中。这不是使用模式的唯一方式。它们也可以出现在表达式中。要了解这如何有用，请先看看[示例
    2-96](#switch_with_patterns_return_value)中的`switch`语句。这里的意图是返回一个由输入确定的单个值，但有点笨拙：我不得不写四个单独的`return`语句来表达这一点。
- en: Example 2-96\. Patterns, but not in expressions
  id: totrans-588
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-96\. 模式，但不在表达式中
- en: '[PRE103]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[Example 2-97](#switch_expression) shows code that performs the same job but
    rewritten to use a *switch expression*. As with a `switch` statement, a `switch`
    expression contains a list of patterns. The difference is that whereas labels
    in a `switch` statement are followed by a list of statements, in a `switch` expression
    each pattern is followed by a single expression. The value of a `switch` expression
    is the result of evaluating the expression associated with the first pattern that
    matches.'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 2-97](#switch_expression)展示了执行相同任务的代码，但重写为使用*switch表达式*。与`switch`语句一样，`switch`表达式包含一系列模式。区别在于，`switch`语句中的标签后面跟着一系列语句，而在`switch`表达式中，每个模式后面跟着一个单一表达式。`switch`表达式的值是与第一个匹配模式相关联的表达式的结果。'
- en: Example 2-97\. A `switch` expression
  id: totrans-591
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-97\. 一个`switch`表达式
- en: '[PRE104]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '`switch` expressions look quite different than `switch` statements, because
    they don’t use the `case` keyword. Instead, they just dive straight in with the
    pattern, and then use `=>` between the pattern and its corresponding expression.
    There are a few reasons for this. First, it makes `switch` expressions a bit more
    compact. Expressions are generally used inside other things—in this case, the
    `switch` expression is the value of a `return` statement, but you might also use
    these as a method argument or anywhere else an expression is allowed—so we generally
    want them to be succinct. Secondly, using `case` here could have led to confusion
    because the rules for what follows each `case` would be different for `switch`
    statements and `switch` expressions: in a `switch` statement, each `case` label
    is followed by one or more statements, but in a `switch` expression, each pattern
    needs to be followed by a single expression. Finally, although `switch` expressions
    were only added to version 8.0 of C#, this sort of construct has been around in
    other languages for many years. C#’s version of it more closely resembles equivalents
    from other languages than it would have done if the expression form used the `case`
    keyword.'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 表达式看起来与 `switch` 语句有很大不同，因为它们不使用 `case` 关键字。相反，它们直接使用模式，然后在模式和相应表达式之间使用
    `=>`。这样做有几个原因。首先，它使 `switch` 表达式更加紧凑。通常在其他东西内部使用表达式——在这种情况下，`switch` 表达式是 `return`
    语句的值，但您也可以在方法参数或任何允许表达式的地方使用它们——因此我们通常希望它们简洁明了。其次，在这里使用 `case` 可能会导致混淆，因为对于 `switch`
    语句和 `switch` 表达式，跟随每个 `case` 的规则是不同的：在 `switch` 语句中，每个 `case` 标签后面跟随一个或多个语句，但在
    `switch` 表达式中，每个模式后必须跟随一个单一的表达式。最后，尽管 `switch` 表达式是在 C# 的 8.0 版本中添加的，但这种构造形式在其他语言中已经存在多年了。C#
    的版本更接近于其他语言中的等价物，而不是使用 `case` 关键字时可能会有所不同。'
- en: Notice that the final pattern in [Example 2-97](#switch_expression) is a discard
    pattern. This will match anything, and it’s there to ensure that the pattern is
    exhaustive, i.e., that it covers all possible cases. (It has a similar effect
    to a `default` section in a `switch` statement.) Unlike a `switch` statement,
    where it’s OK for there to be no matches, a `switch` expression has to produce
    a result, so the compiler will warn you if your patterns don’t handle all possible
    cases for the input type. It would complain in this situation if we were to remove
    that final case, assuming the `shape` input is of type `object`. (Conversely,
    if `shape` were of type `(int, int)`, we would have to remove that final case,
    because the first three cases in fact cover all possible values for that type
    and the compiler will produce an error telling us that the final pattern will
    never apply.) If you ignore this warning, and then at runtime you evaluate a `switch`
    expression with an unmatchable value, it will throw a `SwitchExpressionException`.
    Exceptions are described in [Chapter 8](ch08.xhtml#ch_exceptions).
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 [示例 2-97](#switch_expression) 中，最后的模式是一个丢弃模式。它会匹配任何内容，并且用于确保模式是穷尽的，即覆盖了所有可能的情况。它与
    `switch` 语句中的 `default` 部分有类似的效果。不同于 `switch` 语句，其中无匹配是可以接受的，`switch` 表达式必须产生一个结果，因此如果您的模式不处理输入类型的所有可能情况，编译器会发出警告。如果我们移除了最后一个情况（假设
    `shape` 的类型是 `object`），在这种情况下编译器会抱怨。反之，如果 `shape` 的类型是 `(int, int)`，那么我们必须移除最后一个情况，因为前三个情况实际上覆盖了该类型的所有可能值，编译器会提示最后的模式永远不会应用。如果忽略此警告，然后在运行时评估一个
    `switch` 表达式，传入一个无法匹配的值，它将抛出 `SwitchExpressionException`。异常在 [第 8 章](ch08.xhtml#ch_exceptions)
    中有描述。
- en: There’s one more way to use a pattern in an expression, and that’s with the
    `is` keyword. It turns any pattern into a Boolean expression. [Example 2-98](#simple_is_expression)
    shows a simple example that determines whether a value is a tuple containing two
    integers.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种方法可以在表达式中使用模式，那就是使用 `is` 关键字。它将任何模式转换为布尔表达式。[示例 2-98](#simple_is_expression)
    展示了一个简单的例子，用于确定一个值是否是包含两个整数的元组。
- en: Example 2-98\. An `is` expression
  id: totrans-596
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-98\. 一个 `is` 表达式
- en: '[PRE105]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: This also provides a way to ensure that a value is non-null before proceeding.
    [Example 2-99](#test_for_non_null_with_pattern) combines a negation with a constant
    pattern testing for `null`.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 这也提供了一种在继续之前确保值非空的方法。[示例 2-99](#test_for_non_null_with_pattern) 结合了否定和常量模式测试
    `null`。
- en: Example 2-99\. Testing for non-nullness with `is`
  id: totrans-599
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-99\. 使用 `is` 进行非空性测试
- en: '[PRE106]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'You might be wondering why we wouldn’t just write `s != null`. In most cases
    that will work, but it has a potential problem: types are free to customize the
    behavior of comparison operators such as `!=`. The advantage of the approach in
    [Example 2-99](#test_for_non_null_with_pattern) is that it will invariably perform
    just a simple comparison with `null` even with types that have customized the
    behavior of `!=` and `==`. (The positive form, `is null`, has the same advantage.)'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想为什么我们不直接写`s != null`。在大多数情况下，这样做是有效的，但它存在一个潜在问题：类型可以自定义比较运算符（如`!=`）的行为。[示例
    2-99](#test_for_non_null_with_pattern)中的方法的优势在于，即使类型已经自定义了`!=`和`==`的行为，它也会始终执行与`null`的简单比较。（肯定形式`is
    null`也具有相同的优势。）
- en: As with patterns in `switch` statements or expressions, the pattern in an `is`
    expression can extract values from its source. Like [Example 2-98](#simple_is_expression),
    the pattern in [Example 2-100](#is_expression_use_values) tests whether a value
    is a tuple containing two integers but goes on to use the two values from the
    tuple.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 与`switch`语句或表达式中的模式一样，`is`表达式中的模式可以从其源中提取值。就像[示例 2-98](#simple_is_expression)中的模式一样，[示例
    2-100](#is_expression_use_values)中的模式测试一个值是否是包含两个整数的元组，但继续使用元组中的两个值。
- en: Example 2-100\. Using the values from an `is` expression’s pattern
  id: totrans-603
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-100。使用`is`表达式中的模式的值
- en: '[PRE107]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: New variables introduced in this way by an `is` expression remain in scope after
    their containing statement. So in both these examples, `x` and `y` would continue
    to be in scope until the end of the containing block. Since the pattern in [Example 2-100](#is_expression_use_values)
    is in the `if` statement’s condition expression, that means these variables remain
    in scope after the body block. However, if you try to use them outside of the
    body, you’ll find that the compiler’s definite assignment rules will tell you
    that they are uninitialized. It allows [Example 2-100](#is_expression_use_values)
    because it knows that the body of the `if` statement will run only if the pattern
    matches, so in that case `x` and `y` will have been initialized and are safe to
    use.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`is`表达式以这种方式引入的新变量在其包含语句之后仍然在作用域内。因此，在这两个示例中，`x`和`y`将一直在作用域内，直到包含块的末尾。由于[示例
    2-100](#is_expression_use_values)中的模式在`if`语句的条件表达式中，这意味着这些变量在主体块之后仍然在作用域内。然而，如果您尝试在主体之外使用它们，您会发现编译器的明确赋值规则会告诉您它们未初始化。它允许[示例
    2-100](#is_expression_use_values)，因为它知道`if`语句的主体只有在模式匹配时才会运行，因此在这种情况下，`x`和`y`将已经初始化并且可以安全使用。
- en: 'Patterns in `is` expressions cannot include a `when` clause. It would be redundant:
    the result is a Boolean expression, so you can just add on any qualification you
    require using the normal Boolean operators, as [Example 2-101](#qualifying_an_is_expression)
    shows.'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '`is`表达式中的模式不能包含`when`子句。这是多余的：结果是一个布尔表达式，因此您可以使用正常的布尔运算符添加任何所需的限定条件，就像[示例 2-101](#qualifying_an_is_expression)所示。'
- en: Example 2-101\. No need for `when` in an `is` expression’s pattern
  id: totrans-607
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-101。`is`表达式中的模式不需要`when`
- en: '[PRE108]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Summary
  id: totrans-609
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, I showed the nuts and bolts of C# code—variables, statements,
    expressions, basic data types, operators, flow control, and patterns. Now it’s
    time to take a look at the broader structure of a program. All code in C# programs
    must belong to a type, and types are the topic of the next chapter.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我展示了C#代码的基本要素——变量、语句、表达式、基本数据类型、运算符、流控制和模式。现在是时候看看程序的更广泛结构了。C#程序中的所有代码必须属于一个类型，而类型将是下一章的主题。
- en: '^([1](ch02.xhtml#fn05-marker)) C# does in fact offer dynamic typing as an option
    with its `dynamic` keyword, but it takes the slightly unusual step of fitting
    that into a statically typed point of view: dynamic variables have a static type
    of `dynamic`.'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.xhtml#fn05-marker)) C#确实提供了动态类型作为一个选项，使用`dynamic`关键字，但它采取了一个略微不同寻常的步骤，将其纳入静态类型的观点中：动态变量的静态类型为`dynamic`。
- en: ^([2](ch02.xhtml#fn06-marker)) See Alan Turing’s seminal work on computation
    for details. Charles Petzold’s *The Annotated Turing* (John Wiley & Sons) is an
    excellent guide to the relevant paper.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch02.xhtml#fn06-marker)) 有关计算的详细信息，请参阅艾伦·图灵的开创性工作。查尔斯·佩兹尔德的《图灵注释》（约翰·威利和儿子）是相关论文的优秀指南。
- en: ^([3](ch02.xhtml#idm45884862601824-marker)) If you’re new to C-family languages,
    the `+=` operator may be unfamiliar. It is a *compound assignment* operator, described
    later in this chapter. I’m using it here to increase `errorCount` by one.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch02.xhtml#idm45884862601824-marker)) 如果您对C系列语言不熟悉，`+=`运算符可能会让您感到陌生。它是一个*复合赋值*运算符，在本章后面进行了描述。我在这里使用它来将`errorCount`增加一。
- en: ^([4](ch02.xhtml#fn07-marker)) In the absence of parentheses, C# has rules of
    *precedence* that determine the order in which operators are evaluated. For the
    full (and not very interesting) details, consult the documentation. In this example,
    because division has higher precedence than addition, without parentheses the
    expression would evaluate to 14.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch02.xhtml#fn07-marker)) 在没有括号的情况下，C# 有 *优先级* 规则来确定操作符的求值顺序。有关完整且不是很有趣的细节，请参阅文档。在这个例子中，因为除法比加法具有更高的优先级，所以在没有括号的情况下，表达式将求值为
    14。
- en: ^([5](ch02.xhtml#fn08-marker)) Strictly speaking, this is guaranteed only for
    correctly aligned 32-bit types. However, C# aligns them correctly by default,
    and you’d normally encounter misaligned data only if your code needs to call out
    into unmanaged code.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch02.xhtml#fn08-marker)) 严格来说，这仅对正确对齐的 32 位类型保证。然而，C# 默认正确对齐它们，只有当你的代码需要调用非托管代码时，你才会遇到数据错位的情况。
- en: ^([6](ch02.xhtml#fn10-marker)) A decimal, therefore, doesn’t use all of its
    128 bits. Making it smaller would cause alignment difficulties, and using the
    additional bits for extra precision would have a significant performance impact,
    because integers whose length is a multiple of 32 bits are easier for most CPUs
    to deal with than the alternatives.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch02.xhtml#fn10-marker)) 因此，十进制数并没有使用其全部的 128 位。如果使其更小会导致对齐困难，而将额外的位用于提高精度则会对性能产生显著影响，因为长度是
    32 位的整数对大多数 CPU 来说更容易处理。
- en: '^([7](ch02.xhtml#fn11-marker)) Promotions are not in fact a feature of C#.
    There is a more general mechanism: conversion operators. C# defines intrinsic
    implicit conversion operators for the built-in data types. The promotions discussed
    here occur as a result of the compiler following its usual rules for conversions.'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch02.xhtml#fn11-marker)) 升级实际上并不是 C# 的一个特性。有一个更通用的机制：转换操作符。C# 为内置数据类型定义了内置的隐式转换操作符。这里讨论的升级是由编译器根据其通常的转换规则而发生的。
- en: ^([8](ch02.xhtml#fn12-marker)) A *property* is a member of a type that represents
    a value that can be read or modified or both. [Chapter 3](ch03.xhtml#ch_types)
    describes properties in detail.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch02.xhtml#fn12-marker)) *属性* 是类型的成员，代表可以读取或修改或两者都可以的值。[第 3 章](ch03.xhtml#ch_types)
    详细描述了属性。
- en: ^([9](ch02.xhtml#fn13-marker)) There are some specialized exceptions, such as
    pointer types.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch02.xhtml#fn13-marker)) 存在一些特殊的例外情况，比如指针类型。
- en: ^([10](ch02.xhtml#fn14-marker)) Language pedants will note that it will also
    be meaningful in certain situations where custom implicit conversions to `bool`
    are available. We’ll get to custom conversions in [Chapter 3](ch03.xhtml#ch_types).
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch02.xhtml#fn14-marker)) 语言专家会注意到，在存在自定义的隐式转换到 `bool` 的情况下，它在某些情况下也会有意义。我们将在
    [第 3 章](ch03.xhtml#ch_types) 中讨论自定义转换。
- en: ^([11](ch02.xhtml#fn15-marker)) A `continue` statement complicates matters,
    because it provides a way to move to the next iteration without getting all the
    way to the end of the loop body. Even so, you could still reproduce the effect
    of the iterator when using `continue` statements—it would just require more work.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: ^([11](ch02.xhtml#fn15-marker)) `continue` 语句使事情变得复杂，因为它提供了一种在不完全执行循环体的情况下进入下一次迭代的方式。即使如此，在使用
    `continue` 语句时也可以复制迭代器的效果，只是需要更多的工作。
