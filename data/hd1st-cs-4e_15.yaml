- en: 'Chapter 10\. Reading and writing files: *Save the last byte for me!*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。读写文件：*为我保存最后一个字节！*
- en: '![Images](assets/pg529.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg529.png)'
- en: '**Sometimes it pays to be a little persistent.**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**有时坚持一下是值得的。**'
- en: So far, all of your programs have been pretty short-lived. They fire up, run
    for a while, and shut down. But that’s not always enough, especially when you’re
    dealing with important information. You need to be able to **save your work**.
    In this chapter, we’ll look at how to **write data to a file**, and then how to
    **read that information back in** from a file. You’ll learn about **streams**,
    and how to store your objects in files with **serialization**, and get down to
    the actual bits and bytes of **hexadecimal**, **Unicode**, and **binary data**
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您所有的程序都相当短暂。它们启动，运行一段时间，然后关闭。但这通常不够，特别是当您处理重要信息时。您需要能够**保存您的工作**。在本章中，我们将学习如何**将数据写入文件**，然后如何从文件中**读取这些信息**。您将了解**流**的概念，以及如何使用**序列化**将对象存储到文件中，深入探讨**十六进制**、**Unicode**和**二进制数据**的实际比特和字节。
- en: .NET uses streams to read and write data
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET 使用流来读取和写入数据。
- en: A **stream** is the .NET Framework’s way of getting data into and out of your
    program. Any time your program reads or writes a file, connects to another computer
    over a network, or generally does anything where it **sends or receives bytes**,
    you’re using streams. Sometimes you’re using streams directly , other times indirectly.
    Even when you’re using classes that don’t directly expose streams, under the hood
    they’re almost always using streams.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**流**是 .NET Framework 用来将数据输入和输出到程序的方式。每当您的程序读取或写入文件、通过网络连接到另一台计算机，或者通常做任何需要**发送或接收字节**的操作时，您都在使用流。有时您会直接使用流，有时间接使用。即使在使用不直接暴露流的类时，在幕后它们几乎总是在使用流。'
- en: '**Whenever you want to read data from a file or write data to a file, you’ll
    use a Stream object.**'
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**每当您需要从文件读取数据或向文件写入数据时，都会使用一个 Stream 对象。**'
- en: Note
  id: totrans-7
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Let’s say you have a simple app that needs to read data from a file. A really
    basic way to do that is to use a `Stream` object.**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**假设您有一个简单的应用程序需要从文件中读取数据。最基本的方法之一是使用 `Stream` 对象。**'
- en: '![Images](assets/pg530-1.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg530-1.png)'
- en: Note
  id: totrans-10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**And if your app needs to write data out to the file, it can use another `Stream`
    object.**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果您的应用程序需要将数据写入文件，则可以使用另一个 `Stream` 对象。**'
- en: '![Images](assets/pg530-2.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg530-2.png)'
- en: Different streams read and write different things
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的流读取和写入不同的内容。
- en: Every stream is a subclass of the **abstract Stream class**, and there are many
    subclasses of Stream that do different things. We’ll be concentrating on reading
    and writing regular files, but everything you learn about streams in this chapter
    can apply to compressed or encrypted files, or network streams that don’t use
    files at all.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每个流都是**抽象 Stream 类**的子类，有许多不同的流子类执行不同的功能。我们将集中讨论读写常规文件，但是在本章中学到的有关流的知识也可以应用于压缩或加密文件，或者根本不使用文件的网络流。
- en: '![Images](assets/pg531.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg531.png)'
- en: 'Things you can do with a stream:'
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流可执行的操作：
- en: '**Write to the stream.**'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**向流中写入数据。**'
- en: You can write your data to a stream through a stream’s **Write method.**
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以通过流的**Write方法**将数据写入流中。
- en: '**Read from the stream.**'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从流中读取数据。**'
- en: You can use the **Read method** to get data from a file, or a network, or memory,
    or just about anything else using a stream. You can even read data from ***really
    big*** files, even if they’re too big to fit into memory.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以使用**Read方法**从文件、网络、内存或几乎任何其他位置使用流获取数据。即使是***非常大***的文件，即使它们太大而无法放入内存中，您也可以使用流读取数据。
- en: '**Change your position within the stream.**'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在流中更改位置。**'
- en: Most streams support a `**Seek method**` that lets you find a position within
    the stream so you can read or insert data at a specific place. However, not every
    Stream class supports Seek—which makes sense, because you can’t always backtrack
    in some sources of streaming data.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 大多数流支持`**Seek方法**`，允许您在流中找到位置，以便在特定位置读取或插入数据。然而，并非每个 Stream 类都支持 Seek，这是有道理的，因为在某些流数据源中无法回溯。
- en: '**Streams let you read and write data. Use the right kind of stream for the
    data you’re working with.**'
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**流允许您读取和写入数据。根据您处理的数据类型选择适当的流类型。**'
- en: A FileStream reads and writes bytes in a file
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FileStream 在文件中读取和写入字节。
- en: 'When your program needs to write a few lines of text to a file, there are a
    lot of things that have to happen:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序需要向文件写入几行文本时，需要执行很多操作：
- en: Create a new FileStream object and tell it to write to the file.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 FileStream 对象，并告诉它写入文件。
- en: '![Images](assets/pg532-1.png)'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg532-1.png)'
- en: The FileStream attaches itself to a file.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FileStream 会连接到一个文件。
- en: '![Images](assets/pg532-2.png)'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg532-2.png)'
- en: Streams write bytes to files, so you’ll need to convert the string that you
    want to write to an array of bytes.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 流将字节写入文件，所以你需要将要写入的字符串转换为字节数组。
- en: '![Images](assets/pg532-3.png)'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg532-3.png)'
- en: Call the stream’s Write method and pass it the byte array.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用流的 Write 方法并传递字节数组。
- en: '![Images](assets/pg532-4.png)'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg532-4.png)'
- en: Close the stream so other programs can access the file.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭流以便其他程序能够访问文件。
- en: '![Images](assets/pg532-5.png)'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg532-5.png)'
- en: Write text to a file in three simple steps
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在三个简单步骤中向文件写入文本
- en: C# comes with a convenient class called **StreamWriter** that simplifies those
    things for you. All you have to do is create a new StreamWriter object and give
    it a filename. It ***automatically*** creates a FileStream and opens the file.
    Then you can use the StreamWriter’s Write and WriteLine methods to write everything
    to the file you want.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: C# 提供了一个方便的类叫做**StreamWriter**，它为你简化了这些操作。你只需要创建一个新的 StreamWriter 对象并给它一个文件名。它会***自动***创建一个
    FileStream 并打开文件。然后你可以使用 StreamWriter 的 Write 和 WriteLine 方法将所有内容写入你想要的文件中。
- en: '**StreamWriter creates and manages a FileStream object for you automatically.**'
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**StreamWriter 会为你自动创建和管理一个 FileStream 对象。**'
- en: '**Use the StreamWriter’s constructor to open or create a file.**'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用 StreamWriter 的构造函数来打开或创建文件。**'
- en: 'You can pass a filename to the StreamWriter’s constructor. When you do, the
    writer automatically opens the file. StreamWriter also has an overloaded constructor
    that lets you specify its *append* mode: passing it `true` tells it to add data
    to the end of an existing file (or append), while `false` tells the stream to
    delete the existing file and create a new file with the same name.'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以将文件名传递给 StreamWriter 的构造函数。这样做时，写入器会自动打开文件。StreamWriter 还有一个重载的构造函数，可以让你指定它的*追加*模式：传递`true`告诉它将数据添加到现有文件的末尾（或追加），传递`false`告诉流删除现有文件并创建一个同名的新文件。
- en: '[PRE0]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Images](assets/pg533-1.png)'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg533-1.png)'
- en: '**Use the Write and WriteLine methods to write to the file.**'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用 Write 和 WriteLine 方法来写入文件。**'
- en: 'These methods work just like the ones in the Console class: Write writes text,
    and WriteLine writes text and adds a line break to the end.'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些方法的工作方式与控制台类似：Write 写入文本，WriteLine 写入文本并在末尾添加换行。
- en: '[PRE1]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![Images](assets/pg533-2.png)'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg533-2.png)'
- en: '**Call the Close method to release the file.**'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**调用 Close 方法释放文件。**'
- en: If you leave the stream open and attached to a file, then it’ll keep the file
    locked and no other program will be able to use it. So make sure you always close
    your files!
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你保持流处于打开状态并连接到一个文件中，那么它会锁定该文件，其他程序将无法使用它。所以一定要确保始终关闭你的文件！
- en: '[PRE2]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The Swindler launches another diabolical plan
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 骗子启动了另一个毒计划
- en: 'The citizens of Objectville have long lived in fear of the Swindler, Captain
    Amazing’s archnemesis. Now he’s using a StreamWriter to implement another evil
    plan. Let’s take a look at what’s going on. Create a new Console App project and
    **add this Main code**, starting with a `using` declaration because StreamWriter
    is in the **System.IO namespace**:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Objectville 的居民长久以来一直生活在对奇才队长的宿敌骗子的恐惧中。现在他正在使用 StreamWriter 实施另一个邪恶计划。让我们看看发生了什么。创建一个新的控制台应用项目并**添加此
    Main 代码**，从一个 `using` 声明开始，因为 StreamWriter 在**System.IO 命名空间**中：
- en: Note
  id: totrans-52
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**StreamWriter’s Write and WriteLine methods work just like Console’s: Write
    writes text, and WriteLine writes text with a line break. Both classes support
    {curly brackets} like this:**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**StreamWriter 的 Write 和 WriteLine 方法的工作方式与控制台的类似：Write 写入文本，WriteLine 写入文本并换行。这两个类都支持像这样的
    {花括号}。**'
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**When you include {0} in the text, it’s replaced by the first parameter after
    the string; {1} is replaced by the second, {2} by the third, etc.**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**当你在文本中包含 {0} 时，它会被字符串后的第一个参数替换；{1} 被第二个参数替换，{2} 被第三个参数替换，依此类推。**'
- en: '![Images](assets/pg534-1.png)![Images](assets/pg534-2.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg534-1.png)![图片](assets/pg534-2.png)'
- en: Note
  id: totrans-57
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The Swindler is Captain Amazing’s arch-nemesis, a shadowy supervillain bent
    on the domination of Objectville.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 骗子是奇才队长的宿敌，一个阴影般的超级恶棍，企图统治 Objectville。
- en: '![Images](assets/pg534-3.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg534-3.png)'
- en: 'Here’s the output that it writes to *secret_plan.txt*:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它写入到 *secret_plan.txt* 中的输出：
- en: '**Output**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: StreamWriter Magnets
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: StreamWriter 磁铁
- en: '![Images](assets/pg535a.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg535a.png)'
- en: Oops! These magnets were nicely arranged on the fridge with the code for the
    Flobbo class, but someone slammed the door and they all fell off. Can you rearrange
    them so the Main method produces the output below?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕！这些磁铁原本很好地排列在冰箱上，用于Flobbo类的代码，但有人猛地关上了门，它们全部掉了下来。你能重新排列它们，使得Main方法产生下面的输出吗？
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**We added an extra challenge.**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们增加了一个额外的挑战。**'
- en: Something weird is going on with the Blobbo method. See how it has two different
    declarations in the first two magnets? We defined Blobbo as an **overloaded method**—there
    are two different versions, each with its own parameters, just like the **overloaded
    methods** you’ve used in previous chapters.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Blobbo方法似乎有些奇怪。看看它在前两个磁铁中有两个不同的声明？我们定义Blobbo作为**重载方法**——就像你在前几章中使用的重载方法一样，每个都有自己的参数。
- en: '![Images](assets/pg535.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/pg535.png)'
- en: StreamWriter Magnets Solution
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: StreamWriter磁铁解决方案
- en: '![Images](assets/pg535a.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/pg535a.png)'
- en: Your job was to construct the Flobbo class from the magnets to create the desired
    output.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务是从磁铁中构建Flobbo类，以创建所需的输出。
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![Images](assets/pg536.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/pg536.png)'
- en: Note
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Just a reminder: we picked intentionally weird variable names and methods
    in these puzzles because if we used really good names, the puzzles would be too
    easy! Don’t use names like this in your code, OK?**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**只是提醒：我们在这些谜题中故意选择了奇怪的变量名和方法，因为如果我们使用真正好的名字，那么这些谜题就太容易了！在你的代码中不要使用这样的名字，好吗？**'
- en: Use a StreamReader to read a file
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用StreamReader来读取文件
- en: 'Let’s read the Swindler’s secret plans with **StreamReader**, a class that’s
    a lot like StreamWriter—except instead of writing a file, you create a StreamReader
    and pass it the name of the file to read in its constructor. Its ReadLine method
    returns a string that contains the next line from the file. You can write a loop
    that reads lines from it until its EndOfStream field is true—that’s when it runs
    out of lines to read. Add this console app that uses a StreamReader to read one
    file, and a StreamWriter to write another file:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用**StreamReader**来阅读骗子的秘密计划，这个类很像StreamWriter——不过不是写文件，而是在构造函数中创建一个StreamReader，并传递文件名。它的ReadLine方法返回一个包含文件中下一行的字符串。你可以编写一个循环，从中读取行，直到其EndOfStream字段为true——那时就读完了所有行。添加这个控制台应用程序，使用StreamReader来读取一个文件，同时使用StreamWriter来写入另一个文件：
- en: Note
  id: totrans-79
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**StreamReader is a class that reads characters from streams, but it’s not
    a stream itself. When you pass a filename to its constructor, it creates a stream
    for you, and closes it when you call its Close method. It also has an overloaded
    constructor that takes a reference to a Stream.**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**StreamReader是一个从流中读取字符的类，但它本身不是流。当你将文件名传递给它的构造函数时，它会为你创建一个流，并在调用其Close方法时关闭它。它还有一个重载的构造函数，它接受一个流的引用。**'
- en: '![Images](assets/pg537.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/pg537.png)'
- en: Note
  id: totrans-82
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Output**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Data can go through more than one stream
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据可以通过多个流传输
- en: 'One big advantage to working with streams in .NET is that you can have your
    data go through more than one stream on its way to its final destination. One
    of the many types of streams in .NET Core is the CryptoStream class. This lets
    you encrypt your data before you do anything else with it. So instead of writing
    plain text to a regular old text file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中使用流的一个巨大优势是，你可以让数据通过多个流传输到最终目的地。在.NET Core中的众多流类型之一是CryptoStream类。这允许你在做任何其他操作之前对数据进行加密。所以，不是将纯文本写入普通的文本文件：
- en: '![Images](assets/pg538-1.png)![Images](assets/pg538-2.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/pg538-1.png)![图像](assets/pg538-2.png)'
- en: 'the Swindler can **chain streams together** and send the text through a CryptoStream
    object before writing its output to a FileStream:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 骗子可以**链接多个流**，并在将文本通过CryptoStream对象写入其输出之前通过它加密：
- en: '![Images](assets/pg538-3.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/pg538-3.png)'
- en: '**You can CHAIN streams. One stream can write to another stream, which writes
    to another stream...often ending with a network or file stream.**'
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**你可以链接流。一个流可以写入另一个流，后者可以写入另一个流...最终通常以网络或文件流结束。**'
- en: Pool Puzzle
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 水池拼图
- en: '![Images](assets/pg539-1.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/pg539-1.png)'
- en: Your ***job*** is to take code snippets from the pool and place them into the
    blank lines in the Pineapple, Pizza, and Party classes. You can use the same snippet
    more than once, and you won’t need to use all the snippets. Your ***goal*** is
    to make the program write a file called *order.txt* with the five lines listed
    in the output box below.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你的***任务***是从池中的代码片段中选取并将它们放入 Pineapple、Pizza 和 Party 类的空白行中。你可以多次使用同一段代码片段，而且不需要使用所有的片段。你的***目标***是使程序将五行内容写入名为
    *order.txt* 的文件中，如输出框中所示。
- en: '![Images](assets/pg539-2.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/pg539-2.png)'
- en: Pool Puzzle Solution
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 池子谜题解决方案
- en: '![Images](assets/pg540.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/pg540.png)'
- en: Use the static File and Directory classes to work with files and directories
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用静态的 File 和 Directory 类来处理文件和目录。
- en: Like StreamWriter, the File class creates streams that let you work with files
    behind the scenes. You can use its methods to do most common actions without having
    to create the FileStreams first. The Directory class lets you work with whole
    directories full of files.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 StreamWriter，File 类创建的流使你能够在后台处理文件。你可以使用它的方法来执行大多数常见操作，而不必首先创建 FileStreams。Directory
    类允许你处理整个目录中的文件。
- en: 'Things you can do with the static File class:'
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用静态的 File 类可以做的事情：
- en: '**Find out if the file exists.**'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**查找文件是否存在。**'
- en: You can check to see if a file exists using the File.Exists method. It’ll return
    true if it does, and false if it doesn’t.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以使用 File.Exists 方法来检查文件是否存在。如果存在，则返回 true；否则返回 false。
- en: '**Read from and write to the file.**'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从文件中读取和写入。**'
- en: You can use the File.OpenRead method to get data from a file, or the File.Create
    or File.OpenWrite method to write to the file.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以使用 File.OpenRead 方法从文件获取数据，或者使用 File.Create 或 File.OpenWrite 方法向文件写入数据。
- en: '**Append text to the file.**'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**向文件追加文本。**'
- en: The File.AppendAllText method lets you append text to an already created file.
    It even creates the file if it’s not there when the method runs.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: File.AppendAllText 方法允许你向已创建的文件追加文本。即使在方法运行时文件不存在，它也会创建该文件。
- en: '**Get information about the file.**'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**获取文件的信息。**'
- en: The File.GetLastAccessTime and File.GetLastWriteTime methods return the date
    and time when the file was last accessed and modified.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: File.GetLastAccessTime 和 File.GetLastWriteTime 方法返回文件上次访问和修改的日期和时间。
- en: '![Images](assets/pg542.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/pg542.png)'
- en: 'Things you can do with the static Directory class:'
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用静态的 Directory 类可以做的事情：
- en: '**Create a new directory.**'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个新目录。**'
- en: Create a directory using the Directory.CreateDirectory method. All you have
    to do is supply the path; this method does the rest.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 Directory.CreateDirectory 方法创建一个目录。你只需提供路径即可，此方法会完成其余工作。
- en: '**Get a list of the files in a directory.**'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**获取目录中文件的列表。**'
- en: You can create an array of files in a directory using the Directory.GetFiles
    method; just tell the method which directory you want to know about, and it will
    do the rest.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以使用 Directory.GetFiles 方法创建一个目录中文件的数组；只需告诉方法你想知道哪个目录，它会完成其余工作。
- en: '**Delete a directory.**'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**删除一个目录。**'
- en: Need to delete a directory? Call the Directory.Delete method.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 需要删除一个目录吗？调用 Directory.Delete 方法。
- en: IDisposable makes sure objects are closed properly
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDisposable 确保对象被正确关闭
- en: 'A lot of .NET classes implement a particularly useful interface called IDisposable.
    It **has only one member**: a method called Dispose. Whenever a class implements
    IDisposable, it’s telling you that there are important things that it needs to
    do in order to shut itself down, usually because it’s **allocated resources**
    that it won’t give back until you tell it to. The Dispose method is how you tell
    the object to release those resources.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 很多 .NET 类实现了一个非常有用的接口叫做 IDisposable。它**只有一个成员**：一个叫做 Dispose 的方法。每当一个类实现 IDisposable，它告诉你有一些重要的事情需要它自己关闭，通常是因为它**分配了资源**，直到你告诉它放弃这些资源为止。Dispose
    方法就是告诉对象释放这些资源的方式。
- en: Use the IDE to explore IDisposable
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 IDE 探索 IDisposable
- en: 'You can use the Go To Definition feature in the IDE (or “Go to Declaration”
    on a Mac) to see the definition of IDisposable. Go to your project and type `IDisposable`
    anywhere inside a class. Then right-click on it and select Go To Definition from
    the menu. It’ll open a new tab with code in it. Expand all of the code and this
    is what you’ll see:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 IDE 中使用“Go To Definition”功能（Mac 上称为“Go to Declaration”）来查看 IDisposable
    的定义。转到项目中的类并在其中的任何位置键入 `IDisposable`。然后右键单击它，并从菜单中选择“Go To Definition”。它会在新的标签页中打开代码。展开所有代码，你将看到以下内容：
- en: '![Images](assets/pg545.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/pg545.png)'
- en: Avoid filesystem errors with using statements
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用语句避免文件系统错误
- en: 'Throughout the chapter we’ve been stressing that you need to **close your streams**.
    That’s because some of the most common bugs that programmers run across when they
    deal with files are caused when streams aren’t closed properly. Luckily, C# gives
    you a great tool to make sure that never happens to you: IDisposable and the Dispose
    method. When you **wrap your stream code in a `using` statement**, it automatically
    closes your streams for you. All you need to do is **declare your stream reference**
    with a `using` statement, followed by a block of code (inside curly brackets)
    that uses that reference. When you do that, C# **automatically calls the Dispose
    method** as soon as it finishes running the block of code.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在整章中，我们一直强调需要**关闭你的流**。这是因为当程序员处理文件时，一些最常见的bug是由于流未正确关闭而引起的。幸运的是，C#为你提供了一个很好的工具来确保这种情况永远不会发生：IDisposable和Dispose方法。当你**在`using`语句中包装你的流代码**时，它会自动为你关闭流。你只需用`using`语句声明你的流引用，后面跟着一个使用该引用的代码块（在花括号内）。这样做时，C#会在代码块运行完毕后**自动调用Dispose方法**。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: These “using” statements are different from the ones at the top of your code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这些“using”语句与你代码顶部的不同。
- en: '![Images](assets/pg546.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg546.png)'
- en: Note
  id: totrans-126
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**This `using` statement declares a variable `sw` that references a new StreamWriter
    and is followed by a block of code. After all of the statements in the block are
    executed, the using block will automatically call sw.Dispose.**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**这个`using`语句声明了一个变量`sw`，它引用一个新的StreamWriter，并后面跟着一个代码块。在代码块中的所有语句执行完毕后，using块会自动调用sw.Dispose。**'
- en: Use multiple using statements for multiple objects
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对多个对象使用多个using语句
- en: 'You can pile `using` statements on top of each other—you don’t need extra sets
    of curly brackets or indents:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`using`语句堆叠在一起，不需要额外的花括号或缩进：
- en: '[PRE8]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-131
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Every stream has a Dispose method that closes the stream. When you declare
    your stream in a `using` statement, it will always get closed! And that’s important,
    because some streams *don’t write* all of their data *until they’re closed.***'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**每个流都有一个Dispose方法来关闭流。当你在using语句中声明你的流时，它总是会被关闭！这很重要，因为一些流*直到关闭时*才会写入它们的所有数据。**'
- en: '**When you declare an object in a using block, that object’s Dispose method
    is called automatically.**'
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**当你在using块中声明一个对象时，该对象的Dispose方法会被自动调用。**'
- en: Use a MemoryStream to stream data to memory
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MemoryStream将数据流向内存
- en: We’ve been using streams to read and write files. What if you want to read data
    from a file and then, well, do something with it? You can use a **MemoryStream**,
    which keeps track of all data streamed to it by storing it in memory. For example,
    you can create a new MemoryStream and pass it as an argument to a StreamWriter
    constructor, and then any data you write with the StreamWriter will be sent to
    that MemoryStream. You can retrieve that data using the **MemoryStream.ToArray
    method**, which returns all of the data that’s been streamed to it in a byte array.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用流来读取和写入文件。如果你想从文件中读取数据，然后做些什么呢？你可以使用**MemoryStream**，它通过在内存中存储数据来跟踪所有流向它的数据。例如，你可以创建一个新的MemoryStream，并将其作为参数传递给StreamWriter的构造函数，然后使用StreamWriter写入的任何数据都会发送到该MemoryStream。你可以使用**MemoryStream.ToArray方法**检索这些数据，它会以字节数组的形式返回所有已经流向它的数据。
- en: Use Encoding.UTF8.GetString to convert byte arrays to strings
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Encoding.UTF8.GetString将字节数组转换为字符串
- en: 'One of the most common things that you’ll do with byte arrays is convert them
    to strings. For example, if you have a byte array called bytes, here’s one way
    to convert it to a string:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字节数组，你最常见的操作之一就是将它们转换为字符串。例如，如果你有一个名为bytes的字节数组，这是一种转换为字符串的方法：
- en: '![Images](assets/pg547-1.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg547-1.png)'
- en: Here’s a small console app that uses composite formatting to write a number
    to a MemoryStream, and then convert it to a byte array and then to a string. Just
    one problem... ***it doesn’t work!***
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个小型控制台应用程序，它使用复合格式化将数字写入MemoryStream，然后将其转换为字节数组，最后转换为字符串。只有一个问题…… ***它不起作用！***
- en: '**Create a new console app** and add this code to it. Can you sleuth out the
    problem and fix it?'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建一个新的控制台应用程序**，并将此代码添加到其中。你能找出问题并修复它吗？'
- en: '***Do this!***'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '***一定要这样做！***'
- en: '![Images](assets/pg547-2.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg547-2.png)'
- en: Note
  id: totrans-143
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**This app doesn’t work! When you run it, it ’s supposed to write a line of
    text to the console, but it doesn’t write anything at all. We’ll explain what’s
    wrong, but before we do first see if you can sleuth it out on your own.**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**这个应用程序无法工作！当你运行它时，它应该向控制台写入一行文本，但实际上什么都没写。我们会解释出了什么问题，但在我们解释之前，先看看你能不能自己找到答案。**'
- en: '***Here’s a hint: can you figure out when the streams are closed?***'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '***这里有一个提示：你能找出流何时关闭吗？***'
- en: '**Q: Remind me why you put an @ in front of the strings that contained filenames
    in that “Sharpen your pencil” exercise?**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q:** 为什么在“磨砺你的铅笔”练习中的文件名字符串前面要加上@符号？'
- en: '**A:** Because if we didn’t, the \S in “C:\SYP” would be interpreted as an
    invalid escape sequence and throw an exception. When you add a string literal
    to your program, the compiler converts escape sequences like `\n` and `\r` to
    special characters. Windows filenames have backslash characters in them, but C#
    strings normally use backslashes to start escape sequences. If you put @ in front
    of a string, it tells C# not to interpret escape sequences. It also tells C# to
    include line breaks in your string, so you can hit Enter halfway through the string
    and it’ll include that as a line break in the output.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**A:** 因为如果我们不这样做，字符串“C:\\SYP”中的\S将被解释为无效的转义序列并抛出异常。当你向程序添加一个字符串文字时，编译器会将像\n和\r这样的转义序列转换为特殊字符。Windows文件名中包含反斜杠字符，但C#字符串通常使用反斜杠来开始转义序列。如果在字符串前面加上@，它告诉C#不要解释转义序列。它还告诉C#包含换行符在你的字符串中，所以你可以在字符串中间按Enter键，它会把那部分作为换行符包含在输出中。'
- en: '**Q: And what exactly are escape sequences?**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q:** 那么转义序列到底是什么？'
- en: '**A:** An escape sequence is a way to include special characters in your strings.
    For example, `\n` is a line feed, `\t` is a tab, and `\r` is a return character,
    or half of a Windows return (in Windows text files, lines have to end with `\r\n`;
    for macOS and Linux, lines just end in `\n`). If you need to include a quotation
    mark inside a string, you can use `\"` and it won’t end the string. If you want
    to use an actual backslash in your string and not have C# interpret it as the
    beginning of an escape sequence, just do a double backslash: `\\`.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**A:** 转义序列是一种在字符串中包含特殊字符的方法。例如，\n是换行符，\t是制表符，\r是回车符，或者说是Windows回车的一半（在Windows文本文件中，行必须以\r\n结束；对于macOS和Linux，行只需以\n结束）。如果需要在字符串中包含引号，可以使用\"，它不会结束字符串。如果要在字符串中使用实际的反斜杠而不让C#解释它作为转义序列的开头，只需使用两个反斜杠：\\。'
- en: Note
  id: totrans-150
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We gave you a chance to sleuth this problem out on your own. Here’s how we fixed
    it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给了你一个机会自己解决这个问题。这是我们是如何修复它的。
- en: '![Images](assets/pg552.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg552.png)'
- en: '**There’s an easier way to store your objects in files. It’s called serialization.**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**存储对象到文件中有一种更简单的方法。它叫做序列化。**'
- en: '**Serialization** means writing an object’s entire state to a file or string.
    **Deserialization** means reading the object’s state back from that file or string.
    So instead of painstakingly writing out each field and value to a file line by
    line, you can save your object the easy way by serializing it out to a stream.
    ***Serializing*** an object is like **flattening it out** so you can slip it into
    a file. On the other end, ***deserializing*** an object is like taking it out
    of the file and **inflating** it again.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**序列化**意味着将对象的整个状态写入到文件或字符串中。**反序列化**意味着从该文件或字符串中读取对象的状态。因此，不必一行一行地费力写出每个字段和值到文件中，你可以通过将对象序列化到流中来轻松地保存对象。***序列化***对象就像**将其展平**，以便你可以将其放入文件中。另一方面，***反序列化***对象就像将其从文件中取出并**膨胀**一样。'
- en: Note
  id: totrans-155
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'OK, just to come clean here: there’s also a method called Enum.Parse that will
    convert the string “Spades” to the enum value Suits.Spades. It even has a companion,
    Enum.TryParse, that works just like the int. TryParse method you’ve used throughout
    this book. But serialization still makes a lot more sense here. You’ll find out
    more about that shortly...'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，坦白说：还有一个名为Enum.Parse的方法，它将字符串“Spades”转换为枚举值Suits.Spades。它甚至有一个伴侣方法Enum.TryParse，它的工作方式就像你在本书中一直使用的int.TryParse方法一样。但是在这里序列化更加合理。你很快就会了解更多...
- en: What happens to an object when it’s serialized?
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当对象被序列化时会发生什么？
- en: It seems like something mysterious has to happen to an object in order to copy
    it off of the heap and put it into a file, but it’s actually pretty straightforward.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来似乎要对一个对象进行某种神秘的操作，才能将其从堆中复制到文件中，但实际上这并不复杂。
- en: '**Object on the heap**'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**堆上的对象**'
- en: '![Images](assets/pg553-1.png)'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg553-1.png)'
- en: When you create an instance of an object, it has a **state**. Everything that
    an object “knows” is what makes one instance of a class different from another
    instance of the same class.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你创建一个对象的实例时，它有一个**状态**。一个对象“知道”的一切是使一个类的一个实例与同一类的另一个实例不同的东西。
- en: '**Object serialized**'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**对象已序列化**'
- en: '![Images](assets/pg553-2.png)'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg553-2.png)'
- en: When C# serializes an object, it **saves the complete state of the object**,
    so that an identical instance (object) can be brought back to life on the heap
    later.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当C#序列化一个对象时，它**保存对象的完整状态**，以便稍后可以在堆上重新创建一个完全相同的实例（对象）。
- en: '![Images](assets/pg553-3.png)'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg553-3.png)'
- en: '**And later on...**'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**以及后来...**'
- en: Later—maybe days later, and in a different program—you can go back to the file
    and **deserialize** it. That pulls the original class back out of the file and
    restores it **exactly as it was**, with all of its fields and values intact.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以后——也许是几天后，在另一个程序中——你可以回到文件并**反序列化**它。这会将原始类从文件中取回，并**完全恢复**它，所有字段和值都完好无损。
- en: '![Images](assets/pg553-4.png)'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg553-4.png)'
- en: But what exactly IS an object’s state? What needs to be saved?
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 但一个对象的状态到底是什么？需要保存什么？
- en: We already know that **an object stores its state in its fields and properties**.
    So when an object is serialized, each of those values needs to be saved to the
    file.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道**一个对象将其状态存储在其字段和属性中**。因此，当一个对象被序列化时，每个值都需要保存到文件中。
- en: Serialization starts to get interesting when you have more complicated objects.
    Chars, ints, doubles, and other value types have bytes that can just be written
    out to a file as is. What if an object has an instance variable that’s an object
    *reference*? What about an object that has five instance variables that are object
    references? What if those object instance variables themselves have instance variables?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有更复杂的对象时，序列化就变得有趣起来。字符、整数、双精度和其他值类型有可以直接写入文件的字节。如果一个对象有一个实例变量是对象*引用*呢？如果一个对象有五个实例变量是对象引用呢？如果这些对象实例变量本身有实例变量呢？
- en: Think about it for a minute. What part of an object is potentially unique? Think
    about what needs to be restored in order to get an object that’s identical to
    the one that was saved. Somehow everything on the heap has to be written to the
    file.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 花一分钟时间考虑一下。一个对象的哪一部分可能是唯一的？考虑一下需要恢复什么才能获得与保存的对象完全相同的对象。堆上的所有内容都必须写入文件中。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Brain Barbell is like a “juiced up” Brain Power. Take a few minutes and really
    think about this one.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Brain Barbell就像是“增强版”的Brain Power。花几分钟时间认真思考一下这个。
- en: When an object is serialized, all of the objects it refers to get serialized,
    too...
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当一个对象被序列化时，它所引用的所有对象也会被序列化...
- en: '...and all of the objects *they* refer to, and all of the objects *those other
    objects* refer to, and so on and so on. Don’t worry—it may sound complicated,
    but it all happens automatically. C# starts with the object you want to serialize
    and looks through its fields for other objects. Then it does the same for each
    of them. Every single object gets written out to the file, along with all the
    information C# needs to reconstitute it all when the object gets deserialized.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '...以及所有它们所引用的对象，以及所有那些其他对象所引用的对象，依此类推。别担心——听起来可能很复杂，但这一切都会自动发生。C#从你想要序列化的对象开始，并查看其字段中的其他对象。然后对每个对象执行相同的操作。每个对象都会被写入文件，连同C#重新构建对象时所需的所有信息。'
- en: Note
  id: totrans-177
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**A group of objects connected to each other by references is sometimes referred
    to as a graph.**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**一组通过引用相互连接的对象有时被称为图。**'
- en: '![Images](assets/pg555.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg555.png)'
- en: Use JsonSerialization to serialize your objects
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JsonSerialization来序列化你的对象
- en: You’re not just limited to reading and writing lines of text to your files.
    You can use **JSON serialization** to let your programs ***copy entire objects***
    to strings (which you can write to files!) and read them back in...all in just
    a few lines of code! Let’s take a look at how this works. Start by **creating
    a new console app.**
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅仅局限于读写文本行到你的文件中。你可以使用**JSON序列化**让你的程序***复制整个对象***到字符串（然后你可以将其写入文件！）并读取它们回来...所有这些只需几行代码！让我们看看这是如何工作的。首先**创建一个新的控制台应用程序。**
- en: '***Do this!***'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '***做这个！***'
- en: '**Design some classes for your object graph.**'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为你的对象图设计一些类。**'
- en: 'Add this `HairColor` enum and these Guy, Outfit, and HairStyle classes to your
    new console app:'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将这个`HairColor`枚举和这些Guy、Outfit和HairStyle类添加到你的新控制台应用程序中：
- en: '[PRE9]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Create a graph of objects to serialize.**'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个要序列化的对象图。**'
- en: 'Now create a small graph of objects to serialize: a new List<Guy> pointing
    to a couple of Guy objects. Add this code to your Main method. It uses a collection
    initializer and object initializers to build the object graph:'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在创建一个小的对象图来序列化：一个新的 List<Guy> 指向几个 Guy 对象。将以下代码添加到你的 Main 方法中。它使用集合初始化器和对象初始化器来构建对象图：
- en: '[PRE10]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![Images](assets/pg556.png)'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图像](assets/pg556.png)'
- en: '**Use JsonSerializer to serialize the objects to a string.**'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用 JsonSerializer 将对象序列化为字符串。**'
- en: 'First add a `using` directive to the top of your code file:'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，在你的代码文件顶部添加一个 `using` 指令：
- en: '[PRE11]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now you can **serialize the entire graph** with a single line of code:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在你可以用一行代码**序列化整个图形**：
- en: '[PRE12]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run your app and look closely at what it prints to the console:'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次运行你的应用程序，并仔细观察它打印到控制台的内容：
- en: '[PRE13]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'That’s your object graph **serialized to JSON** (which some people pronounce
    “Jason” and others pronounce “JAY-sahn”). It’s *a human-readable data interchange
    format*, which means that it’s a way to store complex objects using strings that
    a person can make sense of. Because it’s human readable, you can see that it has
    all of the parts of the graph: names and clothes are encoded as strings (“Bob”,
    “t-shirt”) and enums are encoded as their integer values.'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是你的对象图 **序列化为 JSON**（有些人发音为“Jason”，其他人发音为“JAY-sahn”）。它是*一种人类可读的数据交换格式*，这意味着它是一种使用字符串存储复杂对象的方式，人们可以理解。因为它是人类可读的，你可以看到它包含图的所有部分：名称和衣服被编码为字符串（“Bob”，“t-shirt”），枚举被编码为它们的整数值。
- en: '**Use JsonSerializer to deserialize the JSON to a new object graph.**'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用 JsonSerializer 将 JSON 反序列化为一个新的对象图。**'
- en: 'Now that we have a string that contains the object graph serialized to JSON,
    we can **deserialize** it. That just means using it to create new objects. JsonSerializer
    lets us do that in one line of code, too. Add this to the Main method:'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们有了一个包含对象图的 JSON 序列化的字符串，我们可以进行反序列化。这意味着使用它来创建新的对象。JsonSerializer 也让我们可以用一行代码完成这个操作。在
    Main 方法中添加以下代码：
- en: '[PRE14]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Run your app again. It deserializes the guys from the JSON string and writes
    them to the console:'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次运行你的应用程序。它会将从 JSON 字符串中反序列化的人物输出到控制台：
- en: '[PRE15]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-203
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**When you use JsonSerializer to serialize an object graph to JSON, it generates
    a (somewhat) readable text representation of the data in each object.**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**当你使用 JsonSerializer 将对象图序列化为 JSON 时，它生成了（在某种程度上）可读的文本表示形式的数据。**'
- en: JSON only includes data, not specific C# types
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON 只包含数据，不包括特定的 C# 类型。
- en: 'When you were looking through the JSON data, you saw human-readable versions
    of the data in your objects: strings like “Bob” and “slacks”, numbers like 8 and
    3.5, and even lists and nested objects. What *didn’t* you see when you looked
    at the JSON data? JSON **does not include the names of types**. Look inside a
    JSON file and you won’t see class names like Guy, Outfit, HairColor, or HairStyle,
    or even the names of basic types like int, string, or double. That’s because JSON
    just contains the data, and JsonSerializer will do its best to deserialize the
    data into whatever properties it finds.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当你浏览 JSON 数据时，你会看到对象中可读的版本的数据：像“Bob”和“slacks”这样的字符串，像 8 和 3.5 这样的数字，甚至是列表和嵌套对象。当你查看
    JSON 数据时，你看不到什么？JSON **不包括类型的名称**。查看 JSON 文件，你不会看到 Guy、Outfit、HairColor 或 HairStyle
    等类的名称，甚至连 int、string 或 double 等基本类型的名称也不会看到。这是因为 JSON 只包含数据，而 JsonSerializer 将尽力将数据反序列化为它发现的任何属性。
- en: 'Let’s put this to the test. Add a new class to your project:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下。向你的项目添加一个新类：
- en: '![Images](assets/pg559.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/pg559.png)'
- en: 'And run your code again. Since the JSON just has a list of objects, JsonSerializer.Deserialize
    will happily stick them into a Stack (or a Queue, or an array, or another collection
    type). Since Dude has public Name and Hair properties that match the data, it
    will fill in any data that it can. Here’s what it prints to the output:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后再次运行你的代码。由于 JSON 只包含对象列表，JsonSerializer.Deserialize 将乐意将它们放入栈（或队列、数组或其他集合类型）。由于
    Dude 公开了与数据匹配的 Name 和 Hair 属性，它将填充任何可以找到的数据。这是它打印到输出的内容：
- en: '[PRE16]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-211
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: One more thing! We showed you basic serialization with JsonSerializer. There
    are just a couple more things you need to know about it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事！我们向你展示了如何使用 JsonSerializer 进行基本的序列化。你只需要了解它的另外几点内容。
- en: 'Next up: we’ll take a deep dive into our data'
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来：我们将深入研究我们的数据。
- en: You’ve been writing lots of code using value types like int, bool, and double,
    and creating objects that store data in fields. Now it’s time to take a lower-level
    view of things. The rest of this chapter is all about getting to know your data
    better by understanding the actual bytes that C# and .NET use to represent it.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经写了很多代码，使用了像 int、bool 和 double 这样的值类型，并创建了存储数据的字段对象。现在是时候从更低的角度来看待事物了。本章的其余部分都是关于通过理解
    C# 和 .NET 用于表示数据的实际字节来更好地了解你的数据。
- en: Here’s what we’ll do.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要做的事情。
- en: '![Images](assets/pg561-1.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg561-1.png)'
- en: '**We’ll explore how C# strings are encoded with Unicod—.NET uses Unicode to
    store characters and text.**'
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**我们将探讨 C# 字符串如何使用 Unicode 编码——.NET 使用 Unicode 存储字符和文本。**'
- en: '![Images](assets/pg561-2.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg561-2.png)'
- en: '**We’ll write values as binary data, then we’ll read them back in and see what
    bytes were written.**'
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**我们将把值写入二进制数据，然后读取它们，看看写入了哪些字节。**'
- en: '![Images](assets/pg561-3.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg561-3.png)'
- en: '**We’ll build a hex dumper that lets us take a closer look at the bits and
    bytes in files.**'
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**我们将构建一个十六进制转储程序，让我们更仔细地查看文件中的位和字节。**'
- en: Note
  id: totrans-222
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Accessibility features are often included as an afterthought, but your games—and
    any other kind of program!—come out better if you think about these things from
    the very beginning.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助功能通常是事后加入的，但如果从一开始就考虑这些事情，你的游戏——以及任何其他类型的程序！——会更加出色。
- en: C# strings are encoded with Unicode
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 字符串使用 Unicode 编码
- en: You’ve been using strings since you typed `"Hello, world!"` into the IDE at
    the start of [#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin).
    Because strings are so intuitive, we haven’t really needed to dissect them and
    figure out what makes them tick. But ask yourself...***what exactly is a string?***
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你自从在 IDE 开始时键入了`"Hello, world!"`以来，一直在使用字符串。因为字符串如此直观，我们并没有真正需要解剖它们并弄清楚它们如何运作。但是请问自己……***究竟什么是字符串？***
- en: A C# string is a **read-only collection of chars**. So if you actually look
    at how a string is stored in memory, you’ll see the string “Elephant” stored as
    the chars ‘E’, ‘l’, ‘e’, ‘p’, ‘h’, ‘a’, ‘n’, and ‘t’. Now ask yourself...***what
    exactly is a char?***
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: C# 字符串是 **只读的字符集合**。因此，如果你实际查看存储在内存中的字符串，“Elephant”将被存储为字符‘E’、‘l’、‘e’、‘p’、‘h’、‘a’、‘n’和‘t’。现在问问自己……***究竟什么是字符？***
- en: A char is a character represented with **Unicode**. Unicode is an industry standard
    for **encoding** characters, or converting them into bytes so they can be stored
    in memory, transmitted across networks, included in documents, or pretty much
    anything else you want to do with them—and you’re guaranteed that you’ll always
    get the correct characters.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: char 是用 **Unicode** 表示的字符。Unicode 是用于 **编码** 字符的行业标准，或将它们转换为字节，以便存储在内存中、通过网络传输、包含在文档中或几乎任何其他你想做的事情——并且你保证总是获得正确的字符。
- en: 'This is especially important when you consider just how many characters there
    are. The Unicode standard supports over 150 **scripts** (sets of characters for
    specific languages), including not just Latin (which has the 26 English letters
    and variants like é and ç but scripts for many languages used around the world.
    The list of supported scripts is constantly growing, as the Unicode Consortium
    adds new ones every year (here’s the current list: [http://www.unicode.org/standard/supported.html](http://www.unicode.org/standard/supported.html)).'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是当你考虑到有多少字符时，这点尤为重要。Unicode 标准支持超过 150 个 **脚本**（特定语言的字符集），包括不仅限于拉丁文（包括 26
    个英文字母和变体如 é 和 ç，还有全球许多语言使用的脚本。支持的脚本列表不断增长，Unicode 联盟每年都在添加新的（这是当前的列表：[http://www.unicode.org/standard/supported.html](http://www.unicode.org/standard/supported.html)）。
- en: '![Images](assets/pg563-1.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg563-1.png)'
- en: 'Unicode supports another really important set of characters: **emoji**. All
    of the emoji, from the winking smiley face (![Images](assets/pg563-2.png) ) to
    the ever-popular pile of poo (![Images](assets/pg563-3.png) ), are Unicode characters.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 还支持另一组非常重要的字符：**emoji**。从眨眼笑脸 (![图片](assets/pg563-2.png)) 到广受欢迎的一堆大便
    (![图片](assets/pg563-3.png)) ，所有的 emoji 都是 Unicode 字符。
- en: '![Images](assets/pg564.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg564.png)'
- en: '**Every Unicode character—including emoji—has a unique number called a code
    point.**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**每个 Unicode 字符（包括 emoji）都有一个称为代码点的唯一编号**。'
- en: 'The number for a Unicode character is called a **code point**. You can download
    a list of all of the Unicode characters here: [https://www.unicode.org/Public/UNIDATA/UnicodeData.txt](https://www.unicode.org/Public/UNIDATA/UnicodeData.txt).'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode字符的编号称为**代码点**。你可以在这里下载所有Unicode字符的列表：[https://www.unicode.org/Public/UNIDATA/UnicodeData.txt](https://www.unicode.org/Public/UNIDATA/UnicodeData.txt)。
- en: 'That’s a large text file with a line for every Unicode character. Download
    it and search for “ELEPHANT” and you’ll find a line that starts like this: `1F418;ELEPHANT`.
    The numbers 1F418 represent a **hexadecimal** (or **hex**) value. Hex values are
    written with the numbers 0 to 9 and letters A to F, and it’s often easier to work
    with Unicode values (and binary values in general) in hex than in decimal. You
    can create a hex literal in C# by adding 0x to the beginning, like this: 0x1F418.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 那是一个包含每个Unicode字符一行的大文本文件。下载它并搜索“ELEPHANT”，你会找到以这种方式开始的行：`1F418;ELEPHANT`。数字1F418代表一个**十六进制**（或**十六进制**）值。十六进制值用数字0到9和字母A到F编写，通常在处理Unicode值（以及一般的二进制值）时，使用十六进制比使用十进制更方便。在C#中，你可以通过在开头加上0x来创建十六进制文字，就像这样：0x1F418。
- en: '1F418 is the Elephant emoji’s ***UTF-8*** **code point**. UTF-8 is the most
    common way to **encode** a character as Unicode (or represent it as a number).
    It’s a variable-length encoding, using between 1 and 4 bytes. In this case, it
    uses 3 bytes: 0x01 (or 1), 0xF4 (or 244), and 0x18 (or 24).'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 1F418是大象表情符号的***UTF-8*** **代码点**。UTF-8是将字符编码为Unicode（或表示为数字）的最常见方式。它是一种可变长度编码，使用1到4字节。在这种情况下，它使用3字节：0x01（或1）、0xF4（或244）和0x18（或24）。
- en: 'But that’s not what the JSON serializer printed. It printed a longer hex number:
    D83DDC18\. That’s because **the C# char type uses *UTF-16***, which uses code
    points that consist of either one or two 2-byte numbers. The UTF-16 code point
    of the elephant emoji is 0xD83D 0xDC18\. UTF-8 is much more popular than UTF-16,
    especially on the Web, so when you look up code points you’re much more likely
    to find UTF-8 than UTF-16.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不是JSON序列化器打印的内容。它打印了一个更长的十六进制数：D83DDC18。这是因为**C# char类型使用*UTF-16***，它使用由一个或两个2字节数字组成的代码点。大象表情符号的UTF-16代码点是0xD83D
    0xDC18。UTF-8比UTF-16更受欢迎，特别是在Web上，因此当你查找代码点时，更有可能找到UTF-8而不是UTF-16。
- en: '**UTF-8 is a variable-length encoding used by most web pages and many systems.
    It can store characters using one, two, three, or more bytes. UTF-16 is a fixed-length
    encoding that always uses either one or two 2-byte numbers. .NET stores char values
    in memory as UTF-16 values.**'
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**UTF-8是大多数网页和许多系统使用的可变长度编码。它可以使用1、2、3或更多字节存储字符。UTF-16是一个固定长度编码，总是使用一个或两个2字节数字。.NET将char值存储在内存中作为UTF-16值。**'
- en: Visual Studio works really well with Unicode
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio非常适合处理Unicode
- en: 'Let’s use Visual Studio to see how the IDE works with Unicode characters. You
    saw back in [#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin)
    that you can use emoji in code. Let’s see what else the IDE can handle. Go to
    the code editor and enter this code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Visual Studio来查看IDE如何处理Unicode字符。你在[#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin)中看到了可以在代码中使用表情符号。让我们看看IDE还能处理什么。进入代码编辑器并输入以下代码：
- en: '[PRE17]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you’re using Windows, open up the Character Map app. If you’re using a Mac,
    press Ctrl-![Images](assets/pg565a.png)-space to pop up the Character Viewer.
    Then search for the Hebrew letter shin (![Images](assets/pg565b.png)) and copy
    it to the clipboard.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Windows，打开字符映射应用程序。如果你使用的是Mac，按下Ctrl-![图片](assets/pg565a.png)-空格来弹出字符查看器。然后搜索希伯来字母*辉*
    (![图片](assets/pg565b.png))并复制到剪贴板。
- en: '![Images](assets/pg565.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg565.png)'
- en: 'Place your cursor at the end of the string between the space and the quotation
    mark, and paste in the shin character that you copied to the clipboard. Hmm, something
    looks weird:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 把光标放在空格和引号之间的字符串末尾，然后粘贴你复制到剪贴板上的*辉*字符。嗯，看起来有些奇怪：
- en: '![Images](assets/pg565-1.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg565-1.png)'
- en: 'Did you notice that the cursor is positioned to the *left* of the pasted letter?
    Well, let’s continue. Don’t click anywhere in the IDE—keep the cursor where it
    is, then switch over to Character Map or Character Viewer to search for the Hebrew
    letter lamed (![Images](assets/pg565-2.png)). Switch back to the IDE—make sure
    the cursor is still positioned just left of the shin—and paste in the lamed:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到光标位于粘贴字母的*左侧*吗？好的，让我们继续。不要在IDE中点击任何地方——保持光标所在的位置，然后切换到字符映射或字符查看器中搜索希伯来字母拉梅德
    (![图片](assets/pg565-2.png))。切换回IDE——确保光标仍然位于辉的左侧——并粘贴拉梅德进去：
- en: '![Images](assets/pg565-3.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg565-3.png)'
- en: 'When you pasted the lamed, the IDE added it to the left of the shin. Now search
    for the Hebrew letters vav (`I`) and final mem (![Images](assets/pg565-4.png)).
    Paste each of them into the IDE—it will insert them to the left of the cursor:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当你粘贴了lamed时，IDE将其添加到shin的左侧。现在搜索希伯来字母vav（`I`）和final mem（![Images](assets/pg565-4.png)）。将它们粘贴到IDE中——它会将它们插入到光标的左侧：
- en: '![Images](assets/pg565-5.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/pg565-5.png)'
- en: The IDE knows that ***Hebrew is read right to left***, so it’s behaving accordingly.
    Click to select the text near the beginning of the statement, and slowly drag
    your cursor right to select `Hello` and then ![Images](assets/pg565-6.png). Watch
    carefully what happens when the selection reaches the Hebrew letters. It skips
    to the shin (![Images](assets/pg565-7.png)) and then selects from right to left—and
    that’s exactly what a Hebrew reader would expect it to do.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: IDE知道***希伯来语从右向左读***，因此它会相应地行为。点击选择语句开头附近的文本，并慢慢将光标向右拖动以选择`Hello`，然后是![Images](assets/pg565-6.png)。当选择到希伯来字母时，请仔细观察会发生什么。它跳到shin（![Images](assets/pg565-7.png)）然后从右向左选择——这正是希伯来读者期望它做的。
- en: .NET uses Unicode to store characters and text
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET使用Unicode来存储字符和文本
- en: The two C# types for storing text and characters—string and char—keep their
    data in memory as Unicode. When that data’s written out as bytes to a file, each
    of those Unicode numbers is written out to the file. Let’s get a sense of exactly
    how Unicode data is written out to a file. **Create a new console app.** We’ll
    use the File.WriteAllBytes and File.ReadAllBytes methods to start exploring Unicode.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 用于存储文本和字符的两个C#类型——string和char——将它们的数据作为Unicode保存在内存中。当这些数据作为字节写入文件时，每个Unicode数都被写入文件。让我们来感受一下Unicode数据如何写入文件。**创建一个新的控制台应用。**我们将使用File.WriteAllBytes和File.ReadAllBytes方法开始探索Unicode。
- en: '***Do this!***'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '***做这个！***'
- en: '**Write a normal string out to a file and read it back.**'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将普通字符串写入文件并读取它。**'
- en: 'Add the following code to the Main method—it uses File.WriteAllText to write
    the string “Eureka!” out to a file called *eureka.txt* (so you’ll need `using
    System.IO;`). Then it creates a new byte array called `eurekaBytes`, reads the
    file into it, and prints out all of the bytes it read:'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将以下代码添加到Main方法中——它使用File.WriteAllText将字符串“Eureka！”写入名为*eureka.txt*的文件（所以你需要`using
    System.IO;`）。然后创建一个新的字节数组称为`eurekaBytes`，将文件读入其中，并打印出它读取的所有字节：
- en: '![Images](assets/pg566.png)'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Images](assets/pg566.png)'
- en: 'You’ll see these bytes written to the output: `69 117 114 101 107 97 33`. The
    last line calls the method Encoding.UTF8.GetString, which converts a byte array
    with UTF-8-encoded characters to a string. Now **open the file in Notepad** (Windows)
    **or TextEdit** (Mac). It says “Eureka!”'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会看到这些字节被写入输出：`69 117 114 101 107 97 33`。最后一行调用了Encoding.UTF8.GetString方法，它将UTF-8编码的字节数组转换为字符串。现在在Notepad（Windows）或TextEdit（Mac）中**打开文件**。它说“Eureka！”
- en: '**Then add code to write the bytes as hex numbers.**'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**然后添加代码以将字节写成十六进制数。**'
- en: 'When you’re encoding data you’lloften use hex, so let’s do that now. Add this
    code to the end of the Main method that writes the same bytes out, using `{0:x2}`
    to **format each byte as a hex number**:'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你编码数据时，你经常会使用十六进制，所以现在让我们这样做。在Main方法的末尾添加此代码，使用`{0:x2}`来**格式化每个字节为十六进制数**：
- en: '[PRE18]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Hex uses the numbers 0 through 9 and letters A through F to represent numbers
    in base 16, so 6B is equal to 107.
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 十六进制使用数字0到9和字母A到F来表示基数为16的数字，所以6B等于107。
- en: 'That tells Write to print parameter 0 (the first one after the string to print)
    as a two-character hex code. So it writes the same seven bytes in hex instead
    of decimal: `45 75 72 65 6b-61 21`.'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这告诉Write将参数0（打印字符串后的第一个参数）打印为两个字符的十六进制代码。因此，它以十六进制而不是十进制写出相同的七个字节：`45 75 72
    65 6b-61 21`。
- en: '**Modify the first line to write the Hebrew letters “![Images](assets/pg566-2.png)”
    instead of “Eureka!”**'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**修改第一行，写希伯来字母“![Images](assets/pg566-2.png)”而不是“Eureka！”**'
- en: 'You just added the Hebrew text ![Images](assets/pg566-2.png) to another program
    using either Character Map (Windows) or Character Viewer (Mac). **Comment out
    the first line of the Main method and replace it with the following code** that
    writes ![Images](assets/pg566-2.png) to the file instead of “Eureka!” We’ve added
    an extra Encoding.Unicode parameter so it writes UTF-16 (the Encoding class is
    in the System.Text namespace, so also add `using System.Text;` to the top):'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你刚刚使用了Character Map（Windows）或Character Viewer（Mac）将希伯来文本 ![图片](assets/pg566-2.png)
    添加到另一个程序。**注释掉Main方法的第一行，并用以下代码替换它**，该代码将 ![图片](assets/pg566-2.png) 而不是“Eureka！”写入文件。我们添加了一个额外的Encoding.Unicode参数，以便写入UTF-16（Encoding类位于System.Text命名空间中，因此还要在顶部添加`using
    System.Text;`）：
- en: '![Images](assets/pg566-1.png)'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg566-1.png)'
- en: 'Now run the code again, and look closely at the output: `ff fe e9 05 dc 05
    d5 05 dd 05`. The first two characters are “FF FE”, which is the Unicode way of
    saying that we’re going to have a string of 2-byte characters. The rest of the
    bytes are the Hebrew letters—but they’re reversed, so U+05E9 appears as `**e9
    05**`. Now open the file up in Notepad or TextEdit to make sure it looks right.'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在再次运行代码，并仔细观察输出：`ff fe e9 05 dc 05 d5 05 dd 05`。前两个字符是“FF FE”，这是Unicode表示我们将有一个2字节字符的方式。其余的字节是希伯来字母
    —— 但它们是反向的，所以U+05E9显示为`**e9 05**`。现在在记事本或TextEdit中打开文件，确保它看起来正确。
- en: '**Use JsonSerializer to explore UTF-8 and UTF-16 code points.**'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用JsonSerializer探索UTF-8和UTF-16代码点。**'
- en: 'When you serialized the elephant emoji, JsonSerializer generated `\uD83D\uDC18`
    – which we now know is the 4-byte UTF-16 code point in hex. Now let’s try that
    with the Hebrew letter shin. Add `using System.Text.Json;` to the top of your
    app and then add this line:'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你序列化大象表情符号时，JsonSerializer生成了`\uD83D\uDC18` —— 我们现在知道这是4字节UTF-16代码点的十六进制表示。现在让我们试试希伯来字母shin。在你的应用程序顶部添加`using
    System.Text.Json;`，然后添加这一行：
- en: '![Images](assets/pg567-1a.png)'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg567-1a.png)'
- en: Run your app again. This time it printed a value with two hex bytes, “\u05E9”—that’s
    the UTF-16 code point for the Hebrew letter shin. It’s also the UTF-8 code point
    for the same letter.
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次运行你的应用程序。这一次它打印了一个值，有两个十六进制字节，“\u05E9” —— 这是希伯来字母shin的UTF-16代码点。它也是相同字母的UTF-8代码点。
- en: But wait a minute—we learned that the UTF-8 code point for the elephant emoji
    is `0x1F418`, which is ***different*** than the UTF-16 code point (0xD83D 0xDC18).
    What’s going on?
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 等等——我们了解到大象表情符号的UTF-8代码点是`0x1F418`，与UTF-16代码点（0xD83D 0xDC18）***不同***。发生了什么事？
- en: It turns out that most of the characters with 2-byte UTF-8 code points have
    the same code points in UTF-16\. Once you reach the UTF-8 values that require
    three or more bytes—which includes the familiar emoji that we’ve used in this
    book—they differ. So while the Hebrew letter shin is 0x05E9 in both UTF-8 and
    UTF-16, the elephant emoji is 0x1F418 in UTF-8 and 0xD8ED 0xDC18 in UTF-16.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 原来大多数具有2字节UTF-8代码点的字符在UTF-16中具有相同的代码点。一旦达到需要三个或更多字节的UTF-8值——包括本书中使用的熟悉表情符号——它们就不同了。所以尽管希伯来字母shin在UTF-8和UTF-16中都是0x05E9，大象表情符号在UTF-8中是0x1F418，在UTF-16中是0xD8ED
    0xDC18。
- en: '![Images](assets/pg567-1.png)'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg567-1.png)'
- en: '**Use Unicode escape sequences to encode** ![Images](assets/pg567-2.png).'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用Unicode转义序列进行编码** ![图片](assets/pg567-2.png)。'
- en: 'Add these lines to your Main method to write the elephant emoji to two files
    using both the UTF-16 and UTF-32 escape sequences:'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在你的Main方法中添加这些行，使用UTF-16和UTF-32转义序列将大象表情符号写入两个文件：
- en: '[PRE19]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Run your app again, then open both of those files in Notepad or TextEdit. You
    should see the correct character written to the file.
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次运行你的应用程序，然后在记事本或TextEdit中打开这两个文件。你应该看到正确的字符被写入文件。
- en: Note
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**You used UTF-16 and UTF-32 escape sequences to create your emoji, but the
    WriteAllText method writes a UTF-8 file. The Encoding.UTF8.GetString method you
    used in step 1 converts a byte array with UTF-8-encoded data back to a string.**'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**你使用UTF-16和UTF-32转义序列来创建你的表情符号，但WriteAllText方法却写入了一个UTF-8文件。你在步骤1中使用的Encoding.UTF8.GetString方法将UTF-8编码的数据转换回字符串。**'
- en: C# can use byte arrays to move data around
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#可以使用字节数组来移动数据
- en: Since all your data ends up encoded as **bytes**, it makes sense to think of
    a file as one **big byte array**...and you already know how to read and write
    byte arrays.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 因为所有的数据最终都以**字节**编码，所以把文件想象成一个**大字节数组**是有意义的……而且你已经知道如何读取和写入字节数组。
- en: '![Images](assets/pg568.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg568.png)'
- en: Use a BinaryWriter to write binary data
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用BinaryWriter写入二进制数据
- en: Note
  id: totrans-284
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: StreamWriter also encodes your data. It just specializes in text and text encoding—it
    defaults to UTF-8.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: StreamWriter 也对数据进行编码。它专门处理文本和文本编码——默认为 UTF-8。
- en: You ***could*** encode all of your strings, chars, ints, and floats into byte
    arrays before writing them out to files, but that would get pretty tedious. That’s
    why .NET gives you a very useful class called **BinaryWriter** that **automatically
    encodes your data** and writes it to a file. All you need to do is create a FileStream
    and pass it into the BinaryWriter’s constructor (they’re in the System.IO namespace,
    so you’ll need `using System.IO;`). Then you can call its methods to write out
    your data. Let’s practice using BinaryWriter to write binary data to a file.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 您***可以***将所有字符串、字符、整数和浮点数编码为字节数组，然后再将它们写入文件，但这将变得非常繁琐。这就是为什么 .NET 给您提供了一个非常有用的类叫做
    **BinaryWriter**，它**自动编码您的数据**并将其写入文件。您只需创建一个 FileStream 并将其传递给 BinaryWriter 的构造函数（它们都在
    System.IO 命名空间中，所以您需要 `using System.IO;`）。然后，您可以调用其方法将数据写出。让我们练习使用 BinaryWriter
    将二进制数据写入文件。
- en: '***Do this!***'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '***就这样！***'
- en: 'Start by creating a console app and setting up some data to write to a file:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个控制台应用程序并设置一些要写入文件的数据：
- en: '![Images](assets/pg569-1a.png)'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图像](assets/pg569-1a.png)'
- en: 'To use a BinaryWriter, first you need to open a new stream with File.Create:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用 BinaryWriter，首先需要使用 File.Create 打开一个新流：
- en: '[PRE20]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now just call its Write method. Each time you do this, it adds new bytes onto
    the end of the file that contain an encoded version of whatever data you passed
    it as a parameter:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在只需调用其 Write 方法。每次执行此操作时，它都会将包含传递给它作为参数的数据的编码版本的新字节添加到文件的末尾：
- en: '![Images](assets/pg569-1.png)'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图像](assets/pg569-1.png)'
- en: 'Now use the same code you used before to read in the file you just wrote:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在使用之前用于读取您刚刚写入的文件的相同代码：
- en: '[PRE21]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Write down the output in the blanks below. Can you **figure out** **what bytes
    correspond** to each of the five `writer.Write(...)` statements? We put a bracket
    under the groups of bytes that correspond with each statement to help you figure
    out which bytes in the file correspond with data written by the app.
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的空白处写下输出。您能**找出每个 writer.Write(...) 语句对应的字节吗**？我们在与每个语句对应的字节组下面放置了括号，以帮助您确定文件中哪些字节对应于应用程序写入的数据。
- en: Use BinaryReader to read the data back in
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 BinaryReader 读取数据
- en: The BinaryReader class works just like BinaryWriter. You create a stream, attach
    the BinaryReader object to it, and then call its methods...but the reader **doesn’t
    know what data’s in the file**! It has no way of knowing. Your float value of
    491.695F was encoded as d8 f5 43 45\. Those same bytes are a perfectly valid `int`—1,140,185,334—so
    you’ll need to tell the BinaryReader exactly what types to read from the file.
    Add the following code to your program, and have it read the data you just wrote.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: BinaryReader 类的工作方式与 BinaryWriter 类似。您创建一个流，将 BinaryReader 对象附加到该流，然后调用其方法……但读取器**不知道文件中的数据是什么**！它没有办法知道。您的浮点值
    491.695F 被编码为 d8 f5 43 45。这些字节也可以作为一个完全有效的`int`——1,140,185,334——所以您需要告诉 BinaryReader
    究竟从文件中读取哪些类型。将以下代码添加到您的程序中，并让它读取您刚刚写入的数据。
- en: Note
  id: totrans-299
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Don’t take our word for it. Replace the line that reads the float with a call
    to ReadInt32\. (You’ll need to change the type of floatRead to int.) Then you
    can see for yourself what it reads from the file.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 不要轻信我们的话。用调用 ReadInt32 替换读取浮点数的那一行。（您需要将 floatRead 的类型更改为 int。）然后，您可以亲自看看它从文件中读取了什么。
- en: 'Start out by setting up the FileStream and BinaryReader objects:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先设置 FileStream 和 BinaryReader 对象：
- en: '[PRE22]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You tell BinaryReader what type of data to read by calling its different methods:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您通过调用 BinaryReader 的不同方法告诉它要读取什么类型的数据：
- en: '![Images](assets/pg570-1.png)'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图像](assets/pg570-1.png)'
- en: 'Now write the data that you read from the file to the console:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将从文件中读取的数据写入控制台：
- en: '[PRE23]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here’s the output that gets printed to the console:'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是打印到控制台的输出：
- en: '[PRE24]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-309
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**If you’re writing a string that only has Unicode characters with low numbers
    (such as Latin letters), it writes one byte per character. If it’s got high-numbered
    characters (like emoji characters), they’ll be written using two or more bytes
    each.**'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果您要写入仅包含低编号 Unicode 字符的字符串（如拉丁字母），则每个字符写入一个字节。如果有高编号字符（如表情符号），则每个字符将使用两个或更多字节进行编写。**'
- en: A hex dump lets you see the bytes in your files
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 十六进制转储可以让您查看文件中的字节
- en: A **hex dump** is a *hexadecimal* view of the contents of a file, and it’s a
    really common way for programmers to take a deep look at a file’s internal structure.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**十六进制转储**是文件内容的*十六进制*视图，是程序员深入查看文件内部结构的常见方式。'
- en: 'It turns out that hex is a convenient way to display bytes in a file. A byte
    takes two characters to display in hex: bytes range from 0 to 255, or 00 to ff
    in hex. That lets you see a lot of data in a really small space, and in a format
    that makes it easier to spot patterns. It’s useful to display binary data in rows
    that are 8, 16, or 32 bytes long because most binary data tends to break down
    in chunks of 4, 8, 16, or 32...like all the types in C#. (For example, an int
    takes up 4 bytes.) A hex dump lets you see exactly what those values are made
    of.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Hex（十六进制）原来是在文件中显示字节的便捷方式。一个字节在十六进制中占用两个字符：字节的范围是从0到255，或者在十六进制中是00到ff。这使您可以在非常小的空间中查看大量数据，并且以一种易于识别模式的格式呈现。将二进制数据显示为每行8、16或32字节很有用，因为大多数二进制数据倾向于以4、8、16或32个字节的块来处理，就像C#中的所有类型一样（例如，int占用4个字节）。十六进制转储让您可以准确查看这些值由什么组成。
- en: How to make a hex dump of some plain text
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何制作一些普通文本的十六进制转储
- en: 'Start with some familiar text using Latin characters:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 从一些使用拉丁字符的熟悉文本开始：
- en: '[PRE25]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'First, break up the text into 16-character segments, starting with the first
    16: `When you have el`'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将文本分成16字符段，从第一个16个字符开始：`When you have el`
- en: 'Next, convert each character in the text to its UTF-8 code point. Since the
    Latin characters all have ***1-byte*** UTF-8 code points, each will be represented
    by a two-digit hex number from 00 to 7F. Here’s what each line of our dump will
    look like:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将文本中的每个字符转换为其UTF-8代码点。由于所有拉丁字符都具有***1字节***的UTF-8代码点，每个字符将以从00到7F的两位十六进制数字表示。我们的每行转储看起来将是这样的：
- en: '![Images](assets/pg572.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/pg572.png)'
- en: 'Repeat until you’ve dumped every 16-character segment in the file:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 重复，直到您在文件中转储了每个16字符段：
- en: '[PRE26]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: And that’s our dump. There are many hex dump programs for various operating
    systems, and each of them has a slightly different output. Each line in our particular
    hex dump format represents 16 characters in the input that was used to generate
    it, with the offset at the start of each line and the text for each character
    at the end. Other hex dump apps might display things differently (for example,
    rendering escape sequences or showing values in decimal).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的转储结果。各种操作系统都有许多不同的十六进制转储程序，每个程序的输出略有不同。我们特定的十六进制转储格式中，每行表示生成它的输入中的16个字符，每行开头有偏移量，每个字符的文本在行尾。其他十六进制转储应用程序可能会以不同方式显示内容（例如，呈现转义序列或以十进制显示值）。
- en: '**A hex dump is a hexadecimal view of data in a file or memory, and can be
    a really useful tool to help you debug binary data.**'
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**十六进制转储是文件或内存中数据的十六进制视图，是帮助您调试二进制数据的非常有用的工具。**'
- en: Use StreamReader to build a hex dumper
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用StreamReader构建一个十六进制转储程序
- en: 'Let’s build a hex dump app that reads data from a file with StreamReader and
    writes its dump to the console. We’ll take advantage of the **ReadBlock method**
    in StreamReader, which reads a block of characters into a char array: you specify
    the number of characters you want to read, and it’ll either read that many characters
    or, if there are fewer than that many left in the file, it’ll read the rest of
    the file. Since we’re displaying 16 characters per line, we’ll read blocks of
    16 characters.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个十六进制转储应用程序，它从文件中使用StreamReader读取数据，并将其转储到控制台上。我们将利用StreamReader中的**ReadBlock方法**，它会读取一个字符块到char数组中：您可以指定要读取的字符数，它将读取指定数量的字符，或者如果文件中剩余的字符少于要求的数量，则读取剩余的所有字符。由于我们每行显示16个字符，因此我们将读取16个字符的块。
- en: '**Create a new console app called HexDump**. Before you add code, **run the
    app** to create the folder with the binary. Use Notepad or TextEdit to **create
    a text file called** *textdata.txt*, add some text to it, and put it in the same
    folder as the binary.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建一个名为HexDump的新控制台应用程序**。在添加代码之前，**运行该应用程序**以创建带有二进制文件的文件夹。使用记事本或TextEdit创建一个名为*textdata.txt*的文本文件，向其中添加一些文本，并将其放在与二进制文件相同的文件夹中。'
- en: Here’s the code from inside the Main method—it reads the *textdata.txt* file
    and writes a hex dump to the console. Make sure you add `using System.IO;` to
    the top.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是Main方法内部的代码——它读取*textdata.txt*文件并将十六进制转储写入控制台。确保在顶部添加`using System.IO;`。
- en: Note
  id: totrans-328
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**The ReadBlock method reads the next characters from its input into a byte
    array (sometimes referred to as a buffer). It blocks, which means it keeps executing
    and doesn’t return until it’s either read all of the characters you asked for
    or run out of data to read.**'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '**ReadBlock方法从其输入中读取下一个字符，并将其读入字节数组（有时称为缓冲区）。它会阻塞，这意味着它会继续执行，并且只有在读取完您请求的所有字符或者没有更多数据可读时才会返回。**'
- en: '![Images](assets/pg573.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/pg573.png)'
- en: Use Stream.Read to read bytes from a stream
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Stream.Read从流中读取字节
- en: 'The hex dumper works just fine for text files—but there’s a problem. **Copy
    the *binarydata.dat* file** you wrote with BinaryWriter into the same folder as
    your app, then change the app to read it:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文本文件，十六进制转储程序工作得很好——但存在问题。**复制你用BinaryWriter写入的*binarydata.dat*文件**到与你的应用程序相同的文件夹中，然后更改应用程序以读取它：
- en: '[PRE27]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now run your app. This time it prints something else—but it’s not quite right:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次运行你的应用程序。这次它打印出了其他内容——但不完全正确：
- en: '![Images](assets/pg574-1.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/pg574-1.png)'
- en: The text characters (“Hello`!`”) seem OK. But compare the output with the “Sharpen
    your pencil” solution—the bytes aren’t quite right. It looks like it replaced
    some bytes (86, e8, 81, f6, d8, and f5) with a different byte, fd. That’s because
    **StreamReader is built to read text files**, so it only reads **7-bit values**,
    or byte values up to 127 (7F in hex, or 1111111 in binary—which are 7 bits).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 文本字符（“Hello`!`”）看起来没问题。但是与“磨练你的铅笔”解决方案的输出进行比较——字节并不完全正确。看起来它用不同的字节fd替换了一些字节（86、e8、81、f6、d8和f5）。这是因为**StreamReader用于读取文本文件**，所以它只读取**7位值**，或者说最多127的字节值（十六进制7F，或二进制中的1111111）。
- en: 'So let’s do this right—by ***reading the bytes directly from the stream***.
    Modify the `using` block so it uses **File.OpenRead**, which opens the file and
    **returns a FileStream**. You’ll use the Stream’s Length property to keep reading
    until you’ve read all of the bytes in the file, and its Read method to read the
    next 16 bytes into the byte array buffer:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们做得对——通过***直接从流中读取字节***。修改`using`块以使用**File.OpenRead**，它打开文件并**返回一个FileStream**。你将使用流的Length属性继续读取，直到读取文件中的所有字节，并使用其Read方法将下一个16个字节读入字节数组缓冲区：
- en: '![Images](assets/pg574-2.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/pg574-2.png)'
- en: The rest of the code is the same, except for the line that sets `bufferContents:`
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的代码与设置`bufferContents:`行除外。
- en: '[PRE28]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You used the Encoding class earlier in the chapter to convert a byte array to
    a string. This byte array contains a single byte per character—that means it’s
    a valid UTF-8 string. That means you can use Encoding.UTF8.GetString to convert
    it. Since the Encoding class is in the System.Text namespace, you’ll need to add
    `using System.Text;` to the top of the file.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章前面使用过Encoding类将字节数组转换为字符串。这个字节数组每个字符包含一个字节，这意味着它是一个有效的UTF-8字符串。这意味着你可以使用Encoding.UTF8.GetString来转换它。由于Encoding类在System.Text命名空间中，你需要在文件顶部添加`using
    System.Text;`。
- en: 'Now run your app again. This time it prints the correct bytes instead of changing
    them to fd:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次运行你的应用程序。这次它打印出正确的字节而不是将它们改变为fd：
- en: '![Images](assets/pg574-3.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/pg574-3.png)'
- en: There’s just one more thing we can do to clean up the output. Many hex dump
    programs replace nontext characters with dots in the output. **Add this line to
    the end of the `for` loop:**
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事我们可以做来清理输出。许多十六进制转储程序会在输出中将非文本字符替换为点。**在`for`循环的末尾添加这一行：**
- en: '[PRE29]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now run your app again—this time the question marks are replaced with dots:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次运行你的应用程序——这次问号被点替换为点：
- en: '[PRE30]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Modify your hex dumper to use command-line arguments
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改你的十六进制转储程序以使用命令行参数
- en: 'Most hex dump programs are utilities that you run from the command line. You
    can dump a file by passing its name to the hex dumper as a **command-line argument**,
    like this: `C:\> HexDump myfile.txt`'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数十六进制转储程序是从命令行运行的实用程序。你可以通过将文件名作为**命令行参数**传递给十六进制转储器来转储文件，例如：`C:\> HexDump
    myfile.txt`
- en: 'Let’s modify the hex dumper to use command-line arguments. When you create
    a console app, C# makes the command-line arguments available as the **`args` string
    array** that gets passed to the Main method:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改十六进制转储程序以使用命令行参数。当你创建控制台应用程序时，C#将命令行参数作为**`args`字符串数组**传递给Main方法：
- en: '[PRE31]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We’ll modify the Main method to open a file and read its contents from a stream.
    The **File.OpenRead method** takes a filename as a parameter, opens it for reading,
    and returns a stream with the file contents.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改Main方法以打开文件并从流中读取其内容。**File.OpenRead方法**接受文件名作为参数，打开它以便读取，并返回一个带有文件内容的流。
- en: 'Change these lines in your Main method:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 更改Main方法中的这些行：
- en: '![Images](assets/pg575.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/pg575.png)'
- en: 'Now let’s use the command-line argument in the IDE by **changing the debug
    properties** to pass a command line to the program. **Right-click on the project**
    in the solution, then:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过**更改调试属性**来在IDE中使用命令行参数来传递给程序。在解决方案中**右键单击项目**，然后：
- en: '***On Windows,*** choose Properties, then click Debug, and enter the filename
    to dump in the Application arguments box (either the full path or the name of
    a file in the binary folder).'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***在 Windows 上，*** 选择属性，然后点击调试，在应用程序参数框中输入要转储的文件名（可以是完整路径或者二进制文件夹中文件的名称）。'
- en: '***On macOS,*** choose Options, expand Run >> Configurations, click Default,
    and enter the filename in the Arguments box.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***在 macOS 上，*** 选择选项，展开运行 >> 配置，点击默认，然后在参数框中输入文件名。'
- en: Note
  id: totrans-358
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure you right-click on the project, not the solution.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您右键单击项目，而不是解决方案。
- en: Now when you debug your app, its `args` array will contain the arguments you
    set in the project settings. ***Make sure you specify a valid filename when you
    set up the command-line arguments.***
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您调试应用程序时，其 `args` 数组将包含您在项目设置中设置的参数。***确保在设置命令行参数时指定有效的文件名。***
- en: Run your app from the command line
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从命令行运行您的应用程序
- en: 'You can also run the app from the command line, replacing `[filename]` with
    the name of a file (either the full path or the name of a file in the current
    directory):'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从命令行运行应用程序，用文件名（可以是完整路径或当前目录中的文件名）替换 `[filename]`：
- en: '***On Windows,*** Visual Studio builds an executable under the bin\Debug folder
    (in the same place you put your files to read), so you can run the executable
    directly from that folder. Open a command window, **`cd`** to the bin\Debug folder,
    and run `HexDump [filename].`'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***在 Windows 上，*** Visual Studio 会在 bin\Debug 文件夹下生成一个可执行文件（与您放置文件以读取的位置相同），因此您可以直接从该文件夹运行可执行文件。打开命令窗口，**`cd`**
    到 bin\Debug 文件夹，并运行 `HexDump [filename].`'
- en: '***On a Mac,*** you’ll need to **build a self-contained application**. Open
    a Terminal window, go to the project folder, and run this command: `dotnet publish
    -r osx-x64.`'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***在 Mac 上，*** 您需要**构建一个独立的应用程序**。打开一个终端窗口，进入项目文件夹，并运行以下命令：`dotnet publish
    -r osx-x64.`'
- en: 'The output will include a line like this: `HexDump -> /path-to-binary/osx-x64/publish/`'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将包含类似于这样的一行：`HexDump -> /path-to-binary/osx-x64/publish/`
- en: Open a Terminal window, `cd` to the full path that it printed, and run `./HexDump
    [filename].`
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，`cd` 到打印的完整路径，并运行 `./HexDump [filename].`
