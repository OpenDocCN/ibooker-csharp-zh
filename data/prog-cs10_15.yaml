- en: Chapter 15\. Files and Streams
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章 文件和流
- en: 'Most of the techniques I’ve shown so far in this book revolve around the information
    that lives in objects and variables. This kind of state is stored in a particular
    process’s memory, but to be useful, a program must interact with a broader world.
    This might happen through UI frameworks, but there’s one particular abstraction
    that can be used for many kinds of interactions with the outside world: a *stream*.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中我展示的大多数技术都围绕着存在于对象和变量中的信息。这种状态存储在特定进程的内存中，但为了实用，程序必须与更广泛的世界进行交互。这可能通过UI框架实现，但有一种特定的抽象可以用于与外部世界的许多种交互：*流*。
- en: 'Streams are so widely used in computing that you will no doubt already be familiar
    with them, and a .NET stream is much the same as in most other programming systems:
    it is simply a sequence of bytes. That makes a stream a useful abstraction for
    many commonly encountered features such as a file on disk or the body of an HTTP
    response. A console application uses streams to represent its input and output.
    If you run such a program interactively, the text that the user types at the keyboard
    becomes the program’s input stream, and anything the program writes to its output
    stream appears on screen. A program doesn’t necessarily know what kind of input
    or output it has, though—you can redirect these streams with console programs.
    For example, the input stream might actually provide the contents of a file on
    disk, or it could even be the output from some other program.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 流在计算中被如此广泛使用，以至于你无疑已经对它们非常熟悉了。在大多数其他编程系统中，.NET流与它们基本相同：它只是一系列字节。这使得流对于许多常见功能非常有用，比如磁盘上的文件或HTTP响应的主体。控制台应用程序使用流来表示其输入和输出。如果你以交互方式运行这样的程序，用户在键盘上输入的文本成为程序的输入流，程序写入其输出流的任何内容都会显示在屏幕上。但程序不一定知道它的输入或输出类型——你可以重定向这些流以用于控制台程序。例如，输入流实际上可以提供磁盘上文件的内容，或者甚至可以是其他程序的输出。
- en: Note
  id: totrans-3
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Not all I/O APIs are stream-based. For example, in addition to the input stream,
    the `Console` class provides a `ReadKey` method that gives information about exactly
    which key was pressed, which works only if the input comes from the keyboard.
    So, although you can write programs that do not care whether their input comes
    interactively or from a file, some programs are pickier.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的I/O API都是基于流的。例如，除了输入流之外，`Console` 类还提供了一个 `ReadKey` 方法，可以准确地返回哪个按键被按下，但这仅在输入来自键盘时有效。因此，虽然你可以编写不关心输入是交互式还是来自文件的程序，但有些程序更为挑剔。
- en: The stream APIs present you with raw byte data. However, it is possible to work
    at a different level. For example, there are text-oriented APIs that can wrap
    underlying streams, so you can work with characters or strings instead of raw
    bytes. There are also various *serialization* mechanisms that enable you to convert
    .NET objects into a stream representation, which you can turn back into objects
    later, making it possible to save an object’s state persistently or to send that
    state over the network. I’ll show these higher-level APIs later, but first, let’s
    look at the stream abstraction itself.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 流API向你提供原始的字节数据。然而，你也可以在不同的层次上操作。例如，有些面向文本的API可以包装底层流，这样你可以处理字符或字符串，而不是原始字节。还有各种*序列化*机制，允许你将.NET对象转换为流表示，稍后可以将其转换回对象，从而可以持久保存对象的状态或将其状态发送到网络上。我稍后会展示这些更高级的API，但首先让我们看看流抽象本身。
- en: The Stream Class
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Stream 类
- en: The `Stream` class is defined in the `System.IO` namespace. It is an abstract
    base class, with concrete derived types such as `FileStream` or `GZipStream` representing
    particular kinds of streams. [Example 15-1](#the_most_important_members_of_stream)
    shows the `Stream` class’s three most important members. It has several other
    members, but these are at the heart of the abstraction. (As you’ll see later,
    there are also asynchronous versions of `Read` and `Write`. .NET Core 3.1 and
    .NET also provide overloads that take one of the *span* types described in [Chapter 18](ch18.xhtml#ch_memory_efficiency)
    in place of an array. Everything I say in this section about these methods also
    applies to the asynchronous and span-based forms.)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream`类定义在`System.IO`命名空间中。它是一个抽象基类，具有具体派生类型，如`FileStream`或`GZipStream`，代表特定类型的流。[示例 15-1](#the_most_important_members_of_stream)展示了`Stream`类的三个最重要成员。它还有其他几个成员，但这些是抽象的核心。（稍后您将看到，还有`Read`和`Write`的异步版本。
    .NET Core 3.1和.NET还提供了使用[第18章](ch18.xhtml#ch_memory_efficiency)中描述的*span*类型之一替代数组的重载版本。本节中关于这些方法的所有内容也适用于异步和基于span的形式。）'
- en: Example 15-1\. The most important members of `Stream`
  id: totrans-8
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 15-1\. `Stream`的最重要成员
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Some streams are read-only. For example, when the input stream for a console
    application represents the keyboard or the output of some other program, there’s
    no meaningful way for the program to write to that stream. (And for consistency,
    even if you use input redirection to run a console application with a file as
    its input, the input stream will be read-only.) Some streams are write-only, such
    as the output stream of a console application. If you call `Read` on a write-only
    stream or `Write` on a read-only one, these methods throw a `NotSupportedException`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一些流是只读的。例如，当控制台应用程序的输入流表示键盘或其他程序的输出时，程序无法向该流写入有意义的内容。（即使使用输入重定向运行具有文件输入的控制台应用程序，输入流也是只读的。）一些流是只写的，例如控制台应用程序的输出流。如果在只写流上调用`Read`方法或在只读流上调用`Write`方法，则这些方法会抛出`NotSupportedException`异常。
- en: Tip
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Tip
- en: The `Stream` class defines various `bool` properties that describe a stream’s
    capabilities, so you don’t have to wait until you get an exception to find out
    what sort of stream you’ve got. You can check the `CanRead` or `CanWrite` properties.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream`类定义了各种描述流能力的`bool`属性，因此您不必等到出现异常才能知道流的类型。您可以检查`CanRead`或`CanWrite`属性。'
- en: Both `Read` and `Write` take a `byte[]` array as their first argument, and these
    methods copy data into or out of that array, respectively. The `offset` and `count`
    arguments that follow indicate the array element at which to start and the number
    of bytes to read or write; you do not have to use the whole array. Notice that
    there are no arguments to specify the offset within the stream at which to read
    or write. This is managed by the `Position` property—this starts at zero, but
    each time you read or write, the position advances by the number of bytes processed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`Read`和`Write`都以`byte[]`数组作为它们的第一个参数，并分别将数据复制到该数组中或从该数组中复制数据出来。随后的`offset`和`count`参数指示从数组的哪个元素开始，以及要读取或写入的字节数；您不必使用整个数组。请注意，没有参数指定要在流中的偏移量处读取或写入。这由`Position`属性管理
    —— 它从零开始，但每次读取或写入时，位置会根据处理的字节数前进。'
- en: Notice that the `Read` method returns an `int`. This tells you how many bytes
    were read from the stream—the method does not guarantee to provide the amount
    of data you requested. One obvious reason for this is that you could reach the
    end of the stream, so even though you may have asked to read 100 bytes into your
    array, there may have been only 30 bytes of data left between the current `Position`
    and the end of the stream. However, that’s not the only reason you might get less
    than you asked for, and this often catches people out, so for the benefit of people
    skim-reading this chapter, I’ll put this in a scary warning.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Read`方法返回一个`int`值。这告诉您从流中读取了多少字节 —— 该方法不保证提供您请求的数据量。这样做的一个明显原因是您可能已经达到流的末尾，因此即使您要求将100个字节读入数组中，当前`Position`和流的末尾之间可能只剩下30个字节的数据。然而，并不是这唯一可能导致您获取少于请求数据的原因，这经常会让人摸不着头脑，因此为了那些快速浏览本章节的人，我会做出一个警告。
- en: Warning
  id: totrans-15
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Warning
- en: If you ask for more than one byte at a time, a `Stream` is always free to return
    less data than you requested from `Read` for any reason. You should never presume
    that a call to `Read` returned as much data as it could, even if you have good
    reason to know that the amount you asked for will be available.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一次请求多个字节，`Stream` 可以出于任何原因返回少于你从 `Read` 请求的数据。你不应该假设调用 `Read` 返回了它所能返回的所有数据量，即使你有足够的理由知道你请求的数据量是可用的。
- en: The reason `Read` is slightly tricky is that some streams are live, representing
    a source of information that produces data gradually as the program runs. For
    example, if a console application is running interactively, its input stream can
    provide data only as fast as the user types; a stream representing data being
    received over a network connection can provide data only as fast as it arrives.
    If you call `Read` and you ask for more data than is currently available, a stream
    might wait until it has as much as you’ve asked for, but it doesn’t have to—it
    may return whatever data it has immediately. (The only situation in which it is
    obliged to wait before returning is if it currently has no data at all but is
    not yet at the end of the stream. It has to return at least one byte, because
    a `0` return value indicates the end of the stream.) If you want to ensure that
    you read a specific number of bytes, you’ll have to check whether `Read` returned
    fewer bytes than you wanted, and if necessary, keep calling it until you have
    what you need. [Example 15-2](#reading_a_specific_number_of_bytes) shows how to
    do this.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`Read` 稍微复杂的原因在于，某些流是实时的，代表程序运行时逐渐产生数据的信息源。例如，如果一个控制台应用程序在交互运行，其输入流只能在用户键入时提供数据；表示通过网络连接接收的数据的流只能在数据到达时提供数据。如果你调用
    `Read` 并请求的数据超过当前可用的数据量，流可能会等待直到它有你请求的那么多数据，但它不必这样做——它可能会立即返回任何它当前已经有的数据。（它在返回之前必须等待的唯一情况是，如果它当前没有任何数据但尚未到达流的末尾。它必须返回至少一个字节，因为返回值
    `0` 表示流的末尾。）如果你想确保读取特定数量的字节，你需要检查 `Read` 是否返回少于你想要的字节数，并在必要时继续调用它，直到你得到所需的数据。[示例
    15-2](#reading_a_specific_number_of_bytes) 展示了如何做到这一点。'
- en: Example 15-2\. Reading a specific number of bytes
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-2\. 读取特定数量的字节
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that this code checks for a `0` return value from `Read` to detect the
    end of the stream. Without that, it would loop forever if it reached the end of
    the stream before reading as much data as has been asked for. That means that
    if we do reach the end of the stream, this method will have to provide less data
    than the caller requested, so this may seem like it hasn’t really solved the problem.
    However, it does rule out the situation where you get less than you asked for
    despite not reaching the end of the stream. (You could change the method so that
    it throws an exception if it reaches the end of the stream before providing the
    specified number of bytes. That way, if the method returns at all, it is guaranteed
    to return exactly as many bytes as have been requested.)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这段代码检查了从 `Read` 返回的 `0` 值以检测流的末尾。如果没有这样的检查，如果在读取了被请求的数据量之前达到了流的末尾，它将永远循环下去。这意味着如果我们确实到达了流的末尾，这个方法将必须提供比调用者请求的数据少的数据量，因此这似乎并没有真正解决问题。然而，这确实排除了在没有到达流的末尾的情况下获得少于请求的数据量的情况。（你可以更改方法，使其在到达流的末尾之前提供指定数量的字节时抛出异常。这样，如果方法返回，它保证返回的字节数正好是所请求的数量。）
- en: '`Stream` offers a simpler way to read. The `ReadByte` method returns a single
    byte, unless you hit the end of the stream, at which point it returns a value
    of `−1`. (Its return type is `int`, enabling it to return any possible value for
    `byte` as well as negative values.) This avoids the problem of being handed back
    only some of the data you requested, because if you get anything back at all,
    you always get exactly one byte. However, it’s not especially convenient or efficient
    if you want to read larger chunks of data.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream` 提供了一个更简单的读取方法。`ReadByte` 方法返回一个单字节，除非你已达到流的末尾，在这种情况下它返回值 `-1`。（它的返回类型是
    `int`，允许它返回任何可能的 `byte` 值以及负值。）这避免了只返回部分请求数据的问题，因为如果你得到任何返回，你总是得到确切的一个字节。然而，如果你想读取更大的数据块，这并不特别方便或高效。'
- en: The `Write` method doesn’t have any of these issues. If it succeeds, it always
    accepts all of the data you provide. Of course, it might fail—it could throw an
    exception before it manages to write all of the data because of an error (e.g.,
    running out of space on disk or losing a network connection).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`Write`方法没有任何这些问题。如果成功，它始终接受您提供的所有数据。当然，它可能会失败——可能会因为错误（例如，磁盘空间不足或网络连接丢失）而在成功写入所有数据之前抛出异常。'
- en: Position and Seeking
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位置和寻址
- en: Streams automatically update their current position each time you read or write.
    As you can see in [Example 15-1](#the_most_important_members_of_stream), the `Position`
    property can be set, so you can attempt to move directly to a particular position.
    This is not guaranteed to work because it’s not always possible to support it.
    For example, a `Stream` that represents data being received over a TCP network
    connection could produce data indefinitely—as long as the connection remains open
    and the other end keeps sending data, the stream will continue to honor calls
    to `Read`. A connection could remain open for many days and might receive terabytes
    of data in that time. If such a stream let you set its `Position` property, enabling
    your code to go back and reread data received earlier, the stream would have to
    find somewhere to store every single byte it received just in case the code using
    the stream wants to see it again. Since that might involve storing more data than
    you have space for on disk, this is clearly not practical, so some streams will
    throw `NotSupportedException` when you try to set the `Position` property. (There’s
    a `CanSeek` property you can use to discover whether a particular stream supports
    changing the position, so just like with read-only and write-only streams, you
    don’t have to wait until you get an exception to find out whether it will work.)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每次读取或写入时，流会自动更新其当前位置。如您在[示例 15-1](#the_most_important_members_of_stream)中所见，`Position`属性可以设置，因此您可以尝试直接移动到特定位置。这并不保证能够成功，因为并非总是可能支持它。例如，代表通过TCP网络连接接收的数据的`Stream`可以无限产生数据——只要连接保持打开且另一端继续发送数据，流将继续响应对`Read`的调用。连接可能保持打开多天，并在此期间接收到数TB的数据。如果这样的流允许您设置其`Position`属性，使您的代码能够返回并重新读取先前接收到的数据，则流必须找到存储每个接收到的字节的地方，以防万一代码希望再次查看它。由于这可能涉及存储比磁盘上有空间更多的数据，显然是不切实际的，因此某些流在尝试设置`Position`属性时会抛出`NotSupportedException`。（有一个`CanSeek`属性，您可以使用它来发现特定流是否支持更改位置，因此就像只读和只写流一样，您不必等到出现异常才能找出它是否有效。）
- en: As well as the `Position` property, `Stream` also defines a `Seek` method, whose
    signature is shown in [Example 15-3](#the_seek_method). This lets you specify
    the position you require relative to the stream’s current position. (This also
    throws `NotSupportedException` on streams that don’t support seeking.)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Position`属性外，`Stream`还定义了一个`Seek`方法，其签名如[示例 15-3](#the_seek_method)所示。这使您可以相对于流的当前位置指定所需的位置。（对于不支持寻址的流，这也会抛出`NotSupportedException`。）
- en: Example 15-3\. The `Seek` method
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-3\. `Seek`方法
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you pass `SeekOrigin.Current` as the second argument, it will set the position
    by adding the first argument to the current position. You can pass a negative
    `offset` if you want to move backward. You can also pass `SeekOrigin.End` to set
    the position to be some specified number of bytes from the end of the stream.
    Passing `Seek​Ori⁠gin.Begin` has the same logical effect as just setting `Position`—it
    sets the position relative to the start of the stream.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`SeekOrigin.Current`作为第二个参数传递，它将通过将第一个参数添加到当前位置来设置位置。如果要向后移动，可以传递负的`offset`。还可以传递`SeekOrigin.End`将位置设置为距离流末尾指定的字节数。传递`Seek​Ori⁠gin.Begin`与仅设置`Position`具有相同的逻辑效果——它将相对于流的起始位置设置位置。
- en: Flushing
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刷新
- en: As with many stream APIs on other programming systems, writing data to a `Stream`
    does not necessarily cause the data to reach its destination immediately. When
    a call to `Write` returns, all you know is that it has copied your data somewhere;
    but that might be a buffer in memory, not the final target. For example, if you
    write a single byte to a stream representing a file on a storage device, the stream
    object will typically defer writing that to the drive until it has enough bytes
    to make it worth the effort. Storage devices are block-based, meaning that writes
    happen in fixed-size chunks, typically several kilobytes in size, so it generally
    makes sense to wait until there’s enough data to fill a block before writing anything
    out.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他编程系统上许多流API一样，在`Stream`中写入数据不一定会立即使数据到达目的地。当调用`Write`时，你只知道它已经将你的数据复制到某个地方；但那可能是内存中的缓冲区，而不是最终的目标。例如，如果你向代表存储设备上文件的流写入单个字节，流对象通常会推迟将其写入驱动器，直到有足够的字节使得这样做值得。存储设备是基于块的，意味着写入以固定大小的块发生，通常是几千字节大小，因此等到有足够的数据来填充一个块再进行写入是有意义的。
- en: This buffering is usually a good thing—it improves write performance while enabling
    you to ignore the details of how the disk works. However, a downside is that if
    you write data only occasionally (e.g., when writing error messages to a logfile),
    you could easily end up with long delays between the program writing data to a
    stream and that data reaching the disk. This could be perplexing for someone trying
    to diagnose a problem by looking at the logfiles of a program that’s currently
    running. And more insidiously, if your program crashes, anything in a stream’s
    buffers that has not yet made it to the storage device will probably be lost.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种缓冲通常是件好事——它提高了写入性能，同时使你可以忽略磁盘工作的细节。然而，缺点是如果你偶尔写入数据（例如将错误消息写入日志文件时），你可能会在程序写入数据到流和数据到达磁盘之间遇到长时间的延迟。对于试图通过查看当前正在运行的程序日志文件来诊断问题的人来说，这可能会令人困惑。更隐秘的是，如果你的程序崩溃，流缓冲区中尚未到达存储设备的任何数据可能会丢失。
- en: The `Stream` class therefore offers a `Flush` method. This lets you tell the
    stream that you want it to do whatever work is required to ensure that any buffered
    data is written to its target, even if that means making suboptimal use of the
    buffer.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Stream`类提供了`Flush`方法。这让你告诉流，你希望它执行任何必要的工作，以确保任何缓冲数据都被写入到其目标，即使这意味着对缓冲区的使用不是最优的情况。
- en: Warning
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: When using a `FileStream`, the `Flush` method does not necessarily guarantee
    that the data being flushed has made it to disk yet. It merely makes the stream
    pass the data to the OS. Before you call `Flush`, the OS hasn’t even seen the
    data, so if you were to terminate the process suddenly, the data would be lost.
    After `Flush` has returned, the OS has everything your code has written, so the
    process could be terminated without loss of data. However, the OS may perform
    additional buffering of its own, so if the power fails before the OS gets around
    to writing everything to disk, the data will still be lost. If you need to guarantee
    that data has been written persistently (rather than merely ensuring that you’ve
    handed it to the OS), you will also need to either use the `WriteThrough` flag,
    described in [“FileStream Class”](#filestream_class), or call the `Flush` overload
    that takes a `bool`, passing `true` to force flushing to the storage device.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`FileStream`时，`Flush`方法并不一定保证刷新的数据已经写入磁盘。它只是让流将数据传递给操作系统。在调用`Flush`之前，操作系统甚至还没有看到数据，因此如果突然终止进程，数据将会丢失。在`Flush`返回后，操作系统已经拥有你的代码已经写入的所有数据，因此可以在没有数据丢失的情况下终止进程。然而，操作系统可能会执行自己的额外缓冲，因此如果在操作系统开始将所有数据写入磁盘之前电源失败，数据仍可能丢失。如果需要确保数据已经持久写入（而不仅仅是确保你已经将数据交给操作系统），你还需要使用`WriteThrough`标志，描述在["FileStream
    Class"](https://example.org/filestream_class)中，或者调用带有`bool`参数的`Flush`重载，传递`true`以强制刷新到存储设备。
- en: A stream automatically flushes its contents when you call `Dispose`. You need
    to use `Flush` only when you want to keep a stream open after writing out buffered
    data. It is particularly important if there will be extended periods during which
    the stream is open but inactive. (If the stream represents a network connection,
    and if your application depends on prompt data delivery—this would be the case
    in an online chat application or game, for example—you would call `Flush` even
    if you expect only fairly brief periods of inactivity.)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `Dispose` 时，流会自动刷新其内容。只有在希望在写出缓冲数据后保持流打开状态时，才需要使用 `Flush`。如果流在打开但不活动期间会有较长时间，这一点尤其重要。（如果流代表网络连接，并且如果您的应用程序依赖于及时数据传递
    —— 例如在线聊天应用程序或游戏 —— 即使您期望只有相对短暂的不活动期间，也应调用 `Flush`。）
- en: Copying
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制
- en: Copying all of the data from one stream to another is occasionally useful. It
    wouldn’t be hard to write a loop to do this, but you don’t have to, because the
    `Stream` class’s `CopyTo` method (or the equivalent `CopyToAsync`) does it for
    you. There’s not much to say about it. The main reason I’m mentioning it is that
    it’s not uncommon for developers to write their own version of this method because
    they didn’t know the functionality was built into `Stream`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有时将所有数据从一个流复制到另一个流会很有用。你可以轻易地编写一个循环来做到这一点，但你不必这样做，因为 `Stream` 类的 `CopyTo` 方法（或等效的
    `CopyToAsync`）已经为你实现了这一功能。关于它，没有太多可以说的。我提到它的主要原因是，开发人员通常因为不知道 `Stream` 中内置了这个功能，所以会自己编写这个方法的版本。
- en: Length
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 长度
- en: Some streams are able to report their length through the predictably named `Length`
    property. As with `Position`, this property’s type is `long`—`Stream` uses 64-bit
    numbers because streams often need to be larger than 2 GB, which would be the
    upper limit if sizes and positions were represented with `int`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一些流能够通过名为 `Length` 的属性报告它们的长度。与 `Position` 一样，该属性的类型为 `long` —— `Stream` 使用
    64 位数值，因为流通常需要比 2GB 更大的容量，如果使用 `int` 表示大小和位置，则会受到上限的限制。
- en: '`Stream` also defines a `SetLength` method that lets you define the length
    of a stream (where supported). You might think about using this when writing a
    large quantity of data to a file, to ensure that there is enough space to contain
    all the data you wish to write—better to get an `IOException` before you start
    than wasting time on a doomed operation and potentially causing system-wide problems
    by using up all of the free space. However, many filesystems support sparse files,
    letting you create files far larger than the available free space, so in practice
    you might not see any error until you start writing nonzero data. Even so, if
    you specify a length that is longer than the filesystem supports, `SetLength`
    will throw an `ArgumentException`.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream` 还定义了一个 `SetLength` 方法，用于在支持的情况下定义流的长度。在向文件写入大量数据时，可以考虑使用此方法，以确保有足够的空间来容纳所有希望写入的数据
    —— 最好在开始之前遇到 `IOException`，而不是浪费时间进行注定失败的操作，并可能通过使用所有可用的空闲空间来引起系统范围的问题。然而，许多文件系统支持稀疏文件，允许创建远远大于可用空间的文件，因此在实践中，您可能直到开始写入非零数据时才会看到任何错误。即使如此，如果指定的长度超出文件系统支持的长度，`SetLength`
    将抛出 `ArgumentException`。'
- en: Not all streams support length operations. The `Stream` class documentation
    says that the `Length` property is available only on streams that support `CanSeek`.
    This is because streams that support seeking are typically ones where the whole
    content of the stream is known and accessible up front. Seeking is unavailable
    on streams where the content is produced at runtime (e.g., input streams representing
    user input or streams representing data received over the network), and in those
    cases the length is also very often not known in advance. As for `SetLength`,
    the documentation states that this is supported only on streams that support both
    writing and seeking. (As with all members representing optional features, `Length`
    and `SetLength` will throw a `NotSupportedException` if you try to use these members
    on streams that do not support them.)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有流支持长度操作。`Stream` 类文档指出，`Length` 属性仅在支持 `CanSeek` 的流上可用。这是因为支持寻址的流通常是那些整个流内容在开始时就已知并且可访问的流。在内容在运行时生成的流上（例如代表用户输入的输入流或代表网络接收数据的流），通常也不会预先知道长度。至于
    `SetLength`，文档说明仅在既支持写入又支持寻址的流上受支持。（与所有表示可选功能的成员一样，如果在不支持它们的流上尝试使用这些成员，`Length`
    和 `SetLength` 将抛出 `NotSupportedException`。）
- en: Disposal
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处置
- en: Some streams represent resources external to the .NET runtime. For example,
    `FileStream` provides stream access to the contents of a file, so it needs to
    obtain a file handle from the OS. It’s important to close handles when you’re
    done with them; otherwise you might prevent other applications from being able
    to use the file. Consequently, the `Stream` class implements the `IDisposable`
    interface (described in [Chapter 7](ch07.xhtml#ch_object_lifetime)) so that it
    can know when to do that. And, as I mentioned earlier, buffering streams such
    as `FileStream` flush their buffers when you call `Dispose`, before closing handles.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一些流表示.NET运行时外部的资源。例如，`FileStream`提供对文件内容的流访问，因此它需要从操作系统获取文件句柄。当你使用完毕后，关闭句柄非常重要；否则可能会阻止其他应用程序使用该文件。因此，`Stream`类实现了`IDisposable`接口（在[第7章](ch07.xhtml#ch_object_lifetime)中描述），以便在必要时进行处理。正如我之前提到的，缓冲流如`FileStream`在调用`Dispose`之前会刷新它们的缓冲区，然后关闭句柄。
- en: 'Not all stream types depend on `Dispose` being called: `MemoryStream` works
    entirely in memory, so the GC would be able to take care of it. But in general,
    if you caused a stream to be created, you should call `Dispose` when you no longer
    need it.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有流类型都依赖于调用`Dispose`：例如，`MemoryStream`完全在内存中工作，因此GC可以负责处理它。但通常情况下，如果你创建了一个流，当你不再需要它时应该调用`Dispose`。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There are some situations in which you will be provided with a stream, but it
    is not your job to dispose it. For example, ASP.NET Core can provide streams to
    represent data in HTTP requests and responses. It creates these for you and then
    disposes them after you’ve used them, so you should not call `Dispose` on them.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，你会得到一个流，但并不是你的工作来处理它。例如，ASP.NET Core可以提供流来表示HTTP请求和响应中的数据。它会为你创建这些流，并在你使用完之后进行处理，因此你不应该调用`Dispose`来处理它们。
- en: Confusingly, the `Stream` class also has a `Close` method. This is an accident
    of history. The first public beta release of .NET 1.0 did not define `IDisposable`,
    and C# did not have `using` statements—the keyword was only for `using` directives,
    which bring namespaces into scope. The `Stream` class needed some way of knowing
    when to clean up its resources, and since there was not yet a standard way to
    do this, it invented its own idiom. It defined a `Close` method, which was consistent
    with the terminology used in many stream-based APIs in other programming systems.
    `IDisposable` was added before the final release of .NET 1.0, and the `Stream`
    class added support for this, but it left the `Close` method in place; removing
    it would have disrupted a lot of early adopters who had been using the betas.
    But `Close` is redundant, and the documentation actively advises against using
    it. It says you should call `Dispose` instead (through a `using` statement if
    that is convenient). There’s no harm in calling `Close`—there’s no practical difference
    between that and `Dispose`—but `Dispose` is the more common idiom and is therefore
    preferred.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 令人困惑的是，`Stream`类也有一个`Close`方法。这是历史的偶然。在.NET 1.0的第一个公共测试版发布时，并没有定义`IDisposable`，并且C#也没有`using`语句——这个关键字仅用于`using`指令，用于将命名空间引入作用域。`Stream`类需要一种方式来知道何时清理其资源，但当时还没有一个标准的方法，所以它发明了自己的习惯用语。它定义了一个`Close`方法，这与其他编程系统中许多基于流的API使用的术语是一致的。在.NET
    1.0正式发布之前添加了`IDisposable`，并且`Stream`类增加了对其的支持，但保留了`Close`方法；如果移除它，将会影响到许多早期采用者，因为他们一直在使用测试版。但是，`Close`是多余的，并且文档明确建议不要使用它。文档说应该使用`Dispose`（通过`using`语句如果方便的话）。调用`Close`没有害处——它与`Dispose`之间没有实际区别——但`Dispose`是更常见的习惯用语，因此更为推荐。
- en: Asynchronous Operation
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步操作
- en: 'The `Stream` class offers asynchronous versions of `Read` and `Write`. Be aware
    that there are two forms. `Stream` first appeared in .NET 1.0, so it supported
    what was then the standard asynchronous mechanism, the Asynchronous Programming
    Model (APM, described in [Chapter 16](ch16.xhtml#ch_multithreading)) through the
    `BeginRead`, `EndRead`, `BeginWrite`, and `EndWrite` methods. This model is now
    deprecated, having been superseded by the newer Task-based Asynchronous Pattern
    (or TAP, also described in [Chapter 16](ch16.xhtml#ch_multithreading)). `Stream`
    supports this through its `ReadAsync` and `WriteAsync` methods. There are two
    more operations that did not originally have any kind of asynchronous form that
    now have TAP versions: `FlushAsync` and `CopyToAsync`. (These support only TAP,
    because APM was already deprecated by the time Microsoft added these methods.)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream` 类提供了 `Read` 和 `Write` 的异步版本。请注意有两种形式。`Stream` 首次出现在 .NET 1.0 中，因此它支持当时的标准异步机制，即异步编程模型（APM，见[第16章](ch16.xhtml#ch_multithreading)）。通过
    `BeginRead`、`EndRead`、`BeginWrite` 和 `EndWrite` 方法。此模型现已弃用，并已被较新的基于任务的异步模式（或TAP，也见[第16章](ch16.xhtml#ch_multithreading)）所取代。`Stream`
    通过其 `ReadAsync` 和 `WriteAsync` 方法支持此模式。还有两个操作最初没有任何异步形式，现在有了 TAP 版本：`FlushAsync`
    和 `CopyToAsync`。（这些仅支持TAP，因为APM在Microsoft添加这些方法时已经弃用。）'
- en: Warning
  id: totrans-50
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Avoid the old APM-based `Begin`/`End` forms of `Read` and `Write`. They weren’t
    present at all in early versions of .NET Core, nor in .NET Standard prior to 2.0\.
    They reappeared to make it easier to migrate existing code from .NET Framework
    to .NET Core, so they are supported only for legacy scenarios.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用基于旧的 APM 的 `Begin`/`End` 形式的 `Read` 和 `Write`。在 .NET Core 的早期版本和 .NET Standard
    2.0 之前，它们根本不存在。它们重新出现是为了更容易地将现有代码从 .NET Framework 迁移到 .NET Core，因此仅支持传统场景。
- en: Some stream types implement asynchronous operations using very efficient techniques
    that correspond directly to the asynchronous capabilities of the underlying OS.
    (`FileStream` does this, as do the various streams .NET can provide to represent
    content from network connections.) You may come across libraries with custom stream
    types that do not do this, but even then, the asynchronous methods will be available,
    because the base `Stream` class can fall back to using multithreaded techniques
    instead.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一些流类型利用非常高效的技术实现异步操作，直接对应于底层操作系统的异步能力。(`FileStream` 就是这样做的，以及.NET可以提供的各种用于表示网络连接内容的流。)
    您可能会遇到具有自定义流类型的库，这些流类型不会这样做，但即使如此，异步方法也会可用，因为基本的 `Stream` 类可以退回到使用多线程技术。
- en: One thing you need to be careful of when using asynchronous reads and writes
    is that a stream only has a single `Position` property. Reads and writes depend
    on the current `Position` and also update it when they are done, so in general
    you must avoid starting a new operation before one already in progress is complete.
    However, if you wish to perform multiple concurrent read or write operations from
    a particular file, `FileStream` has special handling for this. If you tell it
    that you will be using the file in asynchronous mode, operations use the value
    `Position` has at the start of the operation, and once an asynchronous read or
    write has started, you are allowed to change `Position` and start another operation
    without waiting for all the previous ones to complete. But this only applies to
    `FileStream`, and only when the file was opened in asynchronous mode. Alternatively,
    instead of using `FileStream`, you could use the new `RandomAccess` class described
    later in this chapter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用异步读取和写入时需要注意的一点是，流只有一个 `Position` 属性。读取和写入取决于当前的 `Position`，并在完成时更新它，因此通常必须避免在已经开始的操作完成之前启动新的操作。但是，如果您希望从特定文件执行多个并发读取或写入操作，`FileStream`
    对此有特殊处理。如果告诉它您将在异步模式下使用文件，则操作使用操作开始时 `Position` 的值，一旦异步读取或写入开始，您可以更改 `Position`
    并启动另一个操作，而无需等待所有先前的操作完成。但这仅适用于 `FileStream`，且仅在文件以异步模式打开时。或者，可以使用稍后在本章描述的新 `RandomAccess`
    类，而不是使用 `FileStream`。
- en: .NET Core 3.1 and .NET 5.0 and later offer `IAsyncDisposable`, an asynchronous
    form of `Dispose`. The `Stream` class implements this, because disposal often
    involves flushing, which is a potentially slow operation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 3.1 和 .NET 5.0 及更高版本提供了 `IAsyncDisposable`，这是 `Dispose` 的异步形式。`Stream`
    类实现了这一点，因为处置通常涉及刷新，这是一种潜在的缓慢操作。
- en: Concrete Stream Types
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 具体的流类型
- en: The `Stream` class is abstract, so to use a stream, you’ll need a concrete derived
    type. In some situations, this will be provided for you—the ASP.NET Core web framework
    supplies stream objects representing HTTP request and response bodies, for example,
    and the client-side `HttpClient` class will do something similar. But sometimes
    you’ll need to create a stream object yourself. This section describes a few of
    the more commonly used types that derive from `Stream`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream` 类是抽象的，因此要使用流，你需要一个具体的派生类型。在某些情况下，这些类型将由框架提供给你——例如，ASP.NET Core Web
    框架提供了表示 HTTP 请求和响应主体的流对象，客户端的 `HttpClient` 类会执行类似操作。但有时你需要自己创建一个流对象。本节描述了一些常用的从
    `Stream` 派生的类型。'
- en: The `FileStream` class represents a file on the filesystem. I will describe
    this in [“Files and Directories”](#files_and_directories).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileStream` 类表示文件系统上的文件。我将在[“文件和目录”](#files_and_directories)中描述这一点。'
- en: '`MemoryStream` lets you create a stream on top of a `byte[]` array. You can
    either take an existing `byte[]` and wrap it in a `MemoryStream`, or you can create
    a `MemoryStream` and then populate it with data by calling `Write` (or the asynchronous
    equivalent). You can retrieve the populated `byte[]` once you’re done by calling
    either `ToArray` or `GetBuffer`. (`ToArray` allocates a new array, with the size
    based on the number of bytes actually written. `GetBuffer` is more efficient because
    it returns the underlying array `MemoryStream` is using, but unless the writes
    happened to fill it completely, the array returned will typically be oversized,
    with some unused space at the end.) This class is useful when you are working
    with APIs that require a stream and you don’t have one for some reason. For example,
    most of the serialization APIs described later in this chapter work with streams,
    but you might end up wanting to use that in conjunction with some other API that
    works in terms of `byte[]`. `MemoryStream` lets you bridge between those two representations.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`MemoryStream` 允许你在 `byte[]` 数组之上创建一个流。你可以取一个现有的 `byte[]` 并将其包装在 `MemoryStream`
    中，或者你可以创建一个 `MemoryStream`，然后通过调用 `Write`（或异步等效）来填充数据。完成后，你可以通过调用 `ToArray` 或
    `GetBuffer` 来检索填充的 `byte[]`。(`ToArray` 分配一个基于实际写入的字节数的新数组。`GetBuffer` 更有效率，因为它返回
    `MemoryStream` 正在使用的底层数组，但除非写入恰好完全填满它，否则返回的数组通常会超过实际使用的部分，在末尾有一些未使用的空间。) 当你需要与需要流的
    API 一起工作但由于某些原因没有流时，此类非常有用。例如，本章后面描述的大多数序列化 API 都与流一起工作，但你可能希望将其与某些以 `byte[]`
    为单位的其他 API 结合使用。`MemoryStream` 允许你在这两种表示之间建立桥梁。'
- en: 'Both Windows and Unix define an interprocess communication (IPC) mechanism
    enabling you to connect two processes through a stream. Windows calls these *named
    pipes*. Unix also has a mechanism with that name, but it is completely different;
    it does, however, offer a mechanism similar to Windows named pipes: *domain sockets*.
    Although the precise details of Windows named pipes and Unix domain sockets differ,
    the various classes derived from `PipeStream` provide a common abstraction for
    both in .NET.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 和 Unix 都定义了一种进程间通信（IPC）机制，通过流连接两个进程。Windows 将其称为 *命名管道*。Unix 也有一个同名的机制，但完全不同；不过它确实提供了类似于
    Windows 命名管道的机制：*域套接字*。虽然 Windows 命名管道和 Unix 域套接字的具体细节不同，但在 .NET 中，从 `PipeStream`
    派生的各种类提供了对两者的共同抽象。
- en: '`BufferedStream` derives from `Stream` but also takes a `Stream` in its constructor.
    It adds a layer of buffering, which is useful if you want to perform small reads
    or writes on a stream that is designed to work best with larger operations. (You
    don’t need to use this with `FileStream` because that has its own built-in buffering
    mechanism.)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`BufferedStream` 是从 `Stream` 派生出来的，但在其构造函数中还接受一个 `Stream`。它添加了一个缓冲层，如果你想在设计为更大操作最佳的流上执行小读取或写入操作，这将非常有用。（对于
    `FileStream`，你不需要使用这个，因为它有其自己内置的缓冲机制。）'
- en: There are various stream types that transform the contents of other streams
    in some way. For example, `DeflateStream`, `GZipStream`, and `BrotliStream` implement
    three widely used compression algorithms. You can wrap these around other streams
    to compress the data written to the underlying stream or to decompress the data
    read from it. (These just provide the lowest-level compression service. If you
    want to work with the popular ZIP format for packages of compressed files, use
    the `ZipArchive` class.) There’s also a class called `CryptoStream`, which can
    encrypt or decrypt the contents of other streams using any of the wide variety
    of encryption mechanisms supported in .NET.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种流类型可以以某种方式转换其他流的内容。例如，`DeflateStream`、`GZipStream` 和 `BrotliStream` 实现了三种广泛使用的压缩算法。你可以将它们包装在其他流周围，以压缩写入底层流的数据，或者解压读取自底层流的数据。（这些只提供了最低级别的压缩服务。如果你想处理流行的ZIP格式，用于压缩文件包，请使用
    `ZipArchive` 类。）还有一个称为 `CryptoStream` 的类，可以使用.NET支持的各种加密机制之一加密或解密其他流的内容。
- en: One Type, Many Behaviors
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个类型，多种行为
- en: As you’ve now seen, the abstract base class `Stream` gets used in a wide range
    of scenarios. It is arguably an abstraction that has been stretched a little too
    thin. The presence of properties such as `CanSeek` that tell you whether the particular
    `Stream` you have can be used in a certain way is arguably a symptom of an underlying
    problem, an example of something known as a *code smell*. .NET streams did not
    invent this particular one-size-fits-all approach—it was popularized by Unix and
    the C programming language’s standard library a long time ago. The problem is
    that when writing code that deals with a `Stream`, you might not know what sort
    of thing you are dealing with.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你现在所见，抽象基类 `Stream` 在各种场景中被广泛使用。可以说，这是一个有点过于泛化的抽象。例如，像 `CanSeek` 这样的属性告诉你，你所拥有的特定
    `Stream` 是否可以以某种方式使用，这可能是一个潜在问题的症状，是一种被称为 *代码异味* 的示例。.NET流并不是发明这种一刀切的方法——它早在Unix和C编程语言的标准库中就很流行了。问题在于，当编写处理
    `Stream` 的代码时，你可能不知道正在处理的是什么类型的东西。
- en: 'There are many different ways to use a `Stream`, but three usage styles come
    up a lot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的方法可以使用 `Stream`，但经常遇到三种使用样式：
- en: Sequential access of a sequence of bytes
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字节序列的顺序访问
- en: Random access, with a presumption of efficient caching
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机访问，假定具有高效的缓存机制
- en: Access to some underlying capability of a device or system
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问设备或系统某些底层能力
- en: As you know, not all `Stream` implementations support all three models—if `CanSeek`
    returns `false`, that rules out the middle option. But what is less obvious is
    that even when these properties indicate that a capability is available, not all
    streams support all usage models equally efficiently.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，不是所有的`Stream`实现都支持这三种模型——如果`CanSeek`返回`false`，那就排除了中间选项。但不太明显的是，即使这些属性表明某种能力可用，也不是所有流都同样高效地支持所有使用模型。
- en: 'For example, I worked on a project that used a library for accessing files
    in a cloud-hosted storage service that was able to represent those files with
    `Stream` objects. This looks convenient because you can pass those to any API
    that works with a `Stream`. However, it was designed very much for the third style
    of use in the preceding list: every single call to `Read` (or `ReadAsync`) would
    cause the library to make an HTTP request to the storage service. We had initially
    hoped to use this with another library that knew how to parse Parquet files (a
    binary tabular data storage format widely used in high-volume data processing).
    However, it turned out that the library was expecting a stream that supported
    the second type of access: it jumped back and forth through the file, making large
    numbers of fairly small reads. It worked perfectly well with the `FileStream`
    type I’ll be describing later, because that supports the first two modes of use
    well. (For the second style, it relies on the OS to do the caching.) But it would
    have been a performance disaster to plug a `Stream` from the storage service library
    directly into the Parquet parsing library.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我曾经参与过一个项目，该项目使用了一个库来访问云托管存储服务中的文件，并能用`Stream`对象表示这些文件。这看起来很方便，因为你可以将它们传递给任何可以处理`Stream`的API。然而，它的设计非常适合前述列表中的第三种使用方式：每次调用`Read`（或`ReadAsync`）都会导致该库向存储服务发出HTTP请求。最初我们希望能够将其与另一个能够解析Parquet文件（一种广泛用于大容量数据处理的二进制表格数据存储格式）的库一起使用。然而，事实证明该库期望的是支持第二种访问方式的流：它会在文件中前后跳跃，进行大量相对较小的读取。它与我稍后将要描述的`FileStream`类型完美配合，因为后者很好地支持了前两种使用模式。（对于第二种模式，它依赖于操作系统进行缓存。）但是，直接将来自存储服务库的`Stream`直接插入Parquet解析库将会导致性能灾难。
- en: 'It’s not always obvious when you have a mismatch of this kind. In this example,
    the properties reporting capabilities such as `CanSeek` gave no clue that there
    would be a problem. And applications that use Parquet files often use some sort
    of remote storage service, rather than the local filesystem, so there was no obvious
    reason to think that this library would presume that any `Stream` would offer
    local filesystem-like caching. It did technically work when we tried it: the storage
    library `Stream` worked hard to do everything asked of it, and the code worked
    correctly…eventually. So whenever you use a `Stream`, it’s important to make sure
    you have fully understood what access patterns it will be subjected to and how
    efficiently it supports those patterns.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当你遇到这种类型的不匹配时，往往并不明显。在这个例子中，像`CanSeek`这样的属性报告能力并没有暗示会有问题。而使用Parquet文件的应用程序通常使用某种远程存储服务，而不是本地文件系统，因此没有明显的理由认为该库会假设任何`Stream`都会提供类似本地文件系统的缓存。当我们尝试时，技术上它确实能够工作：存储库的`Stream`努力做到了一切所需，并且代码最终是正确的......但是要记住，每当你使用`Stream`时，确保你完全理解它将被应用的访问模式及其对这些模式的高效支持是非常重要的。
- en: In some cases you might be able to bridge the gap. The `BufferedStream` class
    can often take a `Stream` designed only for the third usage style mentioned previously
    and adapt it for the first style of usage. However, there’s nothing in the runtime
    libraries that can add support for the second style of usage to a `Stream` that
    doesn’t already innately support it. (This is typically only available either
    with streams that represent something already fully in memory or that wrap some
    local API that does the caching for you, such as the OS filesystem APIs.) In these
    cases you will either need to rethink your design (e.g., make a local copy of
    the `Stream` contents), change the way that the `Stream` is consumed, or write
    some sort of custom caching adapter. (In the end, we wrote an adapter that augmented
    the capabilities of `BufferedStream` with just enough random access caching to
    solve the performance problems.)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能能够弥合这种差距。`BufferedStream`类通常可以接受仅设计用于前述第三种使用方式的`Stream`并使其适应第一种使用方式。然而，在运行库中没有任何内容可以为不本能地支持第二种使用方式的`Stream`添加对其的支持。（通常只有代表已完全在内存中或包装某些本地API（例如操作系统文件系统API）进行缓存的流才可用。）在这些情况下，你将需要重新考虑你的设计（例如，制作`Stream`内容的本地副本），更改`Stream`的使用方式，或编写某种自定义缓存适配器。（最终，我们编写了一个适配器，通过增加`BufferedStream`的能力，仅添加了足够的随机访问缓存来解决性能问题。）
- en: Random Access and Scatter/Gather I/O Without Stream
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无须`Stream`的随机访问和分散/聚集I/O
- en: '.NET 6.0 adds a new class to the `System.IO` namespace: `RandomAccess`. It
    enables file read and write operations without using `Stream`. It can simplify
    scenarios in which you want to perform multiple concurrent reads from a single
    file. It can also perform single read or write operations that operate across
    data that is not in a single contiguous block of memory, taking advantage of the
    underlying OS’s ability to handle such reads and writes efficiently.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`.NET 6.0` 在 `System.IO` 命名空间中新增了一个新类：`RandomAccess`。它可以在不使用 `Stream` 的情况下进行文件读写操作。它可以简化需要从单个文件执行多个并发读取的场景。它还可以执行跨越不是单个连续内存块的数据的单个读取或写入操作，利用底层操作系统处理此类读写的高效能力。'
- en: To use `RandomAccess`, you must open a file with the `File` class’s `OpenHandle`
    method (also new in .NET 6.0), which returns a `SafeFileHandle`, a disposable
    wrapper around an OS file handle. You can pass this to the various `Read`, `ReadAsync`,
    `Write`, and `WriteAsync` static methods offered by `RandomAccess`. All of the
    read and write methods require you to pass the offset within the file, unlike
    `Stream`, which remembers the current `Position` for you. The advantage of passing
    the offset with each method is that it avoids the problems described earlier with
    performing multiple concurrent operations. [Example 15-4](#randomaccess_read)
    uses this to read data directly from a Windows *.exe* file. Notice that as with
    the `Stream` class, reads may fetch less data than you ask for, so in cases where
    you need to read a particular number of bytes, you will need to write a loop that
    can keep reading until the required amount of data has been fetched.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `RandomAccess`，必须使用 `.NET 6.0` 中新增的 `File` 类的 `OpenHandle` 方法打开文件，该方法返回
    `SafeFileHandle`，它是围绕操作系统文件句柄的一次性包装。可以将其传递给 `RandomAccess` 提供的各种 `Read`、`ReadAsync`、`Write`
    和 `WriteAsync` 静态方法。所有的读取和写入方法都要求你传递文件内的偏移量，这与 `Stream` 不同，后者会为你记住当前的 `Position`。每个方法都传递偏移量的优势在于，它避免了执行多个并发操作时出现的问题，正如前面描述的。[示例
    15-4](#randomaccess_read) 使用此方法直接从 Windows 的 *.exe* 文件中读取数据。注意，与 `Stream` 类似，读取操作可能获取比请求的数据量少，因此在需要读取特定字节数的情况下，你需要编写一个循环，以确保获取所需量的数据。
- en: Example 15-4\. Reading data from a file with `RandomAccess`
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-4\. 使用 `RandomAccess` 从文件中读取数据
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This particular example just performs a single read to illustrate the usage,
    but a more complex example would be free to execute multiple concurrent reads,
    either on multiple threads or by using the `ReadAsync` method.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例仅执行单个读取以说明用法，但更复杂的示例可以自由执行多个并发读取，可以在多个线程上或使用 `ReadAsync` 方法。
- en: The buffer here is passed as a `Span<byte>`; `Write` takes a `ReadOnlySpan<byte>`.
    The asynchronous forms take `Memory<byte>` and `ReadOnlyMemory<byte>`, respectively.
    These types represent regions of memory—often but not necessarily arrays. They
    are all described in [Chapter 18](ch18.xhtml#ch_memory_efficiency).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的缓冲区以 `Span<byte>` 形式传递；`Write` 方法使用 `ReadOnlySpan<byte>`。异步形式则分别接受 `Memory<byte>`
    和 `ReadOnlyMemory<byte>`。这些类型表示内存区域——通常是数组，但不一定。它们在[第18章](ch18.xhtml#ch_memory_efficiency)中均有详细描述。
- en: 'Each method also offers an overload that accepts a list of the relevant type
    (e.g., `IReadOnlyList<Memory<byte>>`, `IReadOnlyList<ReadOnlyMemory<byte>>`, etc.)
    to support *scatter/gather* reads or writes. These are operations in which a single
    read or write spans multiple blocks of memory. If the data you want to write out
    to a file is spread across multiple areas of memory (e.g., because the data in
    question was obtained by making multiple requests to external services), you can
    perform a single write operation, passing in a list of all the blocks of memory
    to write. This can be considerably more efficient than performing multiple separate
    writes—the operating system is able to handle this sort of I/O directly, and in
    many cases the underlying disk controller hardware is able to do the work of aggregating
    the blocks of data back into a single disk operation—it gathers together the data
    that was scattered in memory, hence the name. And the mirror image of this is
    available for reads: you can read a block of data from a file and have that distributed
    across multiple destination buffers.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法还提供了接受相关类型列表（例如`IReadOnlyList<Memory<byte>>`、`IReadOnlyList<ReadOnlyMemory<byte>>`等）的重载，以支持*scatter/gather*
    读取或写入。这些操作中，单次读取或写入跨越多个内存块。如果要写出到文件的数据分布在多个内存区域中（例如因为所涉及的数据是通过对外部服务进行多次请求获得的），你可以执行单个写入操作，传入所有要写入的内存块列表。这比执行多个单独的写入要高效得多——操作系统可以直接处理这种
    I/O，而在许多情况下，底层磁盘控制器硬件能够将散布在内存中的数据聚合成单个磁盘操作——它将散落在内存中的数据汇总起来，因此得名。同样的操作也适用于读取：你可以从文件中读取一块数据，并将其分布到多个目标缓冲区中。
- en: Text-Oriented Types
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本导向类型
- en: The `Stream` and `RandomAccess` classes are byte oriented, but it’s common to
    work with files that contain text. If you want to process text stored in a file
    (or received over the network), it is cumbersome to use a byte-based API, because
    this forces you to deal explicitly with all of the variations that can occur.
    For example, there are multiple conventions for how to represent the end of a
    line—Windows typically uses two bytes with values of `13` and `10`, as do many
    internet standards such as HTTP, but Unix-like systems often use just a single
    byte with the value `10`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream` 和 `RandomAccess` 类是面向字节的，但通常需要处理包含文本的文件。如果要处理存储在文件中（或通过网络接收到的）文本，使用基于字节的
    API 是很麻烦的，因为这会迫使你显式处理所有可能发生的变化。例如，有多种约定来表示行的结束——Windows 通常使用值为`13`和`10`的两个字节，许多互联网标准如
    HTTP 也是如此，但类 Unix 系统通常只使用值为`10`的单个字节。'
- en: There are also multiple character encodings in popular use. Some files use one
    byte per character, some use two, and some use a variable-length encoding. There
    are many different single-byte encodings too, so if you encounter a byte value
    of, say, `163` in a text file, you cannot know what that means unless you know
    which encoding is in use.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 目前也有多种流行的字符编码。有些文件每个字符使用一个字节，有些使用两个字节，还有一些使用可变长度编码。也有许多不同的单字节编码，因此，如果在文本文件中遇到字节值，例如`163`，除非知道使用的编码方式，否则无法知道其含义。
- en: 'In a file using the single-byte Windows-1252 encoding, the value `163` represents
    a pound sign: £.^([1](ch15.xhtml#CHP-16-FN-2)) But if the file is encoded with
    ISO/IEC 8859-5 (designed for regions that use Cyrillic alphabets), the exact same
    code represents the Cyrillic capital letter DJE: Ђ. And if the file uses the UTF-8
    encoding, the value `163` would only be allowed as part of a multibyte sequence
    representing a single character.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用单字节 Windows-1252 编码的文件中，值`163`代表英镑符号：£。^([1](ch15.xhtml#CHP-16-FN-2)) 但如果文件采用
    ISO/IEC 8859-5 编码（设计用于使用西里尔字母的地区），同样的代码表示西里尔大写字母 DJE：Ђ。而如果文件使用 UTF-8 编码，值`163`只能作为多字节序列的一部分，代表一个单一字符。
- en: Awareness of these issues is, of course, an essential part of any developer’s
    skill set, but that doesn’t mean you should have to handle every little detail
    any time you encounter text. So .NET defines specialized abstractions for working
    with text.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，了解这些问题是任何开发者技能集的重要组成部分，但这并不意味着每次遇到文本都要处理每一个小细节。因此，.NET 定义了专门的抽象来处理文本。
- en: TextReader and TextWriter
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TextReader 和 TextWriter
- en: The abstract `TextReader` and `TextWriter` classes present data as a sequence
    of `char` values. Logically speaking, these classes are similar to a stream, but
    each element in the sequence is a `char` instead of a `byte`. However, there are
    some differences in the details. For one thing, there are separate abstractions
    for reading and writing. `Stream` combines these, because it’s common to want
    read/write access to a single entity, particularly if the stream represents a
    file on disk. For byte-oriented random access, this makes sense, but it’s a problematic
    abstraction for text.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象的 `TextReader` 和 `TextWriter` 类将数据表示为一系列 `char` 值。从逻辑上讲，这些类类似于流，但序列中的每个元素是一个
    `char` 而不是一个 `byte`。然而，在细节上有一些区别。首先，有读和写的分离抽象。`Stream` 结合了这些功能，因为通常希望对单个实体进行读/写访问，特别是如果流表示磁盘上的文件。对于面向字节的随机访问，这是有意义的，但对于文本来说，这是一个问题的抽象。
- en: Variable-length encodings make it tricky to support random write access (i.e.,
    the ability to change values at any point in the sequence). Consider what it would
    mean to take a 1 GB UTF-8 text file whose first character is a $ and replace that
    first character with a £. In UTF-8, the $ character takes only one byte, but £
    requires two, so changing that first character would require an extra byte to
    be inserted at the start of the file. This would mean moving the remaining file
    contents—almost 1 GB of data—along by one byte.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 变长编码使得支持随机写访问变得棘手（即能够在序列的任何点更改值）。考虑一下将一个 1 GB 的 UTF-8 文本文件的第一个字符 $ 替换为 £ 的意义。在
    UTF-8 中，$ 字符只需要一个字节，但 £ 需要两个字节，因此更改第一个字符将需要在文件开头插入一个额外的字节。这意味着需要将剩余的文件内容——几乎 1
    GB 的数据——向后移动一个字节。
- en: Even read-only random access is relatively expensive. Finding the millionth
    character in a UTF-8 file requires you to read the first 999,999 characters, because
    without doing that, you have no way of knowing what mix of single-byte and multibyte
    characters there is. The millionth character might start at the millionth byte,
    but it could also start some 4 million bytes in, or anywhere in between. Since
    supporting random access with variable-length text encodings is expensive, particularly
    for writable data, these text-based types don’t offer it. Without random access,
    there’s no real benefit in merging readers and writers into one type. Also, separating
    reader and writer types removes the need to check the `CanWrite` property—you
    know that you can write because you’ve got a `TextWriter`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 即使只是只读的随机访问也相对昂贵。在一个 UTF-8 文件中找到第一百万个字符需要读取前 999,999 个字符，因为没有这样做，您无法知道其中包含的单字节和多字节字符的混合情况。第一百万个字符可能从第一百万个字节开始，但也可能从第四百万个字节开始，或者介于两者之间的任何位置。由于支持带有可变长度文本编码的随机访问是昂贵的，特别是对于可写数据，因此这些基于文本的类型不提供此功能。没有随机访问，将读者和写者合并为一个类型没有真正的好处。另外，将读者和写者类型分开消除了检查
    `CanWrite` 属性的需要——您知道可以写入，因为您有一个 `TextWriter`。
- en: '`TextReader` offers several ways to read data. The simplest is the zero-argument
    overload of `Read`, which returns an `int`. This will return `−1` if you’ve reached
    the end of the input and will otherwise return a character value. (You’ll need
    to cast it to a `char` once you’ve verified that it’s nonnegative.) Alternatively,
    there are two methods that look similar to the `Stream` class’s `Read` method,
    as [Example 15-5](#textreader_chunk_reading_methods) shows.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextReader` 提供了几种读取数据的方式。最简单的是零参数重载的 `Read` 方法，它返回一个 `int`。如果已经到达输入的末尾，它将返回
    `−1`，否则将返回一个字符值。（在确认非负后，您需要将其转换为 `char`。）此外，还有两种看起来类似于 `Stream` 类的 `Read` 方法的方法，正如
    [示例 15-5](#textreader_chunk_reading_methods) 所示。'
- en: Example 15-5\. `TextReader` chunk reading methods
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-5\. `TextReader` 块读取方法
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Just like `Stream.Read`, these take an array, as well as an index into that
    array and a count, and will attempt to read the number of values specified. The
    most obvious difference from `Stream` is that these use `char` instead of `byte`.
    But what’s the difference between `Read` and `ReadBlock`? Well, `ReadBlock` solves
    the same problem that I had to solve manually for `Stream` in [Example 15-2](#reading_a_specific_number_of_bytes):
    whereas `Read` may return fewer characters than you asked for, `ReadBlock` will
    not return until either as many characters as you asked for are available or it
    reaches the end of the content.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`Stream.Read`一样，这些方法接受一个数组，以及数组中的索引和计数，并尝试读取指定数量的值。与`Stream`最明显的区别是，这些方法使用`char`而不是`byte`。但是`Read`和`ReadBlock`有什么区别呢？嗯，`ReadBlock`解决了我在[Example 15-2](#reading_a_specific_number_of_bytes)中必须为`Stream`手动解决的问题：虽然`Read`可能返回比请求的字符数少，但`ReadBlock`不会在达到请求的字符数或到达内容结尾之前返回。
- en: One of the challenges of handling text input is dealing with the various conventions
    for line endings, and `TextReader` can insulate you from that. Its `ReadLine`
    method reads an entire line of input and returns it as a `string`. This string
    will not include the end-of-line character or characters.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 处理文本输入的挑战之一是处理各种行结束的约定，而`TextReader`可以使你免受这些影响。它的`ReadLine`方法读取整行输入并将其作为一个`string`返回。该字符串不包括行尾的字符。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`TextReader` does not presume one particular end-of-line convention. It accepts
    either a carriage return (character value `13`, which we write as `\r` in string
    literals) or a line feed (`10`, or `\n`). And if both characters appear adjacently,
    the character pair is treated as being a single end of line, despite being two
    characters. This processing happens only when you use either `ReadLine` or `Read​Li⁠neAsync`.
    If you work directly at the character level by using `Read` or `ReadBlock`, you
    will see the end-of-line characters exactly as they are.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextReader`并不假定特定的行结束约定。它接受回车符（字符值`13`，在字符串字面量中写作`\r`）或换行符（`10`，或`\n`）。如果这两个字符相邻出现，该字符对被视为单个行结束，尽管实际是两个字符。此处理仅在使用`ReadLine`或`Read​Li⁠neAsync`时发生。如果直接使用`Read`或`ReadBlock`在字符级别操作，你将看到行结束字符的确切形式。'
- en: '`TextReader` also offers `ReadToEnd`, which reads the input in its entirety
    and returns it as a single `string`. And finally, there’s `Peek`, which does the
    same thing as the single-argument `Read` method, except it does not change the
    state of the reader. It lets you look at the next character without consuming
    it, so the next time you call either `Peek` or `Read`, it will return the same
    character again.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextReader`还提供了`ReadToEnd`方法，它会将输入完全读取并作为一个单独的`string`返回。最后，还有`Peek`方法，与单参数的`Read`方法相同，但不会改变阅读器的状态。它允许你查看下一个字符而不消耗它，所以下次调用`Peek`或`Read`时，它将再次返回相同的字符。'
- en: 'As for `TextWriter`, it offers two overloaded methods for writing: `Write`
    and `WriteLine`. Each of these offers overloads for all of the built-in value
    types (`bool`, `int`, `float`, etc.). Functionally, the class could have gotten
    away with a single overload that takes an `object`, because that can just call
    `ToString` on its argument, but these specialized overloads make it possible to
    avoid boxing the argument. `TextWriter` also offers a `Flush` method for much
    the same reason that `Stream` does.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 至于`TextWriter`，它提供了两个重载方法用于写入：`Write`和`WriteLine`。每个方法都为所有内置的值类型（`bool`、`int`、`float`等）提供了重载。从功能上讲，该类本可以只使用一个接受`object`参数的重载方法，因为它可以直接调用参数的`ToString`方法，但是这些专门的重载方法使得可以避免装箱。`TextWriter`还提供了一个`Flush`方法，原因与`Stream`提供的相同。
- en: By default, a `TextWriter` will use the default end-of-line sequence for the
    OS you are running on. On Windows this is the `\r\n` sequence (`13`, then `10`).
    On Linux you will just get a single `\n` at each line end. You can change this
    by setting the writer’s `NewLine` property.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`TextWriter`将使用操作系统的默认行结束序列。在Windows上是`\r\n`序列（先`13`，然后`10`）。在Linux上，每行末尾只有一个`\n`。你可以通过设置写入器的`NewLine`属性来更改这一行为。
- en: Both of these abstract classes implement `IDisposable` because some of the concrete
    derived text reader and writer types are wrappers around other disposable resources.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个抽象类都实现了`IDisposable`接口，因为一些具体的派生文本阅读器和写入器类型是对其他可释放资源的包装。
- en: As with `Stream`, these classes offer asynchronous versions of their methods.
    Unlike with `Stream`, this was a fairly recent addition, so they support only
    the task-based pattern described in [Chapter 16](ch16.xhtml#ch_multithreading),
    which can be consumed with the `await` keyword described in [Chapter 17](ch17.xhtml#ch_asynchronous_language_features).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Stream` 一样，这些类提供了其方法的异步版本。与 `Stream` 不同的是，这是一个相当近期的增加，因此它们仅支持在 [第16章](ch16.xhtml#ch_multithreading)
    中描述的基于任务的模式，可以使用 [第17章](ch17.xhtml#ch_asynchronous_language_features) 中描述的 `await`
    关键字消费。
- en: Concrete Reader and Writer Types
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 具体的读取器和写入器类型
- en: As with `Stream`, various APIs in .NET will present you with `TextReader` and
    `TextWriter` objects. For example, the `Console` class defines `In` and `Out`
    properties that provide textual access to the process’s input and output streams.
    I’ve not described these before, but we have been using them implicitly—the `Console.WriteLine`
    method overloads are all just wrappers that call `Out.WriteLine` for you. Likewise,
    the `Console` class’s `Read` and `ReadLine` methods simply forward to `In.Read`
    and `In.ReadLine`. There’s also `Error`, another `TextWriter` for writing to the
    standard error output stream. However, there are some concrete classes that derive
    from `TextReader` or `TextWriter` that you might want to instantiate directly.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Stream` 类似，.NET 中的各种 API 将向您提供 `TextReader` 和 `TextWriter` 对象。例如，`Console`
    类定义了 `In` 和 `Out` 属性，用于提供对进程输入和输出流的文本访问。虽然我之前没有描述过这些，但我们已经在隐式地使用它们——`Console.WriteLine`
    方法的重载只是为您调用 `Out.WriteLine` 的包装器。同样，`Console` 类的 `Read` 和 `ReadLine` 方法只是简单地转发到
    `In.Read` 和 `In.ReadLine`。还有一个 `Error`，另一个用于将输出写入标准错误输出流的 `TextWriter`。但是，有一些直接派生自
    `TextReader` 或 `TextWriter` 的具体类，您可能希望直接实例化它们。
- en: StreamReader and StreamWriter
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`StreamReader` 和 `StreamWriter`'
- en: Perhaps the most useful concrete text reader and writer types are `StreamReader`
    and `StreamWriter`, which wrap a `Stream` object. You can pass a `Stream` as a
    constructor argument, or you can just pass a string containing the path of a file,
    in which case they will automatically construct a `FileStream` for you and then
    wrap that. [Example 15-6](#writing_text_to_a_file_with_streamwriter) uses this
    technique to write some text to a file.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最有用的具体文本读取器和写入器类型是 `StreamReader` 和 `StreamWriter`，它们包装了一个 `Stream` 对象。您可以将
    `Stream` 作为构造函数参数传递，或者只需传递包含文件路径的字符串，它们将自动为您构造一个 `FileStream` 然后包装它。[示例 15-6](#writing_text_to_a_file_with_streamwriter)
    使用此技术向文件写入一些文本。
- en: Example 15-6\. Writing text to a file with `StreamWriter`
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-6\. 使用 `StreamWriter` 向文件写入文本
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There are various constructor overloads offering more fine-grained control.
    When passing a string in order to use a file with a `StreamWriter` (as opposed
    to some `Stream` you have already obtained), you can optionally pass a `bool`
    indicating whether to start from scratch or to append to an existing file if one
    exists. (A `true` value enables appending.) If you do not pass this argument,
    appending is not used, and writing will begin from the start. You can also specify
    an encoding. By default, `StreamWriter` will use UTF-8 with no byte order mark
    (BOM), but you can pass any type derived from the `Encoding` class, which is described
    in [“Encoding”](#encoding).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了多种构造函数重载，以提供更精细的控制。当传递一个字符串以便使用 `StreamWriter`（而不是您已经获得的某个 `Stream`）时，可以选择性地传递一个
    `bool`，指示是否从头开始或者追加到已存在的文件（传递 `true` 启用追加）。如果不传递此参数，则不使用追加，并且写入将从头开始。您还可以指定编码。默认情况下，`StreamWriter`
    将使用没有字节顺序标记（BOM）的 UTF-8，但可以传递从 `Encoding` 类派生的任何类型，该类在 [“编码”](#encoding) 中描述。
- en: '`StreamReader` is similar—you can construct it by passing either a `Stream`
    or a `string` containing the path of a file, and you can optionally specify an
    encoding. However, if you don’t specify an encoding, the behavior is subtly different
    from `StreamWriter`. Whereas `StreamWriter` just defaults to UTF-8, `StreamReader`
    will attempt to detect the encoding from the stream’s content. It looks at the
    first few bytes and will look for certain features that are typically a good sign
    that a particular encoding is in use. If the encoded text begins with a Unicode
    BOM, this makes it possible to determine with high confidence what the encoding
    is.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`StreamReader` 类似，可以通过传递 `Stream` 或包含文件路径的 `string` 来构造它，还可以选择性地指定编码。然而，如果不指定编码，其行为与
    `StreamWriter` 稍有不同。`StreamWriter` 默认使用 UTF-8，而 `StreamReader` 则尝试从流内容中检测编码。它会查看前几个字节，并寻找一些特征，这些特征通常是确定特定编码正在使用的好迹象。如果编码的文本以
    Unicode BOM 开头，这将极大地提高确定编码的准确性。'
- en: StringReader and StringWriter
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`StringReader` 和 `StringWriter`'
- en: 'The `StringReader` and `StringWriter` classes serve a similar purpose to `MemoryStream`:
    they are useful when you are working with an API that requires either a `TextReader`
    or `TextWriter`, but you want to work entirely in memory. Whereas `MemoryStream`
    presents a `Stream` API on top of a `byte[]` array, `StringReader` wraps a `string`
    as a `TextReader`, while `StringWriter` presents a `TextWriter` API on top of
    a `StringBuilder`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringReader` 和 `StringWriter` 类与 `MemoryStream` 的作用类似：当你需要与要求 `TextReader`
    或 `TextWriter` 的 API 一起工作，但希望完全在内存中操作时，它们非常有用。`MemoryStream` 在 `byte[]` 数组上提供了
    `Stream` API，`StringReader` 则将 `string` 包装为 `TextReader`，而 `StringWriter` 在 `StringBuilder`
    上提供了 `TextWriter` API。'
- en: One of the APIs .NET offers for working with XML, `XmlReader`, requires either
    a `Stream` or a `TextReader`. Suppose you have XML content in a `string`. If you
    pass a `string` when creating a new `XmlReader`, it will interpret that as a URI
    from which to fetch the content, rather than the content itself. The constructor
    for `StringReader` that takes a string just wraps that string as the content of
    the reader, and we can pass that to the `XmlReader.Create` overload that requires
    a `TextReader`, as [Example 15-7](#wrapping_a_string_in_a_stringreader) shows.
    (The line that does this is in bold—the code that follows just uses the `XmlReader`
    to read the content to show that it works as expected.)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 提供的用于处理 XML 的 API 之一，`XmlReader`，需要一个 `Stream` 或 `TextReader`。假设你有一个存储在
    `string` 中的 XML 内容。如果在创建新的 `XmlReader` 时传递一个 `string`，它会将其解释为用于获取内容的 URI，而不是内容本身。接受一个
    `string` 的 `StringReader` 构造函数会将该字符串包装为读取器的内容，我们可以将其传递给需要 `TextReader` 的 `XmlReader.Create`
    重载方法，如 [示例 15-7](#wrapping_a_string_in_a_stringreader) 所示。（这行代码用粗体标记，接下来的代码仅使用
    `XmlReader` 读取内容以展示其按预期工作。）
- en: Example 15-7\. Wrapping a string in a `StringReader`
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-7. 将字符串包装在 `StringReader` 中
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`StringWriter` is even simpler: you can just construct it with no arguments.
    Once you’ve finished writing to it, you can call either `ToString` or `GetStringBuilder`
    to extract all of the text that has been written.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringWriter` 更为简单：你可以不带任何参数地构造它。在写入完成后，你可以调用 `ToString` 或 `GetStringBuilder`
    来提取所有已写入的文本。'
- en: Encoding
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码
- en: As I mentioned earlier, if you’re using the `StreamReader` or `StreamWriter`,
    these need to know which character encoding the underlying stream uses to be able
    to convert correctly between the bytes in the stream and .NET’s `char` or `string`
    types. To manage this, the `System.Text` namespace defines an abstract `Encoding`
    class, with various encoding-specific public concrete derived types, including
    `ASCIIEncoding`, `UTF7Encoding`, `UTF8Encoding`, `UTF32Encoding`, and `UnicodeEncoding`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，如果使用 `StreamReader` 或 `StreamWriter`，它们需要知道底层流使用的字符编码，以便能够正确地在流中的字节和
    .NET 的 `char` 或 `string` 类型之间进行转换。为了管理这一点，`System.Text` 命名空间定义了一个抽象的 `Encoding`
    类，具有各种具体的编码特定公共派生类型，包括 `ASCIIEncoding`、`UTF7Encoding`、`UTF8Encoding`、`UTF32Encoding`
    和 `UnicodeEncoding`。
- en: 'Most of those type names are self-explanatory, because they are named after
    the standard character encodings they represent, such as ASCII or UTF-8\. The
    one that requires a little more explanation is `UnicodeEncoding`—after all, UTF-7,
    UTF-8, and UTF-32 are all Unicode encodings, so what’s this other one for? When
    Windows introduced support for Unicode back in the first version of Windows NT,
    it adopted a slightly unfortunate convention: in documentation and various API
    names, the term *Unicode* was used to refer to a 2-byte little-endian^([2](ch15.xhtml#CHP-16-FN-3))
    character encoding, which is just one of many possible encoding schemes, all of
    which could correctly be described as being “Unicode” of one form or another.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些类型名称都是不言自明的，因为它们命名自它们代表的标准字符编码，比如 ASCII 或 UTF-8。需要稍作解释的是 `UnicodeEncoding`
    —— 毕竟，UTF-7、UTF-8 和 UTF-32 都是 Unicode 编码，那么这个“UnicodeEncoding”又是什么呢？当 Windows
    在第一个 Windows NT 版本中引入对 Unicode 的支持时，采用了一个有点不太恰当的约定：在文档和各种 API 名称中，“Unicode”一词被用来指代一种2字节的小端字符编码，这只是众多可能的编码方案中的一种，它们都可以正确地描述为某种形式的“Unicode”。
- en: The `UnicodeEncoding` class is named to be consistent with this historical convention,
    although even then it’s still a bit confusing. The encoding referred to as “Unicode”
    in Win32 APIs is effectively UTF-16LE, but the `UnicodeEncoding` class is also
    capable of supporting the big-endian UTF-16BE.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnicodeEncoding` 类的命名是为了与这个历史约定保持一致，尽管即便如此，仍然有些令人困惑。在 Win32 API 中，“Unicode”所指的编码实际上是
    UTF-16LE，但 `UnicodeEncoding` 类也能支持大端的 UTF-16BE。'
- en: 'The base `Encoding` class defines static properties that return instances of
    all the encoding types I’ve mentioned, so if you need an object representing a
    particular encoding, you would normally just write `Encoding.ASCII` or `Encoding.UTF8`,
    etc., instead of constructing a new object. There are two properties of type `UnicodeEncoding`:
    the `Unicode` property returns one configured for UTF-16LE, and `BigEndianUnicode`
    returns one for UTF-16BE.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 基础的`Encoding`类定义了静态属性，返回我提到的所有编码类型的实例，因此如果需要表示特定编码的对象，通常只需写`Encoding.ASCII`或`Encoding.UTF8`等，而不是构造新对象。有两个类型为`UnicodeEncoding`的属性：`Unicode`属性返回一个配置为UTF-16LE的实例，`BigEndianUnicode`返回一个UTF-16BE的实例。
- en: For the various Unicode encodings, these properties will return encoding objects
    that will tell `StreamWriter` to generate a BOM at the start of the output. The
    main purpose of the BOM is to enable software that reads encoded text to detect
    automatically whether the encoding is big- or little-endian. (You can also use
    it to recognize UTF-8, because that encodes the BOM differently than other encodings.)
    If you know that you will be using an endian-specific encoding (e.g., UTF-16LE),
    the BOM is unnecessary, because you already know the order, but the Unicode specification
    defines adaptable formats in which the encoded bytes can advertise the order in
    use by starting with a BOM, a character with Unicode code point `U+FEFF`. The
    16-bit version of this encoding is just called UTF-16, and you can tell whether
    any particular set of UTF-16-encoded bytes is big- or little-endian by seeing
    whether it begins with 0xFE, 0xFF or 0xFF, 0xFE.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于各种Unicode编码，这些属性将返回编码对象，告诉`StreamWriter`在输出开头生成BOM。BOM的主要目的是使读取编码文本的软件能够自动检测编码是大端序还是小端序（你也可以用它来识别UTF-8，因为其编码BOM与其他编码不同）。如果知道将使用特定字节顺序的编码（例如UTF-16LE），则BOM是不必要的，因为你已经知道顺序，但Unicode规范定义了可以通过以BOM开头的编码字节来广告正在使用的顺序的可适应格式。其16位版本称为UTF-16，可以通过查看其是否以0xFE、0xFF或0xFF、0xFE开始来判断任何特定的UTF-16编码字节集是大端序还是小端序。
- en: Warning
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Although Unicode defines encoding schemes that allow the endianness to be detected,
    it is not possible to create an `Encoding` object that works that way—it will
    always have a specific endianness. So, although an `Encoding` specifies whether
    a BOM should be written when writing data, this does not influence the behavior
    when reading data—it will always presume the endianness specified when the `Encoding`
    was constructed. This means that the `Encoding.UTF32` property is arguably misnamed—it
    always interprets data as little-endian even though the Unicode specification
    allows UTF-32 to use either big- or little-endian. `Encoding.UTF32` is really
    UTF-32LE.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Unicode定义了允许检测字节顺序的编码方案，但无法创建按此方式工作的`Encoding`对象——它总是具有特定的字节顺序。因此，尽管`Encoding`指定在写入数据时是否写入BOM，但这不会影响读取数据的行为——它总是假定在构造`Encoding`时指定的字节顺序。这意味着`Encoding.UTF32`属性可能名字起得不太准确——它总是将数据解释为小端序，尽管Unicode规范允许UTF-32使用大端或小端序。`Encoding.UTF32`实际上是UTF-32LE。
- en: 'As mentioned earlier, if you do not specify an encoding when creating a `StreamWriter`,
    it defaults to UTF-8 with no BOM, which is different from `Encoding.UTF8`—that
    will generate a BOM. And recall that `StreamReader` is more interesting: if you
    do not specify an encoding, it will attempt to detect the encoding. So .NET is
    able to handle automatic detection of byte ordering as required by the Unicode
    specification for UTF-16 and UTF-32; it is just that the way to do it is *not*
    to specify any particular encoding when constructing a `StreamReader`. It will
    look for a BOM, and if it finds one present, it will use a suitable Unicode encoding;
    otherwise, it presumes UTF-8 encoding.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在创建`StreamWriter`时未指定编码时，默认为无BOM的UTF-8编码，这与`Encoding.UTF8`不同，后者会生成BOM。而`StreamReader`更有趣：如果未指定编码，它将尝试检测编码。因此，.NET能够根据Unicode规范对UTF-16和UTF-32自动检测字节顺序；不过做法是在构造`StreamReader`时*不*指定特定编码。它会查找BOM，如果找到，则使用适当的Unicode编码；否则假定为UTF-8编码。
- en: UTF-8 is a popular encoding. If your main language is English, it’s a particularly
    convenient representation, because if you happen to use only the characters available
    in ASCII, each character will occupy a single byte, and the encoded text will
    have the exact same byte values as it would with ASCII encoding. But unlike ASCII,
    you’re not limited to a 7-bit character set. All Unicode code points are available;
    you just have to use multibyte representations for anything outside of the ASCII
    range. However, although it’s very widely used, UTF-8 is not the only popular
    8-bit encoding.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8是一种流行的编码方式。如果你的主要语言是英语，这是一种特别方便的表示方法，因为如果你只使用ASCII中可用的字符，每个字符将占据一个字节，并且编码后的文本将与ASCII编码具有相同的字节值。但不同于ASCII，你不受限于7位字符集。所有Unicode代码点都可用；你只需对ASCII范围外的内容使用多字节表示。然而，尽管它非常广泛使用，UTF-8并不是唯一流行的8位编码。
- en: Code page encodings
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码页编码
- en: Windows, like DOS before it, has long supported 8-bit encodings that extend
    ASCII. ASCII is a 7-bit encoding, meaning that with 8-bit bytes you have 128 “spare”
    values to use for other characters. This is nowhere near enough to cover every
    character for every locale, but within a particular country, it’s often enough
    to get by (although not always—many Far Eastern countries need more than 8 bits
    per character). But each country tends to want a different set of non-ASCII characters,
    depending on which accented characters are popular in that locale and whether
    a non-Roman alphabet is required. So various *code pages* exist for different
    locales. For example, code page 1253 uses values in the range 193–254 to define
    characters from the Greek alphabet (filling the remaining non-ASCII values with
    useful characters such as non-US currency symbols). Code page 1255 defines Hebrew
    characters instead, while 1256 defines Arabic characters in the upper range (and
    there is some common ground for these particular code pages, such as using 128
    for the euro symbol, €, and 163 for the pound sign, £).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Windows，如同之前的DOS一样，长期支持扩展ASCII的8位编码。ASCII是一个7位编码，意味着使用8位字节，你有128个“多余”的值可用于其他字符。这远远不足以覆盖每个区域的每个字符，但在特定国家内，通常足够应付（尽管并非总是如此——许多远东国家需要超过8位每字符的编码）。但每个国家往往希望有一套不同的非ASCII字符集，这取决于该地区流行的重音字符以及是否需要非罗马字母表。因此，为不同地区存在各种*代码页*。例如，代码页1253使用193–254范围内的值来定义希腊字母字符（用其余的非ASCII值填充有用字符，如非美元货币符号）。代码页1255定义希伯来字符，而1256则定义阿拉伯字符在上部范围内（这些特定代码页也有一些共同点，例如使用128表示欧元符号€，163表示英镑符号£）。
- en: One of the most commonly encountered code pages is 1252, because that’s the
    Windows default for English-speaking locales. This does not define a non-Roman
    alphabet; instead it uses the upper character range for useful symbols and for
    various accented versions of the Roman alphabet that enable a wide range of Western
    European languages to be adequately represented.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的代码页之一是1252，因为它是英语环境下的Windows默认设置。这并不定义非罗马字母表；相反，它使用上部字符范围来放置有用的符号以及各种罗马字母的重音版本，使得广泛的西欧语言得到适当的表示。
- en: You can create an encoding for a code page by calling the `Encoding.GetEncoding`
    method, passing in the code page number. (The concrete type of the object you
    get back is often not one of those I listed earlier. This method may return nonpublic
    types that derive from `Encoding`.) [Example 15-8](#writing_with_the_windows_1252_code_page)
    uses this to write text containing a pound sign to a file using code page 1252.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用`Encoding.GetEncoding`方法，传入代码页号来创建代码页的编码。（你得到的对象的具体类型通常不是我之前列出的那些。这个方法可能会返回从`Encoding`派生的非公共类型。）[示例 15-8](#writing_with_the_windows_1252_code_page)
    使用此方法将包含英镑符号的文本写入文件，使用代码页1252。
- en: Example 15-8\. Writing with the Windows 1252 code page
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例15-8\. 使用Windows 1252代码页写入
- en: '[PRE7]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will encode the £ symbol as a single byte with the value `163`. With the
    default UTF-8 encoding, it would have been encoded as two bytes, with values of
    `194` and `163`, respectively.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把£符号编码为单字节，其值为`163`。使用默认的UTF-8编码，则会以两个字节编码，其值分别为`194`和`163`。
- en: Using encodings directly
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直接使用编码
- en: '`TextReader` and `TextWriter` are not the only way to use encodings. Objects
    representing encodings (such as `Encoding.UTF8`) define various members. The `GetBytes`
    method converts a `string` directly to a `byte[]` array, for example, and the
    `GetString` method converts back again.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextReader`和`TextWriter`并不是使用编码的唯一方式。代表编码的对象（如`Encoding.UTF8`）定义了各种成员。例如，`GetBytes`方法将`string`直接转换为`byte[]`数组，而`GetString`方法则进行相反的转换。'
- en: You can also discover how much data these conversions will produce. `GetByteCount`
    tells you how large an array `GetBytes` would produce for a given string, while
    `GetCharCount` tells you how many characters decoding a particular array would
    generate. You can also find an upper limit for how much space will be required
    without knowing the exact text with `GetMaxByteCount`. Instead of a `string`,
    this takes a number, which it interprets as a string length; since .NET strings
    use UTF-16, this means that this API answers the question “If I have this many
    UTF-16 code units, what’s the largest number of code units that might be required
    to represent the same text in the target encoding?” This can produce a significant
    overestimate for variable-length encodings. For example, with UTF-8, `GetMaxByteCount`
    multiplies the length of the input string by three^([3](ch15.xhtml#idm45884790912256))
    and adds an extra 3 bytes to deal with an edge case that can occur with surrogate
    characters. It produces a correct description of the worst possible case, but
    text containing any characters that don’t require 3 bytes in UTF-8 (i.e., any
    text in English or any other languages that use the Latin alphabet, and also any
    text using Greek, Cyrillic, Hebrew, or Arabic writing systems, for example) will
    require significantly less space than `GetMaxByteCount` predicts.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以了解这些转换会产生多少数据。`GetByteCount`告诉你为给定字符串调用`GetBytes`将产生多大的数组，而`GetCharCount`告诉你解码特定数组将生成多少字符。你还可以找到在不知道确切文本情况下所需空间的上限，通过`GetMaxByteCount`方法。这个方法接受一个数字而不是一个`string`，它将其解释为字符串长度；由于.NET字符串使用UTF-16，这意味着这个API回答的问题是：“如果我有这么多UTF-16代码单元，那么在目标编码中表示相同文本可能需要的最大代码单元数是多少？”对于可变长度编码，这可能会产生显著的高估。例如，对于UTF-8，`GetMaxByteCount`将输入字符串的长度乘以三^([3](ch15.xhtml#idm45884790912256))，并额外添加3个字节来处理可能出现的代理字符边缘情况。它生成了可能情况的正确描述，但是包含不需要在UTF-8中占用3个字节的任何字符（即英语或任何使用拉丁字母表的其他语言，以及使用希腊文、西里尔字母、希伯来文或阿拉伯文写作系统的任何文本）将需要比`GetMaxByteCount`预测的空间少得多。
- en: Some encodings can provide a *preamble*, a distinctive sequence of bytes that,
    if found at the start of some encoded text, indicate that you are likely to be
    looking at something using that encoding. This can be useful if you are trying
    to detect which encoding is in use when you don’t already know. The various Unicode
    encodings all return their encoding of the BOM as the preamble, which you can
    retrieve with the `GetPreamble` method.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有些编码可以提供一个*preamble*，即一系列独特的字节序列，如果在某些编码文本的开头找到它，表明你很可能正在查看使用该编码的内容。当你不知道正在使用哪种编码时，这可能非常有用。各种Unicode编码都会返回它们的BOM编码作为preamble，你可以通过`GetPreamble`方法获取它。
- en: The `Encoding` class defines instance properties offering information about
    the encoding. `EncodingName` returns a human-readable name for the encoding, but
    there are two more names available. The `WebName` property returns the standard
    name for the encoding registered with the Internet Assigned Numbers Authority
    (IANA), which manages standard names and numbers for things on the internet such
    as MIME types. Some protocols, such as HTTP, sometimes put encoding names into
    headers, and this is the text you should use in that situation. The other two
    names, `BodyName` and `HeaderName`, are somewhat more obscure and are used only
    for internet email—there are different conventions for how certain encodings are
    represented in the body and headers of email.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Encoding`类定义了实例属性，提供关于编码的信息。`EncodingName`返回编码的人类可读名称，但还有两个可用的名称。`WebName`属性返回与Internet分配号码管理局（IANA）注册的编码标准名称，该局管理互联网上的标准名称和编号，例如MIME类型。一些协议（如HTTP）有时会将编码名称放入头部，这就是在该情况下应使用的文本。另外两个名称，`BodyName`和`HeaderName`，相对更为晦涩，仅用于互联网电子邮件——有不同的约定来表示某些编码在电子邮件正文和标题中的表示方式。'
- en: Files and Directories
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件和目录
- en: The abstractions I’ve shown so far in this chapter are very general purpose
    in nature—you can write code that uses a `Stream` without needing to have any
    idea where the bytes it contains come from or are going to, and likewise, `TextReader`
    and `TextWriter` do not demand any particular origin or destination for their
    data. This is useful because it makes it possible to write code that can be applied
    in a variety of scenarios. For example, the stream-based `GZipStream` can compress
    or decompress data from a file, over a network connection, or from any other stream.
    However, there are occasions where you know you will be dealing with files and
    want access to file-specific features. This section describes the classes for
    working with files and the filesystem.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中展示的抽象概念非常通用——您可以编写使用 `Stream` 的代码，而无需知道其中包含的字节来自何处或将要去哪里；同样，`TextReader`
    和 `TextWriter` 不要求其数据有任何特定的起源或目的地。这很有用，因为它使得能够编写可应用于各种情境的代码成为可能。例如，基于流的 `GZipStream`
    可以从文件、网络连接或任何其他流中压缩或解压缩数据。但是，有时您知道自己将处理文件并希望访问特定于文件的功能。本节描述了用于处理文件和文件系统的类。
- en: FileStream Class
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FileStream 类
- en: The `FileStream` class derives from `Stream` and represents a file from the
    filesystem. I’ve used it a few times in passing already. It adds relatively few
    members to those provided by the base class. The `Lock` and `Unlock` methods provide
    a way of acquiring exclusive access to specific byte ranges when using a single
    file from multiple processes. The `Name` property tells you the filename.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileStream` 类继承自 `Stream` 类，表示文件系统中的文件。我已经偶尔使用过它几次了。相比基类，它只添加了相对较少的成员。`Lock`
    和 `Unlock` 方法提供了在多个进程中使用单个文件时获取特定字节范围的独占访问的方式。`Name` 属性告诉你文件名。'
- en: '`FileStream` offers a great deal of control in its constructors—disregarding
    the ones marked with the `[Obsolete]` attribute,^([4](ch15.xhtml#CHP-16-FN-4))
    there are no fewer than 10 constructor overloads. The ways of creating a `FileStream`
    fall into two groups: ones where you already have an OS file handle and ones where
    you don’t. If you already have a handle from somewhere, you are required to tell
    the `FileStream` whether that handle offers read, write, or read/write access
    to the file, which you do by passing a value from the `FileAccess` enumeration.
    The other overloads optionally let you indicate the buffer size you’d like to
    use when reading or writing, and a flag indicating whether the handle was opened
    for overlapped I/O, a Win32 mechanism for supporting asynchronous operation. (The
    constructors that don’t take that flag assume that you did not request overlapped
    I/O when creating the file handle.)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileStream` 在其构造函数中提供了极大的灵活性——忽略带有 `[Obsolete]` 属性标记的构造函数，[^4] 总共有不少于 10 个构造函数重载。创建
    `FileStream` 的方法可分为两组：一种是已经有操作系统文件句柄的情况，另一种是没有文件句柄的情况。如果你已经从某处获得了句柄，你需要告诉 `FileStream`
    该句柄提供了对文件的读、写或读/写访问权限，这可以通过传递 `FileAccess` 枚举值来实现。其他重载可选地允许你指定在读取或写入时要使用的缓冲区大小，以及一个指示句柄是否已为重叠
    I/O（一种支持异步操作的 Win32 机制）打开的标志。（不带该标志的构造函数假定在创建文件句柄时未请求重叠 I/O。）'
- en: It is more common to use the other constructors, in which the `FileStream` uses
    OS APIs to create the file handle on your behalf. You can provide varying levels
    of detail on how you’d like this done. At a minimum, you must specify the file’s
    path and a value from the `FileMode` enumeration. [Table 15-1](#filemode_enumeration)
    shows the values this enumeration defines and describes what the `FileStream`
    constructor will do for each value in situations where the named file already
    exists and where it does not.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 更常见的是使用其他构造函数，其中 `FileStream` 使用操作系统 API 代表您创建文件句柄。您可以提供不同级别的详细信息来指定希望如何完成这些操作。至少，您必须指定文件的路径和
    `FileMode` 枚举值。[Table 15-1](#filemode_enumeration) 显示了此枚举定义的值，并描述了 `FileStream`
    构造函数在已命名文件存在和不存在的情况下将如何处理每个值的情况。
- en: Table 15-1\. `FileMode` enumeration
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15-1. `FileMode` 枚举
- en: '| Value | Behavior if file exists | Behavior if file does not exist |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 文件存在时的行为 | 文件不存在时的行为 |'
- en: '| --- | --- | --- |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `CreateNew` | Throws `IOException` | Creates new file |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `CreateNew` | 抛出 `IOException` | 创建新文件 |'
- en: '| `Create` | Replaces existing file | Creates new file |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `Create` | 替换现有文件 | 创建新文件 |'
- en: '| `Open` | Opens existing file | Throws `FileNotFoundException` |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `Open` | 打开现有文件 | 抛出 `FileNotFoundException` |'
- en: '| `OpenOrCreate` | Opens existing file | Creates new file |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `OpenOrCreate` | 打开现有文件 | 创建新文件 |'
- en: '| `Truncate` | Replaces existing file | Throws `FileNotFoundException` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `Truncate` | 替换现有文件 | 抛出`FileNotFoundException` |'
- en: '| `Append` | Opens existing file, setting `Position` to end of file | Creates
    new file |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `Append` | 打开现有文件，将`Position`设置为文件末尾 | 创建新文件 |'
- en: You can optionally specify a `FileAccess` too. If you do not, the `FileStream`
    will use `FileAccess.ReadWrite` unless you’ve chosen a `FileMode` of `Append`.
    Files opened in append mode can only be written to, so `FileStream` chooses `Write`
    in that case. (If you pass an explicit `FileAccess` asking for anything other
    than `Write` when opening in `Append` mode, the constructor throws an `ArgumentException`.)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以选择指定`FileAccess`。如果不指定，`FileStream`将使用`FileAccess.ReadWrite`，除非您选择了`FileMode.Append`。以追加模式打开的文件只能进行写入操作，因此在这种情况下，`FileStream`会选择`Write`。（如果在打开追加模式时传递显式的`FileAccess`请求除`Write`之外的任何值，构造函数会抛出`ArgumentException`。）
- en: By the way, as I describe each additional constructor argument in this section,
    the relevant overload will take all of the previously described ones too (with
    the exception of the `useAsync` argument, which appears in just one constructor).
    As [Example 15-9](#filestream_constructors_taking_a_path) shows, most of these
    constructors look just like the one before it, with one additional argument.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，在本节描述每个额外构造函数参数时，相关重载将还会接受之前描述过的所有参数（但`useAsync`参数除外，该参数仅出现在一个构造函数中）。正如[示例 15-9](#filestream_constructors_taking_a_path)所示，大多数这些构造函数看起来都和前一个构造函数类似，只是多了一个额外参数。
- en: Example 15-9\. `FileStream` constructors taking a path
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-9\. 使用路径的`FileStream`构造函数
- en: '[PRE8]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The overloads that accept an argument of type `FileShare` let you indicate whether
    you want exclusive access to the file. If you pass `FileShare.None`, the constructor
    will throw an `IOException` if the file is already open elsewhere, and if it succeeds,
    no other code will be able to open this file until you are finished with it. If
    you are prepared to allow other processes (or other code in your process) to open
    the file simultaneously, you can indicate whether your code can tolerate other
    users of the file having read access, write access, or both. `FileShare` is a
    flags-style enumeration, so you can specify `FileShare.Read|FileShare.Write`,
    but since that’s a common combination, `FileShare` defines a precombined `ReadWrite`
    value.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 那些接受`FileShare`类型参数的重载允许您指示是否需要独占文件访问权。如果传递`FileShare.None`，那么如果文件已在其他地方打开，构造函数将抛出`IOException`，如果成功打开，则在您完成使用文件之前，没有其他代码能够打开该文件。如果您愿意允许其他进程（或同一进程中的其他代码）同时打开文件，您可以指示您的代码是否能够容忍其他用户同时拥有文件的读取访问权、写入访问权或两者兼有。`FileShare`是一个类似标志的枚举，因此您可以指定`FileShare.Read|FileShare.Write`，但由于这是一个常见的组合，`FileShare`定义了一个预组合的`ReadWrite`值。
- en: 'The constructor overloads that don’t take an explicit `FileShare` both use
    `FileShare.Read`, which indicates that your code is happy for other code to have
    the same file open simultaneously for reading but not writing. This would make
    sense if you are writing entries to a logfile, for example: you would most likely
    use `FileMode.Append` and `FileShare.Read`, meaning only your code will be able
    to append log entries, but others could still open the file with `FileAccess.Read`
    to be able to read the log. If two programs attempt to open the same log file
    simultaneously for write access, and both specify `FileShare.Read` (explicitly
    or as the implicit default), then whichever gets in there first will succeed,
    but when the second one tries, the constructor will throw an `IOException` because
    the attempt to open the file for writing conflicts with the fact that the file
    is already open without `FileShare.Write`. And in this case, that is what you’d
    want—if two programs attempted to append to the end of the same file simultaneously,
    the result would be a mess because each would have its own idea about where the
    end of the file is.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 那些不显式指定`FileShare`的构造函数重载都使用`FileShare.Read`，这表示您的代码允许其他代码同时打开文件以进行读取，但不允许写入。例如，如果您正在向日志文件写入条目，那么您很可能会使用`FileMode.Append`和`FileShare.Read`，这意味着只有您的代码能够追加日志条目，但其他代码仍然可以使用`FileAccess.Read`打开文件以读取日志。如果两个程序尝试同时以写入访问方式打开同一日志文件，并且两者都指定了`FileShare.Read`（显式或作为隐式默认值），那么谁先进入就会成功，但第二个尝试时构造函数会抛出`IOException`，因为尝试打开文件进行写入与文件已经以没有`FileShare.Write`的方式打开的事实相冲突。在这种情况下，这是您想要的行为——如果两个程序尝试同时向同一文件末尾追加内容，结果将会非常混乱，因为每个程序都会有自己关于文件末尾位置的想法。
- en: 'If you attempt to open a file that some other code (either another process
    or code elsewhere inside your application) already has open, it will succeed only
    if the `File​Ac⁠cess` and `FileShare` you specify are compatible with the `FileShare`
    that was used by the code that got there first. Likewise, if your code has already
    opened a file, the `FileShare` you chose at that point determines which `FileAccess`
    and `FileShare` combinations other code could successfully apply while you are
    using the file. For example, if you want to read a logfile that some other process
    is writing to, then if that other process specified `FileShare.Read`, you will
    need to use `FileAccess.Read`. (The constructors that don’t specify a `FileAccess`
    default to `FileAccess.ReadWrite`, which would fail in this case because you can’t
    get write access if something else already has the file open with `FileShare.Read`.)
    But you would also need to specify `FileShare.ReadWrite`. That may look surprising
    in code that only wants to read, but it makes sense: it states that we don’t mind
    if other code attempts to modify the file while we are reading from it. The default
    of `FileShare.Read` states that we need the file not to change while we’re using
    it, but that would be the wrong choice for *reading* from a logfile—if we managed
    to open a logfile with `FileShare.Read`, that would prevent the main application
    from opening the logfile for writing.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试打开某个其他代码（可能是另一个进程或应用程序内的其他位置的代码）已经打开的文件，只有在您指定的 `FileAccess` 和 `FileShare`
    与先前使用该文件的代码所使用的 `FileShare` 兼容时才会成功。同样地，如果您的代码已经打开了一个文件，那么在那一点上选择的 `FileShare`
    决定了在您使用文件时其他代码可以成功应用的 `FileAccess` 和 `FileShare` 组合。例如，如果您想要读取一个其他进程正在写入的日志文件，那么如果那个进程指定了
    `FileShare.Read`，您将需要使用 `FileAccess.Read`。 （那些未指定 `FileAccess` 的构造函数默认为 `FileAccess.ReadWrite`，在这种情况下将失败，因为如果某物已经使用
    `FileShare.Read` 打开文件，则无法获得写访问权限。）但是您还需要指定 `FileShare.ReadWrite`。这在只想要读取的代码中可能看起来令人惊讶，但它是有道理的：它声明了我们不介意在我们读取时其他代码试图修改文件。`FileShare.Read`
    的默认值表明我们在使用文件时不希望文件发生更改，但这对于从日志文件中*读取*是错误的选择——如果我们设法使用 `FileShare.Read` 打开日志文件，那将阻止主应用程序打开日志文件进行写入。
- en: Specifying `FileShare.Write` on its own (not combined with `FileShare.Read`)
    is legal but slightly strange. It tolerates other handles with write access being
    active simultaneously, but no readers will be allowed. You can also pass `Delete`
    (on its own or in combination with `Read` and/or `Write`), indicating that you
    don’t mind if someone else tries to delete the file while you have it open. Obviously,
    you’ll get I/O exceptions if you try to use a file after it has been deleted,
    so you’d need to be prepared for that, but this can sometimes be worth the effort;
    otherwise, attempts to delete a file will be blocked while you have it open.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 单独指定 `FileShare.Write`（而不与 `FileShare.Read` 结合）是合法的，但有点奇怪。它容忍同时存在具有写访问权限的其他句柄，但不允许读取者。您还可以传递
    `Delete`（单独或与 `Read` 和/或 `Write` 结合使用），表示您不介意在您打开文件时有人尝试删除它。显然，如果尝试在文件被删除后使用文件，将会收到
    I/O 异常，因此您需要为此做好准备，但有时这样做可能值得努力；否则，尝试删除文件时将会被阻止，而您已经打开了文件。
- en: Warning
  id: totrans-160
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Unix has fewer file-locking mechanisms than Windows, so these locking semantics
    will often be mapped to something simpler in those environments. Also, file locks
    are advisory in Unix, meaning processes can simply ignore them if they want to.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 的文件锁机制比 Windows 少，因此这些锁定语义通常会在这些环境中映射为更简单的东西。此外，在 Unix 中，文件锁是建议性的，这意味着进程可以选择忽略它们。
- en: The next piece of information we can pass is the buffer size. This controls
    the size of block that the `FileStream` will use when reading from and writing
    to the filesystem. It defaults to 4,096 bytes. In most scenarios, this value works
    just fine, but if you are processing very high volumes of data, a large buffer
    size might provide better throughput. However, as with all performance matters,
    you should measure the effect of such a change to see if it is worthwhile—in some
    cases, you will not see any difference in data throughput and will simply use
    a bit more memory than necessary.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以传递的下一个信息片段是缓冲区大小。这控制了 `FileStream` 从文件系统读取和写入时使用的块大小。它的默认值为 4,096 字节。在大多数情况下，这个值都可以很好地工作，但是如果您正在处理非常高的数据量，较大的缓冲区大小可能会提供更好的吞吐量。然而，与所有性能问题一样，您应该测量此类更改的影响，看看是否值得——在某些情况下，您可能看不到数据吞吐量的任何差异，只会使用比必要更多一点的内存。
- en: The `useAsync` flag lets you determine whether the file handle is opened in
    a way that is optimized for large asynchronous reads and writes. (On Windows,
    this opens the file for *overlapped I/O*, a Win32 feature supporting asynchronous
    operations.) If you are reading data in relatively large chunks, and you use the
    stream’s asynchronous APIs, you will typically get better performance by setting
    this flag. However, if you read data a few bytes at a time, this mode actually
    increases overhead. If the code accessing the file is particularly performance
    sensitive, it will be worth trying both settings to see which works better for
    your workload. As mentioned earlier, this also makes it possible to perform multiple
    concurrent operations on a single `FileStream`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`useAsync` 标志允许你确定文件句柄是否以优化大型异步读取和写入的方式打开。（在Windows上，这会打开文件进行*重叠I/O*，这是支持异步操作的Win32特性。）如果你以相对较大的块读取数据，并使用流的异步API，通常通过设置此标志可以获得更好的性能。但是，如果每次读取几个字节，这种模式实际上会增加开销。如果访问文件的代码对性能特别敏感，值得尝试两种设置，看看哪种对你的工作负载更有效。正如前面提到的，这也使得可以在单个
    `FileStream` 上执行多个并发操作。'
- en: The next argument you can add is of type `FileOptions`. If you’re paying close
    attention, you’ll notice in [Example 15-9](#filestream_constructors_taking_a_path)
    that each of the overloads we’ve looked at up to now adds one more argument, but
    with this one, the `FileOptions` argument *replaces* the `bool useAsync` argument.
    That’s because one of the options you can specify with `FileOptions` is asynchronous
    access. `FileOptions` is a flags enumeration, so you can specify a combination
    of any of the flags it offers, which are described in [Table 15-2](#fileoptions_flags).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个参数可以添加的类型是`FileOptions`。如果你非常注意的话，你会注意到在[示例 15-9](#filestream_constructors_taking_a_path)
    中，到目前为止我们看过的每一个重载都添加了一个新参数，但是在这个中，`FileOptions` 参数*替换了* `bool useAsync` 参数。这是因为你可以用
    `FileOptions` 指定的选项之一是异步访问。`FileOptions` 是一个标志枚举，所以你可以指定它提供的任何组合标志，这些标志在[表 15-2](#fileoptions_flags)中有描述。
- en: Table 15-2\. `FileOptions` flags
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15-2\. `FileOptions` 标志
- en: '| Flag | Meaning |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 含义 |'
- en: '| --- | --- |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `WriteThrough` | Disables OS write buffering so data goes straight to the
    storage device when you flush the stream |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `WriteThrough` | 禁用操作系统写入缓冲，数据直接传递到存储设备当你刷新流时 |'
- en: '| `Asynchronous` | Specifies the use of asynchronous I/O |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `Asynchronous` | 指定使用异步I/O |'
- en: '| `RandomAccess` | Hints to filesystem cache that you will be seeking, not
    reading or writing data in order |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `RandomAccess` | 提示文件系统缓存，你将会进行查找，而不是按顺序读取或写入数据 |'
- en: '| `SequentialScan` | Hints to filesystem cache that you will be reading or
    writing data in order |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `SequentialScan` | 提示文件系统缓存，你将按顺序读取或写入数据 |'
- en: '| `DeleteOnClose` | Tells `FileStream` to delete the file when you call `Dispose`
    |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `DeleteOnClose` | 告诉 `FileStream` 在调用 `Dispose` 时删除文件 |'
- en: '| `Encrypted` | Encrypts the file so that its contents cannot be read by other
    users |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `Encrypted` | 加密文件，以防其他用户读取其内容 |'
- en: Be wary of the `WriteThrough` flag. Although it works as advertised, it might
    not have the desired effect, because some hard drives defer writes to improve
    performance. (Many hard drives have their own RAM, enabling them to receive data
    from the computer very quickly and to report write operations as having completed
    before really storing the data.) The `WriteThrough` flag will ensure that when
    you dispose or flush the stream, all the data you’ve written will have been delivered
    to the drive, but the drive will not necessarily have written that data persistently,
    so you could still lose the data if the power fails. The exact behavior will depend
    on how you have told the OS to configure the drive.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要注意`WriteThrough` 标志。虽然它按照预期工作，但可能没有预期的效果，因为某些硬盘会延迟写入以提高性能（许多硬盘有自己的RAM，能够非常快速地接收来自计算机的数据，并在真正存储数据之前报告写入操作已完成）。`WriteThrough`
    标志将确保当你释放或刷新流时，你写入的所有数据都已传送到驱动器，但驱动器不一定已将该数据持久写入，因此如果电源故障，你仍可能丢失数据。确切的行为将取决于你如何告诉操作系统配置驱动器。
- en: '.NET 6.0 adds a new overload that accepts two arguments: a `string` (the file’s
    path) and a `FileStreamOptions`. `FileStreamOptions` defines a property for each
    of the settings we’ve just discussed. So it has `Mode`, `Access`, `Share`, `Options`,
    and `BufferSize`. It also adds an additional setting, new to .NET 6.0, `PreallocationSize`,
    enabling applications to indicate how much space they expect the file to take
    up. This enables the OS to detect when insufficient space is available and also
    to reserve the space, reducing the chances of starting an operation that eventually
    fails due to lack of disk space. The `FileStreamOptions` overload makes it easier
    to set only those aspects for which you don’t want the defaults—you can just set
    the relevant properties. This means it’s no longer inconvenient if there isn’t
    a `FileStream` constructor overload with the exact combination of parameters you
    need.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 6.0 添加了一个新的重载，接受两个参数：一个`string`（文件的路径）和一个`FileStreamOptions`。`FileStreamOptions`定义了我们刚刚讨论的每个设置的属性。因此，它具有`Mode`、`Access`、`Share`、`Options`和`BufferSize`。它还添加了一个新的设置，新添加到.NET
    6.0中，`PreallocationSize`，允许应用程序指示文件预计需要占用的空间大小。这使得操作系统可以检测到当空间不足时，并且可以预留空间，减少由于磁盘空间不足而导致的操作失败的可能性。`FileStreamOptions`的重载使得只设置那些不想要默认值的方面变得更容易——您只需设置相关属性。这意味着，如果没有一个`FileStream`构造函数重载正好符合您需要的参数组合，那也不再不方便。
- en: While `FileStream` gives you control over the contents of the file, some operations
    you might wish to perform on files are either cumbersome or not supported at all
    with `FileStream`. For example, you can copy a file with this class, but it’s
    not as straightforward as it could be, and `FileStream` does not offer any way
    to delete a file. So the runtime libraries include a separate class for these
    kinds of operations.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`FileStream`可以控制文件的内容，但有些操作可能非常繁琐，或者`FileStream`根本不支持。例如，您可以使用这个类复制文件，但这并不像可能的那么简单，并且`FileStream`没有提供任何删除文件的方法。因此，运行时库包含了一个专门的类来处理这类操作。
- en: File Class
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件类
- en: The static `File` class provides methods for performing various operations on
    files. The `Delete` method removes the named file from the filesystem. The `Move`
    method can either move or just rename a file. There are methods for retrieving
    information and attributes that the filesystem stores about each file, such as
    `GetCreationTime`, `GetLast``AccessTime`, `GetLastWriteTime`,^([5](ch15.xhtml#CHP-16-FN-5))
    and `GetAttributes`. (The last of those returns a `FileAttributes` value, which
    is a flags enumeration type telling you whether the file is read only, a hidden
    file, a system file, and so on.)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类`File`提供了各种文件操作的方法。`Delete`方法从文件系统中删除指定的文件。`Move`方法可以移动或重命名文件。还有一些方法用于检索文件系统存储的关于每个文件的信息和属性，如`GetCreationTime`、`GetLastAccessTime`、`GetLastWriteTime`^([5](ch15.xhtml#CHP-16-FN-5))和`GetAttributes`。（最后一个返回一个`FileAttributes`值，这是一个标志枚举类型，告诉您文件是否为只读、隐藏文件、系统文件等等。）
- en: The `Encrypt` method overlaps with `FileStream` to some extent—as you saw earlier,
    you can request that a file be stored with encryption when you create it. However,
    `Encrypt` is able to work with a file that has already been created without encryption—it
    effectively encrypts it in situ. (This is only supported on Windows, and only
    on drives where the filesystem supports it. It will throw `PlatformNotSupported​Ex⁠ception`
    on other operating systems, and `NotSupportedException` on Windows if encryption
    is not available for the specified file. This has the same effect as enabling
    encryption through a file’s Properties window in Windows File Explorer.) You can
    also turn an encrypted file back into an unencrypted one by calling `Decrypt`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`Encrypt`方法在某种程度上与`FileStream`重叠——正如您之前看到的，您可以在创建文件时请求以加密方式存储它。然而，`Encrypt`能够处理已经创建但未加密的文件——它会在原地对其进行加密。（这仅在Windows上支持，在文件系统支持的驱动器上有效。在其他操作系统上会抛出`PlatformNotSupportedException`异常，在Windows上如果指定的文件不支持加密也会抛出`NotSupportedException`异常。这与通过Windows文件资源管理器中的文件属性窗口启用加密具有相同的效果。）您还可以通过调用`Decrypt`将加密文件转换回未加密状态。'
- en: Note
  id: totrans-180
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It is not necessary to call `Decrypt` before reading an encrypted file. When
    logged in under the same user account that encrypted a file, you can read its
    contents in the usual way—encrypted files look just like normal ones because Windows
    automatically decrypts the contents as you read from them. The purpose of this
    particular encryption mechanism is that if some other user manages to obtain access
    to the file (e.g., if it’s on an external drive that gets stolen), the content
    will appear to be random junk. `Decrypt` removes this encryption, meaning that
    anyone who can access the file will be able to look at its contents.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取加密文件之前，不需要先调用`Decrypt`。在以加密文件的相同用户账户登录时，可以像平常一样读取其内容——加密文件看起来就像普通文件，因为Windows在读取时会自动解密内容。这种特定的加密机制的目的是，如果其他用户设法获取文件访问权限（例如，如果它在被盗的外部驱动器上），文件内容将会看起来像随机垃圾。`Decrypt`移除了这种加密，这意味着任何能够访问文件的人都能查看其内容。
- en: The other methods provided by `File` all just offer slightly more convenient
    ways of doing things you could have done by hand with `FileStream`. The `Copy`
    method makes a copy of a file, and while you could do that with the `CopyTo` method
    on `FileStream`, `Copy` takes care of some awkward details. For example, it ensures
    that the target file carries over attributes such as whether it’s read-only and
    whether encryption is enabled.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`File`提供的其他方法只是提供了更方便的方式来完成可以用`FileStream`手动完成的事情。`Copy`方法复制文件，虽然你可以使用`FileStream`的`CopyTo`方法来完成这个操作，但`Copy`方法会处理一些棘手的细节。例如，它确保目标文件保留诸如是否只读和是否启用加密等属性。'
- en: The `Exists` method lets you discover whether a file exists before you attempt
    to open it. You don’t strictly need this, because `FileStream` will throw a `FileNotFound`
    exception if you attempt to open a nonexistent file, but `Exists` is useful if
    you don’t need to do anything with the file other than determining whether it
    is there. If you are planning to open the file anyway, and are just trying to
    avoid an exception, you should be wary of this method; just because `Exists` returns
    `true`, that’s no guarantee that you won’t get a `FileNotFound` exception. It’s
    always possible that in between your checking for a file’s existence and attempting
    to open it, another process might delete the file. Alternatively, the file might
    be on a network share, and you might lose network connectivity. So you should
    always be prepared for exceptions with file access, even if you’ve attempted to
    avoid provoking them.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`Exists`方法允许你在尝试打开文件之前发现文件是否存在。虽然在尝试打开不存在的文件时，`FileStream`会抛出`FileNotFound`异常，但是`Exists`在你只需确定文件是否存在而不需要进行其他操作时很有用。如果你打算无论如何都要打开文件，并且只是想避免异常，那么你应该谨慎使用这个方法；仅仅因为`Exists`返回`true`并不意味着你不会收到`FileNotFound`异常。总是有可能在你检查文件存在性和尝试打开它之间，另一个进程删除了文件。或者，文件可能位于网络共享中，你可能会失去网络连接。因此，即使你试图避免引发异常，也应该时刻准备处理文件访问时可能出现的异常。'
- en: '`File` offers many helper methods to simplify opening or creating files. The
    `Create` method simply constructs a `FileStream` for you, passing in suitable
    `FileMode`, `FileAccess`, and `FileShare` values. [Example 15-10](#file.create_versus_new_filestream)
    shows how to use it and also shows what the equivalent code would look like without
    using the `Create` helper. The `Create` method provides overloads letting you
    specify the buffer size, `FileOptions`, and `FileSecurity`, but these still provide
    the other arguments for you.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`File`提供了许多辅助方法来简化打开或创建文件的过程。`Create`方法简单地为你构造一个`FileStream`，传入适当的`FileMode`、`FileAccess`和`FileShare`值。[示例 15-10](#file.create_versus_new_filestream)展示了如何使用它，同时展示了如果不使用`Create`辅助方法，等效的代码会是什么样子。`Create`方法提供了重载，允许你指定缓冲区大小、`FileOptions`和`FileSecurity`，但仍然为你提供了其他参数。'
- en: Example 15-10\. `File.Create` versus new `FileStream`
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-10\. `File.Create` versus 新建 `FileStream`
- en: '[PRE9]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `File` class’s `OpenRead` and `OpenWrite` methods provide similar decluttering
    for when you want to open an existing file for reading or open or create a file
    for writing. There’s also an `Open` method that requires you to pass a `FileMode`.
    This is of more marginal utility—it’s very similar to the `FileStream` constructor
    overload that also takes just a path and a mode, automatically supplying suitable
    other settings. The somewhat arbitrary difference is that while the `FileStream`
    constructor defaults to `FileShare.Read`, the `File.Open` method defaults to `FileShare.None`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`File` 类的 `OpenRead` 和 `OpenWrite` 方法为当你想要打开现有文件以供读取或打开或创建文件以供写入时提供了类似的简化功能。还有一个需要传递
    `FileMode` 的 `Open` 方法。这种方法的效用较低——它与也接受路径和模式参数的 `FileStream` 构造函数重载非常相似，自动提供适当的其他设置。它们的某种任意的区别在于，虽然
    `FileStream` 构造函数默认为 `FileShare.Read`，但 `File.Open` 方法默认为 `FileShare.None`。'
- en: '`File` also offers several text-oriented helpers. The simplest method, `OpenText`,
    opens a file for text reading and is of limited value because it does exactly
    the same thing as the `StreamReader` constructor that takes a single string argument.
    The only reason to use this is if you happen to prefer how it makes your code
    look—if your code makes heavy use of the `File` helpers, you might choose to use
    this for idiomatic consistency.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`File` 还提供了几个面向文本的辅助方法。最简单的方法是 `OpenText`，用于打开一个文本读取文件，但其价值有限，因为它与接受单个字符串参数的
    `StreamReader` 构造函数的功能完全相同。只有在你偏好它使你的代码看起来更加整洁时才会使用它——如果你的代码大量使用 `File` 辅助方法，你可能会选择出于惯用性一致性的考虑使用它。'
- en: Several of the methods exposed by `File` are text oriented. These enable us
    to improve on code of the kind shown in [Example 15-11](#appending_to_a_file_with_streamwriter).
    This appends a line of text to a logfile.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`File` 类暴露的几种方法都是面向文本的。这些方法使我们能够改进类似 [示例 15-11](#appending_to_a_file_with_streamwriter)
    中所示的代码。它向日志文件追加一行文本。'
- en: Example 15-11\. Appending to a file with `StreamWriter`
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-11\. 使用 `StreamWriter` 向文件追加
- en: '[PRE10]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: One issue with this is that it’s not all that easy to see at a glance how the
    `StreamWriter` is being opened—what does that `true` argument mean? As it happens,
    that tells the `StreamWriter` that we want it to create the underlying `FileStream`
    in append mode. [Example 15-12](#creating_an_appending_streamwriter_with) has
    the same effect—it uses `File.AppendText`, which just calls the exact same `FileStream`
    constructor for us. While I was somewhat dismissive of `File.OpenText` earlier
    for offering similarly marginal value, I think `File.AppendText` did once provide
    a genuinely useful improvement in readability in a way that `File.OpenText` does
    not. It’s much easier to see that [Example 15-12](#creating_an_appending_streamwriter_with)
    will append text to a file than it is with [Example 15-11](#appending_to_a_file_with_streamwriter).
    However, since support for named arguments was added to C#, `AppendText` now looks
    less useful—we could just name the `append` argument in [Example 15-11](#appending_to_a_file_with_streamwriter)
    for a similar improvement in readability.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个问题是一眼看不出 `StreamWriter` 是如何被打开的——`true` 参数的含义是什么？事实上，这告诉 `StreamWriter`
    我们希望它在追加模式下创建底层的 `FileStream`。[示例 15-12](#creating_an_appending_streamwriter_with)
    也具有相同的效果——它使用 `File.AppendText`，为我们调用完全相同的 `FileStream` 构造函数。尽管我之前对于 `File.OpenText`
    的评价有些苛刻，认为它提供的价值较低，但我认为 `File.AppendText` 曾经确实在可读性方面提供了真正有用的改进，而 `File.OpenText`
    并没有。相比之下，通过 C# 添加了对命名参数的支持后，`AppendText` 看起来不再那么有用了——我们可以在 [示例 15-11](#appending_to_a_file_with_streamwriter)
    中为 `append` 参数命名以达到类似的可读性改进。
- en: Example 15-12\. Creating an appending `StreamWriter` with `File.AppendText`
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-12\. 使用 `File.AppendText` 创建一个追加的 `StreamWriter`
- en: '[PRE11]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you’re only going to append some text to a file and immediately close it,
    there’s an even easier way. As [Example 15-13](#appending_a_single_string_to_a_file)
    shows, we can simplify things further with the `AppendAllText` helper.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想将一些文本附加到文件并立即关闭它，有一种更简单的方法。正如 [示例 15-13](#appending_a_single_string_to_a_file)
    所示，我们可以使用 `AppendAllText` 辅助方法进一步简化事情。
- en: Example 15-13\. Appending a single string to a file
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-13\. 将单个字符串附加到文件末尾
- en: '[PRE12]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Be careful, though. This does not do quite the same thing as [Example 15-12](#creating_an_appending_streamwriter_with).
    That example used `WriteLine` to append the text, but [Example 15-13](#appending_a_single_string_to_a_file)
    is equivalent to using just `Write`. So, if you were to call the `Log` method
    in [Example 15-13](#appending_a_single_string_to_a_file) multiple times, you’d
    end up with one long line in your output file, unless the strings you were using
    happened to contain end-of-line characters. If you want to work with lines, there’s
    an `AppendAllLines` method that takes a collection of strings and appends each
    as a new line to the end of a file. [Example 15-14](#appending_a_single_line_to_a_file)
    uses this to append a full line with each call.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要小心哦。这与[示例 15-12](#creating_an_appending_streamwriter_with)并不完全相同。该示例使用了`WriteLine`来追加文本，但[示例 15-13](#appending_a_single_string_to_a_file)相当于只使用了`Write`。因此，如果你在多次调用[示例 15-13](#appending_a_single_string_to_a_file)中的`Log`方法，除非你使用的字符串恰好包含行尾字符，否则你最终会在输出文件中得到一行长文本。如果你想逐行处理，可以使用`AppendAllLines`方法，该方法接受一个字符串集合，并将每个字符串作为新行追加到文件末尾。[示例 15-14](#appending_a_single_line_to_a_file)使用此方法在每次调用时追加一整行。
- en: Example 15-14\. Appending a single line to a file
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-14\. 向文件追加单行
- en: '[PRE13]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Since `AppendAllLines` accepts an `IEnumerable<string>`, you can use it to append
    any number of lines. But it’s perfectly happy to append just one if that’s what
    you want. `File` also defines `WriteAllText` and `WriteAllLines` methods, which
    work in a very similar way, but if there is already a file at the specified path,
    these will replace it instead of appending to it.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `AppendAllLines` 接受 `IEnumerable<string>`，因此您可以使用它来追加任意数量的行。但是如果您只想追加一行，它也完全可以胜任。`File`
    还定义了 `WriteAllText` 和 `WriteAllLines` 方法，它们的工作方式非常相似，但如果指定路径处已经存在文件，它们将替换它而不是追加到它。
- en: There are also some related text-oriented methods for reading the contents of
    files. `ReadAllText` performs the equivalent of constructing a `StreamReader`
    and then calling its `ReadToEnd` method—it returns the entire content of the file
    as a single `string`. `ReadAllBytes` fetches the whole file into a `byte[]` array.
    `ReadAllLines` reads the whole file as a `string[]` array, with one element for
    each line in the file. `ReadLines` is superficially very similar. It provides
    access to the whole file as an `IEnumerable<string>` with one item for each line,
    but the difference is that it works lazily—unlike all the other methods I’ve described
    in this paragraph, it does not read the entire file into memory up front, so `ReadLines`
    would be a better choice for very large files. It not only consumes less memory,
    but it also enables your code to get started more quickly—you can begin to process
    data as soon as the first line can be read from disk, whereas none of the other
    methods return until they have read the whole file.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些用于读取文件内容的相关文本方法。`ReadAllText`执行的是构造一个 `StreamReader`，然后调用其 `ReadToEnd` 方法的等效操作——它将整个文件内容作为一个单独的
    `string` 返回。`ReadAllBytes`将整个文件读入一个 `byte[]` 数组。`ReadAllLines`将整个文件作为一个 `string[]`
    数组读取，每行一个元素。`ReadLines`看起来非常相似。它以 `IEnumerable<string>` 的形式提供对整个文件的访问，每行一个条目，但不同之处在于它是懒加载的——与我在本段描述的所有其他方法不同，它不会一次性将整个文件读入内存，因此对于非常大的文件来说，`ReadLines`是更好的选择。它不仅消耗更少的内存，而且使您的代码能够更快地启动——只要从磁盘读取到第一行数据，您就可以开始处理数据，而其他方法在读取整个文件之前都不会返回。
- en: Directory Class
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Directory 类
- en: Just as `File` is a static class offering methods for performing operations
    with files, `Directory` is a static class offering methods for performing operations
    with directories. Some of the methods are very similar to those offered by `File`—there
    are methods to get and set the creation time, last access time, and last write
    time, for example, and we also get `Move`, `Exists`, and `Delete` methods. Unlike
    `File`, `Directory.Delete` has two overloads. One takes just a path and works
    only if the directory is empty. The other also takes a `bool` that, if `true`,
    will delete everything in the folder, recursively deleting any nested folders
    and the files they contain. Use that one carefully.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `File` 是一个静态类，提供用于执行文件操作的方法一样，`Directory` 也是一个静态类，提供用于执行目录操作的方法。其中一些方法与 `File`
    提供的方法非常相似——例如，有方法来获取和设置创建时间、最后访问时间和最后写入时间，还有 `Move`、`Exists` 和 `Delete` 方法。与 `File`
    不同，`Directory.Delete` 有两个重载。一个只接受路径，只有在目录为空时才起作用。另一个还接受一个 `bool` 参数，如果为 `true`，将递归删除文件夹中的所有内容，包括嵌套的文件夹和它们包含的文件。请谨慎使用这个方法。
- en: Of course, there are also directory-specific methods. `GetFiles` takes a directory
    path and returns a `string[]` array containing the full path of each file in that
    directory. There’s an overload that lets you specify a pattern by which to filter
    the results, and a third overload that takes a pattern and also a flag that lets
    you request recursive searching of all subfolders. [Example 15-15](#recursively_searching_for_files_of_a_par)
    uses that to find all files with a *.jpg* extension in my *Pictures* folder. (Unless
    you’re also called Ian, you’d need to change that path to match your account name
    for this to work on your computer.) In a real application, you should get this
    path using the technique shown in [“Known Folders”](#known_folders).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有专用于目录的方法。`GetFiles`接受一个目录路径，并返回包含该目录中每个文件的完整路径的`string[]`数组。还有一个重载方法，允许您指定一个模式来过滤结果，并且第三个重载方法接受一个模式，并且还可以使用一个标志来请求递归搜索所有子文件夹。[示例 15-15](#recursively_searching_for_files_of_a_par)
    使用它来查找我的*Pictures*文件夹中所有具有*.jpg*扩展名的文件。（除非您也叫伊恩，否则您需要更改该路径以匹配您的帐户名称，以使其在您的计算机上起作用。）在实际应用程序中，您应该使用[“已知文件夹”](#known_folders)中显示的技术获取此路径。
- en: Example 15-15\. Recursively searching for files of a particular type
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-15\. 递归搜索特定类型的文件
- en: '[PRE14]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There is a similar `GetDirectories` method, offering the same three overloads,
    which returns the directories inside the specified directory instead of returning
    files. And there’s a `GetFileSystemEntries` method, again with the same three
    overloads, which returns both files and folders.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个类似的`GetDirectories`方法，提供相同的三个重载，它返回指定目录中的目录而不是文件。还有一个`GetFileSystemEntries`方法，同样有三个重载，它返回文件和文件夹。
- en: There are also methods called `EnumerateFiles`, `EnumerateDirectories`, and
    `EnumerateFileSystemEntries`, which do exactly the same thing as the three `GetXxx`
    methods, but they return `IEnumerable<string>`. This is a lazy enumeration, so
    you can start processing results immediately instead of waiting for all the results
    as one big array.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些称为`EnumerateFiles`、`EnumerateDirectories`和`EnumerateFileSystemEntries`的方法，与三个`GetXxx`方法完全相同，但它们返回`IEnumerable<string>`。这是一种延迟枚举，因此您可以立即开始处理结果，而不是等待所有结果作为一个大数组。
- en: The `Directory` class offers methods relating to the process’s current directory
    (the one used any time you call a file-based API without specifying the full path).
    `GetCurrentDirectory` returns the path, and `SetCurrentDirectory` sets it.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`Directory`类提供与进程当前目录（每次调用文件API而不指定完整路径时使用的目录）相关的方法。`GetCurrentDirectory`返回路径，`SetCurrentDirectory`设置它。'
- en: 'You can create new directories too. The `CreateDirectory` method takes a path
    and will attempt to create as many directories as are necessary to ensure that
    the path exists. So, if you pass *C:\new\dir\here*, and there is no *C:\new* directory,
    it will create three new directories: first it will create *C:\new*, then *C:\new\dir*,
    and then *C:\new\dir\here*. If the folder you ask for already exists, it doesn’t
    treat that as an error; it just returns without doing anything.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以创建新目录。`CreateDirectory`方法接受一个路径，并尝试创建尽可能多的目录，以确保路径存在。因此，如果您传递*C:\new\dir\here*，并且没有*C:\new*目录，它将创建三个新目录：首先它将创建*C:\new*，然后*C:\new\dir*，然后*C:\new\dir\here*。如果您请求的文件夹已经存在，它不会将其视为错误；它只是返回而不执行任何操作。
- en: The `GetDirectoryRoot` strips a directory path down to the drive name or other
    root, such as a network share name. For example, on Windows if you pass this *C:\temp\logs*,
    it will return *C:\*; and if you pass *\\someserver\myshare\dir\test*, it will
    return *\\someserver\myshare*. This sort of string slicing, in which you split
    a path into its component parts, is a sufficiently common requirement that there’s
    a class dedicated to various operations of this kind.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetDirectoryRoot`将目录路径剥离为驱动器名称或其他根目录，例如网络共享名称。例如，在Windows上，如果您传递*C:\temp\logs*，它将返回*C:\*；如果您传递*\\someserver\myshare\dir\test*，它将返回*\\someserver\myshare*。这种字符串分割操作，即将路径拆分为其组成部分，是一个非常常见的需求，因此有一个专门的类来处理这类操作。'
- en: Path Class
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路径类
- en: The static `Path` class provides useful utilities for strings containing filenames.
    Some extract pieces from a file path, such as the containing folder name or the
    file extension. Some combine strings to produce new file paths. Most of these
    methods just perform specialized string processing and do not require the files
    or directories to which the paths refer to exist. However, there are a few that
    go beyond string manipulation. For example, `Path.GetFullPath` will take the current
    directory into account if you do not pass an absolute path as the argument. But
    only the methods that need to make use of real locations will do so.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path` 类提供了一些有用的工具函数，用于处理包含文件名的字符串。其中一些函数用于从文件路径中提取片段，比如包含的文件夹名称或文件扩展名。还有一些函数用于组合字符串，生成新的文件路径。这些大多数方法仅执行特定的字符串处理，不需要路径所指代的文件或目录真实存在。然而，也有一些方法超出了字符串操作的范畴。例如，`Path.GetFullPath`
    方法会考虑当前目录，如果传入的参数不是绝对路径的话。但只有需要使用真实位置的方法才会这样做。'
- en: The `Path.Combine` method deals with the fiddly issues around combining folder
    and filenames. If you have a folder name, *C:\temp*, and a filename, *log.txt*,
    passing both to `Path.Combine` returns *C:\temp\log.txt*. And it will also work
    if you pass *C:\temp\* as the first argument, so one of the issues it deals with
    is working out whether it needs to supply an extra `\` character. If the second
    path is absolute, it detects this and simply ignores the first path, so if you
    pass *C:\temp* and *C:\logs\log.txt*, the result will be *C:\logs\log.txt*. Although
    these may seem like trivial matters, it’s surprisingly easy to get the file path
    combination wrong if you try to do it yourself by concatenating strings, so you
    should always avoid the temptation to do that and just use `Path.Combine`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path.Combine` 方法处理了在组合文件夹和文件名时遇到的繁琐问题。如果你有一个文件夹名 *C:\temp* 和一个文件名 *log.txt*，将它们同时传给
    `Path.Combine` 方法会返回 *C:\temp\log.txt*。如果将 *C:\temp\* 作为第一个参数传入，它也会正常工作，因此其中一个处理的问题是确定是否需要提供额外的
    `\` 字符。如果第二个路径是绝对路径，它会检测并简单地忽略第一个路径，因此如果你传入 *C:\temp* 和 *C:\logs\log.txt*，结果将会是
    *C:\logs\log.txt*。虽然这些问题可能看起来微不足道，但如果尝试通过字符串连接自己做文件路径的组合，很容易出错，因此你应该始终避免这样做，而是使用
    `Path.Combine` 方法。'
- en: .NET Core and .NET have platform-specific behavior when it comes to paths. On
    Unix-like systems, only the `/` character is used as a directory separator, so
    the various methods in `Path` that expect paths to contain directories will treat
    only `/` as a separator on these systems. Windows uses a `\` as a separator, although
    it is common for `/` to be tolerated as a substitute, and `Path` follows suit.
    So `Path​.Com⁠bine("/x/y", "/z.txt")` will produce the same results on Windows
    and Linux, but `Path.Combine(@"\x\y", @"\z.txt")` will not. Also, on Windows,
    if a path begins with a drive letter, it is an absolute path, but Unix does not
    recognize drive letters. The examples in the preceding paragraph will produce
    strange-looking results on Linux or macOS because on those systems, all the paths
    will be treated as relative paths. If you remove the drive letters and replace
    `\` with `/`, the results will be as you’d expect.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及路径时，.NET Core 和 .NET 在不同平台上表现不同。在类 Unix 系统上，只使用 `/` 作为目录分隔符，因此 `Path` 类中期望路径包含目录的各种方法会在这些系统上将
    `/` 视为唯一的分隔符。Windows 使用 `\` 作为分隔符，尽管在 Windows 上也普遍容忍使用 `/` 作为替代，`Path` 类也支持这一点。因此，`Path​.Com⁠bine("/x/y",
    "/z.txt")` 在 Windows 和 Linux 上会产生相同的结果，但 `Path.Combine(@"\x\y", @"\z.txt")` 则不会。此外，在
    Windows 上，如果路径以驱动器号开头，则是绝对路径，但 Unix 不认识驱动器号。在上文中的例子中，如果在 Linux 或 macOS 上移除驱动器号并将
    `\` 替换为 `/`，结果将会是你所期望的。
- en: Given a file path, the `GetDirectoryName` method removes the filename part and
    just returns the directory. This method provides a good illustration of why you
    need to remember that most of the `Path` class’s members do not look at the filesystem.
    If you didn’t take that into account, you might expect that if you pass `GetDirectoryName`
    just the name of a directory such as *C:\Program Files*, it would detect that
    this is a directory and return the same string, but in fact it will return just
    *C:\*. The name *Program Files* is a perfectly good name for either a file or
    a directory, and since `GetDirectoryName` does not inspect the disk, and it expects
    to be passed a path that includes a filename, it will conclude in this case that
    it is a file. (Arguably, even if it were aware that *C:\Program Files* is a directory,
    *C:\* would be the correct result because that is the directory that contains
    the *Program Files* directory.) This method effectively looks for the final `/`
    or `\` character and returns everything before that. (So, if you pass a directory
    name with a trailing `\`, such as *C:\Program Files\*, it will return *C:\Program
    Files*. Then again, the whole point of this API is to remove the filename from
    a file’s full path. If you already have a string with just a directory name, you
    should not call this API.)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 给定文件路径，`GetDirectoryName` 方法会移除文件名部分，仅返回目录。这个方法很好地说明了为什么你需要记住大多数 `Path` 类的成员不会查看文件系统。如果你没有考虑这一点，你可能会期望当你传递给
    `GetDirectoryName` 一个目录名，比如 *C:\Program Files*，它会检测到这是一个目录并返回相同的字符串，但事实上它将仅返回
    *C:\*。名称 *Program Files* 对于文件或目录来说都是一个完全合法的名称，由于 `GetDirectoryName` 不会检查磁盘，并且它期望传递的路径包括文件名，因此在这种情况下它会认为这是一个文件。（可以说，即使它意识到
    *C:\Program Files* 是一个目录，*C:\* 也将是正确的结果，因为那是包含 *Program Files* 目录的目录。）该方法有效地查找最后的
    `/` 或 `\` 字符，并返回其前面的所有内容。（因此，如果你传递一个带有尾部 `\` 的目录名，比如 *C:\Program Files\*，它将返回
    *C:\Program Files*。然而，这个 API 的整个目的是从文件的完整路径中移除文件名。如果你已经有一个只有目录名的字符串，你不应该调用这个 API。）
- en: The `GetFileName` method returns just the filename (including the extension,
    if any). Like `GetDirectoryName`, it also looks for the last directory separator
    character, but it returns the text that comes after it rather than before it.
    Again, it does not look at the filesystem—this works purely through string manipulation
    (although as with all of these operations, it takes into account the local system’s
    rules for what counts as a directory separator or an absolute path). `GetFileNameWithoutExtension`
    is similar, but if an extension is present (e.g., *.txt* or *.jpg*), it removes
    that from the end of the name. Conversely, `GetExtension` returns the extension
    and nothing else.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetFileName` 方法返回文件名（包括扩展名，如果有）。和 `GetDirectoryName` 一样，它也查找最后的目录分隔符字符，但返回的是它后面的文本，而不是前面的文本。同样，它不查看文件系统——这完全通过字符串操作完成（尽管和所有这些操作一样，它考虑了本地系统对于目录分隔符或绝对路径的规则）。`GetFileNameWithoutExtension`
    类似，但如果存在扩展名（如 *.txt* 或 *.jpg*），它会从名称的末尾移除扩展名。相反，`GetExtension` 返回扩展名而不返回其他内容。'
- en: 'If you need to create temporary files to perform some work, `Path` provides
    three useful methods. `GetRandomFileName` uses a random-number generator to create
    a name you can use for either a random file or folder. The random number is cryptographically
    strong, which provides two useful properties: the name will be unique and hard
    to guess. (Certain kinds of attacks on a system’s security can become possible
    if an attacker can predict the name or location of temporary files.) This method
    does not actually create anything on the filesystem—it just hands back a suitable
    name. `GetTempFileName`, on the other hand, will create a file in the location
    the OS provides for temporary files. This file will be empty, and the method returns
    you its path as a string. You can then open the file and modify it. (This does
    not guarantee that cryptography will be used to pick a truly random name, so you
    should not depend on this sort of file’s location being unguessable. It will be
    unique, but that is all.) You should delete any file created by `GetTempFileName`
    once you have finished with it. Finally, `GetTempPath` returns the path of the
    folder that `GetTempFileName` would use; this doesn’t create anything, but you
    could use this in conjunction with a name returned by `GetRandomFileName` (combined
    with `Path.Combine`) to pick a location in which to create your own temporary
    file.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要创建临时文件来执行一些工作，`Path` 提供了三个有用的方法。`GetRandomFileName` 使用随机数生成器创建一个您可以用于随机文件或文件夹的名称。这个随机数是密码强度的，具有两个有用的属性：名称将是唯一且难以猜测的。（如果攻击者能够预测临时文件的名称或位置，系统安全的某些攻击可能变得可能。）这个方法实际上不会在文件系统上创建任何内容，它只是返回一个合适的名称。另一方面，`GetTempFileName`
    将在操作系统为临时文件提供的位置创建一个文件。这个文件将是空的，并且该方法返回其路径作为一个字符串。然后您可以打开文件并修改它。（这并不保证使用加密来选择一个真正随机的名称，因此不应依赖于此类文件位置的不可猜测性。它将是唯一的，但仅此而已。）您应该在完成对其的操作后删除由
    `GetTempFileName` 创建的任何文件。最后，`GetTempPath` 返回 `GetTempFileName` 将使用的文件夹的路径；这并不会创建任何内容，但您可以与
    `GetRandomFileName` 返回的名称（与 `Path.Combine` 结合使用）一起使用它来选择一个位置来创建您自己的临时文件。
- en: FileInfo, DirectoryInfo, and FileSystemInfo
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FileInfo、DirectoryInfo 和 FileSystemInfo
- en: Although the `File` and `Folder` classes provide you with access to information—such
    as a file’s creation time and whether it is a system file or a read-only file—those
    classes have an issue if you need access to multiple pieces of information. It’s
    not very efficient to collect each bit of data with a separate call, because the
    information can be fetched from the underlying OS with fewer steps. Also, it can
    sometimes be easier to pass around a single object containing all the data you
    need instead of finding somewhere to put lots of separate items. So the `System.IO`
    namespace defines `FileInfo` and `DirectoryInfo` classes that contain the information
    about a file or directory. Since there’s a certain amount of common ground, these
    types both derive from a base class, `FileSystemInfo`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `File` 和 `Folder` 类提供了访问信息的方式——例如文件的创建时间以及它是系统文件还是只读文件——但如果您需要访问多个信息，这些类存在问题。使用单独的调用收集每个数据位不是很高效，因为可以通过更少的步骤从底层操作系统获取信息。此外，有时传递包含您需要的所有数据的单个对象可能更容易，而不是找到放置许多单独项目的地方。因此，`System.IO`
    命名空间定义了包含有关文件或目录信息的 `FileInfo` 和 `DirectoryInfo` 类。由于存在一定的共同点，这些类型都派生自基类 `FileSystemInfo`。
- en: To construct instances of these classes, you pass the path of the file or folder
    you want, as [Example 15-16](#displaying_information_about_a_file_with) shows.
    By the way, if sometime later you think the file may have been changed by some
    other program, and you want to update the information a `FileInfo` or `DirectoryInfo`
    returns, you can call `Refresh`, and it will reload information from the filesystem.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要构造这些类的实例，您需要传递您想要的文件或文件夹的路径，就像 [示例 15-16](#displaying_information_about_a_file_with)
    中所示。顺便说一句，如果稍后您认为文件可能已被其他程序更改，并且您想要更新 `FileInfo` 或 `DirectoryInfo` 返回的信息，您可以调用
    `Refresh`，它将重新加载来自文件系统的信息。
- en: Example 15-16\. Displaying information about a file with `FileInfo`
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-16\. 使用 `FileInfo` 显示有关文件的信息
- en: '[PRE15]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As well as providing properties corresponding to the various `File` and `Directory`
    methods that fetch information (`CreationTime`, `Attributes,` etc.), these information
    classes provide instance methods that correspond to many of the static methods
    of `File` and `Directory`. For example, if you have a `FileInfo`, it provides
    `Delete`, `Encrypt`, and `Decrypt`—methods that work just like their `File` namesakes,
    except you don’t need to pass a path argument. There is also a counterpart of
    `Move`, although with a different name, `MoveTo`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供对应于各种`File`和`Directory`方法获取信息（`CreationTime`、`Attributes`等）的属性外，这些信息类还提供了实例方法，这些方法对应于`File`和`Directory`的许多静态方法。例如，如果你有一个`FileInfo`，它提供了`Delete`、`Encrypt`和`Decrypt`等方法，这些方法的工作方式与它们的`File`名称相同，只是你不需要传递路径参数。还有一个名为`MoveTo`的对应方法，尽管名字不同，但功能相同。
- en: '`FileInfo` also provides equivalents to the various helper methods for opening
    the file with a `Stream` or a `FileStream`, such as `AppendText`, `OpenRead`,
    and `OpenText`. Perhaps more surprisingly, `Create` and `CreateText` are also
    available. It turns out that you can construct a `FileInfo` for a file that does
    not exist yet and then create it with these helpers. It doesn’t attempt to populate
    any of the properties that describe the file until the first time you try to read
    them, so it will defer throwing a `FileNotFound​Ex⁠ception` until that point,
    in case you were creating the `FileInfo` in order to create a new file.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileInfo`还提供了与使用`Stream`或`FileStream`打开文件的各种辅助方法的等效方法，例如`AppendText`、`OpenRead`和`OpenText`。也许更令人惊讶的是，`Create`和`CreateText`也是可用的。事实证明，你可以为尚不存在的文件构造一个`FileInfo`，然后使用这些辅助方法创建它。它不会尝试填充描述文件的任何属性，直到你尝试读取它们的第一次，因此它会推迟在那一点抛出`FileNotFound​Ex⁠ception`，以防你创建`FileInfo`是为了创建新文件。'
- en: As you’d expect, `DirectoryInfo` also offers instance methods that correspond
    to the various static helper methods defined by `Directory`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所料，`DirectoryInfo`也提供了实例方法，这些方法对应于`Directory`定义的各种静态辅助方法。
- en: Known Folders
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已知文件夹
- en: Desktop applications sometimes need to use specific folders. For example, an
    application’s settings will typically be stored in a certain folder under the
    user’s profile. There’s a separate folder for system-wide application settings.
    On Windows these are typically in the user’s *AppData* folder and *C:\ProgramData*,
    respectively. Windows also defines standard places for pictures, videos, music,
    and documents, and there are also folders representing special shell features,
    such as the desktop and the user’s “favorites.”
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面应用程序有时需要使用特定的文件夹。例如，应用程序的设置通常存储在用户配置文件夹的特定文件夹中。有一个专门用于系统范围应用程序设置的文件夹。在Windows上，这些通常位于用户的*AppData*文件夹和*C:\ProgramData*文件夹中。Windows还定义了图片、视频、音乐和文档的标准位置，还有代表特殊外壳功能的文件夹，例如桌面和用户的“收藏夹”。
- en: Although these folders are often in much the same place from one system to another,
    you should never presume that they will be where you expect. (So you should never
    do what [Example 15-15](#recursively_searching_for_files_of_a_par) does in real
    code.) Many of these folders have different names in localized versions of Windows.
    And even within a particular language, there’s no guarantee that these folders
    will be in the usual place—it’s possible to move some of them, and the locations
    have not remained fixed across different versions of Windows.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些文件夹在不同系统中通常位于相同位置，但你不应假设它们会出现在你期望的位置。（因此，在真实代码中，你不应像[示例 15-15](#recursively_searching_for_files_of_a_par)那样做。）许多这些文件夹在Windows的本地化版本中有不同的名称。甚至在特定语言中，也不能保证这些文件夹会出现在通常的位置——有些文件夹是可以移动的，并且它们的位置在不同版本的Windows中并不固定。
- en: So, if you need access to a particular standard folder, you should use the `Environment`
    class’s `GetFolderPath` method, as shown in [Example 15-17](#discovering_where_to_store_settings).
    This takes a member from the nested `Environment.SpecialFolder` enum type, which
    defines values for all of the well-known folder types available in Windows.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果需要访问特定的标准文件夹，应使用`Environment`类的`GetFolderPath`方法，如[示例 15-17](#discovering_where_to_store_settings)中所示。这个方法接受来自嵌套的`Environment.SpecialFolder`枚举类型的成员，该枚举定义了Windows中所有已知文件夹类型的值。
- en: Example 15-17\. Discovering where to store settings
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-17\. 发现存储设置的位置
- en: '[PRE16]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-234
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: On non-Windows systems, `GetFolderPath` returns an empty string for most of
    this enumeration’s entries, because there is no local equivalent. However, a few
    work, such as `MyDocuments`, `Common​Ap⁠plicationData`, and `UserProfile`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在非 Windows 系统上，对于大多数此枚举条目，`GetFolderPath` 返回空字符串，因为没有本地等效项。但是，有些项确实有效，比如 `MyDocuments`，`Common​Ap⁠plicationData`
    和 `UserProfile`。
- en: The `ApplicationData` folder is in the roaming section of the user’s profile.
    Information that does not need to be copied across all the machines a person uses
    (e.g., a cache that could be reconstructed if necessary) should go in the local
    section, which you can get with the `LocalApplicationData` enum entry.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApplicationData` 文件夹位于用户配置文件的漫游部分。不需要在用户使用的所有计算机上复制的信息（例如，如果需要可以重建的缓存），应放在本地部分，可以使用
    `LocalApplicationData` 枚举项获取。'
- en: Serialization
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化
- en: The `Stream`, `TextReader`, and `TextWriter` types provide the ability to read
    and write data in files, networks, or anything else stream-like that provides
    a suitable concrete class. But these abstractions support only byte or text data.
    Suppose you have an object with several properties of various types, including
    some numeric types and perhaps also references to other objects, some of which
    might be collections. What if you wanted to write all the information in that
    object out to a file or over a network connection so that an object of the same
    type and with the same property values could be reconstituted at a later date,
    or on another computer at the other end of a connection?
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream`、`TextReader` 和 `TextWriter` 类型提供了在文件、网络或其他类似流的任何东西中读取和写入数据的能力，只要提供一个适当的具体类。但这些抽象仅支持字节或文本数据。假设您有一个具有多个类型属性的对象，包括一些数值类型，可能还包括对其他对象的引用，其中一些可能是集合。如果您希望将该对象的所有信息写入文件或通过网络连接发送，以便稍后在同一类型的对象和相同属性值的计算机上或连接的另一端重新构建该对象，该怎么办？'
- en: You could do this with the abstractions shown in this chapter, but it would
    require a fair amount of work. You’d have to write code to read each property
    and write its value out to a `Stream` or `TextWriter`, and you’d need to convert
    the value to either binary or text. You’d also need to decide on your representation—would
    you just write values out in a fixed order, or would you come up with a scheme
    for writing name/value pairs so that you’re not stuck with an inflexible format
    if you need to add more properties later on? You’d also need to come up with ways
    to handle collections and references to other objects, and you’d need to decide
    what to do in the face of circular references—if two objects each refer to one
    another, naive code could end up getting stuck in an infinite loop.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用本章中显示的抽象来完成此操作，但这需要相当多的工作。您需要编写代码来读取每个属性并将其值写入到 `Stream` 或 `TextWriter`
    中，并且需要将值转换为二进制或文本。您还需要决定您的表示方式——您只是按固定顺序写入值，还是会设计一种方案来写入名称/值对，以便在日后需要添加更多属性时不受限制？您还需要想出处理集合和对其他对象的引用的方法，并且需要决定在面对循环引用时应采取的措施——如果两个对象互相引用，简单的代码可能会陷入无限循环。
- en: .NET offers several solutions to this problem, each making varying trade-offs
    between the complexity of the scenarios they are able to support, how well they
    deal with versioning, and how suitable they are for interoperating with other
    platforms. These techniques all fall under the broad name of *serialization* (because
    they involve writing an object’s state into some form that stores data sequentially—serially—such
    as a `Stream`). Many different mechanisms have been introduced over the years
    in .NET, so I won’t cover all of them. I’ll just present the ones that best represent
    particular approaches to the problem.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 提供了几种解决此问题的方案，每种方案在能够支持的场景复杂性、版本控制的处理能力以及与其他平台的互操作性方面存在不同的权衡。这些技术都属于广义上的*序列化*（因为它们涉及将对象的状态按顺序写入某种形式的数据存储中——序列化——例如
    `Stream`）。多年来在 .NET 中引入了许多不同的机制，所以我不会涵盖所有内容。我只会介绍最能代表特定方法处理该问题的几种方式。
- en: BinaryReader, BinaryWriter, and BinaryPrimitives
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BinaryReader、BinaryWriter 和 BinaryPrimitives
- en: 'Although they are not strictly forms of serialization, no discussion of this
    area is complete without covering the `BinaryReader` and `BinaryWriter` classes,
    because they solve a fundamental problem that any attempt to serialize and deserialize
    objects must deal with: they can convert the CLR’s intrinsic types to and from
    streams of bytes. `BinaryPrimitives` does the same thing, but it is able to work
    with `Span<byte>` and related types, which are discussed in [Chapter 18](ch18.xhtml#ch_memory_efficiency).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们不严格属于序列化形式，但任何关于此领域的讨论都不完整，没有涵盖`BinaryReader`和`BinaryWriter`类，因为它们解决了任何序列化和反序列化对象尝试必须处理的基本问题：它们可以将CLR的内置类型转换为字节流，`BinaryPrimitives`也做同样的事情，但它能够处理`Span<byte>`和相关类型，这些在[第18章](ch18.xhtml#ch_memory_efficiency)中讨论过内存效率。
- en: '`BinaryWriter` is a wrapper around a writable `Stream`. It provides a `Write`
    method that has overloads for all of the intrinsic types except for `object`.
    So it can take a value of any of the numeric types, or the `string`, `char`, or
    `bool` types, and it writes a binary representation of that value into a `Stream`.
    It can also write arrays of type `byte` or `char`.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`BinaryWriter`是围绕可写的`Stream`的包装器。它提供了一个`Write`方法，支持除了`object`类型以外的所有内置类型的重载。因此，它可以接受任何数值类型、`string`、`char`或`bool`类型的值，并将该值的二进制表示写入`Stream`中。它还可以写入`byte`或`char`类型的数组。'
- en: '`BinaryReader` is a wrapper around a readable `Stream`, and it provides various
    methods for reading data, each corresponding to the overloads of `Write` provided
    by `BinaryWriter`. For example, you have `ReadDouble`, `ReadInt32`, and `ReadString`.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`BinaryReader`是围绕可读的`Stream`的包装器，提供了各种用于读取数据的方法，每种方法对应于`BinaryWriter`提供的`Write`的重载。例如，您有`ReadDouble`、`ReadInt32`和`ReadString`等方法。'
- en: To use these types, you would create a `BinaryWriter` when you want to serialize
    some data, and write out each value you wish to store. When you later want to
    deserialize that data, you’d wrap a `BinaryReader` around a stream containing
    the data written with the writer, and call the relevant read methods in the exact
    same order that you wrote the data out in the first place.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些类型，当您想要序列化一些数据时，可以创建一个`BinaryWriter`，并写入每个要存储的值。稍后当您想要反序列化该数据时，可以围绕包含写入的数据的流创建一个`BinaryReader`，并按照与首次写出数据时完全相同的顺序调用相关的读取方法。
- en: '`BinaryPrimitives` works slightly differently. It is designed for code that
    needs to minimize the number of heap allocations, so it’s not a wrapper type—it
    is a static class offering a wide range of methods, such as `ReadInt32LittleEndian`
    and `WriteUInt16BigEndian`. These take `ReadOnlySpan<byte>` and `Span<byte>` arguments,
    respectively, because it is designed to work directly with data wherever it may
    lie in memory (not necessarily wrapped in a `Stream`). However, the basic principle
    is the same: it converts between byte sequences and primitive .NET types. (Also,
    string handling is rather more complex: there’s no `ReadString` method because
    anything that returns a `string` will create a new string object on the heap,
    unless there’s a fixed set of possible strings that you can preallocate and hand
    out again and again. See [Chapter 18](ch18.xhtml#ch_memory_efficiency) for details.)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`BinaryPrimitives`的工作方式略有不同。它专为需要最小化堆分配数量的代码设计，因此它不是一个包装器类型，而是一个静态类，提供了广泛的方法，如`ReadInt32LittleEndian`和`WriteUInt16BigEndian`。这些方法分别接受`ReadOnlySpan<byte>`和`Span<byte>`参数，因为它设计为直接处理内存中的数据（不一定是包装在`Stream`中）。然而，其基本原理是相同的：它在字节序列与基本的.NET类型之间进行转换。（另外，字符串处理相对复杂：没有`ReadString`方法，因为返回`string`的任何方法都会在堆上创建一个新的字符串对象，除非有一个预先分配并反复分配的固定字符串集。有关详细信息，请参见[第18章](ch18.xhtml#ch_memory_efficiency)。）'
- en: These classes only solve the problem of how to represent various built-in types
    in binary. You are still left with the task of working out how to represent whole
    objects and what to do about more complex kinds of structures such as references
    between objects.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类仅解决了如何以二进制形式表示各种内置类型的问题。您仍然需要解决如何表示整个对象以及如何处理对象之间的引用等更复杂的结构。
- en: CLR Serialization
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CLR序列化
- en: CLR serialization is, as the name suggests, a feature built into the runtime
    itself—it is not simply a library feature. Although it has been in .NET Framework
    since v1.0, it was not supported in .NET Core for the first few versions, but
    Microsoft eventually added it back in a somewhat reduced form to make it easier
    to migrate applications from .NET Framework. Microsoft discourages its use, but
    it continues to be popular in certain scenarios. It is fairly widely used in microservice
    environments for sending exceptions and relatively straightforward data structures
    across service boundaries. The limited support that .NET Core and .NET provide
    is aimed at these scenarios, so you cannot serialize just any old .NET object.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: CLR序列化如其名称所示，是内置到运行时本身的特性——它不仅仅是一个库功能。虽然它自.NET Framework 1.0起就存在，但在最初几个版本的.NET
    Core中并未支持，但微软最终以一种较简化的形式将其重新添加回去，以便更轻松地从.NET Framework迁移应用程序。微软不鼓励使用它，但在某些场景中它仍然很受欢迎。在微服务环境中，它被广泛用于跨服务边界发送异常和相对简单的数据结构。.NET
    Core和.NET提供的有限支持针对这些场景，因此你不能对任意的.NET对象进行序列化。
- en: The most interesting aspect of CLR serialization is that it deals directly with
    object references. If you serialize, say, a `List<SomeType>` where multiple entries
    in the list refer to the same object, CLR serialization will detect this, storing
    just one copy of that object, and when deserializing, it will re-create that one-object-many-references
    structure. (Serialization systems based on the very widely used JSON format normally
    don’t do this.)
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: CLR序列化最有趣的方面是它直接处理对象引用。如果你序列化一个`List<SomeType>`，其中列表中的多个条目引用同一个对象，CLR序列化会检测到这一点，只存储该对象的一个副本，在反序列化时会重新创建这个一个对象多个引用的结构。（基于非常广泛使用的JSON格式的序列化系统通常不会这样做。）
- en: Types are required to opt into CLR serialization. .NET defines a `[Serializable]`
    attribute that must be present, and once you’ve added this, the CLR can take care
    of all of the details for you. Serialization works directly with an object’s fields.
    It uses reflection, which enables it to access all of them, whether public or
    private. The `BinaryFormatter` type (which is in the `System.Runtime.Serialization.Format⁠ters​.Binary`
    namespace) provides a `Serialize` method that will write an instance of any serializable
    type to a stream. It correctly detects circular references, storing just one copy
    of each object in the stream, and when we pass the resulting stream back into
    the `Deserialize` method, it will restore any such structure correctly.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 类型需要选择CLR序列化。.NET定义了一个`[Serializable]`属性，必须存在，一旦你添加了这个属性，CLR就可以为你处理所有细节。序列化直接使用对象的字段。它使用反射来访问所有字段，无论是公共的还是私有的。`BinaryFormatter`类型（位于`System.Runtime.Serialization.Formatters.Binary`命名空间中）提供了一个`Serialize`方法，可以将任何可序列化类型的实例写入流中。它正确地检测到循环引用，在流中仅存储每个对象的一个副本。当我们将生成的流传递给`Deserialize`方法时，它将正确地恢复任何这样的结构。
- en: 'So this is pretty powerful—by adding a single attribute, I can write out a
    complete graph of objects. There is a downside: if I change the implementation
    of any of the types being serialized, I will be in trouble if a new version of
    my code attempts to deserialize a stream produced by an old version. So this is
    not a good choice for writing out an application’s settings to disk, because those
    are likely to evolve with each new version. As it happens, you can customize the
    way serialization works, which does make it possible to support versioning, but
    at that point, you’re back to doing a lot of the work by hand. (It may actually
    be easier to use `BinaryReader` and `BinaryWriter`.) Also, it’s easy to introduce
    security problems with this style of serialization: someone who controls a stream
    that you deserialize essentially has complete control over all the fields of your
    objects. The documentation states that `BinaryFormatter` “is insecure and can’t
    be made secure,” and you will see deprecation warnings when you attempt to use
    it. So I’m only describing CLR serialization here because it still gets used despite
    Microsoft’s attempts to end it, and also because its existence means that an assumption
    you might otherwise have made about object creation—specifically that a reference
    type can only be created through one of its constructors or via `MemberwiseClone`—turns
    out not be true.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 因此这非常强大——通过添加一个属性，我可以将整个对象图写出来。但也有缺点：如果我改变了任何被序列化类型的实现，那么当新版本的代码尝试反序列化旧版本生成的流时，我会遇到问题。因此，这并不适合将应用程序的设置写入磁盘，因为这些设置可能会随着每个新版本而演变。实际上，你可以定制序列化的方式，这样可以支持版本控制，但到了这一步，你又要手工完成大部分工作。（实际上使用`BinaryReader`和`BinaryWriter`可能更容易。）此外，使用这种序列化方式很容易引入安全问题：控制反序列化流的人基本上可以完全控制你对象的所有字段。文档指出，`BinaryFormatter`“不安全且无法安全使用”，当你尝试使用它时会看到弃用警告。因此，我在这里只是描述CLR序列化，因为尽管微软试图终止它，但它仍然在使用，而且因为它的存在意味着你可能对对象创建有所假设——特别是引用类型只能通过其构造函数或通过`MemberwiseClone`创建，但事实证明这并非正确。
- en: Another issue with CLR serialization is that it produces binary streams in a
    .NET-specific format. If the only code that needs to deal with the stream is running
    .NET, then that’s not a problem, but you might want to produce streams for a broader
    audience. There are other serialization mechanisms than CLR serialization, and
    these can produce streams that may be easier for other systems to consume.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: CLR 序列化的另一个问题是它生成的二进制流是.NET特定的格式。如果需要处理该流的代码仅在.NET上运行，那么这不是问题，但你可能希望生成更广泛受众使用的流。除了CLR序列化外，还有其他的序列化机制，这些机制可以生成其他系统更容易消费的流。
- en: JSON
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON
- en: The JavaScript Object Notation, JSON, is a very widely used serialization format,
    and the .NET runtime libraries provide support for working with it in the `System.Text.Json`
    namespace.^([6](ch15.xhtml#idm45884789970704)) It provides three ways of working
    with JSON data.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: JSON（JavaScript对象表示法）是一种非常广泛使用的序列化格式，.NET运行时库提供了在`System.Text.Json`命名空间中处理它的支持。^([6](ch15.xhtml#idm45884789970704))
    它提供了三种处理JSON数据的方式。
- en: The `Utf8JsonReader` and `Utf8JsonWriter` types are stream-like abstractions
    that represent the contents of JSON data as a sequence of elements. These can
    be useful if you need to process JSON documents that are too large to load into
    memory as a single object. They are built on the memory-efficient mechanisms described
    in [Chapter 18](ch18.xhtml#ch_memory_efficiency), which includes a full example
    showing how to process JSON with these types. This is a very high-performance
    option, but it is not the easiest to use.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`Utf8JsonReader`和`Utf8JsonWriter`类型是类似流的抽象，它们将JSON数据内容表示为一系列元素。如果需要处理太大无法一次性加载到内存中的JSON文档，它们非常有用。它们构建在[第18章](ch18.xhtml#ch_memory_efficiency)描述的内存高效机制上，该章包括一个完整示例，展示了如何使用这些类型处理JSON。这是一个非常高性能的选择，但使用起来并不是最容易的。'
- en: Note
  id: totrans-257
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As the names suggest, these types read and write JSON using UTF-8 encoding.
    This is by far the most widely used encoding for sending and storing JSON, so
    all of `System.Text.Json` is optimized for it. Because of this, performance-sensitive
    code should typically avoid ever obtaining a JSON document as a .NET `string`,
    because that uses UTF-16 encoding and will require conversion to UTF-8 before
    you can work with these APIs.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称所示，这些类型使用 UTF-8 编码来读取和写入 JSON。这是发送和存储 JSON 数据最广泛使用的编码方式，因此所有 `System.Text.Json`
    都针对其进行了优化。因此，性能敏感的代码通常应避免在 .NET `string` 中获取 JSON 文档，因为这将使用 UTF-16 编码，需要在您可以使用这些
    API 之前转换为 UTF-8。
- en: There’s also the `JsonSerializer` class, which converts between entire .NET
    objects and JSON. It requires you to define classes with a structure corresponding
    to the JSON.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 还有 `JsonSerializer` 类，它在整个 .NET 对象和 JSON 之间进行转换。它要求您定义的类结构与 JSON 对应。
- en: Finally, `System.Text.Json` offers types that can provide a description of a
    JSON document’s structure. These are useful when you do not know at development
    time exactly what the structure of your JSON data will be, because they provide
    a flexible object model that can adapt to any shape of JSON data. In fact, there
    are two variations on this approach. We have `JsonDocument`, `JsonElement`, and
    related types, which provide a highly efficient read-only mechanism for inspecting
    a JSON document, and the more flexible but slightly less efficient `JsonNode`,
    which is writable, enabling you either to build up a description of JSON from
    scratch or to read in some JSON and then modify it.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`System.Text.Json` 提供了可以提供 JSON 文档结构描述的类型。当您在开发时不确定 JSON 数据结构的确切形式时，这些类型非常有用，因为它们提供了一个灵活的对象模型，可以适应任何形状的
    JSON 数据。事实上，有两种方法可以实现这种方法。我们有 `JsonDocument`、`JsonElement` 和相关类型，提供了一种高效的只读机制，用于检查
    JSON 文档，以及更灵活但略显低效的 `JsonNode`，它是可写的，使您可以从头开始构建 JSON 的描述，或者读入一些 JSON 然后修改它。
- en: JsonSerializer
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JsonSerializer
- en: '`JsonSerializer` offers an attribute-driven serialization model in which you
    define one or more classes mirroring the structure of the JSON data you need to
    deal with, and can then convert JSON data to and from that model.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonSerializer` 提供了一种基于属性的序列化模型，您可以在其中定义一个或多个类，反映您需要处理的 JSON 数据的结构，然后可以在这些模型之间进行
    JSON 数据的转换。'
- en: '[Example 15-18](#json_model) shows a simple model suitable for use with `JsonSerializer`.
    As you can see, I’m not required to use any particular base class, and there are
    no mandatory attributes.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15-18](#json_model) 展示了一个简单的模型，适合与 `JsonSerializer` 一起使用。正如您所见，我不必使用任何特定的基类，也没有强制要求的属性。'
- en: Example 15-18\. Simple JSON serialization model
  id: totrans-264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-18\. 简单的 JSON 序列化模型
- en: '[PRE17]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[Example 15-19](#jsonserializer_serialize) creates an instance of this model
    and then uses the `JsonConvert` class’s `Serialize` method to serialize it to
    a string.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15-19](#jsonserializer_serialize) 创建了此模型的一个实例，然后使用 `JsonConvert` 类的 `Serialize`
    方法将其序列化为字符串。'
- en: Example 15-19\. Serializing data with `JsonSerializer`
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-19\. 使用 `JsonSerializer` 序列化数据
- en: '[PRE18]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The second argument to `Serialize` is optional. I’ve used it here to indent
    the JSON to make it easier to read. (By default, `JsonSerializer` will use a more
    efficient layout with no unnecessary whitespace, but that is much harder to read.)
    The results look like this:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`Serialize` 的第二个参数是可选的。我在这里使用它来缩进 JSON，使其更易于阅读。（默认情况下，`JsonSerializer` 将使用更高效的布局，没有不必要的空格，但这样更难阅读。）结果如下所示：'
- en: '[PRE19]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, each .NET object has become a JSON object, where the name/value
    pairs correspond to properties in my model. Numbers and strings are represented
    exactly as you would expect. The `IList<string>` has become a JSON array, and
    the `IDictionary<string, int>` has become another JSON dictionary. I’ve used interfaces
    for these collections, but you can also use the concrete `List<T>` and `Dictio⁠nary​<TKey,TValue>`
    types. You can use ordinary arrays to represent lists if you prefer. I tend to
    prefer the interfaces because it leaves you free to use whatever collection types
    you want. (E.g., [Example 15-19](#jsonserializer_serialize) initialized the `Names`
    property with a string array, but it could also have used `List<string>` without
    changing the model type.)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，每个 .NET 对象都变成了一个 JSON 对象，其中名称/值对应于模型中的属性。数字和字符串的表示与您的预期完全一致。`IList<string>`
    变成了一个 JSON 数组，而 `IDictionary<string, int>` 则变成了另一个 JSON 字典。我在这些集合中使用了接口，但您也可以使用具体的
    `List<T>` 和 `Dictio⁠nary​<TKey,TValue>` 类型。如果您喜欢，也可以使用普通的数组来表示列表。我倾向于使用接口，因为这样可以自由地使用任何集合类型（例如，[示例 15-19](#jsonserializer_serialize)
    使用字符串数组初始化了 `Names` 属性，但也可以使用 `List<string>` 而不更改模型类型）。
- en: Converting serialized JSON back into the model is equally straightforward, as
    [Example 15-20](#json_convert_deserialize) shows.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 将序列化后的 JSON 转换回模型同样简单，正如 [示例 15-20](#json_convert_deserialize) 所示。
- en: Example 15-20\. Deserializing data with `JsonSerializer`
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-20\. 使用 `JsonSerializer` 反序列化数据
- en: '[PRE20]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Although a plain and simple model such as this will often suffice, sometimes
    you may need to take control over some aspects of serialization, particularly
    if you are working with an externally defined JSON format. For example, you might
    need to work with a JSON API that uses naming conventions that are different from
    .NET’s—camelCasing is popular but conflicts with the PascalCasing convention for
    .NET properties. One way to resolve this to use the `JsonPropertyName` attribute
    to specify the name to use in the JSON, as [Example 15-21](#json_property_attribute)
    shows.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此简单的模型通常就足够了，但有时您可能需要控制序列化的某些方面，特别是在使用外部定义的 JSON 格式时。例如，您可能需要与使用与 .NET 不同的命名约定的
    JSON API 一起工作——驼峰命名法很受欢迎，但与 .NET 属性的帕斯卡命名法冲突。解决此问题的一种方法是使用 `JsonPropertyName`
    属性来指定在 JSON 中使用的名称，如 [示例 15-21](#json_property_attribute) 所示。
- en: Example 15-21\. Controlling the JSON with `JsonPropertyName` attributes
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-21\. 使用 `JsonPropertyName` 属性控制 JSON
- en: '[PRE21]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`JsonSerializer` will use the names specified in `JsonPropertyName` when serializing
    and will look for those names when deserializing. This approach gives us complete
    control over the .NET and JSON property names, but there is a simpler solution
    for this particular scenario. This kind of renaming that just changes the case
    of the first letter is so common that you can get `JsonSerializer` to do it for
    you. The `JsonSerializationOptions` passed to `JsonSerializer.Serialize` takes
    an optional constructor argument of type `JsonSerializerDefaults`, and if you
    pass `Json​Seri⁠ali⁠zerDefaults.Web`, as [Example 15-22](#jsonserializer_with_web_defaults)
    does, you will get the camelCasing style without needing to use any attributes.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在序列化时，`JsonSerializer` 会使用 `JsonPropertyName` 中指定的名称，并在反序列化时寻找这些名称。这种方法完全控制了
    .NET 和 JSON 属性的命名，但在特定情况下也有更简单的解决方案。这种仅更改首字母大小写的重命名是如此常见，以至于可以让 `JsonSerializer`
    来完成。传递给 `JsonSerializer.Serialize` 的 `JsonSerializationOptions` 可以选择使用 `JsonSerializerDefaults`
    类型的可选构造函数参数，如果像 [示例 15-22](#jsonserializer_with_web_defaults) 中那样传递 `JsonSeri⁠ali⁠zerDefaults.Web`，将会得到驼峰样式的命名，而无需使用任何属性。
- en: Example 15-22\. Using `JsonSerializerDefaults` to get camelCased property names
  id: totrans-279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-22\. 使用 `JsonSerializerDefaults` 来获取驼峰式属性名称
- en: '[PRE22]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `JsonSerializerOptions` also provide a way to handle circular references.
    Suppose you want to serialize objects of type `SelfRef`, as shown in [Example 15-23](#self_referential_type).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonSerializerOptions` 还提供了处理循环引用的方法。假设你要序列化 `SelfRef` 类型的对象，如 [示例 15-23](#self_referential_type)
    所示。'
- en: Example 15-23\. A type supporting circular references
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-23\. 支持循环引用的类型
- en: '[PRE23]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: By default, if you attempt to serialize objects that refer to one another either
    directly or indirectly, you’ll get a `JsonException` reporting a possible cycle.
    It says “possible” because it doesn’t directly detect cycles by default—instead,
    `JsonSerializer` has a limit on the depth of any object graph that it will serialize.
    This is configurable through the `JsonSerializerOptions.MaxDepth` property, but
    by default the serializer will report an error if it has to go more than 64 objects
    deep. However, you can set the `ReferenceHandler` to change the behavior. [Example 15-24](#serializing_circular_references)
    sets this to `ReferenceHandler.Preserve`, enabling it to serialize a pair of `SelfRef`
    instances that refer to each other.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果试图序列化直接或间接引用彼此的对象，将会收到 `JsonException` 报告可能存在循环。它说“可能”是因为默认情况下它不直接检测循环，而是
    `JsonSerializer` 对任何对象图的深度都有一个限制。这可以通过 `JsonSerializerOptions.MaxDepth` 属性进行配置，但默认情况下，如果超过
    64 个对象的深度，序列化器将报告错误。但是，可以通过设置 `ReferenceHandler` 来更改其行为。[示例 15-24](#serializing_circular_references)
    将此设置为 `ReferenceHandler.Preserve`，使其能够序列化相互引用的 `SelfRef` 实例对。
- en: Example 15-24\. Serializing a type supporting circular references
  id: totrans-285
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-24\. 序列化支持循环引用的类型
- en: '[PRE24]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To enable this, the `JsonSerializer` gives objects identifiers by adding an
    `$id` property:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 为实现此目的，`JsonSerializer` 通过添加一个 `$id` 属性为对象分配标识符：
- en: '[PRE25]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This enables the serializer to avoid problems when it encounters a circular
    reference. Whenever it has to serialize a property, it checks to see whether that
    refers to some object that has already been written out (or is in the process
    of being written out). If it does, then instead of attempting to write out the
    object again (which would cause an infinite loop, since it’ll just encounter the
    circular reference again and again), the serializer emits a JSON object containing
    a property with the special name `$ref` referring back to the relevant `$id`.
    This is not a universally supported form of JSON, which is why ID generation is
    not enabled by default.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得序列化器在遇到循环引用时能够避免问题。每当它需要序列化属性时，它会检查该属性是否引用了已经写出的对象（或正在写出的对象）。如果是这样，而不是尝试再次写出对象（这将导致无限循环，因为它会不断遇到循环引用），序列化器会发出一个
    JSON 对象，其中包含一个特殊名称为 `$ref` 的属性，指向相关的 `$id`。这不是 JSON 的普遍支持形式，因此 ID 生成默认情况下未启用。
- en: You can control many other aspects of serialization with `JsonSerializerOptions`—you
    can define custom serialization mechanisms for data types, for example. (E.g.,
    you might want to represent something as a `DateTimeOffset` in your C# code but
    have that become a string with a particular date-time format in the JSON.) The
    full details can be found in the `System.Text.Json` documentation.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `JsonSerializerOptions` 控制序列化的许多其他方面，例如为数据类型定义自定义序列化机制。例如，你可能想在 C# 代码中表示某些内容为
    `DateTimeOffset`，但希望在 JSON 中将其变为带有特定日期时间格式的字符串。详细信息可以在 `System.Text.Json` 文档中找到。
- en: JSON DOM
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON 文档对象模型
- en: Whereas `JsonSerializer` requires you to define one or more types representing
    the structure of the JSON you want to work with, `System.Text.Json` provides a
    fixed set of types that enable a more dynamic approach. You can build a Document
    Object Model (DOM) in which instances of types such as `JsonElement` or `JsonNode`
    represent the structure of the JSON.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonSerializer` 要求你定义一个或多个类型来表示你想处理的 JSON 结构，而 `System.Text.Json` 则提供了一组固定类型，支持更动态的方法。你可以构建一个文档对象模型（DOM），其中诸如
    `JsonElement` 或 `JsonNode` 的类型实例表示 JSON 的结构。'
- en: '`System.Text.Json` provides two ways to build a DOM. If you have data already
    in JSON form, you can use the `JsonDocument` class to obtain a read-only model
    of the JSON, in which each object, value, and array is represented as a `JsonElement`,
    and each property in an object is represented as a `JsonProperty`. [Example 15-25](#dynamic_json_inspection)
    uses `JsonDocument` to discover all of the properties in the object at the root
    of the JSON by calling `RootElement.EnumerateObject()` on the `JsonDocument`.
    This returns a collection of `JsonProperty` structs.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Text.Json` 提供了两种构建 DOM 的方式。如果你已经有 JSON 格式的数据，可以使用 `JsonDocument` 类获取
    JSON 的只读模型，其中每个对象、值和数组都表示为 `JsonElement`，而对象中的每个属性则表示为 `JsonProperty`。[示例 15-25](#dynamic_json_inspection)
    使用 `JsonDocument` 调用 `RootElement.EnumerateObject()` 来发现 JSON 根对象中的所有属性。这返回一个
    `JsonProperty` 结构的集合。'
- en: Example 15-25\. Dynamic JSON inspection with `JsonDocument` and `JsonElement`
  id: totrans-294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-25\. 使用 `JsonDocument` 和 `JsonElement` 进行动态 JSON 检查
- en: '[PRE26]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Running this on the serialized document produced by earlier examples produces
    this output:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码，处理早期示例生成的序列化文档后，会产生以下输出：
- en: '[PRE27]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As this shows, we are able to discover at runtime what properties exist. The
    `JsonProperty.Value` returns a `JsonElement` struct, and we can inspect its `ValueKind`
    to discover which sort of JSON value it is. If it’s an array, we can enumerate
    its contents by calling `EnumerateArray`, and if it’s a string value, we can read
    its value by calling `GetString`. [Example 15-26](#dynamic_json_array_inspection)
    uses these methods to show all the strings in the `names` property.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所示，我们能够在运行时发现存在的属性。`JsonProperty.Value` 返回一个 `JsonElement` 结构，可以检查其 `ValueKind`
    来确定其所表示的 JSON 值类型。如果是数组，可以通过调用 `EnumerateArray` 枚举其内容；如果是字符串值，可以通过调用 `GetString`
    读取其值。[Example 15-26](#dynamic_json_array_inspection) 使用这些方法展示了 `names` 属性中的所有字符串。
- en: Example 15-26\. Dynamic JSON array enumeration with `JsonDocument` and `JsonElement`
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 15-26\. 使用 `JsonDocument` 和 `JsonElement` 动态枚举 JSON 数组
- en: '[PRE28]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As this example also shows, if you know in advance that a particular property
    will be present, you don’t need to use `EnumerateObject` to find it: you can call
    `GetProperty`. There’s also a `TryGetProperty` for when the property is optional.
    [Example 15-27](#dynamic_json_read_properties) uses both: this treats the root
    object’s `location` property as optional, but if it is present, it then requires
    the `locationName`, `latitude`, and `longitude` properties to be present.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本例还展示的那样，如果事先知道某个属性肯定存在，就无需使用 `EnumerateObject` 来查找它：可以直接调用 `GetProperty`。对于可选属性，还有
    `TryGetProperty` 方法。[Example 15-27](#dynamic_json_read_properties) 使用了两者：将根对象的
    `location` 属性视为可选，但如果存在，还需要 `locationName`、`latitude` 和 `longitude` 属性。
- en: Example 15-27\. Reading JSON properties with `JsonElement`
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 15-27\. 使用 `JsonElement` 读取 JSON 属性
- en: '[PRE29]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In addition to structural elements, objects and arrays, the data model in the
    [JSON specification](https://oreil.ly/T1Qoe) recognizes four basic data types:
    strings, numbers, Booleans, and null. As you’ve seen, you can discover which of
    these any particular `JsonElement` represents with its `Kind` property. If it’s
    one of the basic data types, you can use a suitable `Get` method. The last two
    examples both used `GetString`, and the second also used `GetDouble`. There are
    multiple methods you can use to retrieve a number: if you are expecting an integer,
    you can call `GetSByte`, `GetInt16`, `GetInt32`, or `GetInt64` (and unsigned versions
    are also available) depending on what range of values you are expecting. There’s
    also `GetDecimal`.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 除了结构元素、对象和数组之外，在 [JSON 规范](https://oreil.ly/T1Qoe) 中的数据模型还识别四种基本数据类型：字符串、数字、布尔和
    null。正如您所见，可以使用 `Kind` 属性确定 `JsonElement` 所表示的基本数据类型之一。如果是基本数据类型之一，可以使用相应的 `Get`
    方法。最后两个示例都使用了 `GetString`，第二个示例还使用了 `GetDouble`。可以使用多种方法来获取数字：如果预期是整数，可以调用 `GetSByte`、`GetInt16`、`GetInt32`
    或 `GetInt64`（也有无符号版本），具体取决于预期的值范围。还有 `GetDecimal` 方法。
- en: '`JsonElement` also offers methods for reading string properties in particular
    formats: `GetGuid`, `GetDateTime`, `GetDateTimeOffset`, and `GetBytesFromBase64`.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonElement` 还提供了读取特定格式字符串属性的方法：`GetGuid`、`GetDateTime`、`GetDateTimeOffset`
    和 `GetBytesFromBase64`。'
- en: All of the `Get` methods will throw an `InvalidOperationException` if the value
    is not in the required format. Each of them is also available in a `TryGet` form,
    enabling you to detect when the data cannot be parsed in the expected way without
    having to trigger an exception.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 `Get` 方法如果数值不符合所需格式，都会抛出 `InvalidOperationException` 异常。它们都有对应的 `TryGet`
    形式，可以在数据无法按预期方式解析时进行检测，而无需触发异常。
- en: These types attempt to minimize the amount of memory allocated. `JsonElement`
    and `JsonProperty` are both structs, so you can obtain these without causing additional
    heap allocations. The underlying data is held in UTF-8 format by the `JsonDocument`,
    and the `JsonElement` and `JsonProperty` instances just refer back to that, avoiding
    the need to allocate copies of the relevant data. Obviously, the underlying data
    does need to live somewhere, and depending on exactly how you loaded the JSON
    into a `JsonDocument`, it may have to allocate some memory to hold it. (E.g.,
    you can pass it a `Stream`, and since not all streams are rewindable, `JsonDocument`
    would need to make a copy of the stream’s contents.) `JsonDocument` uses the buffer
    pooling features available in the .NET runtime libraries to manage this data,
    meaning that if an application parses many JSON documents, it may be able to reuse
    memory, reducing pressure on the garbage collector (GC). But this means the `JsonDocument`
    needs to know when you’ve finished with the JSON so that it can return buffers
    to the pool. That’s why we use a `using` statement when working with a `JsonDocument`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型试图最小化分配的内存量。`JsonElement`和`JsonProperty`都是结构体，因此您可以在不引起额外堆分配的情况下获取它们。`JsonDocument`通过UTF-8格式保存底层数据，并且`JsonElement`和`JsonProperty`实例只是引用该数据，避免了分配相关数据的副本的需要。显然，底层数据确实需要存放在某处，并且根据您如何加载JSON到`JsonDocument`中的方式，可能需要分配一些内存来存放它。（例如，您可以传递一个`Stream`，由于并非所有流都可重播，`JsonDocument`可能需要复制流的内容。）`JsonDocument`使用.NET运行库中可用的缓冲池特性来管理这些数据，这意味着如果应用程序解析许多JSON文档，它可能能够重用内存，减少垃圾收集器（GC）的压力。但这也意味着`JsonDocument`需要知道您何时完成对JSON的处理，以便可以将缓冲区返回到池中。这就是在使用`JsonDocument`时为什么要使用`using`语句的原因。
- en: Warning
  id: totrans-308
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Be aware that `JsonElement.GetString` is more expensive than all the other `Get`
    methods, because it has to create a new .NET string on the heap. The other `Get`
    methods all return value types, so they do not cause heap allocations.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`JsonElement.GetString`比所有其他`Get`方法都更昂贵，因为它必须在堆上创建一个新的.NET字符串。其他`Get`方法都返回值类型，因此它们不会导致堆分配。
- en: I mentioned earlier that there are two ways of working with a JSON DOM. `JsonDocument`
    provides a read-only model that lets you inspect existing JSON. But there is also
    `JsonNode`, which is read/write. You can use this in a couple of ways that `JsonDocument`
    does not support. You can build up an object model from scratch to create a new
    JSON document. Alternatively, you can parse existing JSON into an object model
    just like with `JsonDocument`, but when you use `JsonNode`, the resulting model
    is modifiable. So you could use it to load some JSON and modify it, as [Example 15-28](#dynamic_json_modification)
    illustrates.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到有两种处理JSON DOM的方式。`JsonDocument`提供了一个只读模型，允许您检查现有的JSON。但还有`JsonNode`，它是可读/写的。您可以使用它的方式是`JsonDocument`不支持的。您可以从头开始建立一个对象模型来创建一个新的JSON文档。或者，您可以像使用`JsonDocument`一样解析现有的JSON到对象模型中，但是当您使用`JsonNode`时，结果模型是可修改的。因此，您可以使用它来加载一些JSON并对其进行修改，正如[示例 15-28](#dynamic_json_modification)所示。
- en: Example 15-28\. Modifying JSON with `JsonNode`
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-28\. 使用`JsonNode`修改JSON
- en: '[PRE30]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This loads the JSON text in `json` into a `JsonNode` and then retrieves the
    `map` property. (This example expects to work with JSON in the same form as I’ve
    used in the preceding examples, with camelCased property names.) So far this doesn’t
    do anything we couldn’t do with `JsonDocument`. But the final line adds a new
    entry to the object in `map`. It’s this ability to modify the document that makes
    `JsonNode` more powerful. So why do we need `JsonDocument` if `JsonNode` is more
    powerful? The power comes at a price: `JsonNode` is less efficient, so if you
    don’t need the extra flexibility, you shouldn’t use it.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将`json`中的JSON文本加载到`JsonNode`中，然后检索`map`属性。（此示例期望与前面示例中使用的JSON形式相同，其中属性名称为驼峰式命名。）到目前为止，这并没有做任何我们不能用`JsonDocument`做的事情。但最后一行在`map`对象中添加了一个新条目。正是这种修改文档的能力使`JsonNode`更加强大。那么如果`JsonNode`更强大，为什么还需要`JsonDocument`呢？这种能力是有代价的：`JsonNode`效率较低，因此如果不需要额外的灵活性，就不应使用它。
- en: The main advantage of using either the read-only `JsonDocument` and `JsonElement`
    or the writable `JsonNode` is that you don’t need to define any types to model
    the data. They also make it easier to write code whose behavior is driven by the
    structure of the data, because these APIs are able to describe what they find.
    The read-only form is typically more efficient than `JsonSerializer`, because
    it may enable you to cause fewer object allocations when reading data from a JSON
    document.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用只读的`JsonDocument`和`JsonElement`或可写的`JsonNode`的主要优势在于，你无需定义任何类型来建模数据。它们还能更轻松地编写以数据结构驱动行为的代码，因为这些API能描述它们所找到的内容。只读形式通常比`JsonSerializer`更高效，因为在从JSON文档读取数据时可能能减少对象分配。
- en: Summary
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: The `Stream` class is an abstraction representing data as a sequence of bytes.
    A stream can support reading, writing, or both, and may support seeking to arbitrary
    offsets as well as straightforward sequential access. `TextReader` and `TextWriter`
    provide strictly sequential reading and writing of character data, abstracting
    away the character encoding. These types may sit on top of a file, a network connection,
    or memory, or you could implement your own versions of these abstract classes.
    The `FileStream` class also provides some other filesystem access features, but
    for full control, we also have the `File` and `Directory` classes. When bytes
    and strings aren’t enough, .NET offers various serialization mechanisms that can
    automate the mapping between an object’s state in memory and a representation
    that can be written out to disk or sent over the network or any other stream-like
    target; this representation can later be turned back into an object of the same
    type and with equivalent state.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream`类是表示数据的字节序列的抽象。流可以支持读取、写入或两者，并且可以支持定位到任意偏移量以及直接的顺序访问。`TextReader`和`TextWriter`提供严格的字符数据顺序读取和写入，抽象化字符编码。这些类型可以位于文件、网络连接、内存之上，或者你可以实现自己版本的这些抽象类。`FileStream`类还提供一些其他的文件系统访问功能，但为了完全控制，我们还有`File`和`Directory`类。当字节和字符串不足时，.NET提供各种序列化机制，可以自动映射对象在内存中的状态与可以写入磁盘或发送到网络或任何其他类似流目标的表示之间的关系；这种表示后来可以转换回相同类型的对象，并且具有等效的状态。'
- en: As you’ve seen, a few of the file and stream APIs offer asynchronous forms that
    can help improve performance, particularly in highly concurrent systems. The next
    chapter tackles concurrency, parallelism, and the task-based pattern that the
    asynchronous forms of these APIs use.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，一些文件和流API提供了异步形式，可以帮助提升性能，特别是在高并发系统中。下一章将讨论并发性、并行性以及这些API的异步形式所使用的基于任务的模式。
- en: '^([1](ch15.xhtml#CHP-16-FN-2-marker)) You might have thought that the pound
    sign was #, but if, like me, you’re British, that’s just not on. It would be like
    someone insisting on referring to @ as a dollar sign. Unicode’s canonical name
    for # is *number sign*, and it also allows my preferred option, *hash*, as well
    as *octothorpe*, *crosshatch*, and, regrettably, *pound sign*.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch15.xhtml#CHP-16-FN-2-marker)) 你可能认为井号是#，但如果像我一样是英国人，那就不对了。这就像有人坚持把@称为美元符号一样。Unicode对#的官方名称是*number
    sign*，它还允许使用我偏爱的选项*hash*，以及*octothorpe*、*crosshatch*，以及遗憾的是*英镑符号*。
- en: ^([2](ch15.xhtml#CHP-16-FN-3-marker)) Just in case you’ve not come across the
    term, in *little-endian* representations, multibyte values start with the lower-order
    bytes, so the value 0x1234 in 16-bit little-endian would be 0x34, 0x12, whereas
    the big-endian version would be 0x12, 0x34\. Little-endian looks reversed, but
    it’s the native format for Intel’s processors.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch15.xhtml#CHP-16-FN-3-marker)) 以防你还不知道这个术语，在*小端*表示中，多字节值以低位字节开始，因此在16位小端中，值0x1234将是0x34、0x12，而大端版本将是0x12、0x34。小端看起来是颠倒的，但它是Intel处理器的本地格式。
- en: ^([3](ch15.xhtml#idm45884790912256-marker)) Some Unicode characters can take
    up to 4 bytes in UTF-8, so multiplying by three might seem like it could underestimate.
    However, all such characters require two code units in UTF-16\. Any single `char`
    in .NET will never require more than 3 bytes in UTF-8.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch15.xhtml#idm45884790912256-marker)) 一些Unicode字符在UTF-8中可以占据最多4个字节，因此乘以三似乎可能低估了。然而，所有这些字符在UTF-16中都需要两个代码单元。在.NET中的任何单个`char`在UTF-8中最多只需要3个字节。
- en: ^([4](ch15.xhtml#CHP-16-FN-4-marker)) Four overloads became obsolete when .NET
    2.0 introduced a new way of representing OS handles. The overloads that accept
    an `IntPtr` were deprecated at that point, replaced by new ones taking a `SafeFileHandle`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch15.xhtml#CHP-16-FN-4-marker)) 当 .NET 2.0 引入了一种新的操作系统句柄表示方式时，四种重载方法变得过时了。那时接受
    `IntPtr` 的重载方法被弃用，取而代之的是接受 `SafeFileHandle` 的新方法。
- en: ^([5](ch15.xhtml#CHP-16-FN-5-marker)) These all return a `DateTime` that is
    relative to the computer’s current time zone. Each of these methods has an equivalent
    that returns the time relative to time zone zero (e.g., `GetCreationTimeUtc`).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch15.xhtml#CHP-16-FN-5-marker)) 这些方法都返回一个相对于计算机当前时区的 `DateTime`。每个方法都有一个相应的等效方法，返回相对于时区零的时间（例如
    `GetCreationTimeUtc`）。
- en: ^([6](ch15.xhtml#idm45884789970704-marker)) This is not available on .NET Framework.
    There, the open source JSON.NET project, available on the [Newtonsoft website](https://oreil.ly/LpJfk)
    or via NuGet as `Newtonsoft.Json`, is a popular choice.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch15.xhtml#idm45884789970704-marker)) 这在 .NET Framework 上不可用。在那里，开源的 JSON.NET
    项目，在 [Newtonsoft 网站](https://oreil.ly/LpJfk) 或通过 NuGet 的 `Newtonsoft.Json`，是一个受欢迎的选择。
