- en: Chapter 5\. Implementing Dynamic and Reflection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 实现动态和反射
- en: Reflection allows code to look inside of a type and examine its details and
    members. This is useful for libraries and tools that want to give the user maximum
    flexibility to submit objects to perform some automatic operation. A common example
    of code that does reflection are unit testing frameworks. As described in [Recipe
    3.1](ch03.xhtml#writing_a_unit_test), unit tests take classes whose members have
    attributes to indicate which methods are tests. The unit testing framework uses
    reflection to find classes that are tests, locate the test methods, and execute
    the tests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 反射允许代码查看类型的内部并检查其细节和成员。这对于希望给用户最大灵活性以提交对象以执行某些自动操作的库和工具非常有用。一个常见的进行反射的代码示例是单元测试框架。如
    [Recipe 3.1](ch03.xhtml#writing_a_unit_test) 所述，单元测试使用具有属性的类来指示哪些方法是测试方法。单元测试框架使用反射来查找测试类，定位测试方法并执行测试。
- en: The example in this chapter is based on a dynamic report-building application.
    It uses reflection to read attributes of a class, access type members, and execute
    methods. The first four sections of this chapter show how to do that.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章示例基于一个动态报表构建应用程序。它使用反射来读取类的属性，访问类型成员并执行方法。本章的前四节展示了如何做到这一点。
- en: In addition to reflection, another way to work flexibly with code is a C# feature
    called dynamic. In C#, much of the code we write is strongly typed, and that’s
    a huge benefit for productivity and maintainability. That said, C# has a `dynamic`
    keyword that allows developers to assume that objects have a certain structure.
    This is much like dynamic programming languages, like JavaScript and Python, where
    developers access objects based on documentation that specifies what members an
    object has. So, they just write code that uses those members. Dynamic code allows
    C# to do the same thing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除了反射之外，另一种灵活处理代码的方式是 C# 中的一个特性，称为动态。在 C# 中，我们编写的大部分代码都是强类型的，这对于提高生产力和可维护性非常有益。尽管如此，C#
    中有一个`dynamic`关键字，允许开发人员假设对象具有某种结构。这很像动态编程语言（如 JavaScript 和 Python），开发人员根据文档访问对象，该文档指定了对象具有哪些成员。因此，他们只需编写使用这些成员的代码。动态代码允许
    C# 做到同样的事情。
- en: When performing operations requiring COM interop, dynamic is particularly useful,
    and there’s a section explaining how that works. You’ll see how dynamic can be
    useful in significantly reducing and simplifying the code, as compared to the
    verbosity and complexity of reflection. There are also types that allow us to
    build an inherently dynamic type. Additionally, there’s a dynamic language runtime
    (DLR) that enables interop between C# and dynamic languages, such as Python, and
    you’ll see two sections on interoperability between C# and Python.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行需要 COM 互操作的操作时，动态特别有用，有一个部分专门解释了其工作原理。您将看到动态如何能够显著减少和简化代码，相比反射的冗长和复杂性。还有一些类型允许我们构建本质上是动态的类型。此外，还有一个动态语言运行时（DLR），它允许在
    C# 和动态语言（如 Python）之间进行互操作，您将看到两个关于 C# 和 Python 互操作的部分。
- en: 5.1 Reading Attributes with Reflection
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.1 使用反射读取属性
- en: Problem
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want consumers of your library to have maximum flexibility when passing
    objects, but they still need to communicate important details of the object.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望您的库的消费者在传递对象时具有最大的灵活性，但他们仍然需要传达对象的重要细节。
- en: Solution
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s an `Attribute` class, representing report column metadata:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`Attribute`类，表示报表列元数据：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This class represents a record to display and uses the attribute:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类表示要显示的记录，并使用了以下属性：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `Main` method shows how to instantiate and pass the data:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法展示了如何实例化和传递数据：'
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This `Report` class has methods for building a report header and generating
    a report:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Report`类有用于构建报表头和生成报表的方法：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This method is a member of the `Report` class and uses reflection to find all
    type members:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法是`Report`类的一个成员，使用反射来找到所有类型成员：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This method is a member of the `Report` class and uses reflection to read attributes
    of a type:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法是`Report`类的一个成员，使用反射来读取类型的属性：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And here’s the output:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出结果：
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Discussion
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Attributes, which are metadata, typically exist to support tooling on code.
    The solution in this section takes a similar approach where the `ColumnAttribute`
    is metadata for a column of data in a report. You can see where the `AttributeUsage`
    specifies that you can apply `ColumnAttribute` to either properties or methods.
    Thinking of which features that a report column might be able to support, this
    attribute boils down to two typical features: `Name` and `Format`. Because a C#
    property name might not represent the text of a column header, `Name` lets you
    specify anything you want. Also, without specifying a string format, `DateTime`
    and `decimal` columns would take default displays, which is often not what you
    want. This essentially solves the problem where a consumer of a report library
    wants to pass any type of object they want, using `ColumnAttribute` to share important
    details.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 属性，即元数据，通常存在于代码工具中。本节中的解决方案采用类似的方法，其中 `ColumnAttribute` 是报表中数据列的元数据。你可以看到 `AttributeUsage`
    指定了可以将 `ColumnAttribute` 应用于属性或方法。考虑报表列可能支持的功能，这个属性归结为两个典型的特征：`Name` 和 `Format`。因为
    C# 属性名称可能不代表列标题的文本，`Name` 允许你指定任何你想要的内容。此外，如果不指定字符串格式，`DateTime` 和 `decimal` 列将采用默认显示方式，通常这并非你所期望的。这本质上解决了报表库的使用者想要传递任何类型对象的问题，通过使用
    `ColumnAttribute` 共享重要的细节。
- en: '`InventoryItem` shows how `ColumnAttribute` works. Notice how the positional
    property, `Name`, differs from the name of the properties and method. [Recipe
    5.2](#accessing_type_members_with_reflection) has an example of how the `Format`
    property works, while this section only concentrates on how to extract and display
    the metadata as a Markdown formatted column.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`InventoryItem` 展示了 `ColumnAttribute` 的工作原理。注意位置属性 `Name` 如何与属性和方法的名称不同。[Recipe
    5.2](#accessing_type_members_with_reflection) 展示了 `Format` 属性如何工作的例子，而本节仅集中于如何提取和显示
    Markdown 格式列的元数据。'
- en: Note
  id: totrans-26
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Architecturally, you should look at this project as two separate applications.
    There’s a reusable report library that anyone can submit objects to. The report
    library consists of a `Report` class and the `ColumnAttribute` attribute. Then
    there’s a consumer application, which is the `Main` method. For simplicity, the
    source code for this demo puts all the code into the same project, but in practice,
    these would be separate.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从架构上讲，你应该把这个项目看作两个独立的应用程序。有一个可重用的报表库，任何人都可以提交对象。报表库包括一个 `Report` 类和 `ColumnAttribute`
    属性。然后有一个消费应用程序，即 `Main` 方法。为简单起见，本演示的源代码将所有代码放在同一个项目中，但在实践中，这些应该是分开的。
- en: The `Main` method instantiates a `List<object>` that contains `InventoryItem`
    instances. This is data that would typically come from a database or other data
    source. It instantiates the `Report`, passes the data, and prints the result.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法实例化一个包含 `InventoryItem` 实例的 `List<object>`。这些数据通常来自数据库或其他数据源。它实例化
    `Report`，传递数据，并打印结果。'
- en: The `Generate` method belongs to the `Report` class. Notice that it accepts
    a `List<object>`, which is why `Main` passed a `List<object>`. Essentially, `Report`
    wants to be able to operate on any object type.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`Generate` 方法属于 `Report` 类。注意它接受一个 `List<object>`，这就是为什么 `Main` 传递了一个 `List<object>`。实质上，`Report`
    希望能够操作任何对象类型。'
- en: After validating input items, `Generate` uses reflection to discover what members
    exist in the objects passed. You see, we’re no longer able to know because the
    objects aren’t strongly typed, and we want maximum flexibility in what types can
    be passed. This is a good case for reflection. That said, we no longer have the
    guarantee that all instances in items are the same type, and that has to be an
    implied contract, rather than enforced by code. [Recipe 5.3](#instantiating_type_members_with_reflection)
    fixes this by showing how to use generics so we have both type safety and the
    ability to use generics, and using interfaces might be another approach.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证输入项后，`Generate` 使用反射来发现传递对象中存在的成员。你看，我们再也无法知道因为对象不是强类型的，而且我们希望能够在可以传递任何类型时具有最大的灵活性。这是反射的一个好案例。话虽如此，我们不再保证所有项实例是相同类型，这必须是一个隐含的约定，而不是由代码强制执行的。[Recipe
    5.3](#instantiating_type_members_with_reflection) 通过展示如何使用泛型来同时具有类型安全性和使用泛型的能力来解决这个问题，使用接口可能是另一种方法。
- en: We’re assuming all objects are the same, and `Generate` calls `First` on `items`,
    because it has the exact same attributes of all objects in `items`. `Generate`
    then calls `GetType` on the first item. The `Type` instance is the gateway for
    performing reflection.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设所有对象都相同，并且 `Generate` 在 `items` 上调用 `First`，因为所有对象在 `items` 中具有相同的属性。然后
    `Generate` 在第一个项目上调用 `GetType`。 `Type` 实例是执行反射的门户。
- en: 'After getting the `Type` instance, you can ask for anything about a type and
    work with particular instances. This example calls `GetMembers` to get a `MemberInfo[]`.
    A `MemberInfo` has all the information about a particular type member, like its
    name and type. In this example, the `MemberInfo[]` contains the properties and
    methods from the `InventoryItem` that `Main` passed in: `PartNumber`, `Description`,
    `Count`, `ItemPrice`, and `CalculateTotal`.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 获得 `Type` 实例之后，您可以查询有关类型的任何信息，并使用特定实例。此示例调用 `GetMembers` 获取 `MemberInfo[]`。
    `MemberInfo` 包含有关特定类型成员的所有信息，例如其名称和类型。在此示例中，`MemberInfo[]` 包含从 `Main` 传入的 `InventoryItem`
    的属性和方法：`PartNumber`、`Description`、`Count`、`ItemPrice` 和 `CalculateTotal`。
- en: Because the report is a string of Markdown text and there is a lot of concatenation,
    the solution uses `StringBuilder`. [Recipe 2.1](ch02.xhtml#processing_strings_efficiently)
    explains why this is a good approach.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因为报告是 Markdown 文本的字符串，并且有很多连接操作，解决方案使用 `StringBuilder`。[第 2.1 节](ch02.xhtml#processing_strings_efficiently)
    解释了为什么这是一个好方法。
- en: Because we’re concerned with attributes, this solution only prints the report
    header, and later sections in this chapter explain a lot of different ways to
    generate the report body, depending on your needs. The `GetHeader` method takes
    the `MemberInfo[]` and uses reflection to learn what those header titles should
    be.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们关注属性，此解决方案仅打印报告头部，本章后面的部分将详细解释根据您的需求生成报告主体的多种不同方法。 `GetHeader` 方法接收 `MemberInfo[]`
    并使用反射来确定这些标题应该是什么。
- en: In Markdown, we separate table headers with pipes, `|`, and add an underscore,
    which is why we have two arrays for `columnNames` and `underscores`. The `foreach`
    loop examines each `MemberInfo`, calling `GetCustomAttribute`. Notice that the
    type parameter for `GetCustomAttribute` is `ColumnAttribute`—members could have
    multiple attributes, but we only want that one. The instance returned from `GetCustom​Attri⁠bute`
    is `ColumnAttribute`, so we have access to its properties, such as `Name`. The
    code populates `columnNames` with `Name` and adds an underscore that is the same
    length as `Name`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Markdown 中，我们用管道符号 `|` 分隔表头，并添加下划线，这就是为什么我们在 `columnNames` 和 `underscores`
    中有两个数组。 `foreach` 循环检查每个 `MemberInfo`，调用 `GetCustomAttribute`。注意 `GetCustomAttribute`
    的类型参数是 `ColumnAttribute` —— 成员可能有多个属性，但我们只需要这一个。从 `GetCustomAttribute` 返回的实例是
    `ColumnAttribute`，所以我们可以访问它的属性，比如 `Name`。代码使用 `Name` 填充 `columnNames`，并添加与 `Name`
    长度相同的下划线。
- en: Finally, `GetHeaders` concatenates values with pipes, `|`, and returns the resulting
    header. Following this back through the call chain, `Generate` appends the `GetHeaders`
    results and `Main` prints the header, which you can see in the solution output.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`GetHeaders` 使用管道符号 `|` 连接值并返回结果头部。通过调用链追溯回来，`Generate` 添加了 `GetHeaders`
    的结果，而 `Main` 打印了标题，您可以在解决方案输出中看到。
- en: See Also
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 2.1, “Processing Strings Efficiently”](ch02.xhtml#processing_strings_efficiently)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 2.1 节，“高效处理字符串”](ch02.xhtml#processing_strings_efficiently)'
- en: '[Recipe 5.2, “Accessing Type Members with Reflection”](#accessing_type_members_with_reflection)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 5.2 节，“使用反射访问类型成员”](#accessing_type_members_with_reflection)'
- en: 5.2 Accessing Type Members with Reflection
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.2 使用反射访问类型成员
- en: Problem
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to examine an object to see what properties you can read.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要检查对象以查看可以读取哪些属性。
- en: Solution
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This class represents a record to display:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类表示要显示的记录：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here’s a class that contains metadata for each report column:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含每个报告列元数据的类：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This method collects the data to populate column metadata:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法收集数据以填充列元数据：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here’s a more streamlined way to get header data with LINQ:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 LINQ 更简洁获取头部数据的方式：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This method uses reflection to pull the value out of an object property:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用反射从对象属性中提取值：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This method uses reflection to retrieve and format property data:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用反射检索和格式化属性数据：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This method combines and formats all rows of data:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法组合和格式化所有数据行：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, this method uses all of the others to build a complete report:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个方法使用所有其他方法来构建完整的报告：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And here’s the output:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Discussion
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The report library in the solution receives a `List<object>` so that consumers
    can send objects of any type they want. Since the input objects aren’t strongly
    typed, the `Report` class needs to perform reflection to extract data from each
    object. [Recipe 5.1](#reading_attributes_with_reflection) explained how the `Main`
    method passes this data and how the solution generates the header. This section
    concentrates on data, and the solution doesn’t repeat the exact code from [Recipe
    5.1](#reading_attributes_with_reflection).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案中的报表库接收一个`List<object>`，以便消费者可以发送任何类型的对象。由于输入对象没有强类型，`Report`类需要执行反射以从每个对象中提取数据。[Recipe
    5.1](#reading_attributes_with_reflection)解释了`Main`方法如何传递这些数据以及解决方案如何生成标题。本节关注数据，解决方案不会重复来自[Recipe
    5.1](#reading_attributes_with_reflection)的确切代码。
- en: The `InventoryItem` class uses `ColumnAttribute` attributes. Notice that `ItemPrice`
    now has the named property `Format`, specifying that this column should be formatted
    in the report as currency.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`InventoryItem`类使用`ColumnAttribute`属性。请注意，`ItemPrice`现在具有名为`Format`的属性，指定该列应在报表中格式化为货币。'
- en: 'During reflection, we need to extract a set of data from the objects that helps
    with report layout and formatting. The `ColumnDetail` helps with this because
    when processing each column, we need to know:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在反射过程中，我们需要从对象中提取一组数据，以帮助报表布局和格式化。`ColumnDetail`对此很有帮助，因为在处理每列时，我们需要知道：
- en: '`Name` to ensure we’re working on the right column'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Name`以确保我们正在处理正确的列'
- en: '`Attribute` for formatting column data'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于格式化列数据的`Attribute`
- en: '`PropertyInfo` for getting property data'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于获取属性数据的`PropertyInfo`
- en: The `GetColumnDetails` method populates a `ColumnDetail` for each column. Getting
    the first object in the data, it gets the type and then calls `GetProperties`
    on the types for a `PropertyInfo[]`. Unlike [Recipe 5.1](#reading_attributes_with_reflection),
    which calls `GetMembers` for a `MemberInfo[]`, this only gets the properties from
    the type and not any other members.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetColumnDetails`方法为每列填充一个`ColumnDetail`。获取数据中的第一个对象，获取其类型，然后在类型上调用`GetProperties`以获取`PropertyInfo[]`。与[Recipe
    5.1](#reading_attributes_with_reflection)不同，后者调用`GetMembers`以获取`MemberInfo[]`，此方法仅从类型获取属性，而不是其他任何成员。'
- en: Tip
  id: totrans-70
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: In addition to `GetMembers` and `GetProperties`, `Type` has other reflection
    methods that will only get constructors, fields, or methods. These would be useful
    if you need to restrict the type of member you’re working with.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`GetMembers`和`GetProperties`之外，`Type`还具有其他反射方法，仅获取构造函数、字段或方法。如果需要限制正在处理的成员类型，则这些方法会很有用。
- en: Because reflection returns a collection of objects (`PropertyInfo[]` in this
    solution), we can use LINQ to Objects for a more declarative approach. This is
    what `GetColumnDetails` does, projecting into `ColumnDetails` instances and returning
    a `Dictionary` with the column name as key and `ColumnDetail` as value.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因为反射返回一组对象（在本解决方案中为`PropertyInfo[]`），我们可以使用LINQ to Objects进行更声明性的方法。这就是`GetColumnDetails`所做的事情，将投影到`ColumnDetails`实例中，并返回以列名为键，`ColumnDetail`为值的`Dictionary`。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As you’ll see later in the solution, the code iterates through the `Dictionary<string,
    ColumnDetail>`, assuming that columns and their data are laid out in the order
    returned by reflection queries. However, imagine a future implementation where
    `ColumnAttribute` had an `Order` property or the consumer could pass `include/exclude`
    column metadata that didn’t guarantee that the order of the columns matches what
    reflection returned. In that case, having the dictionary is essential to look
    up `ColumnDetail` metadata based on which column you’re working on. Although that’s
    left out of this example to reduce complexity and focus on the original problem
    statement, it might give you ideas on how something like this could be extended.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如您稍后在解决方案中看到的那样，代码通过`Dictionary<string, ColumnDetail>`迭代，假设列及其数据按反射查询返回的顺序排列。但是，请想象一下未来的实现，其中`ColumnAttribute`具有`Order`属性，或者消费者可以传递`include/exclude`列元数据，这并不保证列的顺序与反射返回的顺序相匹配。在这种情况下，具有字典是至关重要的，可以根据您正在处理的列查找`ColumnDetail`元数据。尽管这个示例中没有涉及这一点以减少复杂性并集中于原始问题陈述，但它可能会给您一些如何扩展类似功能的想法。
- en: The `GetHeaders` method does exactly the same thing as [Recipe 5.1](#reading_attributes_with_reflection),
    except it’s written as LINQ statements to reduce and simplify the code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetHeaders`方法与[Recipe 5.1](#reading_attributes_with_reflection)完全相同，只是它以LINQ语句编写，以减少和简化代码。'
- en: The `GetReflectedResult` returns a tuple, `(object, Type)`. Its task is to pull
    out the value from the property and the type of the property from its `PropertyInfo`.
    Here, `item` is the actual object instance and `property` is the reflected metadata
    for that property. Using `property`, the code calls `GetValue` with `item` as
    the parameter—it reads that property from `item`. Again, we’re using reflection
    and don’t know the type for the property, so we put it in type object. `PropertyInfo`
    also has a `PropertyType`, which is where we get the `Type` object from.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetReflectedResult` 返回一个元组，`(object, Type)`。其任务是从其 `PropertyInfo` 中提取属性的值和属性的类型。在这里，`item`
    是实际的对象实例，`property` 是该属性的反射元数据。使用 `property`，代码使用 `item` 作为参数调用 `GetValue` ——
    从 `item` 中读取该属性。再次强调，我们使用反射，并不知道属性的类型，因此将其放在类型对象中。`PropertyInfo` 还具有 `PropertyType`，我们可以从中获取
    `Type` 对象。'
- en: Warning
  id: totrans-77
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: This application uses reflection to put property data into a variable of type
    `object`. If the property type is a value type (e.g., `int`, `double`, `decimal`),
    you incur a boxing penalty, which affects application performance. If you were
    doing this millions of times, you might need to take a second look at your requirements
    and analyze whether this was a good approach for your scenario. That said, this
    is a report. Think about how many records you might include in a report for the
    purpose of displaying the data to a human. In this case, any performance issues
    would be negligible. It’s a classic trade-off of flexibility versus performance;
    you just need to think about how it affects your situation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序使用反射将属性数据放入 `object` 类型的变量中。如果属性类型是值类型（例如 `int`、`double`、`decimal`），则会产生装箱开销，这会影响应用程序的性能。如果您执行这种操作数百万次，您可能需要重新审视您的需求，并分析是否这对您的情况是一个好方法。尽管如此，这只是一份报告。考虑一下您可能为了向人显示数据而在报告中包含多少记录。在这种情况下，任何性能问题都将是微不足道的。这是灵活性与性能之间的经典权衡；您只需考虑它如何影响您的情况。
- en: The `GetColumns` method uses `GetReflectedResult` as it loops through each column
    for a given object. The collection of `ColumnDetail` is useful, providing `Proper⁠ty​Info`
    for the current column. The format defaults to no format if the `Column​Attri⁠bute`
    for a column doesn’t include the `Format` property. The `switch` statement applies
    the format to the object based on the `Type` returned from `GetReflectedResult`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetColumns` 方法在遍历给定对象的每一列时使用 `GetReflectedResult`。`ColumnDetail` 的集合很有用，为当前列提供
    `PropertyInfo`。如果列的 `ColumnAttribute` 不包括 `Format` 属性，则格式默认为无格式。`switch` 语句根据
    `GetReflectedResult` 返回的 `Type` 对象对对象应用格式。'
- en: Note
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: For simplicity, the `switch` statement in `GetColumns` only contains types in
    the solution, though you might imagine it including all built-in types. We might
    have used reflection to invoke `ToString` with a format specifier and type, which
    we’ll discuss in [Recipe 5.4](#invoking_methods_with_reflection), to reduce code.
    However, at some point the additional complexity doesn’t add value. In this case,
    we’re just covering a finite set of built-in types, and once that code is written,
    it will be unlikely to change. My thoughts on this trade-off are that sometimes
    being too clever results in code that’s difficult to read and takes longer to
    write.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，在 `GetColumns` 的 `switch` 语句中仅包含解决方案中的类型，尽管您可以想象它包含所有内置类型。我们可以使用反射调用 `ToString`，并带有格式说明符和类型，在
    [Recipe 5.4](#invoking_methods_with_reflection) 中讨论，以减少代码量。然而，某些情况下，额外的复杂性并不增加价值。在这种情况下，我们只涵盖了一组有限的内置类型，一旦编写了该代码，它将不太可能更改。我对这种权衡的看法是，有时过于聪明会导致难以阅读且写作时间更长的代码。
- en: Finally, `GetRows` calls `GetColumns` for each row and returns to `Generate`.
    Then, having called `GetHeaders` and `GetRows`, `Generate` appends the results
    to a `StringBuilder` and returns the string to the caller with the entire report,
    which you can see in the solution output.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`GetRows` 为每一行调用 `GetColumns` 并返回给 `Generate`。然后，在调用了 `GetHeaders` 和 `GetRows`
    后，`Generate` 将结果追加到 `StringBuilder` 并将字符串返回给调用者，其中包含整个报告，您可以在解决方案输出中看到。
- en: See Also
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 5.1, “Reading Attributes with Reflection”](#reading_attributes_with_reflection)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 5.1, “使用反射读取属性”](#reading_attributes_with_reflection)'
- en: '[Recipe 5.4, “Invoking Methods with Reflection”](#invoking_methods_with_reflection)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 5.4, “使用反射调用方法”](#invoking_methods_with_reflection)'
- en: 5.3 Instantiating Type Members with Reflection
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.3 使用反射实例化类型成员
- en: Problem
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to instantiate generic types but don’t know the type or type parameters
    ahead of time.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要实例化泛型类型，但事先不知道类型或类型参数。
- en: Solution
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'The solution generates a uniquely formatted report, depending on this enum:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案生成根据此枚举唯一格式化的报告：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here’s a reusable base class for generating reports:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个可重用的生成报告的基类：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This class uses that base class to generate Markdown reports:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此类使用基类生成Markdown报告：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And this class uses that base class to generate HTML reports:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 而这个类则使用基类生成HTML报告：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This method, from the `Report` class, manages the report-generation process:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法，来自`Report`类，管理报告生成过程：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here’s a method, from the `Report` class, that uses an enum to figure out which
    report format to generate:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个从`Report`类中使用枚举来确定要生成的报告格式的方法：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here’s another way, via convention, to figure out which report format to generate:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一种通过约定来确定要生成的报告格式的方法：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `Main` method passes data and specifies which report format it wants:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`方法传递数据并指定要生成的报告格式：'
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And here’s the output:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Discussion
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '[Recipe 5.2](#accessing_type_members_with_reflection) created reports based
    on a generic object type, and this caused us to lose the type safety we are accustomed
    to. This section fixes that problem by using generics and showing how to use reflection
    to instantiate objects with a generic type parameter.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 5.2](#accessing_type_members_with_reflection)基于一个通用对象类型创建报告，这导致我们失去了我们习惯的类型安全性。本节通过使用泛型来修复这个问题，并展示如何使用反射来实例化具有泛型类型参数的对象。'
- en: The concept of the previous sections was to generate a report in Markdown format.
    However, a report generator could be much more useful if it had the ability to
    generate reports in any format of your choosing. This example refactors the example
    in [Recipe 5.2](#accessing_type_members_with_reflection) to offer both a Markdown
    and an HTML output report.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 前面几节的概念是生成Markdown格式的报告。但是，如果报告生成器能够根据您选择的任何格式生成报告，它可能会更有用。本示例重构了[Recipe 5.2](#accessing_type_members_with_reflection)中的示例，以提供Markdown和HTML输出报告。
- en: 'The `ReportType` enum specifies the type of report output to generate: `Html`
    or `Markdown`. Because we can generate multiple formats, we need separate classes
    for each format: `HtmlGenerator` and `MarkdownGenerator`. Further, we don’t want
    to duplicate code, so each format generation class derives from `GeneratorBase`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举`ReportType`指定要生成的报告输出类型：`Html`或`Markdown`。因为我们可以生成多种格式，所以我们需要为每种格式单独创建类：`HtmlGenerator`和`MarkdownGenerator`。此外，我们不想重复代码，所以每个格式生成类都继承自`GeneratorBase`。
- en: 'Notice that `GeneratorBase` is an abstract class (you can’t instantiate it),
    with both `abstract` and implemented methods. The implemented methods in `GeneratorBase`
    have code that is independent of output formatted and that all derived generator
    classes will use: `GetColumns`, `GetColumnDetails`, and `GetReflectedResult`.
    By definition, the derived generator classes must `override` the `abstract` methods,
    which are format specific: `GetTitle`, `GetHeaders`, `GetRows`. Looking at `HtmlGenerator`
    and `MarkdownGenerator`, you can see the `override` implementations for these
    `abstract` methods.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`GeneratorBase`是一个抽象类（无法实例化），具有抽象和已实现的方法。在`GeneratorBase`中已实现的方法具有与输出格式无关的代码，并且所有派生的生成器类都将使用这些方法：`GetColumns`、`GetColumnDetails`和`GetReflectedResult`。根据定义，派生的生成器类必须覆盖这些特定于格式的抽象方法：`GetTitle`、`GetHeaders`和`GetRows`。查看`HtmlGenerator`和`MarkdownGenerator`，你可以看到这些抽象方法的覆盖实现。
- en: 'Now, let’s put this all together so it makes sense. When the program starts,
    the first method called on the `Report` instance is `Generate`, in `GeneratorBase`.
    Notice how `Generate` calls the sequence: `GetTitle`, `GetColumnDetails`, `GetHeaders`,
    and then `GetRows`. This is essentially the same sequence as described in [Recipe
    5.2](#accessing_type_members_with_reflection). You can imagine a report being
    generated top to bottom by writing the title, getting metadata for the rest of
    the report, writing the header, and then writing each of the rows of the report.
    To get code reuse and create an extensible framework for adding report formats
    in the future, we have a general abstract base class, `GeneratorBase`, and derived
    classes that understand the format. Using `MarkdownGenerator` as an example, here’s
    the sequence:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这一切整合起来，使其有意义。当程序启动时，在 `Report` 实例上调用的第一个方法是 `Generate`，在 `GeneratorBase`
    中。注意 `Generate` 调用的顺序：`GetTitle`、`GetColumnDetails`、`GetHeaders`，然后是 `GetRows`。这基本上与
    [Recipe 5.2](#accessing_type_members_with_reflection) 中描述的顺序相同。你可以想象通过编写标题、获取其余报告的元数据、编写标题，并逐行编写报告的每一行来生成报告。为了实现代码重用并创建未来添加报告格式的可扩展框架，我们有一个通用的抽象基类
    `GeneratorBase`，以及理解格式的派生类。以 `MarkdownGenerator` 为例，这是一个示例：
- en: External code calls `GeneratorBase.Generate`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 外部代码调用 `GeneratorBase.Generate`。
- en: '`Generator.Generate` calls `MarkdownGenerator.GetTitle`.'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Generator.Generate` 调用 `MarkdownGenerator.GetTitle`。'
- en: '`Generator.Generate` calls `Generator.GetColumnDetails`.'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Generator.Generate` 调用 `Generator.GetColumnDetails`。'
- en: '`Generator.Generate` calls `MarkdownGenerator.GetHeader`.'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Generator.Generate` 调用 `MarkdownGenerator.GetHeader`。'
- en: '`Generator.Generate` calls `MarkdownGenerator.GetRows`.'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Generator.Generate` 调用 `MarkdownGenerator.GetRows`。'
- en: '`MarkdownGenerator.GetRows` calls `Generator.GetColumns`.'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MarkdownGenerator.GetRows` 调用 `Generator.GetColumns`。'
- en: '`Generator.GetColumns` calls `Generator.GetReflectedResult`.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Generator.GetColumns` 调用 `Generator.GetReflectedResult`。'
- en: '`MarkdownGenerator.GetRows` completes, returning to `Generator.Generate`.'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MarkdownGenerator.GetRows` 完成，返回至 `Generator.Generate`。'
- en: '`Generator.Generate` returns the report to calling code.'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Generator.Generate` 将报告返回给调用代码。'
- en: The `HtmlGenerator` works exactly the same way, and so would any future report
    format. In fact, [Recipe 5.6](#performing_interop_with_office_apps) extends this
    example by adding a third format to support creating an Excel report.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`HtmlGenerator` 的工作方式完全相同，未来的任何报告格式也将如此。事实上，[Recipe 5.6](#performing_interop_with_office_apps)
    通过添加第三种格式来扩展此示例，以支持创建 Excel 报告。'
- en: Note
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The solution uses a pattern known as the *template pattern*. In this pattern,
    a base class implements common logic and delegates implementation-specific work
    to derived classes. This is the object-oriented principle of polymorphism at work.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 该解决方案使用一种称为*模板模式*的模式。在这种模式中，基类实现通用逻辑，并将实现特定工作委托给派生类。这体现了面向对象的多态原则。
- en: The fact that we can extend this framework without needing to re-write boilerplate
    logic makes this a viable approach. [Recipe 5.6](#performing_interop_with_office_apps)
    shows how that works.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展这个框架，而无需重写样板逻辑，这使得这种方法变得可行。[Recipe 5.6](#performing_interop_with_office_apps)
    展示了其工作原理。
- en: The `GenerateBase` class is intentionally `abstract` because the only way for
    this to work is via an instance of a derived class. The `Report.Generate` method
    calls `GeneratorBase.Generate`. Before doing so, it must figure out which specific
    `GeneratorBase` derived class to instantiate via `CreateGenerator`, of which there
    are two examples.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`GenerateBase` 类故意声明为 `abstract`，因为唯一的工作方式是通过派生类的实例。`Report.Generate` 方法调用
    `GeneratorBase.Generate`。在此之前，它必须确定通过 `CreateGenerator` 实例化哪个具体的 `GeneratorBase`
    派生类，其中有两个示例。'
- en: The first example of `CreateGenerator` examines the `ReportType` enum to see
    which type of report to generate via a `switch` statement. As explained in earlier
    sections, you need a `Type` object to perform reflection, which the `typeof` operator
    does. Notice that we’re passing a generic type with the `<>` suffix, without the
    generic type. After that, we use the `typeof` operator to get the type of the
    type parameter passed to the `Report` class, `TData`. Now we have a type for both
    the generic type and its type parameter. Next, we need to bring the generic type
    and its parameter type together to get a fully constructed type, (e.g., `HtmlGenerator<TData>`
    for `Html`). Once you have a fully constructed type, you can use the `Activator`
    class to call `CreateInstance`, which instantiates the type. With a new instance
    of the `GeneratorBase`-derived type, `CreateGenerate` returns to `ReportGenerate`,
    which calls `Generate` on the new instance. As you learned earlier, `GeneratorBase`
    implements `Generate` for all derived instances.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateGenerator`的第一个示例检查`ReportType`枚举，以查看通过`switch`语句生成哪种类型的报告。正如前面部分所述，执行反射需要`Type`对象，`typeof`操作符就是这样做的。请注意，我们传递了一个带有`<>`后缀的泛型类型，而没有泛型类型。之后，我们使用`typeof`操作符获取传递给`Report`类的类型参数`TData`的类型。现在我们有了泛型类型和其类型参数的类型。接下来，我们需要将泛型类型和其参数类型结合在一起，以获得一个完全构造的类型（例如，对于`Html`是`HtmlGenerator<TData>`）。一旦你有了完全构造的类型，你可以使用`Activator`类调用`CreateInstance`来实例化该类型。通过`GeneratorBase`派生类型的新实例，`CreateGenerate`返回到`ReportGenerate`，在新实例上调用`Generate`。正如你之前学到的，`GeneratorBase`为所有派生实例实现了`Generate`。'
- en: That is one way to use reflection to instantiate a generic type, as specified
    by the problem statement. One thing to consider, though, is whether you want to
    add more formats to support in the future. You’ll have to go back into the `Report`
    class and change the `switch` statement, which is a configuration by code change.
    What if you prefer to write the `Report` class one time and never touch it again?
    Further, what if you preferred a design by the principles of convention-over-configuration?
    A good example of convention over configuration in .NET is ASP.NET MVC. A couple
    of ASP.NET MVC conventions are that controllers go in a `Controllers` folder and
    views go in a `Views` folder. Another is that the controller name is the URL path
    with a `Controller` suffix to its name. Things just work because that’s the convention.
    The second example of `CreateGenerator` uses the convention-over-configuration
    approach.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用反射来实例化泛型类型的一种方法，如问题陈述所指定的。不过，需要考虑的一点是，你是否希望在将来添加更多格式支持？你将不得不返回到`Report`类并更改`switch`语句，这是一种通过代码更改的配置。如果你希望只编写一次`Report`类并且永远不再修改它呢？此外，如果你更喜欢通过约定优于配置的原则进行设计呢？.NET中约定优于配置的一个很好的例子是ASP.NET
    MVC。ASP.NET MVC的一些约定包括控制器放在`Controllers`文件夹中，视图放在`Views`文件夹中。另一个约定是控制器名称是URL路径，其名称带有`Controller`后缀。这些事情只是因为这是约定而工作。`CreateGenerator`的第二个例子使用了约定优于配置的方法。
- en: Notice that the second implementation of `CreateGenerator` builds a fully qualified
    type name with namespace and typename (e.g., `Section_05_03.HtmlGenerator` for
    `Html`). Also notice that the `ReportType` enum members match the class names
    exactly. This means that anytime in the future, you can create a new format, derived
    from `GeneratorBase`, and add the prefix to `ReportType` with `Generator` as the
    suffix and it will work. No need to ever touch the `Report` class again, unless
    adding a new feature.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`CreateGenerator`的第二个实现会构建一个带有命名空间和类型名称的完全限定类型名（例如，对于`Html`是`Section_05_03.HtmlGenerator`）。还请注意，`ReportType`枚举成员与类名完全匹配。这意味着将来任何时候，你都可以创建一个新格式，从`GeneratorBase`派生，并将前缀添加到`ReportType`，以`Generator`作为后缀，它将起作用。除非添加新功能，否则不需要再次触及`Report`类。
- en: After getting type objects, both `CreateGenerator` examples call `Activator.Create​In⁠stance`
    to return a new instance to `Report.Generate`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取类型对象之后，两个`CreateGenerator`示例都调用`Activator.CreateInstance`返回一个新实例给`Report.Generate`。
- en: Finally, looking at the `Main` method, all a user of this report library needs
    to do is pass in the data and the `ReportType` they want to generate.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，看看`Main`方法，这个报告库的用户所需做的就是传入数据和他们想要生成的`ReportType`。
- en: See Also
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 5.2, “Accessing Type Members with Reflection”](#accessing_type_members_with_reflection)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[5.2节，“使用反射访问类型成员”](#accessing_type_members_with_reflection)'
- en: '[Recipe 5.6, “Performing Interop with Office Apps”](#performing_interop_with_office_apps)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[5.6节，“与Office应用程序进行Interop”](#performing_interop_with_office_apps)'
- en: 5.4 Invoking Methods with Reflection
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.4 使用反射调用方法
- en: Problem
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: An object you’ve received has methods that you need to invoke.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您收到的对象具有需要调用的方法。
- en: Solution
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'The column metadata class has a `MemberInfo` property:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列元数据类具有`MemberInfo`属性：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This class, to be reflected upon, has properties and a method:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类，要进行反射，有属性和一个方法：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This method calls `GetMembers` to work with `MemberInfo` instances:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法调用`GetMembers`以处理`MemberInfo`实例：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This method uses the `MemberInfo` type to determine how to retrieve a value:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用`MemberInfo`类型来确定如何检索值：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Discussion
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Earlier sections in this chapter worked primarily with properties as report
    inputs. In this section we’ll modify the example in [Recipe 5.2](#accessing_type_members_with_reflection)
    and add a method that we’ll need to invoke via reflection.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 本章前几节主要使用属性作为报表输入。在本节中，我们将修改[Recipe 5.2](https://example.org/#accessing_type_members_with_reflection)中的示例，并添加我们需要通过反射调用的方法。
- en: The first change is that `ColumnDetail` has a `MemberInfo` property, which holds
    metadata for any type member.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变化是`ColumnDetail`有一个`MemberInfo`属性，该属性保存了任何类型成员的元数据。
- en: The `InventoryItem` class has a `CalculateTotal` method. It multiplies the `ItemPrice`
    and `Count` to show the total price for that amount of items.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`InventoryItem`类有一个`CalculateTotal`方法。它将`ItemPrice`和`Count`相乘，显示该数量物品的总价格。'
- en: The change in `GetColumnDetails` is in the LINQ statement, where it iterates
    on the result of `GetMembers`, which is a `MemberInfo[]`. Unlike [Recipe 5.2](#accessing_type_members_with_reflection),
    we’re using `MemberInfo`. This is required for this solution because we want information
    on both properties and methods.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在LINQ语句中，`GetColumnDetails`的变化在于它迭代了`GetMembers`的结果，这是一个`MemberInfo[]`。与[Recipe
    5.2](https://example.org/#accessing_type_members_with_reflection)不同，我们使用`MemberInfo`。这对于解决方案是必需的，因为我们希望获取属性和方法的信息。
- en: Finally, `GetReflectedResult` has a `switch` statement to figure out how to
    get a member’s value. Since the parameter is a `MemberInfo`, we look at the `MemberType`
    property to figure out whether we’re working with a property or method. In either
    case, we have to call `GetProperty` or `GetMethod` to get a `PropertyInfo` or
    `MethodInfo`, respectively. Call the `Invoke` method for methods, with `item`
    as the object instance to invoke the method on. The second parameter to `Invoke`
    is `null`, indicating that the method, `CalculateTotal` in this example, doesn’t
    have arguments. If you need to pass arguments, put an `object[]` in the second
    parameter of `Invoke` with the members in the order that the method expects them.
    As in [Recipe 5.2](#accessing_type_members_with_reflection), call `GetValue` on
    the `Proper⁠ty​Info` instance, with `item` as the object reference to get the
    value of that property.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`GetReflectedResult`有一个`switch`语句来确定如何获取成员的值。由于参数是`MemberInfo`，我们查看`MemberType`属性来确定是否在处理属性或方法。无论哪种情况，我们都必须调用`GetProperty`或`GetMethod`来获取`PropertyInfo`或`MethodInfo`。对于方法，调用`Invoke`方法，参数是`item`作为要调用方法的对象实例。`Invoke`的第二个参数是`null`，表示此示例中的方法`CalculateTotal`没有参数。如果需要传递参数，请将`object[]`放入`Invoke`的第二个参数中，按照方法期望的顺序传递成员。如同[Recipe
    5.2](https://example.org/#accessing_type_members_with_reflection)一样，在`Proper⁠ty​Info`实例上调用`GetValue`，使用`item`作为对象引用来获取该属性的值。
- en: To summarize, anytime you need to call a method on an object via reflection,
    get its `Type` object, get a `MethodInfo` (even if you need the intermediate step
    of pulling from a `MemberInfo`), and call the `Invoke` method on the `MethodInfo`
    with the object instance as the argument.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，每当您需要通过反射调用对象的方法时，获取其`Type`对象，获取一个`MethodInfo`（即使您需要从`MemberInfo`中获取中间步骤），然后调用`Invoke`方法，并将对象实例作为参数传递给`MethodInfo`。
- en: See Also
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 5.2, “Accessing Type Members with Reflection”](#accessing_type_members_with_reflection)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 5.2，“使用反射访问类型成员”](https://example.org/#accessing_type_members_with_reflection)'
- en: 5.5 Replacing Reflection with Dynamic Code
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.5 用动态代码替换反射
- en: Problem
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You’re using reflection but know what some of a type’s members are and want
    to simplify code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用反射时，但了解某个类型的一些成员，并希望简化代码时。
- en: Solution
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This class contains the list of data for a report:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此类包含报表的数据列表：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here’s the `Main` method that populates the data:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是填充数据的`Main`方法：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This method uses reflection to extract a property’s values:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用反射来提取属性的值：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And this class extracts the same property values but uses `dynamic`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类提取相同的属性值，但使用`dynamic`：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Discussion
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The concept of this solution is again to give users of the report library maximum
    control over what types they want to work with. However, what if you did have
    some constraints? For instance, there must be some way to set the report title,
    and you would need to know what that property is. This solution meets the user
    halfway by telling them to provide an object with `Title` and `Data` properties.
    `Title` has the report title and `Data` has report rows. They can use any object
    they want as long as they provide those properties. If the input objects had other
    properties on the object we don’t care about, it won’t affect the report library.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案的概念再次是为报告库的用户提供对他们想要使用的类型的最大控制权。但是，如果你确实有一些限制怎么办？例如，必须有一种设置报告标题的方法，并且你需要知道那个属性是什么。这个解决方案通过告诉用户提供一个具有`Title`和`Data`属性的对象来与用户妥协。`Title`包含报告标题，`Data`包含报告行。只要他们提供这些属性，他们可以使用任何他们想要的对象。如果输入对象上有其他我们不关心的属性，它不会影响报告库。
- en: The class we’ll use is `Inventory`, with a `Title` string and `Data` collection.
    The `Main` method populates an `Inventory` instance and passes it to `Generate`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的类是`Inventory`，包含一个`Title`字符串和一个`Data`集合。`Main`方法填充一个`Inventory`实例并将其传递给`Generate`。
- en: 'We have two examples of `Generate`: one uses reflection and the other uses
    dynamic. After getting the type, the first example calls `GetProperty` and `GetValue`
    to get the value of each property. The rest of the method works just like in [Recipe
    5.2](#accessing_type_members_with_reflection).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个`Generate`的示例：一个使用反射，另一个使用动态。在获取类型后，第一个示例调用`GetProperty`和`GetValue`来获取每个属性的值。方法的其余部分与[配方
    5.2](#accessing_type_members_with_reflection)中的操作方式相同。
- en: As you see, reflection can be verbose, making many method calls and converting
    types. This is a good case for using `dynamic`. We know that `Title` and `Data`
    exist, so why not just access them? That’s what the second example does. First,
    notice that the `reportDetails` parameter type is `dynamic`. Then observe how
    the code calls `Title` and `Data`, placing them in strongly typed variables.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，反射可能会很冗长，进行许多方法调用和类型转换。这是使用`dynamic`的一个好案例。我们知道`Title`和`Data`是存在的，那为什么不直接访问它们呢？这就是第二个示例的做法。首先，注意`reportDetails`参数的类型是`dynamic`。然后观察代码如何调用`Title`和`Data`，并将它们放入强类型变量中。
- en: Note
  id: totrans-174
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `dynamic` type is still type `object` but with a little extra magic performed
    behind the scenes by the DLR.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynamic`类型仍然是`object`类型，但是由 DLR 在后台执行了一些额外的魔法。'
- en: While you don’t get IntelliSense during development because `dynamic` doesn’t
    know what types it’s working with, you do get readable code. Behind the scenes,
    the DLR did all the work for you. When you know the members of the types being
    passed to the code, `dynamic` is a better mechanism for reflection.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，由于`dynamic`不知道它正在处理的类型，所以你不能获得 IntelliSense，但是你可以得到可读的代码。在你了解到传递给代码的类型的成员时，`dynamic`是反射的更好机制。
- en: See Also
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 5.2, “Accessing Type Members with Reflection”](#accessing_type_members_with_reflection)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[配方 5.2，“使用反射访问类型成员”](#accessing_type_members_with_reflection)'
- en: 5.6 Performing Interop with Office Apps
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.6 使用 Office 应用程序进行互操作
- en: Problem
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to populate an Excel spreadsheet with object data with the simplest
    code possible.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用尽可能简单的代码填充 Excel 电子表格中的对象数据。
- en: Solution
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s an enum with extra members for Excel:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个为 Excel 添加额外成员的枚举：
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Excel report generator without `dynamic`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用`dynamic`的 Excel 报告生成器：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Excel report generator with dynamic:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用动态生成 Excel 报告：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Discussion
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: This example is based on the multiple report format generation code in [Recipe
    5.3](#instantiating_type_members_with_reflection), which briefly explains how
    to add another report type. This solution shows how to do it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例基于[配方 5.3](#instantiating_type_members_with_reflection)中的多报告格式生成代码，简要说明了如何添加另一种报告类型。这个解决方案展示了如何实现。
- en: 'First, notice that the `ReportType` enum has two extra members: `ExcelTyped`
    and `ExcelDynamic`. Both use the convention where `ExcelTyped` creates a `ExcelTyped​Gen⁠erator`
    instance and `ExcelDynamic` creates an `ExcelDynamicGenerator` instance. The difference
    is that `ExcelTypedGenerator` uses strongly typed code to generate an Excel report,
    and `ExcelDynamicGenerator` uses dynamic code to generate an Excel report.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意`ReportType`枚举有两个额外的成员：`ExcelTyped`和`ExcelDynamic`。两者都使用一致的约定，其中`ExcelTyped`创建一个`ExcelTypedGenerator`实例，而`ExcelDynamic`创建一个`ExcelDynamicGenerator`实例。区别在于，`ExcelTypedGenerator`使用强类型代码生成
    Excel 报告，而`ExcelDynamicGenerator`使用动态代码生成 Excel 报告。
- en: Tip
  id: totrans-192
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You can use techniques like this to automate any Microsoft Office application.
    The trick is to ensure you’ve installed Visual Studio Tools for Office (VSTO)
    via the Visual Studio Installer. This will install what is called *primary interop
    assemblies* (PIAs). After installation, you can find these PIAs under your Visual
    Studio installation folder (for instance, the folder on my machine is *C:\Program
    Files (x86)\Microsoft Visual Studio\Shared\Visual Studio Tools for Office\PIA*)
    and use the version corresponding to the Microsoft Office version you have installed.
    Search the [download options](https://oreil.ly/vbMvL) if you have an older version
    of Office that the VSTO couldn’t install.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这样的技术来自动化任何 Microsoft Office 应用程序。关键是确保您已通过 Visual Studio Installer 安装了
    Visual Studio Tools for Office（VSTO）。这将安装所谓的*主互操作程序集*（PIAs）。安装后，您可以在您的 Visual
    Studio 安装文件夹下找到这些 PIAs（例如，我的机器上的文件夹是*C:\Program Files (x86)\Microsoft Visual Studio\Shared\Visual
    Studio Tools for Office\PIA*），并使用与您安装的 Microsoft Office 版本对应的版本。如果您的 Office 版本较旧，无法安装
    VSTO，请搜索[下载选项](https://oreil.ly/vbMvL)。
- en: To see the differences between the two examples, go member by member. In particular,
    `ExcelTypedGenerator` has strongly typed fields, so it must use the `Missing.Value`
    placeholder anytime it doesn’t use a parameter and needs to perform a conversion
    on return types. Notice the `SaveAs` method call at the end of the `GetRows` method,
    which is particularly onerous.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这两个示例之间的区别，请逐个成员地查看。特别是 `ExcelTypedGenerator` 具有强类型字段，因此每当不使用参数并且需要对返回类型执行转换时，必须使用
    `Missing.Value` 占位符。注意 `GetRows` 方法末尾的 `SaveAs` 方法调用，这特别繁琐。
- en: In contrast, compare those examples with the `ExcelDynamicGenerator` code. Making
    the `wkBook` field `dynamic`, rather than strongly typed, transforms the code.
    No more `Missing.Value` placeholders or type conversions. The code is much easier
    to write and easier to read.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，将这些示例与 `ExcelDynamicGenerator` 代码进行比较。将 `wkBook` 字段设置为 `dynamic`，而不是强类型，可以改变代码。不再需要
    `Missing.Value` 占位符或类型转换。代码编写起来更容易，阅读起来也更容易。
- en: See Also
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 5.3, “Instantiating Type Members with Reflection”](#instantiating_type_members_with_reflection)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 5.3，“使用反射实例化类型成员”](#instantiating_type_members_with_reflection)'
- en: 5.7 Creating an Inherently Dynamic Type
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.7 创建一个固有动态类型
- en: Problem
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have data in a proprietary format but want to access members through an
    object without parsing yourself.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您的数据以专有格式存在，但希望通过对象访问成员而无需自行解析。
- en: Solution
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This class holds data to display in a report:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类保存要显示在报告中的数据：
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'These methods get log data and return a list of `DynamicObject` types with
    that data:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法获取日志数据并返回具有该数据的 `DynamicObject` 类型列表：
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This class is a `DynamicObject` that knows how to read log files and dynamically
    expose properties:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类是一个 `DynamicObject`，它知道如何读取日志文件并动态公开属性：
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `Main` method consumes the dynamic data, populates data objects, and gets
    a new report:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法消耗动态数据，填充数据对象，并获取新报告：'
- en: '[PRE39]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Discussion
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The `DynamicObject` type is part of the .NET Framework and supports the DLR
    for interoperability with dynamic languages. It’s a peculiar type that lets anyone
    call type members, and it can intercept the call and behave in any way you’ve
    programmed it to. Rather than wave hands and enumerate several ways to use `DynamicObject`,
    this solution focuses on the problem where you need an object to work on proprietary
    data. In this solution, the data is a log file format. Here, we’ll use the `DynamicObject`
    to provide the data and the report library from [Recipe 5.2](#accessing_type_members_with_reflection)
    to display the log data.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`DynamicObject` 类型是 .NET Framework 的一部分，支持用于与动态语言的互操作性的 DLR。这是一种特殊的类型，允许任何人调用类型成员，并且它可以拦截调用并根据您编程的方式行为。与其挥手列举使用
    `DynamicObject` 的几种方法，这个解决方案专注于需要一个对象来处理专有数据的问题。在这个解决方案中，数据是日志文件格式。在这里，我们将使用 `DynamicObject`
    提供数据，并使用来自[Recipe 5.2](#accessing_type_members_with_reflection)的报告库来显示日志数据。'
- en: The `LogEntry` class represents a row in the report. We can’t give a `DynamicObject`
    instance to `Report` because there isn’t a way to reflect on it and extract attributes.
    Any workaround is cumbersome, and it’s easier to use the `DynamicObject` for working
    with the data, generate a collection of `LogEntry` objects, and pass them to the
    `Report`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`LogEntry` 类表示报告中的一行。我们无法将 `DynamicObject` 实例传递给 `Report`，因为没有办法反射它并提取属性。任何解决方法都很麻烦，使用
    `DynamicObject` 处理数据并生成 `LogEntry` 对象的集合，然后将它们传递给 `Report` 更为简单。'
- en: The `GetLogData` method shows what the log file looks like. `GetData` defines
    a `headers` string, which is metadata for each entry of the log file. The LINQ
    query iterates through each line of the log, resulting in a `List<dynamic>`. The
    projection instantiates a new `DynamicLog` instance with the header and log entry.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetLogData` 方法展示了日志文件的样子。`GetData` 定义了一个 `headers` 字符串，它是每个日志文件条目的元数据。LINQ
    查询遍历日志的每一行，结果是一个 `List<dynamic>`。投影使用头部和日志条目实例化一个新的 `DynamicLog` 实例。'
- en: 'The `DynamicLog` type derives from `DynamicObject`, implementing only the methods
    it needs. The `DynamicLog` implementation shows a few of these members: `TryGetMember`,
    `TryInvokeMember`, and `TrySetMember`. The solution doesn’t use `TryInvokeMember`,
    but I left it in there to show that `DynamicObject` does more than work with properties
    and that there are other overloads. The `Dictionary<string, string>` `members`,
    hold a value for each field in the log with the key coming from the header and
    the value coming from the identically positioned string in the log file.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`DynamicLog` 类型继承自 `DynamicObject`，仅实现了它需要的方法。`DynamicLog` 的实现展示了其中一些成员：`TryGetMember`、`TryInvokeMember`
    和 `TrySetMember`。解决方案没有使用 `TryInvokeMember`，但我把它保留在那里以展示 `DynamicObject` 不仅仅与属性一起工作，还有其他重载。`Dictionary<string,
    string>` `members` 中保存着日志中每个字段的值，键来自头部，值来自日志文件中相同位置的字符串。'
- en: The constructor populates members. It splits each field on the pipe, `(|)`,
    separator and iterates through the headers until members has an entry for each
    column. The `TryGetMembers` method reads from the dictionary to return the value
    via the `out object result` parameter. Remember to return `true` when successful
    because returning `false` indicates that you couldn’t perform the operation, and
    the user will receive a runtime exception. `TrySetMember` populates the dictionary
    with the value.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数填充成员。它在每个字段的 `(|)` 分隔符上分割，并通过头部迭代，直到 `members` 每列都有一个条目。`TryGetMembers`
    方法通过 `out object result` 参数从字典读取返回值。记得在成功时返回 `true`，因为返回 `false` 表示无法执行操作，用户将收到运行时异常。`TrySetMember`
    用值填充字典。
- en: '`GetMemberBinder` and `SetMemberBinder` contain metadata on the property that
    is being accessed. For example, the following would call `TryGetMember`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetMemberBinder` 和 `SetMemberBinder` 包含被访问属性的元数据。例如，以下代码将调用 `TryGetMember`：'
- en: '[PRE40]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Assuming that log is an instance of `DynamicLog`, the `GetMemberBinder` `Name`
    property would be `Severity`. It would index into the dictionary and return whatever
    value is assigned to that key. Similarly, the following would call `TrySetMember`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `log` 是 `DynamicLog` 的一个实例，则 `GetMemberBinder` 的 `Name` 属性将是 `Severity`。它将索引字典并返回分配给该键的任何值。类似地，以下代码将调用
    `TrySetMember`：
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this case, `binder.Name` would be `Severity`, and it would update that key
    in the dictionary with the value `ERROR`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`binder.Name` 将是 `Severity`，它将更新字典中该键的值为 `ERROR`。
- en: That means now we have an object where you can set property names of your choosing
    and provide any log file of the same format (pipe-separated). No need for a custom
    class every time you want to accommodate a pipe-separated format log file.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着现在我们有一个对象，您可以在其中设置您选择的属性名称，并提供相同格式的任何日志文件（管道分隔符）。每次您想要适应管道分隔格式的日志文件时，无需自定义类。
- en: '`GetData` returns a `List<dynamic>`. Because it’s a dynamic object and we already
    know what the property names should be (they match the header), we can project
    into `LogEntry` instances by only specifying the property name on the dynamic
    object. Additionally, you could specify what those headers should be in a configuration
    file or database where they can be data-driven and change every time. Maybe you
    even want the ability to change the delimiter on the file to accommodate handling
    even more file types. As you can see, that’s easy to do with `DynamicObject`.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetData` 返回一个 `List<dynamic>`。因为它是一个动态对象，并且我们已经知道属性名称应该是什么（它们与头部匹配），我们可以通过在动态对象上仅指定属性名称来投影为
    `LogEntry` 实例。此外，您可以在配置文件或数据库中指定这些头部，这些头部可以是数据驱动的，并且每次都可以更改。也许您甚至想要能够更改文件的分隔符来处理更多文件类型。正如您所看到的，这在
    `DynamicObject` 中非常容易实现。'
- en: See Also
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 5.2, “Accessing Type Members with Reflection”](#accessing_type_members_with_reflection)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 5.2, “使用反射访问类型成员”](#accessing_type_members_with_reflection)'
- en: 5.8 Adding and Removing Type Members Dynamically
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.8 动态添加和删除类型成员
- en: Problem
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want a fully dynamic object that you can add members to during runtime,
    as in JavaScript.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望一个完全动态的对象，可以在运行时添加成员，就像在 JavaScript 中一样。
- en: Solution
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This method uses an `ExpandoObject` to collect data:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用 `ExpandoObject` 收集数据：
- en: '[PRE42]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `Main` method converts a `List<dynamic>` to a `List<LogEntry>` and gets
    the report:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法将 `List<dynamic>` 转换为 `List<LogEntry>` 并获取报告：'
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Discussion
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: This is similar to the `DynamicObject` example in [Recipe 5.7](#creating_an_inherently_dynamic_type),
    except it covers a simpler case where you don’t need as much flexibility. What
    if you knew what the file format was ahead of time and that it won’t change, yet
    you want a simple way to pull the data into a dynamic object without creating
    a new type every time you need to send data to the report?
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于 [Recipe 5.7](#creating_an_inherently_dynamic_type) 中的 `DynamicObject` 示例，但它涵盖了一个更简单的情况，您不需要那么多的灵活性。如果您预先知道文件格式，并且知道它不会更改，但希望以一种简单的方式将数据提取到动态对象中，而不必每次都创建一个新类型发送到报告中，那该怎么办？
- en: In this case, you can use `ExpandoObject`, a .NET Framework type that lets you
    add and remove type members on the fly, the same as in JavaScript.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您可以使用 `ExpandoObject`，它是 .NET Framework 的一种类型，允许您动态添加和移除类型成员，与 JavaScript
    中的操作相同。
- en: In the solution, the `GetData` method instantiates an `ExpandoObject`, assigning
    it to the `dynamic` `logEntry`. Then, it adds properties on the fly and populates
    them with the parsed log file data.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中，`GetData` 方法实例化一个 `ExpandoObject`，将其分配给 `dynamic` 类型的 `logEntry`。然后，它会动态添加属性，并使用解析的日志文件数据填充这些属性。
- en: The `Main` method accepts a `List<dynamic>` from `GetData`. As long as each
    object has the properties it expects, everything works well.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法从 `GetData` 接受一个 `List<dynamic>`。只要每个对象具有它所期望的属性，一切都会很好。'
- en: See Also
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 5.7, “Creating an Inherently Dynamic Type”](#creating_an_inherently_dynamic_type)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 5.7, “Creating an Inherently Dynamic Type”](#creating_an_inherently_dynamic_type)'
- en: 5.9 Calling Python Code from C#
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.9 从 C# 调用 Python 代码
- en: Problem
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have a C# program and want to use some Python code but don’t want to rewrite
    it.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您有一个 C# 程序，并且想要使用一些 Python 代码，但不想重写它。
- en: Solution
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This Python file has code that we need to use:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 此 Python 文件包含我们需要使用的代码：
- en: '[PRE44]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This class represents social media data:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此类表示社交媒体数据：
- en: '[PRE45]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `Main` method gets data and generates a report:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法获取数据并生成报告：'
- en: '[PRE46]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'These are the required namespaces that are part of the `IronPython` NuGet package:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 `IronPython` NuGet 包的必需命名空间的一部分：
- en: '[PRE47]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This method sets up the Python interop:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法设置了 Python 互操作：
- en: '[PRE48]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This method calls the Python code via `dynamic` instance:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法通过 `dynamic` 实例调用 Python 代码：
- en: '[PRE49]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Discussion
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The scenario in this example is one where you’re working with social media data.
    One of the report items is semantics, telling whether a user’s tweet was positive
    or negative. You’ve got this great semantic analysis AI model, but it’s built
    with TensorFlow in a Python module. It would be helpful to be able to reuse that
    code instead of rewriting it.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您正在处理社交媒体数据。报告中的一个项目是语义分析，告诉用户的推文是积极的还是消极的。您有一个很棒的语义分析 AI 模型，但它是用 TensorFlow
    在 Python 模块中构建的。能够重用该代码而不是重写它将非常有帮助。
- en: This is where the DLR comes in, because it lets you call Python (and other dynamic
    languages) from C#. Considering that it could have taken many months to build
    a machine learning model (or any other type of module), the advantage of reusing
    that code across languages can be huge.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 DLR 的作用所在，因为它允许您从 C# 中调用 Python（以及其他动态语言）。考虑到建立一个机器学习模型（或任何其他类型的模块）可能需要很多个月的时间，跨语言重用代码的优势是巨大的。
- en: The `SemanticAnalysis` class in the Python file simulates a model, returning
    `true` for a positive result or `false` for a negative result.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Python 文件中的 `SemanticAnalysis` 类模拟一个模型，返回正面结果为 `true` 或负面结果为 `false`。
- en: The `Main` method calls `GetTweets` to get data and uses the `Report` class,
    which is the same as in [Recipe 5.2](#accessing_type_members_with_reflection).
    The `List<object>` returned from `GetTweets` contains `Tweet` objects that can
    work with the report generator.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法调用 `GetTweets` 来获取数据，并使用 `Report` 类，与 [Recipe 5.2](#accessing_type_members_with_reflection)
    中相同。从 `GetTweets` 返回的 `List<object>` 包含可以与报告生成器一起工作的 `Tweet` 对象。'
- en: Tip
  id: totrans-261
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: To set this up, you’ll need to reference the `IronPython` package, which you
    can find on NuGet. You also might find it useful to install Python Tools for Visual
    Studio via the Visual Studio Installer.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置这一点，您需要引用 `IronPython` 包，您可以在 NuGet 上找到它。您还可能发现通过 Visual Studio 安装程序安装 Python
    工具对于 Visual Studio 会很有用。
- en: The `GetTweets` method needs a reference to the Python `SemanticAnalysis` class.
    Calling `CreateRuntime` creates a DLR reference. Then you need to specify the
    location of the Python file via `UseFile`. After that, you can instantiate the
    `SemanticAnalysis` class. Each `Tweet` instance sets the `Semantics` property
    with a call to `GetSemanticText`, passing the `SemanticAnalysis` reference and
    `text` to evaluate.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetTweets`方法需要一个对Python `SemanticAnalysis`类的引用。调用`CreateRuntime`创建一个DLR引用。然后，您需要通过`UseFile`指定Python文件的位置。之后，您可以实例化`SemanticAnalysis`类。每个`Tweet`实例通过调用`GetSemanticText`，传递`SemanticAnalysis`引用和`text`来设置`Semantics`属性。'
- en: The `GetSemanticText` method calls `Eval` with `text` as its parameter and returns
    a `bool` result, which it then translates to a report-friendly “Positive” or “Negative”
    string.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetSemanticText`方法调用`Eval`并以`text`作为其参数，返回一个`bool`结果，然后将其翻译为报告友好的“Positive”或“Negative”字符串。'
- en: In just a few lines of code, you saw how easy it is to reuse important code
    that was written in a dynamic language. Languages supported by the DLR include
    Ruby and JavaScript, among others.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在几行代码中，您看到了重用用动态语言编写的重要代码有多容易。DLR支持的语言包括Ruby和JavaScript等。
- en: See Also
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 5.2, “Accessing Type Members with Reflection”](#accessing_type_members_with_reflection)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 5.2，“使用反射访问类型成员”](#accessing_type_members_with_reflection)'
- en: 5.10 Calling C# Code from Python
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.10 从Python调用C#代码
- en: Problem
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have a Python program and want to use C# code but don’t want to rewrite
    it.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 您有一个Python程序，并且想要使用C#代码，但不想重写它。
- en: Solution
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s the main Python application that needs to use the report generator:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这是需要使用报告生成器的主要Python应用程序：
- en: '[PRE50]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This class has a constructor to make it easier to work with in Python:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有一个构造函数，以便在Python中更容易使用：
- en: '[PRE51]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here’s the C# method that the Python code calls to generate the report:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Python代码调用以生成报告的C#方法：
- en: '[PRE52]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Discussion
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: In [Recipe 5.9](#calling_python_code_from_C_sharp), the scenario was to call
    Python from C#. The scenario in this problem is opposite in that I have a Python
    application and need to be able to generate reports. However, the report generator
    is written in C#. So much work has gone into the report library that it doesn’t
    make sense to rewrite in Python. Fortunately, the DLR allows us to call that C#
    code with Python.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Recipe 5.9](#calling_python_code_from_C_sharp)中，场景是从C#调用Python。在这个问题中的场景相反，我有一个Python应用程序，并且需要能够生成报告。然而，报告生成器是用C#编写的。报告库已经投入了大量工作，因此重写为Python没有意义。幸运的是，DLR允许我们用Python调用那个C#代码。
- en: The report is the same one used in [Recipe 5.2](#accessing_type_members_with_reflection)
    and the C# code has the same `Inventor⁠y​Item` class.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 报告与[Recipe 5.2](#accessing_type_members_with_reflection)中使用的相同，而且C#代码具有相同的`InventoryItem`类。
- en: Tip
  id: totrans-281
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'To set this up, you might need to install the [`pythonnet` package](https://oreil.ly/hY9bZ):'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置这个，您可能需要安装[`pythonnet` package](https://oreil.ly/hY9bZ)：
- en: '[PRE53]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You set up the Python code by importing `clr` and `sys`, calling `sys.path.append`
    as a reference to the path where the C# DLL resides and then calling `clr.AddReference`
    to add a reference to the C# DLL you want to use.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导入`clr`和`sys`来设置Python代码，并调用`sys.path.append`来引用C# DLL所在的路径，然后调用`clr.AddReference`来添加对要使用的C#
    DLL的引用。
- en: In Python, whenever you need to use a .NET type from either the framework or
    a custom assembly, use the `from Namespace import type` syntax, which is roughly
    equivalent to a C# `using` declaration. The namespace in the C# source code is
    `PythonToCS` and the code uses that to import a reference to `Report` and `InventoryItem`.
    It also uses the `System` namespace to get a reference to the `Decimal` type,
    which aliases the C# `decimal` type.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，每当您需要从框架或自定义程序集中使用.NET类型时，请使用`from Namespace import type`语法，它大致相当于C#的`using`声明。在C#源代码中，命名空间是`PythonToCS`，代码使用它来导入`Report`和`InventoryItem`的引用。它还使用`System`命名空间来获取对`Decimal`类型的引用，该类型别名为C#的`decimal`类型。
- en: In Python, whenever you use square brackets, `[]`, you’re creating a data structure
    called a `list`. It’s a collection of objects with Python semantics. In this example,
    we’re creating a list of `InventoryItem`, assigning it to a variable named `inventory`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，每当您使用方括号`[]`时，您正在创建一个名为`list`的数据结构。它是一个具有Python语义的对象集合。在这个例子中，我们正在创建一个`InventoryItem`列表，并将其赋值给名为`inventory`的变量。
- en: Notice we’re using `Decimal` for the last parameter, `itemPrice`, of the `InventoryItem`
    constructor. Python doesn’t have a concept of `decimal` and will pass that value
    as a `float`, which causes an error because the C# `InventoryItem` defines that
    parameter as a `decimal`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`InventoryItem`构造函数的最后一个参数`itemPrice`中我们使用了`Decimal`。Python 没有`decimal`的概念，会将该值作为`float`传递，这会导致错误，因为
    C# 中的 `InventoryItem` 将该参数定义为`decimal`。
- en: Next, the Python code instantiates `Report`, `rpt`, and calls `GenerateDynamic`,
    passing `inventory`. This calls the `GenerateDynamic` in `Report` and automatically
    translates inventory from a Python `list` into a C# `dynamic[]`, `items`. Because
    each object in `items` is `dynamic`, we can query it using a LINQ statement, accessing
    the names of each object dynamically in the projection.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Python 代码实例化了`Report`，`rpt`，并调用了`GenerateDynamic`，传递了`inventory`。这将在`Report`中调用`GenerateDynamic`，并自动将
    Python 的`list`转换为 C# 的`dynamic[]`，`items`。因为`items`中的每个对象都是`dynamic`，我们可以使用 LINQ
    语句查询它，动态访问投影中每个对象的名称。
- en: Finally, `GenerateDynamically` calls `Generate`, the application returns a report,
    and the Python code prints the report.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`GenerateDynamically`调用`Generate`，应用程序返回一个报告，Python 代码打印该报告。
- en: See Also
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Recipe 5.2, “Accessing Type Members with Reflection”](#accessing_type_members_with_reflection)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 5.2，“使用反射访问类型成员”](#accessing_type_members_with_reflection)'
- en: '[Recipe 5.9, “Calling Python Code from C#”](#calling_python_code_from_C_sharp)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 5.9，“从 C# 调用 Python 代码”](#calling_python_code_from_C_sharp)'
