- en: Chapter 3\. Creating Types in C#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章\. 在 C# 中创建类型
- en: In this chapter, we delve into types and type members.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了类型和类型成员。
- en: Classes
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: 'A class is the most common kind of reference type. The simplest possible class
    declaration is as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 类是最常见的引用类型。最简单的类声明如下：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A more complex class optionally has the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的类可选包括以下内容：
- en: '| Preceding the keyword `class` | *Attributes* and *class modifiers*. The non-nested
    class modifiers are `public`, `internal`, `abstract`, `sealed`, `static`, `unsafe`,
    and `partial`. |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| 在关键字 `class` 前面 | *属性* 和 *类修饰符*。非嵌套类修饰符包括 `public`、`internal`、`abstract`、`sealed`、`static`、`unsafe`
    和 `partial`。 |'
- en: '| Following `YourClassName` | *Generic type parameters* and *constraints*,
    a *base class*, and *interfaces*. |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| 在 `YourClassName` 之后 | *泛型类型参数* 和 *约束*，一个 *基类* 和 *接口*。 |'
- en: '| Within the braces | *Class members* (these are *methods*, *properties*, *indexers*,
    *events*, *fields*, *constructors*, *overloaded operators*, *nested types*, and
    a *finalizer*). |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 在大括号内 | *类成员*（这些是 *方法*、*属性*、*索引器*、*事件*、*字段*、*构造函数*、*重载操作符*、*嵌套类型* 和 *终结器*）。
    |'
- en: This chapter covers all of these constructs except attributes, operator functions,
    and the `unsafe` keyword, which are covered in [Chapter 4](ch04.html#advanced_chash).
    The following sections enumerate each of the class members.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章覆盖了所有这些结构，除了属性、操作符函数和 `unsafe` 关键字，这些在 [第四章](ch04.html#advanced_chash) 中详细讨论。以下各节列举了每个类成员。
- en: Fields
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段
- en: 'A *field* is a variable that is a member of a class or struct; for example:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*字段* 是类或结构的成员变量；例如：'
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Fields allow the following modifiers:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 字段允许以下修饰符：
- en: '| Static modifier | `static` |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 静态修饰符 | `static` |'
- en: '| Access modifiers | `public internal private protected` |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 访问修饰符 | `public internal private protected` |'
- en: '| Inheritance modifier | `new` |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 继承修饰符 | `new` |'
- en: '| Unsafe code modifier | `unsafe` |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 不安全代码修饰符 | `unsafe` |'
- en: '| Read-only modifier | `readonly` |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 只读修饰符 | `readonly` |'
- en: '| Threading modifier | `volatile` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 线程修饰符 | `volatile` |'
- en: 'There are two popular naming conventions for private fields: camel-cased (e.g.,
    `firstName`), and camel-cased with an underscore (`_firstName`). The latter convention
    lets you instantly distinguish private fields from parameters and local variables.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 私有字段有两种常用的命名约定：小驼峰式（例如，`firstName`），以及带下划线的小驼峰式（`_firstName`）。后一种约定使你能够立即区分私有字段和参数以及局部变量。
- en: The readonly modifier
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 只读修饰符
- en: The `readonly` modifier prevents a field from being modified after construction.
    A read-only field can be assigned only in its declaration or within the enclosing
    type’s constructor.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`readonly` 修饰符防止字段在构造后被修改。只读字段只能在其声明中或在封闭类型的构造函数中赋值。'
- en: Field initialization
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字段初始化
- en: 'Field initialization is optional. An uninitialized field has a default value
    (`0`, `''\0''`, `null`, `false`). Field initializers run before constructors:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 字段初始化是可选的。未初始化的字段具有默认值（`0`、`'\0'`、`null`、`false`）。字段初始化器在构造函数之前运行：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A field initializer can contain expressions and call methods:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 字段初始化器可以包含表达式并调用方法：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Declaring multiple fields together
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明多个字段一起
- en: 'For convenience, you can declare multiple fields of the same type in a comma-separated
    list. This is a convenient way for all the fields to share the same attributes
    and field modifiers:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，你可以在逗号分隔的列表中声明多个相同类型的字段。这是所有字段共享相同属性和字段修饰符的便捷方式：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Constants
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量
- en: A *constant* is evaluated statically at compile time, and the compiler literally
    substitutes its value whenever used (rather like a macro in C++). A constant can
    be `bool`, `char`, `string`, any of the built-in numeric types, or an enum type.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*常量* 在编译时静态评估，并且编译器在使用时字面上替换它的值（有点像 C++ 中的宏）。常量可以是 `bool`、`char`、`string`，任何内置数值类型，或者枚举类型。'
- en: 'A constant is declared with the `const` keyword and must be initialized with
    a value. For example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `const` 关键字声明常量，并且必须用一个值进行初始化。例如：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A constant can serve a similar role to a `static readonly` field, but it is
    much more restrictive—both in the types you can use and in field initialization
    semantics. A constant also differs from a `static readonly` field in that the
    evaluation of the constant occurs at compile time; thus
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 常量可以类似于 `static readonly` 字段，但限制更多——包括可以使用的类型以及字段初始化语义。常量与 `static readonly`
    字段的不同之处在于常量的评估发生在编译时；因此
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: is compiled to
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 编译为
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It makes sense for `PI` to be a constant because its value is predetermined
    at compile time. In contrast, a `static readonly` field’s value can potentially
    differ each time the program is run:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将`PI`定义为常量是有意义的，因为其值在编译时确定。相比之下，`static readonly`字段的值可能每次程序运行时都有所不同：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'A `static readonly` field is also advantageous when exposing to other assemblies
    a value that might change in a later version. For instance, suppose that assembly
    `X` exposes a constant as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当向其他装配件暴露可能在后续版本中更改的值时，`static readonly`字段也很有优势。例如，假设装配件`X`将常量暴露如下：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If assembly `Y` references `X` and uses this constant, the value `2.3` will
    be baked into assembly `Y` when compiled. This means that if `X` is later recompiled
    with the constant set to 2.4, `Y` will still use the old value of 2.3 *until*
    `Y` *is recompiled*. A `static readonly` field avoids this problem.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果装配件`Y`引用`X`并使用此常量，则编译时装配件`Y`将使用值`2.3`。这意味着如果稍后使用常量重新编译`X`为2.4，则`Y`仍将使用旧值2.3，*直到*重新编译`Y`。使用`static
    readonly`字段可以避免此问题。
- en: Another way of looking at this is that any value that might change in the future
    is not constant by definition; thus, it should not be represented as one.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待这个问题的方式是，任何可能在将来改变的值从定义上来说都不是常量；因此，不应该将其表示为常量。
- en: 'Constants can also be declared local to a method:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 常量也可以声明为方法的局部变量：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Nonlocal constants allow the following modifiers:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 非局部常量允许以下修饰符：
- en: '| Access modifiers | `public internal private protected` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 访问修饰符 | `public internal private protected` |'
- en: '| Inheritance modifier | `new` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 继承修饰符 | `new` |'
- en: Methods
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法
- en: A method performs an action in a series of statements. A method can receive
    *input* data from the caller by specifying *parameters* and *output* data back
    to the caller by specifying a *return type*. A method can specify a `void` return
    type, indicating that it doesn’t return any value to its caller. A method can
    also output data back to the caller via `ref`/`out` parameters.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 方法通过一系列语句执行操作。方法可以通过指定*参数*和*返回类型*从调用者那里接收*输入*数据，并将*输出*数据返回给调用者。方法可以指定`void`返回类型，表示不向其调用者返回任何值。方法还可以通过`ref`/`out`参数向调用者输出数据。
- en: A method’s *signature* must be unique within the type. A method’s signature
    comprises its name and parameter types in order (but not the parameter *names*,
    nor the return type).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的*签名*在类型内必须是唯一的。方法的签名由其名称和参数类型按顺序组成（但不包括参数*名称*，也不包括返回类型）。
- en: 'Methods allow the following modifiers:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 方法允许以下修饰符：
- en: '| Static modifier | `static` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 静态修饰符 | `static` |'
- en: '| Access modifiers | `public internal private protected` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 访问修饰符 | `public internal private protected` |'
- en: '| Inheritance modifiers | `new virtual abstract override sealed` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 继承修饰符 | `new virtual abstract override sealed` |'
- en: '| Partial method modifier | `partial` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 部分方法修饰符 | `partial` |'
- en: '| Unmanaged code modifiers | `unsafe extern` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 未管理代码修饰符 | `unsafe extern` |'
- en: '| Asynchronous code modifier | `async` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 异步代码修饰符 | `async` |'
- en: Expression-bodied methods
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表达式主体方法
- en: A method that comprises a single expression, such as
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 方法可以由单个表达式组成，例如
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'can be written more tersely as an *expression-bodied method*. A fat arrow replaces
    the braces and `return` keyword:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可以更简洁地编写为*表达式主体方法*。一个箭头符号替代大括号和`return`关键字：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Expression-bodied functions can also have a void return type:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式主体函数也可以具有`void`返回类型：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Local methods
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 局部方法
- en: 'You can define a method within another method:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 可在另一个方法内定义方法：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The local method (`Cube`, in this case) is visible only to the enclosing method
    (`WriteCubes`). This simplifies the containing type and instantly signals to anyone
    looking at the code that `Cube` is used nowhere else. Another benefit of local
    methods is that they can access the local variables and parameters of the enclosing
    method. This has a number of consequences, which we describe in detail in [“Capturing
    Outer Variables”](ch04.html#capturing_outer_variables).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 局部方法（本例中的`Cube`）仅对封闭方法（`WriteCubes`）可见。这简化了包含类型，并立即向查看代码的任何人表明`Cube`没有其他用途。局部方法的另一个好处是可以访问封闭方法的局部变量和参数。我们将详细描述这些的几个后果，见[“捕获外部变量”](ch04.html#capturing_outer_variables)。
- en: Local methods can appear within other function kinds, such as property accessors,
    constructors, and so on. You can even put local methods inside other local methods,
    and inside lambda expressions that use a statement block ([Chapter 4](ch04.html#advanced_chash)).
    Local methods can be iterators ([Chapter 4](ch04.html#advanced_chash)) or asynchronous
    ([Chapter 14](ch14.html#concurrency_and_asynchron)).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 局部方法可以出现在其他函数类型中，例如属性访问器、构造函数等。甚至可以将局部方法放在其他局部方法和使用语句块的lambda表达式中（[第四章](ch04.html#advanced_chash)）。局部方法可以是迭代器（[第四章](ch04.html#advanced_chash)）或异步的（[第十四章](ch14.html#concurrency_and_asynchron)）。
- en: Static local methods
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态局部方法
- en: Adding the `static` modifier to a local method (from C# 8) prevents it from
    seeing the local variables and parameters of the enclosing method. This helps
    to reduce coupling and prevents the local method from accidentally referring to
    variables in the containing method.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 将`static`修饰符添加到局部方法（从C# 8开始）可以防止其访问封闭方法的局部变量和参数。这有助于减少耦合并防止局部方法意外引用包含方法中的变量。
- en: Local methods and top-level statements
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 局部方法和顶层语句
- en: 'Any methods that you declare in top-level statements are treated as local methods.
    This means that (unless marked as `static`) they can access the variables in the
    top-level statements:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶层语句中声明的任何方法都视为局部方法。这意味着（除非标记为`static`），它们可以访问顶层语句中的变量：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Overloading methods
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法重载
- en: Warning
  id: totrans-79
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Local methods cannot be overloaded. This means that methods declared in top-level
    statements (which are treated as local methods) cannot be overloaded.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 局部方法不能被重载。这意味着在顶层语句中声明的方法（视为局部方法）不能被重载。
- en: 'A type can *overload* methods (define multiple methods with the same name)
    as long as the signatures are different. For example, the following methods can
    all coexist in the same type:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 类型可以*重载*方法（定义多个具有相同名称的方法），只要签名不同。例如，以下方法可以在同一类型中并存：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'However, the following pairs of methods cannot coexist in the same type, because
    the return type and the `params` modifier are not part of a method’s signature:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，以下方法对不能在同一类型中并存，因为返回类型和`params`修饰符不是方法签名的一部分：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Whether a parameter is pass-by-value or pass-by-reference is also part of the
    signature. For example, `Foo(int)` can coexist with either `Foo(ref int)` or `Foo(out
    int)`. However, `Foo(ref int)` and `Foo(out int)` cannot coexist:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 是否参数是传值还是传引用也是签名的一部分。例如，`Foo(int)`可以与`Foo(ref int)`或`Foo(out int)`并存。但是，`Foo(ref
    int)`和`Foo(out int)`不能共存：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Instance Constructors
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例构造函数
- en: 'Constructors run initialization code on a class or struct. A constructor is
    defined like a method, except that the method name and return type are reduced
    to the name of the enclosing type:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数在类或结构体上运行初始化代码。构造函数的定义类似于方法，但方法名称和返回类型缩减为封闭类型的名称：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Instance constructors allow the following modifiers:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 实例构造函数允许以下修饰符：
- en: '| Access modifiers | `public internal private protected` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 访问修饰符 | `public internal private protected` |'
- en: '| Unmanaged code modifiers | `unsafe extern` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 非托管代码修饰符 | `unsafe extern` |'
- en: 'Single-statement constructors can also be written as expression-bodied members:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 单语句构造函数也可以写为表达式主体成员：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'If a parameter name (or any variable name, for that matter) conflicts with
    a field name, you can disambiguate by prefixing the field with a `this` reference:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数名称（或者任何变量名称）与字段名称冲突，您可以通过在字段前加上`this`引用来消除歧义：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Overloading constructors
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数重载
- en: 'A class or struct may overload constructors. To avoid code duplication, one
    constructor can call another, using the `this` keyword:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 类或结构体可以重载构造函数。为了避免代码重复，一个构造函数可以调用另一个，使用`this`关键字：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When one constructor calls another, the *called constructor* executes first.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个构造函数调用另一个构造函数时，*被调用的构造函数*先执行。
- en: 'You can pass an *expression* into another constructor, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将一个*表达式*传递到另一个构造函数中，如下所示：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The expression can access static members of the class but not instance members.
    (This is enforced because the object has not been initialized by the constructor
    at this stage, so any methods that you call on it are likely to fail.)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式可以访问类的静态成员，但不能访问实例成员。（这是强制执行的，因为在此阶段对象尚未通过构造函数进行初始化，因此调用它的任何方法可能会失败。）
- en: Note
  id: totrans-105
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'This particular example could be better implemented with a single constructor
    that has `year` as an optional parameter:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的例子最好用一个具有`year`作为可选参数的单一构造函数来实现：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We will offer yet another solution shortly, in [“Object Initializers”](#object_initializers).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后的 [“对象初始化器”](#object_initializers) 中提供另一个解决方案。
- en: Implicit parameterless constructors
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐式无参构造函数
- en: For classes, the C# compiler automatically generates a parameterless public
    constructor if and only if you do not define any constructors. However, as soon
    as you define at least one constructor, the parameterless constructor is no longer
    automatically generated.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类，只有在不定义任何构造函数时，C# 编译器才会自动生成一个无参公共构造函数。但是，一旦您定义了至少一个构造函数，无参构造函数将不再自动生成。
- en: Constructor and field initialization order
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数和字段初始化顺序
- en: 'We previously saw that fields can be initialized with default values in their
    declaration:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先前看到字段可以在其声明中使用默认值进行初始化：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Field initializations occur *before* the constructor is executed, and in the
    declaration order of the fields.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 字段初始化发生在构造函数执行之前，并按字段的声明顺序进行。
- en: Nonpublic constructors
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非公共构造函数
- en: 'Constructors need not be public. A common reason to have a nonpublic constructor
    is to control instance creation via a static method call. The static method could
    be used to return an object from a pool rather than creating a new object, or
    to return various subclasses based on input arguments:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数不必是公共的。具有非公共构造函数的常见原因是通过静态方法调用来控制实例创建。静态方法可以用于从池中返回对象，而不是创建新对象，或者根据输入参数返回各种子类：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Deconstructors
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解构器
- en: 'A deconstructor (also called a *deconstructing method*) acts as an approximate
    opposite to a constructor: whereas a constructor typically takes a set of values
    (as parameters) and assigns them to fields, a deconstructor does the reverse and
    assigns fields back to a set of variables.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 解构方法（也称为*解构方法*）充当构造函数的近似对立面：构造函数通常接受一组值（作为参数）并将它们分配给字段，而解构方法则反之，将字段分配回一组变量。
- en: 'A deconstruction method must be called `Deconstruct` and must have one or more
    `out` parameters, such as in the following class:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 解构方法必须被称为 `Deconstruct`，并且必须有一个或多个 `out` 参数，例如以下类：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following special syntax calls the deconstructor:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下特殊语法调用解构方法：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The second line is the deconstructing call. It creates two local variables
    and then calls the `Deconstruct` method. Our deconstructing call is equivalent
    to the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行是解构调用。它创建两个局部变量，然后调用 `Deconstruct` 方法。我们的解构调用等效于以下内容：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Or:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Deconstructing calls allow implicit typing, so we could shorten our call to
    this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 解构调用允许隐式类型推断，因此我们可以将我们的调用简写为这样：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Or simply this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 或者简单地这样：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-132
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can use C#’s discard symbol (`_`) if you’re uninterested in one or more
    variables:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对一个或多个变量不感兴趣，可以使用 C# 的丢弃符号（`_`）：
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This better indicates your intention than declaring a variable that you never
    use.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这比声明一个从未使用的变量更能表明您的意图。
- en: 'If the variables into which you’re deconstructing are already defined, omit
    the types altogether:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您解构的变量已经定义，可以完全省略类型：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This is called a *deconstructing assignment*. You can use a deconstructing
    assignment to simplify your class’s constructor:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这称为*解构赋值*。您可以使用解构赋值来简化类的构造函数：
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You can offer the caller a range of deconstruction options by overloading the
    `Deconstruct` method.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重载 `Deconstruct` 方法，您可以为调用者提供一系列解构选项。
- en: Note
  id: totrans-141
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `Deconstruct` method can be an extension method (see [“Extension Methods”](ch04.html#extension_methods)).
    This is a useful trick if you want to deconstruct types that you did not author.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`Deconstruct` 方法可以是一个扩展方法（参见 [“扩展方法”](ch04.html#extension_methods)）。如果要解构您未编写的类型，这是一个有用的技巧。'
- en: 'From C# 10, you can mix and match existing and new variables when deconstructing:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 10 开始，在解构时可以混合使用现有变量和新变量：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Object Initializers
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象初始化器
- en: 'To simplify object initialization, any accessible fields or properties of an
    object can be set via an *object initializer* directly after construction. For
    example, consider the following class:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化对象初始化，可以直接在构造之后通过*对象初始化器*设置对象的任何可访问字段或属性。例如，请考虑以下类：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Using object initializers, you can instantiate `Bunny` objects as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象初始化器，您可以像以下方式实例化 `Bunny` 对象：
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The code to construct `b1` and `b2` is precisely equivalent to the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 构造 `b1` 和 `b2` 的代码与以下完全等效：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The temporary variables are to ensure that if an exception is thrown during
    initialization, you can’t end up with a half-initialized object.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 临时变量的作用是确保在初始化过程中抛出异常时，不会得到一个半初始化的对象。
- en: The this Reference
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: this 引用
- en: 'The `this` reference refers to the instance itself. In the following example,
    the `Marry` method uses `this` to set the `partner`’s `mate` field:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`this` 引用指的是实例本身。在以下示例中，`Marry`方法使用`this`来设置`partner`的`mate`字段：'
- en: '[PRE40]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `this` reference also disambiguates a local variable or parameter from
    a field; for example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`this` 引用还可以消除局部变量或参数与字段之间的歧义；例如：'
- en: '[PRE41]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `this` reference is valid only within nonstatic members of a class or struct.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`引用仅在类或结构的非静态成员中有效。'
- en: Properties
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: 'Properties look like fields from the outside, but internally they contain logic,
    like methods do. For example, you can’t tell by looking at the following code
    whether `CurrentPrice` is a field or a property:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从外部看，属性看起来像字段，但在内部它们包含逻辑，就像方法一样。例如，通过查看以下代码，您无法确定`CurrentPrice`是字段还是属性：
- en: '[PRE42]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'A property is declared like a field but with a `get`/`set` block added. Here’s
    how to implement `CurrentPrice` as a property:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 属性声明与字段类似，但添加了`get`/`set`块。以下是如何将`CurrentPrice`实现为属性的示例：
- en: '[PRE43]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`get` and `set` denote property *accessors*. The `get` accessor runs when the
    property is read. It must return a value of the property’s type. The `set` accessor
    runs when the property is assigned. It has an implicit parameter named `value`
    of the property’s type that you typically assign to a private field (in this case,
    `currentPrice`).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`和`set`表示属性的*访问器*。当读取属性时，`get`访问器运行。它必须返回属性类型的值。当分配属性时，`set`访问器运行。它有一个名为`value`的隐式参数，类型为属性的类型，通常将其分配给私有字段（在本例中为`currentPrice`）。'
- en: Although properties are accessed in the same way as fields, they differ in that
    they give the implementer complete control over getting and setting its value.
    This control enables the implementer to choose whatever internal representation
    is needed without exposing the internal details to the user of the property. In
    this example, the `set` method could throw an exception if `value` was outside
    a valid range of values.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然属性的访问方式与字段相同，但它们的不同之处在于，它们使实现者完全控制获取和设置其值。此控制使实现者能够选择所需的任何内部表示方式，而不会向属性的用户公开内部细节。在此示例中，如果`value`超出有效值范围，则`set`方法可能会引发异常。
- en: Note
  id: totrans-166
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Throughout this book, we use public fields extensively to keep the examples
    free of distraction. In a real application, you would typically favor public properties
    over public fields in order to promote encapsulation.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们广泛使用公共字段，以保持示例的干净。在实际应用中，您通常会更倾向于使用公共属性而不是公共字段，以促进封装。
- en: 'Properties allow the following modifiers:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 属性允许以下修饰符：
- en: '| Static modifier | `static` |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 静态修饰符 | `static` |'
- en: '| Access modifiers | `public internal private protected` |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 访问修饰符 | `public internal private protected` |'
- en: '| Inheritance modifiers | `new virtual abstract override sealed` |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 继承修饰符 | `new virtual abstract override sealed` |'
- en: '| Unmanaged code modifiers | `unsafe extern` |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 无管理代码修饰符 | `unsafe extern` |'
- en: Read-only and calculated properties
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 只读和计算属性
- en: A property is read-only if it specifies only a `get` accessor, and it is write-only
    if it specifies only a `set` accessor. Write-only properties are rarely used.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果属性仅指定了`get`访问器，则它是只读的；如果属性仅指定了`set`访问器，则它是只写的。很少使用只写属性。
- en: 'A property typically has a dedicated backing field to store the underlying
    data. However, a property can also be computed from other data:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 属性通常具有专用的后备字段来存储基础数据。但是，属性也可以从其他数据计算得出：
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Expression-bodied properties
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表达式主体属性
- en: 'You can declare a read-only property, such as the one in the preceding example,
    more tersely as an *expression-bodied property*. A fat arrow replaces all the
    braces and the `get` and `return` keywords:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将只读属性（例如前面示例中的属性）更简洁地声明为*表达式主体属性*。一个粗箭头替换了所有大括号、`get`和`return`关键字：
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'With a little extra syntax, `set` accessors can also be expression-bodied:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 加上一些额外的语法，`set`访问器也可以是表达式主体的：
- en: '[PRE46]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Automatic properties
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动属性
- en: 'The most common implementation for a property is a getter and/or setter that
    simply reads and writes to a private field of the same type as the property. An
    *automatic property* declaration instructs the compiler to provide this implementation.
    We can improve the first example in this section by declaring `CurrentPrice` as
    an automatic property:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的最常见实现是仅读取和写入与属性相同类型的私有字段的getter和/或setter。*自动属性*声明指示编译器提供此实现。我们可以通过将`CurrentPrice`声明为自动属性来改进本节中的第一个示例：
- en: '[PRE47]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The compiler automatically generates a private backing field of a compiler-generated
    name that cannot be referred to. The `set` accessor can be marked `private` or
    `protected` if you want to expose the property as read-only to other types. Automatic
    properties were introduced in C# 3.0.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会自动生成一个私有后备字段，其名称为编译器生成的名称，不可引用。如果要将`set`访问器标记为`private`或`protected`，则可以将属性公开为其他类型的只读。自动属性是在
    C# 3.0 中引入的。
- en: Property initializers
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性初始化器
- en: 'You can add a *property initializer* to automatic properties, just as with
    fields:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像字段一样为自动属性添加*属性初始化器*：
- en: '[PRE48]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This gives `CurrentPrice` an initial value of `123`. Properties with an initializer
    can be read-only:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得`CurrentPrice`的初始值为`123`。具有初始化程序的属性可以是只读的：
- en: '[PRE49]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Just as with read-only fields, read-only automatic properties can also be assigned
    in the type’s constructor. This is useful in creating *immutable* (read-only)
    types.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与只读字段一样，只读自动属性也可以在类型的构造函数中分配。这在创建*不可变*（只读）类型时非常有用。
- en: get and set accessibility
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取和设置的可访问性
- en: 'The `get` and `set` accessors can have different access levels. The typical
    use case for this is to have a `public` property with an `internal` or `private`
    access modifier on the setter:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`和`set`访问器可以具有不同的访问级别。此的典型用例是在`setter`上具有`internal`或`private`访问修饰符的`public`属性：'
- en: '[PRE50]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Notice that you declare the property itself with the more permissive access
    level (`public`, in this case) and add the modifier to the accessor you want to
    be *less* accessible.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您声明属性本身的访问级别更宽松（在本例中为`public`），并将修饰符添加到您希望*较不*访问的访问器。
- en: Init-only setters
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅初始化的设置器
- en: 'From C# 9, you can declare a property accessor with `init` instead of `set`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 9 开始，可以使用`init`而不是`set`声明属性访问器：
- en: '[PRE51]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'These *init-only* properties act like read-only properties, except that they
    can also be set via an object initializer:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这些*仅初始化*属性的作用类似于只读属性，但也可以通过对象初始化器进行设置：
- en: '[PRE52]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'After that, the property cannot be altered:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，属性无法更改：
- en: '[PRE53]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Init-only properties cannot even be set from inside their class, except via
    their property initializer, the constructor, or another init-only accessor.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过属性初始化器、构造函数或另一个仅初始化访问器，仅初始化属性甚至不能从其类内部设置。
- en: 'The alternative to init-only properties is to have read-only properties that
    you populate via a constructor:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 仅初始化属性的替代方法是通过构造函数填充的只读属性：
- en: '[PRE54]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Should the class be part of a public library, this approach makes versioning
    difficult, in that adding an optional parameter to the constructor at a later
    date breaks binary compatibility with consumers (whereas adding a new init-only
    property breaks nothing).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类是公共库的一部分，则此方法使得后期在构造函数中添加可选参数时版本控制变得困难，因为这会破坏与消费者的二进制兼容性（而添加新的仅初始化属性则不会破坏任何内容）。
- en: Note
  id: totrans-207
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Init-only properties have another significant advantage, which is that they
    allow for nondestructive mutation when used in conjunction with records (see [“Records”](ch04.html#records-id00087)).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 仅初始化属性还有另一个重要优势，即在与记录结合使用时允许非破坏性变异（参见[“记录”](ch04.html#records-id00087)）。
- en: 'Just as with ordinary `set` accessors, init-only accessors can provide an implementation:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通`set`访问器一样，仅初始化访问器也可以提供一个实现：
- en: '[PRE55]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Notice that the `_pitch` field is read-only: init-only setters are permitted
    to modify `readonly` fields in their own class. (Without this feature, `_pitch`
    would need to be writable, and the class would fail at being internally immutable.)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`_pitch`字段是只读的：仅初始化的设置器允许修改其自身类中的`readonly`字段。（如果没有此功能，`_pitch`将需要可写，并且类将无法内部实现不可变性。）
- en: Warning
  id: totrans-212
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'Changing a property’s accessor from `init` to `set` (or vice versa) is a *binary
    breaking change*: anyone that references your assembly will need to recompile
    their assembly.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 将属性的访问器从`init`更改为`set`（或反之）是*二进制破坏性更改*：任何引用您程序集的人都需要重新编译他们的程序集。
- en: This should not be an issue when creating wholly immutable types, in that your
    type will never require properties with a (writable) `set` accessor.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建完全不可变类型时，这应该不是问题，因为您的类型永远不需要具有（可写）`set`访问器的属性。
- en: CLR property implementation
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CLR 属性实现
- en: 'C# property accessors internally compile to methods called `get_*XXX*` and
    `set_*XXX*`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: C# 属性访问器在内部编译为称为`get_*XXX*`和`set_*XXX*`的方法：
- en: '[PRE56]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: An `init` accessor is processed like a `set` accessor, but with an extra flag
    encoded into the `set` accessor’s “modreq” metadata (see [“Init-only properties”](ch18.html#init_only_properties)).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 访问器处理类似于 `set` 访问器，但是在 `set` 访问器的“modreq”元数据中编码了一个额外的标志（请参阅 [“仅初始化属性”](ch18.html#init_only_properties)）。'
- en: Simple nonvirtual property accessors are *inlined* by the Just-In-Time (JIT)
    compiler, eliminating any performance difference between accessing a property
    and a field. Inlining is an optimization in which a method call is replaced with
    the body of that method.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Just-In-Time (JIT) 编译器通过内联简单的非虚拟属性访问器，消除了访问属性和字段之间的任何性能差异。内联是一种优化技术，其中方法调用被该方法的主体替换。
- en: Indexers
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引器
- en: 'Indexers provide a natural syntax for accessing elements in a class or struct
    that encapsulate a list or dictionary of values. Indexers are similar to properties
    but are accessed via an index argument rather than a property name. The `string`
    class has an indexer that lets you access each of its `char` values via an `int`
    index:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Indexers 提供了一种自然的语法，用于访问封装了值列表或字典的类或结构体中的元素。Indexers 类似于属性，但通过索引参数访问，而不是属性名。`string`
    类具有一个索引器，允许您通过 `int` 索引访问其每个 `char` 值：
- en: '[PRE57]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The syntax for using indexers is like that for using arrays, except that the
    index argument(s) can be of any type(s).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用索引器的语法类似于使用数组，不同之处在于索引参数可以是任何类型。
- en: 'Indexers have the same modifiers as properties (see [“Properties”](#properties))
    and can be called null-conditionally by inserting a question mark before the square
    bracket (see [“Null Operators”](ch02.html#null_operators)):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 索引器具有与属性相同的修饰符（请参阅 [“属性”](#properties)）并且可以通过在方括号前插入问号来在空安全方式下调用（请参阅 [“Null
    操作符”](ch02.html#null_operators)）：
- en: '[PRE58]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Implementing an indexer
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现一个索引器
- en: 'To write an indexer, define a property called `this`, specifying the arguments
    in square brackets:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写一个索引器，定义一个名为 `this` 的属性，指定方括号中的参数：
- en: '[PRE59]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Here’s how we could use this indexer:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们如何使用这个索引器的方法：
- en: '[PRE60]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'A type can declare multiple indexers, each with parameters of different types.
    An indexer can also take more than one parameter:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 类型可以声明多个索引器，每个索引器具有不同类型的参数。索引器还可以接受多个参数：
- en: '[PRE61]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If you omit the `set` accessor, an indexer becomes read-only, and you can use
    expression-bodied syntax to shorten its definition:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略 `set` 访问器，则索引器变为只读，并且可以使用表达式主体语法来缩短其定义：
- en: '[PRE62]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: CLR indexer implementation
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CLR 索引器实现
- en: 'Indexers internally compile to methods called `get_Item` and `set_Item`, as
    follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 索引器在内部编译为名为 `get_Item` 和 `set_Item` 的方法，如下所示：
- en: '[PRE63]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Using indices and ranges with indexers
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用索引和范围与索引器
- en: 'You can support indices and ranges (see [“Indices and Ranges”](ch02.html#indices_and_ranges-id00073))
    in your own classes by defining an indexer with a parameter type of `Index` or
    `Range`. We could extend our previous example, by adding the following indexers
    to the `Sentence` class:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过定义一个具有 `Index` 或 `Range` 参数类型的索引器来在自己的类中支持索引和范围（请参阅 [“索引和范围”](ch02.html#indices_and_ranges-id00073)）。我们可以通过向
    `Sentence` 类添加以下索引器来扩展我们之前的示例：
- en: '[PRE64]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This then enables the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以启用以下功能：
- en: '[PRE65]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Primary Constructors (C# 12)
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主构造函数 (C# 12)
- en: 'From C# 12, you can include a parameter list directly after a class (or struct)
    declaration:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 12 开始，您可以在类（或结构体）声明之后直接包含一个参数列表：
- en: '[PRE66]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This instructs the compiler to automatically build a *primary constructor*
    using the *primary constructor parameters* (`firstName` and `lastName`), so that
    we can instantiate our class as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这指示编译器使用 *主构造函数参数*（`firstName` 和 `lastName`）自动构建一个 *主构造函数*，以便我们可以按以下方式实例化我们的类：
- en: '[PRE67]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Primary constructors are useful for prototyping and other simple scenarios.
    The alternative would be to define fields and write a constructor explicitly:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 主构造函数对于原型设计和其他简单场景非常有用。另一种选择是定义字段并显式编写构造函数：
- en: '[PRE68]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The constructor that C# builds is called primary because any additional constructors
    that you choose to (explicitly) write must invoke it:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: C# 构建的构造函数被称为主构造函数，因为您选择（显式）编写的任何其他构造函数必须调用它：
- en: '[PRE69]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This ensures that primary constructor parameters are *always populated*.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保主构造函数参数始终被 *始终填充*。
- en: Note
  id: totrans-253
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: C# also provides *records*, which we cover in [“Records”](ch04.html#records-id00087).
    Records also support primary constructors; however, the compiler takes an extra
    step with records and generates (by default) a public init-only property for each
    primary constructor parameter. Should this behavior be desirable, consider using
    records instead.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: C# 还提供了 *records*，我们在 [“Records”](ch04.html#records-id00087) 中介绍。记录也支持主构造函数；然而，编译器对记录采取额外步骤，并生成（默认情况下）每个主构造函数参数的公共
    init-only 属性。如果需要此行为，请考虑改用记录。
- en: 'Primary constructors are best suited to simple scenarios due to the following
    limitations:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 主构造函数最适合简单场景，因为以下限制：
- en: You cannot add extra initialization code to a primary constructor.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能向主构造函数添加额外的初始化代码。
- en: Although it’s easy to expose a primary constructor parameter as a public property,
    you cannot easily incorporate validation logic unless the property is read-only.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然很容易将主构造函数参数公开为公共属性，但除非属性是只读的，否则你无法轻松地集成验证逻辑。
- en: Primary constructors displace the default parameterless constructor that C#
    would otherwise generate.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 主构造函数替换了 C# 否则会生成的默认无参数构造函数。
- en: Primary constructor semantics
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主构造函数语义
- en: 'To understand how primary constructors work, consider how an ordinary constructor
    behaves:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解主构造函数的工作原理，请考虑普通构造函数的行为：
- en: '[PRE70]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: When the code inside this constructor finishes executing, parameters `firstName`
    and `lastName` disappear out of scope and cannot be subsequently accessed. In
    contrast, a primary constructor’s parameters do *not* disappear out of scope and
    can be subsequently accessed from anywhere within the class, for the life of the
    object.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当此构造函数内的代码执行完毕时，参数`firstName`和`lastName`将超出作用域，并且不能随后访问。相反，主构造函数的参数不会超出作用域，并且可以在类内的任何地方访问对象的生命周期内。
- en: Note
  id: totrans-263
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Primary constructor parameters are special C# constructs, not *fields*, although
    the compiler does end up generating hidden fields behind the scenes to store their
    values if necessary.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 主构造函数参数是特殊的 C# 结构，不是字段，尽管编译器在幕后确实会生成隐藏字段来存储它们的值（如果需要的话）。
- en: Primary constructors and field/property initializers
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主构造函数和字段/属性初始化器
- en: 'The accessibility of primary constructor parameters extends to field and property
    initializers. In the following example, we use field and property initializers
    to assign `firstName` to a public field, and `lastName` to a public property:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 主构造函数参数的可访问性延伸到字段和属性初始化器。在以下示例中，我们使用字段和属性初始化器将`firstName`分配给公共字段，并将`lastName`分配给公共属性：
- en: '[PRE71]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Masking primary constructor parameters
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 掩盖主构造函数参数
- en: 'Fields (or properties) can reuse primary constructor parameter names:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 字段（或属性）可以重用主构造函数参数名称：
- en: '[PRE72]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In this scenario, the field or property takes precedence, thereby masking the
    primary constructor parameter, *except* on the righthand side of field and property
    initializers (shown in boldface).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在此场景中，字段或属性优先，从而掩盖主构造函数参数，*除非*在字段和属性初始化器的右侧（以粗体显示）。
- en: Note
  id: totrans-272
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Just like ordinary parameters, primary constructor parameters are writable.
    Masking them with a same-named `readonly` field (as in our example) effectively
    protects them from subsequent modification.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 就像普通参数一样，主构造函数参数是可写的。使用同名的`readonly`字段（如我们的示例中所示），有效地保护它们免受后续修改。
- en: Validating primary constructor parameters
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证主构造函数参数
- en: 'Sometimes it’s useful to perform computation in field initializers:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在字段初始化器中执行计算是有用的：
- en: '[PRE73]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In the next example, we save an uppercase version of `lastName` to a field
    of the same name (masking the original value):'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将`lastName`的大写版本保存到同名字段中（掩盖原始值）：
- en: '[PRE74]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In [“throw expressions”](ch04.html#throw_expressions-id00096), we describe
    how to throw exceptions when encountering scenarios such as invalid data. Here’s
    a preview to illustrate how this can be used with primary constructors to validate
    `lastName` upon construction, ensuring that it cannot be null:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [“throw expressions”](ch04.html#throw_expressions-id00096) 中，我们描述了在遇到无效数据等情况时如何抛出异常。以下是一个预览，演示如何使用主构造函数验证`lastName`在构造时不为
    null：
- en: '[PRE75]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '(Remember that code within a field or property initializer executes when the
    object is constructed—not when the field or property is accessed.) In the next
    example, we expose a primary constructor parameter as a read/write property:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: （请记住，在对象构造时执行字段或属性初始化器中的代码，而不是在访问字段或属性时执行。）在下一个示例中，我们将主构造函数参数公开为读/写属性：
- en: '[PRE76]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Adding validation to this example is not straightforward in that you must validate
    in two places: in a (manually implemented) property `set` accessor and in the
    property initializer. (The same problem exists if the property is defined as init-only.)
    At this point, it’s easier to abandon the shortcut of primary constructors and
    define a constructor and backing fields explicitly.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中添加验证并不简单，因为你必须在两个地方验证：在（手动实现的）属性 `set` 访问器中和属性初始化器中。 （如果属性定义为仅初始化，则存在相同的问题。）在这一点上，放弃主要构造函数的捷径并显式定义构造函数和后备字段更容易。
- en: Static Constructors
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态构造函数
- en: 'A static constructor executes once per *type* rather than once per *instance*.
    A type can define only one static constructor, and it must be parameterless and
    have the same name as the type:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 静态构造函数每个*类型*只执行一次，而不是每个*实例*。类型只能定义一个静态构造函数，它必须是无参数的，并且与类型同名：
- en: '[PRE77]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The runtime automatically invokes a static constructor just prior to the type
    being used. Two things trigger this:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时会在类型被使用之前自动调用静态构造函数。两件事会触发这一点：
- en: Instantiating the type
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化类型
- en: Accessing a static member in the type
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问类型中的静态成员
- en: The only modifiers allowed by static constructors are `unsafe` and `extern`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 静态构造函数允许的唯一修饰符是 `unsafe` 和 `extern`。
- en: Warning
  id: totrans-291
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: If a static constructor throws an unhandled exception ([Chapter 4](ch04.html#advanced_chash)),
    that type becomes *unusable* for the life of the application.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果静态构造函数抛出未处理的异常（[第 4 章](ch04.html#advanced_chash)），该类型将在应用程序的整个生命周期中变得*不可用*。
- en: Note
  id: totrans-293
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'From C# 9, you can also define *module initializers*, which execute once per
    assembly (when the assembly is first loaded). To define a module initializer,
    write a static void method and then apply the `[ModuleInitializer]` attribute
    to that method:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 9 开始，您还可以定义*模块初始化器*，这些初始化器在程序集每次加载时执行一次。要定义模块初始化器，请编写一个静态 `void` 方法，然后将
    `[ModuleInitializer]` 属性应用于该方法：
- en: '[PRE78]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Static constructors and field initialization order
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态构造函数和字段初始化顺序
- en: Static field initializers run just *before* the static constructor is called.
    If a type has no static constructor, static field initializers will execute just
    prior to the type being used—or *anytime earlier* at the whim of the runtime.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 静态字段初始化器在调用静态构造函数之前运行。如果类型没有静态构造函数，则静态字段初始化器将在类型被使用之前执行——或者在运行时任意更早的时间执行。
- en: 'Static field initializers run in the order in which the fields are declared.
    The following example illustrates this. `X` is initialized to `0`, and `Y` is
    initialized to `3`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 静态字段初始化器按照字段声明的顺序运行。以下示例说明了这一点。`X` 被初始化为 `0`，而 `Y` 被初始化为 `3`：
- en: '[PRE79]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'If we swap the two field initializers around, both fields are initialized to
    3\. The next example prints 0 followed by 3 because the field initializer that
    instantiates a `Foo` executes before `X` is initialized to `3`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调换两个字段初始化器的顺序，两个字段都将初始化为 3。下一个示例将打印出 0，然后是 3，因为在将 `X` 初始化为 `3` 之前实例化 `Foo`
    的字段初始化器先执行：
- en: '[PRE80]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: If we swap the two lines in boldface, the example prints 3 followed by 3.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们交换粗体部分的两行，则示例将打印出 3 后面跟着 3。
- en: Static Classes
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态类
- en: A class marked `static` cannot be instantiated or subclassed, and must be composed
    solely of static members. The `System.Console` and `System.Math` classes are good
    examples of static classes.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为`static`的类不能实例化或派生，并且必须仅由静态成员组成。 `System.Console` 和 `System.Math` 类是静态类的良好示例。
- en: Finalizers
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终结器
- en: 'Finalizers are class-only methods that execute before the garbage collector
    reclaims the memory for an unreferenced object. The syntax for a finalizer is
    the name of the class prefixed with the `~` symbol:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 终结器是仅限于类的方法，在垃圾收集器回收未引用对象的内存之前执行。终结器的语法是类名前缀为 `~` 符号：
- en: '[PRE81]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This is actually C# syntax for overriding `Object`’s `Finalize` method, and
    the compiler expands it into the following method declaration:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是 C# 中覆盖 `Object` 的 `Finalize` 方法的语法，编译器将其扩展为以下方法声明：
- en: '[PRE82]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: We discuss garbage collection and finalizers fully in [Chapter 12](ch12.html#disposal_and_garbage_collection).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第 12 章](ch12.html#disposal_and_garbage_collection)中全面讨论了垃圾收集和终结器。
- en: 'You can write single-statement finalizers using expression-bodied syntax:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用表达式体语法编写单语句终结器：
- en: '[PRE83]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Partial Types and Methods
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分类型和方法
- en: 'Partial types allow a type definition to be split—typically across multiple
    files. A common scenario is for a partial class to be autogenerated from some
    other source (such as a Visual Studio template or designer), and for that class
    to be augmented with additional hand-authored methods:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 部分类型允许将类型定义分割-通常跨多个文件。常见的情况是从其他来源（如Visual Studio模板或设计者）自动生成部分类，并且该类用额外的手动编写的方法增强：
- en: '[PRE84]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Each participant must have the `partial` declaration; the following is illegal:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 每个参与者必须有`partial`声明；以下内容是非法的：
- en: '[PRE85]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Participants cannot have conflicting members. A constructor with the same parameters,
    for instance, cannot be repeated. Partial types are resolved entirely by the compiler,
    which means that each participant must be available at compile time and must reside
    in the same assembly.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 参与者不能有冲突的成员。例如，具有相同参数的构造函数不能重复。部分类型完全由编译器解析，这意味着每个参与者在编译时必须可用，并且必须驻留在同一个程序集中。
- en: You can specify a base class on one or more partial class declarations, as long
    as the base class, if specified, is the same. In addition, each participant can
    independently specify interfaces to implement. We cover base classes and interfaces
    in [“Inheritance”](#inheritance) and [“Interfaces”](#interfaces).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在一个或多个部分类声明上指定一个基类，只要基类（如果指定）相同即可。此外，每个参与者可以独立指定要实现的接口。我们在[“继承”](#inheritance)和[“接口”](#interfaces)中介绍基类和接口。
- en: The compiler makes no guarantees with regard to field initialization order between
    partial type declarations.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器不保证部分类型声明之间的字段初始化顺序。
- en: Partial methods
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部分方法
- en: 'A partial type can contain *partial methods*. These let an autogenerated partial
    type provide customizable hooks for manual authoring; for example:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 部分类型可以包含*部分方法*。这些方法允许自动生成的部分类型为手动编写提供可定制的钩子；例如：
- en: '[PRE86]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'A partial method consists of two parts: a *definition* and an *implementation*.
    The definition is typically written by a code generator, and the implementation
    is typically manually authored. If an implementation is not provided, the definition
    of the partial method is compiled away (as is the code that calls it). This allows
    autogenerated code to be liberal in providing hooks without having to worry about
    bloat. Partial methods must be `void` and are implicitly `private`. They cannot
    include `out` parameters.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 部分方法由两部分组成：*定义*和*实现*。定义通常由代码生成器编写，实现通常由手动编写。如果未提供实现，则部分方法的定义将被编译器删除（调用它的代码也会被删除）。这使得自动生成的代码可以自由地提供钩子，而不必担心膨胀。部分方法必须是`void`，并且隐式为`private`。它们不能包含`out`参数。
- en: Extended partial methods
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展的部分方法
- en: '*Extended partial methods* (from C# 9) are designed for the reverse code generation
    scenario, where a programmer defines hooks that a code generator implements. An
    example of where this might occur is with *source generators*, a Roslyn feature
    that lets you feed the compiler an assembly that automatically generates portions
    of your code.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '*扩展的部分方法*（来自C# 9）旨在用于反向代码生成场景，其中程序员定义代码生成器实现的钩子。这种情况的示例是*源生成器*，这是Roslyn的一个功能，允许您向编译器提供一个自动生成代码部分的程序集。'
- en: 'A partial method declaration is *extended* if it begins with an accessibility
    modifier:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果部分方法声明以访问修饰符开头，则称为*扩展*部分方法。
- en: '[PRE87]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The presence of the accessibility modifier doesn’t just affect accessibility:
    it tells the compiler to treat the declaration differently.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 访问修饰符的存在不仅影响可访问性：它告诉编译器以不同的方式处理声明。
- en: Extended partial methods *must* have implementations; they do not melt away
    if unimplemented. In this example, both `M1` and `M2` must have implementations
    because they each specify accessibility modifiers (`public` and `private`).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展的部分方法*必须*有实现；如果未实现，它们不会消失。在这个例子中，`M1`和`M2`必须都有实现，因为它们各自指定了访问修饰符（`public`和`private`）。
- en: 'Because they cannot melt away, extended partial methods can return any type
    and can include `out` parameters:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们不会消失，扩展的部分方法可以返回任何类型，并且可以包含`out`参数：
- en: '[PRE88]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The nameof operator
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: nameof运算符
- en: 'The `nameof` operator returns the name of any symbol (type, member, variable,
    and so on) as a string:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`nameof`运算符返回任何符号（类型、成员、变量等）的名称作为字符串：'
- en: '[PRE89]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Its advantage over simply specifying a string is that of static type checking.
    Tools such as Visual Studio can understand the symbol reference, so if you rename
    the symbol in question, all of its references will be renamed, too.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 与仅指定字符串相比，它的优势在于静态类型检查。像Visual Studio这样的工具可以理解符号引用，因此如果您重命名该符号，所有引用也将被重命名。
- en: 'To specify the name of a type member such as a field or property, include the
    type as well. This works with both static and instance members:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定类型成员（如字段或属性）的名称，请同时包含类型。这适用于静态和实例成员：
- en: '[PRE90]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'This evaluates to `Length`. To return `StringBuilder.Length`, you would do
    this:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这个求值结果是`Length`。要返回`StringBuilder.Length`，你可以这样做：
- en: '[PRE91]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Inheritance
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: 'A class can *inherit* from another class to extend or customize the original
    class. Inheriting from a class lets you reuse the functionality in that class
    instead of building it from scratch. A class can inherit from only a single class
    but can itself be inherited by many classes, thus forming a class hierarchy. In
    this example, we begin by defining a class called `Asset`:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以从另一个类*继承*，以扩展或定制原始类。从类继承可以重用该类中的功能，而不是从头开始构建。一个类只能从一个类继承，但可以被多个类继承，从而形成一个类层次结构。在这个例子中，我们首先定义了一个名为`Asset`的类：
- en: '[PRE92]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Next, we define classes called `Stock` and `House`, which will inherit from
    `Asset`. `Stock` and `House` get everything an `Asset` has, plus any additional
    members that they define:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了名为`Stock`和`House`的类，它们将从`Asset`继承。`Stock`和`House`获得`Asset`拥有的一切，以及它们自己定义的任何额外成员：
- en: '[PRE93]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Here’s how we can use these classes:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用这些类的示例：
- en: '[PRE94]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The *derived classes*, `Stock` and `House`, inherit the `Name` field from the
    *base class*, `Asset`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '*派生类*`Stock`和`House`从*基类*`Asset`继承了`Name`字段。'
- en: Note
  id: totrans-349
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A derived class is also called a *subclass*.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 派生类也称为*子类*。
- en: A base class is also called a *superclass*.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 基类也称为*超类*。
- en: Polymorphism
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态性
- en: 'References are *polymorphic*. This means a variable of type *x* can refer to
    an object that subclasses *x*. For instance, consider the following method:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 引用是*多态*的。这意味着类型为*x*的变量可以引用一个子类*x*的对象。例如，考虑以下方法：
- en: '[PRE95]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'This method can display both a `Stock` and a `House` because they are both
    `Asset`s:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法可以显示`Stock`和`House`，因为它们都是`Asset`：
- en: '[PRE96]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Polymorphism works on the basis that subclasses (`Stock` and `House`) have
    all the features of their base class (`Asset`). The converse, however, is not
    true. If `Display` was modified to accept a `House`, you could not pass in an
    `Asset`:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性基于子类（`Stock`和`House`）拥有其基类（`Asset`）的所有特征。反之则不然。如果修改`Display`以接受`House`，则无法传递`Asset`：
- en: '[PRE97]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Casting and Reference Conversions
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用类型转换和引用转换
- en: 'An object reference can be:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 对象引用可以是：
- en: Implicitly *upcast* to a base class reference
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式地向上转型到基类引用
- en: Explicitly *downcast* to a subclass reference
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式地向下转型到子类引用
- en: 'Upcasting and downcasting between compatible reference types performs *reference
    conversions*: a new reference is (logically) created that points to the *same*
    object. An upcast always succeeds; a downcast succeeds only if the object is suitably
    typed.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在兼容的引用类型之间进行向上转型和向下转型执行*引用转换*：一个新的引用（逻辑上）被创建，指向*同一个*对象。向上转型总是成功的；向下转型仅在对象适当类型化时成功。
- en: Upcasting
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向上转型
- en: 'An upcast operation creates a base class reference from a subclass reference:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 向上转型操作会从子类引用创建一个基类引用：
- en: '[PRE98]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'After the upcast, variable `a` still references the same `Stock` object as
    variable `msft`. The object being referenced is not itself altered or converted:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在向上转型后，变量`a`仍然引用与变量`msft`相同的`Stock`对象。被引用的对象本身不会被改变或转换：
- en: '[PRE99]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Although `a` and `msft` refer to the identical object, `a` has a more restrictive
    view on that object:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`a`和`msft`引用相同的对象，但`a`对该对象有更严格的视图：
- en: '[PRE100]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The last line generates a compile-time error because the variable `a` is of
    type `Asset`, even though it refers to an object of type `Stock`. To get to its
    `SharesOwned` field, you must *downcast* the `Asset` to a `Stock`.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行生成了编译时错误，因为变量`a`的类型是`Asset`，即使它引用了类型为`Stock`的对象。要访问其`SharesOwned`字段，必须将`Asset`向下转型为`Stock`。
- en: Downcasting
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向下转型
- en: 'A downcast operation creates a subclass reference from a base class reference:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 向下转型操作会从基类引用创建一个子类引用：
- en: '[PRE101]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'As with an upcast, only references are affected—not the underlying object.
    A downcast requires an explicit cast because it can potentially fail at runtime:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 与向上转型一样，只影响引用，而不是底层对象。向下转型需要显式转换，因为它在运行时可能失败：
- en: '[PRE102]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: If a downcast fails, an `InvalidCastException` is thrown. This is an example
    of *runtime type checking* (we elaborate on this concept in [“Static and Runtime
    Type Checking”](#static_and_runtime_type_checking)).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果向下转换失败，将抛出`InvalidCastException`。这是*运行时类型检查*的一个例子（我们在[“静态和运行时类型检查”](#static_and_runtime_type_checking)中详细阐述此概念）。
- en: The as operator
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: as运算符
- en: 'The `as` operator performs a downcast that evaluates to `null` (rather than
    throwing an exception) if the downcast fails:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`as`运算符执行一个向下转换，如果转换失败则返回`null`（而不是抛出异常）：'
- en: '[PRE103]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'This is useful when you’re going to subsequently test whether the result is
    `null`:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 当你随后要测试结果是否为`null`时，这非常有用：
- en: '[PRE104]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Note
  id: totrans-383
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Without such a test, a cast is advantageous, because if it fails, a more helpful
    exception is thrown. We can illustrate by comparing the following two lines of
    code:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这样的测试，强制转换更有优势，因为如果失败，会抛出一个更有帮助的异常。我们可以通过比较以下两行代码来说明：
- en: '[PRE105]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: If `a` is not a `Stock`, the first line throws an `InvalidCastException`, which
    is an accurate description of what went wrong. The second line throws a `NullReferenceException`,
    which is ambiguous. Was `a` not a `Stock`, or was `a` null?
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`a`不是`Stock`，第一行将抛出`InvalidCastException`，这准确描述了出错的原因。第二行抛出`NullReferenceException`，这是含糊不清的。`a`不是`Stock`，还是`a`是空的？
- en: 'Another way of looking at it is that with the cast operator, you’re saying
    to the compiler: “I’m *certain* of a value’s type; if I’m wrong, there’s a bug
    in my code, so throw an exception!” Whereas with the `as` operator, you’re uncertain
    of its type and want to branch according to the outcome at runtime.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待它的方式是，使用转换运算符时，你在告诉编译器：“我*确定*这个值的类型；如果我错了，那么我的代码有bug，所以抛出异常！”而使用`as`运算符时，你不确定它的类型，并希望根据运行时的结果进行分支。
- en: 'The `as` operator cannot perform *custom conversions* (see [“Operator Overloading”](ch04.html#operator_overloading)),
    and it cannot do numeric conversions:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`as`运算符无法执行*自定义转换*（参见[“运算符重载”](ch04.html#operator_overloading)），也不能执行数值转换：'
- en: '[PRE106]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Note
  id: totrans-390
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `as` and cast operators will also perform upcasts, although this is not
    terribly useful because an implicit conversion will do the job.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`as`和转换运算符也会执行向上转换，尽管这并不是非常有用，因为隐式转换可以完成工作。'
- en: The is operator
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: is运算符
- en: The `is` operator tests whether a variable matches a *pattern*. C# supports
    several kinds of patterns, the most important being a *type pattern*, where a
    type name follows the `is` keyword.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`is`运算符测试变量是否匹配*模式*。C#支持多种模式，最重要的是*类型模式*，其中类型名跟在`is`关键字后面。'
- en: 'In this context, the `is` operator tests whether a reference conversion would
    succeed—in other words, whether an object derives from a specified class (or implements
    an interface). It is often used to test before downcasting:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，`is`运算符测试引用转换是否会成功——换句话说，对象是否从指定的类（或实现接口）派生。通常用于在进行向下转换之前进行测试：
- en: '[PRE107]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The `is` operator also evaluates to true if an *unboxing conversion* would succeed
    (see [“The object Type”](#the_object_type)). However, it does not consider custom
    or numeric conversions.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`is`运算符还在*拆箱转换*成功时返回true（参见[“对象类型”](#the_object_type)）。但它不考虑自定义或数值转换。'
- en: Note
  id: totrans-397
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `is` operator works with many other patterns introduced in recent versions
    of C#. For a full discussion, see [“Patterns”](ch04.html#patterns).
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`is`运算符与C#最近版本引入的许多其他模式一起使用。有关详细讨论，请参见[“模式”](ch04.html#patterns)。'
- en: Introducing a pattern variable
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引入模式变量
- en: 'You can introduce a variable while using the `is` operator:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`is`运算符时，可以引入一个变量：
- en: '[PRE108]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'This is equivalent to the following:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这等效于以下内容：
- en: '[PRE109]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The variable that you introduce is available for “immediate” consumption, so
    the following is legal:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 引入的变量可以“立即”使用，因此以下是合法的：
- en: '[PRE110]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'And it remains in scope outside the `is` expression, allowing this:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 并且它在`is`表达式之外仍然处于作用域中，允许这样：
- en: '[PRE111]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Virtual Function Members
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚函数成员
- en: 'A function marked as `virtual` can be *overridden* by subclasses wanting to
    provide a specialized implementation. Methods, properties, indexers, and events
    can all be declared `virtual`:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为`virtual`的函数可以被子类重写，以提供专门的实现。方法、属性、索引器和事件都可以声明为`virtual`：
- en: '[PRE112]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: (`Liability => 0` is a shortcut for `{ get { return 0; } }`. For more details
    on this syntax, see [“Expression-bodied properties”](#expression_bodied_properties).)
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: （`Liability => 0`是`{ get { return 0; } }`的一种快捷方式。有关此语法的详细信息，请参见[“表达式体属性”](#expression_bodied_properties)。）
- en: 'A subclass overrides a virtual method by applying the `override` modifier:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 子类通过应用`override`修饰符来覆盖虚方法：
- en: '[PRE113]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'By default, the `Liability` of an `Asset` is `0`. A `Stock` does not need to
    specialize this behavior. However, the `House` specializes the `Liability` property
    to return the value of the `Mortgage`:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`Asset`的`Liability`为`0`。`Stock`不需要专门化此行为。然而，`House`专门化`Liability`属性以返回`Mortgage`的值：
- en: '[PRE114]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The signatures, return types, and accessibility of the virtual and overridden
    methods must be identical. An overridden method can call its base class implementation
    via the `base` keyword (we cover this in [“The base Keyword”](#the_base_keyword)).
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 虚方法和重写方法的签名、返回类型和可访问性必须相同。重写方法可以通过`base`关键字调用其基类实现（我们在[“基类关键字”](#the_base_keyword)中讨论此问题）。
- en: Warning
  id: totrans-417
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Calling virtual methods from a constructor is potentially dangerous because
    authors of subclasses are unlikely to know, when overriding the method, that they
    are working with a partially initialized object. In other words, the overriding
    method might end up accessing methods or properties that rely on fields not yet
    initialized by the constructor.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 从构造函数调用虚方法可能是危险的，因为子类的作者在覆盖方法时可能不知道它们正在处理的是部分初始化的对象。换句话说，覆盖方法可能会访问尚未由构造函数初始化的字段的方法或属性。
- en: Covariant return types
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协变返回类型
- en: 'From C# 9, you can override a method (or property `get` accessor) such that
    it returns a *more derived* (subclassed) type. For example:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 9开始，您可以覆盖一个方法（或属性的`get`访问器），使其返回一个*更具体*（子类化）的类型。例如：
- en: '[PRE115]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'This is permitted because it does not break the contract that `Clone` must
    return an `Asset`: it returns a `House`, which *is* an `Asset` (and more).'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这是允许的，因为它不违反`Clone`必须返回`Asset`的约定：它返回一个`House`，*是*一个`Asset`（更多）。
- en: 'Prior to C# 9, you had to override methods with the identical return type:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 9之前，您必须重写具有相同返回类型的方法：
- en: '[PRE116]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'This still does the job, because the overridden `Clone` method instantiates
    a `House` rather than an `Asset`. However, to treat the returned object as a `House`,
    you must then perform a downcast:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这依然有效，因为重写的`Clone`方法实例化了一个`House`而不是`Asset`。然而，要将返回的对象视为`House`，您必须执行向下转换：
- en: '[PRE117]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Abstract Classes and Abstract Members
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象类和抽象成员
- en: A class declared as *abstract* can never be instantiated. Instead, only its
    concrete *subclasses* can be instantiated.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 声明为*抽象*的类永远不能被实例化。相反，只能实例化它的具体*子类*。
- en: 'Abstract classes are able to define *abstract members*. Abstract members are
    like virtual members except that they don’t provide a default implementation.
    That implementation must be provided by the subclass unless that subclass is also
    declared abstract:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类能够定义*抽象成员*。抽象成员类似于虚成员，但它们不提供默认实现。除非该子类也声明为抽象，否则该实现必须由子类提供：
- en: '[PRE118]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Hiding Inherited Members
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏继承成员
- en: 'A base class and a subclass can define identical members. For example:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 基类和子类可以定义相同的成员。例如：
- en: '[PRE119]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The `Counter` field in class `B` is said to *hide* the `Counter` field in class
    `A`. Usually, this happens by accident, when a member is added to the base type
    *after* an identical member was added to the subtype. For this reason, the compiler
    generates a warning and then resolves the ambiguity as follows:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 类`B`中的`Counter`字段被称为*隐藏*类`A`中的`Counter`字段。通常情况下，当一个成员被添加到基类型之后，意外地在子类型中添加了相同的成员时，就会发生这种情况。因此，编译器会生成警告，然后按以下方式解决歧义：
- en: References to `A` (at compile time) bind to `A.Counter`.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`A`的引用（在编译时）绑定到`A.Counter`。
- en: References to `B` (at compile time) bind to `B.Counter`.
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`B`的引用（在编译时）绑定到`B.Counter`。
- en: 'Occasionally, you want to hide a member deliberately, in which case you can
    apply the `new` modifier to the member in the subclass. The `new` modifier *does
    nothing more than suppress the compiler warning that would otherwise result*:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，您希望有意隐藏一个成员，在这种情况下，您可以在子类中对成员应用`new`修饰符。`new`修饰符*仅仅是为了抑制编译器警告*：
- en: '[PRE120]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: The `new` modifier communicates your intent to the compiler—and other programmers—that
    the duplicate member is not an accident.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`修饰符向编译器和其他程序员传达了您的意图，即重复成员不是偶然。'
- en: Note
  id: totrans-440
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: C# overloads the `new` keyword to have independent meanings in different contexts.
    Specifically, the `new` *operator* is different from the `new` *member modifier*.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: C#在不同上下文中重载`new`关键字以获得独立的含义。具体来说，`new` *运算符*与`new` *成员修饰符*是不同的。
- en: new versus override
  id: totrans-442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: new与override
- en: 'Consider the following class hierarchy:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下类层次结构：
- en: '[PRE121]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The differences in behavior between `Overrider` and `Hider` are demonstrated
    in the following code:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '`Overrider`和`Hider`之间的行为差异在以下代码中有所体现：'
- en: '[PRE122]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Sealing Functions and Classes
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封闭函数和类
- en: 'An overridden function member can *seal* its implementation with the `sealed`
    keyword to prevent it from being overridden by further subclasses. In our earlier
    virtual function member example, we could have sealed `House`’s implementation
    of `Liability`, preventing a class that derives from `House` from overriding `Liability`,
    as follows:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 重写的函数成员可以使用`sealed`关键字封闭其实现，防止进一步的子类重写它。在我们早期的虚函数成员示例中，我们可以封闭`House`对`Liability`的实现，防止从`House`派生的类重写`Liability`，如下所示：
- en: '[PRE123]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: You can also apply the `sealed` modifier to the class itself, to prevent subclassing.
    Sealing a class is more common than sealing a function member.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将`sealed`修饰符应用于类本身，以防止其被子类化。封闭类比封闭函数成员更常见。
- en: Although you can seal a function member against overriding, you can’t seal a
    member against being *hidden*.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您可以防止重写函数成员，但不能防止成员被*隐藏*。
- en: The base Keyword
  id: totrans-452
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`base`关键字'
- en: 'The `base` keyword is similar to the `this` keyword. It serves two essential
    purposes:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '`base`关键字类似于`this`关键字。它有两个基本用途：'
- en: Accessing an overridden function member from the subclass
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从子类访问重写的函数成员
- en: Calling a base-class constructor (see the next section)
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用基类构造函数（请参见下一节）
- en: 'In this example, `House` uses the `base` keyword to access `Asset`’s implementation
    of `Liability`:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`House`使用`base`关键字访问`Asset`的`Liability`实现：
- en: '[PRE124]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: With the `base` keyword, we access `Asset`’s `Liability` property *nonvirtually*.
    This means that we will always access `Asset`’s version of this property—regardless
    of the instance’s actual runtime type.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`base`关键字，我们可以*非虚拟地*访问`Asset`类的`Liability`属性。这意味着我们总是访问`Asset`类的这个属性版本，而不管实例的实际运行时类型如何。
- en: The same approach works if `Liability` is *hidden* rather than *overridden*.
    (You can also access hidden members by casting to the base class before invoking
    the function.)
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Liability`被*隐藏*而不是*重写*，同样的方法也适用。（您还可以通过在调用函数之前将类型转换为基类来访问隐藏成员。）
- en: Constructors and Inheritance
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数与继承
- en: 'A subclass must declare its own constructors. The base class’s constructors
    are *accessible* to the derived class but are never automatically *inherited*.
    For example, if we define `Baseclass` and `Subclass` as follows:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 子类必须声明自己的构造函数。基类的构造函数对派生类是*可访问*的，但从不会自动*继承*。例如，如果我们定义`Baseclass`和`Subclass`如下：
- en: '[PRE125]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'the following is illegal:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的做法是非法的：
- en: '[PRE126]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '`Subclass` must hence “redefine” any constructors it wants to expose. In doing
    so, however, it can call any of the base class’s constructors via the `base` keyword:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Subclass`必须“重新定义”想要公开的任何构造函数。不过，在这样做时，它可以通过`base`关键字调用任何基类的构造函数：
- en: '[PRE127]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The `base` keyword works rather like the `this` keyword except that it calls
    a constructor in the base class.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '`base`关键字的工作方式类似于`this`关键字，不同之处在于它调用基类中的构造函数。'
- en: Base-class constructors always execute first; this ensures that *base* initialization
    occurs before *specialized* initialization.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 基类构造函数始终先执行；这确保了*基本*初始化发生在*专业化*初始化之前。
- en: Implicit calling of the parameterless base-class constructor
  id: totrans-469
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐式调用无参数基类构造函数
- en: 'If a constructor in a subclass omits the `base` keyword, the base type’s *parameterless*
    constructor is implicitly called:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 如果子类的构造函数省略了`base`关键字，则隐式调用基类型的*无参数*构造函数：
- en: '[PRE128]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'If the base class has no accessible parameterless constructor, subclasses are
    forced to use the `base` keyword in their constructors. This means that a base
    class with (only) a multiparameter constructor burdens subclasses with the obligation
    to call it:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 如果基类没有可访问的无参数构造函数，则子类被迫在其构造函数中使用`base`关键字。这意味着基类只有一个多参数构造函数时，子类会负担调用它的责任：
- en: '[PRE129]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Required members (C# 11)
  id: totrans-474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 必需成员（C# 11）
- en: 'The requirement for subclasses to invoke a constructor in the base class can
    become burdensome in large class hierarchies if there are many constructors with
    many parameters. Sometimes, the best solution is to avoid constructors altogether
    and rely solely on object initializers to set fields or properties during construction.
    To help with this, you can mark a field or property as `required` (from C# 11):'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在大型类层次结构中存在许多具有许多参数的构造函数，则要求子类调用基类中的构造函数可能会变得繁琐。有时，最好的解决方案是完全避免构造函数，并仅依赖对象初始化器在构造期间设置字段或属性。为了帮助解决这个问题，您可以将字段或属性标记为`required`（来自C#
    11）：
- en: '[PRE130]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'A required member *must* be populated via an object initializer when constructed:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '*必需成员*在构造时必须通过对象初始化器填充：'
- en: '[PRE131]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Should you wish to also write a constructor, you can apply the `[SetsRequired​Mem⁠bers]`
    attribute to bypass the required member restriction for that constructor:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望也写一个构造器，你可以应用`[SetsRequired​Mem⁠bers]`属性，以绕过该构造器的必需成员限制：
- en: '[PRE132]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Consumers can now benefit from the convenience of that constructor without
    any trade-off:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者现在可以享受到那个构造器的便利，而没有任何的权衡：
- en: '[PRE133]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Notice that we also defined a parameterless constructor (for use with the object
    initializer). Its presence also ensures that subclasses remain under no burden
    to reproduce any constructor. In the following example, the `House` class chooses
    not to implement a convenience constructor:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还定义了一个无参数构造函数（用于对象初始化器）。其存在还确保了子类不需要重现任何构造函数。在以下示例中，`House`类选择不实现便利构造函数：
- en: '[PRE134]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Constructor and field initialization order
  id: totrans-485
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数和字段初始化顺序
- en: 'When an object is instantiated, initialization takes place in the following
    order:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象被实例化时，按以下顺序进行初始化：
- en: 'From subclass to base class:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从子类到基类：
- en: Fields are initialized.
  id: totrans-488
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字段被初始化。
- en: Arguments to base-class constructor calls are evaluated.
  id: totrans-489
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用基类构造函数的参数被评估。
- en: 'From base class to subclass:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从基类到子类：
- en: Constructor bodies execute.
  id: totrans-491
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数体执行。
- en: 'For example:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE135]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Inheritance with primary constructors
  id: totrans-494
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用主构造函数的继承
- en: 'Classes with primary constructors can subclass with the following syntax:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 具有主构造函数的类可以使用以下语法进行子类化：
- en: '[PRE136]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The call to `Baseclass(x)` is equivalent to calling `base(x)` in the following
    example:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，对`Baseclass(x)`的调用等同于调用`base(x)`：
- en: '[PRE137]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Overloading and Resolution
  id: totrans-499
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重载与解析
- en: 'Inheritance has an interesting impact on method overloading. Consider the following
    two overloads:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 继承对方法重载有着有趣的影响。考虑以下两个重载：
- en: '[PRE138]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'When an overload is called, the most specific type has precedence:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用重载时，最具体的类型优先：
- en: '[PRE139]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The particular overload to call is determined statically (at compile time)
    rather than at runtime. The following code calls `Foo(Asset)`, even though the
    runtime type of `a` is `House`:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 调用具体的重载是在静态（编译时）而不是在运行时确定的。以下代码调用`Foo(Asset)`，即使`a`的运行时类型是`House`：
- en: '[PRE140]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Note
  id: totrans-506
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you cast `Asset` to `dynamic` ([Chapter 4](ch04.html#advanced_chash)), the
    decision as to which overload to call is deferred until runtime and is then based
    on the object’s actual type:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`Asset`转换为`dynamic`（[第四章](ch04.html#advanced_chash)），决定调用哪个重载将被推迟到运行时，并且基于对象的实际类型进行：
- en: '[PRE141]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: The object Type
  id: totrans-509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象类型
- en: '`object` (`System.Object`) is the ultimate base class for all types. Any type
    can be upcast to `object`.'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '`object`（`System.Object`）是所有类型的最终基类。任何类型都可以向上转型为`object`。'
- en: 'To illustrate how this is useful, consider a general-purpose *stack*. A stack
    is a data structure based on the principle of *LIFO*—“last in, first out.” A stack
    has two operations: *push* an object on the stack and *pop* an object off the
    stack. Here is a simple implementation that can hold up to 10 objects:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这是如何有用的，考虑一个通用的*堆栈*。堆栈是一种基于“后进先出（LIFO）”原则的数据结构。堆栈有两个操作：*push*（将对象推入堆栈）和*pop*（从堆栈弹出对象）。以下是一个可以容纳最多10个对象的简单实现：
- en: '[PRE142]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Because `Stack` works with the object type, we can `Push` and `Pop` instances
    of *any type* to and from the `Stack`:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Stack`与对象类型一起工作，我们可以向`Stack`推送和弹出*任何类型*的实例：
- en: '[PRE143]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '`object` is a reference type, by virtue of being a class. Despite this, value
    types, such as `int`, can also be cast to and from `object`, and so be added to
    our stack. This feature of C# is called *type unification* and is demonstrated
    here:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '`object`是引用类型，因为它是一个类。尽管如此，值类型，如`int`，也可以被转换为`object`并且被添加到我们的堆栈中。C#的这一特性称为*类型统一*，这里进行了演示：'
- en: '[PRE144]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: When you cast between a value type and `object`, the CLR must perform some special
    work to bridge the difference in semantics between value and reference types.
    This process is called *boxing* and *unboxing*.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在值类型和`object`之间进行类型转换时，CLR必须执行一些特殊工作以弥合值类型和引用类型之间的语义差异。这个过程称为*装箱*和*拆箱*。
- en: Note
  id: totrans-518
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In [“Generics”](#generics), we describe how to improve our `Stack` class to
    better handle stacks with same-typed elements.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“泛型”](#generics)中，我们描述了如何改进我们的`Stack`类以更好地处理具有相同类型元素的堆栈。
- en: Boxing and Unboxing
  id: totrans-520
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装箱与拆箱
- en: 'Boxing is the act of converting a value-type instance to a reference-type instance.
    The reference type can be either the `object` class or an interface (which we
    visit later in the chapter).^([1](ch03.html#ch01fn5)) In this example, we box
    an `int` into an object:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 装箱是将值类型实例转换为引用类型实例的过程。引用类型可以是 `object` 类或接口（稍后在本章讨论）。^([1](ch03.html#ch01fn5))
    在此示例中，我们将 `int` 装箱为对象：
- en: '[PRE145]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Unboxing reverses the operation by casting the object back to the original
    value type:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 拆箱通过将对象强制转换回原始值类型来反转操作：
- en: '[PRE146]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Unboxing requires an explicit cast. The runtime checks that the stated value
    type matches the actual object type, and throws an `InvalidCastException` if the
    check fails. For instance, the following throws an exception because `long` does
    not exactly match `int`:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 拆箱需要显式转换。运行时检查所述值类型是否与实际对象类型匹配，如果检查失败，则抛出 `InvalidCastException` 异常。例如，以下代码因
    `long` 与 `int` 不完全匹配而引发异常：
- en: '[PRE147]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'The following succeeds, however:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 以下操作成功：
- en: '[PRE148]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'As does this:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示：
- en: '[PRE149]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: In the last example, `(double)` performs an *unboxing* and then `(int)` performs
    a *numeric conversion*.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个示例中，`(double)` 执行*拆箱*操作，然后 `(int)` 执行*数值转换*。
- en: Note
  id: totrans-532
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Boxing conversions are crucial in providing a unified type system. The system
    is not perfect, however: we’ll see in [“Generics”](#generics) that variance with
    arrays and generics supports only *reference conversions* and not *boxing conversions*:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 装箱转换在提供统一类型系统方面至关重要。然而，该系统并非完美：我们将在[“泛型”](#generics)中看到，数组和泛型的协变仅支持*引用转换*，而不支持*装箱转换*：
- en: '[PRE150]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Copying semantics of boxing and unboxing
  id: totrans-535
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 装箱和拆箱的复制语义
- en: 'Boxing *copies* the value-type instance into the new object, and unboxing *copies*
    the contents of the object back into a value-type instance. In the following example,
    changing the value of `i` doesn’t change its previously boxed copy:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 装箱会将值类型实例*复制*到新对象中，而拆箱会将对象内容*复制*回值类型实例。在以下示例中，更改 `i` 的值不会更改其先前装箱的副本：
- en: '[PRE151]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Static and Runtime Type Checking
  id: totrans-538
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态和运行时类型检查
- en: C# programs are type-checked both statically (at compile time) and at runtime
    (by the CLR).
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: C# 程序在静态（编译时）和运行时（由CLR进行）都进行类型检查。
- en: 'Static type checking enables the compiler to verify the correctness of your
    program without running it. The following code will fail because the compiler
    enforces static typing:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型检查使编译器能够在不运行程序的情况下验证其正确性。以下代码将因编译器强制执行静态类型而失败：
- en: '[PRE152]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Runtime type checking is performed by the CLR when you downcast via a reference
    conversion or unboxing:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: CLR在通过引用转换或拆箱向下转换时执行运行时类型检查：
- en: '[PRE153]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Runtime type checking is possible because each object on the heap internally
    stores a little type token. You can retrieve this token by calling the `GetType`
    method of `object`.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时类型检查之所以可行，是因为堆上的每个对象内部都存储有一个小的类型标记。通过调用 `object` 的 `GetType` 方法可以检索此标记。
- en: The GetType Method and typeof Operator
  id: totrans-545
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`GetType` 方法和 `typeof` 运算符'
- en: 'All types in C# are represented at runtime with an instance of `System.Type`.
    There are two basic ways to get a `System.Type` object:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，所有C#类型都用 `System.Type` 的实例表示。获取 `System.Type` 对象有两种基本方式：
- en: Call `GetType` on the instance
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实例上调用 `GetType`
- en: Use the `typeof` operator on a type name
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编译时使用 `typeof` 运算符对类型名进行操作
- en: '`GetType` is evaluated at runtime; `typeof` is evaluated statically at compile
    time (when generic type parameters are involved, it’s resolved by the JIT compiler).'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetType` 在运行时评估；`typeof` 在编译时静态评估（涉及泛型类型参数时，由JIT编译器解析）。'
- en: '`System.Type` has properties for such things as the type’s name, assembly,
    base type, and so on:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Type` 具有诸如类型名称、程序集、基类型等属性：'
- en: '[PRE154]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '`System.Type` also has methods that act as a gateway to the runtime’s reflection
    model, described in [Chapter 18](ch18.html#reflection_and_metadata).'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Type` 还具有作为运行时反射模型入口的方法，详见[第18章](ch18.html#reflection_and_metadata)。'
- en: The ToString Method
  id: totrans-553
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ToString 方法
- en: 'The `ToString` method returns the default textual representation of a type
    instance. This method is overridden by all built-in types. Here is an example
    of using the `int` type’s `ToString` method:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToString` 方法返回类型实例的默认文本表示。所有内置类型都重写了此方法。以下是使用 `int` 类型的 `ToString` 方法的示例：'
- en: '[PRE155]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'You can override the `ToString` method on custom types as follows:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 可以重写自定义类型的 `ToString` 方法如下：
- en: '[PRE156]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: If you don’t override `ToString`, the method returns the type name.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不重写 `ToString`，该方法将返回类型名称。
- en: Note
  id: totrans-559
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'When you call an *overridden* `object` member such as `ToString` directly on
    a value type, boxing doesn’t occur. Boxing then occurs only if you cast:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 当你直接调用值类型上的*重写*的`object`成员，比如`ToString`时，不会发生装箱。只有在你进行强制类型转换时才会发生装箱：
- en: '[PRE157]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Object Member Listing
  id: totrans-562
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象成员列表
- en: 'Here are all the members of `object`:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是所有`object`的成员：
- en: '[PRE158]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: We describe the `Equals`, `ReferenceEquals`, and `GetHashCode` methods in [“Equality
    Comparison”](ch06.html#equality_comparison-id00067).
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[“相等比较”](ch06.html#equality_comparison-id00067)中描述了`Equals`、`ReferenceEquals`和`GetHashCode`方法。
- en: Structs
  id: totrans-566
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体
- en: 'A *struct* is similar to a class, with the following key differences:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '*结构体*与类似，但以下是其关键区别：'
- en: A struct is a value type, whereas a class is a reference type.
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体是值类型，而类是引用类型。
- en: A struct does not support inheritance (other than implicitly deriving from `object`,
    or more precisely, `System.ValueType`).
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体不支持继承（除了隐式从`object`派生，或更确切地说，`System.ValueType`）。
- en: A struct can have all of the members that a class can, except for a finalizer.
    And because it cannot be subclassed, members cannot be marked as virtual, abstract,
    or protected.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 一个结构体可以拥有所有类的成员，除了析构函数。并且因为它不能被子类化，成员不能标记为虚拟的、抽象的或受保护的。
- en: Warning
  id: totrans-571
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Prior to C# 10, structs were further prohibited from defining fields initializers
    and parameterless constructors. Although this prohibition has now been relaxed—primarily
    for the benefit of record structs (see [“Records”](ch04.html#records-id00087))—it’s
    worth thinking carefully before defining these constructs, as they can result
    in confusing behavior that we’ll describe in [“Struct Construction Semantics”](#struct_construction_semantics).
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 10之前，结构体进一步禁止定义字段初始化器和无参数构造函数。尽管这个禁令现在已经放宽，主要是为了支持记录结构体（见[“记录”](ch04.html#records-id00087)），但在定义这些结构之前，仍值得仔细考虑，因为它们可能导致混乱的行为，我们将在[“结构体构造语义”](#struct_construction_semantics)中描述。
- en: A struct is appropriate when value-type semantics are desirable. Good examples
    of structs are numeric types, where it is more natural for assignment to copy
    a value rather than a reference. Because a struct is a value type, each instance
    does not require instantiation of an object on the heap; this results in useful
    savings when creating many instances of a type. For instance, creating an array
    of value type elements requires only a single heap allocation.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要值类型语义时，结构体是合适的。结构体的良好示例是数值类型，在这些类型中，赋值复制值而不是引用更为自然。因为结构体是值类型，每个实例不需要在堆上实例化对象；这在创建多个类型实例时可以节省内存。例如，创建值类型元素的数组只需要单个堆分配。
- en: Because structs are value types, an instance cannot be null. The default value
    for a struct is an empty instance, with all fields empty (set to their default
    values).
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 因为结构体是值类型，实例不能为null。结构的默认值是一个空实例，所有字段都为空（设置为它们的默认值）。
- en: Struct Construction Semantics
  id: totrans-575
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构体构造语义
- en: Note
  id: totrans-576
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Prior to C# 11, every field in a struct had to be explicitly assigned in the
    constructor (or field initializer). This restriction has now been relaxed.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 11之前，结构体中的每个字段都必须在构造函数（或字段初始化器）中显式赋值。这个限制现在已经放宽。
- en: The default constructor
  id: totrans-578
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认构造函数
- en: 'In addition to any constructors that you define, a struct always has an implicit
    parameterless constructor that performs a bitwise-zeroing of its fields (setting
    them to their default values):'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 除了你定义的任何构造函数外，结构体始终有一个隐式的无参数构造函数，执行其字段的比特零化（将它们设置为它们的默认值）：
- en: '[PRE159]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Even when you define a parameterless constructor of your own, the implicit
    parameterless constructor still exists and can be accessed via the `default` keyword:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你定义了自己的无参数构造函数，隐式的无参数构造函数仍然存在，并且可以通过`default`关键字访问：
- en: '[PRE160]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'In this example, we initialized `x` to 1 via a field initializer, and we initialized
    `y` to 1 via the parameterless constructor. And yet with the `default` keyword,
    we were still able to create a `Point` that bypassed both initializations. The
    default constructor can be accessed other ways, too, as the following example
    illustrates:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过字段初始化器将`x`初始化为1，通过无参数构造函数将`y`初始化为1。然而，使用`default`关键字，我们仍然能够创建一个绕过这两个初始化的`Point`。默认构造函数也可以通过其他方式访问，正如以下例子所示：
- en: '[PRE161]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Note
  id: totrans-585
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Having what amounts to two parameterless constructors can be a source of confusion,
    and is arguably a good reason to avoid defining field initializers and explicit
    parameterless constructors in structs.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有两个无参数构造函数可能会导致混淆，这可能是避免在结构体中定义字段初始化器和显式的无参数构造函数的一个好理由。
- en: 'A good strategy with structs is to design them such that their `default` value
    is a valid state, thereby making initialization redundant. For example, rather
    than initializing a property as follows:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体的一个好策略是设计它们的 `default` 值是一个有效状态，从而使初始化变得多余。例如，而不是初始化属性如下：
- en: '[PRE162]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'consider the following:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下内容：
- en: '[PRE163]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: Read-Only Structs and Functions
  id: totrans-591
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 只读结构体和函数
- en: 'You can apply the `readonly` modifier to a struct to enforce that all fields
    are `readonly`; this aids in declaring intent as well as affording the compiler
    more optimization freedom:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将 `readonly` 修饰符应用于结构体，以强制所有字段都是 `readonly` 的；这有助于声明意图，并为编译器提供更多的优化自由度：
- en: '[PRE164]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'If you need to apply `readonly` at a more granular level, you can apply the
    `readonly` modifier (from C# 8) to a struct’s *functions*. This ensures that if
    the function attempts to modify any field, a compile-time error is generated:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要在更细粒度的级别应用 `readonly`，可以将 `readonly` 修饰符（从 C# 8 开始）应用于结构体的 *函数*。这确保如果函数尝试修改任何字段，则会生成编译时错误：
- en: '[PRE165]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: If a `readonly` function calls a non-`readonly` function, the compiler generates
    a warning (and defensively copies the struct to avoid the possibility of a mutation).
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个 `readonly` 函数调用一个非 `readonly` 函数，编译器会生成警告（并为了避免可能的突变而进行防御性地复制结构体）。
- en: Ref Structs
  id: totrans-597
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ref 结构体
- en: Note
  id: totrans-598
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Ref structs were introduced in C# 7.2 as a niche feature primarily for the benefit
    of the `Span<T>` and `ReadOnlySpan<T>` structs that we describe in [Chapter 23](ch23.html#spanless_thantgreater_than_and-id00089)
    (and the highly optimized `Utf8JsonReader` that we describe in [Chapter 11](ch11.html#other_xml_and_json_technologies)).
    These structs help with a micro-optimization technique that aims to reduce memory
    allocations.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 7.2 中引入了 ref 结构体作为一个主要为了 `Span<T>` 和 `ReadOnlySpan<T>` 结构体的利益而引入的特性。我们在
    [第23章](ch23.html#spanless_thantgreater_than_and-id00089) 中描述了这些结构体（以及高度优化的 `Utf8JsonReader`
    在 [第11章](ch11.html#other_xml_and_json_technologies) 中的描述）。这些结构体有助于一种微优化技术，旨在减少内存分配。
- en: 'Unlike reference types, whose instances always live on the heap, value types
    live *in-place* (wherever the variable was declared). If a value type appears
    as a parameter or local variable, it will reside on the stack:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 不像引用类型，其实例总是存在于堆上，值类型则在 *原地*（变量声明的地方）生存。如果值类型出现为参数或局部变量，它将驻留在堆栈上：
- en: '[PRE166]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'But if a value type appears as a field in a class, it will reside on the heap:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果一个值类型作为类的字段出现，它将驻留在堆上：
- en: '[PRE167]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Similarly, arrays of structs live on the heap, and boxing a struct sends it
    to the heap.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，结构体数组存在于堆上，而装箱一个结构体会将其发送到堆上。
- en: 'Adding the `ref` modifier to a struct’s declaration ensures that it can only
    ever reside on the stack. Attempting to use a *ref struct* in such a way that
    it could reside on the heap generates a compile-time error:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 向结构体的声明添加 `ref` 修饰符确保它只能驻留在堆栈上。试图使用 *ref 结构体* 的方式使其可能驻留在堆上会生成编译时错误：
- en: '[PRE168]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Ref structs were introduced mainly for the benefit of the `Span<T>` and `ReadOnlySpan<T>`
    structs. Because `Span<T>` and `ReadOnlySpan<T>` instances can exist only on the
    stack, it’s possible for them to safely wrap stack-allocated memory.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: Ref 结构体主要为了 `Span<T>` 和 `ReadOnlySpan<T>` 结构体的利益而引入。因为 `Span<T>` 和 `ReadOnlySpan<T>`
    实例只能存在于堆栈上，所以它们可以安全地包装堆栈分配的内存。
- en: Ref structs cannot partake in any C# feature that directly or indirectly introduces
    the possibility of existing on the heap. This includes a number of advanced C#
    features that we describe in [Chapter 4](ch04.html#advanced_chash), namely, lambda
    expressions, iterators, and asynchronous functions (because, behind the scenes,
    these features all create hidden classes with fields). Also, ref structs cannot
    appear inside non-ref structs, and they cannot implement interfaces (because this
    could result in boxing).
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: Ref 结构体不能参与任何直接或间接导致存在于堆上的 C# 功能。这包括我们在 [第4章](ch04.html#advanced_chash) 中描述的许多高级
    C# 功能，即 lambda 表达式、迭代器和异步函数（因为在幕后，这些功能都会创建带有字段的隐藏类）。此外，ref 结构体不能出现在非 ref 结构体内部，也不能实现接口（因为这可能导致装箱）。
- en: Access Modifiers
  id: totrans-609
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问修饰符
- en: 'To promote encapsulation, a type or type member can limit its *accessibility*
    to other types and other assemblies by adding an *access modifier* to the declaration:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 为了促进封装，类型或类型成员可以通过在声明中添加 *访问修饰符* 来限制其对其他类型和其他程序集的 *可访问性*：
- en: '`public`'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '`public`'
- en: Fully accessible. This is the implicit accessibility for members of an enum
    or interface.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 完全可访问。这是枚举或接口成员的隐式可访问性。
- en: '`internal`'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '`internal`'
- en: Accessible only within the containing assembly or friend assemblies. This is
    the default accessibility for non-nested types.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在包含程序集或友元程序集中可访问。这是非嵌套类型的默认可访问性。
- en: '`private`'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '`private`'
- en: Accessible only within the containing type. This is the default accessibility
    for members of a class or struct.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在包含类型内部可访问。这是类或结构的成员的默认可访问性。
- en: '`protected`'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '`protected`'
- en: Accessible only within the containing type or subclasses.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在包含类型或子类中可访问。
- en: '`protected internal`'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '`protected internal`'
- en: The *union* of `protected` and `internal` accessibility. A member that is `protected
    internal` is accessible in two ways.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '`protected` 和 `internal` 可访问性的*并集*。具有 `protected internal` 访问性的成员可以通过两种方式访问。'
- en: '`private protected`'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '`private protected`'
- en: The *intersection* of `protected` and `internal` accessibility. A member that
    is `private protected` is accessible only within the containing type, or from
    subclasses *that reside in the same assembly* (making it *less* accessible than
    `protected` or `internal` alone).
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '`protected` 和 `internal` 可访问性的*交集*。具有 `private protected` 访问性的成员仅在包含类型内部可访问，或者来自*同一程序集中的子类*（使其比单独的
    `protected` 或 `internal` 更不可访问）。'
- en: '`file` (from C# 11)'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '`file`（来自C# 11）'
- en: Accessible only from within the same file. Intended for use by *source generators*
    (see [“Extended partial methods”](#extended_partial_methods)). This modifier can
    be applied only to type declarations.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在同一文件内部可访问。用于*源生成器*的使用（请参阅[“扩展部分方法”](#extended_partial_methods)）。此修饰符仅适用于类型声明。
- en: Examples
  id: totrans-625
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: '`Class2` is accessible from outside its assembly; `Class1` is not:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '`Class2` 可从其程序集外部访问；`Class1` 则不行：'
- en: '[PRE169]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '`ClassB` exposes field `x` to other types in the same assembly; `ClassA` does
    not:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClassB` 将字段 `x` 公开给同一程序集中的其他类型；`ClassA` 则不公开：'
- en: '[PRE170]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Functions within `Subclass` can call `Bar` but not `Foo`:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subclass` 中的函数可以调用 `Bar`，但不能调用 `Foo`：'
- en: '[PRE171]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Friend Assemblies
  id: totrans-632
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 友元程序集
- en: 'You can expose `internal` members to other *friend* assemblies by adding the
    `System.Runtime.CompilerServices.InternalsVisibleTo` assembly attribute, specifying
    the name of the friend assembly as follows:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过添加`System.Runtime.CompilerServices.InternalsVisibleTo`程序集属性，指定友元程序集的名称，来向其他*友元*程序集公开`internal`成员，如下所示：
- en: '[PRE172]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'If the friend assembly has a strong name (see [Chapter 17](ch17.html#assemblies)),
    you must specify its *full* 160-byte public key:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 如果友元程序集具有强名称（请参阅[第17章](ch17.html#assemblies)），则必须指定其完整的160字节公钥：
- en: '[PRE173]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'You can extract the full public key from a strongly named assembly with a LINQ
    query (we explain LINQ in detail in [Chapter 8](ch08.html#linq_queries)):'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用LINQ查询从强命名程序集中提取完整的公钥（我们在[第8章](ch08.html#linq_queries)详细解释LINQ）：
- en: '[PRE174]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Note
  id: totrans-639
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The companion sample in LINQPad invites you to browse to an assembly and then
    copies the assembly’s full public key to the clipboard.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 在LINQPad中的伴侣示例邀请您浏览程序集，然后将程序集的完整公钥复制到剪贴板。
- en: Accessibility Capping
  id: totrans-641
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问性限制
- en: 'A type caps the accessibility of its declared members. The most common example
    of capping is when you have an `internal` type with `public` members. For example,
    consider this:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 类型限制其声明成员的可访问性。最常见的限制示例是具有 `public` 成员的 `internal` 类型。例如，请考虑以下情况：
- en: '[PRE175]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '`C`’s (default) `internal` accessibility caps `Foo`’s accessibility, effectively
    making `Foo internal`. A common reason `Foo` would be marked `public` is to make
    for easier refactoring should `C` later be changed to `public`.'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '`C` 的（默认）`internal` 可访问性限制了 `Foo` 的访问性，实际上使 `Foo` 变为 `internal`。将 `Foo` 标记为
    `public` 的常见原因是，如果以后将 `C` 更改为 `public`，则易于重构。'
- en: Restrictions on Access Modifiers
  id: totrans-645
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问修饰符的限制
- en: 'When overriding a base class function, accessibility must be identical on the
    overridden function; for example:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 当重写基类函数时，重写函数的可访问性必须与被重写函数相同；例如：
- en: '[PRE176]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: (An exception is when overriding a `protected internal` method in another assembly,
    in which case the override must simply be `protected`.)
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: （例外情况是在另一个程序集中重写 `protected internal` 方法时，此时重写必须简单地是 `protected`。）
- en: 'The compiler prevents any inconsistent use of access modifiers. For example,
    a subclass itself can be less accessible than a base class but not more:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器阻止任何不一致使用访问修饰符的情况。例如，子类本身可以比基类更不可访问，但不能更多：
- en: '[PRE177]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: Interfaces
  id: totrans-651
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: 'An interface is similar to a class, but only *specifies behavior* and does
    not hold state (data). Consequently:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 接口类似于类，但仅*指定行为*，而不保存状态（数据）。因此：
- en: An interface can define only functions and not fields.
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口只能定义函数而不能定义字段。
- en: Interface members are *implicitly abstract*. (There are exceptions to this rule
    that we will describe in [“Default Interface Members”](#default_interface_members-id00061)
    and [“Static Interface Members”](#static_interface_members).)
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口成员是*隐式抽象*的。（有一些例外情况，我们将在[“默认接口成员”](#default_interface_members-id00061)和[“静态接口成员”](#static_interface_members)中描述。）
- en: A class (or struct) can implement multiple interfaces. In contrast, a class
    can inherit from only a single class, and a struct cannot inherit at all (aside
    from deriving from `System.ValueType`).
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类（或结构）可以实现多个接口。相比之下，一个类只能继承一个类，而结构体则根本不能继承（除了从`System.ValueType`派生）。
- en: An interface declaration is like a class declaration, but it (normally) provides
    no implementation for its members because its members are implicitly abstract.
    These members will be implemented by the classes and structs that implement the
    interface. An interface can contain only functions, that is, methods, properties,
    events, and indexers (which noncoincidentally are precisely the members of a class
    that can be abstract).
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 接口声明类似于类声明，但它（通常）不为其成员提供实现，因为其成员隐式为抽象。这些成员将由实现接口的类和结构体实现。接口只能包含函数，即方法、属性、事件和索引器（这些恰好是类的成员可以是抽象的成员）。
- en: 'Here is the definition of the `IEnumerator` interface, defined in `System.Collections`:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 这是定义在`System.Collections`中的`IEnumerator`接口的定义：
- en: '[PRE178]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Interface members are always implicitly public and cannot declare an access
    modifier. Implementing an interface means providing a `public` implementation
    for all of its members:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 接口成员始终是隐式公共的，不能声明访问修饰符。实现接口意味着为其所有成员提供`public`实现：
- en: '[PRE179]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'You can implicitly cast an object to any interface that it implements:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将对象隐式转换为其实现的任何接口：
- en: '[PRE180]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Note
  id: totrans-663
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Even though `Countdown` is an internal class, its members that implement `IEnumerator`
    can be called publicly by casting an instance of `Countdown` to `IEnumerator`.
    For instance, if a public type in the same assembly defined a method as follows:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`Countdown`是一个内部类，也可以通过将`Countdown`的实例转换为`IEnumerator`来公开调用其实现的成员。例如，如果同一程序集中的公共类型定义了以下方法：
- en: '[PRE181]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'a caller from another assembly could do this:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 来自另一个程序集的调用者可以这样做：
- en: '[PRE182]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: If `IEnumerator` were itself defined as `internal`, this wouldn’t be possible.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`IEnumerator`本身被定义为`internal`，这是不可能的。
- en: Extending an Interface
  id: totrans-669
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展一个接口
- en: 'Interfaces can derive from other interfaces; for instance:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 接口可以从其他接口派生；例如：
- en: '[PRE183]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '`IRedoable` “inherits” all the members of `IUndoable`. In other words, types
    that implement `IRedoable` must also implement the members of `IUndoable`.'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '`IRedoable`“继承”了`IUndoable`的所有成员。换句话说，实现`IRedoable`的类型也必须实现`IUndoable`的成员。'
- en: Explicit Interface Implementation
  id: totrans-673
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式接口实现
- en: 'Implementing multiple interfaces can sometimes result in a collision between
    member signatures. You can resolve such collisions by *explicitly implementing*
    an interface member. Consider the following example:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 实现多个接口有时会导致成员签名冲突。您可以通过*显式实现*接口成员来解决这类冲突。请考虑以下示例：
- en: '[PRE184]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Because `I1` and `I2` have conflicting `Foo` signatures, `Widget` explicitly
    implements `I2`’s `Foo` method. This lets the two methods coexist in one class.
    The only way to call an explicitly implemented member is to cast to its interface:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`I1`和`I2`具有冲突的`Foo`签名，`Widget`显式实现了`I2`的`Foo`方法。这使得两个方法可以在同一个类中共存。调用显式实现的成员的唯一方法是将其转换为其接口：
- en: '[PRE185]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Another reason to explicitly implement interface members is to hide members
    that are highly specialized and distracting to a type’s normal use case. For example,
    a type that implements `ISerializable` would typically want to avoid flaunting
    its `ISerializable` members unless explicitly cast to that interface.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个显式实现接口成员的原因是隐藏那些对类型的正常使用案例高度专业化和分散注意力的成员。例如，实现`ISerializable`的类型通常希望在没有显式转换为该接口的情况下避免展示其`ISerializable`成员。
- en: Implementing Interface Members Virtually
  id: totrans-679
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟实现接口成员
- en: 'An implicitly implemented interface member is, by default, sealed. It must
    be marked `virtual` or `abstract` in the base class in order to be overridden:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，隐式实现的接口成员是封闭的。必须在基类中标记为`virtual`或`abstract`才能被重写：
- en: '[PRE186]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Calling the interface member through either the base class or the interface
    calls the subclass’s implementation:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 通过基类或接口调用接口成员将调用子类的实现：
- en: '[PRE187]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: An explicitly implemented interface member cannot be marked `virtual`, nor can
    it be overridden in the usual manner. It can, however, be *reimplemented*.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 显式实现的接口成员不能标记为`virtual`，也不能以通常的方式被重写。但是可以*重新实现*它。
- en: Reimplementing an Interface in a Subclass
  id: totrans-685
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在子类中重新实现接口
- en: A subclass can reimplement any interface member already implemented by a base
    class. Reimplementation hijacks a member implementation (when called through the
    interface) and works whether or not the member is `virtual` in the base class.
    It also works whether a member is implemented implicitly or explicitly—although
    it works best in the latter case, as we will demonstrate.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 子类可以重新实现基类已经实现的任何接口成员。当通过接口调用时，重新实现会接管成员的实现，无论基类中成员是否为`virtual`都可以工作。它还适用于成员是隐式实现还是显式实现的情况——尽管在后者的情况下效果最佳，我们将会展示。
- en: 'In the following example, `TextBox` implements `IUndoable.Undo` explicitly,
    and so it cannot be marked as `virtual`. To “override” it, `RichTextBox` must
    reimplement `IUndoable`’s `Undo` method:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`TextBox`显式实现了`IUndoable.Undo`，因此它不能标记为`virtual`。要“覆盖”它，`RichTextBox`必须重新实现`IUndoable`的`Undo`方法：
- en: '[PRE188]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Calling the reimplemented member through the interface calls the subclass’s
    implementation:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 通过接口调用重新实现的成员会调用子类的实现：
- en: '[PRE189]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'Assuming the same `RichTextBox` definition, suppose that `TextBox` implemented
    `Undo` *implicitly*:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 假设相同的`RichTextBox`定义，假设`TextBox`隐式实现了`Undo`：
- en: '[PRE190]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'This would give us another way to call `Undo`, which would “break” the system,
    as shown in Case 3:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供另一种调用`Undo`的方式，这将“破坏”系统，如情况 3 所示：
- en: '[PRE191]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: Case 3 demonstrates that reimplementation hijacking is effective only when a
    member is called through the interface and not through the base class. This is
    usually undesirable in that it can create inconsistent semantics. This makes reimplementation
    most appropriate as a strategy for overriding *explicitly* implemented interface
    members.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 情况 3 表明，重新实现仅在通过接口调用成员时有效，而不是通过基类。通常情况下这是不希望出现的，因为它可能导致不一致的语义。这使得重新实现最适合作为覆盖*显式*实现的接口成员的策略。
- en: Alternatives to interface reimplementation
  id: totrans-696
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接口重新实现的替代方案
- en: 'Even with explicit member implementation, interface reimplementation is problematic
    for a couple of reasons:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有显式成员实现，接口的重新实现也因为几个原因而存在问题：
- en: The subclass has no way to call the base class method.
  id: totrans-698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类没有办法调用基类的方法。
- en: The base class author might not anticipate that a method will be reimplemented
    and might not allow for the potential consequences.
  id: totrans-699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基类作者可能没有预料到某个方法会被重新实现，也可能没有考虑到潜在的后果。
- en: 'Reimplementation can be a good last resort when subclassing hasn’t been anticipated.
    A better option, however, is to design a base class such that reimplementation
    will never be required. There are two ways to achieve this:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 当子类化没有被预料到时，重新实现可以作为一种最后的手段。然而，更好的选择是设计一个基类，使得永远不需要重新实现。有两种方法可以实现这一点：
- en: When implicitly implementing a member, mark it `virtual` if appropriate.
  id: totrans-701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当隐式实现成员时，如果适合，将其标记为`virtual`。
- en: 'When explicitly implementing a member, use the following pattern if you anticipate
    that subclasses might need to override any logic:'
  id: totrans-702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在显式实现成员时，如果预期子类可能需要覆盖任何逻辑，请使用以下模式：
- en: '[PRE192]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: If you don’t anticipate any subclassing, you can mark the class as `sealed`
    to preempt interface reimplementation.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不预期有任何子类化，可以将类标记为`sealed`以预防接口的重新实现。
- en: Interfaces and Boxing
  id: totrans-705
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口和装箱
- en: 'Converting a struct to an interface causes boxing. Calling an implicitly implemented
    member on a struct does not cause boxing:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 将结构转换为接口会导致装箱。在结构上调用隐式实现的成员不会导致装箱：
- en: '[PRE193]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: Default Interface Members
  id: totrans-708
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认接口成员
- en: 'From C# 8, you can add a default implementation to an interface member, making
    it optional to implement:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 8 开始，你可以向接口成员添加默认实现，使其成为可选实现：
- en: '[PRE194]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: This is advantageous if you want to add a member to an interface defined in
    a popular library without breaking (potentially thousands of) implementations.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想向一个流行库中定义的接口添加成员而不破坏（可能有成千上万的）实现，这是有利的。
- en: 'Default implementations are always explicit, so if a class implementing `ILogger`
    fails to define a `Log` method, the only way to call it is through the interface:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 默认实现始终是显式的，因此如果实现`ILogger`的类未定义`Log`方法，则仅通过接口调用它的唯一方法：
- en: '[PRE195]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'This prevents a problem of multiple implementation inheritance: if the same
    default member is added to two interfaces that a class implements, there is never
    an ambiguity as to which member is called.'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以防止多重实现继承的问题：如果一个类实现了两个接口，并且这两个接口都添加了相同的默认成员，则不会出现调用哪个成员的歧义。
- en: Static Interface Members
  id: totrans-715
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态接口成员
- en: 'An interface can also declare static members. There are two kinds of static
    interface members:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 一个接口也可以声明静态成员。有两种静态接口成员：
- en: Static nonvirtual interface members
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态非虚拟接口成员
- en: Static virtual/abstract interface members
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态虚拟/抽象接口成员
- en: Note
  id: totrans-719
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In contrast to *instance* members, static members on interfaces are nonvirtual
    by default. To make a static interface member virtual, you must mark it with `static
    abstract` or `static virtual`.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 与*实例*成员相反，接口上的静态成员默认为非虚拟的。要使静态接口成员虚拟化，必须将其标记为`static abstract`或`static virtual`。
- en: Static nonvirtual interface members
  id: totrans-721
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态非虚拟接口成员
- en: 'Static nonvirtual interface members exist mainly to help with writing default
    interface members. They are not implemented by classes or structs; instead, they
    are consumed directly. Along with methods, properties, events, and indexers, static
    nonvirtual members permit fields, which are typically accessed from code inside
    default member implementations:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 静态非虚拟接口成员主要用于帮助编写默认接口成员。它们不是由类或结构实现的；而是直接被使用。除了方法、属性、事件和索引器外，静态非虚拟成员还允许字段，这些字段通常从默认成员实现内部访问：
- en: '[PRE196]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'Static nonvirtual interface members are public by default, so they can be accessed
    from the outside:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 静态非虚拟接口成员默认为公共的，因此可以从外部访问：
- en: '[PRE197]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: You can restrict this by adding an accessibility modifier (such as `private`,
    `protected`, or `internal`).
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过添加可访问性修饰符（如`private`、`protected`或`internal`）来限制此内容。
- en: Instance fields are (still) prohibited. This is in line with the principle of
    interfaces, which is to define *behavior*, not *state*.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 实例字段（仍然）是禁止的。这与接口的原则一致，即定义*行为*而非*状态*。
- en: Static virtual/abstract interface members
  id: totrans-728
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态虚拟/抽象接口成员
- en: 'Static virtual/abstract interface members (from C# 11) enable *static polymorphism*,
    an advanced feature that we will discuss in [Chapter 4](ch04.html#advanced_chash).
    Static virtual interface members are marked with `static abstract` or `static
    virtual`:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 静态虚拟/抽象接口成员（从C# 11起）支持*静态多态*，这是我们将在[第4章](ch04.html#advanced_chash)中讨论的高级功能。静态虚拟接口成员标记为`static
    abstract`或`static virtual`：
- en: '[PRE198]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'An implementing class or struct must implement static abstract members, and
    can optionally implement static virtual members:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 实现类或结构必须实现静态抽象成员，并可以选择实现静态虚拟成员：
- en: '[PRE199]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: In addition to methods, properties, and events, operators and conversions are
    also legal targets for static virtual interface members (see [“Operator Overloading”](ch04.html#operator_overloading)).
    Static virtual interface members are called through a constrained type parameter;
    we will demonstrate this in [“Static Polymorphism”](ch04.html#static_polymorphism)
    and [“Generic Math”](ch04.html#generic_math-id00069), after covering generics
    later in this chapter.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 除了方法、属性和事件外，运算符和转换也是静态虚拟接口成员的合法目标（参见[“运算符重载”](ch04.html#operator_overloading)）。静态虚拟接口成员通过约束类型参数调用；我们将在本章后面的[“静态多态”](ch04.html#static_polymorphism)和[“泛型数学”](ch04.html#generic_math-id00069)中进行演示。
- en: Enums
  id: totrans-734
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: 'An enum is a special value type that lets you specify a group of named numeric
    constants. For example:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举是一种特殊的值类型，允许您指定一组命名的数值常量。例如：
- en: '[PRE200]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'We can use this enum type as follows:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下使用此枚举类型：
- en: '[PRE201]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'Each enum member has an underlying integral value. These are by default:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 每个枚举成员都有一个基础的整数值。这些默认为：
- en: Underlying values are of type `int`.
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础值的类型为`int`。
- en: The constants `0`, `1`, `2`... are automatically assigned, in the declaration
    order of the enum members.
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量`0`、`1`、`2`...会自动分配，按照枚举成员的声明顺序。
- en: 'You can specify an alternative integral type, as follows:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按以下方式指定替代整数类型：
- en: '[PRE202]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'You can also specify an explicit underlying value for each enum member:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以为每个枚举成员指定显式基础值：
- en: '[PRE203]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: Note
  id: totrans-746
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The compiler also lets you explicitly assign *some* of the enum members. The
    unassigned enum members keep incrementing from the last explicit value. The preceding
    example is equivalent to the following:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器还允许您显式分配*部分*枚举成员。未分配的枚举成员会从最后一个显式值递增。前面的示例等同于以下内容：
- en: '[PRE204]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: Enum Conversions
  id: totrans-749
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举转换
- en: 'You can convert an `enum` instance to and from its underlying integral value
    with an explicit cast:'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用显式强制转换将枚举实例转换为其基础整数值，反之亦然：
- en: '[PRE205]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'You can also explicitly cast one enum type to another. Suppose that `Horizontal​A⁠lignment`
    is defined as follows:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将一个枚举类型显式转换为另一个枚举类型。假设 `HorizontalAlignment` 定义如下：
- en: '[PRE206]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'A translation between the enum types uses the underlying integral values:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举类型之间的转换使用底层整数值：
- en: '[PRE207]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'The numeric literal `0` is treated specially by the compiler in an `enum` expression
    and does not require an explicit cast:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 数字文字 `0` 在枚举表达式中由编译器特别处理，不需要显式转换：
- en: '[PRE208]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'There are two reasons for the special treatment of `0`:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '`0` 有两个特殊处理原因：'
- en: The first member of an enum is often used as the “default” value.
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举的第一个成员通常用作“默认”值。
- en: For *combined enum* types, `0` means “no flags.”
  id: totrans-760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 *组合枚举* 类型，`0` 表示“无标志”。
- en: Flags Enums
  id: totrans-761
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标记枚举
- en: 'You can combine enum members. To prevent ambiguities, members of a combinable
    enum require explicitly assigned values, typically in powers of two:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以组合枚举成员。为防止歧义，组合枚举的成员需要显式分配值，通常是二的幂：
- en: '[PRE209]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'or:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE210]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'To work with combined enum values, you use bitwise operators such as `|` and
    `&`. These operate on the underlying integral values:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理组合枚举值，可以使用位运算符（如 `|` 和 `&`）。这些运算符作用于底层整数值：
- en: '[PRE211]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: By convention, the `Flags` attribute should always be applied to an enum type
    when its members are combinable. If you declare such an `enum` without the `Flags`
    attribute, you can still combine members, but calling `ToString` on an `enum`
    instance will emit a number rather than a series of names.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，当枚举类型的成员可以组合时，应始终将 `Flags` 属性应用于枚举类型。如果在不带 `Flags` 属性的情况下声明这样的 `enum`，仍然可以组合成员，但在枚举实例上调用
    `ToString` 时将输出数字而不是一系列名称。
- en: By convention, a combinable enum type is given a plural rather than singular
    name.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，可组合的枚举类型使用复数而不是单数名称。
- en: 'For convenience, you can include combination members within an enum declaration
    itself:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，您可以在枚举声明本身中包含组合成员：
- en: '[PRE212]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: Enum Operators
  id: totrans-772
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举运算符
- en: 'The operators that work with enums are:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 与枚举一起使用的运算符有：
- en: '[PRE213]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: The bitwise, arithmetic, and comparison operators return the result of processing
    the underlying integral values. Addition is permitted between an enum and an integral
    type, but not between two enums.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 位运算、算术和比较运算符返回处理底层整数值的结果。可以在枚举和整数类型之间进行加法运算，但不能在两个枚举之间进行加法运算。
- en: Type-Safety Issues
  id: totrans-776
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型安全问题
- en: 'Consider the following enum:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下枚举：
- en: '[PRE214]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'Because an enum can be cast to and from its underlying integral type, the actual
    value it can have might fall outside the bounds of a legal enum member:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 因为枚举可以在其基础整数类型之间进行强制转换，所以它可以具有的实际值可能超出合法枚举成员的范围：
- en: '[PRE215]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'The bitwise and arithmetic operators can produce similarly invalid values:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 位运算和算术运算符可能产生类似的无效值：
- en: '[PRE216]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'An invalid `BorderSide` would break the following code:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 无效的 `BorderSide` 将破坏以下代码：
- en: '[PRE217]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'One solution is to add another `else` clause:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 一个解决方法是添加另一个 `else` 子句：
- en: '[PRE218]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'Another workaround is to explicitly check an enum value for validity. The static
    `Enum.IsDefined` method does this job:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个解决方法是显式检查枚举值的有效性。静态的 `Enum.IsDefined` 方法完成这项工作：
- en: '[PRE219]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'Unfortunately, `Enum.IsDefined` does not work for flagged enums. However, the
    following helper method (a trick dependent on the behavior of `Enum.ToString()`)
    returns `true` if a given flagged enum is valid:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`Enum.IsDefined` 对于标记的枚举不起作用。但是，以下辅助方法（依赖于 `Enum.ToString()` 的行为）如果给定的标记枚举有效则返回
    `true`：
- en: '[PRE220]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: Nested Types
  id: totrans-791
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套类型
- en: 'A *nested type* is declared within the scope of another type:'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: '*嵌套类型* 是在另一个类型的范围内声明的：'
- en: '[PRE221]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'A nested type has the following features:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套类型具有以下特点：
- en: It can access the enclosing type’s private members and everything else the enclosing
    type can access.
  id: totrans-795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以访问封闭类型的私有成员以及封闭类型可以访问的其他所有内容。
- en: You can declare it with the full range of access modifiers rather than just
    `public` and `internal`.
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用全范围的访问修饰符声明它，而不仅仅是 `public` 和 `internal`。
- en: The default accessibility for a nested type is `private` rather than `internal`.
  id: totrans-797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套类型的默认访问权限是 `private` 而不是 `internal`。
- en: Accessing a nested type from outside the enclosing type requires qualification
    with the enclosing type’s name (like when accessing static members).
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问封闭类型外部的嵌套类型需要使用封闭类型的名称进行限定（类似访问静态成员时的方式）。
- en: 'For example, to access `Color.Red` from outside our `TopLevel` class, we’d
    need to do this:'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要从外部访问我们的 `TopLevel` 类中的 `Color.Red`，我们需要这样做：
- en: '[PRE222]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: All types (classes, structs, interfaces, delegates, and enums) can be nested
    within either a class or a struct.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类型（类、结构体、接口、委托和枚举）都可以嵌套在类或结构体内部。
- en: 'Here is an example of accessing a private member of a type from a nested type:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是从嵌套类型访问类型的私有成员的示例：
- en: '[PRE223]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'Here is an example of applying the `protected` access modifier to a nested
    type:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是将`protected`访问修饰符应用于嵌套类型的示例：
- en: '[PRE224]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'Here is an example of referring to a nested type from outside the enclosing
    type:'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是从封闭类型外部引用嵌套类型的示例：
- en: '[PRE225]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: Nested types are used heavily by the compiler itself when it generates private
    classes that capture state for constructs such as iterators and anonymous methods.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器本身在生成私有类时广泛使用嵌套类型，这些类为迭代器和匿名方法等构造捕获状态。
- en: Note
  id: totrans-809
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If the sole reason for using a nested type is to avoid cluttering a namespace
    with too many types, consider using a nested namespace, instead. A nested type
    should be used because of its stronger access control restrictions, or when the
    nested class must access private members of the containing class.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用嵌套类型的唯一原因是避免在命名空间中拥有太多类型，考虑使用嵌套命名空间。应当使用嵌套类型是因为它更强的访问控制限制，或者当嵌套类必须访问包含类的私有成员时。
- en: Generics
  id: totrans-811
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型
- en: 'C# has two separate mechanisms for writing code that is reusable across different
    types: *inheritance* and *generics*. Whereas inheritance expresses reusability
    with a base type, generics express reusability with a “template” that contains
    “placeholder” types. Generics, when compared to inheritance, can *increase type
    safety* and *reduce casting and boxing*.'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: C# 有两种分离的机制用于编写可在不同类型之间重复使用的代码：*继承* 和 *泛型*。继承通过基类型表达可重用性，而泛型通过包含“占位符”类型的“模板”表达可重用性。与继承相比，泛型可以*增加类型安全性*
    和 *减少强制转换和装箱*。
- en: Note
  id: totrans-813
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: C# generics and C++ templates are similar concepts, but they work differently.
    We explain this difference in [“C# Generics Versus C++ Templates”](#chash_generics_versus_cplusplus_templat).
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: C# 的泛型和 C++ 的模板是类似的概念，但它们的工作方式不同。我们在 [“C# Generics Versus C++ Templates”](#chash_generics_versus_cplusplus_templat)
    中解释了这种区别。
- en: Generic Types
  id: totrans-815
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型类型
- en: 'A generic type declares *type parameters*—placeholder types to be filled in
    by the consumer of the generic type, which supplies the *type arguments*. Here
    is a generic type `Stack<T>`, designed to stack instances of type `T`. `Stack<T>`
    declares a single type parameter `T`:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型声明*类型参数* ——由泛型类型的使用者提供*类型参数*填充的占位类型。这里是一个泛型类型`Stack<T>`的例子，设计用于堆叠`T`类型的实例。`Stack<T>`声明了一个单一的类型参数`T`：
- en: '[PRE226]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 'We can use `Stack<T>` as follows:'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样使用`Stack<T>`：
- en: '[PRE227]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '`Stack<int>` fills in the type parameter `T` with the type argument `int`,
    implicitly creating a type on the fly (the synthesis occurs at runtime). Attempting
    to push a string onto our `Stack<int>` would, however, produce a compile-time
    error. `Stack<int>` effectively has the following definition (substitutions appear
    in bold, with the class name hashed out to avoid confusion):'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stack<int>`用类型参数`T`隐式地创建了一个类型（合成发生在运行时）。然而，试图将字符串推入我们的`Stack<int>`将会产生编译时错误。`Stack<int>`实际上有以下定义（为避免混淆，类名以粗体标出）：'
- en: '[PRE228]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: 'Technically, we say that `Stack<T>` is an *open type*, whereas `Stack<int>`
    is a *closed type*. At runtime, all generic type instances are closed—with the
    placeholder types filled in. This means that the following statement is illegal:'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，我们称`Stack<T>`为*开放类型*，而`Stack<int>`为*闭合类型*。在运行时，所有泛型类型实例都是闭合的，即用具体的类型参数填充了占位符类型。这意味着以下语句是非法的：
- en: '[PRE229]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: 'However, it’s legal if it’s within a class or method that itself defines `T`
    as a type parameter:'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果它在一个自身定义了`T`作为类型参数的类或方法内，这是合法的：
- en: '[PRE230]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: Why Generics Exist
  id: totrans-826
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型的存在原因
- en: 'Generics exist to write code that is reusable across different types. Suppose
    that we need a stack of integers but we don’t have generic types. One solution
    would be to hardcode a separate version of the class for every required element
    type (e.g., `IntStack`, `StringStack`, etc.). Clearly, this would cause considerable
    code duplication. Another solution would be to write a stack that is generalized
    by using `object` as the element type:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型存在的目的是编写可在不同类型之间重复使用的代码。假设我们需要一个整数堆栈，但没有泛型类型。一种解决方案是为每种所需的元素类型硬编码一个单独的版本（例如，`IntStack`、`StringStack`等）。显然，这将导致大量的代码重复。另一种解决方案是编写一个使用`object`作为元素类型泛化的堆栈：
- en: '[PRE231]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'An `ObjectStack`, however, wouldn’t work as well as a hardcoded `IntStack`
    for specifically stacking integers. An `ObjectStack` would require boxing and
    downcasting that could not be checked at compile time:'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`ObjectStack` 并不像硬编码的 `IntStack` 那样适用于专门堆叠整数。`ObjectStack` 需要装箱和向下转型，这些在编译时无法检查：
- en: '[PRE232]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: What we need is both a general implementation of a stack that works for all
    element types as well as a way to easily specialize that stack to a specific element
    type for increased type safety and reduced casting and boxing. Generics give us
    precisely this by allowing us to parameterize the element type. `Stack<T>` has
    the benefits of both `ObjectStack` and `IntStack`. Like `ObjectStack`, `Stack<T>`
    is written once to work *generally* across all types. Like `IntStack`, `Stack<T>`
    is *specialized* for a particular type—the beauty is that this type is `T`, which
    we substitute on the fly.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是一个通用的堆栈实现，可以适用于所有元素类型，并且可以轻松专门化到特定的元素类型以提高类型安全性并减少转型和装箱。通用类型通过允许我们参数化元素类型来实现这一点。`Stack<T>`
    同时具有 `ObjectStack` 和 `IntStack` 的优点。像 `ObjectStack` 一样，`Stack<T>` 一次编写即可*普遍*适用于所有类型。像
    `IntStack` 一样，`Stack<T>` *专门化*于特定类型——其美妙之处在于这种类型是 `T`，我们可以动态替换。
- en: Note
  id: totrans-832
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`ObjectStack` is functionally equivalent to `Stack<object>`.'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObjectStack` 在功能上等同于 `Stack<object>`。'
- en: Generic Methods
  id: totrans-834
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用方法
- en: A generic method declares type parameters within the signature of a method.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 通用方法在方法的签名内声明类型参数。
- en: 'With generic methods, many fundamental algorithms can be implemented in a general-purpose
    way. Here is a generic method that swaps the contents of two variables of any
    type `T`:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 使用通用方法，可以以通用方式实现许多基本算法。以下是一个通用方法示例，用于交换任意类型 `T` 的两个变量的内容：
- en: '[PRE233]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '`Swap<T>` is called as follows:'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `Swap<T>` 如下所示：
- en: '[PRE234]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: 'Generally, there is no need to supply type arguments to a generic method, because
    the compiler can implicitly infer the type. If there is ambiguity, generic methods
    can be called with type arguments as follows:'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，不需要为通用方法提供类型参数，因为编译器可以隐式推断类型。如果存在歧义，可以如下调用通用方法带有类型参数：
- en: '[PRE235]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: Within a generic *type*, a method is not classed as generic unless it *introduces*
    type parameters (with the angle bracket syntax). The `Pop` method in our generic
    stack merely uses the type’s existing type parameter, `T`, and is not classed
    as a generic method.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 在通用*类型*中，除非它*引入*类型参数（使用尖括号语法），否则方法不被归类为通用方法。我们的通用堆栈中的 `Pop` 方法仅使用类型的现有类型参数 `T`，不被归类为通用方法。
- en: 'Methods and types are the only constructs that can introduce type parameters.
    Properties, indexers, events, fields, constructors, operators, and so on cannot
    declare type parameters, although they can partake in any type parameters already
    declared by their enclosing type. In our generic stack example, for instance,
    we could write an indexer that returns a generic item:'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 方法和类型是唯一可以引入类型参数的结构。属性、索引器、事件、字段、构造函数、运算符等无法声明类型参数，尽管它们可以参与其封闭类型已声明的任何类型参数。例如，在我们的通用堆栈示例中，我们可以编写一个索引器来返回通用项：
- en: '[PRE236]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'Similarly, constructors can partake in existing type parameters but not *introduce*
    them:'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，构造函数可以参与现有的类型参数，但不能*引入*它们：
- en: '[PRE237]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: Declaring Type Parameters
  id: totrans-847
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明类型参数
- en: 'Type parameters can be introduced in the declaration of classes, structs, interfaces,
    delegates (covered in [Chapter 4](ch04.html#advanced_chash)), and methods. Other
    constructs, such as properties, cannot *introduce* a type parameter, but they
    can *use* one. For example, the property `Value` uses `T`:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 类型参数可以在类、结构、接口、委托（详见[第4章](ch04.html#advanced_chash)）和方法的声明中引入。其他构造，如属性，不能*引入*类型参数，但可以*使用*类型参数。例如，属性
    `Value` 使用 `T`：
- en: '[PRE238]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'A generic type or method can have multiple parameters:'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 通用类型或方法可以具有多个参数：
- en: '[PRE239]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: 'To instantiate:'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化：
- en: '[PRE240]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'Or:'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE241]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: 'Generic type names and method names can be overloaded as long as the number
    of type parameters is different. For example, the following three type names do
    not conflict:'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 通用类型名称和方法名称可以重载，只要类型参数的数量不同。例如，以下三个类型名称不会冲突：
- en: '[PRE242]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: Note
  id: totrans-858
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: By convention, generic types and methods with a *single* type parameter typically
    name their parameter `T`, as long as the intent of the parameter is clear. When
    using *multiple* type parameters, each parameter is prefixed with `T` but has
    a more descriptive name.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，具有*单一*类型参数的通用类型和方法通常将其参数命名为 `T`，只要参数的意图清晰即可。在使用*多个*类型参数时，每个参数都以 `T` 为前缀，但具有更具描述性的名称。
- en: typeof and Unbound Generic Types
  id: totrans-860
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: typeof 和未绑定的通用类型
- en: 'Open generic types do not exist at runtime: they are closed as part of compilation.
    However, it is possible for an *unbound* generic type to exist at runtime—purely
    as a `Type` object. The only way to specify an unbound generic type in C# is via
    the `typeof` operator:'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 开放泛型类型在运行时不存在：它们作为编译的一部分关闭。然而，未绑定的泛型类型可以在运行时存在，纯粹作为`Type`对象。在 C# 中指定未绑定的泛型类型的唯一方法是通过`typeof`运算符：
- en: '[PRE243]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: Open generic types are used in conjunction with the Reflection API ([Chapter 18](ch18.html#reflection_and_metadata)).
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 开放泛型类型与反射 API（[第18章](ch18.html#reflection_and_metadata)）结合使用。
- en: 'You can also use the `typeof` operator to specify a closed type:'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`typeof`运算符指定一个封闭类型：
- en: '[PRE244]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: 'Or, you can specify an open type (which is closed at runtime):'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以指定一个在运行时关闭的开放类型：
- en: '[PRE245]'
  id: totrans-867
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: The default Generic Value
  id: totrans-868
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认通用值
- en: 'You can use the `default` keyword to get the default value for a generic type
    parameter. The default value for a reference type is `null`, and the default value
    for a value type is the result of bitwise-zeroing the value type’s fields:'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`default`关键字获取泛型类型参数的默认值。引用类型的默认值为`null`，值类型的默认值是对值类型字段进行按位零处理的结果：
- en: '[PRE246]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: 'From C# 7.1, you can omit the type argument for cases in which the compiler
    is able to infer it. We could replace the last line of code with this:'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 7.1开始，可以省略类型参数，这是编译器能够推断的情况。我们可以用以下代码替换最后一行：
- en: '[PRE247]'
  id: totrans-872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: Generic Constraints
  id: totrans-873
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型约束
- en: 'By default, you can substitute a type parameter with any type whatsoever. *Constraints*
    can be applied to a type parameter to require more specific type arguments. These
    are the possible constraints:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，可以用任何类型替换类型参数。*约束*可以应用于类型参数，以要求更具体的类型参数。这些是可能的约束：
- en: '[PRE248]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: 'In the following example, `GenericClass<T,U>` requires `T` to derive from (or
    be identical to) `SomeClass` and implement `Interface1`, and requires `U` to provide
    a parameterless constructor:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`GenericClass<T,U>`要求`T`派生自（或等同于）`SomeClass`并实现`Interface1`，并要求`U`提供无参数构造函数：
- en: '[PRE249]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: You can apply constraints wherever type parameters are defined, in both methods
    and type definitions.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在定义类型参数的地方应用约束，无论是在方法还是类型定义中。
- en: Note
  id: totrans-879
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A *constraint* is a *restriction*; however, the main purpose of type parameter
    constraints is to enable things that would otherwise be prohibited.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: '*约束*是*限制*；然而，类型参数约束的主要目的是启用其他情况下会被禁止的功能。'
- en: For instance, the constraint `T:Foo` lets you treat instances of `T` as `Foo`,
    and the constraint `T:new()` lets you construct new instances of `T`.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，约束`T:Foo`允许您将`T`的实例视为`Foo`，约束`T:new()`允许您构造`T`的新实例。
- en: 'A *base-class constraint* specifies that the type parameter must subclass (or
    match) a particular class; an *interface constraint* specifies that the type parameter
    must implement that interface. These constraints allow instances of the type parameter
    to be implicitly converted to that class or interface. For example, suppose that
    we want to write a generic `Max` method, which returns the maximum of two values.
    We can take advantage of the generic interface defined in the `System` namespace
    called `IComparable<T>`:'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: '*基类约束*指定类型参数必须是某个类的子类（或匹配）；*接口约束*指定类型参数必须实现该接口。这些约束允许将类型参数的实例隐式转换为该类或接口。例如，假设我们想要编写一个通用的`Max`方法，它返回两个值中的最大值。我们可以利用在`System`命名空间中定义的通用接口：'
- en: '[PRE250]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '`CompareTo` returns a positive number if `this` is greater than `other`. Using
    this interface as a constraint, we can write a `Max` method as follows (to avoid
    distraction, null checking is omitted):'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompareTo`如果`this`大于`other`，则返回一个正数。通过此接口作为约束，我们可以编写`Max`方法如下（为避免分散注意力，省略了空值检查）：'
- en: '[PRE251]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: 'The `Max` method can accept arguments of any type implementing `IComparable<T>`
    (which includes most built-in types such as `int` and `string`):'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: '`Max`方法可以接受实现`IComparable<T>`的任何类型的参数（包括大多数内置类型如`int`和`string`）：'
- en: '[PRE252]'
  id: totrans-887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: Note
  id: totrans-888
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: From C# 11, an interface constraint also lets you call static virtual/abstract
    members on that interface (see [“Static virtual/abstract interface members”](ch01.html#static_virtualsolidusabstract-id00040)).
    For example, if interface `IFoo` defines a static abstract method called `Bar`,
    the `T:IFoo` constraint makes it legal to call `T.Bar()`. We pick up this topic
    again in [“Static Polymorphism”](ch04.html#static_polymorphism).
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 11开始，接口约束还允许你在该接口上调用静态虚拟/抽象成员（参见[“静态虚拟/抽象接口成员”](ch01.html#static_virtualsolidusabstract-id00040)）。例如，如果接口`IFoo`定义了一个名为`Bar`的静态抽象方法，则`T:IFoo`约束使得调用`T.Bar()`合法。我们在[“静态多态性”](ch04.html#static_polymorphism)中再次提到这个话题。
- en: 'The *class constraint* and *struct constraint* specify that `T` must be a reference
    type or (non-nullable) value type. A great example of the struct constraint is
    the `System.Nullable<T>` struct (we discuss this class in depth in [“Nullable
    Value Types”](ch04.html#nullable_value_types)):'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: '*类约束* 和 *结构约束* 指定`T`必须是引用类型或（非空）值类型。结构约束的一个很好的例子是`System.Nullable<T>`结构（我们在[“可空值类型”](ch04.html#nullable_value_types)中深入讨论这个类）：'
- en: '[PRE253]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: 'The *unmanaged constraint* (introduced in C# 7.3) is a stronger version of
    a struct constraint: `T` must be a simple value type or a struct that is (recursively)
    free of any reference types.'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: '*未管理约束*（在C# 7.3中引入）是结构约束的一个更强版本：`T`必须是简单值类型或递归地没有任何引用类型的结构。'
- en: 'The *parameterless constructor constraint* requires `T` to have a public parameterless
    constructor. If this constraint is defined, you can call `new()` on `T`:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: '*无参构造函数约束* 要求`T`具有公共的无参构造函数。如果定义了这个约束，你可以在`T`上调用`new()`：'
- en: '[PRE254]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: 'The *naked type constraint* requires one type parameter to derive from (or
    match) another type parameter. In this example, the method `FilteredStack` returns
    another `Stack`, containing only the subset of elements where the type parameter
    `U` is of the type parameter `T`:'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: '*裸类型约束* 要求一个类型参数从另一个类型参数派生（或匹配）。在这个例子中，方法`FilteredStack`返回另一个`Stack`，其中只包含类型参数`U`是类型参数`T`的子集的元素：'
- en: '[PRE255]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: Subclassing Generic Types
  id: totrans-897
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型类型的子类化
- en: 'A generic class can be subclassed just like a nongeneric class. The subclass
    can leave the base class’s type parameters open, as in the following example:'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类可以像非泛型类一样被子类化。子类可以保留基类的类型参数不变，如下面的例子：
- en: '[PRE256]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: 'Or, the subclass can close the generic type parameters with a concrete type:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，子类可以用具体类型关闭泛型类型参数：
- en: '[PRE257]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: 'A subtype can also introduce fresh type arguments:'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 子类型也可以引入新鲜的类型参数：
- en: '[PRE258]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: Note
  id: totrans-904
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Technically, *all* type arguments on a subtype are fresh: you could say that
    a subtype closes and then reopens the base type arguments. This means that a subclass
    can give new (and potentially more meaningful) names to the type arguments that
    it reopens:'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，子类型上的所有类型参数都是新鲜的：你可以说子类型关闭然后重新打开基类型参数。这意味着子类可以为重新打开的类型参数提供新的（可能更有意义的）名称：
- en: '[PRE259]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: Self-Referencing Generic Declarations
  id: totrans-907
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自引用泛型声明
- en: 'A type can name *itself* as the concrete type when closing a type argument:'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类型可以在关闭类型参数时将*自己*命名为具体类型：
- en: '[PRE260]'
  id: totrans-909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: 'The following are also legal:'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 以下也是合法的：
- en: '[PRE261]'
  id: totrans-911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: Static Data
  id: totrans-912
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态数据
- en: 'Static data is unique for each closed type:'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 静态数据对于每个关闭类型是唯一的：
- en: '[PRE262]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: Type Parameters and Conversions
  id: totrans-915
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型参数和转换
- en: 'C#’s cast operator can perform several kinds of conversion, including the following:'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: C#的转型运算符可以执行多种类型的转换，包括以下内容：
- en: Numeric conversion
  id: totrans-917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字转换
- en: Reference conversion
  id: totrans-918
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用转换
- en: Boxing/unboxing conversion
  id: totrans-919
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装箱/拆箱转换
- en: Custom conversion (via operator overloading; see [Chapter 4](ch04.html#advanced_chash))
  id: totrans-920
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义转换（通过运算符重载；参见[第4章](ch04.html#advanced_chash)）
- en: The decision as to which kind of conversion will take place happens at *compile
    time*, based on the known types of the operands. This creates an interesting scenario
    with generic type parameters, because the precise operand types are unknown at
    compile time. If this leads to ambiguity, the compiler generates an error.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 决定将发生哪种类型的转换是在*编译时*进行的，根据操作数的已知类型。这在泛型类型参数方面创建了一个有趣的场景，因为编译时未知精确的操作数类型。如果这导致歧义，编译器会生成错误。
- en: 'The most common scenario is when you want to perform a reference conversion:'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的情况是当你想要执行引用转换时：
- en: '[PRE263]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: 'Without knowledge of `T`’s actual type, the compiler is concerned that you
    might have intended this to be a *custom conversion*. The simplest solution is
    to instead use the `as` operator, which is unambiguous because it cannot perform
    custom conversions:'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 在不知道 `T` 的实际类型的情况下，编译器担心您可能打算进行一个 *自定义转换*。最简单的解决方案是改用 `as` 运算符，因为它是明确的，因为它不能执行自定义转换：
- en: '[PRE264]'
  id: totrans-925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: 'A more general solution is to first cast to `object`. This works because conversions
    to/from `object` are assumed not to be custom conversions, but reference or boxing/unboxing
    conversions. In this case, `StringBuilder` is a reference type, so it must be
    a reference conversion:'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般的解决方案是首先转换为 `object`。这是因为到/从 `object` 的转换被假定不是自定义转换，而是引用或装箱/拆箱转换。在这种情况下，`StringBuilder`
    是一个引用类型，所以必须是一个引用转换：
- en: '[PRE265]'
  id: totrans-927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: 'Unboxing conversions can also introduce ambiguities. The following could be
    an unboxing, numeric, or custom conversion:'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 拆箱转换也可能引入歧义。以下内容可能是一个拆箱、数值或自定义转换：
- en: '[PRE266]'
  id: totrans-929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: 'The solution, again, is to first cast to `object` and then to `int` (which
    then unambiguously signals an unboxing conversion in this case):'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案再次是先转换为 `object`，然后再转换为 `int`（这在这种情况下明确地表示一个拆箱转换）：
- en: '[PRE267]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: Covariance
  id: totrans-932
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协变
- en: Assuming `A` is convertible to `B`, `X` has a covariant type parameter if `X<A>`
    is convertible to `X<B>`.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `A` 可转换为 `B`，则如果 `X<A>` 可转换为 `X<B>`，则 `X` 具有协变类型参数。
- en: Note
  id: totrans-934
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: With C#’s notion of covariance (and contravariance), “convertible” means convertible
    via an *implicit reference conversion*—such as `A` *subclassing* `B`, or `A` *implementing*
    `B`. Numeric conversions, boxing conversions, and custom conversions are not included.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 的协变（和逆变）概念中，“可转换”意味着可以通过 *隐式引用转换* 进行转换，例如 `A` *子类化* `B`，或者 `A` *实现* `B`。数值转换、装箱转换和自定义转换不包括在内。
- en: 'For instance, type `IFoo<T>` has a covariant `T` if the following is legal:'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，类型 `IFoo<T>` 如果以下内容合法，则具有协变的 `T`：
- en: '[PRE268]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: Interfaces permit covariant type parameters (as do delegates; see [Chapter 4](ch04.html#advanced_chash)),
    but classes do not. Arrays also allow covariance (`A[]` can be converted to `B[]`
    if `A` has an implicit reference conversion to `B`) and are discussed here for
    comparison.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 接口允许协变类型参数（委托也允许；参见 [第四章](ch04.html#advanced_chash)），但类不允许。数组也允许协变（如果 `A` 对
    `B` 有隐式引用转换，则 `A[]` 可以转换为 `B[]`），并且在此处进行了比较讨论。
- en: Note
  id: totrans-939
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Covariance and contravariance (or simply “variance”) are advanced concepts.
    The motivation behind introducing and enhancing variance in C# was to allow generic
    interface and generic types (in particular, those defined in .NET, such as `IEnumerable<T>`)
    to work more as you’d expect. You can benefit from this without understanding
    the details behind covariance and contravariance.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 协变和逆变（或简称“变异”）是高级概念。引入和增强 C# 中协变和逆变的动机是为了使泛型接口和泛型类型（特别是在 .NET 中定义的那些，比如 `IEnumerable<T>`）能更符合您的预期工作。您可以在不理解协变和逆变的详细信息的情况下从中受益。
- en: Variance is not automatic
  id: totrans-941
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协变不是自动的
- en: 'To ensure static type safety, type parameters are not automatically variant.
    Consider the following:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保静态类型安全，类型参数不会自动变异。考虑以下情况：
- en: '[PRE269]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: 'The following fails to compile:'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容无法编译通过：
- en: '[PRE270]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: 'That restriction prevents the possibility of runtime failure with the following
    code:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 该限制阻止了以下代码可能导致运行时失败的可能性：
- en: '[PRE271]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: 'Lack of covariance, however, can hinder reusability. Suppose, for instance,
    that we wanted to write a method to `Wash` a stack of animals:'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，缺乏协变可能会阻碍可重用性。例如，假设我们想编写一个方法来 `Wash` 一堆动物：
- en: '[PRE272]'
  id: totrans-949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: 'Calling `Wash` with a stack of bears would generate a compile-time error. One
    workaround is to redefine the `Wash` method with a constraint:'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一堆熊调用 `Wash` 将会生成一个编译时错误。一种解决方法是重新定义带有约束条件的 `Wash` 方法：
- en: '[PRE273]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: 'We can now call `Wash` as follows:'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以按以下方式调用 `Wash`：
- en: '[PRE274]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: Another solution is to have `Stack<T>` implement an interface with a covariant
    type parameter, as you’ll see shortly.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是让 `Stack<T>` 实现一个具有协变类型参数的接口，您很快将会看到。
- en: Arrays
  id: totrans-955
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组
- en: 'For historical reasons, array types support covariance. This means that `B[]`
    can be cast to `A[]` if `B` subclasses `A` (and both are reference types):'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 基于历史原因，数组类型支持协变。这意味着如果 `B` 是 `A` 的子类（且两者都是引用类型），则 `B[]` 可以转换为 `A[]`：
- en: '[PRE275]'
  id: totrans-957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: 'The downside of this reusability is that element assignments can fail at runtime:'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 这种可重用性的缺点是元素赋值可能在运行时失败：
- en: '[PRE276]'
  id: totrans-959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: Declaring a covariant type parameter
  id: totrans-960
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明一个协变类型参数
- en: Type parameters on interfaces and delegates can be declared covariant by marking
    them with the `out` modifier. This modifier ensures that, unlike with arrays,
    covariant type parameters are fully type-safe.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 接口和委托上的类型参数可以通过标记它们为`out`来声明为协变。该修饰符确保与数组不同，协变类型参数是完全类型安全的。
- en: 'We can illustrate this with our `Stack<T>` class by having it implement the
    following interface:'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过我们的`Stack<T>`类来说明这一点，通过实现以下接口：
- en: '[PRE277]'
  id: totrans-963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: 'The `out` modifier on `T` indicates that `T` is used only in *output positions*
    (e.g., return types for methods). The `out` modifier flags the type parameter
    as *covariant* and allows us to do this:'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`T`上的`out`修饰符表明，`T`仅在*输出*位置（例如，方法的返回类型）中使用。`out`修饰符标志着类型参数为*协变*，并允许我们这样做：
- en: '[PRE278]'
  id: totrans-965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: The conversion from `bears` to `animals` is permitted by the compiler—by virtue
    of the type parameter being covariant. This is type-safe because the case the
    compiler is trying to avoid—pushing a `Camel` onto the stack—can’t occur, because
    there’s no way to feed a `Camel` *in*to an interface where `T` can appear only
    in *out*put positions.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器允许从`bears`到`animals`的转换，因为类型参数是协变的。这是类型安全的，因为编译器试图避免的情况——将`Camel`推入堆栈——不可能发生，因为没有方法将`Camel`*输入*到仅能在*输出*位置中出现`T`的接口中。
- en: Note
  id: totrans-967
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Covariance (and contravariance) in interfaces is something that you typically
    *consume*: it’s less common that you need to *write* variant interfaces.'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 接口中的协变（和逆变）通常是*消费*的概念：相比之下，您很少需要*编写*变体接口。
- en: Warning
  id: totrans-969
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Curiously, method parameters marked as `out` are not eligible for covariance,
    due to a limitation in the CLR.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，由于CLR的限制，标记为`out`的方法参数不符合协变条件。
- en: 'We can leverage the ability to cast covariantly to solve the reusability problem
    described earlier:'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用协变转型来解决前面描述的可重用性问题：
- en: '[PRE279]'
  id: totrans-972
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: Note
  id: totrans-973
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `IEnumerator<T>` and `IEnumerable<T>` interfaces described in [Chapter 7](ch07.html#collections-id00055)
    have a covariant `T`. This allows you to cast `IEnumerable<string>` to `IEnumerable<object>`,
    for instance.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html#collections-id00055)中描述的`IEnumerator<T>`和`IEnumerable<T>`接口具有协变的`T`。这允许您将`IEnumerable<string>`转换为`IEnumerable<object>`，例如。
- en: The compiler will generate an error if you use a covariant type parameter in
    an *input* position (e.g., a parameter to a method or a writable property).
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在*输入*位置使用协变类型参数（例如，方法的参数或可写属性），编译器将生成错误。
- en: Note
  id: totrans-976
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Covariance (and contravariance) works only for elements with *reference conversions*—not
    *boxing conversions*. (This applies both to type parameter variance and array
    variance.) So, if you wrote a method that accepted a parameter of type `IPoppable<object>`,
    you could call it with `IPoppable<string>` but not `IPoppable<int>`.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 协变（和逆变）仅适用于*引用转换*的元素——而非*装箱转换*（这既适用于类型参数的方差，也适用于数组的方差）。因此，如果您编写了一个接受类型为`IPoppable<object>`的参数的方法，则可以使用`IPoppable<string>`但不能使用`IPoppable<int>`来调用它。
- en: Contravariance
  id: totrans-978
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逆变
- en: 'We previously saw that, assuming that `A` allows an implicit reference conversion
    to `B`, a type `X` has a covariant type parameter if `X<A>` allows a reference
    conversion to `X<B>`. *Contravariance* is when you can convert in the reverse
    direction—from `X<B>` to `X<A>`. This is supported if the type parameter appears
    only in *input* positions and is designated with the `in` modifier. Extending
    our previous example, suppose the `Stack<T>` class implements the following interface:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到，假设`A`允许隐式引用转换到`B`，如果类型`X<A>`允许将引用转换到`X<B>`，则类型`X`具有协变类型参数。*逆变*是指可以反向转换——从`X<B>`到`X<A>`。如果类型参数仅在*输入*位置中出现并带有`in`修饰符，则支持此操作。扩展我们之前的示例，假设`Stack<T>`类实现了以下接口：
- en: '[PRE280]'
  id: totrans-980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: 'We can now legally do this:'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以合法地执行此操作：
- en: '[PRE281]'
  id: totrans-982
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: No member in `IPushable` *outputs* a `T`, so we can’t get into trouble by casting
    `animals` to `bears` (there’s no way to `Pop`, for instance, through that interface).
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: '`IPushable`中没有任何成员*输出*`T`，因此我们无法通过该接口将`animals`转换为`bears`（例如，无法通过该接口进行`Pop`操作）。'
- en: Note
  id: totrans-984
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Our `Stack<T>` class can implement both `IPushable<T>` and `IPoppable<T>`—despite
    `T` having opposing variance annotations in the two interfaces! This works because
    you must exercise variance through the interface and not the class; therefore,
    you must commit to the lens of either `IPoppable` or `IPushable` before performing
    a variant conversion. This lens then restricts you to the operations that are
    legal under the appropriate variance rules.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Stack<T>`类可以同时实现`IPushable<T>`和`IPoppable<T>`—尽管`T`在这两个接口中具有相反的变异注释！这是因为你必须通过接口来实现变异，而不是类；因此，在执行变体转换之前，你必须承诺使用`IPoppable`或`IPushable`的视角。然后，这个视角限制了你只能在适当的变异规则下执行合法的操作。
- en: 'This also illustrates why *classes* do not allow variant type parameters: concrete
    implementations typically require data to flow in both directions.'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 这也说明了为什么*类*不允许变异类型参数：具体的实现通常要求数据在两个方向上流动。
- en: 'To give another example, consider the following interface, defined in the `System`
    namespace:'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 再举一个例子，考虑在`System`命名空间中定义的以下接口：
- en: '[PRE282]'
  id: totrans-988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: 'Because the interface has a contravariant `T`, we can use an `IComparer<**object**>`
    to compare two *strings*:'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 因为接口具有逆变`T`，我们可以使用`IComparer<**object**>`来比较两个*字符串*：
- en: '[PRE283]'
  id: totrans-990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: Mirroring covariance, the compiler will report an error if you try to use a
    contravariant type parameter in an output position (e.g., as a return value or
    in a readable property).
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 与协变相反，如果您尝试在输出位置（例如作为返回值或可读属性中）使用逆变类型参数，编译器将报告错误。
- en: C# Generics Versus C++ Templates
  id: totrans-992
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#泛型与C++模板对比
- en: C# generics are similar in application to C++ templates, but they work very
    differently. In both cases, a synthesis between the producer and consumer must
    take place in which the placeholder types of the producer are filled in by the
    consumer. However, with C# generics, producer types (i.e., open types such as
    `List<T>`) can be compiled into a library (such as *mscorlib.dll*). This works
    because the synthesis between the producer and the consumer that produces closed
    types doesn’t actually happen until runtime. With C++ templates, this synthesis
    is performed at compile time. This means that in C++ you don’t deploy template
    libraries as *.dll*s—they exist only as source code. It also makes it difficult
    to dynamically inspect, let alone create, parameterized types on the fly.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: C#泛型与C++模板在应用上相似，但它们的工作方式大不相同。在两种情况下，都需要在生产者和消费者之间进行综合，其中生产者的占位类型由消费者填充。然而，对于C#泛型，生产者类型（例如`List<T>`这样的开放类型）可以编译为库（例如*mscorlib.dll*）。这是因为生产者和消费者之间在运行时实际上并不进行生成闭合类型的综合。而对于C++模板，这种综合是在编译时执行的。这意味着在C++中，你不会将模板库部署为*.dll*文件——它们仅存在于源代码中。这也使得动态检查甚至创建参数化类型变得困难。
- en: 'To dig deeper into why this is the case, consider again the `Max` method in
    C#:'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入探讨这种情况背后的原因，再次考虑C#中的`Max`方法：
- en: '[PRE284]'
  id: totrans-995
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: Why couldn’t we have implemented it like this?
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不能这样实现呢？
- en: '[PRE285]'
  id: totrans-997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: 'The reason is that `Max` needs to be compiled once and work for all possible
    values of `T`. Compilation cannot succeed because there is no single meaning for
    `>` across all values of `T`—in fact, not every `T` even has a `>` operator. In
    contrast, the following code shows the same `Max` method written with C++ templates.
    This code will be compiled separately for each value of `T`, taking on whatever
    semantics `>` has for a particular `T`, and failing to compile if a particular
    `T` does not support the `>` operator:'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是`Max`需要编译一次，并且适用于`T`的所有可能值。编译无法成功，因为对于所有`T`的值来说，`>`都没有单一的含义——事实上，并不是每个`T`都有`>`运算符。相比之下，以下代码展示了用C++模板编写的相同`Max`方法。这段代码将为每个`T`的值单独编译，承担特定`T`所具有的`>`运算符的任何语义，并在特定`T`不支持`>`运算符时无法编译通过：
- en: '[PRE286]'
  id: totrans-999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: ^([1](ch03.html#ch01fn5-marker)) The reference type can also be `System.ValueType`
    or `System.Enum` ([Chapter 6](ch06.html#dotnet_fundamentals)).
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch03.html#ch01fn5-marker)) 参考类型也可以是`System.ValueType`或`System.Enum`（[第6章](ch06.html#dotnet_fundamentals)）。
