- en: Chapter 5\. Higher-Order Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章。高阶函数
- en: Welcome back my friends to the show that never ends.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎回到我的朋友们，这场永无止境的表演。
- en: This chapter, we’re looking at uses for higher-order functions. I’m going to
    look at novel ways to use them in C# to save yourself effort, and to make code
    that is less likely to fail.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章，我们将探讨高阶函数的用途。我将探讨在C#中使用它们的新颖方式，以节省您的工作量，并使代码不太可能失败。
- en: But, what *are* Higher-order functions?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，*什么是*高阶函数呢？
- en: 'Higher-order Functions is a slightly odd name for something very simple. In
    fact you’ve likely been using them for some time if you’ve spent much time working
    with LINQ. They come in two flavors, here’s the first:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数对于一些非常简单的事情来说是一个稍微奇怪的名字。事实上，如果你花了很多时间使用LINQ，你很可能已经在使用它们了。它们有两种风味，这是第一种：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Passed into the `Where` function there is an arrow expression - which is just
    a shorthand for writing out an unnamed function. The long-hand version would look
    like this:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 传递到`Where`函数中的是一个箭头表达式 - 这只是一种用于编写匿名函数的简写。长格式版本将如下所示：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So here, the function has been passed around as the parameter to another function,
    to be executed elsewhere inside it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这里，函数已作为参数传递给另一个函数，在其内部的其他地方执行。
- en: 'This is another example of the use of higher-order functions:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是高阶函数的另一个使用示例：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice here that there are two arrows, not one. We’re taking an integer *x*
    and from that returning a new function. In that new function references to *x*
    will be filled in with whatever was provided when MakeAddFunc was called originally.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里有两个箭头，而不是一个。我们正在获取一个整数 *x*，并从中返回一个新函数。在该新函数中，对 *x* 的引用将使用在最初调用MakeAddFunc时提供的任何内容填充。
- en: 'For example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By passing 10 into `MakeAddFunc` in the example above, I created a new function
    whose function is simply to add 10 to whatever addtional integer you pass into
    it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将10传递到`MakeAddFunc`中，在上面的示例中，我创建了一个新函数，其功能只是将10添加到您传递给它的任何其他整数中。
- en: 'In short a higher-order function is a function with one or more of the following
    properties:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，高阶函数是具有以下一项或多项属性的函数：
- en: Accepts a function as a parameter
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受一个函数作为参数
- en: Returns a function as its return type
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数作为其返回类型返回
- en: In C# this is all typically done with either a `Func` (for functions with a
    return type) or `Action` (for functions that return void) delegate types.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，这通常通过`Func`（用于具有返回类型的函数）或`Action`（用于返回void的函数）委托类型完成。
- en: It’s a fairly simple idea, and even easier to implement - but the effect they
    can have on your codebase is incredible.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的想法，甚至更容易实现 - 但它们对你的代码库可能产生的影响是不可思议的。
- en: In this chapter I’m going to walk through ways of using Higher-Order Functions
    to improve your daily coding.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将介绍如何使用高阶函数来改进您的日常编码方式。
- en: I’ll also be looking quite a bit into a next-level usage of Higher-Order functions
    called Combinators. These enable passing around functions in a way that creates
    a more complex - and useful - behavior. They’re called that incidentally, because
    they originate from a mathematical technique called Combinatory Logic. You won’t
    need to worry about ever hearing that term again, or about any references to advanced
    maths - I’m not going there. It’s just in case you were curious…​
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将深入研究称为组合子的高阶函数的下一级用法。这些允许以一种创建更复杂和有用行为的方式传递函数。它们之所以被称为组合子，是因为它们源自一种称为组合逻辑的数学技术。你以后不需要担心再听到这个术语，或者关于任何高级数学的引用
    - 我不会去那里。只是以防你好奇...​
- en: A Problem Report
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题报告
- en: To get started, we’ll look at a bit of problem code. Let’s imagine that your
    company have asked you for a function to take a data store of some kind (an XML
    file, a JSON file, who knows. Doesn’t matter), summarise how many there are of
    each possible value, then transmit that data on to somewhere else. On top of that,
    they want a separate message to be sent in the event that no data was found at
    all. I run a really, really loose ship, so let’s keep things fun, and imagine
    you work for the Evil Galactic Empire™ and you are cataloguing Rebel Alliance
    ships on your radar.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们将查看一些问题代码。假设您的公司要求您编写一个函数来获取某种数据存储（XML文件、JSON文件，谁知道。无所谓），总结每种可能值的数量，然后将该数据传输到其他地方。除此之外，他们希望在找不到任何数据时发送一个单独的消息。我管理一个非常宽松的公司，所以让我们保持有趣，想象你在邪恶银河帝国™工作，并且你正在对你的雷达上的反抗联盟飞船进行分类。
- en: 'The code might look something like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可能如下所示：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is fine, isn’t it? Isn’t it? Well, think about this scenario. You’re sitting
    at your desk, eating your daily pot noodle^([1](ch05.html#idm45400867135648)),
    when you notice that - Jurassic Park style - there is a rhythmic ripple appearing
    in your coffee. This signals the arrival of your worst nightmare. Your boss! Let’s
    imagine that your boss is - thinking totally at random here - a tall, deep-voiced
    gentleman in a black cape and with appauling asthma. He also really hates it when
    people displease him. *Really* hates it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这没问题，对吧？对吧？好吧，想想这种情景。你坐在桌前，吃着你的每日速食面^([1](ch05.html#idm45400867135648))，突然发现——就像《侏罗纪公园》一样——你的咖啡里开始有了节奏感的涟漪。这意味着你的噩梦来了。你的老板！让我们假设你的老板是——我随便说的——一个高个子、深沉嗓音的绅士，穿着黑色斗篷，患有可怕的哮喘。而且他真的讨厌人们惹他生气。*非常*讨厌。
- en: He’s happy with the first function you created. For this you can breath a sigh
    of relief. But now he wants a second function. This one is going to create another
    summary, but this time of the level of weaponry in each ship. Whether they are
    unarmed, lightly armed, heavily armed or capable of destroying planets. That sort
    of thing.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 他对你创建的第一个函数感到满意。你可以松一口气了。但现在他想要第二个函数。这个函数将创建另一个摘要，但这次是关于每艘飞船的武器水平。无论它们是无武装、轻装、重装还是能毁灭行星的。那种情况。
- en: 'Easy, you think. The boss will be so impressed with how quickly I do this.
    So, you do what seems easiest `Ctrl+C`, then `Ctrl+V` to copy & paste the original,
    change the name, change the property you’re summarising, and you end up with something
    like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 简单啊，你想。老板会对我多快地完成这个任务感到印象深刻的。所以，你做了看起来最简单的事情 `Ctrl+C`，然后 `Ctrl+V` 复制和粘贴原始内容，改变名称，改变你要总结的属性，最后得到了这样的东西：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Five seconds of work, and a day or two of leaning on your figurative shovel
    with the odd complaint out-loud of how hard the work is here, all while you secretly
    work on today’s Wordle. Job done, and slaps on the back all round, right? Right?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 五秒钟的工作，一天或两天在你象征性的铲子上使劲，还时不时地抱怨这里的工作有多难，而你暗中又在玩今天的Wordle。完成任务，到处拍背，对吧？对吧？
- en: Well…​.There are a couple of problems with this approach.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯……这种方法存在几个问题。
- en: First, let’s think about unit testing. As good, upstanding code citizens, we
    unit test all of our code. Imagine we’d unit tested the snot out of that first
    function. When we copied & pasted the second in, what was the level of unit test
    coverage at that point?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑单元测试。作为优秀的、正直的代码公民，我们对所有的代码进行单元测试。想象一下，我们对第一个函数进行了彻底的单元测试。当我们复制和粘贴第二个函数时，此时单元测试覆盖率是多少呢？
- en: I’ll give you a clue - it was between zero and zero. You could copy and paste
    the tests too, and that would be fine, but that’s now an awful lot more code that
    we’re copying and pasting every time.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我给你一个提示——它介于零和零之间。你也可以复制并粘贴测试，这也可以，但这样我们每次复制和粘贴的代码量就更多了。
- en: This isn’t an approach that scales up well. What if our boss wanted another
    function after this one, and another, and another. What if we ended being asked
    for 50 functions? Or 100?!? That’s a lot of code. You’d end up with something
    thousands of lines long, not something I’d be keen to support.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不适合扩展。如果我们的老板在这之后还想要另一个函数，再一个，再一个。如果我们最终被要求做50个函数？或者100个？！那就是大量的代码。你最终会得到一些上千行长的东西，这不是我乐意支持的。
- en: It gets worse when you consider something that happened to me near the beginnning
    of my career. I was working for an organisation that had a desktop application
    that carried out a series of complex calculations for each customer, based on
    a few input parameters. Each year, the rules changed, but the old rule bases had
    to be replicated because it might be necessary to see what would have been calculated
    in a previous year.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当你考虑到我职业生涯初期发生的一件事情时，情况变得更糟。我曾在一家组织工作，他们有一个桌面应用程序，根据几个输入参数为每个客户进行一系列复杂的计算。每年规则都会改变，但旧的规则基础必须复制，因为可能需要查看以前年份的计算结果。
- en: So, the folks that had been developing the app before I joined the team had
    copied a whole chunk of code every year. Made a few little changes, added a link
    somewhere to the new version, and voilà. Job done.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在我加入团队之前，一直在开发该应用程序的人每年都复制了一大块代码。做了一些小改动，然后在某处添加了指向新版本的链接，完成了。
- en: I was tasked with making these annual changes one year, so off I went, young,
    innocent and raring to make a difference to the world. When I was making my changes,
    I noticed something odd. There was a weird error with a field that wasn’t anything
    to do with my changes. I fixed the bug, but then a thought occurred to me that
    made my heart sink…​
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有一年，我被委派去做这些年度更改，于是我开始了，年轻、无邪，怀揣改变世界的热情。在进行更改时，我注意到了一些奇怪的现象。有一个与我的更改毫无关系的字段出现了错误。我修复了这个错误，但接着我产生了一个让我心情沉重的想法…​
- en: I checked every previous version of the codebase for each previous year and
    found that nearly all of them had the same bug. It had been introduced about 10
    years ago, and every devleoper since then had replicated the bug precisely. So,
    I had to fix it 10 times over, increasing the testing effort by an order of magnitude.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我查看了每个之前版本的代码库，每一年的版本，几乎所有的版本都有同样的bug。这个bug大约10年前引入，从那以后每位开发者都精确复制了这个bug。因此，我不得不多次修复它，使得测试工作的工作量成倍增加。
- en: With this in mind, ask yourself - did copying and pasting really save you any
    time? I routinely work on apps that stay in existence for decades, and which show
    no sign of being put out to pasture any time soon.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 思考一下这个问题——复制粘贴真的节省了你多少时间吗？我经常处理那些可能在几十年后仍然存在且毫无放弃迹象的应用程序。
- en: When I decide where to make time-saving measures for coding work, I try and
    look over the whole life of the application, and try to keep in mind what the
    consequences might be for a decision a decade on.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我决定在编码工作中节省时间时，我尝试审视整个应用程序的生命周期，并考虑一个决策在十年后可能产生的后果。
- en: To return to the subject at hand, how would I have used Higher-order functions
    to solve this problem? Well, are you sitting comfortably? Then I’ll begin…​
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要回到我们的主题，我如何使用高阶函数来解决这个问题？好了，你们准备好了吗？那么，我就开始说了…​
- en: Thunks
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Thunks
- en: A bundle of code that carries a stored calculation, which can be executed later
    on request is properly known as a *Thunk*. Same as the sound a plank of wood makes
    when it smacks you in the side of the head. There’s an argument to be had as to
    whether that hurts your head more or less than reading this book!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一个代码束，其中包含一个存储计算的存储计算，可以在请求时执行，被正式称为*Thunk*。就像一块木板打在你头上发出的声音一样。关于这是否比读这本书更伤脑筋，这是一个有争议的问题！
- en: Here in C#, `Func` delegates are again the way that we’d implement this. We
    can write functions that take `Func` delegates as parameter values, to allow for
    certain calculations in our function to be left effectively blank, and which can
    be filled in from the outside world, via an arrow function.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，我们可以使用`Func`委托来实现这一点。我们可以编写接受`Func`委托作为参数值的函数，以允许我们的函数中某些计算留空，这些空缺可以通过外部世界，通过箭头函数来填补。
- en: Although there is a serious, proper, mathematical term for this technique, I
    like calling them doughnut functions, because it’s more descriptive. They’re like
    normal functions, but with a hole in the middle! A hole I’d ask someone else to
    fill in with the necessary functionality.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个技术有一个严肃的、正式的数学术语，我喜欢称之为“甜甜圈函数”，因为这更具描述性。它们就像普通函数，但中间有一个空洞！这个空洞我会请别人填补必要的功能。
- en: 'This is one potential way to refactor the problem report function:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是重构问题报告函数的一种潜在方式：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this, revised version, we’ve gained a few advantages.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个修订版本中，我们获得了一些优势。
- en: Firstly, the number of additional lines per new report is just one! That’s a
    much tidier codebase, and easier to read. The code is kept very close to the intent
    of the new function - i.e. be the same as the first, but with a few changes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，每个新报告的额外行数仅为一行！这使得代码库更加整洁，更易于阅读。代码与新函数的意图非常接近——即与第一个函数相同，但有一些变化。
- en: Secondly, after unit testing function 1, when we create function 2, the unit
    test level is still close to 100%. The only difference functionally is the report
    name, and the field to be summarised.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在对第一个功能进行单元测试后，当我们创建第二个功能时，单元测试水平仍然接近100%。从功能上讲，唯一的区别是报告名称和要汇总的字段。
- en: Lastly, any enhancements or bug fixes to the base function will be shared between
    all report functions simultaniously. That’s a lot of benefit for relatively little
    effort. There’s also a very high degree of confidence that if one report function
    tests well, that all of the others will be the same.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对基础函数的任何增强或错误修复将同时应用于所有报表函数。这对相对较少的工作量来说带来了很多好处。还有非常高的信心度，如果一个报表函数测试通过了，其他所有报表函数也将会是一样。
- en: One could actually walk away from this version happy. But, if it were me, I’d
    actually consider going a step further and exposing the private version with its
    `Func` parameters on the interface for whatever wants to use it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能会对这个版本感到满意。但如果是我，我实际上会考虑进一步，将带有其`Func`参数的私有版本暴露在接口上，供希望使用它的任何人使用。
- en: 'Something like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The implementation would be the private function from the previous code sample
    made public instead. This way there’s no need to ever modify the interface or
    implementing class again, at least not if all that’s wanted is an additional report
    for a different field.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 实现方式是将前面代码示例中的私有函数公开化。这样一来，至少在希望为不同字段添加额外报告时，不需要修改接口或实现类。
- en: This makes the business of creating reports something that can be done entirely
    arbitrarily by whatever code module consumes this class. It saves a lot of the
    burdon of maintaining the report set from developers like ourselves, and puts
    it more in the hands of the teams that care about the reports themselves. Imagine
    the sheer number of Requests for Change that will now never need to come to a
    development team.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得创建报告的工作完全可以由任何消耗这个类的代码模块任意完成。这样做不仅节省了我们这样的开发者在维护报告集方面的大量负担，而且更多地放在关心报告本身的团队手中。想象一下，现在不再需要向开发团队提交多少变更请求。
- en: If you wanted to be really wild, you could expose further `Func` parameters
    as `Func<ReportLine,string>` to allow users of the report class to define custom
    formatting. You could also use `Action` parameters to allow for bespoke logging
    or event handling. This is just in my silly, made-up reporting class. The possibilities
    for the use of higher-order functions in this way are endless.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的想要野心勃勃，你可以进一步将`Func`参数公开为`Func<ReportLine,string>`，以允许报告类的用户定义自定义格式。你也可以使用`Action`参数来实现定制的日志记录或事件处理。这只是我那个傻乎乎、虚构的报告类。通过这种方式使用高阶函数的可能性是无限的。
- en: Despite being a functional programming feature, this is keeping us squarely
    in line with the *O* of the SOLID Principles of Object-Oriented design^([2](ch05.html#idm45400866574816))
    - the Open/Closed principle, which states a module should be open to extension,
    but closed to modification.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个功能编程的特性，但这确实使我们牢牢地遵循了面向对象设计的SOLID原则中的*O* - 开闭原则^([2](ch05.html#idm45400866574816))，即模块应该对扩展开放，对修改关闭。
- en: It’s surprising how well OO and functional programming can complement each other
    in C#. I often think it’s important for developers to make sure they are adept
    at both paradigms, so they know how to use them together effectively.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，在C#中，面向对象和功能编程如何能够互补。我经常认为，开发人员应该确保自己在两种范式中都能够熟练运用，这样才能有效地将它们结合使用。
- en: Chaining Functions
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数链
- en: Allow me to introduce you to the best friend you never knew you needed - the
    Map function. This function is also commonly referred to as Chain and Pipe, but
    for the sake of consistency, we’ll call it Map throughout this book. I’m afraid
    that there’s a tendency for a lot of functional structures to have many names
    in use, depending on the programming language and implementation. I’ll try and
    point out whenever this is the case.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请允许我介绍你可能从未意识到需要的最好朋友 - Map函数。这个函数通常也被称为Chain和Pipe，但为了保持一致性，在本书中我们将统一称它为Map。恐怕很多功能性结构会根据编程语言和实现方式有很多不同的名称，我会尽量在适当时指出。
- en: Now, I’m British, and there’s a cliché about British people that we like talking
    about the weather. It’s entirely true. Our country is one that’s been known to
    go through 4 seasons in a single day, so the weather is a constant source of fascination
    to us.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我是英国人，有一个关于英国人的俗语是我们喜欢谈论天气。这完全是真的。我们的国家有时一天内会经历四季，所以天气对我们来说是一个持续引发兴趣的话题。
- en: 'I used to work for an American company, once upon a time, and when I did, the
    topic of conversation with my colleagues over video call would often turn inevitably
    to the subject of the weather. They’d tell me that the temperature outside was
    around 100 degrees. I work in celcius, so to me this sounds rather suspiciously
    like the boiling point of water. Given that my colleagues were not screamning
    as their blood boiled away into steam, I suspected something else was at work.
    It was, of course, that they were working in Fahrenheit, so I had to convert this
    to something I understood with the following formula:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经我为一家美国公司工作，那时候，当我与同事通过视频通话讨论天气时，话题往往不可避免地转向了天气。他们告诉我外面的温度大约是 100 度。我使用摄氏度工作，所以对我来说这听起来非常像水的沸点。考虑到我的同事并没有因为血液沸腾而尖叫，我怀疑是其他因素在起作用。当然，他们使用的是华氏度，因此我需要将其转换为我理解的单位，用以下公式：
- en: subtract 32
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减去 32
- en: Then, multiply by 5
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，乘以 5
- en: Then, divide by 9
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，除以 9
- en: Which gives a temperature in Celcius of around 38 degrees, which is warm and
    toasty, but for the most part safe for human life.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出大约 38 度的摄氏温度，温暖而舒适，对于人类生活大多数时间是安全的。
- en: 'How could I code this process in exactly that multi-step operation, then finish
    by returning a formatted string? I *could* stick it all together into a single
    line like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我如何在完全这种多步操作中编码这个过程，然后返回一个格式化的字符串呢？我*可以*将它们全部拼接成一行，就像这样：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Not very readable though, is it? Honestly, I probably wouldn’t make too much
    fuss about that in production code, but I’m demonstrating a technique, and I don’t
    want to get bogged down, so bear with me.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是很易读，对吧？说实话，在实际编码中，我可能不会对此太过挑剔，但我正在展示一种技术，不想深陷其中，所以请耐心等待。
- en: 'The multi-step way to write this out is like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 编写这个多步骤操作的方式如下：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is much more readable, and easier to maintain, but it still has an issue.
    We’re creating variables that are essential intended to be used a single time
    and then thrown away. In this little function it’s not terribly relevant, but
    what if this were a gigantic thousand-line function? What if instead of a little
    decimal variable like these, there was a large, complex object instead? All the
    way down at line 1000, that variable - which is never intended to be used again
    - is still in scope, and holding up memory. It’s also a little messy to create
    a variable you aren’t planning to make any use of beyond the next line. This is
    where Map comes in.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更易读，更易于维护，但仍然存在一个问题。我们正在创建打算仅使用一次然后丢弃的变量。在这个小函数中，这并不是太重要，但如果这是一个庞大的千行函数呢？如果不是这些小小的十进制变量，而是一个大型复杂对象呢？在第
    1000 行，那个不打算再次使用的变量仍然在作用域中，并占用内存。创建一个在下一行之后不打算再使用的变量也有点混乱。这就是 Map 发挥作用的地方。
- en: Map is somewhat like the LINQ `Select` function, except instead of operating
    on each element of an Enumerable, it operates on an object. Any object. You pass
    it a Lambda arrow function just the same as with `Select` except that your *x*
    parameter refers to the base object. If you applied it to an Enumerable, the *x*
    parameter would refer to the entire enumerable, not indivudual elements thereof.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Map 类似于 LINQ `Select` 函数，但不是作用于可枚举的每个元素，而是作用于对象。任何对象。你传递一个 Lambda 箭头函数，方式与 `Select`
    相同，只是你的 *x* 参数指的是基础对象。如果你将其应用于可枚举对象，*x* 参数将指整个可枚举对象，而不是其中的单个元素。
- en: 'Here’s what my modified Fahrenheit conversion would look:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我修改后的华氏转摄氏度函数的样子：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Same exact functionality, same friendly, multi-stage operation, but no throw-away
    variables. Each of those arrow functions is executed, then once completed, their
    contents are subject for Garbage Collection. The decimal *x* that is multiplied
    by 5 is subject for disposal when the next arrow function takes a copy of its
    result and divides that by 9.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 完全相同的功能，友好的多阶段操作，但没有丢弃的变量。每个箭头函数执行后，它们的内容就会被垃圾回收。被乘以 5 的十进制 *x* 在下一个箭头函数获取其结果并将其除以
    9 时，也将被处理掉。
- en: 'Here’s how you implement Map:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现 Map 的方法：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It’s tiny, isn’t it? Despite that, I use this partiular method quite a lot.
    Whenever I want to do a multi-step transformaton of data. It makes it easier to
    convert whole function bodies into simple arrow functions, like my Map-based FahrenheitToCelcius
    function, above.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 它很小，不是吗？尽管如此，我经常使用这种特定方法。每当我想要对数据进行多步转换时，这使得将整个函数体转换为简单的箭头函数变得更容易，就像我上面基于 Map
    的 FahrenheitToCelcius 函数一样。
- en: There are far more advanced versions of this method, which includes things like
    error handling, and which I’ll be getting onto in Chapter 7\. For now though,
    this is a fantastic little toy that you can start playing with right away. Uncle
    Simon’s early Christmas gift to you. Ho, ho, ho.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法还有更高级的版本，包括错误处理等，我将在第7章中详细介绍。但目前，这是一个您可以立即开始玩耍的奇妙小玩具。大叔西蒙送给你的提前圣诞礼物。嘿，嘿，嘿。
- en: There is a simpler implementation of Map possible, if you don’t want to change
    types with each transformation. This is cleaner and more concise, if it suits
    your needs.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想在每次转换时更改类型，那么可能存在一种更简洁的Map实现。如果符合您的需求，这样更清晰、更简洁。
- en: 'It could be implemented like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 可以这样实现：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Using that, the basic Fahrenheit to Celcius transformation would be something
    like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它，基本的华氏温度到摄氏温度的转换将会像这样：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This might be worth using to save a little bit of boilerplate in simpler cases,
    like the temperature conversion. See Chapter 8 later on Currying for some ideas
    on how to make this look even better.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能值得使用，以节省一些简单情况下的样板代码，比如温度转换。请参阅第8章有关柯里化的一些想法，了解如何使其看起来更好。
- en: Fork Combinator
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分支组合器
- en: I’ve also heard this one called “Converge”. I like “Fork” though, it’s more
    descriptive of how exactly it works. A Fork combinator is used to taka a single
    value, then process it in multiple ways, simultaniously, then join up all of those
    separate strands into a single, final value. It can be used to simplify some fairly
    complex multi-step calculations into a single line of code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我也听说过这个被称为“Converge”。不过我更喜欢“Fork”，它更详细地描述了它的工作原理。Fork组合器用于接收单个值，然后同时以多种方式处理它，然后将所有这些单独的分支合并为一个单一的最终值。它可以将一些相当复杂的多步计算简化为一行代码。
- en: 'The process is going to run roughly like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程大致会像这样运行：
- en: Start with a single value
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个单一值开始
- en: Feed it into a set of “prong” functions - each of which act on the original
    input in isolation to produce some sort of output
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其输入一组“分支”函数 - 每个函数都独立作用于原始输入以产生某种输出
- en: A “join” function takes the result of the prongs and merges it into a final
    result.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “join”函数将分支的结果合并为最终结果。
- en: Here are a few examples of how I might use it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我可能使用它的几个示例。
- en: 'If you want to specify the number of arguments in your function definition
    - rather than having an unspecified number of prongs from an array, then it’s
    possible to use a Fork to calculate an average value:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在函数定义中指定参数的数量 - 而不是从数组中具有未指定数量的分支，则可以使用Fork来计算平均值：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'or here’s a blast from the past, a Fork you can use to calculate the Hypotenuse
    of a triangle:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 或者这里有个来自过去的东西，一个用于计算三角形斜边的Fork：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The implementation looks like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 实现看起来像这样：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that having two generic types, one for each prong, means that any combination
    of types can be returned by those functions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，拥有两个泛型类型，每个分支一个，意味着这些函数可以返回任何类型的组合。
- en: You could easily go out and write versions of this for any number of parameters
    beyond two as well, but each additional parameter you want to consider would require
    an additional extension method.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以轻松地为任意数量的参数编写版本，但你想考虑的每个额外参数都需要一个额外的扩展方法。
- en: 'If you wanted to go further, and have an unlimited number of “prongs”, then
    provided you are OK with having the same intermediate type generated by each,
    that’s easily done:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想进一步，并且有无限数量的“分支”，那么只要您愿意使用每个生成的相同中间类型，这很容易实现：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We could use this, for instance, to create a text description based on an object:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以用它来基于对象创建一个文本描述：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With this Fork example, it’s easy enough to add as many more lines of description
    as we want, but maintaining the same level of complexity, and readability.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个分支示例，我们可以轻松地添加更多描述性的行，但保持相同的复杂性和可读性。
- en: Alt Combinator
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Alt组合器
- en: I’ve also seen this referred to as “Or”, “Alternate” and “Alternation”. It’s
    used to bind together a set of functions to achieve the same end, but which should
    be tried one after the other until one of them returns a value.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我也见过这被称为“Or”、“Alternate”和“Alternation”。它用于将一组函数绑定在一起以实现相同的目标，但应该依次尝试，直到其中一个返回一个值。
- en: Think of it as working like “Try method A, if that doesn’t work, try method
    B, if that doesn’t work, try method C, if that doesn’t work I suppose we’re out
    of luck”.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将其视为“尝试方法A，如果不行，则尝试方法B，如果不行，则尝试方法C，如果还不行，我想我们没办法了”的工作方式。
- en: 'Let’s try and imagine a scenario where we might want to find something by trying
    multiple methods:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着想象一种情景，我们可能希望通过尝试多种方法来查找某物：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: So long as one of those three methods returns a value corresponding to a hard-drinking,
    boderline-misogynist, thuggish employee of the British Government, then the jamesBond
    variable won’t be null. Whichever function returned a value first is the last
    function to be run.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要这三种方法中的一种返回与英国政府的一个酒鬼、边缘厌恶女性主义者、凶恶的雇员相对应的值，那么jamesBond变量就不会为空。哪个函数首先返回值就是最后一个要运行的函数。
- en: 'So how do we implement this function before we find our enemy has scarpered?
    Like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 那么在找到我们的敌人已经逃跑之前，我们如何实现这个函数呢？像这样：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Remember here that the LINQ `Select` function operates on a lazy-loading principle,
    so even though I appear to be converting the whole of the `Func` array into concrete
    types, I’m not, because the `First` function will prevent any elements from being
    executed after one of them has returned a non-null value. Isn’t LINQ great?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，LINQ的`Select`函数采用延迟加载的原则运行，所以即使我看起来在将整个`Func`数组转换为具体类型，实际上我并没有，因为`First`函数将阻止在其中一个返回非空值后执行任何元素。LINQ真是太棒了，不是吗？
- en: Compose
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Compose
- en: A common feature of functional languages is the ability to build up a higher-order
    function from a collection of smaller functions. Any process that involves combinging
    functions is called *Composing*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式语言的一个共同特性是能够从一组较小的函数构建出一个高阶函数。任何涉及组合函数的过程都称为*组合*。
- en: There are JavaScript libraries like RamdaJS^([3](ch05.html#idm45400865400736))
    that have terrific composing features available, but C#’s strong typing actually
    works against it in this instance.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript库如RamdaJS^([3](ch05.html#idm45400865400736))具有出色的组合功能，但是在这种情况下，C#的强类型实际上对其起到了反作用。
- en: 'There are a few methods for composing functions in C#. The first is the most
    simple, just using basic Map functions, as described earlier in this chapter:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中有几种组合函数的方法。第一种是最简单的，只是使用基本的Map函数，如本章前面描述的那样：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*f* here is a composed higher-order function. There are 5 functions (e.g. x
    ⇒ x - 32, those steps of the calculation) used to create it, which are described
    as anonymous lambda expressions. They combine, like lego bricks, to form a larger,
    more complex behavior.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*f*是一个组合的高阶函数。有5个函数（例如x ⇒ x - 32，计算的那些步骤）用于创建它，这些函数被描述为匿名的lambda表达式。它们像乐高积木一样组合成一个更大、更复杂的行为。
- en: A valid question at this point - What’s the point of composing functions?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此时一个有效的问题是 - 组合函数的意义何在？
- en: The answer is that you don’t necesarily have to do the whole thing all in once.
    You could build it in pieces, and then ultimately create many functions using
    the same base pieces.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，您不一定要一次完成整个过程。您可以分步构建它，然后最终使用相同的基础部件创建许多函数。
- en: 'Imagine now that I want to also hold a `Func` delegate that represented the
    opposite conversion - we’d end up with two functions like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，我还想拥有一个表示相反转换的`Func`委托 - 我们最终会得到两个这样的函数：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The last two lines of each function are actually identical. Isn’t it a bit
    wasteful to repeat them each time? We can actually eliminate the repetition using
    a Compose function:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数的最后两行实际上是相同的。重复每次都重复它们有点浪费吗？我们可以使用Compose函数消除这种重复：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Functionally, these new versions using Compose are identical to the previous
    versions exclusively using Map.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从功能上讲，这些使用Compose的新版本与仅使用Map的先前版本是相同的。
- en: 'The Compose function performs nearly the same task as Map, with the subtle
    difference that we’re ultimately producing a `Func` delegate at the end, not a
    final value. This is the code that performs the Compose process:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Compose函数执行的任务与Map几乎相同，不同之处在于我们最终生成的是一个`Func`委托，而不是最终值。这是执行Compose过程的代码：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: By using the Compose, we’ve eliminated some unnecessary replication. Any improvements
    to the Format process will be shared by both `Func` delegate objects simultaniously.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Compose，我们已经消除了一些不必要的复制。任何对格式化过程的改进都将同时应用于`Func`委托对象。
- en: There is a limitation, however. In C#, extension methods can’t be attached to
    lambda expressions or to functions directly. We can attach an extension to a lambda
    expression if it’s referenced as a `Func` or `Action` delegate, but for that to
    happen it first needs to be assigned to a variable where it will be automatically
    set as a delegate type for us. This is why its necessary in the examples above
    to assigned the chains of `Map` functions to a variable before calling `Compose`
    - otherwise it would be possible to simply call `Compose` at the end of the `Map`
    chain and save ourselves a variable assignment.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而存在一个限制。在C#中，不能将扩展方法附加到lambda表达式或直接到函数上。如果我们将lambda表达式引用为`Func`或`Action`委托，则可以将扩展方法附加到lambda表达式，但是在此之前，它需要被分配到一个变量中，以便自动设置为委托类型。这就是为什么在上面的示例中，在调用`Compose`之前需要将`Map`函数链分配给变量的原因
    - 否则，可以简单地在`Map`链的末尾调用`Compose`并节省变量分配。
- en: This process is not unlike reusing code via inheritance in Object-Oriented programming,
    except it’s done at the individual line level, and requires quite significantly
    less boilerplate to achieve. It also keeps these similar, related pieces of code
    together, rather than them having to necessarily be spread out over separate classes
    and files.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程与面向对象编程中通过继承重用代码类似，只是在单行级别进行，而且需要的样板代码要少得多。它还将这些类似的相关代码放在一起，而不是必须分散在不同的类和文件中。
- en: Transduce
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换
- en: A Transducer is a way of combining list-based operations, like Select and Where,
    with some form of aggregation to perform multiple transformations to a list of
    values, before finally collapsing it down into a single, final value.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Transducer是一种将基于列表的操作（如Select和Where）与某种形式的聚合结合起来，对值列表执行多个转换，最后将其折叠为单个最终值的方法。
- en: 'While Compose is a useful feature, it has some limitations. It effectively
    only ever takes the place of a Map function - i.e. it acts on the object as a
    whole, and it can’t perform LINQ operations on Enumerables. You *could* Compose
    an array and put Select and Where operations inside each, but honestly that looks
    pretty messy:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Compose是一个有用的功能，但它也有一些限制。它实际上只替代了一个Map函数的位置 - 即它作用于整个对象，并且无法对可枚举对象执行LINQ操作。*你可以*在数组中组合并放入Select和Where操作，但老实说，这看起来非常凌乱：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you’re happy with that, the by all means use it. There’s nothing wrong with
    it per se, aside from being rather inelegant.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对此感到满意，那么尽管使用它。本质上并没有什么错，除了相当不雅。
- en: 'There is another structure that we can use though - Transduce. A Transduce
    operation acts on an array and represents all of the stages of a functional flow:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种结构可以使用 - Transduce。Transduce操作作用于数组，并代表功能流的所有阶段：
- en: Filter (i.e. `.Where`) - Reduce the number of elements
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤（即`.Where`）- 减少元素的数量
- en: Transform (i.e. `.Select`) - Convert them to a new form
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换（即`.Select`）- 将它们转换为新的形式
- en: Aggregate (i.e. Erm..actually is *is* Aggregate) - whittle down the collection
    of many items to a single item using these rules
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合（即，嗯... 实际上就是*聚合*）- 使用这些规则将许多项的集合缩减为单个项。
- en: 'There are many ways this could be implemented in C#, but here’s one possibility:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中可以有许多实现方式，但这是一种可能性：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This extension method takes a transformer method - which can be any combination
    of `Select` and `Where` the user defines to transform the Enumerable ultimately
    from one form and size, to another. The method also takes an aggregator, which
    converts the output of the transformer into a single value.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此扩展方法采用一个转换方法 - 用户定义的`Select`和`Where`的任何组合，最终将可枚举对象从一种形式和大小转换为另一种形式。该方法还接受一个聚合器，将转换器的输出转换为单个值。
- en: 'This is how the compose function I defined above could be implemented with
    this version of the Transduce method:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我上面定义的组合函数如何使用此版本的Transduce方法实现的方式：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Alternatively, if you’d prefer to handle everything as `Func` delegates, so
    that you can reuse the Transducer function, it could be written in this way:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您更喜欢将所有东西都处理为`Func`委托，以便可以重用Transducer函数，则可以这样编写：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is the updated extension method:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是更新后的扩展方法：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We’ve now generated a `Func` delegate variable that can be used as a function
    on as many arrays of integers as we want, and that single `Func` will perfom any
    number of transformations and filters required, then aggregate the array down
    to a single, final value.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们生成了一个`Func`委托变量，可以作为函数在任意多个整数数组上使用，该单一`Func`将执行所需数量的转换和过滤，然后将数组聚合为单个最终值。
- en: Tap
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点击
- en: A common concern I hear raised about chains of functions is that it’s impossible
    to perform logging within them - excepting that you make one of the links in the
    chain a reference to a separate function that does have logging calls within it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常听到有人对函数链提出的一个普遍关注是，在其中执行记录日志是不可能的 - 除非你将链中的一个链接指向一个带有记录调用的单独函数。
- en: There is a technique in functional programming that can be used to inspect the
    contents of a function chain at any point - a Tap function.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程中有一种技术，可以用来在任何函数链的某个点检查函数链的内容 - Tap 函数。
- en: A Tap function is a bit like a wire tap^([4](ch05.html#idm45400864138112)) in
    old detective films. Something that allows a stream of information to be monitored
    and acted on, but without disrupting or altering it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Tap 函数有点像旧侦探片中的窃听器^([4](ch05.html#idm45400864138112))。它允许监视和处理信息流，但不会干扰或改变它。
- en: 'The way to implement a Tap is like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 Tap 的方式如下：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: An `Action` delegate is effectively like a void returning function. In this
    instance it accepts a single parameter - a generic type, T. The Tap function passes
    the current value of the object in the chain into the Action, where logging can
    take place, then returns an unmodified copy of that same object.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`Action`委托实际上就像一个无返回值的函数。在这个实例中，它接受一个参数 - 一个泛型类型 T。Tap 函数将链中当前对象的当前值传递给 Action，在那里可以进行记录，然后返回相同对象的未修改副本。
- en: 'You could use it like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样使用它：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this new version of the Fahrenheit to Celcius functional chain, I’m now Tapping
    into it after the basic calculation is completed, but before I start rounding
    and formatting to string.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新版本的华氏度转换为摄氏度的函数链中，我现在在基本计算完成后开始窥探它，但在我开始四舍五入和格式化字符串之前。
- en: I added a call to a logger in the Tap, but you could switch that for a `Console.WriteLine`
    or whatever else you’d like.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 Tap 中添加了一个调用记录器的调用，但你可以将其换成`Console.WriteLine`或者其他你想要的东西。
- en: Try/Catch
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试/捕获
- en: There are several more advanced structures in functional programming for handling
    errors. If you just want something quick and easy you can quickly implement in
    a few lines of code, but which has its limitations, keep reading. Otherwise, try
    having a look ahead at the next chapter on Discriminated Unions, and the chapter
    after on advanced functional structures. There’s plenty to be found there on handling
    errors without side effects.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程中有几种更高级的结构来处理错误。如果你只是想要一些快速简单的东西，你可以在几行代码中快速实现它，但它有其局限性，请继续阅读。否则，试着提前看看下一章的歧视联盟，以及在高级函数结构之后的章节。在那里可以找到大量关于处理没有副作用的错误的内容。
- en: For now though, let’s see what we can do with a few simple lines of code…​
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 但是现在，让我们看看我们可以用几行简单的代码做些什么……
- en: In theory, in the middle of functional-style code, there shouldn’t be any errors
    possible. If everything is done in line with the functional principles of side-effect
    free code, immutable variables, etc. then you should be safe. On the fringes though,
    there are always interactions that might be considered unsafe.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，在函数风格的代码中间不应该有任何错误。如果一切都按照无副作用的代码、不可变变量等函数式原则进行，你应该是安全的。然而，在边缘处总是可能有一些被认为是不安全的交互。
- en: Let’s imagine you have a scenario in which you want to run a lookup in an external
    system with an integer Id. This external system could be a database, a web api,
    a flat file on a network share, anything at all. The thing all of these possibilities
    have in common though, is that any of them can fail for many reasons, few, if
    any, of which are the fault of the devleoper.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个场景，你想要在一个整数 Id 的外部系统中进行查找。这个外部系统可以是数据库，Web API，网络共享上的平面文件，或者任何其他东西。这些可能性的共同点是，它们中的任何一个都可能由于多种原因而失败，其中很少有任何一个是开发者的错。
- en: There could be network issues, hardware issues on the local or remote computers,
    inadvertent human intervention. The list goes on…​
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会出现网络问题，本地或远程计算机上的硬件问题，无意中的人为干预。问题的列表还在继续……
- en: 'This is how you’d usually deal with that situation in Object Oriented code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你通常在面向对象代码中处理这种情况的方式：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There are two things I dislike about this code block. The first is how much
    boilerplate we have to bulk out the code with. There’s a lot of industrial-strength
    coding we have to add to protect ourselves from problems that we didn’t cause.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个代码块，有两件事我不喜欢。首先是我们必须用多少样板代码来填充代码。我们必须添加大量强大的编码以保护自己，以防我们没有引起的问题。
- en: The other issue is with try/catch blocks themselves. It breaks the order of
    operations, moving execution of the program from where we were to some potentially
    hard-to-find location. In this case, it’s a nice, simple, compact little function
    and the location of the Catch is easy to determine. I’ve worked in codebases though
    where the Catch was several layers of functions higher than the place the fault
    occurred. Bugs were common in that codebase because assumptions were made about
    certains lines of code being reached when they weren’t due to the strange positioning
    of the Try/Catch block.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是 try/catch 块本身。它打破了操作顺序，将程序执行从原来的位置移动到一些可能难以找到的地方。在这种情况下，这是一个很好、简单、紧凑的小函数，并且很容易确定
    Catch 的位置。不过，我曾在代码库中工作过，其中 Catch 位于比故障发生位置高几层的函数中。在那个代码库中，由于假设某些代码行会被执行而实际上未被执行，经常出现错误。
- en: I probably wouldn’t honestly have too many issues with the code block above
    in production, but left unchecked, bad coding practices can leak in. There’s nothing
    in the code that’s preventing future coders from introducing multi-level nested
    functions in here.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，我可能对上面的代码块在生产中并不会有太多问题，但如果不加以检查，不良编码实践可能会渗入其中。代码中没有任何阻止未来编码人员在此处引入多级嵌套函数的机制。
- en: I think the best solution is to use an approach that removes all of the boilerplate,
    and makes it hard, or even impossible, to introduce bad code structure later.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为最好的解决方案是采用一种方法，消除所有样板文件，并使引入不良代码结构变得困难，甚至不可能。
- en: 'Something like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 类似这样：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: What I’m doing is running a Map function with an embedded Try/Catch. The new
    Map function either returns a value if everything worked, or `null` if there was
    a failure.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在执行一个带有内嵌 Try/Catch 的 Map 函数。新的 Map 函数如果一切正常则返回一个值，如果失败则返回 `null`。
- en: 'The extension method looks like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法如下：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This isn’t quite a perfect solution though. What about error logging? This is
    committing the cardinal sin of swallowing error messages unlogged.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 不过这并不是完美的解决方案。那么错误日志记录呢？这是未记录错误消息的重大错误。
- en: There are a few ways you could think about solving this. Any of these are equally
    fine, so proceed as your fancy takes you.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以考虑解决这个问题。任何一种都可以，所以按照你的兴致去做。
- en: 'One option is to instead have an extension method that takes an ILogger instance
    to return a `Func` delegate containing the Try/Catch functionality. Something
    like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是改为使用一个接受 `ILogger` 实例并返回包含 Try/Catch 功能的 `Func` 委托的扩展方法。类似这样：
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The usage would be pretty similar:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法基本相似：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Only a single additional line of boilerplate added, and now logging is being
    done. Sadly there isn’t anything specific we can add in the message besides the
    error itself. The extension method doesn’t know where it’s called from, or the
    context of the error, which is perfect for re-using the method all over the codebase.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 只增加了一行样板文件，现在开始记录。可惜的是，除了错误本身外，我们无法在消息中添加任何具体内容。扩展方法不知道它被调用的位置或错误的上下文，这使得在整个代码库中重复使用该方法非常方便。
- en: If you don’t want the try/catch being aware of the `ILogger` interface, or you
    want to provide a custom error message every time, then we need to look at something
    a little more complicated to handle error messaging.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不希望 Try/Catch 意识到 `ILogger` 接口，或者每次都想提供自定义错误消息，那么我们需要考虑一些更复杂的方法来处理错误消息。
- en: 'One option is to return a meta-data object which contains the return value
    of the function that’s being executed, and a bit of data about whether things
    worked, whether there were errors and what they were. Something like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是返回一个包含正在执行的函数的返回值以及一些关于是否工作、是否存在错误及其内容的元数据对象。类似这样：
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: I don’t really like this approach. It’s breaking one of the SOLID principles
    of Object-Oriented design - the Interface Segregation Principle. Well sort of.
    Techically that applies to Interfaces, but I try to apply it everywhere. Even
    if I do write functional code. The idea is that we shouldn’t be forced to include
    something in a class or interface that we don’t actually need. Here, we’re forcing
    a successful run to include an `Exception` property that it’ll never need, and
    likewise, a failure run will have to include the Result property it’ll never need.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的不喜欢这种方法。它违反了面向对象设计的 SOLID 原则之一 - 接口隔离原则。嗯，有点。从技术上讲，这适用于接口，但我尽量在任何地方都应用它。即使我写函数式代码。理念是，我们不应被迫在类或接口中包含我们实际上不需要的内容。在这里，我们强制一个成功运行包含一个
    `Exception` 属性，它永远不会需要，同样，一个失败运行将不得不包含它永远不会需要的 Result 属性。
- en: There are other ways you could do this, but I’m making it simple, and either
    returning a version of the `ExecutionResult` class with the result, or else a
    `default` value of Result and the Exception returned.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他方法可以做到这一点，但我选择了简单的方法，并返回了一个带有结果的 `ExecutionResult` 类的版本，或者一个带有默认值的 Result
    和返回的异常。
- en: 'This means I can call it like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我可以像这样调用它：
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The unnecessary fields aside, there’s another issue with this approach - the
    onus is now on the developer using the Try/Catch function to add additional boilerplate
    to check for errors.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 除了不必要的字段外，这种方法还有另一个问题 - 现在开发者使用 Try/Catch 函数需要增加额外的样板代码来检查错误。
- en: Skip ahead to the next chapter for an alternative way of handling this sort
    of return value in a more purely functional manner. For now though, here’s a slightly
    cleaner way of handling it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 跳到下一章节，以更纯函数式的方式处理此类返回值的替代方法。但现在，这里有一种稍微更清洁的处理方式。
- en: 'First, I’ll add in another extension method. One that attaches to the ExecutionResult
    object this time:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将添加另一个扩展方法。这次是附加到 ExecutionResult 对象：
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: What I’m doing here is first checking whether there’s an error. If there is,
    then execute the user-defined `Action` - which will presumably be a logging operation.
    It finishes by unwrapping the ExecutionResult into just its actual returned data
    object.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我这里做的第一步是先检查是否有错误。如果有，那么执行用户定义的 `Action` - 这可能是一个日志操作。最后，将 ExecutionResult 解包成其实际返回的数据对象。
- en: 'All of that means you can now handle the Try/Catch like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些意味着你现在可以这样处理 Try/Catch：
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It’s far from a perfect solution, but without moving on another level in functional
    theory, it’s workable and elegant enough that it’s not setting off my internal
    perfectionist. It also forces the user to consider error handling when using this,
    which can only be a good thing!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这远非完美的解决方案，但在不深入函数理论的情况下，它是可行且优雅的，足以不触发我的内部完美主义。这也迫使用户在使用时考虑错误处理，这只能是一件好事！
- en: Handling Nulls
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理空值
- en: Aren’t null reference exceptions annoying? If you want someone to blame, it’s
    a guy called Tony Hoare who invented the concept of Null back in the 60s. Actually,
    let’s not blame anyone. I’m sure he’s a lovely person, beloved by everyone that
    knows him. In any case, we can hopefully all agree that null reference exceptions
    are an absolute pain in the preverbial.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 空引用异常很烦人，不是吗？如果你想责怪某人，那就是一个叫 Tony Hoare 的家伙，他在60年代发明了 Null 的概念。不过，我们最好不要责怪任何人。我相信他是一个可爱的人，所有认识他的人都喜欢他。无论如何，我们可以希望大家都同意，空引用异常确实是一个很大的麻烦。
- en: So, is there a functional way to deal with them? If you’ve read this far, you
    probably know that the answer will be a resounding “yes!”^([5](ch05.html#idm45400863100640)).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，有没有一种函数式的方式来处理它们？如果你读到这里，你可能知道答案将会是一个响亮的“是！”^([5](ch05.html#idm45400863100640))。
- en: The *Unless* function takes in a boolean condition and an `Action` delegate,
    and only executes the `Action` if the boolean is false - i.e. the `Action` is
    always executed *unless* the condition is true.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*Unless* 函数接受一个布尔条件和一个 `Action` 委托，并且仅在布尔条件为假时执行 `Action` - 即 `Action` 总是执行，*除非*
    条件为真。'
- en: The most common usage for something like this is - you guessed it - checking
    for null.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的用法最常见的情况就是 - 你猜对了 - 检查空值。
- en: 'Here’s an example of exactly the sort of code I’m trying to replace. This is
    a rarely-seen bit of source code for a Dalek^([6](ch05.html#idm45400863096432)):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个我试图替换的代码示例。这是一个很少见的 Dalek 的源代码片段^([6](ch05.html#idm45400863096432))：
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is all well and good, and probably leaves a lot of people killed by a psychotic
    mutant in a mobile pepper-pot shaped tank. But, what if the Coordinates object
    was null for some reason? That’s right - null reference exception.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很好，也许会留下许多人被一个移动的胡椒罐形状的精神病突变体杀死。但是，如果 Coordinates 对象因某种原因为空呢？没错——空引用异常。
- en: 'This is where we make this functional, and introduce an Unless function to
    prevent the exception from occuring. This is what unless looks like:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们使其功能化并引入 Unless 函数以防止异常发生的地方。这就是 Unless 的样子：
- en: '[PRE42]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: It has to be a void, unfortunately. If we swapped the `Action` for a `Func`,
    then it’s fine to return the result of the `Func` from the extension method. What
    about when condition is true though, and we don’t execute? What do I return then?
    There isn’t really an answer to that question.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，它必须是一个 void。如果我们将 `Action` 换成 `Func`，那么从扩展方法返回 `Func` 的结果是可以的。然而，当条件为真时，我们不执行时怎么办？那我返回什么？这个问题真的没有一个答案。
- en: 'This is how I’d use it to make my new, super-duper, even more deadly functional
    Dalek:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我如何用它来制作我的新的、超级、更致命的功能达雷克：
- en: '[PRE43]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Using this, a null Coordinates object won’t result in an exception, the gun
    simply won’t be fired.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个方法，一个空的 Coordinates 对象不会导致异常，枪根本不会被开火。
- en: There are more ways to prevent null exceptions coming over the next few chapters
    - ways that require more advanced coding and a little theory, but which are much
    more thorough in the way they work. Stay tuned.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，有更多方法可以预防空指针异常——这些方法需要更高级的编码和一些理论，但在工作方式上更加彻底。敬请期待。
- en: Update an Enumerable
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新一个 Enumerable
- en: I’m going to finish off this section with a useful. It involves updating an
    element in an Enumerable without changing any data at all!
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我将用一个有用的示例结束这一节。它涉及更新一个 Enumerable 中的元素，而不改变任何数据！
- en: The thing to remember about enumerables is that they are designed to make use
    of “lazy evaluation” - i.e. they don’t actually convert from a set of functions
    pointing at a data source to actual data until the last possible moment. Quite
    often, the use of `Select` functions doesn’t trigger an evaluation, so we can
    use them to effectively create filters sitting between the data source and the
    place in the code in which enumeration of the data will actually take place.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 关于可枚举的要记住的一点是，它们被设计用来利用“惰性评估”——即直到最后可能的时刻才实际从指向数据源的一组函数转换为实际数据。很多时候，使用 `Select`
    函数并不会触发评估，因此我们可以用它们有效地创建过滤器，坐落在数据源和代码中枚举数据的位置之间。
- en: 'Here’s an example of altering an Enumerable, so that the item at position x
    is replaced:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这是修改 Enumerable 的一个示例，使位置 x 处的项目被替换：
- en: '[PRE44]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: What I’ve done is call a function to replace the element at position 1 (i.e.
    “Doctor”) with a new value. Despite having two variables, nothing is actually
    done to the source data at all. The variable SourceData remains the same after
    this code snippet has come to the end. Further to that, no replacement is actually
    made until calling `string.Join`, because that’s the very moment at which concrete
    values are required.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我所做的是调用一个函数来替换位置 1（即“Doctor”）的元素为一个新值。尽管有两个变量，在这段代码片段结束后，对源数据实际上并没有做任何操作。此外，直到调用
    `string.Join` 时，才会进行实际的替换，因为那是需要具体值的时刻。
- en: 'This is how it’s done:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何完成的：
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This Enumerable, returned here, actually points at the original Enumerable and
    gets its values from there, but with one crucial difference. If the index of the
    element ever equals the user-defined value (1, the second element, in our example).
    All other values are passed through, unaltered.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这里返回的 Enumerable 实际上指向原始 Enumerable，并从那里获取其值，但有一个关键的区别。如果元素的索引等于用户定义的值（在我们的示例中是第二个元素，即1），那么所有其他值都将不变地传递。
- en: If you were so inclined, you could provide a function to perform the update
    - giving the user the ability to base the new version of the data item on the
    old that is being replaced.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意的话，你可以提供一个函数来执行更新——让用户能够基于正在被替换的旧数据项来生成新版本的数据项。
- en: 'This is how you’d achieve that:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你会做到的：
- en: '[PRE46]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Easy enough to use too:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 使用起来也很简单：
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It’s also possible that we don’t know the Id of the element we want to update
    - in fact there could be multiple items to update. This is an alternative Enumerable
    update function based on providing a T to Bool converting `Func` to identify the
    records that should be updated.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可能不知道要更新的元素的 Id - 实际上可能有多个要更新的项目。这是一种基于提供 T 到 Bool 转换 `Func` 的替代 Enumerable
    更新函数，用于标识应该更新的记录。
- en: This example is based on board games - one of my favorite hobbies - much to
    the annoyance of my ever-patient wife! In this scenario there is a Tag property
    on the BoardGame object, which contains meta data tags describing the game (“family”,
    “co-op”, “complex”, stuff like that) which will be used by a search engine app.
    It’s been decided that another tag should be added to games suitable for 1 player
    - “solo”.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是基于桌游 - 我最喜欢的爱好之一 - 让我永远耐心的妻子很恼火！在这种情况下，BoardGame 对象上有一个 Tag 属性，其中包含描述游戏的元数据标签（“家庭”，“合作”，“复杂”等），这将被搜索引擎应用程序使用。已决定为适合单人游戏的游戏添加另一个标签
    - “独奏”。
- en: '[PRE48]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The implementation is a variation on code we’ve already covered:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 实现是我们已经讨论过的代码的变体：
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This function can be used to replace the need for many instances of If-statements,
    and reduce them down to simpler, more predictable operations.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数可用于替代许多 If 语句的需求，并将它们简化为更简单、更可预测的操作。
- en: Conclusion
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter we looked at various ways to use the concept of higher-order
    functions to develop ways to provide rich functionality to our codebase, avoiding
    the need for Object-Oriented style statements.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用高阶函数概念开发丰富功能以避免需要面向对象风格语句的各种方法。
- en: Do get in touch if you have any ideas of your own for higher-order function
    uses. You never know, it might end up in a future edition of this book!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有任何关于自己用于高阶函数用途的想法，请随时与我们联系。您永远不知道，它可能会出现在本书的未来版本中！
- en: In the next chapter, we’ll be looking at Discriminated Unions, and how this
    functional concept can help to better model concepts in your codebase, and remove
    the need for a lot of defensive code typically needed with non-functional projects.
    Enjoy!
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨**辨识联合**，以及这个函数式概念如何帮助更好地模拟代码库中的概念，并消除通常在非函数式项目中所需的大量防御性代码。享受吧！
- en: ^([1](ch05.html#idm45400867135648-marker)) Ideally the hotest, spiciest flavor
    you can find. Flames should be shooting from your mouth as you eat!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch05.html#idm45400867135648-marker)) 理想情况下，您可以找到最热辣的口味。吃时火焰应从您的嘴里冒出！
- en: '^([2](ch05.html#idm45400866574816-marker)) Read more about it here: [*https://en.wikipedia.org/wiki/SOLID*](https://en.wikipedia.org/wiki/SOLID)
    - or if you prefer video then here’s one presented by yours truly: [*https://www.youtube.com/watch?v=0vJb_B47J6U*](https://www.youtube.com/watch?v=0vJb_B47J6U)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch05.html#idm45400866574816-marker)) 在此处了解更多信息：[*https://en.wikipedia.org/wiki/SOLID*](https://en.wikipedia.org/wiki/SOLID)
    - 或者如果您更喜欢视频，这里有一个由我亲自主持的视频：[*https://www.youtube.com/watch?v=0vJb_B47J6U*](https://www.youtube.com/watch?v=0vJb_B47J6U)
- en: '^([3](ch05.html#idm45400865400736-marker)) See it for yourself here: [*https://ramdajs.com/*](https://ramdajs.com/)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch05.html#idm45400865400736-marker)) 自己看看这里：[*https://ramdajs.com/*](https://ramdajs.com/)
- en: ^([4](ch05.html#idm45400864138112-marker)) I’d guess that’s where they get their
    name
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch05.html#idm45400864138112-marker)) 我猜那可能就是它们得名的原因
- en: ^([5](ch05.html#idm45400863100640-marker)) Also, congratulations for making
    it this far. Although it probably didn’t take you anywhere so much time as it
    did me!!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch05.html#idm45400863100640-marker)) 还有，祝贺您走到了这一步。虽然你花的时间可能没有我多！
- en: '^([6](ch05.html#idm45400863096432-marker)) For the non-initiated, these are
    the main baddies in the British SF TV series Doctor Who. See them in action here:
    [*https://www.youtube.com/watch?v=d77jOE2Cjx8*](https://www.youtube.com/watch?v=d77jOE2Cjx8)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch05.html#idm45400863096432-marker)) 对于未了解的人来说，它们是英国科幻电视系列《Doctor Who》中的主要反派。在这里看看它们的表现：[*https://www.youtube.com/watch?v=d77jOE2Cjx8*](https://www.youtube.com/watch?v=d77jOE2Cjx8)
