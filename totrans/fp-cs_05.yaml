- en: Chapter 5\. Higher-Order Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome back my friends to the show that never ends.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter, we’re looking at uses for higher-order functions. I’m going to
    look at novel ways to use them in C# to save yourself effort, and to make code
    that is less likely to fail.
  prefs: []
  type: TYPE_NORMAL
- en: But, what *are* Higher-order functions?
  prefs: []
  type: TYPE_NORMAL
- en: 'Higher-order Functions is a slightly odd name for something very simple. In
    fact you’ve likely been using them for some time if you’ve spent much time working
    with LINQ. They come in two flavors, here’s the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Passed into the `Where` function there is an arrow expression - which is just
    a shorthand for writing out an unnamed function. The long-hand version would look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So here, the function has been passed around as the parameter to another function,
    to be executed elsewhere inside it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is another example of the use of higher-order functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice here that there are two arrows, not one. We’re taking an integer *x*
    and from that returning a new function. In that new function references to *x*
    will be filled in with whatever was provided when MakeAddFunc was called originally.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: By passing 10 into `MakeAddFunc` in the example above, I created a new function
    whose function is simply to add 10 to whatever addtional integer you pass into
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In short a higher-order function is a function with one or more of the following
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Accepts a function as a parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a function as its return type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In C# this is all typically done with either a `Func` (for functions with a
    return type) or `Action` (for functions that return void) delegate types.
  prefs: []
  type: TYPE_NORMAL
- en: It’s a fairly simple idea, and even easier to implement - but the effect they
    can have on your codebase is incredible.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter I’m going to walk through ways of using Higher-Order Functions
    to improve your daily coding.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll also be looking quite a bit into a next-level usage of Higher-Order functions
    called Combinators. These enable passing around functions in a way that creates
    a more complex - and useful - behavior. They’re called that incidentally, because
    they originate from a mathematical technique called Combinatory Logic. You won’t
    need to worry about ever hearing that term again, or about any references to advanced
    maths - I’m not going there. It’s just in case you were curious…​
  prefs: []
  type: TYPE_NORMAL
- en: A Problem Report
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started, we’ll look at a bit of problem code. Let’s imagine that your
    company have asked you for a function to take a data store of some kind (an XML
    file, a JSON file, who knows. Doesn’t matter), summarise how many there are of
    each possible value, then transmit that data on to somewhere else. On top of that,
    they want a separate message to be sent in the event that no data was found at
    all. I run a really, really loose ship, so let’s keep things fun, and imagine
    you work for the Evil Galactic Empire™ and you are cataloguing Rebel Alliance
    ships on your radar.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is fine, isn’t it? Isn’t it? Well, think about this scenario. You’re sitting
    at your desk, eating your daily pot noodle^([1](ch05.html#idm45400867135648)),
    when you notice that - Jurassic Park style - there is a rhythmic ripple appearing
    in your coffee. This signals the arrival of your worst nightmare. Your boss! Let’s
    imagine that your boss is - thinking totally at random here - a tall, deep-voiced
    gentleman in a black cape and with appauling asthma. He also really hates it when
    people displease him. *Really* hates it.
  prefs: []
  type: TYPE_NORMAL
- en: He’s happy with the first function you created. For this you can breath a sigh
    of relief. But now he wants a second function. This one is going to create another
    summary, but this time of the level of weaponry in each ship. Whether they are
    unarmed, lightly armed, heavily armed or capable of destroying planets. That sort
    of thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Easy, you think. The boss will be so impressed with how quickly I do this.
    So, you do what seems easiest `Ctrl+C`, then `Ctrl+V` to copy & paste the original,
    change the name, change the property you’re summarising, and you end up with something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Five seconds of work, and a day or two of leaning on your figurative shovel
    with the odd complaint out-loud of how hard the work is here, all while you secretly
    work on today’s Wordle. Job done, and slaps on the back all round, right? Right?
  prefs: []
  type: TYPE_NORMAL
- en: Well…​.There are a couple of problems with this approach.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s think about unit testing. As good, upstanding code citizens, we
    unit test all of our code. Imagine we’d unit tested the snot out of that first
    function. When we copied & pasted the second in, what was the level of unit test
    coverage at that point?
  prefs: []
  type: TYPE_NORMAL
- en: I’ll give you a clue - it was between zero and zero. You could copy and paste
    the tests too, and that would be fine, but that’s now an awful lot more code that
    we’re copying and pasting every time.
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t an approach that scales up well. What if our boss wanted another
    function after this one, and another, and another. What if we ended being asked
    for 50 functions? Or 100?!? That’s a lot of code. You’d end up with something
    thousands of lines long, not something I’d be keen to support.
  prefs: []
  type: TYPE_NORMAL
- en: It gets worse when you consider something that happened to me near the beginnning
    of my career. I was working for an organisation that had a desktop application
    that carried out a series of complex calculations for each customer, based on
    a few input parameters. Each year, the rules changed, but the old rule bases had
    to be replicated because it might be necessary to see what would have been calculated
    in a previous year.
  prefs: []
  type: TYPE_NORMAL
- en: So, the folks that had been developing the app before I joined the team had
    copied a whole chunk of code every year. Made a few little changes, added a link
    somewhere to the new version, and voilà. Job done.
  prefs: []
  type: TYPE_NORMAL
- en: I was tasked with making these annual changes one year, so off I went, young,
    innocent and raring to make a difference to the world. When I was making my changes,
    I noticed something odd. There was a weird error with a field that wasn’t anything
    to do with my changes. I fixed the bug, but then a thought occurred to me that
    made my heart sink…​
  prefs: []
  type: TYPE_NORMAL
- en: I checked every previous version of the codebase for each previous year and
    found that nearly all of them had the same bug. It had been introduced about 10
    years ago, and every devleoper since then had replicated the bug precisely. So,
    I had to fix it 10 times over, increasing the testing effort by an order of magnitude.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, ask yourself - did copying and pasting really save you any
    time? I routinely work on apps that stay in existence for decades, and which show
    no sign of being put out to pasture any time soon.
  prefs: []
  type: TYPE_NORMAL
- en: When I decide where to make time-saving measures for coding work, I try and
    look over the whole life of the application, and try to keep in mind what the
    consequences might be for a decision a decade on.
  prefs: []
  type: TYPE_NORMAL
- en: To return to the subject at hand, how would I have used Higher-order functions
    to solve this problem? Well, are you sitting comfortably? Then I’ll begin…​
  prefs: []
  type: TYPE_NORMAL
- en: Thunks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A bundle of code that carries a stored calculation, which can be executed later
    on request is properly known as a *Thunk*. Same as the sound a plank of wood makes
    when it smacks you in the side of the head. There’s an argument to be had as to
    whether that hurts your head more or less than reading this book!
  prefs: []
  type: TYPE_NORMAL
- en: Here in C#, `Func` delegates are again the way that we’d implement this. We
    can write functions that take `Func` delegates as parameter values, to allow for
    certain calculations in our function to be left effectively blank, and which can
    be filled in from the outside world, via an arrow function.
  prefs: []
  type: TYPE_NORMAL
- en: Although there is a serious, proper, mathematical term for this technique, I
    like calling them doughnut functions, because it’s more descriptive. They’re like
    normal functions, but with a hole in the middle! A hole I’d ask someone else to
    fill in with the necessary functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is one potential way to refactor the problem report function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this, revised version, we’ve gained a few advantages.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, the number of additional lines per new report is just one! That’s a
    much tidier codebase, and easier to read. The code is kept very close to the intent
    of the new function - i.e. be the same as the first, but with a few changes.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, after unit testing function 1, when we create function 2, the unit
    test level is still close to 100%. The only difference functionally is the report
    name, and the field to be summarised.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, any enhancements or bug fixes to the base function will be shared between
    all report functions simultaniously. That’s a lot of benefit for relatively little
    effort. There’s also a very high degree of confidence that if one report function
    tests well, that all of the others will be the same.
  prefs: []
  type: TYPE_NORMAL
- en: One could actually walk away from this version happy. But, if it were me, I’d
    actually consider going a step further and exposing the private version with its
    `Func` parameters on the interface for whatever wants to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The implementation would be the private function from the previous code sample
    made public instead. This way there’s no need to ever modify the interface or
    implementing class again, at least not if all that’s wanted is an additional report
    for a different field.
  prefs: []
  type: TYPE_NORMAL
- en: This makes the business of creating reports something that can be done entirely
    arbitrarily by whatever code module consumes this class. It saves a lot of the
    burdon of maintaining the report set from developers like ourselves, and puts
    it more in the hands of the teams that care about the reports themselves. Imagine
    the sheer number of Requests for Change that will now never need to come to a
    development team.
  prefs: []
  type: TYPE_NORMAL
- en: If you wanted to be really wild, you could expose further `Func` parameters
    as `Func<ReportLine,string>` to allow users of the report class to define custom
    formatting. You could also use `Action` parameters to allow for bespoke logging
    or event handling. This is just in my silly, made-up reporting class. The possibilities
    for the use of higher-order functions in this way are endless.
  prefs: []
  type: TYPE_NORMAL
- en: Despite being a functional programming feature, this is keeping us squarely
    in line with the *O* of the SOLID Principles of Object-Oriented design^([2](ch05.html#idm45400866574816))
    - the Open/Closed principle, which states a module should be open to extension,
    but closed to modification.
  prefs: []
  type: TYPE_NORMAL
- en: It’s surprising how well OO and functional programming can complement each other
    in C#. I often think it’s important for developers to make sure they are adept
    at both paradigms, so they know how to use them together effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Allow me to introduce you to the best friend you never knew you needed - the
    Map function. This function is also commonly referred to as Chain and Pipe, but
    for the sake of consistency, we’ll call it Map throughout this book. I’m afraid
    that there’s a tendency for a lot of functional structures to have many names
    in use, depending on the programming language and implementation. I’ll try and
    point out whenever this is the case.
  prefs: []
  type: TYPE_NORMAL
- en: Now, I’m British, and there’s a cliché about British people that we like talking
    about the weather. It’s entirely true. Our country is one that’s been known to
    go through 4 seasons in a single day, so the weather is a constant source of fascination
    to us.
  prefs: []
  type: TYPE_NORMAL
- en: 'I used to work for an American company, once upon a time, and when I did, the
    topic of conversation with my colleagues over video call would often turn inevitably
    to the subject of the weather. They’d tell me that the temperature outside was
    around 100 degrees. I work in celcius, so to me this sounds rather suspiciously
    like the boiling point of water. Given that my colleagues were not screamning
    as their blood boiled away into steam, I suspected something else was at work.
    It was, of course, that they were working in Fahrenheit, so I had to convert this
    to something I understood with the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: subtract 32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, multiply by 5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, divide by 9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which gives a temperature in Celcius of around 38 degrees, which is warm and
    toasty, but for the most part safe for human life.
  prefs: []
  type: TYPE_NORMAL
- en: 'How could I code this process in exactly that multi-step operation, then finish
    by returning a formatted string? I *could* stick it all together into a single
    line like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Not very readable though, is it? Honestly, I probably wouldn’t make too much
    fuss about that in production code, but I’m demonstrating a technique, and I don’t
    want to get bogged down, so bear with me.
  prefs: []
  type: TYPE_NORMAL
- en: 'The multi-step way to write this out is like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is much more readable, and easier to maintain, but it still has an issue.
    We’re creating variables that are essential intended to be used a single time
    and then thrown away. In this little function it’s not terribly relevant, but
    what if this were a gigantic thousand-line function? What if instead of a little
    decimal variable like these, there was a large, complex object instead? All the
    way down at line 1000, that variable - which is never intended to be used again
    - is still in scope, and holding up memory. It’s also a little messy to create
    a variable you aren’t planning to make any use of beyond the next line. This is
    where Map comes in.
  prefs: []
  type: TYPE_NORMAL
- en: Map is somewhat like the LINQ `Select` function, except instead of operating
    on each element of an Enumerable, it operates on an object. Any object. You pass
    it a Lambda arrow function just the same as with `Select` except that your *x*
    parameter refers to the base object. If you applied it to an Enumerable, the *x*
    parameter would refer to the entire enumerable, not indivudual elements thereof.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what my modified Fahrenheit conversion would look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Same exact functionality, same friendly, multi-stage operation, but no throw-away
    variables. Each of those arrow functions is executed, then once completed, their
    contents are subject for Garbage Collection. The decimal *x* that is multiplied
    by 5 is subject for disposal when the next arrow function takes a copy of its
    result and divides that by 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how you implement Map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It’s tiny, isn’t it? Despite that, I use this partiular method quite a lot.
    Whenever I want to do a multi-step transformaton of data. It makes it easier to
    convert whole function bodies into simple arrow functions, like my Map-based FahrenheitToCelcius
    function, above.
  prefs: []
  type: TYPE_NORMAL
- en: There are far more advanced versions of this method, which includes things like
    error handling, and which I’ll be getting onto in Chapter 7\. For now though,
    this is a fantastic little toy that you can start playing with right away. Uncle
    Simon’s early Christmas gift to you. Ho, ho, ho.
  prefs: []
  type: TYPE_NORMAL
- en: There is a simpler implementation of Map possible, if you don’t want to change
    types with each transformation. This is cleaner and more concise, if it suits
    your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'It could be implemented like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Using that, the basic Fahrenheit to Celcius transformation would be something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This might be worth using to save a little bit of boilerplate in simpler cases,
    like the temperature conversion. See Chapter 8 later on Currying for some ideas
    on how to make this look even better.
  prefs: []
  type: TYPE_NORMAL
- en: Fork Combinator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’ve also heard this one called “Converge”. I like “Fork” though, it’s more
    descriptive of how exactly it works. A Fork combinator is used to taka a single
    value, then process it in multiple ways, simultaniously, then join up all of those
    separate strands into a single, final value. It can be used to simplify some fairly
    complex multi-step calculations into a single line of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process is going to run roughly like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with a single value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feed it into a set of “prong” functions - each of which act on the original
    input in isolation to produce some sort of output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A “join” function takes the result of the prongs and merges it into a final
    result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here are a few examples of how I might use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to specify the number of arguments in your function definition
    - rather than having an unspecified number of prongs from an array, then it’s
    possible to use a Fork to calculate an average value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'or here’s a blast from the past, a Fork you can use to calculate the Hypotenuse
    of a triangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that having two generic types, one for each prong, means that any combination
    of types can be returned by those functions.
  prefs: []
  type: TYPE_NORMAL
- en: You could easily go out and write versions of this for any number of parameters
    beyond two as well, but each additional parameter you want to consider would require
    an additional extension method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wanted to go further, and have an unlimited number of “prongs”, then
    provided you are OK with having the same intermediate type generated by each,
    that’s easily done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We could use this, for instance, to create a text description based on an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With this Fork example, it’s easy enough to add as many more lines of description
    as we want, but maintaining the same level of complexity, and readability.
  prefs: []
  type: TYPE_NORMAL
- en: Alt Combinator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’ve also seen this referred to as “Or”, “Alternate” and “Alternation”. It’s
    used to bind together a set of functions to achieve the same end, but which should
    be tried one after the other until one of them returns a value.
  prefs: []
  type: TYPE_NORMAL
- en: Think of it as working like “Try method A, if that doesn’t work, try method
    B, if that doesn’t work, try method C, if that doesn’t work I suppose we’re out
    of luck”.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try and imagine a scenario where we might want to find something by trying
    multiple methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: So long as one of those three methods returns a value corresponding to a hard-drinking,
    boderline-misogynist, thuggish employee of the British Government, then the jamesBond
    variable won’t be null. Whichever function returned a value first is the last
    function to be run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So how do we implement this function before we find our enemy has scarpered?
    Like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Remember here that the LINQ `Select` function operates on a lazy-loading principle,
    so even though I appear to be converting the whole of the `Func` array into concrete
    types, I’m not, because the `First` function will prevent any elements from being
    executed after one of them has returned a non-null value. Isn’t LINQ great?
  prefs: []
  type: TYPE_NORMAL
- en: Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common feature of functional languages is the ability to build up a higher-order
    function from a collection of smaller functions. Any process that involves combinging
    functions is called *Composing*.
  prefs: []
  type: TYPE_NORMAL
- en: There are JavaScript libraries like RamdaJS^([3](ch05.html#idm45400865400736))
    that have terrific composing features available, but C#’s strong typing actually
    works against it in this instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few methods for composing functions in C#. The first is the most
    simple, just using basic Map functions, as described earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*f* here is a composed higher-order function. There are 5 functions (e.g. x
    ⇒ x - 32, those steps of the calculation) used to create it, which are described
    as anonymous lambda expressions. They combine, like lego bricks, to form a larger,
    more complex behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: A valid question at this point - What’s the point of composing functions?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that you don’t necesarily have to do the whole thing all in once.
    You could build it in pieces, and then ultimately create many functions using
    the same base pieces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine now that I want to also hold a `Func` delegate that represented the
    opposite conversion - we’d end up with two functions like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The last two lines of each function are actually identical. Isn’t it a bit
    wasteful to repeat them each time? We can actually eliminate the repetition using
    a Compose function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Functionally, these new versions using Compose are identical to the previous
    versions exclusively using Map.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Compose function performs nearly the same task as Map, with the subtle
    difference that we’re ultimately producing a `Func` delegate at the end, not a
    final value. This is the code that performs the Compose process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: By using the Compose, we’ve eliminated some unnecessary replication. Any improvements
    to the Format process will be shared by both `Func` delegate objects simultaniously.
  prefs: []
  type: TYPE_NORMAL
- en: There is a limitation, however. In C#, extension methods can’t be attached to
    lambda expressions or to functions directly. We can attach an extension to a lambda
    expression if it’s referenced as a `Func` or `Action` delegate, but for that to
    happen it first needs to be assigned to a variable where it will be automatically
    set as a delegate type for us. This is why its necessary in the examples above
    to assigned the chains of `Map` functions to a variable before calling `Compose`
    - otherwise it would be possible to simply call `Compose` at the end of the `Map`
    chain and save ourselves a variable assignment.
  prefs: []
  type: TYPE_NORMAL
- en: This process is not unlike reusing code via inheritance in Object-Oriented programming,
    except it’s done at the individual line level, and requires quite significantly
    less boilerplate to achieve. It also keeps these similar, related pieces of code
    together, rather than them having to necessarily be spread out over separate classes
    and files.
  prefs: []
  type: TYPE_NORMAL
- en: Transduce
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Transducer is a way of combining list-based operations, like Select and Where,
    with some form of aggregation to perform multiple transformations to a list of
    values, before finally collapsing it down into a single, final value.
  prefs: []
  type: TYPE_NORMAL
- en: 'While Compose is a useful feature, it has some limitations. It effectively
    only ever takes the place of a Map function - i.e. it acts on the object as a
    whole, and it can’t perform LINQ operations on Enumerables. You *could* Compose
    an array and put Select and Where operations inside each, but honestly that looks
    pretty messy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If you’re happy with that, the by all means use it. There’s nothing wrong with
    it per se, aside from being rather inelegant.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another structure that we can use though - Transduce. A Transduce
    operation acts on an array and represents all of the stages of a functional flow:'
  prefs: []
  type: TYPE_NORMAL
- en: Filter (i.e. `.Where`) - Reduce the number of elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transform (i.e. `.Select`) - Convert them to a new form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregate (i.e. Erm..actually is *is* Aggregate) - whittle down the collection
    of many items to a single item using these rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many ways this could be implemented in C#, but here’s one possibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This extension method takes a transformer method - which can be any combination
    of `Select` and `Where` the user defines to transform the Enumerable ultimately
    from one form and size, to another. The method also takes an aggregator, which
    converts the output of the transformer into a single value.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the compose function I defined above could be implemented with
    this version of the Transduce method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you’d prefer to handle everything as `Func` delegates, so
    that you can reuse the Transducer function, it could be written in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the updated extension method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We’ve now generated a `Func` delegate variable that can be used as a function
    on as many arrays of integers as we want, and that single `Func` will perfom any
    number of transformations and filters required, then aggregate the array down
    to a single, final value.
  prefs: []
  type: TYPE_NORMAL
- en: Tap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common concern I hear raised about chains of functions is that it’s impossible
    to perform logging within them - excepting that you make one of the links in the
    chain a reference to a separate function that does have logging calls within it.
  prefs: []
  type: TYPE_NORMAL
- en: There is a technique in functional programming that can be used to inspect the
    contents of a function chain at any point - a Tap function.
  prefs: []
  type: TYPE_NORMAL
- en: A Tap function is a bit like a wire tap^([4](ch05.html#idm45400864138112)) in
    old detective films. Something that allows a stream of information to be monitored
    and acted on, but without disrupting or altering it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to implement a Tap is like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: An `Action` delegate is effectively like a void returning function. In this
    instance it accepts a single parameter - a generic type, T. The Tap function passes
    the current value of the object in the chain into the Action, where logging can
    take place, then returns an unmodified copy of that same object.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this new version of the Fahrenheit to Celcius functional chain, I’m now Tapping
    into it after the basic calculation is completed, but before I start rounding
    and formatting to string.
  prefs: []
  type: TYPE_NORMAL
- en: I added a call to a logger in the Tap, but you could switch that for a `Console.WriteLine`
    or whatever else you’d like.
  prefs: []
  type: TYPE_NORMAL
- en: Try/Catch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several more advanced structures in functional programming for handling
    errors. If you just want something quick and easy you can quickly implement in
    a few lines of code, but which has its limitations, keep reading. Otherwise, try
    having a look ahead at the next chapter on Discriminated Unions, and the chapter
    after on advanced functional structures. There’s plenty to be found there on handling
    errors without side effects.
  prefs: []
  type: TYPE_NORMAL
- en: For now though, let’s see what we can do with a few simple lines of code…​
  prefs: []
  type: TYPE_NORMAL
- en: In theory, in the middle of functional-style code, there shouldn’t be any errors
    possible. If everything is done in line with the functional principles of side-effect
    free code, immutable variables, etc. then you should be safe. On the fringes though,
    there are always interactions that might be considered unsafe.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s imagine you have a scenario in which you want to run a lookup in an external
    system with an integer Id. This external system could be a database, a web api,
    a flat file on a network share, anything at all. The thing all of these possibilities
    have in common though, is that any of them can fail for many reasons, few, if
    any, of which are the fault of the devleoper.
  prefs: []
  type: TYPE_NORMAL
- en: There could be network issues, hardware issues on the local or remote computers,
    inadvertent human intervention. The list goes on…​
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how you’d usually deal with that situation in Object Oriented code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: There are two things I dislike about this code block. The first is how much
    boilerplate we have to bulk out the code with. There’s a lot of industrial-strength
    coding we have to add to protect ourselves from problems that we didn’t cause.
  prefs: []
  type: TYPE_NORMAL
- en: The other issue is with try/catch blocks themselves. It breaks the order of
    operations, moving execution of the program from where we were to some potentially
    hard-to-find location. In this case, it’s a nice, simple, compact little function
    and the location of the Catch is easy to determine. I’ve worked in codebases though
    where the Catch was several layers of functions higher than the place the fault
    occurred. Bugs were common in that codebase because assumptions were made about
    certains lines of code being reached when they weren’t due to the strange positioning
    of the Try/Catch block.
  prefs: []
  type: TYPE_NORMAL
- en: I probably wouldn’t honestly have too many issues with the code block above
    in production, but left unchecked, bad coding practices can leak in. There’s nothing
    in the code that’s preventing future coders from introducing multi-level nested
    functions in here.
  prefs: []
  type: TYPE_NORMAL
- en: I think the best solution is to use an approach that removes all of the boilerplate,
    and makes it hard, or even impossible, to introduce bad code structure later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: What I’m doing is running a Map function with an embedded Try/Catch. The new
    Map function either returns a value if everything worked, or `null` if there was
    a failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The extension method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This isn’t quite a perfect solution though. What about error logging? This is
    committing the cardinal sin of swallowing error messages unlogged.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few ways you could think about solving this. Any of these are equally
    fine, so proceed as your fancy takes you.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to instead have an extension method that takes an ILogger instance
    to return a `Func` delegate containing the Try/Catch functionality. Something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The usage would be pretty similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Only a single additional line of boilerplate added, and now logging is being
    done. Sadly there isn’t anything specific we can add in the message besides the
    error itself. The extension method doesn’t know where it’s called from, or the
    context of the error, which is perfect for re-using the method all over the codebase.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t want the try/catch being aware of the `ILogger` interface, or you
    want to provide a custom error message every time, then we need to look at something
    a little more complicated to handle error messaging.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to return a meta-data object which contains the return value
    of the function that’s being executed, and a bit of data about whether things
    worked, whether there were errors and what they were. Something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: I don’t really like this approach. It’s breaking one of the SOLID principles
    of Object-Oriented design - the Interface Segregation Principle. Well sort of.
    Techically that applies to Interfaces, but I try to apply it everywhere. Even
    if I do write functional code. The idea is that we shouldn’t be forced to include
    something in a class or interface that we don’t actually need. Here, we’re forcing
    a successful run to include an `Exception` property that it’ll never need, and
    likewise, a failure run will have to include the Result property it’ll never need.
  prefs: []
  type: TYPE_NORMAL
- en: There are other ways you could do this, but I’m making it simple, and either
    returning a version of the `ExecutionResult` class with the result, or else a
    `default` value of Result and the Exception returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means I can call it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The unnecessary fields aside, there’s another issue with this approach - the
    onus is now on the developer using the Try/Catch function to add additional boilerplate
    to check for errors.
  prefs: []
  type: TYPE_NORMAL
- en: Skip ahead to the next chapter for an alternative way of handling this sort
    of return value in a more purely functional manner. For now though, here’s a slightly
    cleaner way of handling it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, I’ll add in another extension method. One that attaches to the ExecutionResult
    object this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: What I’m doing here is first checking whether there’s an error. If there is,
    then execute the user-defined `Action` - which will presumably be a logging operation.
    It finishes by unwrapping the ExecutionResult into just its actual returned data
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of that means you can now handle the Try/Catch like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: It’s far from a perfect solution, but without moving on another level in functional
    theory, it’s workable and elegant enough that it’s not setting off my internal
    perfectionist. It also forces the user to consider error handling when using this,
    which can only be a good thing!
  prefs: []
  type: TYPE_NORMAL
- en: Handling Nulls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aren’t null reference exceptions annoying? If you want someone to blame, it’s
    a guy called Tony Hoare who invented the concept of Null back in the 60s. Actually,
    let’s not blame anyone. I’m sure he’s a lovely person, beloved by everyone that
    knows him. In any case, we can hopefully all agree that null reference exceptions
    are an absolute pain in the preverbial.
  prefs: []
  type: TYPE_NORMAL
- en: So, is there a functional way to deal with them? If you’ve read this far, you
    probably know that the answer will be a resounding “yes!”^([5](ch05.html#idm45400863100640)).
  prefs: []
  type: TYPE_NORMAL
- en: The *Unless* function takes in a boolean condition and an `Action` delegate,
    and only executes the `Action` if the boolean is false - i.e. the `Action` is
    always executed *unless* the condition is true.
  prefs: []
  type: TYPE_NORMAL
- en: The most common usage for something like this is - you guessed it - checking
    for null.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of exactly the sort of code I’m trying to replace. This is
    a rarely-seen bit of source code for a Dalek^([6](ch05.html#idm45400863096432)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This is all well and good, and probably leaves a lot of people killed by a psychotic
    mutant in a mobile pepper-pot shaped tank. But, what if the Coordinates object
    was null for some reason? That’s right - null reference exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where we make this functional, and introduce an Unless function to
    prevent the exception from occuring. This is what unless looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: It has to be a void, unfortunately. If we swapped the `Action` for a `Func`,
    then it’s fine to return the result of the `Func` from the extension method. What
    about when condition is true though, and we don’t execute? What do I return then?
    There isn’t really an answer to that question.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how I’d use it to make my new, super-duper, even more deadly functional
    Dalek:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Using this, a null Coordinates object won’t result in an exception, the gun
    simply won’t be fired.
  prefs: []
  type: TYPE_NORMAL
- en: There are more ways to prevent null exceptions coming over the next few chapters
    - ways that require more advanced coding and a little theory, but which are much
    more thorough in the way they work. Stay tuned.
  prefs: []
  type: TYPE_NORMAL
- en: Update an Enumerable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’m going to finish off this section with a useful. It involves updating an
    element in an Enumerable without changing any data at all!
  prefs: []
  type: TYPE_NORMAL
- en: The thing to remember about enumerables is that they are designed to make use
    of “lazy evaluation” - i.e. they don’t actually convert from a set of functions
    pointing at a data source to actual data until the last possible moment. Quite
    often, the use of `Select` functions doesn’t trigger an evaluation, so we can
    use them to effectively create filters sitting between the data source and the
    place in the code in which enumeration of the data will actually take place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of altering an Enumerable, so that the item at position x
    is replaced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: What I’ve done is call a function to replace the element at position 1 (i.e.
    “Doctor”) with a new value. Despite having two variables, nothing is actually
    done to the source data at all. The variable SourceData remains the same after
    this code snippet has come to the end. Further to that, no replacement is actually
    made until calling `string.Join`, because that’s the very moment at which concrete
    values are required.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how it’s done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This Enumerable, returned here, actually points at the original Enumerable and
    gets its values from there, but with one crucial difference. If the index of the
    element ever equals the user-defined value (1, the second element, in our example).
    All other values are passed through, unaltered.
  prefs: []
  type: TYPE_NORMAL
- en: If you were so inclined, you could provide a function to perform the update
    - giving the user the ability to base the new version of the data item on the
    old that is being replaced.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how you’d achieve that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Easy enough to use too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: It’s also possible that we don’t know the Id of the element we want to update
    - in fact there could be multiple items to update. This is an alternative Enumerable
    update function based on providing a T to Bool converting `Func` to identify the
    records that should be updated.
  prefs: []
  type: TYPE_NORMAL
- en: This example is based on board games - one of my favorite hobbies - much to
    the annoyance of my ever-patient wife! In this scenario there is a Tag property
    on the BoardGame object, which contains meta data tags describing the game (“family”,
    “co-op”, “complex”, stuff like that) which will be used by a search engine app.
    It’s been decided that another tag should be added to games suitable for 1 player
    - “solo”.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation is a variation on code we’ve already covered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This function can be used to replace the need for many instances of If-statements,
    and reduce them down to simpler, more predictable operations.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we looked at various ways to use the concept of higher-order
    functions to develop ways to provide rich functionality to our codebase, avoiding
    the need for Object-Oriented style statements.
  prefs: []
  type: TYPE_NORMAL
- en: Do get in touch if you have any ideas of your own for higher-order function
    uses. You never know, it might end up in a future edition of this book!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll be looking at Discriminated Unions, and how this
    functional concept can help to better model concepts in your codebase, and remove
    the need for a lot of defensive code typically needed with non-functional projects.
    Enjoy!
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch05.html#idm45400867135648-marker)) Ideally the hotest, spiciest flavor
    you can find. Flames should be shooting from your mouth as you eat!
  prefs: []
  type: TYPE_NORMAL
- en: '^([2](ch05.html#idm45400866574816-marker)) Read more about it here: [*https://en.wikipedia.org/wiki/SOLID*](https://en.wikipedia.org/wiki/SOLID)
    - or if you prefer video then here’s one presented by yours truly: [*https://www.youtube.com/watch?v=0vJb_B47J6U*](https://www.youtube.com/watch?v=0vJb_B47J6U)'
  prefs: []
  type: TYPE_NORMAL
- en: '^([3](ch05.html#idm45400865400736-marker)) See it for yourself here: [*https://ramdajs.com/*](https://ramdajs.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch05.html#idm45400864138112-marker)) I’d guess that’s where they get their
    name
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch05.html#idm45400863100640-marker)) Also, congratulations for making
    it this far. Although it probably didn’t take you anywhere so much time as it
    did me!!
  prefs: []
  type: TYPE_NORMAL
- en: '^([6](ch05.html#idm45400863096432-marker)) For the non-initiated, these are
    the main baddies in the British SF TV series Doctor Who. See them in action here:
    [*https://www.youtube.com/watch?v=d77jOE2Cjx8*](https://www.youtube.com/watch?v=d77jOE2Cjx8)'
  prefs: []
  type: TYPE_NORMAL
