["```cs\nprivate readonly Func<Person, DateTime, string> SayHello =\n    (Person p, DateTime today) => today + \" : \" + \"Hello \" + p.Name;\n```", "```cs\nprivate IEnumerable<Func<Employee, string>> descriptors = new []\n{\n    x => \"First Name = \" + x.firstName,\n    x => \"Last Name = \" + x.lastName,\n    x => \"MiddleNames = string.Join(\" \", x.MiddleNames)\n}\n\npublic string DescribeEmployee(Employee emp) =>\n   string.Join(Environment.NewLine, descriptors.Select(x => x(emp)));\n```", "```cs\npublic bool IsPasswordValid(string password)\n{\n   if(password.Length <= 6)\n      return false;\n\n   if(password.Length > 20)\n       return false;\n\n   if(!password.Any(x => Char.IsLower(x)))\n      return false;\n\n   if(!password.Any(x => Char.IsUpper(x)))\n      return false;\n\n   if(!password.Any(x => Char.IsSymbol(x)))\n      return false;\n\n   if(password.Contains(\"Justin\", StringComparison.OrdinalIgnoreCase)\n      && password.Contains(\"Bieber\", StringComparison.OrdinalIgnoreCase))\n       return false;\n\n   return true;\n}\n```", "```cs\npublic bool IsPasswordValid(string password) =>\n    new Func<string, bool>[]\n    {\n        x => x.Length > 6,\n        x => x.Length <= 20,\n        x => x.Any(y => Char.IsLower(y)),\n        x => x.Any(y => Char.IsUpper(y)),\n        x => x.Any(y => Char.IsSymbol(y)),\n        x => !x.Contains(\"Justin\", StringComparison.OrdinalIgnoreCase)\n            && !x.Contains(\"Bieber\", StringComparison.OrdinalIgnoreCase)\n    }.All(f => f(password));\n```", "```cs\npublic static bool IsValid<T>(this T @this, params Func<T,bool>[] rules) =>\n    rules.All(x => x(@this));\n```", "```cs\npublic bool IsPasswordValid(string password) =>\n    password.IsValid(\n        x => x.Length > 6,\n        x => x.Length <= 20,\n        x => x.Any(y => Char.IsLower(y)),\n        x => x.Any(y => Char.IsUpper(y)),\n        x => x.Any(y => Char.IsSymbol(y)),\n        x => !x.Contains(\"Justin\", StringComparison.OrdinalIgnoreCase)\n            && !x.Contains(\"Bieber\", StringComparison.OrdinalIgnoreCase)\n    )\n```", "```cs\npublic static bool IsInvalid<T>(this T @this, params Func<string,bool>[] rules) =>\n    rules.Any(x => @this);\n```", "```cs\npublic bool IsPasswordValid(string password) =>\n    !password.IsInvalid(\n        x => x.Length <= 6,\n        x => x.Length > 20,\n        x => !x.Any(y => Char.IsLower(y)),\n        x => !x.Any(y => Char.IsUpper(y)),\n        x => !x.Any(y => Char.IsSymbol(y)),\n        x => x.Contains(\"Justin\", StringComparison.OrdinalIgnoreCase)\n            && x.Contains(\"Bieber\", StringComparison.OrdinalIgnoreCase)\n    )\n```", "```cs\npublic static bool IsValid<T>(this T @this, params Func<T,bool>[] rules) =>\n rules.All(x => x(@this));\n\npublic static bool IsInvalid<T>(this T @this, params Func<T,bool>[] rules) =>\n !@this.IsValid(rules);\n```", "```cs\ndecimal ApplyTax(decimal income)\n{\n if (income <= 12570)\n  return income;\n else if (income <=50270)\n\t return income * 0.8M;\n else if (income <= 150000)\n\t return income * 0.6M;\n else\n\t return income * 0.55M;\n}\n```", "```cs\nvar inputValue = 25000M;\nvar updatedValue = inputValue.Match(\n (x => x <= 12570, x => x),\n (x => x <= 50270, x => x * 0.8M),\n (x => x <= 150000, x => x * 0.6M)\n).DefaultMatch(x => x * 0.55M);\n```", "```cs\npublic static class ExtensionMethods\n{\n\tpublic static TOutput Match<TInput, TOutput>(\n\t                             this TInput @this,\n\t                             params (Func<TInput, bool> IsMatch,\n\t                             Func<TInput, TOutput> Transform)[] matches)\n\t{\n\t\tvar match = matches.FirstOrDefault(x => x.IsMatch(@this));\n\t\tvar returnValue = match.Transform(@this);\n\t\treturn returnValue;\n\t}\n}\n```", "```cs\npublic static MatchValueOrDefault<TInput, TOutput> Match<TInput, TOutput>(\n  this TInput @this,\n  params (Func<TInput, bool>,\n  Func<TInput, TOutput>)[] predicates)\n{\n\tvar match = predicates.FirstOrDefault(x => x.Item1(@this));\n\tvar returnValue = match?.Item2(@this);\n\treturn new MatchValueOrDefault<TInput, TOutput>(returnValue, @this);\n}\n\npublic class MatchValueOrDefault<TInput, TOutput>\n{\n private readonly TOutput value;\n private readonly TInput originalValue;\n\n public MatchValueOrDefault(TOutput value, TInput originalValue)\n {\n \tthis.value = value;\n \tthis.originalValue = originalValue;\n }\n\npublic TOutput DefaultMatch(Func<TInput, TOutput> defaultMatch)\n{\n if (EqualityComparer<TOutput>.Default.Equals(default, this.value))\n {\n \treturn defaultMatch(this.originalValue);\n }\n else\n  {\n  \treturn this.value;\n  }\n}\n```", "```cs\npublic static MatchValueOrDefault<TInput, TOutput> Match<TInput, TOutput>(\n  this TInput @this,\n  params KeyValuePair<Func<TInput, bool>, Func<TInput, TOutput>>[] predicates)\n{\n    var match = predicates.FirstOrDefault(x => x.Key(@this));\n    var returnValue = match.Value(@this);\n    return new MatchValueOrDefault<TInput, TOutput>(returnValue, @this);\n}\n```", "```cs\nvar inputValue = 25000M;\nvar updatedValue = inputValue.Match(\n\tnew KeyValuePair<Func<decimal, bool>, Func<decimal, decimal>>(\n\t\tx => x <= 12570, x => x),\n\tnew KeyValuePair<Func<decimal, bool>, Func<decimal, decimal>>(\n\t\tx => x <= 50270, x => x * 0.8M),\n\tnew KeyValuePair<Func<decimal, bool>, Func<decimal, decimal>>(\n\t\tx => x <= 150000, x => x * 0.6M)\n).DefaultMatch(x => x * 0.55M);\n```", "```cs\nvar doctorLookup = new []\n{\n\t( 1, \"William Hartnell\" ),\n\t( 2, \"Patrick Troughton\" ),\n\t( 3, \"Jon Pertwee\" ),\n\t( 4, \"Tom Baker\" )\n}.ToDictionary(x => x.Item1, x => x.Item2);\n\nvar fifthDoctorInfo = $\"The 5th Doctor was played by {doctorLookup[5]}\";\n```", "```cs\nvar doctorLookup = new []\n{\n\t( 1, \"William Hartnell\" ),\n\t( 2, \"Patrick Troughton\" ),\n\t( 3, \"Jon Pertwee\" ),\n\t( 4, \"Tom Baker\" )\n}.ToDictionary(x => x.Item1, x => x.Item2);\n\nvar fifthDoctorActor = doctorLookup.ContainsKey(5) ? doctorLookup[5] : \"An Unknown Actor\";\n\nvar fifthDoctorInfo = $\"The 5th Doctor was played by {fifthDoctorActor}\";\n```", "```cs\n var fifthDoctorActor = doctorLookup.TryGetValue(5, out string value) ? value : \"An Unknown Actor\";\n```", "```cs\npublic static class ExtensionMethods\n{\n\tpublic static Func<TKey, TValue> ToLookup<TKey,TValue>(\n\t  this IDictionary<TKey,TValue> @this)\n\t{\n\t\treturn x => @this.TryGetValue(x, out TValue? value) ? value : default;\n\t}\n\n\tpublic static Func<TKey, TValue> ToLookup<TKey,TValue>(\n\t  this IDictionary<TKey,TValue> @this,\n\t  TValue defaultVal)\n\t{\n\t\treturn x => @this.ContainsKey(x) ? @this[x] : defaultVal;\n\t}\n}\n```", "```cs\nvar doctorLookup = new []\n{\n\t( 1, \"William Hartnell\" ),\n\t( 2, \"Patrick Troughton\" ),\n\t( 3, \"Jon Pertwee\" ),\n\t( 4, \"Tom Baker\" )\n}.ToDictionary(x => x.Item1, x => x.Item2)\n\t.ToLookup(\"An Unknown Actor\");\n\nvar fifthDoctorInfo = $\"The 5th Doctor was played by {doctorLookup(5)}\";\n// output = \"The 5th Doctor was played by An Unknown Actor\"\n```", "```cs\npublic Settings GetSettings()\n{\n\tvar settings = new Settings();\n\n\tvar retriesString = ConfigurationManager.AppSettings[\"NumberOfRetries\"];\n\tvar retriesHasValue = int.TryParse(retriesString, out var retriesInt);\n\tif(retriesHasValue)\n\t\tsettings.NumberOfRetries = retriesInt;\n\telse\n\t\tsettings.NumberOfRetries = 5;\n\n\tvar pollingHourStr = ConfigurationManager.AppSettings[\"HourToStartPollingAt\"];\n\tvar pollingHourHasValue = int.TryParse(pollingHourStr, out var pollingHourInt);\n\tif(pollingHourHasValue)\n\t\tsettings.HourToStartPollingAt = pollingHourInt;\n\telse\n\t\tsettings.HourToStartPollingAt = 0;\n\n\tvar alertEmailStr = ConfigurationManager.AppSettings[\"AlertEmailAddress\"];\n\tif(string.IsNullOrWhiteSpace(alertEmailStr))\n\t\tsettings.AlertEmailAddress = \"test@thecompany.net\";\n\telse\n\t\tsettings.AlertEmailAddress = aea.ToString();\n\n\tvar serverNameString = ConfigurationManager.AppSettings[\"ServerName\"];\n\tif(string.IsNullOrWhiteSpace(serverNameString))\n\t\tsettings.ServerName = \"TestServer\";\n\telse\n\t\tsettings.ServerName = sn.ToString();\n\n\treturn settings;\n}\n```", "```cs\npublic static class ExtensionMethods\n{\n\tpublic static int ToIntOrDefault(this object @this, int defaultVal = 0) =>\n\t\tint.TryParse(@this?.ToString() ?? string.Empty, out var parsedValue)\n\t\t      ? parsedValue\n\t\t      : defaultVal;\n\n\tpublic static string ToStringOrDefault(this object @this, string defaultVal = \"\") =>\n\t\tstring.IsNullOrWhiteSpace(@this?.ToString() ?? string.Empty)\n\t        ? defaultVal\n\t        : @this.ToString();\n}\n```", "```cs\npublic Settings GetSettings() =>\n\tnew Settings\n\t{\n\t\tNumberOfRetries = ConfigurationManager.AppSettings[\"NumberOfRetries\"]\n\t                                 .ToIntOrDefault(5),\n\t\tHourToStartPollingAt = ConfigurationManager.AppSettings[\"HourToStartPollingAt\"]\n\t\t                                .ToIntOrDefault(0),\n\t\tAlertEmailAddress = ConfigurationManager.AppSettings[\"AlertEmailAddress\"]\n                                  .ToStringOrDefault(\"test@thecompany.net\"),\n\t\tServerName = ConfigurationManager.AppSettings[\"ServerName\"]\n\t\t                                .ToStringOrDefault(\"TestServer\"),\n\n\t};\n```", "```cs\npublic IEnumerable<int> GenerateRandomNumbers()\n{\n\tvar rnd = new Random();\n\tvar returnValue = new List<int>();\n\tfor (var i = 0; i < 100; i++)\n\t{\n\t\treturnValue.Add(rnd.Next(1, 100));\n\t}\n\treturn returnValue;\n}\n\npublic bool ContainsConsecutiveNumbers(IEnumerable<int> data)\n{\n\t// OK, you caught me out OrderBy isn't strictly Imperative, but\n\t// there's no way I'm going to write out a sorting algorithm out\n\t// here just to prove a point!\n\tvar sortedData = data.OrderBy(x => x).ToArray();\n\n\tfor (var i = 0; i < sortedData.Length - 1; i++)\n\t{\n\t\tif ((sortedData[i] + 1) == sortedData[i + 1])\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvar result = ContainsConsecutiveNumbers(GenerateRandomNumbers());\nConsole.WriteLine(result);\n```", "```cs\npublic static bool Any<T>(this IEnumerable<T> @this, Func<T, T, bool> evaluator)\n{\n\tusing var enumerator = @this.GetEnumerator();\n\tvar hasElements = enumerator.MoveNext();\n\treturn hasElements && Any(enumerator, evaluator, enumerator.Current);\n}\n\nprivate static bool Any<T>(IEnumerator<T> enumerator,\n\t\tFunc<T, T, bool> evaluator,\n\t\tT previousElement)\n{\n\tvar moreItems = enumerator.MoveNext();\n\treturn moreItems && (evaluator(previousElement, enumerator.Current)\n\t\t? true\n\t\t: Any(enumerator, evaluator, enumerator.Current));\n\n}\n```", "```cs\npublic IEnumerable<int> GenerateRandomNumbers()\n{\n var rnd = new Random();\n\n var returnValue = Enumerable.Repeat(0, 100)\n  .Select(x => rnd.Next(1, 100));\n return returnValue;\n}\n\npublic bool ContainsConsecutiveNumbers(IEnumerable<int> data)\n{\n var sortedData = data.OrderBy(x => x).ToArray();\n var result = sortedData.Any((prev, curr) => cur == prev + 1);\n return result;\n}\n```", "```cs\npublic static bool All<T>(this IEnumerator<T> enumerator, Func<T,T,bool> evaluator, T previousElement)\n{\n\tvar moreItems = enumerator.MoveNext();\n\treturn moreItems\n\t\t? evaluator(previousElement, enumerator.Current)\n\t\t\t\t? All(enumerator, evaluator, enumerator.Current)\n\t\t\t\t: false\n\t\t: true;\n}\n\npublic static bool All<T>(this IEnumerable<T> @this, Func<T,T,bool> evaluator)\n{\n\tusing var enumerator = @this.GetEnumerator();\n\tvar hasElements = enumerator.MoveNext();\n\treturn hasElements\n\t ? All(enumerator, evaluator, enumerator.Current)\n\t : true;\n}\n```", "```cs\nvar gameState = new State\n{\n  IsAlive = true,\n  HitPoints = 100\n};\n\nwhile(gameState.IsAlive)\n{\n  var message = this.ComposeMessageToUser(gameState);\n  var userInput = this.InteractWithUser(message);\n  this.UpdateState(gameState, userInput);\n\n  if(gameState.HitPoints <= 0)\n    gameState.IsAlive = false;\n}\n```", "```cs\npublic static class ExtensionMethods\n{\n\tpublic static T AggregateUntil<T>(\n\t  this T @this,\n\t  Func<T,bool> endCondition,\n\t  Func<T,T> update) =>\n\t\tendCondition(@this)\n\t\t\t ? @this\n\t\t\t : AggregateUntil(update(@this), endCondition, update);\n}\n```", "```cs\nvar gameState = new State\n{\n  IsAlive = true,\n  HitPoints = 100\n};\n\nvar endState = gameState.AggregateUntil(\n       x => x.HitPoints <= 0,\n       x => {\n          var message = this.ComposeMessageToUser(x);\n          var userInput = this.InteractWithUser(message);\n          return this.UpdateState(x, userInput);\n       });\n```"]