- en: Chapter 9\. Collections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章。集合
- en: Using the proper collections is essential in concurrent applications. I’m not
    talking about the standard collections like `List<T>`; I assume you already know
    about those. The purpose of this chapter is to introduce newer collections that
    are specifically intended for concurrent or asynchronous use.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发应用程序中，使用适当的集合是至关重要的。我不是在谈论像`List<T>`这样的标准集合；我假设你已经了解了这些。本章的目的是介绍专门用于并发或异步使用的新集合。
- en: '*Immutable collections* are collection instances that can never change. At
    first glance, this sounds completely useless; but they’re actually very useful,
    even in single-threaded, nonconcurrent applications. Read-only operations (such
    as enumeration) act directly on the immutable instance. Write operations (such
    as adding an item) return a new immutable instance instead of changing the existing
    instance. This isn’t as wasteful as it first sounds because most of the time immutable
    collections share most of their memory. Furthermore, immutable collections have
    the advantage of being implicitly safe to access from multiple threads; since
    they cannot change, they are threadsafe.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*不可变集合* 是永远不会改变的集合实例。乍一看，这听起来完全没用；但实际上它们非常有用，即使在单线程、非并发应用程序中也是如此。只读操作（例如枚举）直接作用于不可变实例。写操作（例如添加项目）返回一个新的不可变实例，而不是更改现有实例。这并不像听起来的那么浪费，因为大多数情况下，不可变集合共享大部分内存。此外，不可变集合具有隐式安全的优势，可以从多个线程安全访问；因为它们不能改变，所以它们是线程安全的。'
- en: Tip
  id: totrans-3
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: Immutable collections are in the [`System.Collections.Immutable`](http://bit.ly/sys-coll-imm)
    NuGet package.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变集合位于[`System.Collections.Immutable`](http://bit.ly/sys-coll-imm) NuGet 包中。
- en: Immutable collections are new, but they should be considered for new development
    unless you *need* a mutable instance. If you’re not familiar with immutable collections,
    I recommend that you start with [Recipe 9.1](#recipe-immutable-stacks-queues),
    even if you don’t need a stack or queue, because I’ll cover several common patterns
    that all immutable collections follow.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变集合是新的，但在新开发中应考虑使用它们，除非你*需要*一个可变实例。如果你不熟悉不可变集合，我建议你从[Recipe 9.1](#recipe-immutable-stacks-queues)开始，即使你不需要栈或队列，因为我将覆盖所有不可变集合遵循的几种常见模式。
- en: There are special ways to more efficiently construct an immutable collection
    with lots of existing elements; the example code in these recipes only adds elements
    one at a time. The MSDN documentation has details on how to efficiently construct
    immutable collections if you need to speed up your initialization.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有特殊的方法可以更有效地构建具有大量现有元素的不可变集合；这些示例代码仅逐个添加元素。如果需要加快初始化速度，MSDN 文档详细介绍了如何高效构建不可变集合。
- en: Threadsafe collections
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 线程安全集合
- en: These mutable collection instances can be changed by multiple threads simultaneously.
    Threadsafe collections use a mixture of fine-grained locks and lock-free techniques
    to ensure that threads are blocked for a minimal amount of time (and usually aren’t
    blocked at all). For many threadsafe collections, enumeration of the collection
    creates a snapshot of the collection and then enumerates that snapshot. The key
    advantage of threadsafe collections is that they can be accessed safely from multiple
    threads, yet the operations will only block your code for a short time, if at
    all.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可变集合实例可以同时被多个线程修改。线程安全的集合使用细粒度锁和无锁技术的混合方式，以确保线程被阻塞的时间最少（通常根本不会被阻塞）。对于许多线程安全集合，枚举集合会创建集合的快照，然后枚举该快照。线程安全集合的关键优势在于，它们可以安全地从多个线程访问，但操作只会在很短的时间内（如果有的话）阻塞你的代码。
- en: Producer/consumer collections
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 生产者/消费者集合
- en: 'These mutable collection instances are designed with a specific purpose in
    mind: to allow (possibly multiple) producers to push items to the collection while
    allowing (possibly multiple) consumers to pull items out of the collection. So
    they act as a bridge between producer code and consumer code, and they also have
    an option to limit the number of items in the collection. Producer/consumer collections
    can either have a blocking or asynchronous API. For example, when the collection
    is empty, a blocking producer/consumer collection will block the calling consumer
    thread until another item is added; but an asynchronous producer/consumer collection
    will allow the calling consumer thread to asynchronously wait until another item
    is added.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可变集合实例被设计用于特定目的：允许（可能多个）生产者向集合推送项目，同时允许（可能多个）消费者从集合中取出项目。因此，它们充当生产者代码和消费者代码之间的桥梁，同时还具有限制集合中项目数量的选项。生产者/消费者集合可以具有阻塞或异步
    API。例如，当集合为空时，阻塞生产者/消费者集合将阻塞调用的消费者线程，直到添加另一个项目；但异步生产者/消费者集合将允许调用的消费者线程异步等待直到添加另一个项目。
- en: There are a number of different producer/consumer collections used in the recipes
    in this chapter, and different producer/consumer collections have different advantages.
    [Table 9-1](#producer_consumer_collect) may be helpful in determining which one
    you should use.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节中使用了许多不同的生产者/消费者集合，不同的生产者/消费者集合具有不同的优势。查看 [表 9-1](#producer_consumer_collect)
    可以帮助确定您应该使用哪一个。
- en: Table 9-1\. Producer/consumer collections
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 表9-1\. 生产者/消费者集合
- en: '| Feature | Channels | BlockingCollection<T> | BufferBlock<T> | AsyncProducer-ConsumerQueue<T>
    | AsyncCollection<T> |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 特性 | Channels | BlockingCollection<T> | BufferBlock<T> | AsyncProducer-ConsumerQueue<T>
    | AsyncCollection<T> |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| Queue semantics | ✓ | ✓ | ✓ | ✓ | ✓ |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 队列语义 | ✓ | ✓ | ✓ | ✓ | ✓ |'
- en: '| Stack/bag semantics | ✗ | ✓ | ✗ | ✗ | ✓ |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 堆栈/袋子语义 | ✗ | ✓ | ✗ | ✗ | ✓ |'
- en: '| Synchronous API | ✓ | ✓ | ✓ | ✓ | ✓ |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 同步 API | ✓ | ✓ | ✓ | ✓ | ✓ |'
- en: '| Asynchronous API | ✓ | ✗ | ✓ | ✓ | ✓ |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 异步 API | ✓ | ✗ | ✓ | ✓ | ✓ |'
- en: '| Drop items when full | ✓ | ✗ | ✗ | ✗ | ✗ |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 当满时丢弃项目 | ✓ | ✗ | ✗ | ✗ | ✗ |'
- en: '| Tested by Microsoft | ✓ | ✓ | ✓ | ✗ | ✗ |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 由 Microsoft 测试 | ✓ | ✓ | ✓ | ✗ | ✗ |'
- en: Tip
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Channels can be found in the [`System.Threading.Channels`](http://bit.ly/sys-thrd-chanls)
    NuGet package, `BufferBlock<T>` in the NuGet package for [`System.Threading.Tasks.Dataflow`](http://bit.ly/nuget-df),
    and `AsyncProducerConsumerQueue<T>` and `AsyncCollection<T>` in the NuGet package
    for [`Nito.AsyncEx`](http://bit.ly/nito-async).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Channels 可在 [`System.Threading.Channels`](http://bit.ly/sys-thrd-chanls) NuGet
    包中找到，`BufferBlock<T>` 在 [`System.Threading.Tasks.Dataflow`](http://bit.ly/nuget-df)
    NuGet 包中，`AsyncProducerConsumerQueue<T>` 和 `AsyncCollection<T>` 在 [`Nito.AsyncEx`](http://bit.ly/nito-async)
    NuGet 包中。
- en: 9.1 Immutable Stacks and Queues
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.1 不可变堆栈和队列
- en: Problem
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need a stack or queue that does not change very often and can be accessed
    by multiple threads safely.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个不经常更改且可以安全地被多个线程访问的堆栈或队列。
- en: For example, a queue can be used as a sequence of operations to perform, and
    a stack can be used as a sequence of undo operations.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，队列可以用作执行操作的序列，堆栈可以用作撤销操作的序列。
- en: Solution
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Immutable stacks and queues are the simplest immutable collections. They behave
    very similarly to the standard `Stack<T>` and `Queue<T>`. Performance-wise, immutable
    stacks and queues have the same time complexity as standard stacks and queues;
    however, in simple scenarios where the collections are updated frequently, the
    standard stacks and queues are faster.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变堆栈和队列是最简单的不可变集合。它们的行为与标准`Stack<T>`和`Queue<T>`非常相似。就性能而言，不可变堆栈和队列与标准堆栈和队列具有相同的时间复杂度；然而，在简单的频繁更新集合的场景中，标准堆栈和队列更快。
- en: 'Stacks are a first-in, last-out data structure. The following code creates
    an empty immutable stack, pushes two items, enumerates the items, and then pops
    an item:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈是一种先进后出的数据结构。以下代码创建一个空的不可变堆栈，推送两个项目，枚举项目，然后弹出一个项目：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Note in the example that we keep overwriting the local variable `stack`. Immutable
    collections follow a pattern where they return an updated collection; the original
    collection reference is unchanged. This means that once you have a reference to
    a particular immutable collection instance, it’ll never change. Consider the following
    example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在示例中我们不断重写本地变量 `stack`。不可变集合遵循一种模式，它们返回一个更新的集合；原始集合引用不会改变。这意味着一旦您获得对特定不可变集合实例的引用，它将永远不会改变。考虑以下示例：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Under the covers, the two stacks are sharing the memory used to contain the
    item `13`. This kind of implementation is very efficient while enabling you to
    easily snapshot the current state. Each immutable collection instance is naturally
    threadsafe, but immutable collections can also be used in single-threaded applications.
    In my experience, immutable collections are especially useful when the code is
    more functional or when you need to store a large number of snapshots and want
    them to share memory as much as possible.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部实现上，两个栈共享用于包含项`13`的内存。这种实现方式非常高效，同时可以轻松快速地获取当前状态的快照。每个不可变集合实例本身天然线程安全，但不可变集合也可以在单线程应用程序中使用。在我看来，不可变集合在代码更具功能性或需要存储大量快照且希望尽可能共享内存时尤为有用。
- en: 'Queues are similar to stacks, except they are a first-in, first-out data structure.
    The following code creates an empty immutable queue, enqueues two items, enumerates
    the items, and then dequeues an item:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 队列类似于栈，但是它们是先进先出的数据结构。以下代码创建了一个空的不可变队列，入队两个项，枚举这些项，然后出队一个项：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Discussion
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'This recipe introduced the two simplest immutable collections, the stack and
    the queue. It also covered several important design philosophies that are true
    for *all* immutable collections:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱介绍了两种最简单的不可变集合，栈和队列。还涵盖了几个对*所有*不可变集合都适用的重要设计理念：
- en: An instance of an immutable collection never changes.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变集合的实例永远不会改变。
- en: Since it never changes, it is naturally threadsafe.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它永远不会改变，因此天然线程安全。
- en: When you call a modifying method on an immutable collection, the new modified
    collection is returned.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您对不可变集合调用修改方法时，会返回一个新的修改后的集合。
- en: Warning
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Even though immutable collections are threadsafe, *references* to immutable
    collections are *not* threadsafe. A variable that refers to an immutable collection
    needs the same synchronization protections as any other variable (see [Chapter 12](ch12.html#synchronization)).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 即使不可变集合是线程安全的，对不可变集合的*引用*并不是线程安全的。指向不可变集合的变量需要与其他变量一样的同步保护（参见[第12章](ch12.html#synchronization)）。
- en: Immutable collections are ideal for sharing state. They don’t, however, work
    as well as communication conduits. In particular, don’t use an immutable queue
    to communicate between threads; producer/consumer queues work much better for
    that.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变集合非常适合共享状态。然而，它们不适合作为通信通道。特别是不要使用不可变队列在线程间通信；生产者/消费者队列在这方面效果更佳。
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: '`ImmutableStack<T>` and `ImmutableQueue<T>` can be found in the [`System.Collections.Immutable`](http://bit.ly/sys-coll-imm)
    NuGet package.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImmutableStack<T>`和`ImmutableQueue<T>`可以在[`System.Collections.Immutable`](http://bit.ly/sys-coll-imm)
    NuGet包中找到。'
- en: See Also
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Recipe 9.6](#recipe-blocking-queues) covers threadsafe (blocking) mutable
    queues.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[菜谱 9.6](#recipe-blocking-queues)介绍了线程安全（阻塞式）可变队列。'
- en: '[Recipe 9.7](#recipe-blocking-stacks-bags) covers threadsafe (blocking) mutable
    stacks.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[菜谱 9.7](#recipe-blocking-stacks-bags)介绍了线程安全（阻塞式）可变栈。'
- en: '[Recipe 9.8](#recipe-async-queues) covers async-compatible mutable queues.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[菜谱 9.8](#recipe-async-queues)介绍了支持异步的可变队列。'
- en: '[Recipe 9.11](#recipe-async-stacks-bags) covers async-compatible mutable stacks.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[菜谱 9.11](#recipe-async-stacks-bags)介绍了支持异步的可变栈。'
- en: '[Recipe 9.12](#recipe-blocking-async-queues) covers blocking/asynchronous mutable
    queues.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[菜谱 9.12](#recipe-blocking-async-queues)介绍了阻塞/异步可变队列。'
- en: 9.2 Immutable Lists
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.2 不可变列表
- en: Problem
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need a data structure you can index into that does not change very often
    and can be accessed by multiple threads safely.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一种可以进行索引而不经常变化且可以安全地被多个线程访问的数据结构。
- en: Solution
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: A list is a general-purpose data structure that can be used for all kinds of
    application states. Immutable lists do allow indexing, but you need to be aware
    of the performance characteristics. They’re not just a drop-in replacement for
    `List<T>`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是一种通用的数据结构，可以用于各种应用状态。不可变列表允许索引，但需要注意性能特征。它们并不仅仅是`List<T>`的简单替代品。
- en: '`ImmutableList<T>` does support similar methods as `List<T>`, as the following
    example shows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImmutableList<T>`支持与`List<T>`类似的方法，如以下示例所示：'
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The immutable list is internally organized as a binary tree so that immutable
    list instances may maximize the amount of memory they share with other instances.
    As a result, there are performance differences between `ImmutableList<T>` and
    `List<T>` for some common operations ([Table 9-2](#performance_imm_lists)).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变列表在内部组织为二叉树，以便不可变列表实例可以最大化与其他实例共享的内存量。因此，对于一些常见操作，`ImmutableList<T>`和`List<T>`之间存在性能差异（参见[表 9-2](#performance_imm_lists)）。
- en: Table 9-2\. Performance difference of immutable lists
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9-2\. 不可变列表的性能差异
- en: '| Operation | List<T> | ImmutableList<T> |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | List<T> | ImmutableList<T> |'
- en: '| --- | --- | --- |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Add | amortized O(1) | O(log N) |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 添加 | 摊销 O(1) | O(log N) |'
- en: '| Insert | O(N) | O(log N) |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 插入 | O(N) | O(log N) |'
- en: '| RemoveAt | O(N) | O(log N) |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 移除在 | O(N) | O(log N) |'
- en: '| Item[index] | O(1) | O(log N) |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 项[索引] | O(1) | O(log N) |'
- en: Of note, the indexing operation for `ImmutableList<T>` is O(log N), not O(1),
    as you may expect. If you’re replacing `List<T>` with `ImmutableList<T>` in existing
    code, you’ll need to consider how your algorithms access items in the collection.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，`ImmutableList<T>`的索引操作是O(log N)，而不是您可能期望的O(1)。如果在现有代码中用`ImmutableList<T>`替换`List<T>`，则需要考虑如何访问集合中的项。
- en: 'This means that you should use `foreach` instead of `for` whenever possible.
    A `foreach` loop over an `ImmutableList<T>` executes in O(N) time, while a `for`
    loop over the same collection executes in O(N * log N) time:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在可能的情况下应使用`foreach`而不是`for`。在`ImmutableList<T>`上执行的`foreach`循环的时间复杂度为O(N)，而在相同集合上执行的`for`循环的时间复杂度为O(N
    * log N)：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Discussion
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '`ImmutableList<T>` is a good general-purpose data structure, but because of
    its performance differences, you can’t blindly replace all your `List<T>` uses
    with it. `List<T>` is commonly used by default—it’s the one you use unless you
    *need* a different collection. `ImmutableList<T>` isn’t quite that ubiquitous;
    you’ll need to consider the other immutable collections carefully and choose the
    one that makes the most sense for your situation.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImmutableList<T>`是一个很好的通用数据结构，但由于其性能差异，您不能盲目地用它替换所有`List<T>`的用法。`List<T>`通常是默认使用的——除非*需要*不同的集合。`ImmutableList<T>`并不是如此普遍；您需要仔细考虑其他不可变集合，并选择最适合您情况的那个。'
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: '`ImmutableList<T>` is in the [`System.Collections.Immutable`](http://bit.ly/sys-coll-imm)
    NuGet package.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImmutableList<T>`位于[`System.Collections.Immutable`](http://bit.ly/sys-coll-imm)
    NuGet包中。'
- en: See Also
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 9.1](#recipe-immutable-stacks-queues) covers immutable stacks and queues,
    which are like lists that only allow certain elements to be accessed.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[食谱 9.1](#recipe-immutable-stacks-queues)涵盖了不可变堆栈和队列，类似于只允许访问特定元素的列表。'
- en: The [MSDN documentation on `ImmutableList<T>.Builder`](http://bit.ly/msdn-iml)
    covers an efficient way to populate an immutable list.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[MSDN对`ImmutableList<T>.Builder`的文档](http://bit.ly/msdn-iml)介绍了一种有效的填充不可变列表的方法。'
- en: 9.3 Immutable Sets
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.3 不可变集合
- en: Problem
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need a data structure that does not need to store duplicates, does not change
    very often, and can be accessed by multiple threads safely.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个数据结构，不需要存储重复项，不经常更改，并且可以安全地由多个线程访问。
- en: For example, an index of words from a file would be a good use case for a set.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，文件中的单词索引是集合的一个好用例。
- en: Solution
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'There are two immutable set types: `ImmutableHashSet<T>` is a collection of
    unique items, and `ImmutableSortedSet<T>` is a *sorted* collection of unique items.
    Both types have a similar interface:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种不可变集合类型：`ImmutableHashSet<T>`是独特项的集合，而`ImmutableSortedSet<T>`是*排序*的独特项集合。这两种类型有相似的接口：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Only the sorted set allows indexing into it like a list:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 只有排序集合允许像列表一样进行索引：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Unsorted sets and sorted sets have similar performance (see [Table 9-3](#performance_of_sets)).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 未排序集合和排序集合具有类似的性能（参见[表 9-3](#performance_of_sets)）。
- en: Table 9-3\. Performance of immutable sets
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9-3\. 不可变集合的性能
- en: '| Operation | ImmutableHashSet<T> | ImmutableSortedSet<T> |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | ImmutableHashSet<T> | ImmutableSortedSet<T> |'
- en: '| --- | --- | --- |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Add | O(log N) | O(log N) |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 添加 | O(log N) | O(log N) |'
- en: '| Remove | O(log N) | O(log N) |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 移除 | O(log N) | O(log N) |'
- en: '| Item[index] | n/a | O(log N) |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 项[索引] | n/a | O(log N) |'
- en: However, I recommend you use an unsorted set unless you know it needs to be
    sorted. Many types only support basic equality and not full comparison, so an
    unsorted set can be used for many more types than a sorted set.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我建议您使用未排序集合，除非您知道它需要排序。许多类型仅支持基本相等性而不支持完全比较，因此未排序集合可用于比排序集合更多的类型。
- en: 'One important note about the sorted set is that its indexing is O(log N), not
    O(1), just like `ImmutableList<T>`, which is covered in [Recipe 9.2](#recipe-immutable-lists).
    This means that the same caveat applies in this situation: you should use `foreach`
    instead of `for` whenever possible with an `ImmutableSortedSet<T>`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 关于排序集的一个重要说明是，其索引是 O(log N)，而不是 O(1)，就像 `ImmutableList<T>` 一样，它在 [Recipe 9.2](#recipe-immutable-lists)
    中讨论过。这意味着在这种情况下应该尽可能使用 `foreach` 而不是 `for` 来处理 `ImmutableSortedSet<T>`。
- en: Discussion
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Immutable sets are useful data structures, but populating a large immutable
    set can be slow. Most immutable collections have special builders that can be
    used to construct them quickly in a mutable way and then convert them into an
    immutable collection. This is true for many immutable collections, but I’ve found
    them most useful for immutable sets.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变集合是有用的数据结构，但是填充大型不可变集合可能会很慢。大多数不可变集合都有特殊的构建器，可以在可变方式下快速构建它们，然后将其转换为不可变集合。对许多不可变集合而言是如此，但我发现它们对于不可变集合特别有用。
- en: Tip
  id: totrans-97
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: '`ImmutableHashSet<T>` and `ImmutableSortedSet<T>` are in the NuGet [`System.Collections.Immutable`](http://bit.ly/sys-coll-imm)
    package.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImmutableHashSet<T>` 和 `ImmutableSortedSet<T>` 在 NuGet [`System.Collections.Immutable`](http://bit.ly/sys-coll-imm)
    包中。'
- en: See Also
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 9.7](#recipe-blocking-stacks-bags) covers threadsafe mutable bags,
    which are similar to sets.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 9.7](#recipe-blocking-stacks-bags) 讨论了线程安全的可变背包，它们类似于集合。'
- en: '[Recipe 9.11](#recipe-async-stacks-bags) covers async-compatible mutable bags.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 9.11](#recipe-async-stacks-bags) 讨论了与异步兼容的可变背包。'
- en: The [MSDN documentation on `ImmutableHashSet<T>.Builder`](http://bit.ly/msdn-imh)
    covers an efficient way to populate an immutable hash set.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[MSDN documentation on `ImmutableHashSet<T>.Builder`](http://bit.ly/msdn-imh)
    讨论了填充不可变哈希集的高效方式。'
- en: The [MSDN documentation on `ImmutableSortedSet<T>.Builder`](http://bit.ly/msdn-ims)
    covers an efficient way to populate an immutable sorted set.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[MSDN documentation on `ImmutableSortedSet<T>.Builder`](http://bit.ly/msdn-ims)
    讨论了填充不可变排序集的高效方式。'
- en: 9.4 Immutable Dictionaries
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.4 不可变字典
- en: Problem
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need a key/value collection that does not change very often and can be accessed
    by multiple threads safely. For example, you may want to store reference data
    in a *lookup collection*; the reference data rarely changes but should be available
    to different threads.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个不经常更改且可以安全地被多个线程访问的键/值集合。例如，您可能希望在*查找集合*中存储参考数据，这些参考数据很少更改，但应该对不同线程可用。
- en: Solution
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'There are two immutable dictionary types: `ImmutableDictionary<TKey, TValue>`
    and `ImmutableSortedDictionary<TKey, TValue>`. As you may be able to guess from
    their names, while the items in `ImmutableDictionary` have an unpredictable order,
    `ImmutableSortedDictionary` ensures that its elements are sorted.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种不可变字典类型：`ImmutableDictionary<TKey, TValue>` 和 `ImmutableSortedDictionary<TKey,
    TValue>`。从它们的名称可以猜出，`ImmutableDictionary` 中的项没有可预测的顺序，而 `ImmutableSortedDictionary`
    确保其元素已排序。
- en: 'Both of these collection types have very similar members:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种集合类型都有非常相似的成员：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note the use of `SetItem`. In a mutable dictionary, you could try doing something
    like `dictionary[key] = item`, but immutable dictionaries must return the updated
    immutable dictionary, so they use the `SetItem` method instead:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用 `SetItem`。在可变字典中，您可以尝试像 `dictionary[key] = item` 这样做，但是不可变字典必须返回更新后的不可变字典，因此它们使用
    `SetItem` 方法代替：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Unsorted dictionaries and sorted dictionaries have similar performance, but
    I recommend you use an unordered dictionary unless you need your elements to be
    sorted (see [Table 9-4](#performance_dictionaries)). Unsorted dictionaries can
    be a little faster overall. Furthermore, unsorted dictionaries can be used with
    any key types, whereas sorted dictionaries require their key types to be fully
    comparable.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 无序字典和有序字典有类似的性能，但我建议您使用无序字典，除非您需要元素排序（参见 [Table 9-4](#performance_dictionaries)）。总体而言，无序字典可能略快。此外，无序字典可用于任何键类型，而有序字典要求它们的键类型完全可比较。
- en: Table 9-4\. Performance of immutable dictionaries
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 表9-4 不可变字典的性能
- en: '| Operation | ImmutableDictionary<TK,TV> | ImmutableSortedDictionary<TK,TV>
    |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | ImmutableDictionary<TKey, TV> | ImmutableSortedDictionary<TKey, TV>
    |'
- en: '| --- | --- | --- |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Add | O(log N) | O(log N) |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| Add | O(log N) | O(log N) |'
- en: '| SetItem | O(log N) | O(log N) |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| SetItem | O(log N) | O(log N) |'
- en: '| Item[key] | O(log N) | O(log N) |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| Item[key] | O(log N) | O(log N) |'
- en: '| Remove | O(log N) | O(log N) |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| Remove | O(log N) | O(log N) |'
- en: Discussion
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: In my experience, dictionaries are a common and useful tool when dealing with
    application state. They can be used in any kind of key/value or lookup scenario.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的经验中，字典是处理应用程序状态时常见且有用的工具。它们可用于任何类型的键/值或查找场景。
- en: Like other immutable collections, immutable dictionaries have a builder mechanism
    for efficient construction if the dictionary contains many elements. For example,
    if you load your initial reference data at startup, you should use the builder
    mechanism to construct the initial immutable dictionary. On the other hand, if
    your reference data is gradually built up during your application’s execution,
    then using the regular immutable dictionary `Add` method is likely acceptable.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他不可变集合一样，不可变字典具有用于高效构建的构建器机制，如果字典包含许多元素。例如，如果在启动时加载初始引用数据，则应使用构建器机制来构建初始的不可变字典。另一方面，如果您的引用数据在应用程序执行过程中逐渐构建，则使用常规的不可变字典
    `Add` 方法可能是可接受的。
- en: Tip
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: '`ImmutableDictionary<TK, TV>` and `ImmutableSortedDictionary<TK, TV>` are in
    the [`System.Collections.Immutable`](http://bit.ly/sys-coll-imm) NuGet package.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImmutableDictionary<TK, TV>` 和 `ImmutableSortedDictionary<TK, TV>` 包含在 [`System.Collections.Immutable`](http://bit.ly/sys-coll-imm)
    NuGet 包中。'
- en: See Also
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 9.5](#recipe-threadsafe-dictionaries) covers threadsafe mutable dictionaries.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 9.5 节](#recipe-threadsafe-dictionaries) 涵盖了线程安全的可变字典。'
- en: The [MSDN documentation on `ImmutableDictionary<TK,TV>.Builder`](http://bit.ly/msdn-imd)
    covers an efficient way to populate an immutable dictionary.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[MSDN 关于 `ImmutableDictionary<TK,TV>.Builder`](http://bit.ly/msdn-imd) 涵盖了填充不可变字典的高效方式。'
- en: The [MSDN documentation on `ImmutableSortedDictionary<TK,TV>.Builder`](http://bit.ly/msdn-isd)
    covers an efficient way to populate an immutable sorted dictionary.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[MSDN 关于 `ImmutableSortedDictionary<TK,TV>.Builder`](http://bit.ly/msdn-isd)
    涵盖了填充不可变排序字典的高效方式。'
- en: 9.5 Threadsafe Dictionaries
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.5 线程安全的字典
- en: Problem
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have a key/value collection (e.g., an in-memory cache) that you need to
    keep in sync, even though multiple threads are both reading from and writing to
    it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您有一个键/值集合（例如内存中的缓存），需要保持同步，尽管多个线程同时读取和写入它。
- en: Solution
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: The `ConcurrentDictionary<TKey, TValue>` type in the .NET framework is a true
    gem of a data structure. It’s threadsafe, using a mixture of fine-grained locks
    and lock-free techniques to ensure fast access in the vast majority of scenarios.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 框架中的 `ConcurrentDictionary<TKey, TValue>` 类型是一个真正的宝藏数据结构。它是线程安全的，使用细粒度锁和无锁技术的混合确保在绝大多数场景下快速访问。
- en: Its API does take a bit of getting used to. It’s very different from the standard
    `Dictionary<TKey, TValue>` type, since it must deal with concurrent access from
    multiple threads. But once you have learned the basics in this recipe, you’ll
    find `ConcurrentDictionary<TKey, TValue>` to be one of the most useful collection
    types.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 其 API 确实需要花一点时间适应。它与标准的 `Dictionary<TKey, TValue>` 类型非常不同，因为它必须处理来自多个线程的并发访问。但是一旦您在这个示例中学会了基础知识，您会发现
    `ConcurrentDictionary<TKey, TValue>` 是最有用的集合类型之一。
- en: 'First, let’s learn how to write a value to the collection. To set the value
    of a key, you can use `AddOrUpdate`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们学习如何向集合写入值。要设置键的值，您可以使用 `AddOrUpdate`：
- en: '[PRE9]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`AddOrUpdate` is a bit complex because it must do several things, depending
    on the current contents of the concurrent dictionary. The first method argument
    is the key. The second argument is a delegate that transforms the key (in this
    case, `0`) into a value to be added to the dictionary (in this case, `"Zero"`).
    This delegate is only invoked if the key doesn’t exist in the dictionary. The
    third argument is another delegate that transforms the key (`0`) and the old value
    into an updated value to be stored in the dictionary (`"Zero"`). This delegate
    is only invoked if the key does exist in the dictionary. `AddOrUpdate` returns
    the new value for that key (the same value that was returned by one of the delegates).'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddOrUpdate` 有点复杂，因为它必须根据并发字典的当前内容执行几项操作。第一个方法参数是键。第二个参数是一个委托，将键（在本例中为 `0`）转换为要添加到字典中的值（在本例中为
    `"Zero"`）。仅当字典中不存在该键时才会调用此委托。第三个参数是另一个委托，将键（`0`）和旧值转换为要存储在字典中的更新值（`"Zero"`）。仅当字典中存在该键时才会调用此委托。`AddOrUpdate`
    返回该键的新值（由委托之一返回的相同值）。'
- en: 'Now for the part that really bends your brain: in order for the concurrent
    dictionary to work properly, `AddOrUpdate` *might* have to invoke either (or both)
    delegates multiple times. This is very rare, but it *can* happen. So your delegates
    should be simple and fast and not cause side effects. This means that your delegate
    should only create the value; it shouldn’t change any other variables in your
    application. The same principle holds for all delegates you pass to methods on
    `ConcurrentDictionary<TKey, TValue>`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下真正让你感到头疼的部分：为了使并发字典正常工作，`AddOrUpdate`可能必须多次调用一个或两个委托。这种情况非常罕见，但是确实可能发生。因此，你的委托应该简单快速，不应该引起任何副作用。这意味着你的委托应该只创建值；它不应该更改应用程序中的任何其他变量。对于你传递给`ConcurrentDictionary<TKey,
    TValue>`方法的所有委托，都应遵循相同的原则。
- en: 'There are several other ways to add values to a dictionary. One shortcut is
    to just use indexing syntax:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几种其他向字典添加值的方法。其中一种捷径是只使用索引语法：
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Indexing syntax is less powerful; it doesn’t give you the ability to update
    a value based on the existing value. The syntax is simpler and works fine, however,
    if you already have the value you want to store in the dictionary.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 索引语法功能较弱；它不提供根据现有值更新值的能力。然而，语法更简单，如果你已经有了要存储在字典中的值，它可以正常工作。
- en: 'Let’s look at how to read a value. This can be easily done via `TryGetValue`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 查看如何读取值。这可以通过`TryGetValue`轻松完成：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`TryGetValue` will return `true` and set the `out` value if the key was found
    in the dictionary. If the key wasn’t found, `TryGetValue` will return `false`.
    You can also use indexing syntax to read values, but I find that much less useful
    because it’ll throw an exception if a key isn’t found. Keep in mind that a concurrent
    dictionary has multiple threads reading, updating, adding, and removing values;
    in many situations, it’s difficult to know whether a key exists or not until you
    attempt to read it.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在字典中找到键，则`TryGetValue`将返回`true`并设置`out`值。如果未找到键，则`TryGetValue`将返回`false`。你也可以使用索引语法来读取值，但我发现这不太有用，因为如果找不到键，它会抛出异常。请记住，并发字典有多个线程同时读取、更新、添加和删除值；在许多情况下，很难知道键是否存在，直到尝试读取它为止。
- en: 'Removing values is just as easy as reading them:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 删除值与读取值一样简单：
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`TryRemove` is almost identical to `TryGetValue`, except (of course) it removes
    the key/value pair if the key was found in the dictionary.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`TryRemove`与`TryGetValue`几乎相同（当然），只有在字典中找到键时才会删除键/值对。'
- en: Discussion
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Although `ConcurrentDictionary<TKey, TValue>` is threadsafe, that doesn’t mean
    its operations are atomic. If multiple threads call `AddOrUpdate` concurrently,
    it’s possible for both of them to detect that the key isn’t present, and both
    of them concurrently execute their delegate that creates a new value.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`ConcurrentDictionary<TKey, TValue>`是线程安全的，但这并不意味着它的操作是原子的。如果多个线程同时调用`AddOrUpdate`，它们可能都会检测到键不存在，并且同时执行创建新值的委托。
- en: I think `ConcurrentDictionary<TKey, TValue>` is awesome, mainly because of the
    incredibly powerful `AddOrUpdate` method. However, it doesn’t fit the bill in
    every situation. `ConcurrentDictionary<TKey, TValue>` is best when you have multiple
    threads reading and writing to a shared collection. If the updates are not constant
    (if they’re more rare), then `ImmutableDictionary<TKey, TValue>` may be a better
    choice.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为`ConcurrentDictionary<TKey, TValue>`非常棒，主要是因为其功能强大的`AddOrUpdate`方法。然而，并不是所有情况下它都适用。`ConcurrentDictionary<TKey,
    TValue>`在多线程读写共享集合时表现最佳。如果更新不频繁（如果它们更为稀少），那么`ImmutableDictionary<TKey, TValue>`可能更合适。
- en: '`ConcurrentDictionary<TKey, TValue>` is best in a shared-data situation, where
    multiple threads share the same collection. If some threads only add elements
    and other threads only remove elements, you’d be better served by a producer/consumer
    collection.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentDictionary<TKey, TValue>`最适合于共享数据的情况，多个线程共享同一集合。如果一些线程仅添加元素，而其他线程仅删除元素，则生产者/消费者集合会更好地满足你的需求。'
- en: '`ConcurrentDictionary<TKey, TValue>` isn’t the only threadsafe collection.
    The BCL also provides `ConcurrentStack<T>`, `ConcurrentQueue<T>`, and `ConcurrentBag<T>`.
    Threadsafe collections are commonly used as producer/consumer collections, which
    will be covered in the rest of this chapter.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentDictionary<TKey, TValue>`不是唯一的线程安全集合。BCL还提供`ConcurrentStack<T>`、`ConcurrentQueue<T>`和`ConcurrentBag<T>`。线程安全集合通常用作生产者/消费者集合，在本章的其余部分将进行介绍。'
- en: See Also
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 9.4](#recipe-immutable-dictionaries) covers immutable dictionaries,
    which are ideal if the contents of the dictionary change very rarely.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[配方 9.4](#recipe-immutable-dictionaries)介绍了不可变字典，如果字典的内容变化非常少，则非常理想。'
- en: 9.6 Blocking Queues
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.6 阻塞队列
- en: Problem
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need a conduit to pass messages or data from one thread to another. For
    example, one thread could be loading data, which it pushes down the conduit as
    it loads; meanwhile, there are other threads on the receiving end of the conduit
    that receive the data and process it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个传输介质，用于将消息或数据从一个线程传递到另一个线程。例如，一个线程可以加载数据，并在加载时将其推送到传输介质；同时，传输介质的接收端有其他线程接收并处理数据。
- en: Solution
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: The .NET type `BlockingCollection<T>` was designed to be this kind of conduit.
    By default, `BlockingCollection<T>` is a blocking queue, providing first-in, first-out
    behavior.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 类型`BlockingCollection<T>`设计为这种类型的传输介质。默认情况下，`BlockingCollection<T>`是一个阻塞队列，提供先进先出的行为。
- en: 'A blocking queue needs to be shared by multiple threads, and it’s usually defined
    as a private, read-only field:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 阻塞队列需要被多个线程共享，并且通常被定义为私有的只读字段：
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Usually, a thread will *either* add items to the collection *or* remove items
    from the collection, but not both. Threads that add items are called *producer
    threads*, and threads that remove items are called *consumer threads*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个线程*要么*向集合添加项目*要么*从集合中移除项目，但不会两者兼而有之。添加项目的线程称为*生产者线程*，移除项目的线程称为*消费者线程*。
- en: Producer threads can add items by calling `Add`, and when the producer thread
    is finished (when all items have been added), it can then finish the collection
    by calling `CompleteAdding`. This notifies the collection that no more items will
    be added to it, and the collection can then inform its consumers that there are
    no more items.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 生产者线程可以通过调用`Add`添加项目，并且当生产者线程完成时（即所有项目都已添加），可以通过调用`CompleteAdding`完成集合。这会通知集合不再添加项目，并且集合可以通知其消费者没有更多项目。
- en: 'Here’s a simple example of a producer that adds two items and then marks the
    collection complete:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的生产者示例，添加两个项目，然后标记集合为完成：
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Consumer threads usually run in a loop, waiting for the next item and then
    processing it. If you take the producer code and put it in a separate thread (e.g.,
    via `Task.Run`), then you can consume those items like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者线程通常在循环中运行，等待下一个项目然后处理它。如果将生产者代码放在单独的线程中（例如通过`Task.Run`），那么可以像这样消费这些项目：
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you want to have multiple consumers, `GetConsumingEnumerable` can be called
    from multiple threads at the same time. However, each item is only passed to one
    of those threads. When the collection is completed, the enumerable completes.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望有多个消费者，可以同时从多个线程调用`GetConsumingEnumerable`。然而，每个项目只会传递给这些线程中的一个。当集合完成时，可枚举对象完成。
- en: Discussion
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The preceding examples all use `GetConsumingEnumerable` for the consumer threads;
    this is the most common scenario. However, there’s also a `Take` member that enables
    a consumer to just consume a single item rather than run a loop consuming all
    the items.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例都使用了`GetConsumingEnumerable`来作为消费者线程的一种常见情况。然而，也有一个`Take`成员允许消费者只消费单个项目而不是运行循环消费所有项目。
- en: When you use conduits like this, you do need to consider what happens if your
    producers run faster than your consumers. If you’re producing items faster than
    you can consume them, then you may need to throttle your queue.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用这样的传输介质时，需要考虑如果生产者运行得比消费者快会发生什么。如果您生成的项目比您消费它们的速度快，那么可能需要限制您的队列。
- en: Blocking queues are great when you have a separate thread (such as a threadpool
    thread) acting as a producer or consumer. They’re not as great when you want to
    access the conduit asynchronously—for example, if a UI thread wants to act as
    a consumer. [Recipe 9.8](#recipe-async-queues) covers asynchronous queues.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要异步访问传输介质时，例如UI线程希望充当消费者时，阻塞队列非常适合（例如线程池线程）。[配方 9.8](#recipe-async-queues)介绍了异步队列。
- en: Tip
  id: totrans-174
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Whenever you introduce a conduit like this into your application, consider switching
    to the TPL Dataflow library. A lot of the time, using TPL Dataflow is simpler
    than building your own conduits and background threads.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您将这样的传输介质引入到您的应用程序中时，请考虑切换到TPL Dataflow库。大多数情况下，使用TPL Dataflow比构建自己的传输介质和后台线程更简单。
- en: '`BufferBlock<T>` from TPL Dataflow can act like a blocking queue, and TPL Dataflow
    allows building a pipeline or mesh for processing. In many simpler cases, though,
    ordinary blocking queues like `BlockingCollection<T>` are the appropriate design
    choice.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`BufferBlock<T>`来自TPL Dataflow可以像阻塞队列一样工作，TPL Dataflow允许构建用于处理的管道或网格。然而，在许多更简单的情况下，像`BlockingCollection<T>`这样的普通阻塞队列是适当的设计选择。'
- en: You could also use `AsyncEx` library’s `AsyncProducerConsumerQueue<T>`, which
    can act like a blocking queue.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`AsyncEx`库的`AsyncProducerConsumerQueue<T>`，它可以像阻塞队列一样工作。
- en: See Also
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 9.7](#recipe-blocking-stacks-bags) covers blocking stacks and bags,
    if you want a similar conduit without first-in, first-out semantics.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[9.7 食谱](#recipe-blocking-stacks-bags) 涵盖了阻塞栈和袋，如果您需要类似的传输通道而不需要先进先出语义。'
- en: '[Recipe 9.8](#recipe-async-queues) covers queues that have asynchronous rather
    than blocking APIs.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[9.8 食谱](#recipe-async-queues) 涵盖了具有异步而不是阻塞API的队列。'
- en: '[Recipe 9.12](#recipe-blocking-async-queues) covers queues that have both asynchronous
    and blocking APIs.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[9.12 食谱](#recipe-blocking-async-queues) 涵盖了既有异步又有阻塞API的队列。'
- en: '[Recipe 9.9](#recipe-queue-throttle) covers queues that throttle their number
    of items.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[9.9 食谱](#recipe-queue-throttle) 涵盖了限制其项目数量的队列。'
- en: 9.7 Blocking Stacks and Bags
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.7 阻塞栈和袋
- en: Problem
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need a conduit to pass messages or data from one thread to another, but
    you don’t want (or need) the conduit to have first-in, first-out semantics.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个传输通道来从一个线程传递消息或数据到另一个线程，但不希望（或不需要）这个通道具有先进先出语义。
- en: Solution
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: The .NET type `BlockingCollection<T>` acts as a blocking queue by default, but
    it can also act like any kind of producer/consumer collection. It’s actually a
    wrapper around a threadsafe collection that implements `IProducerConsumerCollection<T>`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 类型`BlockingCollection<T>`默认作为阻塞队列，但也可以像任何种类的生产者/消费者集合一样工作。实际上，它是围绕实现`IProducerConsumerCollection<T>`的线程安全集合的包装器。
- en: 'So, you can create a `BlockingCollection<T>` with last-in, first-out (stack)
    semantics or unordered (bag) semantics:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你可以创建一个具有后进先出（栈）语义或无序（袋）语义的`BlockingCollection<T>`：
- en: '[PRE16]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It’s important to keep in mind that there are now race conditions around the
    ordering of the items. If you let the same producer code execute before any consumer
    code, and then execute the consumer code after the producer code, then the order
    of the items will be exactly like a stack:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，现在围绕项目排序存在竞争条件。如果让相同的生产者代码在任何消费者代码之前执行，然后在生产者代码之后执行消费者代码，则项目的顺序将完全像栈一样：
- en: '[PRE17]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When the producer code and consumer code are on different threads (which is
    the usual case), the consumer always gets the most recently added item next. For
    example, the producer could add `7`, the consumer could take `7`, the producer
    could add `13`, and the consumer could take `13`. The consumer does *not* wait
    for `CompleteAdding` to be called before it returns the first item.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当生产者代码和消费者代码在不同的线程上（这是通常情况），消费者始终获取最近添加的项目。例如，生产者可以添加`7`，消费者可以取`7`，生产者可以添加`13`，消费者可以取`13`。消费者在返回第一个项目之前*不会*等待`CompleteAdding`的调用。
- en: Discussion
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The same considerations around throttling that apply to blocking queues also
    apply to blocking stacks and bags. If your producers run faster than your consumers
    and you need to limit the memory usage of your blocking stack/bag, you can use
    throttling as shown in [Recipe 9.9](#recipe-queue-throttle).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 关于阻塞队列应用于限制内存使用的节流考虑与阻塞栈和袋相同。如果您的生产者运行得比消费者快，而且您需要限制阻塞栈/袋的内存使用，可以像[9.9 食谱](#recipe-queue-throttle)中所示那样使用节流。
- en: This recipe uses `GetConsumingEnumerable` for the consumer code; this is the
    most common scenario. There is also a `Take` member that enables a consumer to
    just consume a single item rather than run a loop consuming all the items.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本篇介绍使用`GetConsumingEnumerable`作为消费者代码；这是最常见的场景。还有一个`Take`成员，允许消费者只消费单个项目，而不是运行循环消费所有项目。
- en: If you want to access shared stacks or bags asynchronously rather than by blocking
    (for example, having your UI thread act as a consumer), see [Recipe 9.11](#recipe-async-stacks-bags).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想异步访问共享的栈或袋而不是通过阻塞（例如，让您的UI线程充当消费者），请参阅[9.11 食谱](#recipe-async-stacks-bags)。
- en: See Also
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 9.6](#recipe-blocking-queues) covers blocking queues, which are much
    more commonly used than blocking stacks or bags.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[9.6 食谱](#recipe-blocking-queues) 涵盖了阻塞队列，比阻塞栈或袋更常用。'
- en: '[Recipe 9.11](#recipe-async-stacks-bags) covers asynchronous stacks and bags.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[9.11 食谱](#recipe-async-stacks-bags) 涵盖了异步栈和袋。'
- en: 9.8 Asynchronous Queues
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.8 异步队列
- en: Problem
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need a conduit to pass messages or data from one part of code to another
    in a first-in, first-out manner, without blocking threads.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一种传递消息或数据的通道，以先进先出的方式从代码的一部分传递到另一部分，而不阻塞线程。
- en: For example, one piece of code could be loading data, which it pushes down the
    conduit as it loads; meanwhile, the UI thread is receiving the data and displaying
    it.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个代码片段可以正在加载数据，它在加载时将数据推送到通道中；同时，UI 线程正在接收数据并显示它。
- en: Solution
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: What you need is a queue with an asynchronous API. There is no type like this
    in the core .NET framework, but there are a couple of options available from NuGet.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的是一个具有异步 API 的队列。核心 .NET 框架中没有这样的类型，但可以从 NuGet 上找到几个选项。
- en: 'The first option is to use Channels. Channels are a modern library for asynchronous
    producer/consumer collections, with a nice emphasis on high performance for high-volume
    scenarios. Producers generally write items to a channel using `WriteAsync`, and
    when they are all done producing, one of them calls `Complete` to notify the channel
    that there won’t be any more items in the future, like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种选项是使用 Channels。Channels 是用于异步生产者/消费者集合的现代库，非常注重高性能处理高频场景。生产者通常使用`WriteAsync`向通道写入项，在它们完成所有生产后，其中一个调用`Complete`通知通道未来不会再有更多项，例如：
- en: '[PRE18]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This more natural consumer code uses asynchronous streams; see [Chapter 3](ch03.html#async-streams)
    for more information. As of this writing, asynchronous streams are only available
    on the newest .NET platforms; older platforms can use the following pattern:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这种更自然的消费者代码使用了异步流；更多信息请参阅[第 3 章](ch03.html#async-streams)。截至本文撰写时，异步流仅适用于最新的
    .NET 平台；旧平台可以使用以下模式：
- en: '[PRE19]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note the double `while` loop in the consumer code for older platforms; this
    is normal. `WaitToReadAsync` will asynchronously wait until an item is available
    or the channel has been marked complete; it returns `true` when there is an item
    available to be read. `TryRead` will attempt to read an item (immediately and
    synchronously), returning `true` if an item was read. If `TryRead` returns `false`,
    this could be because there’s no item available *right now*, or it could be because
    the channel has been marked complete and there will never be any more items. So,
    when `TryRead` returns `false`, the inner `while` loop exits and the consumer
    again calls `WaitToReadAsync`, which will return `false` if the channel has been
    marked complete.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意旧平台消费者代码中的双重`while`循环；这是正常的。`WaitToReadAsync`会异步等待直到有可读取的项或通道已标记为完成；当有可读取的项时返回`true`。`TryRead`会尝试读取一个项（立即和同步），如果读取到项则返回`true`。如果`TryRead`返回`false`，这可能是因为当前没有可用项，或者可能是因为通道已标记为完成且以后不会再有更多项。因此，当`TryRead`返回`false`时，内部`while`循环退出，并且消费者再次调用`WaitToReadAsync`，如果通道已标记为完成，则返回`false`。
- en: 'Another producer/consumer queue option is to use `BufferBlock<T>` from the
    TPL Dataflow library. `BufferBlock<T>` is quite similar to a channel. The following
    example shows how to declare a `BufferBlock<T>`, what the producer code looks
    like, and what the consumer code looks like:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种生产者/消费者队列选项是使用 TPL Dataflow 库中的`BufferBlock<T>`。`BufferBlock<T>`与通道相似。以下示例显示了如何声明`BufferBlock<T>`，生产者代码的样子以及消费者代码的样子：
- en: '[PRE20]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The example consumer code uses `OutputAvailableAsync`, which is really only
    useful if you have just a single consumer. If you have multiple consumers, it
    is possible that `OutputAvailableAsync` will return `true` for more than one consumer
    even though there is only one item. If the queue is completed, then `ReceiveAsync`
    will throw `InvalidOperationException`. So if you have multiple consumers, the
    consumer code usually looks more like the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 示例消费者代码使用了`OutputAvailableAsync`，如果只有一个消费者则确实很有用。如果有多个消费者，则可能`OutputAvailableAsync`会对多个消费者返回`true`，即使只有一个项。如果队列已完成，则`ReceiveAsync`将抛出`InvalidOperationException`。因此，如果有多个消费者，则消费者代码通常看起来更像是以下这样：
- en: '[PRE21]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can also use the `AsyncProducerConsumerQueue<T>` type from the `Nito.AsyncEx`
    NuGet library. The API is similar to but not exactly the same as `BufferBlock<T>`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`Nito.AsyncEx` NuGet 库中的`AsyncProducerConsumerQueue<T>`类型。其 API 与`BufferBlock<T>`类似但并非完全相同：
- en: '[PRE22]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This consumer code also uses `OutputAvailableAsync` and has the same problems
    as `BufferBlock<T>`. If you have multiple consumers, the consumer code usually
    looks more like the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个消费者代码还使用了`OutputAvailableAsync`，并且和`BufferBlock<T>`一样存在相同的问题。如果有多个消费者，消费者代码通常看起来更像是以下这样：
- en: '[PRE23]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Discussion
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: I recommend using Channels for asynchronous producer/consumer queues whenever
    possible. They have multiple sampling options in addition to throttling, and they
    are highly optimized. However, if your application logic can be expressed as a
    “pipeline” through which data flows, then TPL Dataflow may be a more natural fit.
    The final option is `AsyncProducerConsumerQueue<T>`, which may make sense if your
    application is already using other types from `AsyncEx`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在可能的情况下尽量使用通道作为异步生产者/消费者队列。除了节流外，它们还具有多个抽样选项，并且高度优化。但是，如果您的应用逻辑可以表达为通过其流动数据的“管道”，那么TPL
    Dataflow可能是一个更自然的选择。最后的选择是`AsyncProducerConsumerQueue<T>`，如果您的应用已经使用了来自`AsyncEx`的其他类型，则可能会有意义。
- en: Tip
  id: totrans-221
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: Channels can be found in the [`System.Threading.Channels`](http://bit.ly/sys-thrd-chanls)
    NuGet package. The `BufferBlock<T>` type is in the [`System.Threading.Tasks.Dataflow`](http://bit.ly/nuget-df)
    NuGet package. The `AsyncProducerConsumerQueue<T>` type is in the [`Nito.AsyncEx`](http://bit.ly/nito-async)
    NuGet package.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通道可以在[`System.Threading.Channels`](http://bit.ly/sys-thrd-chanls) NuGet包中找到。`BufferBlock<T>`
    类型在[`System.Threading.Tasks.Dataflow`](http://bit.ly/nuget-df) NuGet包中。`AsyncProducerConsumerQueue<T>`
    类型在[`Nito.AsyncEx`](http://bit.ly/nito-async) NuGet包中。
- en: See Also
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 9.6](#recipe-blocking-queues) covers producer/consumer queues with
    blocking semantics rather than asynchronous semantics.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[9.6 配方](#recipe-blocking-queues)涵盖了具有阻塞语义而不是异步语义的生产者/消费者队列。'
- en: '[Recipe 9.12](#recipe-blocking-async-queues) covers producer/consumer queues
    that have *both* blocking and asynchronous semantics.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[9.12 配方](#recipe-blocking-async-queues)涵盖了既有阻塞又有异步语义的生产者/消费者队列。'
- en: '[Recipe 9.7](#recipe-blocking-stacks-bags) covers asynchronous stacks and bags
    if you want a similar conduit without first-in, first-out semantics.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[9.7 配方](#recipe-blocking-stacks-bags)涵盖了异步堆栈和包，如果您想要一个没有先入先出语义的类似通道。'
- en: 9.9 Throttling Queues
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.9 节流队列
- en: Problem
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have a producer/consumer queue, and your producers might run faster than
    your consumers, which would cause undesired memory usage. You also want to keep
    all the queue items, so you need a way to throttle the producers.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您有一个生产者/消费者队列，而且您的生产者可能比消费者运行得更快，这将导致不必要的内存使用。您还想保留所有队列项，因此需要一种方法来限制生产者的速度。
- en: Solution
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: When you use producer/consumer queues, you do need to consider what happens
    if your producers run faster than your consumers, unless you’re sure that your
    consumers will *always* run faster. If you’re producing items faster than you
    can consume them, then you may need to throttle your queue. You can throttle a
    queue by designating a maximum number of elements. When a queue is “full,” it
    applies backpressure to the producers, blocking them until there is more room
    in the queue.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用生产者/消费者队列时，除非您确信消费者总是更快，否则您确实需要考虑如果您的生产者比您的消费者跑得快会发生什么。如果您生产的速度快于消费速度，则可能需要对队列进行节流。您可以通过指定最大元素数量来节流队列。当队列“满”时，它会向生产者施加背压，阻塞它们直到队列有更多空间。
- en: 'Channels can be throttled by creating a bounded channel rather than an unbounded
    channel. Since channels are asynchronous, producers will be asynchronously throttled:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 通道可以通过创建有界通道而不是无界通道来进行节流。由于通道是异步的，生产者将被异步地限制：
- en: '[PRE24]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`BufferBlock<T>` has built-in support for throttling, explored in more detail
    in [Recipe 5.4](ch05.html#recipe-dataflow-throttling). With dataflow blocks, you
    set the `BoundedCapacity` option:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`BufferBlock<T>` 内置支持节流，详细探讨请参阅[5.4 配方](ch05.html#recipe-dataflow-throttling)。使用数据流块时，您可以设置`BoundedCapacity`选项：'
- en: '[PRE25]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The producer in the preceding code snippet uses the asynchronous `SendAsync`
    API; the same approach works for the synchronous `Post` API.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段中的生产者使用了异步的`SendAsync` API；同样的方法适用于同步的`Post` API。
- en: 'The `AsyncEx` type `AsyncProducerConsumerQueue<T>` has support for throttling.
    Just construct the queue with the appropriate value:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncEx` 类型 `AsyncProducerConsumerQueue<T>` 支持节流。只需用适当的值构造队列：'
- en: '[PRE26]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Blocking producer/consumer queues also support throttling. You can use `BlockingCollection<T>`
    to throttle the number of items by passing the appropriate value when you create
    it:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 阻塞生产者/消费者队列还支持节流。您可以使用`BlockingCollection<T>`在创建时传递适当的值来限制项目的数量：
- en: '[PRE27]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Discussion
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Throttling is necessary whenever producers can run faster than consumers. One
    scenario you must consider is whether it’s possible for producers to run faster
    than consumers if your application is running on different hardware than yours.
    Some throttling is usually necessary to ensure your application will run on future
    hardware and/or cloud instances, which are generally more constrained than developer
    machines.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当生产者可能比消费者运行得更快时，节流是必要的。一个您必须考虑的场景是，如果您的应用程序运行在不同于您的硬件的环境中，生产者是否可能比消费者更快。通常需要一些节流以确保您的应用程序可以在未来的硬件和/或云实例上运行，这些硬件和实例通常比开发者的机器更受限制。
- en: Throttling will cause backpressure on the producers, slowing them down to ensure
    that consumers are able to process all items, without causing undue memory pressure.
    If you don’t need to process *every* item, you can choose to sample instead of
    throttle. See [Recipe 9.10](#recipe-queue-sample) for sampling producer/consumer
    queues.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 节流将对生产者施加反压力，使其放慢速度以确保消费者能够处理所有项目，而不会导致不必要的内存压力。如果您不需要处理*每个*项目，您可以选择采样而不是节流。请参见[食谱
    9.10](#recipe-queue-sample)了解采样生产者/消费者队列的方法。
- en: Tip
  id: totrans-244
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Channels are in the [`System.Threading.Channels`](http://bit.ly/sys-thrd-chanls)
    NuGet package. The `BufferBlock<T>` type is in the [`System.Threading.Tasks.Dataflow`](http://bit.ly/nuget-df)
    NuGet package. The `AsyncProducerConsumerQueue<T>` type is in the [`Nito.AsyncEx`](http://bit.ly/nito-async)
    NuGet package.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通道位于[`System.Threading.Channels`](http://bit.ly/sys-thrd-chanls) NuGet包中。`BufferBlock<T>`类型位于[`System.Threading.Tasks.Dataflow`](http://bit.ly/nuget-df)
    NuGet包中。`AsyncProducerConsumerQueue<T>`类型位于[`Nito.AsyncEx`](http://bit.ly/nito-async)
    NuGet包中。
- en: See Also
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Recipe 9.8](#recipe-async-queues) covers basic asynchronous producer/consumer
    queue usage.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[食谱 9.8](#recipe-async-queues)介绍了基本的异步生产者/消费者队列使用方法。'
- en: '[Recipe 9.6](#recipe-blocking-queues) covers basic synchronous producer/consumer
    queue usage.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[食谱 9.6](#recipe-blocking-queues)介绍了基本的同步生产者/消费者队列使用方法。'
- en: '[Recipe 9.10](#recipe-queue-sample) covers sampling producer/consumer queues,
    an alternative to throttling.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '[食谱 9.10](#recipe-queue-sample)介绍了采样生产者/消费者队列，作为节流的替代方法。'
- en: 9.10 Sampling Queues
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.10 采样队列
- en: Problem
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have a producer/consumer queue, but your producers may run faster than your
    consumers, which is causing undesired memory usage. You don’t need to keep all
    the queue items; you need a way to filter the queue items so that the slower producers
    only need to process the important ones.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 您有一个生产者/消费者队列，但您的生产者可能比您的消费者运行得更快，这导致了不必要的内存使用。您不需要保留所有队列项目；您需要一种方法来筛选队列项目，以便较慢的生产者只需要处理重要的项目。
- en: Solution
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Channels are the easiest way to apply sampling to input items. One common example
    is to always take the latest *n* items, discarding the oldest items once the queue
    is full:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 通道是应用输入项采样的最简单方法。一个常见的例子是始终获取最新的*n*个项目，在队列满时丢弃最旧的项目：
- en: '[PRE28]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is an easy way to tame input streams, keeping them from flooding your consumers.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种简单的方法来控制输入流，防止其淹没消费者。
- en: 'There are other `BoundedChannelFullMode` options as well. For example, if you
    wanted the *oldest* items to be preserved, you could discard any new items once
    the channel is full:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他`BoundedChannelFullMode`选项。例如，如果您希望保留*最旧*的项目，您可以在通道满时丢弃任何新项目：
- en: '[PRE29]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Discussion
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Channels are great for doing simple sampling like this. A particularly useful
    option in many situations is `BoundedChannelFullMode.DropOldest`. More complex
    sampling would need to be done by the consumers themselves.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 通道非常适合进行简单的采样。在许多情况下特别有用的选项是`BoundedChannelFullMode.DropOldest`。更复杂的采样可能需要由消费者自行完成。
- en: If you need to do time-based sampling, such as “only 10 items per second,” use
    System.Reactive. System.Reactive has natural operators for working with time.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要进行基于时间的采样，例如“每秒只有10个项目”，请使用System.Reactive。System.Reactive具有与时间相关的自然操作符。
- en: Tip
  id: totrans-262
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Channels are located in the [`System.Threading.Channels`](http://bit.ly/sys-thrd-chanls)
    NuGet package.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 通道位于[`System.Threading.Channels`](http://bit.ly/sys-thrd-chanls) NuGet包中。
- en: See Also
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Recipe 9.9](#recipe-queue-throttle) covers throttling channels, which limits
    the number of items in the channel by blocking producers rather than dropping
    items.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[食谱 9.9](#recipe-queue-throttle)介绍了限制通道流量的节流功能，通过阻塞生产者而不是丢弃项目来限制通道中的项目数量。'
- en: '[Recipe 9.8](#recipe-async-queues) covers basic channel usage, including producer
    and consumer code.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[食谱 9.8](#recipe-async-queues)介绍了基本的通道使用，包括生产者和消费者代码。'
- en: '[Recipe 6.4](ch06.html#recipe-rx-throttle) covers throttling and sampling using
    `System.Reactive`, which supports time-based sampling.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[菜谱 6.4](ch06.html#recipe-rx-throttle)介绍了使用`System.Reactive`进行节流和采样，支持基于时间的采样。'
- en: 9.11 Asynchronous Stacks and Bags
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.11 异步堆栈和包
- en: Problem
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need a conduit to pass messages or data from one part of code to another,
    but you don’t want (or need) the conduit to have first-in, first-out semantics.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个传输管道，将消息或数据从代码的一部分传递到另一部分，但您不希望（或不需要）该传输管道具有先进先出的语义。
- en: Solution
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: The `Nito.AsyncEx` library provides a type `AsyncCollection<T>`, which acts
    like an asynchronous queue by default, but it can also act like any kind of producer/consumer
    collection. The wrapper around an `IProducerConsumerCollection<T>`, `AsyncCollection<T>`
    is also the `async` equivalent of the .NET `BlockingCollection<T>`, which is covered
    in [Recipe 9.7](#recipe-blocking-stacks-bags).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`Nito.AsyncEx`库提供了类型`AsyncCollection<T>`，默认情况下类似于异步队列，但也可以充当任何类型的生产者/消费者集合。围绕`IProducerConsumerCollection<T>`的包装器，`AsyncCollection<T>`也是.NET
    `BlockingCollection<T>`的`async`等效项，该项在[菜谱 9.7](#recipe-blocking-stacks-bags)中有所介绍。'
- en: '`AsyncCollection<T>` supports last-in, first-out (stack) or unordered (bag)
    semantics, based on whatever collection you pass to its constructor:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncCollection<T>`支持后进先出（堆栈）或无序（包）语义，取决于您传递给其构造函数的集合类型：'
- en: '[PRE30]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note that there’s a race condition around the ordering of items in the stack.
    If all producers complete before consumers start, then the order of items is like
    a regular stack:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在堆栈中项目顺序方面存在竞争条件。如果所有生产者在消费者开始之前完成，则项目的顺序类似于常规堆栈：
- en: '[PRE31]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When both producers and consumers are executing concurrently (which is the usual
    case), the consumer will always get the most recently added item next. This will
    cause the collection as a whole to act not quite like a stack. Of course, the
    bag collection has no ordering at all.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当生产者和消费者同时执行（这是通常情况），消费者总是会获取最近添加的项。这将导致整个集合的行为不完全像一个堆栈。当然，包集合根本没有排序。
- en: '`AsyncCollection<T>` has support for throttling, which is necessary if producers
    may add to the collection faster than the consumers can remove from it. Just construct
    the collection with the appropriate value:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncCollection<T>`支持节流，如果生产者可能比消费者更快地向集合中添加内容，则这是必需的。只需使用适当的值构造集合即可：'
- en: '[PRE32]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now the same producer code will asynchronously wait as needed:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在相同的生产者代码将根据需要异步等待：
- en: '[PRE33]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The example consumer code uses `OutputAvailableAsync`, which has the same limitation
    described in [Recipe 9.8](#recipe-async-queues). If you have multiple consumers,
    the consumer code usually looks more like the following:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 示例消费者代码使用了`OutputAvailableAsync`，其限制与[菜谱 9.8](#recipe-async-queues)中描述的相同。如果有多个消费者，消费者代码通常看起来更像以下内容：
- en: '[PRE34]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Discussion
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '`AsyncCollection<T>` is just the asynchronous equivalent of `BlockingCollection<T>`
    with a slightly different API.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncCollection<T>`只是具有略有不同API的`BlockingCollection<T>`的异步等效项。'
- en: Tip
  id: totrans-286
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The `AsyncCollection<T>` type is in the [`Nito.AsyncEx`](http://bit.ly/nito-async)
    NuGet package.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncCollection<T>`类型位于[`Nito.AsyncEx`](http://bit.ly/nito-async) NuGet包中。'
- en: See Also
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 9.8](#recipe-async-queues) covers asynchronous queues, which are much
    more common than asynchronous stacks or bags.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '[菜谱 9.8](#recipe-async-queues)介绍了异步队列，比异步堆栈或包更为常见。'
- en: '[Recipe 9.7](#recipe-blocking-stacks-bags) covers synchronous (blocking) stacks
    and bags.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '[菜谱 9.7](#recipe-blocking-stacks-bags)介绍了同步（阻塞）堆栈和包。'
- en: 9.12 Blocking/Asynchronous Queues
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.12 阻塞/异步队列
- en: Problem
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need a conduit to pass messages or data from one part of code to another
    in a first-in, first-out manner, and you need the flexibility to treat either
    the producer end or the consumer end as synchronous or asynchronous.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个传输管道，以先进先出的方式将消息或数据从代码的一部分传递到另一部分，并且需要灵活性，以将生产者端或消费者端视为同步或异步。
- en: For example, a background thread may be loading data and pushing it into the
    conduit, and you want the background thread to synchronously block if the conduit
    is too full. At the same time, the UI thread is receiving data from the conduit,
    and you want the UI thread to asynchronously pull data from the conduit so the
    UI remains responsive.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，后台线程可能正在加载数据并将其推送到传输管道中，如果传输管道太满，您希望后台线程同步阻塞。同时，UI线程正在从传输管道接收数据，您希望UI线程异步从传输管道中拉取数据，以保持UI的响应性。
- en: Solution
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: After looking at blocking queues in [Recipe 9.6](#recipe-blocking-queues) and
    asynchronous queues in [Recipe 9.8](#recipe-async-queues), now we’ll learn about
    a few queue types that support both blocking and asynchronous APIs.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看[第9.6节](#recipe-blocking-queues)中的阻塞队列和[第9.8节](#recipe-async-queues)中的异步队列后，现在我们将学习一些同时支持阻塞和异步API的队列类型。
- en: 'The first is `BufferBlock<T>` and `ActionBlock<T>` from the TPL Dataflow NuGet
    library. `BufferBlock<T>` can be easily used as an asynchronous producer/consumer
    queue (see [Recipe 9.8](#recipe-async-queues) for more details):'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是TPL Dataflow NuGet库中的`BufferBlock<T>`和`ActionBlock<T>`。`BufferBlock<T>`可以很容易地用作异步生产者/消费者队列（详见[第9.8节](#recipe-async-queues)）：
- en: '[PRE35]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As you can see in the following example, `BufferBlock<T>` also supports a synchronous
    API for both producers and consumers:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在以下示例中所见，`BufferBlock<T>`也支持生产者和消费者的同步API：
- en: '[PRE36]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The consumer code using `BufferBlock<T>` is rather awkward, since it isn’t
    the “dataflow way” of writing code. The TPL Dataflow library includes a number
    of blocks that can be linked together, enabling you to define a reactive mesh.
    In this case, a producer/consumer queue completing with a particular action can
    be defined using `ActionBlock<T>`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`BufferBlock<T>`的消费者代码相当笨拙，因为这不是编写代码的“数据流方式”。TPL Dataflow库包括许多可以链接在一起的块，使您能够定义反应网格。在这种情况下，可以使用`ActionBlock<T>`定义完成特定操作的生产者/消费者队列：
- en: '[PRE37]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If the TPL Dataflow library isn’t available on your desired platform(s), then
    there is an `AsyncProducerConsumerQueue<T>` type in `Nito.AsyncEx` that also supports
    both synchronous and asynchronous methods:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在您期望的平台上TPL Dataflow库不可用，则`Nito.AsyncEx`中也有一个`AsyncProducerConsumerQueue<T>`类型，它还支持同步和异步方法：
- en: '[PRE38]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Discussion
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: I recommend using `BufferBlock<T>` or `ActionBlock<T>` if possible because the
    TPL Dataflow library has been more extensively tested than the `Nito.AsyncEx`
    library. However, `AsyncProducerConsumerQueue<T>` may be useful if your application
    is already using other types from the `AsyncEx` library.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，我建议使用`BufferBlock<T>`或`ActionBlock<T>`，因为TPL Dataflow库经过的测试比`Nito.AsyncEx`库更加全面。然而，如果您的应用程序已经使用了`AsyncEx`库的其他类型，那么`AsyncProducerConsumerQueue<T>`可能也会很有用。
- en: 'It is also possible to use `System.Threading.Channels` synchronously, but only
    indirectly. Their natural API is asynchronous, but since they are threadsafe collections,
    you can force them to work synchronously by wrapping your production or consumption
    code inside a `Task.Run` and then blocking on the task returned from `Task.Run`,
    like this:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以间接地使用`System.Threading.Channels`进行同步操作。它们的自然API是异步的，但由于它们是线程安全的集合，您可以通过将生产或消费代码包装在`Task.Run`中，然后阻塞`Task.Run`返回的任务来强制它们同步工作，就像这样：
- en: '[PRE39]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: TPL Dataflow blocks, `AsyncProducerConsumerQueue<T>`, and Channels all support
    throttling by passing options during construction. Throttling is necessary when
    you have producers that push items faster than your consumers can consume them,
    which could cause your application to take up large amounts of memory.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: TPL Dataflow块，`AsyncProducerConsumerQueue<T>`和Channels都支持通过在构造过程中传递选项来进行节流。当生产者推送项目比消费者消耗它们更快时，节流是必需的，这可能会导致您的应用程序占用大量内存。
- en: Tip
  id: totrans-310
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `BufferBlock<T>` and `ActionBlock<T>` types are in the [`System.Threading.Tasks.Dataflow`](http://bit.ly/nuget-df)
    NuGet package. The `AsyncProducerConsumerQueue<T>` type is in the [`Nito.AsyncEx`](http://bit.ly/nito-async)
    NuGet package. Channels are in the [`System.Threading.Channels`](http://bit.ly/sys-thrd-chanls)
    NuGet package.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`BufferBlock<T>`和`ActionBlock<T>`类型位于[`System.Threading.Tasks.Dataflow`](http://bit.ly/nuget-df)
    NuGet包中。`AsyncProducerConsumerQueue<T>`类型位于[`Nito.AsyncEx`](http://bit.ly/nito-async)
    NuGet包中。Channels位于[`System.Threading.Channels`](http://bit.ly/sys-thrd-chanls)
    NuGet包中。'
- en: See Also
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Recipe 9.6](#recipe-blocking-queues) covers blocking producer/consumer queues.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9.6节](#recipe-blocking-queues)介绍了阻塞生产者/消费者队列。'
- en: '[Recipe 9.8](#recipe-async-queues) covers asynchronous producer/consumer queues.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9.8节](#recipe-async-queues)介绍了异步生产者/消费者队列。'
- en: '[Recipe 5.4](ch05.html#recipe-dataflow-throttling) covers throttling dataflow
    blocks.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '[第5.4节](ch05.html#recipe-dataflow-throttling)介绍了数据流块的节流。'
