["```cs\nclass ThreadUnsafe\n{\n  static int _val1 = 1, _val2 = 1;\n\n  static void Go()\n  {\n    if (_val2 != 0) Console.WriteLine (_val1 / _val2);\n    _val2 = 0;\n  }\n}\n```", "```cs\nclass ThreadSafe\n{\n  static readonly object _locker = new object();\n  static int _val1 = 1, _val2 = 1;\n\n  static void Go()\n  {\n    lock (_locker)\n    {\n      if (_val2 != 0) Console.WriteLine (_val1 / _val2);\n      _val2 = 0;\n    }\n  }\n}\n```", "```cs\nMonitor.Enter (_locker);\ntry\n{\n  if (_val2 != 0) Console.WriteLine (_val1 / _val2);\n  _val2 = 0;\n}\nfinally { Monitor.Exit (_locker); }\n```", "```cs\npublic static void Enter (object obj, ref bool lockTaken);\n```", "```cs\nbool lockTaken = false;\ntry\n{\n  Monitor.Enter (_locker, ref lockTaken);\n  // Do your stuff...\n}\nfinally { if (lockTaken) Monitor.Exit (_locker); }\n```", "```cs\nclass ThreadSafe\n{\n  List <string> _list = new List <string>();\n\n  void Test()\n  {\n    lock (_list)\n    {\n      _list.Add (\"Item 1\");\n      ...\n```", "```cs\nlock (this) { ... }\n```", "```cs\nlock (typeof (Widget)) { ... }    // For protecting access to statics\n```", "```cs\nclass ThreadUnsafe\n{\n  static int _x;\n  static void Increment() { _x++; }\n  static void Assign()    { _x = 123; }\n}\n```", "```cs\nstatic readonly object _locker = new object();\nstatic int _x;\n\nstatic void Increment() { lock (_locker) _x++; }\nstatic void Assign()    { lock (_locker) _x = 123; }\n```", "```cs\nvar signal = new ManualResetEvent (false);\nint x = 0;\nnew Thread (() => { x++; signal.Set(); }).Start();\nsignal.WaitOne();\nConsole.WriteLine (x);    // 1 *(always)*\n```", "```cs\nlock (locker) { if (x != 0) y /= x; }\n```", "```cs\ndecimal _savingsBalance, _checkBalance;\n\nvoid Transfer (decimal amount)\n{\n  lock (_locker)\n  {\n    _savingsBalance += amount;\n    _checkBalance -= amount + GetBankFee();\n  }\n}\n```", "```cs\nlock (locker)\n  lock (locker)\n    lock (locker)\n    {\n       // Do something...\n    }\n```", "```cs\nMonitor.Enter (locker); Monitor.Enter (locker);  Monitor.Enter (locker); \n// Do something...\nMonitor.Exit (locker);  Monitor.Exit (locker);   Monitor.Exit (locker);\n```", "```cs\nobject locker = new object();\n\nlock (locker)\n{\n  AnotherMethod();\n  // We still have the lock - because locks are reentrant.\n}\n\nvoid AnotherMethod()\n{\n  lock (locker) { Console.WriteLine (\"Another method\"); }\n}\n```", "```cs\nobject locker1 = new object();\nobject locker2 = new object();\n\nnew Thread (() => {\n                    lock (locker1)\n                    {\n                      Thread.Sleep (1000);\n                      lock (locker2);      // Deadlock\n                    }\n                  }).Start();\nlock (locker2)\n{\n  Thread.Sleep (1000);\n  lock (locker1);                          // Deadlock\n}\n```", "```cs\n// Naming a Mutex makes it available computer-wide. Use a name that's\n// unique to your company and application (e.g., include your URL).\n\nusing var mutex = new Mutex (true, @\"Global\\oreilly.com OneAtATimeDemo\");\n// Wait a few seconds if contended, in case another instance\n// of the program is still in the process of shutting down.\n\nif (!mutex.WaitOne (TimeSpan.FromSeconds (3), false))\n{\n  Console.WriteLine (\"Another instance of the app is running. Bye!\");\n  return;\n}\ntry { RunProgram(); }\nfinally { mutex.ReleaseMutex (); }\n\nvoid RunProgram()\n{\n  Console.WriteLine (\"Running. Press Enter to exit\");\n  Console.ReadLine();\n}\n```", "```cs\nclass ThreadSafe\n{\n  static List <string> _list = new List <string>();\n\n  static void Main()\n  {\n    new Thread (AddItem).Start();\n    new Thread (AddItem).Start();\n  }\n\n  static void AddItem()\n  {\n    lock (_list) _list.Add (\"Item \" + _list.Count);\n\n    string[] items;\n    lock (_list) items = _list.ToArray();\n    foreach (string s in items) Console.WriteLine (s);\n  }\n}\n```", "```cs\nif (!_list.Contains (newItem)) _list.Add (newItem);\n```", "```cs\n_list.Clear();\n```", "```cs\n// User is a custom class with fields for user data\ninternal User RetrieveUser (int id) { ... }\n```", "```cs\nstatic class UserCache\n{\n  static Dictionary <int, User> _users = new Dictionary <int, User>();\n\n  internal static User GetUser (int id)\n  {\n    User u = null;\n\n    lock (_users)\n      if (_users.TryGetValue (id, out u))\n        return u;\n\n    u = RetrieveUser (id);           // Method to retrieve from database;\n    lock (_users) _users [id] = u;\n    return u;\n  }\n}\n```", "```cs\nstatic class UserCache\n{\n  static Dictionary <int, Task<User>> _userTasks = \n     new Dictionary <int, Task<User>>();\n\n  internal static Task<User> GetUserAsync (int id)\n  {\n    lock (_userTasks)\n      if (_userTasks.TryGetValue (id, out var userTask))\n        return userTask;\n      else\n        return _userTasks [id] = Task.Run (() => RetrieveUser (id));\n  }\n}\n```", "```cs\nint _percentComplete;\nstring _statusMessage;\n```", "```cs\nclass ProgressStatus    // Represents progress of some activity\n{\n  public readonly int PercentComplete;\n  public readonly string StatusMessage;\n\n  // This class might have many more fields...\n\n  public ProgressStatus (int percentComplete, string statusMessage)\n  {\n    PercentComplete = percentComplete;\n    StatusMessage = statusMessage;\n  }\n}\n```", "```cs\nreadonly object _statusLocker = new object();\nProgressStatus _status;\n```", "```cs\nvar status = new ProgressStatus (50, \"Working on it\");\n// Imagine we were assigning many more fields...\n// ...\nlock (_statusLocker) _status = status;    // Very brief lock\n```", "```cs\nProgressStatus status;\nlock (_statusLocker) status = _status;   // Again, a brief lock\nint pc = status.PercentComplete;\nstring msg = status.StatusMessage;\n...\n```", "```cs\nclass TheClub      // No door lists!\n{\n  static SemaphoreSlim _sem = new SemaphoreSlim (3);    // Capacity of 3\n\n  static void Main()\n  {\n    for (int i = 1; i <= 5; i++) new Thread (Enter).Start (i);\n  }\n\n  static void Enter (object id)\n  {\n    Console.WriteLine (id + \" wants to enter\");\n    _sem.Wait();\n    Console.WriteLine (id + \" is in!\");           // Only three threads\n    Thread.Sleep (1000 * (int) id);               // can be here at\n    Console.WriteLine (id + \" is leaving\");       // a time.\n    _sem.Release();\n  }\n}\n\n1 wants to enter\n1 is in!\n2 wants to enter\n2 is in!\n3 wants to enter\n3 is in!\n4 wants to enter\n5 wants to enter\n1 is leaving\n4 is in!\n2 is leaving\n5 is in!\n```", "```cs\nvar semaphore1 = new SemaphoreSlim (3);\nvar semaphore2 = new SemaphoreSlim (0); semaphore2.Release (3);\n```", "```cs\nlock (_locker)\n{\n  await Task.Delay (1000);    // Compilation error\n  ...\n}\n```", "```cs\nSemaphoreSlim _semaphore = new SemaphoreSlim (10);\n\nasync Task<byte[]> DownloadWithSemaphoreAsync (string uri)\n{\n    await _semaphore.WaitAsync();\n    try { return await new WebClient().DownloadDataTaskAsync (uri); }\n    finally { _semaphore.Release(); }\n}\n```", "```cs\npublic static async Task<IDisposable> EnterAsync (this SemaphoreSlim ss)\n{\n  await ss.WaitAsync().ConfigureAwait (false);\n  return Disposable.Create (() => ss.Release());\n}\n```", "```cs\nasync Task<byte[]> DownloadWithSemaphoreAsync (string uri)\n{\n  using (await _semaphore.EnterAsync())\n    return await new WebClient().DownloadDataTaskAsync (uri);\n}\n```", "```cs\nawait Parallel.ForEachAsync (uris,\n  new ParallelOptions { MaxDegreeOfParallelism = 10 },\n  async (uri, cancelToken) =>\n   {\n    var download = await new HttpClient().GetByteArrayAsync (uri);\n    Console.WriteLine ($\"Downloaded {download.Length} bytes\");\n  });\n```", "```cs\npublic void EnterReadLock();\npublic void ExitReadLock();\npublic void EnterWriteLock();\npublic void ExitWriteLock();\n```", "```cs\nclass SlimDemo\n{\n  static ReaderWriterLockSlim _rw = new ReaderWriterLockSlim();\n  static List<int> _items = new List<int>();\n  static Random _rand = new Random();\n\n  static void Main()\n  {\n    new Thread (Read).Start();\n    new Thread (Read).Start();\n    new Thread (Read).Start();\n\n    new Thread (Write).Start (\"A\");\n    new Thread (Write).Start (\"B\");\n  }\n\n  static void Read()\n  {\n    while (true)\n    {\n      _rw.EnterReadLock();\n      foreach (int i in _items) Thread.Sleep (10);\n      _rw.ExitReadLock();\n    }\n  }\n\n  static void Write (object threadID)\n  {\n    while (true)\n    {\n      int newNumber = GetRandNum (100);\n      _rw.EnterWriteLock();\n      _items.Add (newNumber);\n      _rw.ExitWriteLock();\n      Console.WriteLine (\"Thread \" + threadID + \" added \" + newNumber);\n      Thread.Sleep (100);\n    }\n  }\n\n  static int GetRandNum (int max) { lock (_rand) return _rand.Next(max); }\n}\n```", "```cs\nThread B added 61\nThread A added 83\nThread B added 55\nThread A added 33\n...\n```", "```cs\nConsole.WriteLine (_rw.CurrentReadCount + \" concurrent readers\");\n```", "```cs\npublic bool IsReadLockHeld            { get; }\npublic bool IsUpgradeableReadLockHeld { get; }\npublic bool IsWriteLockHeld           { get; }\n\npublic int  WaitingReadCount          { get; }\npublic int  WaitingUpgradeCount       { get; }\npublic int  WaitingWriteCount         { get; }\n\npublic int  RecursiveReadCount        { get; }\npublic int  RecursiveUpgradeCount     { get; }\npublic int  RecursiveWriteCount       { get; }\n```", "```cs\nwhile (true)\n{\n  int newNumber = GetRandNum (100);\n  _rw.EnterUpgradeableReadLock();\n  if (!_items.Contains (newNumber))\n  {\n    _rw.EnterWriteLock();\n    _items.Add (newNumber);\n    _rw.ExitWriteLock();\n    Console.WriteLine (\"Thread \" + threadID + \" added \" + newNumber);\n  }\n  _rw.ExitUpgradeableReadLock();\n  Thread.Sleep (100);\n}\n```", "```cs\nvar rw = new ReaderWriterLockSlim();\nrw.EnterReadLock();\nrw.EnterReadLock();\nrw.ExitReadLock();\nrw.ExitReadLock();\n```", "```cs\nvar rw = new ReaderWriterLockSlim (LockRecursionPolicy.SupportsRecursion);\n```", "```cs\nrw.EnterWriteLock();\nrw.EnterReadLock();\nConsole.WriteLine (rw.IsReadLockHeld);     // True\nConsole.WriteLine (rw.IsWriteLockHeld);    // True\nrw.ExitReadLock();\nrw.ExitWriteLock();\n```", "```cs\nvar auto = new AutoResetEvent (false);\n```", "```cs\nvar auto = new EventWaitHandle (false, EventResetMode.AutoReset);\n```", "```cs\nclass BasicWaitHandle\n{\n  static EventWaitHandle _waitHandle = new AutoResetEvent (false);\n\n  static void Main()\n  {\n    new Thread (Waiter).Start();\n    Thread.Sleep (1000);                  // Pause for a second...\n    _waitHandle.Set();                    // Wake up the Waiter.\n  }\n\n  static void Waiter()\n  {\n    Console.WriteLine (\"Waiting...\");\n    _waitHandle.WaitOne();                // Wait for notification\n    Console.WriteLine (\"Notified\");\n  }\n}\n\n// Output:\nWaiting... *(pause)* Notified.\n```", "```cs\nclass TwoWaySignaling\n{\n  static EventWaitHandle _ready = new AutoResetEvent (false);\n  static EventWaitHandle _go = new AutoResetEvent (false);\n  static readonly object _locker = new object();\n  static string _message;\n\n  static void Main()\n  {\n    new Thread (Work).Start();\n\n    _ready.WaitOne();                  // First wait until worker is ready\n    lock (_locker) _message = \"ooo\";\n    _go.Set();                         // Tell worker to go\n\n _ready.WaitOne();\n    lock (_locker) _message = \"ahhh\";  // Give the worker another message\n _go.Set();\n\n _ready.WaitOne();\n    lock (_locker) _message = null;    // Signal the worker to exit\n _go.Set();\n  }\n\n  static void Work()\n  {\n    while (true)\n    {\n      _ready.Set();                          // Indicate that we're ready\n      _go.WaitOne();                         // Wait to be kicked off...\n      lock (_locker)\n      {\n        if (_message == null) return;        // Gracefully exit\n        Console.WriteLine (_message);\n      }\n    }\n  }\n}\n\n// Output:\nooo\nahhh\n```", "```cs\nvar manual1 = new ManualResetEvent (false);\nvar manual2 = new EventWaitHandle (false, EventResetMode.ManualReset);\n```", "```cs\nvar countdown = new CountdownEvent (3);  // Initialize with \"count\" of 3.\n```", "```cs\nnew Thread (SaySomething).Start (\"I am thread 1\");\nnew Thread (SaySomething).Start (\"I am thread 2\");\nnew Thread (SaySomething).Start (\"I am thread 3\");\n\ncountdown.Wait();   // Blocks until Signal has been called 3 times\nConsole.WriteLine (\"All threads have finished speaking!\");\n\nvoid SaySomething (object thing)\n{\n  Thread.Sleep (1000);\n  Console.WriteLine (thing);\n  countdown.Signal();\n}\n```", "```cs\nEventWaitHandle wh = new EventWaitHandle (false, EventResetMode.AutoReset,\n                                      @\"Global\\MyCompany.MyApp.SomeName\");\n```", "```cs\nvar starter = new ManualResetEvent (false);\n\nRegisteredWaitHandle reg = ThreadPool.RegisterWaitForSingleObject\n (starter, Go, \"Some Data\", -1, true);\n\nThread.Sleep (5000);\nConsole.WriteLine (\"Signaling worker...\");\nstarter.Set();\nConsole.ReadLine();\nreg.Unregister (starter);    // Clean up when weâ€™re done.\n\nvoid Go (object data, bool timedOut)\n{\n  Console.WriteLine (\"Started - \" + data);\n  // Perform task...\n}\n\n// Output:\n(5 second delay)\nSignaling worker...\nStarted - Some Data\n```", "```cs\nWaitHandle.SignalAndWait (wh1, wh2);\n```", "```cs\nWaitHandle.SignalAndWait (wh2, wh1);\n```", "```cs\nvar barrier = new Barrier (3);\n\nnew Thread (Speak).Start();\nnew Thread (Speak).Start();\nnew Thread (Speak).Start();\n\nvoid Speak()\n{\n  for (int i = 0; i < 5; i++)\n  {\n    Console.Write (i + \" \");\n    barrier.SignalAndWait();\n  }\n}\n\nOUTPUT:  0 0 0 1 1 1 2 2 2 3 3 3 4 4 4\n```", "```cs\nstatic Barrier _barrier = new Barrier (3, barrier => Console.WriteLine());\n```", "```cs\n0 0 0 \n1 1 1 \n2 2 2 \n3 3 3 \n4 4 4\n```", "```cs\nclass Foo\n{\n  public readonly Expensive Expensive = new Expensive();\n  ...\n}\nclass Expensive {  /* Suppose this is expensive to construct */  }\n```", "```cs\nclass Foo\n{\n  Expensive _expensive;\n  public Expensive Expensive         // *Lazily* instantiate Expensive\n  {\n    get\n    {\n      if (_expensive == null) _expensive = new Expensive();\n      return _expensive;\n    }\n  }\n  ...\n}\n```", "```cs\nExpensive _expensive;\nreadonly object _expenseLock = new object();\n\npublic Expensive Expensive\n{\n  get\n  {\n    lock (_expenseLock)\n    {\n      if (_expensive == null) _expensive = new Expensive();\n      return _expensive;\n    }\n  }\n}\n```", "```cs\nLazy<Expensive> _expensive = new Lazy<Expensive>\n  (() => new Expensive(), true);\n\npublic Expensive Expensive { get { return _expensive.Value; } }\n```", "```cs\nExpensive _expensive;\npublic Expensive Expensive\n{ \n  get          // Implement double-checked locking\n  { \n    LazyInitializer.EnsureInitialized (ref _expensive,\n                                      () => new Expensive());\n    return _expensive;\n  }\n}\n```", "```cs\n[ThreadStatic] static int _x;\n```", "```cs\nstatic ThreadLocal<int> _x = new ThreadLocal<int> (() => 3);\n```", "```cs\nvar localRandom = new ThreadLocal<Random>(() => new Random());\nConsole.WriteLine (localRandom.Value.Next());\n```", "```cs\nvar localRandom = new ThreadLocal<Random>\n ( () => new Random (Guid.NewGuid().GetHashCode()) );\n```", "```cs\nclass Test\n{\n  // The same LocalDataStoreSlot object can be used across all threads.\n  LocalDataStoreSlot _secSlot = Thread.GetNamedDataSlot (\"securityLevel\");\n\n  // This property has a separate value on each thread.\n  int SecurityLevel\n  {\n    get\n    {\n      object data = Thread.GetData (_secSlot);\n      return data == null ? 0 : (int) data;    // null == uninitialized\n    }\n    set { Thread.SetData (_secSlot, value); }\n  }\n  ...\n```", "```cs\nclass Test\n{\n  LocalDataStoreSlot _secSlot = Thread.AllocateDataSlot();\n  ...\n```", "```cs\nstatic AsyncLocal<string> _asyncLocalTest = new AsyncLocal<string>();\n\nasync void Main()\n{\n  _asyncLocalTest.Value = \"test\";  \n  await Task.Delay (1000);  \n  // The following works even if we come back on another thread:\n  Console.WriteLine (_asyncLocalTest.Value);   // test\n}\n```", "```cs\nstatic AsyncLocal<string> _asyncLocalTest = new AsyncLocal<string>();\n\nvoid Main()\n{\n  // Call Test twice on two concurrent threads:\n  new Thread (() => Test (\"one\")).Start();\n  new Thread (() => Test (\"two\")).Start();\n}\n\nasync void Test (string value)\n{\n  _asyncLocalTest.Value = value;\n  await Task.Delay (1000);\n  Console.WriteLine (value + \" \" + _asyncLocalTest.Value);\n}\n```", "```cs\nstatic AsyncLocal<string> _asyncLocalTest = new AsyncLocal<string>();\n\nvoid Main()\n{\n  _asyncLocalTest.Value = \"test\";\n  new Thread (AnotherMethod).Start();\n}\n\nvoid AnotherMethod() => Console.WriteLine (_asyncLocalTest.Value);  // test\n```", "```cs\nstatic AsyncLocal<string> _asyncLocalTest = new AsyncLocal<string>();\n\nvoid Main()\n{\n  _asyncLocalTest.Value = \"test\";\n  var t = new Thread (AnotherMethod);\n  t.Start(); t.Join();\n  Console.WriteLine (_asyncLocalTest.Value);   // test  (not ha-ha!)\n}\n\nvoid AnotherMethod() => _asyncLocalTest.Value = \"ha-ha!\";\n```", "```cs\nnew Thread (delegate() {\n                         while (*enabled*)\n                         {\n                           *DoSomeAction*();\n                           Thread.Sleep (TimeSpan.FromHours (24));\n                         }\n                       }).Start();\n```", "```cs\nStartPeriodicOperation();\n\nasync void StartPeriodicOperation()\n{\n  while (true)\n  {\n    await Task.Delay (1000);\n    Console.WriteLine (\"Tick\");   // Do some action\n  }\n }\n```", "```cs\nvar timer = new PeriodicTimer (TimeSpan.FromSeconds (1));\nStartPeriodicOperation();\n// Optionally dispose timer when you want to stop looping.\n\nasync void StartPeriodicOperation()\n{\n  while (await timer.WaitForNextTickAsync())\n    Console.WriteLine (\"Tick\");    // Do some action\n}\n```", "```cs\nusing System;\nusing System.Threading;\n\n// First interval = 5000ms; subsequent intervals = 1000ms\nTimer tmr = new Timer (Tick, \"tick...\", 5000, 1000);\nConsole.ReadLine();\ntmr.Dispose();         // This both stops the timer and cleans up.\n\nvoid Tick (object data)\n{\n  // This runs on a pooled thread\n  Console.WriteLine (data);          // Writes \"tick...\"\n}\n```", "```cs\nusing System;\nusing System.Timers;          // Timers namespace rather than Threading\n\nvar tmr = new Timer();        // Doesn't require any args\ntmr.Interval = 500;\ntmr.Elapsed += tmr_Elapsed;   // Uses an event instead of a delegate\ntmr.Start();                  // Start the timer\nConsole.ReadLine();\ntmr.Stop();                   // Stop the timer\nConsole.ReadLine();\ntmr.Start();                  // Restart the timer\nConsole.ReadLine();\ntmr.Dispose();                // Permanently stop the timer\n\nvoid tmr_Elapsed (object sender, EventArgs e)\n  => Console.WriteLine (\"Tick\");\n```"]