- en: Chapter 8\. Accepting Form Input with Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn how to use the framework-provided components for
    accepting form input to bind custom C# models to the `EditForm` component. We’ll
    cover native speech recognition when used in forms. You’ll also learn how to use
    Reactive Extensions with Rx.NET. The model app’s contact page form will demonstrate
    all of this.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with how form submission is used to accept and validate user input.
    You’ll see how valid user input can be sent to HTTP endpoints for processing.
  prefs: []
  type: TYPE_NORMAL
- en: The Basics of Form Submission
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The core functionality of an HTML `form` element is to accept and validate
    user input. When a user’s input is invalid, the user should be notified. When
    there is valid input, submit that input to an HTTP endpoint to process. The form
    submission process is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `form` is presented to the user to fill out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user fills out the `form` and attempts to submit it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `form` is validated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `form` is invalid, validation messages or errors are shown to the user.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `form` is valid, the input is sent off for processing.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Between these steps, the user interacts with the `form` in various ways, sometimes
    by typing, sometimes by clicking, sometimes by selecting a radio button, etc.
    When the form is invalid, the state of the `form` can display validation messages
    or errors to the user. A form can accept many different types of user input. We
    can apply dynamic CSS to desirable input elements to indicate that the user has
    entered invalid input. We can control which element has focus, and we can set
    elements as `disabled` or make them `readonly`. These styles include animations
    to emphasize errant conditions and draw the user’s attention to a specific area.
  prefs: []
  type: TYPE_NORMAL
- en: Framework-Provided Components for Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blazor provides many components that apply a layer atop native HTML elements.
    One such component is `EditForm`. The `EditForm` component is designed to be used
    as a wrapper around the native HTML `form` element. This is what’s used in the
    `Contact` form of the book’s model app. There are other framework-provided components
    as well. In the next section, you’ll see the various framework- provided components
    that can be used with `EditForm`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 8-1](#built-in-components) shows the various framework-provided components
    that can be used with the `EditForm` component.^([1](ch08.html#idm46365007034848))'
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-1\. Framework-provided form components
  prefs: []
  type: TYPE_NORMAL
- en: '| Blazor component | HTML element wrapped | Purpose of component |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `EditForm` | `<form>` | Provides a wrapper around the native HTML `form`
    element |'
  prefs: []
  type: TYPE_TB
- en: '| `InputCheckbox` | `<input type="checkbox">` | Accepts user input for either
    `true` or `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `Input⁠Date​<TValue>` | `<input type="date">` | Accepts a `DateTime` value
    as user input |'
  prefs: []
  type: TYPE_TB
- en: '| `InputFile` | `<input type="file">` | Accepts a file upload |'
  prefs: []
  type: TYPE_TB
- en: '| `InputNum⁠ber​<TValue>` | `<input type="number">` | Accepts a numeric value
    as user input |'
  prefs: []
  type: TYPE_TB
- en: '| `InputRa⁠dio​<TValue>` | `<input type="radio">` | Accepts a mutually exclusive
    set of values representing a single choice |'
  prefs: []
  type: TYPE_TB
- en: '| `InputRa⁠dioGroup​<TValue>` | Parent of one or more `Input​Ra⁠dio<TValue>`
    components | Semantically wraps the `InputRa⁠dio​<TValue>` components together
    such that they’re mutually exclusive |'
  prefs: []
  type: TYPE_TB
- en: '| `InputSe⁠lect​<TValue>` | `<select>` | Accepts a `TValue` value as user input
    from a list of custom options |'
  prefs: []
  type: TYPE_TB
- en: '| `InputText` | `<input type="text">` | Accepts a string value as user input
    |'
  prefs: []
  type: TYPE_TB
- en: '| `InputTextArea` | `<textarea>` | Accepts a string value as user input but
    traditionally displays and expects larger values than the `InputText` component
    |'
  prefs: []
  type: TYPE_TB
- en: Using these aforementioned components, you can build out a form that is as rich
    and as complex as your app needs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, I’ll show you how to build a model that will represent
    the state of the form and the user interacting with it. This model will be decorated
    with metadata that will power the validation of the form it binds to.
  prefs: []
  type: TYPE_NORMAL
- en: Models and Data Annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the common use cases for forms is to give the end user a way to contact
    someone from within the app for various reasons. The [`Contact` form](https://oreil.ly/LZzCM)
    of the Learning Blazor app does exactly that. The user can fill out the form and
    send me, the owner of the app, a message. After they hit send and confirm that
    they’re human, the message is sent to me as an email. We’ll go over how this works
    throughout the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by going through the form’s user inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: The user’s email address (current user of the app, which is prefilled if the
    user is logged in).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user’s first and last name, as a pair.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The subject of the message, or the reason they’re contacting through the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The message input, which uses a `TextArea` component and some interesting JavaScript
    interop. The message input exposes a microphone button that toggles speech recognition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a visual point of reference, consider [Figure 8-1](#contact-page).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lblz_0801.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1\. An example rendering of the `Contact` page
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Defining Component Models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As part of the form submission process, `EditForm` will validate the user’s
    input. `EditForm` will also display validation messages and errors. This is all
    based on either `EditContext` or a model. A model is a C# class used to bind to
    properties and represent relevant values. In the case of the `Contact` page, it’s
    using `EditContext` to manage the state of the form. And `EditContext` relies
    on a corresponding model. Let’s take a look at `ContactComponentModel` in the
    *ContactComponentModel.cs* C# file, which is responsible for representing the
    state of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_accepting_form_input_with_validation_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The model is a `record` type.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_accepting_form_input_with_validation_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `FirstName` and `LastName` properties are required, per the `Required` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_accepting_form_input_with_validation_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `EmailAddress` property is required, and it must be a valid email address.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_accepting_form_input_with_validation_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `AgreesToTerms` property is required as `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_accepting_form_input_with_validation_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The `NotRobot` property is a `readonly` property that is calculated from the
    `AreYouHumanMath` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_accepting_form_input_with_validation_CO1-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The `record` defines an operator to convert to a `ContactRequest`.
  prefs: []
  type: TYPE_NORMAL
- en: This model exposes the values that the user is expected to provide. The user’s
    first and last name is required, as well as a valid email address. The `Required`
    attribute is a framework-provided data annotation attribute that is used to indicate
    that the user must provide a value for the property. If the user doesn’t provide
    a value, and they attempt to either submit the form or navigate away from the
    underlying HTML element, `EditForm` will display an error message. C# attributes
    are used to provide additional information about the thing they’re applied to.
  prefs: []
  type: TYPE_NORMAL
- en: Defining and Consuming Validation Attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `RegexEmailAddress` attribute is a custom attribute that is used to indicate
    that the user must provide a valid email address. When decorating a model property,
    this attribute will validate it as an email address. The `RequiredAcceptance`
    attribute is a custom attribute that is used to indicate that the user must accept
    the terms and conditions. You can use all sorts of attributes to define objects.
    The `Message` property is required, as is the `Subject` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the `RegexEmailAddress` attribute implementation in the
    *Regex​E⁠mailAddressAttribute.cs* C# file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_accepting_form_input_with_validation_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `AttributeUsage` decorator specifies the usage of another attribute class,
    in this case, `RegexEmailAddressAttribute`, which applies only to properties,
    fields, and parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_accepting_form_input_with_validation_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`EmailExpression` is a `readonly Regex` instance that is used to validate the
    email address.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_accepting_form_input_with_validation_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `IsRequired` property allows the developer to determine whether an email
    address is required at all.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_accepting_form_input_with_validation_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor calls its base constructor with the `DataType.EmailAddress`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_accepting_form_input_with_validation_CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The `IsValid` method is used to validate the email address, which is passed
    as a nullable `object?`.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor developers can author a custom `DataTypeAttribute`. If the user enters
    an email address that doesn’t match the regular expression, `EditForm` will display
    an error message. If the value is `null` and the `IsRequired` property is `true`,
    `EditForm` will display an error message. The other custom attribute is `RequireAcceptance​At⁠tribute`.
    This attribute is used to indicate that the user must accept the terms and conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s look at `RequiredAcceptanceAttribute`, which is defined in the
    *Require⁠d​AcceptanceAttribute.cs* C# file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_accepting_form_input_with_validation_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`RequiredAcceptanceAttribute` is similar to `RegexEmailAddressAttribute`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_accepting_form_input_with_validation_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor calls the `DataTypeAttribute` base constructor with the `DataType.Custom`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_accepting_form_input_with_validation_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `IsValid` method is used to validate the acceptance of the terms and conditions.
  prefs: []
  type: TYPE_NORMAL
- en: If the user doesn’t accept the terms and conditions, `EditForm` will display
    an error message. When the object that represents `value` is `null`, or `value`
    is `false`, the error condition is triggered. You’re free to create any custom
    business logic rules that you may require. Whenever you need to accept user input,
    you’ll start with modeling an object that represents your needs. You’ll attribute
    the model’s properties with either custom or framework-provided data annotations.
    In the next section, we’ll put this into practice and see how a model is bound
    to the form components.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Contact Form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The markup for the `Contact` page is a bit lengthy, but it contains a fair
    number of user inputs with various functionality and validation requirements.
    To animate the controls and provide the appropriate styles when user input is
    in a state of error, the form needs a bit more markup than a semantic form. The
    page markup is contained in the *Contact.cshtml* Razor file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_accepting_form_input_with_validation_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `Contact` page allows anonymous users to contact the site owner.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_accepting_form_input_with_validation_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`EditForm` is a framework-provided component that is used to render a `form`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_accepting_form_input_with_validation_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The page model accepts an `EmailAddress` property and renders an `<InputText>`
    element.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_accepting_form_input_with_validation_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The page model accepts `FirstName` and `LastName` properties and renders two
    `<input type="text">` elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_accepting_form_input_with_validation_CO4-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The page model accepts a `Subject` property and renders an `<InputText>` element.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_accepting_form_input_with_validation_CO4-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The page model accepts a `Message` property and renders an `<InputTextArea>`
    element. This is where the additive speech recognition component is rendered,
    and that’s detailed later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_accepting_form_input_with_validation_CO4-7)'
  prefs: []
  type: TYPE_NORMAL
- en: The page model accepts an `AgreesToTerms` property and renders an `<Input​Check⁠box>`
    element.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_accepting_form_input_with_validation_CO4-8)'
  prefs: []
  type: TYPE_NORMAL
- en: The page model accepts a `Send` button and renders a `<button>` element.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_accepting_form_input_with_validation_CO4-9)'
  prefs: []
  type: TYPE_NORMAL
- en: The page references `VerificationModalComponent` for a spam filter.
  prefs: []
  type: TYPE_NORMAL
- en: The page that displays when the `/contact` route is requested renders as shown
    in [Figure 8-2](#contact-page-rendered).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lblz_0802.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-2\. A blank `Contact` page form with only the email address prefilled
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let’s summarize what’s going on here. The `Contact` page is a form with a few
    fields. The page model is a class that contains the properties that are bound
    to the form elements. The `EditForm` component is a framework-provided component
    that renders an HTML `form` element. It requires either `EditContext` or `Model`,
    but not both. In this case, `EditContext` wraps `ContactComponentModel`. The model
    used in `Edit​Con⁠text` can be any `object`. `EditContext` holds metadata related
    to a data editing process, such as flags to indicate which fields have been modified
    and the current set of validation messages. The `EditContext.Model` will be used
    by `EditForm` to render the form. `EditContext.OnValidSubmit` event handler is
    used to handle the form submission. When the form is both valid and submitted,
    the `Contact.OnValidSubmitAsync` event handler is called. The `DataAnno⁠tations​Val⁠ida⁠tor`
    framework-provided component is used to add validation `Data​Annota⁠tions` attribute
    support that informs the `EditContext` instance with metadata about the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fields in the form are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Email
  prefs: []
  type: TYPE_NORMAL
- en: A `FieldInput` custom component bound to the model’s `EmailAddress` property.
  prefs: []
  type: TYPE_NORMAL
- en: From
  prefs: []
  type: TYPE_NORMAL
- en: Two horizontal fields presented as framework-provided `InputText` components,
    bound to the model’s `FirstName` and `LastName` properties. These values are both
    required and can alter the state of the validation for a shared validation icon.
  prefs: []
  type: TYPE_NORMAL
- en: Subject
  prefs: []
  type: TYPE_NORMAL
- en: A `FieldInput` custom component bound to the model’s `Subject` property.
  prefs: []
  type: TYPE_NORMAL
- en: Message
  prefs: []
  type: TYPE_NORMAL
- en: A `FieldInput` custom component bound to the model’s `Message` property but
    relying on `AdditiveSpeechRecognitionComponent` to add speech recognition support
    that is tied to an `InputTextArea` component. `AdditiveSpeech​Rec⁠ogni⁠tionComponent`
    renders an overlay toggle `<button>` in the upper-righthand corner of its parent
    HTML element.
  prefs: []
  type: TYPE_NORMAL
- en: Whether the user agrees to the terms
  prefs: []
  type: TYPE_NORMAL
- en: A `FieldInput` custom component bound to the model’s `AgreesToTerms` property,
    and the framework-provided `InputCheckbox` component that is used to render a
    checkbox.
  prefs: []
  type: TYPE_NORMAL
- en: Submit form button
  prefs: []
  type: TYPE_NORMAL
- en: A send `<button type="submit">` element at the end of the `EditForm` markup.
    When the user clicks this button, the `EditContext.OnValidSubmit` event handler
    is called, if the form is valid.
  prefs: []
  type: TYPE_NORMAL
- en: Modal dialog
  prefs: []
  type: TYPE_NORMAL
- en: A dialog rendered by `VerificationModalComponent` is shown when the user clicks
    the `Send` button. The dialog serves as a spam filter, as it requires the user
    who submitted the form to answer a math question in string form.
  prefs: []
  type: TYPE_NORMAL
- en: The shadow component does this because there’s a fair bit of Razor markup. It’s
    used to manage the framework-provided `EditContext`, `_model`, `_emailInput`,
    `_firstNameInput`, `_modalComponent`, and two `bool` values for whether the email
    or message input elements should be `readonly`. These are detailed in the coming
    sections. Since the contact page is attributed with `AllowAnonymous`, it can be
    accessed by nonauthenticated users; this is intentional to allow potential users
    of the app to reach out with questions.
  prefs: []
  type: TYPE_NORMAL
- en: It is common for Razor components to use `Expression<Func<T>>` semantics (or
    expression trees) when evaluating model properties. An expression tree represents
    code as a data structure, where each node is an expression. Expressions look like
    functions but are not evaluated. Instead, an expression is parsed. For example,
    when we pass in `_model.EmailAddress`, the Blazor library calls `FieldCssClass`.
    The expression is then parsed extracting how to evaluate both our model and its
    corresponding property value.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a convenience for determining which CSS classes are applicable given the
    state of a specific model’s property expression, the `GetValidityCss` extension
    method calculates the appropriate CSS classes for the property. Consider the *EditContext​Ex⁠tensions.cs*
    C# file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_accepting_form_input_with_validation_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `Expression<Func<T>>` parameter is used to access the model’s property.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_accepting_form_input_with_validation_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `Expression<Func<TOne>>` and `Expression<Func<TTwo>>` parameters are used
    to access the model’s property.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_accepting_form_input_with_validation_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `bool` parameters are used to determine the CSS class to return.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_accepting_form_input_with_validation_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `IsValid` method is used to determine if the property is valid.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_accepting_form_input_with_validation_CO5-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The `IsInvalid` method is used to determine if the property is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_accepting_form_input_with_validation_CO5-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The `IsModified` method is used to determine if the property is modified.
  prefs: []
  type: TYPE_NORMAL
- en: The `EditContextExtensions` class contains some extension methods that are used
    to determine the CSS class to return based on the state of the model’s property.
    The `GetValidityCss` method and its overloads are used to determine the CSS class
    to return based on the state of the model’s property. Using the framework-provided
    `EditContextFieldClassExtensions.FieldCssClass` extension method, we can evaluate
    the current CSS classes given the state of the corresponding expression. The `Get​Vali⁠dityCss`
    method is used throughout the markup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s have a look at the *Contact.razor.cs* C# file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_accepting_form_input_with_validation_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `EditContext` instance wraps `ContactComponentModel`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_accepting_form_input_with_validation_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `OnInitializedAsync` method calls the `base` implementation, which initializes
    the `User` instance and immediately calls `InitializeModelAndContext`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_accepting_form_input_with_validation_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `InitializeModelAndContext` method initializes the `_model` and `_edit​Con⁠text`
    properties from the `User` instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_accepting_form_input_with_validation_CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `OnAfterRenderAsync` method determines which input element should have focus
    when the page is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_accepting_form_input_with_validation_CO6-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The `OnRecognitionStarted` method sets the `_isMessageReadonly` property to
    `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_accepting_form_input_with_validation_CO6-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The `OnSpeechRecognized` method updates the `_model.Message` property with the
    transcript and notifies the `_editContext` instance that the `Message` property
    has changed.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_accepting_form_input_with_validation_CO6-7)'
  prefs: []
  type: TYPE_NORMAL
- en: The `OnValidSubmitAsync` method is called when the user clicks the `Send` button.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_accepting_form_input_with_validation_CO6-8)'
  prefs: []
  type: TYPE_NORMAL
- en: The `OnVerificationAttempted` method throws a `ContactRequest` at the Web.Api
    project’s `[HttpPost("api/contact")]` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: When the `Contact` page is initialized, the `base.User` instance is initialized
    as well. If there is an authenticated user, the email address is set as `readonly`
    and the user’s email is used. If there is no authenticated user, the `_model`
    instance is initialized with an empty `ContactComponentModel` instance. When the
    page first is rendered, either the `_emailInput` or `_firstNameInput` element
    is focused.
  prefs: []
  type: TYPE_NORMAL
- en: There are two methods responsible for managing whether the `_messageInput` element
    is `readonly`. The `OnRecognitionStarted` method sets the `_isMessageReadonly`
    property to `true`; `OnRecognitionStopped` sets it to `false`. When speech is
    recognized, the `_model.Message` property is updated with the transcript, and
    the `_edit​Con⁠text` instance is notified that the `Message` property has changed.
  prefs: []
  type: TYPE_NORMAL
- en: When the user supplies all of the required inputs, the form is considered “valid.”
    At this point, the user is free to submit the form. When the form is submitted,
    the `_modalComponent` instance is shown, which prompts the user to answer one
    question. If they’re able to do so, the form information is sent to the Web.Api
    project’s `[HttpPost("api/contact")]` endpoint for processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help encapsulate a bit of common code for various field inputs, I wrote
    a `Field​In⁠put` form component. This component is used throughout the `Contact`
    page. Let’s take a look at the *FieldInput.razor* Razor markup file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_accepting_form_input_with_validation_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `FieldLabelContent` property is used to render `label` for the field.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_accepting_form_input_with_validation_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `FieldControlContent` property is used to render `input` for the field.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_accepting_form_input_with_validation_CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The component accepts several optional and required parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `label` and `input` elements are rendered as a `RenderFragment`,
    the consumer is free to render whatever they want. In the `Contact` page markup,
    you can see examples of `FieldInput` components with the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: Single framework-provided `InputText` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple framework-provided `InputText` components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A custom `AdditiveSpeechRecognitionComponent` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single framework-provided `InputCheckbox` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s explore a few more states that the form can be rendered as.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to `label`, icons are used to help deliver even more clarity to
    validation errors. Imagine the user enters the first name, forgets to enter the
    last name, and then provides a subject. They’re free to attempt clicking the `Send`
    button, but the `_lastNameInput` element will be outlined with a red border and
    its validity icon will change to a red cross. The `_subjectInput` element will
    have its validity icon change from the question mark to a green check mark, but
    the `_messageInput` element will not be highlighted, as shown in [Figure 8-3](#contact-page-invalid-close-up).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lblz_0803.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-3\. An example close-up rendering of an invalid `Contact` page
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The user could provide a value for the last name and a message, thus clearing
    the validation errors, as shown in [Figure 8-4](#contact-page-valid-close-up).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lblz_0804.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-4\. An example close-up rendering of a valid `Contact` page
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In Figures [8-3](#contact-page-invalid-close-up) and [8-4](#contact-page-valid-close-up),
    you may have noticed a microphone. The message input element has a button rendered
    in the upper-righthand corner of its bounding box. When the user clicks the button,
    the `_messageInput` element is temporarily disabled. This element accepts speech
    recognition as a form of input. The next section will show you how to incorporate
    speech recognition input into your form.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Speech Recognition as User Input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Speech recognition is a commonly used input mechanism in modern apps, both for
    accessibility and overall convenience. More than 90% of web browsers support the
    speech recognition API, according to the [“Can I Use *Speech Recognition*?” web
    page](https://oreil.ly/qhqjt). The speech recognition API allows web developers
    to acquire a transcript from a recognition session from the user’s voice as input.
    The API is supported by all modern browsers, including Chrome, Firefox, Safari,
    and Edge.
  prefs: []
  type: TYPE_NORMAL
- en: To make it so that the user can use speech recognition to input text in the
    message field of a form, you need to rely on the browser’s native speech recognition
    API. This requires JavaScript interop. To use this API, you could either write
    your own implementation to interface with the native API or use a library that
    contains this logic. I maintain a Razor class library that provides an `ISpeech​Recog⁠nitionService`
    implementation that’s published on NuGet as [`Blazor.Speech​Recog⁠nition.WebAssem⁠bly`](https://oreil.ly/UpI60).
    This library exposes this type through DI, allowing consumers to call `.AddSpeechRecognitionServices`
    on the `IServiceCollection` type. Once the services are registered, you can consume
    this interface. This is an abstraction over the speech recognition API, and it
    uses Blazor JavaScript interop. It’s a good example of how you can create a reusable
    Razor class library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Blazor class libraries let you write components, effectively sharing common
    markup, logic, and even static assets. Static assets are typically in the *wwwroot*
    folder in ASP.NET Core apps. The `Blazor.SpeechRecognition.WebAssembly` library
    defines a bit of JavaScript code in the *wwwroot*. Let’s take a look at the *blazorators.speech​Recog⁠nition.js*
    JavaScript file that exposes the `speechSynthesis` functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_accepting_form_input_with_validation_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `_recognition` variable is used to store the current `SpeechRecognition`
    instance globally.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_accepting_form_input_with_validation_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `cancelSpeechRecognition` method is used to cancel the current speech recognition
    session.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_accepting_form_input_with_validation_CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `recognizeSpeech` method is used to start the speech recognition session.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_accepting_form_input_with_validation_CO8-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `_recognition` instance has several callbacks, each of which is registered.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_accepting_form_input_with_validation_CO8-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The `_recognition.onresult` callback is used to send the results back to the
    client.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_accepting_form_input_with_validation_CO8-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The `window.addEventListener` method aborts any active speech recognition session.
  prefs: []
  type: TYPE_NORMAL
- en: Although we’ve used JavaScript for other functionality in this book, this one’s
    different because the functions defined here use the `export` keyword. The `export`
    JavaScript keyword allows you to export a function or variable as an `import`-able
    code from another module. This is a very common JavaScript feature, and it’s used
    to make your code more sharable and readable and easier to maintain. Blazor can
    `import` these functions into .NET via JavaScript interop calls to `import` and
    a path to a JavaScript module. Modules simply `export` their desired functionality,
    and other modules consume it. In .NET, this module is represented as the framework-provided
    `IJSInProcessObjectReference` type. For more information about JavaScript isolation,
    see Microsoft’s [“Call JavaScript Functions from .NET Methods in ASP.NET Core
    Blazor” documentation](https://oreil.ly/0nf9D).
  prefs: []
  type: TYPE_NORMAL
- en: 'The two functions of this JavaScript file are `cancelSpeechRecognition` and
    `recognizeSpeech`. The primary function is `recognizeSpeech` as it conditionally
    registers all of the provided callbacks when they’re able to be handled. It’s
    responsible for instantiating a `SpeechRecognition` instance and assigning it
    to the global `_recognition` variable of the JavaScript code. Next, we’ll look
    at the `ISpeech​Rec⁠ogni⁠tionService` interface. It’s defined in the *ISpeechRecognitionService.cs*
    C# file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_accepting_form_input_with_validation_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The interface declares itself in the `Microsoft.JSInterop` namespace as a convenience.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_accepting_form_input_with_validation_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `ISpeechRecognitionService` interface is used to define the public `Speech​Re⁠cognition`
    API.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_accepting_form_input_with_validation_CO9-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `InitializeModuleAsync` method is used to initialize the speech recognition
    module.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_accepting_form_input_with_validation_CO9-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `CancelSpeechRecognition` method is used to cancel the speech recognition
    session.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_accepting_form_input_with_validation_CO9-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The `RecognizeSpeech` method is used to start the speech recognition session.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Declaring a type in someone else’s namespace (such as `Microsoft.JSInterop`)
    should not be overused. This practice is typically not publicly recommended, but
    it’s used here to make the library more accessible to developers. In this way,
    as developers opt in to using this NuGet package, where their apps are already
    making use of `Microsoft.JSInterop`, they can also use the `SpeechRecognition`
    API.
  prefs: []
  type: TYPE_NORMAL
- en: 'This interface inherits `IAsyncDisposable`, and its `DisposeAsync` call will
    perform the necessary cleanup of the captured module reference. The `ISpeechRecognitionService`
    interface is small, so it’s a good candidate for simple unit testing, which is
    discussed in [Chapter 9](ch09.html#chapter-nine). This makes it easy to perform
    unit tests on the logic surrounding the speech recognition module. Next, we’ll
    look at the `DefaultSpeech​Re⁠cognitionService` class. It’s defined in the *DefaultSpeechRecognitionService.cs*
    C# file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_accepting_form_input_with_validation_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `DefaultSpeechRecognitionService` class is both `sealed` and `internal`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_accepting_form_input_with_validation_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: There are several fields required for this implementation besides the `const
    string` fields—two framework-provided types (`IJSInProcessRuntime` and `IJSInProcessObjectReference`)
    and two custom types (`SpeechRecognitionCallbackRegistry` and `SpeechRecognitionSubject`).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_accepting_form_input_with_validation_CO10-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '`InitializeSpeechRecognitionSubject` creates the speech recognition subject.
    If it already exists, the existing speech recognition session is canceled.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_accepting_form_input_with_validation_CO10-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `InitializeModuleAsync` method is used to initialize the speech recognition
    module.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_accepting_form_input_with_validation_CO10-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The `CancelSpeechRecognition` method is used to cancel the speech recognition
    session.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_accepting_form_input_with_validation_CO10-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The `RecognizeSpeech` method is used to start the speech recognition session.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_accepting_form_input_with_validation_CO10-7)'
  prefs: []
  type: TYPE_NORMAL
- en: The `OnStarted` method is used to invoke the `onStarted` callback.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_accepting_form_input_with_validation_CO10-8)'
  prefs: []
  type: TYPE_NORMAL
- en: The `OnSpeechRecognized` method is used to invoke the `onRecognized` callback.
  prefs: []
  type: TYPE_NORMAL
- en: The `InitializeModuleAsync` method is required to be called before any other
    call. This ensures that the `_speechRecognitionModule` field is initialized. The
    `Cancel​Spee⁠chRecognition` method is used to cancel the speech recognition session.
    The `RecognizeSpeech` method is used to start the speech recognition session.
    When the speech recognition session is started, the `_speechRecognition` field
    is initialized. An invocation key is created (`Guid.NewGuid()`), and this is passed
    from .NET into the JavaScript interop calls. The calling JavaScript then uses
    the given `key` when it invokes its callbacks. This is then used to ensure that
    callbacks are removed from the `_callbackRegistry` once they’re called. The `OnStarted`,
    `OnEnded`, and `OnRecognitionError` methods are used to invoke the corresponding
    callbacks. The `OnSpeechRecognized` is different, as it instead pushes the given
    `transcript` and `isFinal` values into the `SpeechRecognitionResult` object and
    calls the `Recognition​Received` method on the `_speechRecognition` field.
  prefs: []
  type: TYPE_NORMAL
- en: The `_speechRecognition` field is a `SpeechRecognitionSubject` type. This custom
    type wraps a bit of reactive code and provides an encapsulated observer and observable
    pair. In the next section, I’ll explain how ReactiveX (Reactive Extensions) are
    used to create the `SpeechRecognitionSubject` type.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Programming with the Observer Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike the `OnStarted`, `OnEnded`, and `OnRecognitionError` events, the `OnSpeech​Recog⁠nized`
    event triggers many times. This is because the JavaScript speech recognition code
    sets the `continuous` flag to `true` when the speech recognition session is started.
    The JavaScript code will invoke the `onRecognized` callback multiple times, with
    the `isFinal` flag set to `false` for each invocation. When intermediate recognition
    results are available, a final recognition result is still only intermittent.
    When final, it’s a complete thought or sentence. The speech recognition service
    will continue to listen until either an error occurs or a cancellation is requested.
    We’ll use reactive programming, which relies on asynchronous programming logic
    to handle real-time updates to otherwise static content. As the speech recognition
    service fires, our app will observe each occurrence of the event and take appropriate
    action.
  prefs: []
  type: TYPE_NORMAL
- en: '[ReactiveX (or Reactive Extensions)](https://reactivex.io) is an API for asynchronous
    programming with observable streams. ReactiveX is an implementation of the *observer
    pattern*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The .NET implementation of Reactive Extensions is known as Rx.NET. Within this
    library, a `Subject` type represents an object that is both an observable sequence
    and an observer. In the case of speech recognition, the `SpeechRecognition​Sub⁠ject`
    type observes a stream of `SpeechRecognitionResult` objects. Consider the *Speech​Recogni⁠tionSubject.cs*
    C# file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_accepting_form_input_with_validation_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `SpeechRecognitionSubject` type relies on a subject, observer, observable,
    and subscription.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_accepting_form_input_with_validation_CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `_observer` field is used to invoke the `onRecognized` callback, and the
    constructor is `private`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_accepting_form_input_with_validation_CO11-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `Factory` method is used to create the `SpeechRecognitionSubject` type.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_accepting_form_input_with_validation_CO11-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `RecognitionReceived` method is used to push the given `recognition` value
    into the `_speechRecognitionSubject` field.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_accepting_form_input_with_validation_CO11-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The `Dispose` method is used to dispose of the `_speechRecognition​Sub⁠scrip⁠tion`
    field.
  prefs: []
  type: TYPE_NORMAL
- en: The `SpeechRecognitionSubject` allows the consumer to push `SpeechRecognitionResult`
    instances into its underlying `Subject`. The consumer also provides an `Action<string,
    string>` observer function, which is used within the observables subscription.
    When `Subject` acts as an observable, it means its stream of intermittent results
    can be filtered and conditionally dispatched to the consumer. When the final `transcript`
    is ready, the consumer is notified and provided with the `key` and `transcript`
    values.
  prefs: []
  type: TYPE_NORMAL
- en: The custom subject wrapper defines only a `private` constructor, which means
    it’s not possible to instantiate this object unless using the `static` factory
    method. The `Factory` functionality accepts the `observer` used to instantiate
    `SpeechRecognitionSubject`. The subscription instance is stored as a field so
    that it can be explicitly cleaned up when the subject is disposed of.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Callbacks with a Registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since the service exposes several callbacks, it manages the interop callbacks
    in a custom registry. The `SpeechRecognitionCallbackRegistry` object allows for
    registering a callback and the corresponding invocation of a callback given its
    key. Let’s look at the *SpeechRecognitionCallbackRegistry.cs* C# file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_accepting_form_input_with_validation_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `_onResultCallbackRegister` field is used to store the callback register
    for the `onRecognized` callback.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_accepting_form_input_with_validation_CO12-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `RegisterOnRecognized` method registers the `onRecognized` callback, and
    the `_onResultCallbackRegister` field is used to store the callback.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_accepting_form_input_with_validation_CO12-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `RegisterOnError` method registers the `onError` callback, and the `_onErrorCallbackRegister`
    field is used to store the callback.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_accepting_form_input_with_validation_CO12-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `InvokeOnRecognized` method invokes the `onRecognized` callback, and the
    `OnInvokeCallback` method invokes the callback.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_accepting_form_input_with_validation_CO12-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The `InvokeOnError` method invokes the `onError` callback, and the `OnInvoke​Call⁠back`
    method invokes the callback.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_accepting_form_input_with_validation_CO12-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The `OnInvokeCallback` method invokes the callback in the register after it’s
    removed.
  prefs: []
  type: TYPE_NORMAL
- en: A `ConcurrentDictionary` represents a thread-safe collection of KVPs that can
    be accessed by multiple threads concurrently. There are many alternative approaches
    to managing callbacks, but the `SpeechRecognitionCallbackRegistry` object is the
    simplest and most performant. It’s thread-safe and uses globally unique identifiers
    to manage the callbacks—which ensures that a single registration is tethered to
    a single invocation of a callback. One of the advantages to using C# in a browser
    such as this is that we’re spoiled with the native types provided by the .NET
    ecosystem. Having access to primitives like `ConcurrentDictionary`, `Guid`, strongly
    typed delegates (`Action<T>` for example), and even Rx.NET is a huge advantage.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the Speech Recognition Service to Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Applying `SpeechRecognitionSubject` and `SpeechRecognitionCallbackRegistry`
    to expose the `ISpeechRecognitionService` interface, we can now create a custom
    component that can be added to an HTML element and surface speech recognition
    functionality. Let’s look at the *AdditiveSpeechRecognitionComponent.cs* C# file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_accepting_form_input_with_validation_CO13-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `AdditiveSpeechRecognitionComponent` implements the `IAsyncDisposable` interface,
    which allows us to dispose of the speech recognition module when the component
    is removed from the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_accepting_form_input_with_validation_CO13-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `SpeechRecognition` property is used to access the speech recognition service.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_accepting_form_input_with_validation_CO13-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `SpeechRecognitionStarted` property is optional and is used to notify the
    parent component that the speech recognition has started.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_accepting_form_input_with_validation_CO13-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `SpeechRecognitionStopped` property is also optional, and it’s signaled
    when speech recognition has stopped.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_accepting_form_input_with_validation_CO13-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The `SpeechRecognized` property is an `EditorRequired` parameter, and it’s called
    multiple times over the typical session.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_accepting_form_input_with_validation_CO13-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The `OnAfterRenderAsync` method is used to initialize the speech recognition
    module.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_accepting_form_input_with_validation_CO13-7)'
  prefs: []
  type: TYPE_NORMAL
- en: The `OnRecognizeButtonClick` method is used to start or stop speech recognition.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_accepting_form_input_with_validation_CO13-8)'
  prefs: []
  type: TYPE_NORMAL
- en: The `OnRecognized` method is used to notify the parent component that speech
    recognition has been completed.
  prefs: []
  type: TYPE_NORMAL
- en: When the user clicks the microphone button, the `OnRecognizeButtonClick` method
    is called. The consuming `Contact` page will mark the corresponding `input` element
    as `readonly`. This helps to ensure that the user cannot edit the text in the
    input field, as it is automatically updating from the speech recognition. So,
    you can’t talk and type at the same time. The `EventCallback` instances signal
    any changes to the consumer. The `TryInvokeAsync` is an extension method that
    conditionally calls the `InvokeAsync` method on the `EventCallback` instance if
    its `HasDelegate` value is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Form Submission Validation and Verification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Putting this all together, we’ve built a custom `Contact` page that displays
    a beautifully styled form that boasts speech recognition functionality with the
    click of a button. Before a user can submit the form, all fields must be validated.
    As the primary function of a form is to take user input and give it to the recipient,
    it’s vital to validate the input to make sure the information is communicated
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The form model is bound to various form fields, and the form is validated on
    submission. Each form field is represented by an HTML element using Blazor components.
    The form field components are responsible for validating the user’s input. When
    the framework-provided `EditForm` component is given a C# model that is invalid,
    it will render the form with the appropriate error messages. Only when the form
    submission is valid will the `EditForm` component submit the form. Meaning all
    of the data annotations on the model are validated, including required fields,
    custom regex patterns, and custom validation methods.
  prefs: []
  type: TYPE_NORMAL
- en: Once the `Contact` form is considered valid and submitted, the user is prompted
    by a modal that acts as a basic spam blocker. We set up this `VerificationModalComponent`
    in [Figure 4-3](ch04.html#are-you-human-modal) in [Chapter 4](ch04.html#chapter-four).
    The modal prompts the user to answer random math problems and requires a correct
    answer for the submission to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-5](#are-you-human-modal-zoom) shows an example of this modal prompt.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lblz_0805.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-5\. An example rendering of the `VerificationModalComponent` zoomed
    in
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If the answer is incorrect, the modal will not allow the user’s form data to
    be sent to the Web.Api project’s endpoint for processing. An incorrect answer
    is shown in [Figure 8-6](#are-you-human-modal-zoom-wrong).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lblz_0806.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-6\. An example rendering of the `VerificationModalComponent` zoomed
    in with the wrong answer
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Once the question is correctly answered, the modal is dismissed and the contact
    form is processed. A notification is triggered, which states that the contact
    attempt is successful, as shown in [Figure 8-7](#contact-page-message-sent-notification).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/lblz_0807.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-7\. An example rendering of the confirmation notification
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Because the primary function of a form is to take user input and give it to
    the recipient, it’s vital to validate the input to make sure the information is
    communicated correctly. A model is bound to various form fields, and the form
    is validated on submission. Each form field is represented by an HTML element
    using Blazor components. The form field components are responsible for validating
    the user’s input. When the framework-provided `EditForm` component is given a
    C# model that is invalid, it will render the form with the appropriate error messages.
    Only when the form submission is valid will the `EditForm` component submit the
    form, meaning all of the data annotations on the model are validated, including
    required fields, custom regex patterns, and custom validation methods.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I showed you how to implement a form that accepts input with
    validation. In the process, you learned the basics of form submission, including
    how to bind custom C# models to `EditForm`, how to use data annotations to decorate
    model properties with validation attributes, and how to render a form with validation
    errors. I also walked you through a speech recognition library that exposes the
    ability to accept a user’s spoken word as input that is bound to text input.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, I’m going to show you how to properly test your Blazor
    apps. From unit tests with xUnit to component tests with bUnit, you’ll learn how
    to write reliable tests that can be used to verify the functionality of your app.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch08.html#idm46365007034848-marker)) “ASP.NET Core Blazor Forms and Input
    Components,” Microsoft .NET Documentation, August 16, 2022, [*https://oreil.ly/3qzqQ*](https://oreil.ly/3qzqQ).
  prefs: []
  type: TYPE_NORMAL
