- en: Chapter 13\. Diagnostics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When things go wrong, it’s important that information is available to aid in
    diagnosing the problem. An Integrated Development Environment (IDE) or debugger
    can assist greatly to this effect—but it is usually available only during development.
    After an application ships, the application itself must gather and record diagnostic
    information. To meet this requirement, .NET provides a set of facilities to log
    diagnostic information, monitor application behavior, detect runtime errors, and
    integrate with debugging tools if available.
  prefs: []
  type: TYPE_NORMAL
- en: Some diagnostic tools and APIs are Windows specific because they rely on features
    of the Windows operating system. In an effort to prevent platform-specific APIs
    from cluttering the .NET BCL, Microsoft has shipped them in separate NuGet packages
    that you can optionally reference. There are more than a dozen Windows-specific
    packages, which you can reference all at once with the *Microsoft.Windows.Compatibility*
    “master” package.
  prefs: []
  type: TYPE_NORMAL
- en: The types in this chapter are defined primarily in the `System.Diagnostics`
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Compilation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can conditionally compile any section of code in C# with *preprocessor directives*.
    Preprocessor directives are special instructions to the compiler that begin with
    the `#` symbol (and, unlike other C# constructs, must appear on a line of their
    own). Logically, they execute before the main compilation takes place (although
    in practice, the compiler processes them during the lexical parsing phase). The
    preprocessor directives for conditional compilation are `#if`, `#else`, `#endif`,
    and `#elif`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `#if` directive instructs the compiler to ignore a section of code unless
    a specified *symbol* has been defined. You can define a symbol in source code
    by using the `#define` directive (in which case the symbol applies to just that
    file), or in the *.csproj* file by using a `<DefineConstants>` element (in which
    case the symbol applies to whole assembly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If we deleted the first line, the program would compile with the `Console.WriteLine`
    statement completely eliminated from the executable, as though it were commented
    out.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `#else` statement is analogous to C#’s `else` statement, and `#elif` is
    equivalent to `#else` followed by `#if`. The `||`, `&&`, and `!` operators perform
    *or*, *and*, and *not* operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind, however, that you’re not building an ordinary C# expression, and
    the symbols upon which you operate have absolutely no connection to *variables*—static
    or otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define symbols that apply to every file in an assembly by editing the
    *.csproj* file (or in Visual Studio, by going to the Build tab in the Project
    Properties window). The following defines two constants, `TESTMODE` and `PLAYMODE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you’ve defined a symbol at the assembly level and then want to “undefine”
    it for a particular file, you can do so by using the `#undef` directive.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Compilation Versus Static Variable Flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You could instead implement the preceding example with a simple static field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This has the advantage of allowing runtime configuration. So, why choose conditional
    compilation? The reason is that conditional compilation can take you places variable
    flags cannot, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Conditionally including an attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the declared type of variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Switching between different namespaces or type aliases in a `using` directive;
    for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can even perform major refactoring under a conditional compilation directive,
    so you can instantly switch between old and new versions, and write libraries
    that can compile against multiple runtime versions, leveraging the latest features
    where available.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of conditional compilation is that debugging code can refer
    to types in assemblies that are not included in deployment.
  prefs: []
  type: TYPE_NORMAL
- en: The Conditional Attribute
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Conditional` attribute instructs the compiler to ignore any calls to a
    particular class or method, if the specified symbol has not been defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this is useful, suppose that you write a method for logging status
    information as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now imagine that you want this to execute only if the `LOGGINGMODE` symbol
    is defined. The first solution is to wrap all calls to `LogStatus` around an `#if`
    directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives an ideal result, but it is tedious. The second solution is to put
    the `#if` directive inside the `LogStatus` method. This, however, is problematic
    should `LogStatus` be called as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`GetComplexMessageHeaders` would always be called—which might incur a performance
    hit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can combine the functionality of the first solution with the convenience
    of the second by attaching the `Conditional` attribute (defined in `System.Diagnostics`)
    to the `LogStatus` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This instructs the compiler to treat calls to `LogStatus` as though they were
    wrapped in an `#if LOGGINGMODE` directive. If the symbol is not defined, any calls
    to `Log​Sta⁠tus` are eliminated entirely in compilation—including their argument
    evaluation expressions. (Hence any side-effecting expressions will be bypassed.)
    This works even if `LogStatus` and the caller are in different assemblies.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Another benefit of `[Conditional]` is that the conditionality check is performed
    when the *caller* is compiled, rather than when the *called method* is compiled.
    This is beneficial because it allows you to write a library containing methods
    such as `LogStatus`—and build just one version of that library.
  prefs: []
  type: TYPE_NORMAL
- en: The `Conditional` attribute is ignored at runtime—it’s purely an instruction
    to the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives to the Conditional attribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Conditional` attribute is useless if you need to dynamically enable or
    disable functionality at runtime: instead, you must use a variable-based approach.
    This leaves the question of how to elegantly circumvent the evaluation of arguments
    when calling conditional logging methods. A functional approach solves this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'A lambda expression lets you call this method without syntax bloat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If `EnableLogging` is `false`, `GetComplexMessageHeaders` is never evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Debug and Trace Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Debug` and `Trace` are static classes that provide basic logging and assertion
    capabilities. The two classes are very similar; the main differentiator is their
    intended use. The `Debug` class is intended for debug builds; the `Trace` class
    is intended for both debug and release builds. To this effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This means that all calls that you make to `Debug` or `Trace` are eliminated
    by the compiler unless you define `DEBUG` or `TRACE` symbols. (Visual Studio provides
    checkboxes for defining these symbols in the Build tab of Project Properties,
    and enables the TRACE symbol by default with new projects.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the `Debug` and `Trace` classes provide `Write`, `WriteLine`, and `WriteIf`
    methods. By default, these send messages to the debugger’s output window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `Trace` class also provides the methods `TraceInformation`, `TraceWarning`,
    and `TraceError`. The difference in behavior between these and the `Write` methods
    depends on the active `TraceListener`s (we cover this in [“TraceListener”](#tracelistener)).
  prefs: []
  type: TYPE_NORMAL
- en: Fail and Assert
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Debug` and `Trace` classes both provide `Fail` and `Assert` methods. `Fail`
    sends the message to each `TraceListener` in the `Debug` or `Trace` class’s `Listeners`
    collection (see the following section), which by default writes the message to
    the debug output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`Assert` simply calls `Fail` if the `bool` argument is `false`—this is called
    *making an assertion* and indicates a bug in the code if violated. Specifying
    a failure message is optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `Write`, `Fail`, and `Assert` methods are also overloaded to accept a `string`
    category in addition to the message, which can be useful in processing the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative to assertion is to throw an exception if the opposite condition
    is true. This is a common practice when validating method arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Such “assertions” are compiled unconditionally and are less flexible in that
    you can’t control the outcome of a failed assertion via `TraceListener`s. And
    technically, they’re not assertions. An assertion is something that, if violated,
    indicates a bug in the current method’s code. Throwing an exception based on argument
    validation indicates a bug in the *caller*’s code.
  prefs: []
  type: TYPE_NORMAL
- en: TraceListener
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Trace` class has a static `Listeners` property that returns a collection
    of `TraceListener` instances. These are responsible for processing the content
    emitted by the `Write`, `Fail`, and `Trace` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the `Listeners` collection of each includes a single listener (`Default​Tra⁠ceListener`).
    The default listener has two key features:'
  prefs: []
  type: TYPE_NORMAL
- en: When connected to a debugger such as Visual Studio, messages are written to
    the debug output window; otherwise, message content is ignored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the `Fail` method is called (or an assertion fails), the application is
    terminated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can change this behavior by (optionally) removing the default listener
    and then adding one or more of your own. You can write trace listeners from scratch
    (by subclassing `TraceListener`) or use one of the predefined types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TextWriterTraceListener` writes to a `Stream` or `TextWriter` or appends to
    a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EventLogTraceListener` writes to the Windows event log (Windows only).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EventProviderTraceListener` writes to the Event Tracing for Windows (ETW)
    subsystem (cross-platform support).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextWriterTraceListener` is further subclassed to `ConsoleTraceListener`,
    `DelimitedListTraceListener`, `XmlWriterTraceListener`, and `EventSchemaTraceListener`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example clears `Trace`’s default listener and then adds three
    listeners—one that appends to a file, one that writes to the console, and one
    that writes to the Windows event log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the case of the Windows event log, messages that you write with the `Write`,
    `Fail`, or `Assert` method always display as “Information” messages in the Windows
    event viewer. Messages that you write via the `TraceWarning` and `TraceError`
    methods, however, show up as warnings or errors.
  prefs: []
  type: TYPE_NORMAL
- en: '`TraceListener` also has a `Filter` of type `TraceFilter` that you can set
    to control whether a message gets written to that listener. To do this, you either
    instantiate one of the predefined subclasses (`EventTypeFilter` or `SourceFilter`),
    or subclass `TraceFilter` and override the `ShouldTrace` method. You could use
    this to filter by category, for instance.'
  prefs: []
  type: TYPE_NORMAL
- en: '`TraceListener` also defines `IndentLevel` and `IndentSize` properties for
    controlling indentation, and the `TraceOutputOptions` property for writing extra
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`TraceOutputOptions` are applied when using the `Trace` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Flushing and Closing Listeners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some listeners, such as `TextWriterTraceListener`, ultimately write to a stream
    that is subject to caching. This has two implications:'
  prefs: []
  type: TYPE_NORMAL
- en: A message might not appear in the output stream or file immediately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must close—or at least flush—the listener before your application ends;
    otherwise, you lose what’s in the cache (up to 4 KB, by default, if you’re writing
    to a file).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Trace` and `Debug` classes provide static `Close` and `Flush` methods that
    call `Close` or `Flush` on all listeners (which in turn calls `Close` or `Flush`
    on any underlying writers and streams). `Close` implicitly calls `Flush`, closes
    file handles, and prevents further data from being written.
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, call `Close` before an application ends, and call `Flush`
    anytime you want to ensure that current message data is written. This applies
    if you’re using stream- or file-based listeners.
  prefs: []
  type: TYPE_NORMAL
- en: '`Trace` and `Debug` also provide an `AutoFlush` property, which, if `true`,
    forces a `Flush` after every message.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It’s a good policy to set `AutoFlush` to `true` on `Debug` and `Trace` if you’re
    using any file- or stream-based listeners. Otherwise, if an unhandled exception
    or critical error occurs, the last 4 KB of diagnostic information can be lost.
  prefs: []
  type: TYPE_NORMAL
- en: Debugger Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it’s useful for an application to interact with a debugger if one
    is available. During development, the debugger is usually your IDE (e.g., Visual
    Studio); in deployment, the debugger is more likely to be one of the lower-level
    debugging tools, such as WinDbg, Cordbg, or MDbg.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching and Breaking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The static `Debugger` class in `System.Diagnostics` provides basic functions
    for interacting with a debugger—namely `Break`, `Launch`, `Log`, and `IsAttached`.
  prefs: []
  type: TYPE_NORMAL
- en: A debugger must first attach to an application in order to debug it. If you
    start an application from within an IDE, this happens automatically, unless you
    request otherwise (by choosing “Start without debugging”). Sometimes, though,
    it’s inconvenient or impossible to start an application in debug mode within the
    IDE. An example is a Windows Service application or (ironically) a Visual Studio
    designer. One solution is to start the application normally and then, in your
    IDE, choose Debug Process. This doesn’t allow you to set breakpoints early in
    the program’s execution, however.
  prefs: []
  type: TYPE_NORMAL
- en: The workaround is to call `Debugger.Break` from within your application. This
    method launches a debugger, attaches to it, and suspends execution at that point.
    (`Launch` does the same, but without suspending execution.) After it’s attached,
    you can log messages directly to the debugger’s output window with the `Log` method.
    You can verify whether you’re attached to a debugger by checking the `IsAttached`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Debugger Attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `DebuggerStepThrough` and `DebuggerHidden` attributes provide suggestions
    to the debugger on how to handle single-stepping for a particular method, constructor,
    or class.
  prefs: []
  type: TYPE_NORMAL
- en: '`DebuggerStepThrough` requests that the debugger step through a function without
    any user interaction. This attribute is useful in automatically generated methods
    and in proxy methods that forward the real work to a method somewhere else. In
    the latter case, the debugger will still show the proxy method in the call stack
    if a breakpoint is set within the “real” method—unless you also add the `DebuggerHidden`
    attribute. You can combine these two attributes on proxies to help the user focus
    on debugging the application logic rather than the plumbing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Processes and Process Threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We described in the last section of [Chapter 6](ch06.html#dotnet_fundamentals)
    how to use `Process.Start` to launch a new process. The `Process` class also allows
    you to query and interact with other processes running on the same or another
    computer. The `Process` class is part of .NET Standard 2.0, although its features
    are restricted for the UWP platform.
  prefs: []
  type: TYPE_NORMAL
- en: Examining Running Processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Process.GetProcess*XXX*` methods retrieve a specific process by name or
    process ID, or all processes running on the current or nominated computer. This
    includes both managed and unmanaged processes. Each `Process` instance has a wealth
    of properties mapping statistics such as name, ID, priority, memory and processor
    utilization, window handles, and so on. The following sample enumerates all the
    running processes on the current computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`Process.GetCurrentProcess` returns the current process.'
  prefs: []
  type: TYPE_NORMAL
- en: You can terminate a process by calling its `Kill` method.
  prefs: []
  type: TYPE_NORMAL
- en: Examining Threads in a Process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also enumerate over the threads of other processes with the `Pro⁠cess​.Threads`
    property. The objects that you get, however, are not `System.Thread⁠ing​.Thread`
    objects; they’re `ProcessThread` objects and are intended for administrative rather
    than synchronization tasks. A `ProcessThread` object provides diagnostic information
    about the underlying thread and allows you to control some aspects of it, such
    as its priority and processor affinity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: StackTrace and StackFrame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `StackTrace` and `StackFrame` classes provide a read-only view of an execution
    call stack. You can obtain stack traces for the current thread or an `Exception`
    object. Such information is useful mostly for diagnostic purposes, though you
    also can use it in programming (hacks). `StackTrace` represents a complete call
    stack; `StackFrame` represents a single method call within that stack.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you just need to know the name and line number of the calling method, caller
    info attributes can provide an easier and faster alternative. We cover this topic
    in [“Caller Info Attributes”](ch04.html#caller_info_attributes).
  prefs: []
  type: TYPE_NORMAL
- en: If you instantiate a `StackTrace` object with no arguments—or with a `bool`
    argument—you get a snapshot of the current thread’s call stack. The `bool` argument,
    if `true`, instructs `StackTrace` to read the assembly *.pdb* (project debug)
    files if they are present, giving you access to filename, line number, and column
    offset data. Project debug files are generated when you compile with the `/debug`
    switch. (Visual Studio compiles with this switch unless you request otherwise
    via *Advanced Build Settings*.)
  prefs: []
  type: TYPE_NORMAL
- en: 'After you’ve obtained a `StackTrace`, you can examine a particular frame by
    calling `GetFrame`—or obtain the whole lot by using `GetFrames`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The Intermediate Language (IL) offset indicates the offset of the instruction
    that will execute *next*—not the instruction that’s currently executing. Peculiarly,
    though, the line and column number (if a *.pdb* file is present) usually indicate
    the actual execution point.
  prefs: []
  type: TYPE_NORMAL
- en: This happens because the CLR does its best to *infer* the actual execution point
    when calculating the line and column from the IL offset. The compiler emits IL
    in such a way as to make this possible—including inserting `nop` (no-operation)
    instructions into the IL stream.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling with optimizations enabled, however, disables the insertion of `nop`
    instructions, and so the stack trace might show the line and column number of
    the next statement to execute. Obtaining a useful stack trace is further hampered
    by the fact that optimization can pull other tricks, including collapsing entire
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'A shortcut to obtaining the essential information for an entire `StackTrace`
    is to call `ToString` on it. Here’s what the result looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You can also obtain the stack trace for an `Exception` object (showing what
    led up to the exception being thrown) by passing the `Exception` into `StackTrace`’s
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`Exception` already has a `StackTrace` property; however, this property returns
    a simple string—not a `StackTrace` object. A `StackTrace` object is far more useful
    in logging exceptions that occur after deployment—where no *.pdb* files are available—because
    you can log the *IL offset* in lieu of line and column numbers. With an IL offset
    and *ildasm*, you can pinpoint where within a method an error occurred.'
  prefs: []
  type: TYPE_NORMAL
- en: Windows Event Logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Win32 platform provides a centralized logging mechanism, in the form of
    the Windows event logs.
  prefs: []
  type: TYPE_NORMAL
- en: The `Debug` and `Trace` classes we used earlier write to a Windows event log
    if you register an `EventLogTraceListener`. With the `EventLog` class, however,
    you can write directly to a Windows event log without using `Trace` or `Debug`.
    You can also use this class to read and monitor event data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Writing to the Windows event log makes sense in a Windows Service application,
    because if something goes wrong, you can’t pop up a user interface directing the
    user to some special file where diagnostic information has been written. Also,
    because it’s common practice for services to write to the Windows event log, this
    is the first place an administrator is likely to look if your service falls over.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three standard Windows event logs, identified by these names:'
  prefs: []
  type: TYPE_NORMAL
- en: Application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Application log is where most applications normally write.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to the Event Log
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To write to a Windows event log:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose one of the three event logs (usually *Application*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decide on a *source name* and create it if necessary (create requires administrative
    permissions).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `EventLog.WriteEntry` with the log name, source name, and message data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The *source name* is an easily identifiable name for your application. You
    must register a source name before you use it—the `CreateEventSource` method performs
    this function. You can then call `WriteEntry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`EventLogEntryType` can be `Information`, `Warning`, `Error`, `SuccessAudit`,
    or `FailureAudit`. Each displays with a different icon in the Windows event viewer.
    You can also optionally specify a category and event ID (each is a number of your
    own choosing) and provide optional binary data.'
  prefs: []
  type: TYPE_NORMAL
- en: '`CreateEventSource` also allows you to specify a machine name: this is to write
    to another computer’s event log, if you have sufficient permissions.'
  prefs: []
  type: TYPE_NORMAL
- en: Reading the Event Log
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To read an event log, instantiate the `EventLog` class with the name of the
    log that you want to access and optionally the name of another computer on which
    the log resides. Each log entry can then be read via the `Entries` collection
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can enumerate over all logs for the current (or another) computer via the
    static method `EventLog.GetEventLogs` (this requires administrative privileges
    for full access):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This normally prints, at a minimum, *Application*, *Security*, and *System*.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring the Event Log
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can be alerted whenever an entry is written to a Windows event log, via
    the `EntryWritten` event. This works for event logs on the local computer, and
    it fires regardless of what application logged the event.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable log monitoring:'
  prefs: []
  type: TYPE_NORMAL
- en: Instantiate an `EventLog` and set its `EnableRaisingEvents` property to `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Handle the `EntryWritten` event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Performance Counters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Performance Counters are a Windows-only feature and require the NuGet package
    `System.Diagnostics​.Per⁠formance​Counter`. If you’re targeting Linux or macOS,
    see [“Cross-Platform Diagnostic Tools”](#cross_platform_diagnostics_tools) for
    alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: The logging mechanisms we’ve discussed to date are useful for capturing information
    for future analysis. However, to gain insight into the current state of an application
    (or the system as a whole), a more real-time approach is needed. The Win32 solution
    to this need is the performance-monitoring infrastructure, which consists of a
    set of performance counters that the system and applications expose, and the Microsoft
    Management Console (MMC) snap-ins used to monitor these counters in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Performance counters are grouped into categories such as “System,” “Processor,”
    “.NET CLR Memory,” and so on. These categories are sometimes also referred to
    as “performance objects” by the graphical user interface (GUI) tools. Each category
    groups a related set of performance counters that monitor one aspect of the system
    or application. Examples of performance counters in the “.NET CLR Memory” category
    include “% Time in GC,” “# Bytes in All Heaps,” and “Allocated bytes/sec.”
  prefs: []
  type: TYPE_NORMAL
- en: Each category can optionally have one or more instances that can be monitored
    independently. For example, this is useful in the “% Processor Time” performance
    counter in the “Processor” category, which allows one to monitor CPU utilization.
    On a multiprocessor machine, this counter supports an instance for each CPU, allowing
    you to monitor the utilization of each CPU independently.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections illustrate how to perform commonly needed tasks such
    as determining which counters are exposed, monitoring a counter, and creating
    your own counters to expose application status information.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Reading performance counters or categories might require administrator privileges
    on the local or target computer, depending on what is accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating the Available Counters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example enumerates over all of the available performance counters
    on the computer. For those that have instances, it enumerates the counters for
    each instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The result is more than 10,000 lines long! It also takes a while to execute
    because `PerformanceCounter​Cate⁠gory.Instance​Exists` has an inefficient implementation.
    In a real system, you’d want to retrieve the more detailed information only on
    demand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example uses LINQ to retrieve just .NET performance counters, writing
    the result to an XML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Reading Performance Counter Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To retrieve the value of a performance counter, instantiate a `PerformanceCounter`
    object and then call the `NextValue` or `NextSample` method. `NextValue` returns
    a simple `float` value; `NextSample` returns a `CounterSample` object that exposes
    a more advanced set of properties, such as `CounterFrequency`, `TimeStamp`, `BaseValue`,
    and `RawValue`.
  prefs: []
  type: TYPE_NORMAL
- en: '`PerformanceCounter`’s constructor takes a category name, counter name, and
    optional instance. So, to display the current processor utilization for all CPUs,
    you would do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Or to display the “real” (i.e., private) memory consumption of the current
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`PerformanceCounter` doesn’t expose a `ValueChanged` event, so if you want
    to monitor for changes, you must poll. In the next example, we poll every 200
    ms—until signaled to quit by an `EventWaitHandle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how we can use this method to simultaneously monitor processor and hard-drive
    activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Creating Counters and Writing Performance Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before writing performance counter data, you need to create a performance category
    and counter. You must create the performance category along with all the counters
    that belong to it in one step, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The new counters then show up in the Windows performance-monitoring tool when
    you choose Add Counters. If you later want to define more counters in the same
    category, you must first delete the old category by calling `Performance​Coun⁠terCategory.Delete`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Creating and deleting performance counters requires administrative privileges.
    For this reason, it’s usually done as part of the application setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you create a counter, you can update its value by instantiating a `PerformanceCounter`,
    setting `ReadOnly` to `false`, and setting `RawValue`. You can also use the `Increment`
    and `IncrementBy` methods to update the existing value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The Stopwatch Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Stopwatch` class provides a convenient mechanism for measuring execution
    times. `Stopwatch` uses the highest-resolution mechanism that the OS and hardware
    provide, which is typically less than a microsecond. (In contrast, `DateTime.Now`
    and `Environment.TickCount` have a resolution of about 15 ms.)
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `Stopwatch`, call `StartNew`—this instantiates a `Stopwatch` and starts
    it ticking. (Alternatively, you can instantiate it manually and then call `Start`.)
    The `Elapsed` property returns the elapsed interval as a `TimeSpan`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`Stopwatch` also exposes an `ElapsedTicks` property, which returns the number
    of elapsed “ticks” as a `long`. To convert from ticks to seconds, divide by `StopWatch​.Fre⁠quency`.
    There’s also an `ElapsedMilliseconds` property, which is often the most convenient.'
  prefs: []
  type: TYPE_NORMAL
- en: Calling `Stop` freezes `Elapsed` and `ElapsedTicks`. There’s no background activity
    incurred by a “running” `Stopwatch`, so calling `Stop` is optional.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Platform Diagnostic Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we briefly describe the cross-platform diagnostic tools available
    to .NET:'
  prefs: []
  type: TYPE_NORMAL
- en: dotnet-counters
  prefs: []
  type: TYPE_NORMAL
- en: Provides an overview of the state of a running application
  prefs: []
  type: TYPE_NORMAL
- en: dotnet-trace
  prefs: []
  type: TYPE_NORMAL
- en: For more detailed performance and event monitoring
  prefs: []
  type: TYPE_NORMAL
- en: dotnet-dump
  prefs: []
  type: TYPE_NORMAL
- en: To obtain a memory dump on demand or after a crash
  prefs: []
  type: TYPE_NORMAL
- en: These tools do not require administrative elevation and are suitable for both
    development and production environments.
  prefs: []
  type: TYPE_NORMAL
- en: dotnet-counters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *dotnet-counters* tool monitors the memory and CPU usage of a .NET process
    and writes the data to the console (or a file).
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the tool, run the following from a command prompt or terminal with
    *dotnet* in the path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then start monitoring a process, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`System.Runtime` means that we want to monitor all counters under the *System.Runtime*
    category. You can specify either a category or counter name (the `dotnet-counters
    list` command lists all available categories and counters).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is continually refreshed and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are all available commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Commands | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `list` | Displays a list of counter names along with a description of each
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ps` | Displays a list of dotnet processes eligible for monitoring |'
  prefs: []
  type: TYPE_TB
- en: '| `monitor` | Displays values of selected counters (periodically refreshed)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `collect` | Saves counter information to a file |'
  prefs: []
  type: TYPE_TB
- en: 'The following parameters are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Options/arguments | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `--version` | Displays the version of *dotnet-counters*. |'
  prefs: []
  type: TYPE_TB
- en: '| `-h, --help` | Displays help about the program. |'
  prefs: []
  type: TYPE_TB
- en: '| `-p, --process-id` | ID of dotnet process to monitor. Applies to the `monitor`
    and `collect` commands. |'
  prefs: []
  type: TYPE_TB
- en: '| `--refresh-interval` | Sets the desired refresh interval in seconds. Applies
    to the `monitor` and `collect` commands. |'
  prefs: []
  type: TYPE_TB
- en: '| `-o, --output` | Sets the output file name. Applies to the `collect` command.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `--format` | Sets the output format. Valid are *csv* or *json*. Applies to
    the `collect` command. |'
  prefs: []
  type: TYPE_TB
- en: dotnet-trace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Traces are timestamped records of events in your program, such as a method being
    called or a database being queried. Traces can also include performance metrics
    and custom events, and can contain local context such as the value of local variables.
    Traditionally, .NET Framework and frameworks such as ASP.NET used ETW. In .NET
    5, application traces are written to ETW when running on Windows and LTTng on
    Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the tool, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To start recording a program’s events, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This runs *dotnet-trace* with the default profile, which collects CPU and .NET
    runtime events and writes to a file called *trace.nettrace*. You can specify other
    profiles with the `--profile` switch: *gc-verbose* tracks garbage collection and
    sampled object allocation, and *gc-collect* tracks garbage collection with a low
    overhead. The `-o` switch lets you specify a different output filename.'
  prefs: []
  type: TYPE_NORMAL
- en: The default output is a *.netperf* file, which can be analyzed directly on a
    Windows machine with the PerfView tool. Alternatively, you can instruct *dotnet-trace*
    to create a file compatible with Speedscope, which is a free online analysis service
    at [*https://speedscope.app*](https://speedscope.app). To create a Speedscope
    (*.speedscope.json*) file, use the option `--format speedscope`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can download the latest version of PerfView from [*https://github.com/microsoft/perfview*](https://github.com/microsoft/perfview).
    The version that ships with Windows 10 might not support *.netperf* files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Commands | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `collect` | Starts recording counter information to a file. |'
  prefs: []
  type: TYPE_TB
- en: '| `ps` | Displays a list of dotnet processes eligible for monitoring. |'
  prefs: []
  type: TYPE_TB
- en: '| `list-profiles` | Lists prebuilt tracing profiles with a description of providers
    and filters in each. |'
  prefs: []
  type: TYPE_TB
- en: '| `convert <file>` | Converts from the *nettrace* (*.netperf*) format to an
    alternative format. Currently, *speedscope* is the only target option. |'
  prefs: []
  type: TYPE_TB
- en: Custom trace events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Your app can emit custom events by defining a custom `EventSource`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WriteEvent` method is overloaded to accept various combinations of simple
    types (primarily strings and integers). You can then call it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'When calling *dotnet-trace*, you must specify the name(s) of any custom event
    sources that want to record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: dotnet-dump
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *dump*, sometimes called a *core dump*, is a snapshot of the state of a process’s
    virtual memory. You can dump a running process on demand, or configure the OS
    to generate a dump when an application crashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Ubuntu Linux, the following command enables a core dump upon application
    crash (the necessary steps can vary between different flavors of Linux):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, use *regedit.exe* to create or edit the following key in the local
    machine hive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Under that, add a key with the same name as your executable (e.g., *foo.exe*),
    and under that key, add the following keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DumpFolder` (REG_EXPAND_SZ), with a value indicating the path to which you
    want dump files written'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DumpType` (REG_DWORD), with a value of 2 to request a full dump'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Optionally) `DumpCount` (REG_DWORD), indicating the maximum number of dump
    files before the oldest is removed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To install the tool, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'After you’ve installed it, you can initiate a dump on demand (without ending
    the process), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command starts an interactive shell for analyzing a dump file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: If an exception took down the application, you can use the *printexceptions*
    command (*pe* for short) to display details of that exception. The dotnet-dump
    shell supports numerous additional commands, which you can list with the *help*
    command.
  prefs: []
  type: TYPE_NORMAL
