- en: Chapter 13\. Diagnostics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章\. 诊断
- en: When things go wrong, it’s important that information is available to aid in
    diagnosing the problem. An Integrated Development Environment (IDE) or debugger
    can assist greatly to this effect—but it is usually available only during development.
    After an application ships, the application itself must gather and record diagnostic
    information. To meet this requirement, .NET provides a set of facilities to log
    diagnostic information, monitor application behavior, detect runtime errors, and
    integrate with debugging tools if available.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现问题时，重要的是有信息可用以帮助诊断问题。集成开发环境（IDE）或调试器可以极大地帮助此过程，但通常仅在开发期间可用。应用程序发布后，必须收集和记录诊断信息。为了满足此要求，.NET
    提供了一组设施来记录诊断信息，监视应用程序行为，检测运行时错误，并在可能时与调试工具集成。
- en: Some diagnostic tools and APIs are Windows specific because they rely on features
    of the Windows operating system. In an effort to prevent platform-specific APIs
    from cluttering the .NET BCL, Microsoft has shipped them in separate NuGet packages
    that you can optionally reference. There are more than a dozen Windows-specific
    packages, which you can reference all at once with the *Microsoft.Windows.Compatibility*
    “master” package.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一些诊断工具和 API 是特定于 Windows 的，因为它们依赖于 Windows 操作系统的功能。为了防止平台特定的 API 混乱.NET BCL，微软已经将它们封装在单独的
    NuGet 包中，您可以选择性地引用它们。有超过一打的特定于 Windows 的包，您可以使用 *Microsoft.Windows.Compatibility*
    “主” 包一次引用它们。
- en: The types in this chapter are defined primarily in the `System.Diagnostics`
    namespace.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的类型主要在 `System.Diagnostics` 命名空间中定义。
- en: Conditional Compilation
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件编译
- en: You can conditionally compile any section of code in C# with *preprocessor directives*.
    Preprocessor directives are special instructions to the compiler that begin with
    the `#` symbol (and, unlike other C# constructs, must appear on a line of their
    own). Logically, they execute before the main compilation takes place (although
    in practice, the compiler processes them during the lexical parsing phase). The
    preprocessor directives for conditional compilation are `#if`, `#else`, `#endif`,
    and `#elif`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用*预处理指令*在 C# 中有条件地编译任何代码段。预处理指令是以 `#` 符号开头的特殊指令（与其他 C# 结构不同，必须单独出现在一行上）。逻辑上，在主编译之前执行它们（尽管在实践中，编译器在词法分析阶段处理它们）。用于条件编译的预处理指令包括
    `#if`、`#else`、`#endif` 和 `#elif`。
- en: 'The `#if` directive instructs the compiler to ignore a section of code unless
    a specified *symbol* has been defined. You can define a symbol in source code
    by using the `#define` directive (in which case the symbol applies to just that
    file), or in the *.csproj* file by using a `<DefineConstants>` element (in which
    case the symbol applies to whole assembly):'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`#if` 指令指示编译器在指定的*符号*已被定义时忽略代码段。您可以通过使用 `#define` 指令在源代码中定义符号（在这种情况下，符号仅适用于该文件），或者在
    *.csproj* 文件中使用 `<DefineConstants>` 元素（在这种情况下，符号适用于整个程序集）：'
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If we deleted the first line, the program would compile with the `Console.WriteLine`
    statement completely eliminated from the executable, as though it were commented
    out.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们删除第一行，则程序将编译，`Console.WriteLine` 语句将完全从可执行文件中删除，就像被注释掉一样。
- en: 'The `#else` statement is analogous to C#’s `else` statement, and `#elif` is
    equivalent to `#else` followed by `#if`. The `||`, `&&`, and `!` operators perform
    *or*, *and*, and *not* operations:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`#else` 语句类似于 C# 的 `else` 语句，而 `#elif` 相当于 `#else` 后跟 `#if`。`||`、`&&` 和 `!`
    运算符执行*或*、*与* 和 *非* 操作：'
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Keep in mind, however, that you’re not building an ordinary C# expression, and
    the symbols upon which you operate have absolutely no connection to *variables*—static
    or otherwise.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，您并不是在构建普通的 C# 表达式，您操作的符号与*变量*（静态或其他）没有任何关联。
- en: 'You can define symbols that apply to every file in an assembly by editing the
    *.csproj* file (or in Visual Studio, by going to the Build tab in the Project
    Properties window). The following defines two constants, `TESTMODE` and `PLAYMODE`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过编辑 *.csproj* 文件（或在 Visual Studio 中，在项目属性窗口的“生成”选项卡中）定义适用于程序集中每个文件的符号。以下定义了两个常量，`TESTMODE`
    和 `PLAYMODE`：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you’ve defined a symbol at the assembly level and then want to “undefine”
    it for a particular file, you can do so by using the `#undef` directive.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在程序集级别定义了一个符号，然后希望在特定文件中“取消定义”它，可以使用 `#undef` 指令。
- en: Conditional Compilation Versus Static Variable Flags
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件编译与静态变量标志对比
- en: 'You could instead implement the preceding example with a simple static field:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用简单的静态字段来实现前面的示例：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This has the advantage of allowing runtime configuration. So, why choose conditional
    compilation? The reason is that conditional compilation can take you places variable
    flags cannot, such as the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这具有允许运行时配置的优点。那么，为什么选择条件编译？原因在于条件编译可以带你到变量标志无法到达的地方，比如以下情况：
- en: Conditionally including an attribute
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件包含属性
- en: Changing the declared type of variable
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改变量的声明类型
- en: 'Switching between different namespaces or type aliases in a `using` directive;
    for example:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`using`指令中切换不同的命名空间或类型别名；例如：
- en: '[PRE4]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can even perform major refactoring under a conditional compilation directive,
    so you can instantly switch between old and new versions, and write libraries
    that can compile against multiple runtime versions, leveraging the latest features
    where available.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以在条件编译指令下执行重大重构，因此您可以即时在旧版和新版之间切换，并编写可以针对多个运行时版本进行编译的库，在可用时利用最新功能。
- en: Another advantage of conditional compilation is that debugging code can refer
    to types in assemblies that are not included in deployment.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 条件编译的另一个优点是调试代码可以引用部署中未包含的程序集中的类型。
- en: The Conditional Attribute
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件属性
- en: The `Conditional` attribute instructs the compiler to ignore any calls to a
    particular class or method, if the specified symbol has not been defined.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Conditional`属性指示编译器忽略对特定类或方法的所有调用，如果指定的符号未被定义。'
- en: 'To see how this is useful, suppose that you write a method for logging status
    information as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这对您有多有用，请假设您编写了一个用于记录状态信息的方法，如下所示：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now imagine that you want this to execute only if the `LOGGINGMODE` symbol
    is defined. The first solution is to wrap all calls to `LogStatus` around an `#if`
    directive:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，您只希望在定义了`LOGGINGMODE`符号时执行此操作。第一种解决方案是将对`LogStatus`的所有调用都包装在`#if`指令中：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This gives an ideal result, but it is tedious. The second solution is to put
    the `#if` directive inside the `LogStatus` method. This, however, is problematic
    should `LogStatus` be called as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以得到理想的结果，但是这很繁琐。第二种解决方案是将`#if`指令放在`LogStatus`方法内部。然而，如果以以下方式调用`LogStatus`，这将会有问题：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`GetComplexMessageHeaders` would always be called—which might incur a performance
    hit.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetComplexMessageHeaders`将始终被调用，这可能会带来性能损失。'
- en: 'We can combine the functionality of the first solution with the convenience
    of the second by attaching the `Conditional` attribute (defined in `System.Diagnostics`)
    to the `LogStatus` method:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将`Conditional`属性（定义在`System.Diagnostics`中）附加到`LogStatus`方法来将第一种解决方案的功能与第二种解决方案的便利性结合起来：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This instructs the compiler to treat calls to `LogStatus` as though they were
    wrapped in an `#if LOGGINGMODE` directive. If the symbol is not defined, any calls
    to `Log​Sta⁠tus` are eliminated entirely in compilation—including their argument
    evaluation expressions. (Hence any side-effecting expressions will be bypassed.)
    This works even if `LogStatus` and the caller are in different assemblies.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这会指示编译器将对`LogStatus`的调用视为包含在`#if LOGGINGMODE`指令中。如果未定义该符号，则在编译中将完全消除对`LogStatus`的任何调用，包括它们的参数评估表达式。（因此，任何具有副作用的表达式将被跳过。）即使`LogStatus`和调用方位于不同的程序集中，这也适用。
- en: Note
  id: totrans-37
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Another benefit of `[Conditional]` is that the conditionality check is performed
    when the *caller* is compiled, rather than when the *called method* is compiled.
    This is beneficial because it allows you to write a library containing methods
    such as `LogStatus`—and build just one version of that library.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`[Conditional]`的另一个好处是条件检查是在*调用方*编译时进行的，而不是在*被调用方法*编译时进行的。这很有益，因为它允许您编写包含诸如`LogStatus`之类方法的库，并且只构建该库的一个版本。'
- en: The `Conditional` attribute is ignored at runtime—it’s purely an instruction
    to the compiler.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Conditional`属性在运行时被忽略——它纯粹是对编译器的指示。'
- en: Alternatives to the Conditional attribute
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件属性的替代方案
- en: 'The `Conditional` attribute is useless if you need to dynamically enable or
    disable functionality at runtime: instead, you must use a variable-based approach.
    This leaves the question of how to elegantly circumvent the evaluation of arguments
    when calling conditional logging methods. A functional approach solves this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要在运行时动态启用或禁用功能，则`Conditional`属性无效：相反，必须使用基于变量的方法。这留下了在调用条件日志方法时如何优雅地避免参数评估的问题。函数方法可以解决这个问题：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A lambda expression lets you call this method without syntax bloat:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用lambda表达式可以在不增加语法复杂性的情况下调用此方法：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If `EnableLogging` is `false`, `GetComplexMessageHeaders` is never evaluated.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`EnableLogging`为`false`，则`GetComplexMessageHeaders`永远不会被评估。
- en: Debug and Trace Classes
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试和跟踪类
- en: '`Debug` and `Trace` are static classes that provide basic logging and assertion
    capabilities. The two classes are very similar; the main differentiator is their
    intended use. The `Debug` class is intended for debug builds; the `Trace` class
    is intended for both debug and release builds. To this effect:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Debug`和`Trace`是提供基本日志记录和断言能力的静态类。这两个类非常相似；主要区别在于它们的预期用途。`Debug`类用于调试版本；`Trace`类用于调试和发布版本。为此：'
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This means that all calls that you make to `Debug` or `Trace` are eliminated
    by the compiler unless you define `DEBUG` or `TRACE` symbols. (Visual Studio provides
    checkboxes for defining these symbols in the Build tab of Project Properties,
    and enables the TRACE symbol by default with new projects.)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，除非定义了`DEBUG`或`TRACE`符号，否则编译器将消除对`Debug`或`Trace`的所有调用（Visual Studio在项目属性的构建选项卡中提供了定义这些符号的复选框，并默认使用新项目启用TRACE符号）。
- en: 'Both the `Debug` and `Trace` classes provide `Write`, `WriteLine`, and `WriteIf`
    methods. By default, these send messages to the debugger’s output window:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Debug`和`Trace`类都提供`Write`、`WriteLine`和`WriteIf`方法。默认情况下，这些方法将消息发送到调试器的输出窗口：'
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `Trace` class also provides the methods `TraceInformation`, `TraceWarning`,
    and `TraceError`. The difference in behavior between these and the `Write` methods
    depends on the active `TraceListener`s (we cover this in [“TraceListener”](#tracelistener)).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Trace`类还提供`TraceInformation`、`TraceWarning`和`TraceError`方法。这些方法与`Write`方法的行为差异取决于活动的`TraceListener`（我们在[“TraceListener”](#tracelistener)中介绍了这一点）。'
- en: Fail and Assert
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 失败和断言
- en: 'The `Debug` and `Trace` classes both provide `Fail` and `Assert` methods. `Fail`
    sends the message to each `TraceListener` in the `Debug` or `Trace` class’s `Listeners`
    collection (see the following section), which by default writes the message to
    the debug output:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Debug`和`Trace`类都提供`Fail`和`Assert`方法。`Fail`将消息发送给`Debug`或`Trace`类的`Listeners`集合中的每个`TraceListener`（请参见下一节），默认情况下将消息写入调试输出：'
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`Assert` simply calls `Fail` if the `bool` argument is `false`—this is called
    *making an assertion* and indicates a bug in the code if violated. Specifying
    a failure message is optional:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Assert`如果`bool`参数为`false`，则简单调用`Fail`，这被称为*进行断言*，如果违反则表示代码中存在 bug。指定失败消息是可选的：'
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `Write`, `Fail`, and `Assert` methods are also overloaded to accept a `string`
    category in addition to the message, which can be useful in processing the output.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了消息外，`Write`、`Fail`和`Assert`方法还可以重载接受一个`string`类别，这在处理输出时非常有用。
- en: 'An alternative to assertion is to throw an exception if the opposite condition
    is true. This is a common practice when validating method arguments:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种断言的替代方法是，如果相反条件为真，则抛出异常。这在验证方法参数时是一种常见做法：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Such “assertions” are compiled unconditionally and are less flexible in that
    you can’t control the outcome of a failed assertion via `TraceListener`s. And
    technically, they’re not assertions. An assertion is something that, if violated,
    indicates a bug in the current method’s code. Throwing an exception based on argument
    validation indicates a bug in the *caller*’s code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此类“断言”被无条件编译，而且在控制失败断言的结果上不够灵活，无法通过`TraceListener`来控制。严格来说，它们并不是断言。断言是指当前方法代码中的bug，如果违反则表明存在问题。基于参数验证抛出异常表明调用者的代码中存在bug。
- en: TraceListener
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TraceListener
- en: The `Trace` class has a static `Listeners` property that returns a collection
    of `TraceListener` instances. These are responsible for processing the content
    emitted by the `Write`, `Fail`, and `Trace` methods.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Trace`类有一个静态的`Listeners`属性，返回一个`TraceListener`实例的集合。这些负责处理`Write`、`Fail`和`Trace`方法发出的内容。'
- en: 'By default, the `Listeners` collection of each includes a single listener (`Default​Tra⁠ceListener`).
    The default listener has two key features:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每个的`Listeners`集合都包含一个监听器（`Default​Tra⁠ceListener`）。默认监听器有两个关键特性：
- en: When connected to a debugger such as Visual Studio, messages are written to
    the debug output window; otherwise, message content is ignored.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当连接到诸如Visual Studio之类的调试器时，消息将被写入调试输出窗口；否则，将忽略消息内容。
- en: When the `Fail` method is called (or an assertion fails), the application is
    terminated.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用`Fail`方法（或断言失败）时，应用程序将终止。
- en: 'You can change this behavior by (optionally) removing the default listener
    and then adding one or more of your own. You can write trace listeners from scratch
    (by subclassing `TraceListener`) or use one of the predefined types:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过（可选地）移除默认侦听器并添加一个或多个自定义侦听器来更改此行为。您可以从头编写跟踪侦听器（通过子类化`TraceListener`）或使用预定义类型之一：
- en: '`TextWriterTraceListener` writes to a `Stream` or `TextWriter` or appends to
    a file.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextWriterTraceListener`写入到`Stream`或`TextWriter`或附加到文件。'
- en: '`EventLogTraceListener` writes to the Windows event log (Windows only).'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventLogTraceListener`写入到Windows事件日志（仅限Windows）。'
- en: '`EventProviderTraceListener` writes to the Event Tracing for Windows (ETW)
    subsystem (cross-platform support).'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventProviderTraceListener`写入到Windows事件跟踪（ETW）子系统（跨平台支持）。'
- en: '`TextWriterTraceListener` is further subclassed to `ConsoleTraceListener`,
    `DelimitedListTraceListener`, `XmlWriterTraceListener`, and `EventSchemaTraceListener`.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextWriterTraceListener`进一步被子类化为`ConsoleTraceListener`、`DelimitedListTraceListener`、`XmlWriterTraceListener`和`EventSchemaTraceListener`。'
- en: 'The following example clears `Trace`’s default listener and then adds three
    listeners—one that appends to a file, one that writes to the console, and one
    that writes to the Windows event log:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例清除`Trace`的默认侦听器，然后添加三个侦听器——一个附加到文件，一个写入控制台，一个写入Windows事件日志：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the case of the Windows event log, messages that you write with the `Write`,
    `Fail`, or `Assert` method always display as “Information” messages in the Windows
    event viewer. Messages that you write via the `TraceWarning` and `TraceError`
    methods, however, show up as warnings or errors.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows事件日志，使用`Write`、`Fail`或`Assert`方法写入的消息始终在Windows事件查看器中显示为“信息”消息。但是，通过`TraceWarning`和`TraceError`方法写入的消息将显示为警告或错误。
- en: '`TraceListener` also has a `Filter` of type `TraceFilter` that you can set
    to control whether a message gets written to that listener. To do this, you either
    instantiate one of the predefined subclasses (`EventTypeFilter` or `SourceFilter`),
    or subclass `TraceFilter` and override the `ShouldTrace` method. You could use
    this to filter by category, for instance.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`TraceListener`还具有`TraceFilter`类型的`Filter`，您可以设置该过滤器以控制是否将消息写入该侦听器。为此，您可以实例化预定义的子类（如`EventTypeFilter`或`SourceFilter`），或者子类化`TraceFilter`并重写`ShouldTrace`方法。例如，您可以使用这个功能按类别进行过滤。'
- en: '`TraceListener` also defines `IndentLevel` and `IndentSize` properties for
    controlling indentation, and the `TraceOutputOptions` property for writing extra
    data:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`TraceListener`还定义了用于控制缩进的`IndentLevel`和`IndentSize`属性，以及用于写入额外数据的`TraceOutputOptions`属性：'
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`TraceOutputOptions` are applied when using the `Trace` methods:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Trace`方法时将应用`TraceOutputOptions`：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Flushing and Closing Listeners
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刷新和关闭侦听器
- en: 'Some listeners, such as `TextWriterTraceListener`, ultimately write to a stream
    that is subject to caching. This has two implications:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一些侦听器（如`TextWriterTraceListener`）最终会写入到可能受缓存影响的流中。这有两个影响：
- en: A message might not appear in the output stream or file immediately.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息可能不会立即显示在输出流或文件中。
- en: You must close—or at least flush—the listener before your application ends;
    otherwise, you lose what’s in the cache (up to 4 KB, by default, if you’re writing
    to a file).
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须在应用程序结束之前关闭——或至少刷新——侦听器；否则，您将丢失缓存中的内容（默认情况下最多4 KB，如果写入文件）。
- en: The `Trace` and `Debug` classes provide static `Close` and `Flush` methods that
    call `Close` or `Flush` on all listeners (which in turn calls `Close` or `Flush`
    on any underlying writers and streams). `Close` implicitly calls `Flush`, closes
    file handles, and prevents further data from being written.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Trace`和`Debug`类提供静态的`Close`和`Flush`方法，这些方法会调用所有侦听器的`Close`或`Flush`（进而调用底层的编写器和流的`Close`或`Flush`）。`Close`隐含调用`Flush`，关闭文件句柄，并防止进一步写入数据。'
- en: As a general rule, call `Close` before an application ends, and call `Flush`
    anytime you want to ensure that current message data is written. This applies
    if you’re using stream- or file-based listeners.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通常建议在应用程序结束之前调用`Close`，并在希望确保当前消息数据已写入时调用`Flush`。如果使用基于流或文件的侦听器，则适用此规则。
- en: '`Trace` and `Debug` also provide an `AutoFlush` property, which, if `true`,
    forces a `Flush` after every message.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Trace`和`Debug`还提供`AutoFlush`属性，如果设置为`true`，则在每条消息后强制执行`Flush`。'
- en: Note
  id: totrans-87
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It’s a good policy to set `AutoFlush` to `true` on `Debug` and `Trace` if you’re
    using any file- or stream-based listeners. Otherwise, if an unhandled exception
    or critical error occurs, the last 4 KB of diagnostic information can be lost.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用任何基于文件或流的侦听器，则将`AutoFlush`设置为`true`是一个好策略，否则，如果发生未处理的异常或关键错误，则可能会丢失最后的4
    KB诊断信息。
- en: Debugger Integration
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试器集成
- en: Sometimes, it’s useful for an application to interact with a debugger if one
    is available. During development, the debugger is usually your IDE (e.g., Visual
    Studio); in deployment, the debugger is more likely to be one of the lower-level
    debugging tools, such as WinDbg, Cordbg, or MDbg.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，如果可用，应用程序与调试器进行交互是有用的。在开发过程中，调试器通常是你的IDE（如Visual Studio）；在部署中，调试器更可能是较低级别的调试工具之一，如WinDbg、Cordbg或MDbg。
- en: Attaching and Breaking
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附加和中断
- en: The static `Debugger` class in `System.Diagnostics` provides basic functions
    for interacting with a debugger—namely `Break`, `Launch`, `Log`, and `IsAttached`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Diagnostics`中的静态`Debugger`类提供了与调试器交互的基本功能，即`Break`、`Launch`、`Log`和`IsAttached`。'
- en: A debugger must first attach to an application in order to debug it. If you
    start an application from within an IDE, this happens automatically, unless you
    request otherwise (by choosing “Start without debugging”). Sometimes, though,
    it’s inconvenient or impossible to start an application in debug mode within the
    IDE. An example is a Windows Service application or (ironically) a Visual Studio
    designer. One solution is to start the application normally and then, in your
    IDE, choose Debug Process. This doesn’t allow you to set breakpoints early in
    the program’s execution, however.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器必须先附加到一个应用程序才能进行调试。如果你从IDE内部启动应用程序，这将自动发生，除非你另有要求（选择“不带调试启动”）。但有时，在IDE内部以调试模式启动应用程序可能不方便或不可能。例如，Windows服务应用程序或（具有讽刺意味的是）Visual
    Studio设计器。一个解决方案是正常启动应用程序，然后在IDE中选择“调试进程”。但这样做不能让你在程序执行早期设置断点。
- en: The workaround is to call `Debugger.Break` from within your application. This
    method launches a debugger, attaches to it, and suspends execution at that point.
    (`Launch` does the same, but without suspending execution.) After it’s attached,
    you can log messages directly to the debugger’s output window with the `Log` method.
    You can verify whether you’re attached to a debugger by checking the `IsAttached`
    property.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方法是在应用程序内部调用`Debugger.Break`。这个方法会启动调试器，附加到它，并在那一点暂停执行（`Launch`做同样的事情，但不会暂停执行）。附加后，你可以使用`Log`方法直接向调试器的输出窗口记录消息。你可以通过检查`IsAttached`属性验证是否已连接到调试器。
- en: Debugger Attributes
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试器属性
- en: The `DebuggerStepThrough` and `DebuggerHidden` attributes provide suggestions
    to the debugger on how to handle single-stepping for a particular method, constructor,
    or class.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`DebuggerStepThrough`和`DebuggerHidden`属性为调试器提供了关于如何处理特定方法、构造函数或类的单步执行建议。'
- en: '`DebuggerStepThrough` requests that the debugger step through a function without
    any user interaction. This attribute is useful in automatically generated methods
    and in proxy methods that forward the real work to a method somewhere else. In
    the latter case, the debugger will still show the proxy method in the call stack
    if a breakpoint is set within the “real” method—unless you also add the `DebuggerHidden`
    attribute. You can combine these two attributes on proxies to help the user focus
    on debugging the application logic rather than the plumbing:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`DebuggerStepThrough` 请求调试器在没有任何用户交互的情况下步入函数。这个属性在自动生成的方法和代理方法中特别有用，后者将实际工作转发到其他位置的方法。在后一种情况下，如果在“真实”方法内设置了断点，调试器仍会显示代理方法在调用堆栈中，除非你还添加了`DebuggerHidden`属性。你可以在代理上结合这两个属性，帮助用户专注于调试应用逻辑而不是底层管理：'
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Processes and Process Threads
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程和进程线程
- en: We described in the last section of [Chapter 6](ch06.html#dotnet_fundamentals)
    how to use `Process.Start` to launch a new process. The `Process` class also allows
    you to query and interact with other processes running on the same or another
    computer. The `Process` class is part of .NET Standard 2.0, although its features
    are restricted for the UWP platform.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第6章](ch06.html#dotnet_fundamentals)的最后一节中描述了如何使用`Process.Start`启动新进程。`Process`类还允许你查询和与运行在同一台或另一台计算机上的其他进程进行交互。`Process`类是.NET
    Standard 2.0的一部分，尽管其功能对于UWP平台有所限制。
- en: Examining Running Processes
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查运行中的进程
- en: 'The `Process.GetProcess*XXX*` methods retrieve a specific process by name or
    process ID, or all processes running on the current or nominated computer. This
    includes both managed and unmanaged processes. Each `Process` instance has a wealth
    of properties mapping statistics such as name, ID, priority, memory and processor
    utilization, window handles, and so on. The following sample enumerates all the
    running processes on the current computer:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Process.GetProcess*XXX*` 方法通过名称或进程 ID 检索特定进程，或检索当前计算机或指定计算机上运行的所有进程。这包括托管和非托管进程。每个
    `Process` 实例具有丰富的属性，映射统计信息，如名称、ID、优先级、内存和处理器利用率、窗口句柄等。以下示例枚举了当前计算机上所有正在运行的进程：'
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`Process.GetCurrentProcess` returns the current process.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Process.GetCurrentProcess`返回当前进程。'
- en: You can terminate a process by calling its `Kill` method.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用其 `Kill` 方法终止进程。
- en: Examining Threads in a Process
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查进程中的线程
- en: 'You can also enumerate over the threads of other processes with the `Pro⁠cess​.Threads`
    property. The objects that you get, however, are not `System.Thread⁠ing​.Thread`
    objects; they’re `ProcessThread` objects and are intended for administrative rather
    than synchronization tasks. A `ProcessThread` object provides diagnostic information
    about the underlying thread and allows you to control some aspects of it, such
    as its priority and processor affinity:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用`Process.Threads`属性枚举其他进程的线程。但是，您获取的对象不是`System.Threading.Thread`对象；它们是`ProcessThread`对象，用于管理而不是同步任务。`ProcessThread`对象提供有关底层线程的诊断信息，并允许您控制一些方面，如其优先级和处理器亲和性：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: StackTrace and StackFrame
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: StackTrace 和 StackFrame
- en: The `StackTrace` and `StackFrame` classes provide a read-only view of an execution
    call stack. You can obtain stack traces for the current thread or an `Exception`
    object. Such information is useful mostly for diagnostic purposes, though you
    also can use it in programming (hacks). `StackTrace` represents a complete call
    stack; `StackFrame` represents a single method call within that stack.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackTrace` 和 `StackFrame` 类提供了执行调用堆栈的只读视图。您可以为当前线程或 `Exception` 对象获取堆栈跟踪信息。这些信息主要用于诊断目的，尽管您也可以在编程（黑客）中使用它。`StackTrace`
    表示完整的调用堆栈；`StackFrame` 表示该堆栈内的单个方法调用。'
- en: Note
  id: totrans-111
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you just need to know the name and line number of the calling method, caller
    info attributes can provide an easier and faster alternative. We cover this topic
    in [“Caller Info Attributes”](ch04.html#caller_info_attributes).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需知道调用方法的名称和行号，调用者信息属性可以提供更简单和更快的替代方法。我们在[“调用者信息属性”](ch04.html#caller_info_attributes)中讨论了这个话题。
- en: If you instantiate a `StackTrace` object with no arguments—or with a `bool`
    argument—you get a snapshot of the current thread’s call stack. The `bool` argument,
    if `true`, instructs `StackTrace` to read the assembly *.pdb* (project debug)
    files if they are present, giving you access to filename, line number, and column
    offset data. Project debug files are generated when you compile with the `/debug`
    switch. (Visual Studio compiles with this switch unless you request otherwise
    via *Advanced Build Settings*.)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用不带参数或带有`bool`参数的`StackTrace`对象进行实例化，您将获得当前线程调用堆栈的快照。如果`bool`参数为`true`，则`StackTrace`将读取程序集的
    *.pdb*（项目调试）文件（如果存在），从而使您能够访问文件名、行号和列偏移数据。在使用 `/debug` 开关进行编译时生成项目调试文件。（Visual
    Studio 默认使用此开关进行编译，除非您通过 *高级构建设置* 请求否定。）
- en: 'After you’ve obtained a `StackTrace`, you can examine a particular frame by
    calling `GetFrame`—or obtain the whole lot by using `GetFrames`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 获得`StackTrace`后，可以通过调用`GetFrame`来检查特定的帧，或者通过使用`GetFrames`获取整个堆栈：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here’s the output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The Intermediate Language (IL) offset indicates the offset of the instruction
    that will execute *next*—not the instruction that’s currently executing. Peculiarly,
    though, the line and column number (if a *.pdb* file is present) usually indicate
    the actual execution point.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 中间语言（IL）偏移量指示将执行*下一个*指令的偏移量 —— 而不是当前正在执行的指令。奇怪的是，如果存在 *.pdb* 文件，行和列号通常指示实际执行点。
- en: This happens because the CLR does its best to *infer* the actual execution point
    when calculating the line and column from the IL offset. The compiler emits IL
    in such a way as to make this possible—including inserting `nop` (no-operation)
    instructions into the IL stream.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 CLR 尽其所能推断出从 IL 偏移计算行和列的实际执行点。编译器以使这种可能成为可能的方式发出 IL —— 包括在 IL 流中插入 `nop`（无操作）指令。
- en: Compiling with optimizations enabled, however, disables the insertion of `nop`
    instructions, and so the stack trace might show the line and column number of
    the next statement to execute. Obtaining a useful stack trace is further hampered
    by the fact that optimization can pull other tricks, including collapsing entire
    methods.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用启用优化编译时，将禁用插入`nop`指令，因此堆栈跟踪可能显示下一条要执行的语句的行号和列号。获得有用的堆栈跟踪进一步受到优化可以引入的其他技巧的阻碍，包括折叠整个方法。
- en: 'A shortcut to obtaining the essential information for an entire `StackTrace`
    is to call `ToString` on it. Here’s what the result looks like:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 获取整个`StackTrace`的基本信息的快捷方式是对其调用`ToString`。以下是结果的样子：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can also obtain the stack trace for an `Exception` object (showing what
    led up to the exception being thrown) by passing the `Exception` into `StackTrace`’s
    constructor.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过将`Exception`对象传递给`StackTrace`的构造函数来获取异常对象（显示导致抛出异常的内容）的堆栈跟踪。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`Exception` already has a `StackTrace` property; however, this property returns
    a simple string—not a `StackTrace` object. A `StackTrace` object is far more useful
    in logging exceptions that occur after deployment—where no *.pdb* files are available—because
    you can log the *IL offset* in lieu of line and column numbers. With an IL offset
    and *ildasm*, you can pinpoint where within a method an error occurred.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Exception`已经有一个`StackTrace`属性；然而，该属性返回一个简单的字符串，而不是`StackTrace`对象。在没有*.pdb*文件可用的部署后发生异常时，IL偏移量比行号和列号更有用。使用IL偏移量和*ildasm*，您可以准确定位发生错误的方法内部位置。'
- en: Windows Event Logs
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows事件日志
- en: The Win32 platform provides a centralized logging mechanism, in the form of
    the Windows event logs.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Win32平台提供了一个集中的日志记录机制，以Windows事件日志的形式存在。
- en: The `Debug` and `Trace` classes we used earlier write to a Windows event log
    if you register an `EventLogTraceListener`. With the `EventLog` class, however,
    you can write directly to a Windows event log without using `Trace` or `Debug`.
    You can also use this class to read and monitor event data.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用的`Debug`和`Trace`类如果注册了`EventLogTraceListener`，则写入Windows事件日志。然而，使用`EventLog`类，您可以直接将数据写入Windows事件日志，而无需使用`Trace`或`Debug`。您还可以使用此类来读取和监视事件数据。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Writing to the Windows event log makes sense in a Windows Service application,
    because if something goes wrong, you can’t pop up a user interface directing the
    user to some special file where diagnostic information has been written. Also,
    because it’s common practice for services to write to the Windows event log, this
    is the first place an administrator is likely to look if your service falls over.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows服务应用程序中写入Windows事件日志是有意义的，因为如果发生问题，您无法弹出用户界面，将用户引导到某个特殊文件中，其中包含已写入的诊断信息。此外，由于服务通常写入Windows事件日志是一种常见做法，如果您的服务停止运行，管理员可能会首先查看此处。
- en: 'There are three standard Windows event logs, identified by these names:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个标准的Windows事件日志，它们分别由以下名称标识：
- en: Application
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序
- en: System
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统
- en: Security
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全
- en: The Application log is where most applications normally write.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序日志通常是大多数应用程序写入的地方。
- en: Writing to the Event Log
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写入事件日志
- en: 'To write to a Windows event log:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要写入Windows事件日志：
- en: Choose one of the three event logs (usually *Application*).
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择三个事件日志之一（通常是*应用程序*）。
- en: Decide on a *source name* and create it if necessary (create requires administrative
    permissions).
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 决定一个*源名称*，如果需要则创建（创建需要管理员权限）。
- en: Call `EventLog.WriteEntry` with the log name, source name, and message data.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用日志名称、源名称和消息数据调用`EventLog.WriteEntry`。
- en: 'The *source name* is an easily identifiable name for your application. You
    must register a source name before you use it—the `CreateEventSource` method performs
    this function. You can then call `WriteEntry`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*源名称*是您的应用程序的易于识别的名称。您必须在使用之前注册源名称——`CreateEventSource`方法执行此功能。然后可以调用`WriteEntry`：'
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`EventLogEntryType` can be `Information`, `Warning`, `Error`, `SuccessAudit`,
    or `FailureAudit`. Each displays with a different icon in the Windows event viewer.
    You can also optionally specify a category and event ID (each is a number of your
    own choosing) and provide optional binary data.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventLogEntryType`可以是`Information`、`Warning`、`Error`、`SuccessAudit`或`FailureAudit`。每种类型在Windows事件查看器中显示不同的图标。您还可以选择性地指定类别和事件ID（每个都是您自己选择的数字），并提供可选的二进制数据。'
- en: '`CreateEventSource` also allows you to specify a machine name: this is to write
    to another computer’s event log, if you have sufficient permissions.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateEventSource`还允许您指定计算机名称：这是为了将日志写入另一台计算机的事件日志（如果您具有足够的权限）。'
- en: Reading the Event Log
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取事件日志
- en: 'To read an event log, instantiate the `EventLog` class with the name of the
    log that you want to access and optionally the name of another computer on which
    the log resides. Each log entry can then be read via the `Entries` collection
    property:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取事件日志，请使用要访问的日志名称和（可选）日志所在计算机的名称实例化`EventLog`类。然后可以通过`Entries`集合属性读取每个日志条目：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can enumerate over all logs for the current (or another) computer via the
    static method `EventLog.GetEventLogs` (this requires administrative privileges
    for full access):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过静态方法`EventLog.GetEventLogs`（这需要管理员权限以获取完全访问权限）枚举当前（或另一个）计算机的所有日志：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This normally prints, at a minimum, *Application*, *Security*, and *System*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常至少打印*应用程序*、*安全性*和*系统*。
- en: Monitoring the Event Log
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监视事件日志
- en: You can be alerted whenever an entry is written to a Windows event log, via
    the `EntryWritten` event. This works for event logs on the local computer, and
    it fires regardless of what application logged the event.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过`EntryWritten`事件在Windows事件日志中写入条目时得到提醒。这适用于本地计算机上的事件日志，并且不管哪个应用程序记录了事件，都会触发此事件。
- en: 'To enable log monitoring:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用日志监视：
- en: Instantiate an `EventLog` and set its `EnableRaisingEvents` property to `true`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个`EventLog`并将其`EnableRaisingEvents`属性设置为`true`。
- en: Handle the `EntryWritten` event.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理`EntryWritten`事件。
- en: 'For example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Performance Counters
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能计数器
- en: Note
  id: totrans-160
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Performance Counters are a Windows-only feature and require the NuGet package
    `System.Diagnostics​.Per⁠formance​Counter`. If you’re targeting Linux or macOS,
    see [“Cross-Platform Diagnostic Tools”](#cross_platform_diagnostics_tools) for
    alternatives.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 性能计数器是仅适用于Windows的功能，需要NuGet包`System.Diagnostics​.PerformanceCounter`。如果您的目标是Linux或macOS，请参阅[“跨平台诊断工具”](#cross_platform_diagnostics_tools)以获取替代方案。
- en: The logging mechanisms we’ve discussed to date are useful for capturing information
    for future analysis. However, to gain insight into the current state of an application
    (or the system as a whole), a more real-time approach is needed. The Win32 solution
    to this need is the performance-monitoring infrastructure, which consists of a
    set of performance counters that the system and applications expose, and the Microsoft
    Management Console (MMC) snap-ins used to monitor these counters in real time.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今讨论的日志记录机制对于捕获未来分析的信息很有用。但是，要深入了解应用程序（或整个系统）的当前状态，需要一种更实时的方法。Win32解决这种需求的方案是性能监控基础设施，它由系统和应用程序公开的一组性能计数器以及用于实时监控这些计数器的Microsoft
    Management Console（MMC）插件组成。
- en: Performance counters are grouped into categories such as “System,” “Processor,”
    “.NET CLR Memory,” and so on. These categories are sometimes also referred to
    as “performance objects” by the graphical user interface (GUI) tools. Each category
    groups a related set of performance counters that monitor one aspect of the system
    or application. Examples of performance counters in the “.NET CLR Memory” category
    include “% Time in GC,” “# Bytes in All Heaps,” and “Allocated bytes/sec.”
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 性能计数器分为类别，如“系统”、“处理器”、“.NET CLR内存”等。这些类别有时也被图形用户界面（GUI）工具称为“性能对象”。每个类别分组了一组相关的性能计数器，用于监视系统或应用程序的一个方面。在“.NET
    CLR内存”类别中，性能计数器的示例包括“%GC时间”、“所有堆中的字节数”和“每秒分配的字节数”。
- en: Each category can optionally have one or more instances that can be monitored
    independently. For example, this is useful in the “% Processor Time” performance
    counter in the “Processor” category, which allows one to monitor CPU utilization.
    On a multiprocessor machine, this counter supports an instance for each CPU, allowing
    you to monitor the utilization of each CPU independently.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类别可以选择性地具有一个或多个可以独立监视的实例。例如，在“处理器”类别的“%处理器时间”性能计数器中，这在监视CPU利用率时非常有用。在多处理器计算机上，此计数器支持每个CPU的实例，允许您独立监视每个CPU的利用率。
- en: The following sections illustrate how to perform commonly needed tasks such
    as determining which counters are exposed, monitoring a counter, and creating
    your own counters to expose application status information.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节说明了如何执行常见的任务，例如确定公开的计数器、监视计数器以及创建自己的计数器以公开应用程序状态信息。
- en: Note
  id: totrans-166
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Reading performance counters or categories might require administrator privileges
    on the local or target computer, depending on what is accessed.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 读取性能计数器或类别可能需要在本地或目标计算机上具有管理员权限，这取决于所访问的内容。
- en: Enumerating the Available Counters
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举可用计数器
- en: 'The following example enumerates over all of the available performance counters
    on the computer. For those that have instances, it enumerates the counters for
    each instance:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例枚举计算机上所有可用的性能计数器。对于具有实例的计数器，它枚举每个实例的计数器：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-171
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The result is more than 10,000 lines long! It also takes a while to execute
    because `PerformanceCounter​Cate⁠gory.Instance​Exists` has an inefficient implementation.
    In a real system, you’d want to retrieve the more detailed information only on
    demand.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 结果超过 10,000 行长！执行起来也需要一些时间，因为 `PerformanceCounter​Cate⁠gory.Instance​Exists`
    的实现效率低下。在实际系统中，您希望仅在需要时检索更详细的信息。
- en: 'The next example uses LINQ to retrieve just .NET performance counters, writing
    the result to an XML file:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例使用 LINQ 仅检索 .NET 性能计数器，并将结果写入 XML 文件：
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Reading Performance Counter Data
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取性能计数器数据
- en: To retrieve the value of a performance counter, instantiate a `PerformanceCounter`
    object and then call the `NextValue` or `NextSample` method. `NextValue` returns
    a simple `float` value; `NextSample` returns a `CounterSample` object that exposes
    a more advanced set of properties, such as `CounterFrequency`, `TimeStamp`, `BaseValue`,
    and `RawValue`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索性能计数器的值，请实例化 `PerformanceCounter` 对象，然后调用 `NextValue` 或 `NextSample` 方法。`NextValue`
    返回一个简单的 `float` 值；`NextSample` 返回一个 `CounterSample` 对象，该对象公开了一组更高级的属性，如 `CounterFrequency`、`TimeStamp`、`BaseValue`
    和 `RawValue`。
- en: '`PerformanceCounter`’s constructor takes a category name, counter name, and
    optional instance. So, to display the current processor utilization for all CPUs,
    you would do the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`PerformanceCounter` 的构造函数接受类别名称、计数器名称和可选的实例。因此，要显示所有 CPU 的当前处理器利用率，您可以执行以下操作：'
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Or to display the “real” (i.e., private) memory consumption of the current
    process:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 或者显示当前进程的“真实”（即私有）内存消耗：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`PerformanceCounter` doesn’t expose a `ValueChanged` event, so if you want
    to monitor for changes, you must poll. In the next example, we poll every 200
    ms—until signaled to quit by an `EventWaitHandle`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`PerformanceCounter` 没有公开 `ValueChanged` 事件，因此如果要监视更改，必须进行轮询。在下一个示例中，我们每 200
    毫秒轮询一次，直到通过 `EventWaitHandle` 发出退出信号：'
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here’s how we can use this method to simultaneously monitor processor and hard-drive
    activity:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法同时监视处理器和硬盘活动：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Creating Counters and Writing Performance Data
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建计数器和写入性能数据
- en: 'Before writing performance counter data, you need to create a performance category
    and counter. You must create the performance category along with all the counters
    that belong to it in one step, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在写入性能计数器数据之前，需要创建性能类别和计数器。您必须在一步中创建性能类别以及属于它的所有计数器，如下所示：
- en: '[PRE35]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The new counters then show up in the Windows performance-monitoring tool when
    you choose Add Counters. If you later want to define more counters in the same
    category, you must first delete the old category by calling `Performance​Coun⁠terCategory.Delete`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当您选择添加计数器时，新的计数器将显示在 Windows 性能监视工具中。如果稍后要在同一类别中定义更多计数器，则必须首先调用 `Performance​Coun⁠terCategory.Delete`
    删除旧类别。
- en: Note
  id: totrans-189
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Creating and deleting performance counters requires administrative privileges.
    For this reason, it’s usually done as part of the application setup.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和删除性能计数器需要管理员权限。因此，通常作为应用程序设置的一部分来完成。
- en: 'After you create a counter, you can update its value by instantiating a `PerformanceCounter`,
    setting `ReadOnly` to `false`, and setting `RawValue`. You can also use the `Increment`
    and `IncrementBy` methods to update the existing value:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 创建计数器后，可以通过实例化 `PerformanceCounter`，将 `ReadOnly` 设置为 `false`，并设置 `RawValue`
    来更新其值。您还可以使用 `Increment` 和 `IncrementBy` 方法来更新现有值：
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The Stopwatch Class
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Stopwatch 类
- en: The `Stopwatch` class provides a convenient mechanism for measuring execution
    times. `Stopwatch` uses the highest-resolution mechanism that the OS and hardware
    provide, which is typically less than a microsecond. (In contrast, `DateTime.Now`
    and `Environment.TickCount` have a resolution of about 15 ms.)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stopwatch` 类提供了一个方便的机制来测量执行时间。`Stopwatch` 使用操作系统和硬件提供的最高分辨率机制，通常小于一微秒。（相比之下，`DateTime.Now`
    和 `Environment.TickCount` 的分辨率约为 15 毫秒。）'
- en: 'To use `Stopwatch`, call `StartNew`—this instantiates a `Stopwatch` and starts
    it ticking. (Alternatively, you can instantiate it manually and then call `Start`.)
    The `Elapsed` property returns the elapsed interval as a `TimeSpan`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `Stopwatch`，调用 `StartNew` —— 这将实例化一个 `Stopwatch` 并启动它开始计时。（或者，您可以手动实例化然后调用
    `Start`。）`Elapsed` 属性以 `TimeSpan` 形式返回经过的时间间隔：
- en: '[PRE37]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`Stopwatch` also exposes an `ElapsedTicks` property, which returns the number
    of elapsed “ticks” as a `long`. To convert from ticks to seconds, divide by `StopWatch​.Fre⁠quency`.
    There’s also an `ElapsedMilliseconds` property, which is often the most convenient.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stopwatch` 还公开了`ElapsedTicks`属性，它以`long`返回经过的“ticks”数。要从ticks转换为秒，请除以 `StopWatch​.Fre⁠quency`。还有一个`ElapsedMilliseconds`属性，通常是最方便的。'
- en: Calling `Stop` freezes `Elapsed` and `ElapsedTicks`. There’s no background activity
    incurred by a “running” `Stopwatch`, so calling `Stop` is optional.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`Stop`会冻结`Elapsed`和`ElapsedTicks`。不会有由“运行中”的`Stopwatch`引起的后台活动，因此调用`Stop`是可选的。
- en: Cross-Platform Diagnostic Tools
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨平台诊断工具
- en: 'In this section, we briefly describe the cross-platform diagnostic tools available
    to .NET:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们简要介绍了.NET可用的跨平台诊断工具：
- en: dotnet-counters
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: dotnet-counters
- en: Provides an overview of the state of a running application
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 提供运行应用程序状态的概述
- en: dotnet-trace
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: dotnet-trace
- en: For more detailed performance and event monitoring
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 获取更详细的性能和事件监视信息
- en: dotnet-dump
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: dotnet-dump
- en: To obtain a memory dump on demand or after a crash
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要在需求或崩溃后获取内存转储
- en: These tools do not require administrative elevation and are suitable for both
    development and production environments.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具不需要管理员权限，并且适用于开发和生产环境。
- en: dotnet-counters
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: dotnet-counters
- en: The *dotnet-counters* tool monitors the memory and CPU usage of a .NET process
    and writes the data to the console (or a file).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*dotnet-counters*工具监视.NET进程的内存和CPU使用情况，并将数据写入控制台（或文件）。'
- en: 'To install the tool, run the following from a command prompt or terminal with
    *dotnet* in the path:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装工具，请从命令提示符或带有*dotnet*路径的终端运行以下命令：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can then start monitoring a process, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按以下方式开始监视进程：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`System.Runtime` means that we want to monitor all counters under the *System.Runtime*
    category. You can specify either a category or counter name (the `dotnet-counters
    list` command lists all available categories and counters).'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Runtime` 表示我们要监视*System.Runtime*类别下的所有计数器。您可以指定类别或计数器名称（`dotnet-counters
    list`命令列出所有可用的类别和计数器）。'
- en: 'The output is continually refreshed and looks like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将持续刷新并类似于以下内容：
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here are all available commands:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是所有可用的命令：
- en: '| Commands | Purpose |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 目的 |'
- en: '| --- | --- |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `list` | Displays a list of counter names along with a description of each
    |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `list` | 显示计数器名称及其描述的列表 |'
- en: '| `ps` | Displays a list of dotnet processes eligible for monitoring |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `ps` | 显示符合监视条件的dotnet进程列表 |'
- en: '| `monitor` | Displays values of selected counters (periodically refreshed)
    |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `monitor` | 显示所选计数器的值（定期刷新） |'
- en: '| `collect` | Saves counter information to a file |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `collect` | 将计数器信息保存到文件 |'
- en: 'The following parameters are supported:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 支持以下参数：
- en: '| Options/arguments | Purpose |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 选项/参数 | 目的 |'
- en: '| --- | --- |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `--version` | Displays the version of *dotnet-counters*. |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `--version` | 显示*dotnet-counters*的版本。 |'
- en: '| `-h, --help` | Displays help about the program. |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `-h, --help` | 显示程序的帮助信息。 |'
- en: '| `-p, --process-id` | ID of dotnet process to monitor. Applies to the `monitor`
    and `collect` commands. |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `-p, --process-id` | 要监视的dotnet进程的ID。适用于`monitor`和`collect`命令。 |'
- en: '| `--refresh-interval` | Sets the desired refresh interval in seconds. Applies
    to the `monitor` and `collect` commands. |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `--refresh-interval` | 设置所需的刷新间隔（以秒为单位）。适用于`monitor`和`collect`命令。 |'
- en: '| `-o, --output` | Sets the output file name. Applies to the `collect` command.
    |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `-o, --output` | 设置输出文件名。适用于`collect`命令。 |'
- en: '| `--format` | Sets the output format. Valid are *csv* or *json*. Applies to
    the `collect` command. |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `--format` | 设置输出格式。有效的格式为*csv*或*json*。适用于`collect`命令。 |'
- en: dotnet-trace
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: dotnet-trace
- en: Traces are timestamped records of events in your program, such as a method being
    called or a database being queried. Traces can also include performance metrics
    and custom events, and can contain local context such as the value of local variables.
    Traditionally, .NET Framework and frameworks such as ASP.NET used ETW. In .NET
    5, application traces are written to ETW when running on Windows and LTTng on
    Linux.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪是程序中事件的时间戳记录，例如调用方法或查询数据库。跟踪还可以包括性能指标和自定义事件，并可以包含局部上下文，例如局部变量的值。传统上，.NET Framework和诸如ASP.NET之类的框架使用ETW。在.NET
    5中，应用程序跟踪在Windows上运行时写入ETW，在Linux上运行时写入LTTng。
- en: 'To install the tool, run the following command:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装工具，请执行以下命令：
- en: '[PRE41]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To start recording a program’s events, run the following command:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始记录程序的事件，请运行以下命令：
- en: '[PRE42]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This runs *dotnet-trace* with the default profile, which collects CPU and .NET
    runtime events and writes to a file called *trace.nettrace*. You can specify other
    profiles with the `--profile` switch: *gc-verbose* tracks garbage collection and
    sampled object allocation, and *gc-collect* tracks garbage collection with a low
    overhead. The `-o` switch lets you specify a different output filename.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这会使用默认配置文件运行*dotnet-trace*，该配置文件收集 CPU 和 .NET 运行时事件，并写入名为*trace.nettrace*的文件。您可以使用`--profile`开关指定其他配置文件：*gc-verbose*
    跟踪垃圾回收和抽样对象分配，*gc-collect* 以低开销跟踪垃圾回收。`-o`开关允许您指定不同的输出文件名。
- en: The default output is a *.netperf* file, which can be analyzed directly on a
    Windows machine with the PerfView tool. Alternatively, you can instruct *dotnet-trace*
    to create a file compatible with Speedscope, which is a free online analysis service
    at [*https://speedscope.app*](https://speedscope.app). To create a Speedscope
    (*.speedscope.json*) file, use the option `--format speedscope`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 默认输出为*.netperf*文件，可以直接在 Windows 机器上使用 PerfView 工具分析。或者，您可以指示*dotnet-trace*创建与
    Speedscope 兼容的文件，Speedscope 是一个免费的在线分析服务，位于[*https://speedscope.app*](https://speedscope.app)。要创建
    Speedscope（*.speedscope.json*）文件，请使用选项`--format speedscope`。
- en: Note
  id: totrans-241
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注：
- en: You can download the latest version of PerfView from [*https://github.com/microsoft/perfview*](https://github.com/microsoft/perfview).
    The version that ships with Windows 10 might not support *.netperf* files.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[*https://github.com/microsoft/perfview*](https://github.com/microsoft/perfview)下载
    PerfView 的最新版本。随 Windows 10 发货的版本可能不支持*.netperf*文件。
- en: 'The following commands are supported:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 支持以下命令：
- en: '| Commands | Purpose |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| Commands | Purpose |'
- en: '| --- | --- |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `collect` | Starts recording counter information to a file. |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `collect` | 开始将计数器信息记录到文件中。 |'
- en: '| `ps` | Displays a list of dotnet processes eligible for monitoring. |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `ps` | 显示可供监视的 dotnet 进程列表。 |'
- en: '| `list-profiles` | Lists prebuilt tracing profiles with a description of providers
    and filters in each. |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `list-profiles` | 列出具有每个提供程序和过滤器描述的预构建跟踪配置文件。 |'
- en: '| `convert <file>` | Converts from the *nettrace* (*.netperf*) format to an
    alternative format. Currently, *speedscope* is the only target option. |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `convert <file>` | 将*nettrace*（*.netperf*）格式转换为另一种格式。当前唯一的目标选项是*speedscope*。
    |'
- en: Custom trace events
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义跟踪事件
- en: 'Your app can emit custom events by defining a custom `EventSource`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序可以通过定义自定义`EventSource`来发出自定义事件：
- en: '[PRE43]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `WriteEvent` method is overloaded to accept various combinations of simple
    types (primarily strings and integers). You can then call it as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriteEvent` 方法被重载以接受各种简单类型的组合（主要是字符串和整数）。然后，您可以按以下方式调用它：'
- en: '[PRE44]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When calling *dotnet-trace*, you must specify the name(s) of any custom event
    sources that want to record:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 调用*dotnet-trace*时，必须指定要记录的任何自定义事件源的名称：
- en: '[PRE45]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: dotnet-dump
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: dotnet-dump
- en: A *dump*, sometimes called a *core dump*, is a snapshot of the state of a process’s
    virtual memory. You can dump a running process on demand, or configure the OS
    to generate a dump when an application crashes.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*Dump*，有时称为*核心转储*，是进程虚拟内存状态的快照。您可以按需转储正在运行的进程，或者配置操作系统在应用程序崩溃时生成转储。'
- en: 'On Ubuntu Linux, the following command enables a core dump upon application
    crash (the necessary steps can vary between different flavors of Linux):'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu Linux 上，以下命令在应用程序崩溃时启用核心转储（不同 Linux 版本间的必要步骤可能有所不同）：
- en: '[PRE46]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'On Windows, use *regedit.exe* to create or edit the following key in the local
    machine hive:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，使用*regedit.exe*在本地计算机 hive 中创建或编辑以下键：
- en: '[PRE47]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Under that, add a key with the same name as your executable (e.g., *foo.exe*),
    and under that key, add the following keys:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之下，添加与您的可执行文件相同的键（例如*foo.exe*），并在该键下添加以下键：
- en: '`DumpFolder` (REG_EXPAND_SZ), with a value indicating the path to which you
    want dump files written'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DumpFolder`（REG_EXPAND_SZ），其值指示要写入转储文件的路径'
- en: '`DumpType` (REG_DWORD), with a value of 2 to request a full dump'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DumpType`（REG_DWORD），其值为2，以请求完整转储'
- en: (Optionally) `DumpCount` (REG_DWORD), indicating the maximum number of dump
    files before the oldest is removed
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （可选）`DumpCount`（REG_DWORD），指示在删除最老的转储文件之前的最大转储文件数
- en: 'To install the tool, run the following command:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装该工具，请运行以下命令：
- en: '[PRE48]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'After you’ve installed it, you can initiate a dump on demand (without ending
    the process), as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完后，您可以按需进行转储（而无需结束进程），如下所示：
- en: '[PRE49]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following command starts an interactive shell for analyzing a dump file:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令启动用于分析转储文件的交互式 shell：
- en: '[PRE50]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If an exception took down the application, you can use the *printexceptions*
    command (*pe* for short) to display details of that exception. The dotnet-dump
    shell supports numerous additional commands, which you can list with the *help*
    command.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果异常导致应用程序崩溃，你可以使用*printexceptions*命令（简写为*pe*）来显示异常的详细信息。dotnet-dump shell支持多个额外的命令，你可以使用*help*命令列出这些命令。
