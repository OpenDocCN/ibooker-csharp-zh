["```cs\n[TestMethod]\npublic async Task MyMethodAsync_ReturnsFalse()\n{\n  var objectUnderTest = ...;\n  bool result = await objectUnderTest.MyMethodAsync();\n  Assert.IsFalse(result);\n}\n```", "```cs\n[TestMethod]\npublic void MyMethodAsync_ReturnsFalse()\n{\n  AsyncContext.Run(async () =>\n  {\n    var objectUnderTest = ...;\n    bool result = await objectUnderTest.MyMethodAsync();\n    Assert.IsFalse(result);\n  });\n}\n```", "```cs\ninterface IMyInterface\n{\n  Task<int> SomethingAsync();\n}\n\nclass SynchronousSuccess : IMyInterface\n{\n  public Task<int> SomethingAsync()\n  {\n    return Task.FromResult(13);\n  }\n}\n\nclass SynchronousError : IMyInterface\n{\n  public Task<int> SomethingAsync()\n  {\n    return Task.FromException<int>(new InvalidOperationException());\n  }\n}\n\nclass AsynchronousSuccess : IMyInterface\n{\n  public async Task<int> SomethingAsync()\n  {\n    await Task.Yield(); // Force asynchronous behavior.\n    return 13;\n  }\n}\n```", "```cs\n// Not a recommended solution; see below.\n[TestMethod]\n[ExpectedException(typeof(DivideByZeroException))]\npublic async Task Divide_WhenDenominatorIsZero_ThrowsDivideByZero()\n{\n  await MyClass.DivideAsync(4, 0);\n}\n```", "```cs\n[Fact]\npublic async Task Divide_WhenDenominatorIsZero_ThrowsDivideByZero()\n{\n  await Assert.ThrowsAsync<DivideByZeroException>(async () =>\n  {\n    await MyClass.DivideAsync(4, 0);\n  });\n}\n```", "```cs\n/// <summary>\n/// Ensures that an asynchronous delegate throws an exception.\n/// </summary>\n/// <typeparam name=\"TException\">\n/// The type of exception to expect.\n/// </typeparam>\n/// <param name=\"action\">The asynchronous delegate to test.</param>\n/// <param name=\"allowDerivedTypes\">\n/// Whether derived types should be accepted.\n/// </param>\npublic static async Task<TException> ThrowsAsync<TException>(Func<Task> action,\n    bool allowDerivedTypes = true)\n    where TException : Exception\n{\n  try\n  {\n    await action();\n    var name = typeof(Exception).Name;\n    Assert.Fail($\"Delegate did not throw expected exception {name}.\");\n    return null;\n  }\n  catch (Exception ex)\n  {\n    if (allowDerivedTypes && !(ex is TException))\n      Assert.Fail($\"Delegate threw exception of type {ex.GetType().Name}\" +\n          $\", but {typeof(TException).Name} or a derived type was expected.\");\n    if (!allowDerivedTypes && ex.GetType() != typeof(TException))\n      Assert.Fail($\"Delegate threw exception of type {ex.GetType().Name}\" +\n          $\", but {typeof(TException).Name} was expected.\");\n    return (TException)ex;\n  }\n}\n```", "```cs\n// Not a recommended solution; see the rest of this section.\n[TestMethod]\npublic void MyMethodAsync_DoesNotThrow()\n{\n  AsyncContext.Run(() =>\n  {\n    var objectUnderTest = new Sut(); // ...;\n    objectUnderTest.MyVoidMethodAsync();\n  });\n}\n```", "```cs\n[TestMethod]\npublic async Task MyCustomBlock_AddsOneToDataItems()\n{\n  var myCustomBlock = CreateMyCustomBlock();\n\n  myCustomBlock.Post(3);\n  myCustomBlock.Post(13);\n  myCustomBlock.Complete();\n\n  Assert.AreEqual(4, myCustomBlock.Receive());\n  Assert.AreEqual(14, myCustomBlock.Receive());\n  await myCustomBlock.Completion;\n}\n```", "```cs\n[TestMethod]\npublic async Task MyCustomBlock_Fault_DiscardsDataAndFaults()\n{\n  var myCustomBlock = CreateMyCustomBlock();\n\n  myCustomBlock.Post(3);\n  myCustomBlock.Post(13);\n  (myCustomBlock as IDataflowBlock).Fault(new InvalidOperationException());\n\n  try\n  {\n    await myCustomBlock.Completion;\n  }\n  catch (AggregateException ex)\n  {\n    AssertExceptionIs<InvalidOperationException>(\n        ex.Flatten().InnerException, false);\n  }\n}\n\npublic static void AssertExceptionIs<TException>(Exception ex,\n    bool allowDerivedTypes = true)\n{\n  if (allowDerivedTypes && !(ex is TException))\n    Assert.Fail($\"Exception is of type {ex.GetType().Name}, but \" +\n        $\"{typeof(TException).Name} or a derived type was expected.\");\n  if (!allowDerivedTypes && ex.GetType() != typeof(TException))\n    Assert.Fail($\"Exception is of type {ex.GetType().Name}, but \" +\n        $\"{typeof(TException).Name} was expected.\");\n}\n```", "```cs\npublic interface IHttpService\n{\n  IObservable<string> GetString(string url);\n}\n\npublic class MyTimeoutClass\n{\n  private readonly IHttpService _httpService;\n\n  public MyTimeoutClass(IHttpService httpService)\n  {\n    _httpService = httpService;\n  }\n\n  public IObservable<string> GetStringWithTimeout(string url)\n  {\n    return _httpService.GetString(url)\n        .Timeout(TimeSpan.FromSeconds(1));\n  }\n}\n```", "```cs\nclass SuccessHttpServiceStub : IHttpService\n{\n  public IObservable<string> GetString(string url)\n  {\n    return Observable.Return(\"stub\");\n  }\n}\n\n[TestMethod]\npublic async Task MyTimeoutClass_SuccessfulGet_ReturnsResult()\n{\n  var stub = new SuccessHttpServiceStub();\n  var my = new MyTimeoutClass(stub);\n\n  var result = await my.GetStringWithTimeout(\"http://www.example.com/\")\n      .SingleAsync();\n\n  Assert.AreEqual(\"stub\", result);\n}\n```", "```cs\nprivate class FailureHttpServiceStub : IHttpService\n{\n  public IObservable<string> GetString(string url)\n  {\n    return Observable.Throw<string>(new HttpRequestException());\n  }\n}\n\n[TestMethod]\npublic async Task MyTimeoutClass_FailedGet_PropagatesFailure()\n{\n  var stub = new FailureHttpServiceStub();\n  var my = new MyTimeoutClass(stub);\n\n  await ThrowsAsync<HttpRequestException>(async () =>\n  {\n    await my.GetStringWithTimeout(\"http://www.example.com/\")\n        .SingleAsync();\n  });\n}\n```", "```cs\npublic interface IHttpService\n{\n  IObservable<string> GetString(string url);\n}\n\npublic class MyTimeoutClass\n{\n  private readonly IHttpService _httpService;\n\n  public MyTimeoutClass(IHttpService httpService)\n  {\n    _httpService = httpService;\n  }\n\n  public IObservable<string> GetStringWithTimeout(string url,\n      IScheduler scheduler = null)\n  {\n    return _httpService.GetString(url)\n        .Timeout(TimeSpan.FromSeconds(1), scheduler ?? Scheduler.Default);\n  }\n}\n```", "```cs\nprivate class SuccessHttpServiceStub : IHttpService\n{\n  public IScheduler Scheduler { get; set; }\n  public TimeSpan Delay { get; set; }\n\n  public IObservable<string> GetString(string url)\n  {\n    return Observable.Return(\"stub\")\n        .Delay(Delay, Scheduler);\n  }\n}\n```", "```cs\n[TestMethod]\npublic void MyTimeoutClass_SuccessfulGetShortDelay_ReturnsResult()\n{\n  var scheduler = new TestScheduler();\n  var stub = new SuccessHttpServiceStub\n  {\n    Scheduler = scheduler,\n    Delay = TimeSpan.FromSeconds(0.5),\n  };\n  var my = new MyTimeoutClass(stub);\n  string result = null;\n\n  my.GetStringWithTimeout(\"http://www.example.com/\", scheduler)\n      .Subscribe(r => { result = r; });\n\n  scheduler.Start();\n\n  Assert.AreEqual(\"stub\", result);\n}\n```", "```cs\n[TestMethod]\npublic void MyTimeoutClass_SuccessfulGetLongDelay_ThrowsTimeoutException()\n{\n  var scheduler = new TestScheduler();\n  var stub = new SuccessHttpServiceStub\n  {\n    Scheduler = scheduler,\n    Delay = TimeSpan.FromSeconds(1.5),\n  };\n  var my = new MyTimeoutClass(stub);\n  Exception result = null;\n\n  my.GetStringWithTimeout(\"http://www.example.com/\", scheduler)\n      .Subscribe(_ => Assert.Fail(\"Received value\"), ex => { result = ex; });\n\n  scheduler.Start();\n\n  Assert.IsInstanceOfType(result, typeof(TimeoutException));\n}\n```"]