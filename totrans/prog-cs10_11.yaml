- en: Chapter 11\. Reactive Extensions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '-   第11章\. 反应式扩展'
- en: The Reactive Extensions for .NET (usually shortened to *Rx*) are designed for
    working with asynchronous and event-based sources of information. Rx provides
    services that help you orchestrate and synchronize the way your code reacts to
    data from these kinds of sources. We already saw how to define and subscribe to
    events in [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events), but Rx offers much
    more than these basic features. It provides an abstraction for event sources that
    has a steeper learning curve than events, but it comes with a powerful set of
    operators that makes it far easier to combine and manage multiple streams of events
    than is possible with the free-for-all that delegates and .NET events provide.
    Microsoft has also made an associated set of libraries called Reaqtor available
    that builds on the foundation of Rx to provide a framework for reliable, stateful,
    distributed, scalable, high-performance event processing in services.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[.NET 反应式扩展](https://wiki.example.org/rx)（通常简称为*Rx*）专为处理异步和基于事件的信息源而设计。Rx 提供了帮助您编排和同步代码对这些类型数据反应的服务。我们已经看到如何在
    [第9章](ch09.xhtml#ch_delegates_lambdas_events) 中定义和订阅事件，但 Rx 提供的远不止这些基本功能。它提供了一个比事件更陡峭的事件源抽象，但却配备了一组强大的操作符，使得组合和管理多个事件流比使用委托和
    .NET 事件提供的自由组合更加容易。微软还推出了一个名为 Reaqtor 的相关库，它基于 Rx 的基础提供了一个可靠、有状态、分布式、可扩展、高性能的事件处理服务框架。'
- en: Rx’s fundamental abstraction, `IObservable<T>`, represents a sequence of items,
    and its operators are defined as extension methods for this interface. This might
    sound a lot like LINQ to Objects, and there are similarities—not only does `IObservable<T>`
    have a lot in common with `IEnumerable<T>`, but Rx also supports almost all of
    the standard LINQ operators. If you are familiar with LINQ to Objects, you will
    also feel at home with Rx. The difference is that in Rx, sequences are less passive.
    Unlike `IEnumerable<T>`, Rx sources do not wait to be asked for their items, nor
    can the consumer of an Rx source demand to be given the next item. Instead, Rx
    uses a *push* model in which the source notifies its recipients when items are
    available.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Rx 的基本抽象是 `IObservable<T>`，它表示一个项的序列，其操作符定义为此接口的扩展方法。这听起来很像 LINQ to Objects，它们确实有相似之处
    —— 不仅 `IObservable<T>` 与 `IEnumerable<T>` 有很多共同之处，而且 Rx 也支持几乎所有标准的 LINQ 操作符。如果您熟悉
    LINQ to Objects，那么您在 Rx 中也会感到如鱼得水。区别在于，在 Rx 中，序列不那么被动。与 `IEnumerable<T>` 不同，Rx
    源不等待请求其项，消费者也不能要求提供下一个项。相反，Rx 使用一种*推送*模型，在此模型中，源在项可用时通知其接收者。
- en: For example, if you’re writing an application that deals with live financial
    information, such as stock market price data, `IObservable<T>` is a much more
    natural model than `IEnumerable<T>`. Because Rx implements standard LINQ operators,
    you can write queries against a live source—you could narrow down the stream of
    events with a `where` clause or group them by stock symbol. Rx goes beyond standard
    LINQ, adding its own operators that take into account the temporal nature of a
    live event source. For example, you could write a query that provides data only
    for stocks that are changing price more frequently than some minimum rate.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，如果您正在编写一个处理实时金融信息（例如股市价格数据）的应用程序，`IObservable<T>` 模型比 `IEnumerable<T>`
    更为自然。因为 Rx 实现了标准的 LINQ 操作符，您可以对实时数据源编写查询 —— 您可以通过 `where` 子句筛选事件流，或者按股票代码分组。Rx
    不仅限于标准的 LINQ，它还添加了自己的操作符，考虑了实时事件源的时间性质。例如，您可以编写一个查询，仅提供更频繁变动价格的股票数据。
- en: Rx’s push-oriented approach makes it a better match than `IEnumerable<T>` for
    event-like sources. But why not just use events, or even plain delegates? Rx addresses
    four shortcomings of those alternatives. First, it defines a standard way for
    sources to report errors. Second, it is able to deliver items in a well-defined
    order, even in multithreaded scenarios involving numerous sources. Third, Rx provides
    a clear way to signal when there are no more items. Fourth, because a traditional
    event is represented by a special kind of member, not a normal object, there are
    significant limits on what you can do with an event—you can’t pass a .NET event
    as an argument to a method, store it in a field, or offer it in a property. You
    can do these things with a delegate, but that’s not the same thing—delegates can
    handle events but cannot represent a source of them. There’s no way to write a
    method that subscribes to some .NET event that you pass as an argument, because
    you can’t pass the actual event itself. Rx fixes this by representing event sources
    as objects, instead of a special distinctive element of the type system that doesn’t
    work like anything else.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Rx的推送式方法使其比`IEnumerable<T>`更适合类似事件的源。但为什么不直接使用事件，甚至普通的委托呢？Rx解决了这些替代方案的四个缺点。首先，它定义了源报告错误的标准方式。其次，在涉及多个源的多线程场景中，它能够以明确定义的顺序传递项。第三，Rx提供了清晰的方法来信号化没有更多项的时候。第四，因为传统事件是特殊类型的成员，而不是正常的对象，所以对于事件的使用有显著的限制——你不能将.NET事件作为参数传递给方法，存储在字段中或在属性中提供。你可以使用委托来处理事件，但这并不相同——委托可以处理事件，但不能表示它们的源。没有办法编写一个订阅某个.NET事件的方法，并将其作为参数传递，因为你不能传递实际的事件本身。Rx通过将事件源表示为对象而不是类型系统中不像其他任何东西的特殊的独特元素来修复了这一点。
- en: We get all four of these features for free back in the world of `IEnumerable<T>`,
    of course. A collection can throw an exception when its contents are being enumerated,
    but with callbacks, it’s less obvious when and where to deliver exceptions. `IEnumerable<T>`
    makes consumers retrieve items one at a time, so the ordering is unambiguous,
    but with plain events and delegates, nothing enforces that. And `IEnumerable<T>`
    tells consumers when the end of the collection has been reached, but with a simple
    callback, it’s not necessarily clear when you’ve had the last call. `IObservable<T>`
    handles all of these eventualities, bringing the things we can take for granted
    with `IEnumerable<T>` into the world of events.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在`IEnumerable<T>`的世界中，我们可以免费获得这四个特性。集合在枚举其内容时可能会抛出异常，但使用回调时，何时何地传递异常就不那么明显了。`IEnumerable<T>`让消费者逐个检索项，所以排序是明确的，但使用普通事件和委托时，并没有强制执行这一点。而`IEnumerable<T>`告诉消费者集合已经结束时，使用简单回调时，并不一定清楚何时发出了最后一次调用。`IObservable<T>`处理了所有这些情况，将我们在`IEnumerable<T>`中可以理所当然的事情带入了事件的世界。
- en: By providing a coherent abstraction that addresses these problems, Rx is able
    to bring all of the benefits of LINQ to event-driven scenarios. Rx does not replace
    events; I wouldn’t have dedicated one-fifth of [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events)
    to them if it did. In fact, Rx can integrate with events. It can bridge between
    its own abstractions and several others, not just ordinary events but also `IEnumerable<T>`
    and various asynchronous programming models. Far from deprecating events, Rx raises
    their capabilities to a new level. It’s considerably harder to get your head around
    Rx than events, but it offers much more power once you do.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供一个统一的抽象来解决这些问题，Rx能够将LINQ的所有优势带入事件驱动的场景中。如果Rx能够替代事件的话，我就不会在[第9章](ch09.xhtml#ch_delegates_lambdas_events)中专门提到它们了。事实上，Rx可以与事件集成。它可以在其自身的抽象和其他几种抽象之间架起桥梁，不仅仅是普通事件，还有`IEnumerable<T>`和各种异步编程模型。远非淘汰事件，Rx将它们的功能提升到了一个新的水平。理解Rx要比理解事件难得多，但一旦理解了，它提供的能力就远超过后者。
- en: Two interfaces form the heart of Rx. Sources that present items through this
    model implement `IObservable<T>`. Subscribers are required to supply an object
    that implements `IObserver<T>`. These two interfaces are built into .NET. The
    other parts of Rx are in the `System.Reactive` NuGet package.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Rx的核心是两个接口。通过这个模型展示项的源实现了`IObservable<T>`。订阅者需要提供一个实现了`IObserver<T>`的对象。这两个接口内置于.NET中。Rx的其他部分包含在`System.Reactive`
    NuGet包中。
- en: Fundamental Interfaces
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本接口
- en: The two most important types in Rx are the `IObservable<T>` and `IObserver<T>`
    interfaces. They are important enough to be in the `System` namespace. [Example 11-1](#iobservableoft_and_iobserveroft)
    shows their definitions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Rx 中最重要的两种类型是 `IObservable<T>` 和 `IObserver<T>` 接口。它们足够重要，以至于位于 `System` 命名空间中。[示例 11-1](#iobservableoft_and_iobserveroft)
    显示了它们的定义。
- en: Example 11-1\. `IObservable<T>` and `IObserver<T>`
  id: totrans-10
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-1\. `IObservable<T>` 和 `IObserver<T>`
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The fundamental abstraction in Rx, `IObservable<T>`, is implemented by event
    sources. Instead of using the `event` keyword, it models events as a sequence
    of items. An `IObservable<T>` provides items to subscribers as and when it’s ready
    to.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Rx 中的基本抽象 `IObservable<T>` 由事件源实现。它模拟事件作为项目序列，而不是使用 `event` 关键字。`IObservable<T>`
    根据准备好提供项目时为订阅者提供项目。
- en: As you can see, the type argument for `IObservable<T>` is covariant, meaning
    if you have a type `Base` that is the base type of another type `Derived`, then
    just as you can pass a `Derived` to any method expecting a `Base`, you can pass
    an `IObservable<Derived>` to anything expecting an `IObservable<Base>`. It makes
    sense intuitively to see the `out` keyword here, because like `IEnumerable<T>`,
    this is a source of information—items come out of it. Conversely, items go into
    a subscriber’s `IObserver<T>` implementation, so that has the `in` keyword, which
    denotes contravariance—you can pass an `IObserver<Base>` to anything expecting
    an `IObserver<Derived>`. (I described variance in [Chapter 6](ch06.xhtml#ch_inheritance).)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`IObservable<T>` 的类型参数是协变的，这意味着如果您有一个类型 `Base` 是另一个类型 `Derived` 的基类型，那么就像您可以将
    `Derived` 传递给任何期望 `Base` 的方法一样，您可以将 `IObservable<Derived>` 传递给任何期望 `IObservable<Base>`
    的东西。直观地看，这里使用 `out` 关键字是有道理的，因为像 `IEnumerable<T>` 一样，这是信息的来源——项目从中出来。相反，项目进入订阅者的
    `IObserver<T>` 实现，因此它具有 `in` 关键字，表示逆变性——您可以将 `IObserver<Base>` 传递给任何期望 `IObserver<Derived>`
    的东西。（我在 [第 6 章](ch06.xhtml#ch_inheritance) 中描述了变体。）
- en: We can subscribe to a source by passing an implementation of `IObserver<T>`
    to the `Subscribe` method. The source will invoke `OnNext` when it wants to report
    events, and it can call `OnCompleted` to indicate that there will be no further
    activity. If the source wants to report an error, it can call `OnError`. Both
    `OnCompleted` and `OnError` indicate the end of the stream—an observable should
    not call any further methods on the observer after that.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将 `IObserver<T>` 的实现传递给 `Subscribe` 方法来订阅源。当源希望报告事件时，它将调用 `OnNext`，并且可以调用
    `OnCompleted` 来指示不再有进一步的活动。如果源希望报告错误，它可以调用 `OnError`。`OnCompleted` 和 `OnError`
    都表示流的结束——在此之后，观察者上的任何方法都不应再调用。
- en: Warning
  id: totrans-15
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: You will not necessarily get an exception immediately if you break this rule.
    In some cases you will—if you use the NuGet `System.Reactive` library to help
    implement and consume these interfaces, there are certain circumstances in which
    it can detect this kind of mistake. But in general it is the responsibility of
    code calling these methods to stick to the rule.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您违反此规则，不一定会立即收到异常。在某些情况下会收到异常——如果您使用 NuGet 的 `System.Reactive` 库来帮助实现和消费这些接口，则某些情况下它可以检测到此类错误。但通常情况下，调用这些方法的代码负责遵守这个规则。
- en: There’s a visual convention for representing Rx activity. It’s sometimes called
    a *marble diagram*, because it consists mainly of small circles that look a bit
    like marbles. [Figure 11-1](#simple_marble_diagram) uses this convention to represent
    two sequences of events. The horizontal lines represent subscriptions to sources,
    with the vertical bar on the left indicating the start of the subscription, and
    the horizontal position indicating when something occurred (with elapsed time
    increasing from left to right). The circles indicate calls to `OnNext` (i.e.,
    events being reported by the source). An arrow on the righthand end indicates
    that the subscription was still active by the end of the time the diagram represents.
    A vertical bar on the right indicates the end of the subscription—either due to
    a call to `OnError` or `OnCompleted` or because the subscriber unsubscribed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 表示 Rx 活动的视觉约定有一个视觉约定。有时称为 *弹珠图*，因为它主要由看起来有点像弹珠的小圆圈组成。[图 11-1](#simple_marble_diagram)
    使用这种约定来表示两个事件序列。水平线表示对源的订阅，左侧的竖线表示订阅开始，水平位置表示事件发生的时间（从左到右的经过时间）。圆圈表示对 `OnNext`
    的调用（即源报告的事件）。右端的箭头表示订阅在图表表示的时间结束时仍然活动。右侧的竖线表示订阅结束——由于调用 `OnError` 或 `OnCompleted`
    或订阅者取消订阅。
- en: '![](assets/pc10_1101.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/pc10_1101.png)'
- en: Figure 11-1\. Simple marble diagram
  id: totrans-19
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-1. 简单的弹珠图
- en: 'When you call `Subscribe` on an observable, it returns an object that implements
    `IDisposable`, which provides a way to unsubscribe. If you call `Dispose`, the
    observable will not deliver any more notifications to your observer. This can
    be more convenient than the mechanism for unsubscribing from an event; to unsubscribe
    from an event, you must pass in an equivalent delegate to the one you used for
    subscription. If you’re using anonymous methods, that can be surprisingly awkward,
    because often the only way to do that is to keep hold of a reference to the original
    delegate. With Rx, any subscription to a source is represented as an `IDisposable`,
    making it easier to handle in a uniform way. In fact, you often do not need to
    unsubscribe anyway—this is necessary only if you want to stop receiving notifications
    before the source completes (making this an example of something that is relatively
    unusual in .NET: optional disposability).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在可观察对象上调用 `Subscribe` 时，它会返回一个实现 `IDisposable` 接口的对象，提供取消订阅的方法。如果调用 `Dispose`，可观察对象将不再向您的观察者发送任何通知。这比取消事件的机制更方便；要取消事件，您必须传入与用于订阅的委托相等的委托。如果您使用匿名方法，这可能会让人感到令人惊讶的笨拙，因为通常唯一的方法是保留对原始委托的引用。使用
    Rx，对源的任何订阅都表示为 `IDisposable`，使其更容易以统一的方式处理。事实上，通常您根本不需要取消订阅 —— 这只有在希望在源完成之前停止接收通知时才是必需的（这是
    .NET 中相对不常见的事情的一个示例：可选的可释放性）。
- en: IObserver<T>
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IObserver<T>
- en: As you’ll see, in practice we often don’t call a source’s `Subscribe` method
    directly, nor do we usually need to implement `IObserver<T>` ourselves. Instead,
    it’s common to use one of the delegate-based extension methods that Rx provides
    and that attaches an Rx-supplied implementation. However, those extension methods
    are not part of Rx’s fundamental types, so for now I’ll show what you’d need to
    write if these interfaces are all you’ve got. [Example 11-2](#simple_iobserver_implementation)
    shows a simple but complete observer.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在实践中，我们通常不直接调用源的 `Subscribe` 方法，也不通常需要自己实现 `IObserver<T>`。相反，通常使用 Rx 提供的基于委托的扩展方法，该方法附加了一个
    Rx 提供的实现。然而，这些扩展方法不是 Rx 的基本类型的一部分，所以现在我将展示如果这些接口是您唯一拥有的内容，您需要编写什么。[示例 11-2](#simple_iobserver_implementation)
    展示了一个简单但完整的观察者。
- en: Example 11-2\. Simple `IObserver<T>` implementation
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-2. 简单的 `IObserver<T>` 实现
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Rx sources (i.e., implementations of `IObservable<T>`) are required to make
    certain guarantees about how they call an observer’s methods. The calls happen
    in a certain order: `OnNext` is called for each item that the source provides,
    and I already mentioned that once either `OnCompleted` or `OnError` is called,
    the observer knows that there will be no further calls to any of the three methods.
    Either of those methods signals the end of the sequence.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Rx 源（即 `IObservable<T>` 的实现）必须对如何调用观察者方法作出某些保证。调用发生在特定顺序中：对于源提供的每个项目，都会调用 `OnNext`
    方法，我已经提到，一旦调用 `OnCompleted` 或 `OnError` 中的任何一个，观察者就知道不会再调用这三种方法中的任何一个。这两种方法中的任何一种信号序列的结束。
- en: Also, calls are not allowed to overlap—when an observable source calls one of
    our observer’s methods, it must wait for that method to return before calling
    again. A multithreaded observable must take care to coordinate its calls, and
    even in a single-threaded world, the possibility of recursion can make it necessary
    for sources to detect and prevent re-entrant calls.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，不允许调用重叠 —— 当可观察源调用我们观察者的方法之一时，必须等待该方法返回后再调用。多线程可观察源必须小心协调其调用，即使在单线程世界中，递归的可能性也可能需要源检测和防止重入调用。
- en: This makes life simple for the observer. Because Rx provides events as a sequence,
    my code doesn’t need to deal with the possibility of concurrent calls. It’s up
    to the source to call methods in the correct order. So, although `IObservable<T>`
    may look like the simpler interface, having just one method, it’s the more demanding
    one to implement. As you’ll see later, it’s usually easiest to let the Rx libraries
    implement this for you, but it’s still important to know how observable sources
    work, so I’ll implement it by hand to begin with.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这让观察者的生活变得简单。因为 Rx 将事件作为一个序列提供，我的代码不需要处理并发调用的可能性。调用方法的正确顺序取决于源。因此，尽管 `IObservable<T>`
    界面看起来更简单，只有一个方法，但实际上更难以实现。稍后您会看到，让 Rx 库为您实现这一点通常是最简单的，但了解可观察源如何工作仍然很重要，因此我将从头开始手动实现它。
- en: IObservable<T>
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IObservable<T>
- en: Rx makes a distinction between *hot* and *cold* observable sources. A hot observable
    produces each value as and when something of interest happens, and if no subscribers
    are attached at that moment, that value will be lost. A hot observable typically
    represents something live, such as mouse input, keypresses, or data reported by
    a sensor, which is why the values it produces are independent of how many subscribers,
    if any, are attached. Hot sources typically have broadcast-like behavior—they
    send each item to all of their subscribers. These can be the more complex kind
    of source to implement, so I’ll discuss cold sources first.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Rx区分*热*和*冷*可观察源。热可观察源会在有趣的事情发生时产生每个值，并且如果此时没有订阅者附加，那么该值将丢失。热可观察源通常代表实时事件，例如鼠标输入、按键或传感器报告的数据，因此它们生成的值独立于附加的订阅者数量。热源通常具有类似广播的行为—它们将每个项目发送给所有订阅者。这些可能是更复杂的源的实现方式，因此我将先讨论冷源。
- en: Implementing cold sources
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现冷源
- en: Whereas hot sources report items as and when they want to, cold observables
    work differently. They start pushing values when an observer subscribes, and they
    provide values to each subscriber separately, rather than broadcasting. This means
    that a subscriber won’t miss anything by being too late, because the source starts
    providing items when you subscribe. [Example 11-3](#a_simple_cold_observable_source)
    shows a very simple cold source.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 热源根据自己的意愿报告项目，而冷可观察源的工作方式有所不同。它们在观察者订阅时开始推送值，并且将值分别提供给每个订阅者，而不是广播。这意味着订阅者不会因为太迟而错过任何内容，因为源在你订阅时开始提供项目。[示例 11-3](#a_simple_cold_observable_source)
    展示了一个非常简单的冷源。
- en: Example 11-3\. A simple cold observable source
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-3\. 一个简单的冷可观察源
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The moment an observer subscribes, this source will provide two values, the
    strings `"Hello,"` and `"World!"`, and will then indicate the end of the sequence
    by calling `OnCompleted`. It does all that inside `Subscribe`, so this doesn’t
    really look like a subscription—the sequence is already over by the time `Subscribe`
    returns, so there’s nothing meaningful to do to support unsubscription. That’s
    why this returns a trivial implementation of `IDisposable`. (I’ve chosen an extremely
    simple example so I can show the basics. Real sources will be more complex.)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦观察者订阅，这个源将提供两个值，字符串 `"Hello,"` 和 `"World!"`，然后通过调用 `OnCompleted` 表示序列结束。它在
    `Subscribe` 中完成所有这些操作，所以这实际上看起来不像是一个订阅—在 `Subscribe` 返回时序列已经结束，所以支持取消订阅没有任何实际意义。这就是为什么这返回一个
    `IDisposable` 的微不足道的实现。（我选择了一个极其简单的示例来展示基础知识。真实的源会更复杂。）
- en: To show this in action, we need to create an instance of `SimpleColdSource`,
    and also an instance of my observer class from [Example 11-2](#simple_iobserver_implementation),
    and use that to subscribe to the source, as [Example 11-4](#attaching_an_observer_to_an_observable)
    does.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要展示这个过程，我们需要创建一个 `SimpleColdSource` 的实例，还需要从 [示例 11-2](#simple_iobserver_implementation)
    中创建一个我的观察者类的实例，并使用它订阅源，就像 [示例 11-4](#attaching_an_observer_to_an_observable) 所做的那样。
- en: Example 11-4\. Attaching an observer to an observable
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-4\. 将观察者附加到可观察源
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Predictably, this produces the following output:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 预计，这将产生以下输出：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In general, a cold observer will have access to some underlying source of information,
    which it can push to a subscriber on demand. In [Example 11-3](#a_simple_cold_observable_source),
    that “source” was just two hardcoded values. [Example 11-5](#file_cold_observable)
    shows a slightly more interesting cold observable, which reads the lines out of
    a file and provides them to a subscriber.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，冷观察者将可以访问某些底层信息源，它可以按需推送给订阅者。在 [示例 11-3](#a_simple_cold_observable_source)
    中，那个“源”只是两个硬编码的值。[示例 11-5](#file_cold_observable) 展示了一个稍微有趣的冷可观察源，它读取文件中的行并将它们提供给订阅者。
- en: Example 11-5\. A cold observable representing a file’s contents
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-5\. 一个表示文件内容的冷可观察源
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As before, this does not represent a live source of events, and it leaps into
    action only when something subscribes, but it’s a little more interesting than
    [Example 11-3](#a_simple_cold_observable_source). This calls into the observer
    as and when it retrieves each line from a file, so although the point at which
    it starts doing its work is determined by the subscriber, this source is in control
    of the rate at which it provides values. Just like [Example 11-3](#a_simple_cold_observable_source),
    this delivers all the items to the observer on the caller’s thread inside the
    call to `Subscribe`, but it would be a relatively small conceptual leap from [Example 11-5](#file_cold_observable)
    to one in which the code reading from the file either ran on a separate thread
    or used asynchronous techniques (such as those described in [Chapter 17](ch17.xhtml#ch_asynchronous_language_features)),
    thus enabling `Subscribe` to return before the work is complete (at which point
    you’d need to write a more interesting `IDisposable` implementation to enable
    callers to unsubscribe). This would still be a cold source, because it represents
    some underlying set of data that it can enumerate from the start for the benefit
    of each individual subscriber.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，这并不表示事件的实时源，它只有在有订阅发生时才会启动，但比[示例 11-3](#a_simple_cold_observable_source)更加有趣。每当从文件中检索到每一行时，它会调用观察者，因此虽然它开始工作的时间由订阅者确定，但这个源控制它提供值的速率。就像[示例
    11-3](#a_simple_cold_observable_source)一样，在`Subscribe`调用内部，它将所有项传递给调用者线程上的观察者，但从[示例
    11-5](#file_cold_observable)到一个从文件读取数据时运行在单独线程或使用异步技术（例如[第17章](ch17.xhtml#ch_asynchronous_language_features)中描述的）的概念跨度可能相对较小，从而使`Subscribe`在工作完成之前返回（在这种情况下，您需要编写一个更有趣的`IDisposable`实现来允许调用者取消订阅）。这仍然是一个冷源，因为它代表一些基础数据集，可以从开始为每个订阅者的利益枚举。
- en: '[Example 11-5](#file_cold_observable) is not quite complete—it fails to handle
    errors that occur while reading from the file. We need to catch these and call
    the observer’s `OnError` method. Unfortunately, it’s not quite as simple as wrapping
    the whole loop in a `try` block, because that would also catch exceptions that
    emerged from the observer’s `OnNext` method. If that throws an exception, we should
    allow it to carry on up the stack—we should handle only exceptions that emerge
    from the places we expect in our code. Unfortunately, this rather complicates
    the code. [Example 11-6](#handling_filesystem_errors) puts all the code that uses
    `FileStream` inside a `try` block but will allow any exceptions thrown by the
    observer to propagate up the stack, because it’s not up to us to handle those.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 11-5](#file_cold_observable)还不完整——它未能处理从文件读取时发生的错误。我们需要捕获这些错误并调用观察者的`OnError`方法。不幸的是，简单地将整个循环放在`try`块中并不那么简单，因为这也会捕获来自观察者的`OnNext`方法的异常。如果`OnNext`抛出异常，我们应该允许它继续向上堆栈传播——我们应该只处理我们代码中预期的位置出现的异常。不幸的是，这使代码变得相当复杂。[示例
    11-6](#handling_filesystem_errors)将使用`FileStream`的所有代码放在`try`块内，但将允许观察者抛出的任何异常向上传播，因为我们无权处理这些异常。'
- en: Example 11-6\. Handling filesystem errors but not observer errors
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-6\. 处理文件系统错误但不处理观察者错误
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If I/O exceptions occur while reading from the file, this reports them to the
    observer’s `OnError` method—so this source uses all three of the `IObserver<T>`
    methods.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在从文件读取时发生I/O异常，则会报告给观察者的`OnError`方法——因此，此源使用`IObserver<T>`的所有三个方法。
- en: Implementing hot sources
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现热源
- en: Hot sources notify all current subscribers of values as they become available.
    This means that any hot observable must keep track of which observers are currently
    subscribed. Subscription and notification are separated out with hot sources in
    a way that they usually aren’t with cold ones.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 热源在数值可用时通知所有当前订阅者。这意味着任何热 observable 必须跟踪当前已订阅的观察者。在热源中，订阅和通知被分开处理，这种方式通常在冷源中是不会出现的。
- en: '[Example 11-7](#keypress_monitor_iobservable) is an observable source that
    reports a single item for each keypress, and it’s a particularly simple source
    as hot ones go. It’s single-threaded, so it doesn’t need to do anything special
    to avoid overlapping calls. It doesn’t report errors, so it never needs to call
    observers’ `OnError` methods. And it never stops, so it doesn’t need to call `OnCompleted`
    either. Even so, it’s quite involved. (Things will get much simpler once I introduce
    the Rx library support—this example is relatively complex because for now, I’m
    sticking with just the two fundamental interfaces.)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 11-7](#keypress_monitor_iobservable) 是一个可观察源，每次按键报告一个项目，作为热源，它非常简单。它是单线程的，因此不需要采取任何特殊措施来避免重叠调用。它不报告错误，因此从不需要调用观察者的`OnError`方法。而且它永不停止，因此也不需要调用`OnCompleted`。即便如此，它也相当复杂。（一旦我介绍Rx库支持，情况将会简单得多——目前，我只坚持使用两个基本接口，所以这个示例相对复杂。）'
- en: Example 11-7\. `IObservable<T>` for monitoring keypresses
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-7\. 用于监控按键的`IObservable<T>`
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This defines a nested class called `Subscription` to keep track of each observer
    that subscribes, and this also provides the implementation of `IDisposable` that
    our `Subscribe` method is required to return. The observable creates a new instance
    of this nested class and adds it to a list of current subscribers during `Subscribe`,
    and then if `Dispose` is called, it removes itself from that list.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个名为`Subscription`的嵌套类，用于跟踪每个订阅的观察者，并提供了我们的`Subscribe`方法需要返回的`IDisposable`的实现。Observable在`Subscribe`期间创建此嵌套类的新实例，并将其添加到当前订阅者列表中；如果调用了`Dispose`，则从该列表中移除自身。
- en: As a general rule in .NET, you should `Dispose` any `IDisposable` resources
    allocated on your behalf when you’ve finished using them. However, in Rx, it is
    common not to dispose objects representing subscriptions, so if you implement
    such an object, you should not count on it being disposed. It’s typically unnecessary,
    because Rx can clean up for you. Unlike with ordinary .NET events or delegates,
    observables can unambiguously come to an end, at which point any resources allocated
    to subscribers can be freed. (Some run indefinitely, but in that case, subscriptions
    usually remain active for the life of the program.) Admittedly, the examples I’ve
    shown so far don’t clean up automatically, because I’ve provided my own implementations
    that are simple enough not to need to, but the Rx libraries do if you use their
    source and subscriber implementations. The only time you’d normally dispose of
    a subscription in Rx is if you want to unsubscribe before the source completes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 作为.NET的一般规则，在使用完代表您的资源分配的任何`IDisposable`资源时，应调用`Dispose`。但在Rx中，通常不会处理表示订阅的对象的释放，因此，如果您实现了这样的对象，则不应指望其被处理。这通常是不必要的，因为Rx可以为您清理。与普通的.NET事件或委托不同，可观察对象可以明确地结束，此时分配给订阅者的任何资源都可以释放。（某些会无限期运行，但在这种情况下，订阅通常会保持活动状态直到程序生命周期结束。）承认，到目前为止我展示的例子并没有自动清理，因为我提供了自己的实现，这些实现足够简单，不需要这样做，但是如果使用Rx库的源和订阅者实现，Rx库会这样做。在Rx中，通常只有在您希望在源完成之前取消订阅时，才会处理订阅。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Subscribers are not obliged to ensure that the `object` returned by `Subscribe`
    remains reachable. You can ignore it if you don’t need the ability to unsubscribe
    early, and it won’t matter if the garbage collector frees the object, because
    none of the `IDisposable` implementations that Rx supplies to represent subscriptions
    have finalizers. (And although you don’t normally implement these yourself—I’m
    doing so here only to illustrate how it works—if you did decide to write your
    own, take the same approach: do not implement a finalizer on a class that represents
    a subscription.)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅者无需确保通过`Subscribe`返回的`object`仍然可访问。如果您不需要早期取消订阅的能力，则可以忽略它，并且如果垃圾收集器释放了对象，则不会有任何影响，因为Rx提供的代表订阅的`IDisposable`实现中没有任何终结器。（虽然通常不会自己实现这些——我在这里只是为了说明它是如何工作的——如果您决定编写自己的实现，请采用相同的方法：不要在代表订阅的类上实现终结器。）
- en: The `KeyWatcher` class in [Example 11-7](#keypress_monitor_iobservable) has
    a `Run` method. That’s not a standard Rx feature; it’s just a loop that sits and
    waits for keyboard input—this observable won’t actually produce any notifications
    unless something calls that method. Each time this loop receives a key, it calls
    the `OnNext` method on every currently subscribed observer. Notice that I’m building
    a copy of the subscriber list (by calling `ToArray`—that’s a simple way to get
    a `List<T>` to duplicate its contents), because there’s every possibility that
    a subscriber might choose to unsubscribe in the middle of a call to `OnNext`.
    If I had passed the subscriber list directly to `foreach`, I would get an exception
    in this scenario, because lists don’t allow items to be added and removed if you’re
    in the middle of iterating through them.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 11-7](#keypress_monitor_iobservable) 中，`KeyWatcher` 类有一个 `Run` 方法。这不是标准的
    Rx 特性；它只是一个循环，坐等键盘输入——这个可观察对象实际上不会产生任何通知，除非有东西调用该方法。每次这个循环接收到一个键时，它会在每个当前订阅的观察者上调用
    `OnNext` 方法。请注意，我正在构建订阅者列表的副本（通过调用 `ToArray` —— 这是让 `List<T>` 复制其内容的简单方法），因为有可能订阅者在调用
    `OnNext` 过程中选择取消订阅。如果我直接将订阅者列表传递给 `foreach`，在这种情况下会抛出异常，因为列表不允许在迭代过程中添加和删除项目。
- en: Warning
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: This example only guards against re-entrant calls on the same thread; handling
    multithreaded unsubscription would be altogether more complex. In fact, even building
    a copy is not sufficiently paranoid. I should really be checking that each observer
    in my snapshot is still currently subscribed before calling its `OnNext`, because
    it’s possible that one observer might choose to unsubscribe some other observer.
    This also makes no attempt to deal with unsubscription from another thread. Later
    on, I’ll replace all of this with a much more robust implementation from the Rx
    library.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子仅防止在同一线程上重新进入调用；处理多线程取消订阅将会更加复杂。事实上，甚至构建一个副本也不够谨慎。我确实应该检查我的快照中的每个观察者在调用其
    `OnNext` 之前当前是否仍在订阅，因为有可能一个观察者可能选择取消其他观察者的订阅。这也不尝试处理来自另一个线程的取消订阅。稍后，我将用 Rx 库中更加健壮的实现来替换所有这些。
- en: In use, this hot source is very similar to my cold sources. We need to create
    an instance of the `KeyWatcher` and also another instance of my observer class
    (with a type argument of `char` this time, because this source produces characters
    instead of strings). Because this source does not generate items until its monitoring
    loop runs, I need to call `Run` to kick it off, as [Example 11-8](#attaching_an_observer)
    does.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用中，这个热源与我的冷源非常相似。我们需要创建一个 `KeyWatcher` 类的实例，并且还需要另一个观察者类的实例（这次使用 `char` 类型参数，因为这个源产生的是字符而不是字符串）。因为这个源在其监控循环运行之前不会生成项目，所以我需要调用
    `Run` 来启动它，就像 [示例 11-8](#attaching_an_observer) 那样。
- en: Example 11-8\. Attaching an observer to an observable
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-8\. 将观察者附加到可观察对象
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Running that code, the application will wait for keyboard input, and if you
    press, say, the *m* key, the observer ([Example 11-2](#simple_iobserver_implementation))
    will display the message `Received: m`. (And since my source never ends, the `Run`
    method will never return.)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '运行该代码时，应用程序将等待键盘输入，如果您按下，比如说，*m* 键，观察者（[示例 11-2](#simple_iobserver_implementation)）将显示消息
    `Received: m`。（由于我的源永不停息，`Run` 方法将永远不会返回。）'
- en: You might need to deal with a mixture of hot and cold observables. Also, some
    cold sources have some hot characteristics. For example, you could imagine a source
    that represented alert messages, and it might make sense to implement that in
    such a way that it stored alerts, to make sure you didn’t miss anything that happens
    in between creating the source and attaching a subscriber. So it would be a cold
    source—any new subscriber would get all the events so far—but once a subscriber
    has caught up, the ongoing behavior would look more like a hot source, because
    any new events would be broadcast to all current subscribers. As you’ll see, the
    Rx libraries provide various ways to mix and adapt between the two types of sources.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要处理混合的热和冷可观察对象。此外，一些冷源具有某些热特性。例如，您可以想象一个表示警报消息的源，可能有意义的是以这样一种方式实现它，即存储警报，以确保您不会错过在创建源和附加订阅者之间发生的任何事件。因此，它将是一个冷源——任何新的订阅者都会获得到目前为止的所有事件——但是一旦订阅者赶上了，持续的行为看起来更像是一个热源，因为任何新事件都将被广播给所有当前的订阅者。正如您将看到的，Rx
    库提供了各种方法来混合和适应这两种类型的源。
- en: While it’s useful to see what observers and observables need to do, it’s more
    productive to let Rx take care of the grunt work, so now I’ll show how you would
    write sources and subscribers if you were using the `System.Reactive` NuGet library
    instead of just the two fundamental interfaces.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然了解观察者和可观察对象需要做什么很有用，但如果让 Rx 来处理这些繁重的工作会更高效。现在我将展示如果你使用 `System.Reactive` NuGet
    库而不仅仅是两个基本接口，你将如何编写源和订阅者。
- en: Publishing and Subscribing with Delegates
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用委托发布和订阅
- en: If you use the `System.Reactive` NuGet package, you do not need to implement
    either `IObservable<T>` or `IObserver<T>` directly. The library provides several
    implementations. Some of these are adapters, bridging between Rx and other representations
    of asynchronously generated sequences. Some wrap existing observable streams.
    But the helpers aren’t just for adapting existing things. They can also help if
    you want to write code that originates new items or that acts as the final destination
    for items. The simplest of these helpers provide delegate-based APIs for creating
    and consuming observable streams.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `System.Reactive` NuGet 包，就不需要直接实现 `IObservable<T>` 或 `IObserver<T>`。该库提供了多种实现。其中一些是适配器，用于在
    Rx 和其他异步生成序列表示之间桥接。有些是包装现有的可观察流。但这些助手不仅仅用于适配现有内容。它们还可以帮助你编写生成新项或作为最终目标的代码。其中最简单的助手提供了基于委托的
    API 来创建和消费可观察流。
- en: Creating an Observable Source with Delegates
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用委托创建可观察源
- en: As you have seen in some of the preceding examples, although `IObservable<T>`
    is a simple interface, sources that implement it may have to do a fair amount
    of work to track subscribers. And we’ve not even seen the whole story yet. As
    you’ll see in [“Schedulers”](#schedulers), a source often needs to take extra
    measures to ensure that it integrates well with Rx’s threading mechanisms. Fortunately,
    the Rx libraries can do some of that work for us. [Example 11-9](#delegate-based_observable_source)
    shows how to use the `Observable` class’s static `Create` method to implement
    a cold source. (Each call to `GetFilePusher` will create a new source, so this
    is effectively a factory method.)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在之前的一些示例中看到的那样，虽然 `IObservable<T>` 是一个简单的接口，但实现它的源可能需要做相当多的工作来跟踪订阅者。而且我们还没有看到全部的故事。正如你将在
    [“Schedulers”](#schedulers) 中看到的那样，源经常需要采取额外的措施来确保它与 Rx 的线程机制良好集成。幸运的是，Rx 库可以为我们完成部分工作。[示例
    11-9](#delegate-based_observable_source) 展示了如何使用 `Observable` 类的静态 `Create` 方法来实现一个冷源。（每次调用
    `GetFilePusher` 都会创建一个新的源，因此这实际上是一个工厂方法。）
- en: Example 11-9\. Delegate-based observable source
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-9\. 基于委托的可观察源
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This serves the same purpose as [Example 11-5](#file_cold_observable)—it provides
    an observable source that supplies each line in a file in turn to subscribers.
    (As with [Example 11-5](#file_cold_observable), I’ve left out error handling for
    clarity. In practice, you’d need to report errors in the same way as [Example 11-6](#handling_filesystem_errors).)
    The heart of the code is the same, but I’ve been able to write just a single method
    instead of a whole class, because Rx is now providing the `IObserva⁠ble​<T>` implementation.
    Each time an observer subscribes to that observable, Rx calls the callback I passed
    to `Create`. So all I have to do is write the code that provides the items. As
    well as not needing the outer class implementing `IObservable<T>`, I’ve also been
    able to omit the nested class that implements `IDisposable`—the `Create` method
    allows us to return an `Action` delegate instead of an object, and it will invoke
    that if the subscriber chooses to unsubscribe. Since my method doesn’t return
    until after it has finished producing items, there’s nothing useful I can do,
    so I’ve just returned an empty method.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 [例子 11-5](#file_cold_observable) 的目的相同——它提供了一个可观察源，逐行向订阅者提供文件中的每一行。（与 [例子
    11-5](#file_cold_observable) 一样，出于清晰起见，我省略了错误处理。在实践中，你需要像 [例子 11-6](#handling_filesystem_errors)
    那样报告错误。）代码的核心部分是相同的，但我只需要编写一个方法而不是整个类，因为现在 Rx 提供了 `IObservable<T>` 的实现。每当观察者订阅该可观察对象时，Rx
    就会调用我传递给 `Create` 的回调函数。因此，我所需要做的就是编写提供这些项的代码。除了不需要外部实现 `IObservable<T>` 的类之外，我还能够省略实现
    `IDisposable` 的嵌套类——`Create` 方法允许我们返回一个 `Action` 委托而不是对象，并且如果订阅者选择取消订阅，它将调用该委托。因为我的方法在生成项目后才会返回，所以我只是返回了一个空方法。
- en: I’ve written rather less code than in [Example 11-5](#file_cold_observable),
    but as well as simplifying my implementation, `Observable.Create` does two more
    slightly subtle things for us that are not immediately apparent from the code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我写的代码比[示例 11-5](#file_cold_observable)少得多，但是除了简化我的实现外，`Observable.Create` 对我们还做了两件稍微微妙的事情，这些事情并不立即从代码中显现出来。
- en: First, if a subscriber unsubscribes early, this code will now correctly stop
    sending it items, even though I’ve written no code to handle that. When an observer
    subscribes to a source of this kind, Rx does not pass the `IObserver<T>` directly
    to our callback. The `observer` argument in the nested method in [Example 11-9](#delegate-based_observable_source)
    refers to an Rx-supplied wrapper. If the underlying observer unsubscribes, that
    wrapper automatically stops forwarding notifications. My loop will carry on running
    through the file even after the subscriber stops listening, which is wasteful,
    but at least the subscriber doesn’t get items after it has asked me to stop. (You
    may be wondering how the subscriber even gets a chance to unsubscribe, given that
    my code doesn’t return until it has finished. It could do this in its `OnNext`
    method.)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果订阅者提前取消订阅，这段代码现在会正确停止发送项目给它，尽管我没有编写处理这种情况的代码。当观察者订阅这种类型的源时，Rx 不会直接将 `IObserver<T>`
    传递给我们的回调。[示例 11-9](#delegate-based_observable_source)中嵌套方法中的 `observer` 参数指的是一个由
    Rx 提供的包装器。如果底层观察者取消订阅，该包装器会自动停止转发通知。我的循环会在订阅者停止监听后继续运行文件，这是浪费的，但至少订阅者在要求停止后不再收到项目。
    （也许你会想知道，订阅者如何有机会取消订阅，因为我的代码直到完成才返回。它可以在其 `OnNext` 方法中执行此操作。）
- en: You can use Rx in conjunction with the C# asynchronous language features (specifically,
    the `async` and `await` keywords) to implement a version of [Example 11-9](#delegate-based_observable_source)
    that not only handles unsubscription more efficiently but also reads from the
    file asynchronously, meaning subscription does not need to block. This is significantly
    more efficient, and yet the code is almost identical. I won’t be introducing the
    asynchronous language features until [Chapter 17](ch17.xhtml#ch_asynchronous_language_features),
    so this might not make complete sense yet, but if you’re curious, [Example 11-10](#an_asynchronous_source)
    shows how it looks. The modified lines are in bold. (Again, this is the version
    without error handling. Asynchronous methods can handle exceptions in much the
    same way as synchronous ones, so you could manage errors with the same approach
    as [Example 11-6](#handling_filesystem_errors).)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以结合 C# 的异步语言特性（具体来说，是`async`和`await`关键字）使用 Rx 来实现[示例 11-9](#delegate-based_observable_source)的一个版本，这不仅可以更有效地处理取消订阅，还可以异步地从文件中读取数据，意味着订阅不需要阻塞。这显著提升了效率，但代码几乎没有改变。我不会在[第17章](ch17.xhtml#ch_asynchronous_language_features)介绍异步语言特性，所以这可能现在还不完全明白，但如果你感兴趣，[示例 11-10](#an_asynchronous_source)展示了其实现方式。修改的行已用粗体标出。（再次强调，这是没有错误处理的版本。异步方法可以像同步方法一样处理异常，所以你可以用与[示例 11-6](#handling_filesystem_errors)相同的方式处理错误。）
- en: Example 11-10\. An asynchronous source
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-10\. 异步源
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The second thing `Observable.Create` does for us under the covers is that in
    certain circumstances, it will use Rx’s scheduler system to call our code via
    a work queue instead of invoking it directly. This avoids possible deadlocks in
    cases where you’ve chained multiple observables together. I will be describing
    schedulers later in this chapter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.Create` 在幕后为我们做的第二件事，在某些情况下，它将使用 Rx 的调度系统通过工作队列调用我们的代码，而不是直接调用它。这样做可以避免在链式多个
    observable 的情况下可能出现的死锁。我将在本章稍后描述调度器。'
- en: This technique is good for cold sources such as [Example 11-9](#delegate-based_observable_source).
    Hot sources work differently, broadcasting live events to all subscribers, and
    `Observable.Create` does not cater to them directly because it invokes the delegate
    you pass once for each subscriber. However, the Rx libraries can still help.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术适用于冷源，比如[示例 11-9](#delegate-based_observable_source)。热源的工作方式不同，它将实时事件广播给所有订阅者，`Observable.Create`
    不直接支持它们，因为它每个订阅者只调用一次你传递的委托。不过，Rx 库仍然可以提供帮助。
- en: Rx provides a `Publish` extension method for any `IObservable<T>`, defined by
    the `Observable` class in the `System.Reactive.Linq` namespace. This method is
    designed to wrap a source whose subscription method (i.e., the delegate you pass
    to `Observa⁠ble​.Create`) supports being run only once but to which you want to
    attach multiple subscribers—it handles the multicast logic for you. Strictly speaking,
    a source that supports only a single subscription is degenerate, but as long as
    you hide it behind `Publish`, it doesn’t matter, and you can use this as a way
    to implement a hot source. [Example 11-11](#delegate-based_hot_source) shows how
    to create a source that provides the same functionality as the `KeyWatcher` in
    [Example 11-7](#keypress_monitor_iobservable). I’ve also hooked up two subscribers,
    just to illustrate the point that this supports multiple subscribers.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Rx 为任何 `IObservable<T>` 提供了一个 `Publish` 扩展方法，由 `System.Reactive.Linq` 命名空间中的
    `Observable` 类定义。该方法旨在包装一个仅支持一次运行的订阅方法的源（即您传递给 `Observa⁠ble​.Create` 的委托），但您希望附加多个订阅者—它为您处理多播逻辑。严格来说，仅支持单个订阅的源是退化的，但只要您将其隐藏在
    `Publish` 后面，这并不重要，您可以将其用作实现热源的方法。[Example 11-11](https://example.org/delegate-based_hot_source)
    展示了如何创建一个提供与 [Example 11-7](https://example.org/keypress_monitor_iobservable)
    中的 `KeyWatcher` 相同功能的源。我还连接了两个订阅者，仅仅是为了说明这支持多个订阅者的点。
- en: Example 11-11\. Delegate-based hot source
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 11-11\. 基于委托的热源
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `Publish` method does not call `Subscribe` on the source immediately. Nor
    does it do so when you first attach a subscriber to the source it returns. I have
    to tell the published source when I want it to start. Notice that `Publish` returns
    an `IConnectableObservable<T>`. This derives from `IObservable<T>` and adds a
    single extra method, `Connect`. This interface represents a source that doesn’t
    start until it’s told to, and it’s designed to let you hook up all the subscribers
    you need before you set it running. Calling `Connect` on the source returned by
    `Publish` causes it to subscribe to my original source, invoking the subscription
    callback I passed to `Observable.Create` and running my loop. This causes the
    `Connect` method to have the same effect as calling `Run` on my original [Example 11-7](#keypress_monitor_iobservable).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Publish` 方法不会立即在源上调用 `Subscribe`。当您首次将订阅器附加到返回的源时，也不会立即调用。我必须告诉已发布的源何时启动。请注意，`Publish`
    返回一个 `IConnectableObservable<T>`。这从 `IObservable<T>` 派生，并添加了一个额外的方法 `Connect`。这个接口表示一个在被告知之前不会启动的源，设计用于让您在设置其运行之前连接所有需要的订阅器。在由
    `Publish` 返回的源上调用 `Connect` 导致它订阅我的原始源，调用我传递给 `Observable.Create` 的订阅回调并运行我的循环。这使得
    `Connect` 方法具有与在我的原始 [Example 11-7](https://example.org/keypress_monitor_iobservable)
    上调用 `Run` 相同的效果。'
- en: '`Connect` returns an `IDisposable`. This provides a way to disconnect at some
    later point—that is, to unsubscribe from the underlying source. (If you don’t
    call this, the connectable observable returned by `Publish` will remain subscribed
    to your source even if you `Dispose` each of the individual downstream subscriptions.)
    In this particular example, the call to `Connect` will never return, because the
    code I passed to `Observable.Create` also never returns. Most observable sources
    don’t do this. Typically, they avoid it by using either asynchronous or scheduler-based
    techniques, which I will show later in this chapter.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Connect` 返回一个 `IDisposable`。这提供了一种在稍后断开连接的方式—即从底层源取消订阅。（如果您不调用此方法，则由 `Publish`
    返回的可连接的可观察对象将保持订阅到您的源，即使您每个单独的下游订阅都 `Dispose`。）在这个特定的例子中，对 `Connect` 的调用将永远不会返回，因为我传递给
    `Observable.Create` 的代码也永远不会返回。大多数可观察源不会这样做。通常，它们通过使用异步或基于调度程序的技术来避免这种情况，我将在本章后面展示。'
- en: The combination of the delegate-based `Observable.Create` and the multicasting
    offered by `Publish` has enabled me to throw away everything in [Example 11-7](#keypress_monitor_iobservable)
    except for the loop that actually generates items, and even that has become simpler.
    Being able to remove about 80% of the code isn’t the whole story, either. This
    will work better—`Publish` lets Rx handle my subscribers, which will deal correctly
    with the awkward situations in which subscribers unsubscribe while being notified.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 基于委托的 `Observable.Create` 结合 `Publish` 提供的多播功能，使我能够丢弃 [Example 11-7](https://example.org/keypress_monitor_iobservable)
    中除了实际生成项的循环之外的所有内容，甚至这个循环也变得更简单了。能够删除大约 80% 的代码并不是全部故事。这将工作得更好—`Publish` 让 Rx
    处理我的订阅者，这些订阅者将正确处理在通知期间取消订阅的尴尬情况。
- en: Of course, the Rx libraries don’t just help with implementing sources. They
    can simplify subscribers too.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Rx 库不仅有助于实现数据源，还可以简化订阅者。
- en: Subscribing to an Observable Source with Delegates
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用委托订阅可观察源
- en: Just as you don’t have to implement `IObservable<T>`, it’s also not necessary
    to provide an implementation of `IObserver<T>`. You won’t always care about all
    three methods—the `KeyWatcher` observable in [Example 11-7](#keypress_monitor_iobservable)
    never even calls the `OnCompleted` or `OnError` methods, because it runs indefinitely
    and has no error detection. Even when you do need to provide all three methods,
    you won’t necessarily want to write a whole separate type to provide them. So
    the Rx libraries provide extension methods to simplify subscription, defined by
    the `ObservableExtensions` class in the `System` namespace. Most C# source files
    include a `using System;` directive, or are in a project with an implicit global
    `using` directive for `System`, so the extensions it offers will usually be available
    as long as your project has a reference to the `System​.Reac⁠tive` NuGet package.
    There are several overloads for the `Subscribe` method available for any `IObservable<T>`.
    [Example 11-12](#subscribing_without_iobserver) uses one of them.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你不必实现`IObservable<T>`一样，也不必提供`IObserver<T>`的实现。你并不总是关心这三种方法中的全部——[示例 11-7](#keypress_monitor_iobservable)
    中的`KeyWatcher`可观察对象甚至从未调用`OnCompleted`或`OnError`方法，因为它运行时间无限，并且没有错误检测。即使你需要提供所有三种方法，你也不一定想要编写一个完全独立的类型来提供它们。因此，Rx
    库提供了扩展方法来简化订阅，由`System`命名空间中的`ObservableExtensions`类定义。大多数 C# 源文件包含`using System;`指令，或者在一个隐式全局`using`指令的项目中，对`System`的引用通常都是可用的，因此它提供的扩展方法也通常可用于任何`IObservable<T>`。[示例 11-12](#subscribing_without_iobserver)
    使用其中一个。
- en: Example 11-12\. Subscribing without implementing `IObserver<T>`
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-12\. 在不实现`IObserver<T>`的情况下订阅
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This example has the same effect as [Example 11-8](#attaching_an_observer).
    However, by using this approach, we no longer need to write a whole class implementing
    `IObserver<T>` like [Example 11-2](#simple_iobserver_implementation). With this
    `Subscribe` extension method, Rx provides the `IObserver<T>` implementation for
    us, and we provide methods only for the notifications we want.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例与[示例 11-8](#attaching_an_observer) 具有相同的效果。然而，通过使用这种方法，我们不再需要像[示例 11-2](#simple_iobserver_implementation)那样编写一个完整实现`IObserver<T>`的类。使用这个`Subscribe`扩展方法，Rx
    为我们提供了`IObserver<T>`的实现，我们只需为我们想要的通知提供方法。
- en: The `Subscribe` overload used by [Example 11-12](#subscribing_without_iobserver)
    takes an `Action<T>`, where `T` is the item type of the `IObservable<T>`, which
    in this case is `char`. My source doesn’t provide error notifications, nor does
    it use `OnCompleted` to indicate the end of the items, but plenty of sources do,
    so there are three overloads of `Subscribe` to handle that. One takes an extra
    delegate of type `Action<Exception>` to handle errors. Another takes a second
    delegate of type `Action` (i.e., one that takes no arguments) to handle the completion
    notification. The third overload takes three delegates—the same per-item callback
    that they all take, and then an exception handler and a completion handler.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 11-12](#subscribing_without_iobserver) 使用的`Subscribe`重载接受一个`Action<T>`，其中`T`是`IObservable<T>`的项类型，在本例中为`char`。我的源代码不提供错误通知，也不使用`OnCompleted`来指示项目结束，但许多源会这样做，因此有三个`Subscribe`重载来处理这种情况。其中一个接受一个额外的`Action<Exception>`委托来处理错误。另一个接受一个类型为`Action`（即不带参数的委托）的第二个委托来处理完成通知。第三个重载接受三个委托——与所有项相关的回调相同，然后是一个异常处理程序和一个完成处理程序。'
- en: Note
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you do not provide an exception handler when using delegate-based subscription,
    but the source calls `OnError`, the `IObserver<T>` Rx supplies throws the exception
    to keep the error from going unnoticed. [Example 11-5](#file_cold_observable)
    calls `OnError` in the `catch` block where it handles I/O exceptions, and if you
    subscribed using the technique in [Example 11-12](#subscribing_without_iobserver),
    you’d find that the call to `OnError` throws the `IOException` right back out
    again—the same exception is then thrown twice in a row, once by the `StreamReader`
    and then again by the Rx-supplied `IObserver<T>` implementation. Since we’d already
    be in the `catch` block in [Example 11-5](#file_cold_observable) by this time
    (and not the `try` block), this second throw would cause the exception to emerge
    from the `Subscribe` method, either to be handled farther up the stack or crashing
    the application.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在使用基于委托的订阅时没有提供异常处理程序，但源调用 `OnError`，Rx提供的 `IObserver<T>` 将抛出异常以防止错误被忽略。[例子 11-5](#file_cold_observable)
    在处理I/O异常的 `catch` 块中调用 `OnError`，如果使用 [例子 11-12](#subscribing_without_iobserver)
    中的技术订阅，你会发现调用 `OnError` 会将 `IOException` 再次抛出——相同的异常连续抛出两次，一次是由 `StreamReader`
    抛出，然后再由Rx提供的 `IObserver<T>` 实现抛出。由于这时我们已经在 [例子 11-5](#file_cold_observable) 的
    `catch` 块中（而不是 `try` 块），这第二次抛出会导致异常从 `Subscribe` 方法中出现，要么被更高层次处理，要么导致应用程序崩溃。
- en: There’s one more overload of the `Subscribe` extension method, taking no arguments.
    This subscribes to a source and then does nothing with the items it receives.
    (It will throw any errors back to the source, just like the other overloads that
    don’t take an error callback.) This would be useful if you have a source that
    does something important as a side effect of subscription, although it’s probably
    best to avoid designs where that’s necessary.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subscribe` 扩展方法还有一个不带参数的重载。这会订阅一个源，然后对接收到的项不做任何处理。（它会将任何错误抛回给源，就像那些不带错误回调的其他重载一样。）如果你有一个源在订阅时执行了一些重要的副作用，这会很有用，尽管最好避免必须这样设计。'
- en: Sequence Builders
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列生成器
- en: Rx defines several methods that create new sequences from scratch, without requiring
    either custom types or callbacks. These are designed for certain simple scenarios
    such as single-element sequences, empty sequences, or particular patterns. These
    are all static methods defined by the `Observable` class.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Rx定义了几种方法，可以从头开始创建新的序列，而无需自定义类型或回调。这些设计用于某些简单的场景，例如单元素序列、空序列或特定模式。这些都是由 `Observable`
    类定义的静态方法。
- en: Empty
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空
- en: 'The `Observable.Empty<T>` method is similar to the `Enumerable.Empty<T>` method
    from LINQ to Objects that I showed in [Chapter 10](ch10.xhtml#ch_linq): it produces
    an empty sequence. (The difference, of course, is that it implements `IObservable<T>`,
    not `IEnumera⁠ble​<T>`.) As with the LINQ to Objects method, this is useful when
    you’re working with APIs that demand an observable source and you have no items
    to provide.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.Empty<T>` 方法类似于LINQ到对象中的 `Enumerable.Empty<T>` 方法，我在[第10章](ch10.xhtml#ch_linq)中展示过它：它生成一个空序列。（当然，不同之处在于它实现了
    `IObservable<T>` 而不是 `IEnumera⁠ble​<T>`。）与LINQ到对象方法一样，当你需要与要求可观察源的API一起工作但没有要提供的项目时，这是非常有用的。'
- en: Any observer that subscribes to an `Observable.Empty<T>` sequence will have
    its `OnCompleted` method called immediately.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 任何订阅 `Observable.Empty<T>` 序列的观察者都会立即调用其 `OnCompleted` 方法。
- en: Never
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从不
- en: The `Observable.Never<T>` method produces a sequence that never does anything—it
    produces no items, and unlike an empty sequence, it never even completes. (The
    Rx team considered calling this `Infinite<T>` to emphasize the fact that as well
    as never producing anything, it also never ends.) There is no counterpart in LINQ
    to Objects. If you wanted to write an `IEnumerable<T>` equivalent of `Never`,
    it would be one that blocked indefinitely when you first tried to retrieve an
    item. In the pull-based world of LINQ to Objects, this would not be at all useful—it
    would cause the calling thread to freeze for the lifetime of the process. (An
    `IAsyncEnumerable<T>` equivalent would return a `ValueTask<bool>` that never completes
    from the first call to `MoveNextAsync`. This does not need to block a thread,
    but you still end up with a logical operation in progress that never completes.)
    But in Rx’s reactive world, sources don’t block progress just because they are
    in a state where they’re not currently producing items, so `Never` is a less disastrous
    idea. It can be helpful with some of the operators I’ll show later that can use
    an `IObservable<T>` to represent duration. `Never` can represent an activity you
    want to run indefinitely.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.Never<T>` 方法生成一个永不执行任何操作的序列——它不生成任何项目，并且不像空序列那样甚至不会完成。（Rx 团队考虑将其称为
    `Infinite<T>`，以强调除了永不生成任何内容外，它也永不结束。）在 LINQ to Objects 中没有对应物。如果要编写 `Never` 的
    `IEnumerable<T>` 等效版本，它将在首次尝试检索项目时无限期地阻塞。在基于拉取的 LINQ to Objects 世界中，这将毫不有用——它将导致调用线程在进程的生命周期内冻结。（`IAsyncEnumerable<T>`
    等效版本将从首次调用 `MoveNextAsync` 开始返回一个永不完成的 `ValueTask<bool>`。这不需要阻塞线程，但你仍然会得到一个永远不会完成的逻辑操作。）但在
    Rx 的响应式世界中，源不会因为它们处于当前不生成项目的状态而阻塞进度，因此 `Never` 是一个不那么灾难性的想法。它对我后面将展示的一些运算符可能有所帮助，这些运算符可以使用
    `IObservable<T>` 表示持续时间。`Never` 可以表示你希望无限期运行的活动。'
- en: Return
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Return
- en: The `Observable.Return<T>` method takes a single argument and returns an observable
    sequence that immediately produces that one value and then completes. Just as
    `Empty` is useful when something requires a sequence and you have no items, this
    is useful when something requires a sequence and you have exactly one item. This
    is a cold source—you can subscribe to it any number of times, and each subscriber
    will receive the same value. There is no exact equivalent in LINQ to Objects,
    although the Rx team provides a library called the Interactive Extensions for
    .NET (or Ix for short, available in the `System.Interactive` NuGet package) that
    provides `IEnumerable<T>` versions of this and several of the other operators
    described in this chapter that are in Rx but not LINQ to Objects.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.Return<T>` 方法接受一个单一参数，并返回一个 observable 序列，立即产生该值，然后完成。就像 `Empty`
    在需要序列但没有项目时很有用一样，当需要序列且只有一个项目时，这也很有用。这是一个冷源——你可以订阅任意次数，每个订阅者都会收到相同的值。在 LINQ to
    Objects 中没有确切的等效物，尽管 Rx 团队提供了一个名为交互扩展（Interactive Extensions for .NET，或简称 Ix，在
    `System.Interactive` NuGet 包中可用）的库，其中包括本章描述的此类和其他几个运算符的 `IEnumerable<T>` 版本，这些运算符在
    Rx 中有但在 LINQ to Objects 中没有。'
- en: Throw
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Throw
- en: The `Observable.Throw<T>` method takes a single argument of type `Exception`
    and returns an observable sequence that passes that exception to `OnError` immediately
    for any subscriber. Like `Return`, this is also a cold source that can be subscribed
    to any number of times, and it will do the same thing to each subscriber.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.Throw<T>` 方法接受一个 `Exception` 类型的单一参数，并返回一个 observable 序列，立即将该异常传递给任何订阅者的
    `OnError`。与 `Return` 类似，这也是一个冷源，可以订阅任意次数，并且每个订阅者都将执行相同的操作。'
- en: Range
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Range
- en: The `Observable.Range` method generates a sequence of numbers. (It always returns
    an `IObservable<int>`, which is why it does not take a type argument.) Like the
    `Enumerable.Range` method, it takes a starting number and a count. This is a cold
    source that will produce the entire range for each subscriber.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.Range` 方法生成一个数字序列。（它总是返回一个 `IObservable<int>`，这就是为什么它不需要类型参数。）类似于
    `Enumerable.Range` 方法，它接受一个起始数字和一个计数。这是一个冷源，每个订阅者都将产生整个范围。'
- en: Repeat
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Repeat
- en: The `Observable.Repeat<T>` method takes an input and produces a sequence that
    repeatedly produces that input over and over again. The input can be a single
    value, but it can also be another observable sequence, in which case it will forward
    items until that input completes and will then resubscribe to produce the whole
    sequence repeatedly. (That means that this will only genuinely repeat the data
    if you pass it a cold observable.)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.Repeat<T>` 方法接受一个输入并产生一个重复产生该输入的序列。输入可以是单个值，但也可以是另一个可观察序列，在这种情况下，它将转发项目直到输入完成，然后重新订阅以重复整个序列。（这意味着只有在传递一个冷可观察序列时，数据才会真正重复。）'
- en: If you pass no other arguments, the resulting sequence will produce values indefinitely—the
    only way to stop it is to unsubscribe. You can also pass a count, saying how many
    times you would like the input to repeat.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有传递其他参数，生成的序列将无限产生值，唯一停止的方法是取消订阅。你还可以传递一个计数，表示你希望输入重复多少次。
- en: Generate
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成
- en: 'The `Observable.Generate<TState, TResult>` method can produce more complex
    sequences than the other methods I’ve just described. You provide `Generate` with
    an object or value representing the generator’s initial state. This can be any
    type you like—it’s one of the method’s generic type arguments. You must also supply
    three functions: one that inspects the current state to decide whether the sequence
    is complete yet, one that advances the state in preparation for producing the
    next item, and one that determines the value to produce for the current state.
    [Example 11-13](#generating_items) uses this to create a source that produces
    random numbers until the sum total of all the numbers produced exceeds 10,000.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.Generate<TState, TResult>` 方法可以生成比我刚刚描述的其他方法更复杂的序列。你提供给 `Generate`
    一个表示生成器初始状态的对象或值。这可以是任何你喜欢的类型——它是方法的泛型类型参数之一。你还必须提供三个函数：一个检查当前状态以决定序列是否已经完成的函数，一个在准备产生下一个项目时推进状态的函数，以及一个确定当前状态下要产生的值的函数。[示例 11-13](#generating_items)
    使用这些函数创建一个源，该源生成随机数，直到所有生成的数字的总和超过 10,000。'
- en: Example 11-13\. Generating items
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-13\. 生成项目
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This always produces `0` as the first item, illustrating that `Generate` calls
    the function that determines the current value (the final lambda in [Example 11-13](#generating_items))
    before making the first call to the function that iterates the state.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这总是作为第一个项目产生`0`，说明 `Generate` 在首次调用用于确定当前值的函数（在[示例 11-13](#generating_items)中的最后一个
    lambda 表达式）之前，会调用用于迭代状态的函数。
- en: 'You could achieve the same effect as this example by using `Observable.Create`
    and a loop. However, `Generate` inverts the flow of control: instead of your code
    sitting in a loop telling Rx when to produce the next item, Rx asks your functions
    for the next item. This gives Rx more flexibility over scheduling of the work.
    For example, it enables `Generate` to offer overloads that bring timing into the
    picture. [Example 11-14](#generating_timed_items) produces items in a similar
    way but passes an extra function as the final argument that tells Rx to delay
    the delivery of each item by a random amount.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `Observable.Create` 和一个循环来实现与这个示例相同的效果。但是，`Generate` 反转了控制流：你的代码不再在循环中告诉
    Rx 何时产生下一个项目，而是 Rx 要求你的函数提供下一个项目。这使得 Rx 在调度工作时具有更大的灵活性。例如，它使 `Generate` 能够提供带有定时功能的重载版本。[示例 11-14](#generating_timed_items)
    以类似的方式产生项目，但是通过传递一个额外的函数作为最后一个参数告诉 Rx 延迟每个项目的传递。
- en: Example 11-14\. Generating timed items
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-14\. 生成定时项目
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For this to work, Rx needs to be able to schedule work to happen at some point
    in the future. I’ll explain how this works in [“Schedulers”](#schedulers).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个方法工作，Rx 需要能够安排未来某个时间点发生的工作。我将在[“调度器”](#schedulers)中解释这是如何工作的。
- en: LINQ Queries
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LINQ 查询
- en: One of the greatest benefits of using Rx is that it has a LINQ implementation,
    enabling you to write queries to process asynchronous streams of items such as
    events. [Example 11-15](#filtering_items_with_a_linq_query) illustrates this.
    It begins by producing an observable source representing `MouseMove` events from
    a UI element. I’ll talk about this technique in more detail in [“Adaptation”](#adaptation),
    but for now it’s enough to know that Rx can wrap any .NET event as an observable
    source. Each event produces an item that provides two properties containing the
    values normally passed to event handlers as arguments (i.e., the sender and the
    event arguments).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Rx 的最大好处之一是它有一个 LINQ 实现，使你能够编写查询来处理诸如事件之类的异步项目流。[示例 11-15](#filtering_items_with_a_linq_query)
    说明了这一点。它首先生成一个表示来自 UI 元素的 `MouseMove` 事件的可观察源。我将在 [“适应”](#adaptation) 中更详细地讨论这种技术，但现在知道
    Rx 可以将任何 .NET 事件包装为可观察源就足够了。每个事件产生一个项目，其中包含两个属性，这些属性包含通常作为参数传递给事件处理程序的值（即发送者和事件参数）。
- en: Example 11-15\. Filtering items with a LINQ query
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-15\. 使用 LINQ 查询过滤项目
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `where` clause in the LINQ query filters the events so that we process only
    those events that were raised while a specific UI element (`background`) has captured
    the mouse. This particular example is based on WPF, but in general, Windows desktop
    applications that want to support dragging *capture* the mouse when the mouse
    button is pressed and *release* it afterward. This ensures that the capturing
    element receives mouse move events for as long as the drag is in progress, even
    if the mouse moves over other UI elements. Typically, UI elements receive mouse
    move events when the mouse is over them even if they have not captured the mouse.
    So I need that `where` clause in [Example 11-15](#filtering_items_with_a_linq_query)
    to ignore those events, leaving only mouse movements that occur while a drag is
    in progress. So, for the code in [Example 11-15](#filtering_items_with_a_linq_query)
    to work, you’d need to attach event handlers such as those in [Example 11-16](#capturing_the_mouse)
    to the relevant element’s `MouseDown` and `MouseUp` events.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 查询中的 `where` 子句过滤事件，以便我们只处理在特定 UI 元素（`background`）捕获鼠标时引发的事件。这个特定示例基于 WPF，但一般来说，希望支持拖动的
    Windows 桌面应用程序在鼠标按钮按下时捕获鼠标，并在之后释放它。这确保捕获元素在拖动进行时接收鼠标移动事件，即使鼠标移动到其他 UI 元素上也是如此。通常，当鼠标位于
    UI 元素上时，即使它们没有捕获鼠标，它们也会接收鼠标移动事件。因此，我需要在 [示例 11-15](#filtering_items_with_a_linq_query)
    中的 `where` 子句中忽略那些事件，只留下在拖动进行时发生的鼠标移动。因此，为了使 [示例 11-15](#filtering_items_with_a_linq_query)
    中的代码工作，你需要将事件处理程序附加到相关元素的 `MouseDown` 和 `MouseUp` 事件，就像 [示例 11-16](#capturing_the_mouse)
    中的那样。
- en: Example 11-16\. Capturing the mouse
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-16\. 捕获鼠标
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `select` clause in [Example 11-15](#filtering_items_with_a_linq_query) works
    in Rx just like it does in LINQ to Objects, or with any other LINQ provider. It
    allows us to extract information from the source items to use as the output. In
    this case, `mouseMoves` is an observable sequence of `EventPattern<MouseEventArgs>`
    objects, but what I really want is an observable sequence of mouse locations.
    So the `select` clause in [Example 11-15](#filtering_items_with_a_linq_query)
    asks for the position relative to a particular UI element.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 11-15](#filtering_items_with_a_linq_query) 中的 `select` 子句在 Rx 中的工作方式与
    LINQ to Objects 中的工作方式相同，或者与任何其他 LINQ 提供程序一样。它允许我们从源项目中提取信息以用作输出。在这种情况下，`mouseMoves`
    是一个 `EventPattern<MouseEventArgs>` 对象的可观察序列，但我真正想要的是一个鼠标位置的可观察序列。因此，在 [示例 11-15](#filtering_items_with_a_linq_query)
    中的 `select` 子句要求相对于特定 UI 元素的位置。
- en: 'The upshot of this query is that `dragPositions` refers to an observable sequence
    of `Point` values, which will report each change of mouse position that occurs
    while a particular UI element in my application has captured the mouse. This is
    a hot source, because it represents something that’s happening live: mouse input.
    The LINQ filtering and projection operators do not change the nature of the source,
    so if you apply them to a hot source, the resulting query will also be hot, and
    if the source is cold, the filtered result will be too.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询的要点是，`dragPositions` 指的是一个 `Point` 值的可观察序列，它将报告每次发生鼠标位置变化的情况，而这发生在我的应用程序中某个特定
    UI 元素捕获鼠标时。这是一个热源，因为它代表着正在实时发生的事情：鼠标输入。LINQ 的过滤和投影操作符不会改变源的性质，因此如果你将它们应用于一个热源，得到的查询结果也将是热的，如果源是冷的，过滤后的结果也将是冷的。
- en: Warning
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Operators do not detect the hotness of the source. The `Where` and `Select`
    operators just pass this aspect straight through. Each time you subscribe to the
    final query produced by the `Select` operator, it will subscribe to its input.
    In this case, the input was the observable returned by the `Where` operator, which
    will in turn subscribe to the source produced by adapting the mouse move events.
    If you subscribe a second time, you’ll get a second chain of subscriptions. The
    hot event source will broadcast every event to both chains, so each item will
    go through the filtering and projection process twice. So be aware that attaching
    multiple subscribers to a complex query of a hot source will work but may incur
    unnecessary expense. If you need to do this, it may be better to call `Publish`
    on the query, which as you’ve seen, can make a single subscription to its input
    and then multicast each item to all its subscribers.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符不会检测源的热度。`Where`和`Select`运算符只是直接传递这个方面。每当你订阅由`Select`运算符生成的最终查询时，它将订阅它的输入。在本例中，输入是由`Where`运算符返回的可观察对象，它将依次订阅由适应鼠标移动事件产生的源。如果你第二次订阅，你将得到第二个订阅链。热事件源将把每个事件广播到这两个链，因此每个项目将通过过滤和投影过程两次。因此，请注意，将多个订阅者附加到热源的复杂查询可能会工作，但可能会带来不必要的开销。如果需要这样做，最好在查询上调用`Publish`，正如你所看到的，它可以对其输入进行单一订阅，然后将每个项目广播给所有订阅者。
- en: The final line of [Example 11-15](#filtering_items_with_a_linq_query) subscribes
    to the filtered and projected source and adds each `Point` value it produces to
    the `Points` collection of another UI element called `line`. That’s a `Polyline`
    element, not shown here,^([1](ch11.xhtml#CHP-11-FN-1)) and the upshot of this
    is that you can scrawl on the application’s window with the mouse. (If you’ve
    been doing Windows development for long enough, you may remember the Scribble
    examples—the effect here is much the same.)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 11-15](#filtering_items_with_a_linq_query)的最后一行订阅了过滤和投影后的源，并将其生成的每个`Point`值添加到另一个名为`line`的
    UI 元素的`Points`集合中。这是一个`Polyline`元素，这里没有显示，^([1](ch11.xhtml#CHP-11-FN-1))这样做的结果是你可以在应用程序窗口上用鼠标涂鸦。（如果你长时间进行过
    Windows 开发，你可能还记得 Scribble 示例，这里的效果大致相同。）'
- en: Rx provides most of the standard query operators described in [Chapter 10](ch10.xhtml#ch_linq).^([2](ch11.xhtml#CHP-11-FN-2))
    Most of these work in Rx exactly as they do with other LINQ implementations. However,
    some work in ways that may seem slightly surprising at first glance, as I will
    describe in the next few sections.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Rx 提供了大部分在[第 10 章](ch10.xhtml#ch_linq)中描述的标准查询运算符。^([2](ch11.xhtml#CHP-11-FN-2))这些运算符在
    Rx 中的工作方式与其他 LINQ 实现完全相同。然而，有些运算符的工作方式可能乍一看会稍有些令人惊讶，我将在接下来的几节中描述。
- en: Grouping Operators
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分组运算符
- en: 'The standard grouping operator, `GroupBy`, produces a sequence of sequences.
    With LINQ to Objects, it returns `IEnumerable<IGrouping<TKey, TSource>>`, and
    as you saw in [Chapter 10](ch10.xhtml#ch_linq), `IGrouping<TKey, TSource>` itself
    derives from `IEnumera⁠ble​<TSource>`. The `GroupJoin` is similar in concept:
    although it returns a plain `IEnumerable<T>`, that `T` is the result of a projection
    function that is passed a sequence as input. So, in either case, you get what
    is logically a sequence of sequences.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的分组运算符`GroupBy`生成一个序列的序列。在 LINQ to Objects 中，它返回`IEnumerable<IGrouping<TKey,
    TSource>>`，正如你在[第 10 章](ch10.xhtml#ch_linq)中看到的，`IGrouping<TKey, TSource>`本身从`IEnumerable<T>`派生而来。`GroupJoin`在概念上类似：虽然它返回一个普通的`IEnumerable<T>`，但`T`是一个投影函数的结果，该函数将序列作为输入。因此，在任一情况下，你得到的都是逻辑上的序列的序列。
- en: 'In the world of Rx, grouping produces an observable sequence of observable
    sequences. This is perfectly consistent but can seem a little surprising because
    Rx introduces a temporal aspect: the observable source that represents all the
    groups produces a new item (a new observable source) at the instant it discovers
    each new group. [Example 11-17](#grouping_events) illustrates this by watching
    for changes in the filesystem and then forming them into groups based on the folder
    in which each occurred. For each group, we get an `IGroupedObservable<TKey, TSource>`,
    which is the Rx equivalent of `IGrouping<TKey, TSource>`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rx 的世界中，分组会生成一个可观察序列的可观察序列。这是完全一致的，但可能会有些令人惊讶，因为 Rx 引入了时间方面：表示所有组的可观察源在发现每个新组时生成一个新项目（一个新的可观察源）。[示例 11-17](#grouping_events)通过监听文件系统中的变化并根据每个发生的文件夹形成组来说明这一点。对于每个组，我们得到一个`IGroupedObservable<TKey,
    TSource>`，这是`IGrouping<TKey, TSource>`的 Rx 等效物。
- en: Example 11-17\. Grouping events
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-17\. 事件分组
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The lambda that subscribes to the grouping source, `folders`, subscribes to
    each group that the source produces. The number of folders from which events could
    occur is endless, as new ones could be added while the program is running. So
    the `folders` observable will produce a new observable source each time it detects
    a change in a folder it hasn’t seen before, as [Figure 11-2](#grouping_iobservables)
    shows.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅到分组源 `folders` 的 lambda 订阅到源产生的每个组。事件可能来自的文件夹数量是无限的，因为在程序运行时可以添加新的文件夹。因此，当它检测到以前未见过的文件夹发生变化时，`folders`
    observable 将产生一个新的 observable 源，正如 [图 11-2](#grouping_iobservables) 所示。
- en: Notice that the production of a new group doesn’t mean that any previous groups
    are now complete, which is different than how we typically consume groups in LINQ
    to Objects. When you run a grouping query on an `IEnumerable<T>`, as it produces
    each group you can enumerate the contents entirely before moving on to the next
    one. But you can’t do that with Rx, because each group is represented as an observable,
    and observables aren’t finished until they tell you they’re complete—instead,
    each group subscription remains active. In [Example 11-17](#grouping_events),
    it’s entirely possible that a folder for which a group had already started will
    be dormant for a long time while activity occurs in other folders, only for it
    to start up again later. And more generally, Rx’s grouping operators have to be
    prepared for that to happen with any source.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 生产新组并不意味着任何先前的组现在已完成，这与我们通常在 LINQ to Objects 中消费组的方式不同。当你在 `IEnumerable<T>`
    上运行分组查询时，它会产生每个组，你可以在移动到下一个组之前完全枚举其内容。但在 Rx 中你做不到这一点，因为每个组被表示为一个 observable，而
    observables 直到它们告诉你它们完成之前都不算完成——相反，每个组的订阅保持活动状态。在 [示例 11-17](#grouping_events)
    中，一个已经开始的组对应的文件夹可能会在其他文件夹活动时长时间处于休眠状态，直到稍后重新启动。而且更一般地说，Rx 的分组操作符必须准备好处理任何源中发生这种情况的情况。
- en: '![Rx Group operator](assets/pc10_1102.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![Rx 分组操作符](assets/pc10_1102.png)'
- en: Figure 11-2\. Splitting an `IObservable<T>` into groups
  id: totrans-142
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-2\. 将 `IObservable<T>` 拆分为组
- en: Join Operators
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接操作符
- en: Rx provides the standard `Join` and `GroupJoin` operators. However, they work
    a bit differently than how LINQ to Objects or most database LINQ providers handle
    joins. In those worlds, items from two input sets are typically joined based on
    having some value in common.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Rx 提供了标准的 `Join` 和 `GroupJoin` 操作符。然而，它们与 LINQ to Objects 或大多数数据库 LINQ 提供者处理连接的方式略有不同。在这些世界中，两个输入集的项目通常基于具有一些共同值进行连接。
- en: In a database, a very common example when joining two tables would be to connect
    rows where a foreign key column in a row from one table has the same value as
    a primary key column in a row from the other table. However, Rx does not base
    joins on values. Instead, items are joined if they are contemporaneous—if their
    durations overlap, then they are joined.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中，当连接两个表时，一个非常常见的示例是连接具有相同值的一个表中行的外键列和另一个表中行的主键列。然而，Rx 并不是基于值进行连接。相反，如果它们的持续时间重叠，那么项目会被连接。
- en: 'But hang on a minute. What exactly is an item’s duration? Rx deals in instantaneous
    events; producing an item, reporting an error, and finishing a stream are all
    things that happen at a particular moment. So the join operators use a convention:
    for each source item, you can provide a function that returns an `IObservable<T>`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 不过稍等一下。一个项目的持续时间究竟是什么？Rx 处理瞬时事件；生成一个项目，报告一个错误以及完成一个流，都是发生在特定时刻的事情。因此，连接操作符使用一个约定：对于每个源项目，你可以提供一个返回
    `IObservable<T>` 的函数。
- en: The duration for that source item starts when the item is produced and finishes
    when the corresponding `IObservable<T>` first reacts (i.e., it either completes
    or generates an item or an error). [Figure 11-3](#defining_duration_with_an_iobservableltg)
    illustrates this idea. At the top is an observable source, beneath which is a
    series of sources that define each item’s duration. At the bottom, I’ve shown
    the duration that the per-item observables establish for their source items.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 该源项目的持续时间从其生成时开始，并在相应的 `IObservable<T>` 第一次响应时结束（即它完成或生成一个项目或错误）。[图 11-3](#defining_duration_with_an_iobservableltg)
    阐明了这个想法。顶部是一个 observable 源，在其下是一系列定义每个项目持续时间的源。底部展示了每个项目 observables 为其源项目建立的持续时间。
- en: '![](assets/pc10_1103.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/pc10_1103.png)'
- en: Figure 11-3\. Defining duration with an `IObservable<T>` for each source item
  id: totrans-149
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-3\. 为每个源项目使用 `IObservable<T>` 定义持续时间
- en: Although you can use a different `IObservable<T>` for each source item, as [Figure 11-3](#defining_duration_with_an_iobservableltg)
    shows, you don’t have to—it’s valid to use the same source every time. For example,
    if you apply the group operator to an `IObservable<T>` representing a stream of
    `MouseDown` events, and you then use another `IObservable<T>` representing a stream
    of `MouseUp` events to define the duration of each item, this would cause Rx to
    consider each `MouseDown` event’s “duration” to last until the next `MouseUp`
    event. [Figure 11-4](#defining_duration_with_a_pair_of_event) depicts this arrangement,
    and you can see that the effective duration of each `MouseDown` event, shown at
    the bottom, is delineated by a pair of `MouseDown` and `MouseUp` events.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以为每个源项目使用不同的 `IObservable<T>`，就像[Figure 11-3](#defining_duration_with_an_iobservableltg)展示的那样，但您并不需要这样做——每次使用相同的源也是有效的。例如，如果您将组操作应用于代表`MouseDown`事件流的`IObservable<T>`，然后再使用另一个代表`MouseUp`事件流的`IObservable<T>`来定义每个项目的持续时间，这将导致
    Rx 将每个`MouseDown`事件的“持续时间”视为持续到下一个`MouseUp`事件。图 [11-4](#defining_duration_with_a_pair_of_event)
    描述了这种安排，您可以看到在底部显示的每个`MouseDown`事件的有效持续时间由`MouseDown`和`MouseUp`事件对界定。
- en: '![](assets/pc10_1104.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/pc10_1104.png)'
- en: Figure 11-4\. Defining duration with a pair of event streams
  id: totrans-152
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-4\. 使用一对事件流定义持续时间
- en: A source can even define its own duration. For example, if you provide an observable
    source representing `MouseDown` events, you might want each item’s duration to
    end when the next item begins. This would mean that the items had contiguous durations—after
    the first item arrives, there is always exactly one current item, and it is the
    last one that occurred. [Figure 11-5](#adjacent_item_duration) illustrates this.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 源甚至可以定义自己的持续时间。例如，如果您提供一个表示`MouseDown`事件的可观察源，您可能希望每个项目的持续时间在下一个项目开始时结束。这意味着项目具有连续的持续时间——在第一个项目到达后，总是有一个当前项目，它是最后发生的项目。图
    [11-5](#adjacent_item_duration) 阐明了这一点。
- en: '![](assets/pc10_1105.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/pc10_1105.png)'
- en: Figure 11-5\. Adjacent item duration
  id: totrans-155
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-5\. 相邻项目持续时间
- en: Item durations are allowed to overlap. If you wanted to, you could supply a
    duration-defining `IObservable<T>` that indicated that an input item’s duration
    finishes some time after the next item begins.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的持续时间可以重叠。如果您愿意，您可以提供一个定义持续时间的`IObservable<T>`，表明输入项目的持续时间在下一个项目开始后一段时间结束。
- en: Now that we know how Rx decides what constitutes an item’s duration for the
    purposes of a join, how does it use that information? Remember, join operators
    combine two inputs. (The duration-defining sources do not count as an input. They
    provide additional information about one of the inputs.) Rx considers a pair of
    items from the two input streams to be related if their durations overlap. The
    way it presents related items in the output depends on whether you use the `Join`
    or the `GroupJoin` operator. The `Join` operator’s output is a stream containing
    one item for each pair of related items. (You provide a projection function that
    will be passed each pair, and it’s up to you what to do with them. This function
    gets to decide the output item type for the joined stream.) [Figure 11-6](#join_operator)
    shows two input streams based on the events `MouseDown` and `MouseMove` (with
    durations defined by `MouseUp` and `MouseMove`, respectively). These are similar
    to the sources in Figures [11-4](#defining_duration_with_a_pair_of_event) and
    [11-5](#adjacent_item_duration), but I’ve added letters and numbers to make it
    easier to refer to each of the items in these streams. At the bottom of the diagram
    is the observable the `Join` operator would produce for these two streams.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道 Rx 如何决定一个项目的持续时间以进行连接，那么它如何使用这些信息呢？请记住，连接运算符结合了两个输入。（定义持续时间的源不算是输入。它们提供有关其中一个输入的额外信息。）Rx
    认为来自两个输入流的项目对是相关的，如果它们的持续时间重叠。它展示相关项目的方式取决于您是使用`Join`还是`GroupJoin`运算符。`Join`运算符的输出是一个包含每对相关项目的流。（您提供一个投影函数，该函数将传递每对项目，并由您决定如何处理它们。这个函数决定连接流的输出项目类型。）[Figure 11-6](#join_operator)
    展示了基于事件`MouseDown`和`MouseMove`的两个输入流（分别由`MouseUp`和`MouseMove`定义持续时间）。这与图示中的源类似于图
    [11-4](#defining_duration_with_a_pair_of_event) 和 [11-5](#adjacent_item_duration)，但我添加了字母和数字，以便更容易引用每个流中的每个项目。在图的底部是`Join`运算符将为这两个流产生的可观察对象。
- en: '![](assets/pc10_1106.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/pc10_1106.png)'
- en: Figure 11-6\. `Join` operator
  id: totrans-159
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-6\. `Join` 运算符
- en: As you can see, any place where the durations of two items from the input streams
    overlap, we get an output item combining the two inputs. If the overlapping items
    started at different times (which will normally be the case), the output item
    is produced whenever the later of the two inputs started. The `MouseDown` event
    `A` starts before the `MouseMove` event `1`, so the resulting output, `A1`, occurs
    where the overlap begins (i.e., when `MouseMove` event `1` occurs). But event
    `3` occurs before event `B`, so the joined output `B3` occurs when `B` starts.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，任何两个输入流项目的持续时间重叠的地方，我们都会得到一个结合两个输入的输出项目。如果重叠的项目在不同的时间开始（这通常是情况），则输出项目将在两个输入中后开始的时间产生。`MouseDown`事件`A`在`MouseMove`事件`1`之前开始，因此结果输出`A1`发生在重叠开始时（即`MouseMove`事件`1`发生时）。但事件`3`在事件`B`之前发生，因此连接的输出`B3`发生在`B`开始时。
- en: Event `5`’s duration does not overlap with any `MouseDown` items’ durations,
    so we do not see any items for that in the output stream. Conversely, it would
    be possible for a `MouseMove` event to appear in multiple output items (just like
    each `MouseDown` event does). If there had been no `3` event, event `2` would
    have a duration that started inside `A` and finished inside `B`, so as well as
    the `A2` shown in [Figure 11-6](#join_operator), there would be a `B2` event at
    the same time as `B` starts.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 事件`5`的持续时间不与任何`MouseDown`项的持续时间重叠，因此在输出流中看不到任何该项。相反，`MouseMove`事件可能会出现在多个输出项目中（就像每个`MouseDown`事件一样）。如果没有`3`事件，事件`2`的持续时间会从`A`内部开始，并在`B`内部完成，因此除了[图 11-6](#join_operator)中显示的`A2`外，还会在`B`开始时出现`B2`事件。
- en: '[Example 11-18](#query_expression_with_join) shows code that performs the join
    illustrated in [Figure 11-6](#join_operator), using a query expression. As you
    saw in [Chapter 10](ch10.xhtml#ch_linq), the compiler turns query expressions
    into a series of method calls, and [Example 11-19](#join_in_code) shows the method-based
    equivalent of the query in [Example 11-18](#query_expression_with_join).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[Example 11-18](#query_expression_with_join)显示了执行[图 11-6](#join_operator)中所示的连接的代码，使用查询表达式。正如您在[第 10
    章](ch10.xhtml#ch_linq)中看到的，编译器会将查询表达式转换为一系列方法调用，而[Example 11-19](#join_in_code)显示了与[Example 11-18](#query_expression_with_join)中查询的基于方法的等效形式。'
- en: Example 11-18\. Query expression with join
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 11-18\. 使用连接进行查询表达式
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Example 11-19\. Join in code
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 11-19\. 加入代码
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can use the `dragPositions` observable source produced by either of these
    examples to replace the one in [Example 11-15](#filtering_items_with_a_linq_query).
    We no longer need to filter based on whether the `background` element has captured
    the mouse, because Rx is now providing us only move events whose duration overlaps
    with the duration of a mouse down event. Any moves that happen in between mouse
    presses will either be ignored or, if they are the last move to occur before a
    mouse down, we’ll receive that position at the moment the mouse button is pressed.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用任何这些示例生成的`dragPositions`可观察源来替换[Example 11-15](#filtering_items_with_a_linq_query)中的源。我们不再需要基于`background`元素是否捕获鼠标来进行过滤，因为现在
    Rx 仅为我们提供了持续时间与鼠标按下事件重叠的移动事件。发生在鼠标按下之间的任何移动都将被忽略，或者如果它们是最后一次在鼠标按下之前发生的移动，则在鼠标按钮按下的瞬间我们将接收到该位置。
- en: '`GroupJoin` combines items in a similar way, but instead of producing a single
    observable output, it produces an observable of observables. For the present example,
    that would mean that its output would produce a new observable source for each
    `MouseDown` input. This would consist of all the pairs containing that input,
    and it would have the same duration as that input. [Figure 11-7](#groupjoin_operator-id1)
    shows this operator in action with the same input events as [Figure 11-6](#join_operator).
    I’ve put vertical bars on the ends of the output sequences to clarify when they
    will call their observers’ `OnComplete` methods. The start and finish of these
    observables align exactly with the duration of the corresponding input, so there
    is often a significant gap between when they produce their final output item and
    when they complete.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`GroupJoin`以类似的方式组合项目，但不是生成单个可观察输出，而是生成一个可观察的可观察对象。对于当前的示例，这意味着其输出会为每个`MouseDown`输入生成一个新的可观察源。这将包含包含该输入的所有配对，并且它的持续时间与该输入相同。[图 11-7](#groupjoin_operator-id1)显示了此运算符与与[图 11-6](#join_operator)相同的输入事件的运行情况。我在输出序列的端点放置了竖线，以澄清它们何时调用其观察者的`OnComplete`方法。这些可观察对象的起始和结束与相应输入的持续时间完全对齐，因此它们产生其最终输出项目和完成时间之间通常存在显著差异。'
- en: '![](assets/pc10_1107.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/pc10_1107.png)'
- en: Figure 11-7\. `GroupJoin` operator
  id: totrans-170
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-7\. `GroupJoin`运算符
- en: In general, with LINQ, the `GroupJoin` operator is able to produce empty groups,
    so unlike the `Join` operator, there will be one output for each item from the
    first input even if there are no corresponding items from the other stream. The
    Rx `GroupJoin` works the same way, adding in a temporal aspect. Each output group
    starts at the same moment the corresponding input event happens (`MouseDown`,
    in this example) and ends when that event is deemed to have finished (at the next
    `MouseUp` here); if there were no moves in that time, that observable will generate
    no items. Since move event durations are contiguous here, that could happen only
    before receiving the first move. But in joins where the second input’s items have
    noncontiguous durations, empty groups are more likely.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，使用LINQ，`GroupJoin`运算符能够产生空组，因此与`Join`运算符不同，即使第二个流中没有相应的项目，每个来自第一个输入的项目也会产生一个输出。Rx的`GroupJoin`也是这样工作的，增加了时间方面的考虑。每个输出组从相应的输入事件发生时开始（在本例中为`MouseDown`），并在该事件被认为已经结束时结束（这里是下一个`MouseUp`）；如果在此期间没有移动，该可观察对象将不会生成任何项目。因为这里的移动事件持续连续，这只能在接收到第一个移动之前发生。但在第二个输入项目具有不连续持续时间的连接中，空组更有可能发生。
- en: In the context of my example application that allows the user to scribble in
    a window with the mouse, this grouped output is useful, because it presents each
    individual drag as a separate object. This means I could create a new line for
    each drag, rather than adding points onto the same increasingly long line. With
    the code in [Example 11-15](#filtering_items_with_a_linq_query), each new drag
    operation will draw a line from wherever the previous drag finished to the new
    location, making it impossible to draw separate shapes. But grouped output makes
    separation easy. [Example 11-20](#adding_a_new_line_for_each_drag_operatio) subscribes
    to the grouped output, and for each new group (which represents a new drag operation),
    it creates a new `Polyline` to render the scribble and then subscribes to the
    items in the group to populate that individual line.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在允许用户用鼠标在窗口中涂鸦的示例应用程序背景下，这种分组输出非常有用，因为它将每个单独的拖动呈现为一个独立的对象。这意味着我可以为每次拖动创建一条新线，而不是将点添加到越来越长的同一线上。使用[示例 11-15](#filtering_items_with_a_linq_query)中的代码，每次新的拖动操作将从上一个拖动结束的地方到新位置画一条线，这样就无法绘制出分离的形状。但是分组输出使得分离变得容易。[示例 11-20](#adding_a_new_line_for_each_drag_operatio)订阅分组输出，并为每个新组（代表一个新的拖动操作）创建一个新的`Polyline`来渲染涂鸦，然后订阅组中的项目以填充该单独的线条。
- en: Example 11-20\. Adding a new line for each drag operation
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-20\. 为每次拖动操作添加新线
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Just to be clear, all of this works in real time even with a join operator—these
    are all hot sources. The `IObservable<IObservable<Point>>` returned by `GroupJoin`
    in [Example 11-20](#adding_a_new_line_for_each_drag_operatio) will produce a new
    group the instant the mouse button is pressed. The `IObservable<Point>` from that
    group will produce a new `Point` immediately for each `MouseMove` event. The upshot
    is that the user sees the line appear and grow instantly when dragging the mouse.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 仅需明确，所有这些即使在连接运算符下也可以实时运行 - 这些都是热源。在[示例 11-20](#adding_a_new_line_for_each_drag_operatio)中由`GroupJoin`返回的`IObservable<IObservable<Point>>`会在按下鼠标按钮时立即产生一个新组。该组中的`IObservable<Point>`将会为每个`MouseMove`事件立即产生一个新的`Point`。总之，当用户拖动鼠标时，用户会立即看到直线出现并增长。
- en: SelectMany Operator
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`SelectMany`运算符'
- en: As you saw in [Chapter 10](ch10.xhtml#ch_linq), the `SelectMany` operator effectively
    flattens a collection of collections into a single one. This operator gets used
    when a query expression has multiple `from` clauses, and with LINQ to Objects,
    its operation is similar to having nested `foreach` loops. With Rx, it still has
    this flattening effect—it lets you take an observable source where each item it
    produces is also an observable source (or can be used to generate one), and the
    result of the `SelectMany` operator will be a single observable sequence that
    contains all of the items from all of the child sources. However, as with grouping,
    things may be less orderly than in LINQ to Objects. The push-driven nature of
    Rx, with its potential for asynchronous operation, makes it possible for all of
    the observable sources involved to be pushing new items at once, including the
    original source that is used as a source of nested sources. (The operator still
    ensures that only one event will be delivered at a time—when it calls on `OnNext`,
    it waits for that to return before making another call. The potential for chaos
    only goes as far as mixing up the order in which events are delivered.)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第 10 章](ch10.xhtml#ch_linq)中所看到的，`SelectMany` 操作符有效地将集合的集合展平为单个集合。当查询表达式具有多个`from`子句时，将使用此操作符，在
    LINQ to Objects 中，其操作类似于嵌套的`foreach`循环。在 Rx 中，它仍然具有这种展平效果 - 它允许你获取一个可观察的源，其中每个生成的项目也是一个可观察的源（或者可以用来生成一个），`SelectMany`
    操作符的结果将是一个包含所有子源中所有项目的单个可观察序列。然而，与分组一样，在 LINQ to Objects 中，情况可能不那么有序。Rx 的推送驱动特性，以及其潜在的异步操作，使得所有涉及的可观察源都有可能同时推送新项目，包括用作嵌套源的原始源。（该操作符仍然确保一次只传递一个事件
    - 当调用`OnNext`时，它会等待返回后再进行下一个调用。混乱的可能性仅限于事件传递的顺序混乱。）
- en: When you use LINQ to Objects to iterate through a jagged array, everything happens
    in a straightforward order. It will retrieve the first nested array and then iterate
    through all the elements in that array before moving to the next nested array
    and iterating through that, and so on. But this orderly flattening occurs only
    because with `IEnumerable<T>`, the consumer of items is in control of when to
    retrieve which items. With Rx, subscribers receive items when sources provide
    them.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 LINQ to Objects 遍历嵌套数组时，一切都按照直观的顺序进行。它会检索第一个嵌套数组，然后遍历该数组中的所有元素，然后转到下一个嵌套数组，并遍历该数组，依此类推。但是，这种有序的展平仅因为使用`IEnumerable<T>`时，项目的消费者可以控制何时检索哪些项目。使用
    Rx 时，订阅者在源提供项目时接收它们。
- en: 'Despite the free-for-all, the behavior is straightforward enough: the output
    stream produced by `SelectMany` just provides items as and when the sources provide
    them.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有这种自由度，行为还是足够直接的：由`SelectMany`产生的输出流只是在源提供它们时提供项目。
- en: Aggregation and Other Single-Value Operators
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚合和其他单值操作符
- en: Several of the standard LINQ operators reduce an entire sequence of values to
    a single value. These include the aggregation operators, such as `Min`, `Sum`,
    and `Aggregate`; the quantifiers `Any` and `All`; and the `Count` operator. It
    also includes selective operators, such as `ElementAt`. These are available in
    Rx, but unlike most LINQ implementations, the Rx implementations do not return
    plain single values. They all return an `IObservable<T>`, just like operators
    that produce sequences as outputs.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 几个标准的 LINQ 操作符将整个值序列减少为单个值。这些包括聚合操作符，如`Min`，`Sum`和`Aggregate`；量词符`Any`和`All`；以及`Count`操作符。它还包括选择性操作符，如`ElementAt`。这些在
    Rx 中也是可用的，但与大多数 LINQ 实现不同，Rx 实现不会返回普通的单个值。它们都返回一个`IObservable<T>`，就像产生序列输出的操作符一样。
- en: Note
  id: totrans-182
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `First`, `Last`, `FirstOrDefault`, `LastOrDefault`, `Single`, and `SingleOrDefault`
    operators should all work the same way, but for historical reasons, they do not.
    Introduced in v1 of Rx, they returned single values that were not wrapped in an
    `IObserva⁠ble​<T>`, which meant they would block until the source provided what
    they needed. This doesn’t fit well with a push-based model and risks introducing
    deadlock, so these are now deprecated, and there are new asynchronous versions
    that work the same way as the other single-value operators in Rx. These all just
    append `Async` to the original operators’ names (e.g., `FirstAsync`, `LastAsync`,
    etc.).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`First`、`Last`、`FirstOrDefault`、`LastOrDefault`、`Single` 和 `SingleOrDefault`
    操作符应该都是以相同的方式工作，但出于历史原因，它们并非如此。在 Rx 的 v1 中引入，它们返回的单个值并不包装在`IObserva⁠ble​<T>`中，这意味着它们会阻塞直到源提供所需的内容。这与推送模型不太匹配，并且可能导致死锁，因此这些操作符现在已被弃用，并且有了新的异步版本，工作方式与
    Rx 中的其他单值操作符相同。所有这些操作符的新版本只需在原始操作符名称后附加`Async`即可（例如`FirstAsync`、`LastAsync`等）。'
- en: Each of these operators still produces a single value, but they all present
    that value as an observable source. The reason is that unlike LINQ to Objects,
    Rx cannot enumerate its input to calculate the aggregate value or to find the
    value being selected. The source is in control, so the Rx versions of these operators
    have to wait for the source to provide its values—like all operators, the single-value
    operators have to be reactive, not proactive. Operators that need to see every
    value, such as `Average`, cannot produce their result until the source says it
    has finished. Even an operator that doesn’t need to wait until the very end of
    the input, such as `FirstAsync` or `ElementAt`, still cannot do anything until
    the source decides to provide the value the operator is waiting for. As soon as
    a single-value operator is able to provide a value, it does so and then completes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作符每个仍然产生单个值，但它们都将该值呈现为可观察源。原因是与 LINQ to Objects 不同，Rx 不能枚举其输入以计算聚合值或查找所选值。源控制着流程，因此这些操作符的
    Rx 版本必须等待源提供其值——就像所有操作符一样，单值操作符必须是被动反应的，而不是主动的。诸如`Average`这样需要看到每个值的操作符，在源表示已完成之前，不能生成其结果。即使像`FirstAsync`或`ElementAt`这样不需要等待输入的末尾的操作符，也要等到源决定提供操作符正在等待的值之前才能执行任何操作。一旦单值操作符能够提供值，它就会这样做，然后完成。
- en: The `ToArray`, `ToList`, `ToDictionary`, and `ToLookup` operators work in a
    similar way. Although these all produce the entire contents of the source, they
    do so as a single output object, which is wrapped as a single-item observable
    source.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToArray`、`ToList`、`ToDictionary` 和 `ToLookup` 操作符的工作方式类似。虽然它们都生成源的全部内容，但作为单个输出对象，被包装为单项可观察源。'
- en: If you really want to sit and wait for the value of any of these items, you
    can use the `Wait` operator, a nonstandard operator specific to Rx available on
    any `IObserva⁠ble​<T>`. This blocking operator waits for the source to complete
    and then returns the final element, so the “sit and wait” behavior of the deprecated
    `First`, `Last`, etc., operators is still available; it’s just no longer the default.
    Alternatively, you can use C#’s asynchronous language features—you can give the
    `await` keyword an observable source. Logically, it does the same thing as `Wait`,
    but it does so with an efficient nonblocking asynchronous wait of the kind described
    in [Chapter 17](ch17.xhtml#ch_asynchronous_language_features).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的想等待任何这些项的值，可以使用`Wait`操作符，这是 Rx 中的一个非标准操作符，适用于任何`IObserva⁠ble​<T>`。这个阻塞操作符等待源完成，然后返回最终元素，因此弃用的`First`、`Last`等操作符的“等待”行为仍然可用；只是不再是默认行为了。或者，你可以使用
    C# 的异步语言特性——将`await`关键字用于可观察源。从逻辑上讲，它与`Wait`做的事情是一样的，但它是通过高效的非阻塞异步等待实现的，这种等待方式在
    [第17章](ch17.xhtml#ch_asynchronous_language_features) 中有描述。
- en: Concat Operator
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Concat 操作符
- en: 'Rx’s `Concat` operator shares the same concept as other LINQ implementations:
    it combines two input sequences to produce a sequence that will produce every
    item in its first input, followed by every item in its second input. (In fact,
    Rx goes further than some LINQ providers and can accept a collection of inputs
    and will concatenate them all.) This is useful only if the first stream eventually
    completes—that’s true in LINQ to Objects too, of course, but infinite sources
    are more common in Rx. Also, be aware that this operator does not subscribe to
    the second stream until the first has finished. This is because cold streams typically
    start producing items when you subscribe, and the `Concat` operator does not want
    to have to buffer the second source’s items while it waits for the first to complete.
    This means that `Concat` may produce nondeterministic results when used with hot
    sources. (If you want an observable source that contains all the items from two
    hot sources, use `Merge`, which I’ll describe shortly.)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Rx 的 `Concat` 操作符与其他 LINQ 实现共享相同的概念：它将两个输入序列组合起来，生成一个序列，该序列首先生成其第一个输入的每个项，然后生成其第二个输入的每个项。
    （事实上，Rx 比一些 LINQ 提供程序更进一步，可以接受一组输入，并将它们全部连接起来。）只有在第一个流最终完成时，这才有用 — 当然，在 LINQ to
    Objects 中也是如此，但在 Rx 中无限源更为常见。此外，请注意，此操作符在第一个流完成之前不会订阅第二个流。这是因为冷流通常在订阅时开始生成项，并且
    `Concat` 操作符不希望在等待第一个流完成时缓冲第二个源的项。这意味着在与热源一起使用时，`Concat` 可能会产生非确定性结果。（如果你想要一个包含来自两个热源的所有项的可观察源，请使用
    `Merge`，我马上会描述。）
- en: Rx is not satisfied with merely providing standard LINQ operators. It defines
    many more of its own operators.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Rx 并不仅仅满足于提供标准的 LINQ 操作符。它定义了更多自己的操作符。
- en: Rx Query Operators
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rx 查询操作符
- en: One of Rx’s main goals is to simplify working with multiple potentially independent
    observable sources that produce items asynchronously. Rx’s designers sometimes
    refer to “orchestration and synchronization,” meaning that your system may have
    many things going on at once but that you need to achieve some kind of coherency
    in how your application reacts to events. Many of Rx’s operators are designed
    with this goal in mind.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Rx 的主要目标之一是简化与多个潜在独立的异步产生项的可观察源的工作。Rx 的设计者有时候会提到“编排和同步”，意思是你的系统可能同时进行许多事情，但你需要确保应用程序对事件的反应是某种程度上协调一致的。Rx
    的许多操作符都是基于这个目标设计的。
- en: Note
  id: totrans-192
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Not everything in this section is driven by the unique requirements of Rx. A
    few of Rx’s nonstandard operators (e.g., `Scan`) would make perfect sense in other
    LINQ providers. And versions of many of these are available for `IEnumerable<T>`
    in the Interactive Extensions for .NET (Ix), which, as mentioned earlier, are
    to be found in the `System.Interactive` NuGet package.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 并非本节的所有内容都是由 Rx 的独特要求驱动的。Rx 的一些非标准操作符（例如 `Scan`）在其他 LINQ 提供程序中也是非常合理的。并且这些操作的许多版本在
    .NET 的交互扩展（Ix）中也有提供，可以在 `System.Interactive` NuGet 包中找到，正如前面提到的。
- en: Rx has such a large repertoire of operators that to do them all justice would
    roughly quadruple the size of this chapter, which is already on the long side.
    Since this is not a book about Rx, and because some of the operators are very
    specialized, I will just pick some of the most useful. I recommend browsing through
    the Rx documentation or [the source](https://github.com/dotnet/reactive) to discover
    the full and remarkably comprehensive set of operators it provides.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Rx 拥有如此丰富的操作符库，以至于要对它们全都公正地介绍将会使本章的长度大致增加四倍，而本章已经偏长了。由于这不是一本关于 Rx 的书籍，并且因为一些操作符非常专业化，我只会挑选一些最有用的来介绍。我建议浏览
    Rx 的文档或者 [源代码](https://github.com/dotnet/reactive) 来探索它所提供的完整和非常全面的操作符集合。
- en: Merge
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并
- en: The `Merge` operator combines all of the elements from two or more observable
    sequences into a single observable sequence. I can use this to fix a problem that
    occurs in Examples [11-15](#filtering_items_with_a_linq_query), [11-18](#query_expression_with_join),
    and [11-20](#adding_a_new_line_for_each_drag_operatio). These all process mouse
    input, and if you’ve done much Windows UI programming, you know that you will
    not necessarily get a mouse move notification corresponding to the points at which
    the mouse button was pressed and released. The notifications for these button
    events include mouse location information, so Windows sees no need to send a separate
    mouse move message providing these locations, because it would just be sending
    you the same information twice. This is perfectly logical, and also rather annoying.^([3](ch11.xhtml#CHP-11-FN-3))
    These start and end locations are not in the observable source that represents
    mouse positions in those examples. I can fix that by merging in the positions
    from all three events. [Example 11-21](#merging_observables) shows how to fix
    [Example 11-15](#filtering_items_with_a_linq_query).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`Merge` 操作符将两个或多个可观察序列中的所有元素合并为一个单一的可观察序列。我可以使用它来解决在示例 [11-15](#filtering_items_with_a_linq_query)、[11-18](#query_expression_with_join)
    和 [11-20](#adding_a_new_line_for_each_drag_operatio) 中出现的问题。这些示例都处理鼠标输入，如果你在 Windows
    UI 编程中做了很多工作，你会知道并不一定会得到与按下和释放鼠标按钮对应的鼠标移动通知。这些按钮事件的通知包含鼠标位置信息，因此 Windows 没有必要发送单独的鼠标移动消息来提供这些位置，因为这只会将相同的信息发送两次。这是完全合理的，但也相当恼人。^([3](ch11.xhtml#CHP-11-FN-3))
    在这些示例中，起始和结束位置不在表示鼠标位置的可观察源中。我可以通过合并所有三个事件的位置来解决这个问题。[示例 11-21](#merging_observables)
    展示了如何修复 [示例 11-15](#filtering_items_with_a_linq_query)。'
- en: Example 11-21\. Merging observables
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-21\. 合并可观察对象
- en: '[PRE21]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'I’ve created three observables to represent the three relevant events: `MouseDown`,
    `MouseUp`, and `MouseMove`. Since all three of these need to share the same projection
    (the `select` clause), but only one needs to filter events, I’ve restructured
    things a bit. Only mouse moves need filtering, so I’ve written a separate query
    for that. I’ve then used the `Observable.Merge` method to combine all three event
    streams into one.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经创建了三个可观察对象来表示三个相关事件：`MouseDown`、`MouseUp` 和 `MouseMove`。因为这三个事件都需要共享同一个投影（`select`
    子句），但只有一个需要过滤事件，所以我稍微重构了一下。只有鼠标移动需要过滤，所以我为此编写了单独的查询。然后我使用了 `Observable.Merge`
    方法将所有三个事件流合并为一个。
- en: Note
  id: totrans-200
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`Merge` is available both as an extension method and a nonextension `static`
    method. If you use the extension methods available on a single observable, the
    only `Merge` overloads available combine it with a single other source (optionally
    specifying a scheduler). In this case, I had three sources, which is why I used
    the nonextension method form. However, if you have an expression that is either
    an enumerable of observable sources or an observable source of observable sources,
    you’ll find that there are also `Merge` extension methods for these. So I could
    have written `new[] { downs, ups, dragMoves }.Merge()`.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`Merge` 既可以作为扩展方法使用，也可以作为非扩展的 `static` 方法使用。如果你在单个可观察对象上使用可用的扩展方法，那么唯一可用的 `Merge`
    重载是将其与单个其他源合并（可选指定调度程序）。在这种情况下，我有三个源，所以我使用了非扩展方法形式。然而，如果你有一个表达式，它是一个可观察源的可枚举或一个可观察源的可观察源，你会发现这些情况下也有
    `Merge` 扩展方法。因此，我本可以写成 `new[] { downs, ups, dragMoves }.Merge()`。'
- en: My `allDragPositionEvents` variable refers to a single observable stream that
    will report all the mouse moves I need. Finally, I run this through a projection
    to extract the mouse position for each item. Again, the result is a hot stream.
    As before, it will produce a position any time the mouse moves while the `background`
    element has captured the mouse, but it will also produce a position each time
    either the `MouseDown` or `MouseUp` event occurs. I could subscribe to this with
    the same call shown in the final line of [Example 11-15](#filtering_items_with_a_linq_query)
    to keep my UI up to date, and this time, I wouldn’t be missing the start and end
    positions.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我的 `allDragPositionEvents` 变量指的是一个单一的可观察流，将报告我所需的所有鼠标移动。最后，我通过投影运行这些数据，以提取每个项目的鼠标位置。同样，结果是一个热流。与之前一样，只要
    `background` 元素捕获了鼠标，它就会在鼠标移动时生成一个位置，但同时也会在 `MouseDown` 或 `MouseUp` 事件发生时生成一个位置。我可以使用与
    [示例 11-15](#filtering_items_with_a_linq_query) 最后一行显示的相同调用订阅此事件，这次我不会错过起始和结束位置。
- en: In the example I’ve just shown, the sources are all endless, but that will not
    always be the case. What should a merged observable do when one of its inputs
    stops? If one stops due to an error, that error will be passed on by the merged
    observable, at which point it will be complete—an observable is not allowed to
    continue producing items after reporting an error. However, although an input
    can unilaterally terminate the output with an error, if inputs complete normally,
    the merged observable doesn’t complete until all of its inputs are complete.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在我刚刚展示的例子中，所有源都是无限的，但并非总是如此。当其中一个输入停止时，合并的可观察应该怎么做？如果其中一个因错误而停止，该错误将通过合并的可观察传递，此时它将变为完成状态—在报告错误后，可观察的对象不允许继续生成项。然而，虽然输入可以单方面地通过错误终止输出，但如果输入正常完成，直到所有输入都完成，合并的可观察才会完成。
- en: Windowing Operators
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 窗口操作符
- en: Rx defines two operators, `Buffer` and `Window`, that both produce an observable
    output where each item is based on multiple adjacent items from the source. (The
    name `Window` has nothing to do with UIs, by the way.) [Figure 11-8](#sliding_windows_with_the_buffer_operator)
    shows three ways in which you could use the `Buffer` operator. I’ve numbered the
    circles representing items in the input, and below this are blobs representing
    the items that will emerge from the observable source produced by `Buffer`, with
    lines and numbers indicating which input items are associated with each output
    item. `Window` works in a very similar way, as you’ll see shortly.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Rx 定义了两个操作符，`Buffer` 和 `Window`，它们都生成一个可观察的输出，其中每个项基于源中的多个相邻项。（顺便说一句，`Window`
    的名称与 UI 无关。）[Figure 11-8](#sliding_windows_with_the_buffer_operator) 展示了使用 `Buffer`
    操作符的三种方式。我已经标记了代表输入项的圆圈，并在其下方展示了代表由 `Buffer` 产生的可观察源的项的形状和数字，其中线条和数字表示与每个输出项相关联的输入项。很快你会看到，`Window`
    的工作方式非常相似。
- en: '![](assets/pc10_1108.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/pc10_1108.png)'
- en: Figure 11-8\. Sliding windows with the `Buffer` operator
  id: totrans-207
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-8\. 使用`Buffer`操作符的滑动窗口
- en: In the first case, I’ve passed arguments of `(2, 2)`, indicating that I want
    each output item to correspond to two input items and that I want to start a new
    buffer on every second input item. That may sound like two different ways of saying
    the same thing until you look at the second example in [Figure 11-8](#sliding_windows_with_the_buffer_operator),
    in which arguments of `(3, 2)` indicate that each output item corresponds to three
    items from the input, but I still want the buffers to begin on every other input.
    This means that each *window*—the set of items from the input used to build an
    output item—overlaps with its neighbors. This will happen whenever the second
    argument, the *skip*, is smaller than the window. The first output item’s window
    contains the first, second, and third input. The second output’s window contains
    the third, fourth, and fifth, so the third item appears in both.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个案例中，我传递了 `(2, 2)` 的参数，表明我希望每个输出项对应于两个输入项，并且我希望在每第二个输入项上启动一个新的缓冲区。这听起来像是用两种不同的方式说同一件事情，直到你看到
    [Figure 11-8](#sliding_windows_with_the_buffer_operator) 中的第二个例子，在这个例子中，`(3, 2)`
    的参数表明每个输出项对应于输入的三个项，但我仍然希望在每第二个输入上开始缓冲。这意味着每个*窗口*—用于构建输出项的输入项集合—与其邻居重叠。当第二个参数，*跳过*，小于窗口大小时，这种情况将发生。第一个输出项的窗口包含第一个、第二和第三个输入。第二个输出项的窗口包含第三、第四和第五个，因此第三个项出现在两者中。
- en: The final example in the figure shows a window size of three, but this time
    I’ve asked for a skip size of one—so in this case, the window moves along by only
    one input item at a time, but it incorporates three items from the source each
    time. I could also specify a skip that is larger than the window, in which case
    the input items that fell between windows would simply be ignored.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的最后一个示例显示了窗口大小为三，但这次我要求跳过一个大小为一的间隔—因此，在这种情况下，窗口每次只移动一个输入项，但每次都包含源中的三个项。我也可以指定一个大于窗口的跳过大小，在这种情况下，落在窗口之间的输入项将被简单地忽略。
- en: The `Buffer` and `Window` operators tend to introduce a lag. In the second and
    third cases, the window size of three means that the input observable needs to
    produce its third value before the whole window can be provided for the output
    item. With `Buffer`, this always means a delay of the size of the window, but
    as you’ll see, with the `Window` operator, each window can get under way before
    it is full.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`Buffer` 和 `Window` 操作符往往会引入一定的延迟。在第二和第三种情况下，窗口大小为三意味着输入可观测对象需要生成其第三个值，然后才能为输出项提供整个窗口。对于
    `Buffer` 来说，这总是意味着窗口大小的延迟，但正如你将看到的那样，使用 `Window` 操作符时，每个窗口在完全填充之前就可以开始处理。'
- en: Note
  id: totrans-211
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`Buffer` offers an overload that takes a single number, which has the same
    effect as passing the same number twice. (E.g., instead of `Buffer(2, 2)`, you
    could write just `Buffer(2)`.) This is logically equivalent to LINQ to Objects’
    `Chunk` operator. As discussed in [Chapter 10](ch10.xhtml#ch_linq), the main reason
    Rx didn’t use the same name is that Rx invented `Buffer` about a decade before
    LINQ to Objects added `Chunk`.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`Buffer` 还提供了一个重载，接受一个数字，其效果与两次传递相同数字相同。 （例如，而不是 `Buffer(2, 2)`，你可以简单地写成 `Buffer(2)`。）这在逻辑上等同于
    LINQ to Objects 的 `Chunk` 操作符。正如 [第 10 章](ch10.xhtml#ch_linq) 中讨论的那样，Rx 没有使用相同的名称的主要原因是，Rx
    在大约十年前发明了 `Buffer`，而 LINQ to Objects 添加了 `Chunk`。'
- en: The difference between the `Buffer` and `Window` operators is the way in which
    they present the windowed items. `Buffer` is the most straightforward. It provides
    an `IObservable<IList<T>>`, where `T` is the input item type. In other words,
    if you subscribe to the output of `Buffer`, for each window produced, your subscriber
    will be passed a list containing all the items in the window. [Example 11-22](#smoothing_input_with_buffer)
    uses this to produce a smoothed-out version of the mouse locations from [Example 11-15](#filtering_items_with_a_linq_query).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`Buffer` 和 `Window` 操作符之间的区别在于它们呈现窗口化项的方式。`Buffer` 是最直接的。它提供一个 `IObservable<IList<T>>`，其中
    `T` 是输入项的类型。换句话说，如果你订阅 `Buffer` 的输出，对于每个生成的窗口，订阅者将收到一个包含窗口中所有项的列表。 [示例 11-22](#smoothing_input_with_buffer)
    使用此方法生成了来自 [示例 11-15](#filtering_items_with_a_linq_query) 的鼠标位置的平滑版本。'
- en: Example 11-22\. Smoothing input with `Buffer`
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-22\. 使用 `Buffer` 对输入进行平滑处理
- en: '[PRE22]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first line of this query states that I want to see groups of five consecutive
    mouse locations, and I want one group for every other input. The rest of the query
    calculates the average mouse position within the window and produces that as the
    output item. [Figure 11-9](#smoothing_in_action) shows the effect. The top line
    is the result of using the raw mouse positions. The line immediately beneath it
    uses the smoothed points generated by [Example 11-22](#smoothing_input_with_buffer)
    from the same input. As you can see, the top line is rather ragged, but the bottom
    line has smoothed out a lot of the lumps.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询的第一行指定我要查看五个连续鼠标位置的组，并且我希望每隔一个输入生成一个组。查询的其余部分计算窗口内的平均鼠标位置，并将其作为输出项。[图 11-9](#smoothing_in_action)
    显示了效果。顶部线条是使用原始鼠标位置的结果。紧接着它下面的线条使用了相同输入产生的 [示例 11-22](#smoothing_input_with_buffer)
    中的平滑点。正如你所看到的，顶部线条有些崎岖不平，而底部线条则平滑了许多突起。
- en: '![](assets/pc10_1109.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/pc10_1109.png)'
- en: Figure 11-9\. Smoothing in action
  id: totrans-218
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-9\. 平滑效果展示
- en: '[Example 11-22](#smoothing_input_with_buffer) uses a mixture of LINQ to Objects
    and Rx’s LINQ implementation. The query expression itself uses Rx, but the range
    variable, `points`, is of type `IList<Point>` (because `Buffer` returns an `IObservable<IList<Point>>`
    in this example). So the nested queries that invoke the `Average` operator on
    `points` will get the LINQ to Objects implementation.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 11-22](#smoothing_input_with_buffer) 使用了 LINQ to Objects 和 Rx 的混合实现。查询表达式本身使用了
    Rx，但是范围变量 `points` 的类型是 `IList<Point>`（因为在这个示例中 `Buffer` 返回一个 `IObservable<IList<Point>>`）。因此，对
    `points` 调用 `Average` 操作符的嵌套查询将得到 LINQ to Objects 的实现。'
- en: If the `Buffer` operator’s input is hot, it will produce a hot observable as
    a result. So you could subscribe to the observable in the `smoothed` variable
    in [Example 11-22](#smoothing_input_with_buffer) with similar code to the final
    line of [Example 11-15](#filtering_items_with_a_linq_query), and it would show
    the smoothed line in real time as you drag the mouse. As discussed, there will
    be a slight lag, of course—the code specifies a skip of two, so it will update
    the screen only for every other mouse event. Averaging over the last five points
    will also tend to increase the gap between the mouse pointer and the end of the
    line. With these parameters, the discrepancy is small enough not to be too distracting,
    but with more aggressive smoothing, it could get annoying.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Buffer`运算符的输入是热的，则它将产生一个热可观测对象作为结果。因此，您可以订阅[示例 11-22](https://example.org/smoothing_input_with_buffer)中`smoothed`变量中的可观测对象，类似于[示例
    11-15](https://example.org/filtering_items_with_a_linq_query)的最后一行代码，它将在您拖动鼠标时实时显示平滑的线条。正如讨论的那样，当然会有一些延迟
    —— 代码指定了跳过两个项目，因此它仅对每两次鼠标事件更新一次屏幕。对最后五个点进行平均处理也会增加鼠标指针与线条末端之间的差距。在这些参数下，差异很小，不会太分散注意力，但如果使用更激进的平滑处理，可能会变得令人不快。
- en: The `Window` operator is very similar to the `Buffer` operator, but instead
    of presenting each window as an `IList<T>`, it provides an `IObservable<T>`. If
    you used `Window` on `dragPositions` in [Example 11-22](#smoothing_input_with_buffer),
    the result would be `IObservable<IObserva⁠ble​<Point>>`. [Figure 11-10](#window_operator)
    shows how the `Window` operator would work in the last of the scenarios illustrated
    in [Figure 11-8](#sliding_windows_with_the_buffer_operator), and as you can see,
    it can start each window sooner. It doesn’t have to wait until all of the items
    in the window are available; instead of providing a fully populated list containing
    the window, each output item is an `IObservable<T>` that will produce the window’s
    items as and when they become available. Each observable produced by `Window`
    completes immediately after supplying the final item (i.e., at the same instant
    at which `Buffer` would have provided the whole window). So, if your processing
    depends on having the whole window, `Window` can’t get it to you any faster, because
    it’s ultimately governed by the rate at which input items arrive, but it will
    start to provide values earlier.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`Window`运算符与`Buffer`运算符非常相似，但不同之处在于它不将每个窗口呈现为`IList<T>`，而是提供一个`IObservable<T>`。如果您在[示例
    11-22](https://example.org/smoothing_input_with_buffer)中对`dragPositions`使用`Window`，结果将是`IObservable<IObservable<Point>>`。[图
    11-10](https://example.org/window_operator)展示了`Window`运算符在[图 11-8](https://example.org/sliding_windows_with_the_buffer_operator)中的最后一种情景中的工作方式，正如您所见，它可以更早地开始每个窗口。它不必等到窗口中的所有项目都可用才开始；它提供的每个输出项目都是一个`IObservable<T>`，该对象将根据项目的可用性逐个产生窗口的项目。`Window`生成的每个可观测对象在提供最后一个项目后立即完成（即与`Buffer`提供整个窗口的时刻相同）。因此，如果您的处理依赖于整个窗口的可用性，`Window`无法更快地将其提供给您，因为它最终受到输入项到达速率的限制，但它将更早地开始提供值。'
- en: One potentially surprising feature of the observables produced by `Window` in
    this example is their start times. Whereas they end immediately after producing
    their final item, they do not start immediately before producing their first.
    The observable representing the very first window starts right away—you will receive
    that observable as soon as you subscribe to the observable of observables the
    operator returns. So the first window will be available immediately, even if the
    `Window` operator’s input hasn’t done anything yet. Then each new window starts
    as soon as all the input items it needs to skip have been received. In this example,
    I’m using a skip count of one, so the second window starts after the input has
    produced one item, the third after two have been produced, and so on.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`Window`在这个例子中生成的可观测对象的一个潜在令人惊讶的特征是它们的起始时间。尽管它们在生成最后一个项目后立即结束，但它们在生成第一个项目之前并不立即开始。代表第一个窗口的可观测对象立即开始
    —— 一旦您订阅运算符返回的可观测对象的可观测对象，您将立即收到该可观测对象。因此，第一个窗口将立即可用，即使`Window`运算符的输入尚未执行任何操作。然后，每个新窗口在接收到需要跳过的所有输入项后立即开始。在这个例子中，我使用的是一个跳过计数为一，因此第二个窗口在输入产生一个项目后开始，第三个在产生两个项目后开始，依此类推。'
- en: As you’ll see later in this section, and also in [“Timed Operations”](#timed_operations),
    `Window` and `Buffer` support some other ways to define when each window starts
    and stops. The general pattern is that as soon as the `Window` operator gets to
    a point where a new item from the source would go into a new window, the operator
    creates that window, anticipating the window’s first item rather than waiting
    for it (see [Figure 11-10](#window_operator)).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您稍后在本节中将看到的，以及在[“定时操作”](#timed_operations)中也看到的，`Window`和`Buffer`支持一些其他定义窗口何时开始和停止的方式。一般模式是，一旦`Window`操作符到达一个点，源中的新项将进入新窗口，操作符就创建该窗口，预期窗口的第一个项，而不是等待它（见[图 11-10](#window_operator)）。
- en: '![](assets/pc10_1110.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/pc10_1110.png)'
- en: Figure 11-10\. `Window` operator
  id: totrans-225
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-10\. `Window`操作符
- en: Note
  id: totrans-226
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If the input completes, all currently open windows will also complete. This
    means that it’s possible to see empty windows. (In fact, with a skip size of one,
    you’re guaranteed to get one empty window if the source completes.) In [Figure 11-10](#window_operator),
    one window right at the bottom has started but has not yet produced any items.
    If the input were to complete without producing any more items, the three observable
    sources still in progress would also complete, including that final one that hasn’t
    yet produced anything.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入完成，所有当前打开的窗口也会完成。这意味着可能会看到空窗口。（事实上，如果跳过大小为一，如果源完成，你保证会得到一个空窗口。）在[图 11-10](#window_operator)中，底部的一个窗口已经开始但尚未产生任何项。如果输入在不再产生任何项的情况下完成，仍在进行中的三个可观测源也会完成，包括那个尚未产生任何内容的最后一个。
- en: Because `Window` delivers items into windows as soon as the source provides
    them, it might enable you to get started with processing sooner than you can with
    `Buffer`, perhaps improving overall responsiveness. The downside of `Window` is
    that it tends to be more complex—your subscribers will start receiving output
    values before all the items for the corresponding input window are available.
    Whereas `Buffer` provides you with a list that you can inspect at your leisure,
    with `Window`, you’ll need to continue working in Rx’s world of sequences that
    produce items only when they’re good and ready. To perform the same smoothing
    as [Example 11-22](#smoothing_input_with_buffer) with `Window` requires the code
    in [Example 11-23](#smoothing_with_window).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Window`操作符会在源提供项时立即将项投放到窗口中，这可能会使您能够更早地开始处理，比使用`Buffer`更能提高整体响应性。`Window`的缺点是它往往更复杂——您的订阅者将在相应的输入窗口的所有项都可用之前开始接收输出值。而`Buffer`提供您一个列表，您可以随时检查，而使用`Window`，您将需要继续在Rx的序列世界中工作，只有当它们准备好时才会产生项。要执行与[示例 11-22](#smoothing_input_with_buffer)相同的平滑操作，使用`Window`需要在[示例 11-23](#smoothing_with_window)中的代码。
- en: Example 11-23\. Smoothing with `Window`
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-23\. 使用`Window`进行平滑操作
- en: '[PRE23]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is a little more complicated because I’ve been unable to use the `Average`
    operator, due to the need to cope with the possibility of empty windows. (Strictly
    speaking, that doesn’t matter in the case where I have one `Polyline` that keeps
    getting longer and longer. But if I group the points by drag operation, as [Example 11-20](#adding_a_new_line_for_each_drag_operatio)
    does, each individual observable source of points will complete at the end of
    the drag, forcing me to handle any empty windows.) The `Average` operator produces
    an error if you provide it with an empty sequence, so I’ve used the `Aggregate`
    operator instead, which lets me add a `where` clause to filter out empty windows
    instead of crashing. But that’s not the only aspect that is more complex.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点复杂，因为我无法使用`Average`操作符，由于需要应对空窗口的可能性。（严格来说，在我有一个不断变长的`Polyline`的情况下，这并不重要。但是，如果我像[示例 11-20](#adding_a_new_line_for_each_drag_operatio)那样按拖动操作分组点，每个单独的可观测点源将在拖动结束时完成，迫使我处理任何空窗口。）如果你向`Average`操作符提供一个空序列，它会产生错误，所以我改用了`Aggregate`操作符，它让我添加一个`where`子句来过滤掉空窗口而不是崩溃。但这不是更复杂的唯一方面。
- en: As I mentioned earlier, all of Rx’s aggregation operators—`Aggregate`, `Min`,
    `Max`, and so on—work differently than with most LINQ providers. LINQ requires
    these operators to reduce the stream down to a single value, so they normally
    return a single value. For example, if I were to call the LINQ to Objects version
    of `Aggregate` with the arguments shown in [Example 11-23](#smoothing_with_window),
    it would return a single value of the anonymous type I’m using for my accumulator.
    But in Rx, the return type is `IObservable<T>` (where `T` is that accumulator
    type in this case). It still produces a single value, but it presents that value
    through an observable source. Unlike LINQ to Objects, which can enumerate its
    input to calculate, say, an average, the Rx operator has to wait for the source
    to provide its values, so it can’t produce an aggregate of those values until
    the source says it has finished.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，Rx 的所有聚合操作符——`Aggregate`、`Min`、`Max` 等——与大多数 LINQ 提供程序的操作方式不同。LINQ
    要求这些操作符将流减少为单个值，因此它们通常返回单个值。例如，如果我使用示例 11-23 中显示的参数调用 LINQ to Objects 版本的 `Aggregate`，它将返回我用作累加器的匿名类型的单个值。但在
    Rx 中，返回类型是 `IObservable<T>`（在这种情况下 `T` 是累加器类型）。它仍然生成单个值，但通过可观测源呈现该值。与 LINQ to
    Objects 不同，它可以枚举其输入以计算平均值，Rx 操作符必须等待源提供其值，因此它不能在源说它已完成之前产生这些值的聚合。
- en: Because the `Aggregate` operator returns an `IObservable<T>`, I’ve had to use
    a second `from` clause. This passes that source to the `SelectMany` operator,
    which extracts all values and makes them appear in the final stream—in this case,
    there is just one value (per window), so `SelectMany` is effectively unwrapping
    the averaged point from its single-item stream.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `Aggregate` 操作符返回一个 `IObservable<T>`，我不得不使用第二个 `from` 子句。这将源传递给 `SelectMany`
    操作符，该操作符提取所有值并使它们出现在最终流中——在本例中，每个窗口只有一个值，因此 `SelectMany` 实际上是从其单一项流中展开平均点。
- en: The code in [Example 11-23](#smoothing_with_window) is a little more complex
    than [Example 11-22](#smoothing_input_with_buffer), and I think it’s considerably
    harder to understand how it works. Worse, it doesn’t even offer any benefit. The
    `Aggregate` operator will begin its work as soon as inputs become available, but
    the code cannot produce the final result—the average—until it has seen every point
    in the window. If I’m going to have to wait until the end of the window before
    I can update the UI, I may as well stick with `Buffer`. So, in this particular
    case, `Window` was a lot more work for no benefit. However, if the work being
    done on the items in the window was less trivial, or if the volumes of data involved
    were so large that you didn’t want to buffer the entire window before starting
    to process it, the extra complexity could be worth the benefit of being able to
    start the aggregation process without having to wait for the whole input window
    to become available.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 11-23](#smoothing_with_window) 中的代码比 [示例 11-22](#smoothing_input_with_buffer)
    复杂一些，我认为理解其工作原理要困难得多。更糟糕的是，它甚至没有提供任何好处。`Aggregate` 操作符在可用输入时就开始工作，但代码在看到窗口中的每个点之前无法生成最终结果——平均值。如果我必须等到窗口结束才能更新
    UI，那么我可能还是坚持使用 `Buffer`。因此，在这种特殊情况下，`Window` 是为了没有好处而做了更多的工作。然而，如果在窗口中处理的项目不那么琐碎，或者涉及的数据量非常大，以至于不希望在开始处理整个窗口之前缓冲整个窗口，那么额外的复杂性可能值得，因为可以开始聚合过程而无需等待整个输入窗口可用。'
- en: Demarcating windows with observables
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用可观测对象划分窗口
- en: The `Window` and `Buffer` operators provide some other ways of defining when
    windows should start and finish. Just as the join operators can specify duration
    with an observable, you can supply a function that returns a duration-defining
    observable for each window. [Example 11-24](#breaking_text_into_words_with_windows)
    uses this to break keyboard input into words. The `keySource` variable in this
    example is the one from [Example 11-11](#delegate-based_hot_source). It’s an observable
    sequence that produces an item for each keypress.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`Window` 和 `Buffer` 操作符提供了一些定义窗口何时开始和结束的其他方式。就像连接操作符可以用可观测对象指定持续时间一样，你可以提供一个返回每个窗口定义持续时间的函数。[示例 11-24](#breaking_text_into_words_with_windows)
    使用此方法将键盘输入分解为单词。本示例中的 `keySource` 变量来自 [示例 11-11](#delegate-based_hot_source)。它是一个生成每次按键的可观测序列。'
- en: Example 11-24\. Breaking text into words with windows
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-24\. 使用窗口将文本分解为单词
- en: '[PRE24]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `Window` operator will immediately create a new window in this example,
    and it will also invoke the lambda I’ve supplied to find out when that window
    should end. It will keep it open until the observable source my lambda returns
    either produces a value or completes. When that happens, `Window` will immediately
    open the next window, invoking my lambda again to get another observable to determine
    the length of the second window, and so on. The lambda here produces the next
    whitespace character from the keyboard, so the window will close on the next space.
    In other words, this breaks the input sequence into a series of windows where
    each window contains zero or more nonwhitespace characters followed by one whitespace
    character.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`Window`运算符将立即在此示例中创建一个新窗口，并且还将调用我提供的lambda来确定窗口的结束时间。它会保持窗口处于打开状态，直到我提供的可观察源的lambda返回一个值或完成。当发生这种情况时，`Window`会立即打开下一个窗口，并再次调用我的lambda以获取另一个可观察对象来确定第二个窗口的长度，依此类推。此处的lambda会从键盘产生下一个空格字符，因此窗口将在下一个空格处关闭。换句话说，这将输入序列分割成一系列窗口，其中每个窗口包含零个或多个非空格字符，后跟一个空格字符。'
- en: The observable sequence the `Window` operator returns presents each window as
    an `IObservable<char>`. The second statement in [Example 11-24](#breaking_text_into_words_with_windows)
    is a query that converts each window to a string. (This will produce empty strings
    if the input contains multiple adjacent whitespace characters. That’s consistent
    with the behavior of the `string` type’s `Split` method, which performs the pull-oriented
    equivalent of this partitioning. If you don’t like it, you can always filter out
    the blanks with a `where` clause.)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`Window`运算符返回的可观察序列将每个窗口呈现为`IObservable<char>`。[Example 11-24](#breaking_text_into_words_with_windows)中的第二个语句是一个查询，将每个窗口转换为一个字符串。（如果输入包含多个相邻的空格字符，这将产生空字符串。这与`string`类型的`Split`方法的行为一致，该方法执行了与此分区相对应的拉取导向的操作。如果你不喜欢这种行为，你可以通过`where`子句来过滤掉空白字符。）'
- en: Because [Example 11-24](#breaking_text_into_words_with_windows) uses `Window`,
    it will start making characters for each word available as soon as the user types
    them. But because my query calls `ToArray` on the window, it will end up waiting
    until the window completes before producing anything. This means `Buffer` would
    be equally effective. It would also be simpler. As [Example 11-25](#work_breaking_with_buffer)
    shows, I don’t need a second `from` clause to collect the completed window if
    I use `Buffer`, because it provides me with windows only once they are complete.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 由于[Example 11-24](#breaking_text_into_words_with_windows)使用了`Window`，它将会在用户键入每个单词时立即使字符可用。但由于我的查询在窗口上调用了`ToArray`，它将等待窗口完成之后才会产生任何内容。这意味着如果使用`Buffer`同样有效，而且更简单。正如[Example 11-25](#work_breaking_with_buffer)所示，如果使用`Buffer`，我不需要第二个`from`子句来收集完成的窗口，因为它仅在窗口完成后提供窗口。
- en: Example 11-25\. Word breaking with `Buffer`
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 11-25\. 使用`Buffer`进行单词拆分
- en: '[PRE25]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The Scan Operator
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scan运算符
- en: The `Scan` operator is very similar to the standard `Aggregate` operator, with
    one difference. Instead of producing a single result after its source completes,
    it produces a sequence containing each accumulator value in turn. To illustrate
    this, I will first introduce a record type that will act as a very simple model
    for a stock trade. This type, shown in [Example 11-26](#simple_stock_trade_with_test_stream),
    also defines a static method that provides a randomly generated stream of trades
    for test purposes.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scan`运算符与标准的`Aggregate`运算符非常相似，只有一个区别。它不会在源完成后产生单个结果，而是产生一个序列，其中依次包含每个累加器的值。为了说明这一点，我将首先介绍一个记录类型，它将作为一个非常简单的股票交易模型。这种类型在[Example 11-26](#simple_stock_trade_with_test_stream)中显示，并定义了一个静态方法，用于提供测试目的的随机生成交易流。'
- en: Example 11-26\. Simple stock trade with test stream
  id: totrans-246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 11-26\. 使用测试流进行简单股票交易
- en: '[PRE26]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[Example 11-27](#summing_with_aggregate) shows the normal `Aggregate` operator
    being used to calculate the total number of stocks traded, by adding up the `Number`
    property of every trade. (You’d normally just use the `Sum` operator, of course,
    but I’m showing this for comparison with `Scan`.)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[Example 11-27](#summing_with_aggregate)展示了使用普通`Aggregate`运算符计算所有交易股票的总数，方法是将每个交易的`Number`属性相加。（当然，你通常会直接使用`Sum`运算符，但为了与`Scan`进行比较，我这里展示了这种方法。）'
- en: Example 11-27\. Summing with `Aggregate`
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 11-27\. 使用`Aggregate`进行求和
- en: '[PRE27]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This displays a single number, because the observable produced by `Aggregate`
    provides only a single value. [Example 11-28](#running_total_with_scan) shows
    almost exactly the same code but using `Scan` instead.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示一个单一的数字，因为由 `Aggregate` 生成的可观测对象只提供一个单一的值。[示例 11-28](#running_total_with_scan)
    几乎完全展示了相同的代码，但是使用了 `Scan` 替代。
- en: Example 11-28\. Running total with `Scan`
  id: totrans-252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-28\. 使用 `Scan` 运行总和
- en: '[PRE28]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Instead of producing a single output value, this produces one output item for
    each input, which is the running total for all items the source has produced so
    far. `Scan` is particularly useful if you need aggregation-like behavior in an
    endless stream, such as one based on an event source. `Aggregate` is no use in
    that scenario because it will not produce anything if its input never completes.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是产生单一输出值，而是为每个输入产生一个输出项目，这是源迄今为止所有项目的累计总和。如果你需要在无限流中实现类似聚合的行为（例如基于事件源），`Scan`
    就特别有用。在这种情况下，`Aggregate` 无法使用，因为如果其输入永远不完成，它将不会产生任何内容。
- en: The Amb Operator
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Amb 操作符
- en: Rx defines an operator with the somewhat cryptic name of `Amb`. (See the next
    sidebar, [“Why Amb?”](#why_amb_question)) This takes any number of observable
    sequences and waits to see which one does something first. (The documentation
    talks about which of the inputs “reacts” first. This means that it calls any of
    the three `IObserver<T>` methods.) Whichever input jumps into action first effectively
    becomes the `Amb` operator’s output—it forwards everything the chosen stream does,
    immediately unsubscribing from the other streams. (If any of them manage to produce
    elements after the first stream does, but before the operator has had time to
    unsubscribe, those elements will be ignored.)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Rx 定义了一个名为 `Amb` 的操作符，其名称有些神秘。（请参见下一个侧边栏，[“Why Amb?”](#why_amb_question)）它接受任意数量的可观测序列，并等待看哪一个先执行操作。（文档讨论了输入中哪一个“首先反应”。这意味着它调用了任意三个
    `IObserver<T>` 方法中的任何一个。）首先行动的输入有效成为 `Amb` 操作符的输出——它立即取消订阅其他流并转发所选择流的所有内容。（如果任何其他流在第一个流之后但操作符尚未取消订阅之前产生元素，这些元素将被忽略。）
- en: You might use this operator to optimize a system’s response time by sending
    a request to multiple machines in a server pool and using the result from whichever
    responds first. (There are dangers with this technique, of course, not least of
    which is that it could increase the overall load on your system so much that the
    effect is to slow everything down, not speed anything up. However, there are some
    scenarios in which careful application of this technique can be successful.)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个操作符可以通过向服务器池中的多台机器发送请求并使用最先响应的结果来优化系统的响应时间。（当然，这种技术存在一些风险，其中最大的风险之一是可能会显著增加系统的总负载，导致整体速度变慢，而不是加快任何事情的速度。然而，在某些场景中，谨慎应用这种技术可以取得成功。）
- en: DistinctUntilChanged
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DistinctUntilChanged
- en: The final operator I’m going to describe in this section is very simple but
    rather useful. The `DistinctUntilChanged` operator removes adjacent duplicates.
    Suppose you have an observable source that produces items on a regular basis but
    tends to produce the same value multiple times in a row. You might need to take
    action only when a different value emerges. `DistinctUntilChanged` is for exactly
    this scenario—when its input produces an item, it will be passed on only if it
    was different from the previous item (or if it was the first item).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我要在本节中描述的最后一个操作符非常简单但相当有用。`DistinctUntilChanged` 操作符删除相邻的重复项。假设你有一个可观测源，它定期产生项目，但往往连续多次产生相同的值。你可能只在出现不同值时需要采取行动。`DistinctUntilChanged`
    正好适用于这种场景——当其输入产生一个项目时，只有在与上一个项目不同（或者是第一个项目）时才会传递该项目。
- en: I’ve not yet shown all of the Rx operators I want to introduce. However, the
    remaining ones, which I’ll discuss in [“Timed Operations”](#timed_operations),
    are all time sensitive. And before I can show those, I need to describe how Rx
    handles timing.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我还没有展示我想介绍的所有 Rx 操作符。然而，剩下的那些我将在[“Timed Operations”](#timed_operations)中讨论，它们都是时间敏感的。在我展示它们之前，我需要描述
    Rx 如何处理时间。
- en: Schedulers
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度器
- en: Rx performs certain work through *schedulers*. A scheduler is an object that
    provides three services. The first is to decide when to execute a particular piece
    of work. For example, when an observer subscribes to a cold source, should the
    source’s items be delivered to the subscriber immediately, or should that work
    be deferred? The second service is to run work in a particular context. A scheduler
    might decide always to execute work on a particular thread, for example. The third
    job is to keep track of time. Some Rx operations are time dependent; to ensure
    predictable behavior and to enable testing, schedulers provide a virtualized model
    for time, so Rx code does not have to depend on the current time of day reported
    by .NET’s `DateTimeOffset` class.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Rx 通过 *调度器* 执行特定的工作。调度器是提供三项服务的对象。首先是决定何时执行特定的工作。例如，当观察者订阅冷源时，应立即将源的项目传递给订阅者，还是应该推迟该工作？第二项服务是在特定上下文中运行工作。例如，调度器可能决定始终在特定线程上执行工作。第三项工作是跟踪时间。某些
    Rx 操作是时间相关的；为了确保可预测的行为并启用测试，调度器为时间提供了虚拟化模型，因此 Rx 代码不必依赖 .NET 的 `DateTimeOffset`
    类报告的当前时间。
- en: 'The scheduler’s first two roles are sometimes interdependent. For example,
    Rx supplies a few schedulers for use in UI applications. There’s a `CoreDispatcherScheduler`
    for Windows Store apps, `DispatcherScheduler` for WPF applications, `Control​Sched⁠uler`
    for Windows Forms programs, and a more generic one called `SynchronizationContextScheduler`,
    which will work in all .NET UI frameworks, albeit with slightly less control over
    the details than the framework-specific ones. All of these have a common characteristic:
    they ensure that work executes in a suitable context for accessing UI objects,
    which typically means running the work on a particular thread. If code that schedules
    work is running on some other thread, the scheduler may have no choice but to
    defer the work, because it will not be able to run it until the UI framework is
    ready. This might mean waiting for a particular thread to finish whatever it is
    doing. In this case, running the work in the right context necessarily also has
    an impact on when the work is executed.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器的前两个角色有时是相互依赖的。例如，Rx 为 UI 应用程序提供了几个调度器。Windows Store 应用程序有一个 `CoreDispatcherScheduler`，WPF
    应用程序有一个 `DispatcherScheduler`，Windows Forms 程序有一个 `Control​Sched⁠uler`，还有一个更通用的称为
    `SynchronizationContextScheduler`，它将在所有 .NET UI 框架中工作，尽管对比特定于框架的调度器，它的细节控制稍逊一筹。所有这些调度器都有一个共同的特点：它们确保工作在适合访问
    UI 对象的上下文中执行，通常意味着在特定线程上运行工作。如果调度工作的代码运行在其他线程上，则调度程序可能别无选择，只能推迟工作，因为它无法在 UI 框架准备好之前运行工作。这可能意味着等待特定线程完成其正在执行的任务。在这种情况下，正确上下文中运行工作也必然会影响工作的执行时间。
- en: 'This isn’t always the case, though. Rx provides two schedulers that use the
    current thread. One of them, `ImmediateScheduler`, is extremely simple: it runs
    work the instant it is scheduled. When you give this scheduler some work, it won’t
    return until the work is complete. The other, `CurrentThreadScheduler`, maintains
    a work queue, which gives it some flexibility with ordering. For example, if some
    work is scheduled in the middle of executing some other piece of work, it can
    allow the work item in progress to finish before starting on the next. If no work
    items are queued or in progress, `CurrentThreadScheduler` runs work immediately,
    just like `Immediate​Sched⁠uler`. When a work item it has invoked completes, the
    `Current​Th⁠read​Sched⁠uler` inspects the queue and will invoke the next item
    if it’s not empty. So it attempts to complete all work items as quickly as possible,
    but unlike `ImmediateScheduler`, it will not start to process a new work item
    before the previous one has finished.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，并非总是如此。Rx 提供了两个使用当前线程的调度器。其中一个是 `ImmediateScheduler`，非常简单：它在调度时立即运行工作。当您给这个调度器一些工作时，它不会返回，直到工作完成为止。另一个是
    `CurrentThreadScheduler`，它维护一个工作队列，这使它在排序上具有一定的灵活性。例如，如果在执行某个其他工作的中间调度了一些工作，它可以允许正在进行的工作项完成后再开始下一个。如果没有排队或正在进行的工作项，`CurrentThreadScheduler`
    就像 `Immediate​Sched⁠uler` 一样立即运行工作。当它调用完成一个工作项时，`Current​Th⁠read​Sched⁠uler` 检查队列，并在队列不为空时调用下一个工作项。因此，它试图尽快完成所有工作项，但与
    `ImmediateScheduler` 不同的是，它不会在前一个工作项完成之前开始处理新的工作项。
- en: Specifying Schedulers
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定调度器
- en: Rx operations often do not go through schedulers. Many observable sources invoke
    their subscribers’ methods directly. Sources that can generate a large number
    of items in quick succession are typically an exception. For example, the `Range`
    and `Repeat` methods for creating sequences use a scheduler to govern the rate
    at which they provide items to new subscribers. You can pass in an explicit scheduler
    or let them pick a default one. You can also get a scheduler involved explicitly
    even when using sources that don’t accept one as an argument.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Rx 操作通常不经过调度程序。许多可观察源直接调用其订阅者的方法。通常可以生成大量项目的源是一个例外。例如，用于创建序列的 `Range` 和 `Repeat`
    方法使用调度程序来控制它们向新订阅者提供项目的速率。您可以传递显式调度程序或让它们选择默认调度程序。即使使用不接受调度程序作为参数的源，您也可以显式地涉及调度程序。
- en: ObserveOn
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`ObserveOn`'
- en: A common way to specify a scheduler is with one of the `ObserveOn` extension
    methods defined by various static classes in the `System.Reactive.Linq` namespace.^([4](ch11.xhtml#CHP-11-FN-4))
    This is useful if you want to handle events in a specific context (such as the
    UI thread) even though they may originate from somewhere else.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 指定调度程序的常见方式是使用 `System.Reactive.Linq` 命名空间中各种静态类定义的 `ObserveOn` 扩展方法。^([4](ch11.xhtml#CHP-11-FN-4))
    即使事件可能来自其他地方，这在想要在特定上下文（如 UI 线程）处理事件时非常有用。
- en: You can invoke `ObserveOn` on any `IObservable<T>`, passing in an `IScheduler`,
    and it returns another `IObservable<T>`. If you subscribe to the observable that
    returns, your observer’s `OnNext`, `OnCompleted`, and `OnError` methods will all
    be invoked through the scheduler you specified. [Example 11-29](#observeon_specific_scheduler)
    uses this to ensure that it’s safe to update the UI in the item handler callback.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在任何 `IObservable<T>` 上调用 `ObserveOn`，传递一个 `IScheduler`，它会返回另一个 `IObservable<T>`。如果订阅返回的可观察对象，则您的观察者的
    `OnNext`、`OnCompleted` 和 `OnError` 方法将通过您指定的调度程序调用。 [Example 11-29](#observeon_specific_scheduler)
    使用此功能确保在项目处理程序回调中更新 UI 是安全的。
- en: Example 11-29\. `ObserveOn` specific scheduler
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-29\. `ObserveOn` 特定调度程序
- en: '[PRE29]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this example, I used the `DispatcherScheduler` class’s static `Current` property,
    which returns a scheduler that executes work via the current thread’s `Dispatcher`.
    (`Dispatcher` is the class that manages the UI message loop in WPF applications.)
    Rx’s `DispatcherObservable` class defines various extension methods providing
    WPF-specific overloads, and instead of passing in a scheduler, I can call `ObserveOn`
    passing just a `Dispatcher` object. I could use this in the codebehind for a UI
    element with code such as that in [Example 11-30](#observeon_wpf_dispatcher).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我使用了 `DispatcherScheduler` 类的静态 `Current` 属性，该属性返回通过当前线程的 `Dispatcher`
    执行工作的调度程序。 （`Dispatcher` 是在 WPF 应用程序中管理 UI 消息循环的类。） Rx 的 `DispatcherObservable`
    类定义了各种提供 WPF 特定重载的扩展方法，而不是传递调度程序，我可以调用 `ObserveOn` 只传递一个 `Dispatcher` 对象。我可以在代码中使用此方法，例如在
    [Example 11-30](#observeon_wpf_dispatcher) 中。
- en: Example 11-30\. `ObserveOn` WPF `Dispatcher`
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-30\. `ObserveOn` WPF `Dispatcher`
- en: '[PRE30]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The advantage of this overload is that I don’t need to be on the UI thread at
    the point at which I call `ObserveOn`. The `Current` property used in [Example 11-29](#observeon_specific_scheduler)
    works only if you are on the thread for the dispatcher you require. If I’m already
    on that thread, there’s an even simpler way to set this up. I can use the `ObserveOnDispatcher`
    extension method, which obtains a `DispatcherScheduler` for the current thread’s
    dispatcher, as shown in [Example 11-31](#observing_on_the_current_dispatcher).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这种重载的优点在于，在调用 `ObserveOn` 的时候我不需要处于 UI 线程上。在 [Example 11-29](#observeon_specific_scheduler)
    中使用的 `Current` 属性只有在您所需的调度程序的线程上时才有效。如果我已经在该线程上，可以更简单地设置它。我可以使用 `ObserveOnDispatcher`
    扩展方法，该方法获取当前线程的调度程序的 `DispatcherScheduler`，如 [Example 11-31](#observing_on_the_current_dispatcher)
    所示。
- en: Example 11-31\. Observing on the current dispatcher
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-31\. 在当前调度程序上观察
- en: '[PRE31]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: SubscribeOn
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`SubscribeOn`'
- en: Most of the various `ObserveOn` extension methods have corresponding `SubscribeOn`
    methods. (There’s also `SubscribeOnDispatcher`, the counterpart of `ObserveOn​Dis⁠patcher`.)
    Instead of arranging for each call to an observer’s methods to be made through
    the scheduler, `SubscribeOn` performs the call to the source observable’s `Subscribe`
    method through the scheduler. And if you unsubscribe by calling `Dispose`, that
    will also be delivered through the scheduler. This can be important for cold sources,
    because many perform significant work in their `Subscribe` method, some even delivering
    all of their items immediately.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数各种`ObserveOn`扩展方法都有相应的`SubscribeOn`方法。（还有`SubscribeOnDispatcher`，它是`ObserveOnDispatcher`的对应物。）`SubscribeOn`不是为了通过调度程序安排每次对观察者方法的调用，而是通过调度程序执行源可观察对象的`Subscribe`方法的调用。如果通过调用`Dispose`取消订阅，那也会通过调度程序传递。对于冷源来说，这可能很重要，因为很多在其`Subscribe`方法中执行重要工作，有些甚至会立即传递所有项目。
- en: Note
  id: totrans-280
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In general, there’s no guarantee of any correspondence between the context in
    which you subscribe to a source and the context in which the items it produces
    will be delivered to a subscriber. Some sources will notify you from their subscription
    context, but many won’t. If you need to receive notifications in a particular
    context, then unless the source provides some way to specify a scheduler, use
    `ObserveOn`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，订阅源的上下文与生成的项目将传递给订阅者的上下文之间没有任何对应关系的保证。某些源会在其订阅上下文中通知您，但很多则不会。如果您需要在特定上下文中接收通知，那么除非源提供某种方式来指定调度程序，否则使用`ObserveOn`。
- en: Passing schedulers explicitly
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 明确传递调度程序
- en: Some operations accept a scheduler as an argument. You will tend to find this
    in operations that can generate many items. The `Observable.Range` method that
    generates a sequence of numbers optionally takes a scheduler as a final argument
    to control the context from which these numbers are generated. This also applies
    to the APIs for adapting other sources, such as `IEnumerable<T>` to observable
    sources, as described in [“Adaptation”](#adaptation).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 一些操作接受调度程序作为参数。您通常会在可以生成多个项目的操作中找到这些调度程序。生成数字序列的`Observable.Range`方法可以选择在最后一个参数中接受一个调度程序，以控制生成这些数字的上下文。这也适用于适应其他源（例如`IEnumerable<T>`）到可观察源的API，如[“适配”](#adaptation)中所述。
- en: Another scenario in which you can usually provide a scheduler is when using
    an observable that combines inputs. Earlier, you saw how the `Merge` operator
    combines the output of multiple sequences. You can provide a scheduler to tell
    the operator to subscribe to the sources from a specific context.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个通常可以提供调度程序的场景是使用合并输入的可观察对象。前面提到过，`Merge`操作符可以合并多个序列的输出。您可以提供一个调度程序来告诉操作符从特定上下文订阅源。
- en: Finally, timed operations all depend on a scheduler. I will show some of these
    in [“Timed Operations”](#timed_operations).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，所有定时操作都依赖于调度程序。我将在[“定时操作”](#timed_operations)中展示其中一些。
- en: Built-in Schedulers
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置调度程序
- en: I’ve already described the four UI-oriented schedulers, `DispatcherScheduler`
    (for WPF), `CoreDispatcherScheduler` (for Windows Store apps), `ControlScheduler`
    (for Windows Forms), and `SynchronizationContextScheduler`, and also the two schedulers
    for running work on the current thread, `CurrentThreadScheduler` and `ImmediateScheduler`.
    But there are some others worth being aware of.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经描述了四个面向UI的调度程序，`DispatcherScheduler`（用于WPF）、`CoreDispatcherScheduler`（用于Windows
    Store应用）、`ControlScheduler`（用于Windows Forms）和`SynchronizationContextScheduler`，以及两个在当前线程上运行工作的调度程序，`CurrentThreadScheduler`和`ImmediateScheduler`。但还有一些其他值得注意的调度程序。
- en: '`EventLoopScheduler` runs all work items on a specific thread. It can create
    a new thread for you, or you can provide it with a callback method that it will
    invoke when it wants you to create the thread. You might use this in a UI application
    to process incoming data. It lets you move work off the UI thread to keep the
    application responsive but ensures that all processing happens on a single thread,
    which can simplify concurrency issues.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventLoopScheduler`在特定线程上运行所有工作项。它可以为您创建一个新线程，或者您可以为其提供一个回调方法，在需要您创建线程时它会调用该方法。您可以在UI应用程序中使用它来处理传入数据。它允许您将工作从UI线程移出，以保持应用程序的响应性，但确保所有处理都在单个线程上进行，这可以简化并发问题。'
- en: '`NewThreadScheduler` creates a new thread for each top-level work item it processes.
    (If that work item spawns further work items, those will run on the same thread,
    rather than creating new ones.) This is appropriate only if you need to do a lot
    of work for each item, because threads have relatively high startup and teardown
    costs in Windows. You are normally better off using a thread pool if you need
    concurrent processing of work items.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewThreadScheduler` 为每个顶级工作项创建一个新线程。（如果该工作项生成更多工作项，则这些工作项将在同一线程上运行，而不是创建新线程。）只有在每个项需要大量工作时才适用，因为在Windows中线程的启动和关闭成本相对较高。如果需要并发处理工作项，通常最好使用线程池。'
- en: '`TaskPoolScheduler` uses the Task Parallel Library’s (TPL) thread pool. The
    TPL, described in [Chapter 16](ch16.xhtml#ch_multithreading), provides an efficient
    pool of threads that can reuse a single thread for multiple work items, amortizing
    the startup costs of creating the thread.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskPoolScheduler` 使用任务并行库（TPL）的线程池。TPL在[第16章](ch16.xhtml#ch_multithreading)中描述，提供了一个高效的线程池，可以重用单个线程来处理多个工作项，从而分摊了创建线程的启动成本。'
- en: '`ThreadPoolScheduler` uses the CLR’s thread pool to run work. This is similar
    in concept to the TPL thread pool, but it’s a somewhat older piece of technology.
    (The TPL was introduced in .NET 4.0, but the CLR thread pool has existed since
    v1.0.) This is a bit less efficient in certain scenarios. Rx introduced this scheduler
    because early versions of Rx supported old versions of .NET that didn’t have the
    TPL. It retains it for backward-compatibility reasons.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadPoolScheduler` 使用CLR的线程池来运行工作。这在概念上类似于TPL线程池，但技术上稍显陈旧。（TPL是在.NET 4.0中引入的，但CLR线程池自v1.0起就存在。）在某些场景下效率较低。Rx引入了这个调度器，因为早期的Rx版本支持没有TPL的旧版.NET。出于向后兼容的原因保留了它。'
- en: '`HistoricalScheduler` is useful when you want to test time-sensitive code without
    needing to execute your tests in real time. All schedulers will provide a time-keeping
    service, but the `HistoricalScheduler` lets you decide the exact rate at which
    you want the scheduler to behave as though time is elapsing. So, if you need to
    test what happens if you wait 30 seconds, you can just tell the `HistoricalScheduler`
    to act as though 30 seconds have passed, without having to actually wait.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`HistoricalScheduler` 在你需要测试依赖于时间的代码，但又不想实时执行测试时非常有用。所有调度器都提供时间服务，但`HistoricalScheduler`让你可以决定调度器以多快的速度模拟时间流逝。因此，如果你需要测试等待30秒后会发生什么，你可以告诉`HistoricalScheduler`模拟30秒已过去，而无需真正等待。'
- en: Subjects
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Subjects
- en: Rx defines various *subjects*, classes that implement both `IObserver<T>` and
    `IObservable<T>`. These can sometimes be useful if you need Rx to provide a robust
    implementation of either of these interfaces, but the usual `Observable.Create`
    or `Subscribe` methods are not convenient. For example, perhaps you need to provide
    an observable source, and there are several different places in your code from
    which you want to provide values for that source to produce. This is awkward to
    fit into the `Create` method’s subscription callback model and can be easier to
    handle with a subject. Some of the subject types provide additional behavior,
    but I’ll start with the simplest, `Subject<T>`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Rx定义了各种*subjects*，这些类实现了`IObserver<T>`和`IObservable<T>`接口。如果需要Rx提供这些接口的强大实现，但通常的`Observable.Create`或`Subscribe`方法不方便时，这些类有时会很有用。例如，也许你需要提供一个可观察的源，而你的代码中有几个不同的地方需要为该源提供值来生成。这很难适配到`Create`方法的订阅回调模型中，使用subject会更容易处理。某些subject类型提供额外的行为，但我将从最简单的`Subject<T>`开始。
- en: Subject<T>
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Subject&lt;T&gt;
- en: The `Subject<T>` class’s `IObserver<T>` implementation just relays calls to
    all observers that have subscribed using its `IObservable<T>` interface. So, if
    you subscribe one or more observables to a `Subject<T>` and then call `OnNext`,
    the subject will call `OnNext` on each of its subscribers. It’s the same for the
    other methods, `OnCompleted` and `OnError`. This multicast relay is very similar
    to the facility provided by the `Publish` operator^([5](ch11.xhtml#CHP-11-FN-5))
    I used in [Example 11-11](#delegate-based_hot_source), so this provides an alternative
    way for me to remove all of the code for tracking subscribers from my `KeyWatcher`
    source, resulting in the code shown in [Example 11-32](#implementing_iobservable_with_subject).
    This is much simpler than the original in [Example 11-7](#keypress_monitor_iobservable),
    although not quite as simple as the delegate-based version in [Example 11-11](#delegate-based_hot_source).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subject<T>` 类的 `IObserver<T>` 实现只是通过其 `IObservable<T>` 接口转发给所有已订阅的观察者。因此，如果你订阅了一个或多个
    `Subject<T>`，然后调用 `OnNext`，该主题将调用其所有订阅者的 `OnNext` 方法。其他方法 `OnCompleted` 和 `OnError`
    也是如此。这种多播转发与我在 [示例 11-11](#delegate-based_hot_source) 中使用的 `Publish` 操作符^([5](ch11.xhtml#CHP-11-FN-5))
    提供的功能非常相似，因此这为我从 `KeyWatcher` 源中移除所有跟踪订阅者代码提供了另一种选择，结果如 [示例 11-32](#implementing_iobservable_with_subject)
    中所示。这比 [示例 11-7](#keypress_monitor_iobservable) 中的原始方法简单得多，尽管不像 [示例 11-11](#delegate-based_hot_source)
    中的基于委托的版本那样简单。'
- en: Example 11-32\. Implementing `IObservable<T>` with a `Subject<T>`
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-32\. 使用 `Subject<T>` 实现 `IObservable<T>`
- en: '[PRE32]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This defers to a `Subject<char>` in its `Subscribe` method, so everything that
    tries to subscribe to this `KeyWatcher` will end up being subscribed to that subject
    instead. My loop can then just call the subject’s `OnNext` method, and it’ll take
    care of broadcasting that to all the subscribers.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在其 `Subscribe` 方法中，它转发到了一个 `Subject<char>`，所以试图订阅这个 `KeyWatcher` 的一切最终都会订阅到该主题。然后，我的循环只需调用主题的
    `OnNext` 方法，它会负责将其广播给所有订阅者。
- en: In fact, I can simplify things further by exposing the observable as a separate
    property, rather than making my entire type observable, as [Example 11-33](#providing_an_iobservable_as_property)
    shows. Not only does this make the code slightly simpler, but it also means my
    `KeyWatcher` could now provide multiple sources if it wanted to.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我可以通过将可观察对象公开为单独的属性来进一步简化事情，而不是使整个类型都成为可观察的，正如 [示例 11-33](#providing_an_iobservable_as_property)
    所示。这不仅使代码稍微简单了些，而且意味着我的 `KeyWatcher` 现在可以提供多个源。
- en: Example 11-33\. Providing an `IObservable<T>` as a property
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-33\. 提供一个 `IObservable<T>` 作为属性
- en: '[PRE33]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is still not quite as simple as the combination of `Observable.Create`
    and the `Publish` operator that I used in [Example 11-11](#delegate-based_hot_source),
    but it does offer two advantages. First, it’s now easier to see when the loop
    that generates keypress notifications runs. I was in control of that in [Example 11-11](#delegate-based_hot_source),
    but for anyone not totally familiar with how `Publish` works, it would not be
    obvious how this was being achieved. I find [Example 11-33](#providing_an_iobservable_as_property)
    a little less cryptic. Second, if I wanted to, I could use this subject from anywhere
    inside my `KeyWatcher` class, whereas in [Example 11-11](#delegate-based_hot_source),
    the only place from which I could easily provide an item was inside the callback
    function invoked by `Observable.Create`. As it happens, in this example I don’t
    need this flexibility, but in scenarios where you do, a `Subject<T>` is likely
    to be a better choice than the callback approach.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然不像我在 [示例 11-11](#delegate-based_hot_source) 中使用的 `Observable.Create` 和 `Publish`
    操作符的组合那样简单，但它确实提供了两个优点。首先，现在更容易看到生成键盘按键通知的循环何时运行。在 [示例 11-11](#delegate-based_hot_source)
    中我控制了这个过程，但对于不太熟悉 `Publish` 工作原理的人来说，这可能并不明显。我觉得 [示例 11-33](#providing_an_iobservable_as_property)
    较少神秘。其次，如果我愿意，我可以从 `KeyWatcher` 类的任何地方使用这个主题，而在 [示例 11-11](#delegate-based_hot_source)
    中，我只能在由 `Observable.Create` 调用的回调函数内部提供一个项。在这个例子中，我并不需要这种灵活性，但在需要时，`Subject<T>`
    很可能比回调方法更好。
- en: BehaviorSubject<T>
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BehaviorSubject<T>
- en: '`BehaviorSubject<T>` looks almost exactly like a `Subject<T>` except for one
    thing: when any observer first subscribes, it is guaranteed to receive a value
    straightaway as long you have not completed the subject by calling `OnComplete`.
    (If you have already completed the subject, it’ll just call `OnComplete` immediately
    on any further subscribers.) It remembers the last item it passed on and hands
    that out to new subscribers. When you construct a `BehaviorSubject<T>`, you have
    to supply an initial value that it will provide to new subscribers until the first
    call to `OnNext`.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`BehaviorSubject<T>` 看起来几乎和 `Subject<T>` 一模一样，除了一点：当任何观察者第一次订阅时，只要你还没有通过调用
    `OnComplete` 完成主题，它就保证会立即接收一个值。（如果你已经完成了主题，它将立即在任何进一步的订阅者上调用 `OnComplete`。）它会记住它传递的最后一项，并将其提供给新的订阅者。当你构造一个
    `BehaviorSubject<T>` 时，你必须提供一个初始值，它将提供给新的订阅者，直到第一次调用 `OnNext`。'
- en: One way to think of this subject is as Rx’s version of a variable. It’s something
    that has a value that you can retrieve at any time, and its value can also change
    over time. But being reactive, you subscribe to it to retrieve its value, and
    your observer will be notified of any further changes until you unsubscribe.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种方法可以将此主题视为 Rx 版本的变量。它是一种具有可以随时检索的值的东西，其值也可以随时间改变。但是由于是响应式的，你必须订阅它才能检索其值，并且在你取消订阅之前，观察者将被通知任何进一步的更改。
- en: This subject has a mix of hot and cold characteristics. It will instantly provide
    a value to any subscriber, making it seem like a cold source, but once that’s
    happened, it then broadcasts new values to all subscribers, more like a hot source
    does. There’s another subject with a similar mix, but that takes the cold side
    a bit further.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 此主题具有热和冷特性的混合。它将立即向任何订阅者提供一个值，使其看起来像一个冷源，但一旦发生这种情况，它会像热源一样向所有订阅者广播新值。还有另一个主题具有类似的混合特性，但更进一步地采用了冷侧。
- en: ReplaySubject<T>
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ReplaySubject<T>`'
- en: '`ReplaySubject<T>` can record every value it receives from whichever source
    you subscribe it to. (Or, if you invoke its methods directly, it remembers every
    value you provide through `OnNext`.) Each new subscriber to this subject will
    receive every item that the `ReplaySubject<T>` has seen so far. So this is much
    more like an ordinary cold subject—instead of just getting the most recent value
    as you would from a `BehaviorSubject<T>`, you get a complete set of items. However,
    once the `ReplaySubject<T>` has provided a particular subscriber with all of the
    items it has recorded, it then transitions into more hot-like behavior for that
    subscriber, because it will continue to provide new incoming items.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReplaySubject<T>` 可以记录它从任何你订阅的源接收到的每个值。（或者，如果你直接调用其方法，它会记住你通过 `OnNext` 提供的每个值。）对此主题的每个新订阅者将接收到
    `ReplaySubject<T>` 到目前为止所看到的每个项目。因此，这更像是一个普通的冷主题——与从 `BehaviorSubject<T>` 获取最近值不同，你会得到一个完整的项目集。然而，一旦
    `ReplaySubject<T>` 向特定的订阅者提供了所有已记录的项目，对于该订阅者，它会转变为更像热主题的行为，因为它将继续提供新接收到的项目。'
- en: So, in the long run, every subscriber to a `ReplaySubject<T>` will by default
    see every item that the `ReplaySubject<T>` receives from its source, regardless
    of how early or late that subscriber subscribed to the subject.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，长期以来，对 `ReplaySubject<T>` 的每个订阅者默认情况下都会看到它从其源接收到的每个项目，无论该订阅者是何时订阅的主题。
- en: In its default configuration, a `ReplaySubject<T>` will consume ever more memory
    for as long as it is subscribed to a source. There’s no way to tell it that it
    will have no more new subscribers and that it’s now OK for it to discard old items
    that it has already distributed to all of its existing subscribers. You should
    therefore not leave it subscribed indefinitely to an endless source. However,
    you can limit the amount that a `ReplaySubject<T>` buffers. It offers various
    constructor overloads, some of which let you specify either an upper limit on
    the number of items to replay or an upper limit on the time for which it will
    hold onto items. Obviously, if you do this, new subscribers can no longer depend
    on getting all of the items previously received.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在其默认配置中，`ReplaySubject<T>` 将消耗越来越多的内存，只要它订阅到一个源。无法告诉它不会再有新的订阅者，并且现在可以丢弃已经分发给所有现有订阅者的旧项。因此，你不应该无限期地将其订阅到一个无限源。但是，你可以限制
    `ReplaySubject<T>` 缓冲的数量。它提供了各种构造函数重载，其中一些让你可以指定回放的项目数量的上限或者持续保留项目的时间的上限。显然，如果你这样做，新的订阅者将无法依赖于获取到以前接收到的所有项目。
- en: AsyncSubject<T>
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`AsyncSubject<T>`'
- en: '`AsyncSubject<T>` remembers just one value from its source, but unlike `Behavior​Sub⁠ject<T>`,
    which remembers the most recent value, `AsyncSubject<T>` waits for its source
    to complete. It will then produce the final item as its output. If the source
    completes without providing any values, the `AsyncSubject<T>` will do the same
    to its subscribers.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncSubject<T>`只会记住其来源的一个值，但与`BehaviorSubject<T>`不同，后者记住最近的值，`AsyncSubject<T>`会等待其来源完成。然后，它将产生最终项作为其输出。如果来源在不提供任何值的情况下完成，`AsyncSubject<T>`将立即完成所有新的订阅者。'
- en: If you subscribe to an `AsyncSubject<T>` before its source has completed, the
    `AsyncSubject<T>` will do nothing with your observer until the source completes.
    But once the source has completed, the `AsyncSubject<T>` acts as a cold source
    that provides a single value, unless the source completed without providing a
    value, in which case this subject will complete all new subscribers immediately.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在其来源完成之前订阅了`AsyncSubject<T>`，则`AsyncSubject<T>`不会对观察者执行任何操作。但一旦来源完成，`AsyncSubject<T>`将作为冷源，提供单个值，除非来源在不提供值的情况下完成，否则此主题将立即完成所有新的订阅者。
- en: Adaptation
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适应
- en: Interesting and powerful though Rx is, it would not be much use if it existed
    in a vacuum. If you are working with asynchronous notifications, it’s possible
    that they will be supplied by an API that does not support Rx. Although `IObservable<T>`
    and `IObserver<T>` have been around for a long time (since .NET 4.0, which was
    released in 2010), not every API that could support these interfaces does. Also,
    because Rx’s fundamental abstraction is a sequence of items, there’s a good chance
    that at some point you might need to convert between Rx’s push-oriented `IObservable<T>`
    and the pull-oriented equivalents `IEnumerable<T>` and `IAsyncEnumerable<T>`.
    Rx provides ways to adapt these and other kinds of sources into `IObservable<T>`,
    and in some cases, it can adapt in either direction.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Rx很有趣且强大，但如果它存在于真空中，则几乎没有用处。如果您正在处理异步通知，可能会有API提供它们，但不支持Rx。虽然`IObservable<T>`和`IObserver<T>`已经存在很长时间（自2010年发布的.NET
    4.0以来），但并非每个支持这些接口的API都能够支持。此外，由于Rx的基本抽象是一系列项目，因此很可能在某个时候需要在Rx的推送式`IObservable<T>`和拉取式等效的`IEnumerable<T>`和`IAsyncEnumerable<T>`之间进行转换。Rx提供了将这些和其他类型的来源适应为`IObservable<T>`的方法，并且在某些情况下，可以在两者之间进行适应。
- en: IEnumerable<T> and IAsyncEnumerable<T>
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IEnumerable<T>和IAsyncEnumerable<T>
- en: Any `IEnumerable<T>` can easily be brought into the world of Rx thanks to the
    `ToObservable` extension methods. These are defined by the `Observable` static
    class in the `System.Reactive.Linq` namespace. [Example 11-34](#converting_an_ienumerableltg_to_an_iobse)
    shows the simplest form, which takes no arguments.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 任何`IEnumerable<T>`都可以轻松地进入Rx的世界，这要归功于`ToObservable`扩展方法。这些方法由`System.Reactive.Linq`命名空间中的`Observable`静态类定义。[示例 11-34](#converting_an_ienumerableltg_to_an_iobse)展示了最简单的形式，不带任何参数。
- en: Example 11-34\. Converting an `IEnumerable<T>` to an `IObservable<T>`
  id: totrans-319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-34\. 将`IEnumerable<T>`转换为`IObservable<T>`
- en: '[PRE34]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `ToObservable` method itself does not enumerate its input—it just returns
    a wrapper that implements `IObservable<T>`. This wrapper is a cold source, and
    each time you subscribe an observer to it, only then does it iterate through the
    input, passing each item to the observer’s `OnNext` method and calling `OnCompleted`
    at the end. If the source throws an exception, this adapter will call `OnError`.
    [Example 11-35](#toobservable_sketch) shows how `ToObservable` might work if it
    weren’t for the fact that it needs to use a scheduler.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToObservable`方法本身不会枚举其输入——它只返回一个实现`IObservable<T>`的包装器。此包装器是一个冷源，每当您向其订阅观察者时，它才会迭代输入，将每个项目传递给观察者的`OnNext`方法，并在最后调用`OnCompleted`。如果源引发异常，此适配器将调用`OnError`。[示例 11-35](#toobservable_sketch)展示了如果不需要使用调度程序，`ToObservable`可能的工作方式。'
- en: Example 11-35\. How `ToObservable` might look without scheduler support
  id: totrans-322
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-35\. 没有调度程序支持时`ToObservable`的实现
- en: '[PRE35]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is not how it really works, because [Example 11-35](#toobservable_sketch)
    cannot use a scheduler. (A full implementation would have been much harder to
    read, defeating the purpose of the example, which was to show the basic idea behind
    `ToObservable`.) The real method uses a scheduler to manage the iteration process,
    enabling subscription to occur asynchronously if required. It also supports stopping
    the work if the observer’s subscription is canceled early. There’s an overload
    that takes a single argument of type `IScheduler`, which lets you tell it to use
    a particular scheduler; if you don’t provide one, it’ll use `CurrentThreadScheduler`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是它真正的工作方式，因为[示例 11-35](#toobservable_sketch)无法使用调度程序。（完整的实现将会更难阅读，从而违背了示例的目的，即显示`ToObservable`背后的基本思想。）真实的方法使用调度程序来管理迭代过程，如果需要，允许异步订阅。它还支持在观察者的订阅被提前取消时停止工作。有一个以`IScheduler`类型的单一参数作为重载，允许您告诉它使用特定的调度程序；如果您不提供一个，它将使用`CurrentThreadScheduler`。
- en: When it comes to going in the other direction—that is, when you have an `IObservable<T>`,
    but you would like to treat it as an `IEnumerable<T>`—you can call the `ToEnumerable`
    extension methods, also provided by the `Observable` class. [Example 11-36](#using_an_iobservable_as_an_ienumerable)
    wraps an `IObservable<string>` as an `IEnumerable<string>` so that it can iterate
    over the items in the source using an ordinary `foreach` loop.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要进行相反方向的操作时，即当您有一个`IObservable<T>`但希望将其视为`IEnumerable<T>`时，您可以调用由`Observable`类提供的`ToEnumerable`扩展方法。[示例
    11-36](#using_an_iobservable_as_an_ienumerable)将`IObservable<string>`封装为`IEnumerable<string>`，以便可以使用普通的`foreach`循环迭代源中的项。
- en: Example 11-36\. Using an `IObservable<T>` as an `IEnumerable<T>`
  id: totrans-326
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-36\. 将`IObservable<T>`用作`IEnumerable<T>`
- en: '[PRE36]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The wrapper subscribes to the source on your behalf. If the source provides
    items faster than you can iterate over them, the wrapper will store the items
    in a queue so you can retrieve them at your leisure. If the source does not provide
    items as fast as you can retrieve them, the wrapper will just wait until items
    become available.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 包装器代表您订阅了源。如果源提供的项比您迭代它们的速度更快，包装器将把这些项存储在队列中，以便您可以随时检索它们。如果源提供的项不如您检索它们的速度快，包装器将等待直到有可用的项。
- en: The `IAsyncEnumerable<T>` interface provides the same model as `IEnumerable<T>`
    but in a way that enables efficient asynchronous operation using the techniques
    discussed in [Chapter 17](ch17.xhtml#ch_asynchronous_language_features). Rx offers
    a `ToObservable` extension method for this and also a `ToAsyncEnumerable` method
    extension method for `IObservable<T>`. These both come from the `AsyncEnumerable`
    class, and to use that you will need a reference to a separate NuGet package called
    `System.Linq.Async`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 接口`IAsyncEnumerable<T>`提供了与`IEnumerable<T>`相同的模型，但通过使用[第 17 章](ch17.xhtml#ch_asynchronous_language_features)中讨论的技术，以一种能够进行有效异步操作的方式实现。Rx提供了`ToObservable`扩展方法，以及`IObservable<T>`的`ToAsyncEnumerable`方法扩展方法。这两者都来自`AsyncEnumerable`类，如果要使用它们，您将需要引用一个名为`System.Linq.Async`的单独NuGet包。
- en: .NET Events
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET 事件
- en: Rx can wrap a .NET event as an `IObservable<T>` using the `Observable` class’s
    static `FromEventPattern` method. Earlier, in [Example 11-17](#grouping_events),
    I used a `FileSystemWatcher`, a class from the `System.IO` namespace that raises
    various events when files are added, deleted, renamed, or otherwise modified in
    a particular folder. [Example 11-37](#wrapping_an_event_in_an_iobservable) reproduces
    the first part of that example, which I glossed over last time. This code uses
    the `Observable.FromEventPattern` static method to produce an observable source
    representing the watcher’s `Created` event. (If you want to handle a static event,
    you can pass a `Type` object as the first argument instead. [Chapter 13](ch13.xhtml#ch_reflection)
    describes the `Type` class.)
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Rx可以使用`Observable`类的静态`FromEventPattern`方法将.NET事件包装为`IObservable<T>`。此前在[示例
    11-17](#grouping_events)中，我使用了`FileSystemWatcher`，这是`System.IO`命名空间中的一个类，在特定文件夹中添加、删除、重命名或以其他方式修改文件时触发各种事件。[示例
    11-37](#wrapping_an_event_in_an_iobservable)复制了该示例的第一部分，这是上次我略过的部分。此代码使用`Observable.FromEventPattern`静态方法生成一个表示监视器`Created`事件的可观察源。（如果要处理静态事件，您可以将`Type`对象作为第一个参数传递。[第
    13 章](ch13.xhtml#ch_reflection)描述了`Type`类。）
- en: Example 11-37\. Wrapping an event in an `IObservable<T>`
  id: totrans-332
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-37\. 将事件包装为`IObservable<T>`
- en: '[PRE37]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: On the face of it, this seems significantly more complicated than just subscribing
    to the event in the normal way shown in [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events),
    and with no obvious advantage. And in this particular example, that would have
    been better. However, one benefit of using Rx is that if you were writing a UI
    application, you could use `ObserveOn` with a suitable scheduler to ensure that
    your handler was always invoked on the right thread, regardless of which thread
    raised the event. Of course, another benefit—and the usual reason for doing this—is
    that you can use any of Rx’s query operators to process the events. (That’s why
    the original [Example 11-17](#grouping_events) did this.)
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，这似乎比在 [第 9 章](ch09.xhtml#ch_delegates_lambdas_events) 中显示的正常订阅事件要复杂得多，而且没有明显的优势。在这种特定示例中，使用传统方法会更好。但是，使用
    Rx 的一个好处是，如果您正在编写 UI 应用程序，您可以使用适当的调度程序与 `ObserveOn` 一起确保您的处理程序始终在正确的线程上调用，无论哪个线程引发事件。当然，另一个好处
    —— 通常的原因 —— 是您可以使用 Rx 的任何查询操作符来处理事件。（这就是为什么原始的 [Example 11-17](#grouping_events)
    这样做的原因。）
- en: The element type of the observable source that [Example 11-37](#wrapping_an_event_in_an_iobservable)
    produces is `Event​Pat⁠tern<FileSystemEventArgs>`. The generic `EventPattern<T>`
    is a type defined by Rx specifically for representing the raising of an event,
    where the event’s delegate type conforms to the standard pattern described in
    [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events) (i.e., it takes two arguments,
    the first being of type `object`, representing the object that raised the event,
    and the second being some type derived from `EventArgs`, containing information
    about the event). `EventPattern<T>` has two properties, `Sender` and `EventArgs`,
    corresponding to the two arguments that an event handler would receive. In effect,
    this is an object that represents what would normally be a method call to an event
    handler.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`Example 11-37` 产生的可观察源的元素类型是 `Event​Pat⁠tern<FileSystemEventArgs>`。泛型 `EventPattern<T>`
    是 Rx 特别为表示事件触发而定义的类型，其中事件的委托类型符合 [第 9 章](ch09.xhtml#ch_delegates_lambdas_events)
    中描述的标准模式（即接受两个参数，第一个是 `object` 类型，表示引发事件的对象，第二个是从 `EventArgs` 派生的某种类型，包含有关事件的信息）。`EventPattern<T>`
    有两个属性，`Sender` 和 `EventArgs`，对应于事件处理程序将接收的两个参数。实际上，这是一个表示通常会对事件处理程序进行方法调用的对象。'
- en: A surprising feature of [Example 11-37](#wrapping_an_event_in_an_iobservable)
    is that the second argument to `FromEvent​Pat⁠tern` is a string containing the
    name of the event. Rx resolves this to the real event member at runtime. This
    is less than ideal for a couple of reasons. First, it means that if you type the
    name in wrong, the compiler won’t notice (although using the `nameof` operator
    mitigates this). Second, it means the compiler can’t help you with types—if you
    handle a .NET event directly with a lambda, the compiler can infer the argument
    types from the event definition, but here, because we’re passing the event name
    as a string, the compiler doesn’t know which event I’m using (or even that I’m
    using an event at all), so I’ve had to specify the generic type argument for the
    method explicitly. And again, if I get that wrong, the compiler won’t know—it’ll
    be checked at runtime instead.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '[Example 11-37](#wrapping_an_event_in_an_iobservable) 的一个令人惊讶的特性是，`FromEvent​Pat⁠tern`
    的第二个参数是一个包含事件名称的字符串。Rx 在运行时将其解析为真实的事件成员。这在某些方面不太理想，原因有几个。首先，这意味着如果您输入错误的名称，编译器不会注意到（尽管使用
    `nameof` 操作符可以缓解这个问题）。其次，这意味着编译器无法帮助您确定类型 —— 如果直接使用 lambda 表达式处理 .NET 事件，编译器可以从事件定义推断参数类型，但在这里，因为我们将事件名称作为字符串传递，编译器不知道我使用的是哪个事件（甚至不知道我是否使用了事件），因此我必须明确地为方法指定泛型类型参数。而且，如果我搞错了，编译器不会察觉
    —— 这将在运行时检查。'
- en: 'This string-based approach arises from a shortcoming of events: you can’t pass
    an event as an argument. In fact, events are very limited members. You can’t do
    anything with an event from outside of the class that defines it other than adding
    or removing handlers. This is one of the ways in which Rx improves on events—once
    you’re in the world of Rx, event sources and subscribers are both represented
    as objects (implementing `IObservable<T>` and `IObserver<T>`, respectively), making
    it straightforward to pass them into methods as arguments. But that doesn’t help
    us at the point where we’re dealing with an event that’s not yet in Rx’s world.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基于字符串的方法源于事件的缺陷：您不能将事件作为参数传递。事实上，事件是非常有限的成员。您不能从定义它的类外部对事件执行任何操作，除了添加或移除处理程序。这是
    Rx 在事件方面改进的一种方式——一旦进入 Rx 的世界，事件源和订阅者都表示为对象（分别实现 `IObservable<T>` 和 `IObserver<T>`），使得将它们作为参数传递到方法中变得简单。但这并不帮助我们处理尚未进入
    Rx 的事件的情况。
- en: Rx does provide an overload that doesn’t require you to use a string—you can
    pass in delegates that add and remove the handlers for Rx, as [Example 11-38](#delegate-based_event_wrapping)
    shows.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: Rx 确实提供了一个重载，不需要使用字符串——您可以传递用于 Rx 添加和移除处理程序的委托，如 [示例 11-38](#delegate-based_event_wrapping)
    所示。
- en: Example 11-38\. Delegate-based event wrapping
  id: totrans-339
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-38\. 基于委托的事件包装
- en: '[PRE38]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is somewhat more verbose, because it requires a generic type argument specifying
    the handler delegate type as well as the event argument type. The string-based
    version discovers the handler type for itself at runtime, but because the normal
    reason for using the approach in [Example 11-38](#delegate-based_event_wrapping)
    is to get compile-time type checking, the compiler needs to know what types you’re
    using, and the lambdas in that example don’t provide quite enough information
    for the compiler to infer all the type arguments automatically.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这相对冗长一些，因为它需要一个泛型类型参数来指定处理程序委托类型以及事件参数类型。基于字符串的版本在运行时自行发现处理程序类型，但因为使用 [示例 11-38](#delegate-based_event_wrapping)
    的一般原因是为了获得编译时类型检查，编译器需要知道你使用的是哪些类型，而该示例中的 Lambda 表达式并没有为编译器提供足够的信息来自动推断所有类型参数。
- en: As well as wrapping an event as an observable source, it’s possible to go in
    the other direction. Rx defines an operator for `IObservable<EventPattern<T>>`
    called `ToEventPattern<T>`. (Note that this is not available for any old observable
    source—it has to be an observable sequence of `EventPattern<T>`.) If you call
    this, it returns an object that implements `IEventPatternSource<T>`. This defines
    a single event called `OnNext`, of type `EventHandler<T>`, which allows you to
    hook up an event handler in the ordinary .NET way to an observable source.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将事件作为可观察源进行包装之外，还可以反过来进行。Rx 定义了一个名为 `ToEventPattern<T>` 的 `IObservable<EventPattern<T>>`
    操作符。（请注意，这不适用于任何旧的可观察源——它必须是 `EventPattern<T>` 的可观察序列。）如果调用此方法，它将返回一个实现了 `IEventPatternSource<T>`
    接口的对象。它定义了一个名为 `OnNext` 的单一事件，类型为 `EventHandler<T>`，允许您以普通的 .NET 方式将事件处理程序连接到可观察源。
- en: Asynchronous APIs
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步 API
- en: .NET supports various asynchronous patterns, which I’ll be describing in detail
    in Chapters [16](ch16.xhtml#ch_multithreading) and [17](ch17.xhtml#ch_asynchronous_language_features).
    The first to be introduced in .NET was the Asynchronous Programming Model (APM).
    However, this pattern is not supported directly by the new C# asynchronous language
    features, so most .NET APIs now use the TPL, and for older APIs the TPL offers
    adapters that can provide a task-based wrapper for an APM-based API. Rx can represent
    any TPL task as an observable source.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 支持各种异步模式，在第 [16](ch16.xhtml#ch_multithreading) 章和第 [17](ch17.xhtml#ch_asynchronous_language_features)
    章中会详细描述。最早在 .NET 中引入的是异步编程模型（APM）。然而，这种模式并不直接被新的 C# 异步语言特性支持，所以现在大多数 .NET API
    使用 TPL，对于旧的 API，TPL 提供了适配器，可以为基于 APM 的 API 提供基于任务的包装器。Rx 可以将任何 TPL 任务表示为可观察源。
- en: 'The basic model for all of .NET’s asynchronous patterns is that you start some
    work that will eventually complete, optionally producing a result. So it may seem
    odd to translate this into Rx, where the fundamental abstraction is a sequence
    of items, not a single result. In fact, one useful way to understand the difference
    between Rx and the TPL is that `IObservable<T>` is analogous to `IEnumerable<T>`,
    while `Task<T>` is analogous to a property of type `T`. Whereas with `IEnumerable<T>`
    and properties, the caller decides when to fetch information from the source,
    with `IObservable<T>` and `Task<T>`, the source provides the information when
    it’s ready. The choice of which party decides when to provide information is separate
    from the question of whether the information is singular or a sequence of items.
    So a mapping between singular asynchronous APIs and `IObservable<T>` seems a little
    mismatched. But then we can cross similar boundaries in the nonasynchronous world—as
    you saw in [Chapter 10](ch10.xhtml#ch_linq), LINQ defines various standard operators
    that produce a single item from a sequence, such as `First` or `Last`. Rx supports
    those operators, but it additionally supports going in the other direction: bringing
    singular asynchronous sources into a stream-like world. The upshot is an `IObservable<T>`
    source that produces just a single item (or reports an error if the operation
    fails). The analogy in the nonasynchronous world would be taking a single value
    and wrapping it in an array so that you can pass it to an API that requires an
    `IEnumerable<T>`.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 所有.NET异步模式的基本模型是，你启动一些工作，最终会完成，可选地生成一个结果。因此，将其翻译成Rx可能看起来有些奇怪，因为Rx的基本抽象是一个项目序列，而不是单个结果。事实上，理解Rx和TPL之间的区别的一种有用方法是，`IObservable<T>`类似于`IEnumerable<T>`，而`Task<T>`类似于类型为`T`的属性。与使用`IEnumerable<T>`和属性时，调用者决定何时从源获取信息不同，使用`IObservable<T>`和`Task<T>`时，源在准备好时提供信息。决定何时提供信息的选择与信息是单个还是项目序列是分开的。因此，将单个异步API映射到`IObservable<T>`似乎有些不匹配。但是我们在非异步世界中也可以跨越类似的界限——正如你在[第10章](ch10.xhtml#ch_linq)中看到的，LINQ定义了各种标准运算符，用于从序列生成单个项目，如`First`或`Last`。Rx支持这些运算符，但它还支持另一种方式：将单个异步源带入类似流的世界。其结果是一个`IObservable<T>`源，只产生一个项目（或者如果操作失败，则报告错误）。在非异步世界中的类比可以是将单个值包装在数组中，以便您可以将其传递给需要`IEnumerable<T>`的API。
- en: '[Example 11-39](#wrapping_a_task_as_an_iobservable) uses this facility to produce
    an `IObservable<string>` that will either produce a single value containing the
    text downloaded from a particular URL or report a failure should the download
    fail.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 11-39](#wrapping_a_task_as_an_iobservable)使用此功能生成一个`IObservable<string>`，它将生成包含从特定URL下载的文本的单个值，或在下载失败时报告故障。'
- en: Example 11-39\. Wrapping a `Task<T>` as an `IObservable<T>`
  id: totrans-347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-39\. 将`Task<T>`包装为`IObservable<T>`
- en: '[PRE39]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `ToObservable` method used in this example is an extension method defined
    for `Task` by Rx. For this to be available, you’ll need the `System.Reactive.Thread⁠ing​.Tasks`
    namespace to be in scope.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中使用的`ToObservable`方法是Rx为`Task`定义的扩展方法。为了使其可用，你需要确保`System.Reactive.Threading.Tasks`命名空间在作用域内。
- en: One potentially unsatisfactory feature of [Example 11-39](#wrapping_a_task_as_an_iobservable)
    is that it will attempt the download only once, no matter how many observers subscribe
    to the source. Depending on your requirements, that might be fine, but in some
    scenarios, it might make sense to attempt to download a fresh copy every time.
    If you want that, a better approach would be to use the `Observable.FromAsync`
    method, because you pass that a lambda that it invokes each time a new observer
    subscribes. Your lambda returns a task that will then be wrapped as an observable
    source. [Example 11-40](#creating_a_new_task_for_each_subscriber) uses this to
    start a new download for each subscriber.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 11-39](#wrapping_a_task_as_an_iobservable)的一个潜在的不满意特性是，它只会尝试下载一次，无论多少观察者订阅源。根据您的需求，这可能没问题，但在某些情况下，每次尝试下载新副本可能更合理。如果您需要这样做，更好的方法是使用`Observable.FromAsync`方法，因为您可以将一个lambda传递给它，每当新的观察者订阅时它都会调用这个lambda。您的lambda返回一个任务，然后将其作为可观察源进行包装。[示例
    11-40](#creating_a_new_task_for_each_subscriber)使用这种方法为每个订阅者启动一个新的下载。'
- en: Example 11-40\. Creating a new task for each subscriber
  id: totrans-351
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-40\. 为每个订阅者创建一个新任务
- en: '[PRE40]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This might be suboptimal if you have many subscribers. On the other hand, it’s
    more efficient when nothing attempts to subscribe at all. [Example 11-39](#wrapping_a_task_as_an_iobservable)
    starts the asynchronous work immediately without even waiting for any subscribers.
    That may be a good thing—if the stream will definitely have subscribers, kicking
    off slow work without waiting for the first subscriber will reduce your overall
    latency. However, if you are writing a class in a library that presents multiple
    observable sources, which might not all be used, deferring work until the first
    subscription might be better.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有多个订阅者，这可能不是最佳选择。另一方面，当没有任何尝试订阅时，这更有效率。[示例 11-39](#wrapping_a_task_as_an_iobservable)
    立即开始异步工作，甚至不等待任何订阅者。这可能是一件好事——如果流肯定会有订阅者，那么在等待第一个订阅者之前开始缓慢的工作将减少整体延迟。然而，如果你正在编写一个库中呈现多个可观察源的类，可能最好推迟工作直到第一次订阅。
- en: Timed Operations
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定时操作
- en: Because Rx can work with live streams of information, you may need to handle
    items in a time-sensitive way. For example, the rate at which items arrive might
    be important, or you may wish to group items based on when they were provided.
    In this final section, I’ll describe some of the time-based operators that Rx
    offers.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Rx 可以处理实时信息流，你可能需要以时间敏感的方式处理项目。例如，项目到达的速率可能很重要，或者你可能希望根据提供的时间对项目进行分组。在最后的这一节中，我将描述
    Rx 提供的一些基于时间的操作符。
- en: Interval
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 间隔
- en: The `Observable.Interval` method returns a sequence that regularly produces
    values at the interval specified by an argument of type `TimeSpan`. [Example 11-41](#regular_items_with_interval)
    creates and subscribes to a source that will produce one value every second.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.Interval` 方法返回一个序列，该序列定期以 `TimeSpan` 类型的参数指定的间隔产生值。[示例 11-41](#regular_items_with_interval)
    创建并订阅了一个每秒产生一个值的源。'
- en: Example 11-41\. Regular items with `Interval`
  id: totrans-358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-41\. 使用 `Interval` 进行定期项目处理
- en: '[PRE41]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The items produced by `Interval` are of type `long`. It produces values of zero,
    one, two, etc.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`Interval` 产生的项目的类型是 `long`。它生成值为零、一、二等。'
- en: '`Interval` handles each subscriber independently (i.e., it is a cold source).
    To demonstrate this, add the code in [Example 11-42](#two_subscribers_for_one_interval_source)
    after that in [Example 11-41](#regular_items_with_interval) to wait for a short
    while and then create a second subscription.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`Interval` 独立处理每个订阅者（即它是一个冷源）。为了演示这一点，在 [示例 11-41](#regular_items_with_interval)
    的代码之后添加 [示例 11-42](#two_subscribers_for_one_interval_source) 中的代码，稍等一会儿，然后创建第二个订阅。'
- en: Example 11-42\. A second subscriber to an `Interval` source
  id: totrans-362
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-42\. 对 `Interval` 源的第二个订阅者
- en: '[PRE42]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The second subscriber subscribes two and a half seconds after the first one,
    so this will produce the following output:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个订阅者在第一个订阅者之后订阅了两秒半，所以这将产生以下输出：
- en: '[PRE43]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You can see that the second subscriber’s values start from zero, and that’s
    because it gets its own sequence. If you want a single set of these timed items
    to feed into multiple subscribers, you can use the `Publish` operator described
    earlier.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到第二个订阅者的值从零开始，这是因为它有自己的序列。如果你希望这些定时项目的单个集合供多个订阅者使用，可以使用前面描述的 `Publish` 操作符。
- en: You could use an `Interval` source in conjunction with a group join as a way
    to break items into chunks based on when they arrive. (This is not the only way—there
    are overloads of `Buffer` and `Window` that can do the same.) [Example 11-43](#calculating_words_per_minute)
    combines a timer with an observable sequence representing the words the user types.
    (That second sequence is in the `words` variable, which comes from [Example 11-25](#work_breaking_with_buffer).)
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `Interval` 源与组连接一起作为一种根据到达时间分割项目的方法。（这不是唯一的方法——`Buffer` 和 `Window` 有多种重载可以做同样的事情。）[示例 11-43](#calculating_words_per_minute)
    将定时器与代表用户输入的可观察序列结合起来。（第二个序列在 `words` 变量中，来自 [示例 11-25](#work_breaking_with_buffer)。）
- en: Example 11-43\. Calculating words per minute
  id: totrans-368
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-43\. 计算每分钟的字数
- en: '[PRE44]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Having grouped the words into boundaries based on events from the `Interval`
    source, this query goes on to count the number of items in each group. Since the
    groups are evenly spaced in time, this can be used to calculate the approximate
    rate at which the user is typing words. I’m forming a group once every 6 seconds,
    so we can multiply the number of words in the group by 10 to estimate the words
    per minute.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 将单词根据来自`Interval`源的事件分组后，此查询继续计算每个组中的项目数。由于组在时间上均匀间隔，这可以用来计算用户输入单词的近似速率。我每6秒形成一组，所以我们可以将组中的单词数乘以10来估算每分钟的单词数。
- en: The results are not entirely accurate, because Rx will join two items if their
    durations overlap. That will cause words to be counted multiple times here. The
    final word at the end of one interval will also be the first word at the start
    of the next interval. In this case, the measurements are pretty approximate, so
    I’m not too worried, but you would need to bear in mind how overlaps affect this
    sort of operation if you wanted more precise results. `Window` or `Buffer` may
    offer a better solution.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 结果并不完全准确，因为 Rx 将会合并两个项目，如果它们的持续时间重叠。这将导致单词在此处被多次计数。在一个间隔的末尾的最后一个单词也将成为下一个间隔开始时的第一个单词。在这种情况下，测量结果相当粗略，所以我不太担心，但如果您希望得到更精确的结果，您需要考虑重叠如何影响这种操作。`Window`或`Buffer`可能提供更好的解决方案。
- en: Timer
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定时器
- en: 'The `Observable.Timer` method can create a sequence that produces exactly one
    item. It waits for the duration specified with a `TimeSpan` argument before producing
    that item. It looks very similar to `Observable.Interval`, because not only does
    it take the same argument, but it even returns a sequence of the same type: `IObservable<long>`.
    So I can subscribe to this kind of source in almost exactly the same way as with
    an interval sequence, as [Example 11-44](#single_item_with_timer) shows.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.Timer`方法可以创建一个产生确切一个项目的序列。它在产生该项目之前等待由`TimeSpan`参数指定的持续时间。它看起来非常类似于`Observable.Interval`，因为它不仅接受相同的参数，而且甚至返回相同类型的序列：`IObservable<long>`。因此，我可以几乎以与间隔序列完全相同的方式订阅此类源，正如[示例 11-44](#single_item_with_timer)所示。'
- en: Example 11-44\. Single item with `Timer`
  id: totrans-374
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-44\. 使用`Timer`的单个项目
- en: '[PRE45]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The effect is the same as an `Interval` that stops after producing its first
    item, so you will always get a value of zero. There are also overloads that accept
    an extra `TimeSpan`, which will repeatedly produce the value just like `Interval`.
    In fact, `Interval` uses `Timer` internally—it’s just a wrapper offering a simpler
    API.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 效果与在产生其第一个项目后停止的`Interval`相同，因此您将始终获得零值。还有接受额外`TimeSpan`的重载，它将像`Interval`一样重复生成值。实际上，`Interval`在内部使用`Timer`——它只是一个提供更简单API的包装器。
- en: Timestamp
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间戳
- en: In the preceding two sections, I used `DateTime.Now` when writing out messages
    to indicate when the sources produced items. One potential problem with this is
    that it tells us the time at which our handler processed the message, which will
    not always be an accurate reflection of when the message was received. For example,
    if you have used `ObserveOn` to ensure that your handler always runs on the UI
    thread, there may be a significant delay in between the item being produced and
    your code getting to handle it, because the UI thread may be busy doing other
    things. You can mitigate this with the `Timestamp` operator, available on any
    `IObservable<T>`. [Example 11-45](#timestamped_items) uses this as an alternative
    way to show the time at which an `Interval` produces its items.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两节中，我在写出消息时使用`DateTime.Now`来指示源产生项目的时间。这样做的一个潜在问题是它告诉我们处理程序处理消息的时间，这不总是准确反映消息接收的时间。例如，如果您使用`ObserveOn`确保处理程序始终在UI线程上运行，那么在项目生成和您的代码处理它之间可能会有显著延迟，因为UI线程可能在执行其他任务。您可以使用`Timestamp`运算符来减轻这一问题，该运算符适用于任何`IObservable<T>`。[示例 11-45](#timestamped_items)使用这种方式作为显示`Interval`生成其项目的时间的替代方法。
- en: Example 11-45\. Timestamped items
  id: totrans-379
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-45\. 带时间戳的项目
- en: '[PRE46]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If the source observable’s item type is some type `T`, this operator will produce
    an observable of `Timestamped<T>` items. This defines a `Value` property, containing
    the original value from the source observable, and a `Timestamp` property, indicating
    when the value went through the `Timestamp` operator.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如果源可观察对象的项目类型为某种类型`T`，此运算符将生成一个`Timestamped<T>`项目的可观察对象。这定义了一个包含来自源可观察对象的原始值的`Value`属性，以及一个指示值何时通过`Timestamp`运算符的`Timestamp`属性。
- en: Note
  id: totrans-382
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `Timestamp` property is a `DateTimeOffset`, and it picks a time zone offset
    of zero (i.e., it is in UTC). This provides a stable basis for timing by removing
    any possibility of moving in or out of daylight saving time while your program
    runs. However, if you want to show the timestamp to an end user, you may want
    to adjust it, which is why [Example 11-45](#timestamped_items) calls `ToLocalTime`
    on it.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`Timestamp`属性是一个`DateTimeOffset`，并选择了零时区偏移（即它在UTC时间）。这通过移除程序运行时进出夏令时的可能性，为定时提供了稳定的基础。然而，如果你想向最终用户显示时间戳，你可能需要调整它，这就是为什么[示例 11-45](https://example.org/timestamped_items)
    在其上调用了 `ToLocalTime` 的原因。'
- en: You should apply this operator directly to the observable you want to timestamp,
    rather than leaving it later on in the chain. Writing `src.ObserveOn(sched)​.Time⁠stamp()`
    would defeat the purpose, because you would be timing the items after they had
    been dispatched by the scheduler passed to `ObserveOn`. You would want to write
    `src.Timestamp().ObserveOn(sched)` to ensure that you acquire a timestamp before
    feeding the items into a processing chain that might introduce delay.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该直接将这个操作符应用到你想要加时间戳的可观察对象上，而不是将它留在链条的后面。写成 `src.ObserveOn(sched).Timestamp()`
    会失去意义，因为你会在调度程序传递给 `ObserveOn` 后对项进行计时。你应该写成 `src.Timestamp().ObserveOn(sched)`，以确保在将项馈送到可能引入延迟的处理链之前获取时间戳。
- en: TimeInterval
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TimeInterval
- en: Whereas `Timestamp` records the current time at which items are produced, its
    relative counterpart `TimeInterval` records the time between successive items.
    [Example 11-46](#measuring_the_gaps) uses this on an observable sequence produced
    by `Observable.Interval`, so we’d expect the items to be reasonably evenly spaced.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 而`Timestamp`记录产生项时的当前时间，它的相对对应物`TimeInterval`记录连续项之间的时间。[示例 11-46](https://example.org/measuring_the_gaps)
    在由`Observable.Interval`产生的可观察序列上使用了这个操作符，所以我们期望这些项间隔相对均匀。
- en: Example 11-46\. Measuring the gaps
  id: totrans-387
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-46\. 测量间隔
- en: '[PRE47]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'While the `Timestamped<T>` items produced by the `Timestamp` operator provide
    a `Timestamp` property, the `TimeInterval<T>` items produced by the `TimeInterval`
    operator define an `Interval` property. This is a `TimeSpan` instead of a `DateTimeOffset`.
    I’ve chosen to show the number of seconds between each item to three decimal places.
    Here’s some of what I see when I run it on my computer:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 由`Timestamp`操作符生成的`Timestamped<T>`项提供一个`Timestamp`属性，而由`TimeInterval`操作符生成的`TimeInterval<T>`项则定义了一个`Interval`属性。这是一个`TimeSpan`，而不是`DateTimeOffset`。我选择显示每个项之间的秒数，保留三位小数。当我在我的计算机上运行时，这是我看到的一些内容：
- en: '[PRE48]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This shows intervals that are as much as 10 ms away from what I asked for, but
    that’s fairly typical. Windows is not a real-time operating system.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示的间隔可能比我要求的要差10毫秒，但这是相当典型的。Windows 不是一个实时操作系统。
- en: Throttle
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Throttle
- en: The `Throttle` operator lets you limit the rate at which you process items.
    You pass a `TimeSpan` that specifies the minimum time interval you want between
    any two items. If the underlying source produces items faster than this, `Throttle`
    will just discard them. If the source is slower than the specified rate, `Throttle`
    just passes everything straight through.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`Throttle`操作符允许你限制处理项的速率。你传递一个`TimeSpan`，指定任意两个项之间的最小时间间隔。如果底层源产生的项比这更快，`Throttle`会直接丢弃它们。如果源比指定速率慢，`Throttle`会直接传递所有内容。'
- en: Surprisingly (or at least, I found this surprising), once the source exceeds
    the specified rate, `Throttle` drops *everything* until the rate drops back down
    below the specified level. So, if you specify a rate of 10 items a second, and
    the source produces 100 per second, it won’t simply return every 10th item—it’ll
    return nothing until the source slows down.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 惊讶的是（或者至少我发现这很惊讶），一旦源超过指定速率，`Throttle`会将*所有*东西都丢弃，直到速率再次降到指定水平以下。因此，如果你指定每秒处理10个项目，而源每秒产生100个项目，它不会简单地返回每第10个项目，而是直到源减速才会返回任何东西。
- en: Sample
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sample
- en: The `Sample` operator produces items from its input at the interval specified
    by its `TimeSpan` argument, regardless of the rate at which the input observable
    is generating items. If the underlying source produces items faster than the chosen
    rate, `Sample` drops items to limit the rate. However, if the source is running
    slower, the `Sample` operator will just repeat the last value to ensure a constant
    supply of notifications.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sample`操作符根据其`TimeSpan`参数指定的间隔从其输入中产生项，而不管输入可观察对象生成项的速率如何。如果底层源产生的项比所选速率快，`Sample`会丢弃项以限制速率。然而，如果源运行较慢，`Sample`操作符会重复最后一个值，以确保持续供应通知。'
- en: Timeout
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Timeout
- en: The `Timeout` operator passes everything through from its source observable
    unless the source leaves too large a gap between either the subscription time
    and the first item or between two subsequent calls to the observer. You specify
    the minimum acceptable gap with a `TimeSpan` argument. If no activity occurs within
    that time, the `Timeout` operator completes by reporting a `TimeoutException`
    to `OnError`.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`Timeout` 操作符从其源可观察对象中传递所有内容，除非源在订阅时间和第一个项目之间或两次调用观察者之间留下了太大的间隙。你可以用 `TimeSpan`
    参数指定最小可接受的间隙。如果在该时间内没有任何活动发生，`Timeout` 操作符将通过向 `OnError` 报告 `TimeoutException`
    来完成。'
- en: Windowing Operators
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 窗口操作符
- en: I described the `Buffer` and `Window` operators earlier, but I didn’t show their
    time-based overloads. As well as being able to specify a window size and skip
    count, or to mark window boundaries with an ancillary observable source, you can
    also specify time-based windows.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前描述了 `Buffer` 和 `Window` 操作符，但没有展示它们基于时间的重载。除了能够指定窗口大小和跳过计数，或者使用辅助的可观察源标记窗口边界外，你还可以指定基于时间的窗口。
- en: If you pass just a `TimeSpan`, both operators will break the input into adjacent
    windows at the specified interval. This provides a considerably simpler way to
    estimate the words per minute than [Example 11-43](#calculating_words_per_minute).
    [Example 11-47](#timed_windows_with_buffer) shows how to achieve the same effect
    with the `Buffer` operator using a timed window.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只传递一个 `TimeSpan`，这两个操作符都会在指定的间隔时间内将输入拆分为相邻窗口。这提供了一种比 [示例 11-43](#calculating_words_per_minute)
    更简单的估算每分钟单词数的方法。[示例 11-47](#timed_windows_with_buffer) 展示了如何使用定时窗口的 `Buffer` 操作符实现相同效果。
- en: Example 11-47\. Timed windows with `Buffer`
  id: totrans-402
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-47\. 使用 `Buffer` 的定时窗口
- en: '[PRE49]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: There are also overloads accepting both a `TimeSpan` and an `int`, enabling
    you to close the current window (thus starting the next window) either when the
    specified interval elapses or when the number of items exceeds a threshold. In
    addition, there are overloads accepting two `TimeSpan` arguments. These support
    the time-based equivalent of the combination of a window size and a skip count.
    The first `TimeSpan` argument specifies the window duration, while the second
    specifies the interval at which to start new windows. This means the windows do
    not need to be strictly adjacent—you can have gaps between them, or they can overlap.
    [Example 11-48](#overlapping_timed_windows) uses this to provide more frequent
    estimates of the word rate while still using a six-second window.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 还有接受 `TimeSpan` 和 `int` 两个参数的重载，允许你在指定的间隔时间内关闭当前窗口（从而启动下一个窗口），或者在项数超过阈值时关闭窗口。此外，还有接受两个
    `TimeSpan` 参数的重载。这些重载支持窗口大小和跳过计数的时间等效组合。第一个 `TimeSpan` 参数指定窗口持续时间，而第二个参数指定开始新窗口的间隔。这意味着窗口不需要严格相邻，它们可以有间隙，或者可以重叠。[示例 11-48](#overlapping_timed_windows)
    使用这种方法提供更频繁的单词速率估算，同时仍然使用六秒窗口。
- en: Example 11-48\. Overlapping timed windows
  id: totrans-405
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-48\. 重叠的定时窗口
- en: '[PRE50]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Unlike the join-based chunking I showed in [Example 11-43](#calculating_words_per_minute),
    `Window` and `Buffer` do not double-count items because they are not based on
    a concept of overlapping durations. They treat item arrivals as instantaneous
    events, which are either inside or outside of any given window. So the examples
    I’ve just shown will provide a slightly more accurate measure of rate.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 与我在 [示例 11-43](#calculating_words_per_minute) 中展示的基于连接的分块不同，`Window` 和 `Buffer`
    不会因为它们不基于重叠持续时间的概念而重复计数项。它们将项目到达视为瞬时事件，要么在给定窗口内，要么在外部。因此，我刚刚展示的示例将提供稍微更准确的速率测量。
- en: Delay
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延迟
- en: The `Delay` operator allows you to time-shift an observable source. You can
    pass a `TimeSpan`, in which case the operator will delay everything by the specified
    amount, or you can pass a `DateTimeOffset`, indicating a specific time at which
    you would like it to start replaying its input. Alternatively, you can pass an
    observable, and whenever that observable first produces something or completes,
    the `Delay` operator will start producing the values it has stored.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delay` 操作符允许你对可观察的源进行时间偏移。你可以传递一个 `TimeSpan`，在这种情况下，操作符将延迟所有内容指定的时间量，或者你可以传递一个
    `DateTimeOffset`，指示你希望它开始重新播放其输入的特定时间。另外，你也可以传递一个可观察对象，当该可观察对象首次产生值或完成时，`Delay`
    操作符将开始产生它存储的值。'
- en: Regardless of how the time-shift duration is determined, in all cases the `Delay`
    operator attempts to maintain the same spacing between inputs. So, if the underlying
    source produces an item immediately, then another item after three seconds, and
    then a third item after a minute, the observable produced by `Delay` will produce
    items separated by the same time intervals.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 不论时间偏移持续时间如何确定，在所有情况下，`Delay` 操作符都试图保持输入之间的相同间隔。因此，如果底层源立即生成一个项目，然后三秒后生成另一个项目，再过一分钟生成第三个项目，`Delay`
    生成的可观察对象将按照相同的时间间隔生成项目。
- en: Obviously, if your source starts producing items at a ferocious rate—two million
    items in a second, perhaps—there’s a limit to the fidelity with which `Delay`
    can reproduce the exact timing of the items, but it will do its best. The limits
    on accuracy are not fixed. They will be determined by the nature of the scheduler
    you’re using and the available CPU capacity on the machine. For example, if you
    use one of the UI-based schedulers, it will be limited by the availability of
    the UI thread and the rate at which that can dispatch work. (As with all time-based
    operators, `Delay` will pick a default scheduler for you, but it provides overloads
    that let you pass one.)
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果你的源开始以惊人的速度生成项目——也许是每秒万个项目 — `Delay` 要复制项目的确切时间安排的保真度存在限制，但它会尽力而为。准确性的限制不是固定的。它们将由你使用的调度器的性质和机器上的可用
    CPU 容量确定。例如，如果你使用其中一个基于 UI 的调度器，它将受制于 UI 线程的可用性以及其能够分派工作的速率。（与所有基于时间的运算符一样，`Delay`
    将为你选择一个默认调度器，但它提供了可以传递调度器的重载。）
- en: DelaySubscription
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DelaySubscription
- en: The `DelaySubscription` operator offers a similar set of overloads to the `Delay`
    operator, but the way it tries to effect a delay is different. When you subscribe
    to an observable source produced by `Delay`, it will immediately subscribe to
    the underlying source and start buffering items, forwarding each item only when
    the required delay has elapsed. The strategy employed by `DelaySubscription` is
    simply to delay the subscription to the underlying source and then forward each
    item immediately.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '`DelaySubscription` 操作符提供了一组与 `Delay` 操作符类似的重载，但它尝试实现延迟的方式不同。当你订阅由 `Delay`
    生成的可观察源时，它将立即订阅底层源并开始缓冲项目，在所需的延迟时间过去后才转发每个项目。`DelaySubscription` 采用的策略只是延迟对底层源的订阅，然后立即转发每个项目。'
- en: For cold sources, `DelaySubscription` will typically do what you need, because
    delaying the start of work for a cold source will typically time-shift the entire
    process. But for a hot source, `DelaySubscription` will cause you to miss any
    events that occurred during the delay, and after that, you’ll start getting events
    with no time shift.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 对于冷源，`DelaySubscription` 通常会满足你的需求，因为延迟冷源的工作开始通常会使整个过程发生时间偏移。但对于热源，`DelaySubscription`
    会导致你错过延迟期间发生的任何事件，并且之后，你将开始获取没有时间偏移的事件。
- en: The `Delay` operator is more dependable—by time-shifting each item individually,
    it works for both hot and cold sources. However, it has to do more work—it needs
    to buffer everything it receives for the delay duration. For busy sources or long
    delays, this could consume a lot of memory. And the attempt to reproduce the original
    timings with a time shift is considerably more complicated than just passing items
    straight on. So, in scenarios where it is viable, `DelaySubscription` is more
    efficient.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delay` 操作符更可靠——通过单独对每个项目进行时间偏移，它适用于热源和冷源。然而，它需要更多的工作——它需要为延迟持续时间内接收到的所有内容进行缓冲。对于繁忙的源或长时间的延迟，这可能会消耗大量内存。并且，试图通过时间偏移来复制原始时间安排比直接传递项目要复杂得多。因此，在适用的场景中，`DelaySubscription`
    更有效率。'
- en: Reaqtor—Rx as a Service
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reaqtor — Rx 作为服务
- en: In May of 2021, Microsoft open sourced Reaqtor, a set of components that makes
    it possible to host long-running Rx queries in a service. Microsoft has been using
    this internally to provide event-driven functionality in a variety of its online
    services, including the Bing search engine and the online versions of Office.
    It enables features such as setting up alerts that tell you when you’ll need to
    leave to get to an appointment on time given current traffic conditions, for example.
    It has a proven track record of being able to maintain millions of active queries.
    The code for the core libraries that make this possible is hosted at [the Reaqtor
    source repository](https://github.com/reaqtive/reaqtor), and you can find [documentation
    and supporting information](https://reaqtive.net).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2021 年 5 月，微软开源了 Reaqtor，这是一组组件，使得能够在服务中托管长时间运行的 Rx 查询成为可能。微软在其多种在线服务中内部使用了这些组件，包括必应搜索引擎和
    Office 的在线版本，为其提供事件驱动功能。例如，它使得设置提醒成为可能，告诉你根据当前交通情况需要何时离开以准时赴约。Reaqtor 已经被证明能够维护数百万活跃查询的记录。使这一切成为可能的核心库的代码托管在
    [Reaqtor 源代码仓库](https://github.com/reaqtive/reaqtor)，你可以在 [文档和支持信息](https://reaqtive.net)
    找到相关内容。
- en: Reaqtor takes the programming model of Rx—observable sequences, subjects, and
    operators—and exploits .NET’s expression tree features described in [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events)
    to enable queries to be stored or sent across the network. It also provides versions
    of standard LINQ operators that are able to persist their state, enabling queries
    with stateful operators (e.g., `Aggregate`, `DistinctUntilChanged`, or anything
    else that needs to remember something about what it has already seen) to survive
    beyond the lifetime of any single process. This enables an application to define
    a LINQ query to some observable source of data and set up a subscription to that
    query that will be hosted in a server pool, persisting with an arbitrarily long
    lifetime. Reaqtor is designed to offer the same kind of durability as a database,
    so some of Microsoft’s applications have Rx queries that have been running uninterrupted
    for several years.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: Reaqtor 借用了 Rx 的编程模型——可观察序列、主题和操作符，并利用了 .NET 的表达式树功能（详见 [第 9 章](ch09.xhtml#ch_delegates_lambdas_events)）来实现可以存储或发送网络传输的查询。它还提供了标准
    LINQ 操作符的版本，能够持久化它们的状态，使得带有状态操作符的查询（如 `Aggregate`、`DistinctUntilChanged` 或其他需要记住已见数据的操作符）可以在任何单个进程生命周期之外继续存在。这使得一个应用程序能够定义一个
    LINQ 查询到某个数据源的可观察对象，并设置一个订阅该查询的服务器池，其寿命可以任意长。Reaqtor 的设计旨在提供与数据库相同的耐久性，因此微软的一些应用程序中有
    Rx 查询已经连续运行数年未中断。
- en: The relationship between Rx and Reaqtor is not unlike the relationship between
    LINQ to Objects and Entity Framework (EF) Core. As you saw in [Chapter 10](ch10.xhtml#ch_linq),
    LINQ to Objects is built on `IEnumerable<T>`, and it works entirely in-memory,
    with no persistence or cross-process capability. EF Core takes the same basic
    concepts and offers most of the same operators, but by building on the expression-tree-based
    `IQueryable<T>`, EF Core is able to send representations of an application’s queries
    over to a database server so that they can be executed remotely—EF Core brings
    LINQ into a world of durable persistence and distributed execution. Similarly,
    whereas Rx is built on `IObservable<T>` and runs entirely in-memory, Reaqtor uses
    an expression-tree-based interface `IQbservable<T>`. (Note the Q instead of an
    O, denoting its similarity in concept to `IQueryable<T>`.) `IQbservable<T>` looks
    very similar to `IObservable<T>` and offers all of the same operators, but because
    it works in the world of expression trees, it is possible for Reaqtor to convert
    queries into a form that can be sent over the network to a server farm, which
    can then reconstitute runnable versions of those queries hosted inside the server
    farm. It exploits the serializability to store the queries, enabling them to be
    migrated from one machine to another within the server farm, providing persistence
    and durability in the face of individual server failures. Reaqtor brings Rx into
    a world of durable persistence and distributed execution.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: Rx 和 Reaqtor 之间的关系与 LINQ to Objects 和 Entity Framework (EF) Core 之间的关系非常相似。正如您在
    [第 10 章](ch10.xhtml#ch_linq) 中看到的那样，LINQ to Objects 是建立在 `IEnumerable<T>` 上的，并且完全在内存中工作，没有持久性或跨进程能力。EF
    Core 使用相同的基本概念，并提供大多数相同的操作符，但是通过基于表达树的 `IQueryable<T>` 来构建，EF Core 能够将应用程序的查询表示发送到数据库服务器，以便远程执行这些查询。EF
    Core 将 LINQ 带入了持久性耐久性和分布式执行的世界。类似地，Rx 是建立在 `IObservable<T>` 上的，并且完全在内存中运行，而 Reaqtor
    则使用基于表达树的接口 `IQbservable<T>`。（请注意，Q 代替了 O，表示其与 `IQueryable<T>` 在概念上的相似性。）`IQbservable<T>`
    看起来与 `IObservable<T>` 非常相似，并提供所有相同的操作符，但是因为它在表达树的世界中工作，Reaqtor 能够将查询转换为可以发送到服务器群的形式，然后服务器群内部能够重新构建可运行版本的这些查询。它利用可序列化性来存储查询，使得这些查询能够在服务器群内的不同机器之间迁移，提供了在单个服务器故障面前的持久性和耐久性。Reaqtor
    将 Rx 带入了持久性耐久性和分布式执行的世界。
- en: At the time of writing this, there isn’t an off-the-shelf hosted version of
    Reaqtor freely available, so it takes quite a lot of work to build something real
    from the Reaqtor libraries. But I’ve built a couple of applications on top of
    this with my employer, so I can say with confidence that it is certainly possible.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，还没有现成的免费可托管的 Reaqtor 版本，因此从 Reaqtor 库构建真实应用需要相当多的工作。但是我已经在雇主那里基于此构建了几个应用程序，所以我可以自信地说，这绝对是可行的。
- en: Summary
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As you’ve now seen, the Reactive Extensions for .NET provide a lot of functionality.
    The concept underpinning Rx is a well-defined abstraction for sequences of items
    where the source decides when to provide each item, and a related abstraction
    representing a subscriber to such a sequence. By representing both concepts as
    objects, event sources and subscribers both become first-class entities, meaning
    you can pass them as arguments, store them in fields, and generally do anything
    with them that you can do with any other data type in .NET. While you can do all
    of that with a delegate too, .NET events are not first class. Moreover, Rx provides
    a clearly defined mechanism for notifying a subscriber of errors, something that
    neither delegates nor events handle well. As well as defining a first-class representation
    for event sources, Rx defines a comprehensive LINQ implementation, which is why
    Rx is sometimes described as LINQ to Events. In fact, it goes well beyond the
    set of standard LINQ operators, adding numerous operators that exploit and help
    to manage the live and potentially time-sensitive world that event-driven systems
    occupy. Rx also provides various services for bridging between its basic abstractions
    and those of other worlds, including standard .NET events, `IEnumerable<T>`, and
    various asynchronous models.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你现在所见，Reactive Extensions for .NET 提供了大量功能。Rx 的基本概念是一种对项序列的良好抽象，其中源决定何时提供每个项，以及一个相关的表示订阅者的抽象。通过将这两个概念表示为对象，事件源和订阅者都成为一流实体，这意味着你可以将它们作为参数传递，存储在字段中，并且通常可以像处理其他任何数据类型一样处理它们。虽然你也可以使用委托完成所有这些操作，但.NET
    事件不是一流的。此外，Rx 提供了一种明确定义的机制来通知订阅者错误，而委托和事件都不擅长处理这一点。除了定义事件源的一流表示外，Rx 还定义了一个全面的
    LINQ 实现，这就是为什么有时将 Rx 描述为 LINQ 到事件的原因。事实上，它远远超出了标准 LINQ 运算符的范围，添加了许多运算符，这些运算符利用和帮助管理事件驱动系统所处的实时和潜在时间敏感的世界。Rx
    还提供各种服务，用于在其基本抽象和其他世界（包括标准的.NET 事件、`IEnumerable<T>` 和各种异步模型）之间进行桥接。
- en: ^([1](ch11.xhtml#CHP-11-FN-1-marker)) You can download the full WPF example
    to which this snippet belongs as part of the examples for this book.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch11.xhtml#CHP-11-FN-1-marker)) 你可以下载完整的 WPF 示例，作为本书示例的一部分。
- en: ^([2](ch11.xhtml#CHP-11-FN-2-marker)) It is missing the `OrderBy` and `ThenBy`
    operators, because these make little sense in a push-based world. They cannot
    produce any items until they have seen all of their input items.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch11.xhtml#CHP-11-FN-2-marker)) 在推送式的世界中，缺少了`OrderBy`和`ThenBy`操作符，因为在看到所有输入项之前，它们不能生成任何项。
- en: ^([3](ch11.xhtml#CHP-11-FN-3-marker)) Like some developers.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch11.xhtml#CHP-11-FN-3-marker)) 像一些开发者。
- en: ^([4](ch11.xhtml#CHP-11-FN-4-marker)) The overloads are spread across multiple
    classes because some of these extension methods are technology specific. WPF gets
    `ObserveOn` overloads that work directly with its `Dispatcher` class instead of
    `IScheduler`, for example.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch11.xhtml#CHP-11-FN-4-marker)) 这些重载分布在多个类中，因为一些扩展方法是特定于技术的。例如，WPF 获取与其`Dispatcher`类直接配合而不是`IScheduler`的`ObserveOn`重载。
- en: ^([5](ch11.xhtml#CHP-11-FN-5-marker)) In fact, `Publish` uses `Subject<T>` internally
    in the current version of Rx.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch11.xhtml#CHP-11-FN-5-marker)) 实际上，`Publish`在当前版本的 Rx 中内部使用`Subject<T>`。
