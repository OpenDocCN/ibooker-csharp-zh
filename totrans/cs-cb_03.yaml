- en: Chapter 3\. Ensuring Quality
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章 确保质量
- en: All the best practices, fancy algorithms, and patterns in the world mean nothing
    if the code doesn’t work properly. We all want to build the best app possible
    and minimize bugs. The themes of this chapter revolve around maintainability,
    error prevention, and writing correct code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的最佳实践、复杂算法和模式，在代码工作正常的情况下毫无意义。我们都希望构建尽可能最好的应用程序并最小化错误。本章的主题围绕可维护性、错误预防和编写正确的代码。
- en: When working on a team, other developers must work with the code you write.
    They add new features and fix bugs. If you write code that’s easy to read, it
    will be more maintainable—that is, other developers will be able to read and understand
    it. Even if you’re the sole developer, coming back to code you’ve written in the
    past can be a new experience. Increased maintainability leads to fewer new bugs
    being introduced and quicker task turnaround. Fewer bugs mean fewer software life-cycle
    costs and more time for other value-added features. It is this spirit of maintainability
    that motivates the content in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在团队合作时，其他开发人员必须与您编写的代码一起工作。他们会添加新功能并修复错误。如果您编写的代码易于阅读，那么它将更易于维护，即其他开发人员将能够阅读和理解它。即使您是唯一的开发人员，回顾过去编写的代码也可能是一种新体验。增强的可维护性导致引入较少的新错误，并且任务周转更快。较少的错误意味着较少的软件生命周期成本，为其他增值功能提供更多时间。正是这种可维护性的精神激励了本章内容。
- en: Similar to maintainability, error prevention is an important quality concept.
    Users can and will use apps in a way that finds the one bug that we never thought
    would happen. Recipes [3.1](#writing_a_unit_test) and [3.4](#protecting_code_from_nullreferenceexception)
    give essential tools to help. Proper exception handling is an important skill
    and you’ll learn that too.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 与可维护性类似，错误预防是一个重要的质量概念。用户可以并且将使用应用程序发现我们从未想过会发生的一个错误。章节[3.1](#writing_a_unit_test)和[3.4](#protecting_code_from_nullreferenceexception)提供了帮助的关键工具。正确的异常处理是一项重要的技能，您也将学到这一点。
- en: Another feature of quality is to ensure the code is correct, and unit testing
    is an essential practice. Although unit testing has been with us for a long time,
    it isn’t a solved problem. A lot of developers still don’t write unit tests. However,
    it’s such an important topic that the first section in this chapter shows you
    how to write a unit test.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 质量的另一个特征是确保代码正确，单元测试是一种重要的实践。虽然单元测试已经存在很长时间，但它并不是一个解决的问题。许多开发人员仍然不写单元测试。然而，这是一个如此重要的主题，本章的第一部分将向您展示如何编写单元测试。
- en: 3.1 Writing a Unit Test
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.1 编写单元测试
- en: Problem
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Quality-assurance professionals are continually finding problems during integration,
    testing, and you want to reduce the number of bugs that are checked in.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 质量保证专业人员在集成测试期间持续发现问题，您希望减少检查到的错误数量。
- en: Solution
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s the code to test:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是测试的代码：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A separate test project has unit tests:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 单独的测试项目包含单元测试：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Discussion
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The code to test is the system under test (SUT), and the code that tests it
    is called a *unit test*. Unit tests are typically in a separate project, referencing
    the SUT, avoiding bloating the deliverable assembly by not shipping test code
    with production code. The size of the unit to test is often a type like a class,
    record, or struct. The solution has an `Order` class (SUT) with a `CalculateDiscount`
    method. The unit tests ensure `CalculateDiscount` operates correctly.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试的代码是系统的被测代码（SUT），测试它的代码称为*单元测试*。单元测试通常在一个独立的项目中，引用SUT，通过不将测试代码与生产代码一起发布来避免膨胀可交付组件的大小。要测试的单元通常是类、记录或结构类型。解决方案中有一个`Order`类（SUT），其中有一个`CalculateDiscount`方法。单元测试确保`CalculateDiscount`能够正确操作。
- en: There are several well-known unit test frameworks, and you can try a few and
    use the one you like best. These examples use XUnit. Most of the unit test frameworks
    integrate with Visual Studio and other IDEs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个众所周知的单元测试框架，您可以尝试几个，并选择最喜欢的一个使用。这些示例使用了XUnit。大多数单元测试框架与Visual Studio和其他IDE集成。
- en: Unit test frameworks help identify unit test code with attributes. Some have
    an attribute for the test class, but XUnit doesn’t. With XUnit, you only need
    to add a `[Fact]` attribute to the unit test and it will work with the IDE or
    other tooling you’re using. The XUnit authors wanted to reduce excessive attribute
    usage and make it easier for F# (and other .NET languages) to use the framework.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试框架帮助使用属性识别单元测试代码。一些框架为测试类添加了一个属性，但XUnit没有。对于XUnit，您只需要为单元测试添加一个`[Fact]`属性，它将与您正在使用的IDE或其他工具配合使用。XUnit的作者希望减少过度使用属性，并使F#（以及其他.NET语言）更容易使用该框架。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: That unit testing frameworks use attributes to identify tests is interesting.
    They do this using a .NET feature called *reflection*. [Recipe 5.1](ch05.xhtml#reading_attributes_with_reflection)
    shows how you can use reflection to work with attributes in your code so you can
    build your own tools.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试框架使用属性来识别测试是很有趣的。它们使用了一个名为*reflection*的.NET特性。[Recipe 5.1](ch05.xhtml#reading_attributes_with_reflection)展示了如何使用reflection在代码中处理属性，以便您可以构建自己的工具。
- en: 'The naming convention of the unit tests indicates their purpose, making it
    easy to read. The `OrderTests` class indicates that its unit tests operate on
    the `Order` class. Unit test method names have the following pattern:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的命名约定指示了它们的目的，使其易于阅读。`OrderTests`类指示其单元测试操作`Order`类。单元测试方法的命名模式如下：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The first unit test, `CalculateDiscount_WithBronzeCustomer_GivesNoDiscount`,
    follows this pattern where:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个单元测试，`CalculateDiscount_WithBronzeCustomer_GivesNoDiscount`，遵循以下模式：
- en: '`CalculateDiscount` is the method to test.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CalculateDiscount`是要测试的方法。'
- en: '`WithBronzeCustomer` specifies what is unique about the input for this particular
    test.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WithBronzeCustomer`指定了这个特定测试的输入中的独特之处。'
- en: '`GivesNoDiscount` is the result to verify.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GivesNoDiscount`是要验证的结果。'
- en: The organization of the unit tests uses a format called Arrange, Act, and Assert
    (AAA). The following discussion covers each of these parts of the test format.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的组织使用了一种称为安排、执行和断言（AAA）的格式。以下讨论涵盖了测试格式的每个部分。
- en: The arrange section creates all the necessary types for the test to occur. In
    these unit tests, the arrange creates a `const ExpectedDiscount`. In more complex
    scenarios, the arrange part will instantiate input parameters that establish the
    appropriate conditions for the test. In this example, the conditions were so simple
    that they are written as constant parameters in the act part.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 安排部分创建了测试发生所需的所有类型。在这些单元测试中，安排创建了一个`const ExpectedDiscount`。在更复杂的情况下，安排部分将实例化输入参数，以建立适当的测试条件。在这个例子中，条件非常简单，它们被写成了执行部分的常量参数。
- en: The act part is a method call that takes parameters, if any, that create the
    conditions to be tested. In these examples, the act part instantiates an `Order`
    instance and calls `CalculateDiscount` with the appropriate parameter values,
    assigning the response to `actualDiscount`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 执行部分是一个方法调用，如果有的话，会传入参数，创建要测试的条件。在这些示例中，执行部分实例化了一个`Order`实例，并调用`CalculateDiscount`，传入适当的参数值，将响应分配给`actualDiscount`。
- en: The `Assert` class belongs to the XUnit testing framework. Appropriately named,
    `Assert` statements are used in the assert part of the test. Notice the naming
    convention I used for `actualDiscount` and `ExpectedDiscount`. The `Assert` class
    has several methods, with `Equal` being very popular because it allows you to
    compare what you expected to what you actually received during the act part.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`Assert`类属于XUnit测试框架。恰如其名，`Assert`语句用于测试的断言部分。请注意我为`actualDiscount`和`ExpectedDiscount`使用的命名约定。`Assert`类有几种方法，其中`Equal`非常受欢迎，因为它允许您比较您在执行部分期望的结果和实际收到的结果。'
- en: The benefits you get from unit tests potentially include better code design,
    verification that the code does what was intended, protection against regressions,
    deployment validation, and documentation. The key word here is *potential* because
    different people and/or teams choose the benefit they want from unit tests.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您从单元测试中可能获得的好处包括更好的代码设计，验证代码是否符合预期，防止回归，部署验证和文档编制。关键词在于*可能*，因为不同的人和/或团队选择他们想要从单元测试中获得的好处。
- en: The better code design comes from writing tests before writing the code. You
    might have heard this technique discussed in agile or behavior-driven development
    (BDD) environments. In making the developer think about expected behavior ahead
    of time, a clearer design might evolve. On the other hand, you might want to write
    unit tests after the code is written. Developers write code and unit tests both
    ways and opinions differ on what is preferable. Ultimately, having the tests,
    regardless of how you arrived there, is more likely to improve code quality better
    than not having tests.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的代码设计来自于在编写代码之前编写测试。你可能听说过这种技术在敏捷或行为驱动开发（BDD）环境中被讨论过。通过让开发者提前考虑预期行为，可能会产生更清晰的设计。另一方面，你可能希望在编写代码之后编写单元测试。开发者们以两种方式编写代码和单元测试，对于哪种方式更可取存在不同意见。但无论如何，拥有测试，比起没有测试，更有可能提高代码质量。
- en: The second point of verifying that the code does what is intended is the biggest
    benefit. For simple methods that serve more as code documentation, it isn’t a
    big deal. However, for complex algorithms or something critical like ensuring
    customers receive the right discount, unit tests save the day.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点验证代码是否达到预期目的是最大的好处。对于像服务于代码文档的简单方法来说，这并不是什么大问题。然而，对于复杂的算法或像确保客户获得正确折扣这样关键的任务来说，单元测试确实发挥了重要作用。
- en: Another important benefit is protecting against regressions. When, not if, the
    code changes, you or another developer could introduce bugs where the original
    intent of the code was accidentally changed. By running the unit tests after changing
    code, you can find and fix bugs at the source and not later by quality-assurance
    professionals or (even worse) customers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的好处是防止回归。当代码发生变化时，你或其他开发者可能会意外改变代码的原始意图，引入错误。通过在修改代码后运行单元测试，可以在源头找到并修复错误，而不是由质量保证专业人员或（更糟糕的是）客户在后期发现。
- en: With modern DevOps, we have the ability to automate builds through continuous
    deployment. You can add unit test runs to a DevOps pipeline, which catches errors
    before they’re merged with the rest of the code. The more unit tests you have,
    the more this technique reduces the possibility of any developers breaking the
    build.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 随着现代化的 DevOps，我们有能力通过持续部署来自动化构建。你可以将单元测试运行添加到 DevOps 管道中，这样可以在与其余代码合并之前捕获错误。拥有更多的单元测试可以通过这种技术减少开发者破坏构建的可能性。
- en: Finally, you have another level of documentation. That’s why the naming conventions
    for unit tests are important. If another developer, unfamiliar with an application,
    needs to understand the code, the unit tests can explain what the correct behavior
    of that code should be.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你还有另一层文档。这就是为什么单元测试的命名约定如此重要。如果另一个不熟悉应用程序的开发者需要理解代码，单元测试可以解释代码应该具有的正确行为。
- en: This discussion was to get you started with unit tests, if you aren’t already
    using them. You can learn more by searching for XUnit and other unit testing frameworks
    to see how they work. If you haven’t done so yet, please review [Recipe 1.2](ch01.xhtml#removing_explicit_dependencies),
    which describes techniques that make code more testable.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有使用单元测试，本讨论将帮助你入门。你可以通过搜索 XUnit 和其他单元测试框架来了解它们的工作原理。如果你还没有这样做，请查看[食谱 1.2](ch01.xhtml#removing_explicit_dependencies)，其中描述了使代码更具可测试性的技术。
- en: See Also
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 1.2, “Removing Explicit Dependencies”](ch01.xhtml#removing_explicit_dependencies)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[食谱 1.2，“移除显式依赖项”](ch01.xhtml#removing_explicit_dependencies)'
- en: '[Recipe 5.1, “Reading Attributes with Reflection”](ch05.xhtml#reading_attributes_with_reflection)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[食谱 5.1，“使用反射读取属性”](ch05.xhtml#reading_attributes_with_reflection)'
- en: 3.2 Versioning Interfaces Safely
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.2 版本化接口的安全性
- en: Problem
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to update an interface in one of your libraries without breaking deployed
    code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在一个库中安全地更新一个接口，而不会破坏已部署的代码。
- en: Solution
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Interface before update:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 更新前的接口：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Interface after update:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的接口：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`CompanyOrder` before update:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompanyOrder` 更新前：'
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`CompanyOrder` after update:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompanyOrder` 更新后：'
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`CustomerOrder` before and after update:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerOrder` 更新前后：'
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here’s how the types are used:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是类型的使用方式：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Discussion
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Prior to C# 8, we couldn’t add new members to an existing interface without
    changing all the types that implement that interface. If those implementing types
    resided in the same code base, it was a recoverable change. However, for framework
    libraries where developers relied on an interface to work with that library, this
    would be a breaking change.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 8之前，我们无法向现有接口添加新成员，而不改变实现该接口的所有类型。如果这些实现类型位于同一代码库中，这是可以修复的更改。然而，对于框架库，开发人员依赖于接口与该库进行交互，这将是一个破坏性变更。
- en: The solution describes how to update interfaces and the effects. The scenario
    is for a customer that might want to apply some reward points, earned previously,
    to a current order.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案描述了如何更新接口以及其影响。这个场景适用于可能希望将之前赚取的一些奖励点数应用到当前订单的客户。
- en: Looking at `IOrder`, you can see that the after update version adds a `GetRewards`
    method. Historically, interfaces were not allowed to have implementations. However,
    in the new version of `IOrder`, the `GetRewards` method has a default implementation
    that returns `$0.00` as the rewards.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`IOrder`，您可以看到更新后版本添加了`GetRewards`方法。从历史上看，接口是不允许有实现的。然而，在新版本的`IOrder`中，`GetRewards`方法有一个默认实现，返回`$0.00`作为奖励。
- en: The solution also has a before and after version of the `CompanyOrder` class,
    where the after version contains an implementation of `GetRewards`. Now, instead
    of the default implementation, any code invoking `GetRewards` through a `CompanyOrder`
    instance will execute the `CompanyOrder` implementation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案还介绍了`CompanyOrder`类的前后版本，其中后版本包含了`GetRewards`的实现。现在，任何通过`CompanyOrder`实例调用`GetRewards`的代码将执行`CompanyOrder`的实现，而不是默认的实现。
- en: In contrast, the solution shows a `CustomerOrder` class that also implements
    `IOrder`. The difference here is that `CustomerOrder` didn’t change. Any code
    invoking `GetRewards` through a `CompanyOrder` instance will execute the default
    `IOrder` implementation.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，解决方案展示了一个同样实现了`IOrder`的`CustomerOrder`类。这里的区别在于`CustomerOrder`没有改变。任何通过`CompanyOrder`实例调用`GetRewards`的代码将执行默认的`IOrder`实现。
- en: The `Program Main` method shows how this works. The `orders` is a list of `IOrder`,
    with runtime instances of `CustomerOrder` and `CompanyOrder`. The `foreach` loops
    through `orders`, calling `IOrder` methods. As described earlier, invoking `GetRewards`
    for the `CompanyOrder` instance uses that class’s implementation, whereas `CustomerOrder`
    uses the default `IOrder` implementation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`Program Main`方法展示了这是如何工作的。`orders`是一个`IOrder`列表，包含`CustomerOrder`和`CompanyOrder`的运行时实例。`foreach`循环遍历`orders`，调用`IOrder`的方法。如前所述，对于`CompanyOrder`实例调用`GetRewards`会使用该类的实现，而`CustomerOrder`则使用默认的`IOrder`实现。'
- en: Essentially, the change means that if a developer implements `IOrder` in their
    own class, such as `CustomerOrder`, their code doesn’t break when updating the
    library to the latest version.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，这个变化意味着如果开发人员在自己的类中实现`IOrder`，比如`CustomerOrder`，他们的代码在更新到最新版本时不会中断。
- en: 3.3 Simplifying Parameter Validation
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.3 简化参数验证
- en: Problem
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You’re always looking for ways to simplify code, including parameter validation.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你总是在寻找简化代码的方法，包括参数验证。
- en: Solution
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Verbose parameter validation syntax:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 冗长的参数验证语法：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Brief parameter validation syntax:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 简洁的参数验证语法：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Discussion
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The first code of a public method is often concerned with parameter validation,
    which can sometimes be verbose. This section shows how to save a few lines of
    code so they don’t obscure the code pertaining to the original purpose of the
    method.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 公共方法的第一行代码通常涉及参数验证，有时可能会很冗长。此部分展示了如何节省几行代码，以免混淆原方法的目的代码。
- en: 'The solution has two parameter validation techniques: verbose and brief. The
    verbose method is typical, where the code ensures that a parameter isn’t `null`
    and throws otherwise. The parentheses aren’t required in this single-line throw
    statement, but some developers/teams prefer for them to be there anyway if their
    coding standards require the parentheses because of a style issue or to avoid
    future maintenance mistakes for statements that should be in the `if` block.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案有两种参数验证技术：冗长和简洁。冗长的方法是典型的，代码确保参数不为空，并在其他情况下抛出异常。在这种单行抛出语句中，括号并不是必需的，但是如果编码标准要求括号出现，某些开发人员/团队可能仍然会喜欢它们，以避免未来维护错误，特别是对于应该在`if`块中的语句。
- en: 'The brief method is an alternative that can save a few lines of code. It relies
    on newer features of C#: the variable discard, `_`; and coalescing operator, `??`.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的方法是可以节省几行代码的替代方法。它依赖于C#的新功能：变量丢弃`_`和合并运算符`??`。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The simplified parameter validation with coalescing operator and discard fits
    on a single line. However, for formatting in the book, it’s necessary to use two
    lines.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用合并运算符和丢弃进行简化的参数验证适合单行。然而，为了书本格式，需要使用两行。
- en: On the line validating `customer`, the code starts with an assignment to the
    discard, because we need an expression. The coalescing operator is a guard that
    detects when the expression is `null`. When the expression is `null`, the next
    statement executes, throwing an exception.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证`customer`的行上，代码以丢弃的赋值开头，因为我们需要一个表达式。合并运算符是一个检测表达式为`null`时执行下一条语句的保护。
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: This example was for parameter evaluation. However, there are other scenarios
    where the code encounters a variable that was set to `null` and needs to throw
    for an invalid condition or a situation that never should have occurred. This
    technique lets you handle that quickly in a single line of code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例是用于参数评估。但是，在代码遇到设置为`null`的变量并需要抛出无效条件或本不应发生的情况时，还有其他场景。此技术让您可以快速处理单行代码。
- en: See Also
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 3.4, “Protecting Code from NullReferenceException”](#protecting_code_from_nullreferenceexception)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3.4节，“保护代码免受NullReferenceException”](#protecting_code_from_nullreferenceexception)'
- en: 3.4 Protecting Code from NullReferenceException
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.4 保护代码免受NullReferenceException
- en: Problem
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You’re building a reusable library and need to communicate nullable reference
    semantics.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在构建一个可重用库，并需要传达可空引用语义。
- en: Solution
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This is old-style code that doesn’t handle null references:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是旧式代码，不处理空引用：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following project file turns on the new nullable reference feature:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下项目文件启用了新的可空引用特性：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here’s the updated library code that communicates nullable references:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是更新后的库代码，涉及可空引用的通信：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is an example of old-style consuming code that ignores nullable references:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个忽略可空引用的旧式消费代码示例：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[Figure 3-1](#warning_wall) shows the warning wall the user sees from consuming
    code that ignores nullable references.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-1](#warning_wall) 显示了用户在使用忽略可空引用的代码时看到的警告墙。'
- en: '![Visual Studio errors window with multiple nullable reference warnings](Images/cscb_0301.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![Visual Studio 中显示多个可空引用警告的错误窗口](Images/cscb_0301.png)'
- en: Figure 3-1\. Nullable reference warnings in Visual Studio
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-1\. Visual Studio 中的可空引用警告
- en: 'Finally, here’s how the consuming code can properly react to the reusable library
    with the proper checks and validation for nullable references:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是消费代码如何正确对待具有适当检查和验证的可重用库的示例：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Discussion
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: If you’ve been programming C# for any length of time, it’s likely that you’ve
    encountered `NullReferenceExceptions`. A `NullReferenceException` occurs when
    referencing a member of a variable that is still null, essentially trying to use
    an object that doesn’t yet exist. Nullable references, first introduced in C#
    8, help write higher-quality code by reducing the number of `NullReferenceException`
    exceptions being thrown. The whole concept revolves around giving the developer
    compile-time notice of situations where variables are null and could potentially
    result in a thrown `NullReferenceException`. This scenario is based on the need
    to write a reusable library, perhaps a separate class library or NuGet package,
    for other developers. Your goal is to let them know where a potential null reference
    occurs in the library so they can write code to protect against a `NullReferenceException`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经使用C#编程一段时间，很可能遇到过`NullReferenceExceptions`。当引用仍为null的变量的成员时会发生`NullReferenceException`，实质上是试图使用尚不存在的对象。C#
    8首次引入了可空引用，通过减少抛出的`NullReferenceException`异常数量来帮助编写更高质量的代码。整个概念围绕着在编译时通知开发人员变量为null的情况，可能导致抛出`NullReferenceException`。这种情况基于需要为其他开发人员编写可重用库，可能是一个单独的类库或NuGet包。您的目标是让他们知道库中可能发生空引用的位置，以便他们编写代码来防止`NullReferenceException`。
- en: 'To demonstrate, the solution shows library code that doesn’t communicate null
    references. Essentially, this is old-style code, representing what developers
    would have written before C# 8\. You’ll also see how to configure a project to
    support C# 8 nullable references. Then you’ll view how to change that library
    code so it communicates null references to a developer who might consume it. Finally,
    you’ll see two examples of consuming code: one that doesn’t handle null references
    and another that shows how to protect against null references.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，解决方案展示了不通知空引用的库代码。本质上，这是旧式代码，展示了C# 8之前开发人员会编写的代码。您还将看到如何配置项目以支持C# 8的可空引用。然后，您将了解如何更改该库代码，以向可能消费它的开发人员传达空引用。最后，您将看到两个消费代码的示例：一个不处理空引用，另一个显示如何防止空引用。
- en: In the first solution example, the `OrderLibraryNonNull` class has members with
    parameters or return types that are reference types, such as `string` and `List<string>`,
    both of which could potentially be set to null. In both a nullable and non-nullable
    context, this code won’t generate any warnings. Even in a nullable context, the
    reference types aren’t marked as nullable and dangerously communicate to users
    that they’ll never receive a `NullReferenceException`. However, because there
    could be potential `NullReferenceExceptions`, we don’t want to write our code
    like this anymore.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个解决方案示例中，`OrderLibraryNonNull`类具有参数或返回类型为引用类型（例如`string`和`List<string>`）的成员。在可空和非可空上下文中，这段代码不会生成任何警告。即使在可空上下文中，引用类型也没有标记为可空，并且危险地传达给用户，他们永远不会收到`NullReferenceException`。然而，由于可能会出现`NullReferenceExceptions`，我们不希望再这样编写我们的代码了。
- en: The XML listing, in the solution, is the project file with a `/Project/PropertyGroup/Nullable`
    element. Setting this to `true` puts the project in a nullable context. Putting
    a separate class library into a nullable context might provide warnings for the
    class library developer, but the consumer of that code won’t ever see those warnings.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中的XML清单是项目文件，其中包含`/Project/PropertyGroup/Nullable`元素。将其设置为`true`将项目置于可空上下文中。将单独的类库放入可空上下文可能会为类库开发人员提供警告，但代码的使用者永远不会看到这些警告。
- en: 'The next solution code snippet for `OrderLibraryWithNull` fixes this problem.
    Compare it with `OrderLibraryNonNull` to tell the differences. When evaluating
    null references, go member by member through a type to think about how parameters
    and return values affect a consumer of your library in regards to null references.
    There are a lot of different null scenarios, but this example captures three common
    ones: property type, method parameter type, and generic parameter type, explained
    in the following paragraphs.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderLibraryWithNull`的下一个解决方案代码片段修复了这个问题。与`OrderLibraryNonNull`进行比较，以区分它们的不同之处。在评估空引用时，逐个成员地遍历类型，思考参数和返回值如何影响库的消费者，特别是在空引用方面。存在许多不同的空场景，但这个例子涵盖了三种常见情况：属性类型、方法参数类型和泛型参数类型，下面的段落中有详细解释。'
- en: Note
  id: totrans-105
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There are times when a method genuinely doesn’t ever return a null reference.
    Then it makes sense to not use the nullable operator to communicate to the consumer
    that they don’t need to check for null.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个方法确实不会返回空引用。这时候不使用可空操作符来告知使用者不需要检查空引用是有意义的。
- en: The `DealOfTheDay` shows the property type null reference scenario. Its `getter`
    property returns a `string`, which could potentially be a `null` value. Fix those
    with the nullable operator, `?` and return `string?`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`DealOfTheDay`展示了属性类型空引用的情景。它的`getter`属性返回一个`string`，这个值可能为空。使用可空操作符`?`来修复这些问题，并返回`string?`。'
- en: '`AddItems` is similar, except it takes a `string` parameter, demonstrating
    the method parameter scenario. Since `string` could be `null`, changing it to
    `string?` lets the compiler know too. Notice how I used the simplified parameter
    checking described in [Recipe 3.3](#simplifying_parameter_validation).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddItems`类似，只是它接受一个`string`参数，演示了方法参数的情况。由于`string`可以为`null`，将其更改为`string?`也让编译器了解了。请注意，我使用了[Recipe
    3.3](#simplifying_parameter_validation)中描述的简化参数检查。'
- en: Sometimes, you’ll encounter nullable generic parameter types. The `GetItems`
    method returns a `List<string>`, and `List<T>` is a reference type. Therefore,
    changing that to `List<string>?` fixes the problem.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能会遇到可空的泛型参数类型。`GetItems`方法返回一个`List<string>`，而`List<T>`是引用类型。因此，将其更改为`List<string>?`可以解决问题。
- en: Finally, here’s one that’s a little tricky. The items parameter in `AddItems`
    is a `List<string>`. It’s easy enough to do a parameter check to test for a `null`
    parameter, but leaving the nullable operator off is also a good approach to let
    the user know that they shouldn’t pass a `null` value.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里有一个有点棘手的例子。`AddItems` 中的 items 参数是一个 `List<string>`。可以轻松进行参数检查以测试 `null`
    参数，但是省略可空操作符也是一种好方法，以告知用户不应传递 `null` 值。
- en: That said, what if one of the values in the `List<string>` were `null`? In this
    case, it’s a `List<string>`, but what about scenarios where the users were allowed
    to pass in a `Dictionary<string, string>`, where the value could be `null`? Then
    annotate the type parameter, as the example does with `List<string?>`, to say
    it’s OK for a value to be `null`. Since you know that the parameter can be `null`,
    it’s important to check before referencing its members—to avoid a `NullReferenceException`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，如果 `List<string>` 中的一个值是 `null` 怎么办？在这种情况下，它是一个 `List<string>`，但是对于用户可以传递
    `Dictionary<string, string>` 的场景，其中值可以是 `null`，那么就像例子中对 `List<string?>` 所做的那样，注释类型参数，表示允许值为
    `null`。因为你知道参数可以为 `null`，在引用其成员之前检查是非常重要的，以避免 `NullReferenceException`。
- en: Now you have library code that’s useful for a consumer. However, it will only
    be useful if the consumer puts their project into a nullable context too, as shown
    in the project file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个对消费者有用的库代码。然而，只有消费者也将其项目置于可为空的上下文中，才能发挥其作用，如项目文件中所示。
- en: The `HandleWithNullNoHandling` method shows how a developer might have written
    code before C# 8\. However, once they put the project into a nullable context,
    they will receive several warnings, as illustrated in the warning wall showing
    the Visual Studio Error List window. Comparing that with the `HandleWithNullAndHandling`
    method, the contrast is strong.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandleWithNullNoHandling` 方法展示了在 C# 8 之前开发者可能编写的代码。然而，一旦将项目置于可为空的上下文中，将收到多个警告，如在
    Visual Studio 错误列表窗口中显示的警告墙所示。与 `HandleWithNullAndHandling` 方法进行比较，对比非常明显。'
- en: 'The whole process cascades, so start at the top of the method and work your
    way down:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程是级联的，所以从方法顶部开始，逐步向下工作：
- en: Because the `DealOfTheDay` getter can return `null`, set `deal` type to `string?`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为 `DealOfTheDay` 的 getter 可能返回 `null`，将 `deal` 的类型设置为 `string?`。
- en: Since `deal` can be `null`, use the null reference operator and a coalescing
    operator to ensure `Console.WriteLine` has something sensible to write.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 `deal` 可能为 `null`，使用空引用操作符和合并操作符确保 `Console.WriteLine` 有合理的内容可写。
- en: The type passed to `AddItems` needs to be `List<string?>` to make the statement
    that you’re aware that an item can be `null`.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传递给 `AddItems` 的类型需要是 `List<string?>`，以表明你知道一个项可能为 `null`。
- en: Instead of inlining `orders.GetItems` in the `foreach` loop, refactor it out
    into a new variable. This lets you check for `null` to avoid consuming a `null`
    iterator.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `orders.GetItems` 内联到 `foreach` 循环中，改为将其重构为一个新变量。这样可以检查 `null` 以避免使用 `null`
    迭代器。
- en: See Also
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 3.3, “Simplifying Parameter Validation”](#simplifying_parameter_validation)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 3.3, “简化参数验证”](#simplifying_parameter_validation)'
- en: 3.5 Avoiding Magic Strings
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.5 避免神奇的字符串
- en: Problem
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: A `const` string resides in multiple places in the app and you need a way to
    change it without breaking other code.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`const` 字符串在应用程序的多个位置存在，并且你需要一种方法来更改它而不会破坏其他代码。'
- en: Solution
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s an `Order` object:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 `Order` 对象：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here are some constants:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些常量：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is the program that uses `Order` and constants to calculate the number
    of days for delivery:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 `Order` 和常量计算交付天数的程序：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Discussion
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: After developing software for a while, most developers have seen their share
    of magic values, which are literal values, such as strings and numbers, written
    directly into an expression. From the perspective of the original developer, they
    might not be a huge problem. However, from the perspective of a maintenance developer,
    those literal values don’t immediately make sense. It’s as if they magically appeared
    out of nowhere, or it feels like magic that the code even works because the meaning
    of the literal value isn’t obvious.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 开发软件一段时间后，大多数开发者都见过一些神奇的值，这些是直接写入表达式的文本值和数字值。从原始开发者的角度来看，它们可能不是一个大问题。然而，从维护开发者的角度来看，这些文本值并不立即显得合理。就像它们神奇地从无处出现一样，或者感觉代码之所以工作是因为这些文本值的含义并不明显。
- en: The goal is to write code that gives a future maintainer a chance to understand.
    Otherwise, project costs increase because of the time wasted trying to figure
    out what some seemingly random number is. The solution is often to replace the
    literal value with a variable whose name expresses the semantics of the value
    or why it’s there. A commonly held belief is that readable code has a more maintainable
    lifetime than comments.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是编写能够让未来的维护人员理解的代码。否则，由于试图弄清楚某些看似随机的数字而浪费的时间，项目成本会增加。解决方案通常是用一个变量替换文字值，其名称表达了值的语义或存在的原因。一种普遍认为可读性良好的代码比注释更具可维护性的生命周期更长。
- en: Going further, a local constant helps a method with readability, but constants
    are often reusable. The solution example demonstrates how some reusable constants
    can be placed in their own class for reuse by other parts of the code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 更进一步，本地常量有助于提高方法的可读性，但常量通常是可重复使用的。解决方案示例演示了如何将一些可重复使用的常量放置在它们自己的类中，以便代码的其他部分重复使用。
- en: In addition to `items`, the `Order` class has a `DeliveryInstructions` property.
    Here, we make the assumption that there is a finite set of delivery instructions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`items`，`Order`类还有一个`DeliveryInstructions`属性。在这里，我们假设有一组有限的交货说明。
- en: The `Delivery` class has `const` `string` values for `NextDay`, `Standard`,
    and `LowFare`, characterizing how an order should be delivered. Also, notice that
    this class has a `StandardDays` value, set to `7`. Which program would you rather
    read—the one that uses `7` or the one that uses a constant named `StandardDays`?
    This makes the code easier to read, as shown in the `Program` class.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delivery`类具有`NextDay`、`Standard`和`LowFare`的`const` `string`值，描述了订单应该如何交付。此外，请注意该类有一个`StandardDays`值，设置为`7`。你更愿意阅读哪种程序——使用`7`还是使用名为`StandardDays`的常量？这使得代码更易读，正如在`Program`类中所示。'
- en: Note
  id: totrans-137
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You might first consider that the `const` `string` values in the `Delivery`
    class might be better candidates for an enum. However, notice that they have spaces.
    Also, they’ll be written with the `order`. While there are techniques for using
    enums as `string`, this was simple.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能首先考虑`Delivery`类中的`const` `string`值更适合用枚举。但请注意它们有空格。而且，它们将与`order`一起写入。虽然有技术可以将枚举用作`string`，但这很简单。
- en: In some scenarios, you need a specific `string` value for lookup. It’s a matter
    of opinion and what you think the right tool for the right job is. If you find
    a scenario where enums are more convenient, then use that route.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景中，你需要一个特定的`string`值进行查找。这是一个主观的问题，取决于你认为适合某项任务的工具。如果发现枚举更方便的情况，请使用该路线。
- en: The `Program` class uses `Orders` and `Delivery` to calculate the number of
    days for delivery, based on the order’s `DeliveryInstructions`. There are three
    orders in a list, each with a different setting for `DeliveryInstructions`. The
    `foreach` loop iterates over those orders with a `switch` statement that sets
    the number of delivery days, depending on `DeliveryInstructions`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Program`类使用`Orders`和`Delivery`来计算交货所需的天数，基于订单的`DeliveryInstructions`。列表中有三个订单，每个订单对`DeliveryInstructions`有不同的设置。`foreach`循环遍历这些订单，使用`switch`语句根据`DeliveryInstructions`设置交货天数。'
- en: Notice that both order list construction and the `switch` statement use constants
    from `Delivery`. Had that not been done, there would have been `strings` everywhere.
    Now, it’s easy to code with IntelliSense support, there is no duplication because
    the `string` is in one place, and the opportunity for mistyping is minimized.
    Further, if the `strings` need to change, that happens in one place. Additionally,
    you get IDE refactoring support to change the name everywhere that constant appears
    in the application.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到有序列表构造和`switch`语句都使用了`Delivery`中的常量。如果没有这样做，到处都会有`strings`。现在，借助IntelliSense支持，编码变得更加容易，没有重复，因为`string`只在一个地方，减少了打字错误的机会。而且，如果需要更改`strings`，只需在一个地方进行修改。此外，你还能获得IDE重构支持，以便在应用程序中改变常量出现的所有地方。
- en: 3.6 Customizing Class String Representation
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.6 自定义类字符串表示
- en: Problem
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: The class representation in the debugger, string parameters, and log files is
    illegible and you want to customize its appearance.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试器中的类表示、字符串参数和日志文件都是不可读的，你希望自定义它们的外观。
- en: Solution
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s a class with a custom `ToString` method:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个具有自定义`ToString`方法的类：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here’s an example of how that’s used:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用的示例：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And here’s the output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Discussion
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Some types are complex, and viewing an instance in the debugger is cumbersome
    because you need to dig multiple levels to examine values. Modern IDEs make this
    easier, but sometimes it’s nicer to have a more readable representation of the
    class.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有些类型很复杂，在调试器中查看实例很麻烦，因为您需要深入多个级别来检查值。现代IDE使这一过程更加轻松，但有时更希望有更可读的类表示。
- en: That’s where overriding the `ToString` method comes in. `ToString` is a method
    of the `Object` type, which all types derive from. The default implementation
    is the fully qualified name of the type, which is `Section_03_06.Order` for the
    `Order` class in the solution. Since it’s a virtual method, you can override it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是重写`ToString`方法的用处。`ToString`是所有类型派生自的`Object`类型的方法。默认实现是类型的完全限定名称，在解决方案中`Order`类的名称是`Section_03_06.Order`。由于它是虚方法，您可以重写它。
- en: In fact, the `Order` class overrides `ToString` with its own representation.
    As covered in [Recipe 2.1](ch02.xhtml#processing_strings_efficiently), the implementation
    uses `StringBuilder`. The format is using the name of the object with properties
    inside of curly braces, as shown in the output.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`Order`类使用自己的表示方式重写了`ToString`。如[第2.1节](ch02.xhtml#processing_strings_efficiently)所述，实现使用`StringBuilder`。格式使用对象名称，大括号内是属性，如输出中所示。
- en: The demo code in `Main` generates this output via the `Console.WriteLine`. This
    works because `Console.WriteLine` calls an object’s `ToString` method if a parameter
    isn’t already a `string`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Main`中，演示代码通过`Console.WriteLine`生成此输出。这是因为如果参数不是`string`，`Console.WriteLine`会调用对象的`ToString`方法。
- en: See Also
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Recipe 2.1, “Processing Strings Efficiently”](ch02.xhtml#processing_strings_efficiently)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2.1节，“高效处理字符串”](ch02.xhtml#processing_strings_efficiently)'
- en: 3.7 Rethrowing Exceptions
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.7 重新抛出异常
- en: Problem
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: An app is throwing exceptions, yet the messages are missing information, and
    you need to ensure all relevant data is available during processing.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序抛出异常，但消息缺少信息，您需要确保处理过程中所有相关数据都是可用的。
- en: Solution
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This object throws an exception:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象抛出一个异常：
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here are different ways to handle the exception:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有处理异常的不同方法：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This program tests each exception-handling method:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序测试每种异常处理方法：
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here’s the output:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出：
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Discussion
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: There are various ways to handle exceptions, with some being better than others.
    From a troubleshooting perspective, we generally want a log of exceptions with
    enough meaningful information to help solve the problem. That is the point of
    this section in determining what the better solution should be.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种处理异常的方法，其中一些比其他方法更好。从故障排除的角度来看，我们通常希望记录具有足够有意义信息的异常日志，以帮助解决问题。这正是本节的目的，确定应采用哪种更好的解决方案。
- en: 'The `Orders` class `Process` method throws an `IndexOutOfRangeException`, and
    the `OrderOrchestrator` class handles that exception in a few different ways:
    one which you should avoid and two that are better, depending on what makes sense
    for your scenario.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`Orders`类的`Process`方法抛出`IndexOutOfRangeException`，而`OrderOrchestrator`类以几种不同的方式处理该异常：其中一种是应该避免的，而另外两种则更好，具体取决于您的情况。'
- en: The `HandleOrdersWrong` method takes the `Message` property of the original
    exception and throws a new `InvalidOperationException` with that message as its
    input. The scenario models a situation where the handling analyzes the situation
    and tries to throw an exception that makes more sense or provides more information
    than what the original exception offered. However, this causes another problem
    where we lose stack trace information that’s critical to fixing the problem. This
    example has a relatively shallow hierarchy, but in practice the exception could
    have been thrown via multiple levels down and arrived via various paths. You can
    see this problem in the output where the stack trace shows that the exception
    originated in the `OrderOrchestrator.HandleOrdersWrong` method, rather than its
    true source in `Orders.Process`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandleOrdersWrong`方法获取原始异常的`Message`属性，并使用该消息作为输入抛出新的`InvalidOperationException`。该场景模拟了分析情况并尝试抛出比原始异常更具意义或提供更多信息的异常的情况。然而，这会导致另一个问题，即丢失关键的堆栈跟踪信息，这些信息对于解决问题至关重要。在实践中，异常可能通过多个级别抛出并通过不同路径到达。您可以在堆栈跟踪中看到此问题，在输出中显示异常的堆栈跟踪源自`OrderOrchestrator.HandleOrdersWrong`方法，而非其真正源自`Orders.Process`。'
- en: Warning
  id: totrans-175
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'Another thing you should never do is rethrow the original exception, like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件绝对不应该做的事情是像这样重新抛出原始异常：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The problem with this is that rethrowing the original exception loses the stack
    trace. Without the original stack trace, developers trying to debug the program
    won’t know where the exception originated. Further, the original exception might
    have been different from the one you received, potentially containing more detailed
    information that no one would see.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的问题在于重新抛出原始异常会导致丢失堆栈跟踪。没有原始堆栈跟踪，试图调试程序的开发人员将不知道异常的起源位置。此外，原始异常可能与您收到的异常不同，可能包含更详细的信息，而没有人会看到。
- en: The `HandleOrdersBetter1` method improves on this scenario by adding an additional
    argument, `ex`, to the `innerException` parameter. This provides the best of both
    worlds because you can now throw an exception with additional data, as well as
    preserving the entire stack trace. You can see that the path of the exception
    originated in `Orders.Process` in the output (delimited by `--- End of inner exception
    stack trace ---`).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandleOrdersBetter1`方法通过向`innerException`参数添加额外的参数`ex`改进了这种情况。这样做的好处在于现在可以抛出带有附加数据的异常，并保留整个堆栈跟踪。您可以在输出中看到异常路径始于`Orders.Process`（由`---
    End of inner exception stack trace ---`分隔）。'
- en: '`HandleOrdersBetter2` just throws the original exception. The assumption here
    is that the logic wasn’t able to do something intelligent with the exception or
    log and rethrow. As shown in the output, the stack trace also originates at `Orders.Process`.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandleOrdersBetter2`仅抛出原始异常。这里的假设是逻辑无法处理异常或记录并重新抛出。如输出所示，堆栈跟踪也源自`Orders.Process`。'
- en: There are a lot of strategies for handling exceptions and this covers one aspect.
    In this case, considering the preservation of original stack trace for later debugging,
    you should rethrow. As always, think about your scenario and what makes sense
    to you.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 处理异常有很多策略，本文涵盖了其中一个方面。在这种情况下，考虑保留用于后续调试的原始堆栈跟踪，您应该重新抛出异常。无论如何，都要考虑您的情景及其对您来说是否有意义。
- en: Occasionally, you might encounter a situation where code throws an exception
    and there isn’t a handling strategy. The `OrderOrchestrator.DontHandleOrders`
    doesn’t do any handling, and the `Main` method doesn’t protect with a `try/catch`.
    In this case, you can still intercept the exception by adding an event handler
    to `AppDomain.​Cur⁠rentDomain.UnhandledException`, as shown at the end of the
    `Main` method. You want to assign the event handler before running any code, otherwise
    you’ll never handle the exception.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，可能会遇到代码抛出异常但没有处理策略的情况。`OrderOrchestrator.DontHandleOrders`不执行任何处理，而`Main`方法未用`try/catch`保护。在这种情况下，仍可以通过向`AppDomain.​Cur⁠rentDomain.UnhandledException`添加事件处理程序来拦截异常，正如在`Main`方法末尾所示。在运行任何代码之前，您需要分配事件处理程序，否则将无法处理异常。
- en: See Also
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 1.9, “Designing a Custom Exception”](ch01.xhtml#designing_a_custom_exception)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 1.9, “设计自定义异常”](ch01.xhtml#designing_a_custom_exception)'
- en: 3.8 Managing Process Status
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.8 管理进程状态
- en: Problem
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: The user started a process, but after an exception, the user interface status
    wasn’t updated.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 用户启动了一个进程，但发生异常后，用户界面状态未更新。
- en: Solution
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This method throws an exception:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法会抛出异常：
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This is the code you should not write:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您不应编写的代码：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here’s the code you should write instead:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 取而代之，这是您应编写的代码：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Discussion
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The problem statement mentions there was an exception that occurred, which is
    true. However, from a user perspective, they won’t receive a message or status
    explaining that a problem occurred and their job didn’t finish. That’s because
    in the first `Main` method, if an exception throws during `ProcessOrder`, the
    “Processing Orders Complete” message won’t appear to the user.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 问题陈述提到发生了异常，这是正确的。但是，从用户角度来看，他们将不会收到解释问题发生以及其工作未完成的消息或状态。这是因为在第一个`Main`方法中，如果在`ProcessOrder`期间抛出异常，"Processing
    Orders Complete"消息不会显示给用户。
- en: This is a good use case for a `try/finally` block, which the second `Main` method
    uses. Put all the code that should run in a `try` block and a final status in
    the `finally` block. If an exception throws, you can catch it, log, and let the
    user know that their job was unsuccessful.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`try/finally`块的良好使用案例，第二个`Main`方法使用了它。将所有应在`try`块中运行的代码和最终状态放在`finally`块中。如果发生异常，可以捕获它，记录下来，并告知用户他们的任务未成功。
- en: Although this was an example in a console application, this is a good technique
    for UI code too. When starting a process, you might have a wait notification like
    an hourglass or progress indicator. Turning the notification off is a task that
    the `finally` block can help with also.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是控制台应用程序的示例，但对于 UI 代码也是一个好的技术。在启动进程时，您可能会有一个类似沙漏或进度指示器的等待通知。关闭通知也是 `finally`
    块可以帮助的任务。
- en: See Also
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 3.9, “Building Resilient Network Connections”](#building_resilient_network_connections)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3.9节，“构建弹性网络连接”](#building_resilient_network_connections)'
- en: '[Recipe 3.10, “Measuring Performance”](#measuring_performance)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3.10节，“性能测量”](#measuring_performance)'
- en: 3.9 Building Resilient Network Connections
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.9 构建弹性网络连接
- en: Problem
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: The app communicates with an unreliable backend service and you want to prevent
    it from failing.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序与不稳定的后端服务通信，您希望防止其失败。
- en: Solution
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This method throws an exception:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法会抛出异常：
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here’s a technique to handle network errors:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种处理网络错误的技术：
- en: '[PRE31]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And here’s the output:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出的内容：
- en: '[PRE32]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Discussion
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Anytime you’re doing out-of-process work, there’s a possibility of errors or
    timeouts. Often you don’t have control of the application you’re interacting with,
    and it pays to write defensive code. In particular, code that does networking
    is prone to errors unrelated to the quality of code at either end of the connection
    due to latency, timeouts, or hardware issues.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您进行进程外工作时，都有可能出现错误或超时。通常您无法控制您正在交互的应用程序，编写防御性代码非常重要。特别是进行网络操作的代码由于延迟、超时或硬件问题而容易出现与连接的两端代码质量无关的错误。
- en: This solution simulates a network connection issue through `GetOrdersAsync`.
    It throws an `HttpRequestException` with a `RequestTimeout` status. This is typical,
    and the `Main` method shows how to mitigate these types of problems. The goal
    is to retry the connection a certain number of times with delay between tries.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此解决方案通过 `GetOrdersAsync` 模拟了网络连接问题。它抛出一个带有 `RequestTimeout` 状态的 `HttpRequestException`。`Main`
    方法展示了如何减轻这些问题的方法。目标是在尝试之间以一定的延迟重试连接。
- en: First, notice that `success` initializes to `false`, and the `finally` of the
    `try/finally` lets the user know the result of the operation, based on `success`.
    Following the nesting of `try/do/try`, the last line of the `try` block sets `success`
    to `true` because all of the logic is complete—if an exception occurred earlier,
    the program would not have reached that line.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意 `success` 初始化为 `false`，`try/finally` 的 `finally` 块让用户根据 `success` 的结果了解操作的结果。在
    `try/do/try` 的嵌套中，`try` 块的最后一行将 `success` 设置为 `true`，因为所有逻辑都完成了——如果之前发生了异常，程序将无法达到那一行。
- en: The `do/while` loop iterates `RetryCount` times. We initialize `tryCount` to
    `0` and increment it in the `catch` block. That’s because if there’s an error,
    we know we’ll retry, and we want to ensure we don’t exceed a specified number
    of retries. `RetryCount` is a `const`, initialized to `3`. You can adjust `RetryCount`
    to as many times as it makes sense to you. If the operation is time sensitive,
    you might want to limit retries and send a notification of a critical error. Another
    scenario might be that you know the other end of the connection will eventually
    come back online and can set `RetryCount` to a very high number.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`do/while` 循环重试 `RetryCount` 次。我们将 `tryCount` 初始化为 `0`，并在 `catch` 块中递增它。因为如果发生错误，我们知道我们将重试，并且希望确保不超过指定的重试次数。`RetryCount`
    是一个 `const`，初始化为 `3`。您可以根据需要调整 `RetryCount` 的次数。如果操作时间敏感，您可能希望限制重试并发送关键错误的通知。另一个场景可能是，您知道连接的另一端最终会恢复在线，并可以将
    `RetryCount` 设置为非常高的数字。'
- en: Whenever there is an exception, you often don’t want to immediately make the
    request again. One of the reasons the timeout occurred might be that the other
    endpoint might not scale well, and overloading it with more requests can overwhelm
    the server. Also, some third-party APIs rate-limit clients, and immediate back-to-back
    requests eat up the rate-limit count. Some API providers might even block your
    app for excessive connection requests.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 每当出现异常时，通常不希望立即重新发起请求。一个超时的原因可能是另一端的扩展能力不强，过多的请求可能会使服务器不堪重负。此外，一些第三方 API 会对客户端进行速率限制，连续的请求会消耗速率限制计数。一些
    API 提供商甚至可能因为过多的连接请求而阻止您的应用程序。
- en: The `DelayMilliseconds` helps your retry policy, initialized to `500` milliseconds.
    You might adjust this if you find that retries are still too fast. If a single
    delay time works, then you can use that. However, a lot of situations call for
    a linear or exponential back-off strategy. You can see that the solution uses
    a linear back-off, multiplying `DelayMilliseconds` by `tryCount`. Since `tryCount`
    initializes to `0`, we increment it first.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`DelayMilliseconds`有助于您的重试策略，初始化为`500`毫秒。如果发现重试仍然太快，您可以调整这个值。如果单个延迟时间有效，那么您可以使用它。然而，许多情况需要线性或指数回退策略。您可以看到，解决方案使用了线性回退，将`DelayMilliseconds`乘以`tryCount`。由于`tryCount`初始化为`0`，我们首先递增它。'
- en: Tip
  id: totrans-219
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You might want to log retries as warning, rather than error. Administrators,
    QA, or anyone looking at the logs (or reports) might be unnecessarily alarmed.
    They see what looks like errors, whereas your application is reacting and repairing
    appropriately to typical network behavior.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望将重试记录为警告，而不是错误。管理员、质量保证或任何查看日志（或报告）的人可能会感到不必要地惊慌。他们看到看起来像错误的东西，而您的应用程序正在对典型的网络行为做出适当的反应和修复。
- en: Alternatively, you might need to use an exponential back-off strategy, such
    as taking `DelayMilliseconds` to the `tryCount` power—`Math.Pow(DelayMilliseconds,
    tryCount)`. You might experiment, e.g., log errors and review periodically, to
    see what works best for your situation.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可能需要使用指数退避策略，例如将`DelayMilliseconds`提高到`tryCount`的幂次方——`Math.Pow(DelayMilliseconds,
    tryCount)`。您可以进行实验，例如记录错误并定期审查，以查看对您的情况最有效的方法。
- en: 3.10 Measuring Performance
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.10 测量性能
- en: Problem
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You know of a few ways to write an algorithm and need to test which algorithm
    performs the best.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您知道几种编写算法的方式，并需要测试哪种算法性能最佳。
- en: Solution
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s the object type we’ll operate on:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将操作的对象类型：
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is the code that creates a list of `OrderItem`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建`OrderItem`列表的代码：
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here’s an inefficient string concatenation method:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个效率低下的字符串连接方法：
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here’s the faster `StringBuilder` method:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这是更快的`StringBuilder`方法：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This code drives the demo:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码驱动演示：
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And here’s the output:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE38]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Discussion
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '[Recipe 2.1](ch02.xhtml#processing_strings_efficiently) discussed the benefits
    of `StringBuilder` over string concatenation, which stressed performance as the
    primary driver. However, it didn’t explain how to measure the performance of the
    code. This section builds on that and shows how to measure algorithmic performance
    through code.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2.1节](ch02.xhtml#processing_strings_efficiently)讨论了`StringBuilder`相对于字符串连接的优势，强调性能是主要驱动因素。然而，它并未解释如何通过代码测量性能。本节建立在此基础上，展示了如何通过代码测量算法性能。'
- en: Tip
  id: totrans-240
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: As our computers become increasingly faster by the year (or less), the results
    of the `StringBuilder` method will move closer to `0`. To experience the real
    magnitude of time difference between the two methods, add another `0` to `ItemCount`
    in `GetOrderItems`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的计算机每年（或更少）变得越来越快，`StringBuilder`方法的结果将接近`0`。要体验两种方法之间时间差异的真实大小，可以在`GetOrderItems`的`ItemCount`中再加一个`0`。
- en: In both the `StringConcatenation` and `StringBuilderConcatenation` methods,
    you will find an instance of `StopWatch`, which is in the `System.Diagnostics`
    namespace.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在`StringConcatenation`和`StringBuilderConcatenation`方法中，您会发现`StopWatch`的实例，它位于`System.Diagnostics`命名空间中。
- en: Calling `Start` starts the timer and `Stop` stops the timer. Notice that the
    algorithms use `try/finally` as described in [Recipe 3.8](#managing_process_status)
    to ensure the timer stops.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`Start`启动计时器，`Stop`停止计时器。注意，算法使用`try/finally`，如[第3.8节](#managing_process_status)所述，以确保计时器停止。
- en: '`Console.WriteLine` uses `stopwatch.ElapsedMilliseconds` at the end of each
    algorithm to show how much time the algorithm used.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`Console.WriteLine`在每个算法末尾使用`stopwatch.ElapsedMilliseconds`显示算法使用的时间。'
- en: As shown in the output, the running time difference between `StringBuilder`
    and string concatenation is dramatic.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出所示，`StringBuilder`和字符串连接之间的运行时间差异是显著的。
- en: See Also
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 2.1, “Processing Strings Efficiently”](ch02.xhtml#processing_strings_efficiently)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2.1节，“高效处理字符串”](ch02.xhtml#processing_strings_efficiently)'
- en: '[Recipe 3.8, “Managing Process Status”](#managing_process_status)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3.8节，“管理进程状态”](#managing_process_status)'
