<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 9. Delegates, Lambdas, and Events" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_delegates_lambdas_events">
<h1><span class="label">Chapter 9. </span>Delegates, Lambdas, and Events</h1>
<p>The most common way to use an API is to invoke the methods and properties its classes provide, but sometimes things need to work in reverse—the API may need to call your code, an operation often described as a <em>callback</em>. In <a data-type="xref" href="ch05.xhtml#ch_collections">Chapter 5</a>, I showed the search features offered by arrays and lists. To use these, I wrote a method that returned <code>true</code> when its argument met my criteria, and the relevant APIs called my method for each item they inspected. Not all callbacks are this immediate. Asynchronous APIs can call a method in our code when long-running work completes. In a client-side application, I want my code to run when the user interacts with certain visual elements in particular ways, such as clicking a <span class="keep-together">button.</span></p>
<p>Interfaces and virtual methods can enable callbacks. In <a data-type="xref" href="ch04.xhtml#ch_generics">Chapter 4</a>, I showed the <code>IComparer&lt;T&gt;</code> interface, which defines a single <code>CompareTo</code> method. This is called by methods like <code>Array.Sort</code> when we want a customized sort ordering. You could imagine a UI framework that defined an <code>IClickHandler</code> interface with a <code>Click</code> method, and perhaps also <code>DoubleClick</code>. The framework could require us to implement this interface if we want to be notified of button clicks.</p>
<p>In fact, none of .NET’s UI frameworks use the interface-based approach, because it gets cumbersome when you need multiple kinds of callback. <span class="keep-together">Single-</span> and double-clicks are the tip of the iceberg for user interactions—in WPF applications, each UI element can provide over 100 kinds of notifications. Most of the time, you need to handle only one or two events from any particular element, so an interface with 100 methods to implement would be annoying.</p>
<p>Splitting notifications across multiple interfaces could mitigate this inconvenience. Default interface implementations could help, because it would make it possible to provide default, empty implementations for all callbacks, meaning we’d need to override only the ones we were interested in. (Neither .NET Standard 2.0 nor .NET Framework support this language feature, but a library targeting those could supply a base class with virtual methods instead.) But even with these refinements, there’s a serious drawback with this object-oriented approach. Imagine a UI with four buttons. In a hypothetical UI framework that used the approach I’ve just described, if you wanted each button to have its own click handler, you’d need four distinct implementations of the <code>IClickHandler</code> interface. A single class can implement any particular interface only once, so you’d need to write four classes. That seems very cumbersome when all we really want to do is tell a button to call a particular method when clicked.</p>
<p><a data-primary="delegates" data-type="indexterm" id="ix_ch09-asciidoc0"/>C# provides a much simpler solution in the form of a <em>delegate</em>, which is a reference to a method. If you want a library to call your code back for any reason, you will normally just pass a delegate referring to the method you’d like it to call. I showed an example of that in <a data-type="xref" href="ch05.xhtml#ch_collections">Chapter 5</a>, which I’ve reproduced in <a data-type="xref" href="#searching_an_array_using_a_delegate">Example 9-1</a>. This finds the index of the first element in an <code>int[]</code> array with a value above zero.</p>
<div data-type="example" id="searching_an_array_using_a_delegate">
<h5><span class="label">Example 9-1. </span>Searching an array using a delegate</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">static</code> <code class="kt">int</code> <code class="nf">GetIndexOfFirstNonEmptyBin</code><code class="p">(</code><code class="kt">int</code><code class="p">[]</code> <code class="n">bins</code><code class="p">)</code> <code class="p">=&gt;</code>
    <code class="n">Array</code><code class="p">.</code><code class="n">FindIndex</code><code class="p">(</code><code class="n">bins</code><code class="p">,</code> <code class="n">IsGreaterThanZero</code><code class="p">);</code>

<code class="k">private</code> <code class="k">static</code> <code class="kt">bool</code> <code class="nf">IsGreaterThanZero</code><code class="p">(</code><code class="kt">int</code> <code class="k">value</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="k">value</code> <code class="p">&gt;</code> <code class="m">0</code><code class="p">;</code></pre></div>
<p>At first glance, this seems very simple: the second parameter to <code>Array.FindIndex</code> requires a method that it can call to ask whether a particular element is a match, so I passed my <code>IsGreaterThanZero</code> method as an argument. But what does it really mean to pass a method, and how does this fit in with .NET’s type system, the CTS?</p>
<section data-pdf-bookmark="Delegate Types" data-type="sect1"><div class="sect1" id="delegate_types">
<h1>Delegate Types</h1>
<p><a data-type="xref" href="#method_with_a_delegate_parameter">Example 9-2</a> shows the declaration of the <code>FindIndex</code> method used in <a data-type="xref" href="#searching_an_array_using_a_delegate">Example 9-1</a>. The first parameter is the array to be searched, but it’s the second one we’re interested in—that’s where I passed a method.</p>
<div data-type="example" id="method_with_a_delegate_parameter">
<h5><span class="label">Example 9-2. </span>Method with a delegate parameter</h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="k">public</code> <code class="k">static</code> <code class="kt">int</code> <code class="n">FindIndex</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code><code class="p">(</code>
      <code class="n">T</code><code class="p">[</code><code class="p">]</code> <code class="n">array</code><code class="p">,</code>
      <strong><code class="n">Predicate</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="n">match</code></strong><code class="p">)</code></pre></div>
<p><a data-primary="Predicate&lt;T&gt; delegate type" data-type="indexterm" id="ix_ch09-asciidoc1"/>The method’s second parameter’s type is <code>Predicate&lt;T&gt;</code>, where <code>T</code> is the array element type, and since <a data-type="xref" href="#searching_an_array_using_a_delegate">Example 9-1</a> uses an <code>int[]</code>, that will be a <code>Predicate&lt;int&gt;</code>. (In case you don’t have a background in either formal logic or computer science, this type uses the word <em>predicate</em> in the sense of a function that determines whether something is true or false. For example, you could have a predicate that tells you whether a <span class="keep-together">number</span> is even. Predicates are often used in this kind of filtering operation.) <a data-type="xref" href="#the_predicateltg_delegate_type">Example 9-3</a> shows how this type is defined. This is the whole of the definition, not an excerpt; if you wanted to write a type that was equivalent to <code>Predicate&lt;T&gt;</code>, that’s all you’d need to write.</p>
<div data-type="example" id="the_predicateltg_delegate_type">
<h5><span class="label">Example 9-3. </span>The <code>Predicate&lt;T&gt;</code> delegate type</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">delegate</code> <code class="kt">bool</code> <code class="n">Predicate</code><code class="p">&lt;</code><code class="k">in</code> <code class="n">T</code><code class="p">&gt;(</code><code class="n">T</code> <code class="n">obj</code><code class="p">);</code></pre></div>
<p>Breaking <a data-type="xref" href="#the_predicateltg_delegate_type">Example 9-3</a> down, we begin as usual with the accessibility, and we can use all the same keywords we could for other types, such as <code>public</code> or <code>internal</code>. (Like any type, delegate types can optionally be nested inside some other type, in which case you can also use <code>private</code> or <code>protected</code>.) Next is the <code>delegate</code> keyword, which tells the C# compiler that we’re defining a delegate type. The rest of the definition looks, not coincidentally, just like a method declaration. We have a return type of <code>bool</code>. You put the delegate type name where you’d normally see the method name. The angle brackets indicate that this is a generic type with a single type parameter <code>T</code>, and the <code>in</code> keyword indicates that <code>T</code> is contravariant. Finally, the method signature has a single parameter of that type.</p>
<div data-type="tip"><h6>Tip</h6>
<p>The use of contravariance here lets you use a predicate that is more general than would otherwise be required. For example, because all values of type <code>string</code> are compatible with the type <code>object</code>, all values of <code>Predicate&lt;object&gt;</code> are compatible with the type 
<span class="keep-together"><code>Predicate&lt;string&gt;</code>.</span> Or to put that informally, if an API needs a method that inspects a <code>string</code>, it will work perfectly well if you pass it a method that is able to inspect any <code>object</code>. <a data-type="xref" href="ch06.xhtml#ch_inheritance">Chapter 6</a> described contravariance in detail.</p>
</div>
<p>Delegate types are special in .NET, and they work quite differently than classes or structs. The compiler generates a superficially normal-looking type definition with various members that we’ll look at in more detail later, but the members are all empty—C# produces no IL for any of them. The CLR provides the implementation at <span class="keep-together">runtime.</span></p>
<p>Instances of delegate types are usually just called delegates, and they refer to methods. A method is compatible with (i.e., can be referred to by an instance of) a particular delegate type if its signature matches. The <code>IsGreaterThanZero</code> method in <a data-type="xref" href="#searching_an_array_using_a_delegate">Example 9-1</a> takes an <code>int</code> and returns a <code>bool</code>, so it is compatible with <code>Predicate&lt;int&gt;</code>. The match does not have to be precise. <a data-primary="conversions" data-secondary="implicit" data-type="indexterm" id="idm45884812274736"/><a data-primary="implicit conversions" data-type="indexterm" id="idm45884812258208"/><a data-primary="conversions" data-secondary="reference" data-type="indexterm" id="idm45884812257600"/><a data-primary="reference conversions" data-type="indexterm" id="idm45884812256752"/>If implicit reference conversions are available for parameter types, you can use a more general method. (Although this may sound very similar to the upshot of <code>T</code> being contravariant, this is a subtly different issue. <code>T</code> being contravariant in <code>Predicate&lt;T&gt;</code> determines what types an existing instance of <code>Predicate&lt;T&gt;</code> can be converted to. This is separate from the rules around whether you can construct a new delegate of some specific type from a particular method: the signature matching rules I’m now describing apply even for nongeneric delegates, and for generic delegates with invariant type parameters.) For example, a method with a return type of <code>bool</code>, and a single parameter of type <code>object</code>, would be compatible with <code>Predicate&lt;object&gt;</code>, but because such a method can accept <code>string</code> arguments, it would also be compatible with <code>Predicate&lt;string&gt;</code>. (It would not be compatible with <code>Predicate&lt;int&gt;</code>, because there’s no implicit reference conversion from <code>int</code> to <code>object</code>. There’s an implicit conversion, but it’s a boxing conversion, not a reference conversion.)<a data-startref="ix_ch09-asciidoc1" data-type="indexterm" id="idm45884812250736"/></p>
<section data-pdf-bookmark="Creating a Delegate" data-type="sect2"><div class="sect2" id="creating_a_delegate">
<h2>Creating a Delegate</h2>
<p><a data-primary="delegates" data-secondary="creating" data-type="indexterm" id="ix_ch09-asciidoc2"/>The simplest way to create a delegate is to write just the method name. <a data-type="xref" href="#creating_a_delegate_natural_type">Example 9-4</a> declares a variable, <code>p</code>, and initializes it with the <code>IsGreaterThanZero</code> method from <a data-type="xref" href="#searching_an_array_using_a_delegate">Example 9-1</a>. (This code requires <code>IsGreaterThanZero</code> to be in scope, so we could only write this inside the same class.)</p>
<div data-type="example" id="creating_a_delegate_natural_type">
<h5><span class="label">Example 9-4. </span>Creating a delegate</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">p</code> <code class="p">=</code> <code class="n">IsGreaterThanZero</code><code class="p">;</code></pre></div>
<p>This example says nothing about the particular delegate type required, which causes the compiler to pick from one of a couple of families of generic types that I’ll be describing later in this chapter.<sup><a data-type="noteref" href="ch09.xhtml#idm45884812227040" id="idm45884812227040-marker">1</a></sup> In the unusual cases where you can’t use those, it will define a type for you. In this case, it will use <code>Func&lt;int, bool&gt;</code>, reflecting the fact that <code>IsGreaterThanZero</code> is a method that takes an <code>int</code> and returns a <code>bool</code>. This is a reasonable choice, but what if I wanted to use the <code>Predicate&lt;int&gt;</code> type because I’m planning to pass it to <code>Array.FindIndex</code>, as in <a data-type="xref" href="#searching_an_array_using_a_delegate">Example 9-1</a>? If you don’t want the compiler’s default choice, you can use the <code>new</code> keyword, as <a data-primary="Predicate&lt;T&gt; delegate type" data-secondary="creating a delegate" data-type="indexterm" id="ix_ch09-asciidoc3"/><a data-type="xref" href="#constructing_a_delegate">Example 9-5</a> shows. This lets you state the type, and where you’d normally pass constructor arguments, you can supply the name of a compatible method.</p>
<div data-type="example" id="constructing_a_delegate">
<h5><span class="label">Example 9-5. </span>Constructing a delegate</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">p</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;(</code><code class="n">IsGreaterThanZero</code><code class="p">);</code></pre></div>
<p>In practice, we rarely use <code>new</code> for delegates. It’s necessary only in cases where the compiler will not infer the right delegate type. Typically, the compiler can work it out from context. <a data-type="xref" href="#implicit_delegate_construction">Example 9-6</a> declares a variable with an explicit type, so the compiler knows a <code>Predicate&lt;int&gt;</code> is required—we don’t need to use <code>new</code> here. This compiles to the same code as <a data-type="xref" href="#constructing_a_delegate">Example 9-5</a>.</p>
<div data-type="example" id="implicit_delegate_construction">
<h5><span class="label">Example 9-6. </span>Implicit delegate construction</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">p</code> <code class="p">=</code> <code class="n">IsGreaterThanZero</code><code class="p">;</code></pre></div>
<p>That still mentions the delegate type name explicitly, but often we don’t even need to do that. <a data-type="xref" href="#searching_an_array_using_a_delegate">Example 9-1</a> correctly determined that <code>IsGreaterThanZero</code> needed to be turned into a <code>Predicate&lt;int&gt;</code> without us needing to say so. The compiler knows that the second argument to <code>FindIndex</code> is <code>Predicate&lt;T&gt;</code>, and because we supplied a first argument of type <code>int[]</code>, it deduced that <code>T</code> is <code>int</code>, so it knows the second argument’s full type is <code>Predicate&lt;int&gt;</code>. Having worked that out, it uses the same built-in implicit conversion rules to construct the delegate as <a data-type="xref" href="#implicit_delegate_construction">Example 9-6</a>. So when you pass a delegate to a method, the compiler will normally work out the right type by itself.</p>
<p>When code refers to a method by name like this, the name is technically called a <em>method group</em>, because multiple overloads may exist for a single name. The compiler narrows this down by looking for the best possible match, in a similar way to how it chooses an overload when you invoke a method. As with method invocation, it is possible that there will be either no matches or multiple equally good matches, and in those cases the compiler will produce an error.</p>
<p>Method groups can take several forms. In the examples shown so far, I have used an unqualified method name, which works only when the method in question is in scope. If you want to refer to a static method defined in some other class, you would need to qualify it with the class name, as <a data-type="xref" href="#delegates_to_methods_in_another_class">Example 9-7</a> shows.</p>
<div data-type="example" id="delegates_to_methods_in_another_class">
<h5><span class="label">Example 9-7. </span>Delegates referring to methods in another class</h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="k">internal</code> <code class="k">class</code> <code class="nc">Program</code>
<code class="p">{</code>
    <code class="k">static</code> <code class="k">void</code> <code class="nf">Main</code><code class="p">(</code><code class="kt">string</code><code class="p">[</code><code class="p">]</code> <code class="n">args</code><code class="p">)</code>
    <code class="p">{</code>
        <strong><code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">p1</code> <code class="p">=</code> <code class="n">Tests</code><code class="p">.</code><code class="n">IsGreaterThanZero</code><code class="p">;</code></strong>
        <strong><code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">p2</code> <code class="p">=</code> <code class="n">Tests</code><code class="p">.</code><code class="n">IsLessThanZero</code><code class="p">;</code></strong>
    <code class="p">}</code>
<code class="p">}</code>

<code class="k">internal</code> <code class="k">class</code> <code class="nc">Tests</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">static</code> <code class="kt">bool</code> <code class="nf">IsGreaterThanZero</code><code class="p">(</code><code class="kt">int</code> <code class="k">value</code><code class="p">)</code> <code class="p">=</code><code class="p">&gt;</code> <code class="k">value</code> <code class="p">&gt;</code> <code class="m">0</code><code class="p">;</code>

    <code class="k">public</code> <code class="k">static</code> <code class="kt">bool</code> <code class="nf">IsLessThanZero</code><code class="p">(</code><code class="kt">int</code> <code class="k">value</code><code class="p">)</code> <code class="p">=</code><code class="p">&gt;</code> <code class="k">value</code> <code class="p">&lt;</code> <code class="m">0</code><code class="p">;</code>
<code class="p">}</code></pre></div>
<p>Delegates don’t have to refer to static methods. They can refer to an instance method. There are a couple of ways you can make that happen. One is simply to refer to an instance method by name from a context in which that method is in scope. The <code>GetIsGreaterThanPredicate</code> method in <a data-type="xref" href="#implicit_instance_delegate">Example 9-8</a> returns a delegate that refers to <code>IsGreaterThan</code>. Both are instance methods, so they can be used only with an object reference, but <code>GetIsGreaterThanPredicate</code> has an implicit <code>this</code> reference, and the compiler automatically provides that to the delegate that it implicitly creates.</p>
<div data-type="example" id="implicit_instance_delegate">
<h5><span class="label">Example 9-8. </span>Implicit instance delegate</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">ThresholdComparer</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="kt">int</code> <code class="n">Threshold</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>

    <code class="k">public</code> <code class="kt">bool</code> <code class="nf">IsGreaterThan</code><code class="p">(</code><code class="kt">int</code> <code class="k">value</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="k">value</code> <code class="p">&gt;</code> <code class="n">Threshold</code><code class="p">;</code>

    <code class="k">public</code> <code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">GetIsGreaterThanPredicate</code><code class="p">()</code> <code class="p">=&gt;</code> <code class="n">IsGreaterThan</code><code class="p">;</code>
<code class="p">}</code></pre></div>
<p>Alternatively, you can be explicit about which instance you want. <a data-type="xref" href="#explicit_instance_delegate">Example 9-9</a> creates three instances of the <code>ThresholdComparer</code> class from <a data-type="xref" href="#implicit_instance_delegate">Example 9-8</a>, and then creates three delegates referring to the <code>IsGreaterThan</code> method, one for each instance.</p>
<div data-type="example" id="explicit_instance_delegate">
<h5><span class="label">Example 9-9. </span>Explicit instance delegate</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">zeroThreshold</code> <code class="p">=</code> <code class="k">new</code> <code class="n">ThresholdComparer</code> <code class="p">{</code> <code class="n">Threshold</code> <code class="p">=</code> <code class="m">0</code> <code class="p">};</code>
<code class="kt">var</code> <code class="n">tenThreshold</code> <code class="p">=</code> <code class="k">new</code> <code class="n">ThresholdComparer</code> <code class="p">{</code> <code class="n">Threshold</code> <code class="p">=</code> <code class="m">10</code> <code class="p">};</code>
<code class="kt">var</code> <code class="n">hundredThreshold</code> <code class="p">=</code> <code class="k">new</code> <code class="n">ThresholdComparer</code> <code class="p">{</code> <code class="n">Threshold</code> <code class="p">=</code> <code class="m">100</code> <code class="p">};</code>

<code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">greaterThanZero</code> <code class="p">=</code> <code class="n">zeroThreshold</code><code class="p">.</code><code class="n">IsGreaterThan</code><code class="p">;</code>
<code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">greaterThanTen</code> <code class="p">=</code> <code class="n">tenThreshold</code><code class="p">.</code><code class="n">IsGreaterThan</code><code class="p">;</code>
<code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">greaterThanOneHundred</code> <code class="p">=</code> <code class="n">hundredThreshold</code><code class="p">.</code><code class="n">IsGreaterThan</code><code class="p">;</code></pre></div>
<p>You don’t have to limit yourself to simple expressions of the form <code><em>variableName</em>.<em>MethodName</em></code>. You can take any expression that evaluates to an object reference, and then just append <code>.<em>MethodName</em></code>; if the object has one or more methods called <code><em>MethodName</em></code>, that will be a valid method group.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>I’ve shown only single-parameter delegates so far, but you can define delegate types with any number of parameters. For example, the runtime libraries define <code>Comparison&lt;T&gt;</code>, which compares two items, and therefore takes two arguments (both of type <code>T</code>).</p>
</div>
<p>C# will not let you create a delegate that refers to an instance method without specifying either implicitly or explicitly which instance you mean, and it will always initialize the delegate with that instance.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>When you pass a delegate to some other code, that code does not need to know whether the delegate’s target is a static or an instance method. And for instance methods, the code that uses the delegate does not supply the instance. Delegates that refer to instance methods always know which instance they refer to, as well as which method.</p>
</div>
<p>There’s another way to create a delegate that can be useful if you do not necessarily know which method or object you will use until runtime: you can use the reflection API (which I will explain in detail in <a data-type="xref" href="ch13.xhtml#ch_reflection">Chapter 13</a>). First, you obtain a <code>MethodInfo</code>, an object representing a particular method. Then you call its <code>CreateDelegate</code> method, passing the delegate type and, where required, the target object. (If you’re creating a delegate referring to a static method, there is no target object, so there’s an overload that takes only the delegate type.) This will create a delegate referring to whichever method the <code>MethodInfo</code> instance identifies. <a data-type="xref" href="#createdelegate">Example 9-10</a> uses this technique. It obtains a <code>Type</code> object (also part of the reflection API; it’s a way to refer to a particular type) representing the <code>ThresholdComparer</code> class. Next, it asks it for a <code>MethodInfo</code> representing the <code>IsGreaterThan</code> method. On this, it calls the overload of <code>Create​Dele⁠gate</code> that takes the delegate type and the target instance.<a data-primary="typeof operator" data-secondary="examples of use" data-type="indexterm" id="idm45884811813040"/></p>
<div data-type="example" id="createdelegate">
<h5><span class="label">Example 9-10. </span><code>CreateDelegate</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">MethodInfo</code> <code class="n">m</code> <code class="p">=</code> <code class="k">typeof</code><code class="p">(</code><code class="n">ThresholdComparer</code><code class="p">).</code><code class="n">GetMethod</code><code class="p">(</code><code class="s">"IsGreaterThan"</code><code class="p">)!;</code>
<code class="kt">var</code> <code class="n">greaterThanZero</code> <code class="p">=</code> <code class="p">(</code><code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;)</code> <code class="n">m</code><code class="p">.</code><code class="n">CreateDelegate</code><code class="p">(</code>
    <code class="k">typeof</code><code class="p">(</code><code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;),</code> <code class="n">zeroThreshold</code><code class="p">);</code></pre></div>
<p>There is another way to perform the same job: the <code>Delegate</code> type has a static <code>CreateDelegate</code> method, which avoids the need to obtain the <code>MethodInfo</code>. You pass it two <code>Type</code> objects—the delegate type and the type defining the target method—and also the method name. If you already have a <code>MethodInfo</code> in hand, you may as well use that, but if all you have is the name, this alternative is more convenient.</p>
<p>To summarize what we’ve seen so far, a delegate identifies a specific function, and if that’s an instance function, the delegate also contains an object reference. But some delegates do more<a data-startref="ix_ch09-asciidoc3" data-type="indexterm" id="idm45884811803632"/>.<a data-startref="ix_ch09-asciidoc2" data-type="indexterm" id="idm45884811802800"/></p>
</div></section>
<section data-pdf-bookmark="Multicast Delegates" data-type="sect2"><div class="sect2" id="multicast_delegates">
<h2>Multicast Delegates</h2>
<p><a data-primary="delegates" data-secondary="multicast" data-type="indexterm" id="ix_ch09-asciidoc4"/><a data-primary="multicast delegates" data-type="indexterm" id="ix_ch09-asciidoc5"/><a data-primary="MulticastDelegate type" data-type="indexterm" id="ix_ch09-asciidoc6"/>If you look at any delegate type with a reverse-engineering tool such as ILDASM,<sup><a data-type="noteref" href="ch09.xhtml#idm45884811784544" id="idm45884811784544-marker">2</a></sup> you’ll see that whether it’s a type supplied by the runtime libraries or one you’ve defined yourself, it derives from a base type called <code>MulticastDelegate</code>. As the name suggests, this means delegates can refer to more than one method. This is mostly 
<span class="keep-together">of interest</span> in notification scenarios where you may need to invoke multiple methods when some event occurs. However, all delegates support this whether you need it 
<span class="keep-together">or not.</span></p>
<p>Even delegates with non-<code>void</code> return types derive from <code>MulticastDelegate</code>. That doesn’t usually make much sense. For example, code that requires a <code>Predicate&lt;T&gt;</code> will normally inspect the return value. <code>Array.FindIndex</code> uses it to find out whether an element matches our search criteria. If a single delegate refers to multiple methods, what’s <code>FindIndex</code> supposed to do with multiple return values? As it happens, it will execute all the methods but will ignore the return values of all except the final method that runs. (It’s possible to write code to provide special handling for multicast delegates, but <code>FindIndex</code> does not.)</p>
<p>The multicast feature is available through the <code>Delegate</code> class’s static <code>Combine</code> method. This takes any two delegates and returns a single delegate. When the resulting delegate is invoked, it is as though you invoked the two original delegates one after the other. This works even when the delegates you pass to <code>Combine</code> already refer to multiple methods—you can chain together ever larger multicast delegates. If the same method is referred to in both arguments, the resulting combined delegate will invoke it twice.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Delegate combination always produces a new delegate. And the 
<span class="keep-together"><code>Combine</code></span> method doesn’t modify either of the delegates you pass it.</p>
</div>
<p>In fact, we rarely call <code>Delegate.Combine</code> explicitly, because C# has built-in support for combining delegates. You can use the <code>+</code> or <code>+=</code> operators. <a data-type="xref" href="#combining_delegates">Example 9-11</a> shows both, combining the three delegates from <a data-type="xref" href="#explicit_instance_delegate">Example 9-9</a> into a single multicast delegate. The two resulting delegates are equivalent—this just shows two ways of writing the same thing. Both cases compile into a couple of calls to <code>Delegate.Combine</code>.</p>
<div data-type="example" id="combining_delegates">
<h5><span class="label">Example 9-11. </span>Combining delegates</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">megaPredicate1</code> <code class="p">=</code>
    <code class="n">greaterThanZero</code> <code class="p">+</code> <code class="n">greaterThanTen</code> <code class="p">+</code> <code class="n">greaterThanOneHundred</code><code class="p">;</code>

<code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">megaPredicate2</code> <code class="p">=</code> <code class="n">greaterThanZero</code><code class="p">;</code>
<code class="n">megaPredicate2</code> <code class="p">+=</code> <code class="n">greaterThanTen</code><code class="p">;</code>
<code class="n">megaPredicate2</code> <code class="p">+=</code> <code class="n">greaterThanOneHundred</code><code class="p">;</code></pre></div>
<p>You can also use the <code>-</code> or <code>-=</code> operators, which produce a new delegate that is a copy of the first operand but with its last reference to the method referred to by the second operand removed. As you might guess, this turns into a call to <code>Delegate.Remove</code>.</p>
</div></section>
<section data-pdf-bookmark="Invoking a Delegate" data-type="sect2"><div class="sect2" id="invoking_a_delegate">
<h2>Invoking a Delegate</h2>
<p><a data-primary="delegates" data-secondary="invoking" data-type="indexterm" id="ix_ch09-asciidoc7"/><a data-primary="invoking a delegate" data-type="indexterm" id="ix_ch09-asciidoc8"/>So far, I’ve shown how to create a delegate, but what if you’re writing your own API that needs to call back into a method supplied by your caller? First, you would need to pick a delegate type. You could use one supplied by the runtime libraries, or, if necessary, you can define your own. Then, you can use this delegate type for a method parameter or a property. <a data-type="xref" href="#invoking_a_delegate-id1">Example 9-12</a> shows what to do when you want to call the method (or methods) the delegate refers to.</p>
<div data-type="example" id="invoking_a_delegate-id1">
<h5><span class="label">Example 9-12. </span>Invoking a delegate</h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="k">public</code> <code class="k">static</code> <code class="k">void</code> <code class="nf">CallMeRightBack</code><code class="p">(</code><code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">userCallback</code><code class="p">)</code>
<code class="p">{</code>
    <strong><code class="kt">bool</code> <code class="n">result</code> <code class="p">=</code> <code class="n">userCallback</code><code class="p">(</code><code class="m">42</code><code class="p">)</code><code class="p">;</code></strong>
    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">result</code><code class="p">)</code><code class="p">;</code>
<code class="p">}</code></pre></div>
<p>As this not terribly realistic example shows, you can use an argument of delegate type as though it were a function. This also works for local variables, fields, and properties. In fact, any expression that produces a delegate can be followed by an argument list in parentheses. The compiler will generate code that invokes the delegate. If the delegate has a non-<code>void</code> return type, the invocation expression’s value will be whatever the underlying method returns (or, in the case of a delegate referring to multiple methods, whatever the final method returns).</p>
<p>Although delegates are special types with runtime-generated code, there is ultimately nothing magical about invoking them. Invoking a delegate with a single target method works as though your code had called the target method in the conventional way. Invoking a multicast delegate is just like calling each of its target methods in turn. In either case, calls happen on the same thread, and exceptions propagate out of methods that were invoked via a delegate in exactly the same way as they do when you invoke the method directly.</p>
<p><a data-primary="invocation list" data-type="indexterm" id="idm45884811629904"/>If you want to get all the return values from a multicast delegate, you can take control of the invocation process. Delegates offer a <code>GetInvocationList</code> method, which returns an array containing a single-method delegate for each of the methods to which the original multicast delegate refers. If you call this on a normal, nonmulticast delegate, this list will contain just that one delegate, but if the multicast feature is being exploited, you could then loop over the array, invoking each in turn.</p>
<p>There is one more way to invoke a delegate that is occasionally useful. The base <code>Delegate</code> class provides a <code>DynamicInvoke</code> method. You can call this on a delegate of any type without needing to know at compile time exactly what arguments are required. It takes a <code>params</code> array of type <code>object[]</code>, so you can pass any number of arguments. It will verify the number and type of arguments at runtime. This can enable certain late-binding scenarios. The intrinsic language features enabled by the <code>dynamic</code> keyword (discussed in <a data-type="xref" href="ch02.xhtml#ch_basic_coding">Chapter 2</a>) are more comprehensive, but they are slightly more heavyweight due to the extra flexibility, so if <code>DynamicInvoke</code> does precisely what you need, it is the better choice.<a data-startref="ix_ch09-asciidoc8" data-type="indexterm" id="idm45884811624592"/><a data-startref="ix_ch09-asciidoc7" data-type="indexterm" id="idm45884811623888"/></p>
</div></section>
<section data-pdf-bookmark="Common Delegate Types" data-type="sect2"><div class="sect2" id="common_delegate_types">
<h2>Common Delegate Types</h2>
<p><a data-primary="delegates" data-secondary="common types" data-type="indexterm" id="ix_ch09-asciidoc9"/><a data-primary="types" data-secondary="delegates" data-type="indexterm" id="ix_ch09-asciidoc10"/>The runtime libraries provide several useful delegate types, and you will often be able to use these instead of needing to define your own. For example, there is a set of generic delegates named <code>Action</code> with varying numbers of type parameters. These all follow a common pattern: for each type parameter, there’s a single method parameter of that type. <a data-type="xref" href="#the_first_few_action_delegates">Example 9-13</a> shows the first four, including the zero-argument form.</p>
<div data-type="example" id="the_first_few_action_delegates">
<h5><span class="label">Example 9-13. </span>The first few <code>Action</code> delegates</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">delegate</code> <code class="k">void</code> <code class="nf">Action</code><code class="p">();</code>
<code class="k">public</code> <code class="k">delegate</code> <code class="k">void</code> <code class="n">Action</code><code class="p">&lt;</code><code class="k">in</code> <code class="n">T1</code><code class="p">&gt;(</code><code class="n">T1</code> <code class="n">arg1</code><code class="p">);</code>
<code class="k">public</code> <code class="k">delegate</code> <code class="k">void</code> <code class="n">Action</code><code class="p">&lt;</code><code class="k">in</code> <code class="n">T1</code><code class="p">,</code> <code class="k">in</code> <code class="n">T2</code> <code class="p">&gt;(</code><code class="n">T1</code> <code class="n">arg1</code><code class="p">,</code> <code class="n">T2</code> <code class="n">arg2</code><code class="p">);</code>
<code class="k">public</code> <code class="k">delegate</code> <code class="k">void</code> <code class="n">Action</code><code class="p">&lt;</code><code class="k">in</code> <code class="n">T1</code><code class="p">,</code> <code class="k">in</code> <code class="n">T2</code><code class="p">,</code> <code class="k">in</code> <code class="n">T3</code><code class="p">&gt;(</code><code class="n">T1</code> <code class="n">arg1</code><code class="p">,</code> <code class="n">T2</code> <code class="n">arg2</code><code class="p">,</code> <code class="n">T3</code> <code class="n">arg3</code><code class="p">);</code></pre></div>
<p>Although this is clearly an open-ended concept—you could imagine delegates of this form with any number of parameters—the CTS does not provide a way to define this sort of type as a pattern, so the runtime libraries have to define each form as a separate type. Consequently, there is no 200-parameter form of <code>Action</code>. The largest has 16 parameters.</p>
<p><a data-primary="Func&lt;TResult&gt; delegate type" data-type="indexterm" id="idm45884811497648"/>The obvious limitation with <code>Action</code> is that these types have a <code>void</code> return type, so they cannot refer to methods that return values. But there’s a similar family of delegate types, <code>Func</code>, that allows any return type. <a data-type="xref" href="#the_first_few_func_delegates">Example 9-14</a> shows the first few delegates in this family, and as you can see, they’re pretty similar to <code>Action</code>. They just get an additional final type parameter, <code>TResult</code>, which specifies the return type. As with <code>Action&lt;T&gt;</code>, these go up to 16 parameters.</p>
<div data-type="example" id="the_first_few_func_delegates">
<h5><span class="label">Example 9-14. </span>The first few <code>Func</code> delegates</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">delegate</code> <code class="n">TResult</code> <code class="n">Func</code><code class="p">&lt;</code><code class="k">out</code> <code class="n">TResult</code><code class="p">&gt;();</code>
<code class="k">public</code> <code class="k">delegate</code> <code class="n">TResult</code> <code class="n">Func</code><code class="p">&lt;</code><code class="k">in</code> <code class="n">T1</code><code class="p">,</code> <code class="k">out</code> <code class="n">TResult</code><code class="p">&gt;(</code><code class="n">T1</code> <code class="n">arg1</code><code class="p">);</code>
<code class="k">public</code> <code class="k">delegate</code> <code class="n">TResult</code> <code class="n">Func</code><code class="p">&lt;</code><code class="k">in</code> <code class="n">T1</code><code class="p">,</code> <code class="k">in</code> <code class="n">T2</code><code class="p">,</code> <code class="k">out</code> <code class="n">TResult</code><code class="p">&gt;(</code><code class="n">T1</code> <code class="n">arg1</code><code class="p">,</code> <code class="n">T2</code> <code class="n">arg2</code><code class="p">);</code>
<code class="k">public</code> <code class="k">delegate</code> <code class="n">TResult</code> <code class="n">Func</code><code class="p">&lt;</code><code class="k">in</code> <code class="n">T1</code><code class="p">,</code> <code class="k">in</code> <code class="n">T2</code><code class="p">,</code> <code class="k">in</code> <code class="n">T3</code><code class="p">,</code> <code class="k">out</code> <code class="n">TResult</code><code class="p">&gt;(</code>
    <code class="n">T1</code> <code class="n">arg1</code><code class="p">,</code> <code class="n">T2</code> <code class="n">arg2</code><code class="p">,</code> <code class="n">T3</code> <code class="n">arg3</code><code class="p">);</code></pre></div>
<p>These <code>Action</code> and <code>Func</code> types are the ones C# will use as the <em>natural</em> type of a delegate expression, when possible. You saw this earlier in <a data-type="xref" href="#creating_a_delegate_natural_type">Example 9-4</a>, when, in the absence of any other direction, the compiler picked <code>Func&lt;int, bool&gt;</code>. It will use the <code>Action</code> family for methods that have a <code>void</code> return type.</p>
<p>These two families of delegates would appear to have most requirements covered. Unless you’re writing monster methods with more than 16 parameters, when would you ever need anything else? Well, there are some cases that cannot be expressed with generic type arguments. For example, if you need a delegate that can work with <code>ref</code>, <code>in</code>, or <code>out</code> parameters, you can’t just write, say, <code>Func&lt;bool, string, out int&gt;</code>. This is because there is no such type as <code>out int</code> in .NET. The <code>out</code> keyword makes a statement about exactly how the argument should be passed to the method. Generic type arguments only get to specify a type and cannot fully convey the distinction between <code>in</code>, <code>out</code>, and <code>ref</code> parameters.<sup><a data-type="noteref" href="ch09.xhtml#idm45884811364704" id="idm45884811364704-marker">3</a></sup> So in these cases, you’ll have to write a matching delegate type.</p>
<p>Another reason to define a custom delegate type is that you cannot use a <code>ref struct</code> as a generic type argument. (<a data-type="xref" href="ch18.xhtml#ch_memory_efficiency">Chapter 18</a> discusses these types.) So if you try to instantiate the generic <code>Action&lt;T&gt;</code> type with the <code>ref struct</code> type <code>Span&lt;int&gt;</code>, by writing <code>Action&lt;Span&lt;int&gt;&gt;</code>, you will get a compiler error. This limitation exists because <code>ref struct</code> types can only be used in certain scenarios (they must always live on the stack), and there’s no way to determine whether any particular generic type or method uses its type arguments only in the ways that are allowed. (You could imagine a new kind of type argument constraint that expressed this, but at the time of writing this, no such constraint exists.) So if you want a delegate type that can refer to a method that takes a <code>ref struct</code> argument, it needs to be a dedicated, 
<span class="keep-together">nongeneric delegate.</span></p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you’re relying on the compiler to determine a delegate expression’s natural type (e.g., you write <code>var m = SomeMethod;</code>), these cases in which the <code>Func</code> and <code>Action</code> delegates cannot be used are the cases in which the compiler will generate a delegate type 
<span class="keep-together">for you.</span></p>
</div>
<p>None of these restrictions explains why the runtime libraries define a separate 
<span class="keep-together"><code>Predicate&lt;T&gt;</code></span> delegate type. <code>Func&lt;T, bool&gt;</code> would work perfectly well. Sometimes this kind of specialized delegate type exists as an accident of history: many delegate types have been around since before these general-purpose <code>Action</code> and <code>Func</code> types were added. But that’s not the only reason—new delegate types continue to be added even now. The main reason is that sometimes it’s useful to define a specialized delegate type to indicate particular semantics.</p>
<p>If you have a <code>Func&lt;T, bool&gt;</code>, all you know is that you’ve got a method that takes a <code>T</code> and returns a <code>bool</code>. <a data-primary="Predicate&lt;T&gt; delegate type" data-secondary="implied meaning" data-type="indexterm" id="idm45884811348208"/>But with a <code>Predicate&lt;T&gt;</code>, there’s an implied meaning: it makes a decision about that <code>T</code> instance and returns <code>true</code> or <code>false</code> accordingly; not all methods that take a single argument and return a <code>bool</code> necessarily fit that pattern. By providing a <code>Predicate&lt;T&gt;</code>, you’re not just saying that you have a method with a particular signature; you’re saying you have a method that serves a particular purpose. For example, <code>HashSet&lt;T&gt;</code> (described in <a data-type="xref" href="ch05.xhtml#ch_collections">Chapter 5</a>) has an <code>Add</code> method that takes a single argument and returns a <code>bool</code>, so it matches the signature of <code>Predicate&lt;T&gt;</code> but not the semantics. <code>Add</code>’s main job is to perform an action with side effects, returning some information about what it did, whereas predicates just tell you something about a value or object.</p>
<p>The runtime libraries define many delegate types, most of them even more specialized than <code>Predicate&lt;T&gt;</code>. For example, the <code>System.IO</code> namespace and its descendants define several that relate to specific events, such as <code>SerialPinChangedEventHandler</code>, which is used only when you’re working with old-fashioned serial ports such as the once-ubiquitous RS232 interface.<a data-startref="ix_ch09-asciidoc10" data-type="indexterm" id="idm45884811339728"/><a data-startref="ix_ch09-asciidoc9" data-type="indexterm" id="idm45884811339056"/></p>
</div></section>
<section data-pdf-bookmark="Type Compatibility" data-type="sect2"><div class="sect2" id="type_compatibility">
<h2>Type Compatibility</h2>
<p><a data-primary="delegates" data-secondary="type compatibility" data-type="indexterm" id="ix_ch09-asciidoc11"/>Delegate types do not derive from one another. Any delegate type you define in C# will derive directly from <code>MulticastDelegate</code>, as do all of the delegate types in the runtime libraries. <a data-primary="conversions" data-secondary="implicit reference" data-type="indexterm" id="idm45884811334272"/><a data-primary="implicit conversions" data-secondary="implicit reference conversions" data-type="indexterm" id="idm45884811333216"/><a data-primary="conversions" data-secondary="reference" data-type="indexterm" id="idm45884811332304"/><a data-primary="reference conversions" data-type="indexterm" id="idm45884811331360"/><a data-primary="contravariance" data-type="indexterm" id="idm45884811330688"/><a data-primary="delegates" data-secondary="covariance and contravariance" data-type="indexterm" id="idm45884811330016"/><a data-primary="covariance" data-type="indexterm" id="idm45884811329056"/>However, the type system supports certain implicit reference conversions for generic delegate types through covariance and contravariance. The rules are very similar to those for interfaces. <a data-primary="Predicate&lt;T&gt; delegate type" data-secondary="type compatibility" data-type="indexterm" id="ix_ch09-asciidoc12"/>As the <code>in</code> keyword in <a data-type="xref" href="#the_predicateltg_delegate_type">Example 9-3</a> showed, the type parameter <code>T</code> in <code>Predicate&lt;T&gt;</code> is contravariant, <a data-primary="implicit reference conversions" data-type="indexterm" id="idm45884811324768"/><a data-primary="conversions, implicit reference" data-type="indexterm" id="idm45884811323968"/>which means that if an implicit reference conversion exists between two types, <code>A</code> and <code>B</code>, an implicit reference conversion also exists between the types <code>Predicate&lt;B&gt;</code> and <code>Predicate&lt;A&gt;</code>. <a data-type="xref" href="#delegate_covariance">Example 9-15</a> shows an implicit conversion that this enables.</p>
<div data-type="example" id="delegate_covariance">
<h5><span class="label">Example 9-15. </span>Delegate covariance</h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="k">public</code> <code class="k">static</code> <code class="kt">bool</code> <code class="nf">IsLongString</code><code class="p">(</code><code class="kt">object</code> <code class="n">o</code><code class="p">)</code>
<code class="p">{</code>
    <code class="k">return</code> <code class="n">o</code> <code class="k">is</code> <code class="kt">string</code> <code class="n">s</code> <code class="p">&amp;</code><code class="p">&amp;</code> <code class="n">s</code><code class="p">.</code><code class="n">Length</code> <code class="p">&gt;</code> <code class="m">20</code><code class="p">;</code>
<code class="p">}</code>

<code class="k">static</code> <code class="k">void</code> <code class="nf">Main</code><code class="p">(</code><code class="kt">string</code><code class="p">[</code><code class="p">]</code> <code class="n">args</code><code class="p">)</code>
<code class="p">{</code>
    <code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">object</code><code class="p">&gt;</code> <code class="n">po</code> <code class="p">=</code> <code class="n">IsLongString</code><code class="p">;</code>
    <strong><code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">ps</code> <code class="p">=</code> <code class="n">po</code><code class="p">;</code></strong>
    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">ps</code><code class="p">(</code><code class="s">"Too short"</code><code class="p">)</code><code class="p">)</code><code class="p">;</code>
<code class="p">}</code></pre></div>
<p>The <code>Main</code> method first creates a <code>Predicate&lt;object&gt;</code> referring to the <code>IsLongString</code> method. Any target method for this predicate type is capable of inspecting any <code>object</code> of any kind; thus, it’s clearly able to meet the needs of code that requires a predicate capable of inspecting strings, so it makes sense that the implicit conversion to <code>Predicate&lt;string&gt;</code> should succeed—which it does, thanks to contravariance. Covariance also works in the same way as it does with interfaces, so it would typically be associated with a delegate’s return type. (We denote covariant type parameters with the <code>out</code> keyword.) All of the built-in <code>Func</code> delegate types have a covariant type parameter representing the function’s return type called <code>TResult</code>. The type parameters for the function’s parameters are all contravariant, as are all of the type parameters for the <code>Action</code> delegate types.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The variance-based delegate conversions are implicit reference conversions. This means that when you convert the reference, the result still refers to the same delegate instance. (All implicit reference conversions have this characteristic, but not all implicit conversions work this way. Implicit numeric conversions create a new instance of the target type; implicit boxing conversions create a new box on the heap.) So in <a data-type="xref" href="#delegate_covariance">Example 9-15</a>, <code>po</code> and <code>ps</code> refer to the same delegate on the heap. This is subtly different from assigning <code>IsLongString</code> into both variables—that would create two delegates of different types.</p>
</div>
<p>You might also expect delegates that look the same to be compatible. For example, a <code>Predicate&lt;int&gt;</code> can refer to any method that a <code>Func&lt;int, bool&gt;</code> can use, and vice versa, so you might expect an implicit conversion to exist between these two types. You might be further encouraged by the “Delegate compatibility” section in the C# specification, which says that delegates with identical parameter lists and return types are compatible. (In fact, it goes further, saying that certain differences are allowed. For example, I mentioned earlier that argument types may be different as long as certain implicit reference conversions are available.) However, if you try the code in <a data-type="xref" href="#illegal_delegate_conversion">Example 9-16</a>, it won’t work.<a data-startref="ix_ch09-asciidoc12" data-type="indexterm" id="idm45884811241216"/></p>
<div data-type="example" id="illegal_delegate_conversion">
<h5><span class="label">Example 9-16. </span>Illegal delegate conversion</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">pred</code> <code class="p">=</code> <code class="n">IsLongString</code><code class="p">;</code>
<code class="n">Func</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="kt">bool</code><code class="p">&gt;</code> <code class="n">f</code> <code class="p">=</code> <code class="n">pred</code><code class="p">;</code>  <code class="c1">// Will fail with compiler error</code></pre></div>
<p>Adding an explicit cast doesn’t work either—it removes the compiler error, but you just get a runtime error instead. The CTS considers these to be incompatible types, so a variable declared with one delegate type cannot hold a reference to a different delegate type even if their method signatures are compatible (except for when the two delegate types in question are based on the same generic delegate type and are compatible thanks to covariance or contravariance). This is not the scenario for which C#’s delegate compatibility rules are designed—they are mainly used to determine whether a particular method can be the target for a particular delegate type.</p>
<p>The lack of type compatibility between “compatible” delegate types may seem odd, but structurally identical delegate types don’t necessarily have the same semantics, as we’ve already seen with <code>Predicate&lt;T&gt;</code> and <code>Func&lt;T,bool&gt;</code>. If you find yourself needing to perform this sort of conversion, it may be a sign that something is not quite right in your code’s design.<sup><a data-type="noteref" href="ch09.xhtml#CHP-9-FN-2" id="CHP-9-FN-2-marker">4</a></sup><a data-startref="ix_ch09-asciidoc11" data-type="indexterm" id="idm45884811179744"/></p>
</div></section>
<section data-pdf-bookmark="Behind the Syntax" data-type="sect2"><div class="sect2" id="behind_the_syntax">
<h2>Behind the Syntax</h2>
<p><a data-primary="delegates" data-secondary="syntax" data-type="indexterm" id="ix_ch09-asciidoc13"/>Although it takes just a single line of code to define a delegate type (as <a data-type="xref" href="#the_predicateltg_delegate_type">Example 9-3</a> showed), the compiler turns this into a type that defines three methods and a constructor. Of course, the type also inherits members from its base classes. <a data-primary="Delegate base class" data-type="indexterm" id="idm45884811174688"/><a data-primary="MulticastDelegate type" data-type="indexterm" id="idm45884811174016"/>All delegates derive from <code>MulticastDelegate</code>, although all of the interesting instance members come from its base class, <code>Delegate</code>. (<code>Delegate</code> inherits from <code>object</code>, so delegates all have the ubiquitous <code>object</code> methods too.) Even <code>GetInvocationList</code>, clearly a multicast-oriented feature, is defined by the <code>Delegate</code> base class.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The split between <code>Delegate</code> and <code>MulticastDelegate</code> is the meaningless and arbitrary result of a historical accident. The original plan was to support both multicast and unicast delegates, but toward the end of the prerelease period for .NET 1.0 this distinction was dropped, and now all delegate types support multicast instances. This happened sufficiently late in the day that Microsoft felt it was too risky to merge the two base types into one, so the split remained even though it serves no purpose.</p>
</div>
<p>I’ve already described a couple of the public instance members that <code>Delegate</code> defines: the <code>DynamicInvoke</code> and <code>GetInvocationList</code> methods. There are two more. The <code>Method</code> property returns the <code>MethodInfo</code> representing the target method. (<a data-type="xref" href="ch13.xhtml#ch_reflection">Chapter 13</a> describes the <code>MethodInfo</code> type.) The <code>Target</code> property returns the object that will be passed as the implicit <code>this</code> argument of the target method; if the delegate refers to a static method, <code>Target</code> will return <code>null</code>.  <a data-type="xref" href="#the_members_of_a_delegate_type">Example 9-17</a> shows the signatures of the compiler-generated constructor and methods for a delegate type. The details vary from one type to the next; these are the generated members in the <code>Predicate&lt;T&gt;</code> type.</p>
<div data-type="example" id="the_members_of_a_delegate_type">
<h5><span class="label">Example 9-17. </span>The members of a delegate type</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="nf">Predicate</code><code class="p">(</code><code class="kt">object</code> <code class="n">target</code><code class="p">,</code> <code class="n">IntPtr</code> <code class="n">method</code><code class="p">);</code>

<code class="k">public</code> <code class="kt">bool</code> <code class="nf">Invoke</code><code class="p">(</code><code class="n">T</code> <code class="n">obj</code><code class="p">);</code>

<code class="k">public</code> <code class="n">IAsyncResult</code> <code class="nf">BeginInvoke</code><code class="p">(</code><code class="n">T</code> <code class="n">obj</code><code class="p">,</code> <code class="n">AsyncCallback</code> <code class="n">callback</code><code class="p">,</code> <code class="kt">object</code> <code class="n">state</code><code class="p">);</code>
<code class="k">public</code> <code class="kt">bool</code> <code class="nf">EndInvoke</code><code class="p">(</code><code class="n">IAsyncResult</code> <code class="n">result</code><code class="p">);</code></pre></div>
<p>Any delegate type you define will have four similar members. After compilation, none of them will have bodies yet. The compiler generates only their declarations, because the CLR supplies their implementations at runtime.</p>
<p>The constructor takes the target object (which is <code>null</code> for static methods) and an <code>IntPtr</code> identifying the method.<sup><a data-type="noteref" href="ch09.xhtml#idm45884811070912" id="idm45884811070912-marker">5</a></sup> Notice that this is not the <code>MethodInfo</code> returned by the <code>Method</code> property. <a data-primary="function token" data-type="indexterm" id="idm45884811068336"/>Instead, this is a <em>function token</em>, an opaque binary identifier for the target method. The CLR can provide binary metadata tokens for all members and types, but there’s no C# syntax for working with them, so we don’t normally see them. When you construct a new instance of a delegate type, the compiler automatically generates IL that fetches the function token. The reason delegates use tokens internally is that they can be more efficient than working with reflection API types such as <code>MethodInfo</code>.</p>
<p><a data-primary="Invoke method" data-type="indexterm" id="idm45884811060992"/>The <code>Invoke</code> method is the one that calls the delegate’s target method (or methods). You can use this explicitly from C#, as <a data-type="xref" href="#using_invoke_explicitly">Example 9-18</a> shows. It is almost identical to <a data-type="xref" href="#invoking_a_delegate-id1">Example 9-12</a>, the only difference being that the delegate variable is followed by <code>.Invoke</code>. This generates exactly the same code as <a data-type="xref" href="#invoking_a_delegate-id1">Example 9-12</a>, so whether you write <code>Invoke</code> or just use the syntax that treats delegate identifiers as though they were method names is a matter of style. As a former C++ developer, I’ve always felt at home with the <a data-type="xref" href="#invoking_a_delegate-id1">Example 9-12</a> syntax, because it’s similar to using function pointers in that language, but there’s an argument that writing <code>Invoke</code> explicitly makes it easier to see that the code is using a delegate.</p>
<div data-type="example" id="using_invoke_explicitly">
<h5><span class="label">Example 9-18. </span>Using <code>Invoke</code> explicitly</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">static</code> <code class="k">void</code> <code class="nf">CallMeRightBack</code><code class="p">(</code><code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">userCallback</code><code class="p">)</code>
<code class="p">{</code>
    <code class="kt">bool</code> <code class="n">result</code> <code class="p">=</code> <code class="n">userCallback</code><code class="p">.</code><code class="n">Invoke</code><code class="p">(</code><code class="m">42</code><code class="p">);</code>
    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">result</code><code class="p">);</code>
<code class="p">}</code></pre></div>
<p>One benefit of this explicit form is that you can use the null-conditional operator to handle the case where the delegate variable is null. <a data-type="xref" href="#using_invoke_null_conditionally">Example 9-19</a> uses this to attempt invocation only when a non-null argument is supplied.</p>
<div data-type="example" id="using_invoke_null_conditionally">
<h5><span class="label">Example 9-19. </span>Using <code>Invoke</code> with the null-conditional operator</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">static</code> <code class="k">void</code> <code class="nf">CallMeMaybe</code><code class="p">(</code><code class="n">Action</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;?</code> <code class="n">userCallback</code><code class="p">)</code>
<code class="p">{</code>
    <code class="n">userCallback</code><code class="p">?.</code><code class="n">Invoke</code><code class="p">(</code><code class="m">42</code><code class="p">);</code>
<code class="p">}</code></pre></div>
<p>The <code>Invoke</code> method is the home for a delegate type’s method signature. When you define a delegate type, this is where the return type and parameter list you specify end up. When the compiler needs to check whether a particular method is compatible with a delegate type (e.g., when you create a new delegate of that type), the compiler compares the <code>Invoke</code> method with the method you’ve supplied.</p>
<p>As <a data-type="xref" href="#the_members_of_a_delegate_type">Example 9-17</a> shows, all delegate types also have <code>BeginInvoke</code> and <code>EndInvoke</code> methods. These used to provide a way to use the thread pool, but they are deprecated and do not work on the current version of .NET. (You’ll get a 
<span class="keep-together"><code>PlatformNotSupportedException</code></span> if you call either method.) They still work on .NET Framework, but they are obsolete. You should ignore these outdated methods and use the techniques described in <a data-type="xref" href="ch16.xhtml#ch_multithreading">Chapter 16</a> instead. The main reason these methods used to be popular is that they provided an easy way to pass a set of values from one thread to another—you could just pass whatever you needed as the arguments for the delegate. However, C# now has a much better way to solve the problem: anonymous functions<a data-startref="ix_ch09-asciidoc13" data-type="indexterm" id="idm45884810943600"/>.<a data-startref="ix_ch09-asciidoc0" data-type="indexterm" id="idm45884810972048"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Anonymous Functions" data-type="sect1"><div class="sect1" id="anonymous_functions">
<h1>Anonymous Functions</h1>
<p><a data-primary="anonymous functions" data-type="indexterm" id="ix_ch09-asciidoc14"/>C# lets you create delegates without needing to define a separate method explicitly. You can write a special kind of expression whose value is a method. You could think of them as <em>method expressions</em> or <em>function expressions</em>, but the official name is <em>anonymous functions</em>. Expressions can be passed directly as arguments or assigned directly into variables, so the methods these expressions produce don’t have names. (At least, not in C#. The runtime requires all methods to have names, so C# generates hidden names for these things, but from a C# language perspective, they are anonymous.)</p>
<p>For simple methods, the ability to write them inline as expressions can remove a lot of clutter. And as we’ll see in <a data-type="xref" href="#captured_variables">“Captured Variables”</a>, the compiler exploits the fact that delegates are more than just a reference to a method to provide anonymous functions with access to any variables that were in scope in the containing method at the point at which the anonymous function appears.</p>
<p>For historical reasons, C# provides two ways to define an anonymous function. The older way involves the <code>delegate</code> keyword and is shown in <a data-type="xref" href="#anonymous_method_syntax">Example 9-20</a>. <a data-primary="anonymous methods" data-type="indexterm" id="idm45884810963392"/>This form is known as an <em>anonymous method</em>.<sup><a data-type="noteref" href="ch09.xhtml#CHP-9-FN-3" id="CHP-9-FN-3-marker">6</a></sup> I’ve put each argument for <code>FindIndex</code> on a separate line to make the anonymous functions (the second argument) stand out, but C# does not require this.</p>
<div data-type="example" id="anonymous_method_syntax">
<h5><span class="label">Example 9-20. </span>Anonymous method syntax</h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="k">public</code> <code class="k">static</code> <code class="kt">int</code> <code class="nf">GetIndexOfFirstNonEmptyBin</code><code class="p">(</code><code class="kt">int</code><code class="p">[</code><code class="p">]</code> <code class="n">bins</code><code class="p">)</code>
<code class="p">{</code>
    <code class="k">return</code> <code class="n">Array</code><code class="p">.</code><code class="n">FindIndex</code><code class="p">(</code>
        <code class="n">bins</code><code class="p">,</code>
        <strong><code class="k">delegate</code> <code class="p">(</code><code class="kt">int</code> <code class="k">value</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="k">value</code> <code class="p">&gt;</code> <code class="m">0</code><code class="p">;</code> <code class="p">}</code></strong>
    <code class="p">)</code><code class="p">;</code>
<code class="p">}</code></pre></div>
<p>In some ways, this resembles the normal syntax for defining methods. The parameter list appears in parentheses and is followed by a block containing the body of the method (which can contain as much code as you like, by the way, and is free to contain nested blocks, local variables, loops, and anything else you can put in a normal method). But instead of a method name, we just have the keyword <code>delegate</code>. The compiler infers the return type. In this case, the <code>FindIndex</code> method’s signature declares the second parameter to be a <code>Predicate&lt;T&gt;</code>, which tells the compiler that the return type has to be <code>bool</code>.</p>
<p><a data-primary="Predicate&lt;T&gt; delegate type" data-secondary="anonymous functions and" data-type="indexterm" id="idm45884810891344"/>In fact, the compiler knows more than just the return type. I’ve passed <code>FindIndex</code> an <code>int[]</code> array, so the compiler will deduce that the type argument <code>T</code> is <code>int</code>, making the second argument a <code>Predicate&lt;int&gt;</code>. This means that in <a data-type="xref" href="#anonymous_method_syntax">Example 9-20</a>, I had to supply information—the type of the delegate’s parameter—that the compiler already knew. A later version of C# introduced a more compact anonymous function syntax that takes better advantage of what the compiler can deduce, shown in <a data-type="xref" href="#lambda_syntax">Example 9-21</a>.</p>
<div data-type="example" id="lambda_syntax">
<h5><span class="label">Example 9-21. </span>Lambda syntax</h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="k">public</code> <code class="k">static</code> <code class="kt">int</code> <code class="nf">GetIndexOfFirstNonEmptyBin</code><code class="p">(</code><code class="kt">int</code><code class="p">[</code><code class="p">]</code> <code class="n">bins</code><code class="p">)</code>
<code class="p">{</code>
    <code class="k">return</code> <code class="n">Array</code><code class="p">.</code><code class="n">FindIndex</code><code class="p">(</code>
        <code class="n">bins</code><code class="p">,</code>
        <strong><code class="k">value</code> <code class="p">=</code><code class="p">&gt;</code> <code class="k">value</code> <code class="p">&gt;</code> <code class="m">0</code></strong>
    <code class="p">)</code><code class="p">;</code>
<code class="p">}</code></pre></div>
<p><a data-primary="anonymous functions" data-secondary="lambda expressions" data-type="indexterm" id="ix_ch09-asciidoc15"/><a data-primary="lambda expressions" data-type="indexterm" id="ix_ch09-asciidoc16"/>This form of anonymous function is called a <em>lambda expression</em>, and it is named after a branch of mathematics that is the foundation of a function-based model for computation. There is no particular significance to the choice of the Greek letter lambda (λ). It was the accidental result of the limitations of 1930s printing technology. The inventor of lambda calculus, Alonzo Church, originally wanted a different notation, but when he published his first paper on the subject, the typesetting machine operator decided to print λ instead, because that was the closest approximation to Church’s notation that the machine could produce. Despite these inauspicious origins, this arbitrarily chosen term has become ubiquitous. LISP, an early and influential programming language, used the name <em>lambda</em> for expressions that are functions, and since then, many languages have followed suit, including C#.</p>
<p><a data-type="xref" href="#lambda_syntax">Example 9-21</a> is exactly equivalent to <a data-type="xref" href="#anonymous_method_syntax">Example 9-20</a>; I’ve just been able to leave various things out. <a data-primary="=&gt; syntax" data-secondary="lambdas" data-type="indexterm" id="idm45884810818704"/>The <code>=&gt;</code> token unambiguously marks this out as being a lambda, so the compiler does not need that cumbersome and ugly <code>delegate</code> keyword just to recognize this as an anonymous function. The compiler knows from the surrounding context that the method has to take an <code>int</code>, so there’s no need to specify the parameter’s type; I just provided the parameter’s name: <code>value</code>. For simple methods that consist of just a single expression, the lambda syntax lets you omit the block and the <code>return</code> statement. This all makes for very compact lambdas, but in some cases, you might not want to omit quite so much, so as <a data-type="xref" href="#lambda_variations">Example 9-22</a> shows, there are various optional features. Every lambda in this example is equivalent.</p>
<div data-type="example" id="lambda_variations">
<h5><span class="label">Example 9-22. </span>Lambda variations</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">p1</code> <code class="p">=</code> <code class="k">value</code> <code class="p">=&gt;</code> <code class="k">value</code> <code class="p">&gt;</code> <code class="m">0</code><code class="p">;</code>
<code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">p2</code> <code class="p">=</code> <code class="p">(</code><code class="k">value</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="k">value</code> <code class="p">&gt;</code> <code class="m">0</code><code class="p">;</code>
<code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">p3</code> <code class="p">=</code> <code class="p">(</code><code class="kt">int</code> <code class="k">value</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="k">value</code> <code class="p">&gt;</code> <code class="m">0</code><code class="p">;</code>
<code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">p4</code> <code class="p">=</code> <code class="k">value</code> <code class="p">=&gt;</code> <code class="p">{</code> <code class="k">return</code> <code class="k">value</code> <code class="p">&gt;</code> <code class="m">0</code><code class="p">;</code> <code class="p">};</code>
<code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">p5</code> <code class="p">=</code> <code class="p">(</code><code class="k">value</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="p">{</code> <code class="k">return</code> <code class="k">value</code> <code class="p">&gt;</code> <code class="m">0</code><code class="p">;</code> <code class="p">};</code>
<code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">p6</code> <code class="p">=</code> <code class="p">(</code><code class="kt">int</code> <code class="k">value</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="p">{</code> <code class="k">return</code> <code class="k">value</code> <code class="p">&gt;</code> <code class="m">0</code><code class="p">;</code> <code class="p">};</code>
<code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">p7</code> <code class="p">=</code> <code class="kt">bool</code> <code class="p">(</code><code class="k">value</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="k">value</code> <code class="p">&gt;</code> <code class="m">0</code><code class="p">;</code>
<code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">p8</code> <code class="p">=</code> <code class="kt">bool</code> <code class="p">(</code><code class="kt">int</code> <code class="k">value</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="k">value</code> <code class="p">&gt;</code> <code class="m">0</code><code class="p">;</code>
<code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">p9</code> <code class="p">=</code> <code class="kt">bool</code> <code class="p">(</code><code class="k">value</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="p">{</code> <code class="k">return</code> <code class="k">value</code> <code class="p">&gt;</code> <code class="m">0</code><code class="p">;</code> <code class="p">};</code>
<code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">pA</code> <code class="p">=</code> <code class="kt">bool</code> <code class="p">(</code><code class="kt">int</code> <code class="k">value</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="p">{</code> <code class="k">return</code> <code class="k">value</code> <code class="p">&gt;</code> <code class="m">0</code><code class="p">;</code> <code class="p">};</code></pre></div>
<p>The first variation is that you can put parentheses around the parameter. This is optional with a single parameter, but it is mandatory for multiparameter lambdas. You can also be explicit about the parameters’ types (in which case you will also need parentheses, even if there’s only one parameter). And, if you like, you can use a block instead of a single expression, at which point you also have to use the <code>return</code> keyword if the lambda returns a value. The normal reason for using a block would be if you wanted to write multiple statements inside the method. <a data-primary="C# 10.0" data-secondary="return types for anonymous functions" data-type="indexterm" id="idm45884810631328"/>The final four lines show a capability added in C# 10.0: you can specify the return type explicitly, although that’s only allowed when the parameter list is in parentheses.</p>
<p>You may be wondering why there are quite so many different forms—why not have just one syntax and be done with it? Although the final line of <a data-type="xref" href="#lambda_variations">Example 9-22</a> shows the most general form, it’s also a lot more cluttered than the first line. Since one of the goals of lambdas is to provide a more concise alternative to anonymous methods, C# supports these shorter forms where they can be used without ambiguity.</p>
<p>You can also write a lambda that takes no arguments. As <a data-type="xref" href="#a_zero-argument_lambda">Example 9-23</a> shows, we just put an empty pair of parentheses in front of the <code>=&gt;</code> token. (And, as this example also shows, lambdas that use the greater than or equals operator, <code>&gt;=</code>, can look a bit odd due to the meaningless similarity between the <code>=&gt;</code> and <code>&gt;=</code> tokens.)</p>
<div data-type="example" id="a_zero-argument_lambda">
<h5><span class="label">Example 9-23. </span>A zero-argument lambda</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">Func</code><code class="p">&lt;</code><code class="kt">bool</code><code class="p">&gt;</code> <code class="n">isAfternoon</code> <code class="p">=</code> <code class="p">()</code> <code class="p">=&gt;</code> <code class="n">DateTime</code><code class="p">.</code><code class="n">Now</code><code class="p">.</code><code class="n">Hour</code> <code class="p">&gt;=</code> <code class="m">12</code><code class="p">;</code></pre></div>
<p>The flexible and compact syntax means that lambdas have all but displaced the older anonymous method syntax. However, the older syntax offers one advantage: it allows you to omit the parameter list entirely. In some situations where you provide a callback, you need to know only that whatever you were waiting for has now happened. This is particularly common when using the standard event pattern described later in this chapter, because that requires event handlers to accept arguments even in situations where they serve no purpose. For example, when a button is clicked, there’s not much else to say beyond the fact that it was clicked, and yet all of the button types in .NET’s various UI frameworks pass two arguments to the event handler. <a data-type="xref" href="#ignoring_arguments_in_an_anonymous_metho">Example 9-24</a> successfully ignores this by using an anonymous method that omits the parameter list.</p>
<div data-type="example" id="ignoring_arguments_in_an_anonymous_metho">
<h5><span class="label">Example 9-24. </span>Ignoring arguments in an anonymous method</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">EventHandler</code> <code class="n">clickHandler</code> <code class="p">=</code> <code class="k">delegate</code> <code class="p">{</code> <code class="n">Debug</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Clicked!"</code><code class="p">);</code> <code class="p">};</code></pre></div>
<p><code>EventHandler</code> is a delegate type that requires its<a data-primary="EventArgs class" data-type="indexterm" id="idm45884810476928"/><a data-primary="EventHandler delegate type" data-type="indexterm" id="idm45884810476320"/> target methods to take two arguments, of type <code>object</code> and <code>EventArgs</code>. If our handler needed access to either, we could, of course, add a parameter list, but the anonymous method syntax lets us leave it out if we want. <a data-primary="C# 10.0" data-secondary="ignoring arguments in anonymous methods" data-type="indexterm" id="idm45884810474624"/>You cannot do this with a lambda. That said, C# 10.0 adds a new feature that makes ignoring arguments slightly less cumbersome, which <a data-type="xref" href="#lambda_discards">Example 9-25</a> illustrates.</p>
<div data-type="example" id="lambda_discards">
<h5><span class="label">Example 9-25. </span>A lambda discarding its arguments</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">EventHandler</code> <code class="n">clickHandler</code> <code class="p">=</code> <code class="p">(</code><code class="n">_</code><code class="p">,</code> <code class="n">_</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">Debug</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Clicked!"</code><code class="p">);</code></pre></div>
<p>This has exactly the same effect as <a data-type="xref" href="#ignoring_arguments_in_an_anonymous_metho">Example 9-24</a> but using the lambda syntax. I’ve provided an argument list in parentheses, but because I don’t want to use either argument, I’ve put an underscore in each position. This denotes a <em>discard</em>. You’ve seen the <code>_</code> character in patterns in early chapters, and it’s broadly similar in meaning here: it indicates that we know there’s a value available; it’s just that we don’t care what it is and don’t intend to use it.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Before C# 10.0 introduced support for this discard syntax, people would often use a similar-looking convention. The underscore symbol is a valid identifier, so for single-argument lambdas, nothing stops you from defining an argument named <code>_</code> and choosing not to refer to it. It got weird with multiple arguments because you can’t use the same name for two arguments, meaning <a data-type="xref" href="#lambda_discards">Example 9-25</a> would not compile on older versions of C#. To work around this, people just used multiple underscores, so you might see a lambda starting <code>(_, __, ___) =&gt;</code>. Thankfully, C# 10.0 allows us to use a single <code>_</code> throughout.</p>
</div>
<p><a data-startref="ix_ch09-asciidoc16" data-type="indexterm" id="idm45884810432656"/><a data-startref="ix_ch09-asciidoc15" data-type="indexterm" id="idm45884810431952"/></p>
<section data-pdf-bookmark="Captured Variables" data-type="sect2"><div class="sect2" id="captured_variables">
<h2>Captured Variables</h2>
<p><a data-primary="anonymous functions" data-secondary="captured variables" data-type="indexterm" id="ix_ch09-asciidoc17"/><a data-primary="captured variables" data-type="indexterm" id="ix_ch09-asciidoc18"/><a data-primary="variables" data-secondary="captured" data-type="indexterm" id="ix_ch09-asciidoc19"/>While anonymous functions often take up much less space in your source code than a full, normal method, they’re not just about conciseness. The C# compiler uses a delegate’s ability to refer not just to a method but also to some additional context to provide an extremely useful feature: it can make variables from the containing method available to the anonymous function. <a data-type="xref" href="#using_a_variable_from_the_containing_met">Example 9-26</a> shows a method that returns a <code>Predicate&lt;int&gt;</code>. It creates this with a lambda that uses an argument from the containing method.</p>
<div data-type="example" id="using_a_variable_from_the_containing_met">
<h5><span class="label">Example 9-26. </span>Using a variable from the containing method</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">static</code> <code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">IsGreaterThan</code><code class="p">(</code><code class="kt">int</code> <code class="n">threshold</code><code class="p">)</code>
<code class="p">{</code>
    <code class="k">return</code> <code class="k">value</code> <code class="p">=&gt;</code> <code class="k">value</code> <code class="p">&gt;</code> <code class="n">threshold</code><code class="p">;</code>
<code class="p">}</code></pre></div>
<p>This provides the same functionality as the <code>ThresholdComparer</code> class from <a data-type="xref" href="#implicit_instance_delegate">Example 9-8</a>, but instead of having to write an entire class, we need only a single, simple method. We can make this even more compact by using an expression-bodied method, as <a data-type="xref" href="#even_more_succinct_using_variable">Example 9-27</a> shows. (This might be a bit <em>too</em> concise—two different uses of <code>=&gt;</code> in close proximity to <code>&gt;</code> won’t win any prizes for readability.)</p>
<div data-type="example" id="even_more_succinct_using_variable">
<h5><span class="label">Example 9-27. </span>Using a variable from the containing method (expression-bodied)</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">static</code> <code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">IsGreaterThan</code><code class="p">(</code><code class="kt">int</code> <code class="n">threshold</code><code class="p">)</code> <code class="p">=&gt;</code>
    <code class="k">value</code> <code class="p">=&gt;</code> <code class="k">value</code> <code class="p">&gt;</code> <code class="n">threshold</code><code class="p">;</code></pre></div>
<p>In either form, the code is almost deceptively simple, so it’s worth looking closely at what it does. The <code>IsGreaterThan</code> method returns a delegate instance. That delegate’s target method performs a simple comparison—it evaluates the <code>value &gt; threshold</code> expression and returns the result. The <code>value</code> variable in that expression is just the delegate’s argument—the <code>int</code> passed by whichever code invokes the <code>Predicate&lt;int&gt;</code> that <code>IsGreaterThan</code> returns. The second line of <a data-type="xref" href="#where_value_comes_from">Example 9-28</a> invokes that code, passing in 200 as the argument for <code>value</code>.</p>
<div data-type="example" id="where_value_comes_from">
<h5><span class="label">Example 9-28. </span>Where the <code>value</code> argument comes from</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">greaterThanTen</code> <code class="p">=</code> <code class="n">IsGreaterThan</code><code class="p">(</code><code class="m">10</code><code class="p">);</code>
<code class="kt">bool</code> <code class="n">result</code> <code class="p">=</code> <code class="n">greaterThanTen</code><code class="p">(</code><code class="m">200</code><code class="p">);</code></pre></div>
<p><a data-primary="threshold variable" data-type="indexterm" id="idm45884810314960"/>The <code>threshold</code> variable in the expression is trickier. This is not an argument to the anonymous function. It’s the argument of <code>IsGreaterThan</code>, and <a data-type="xref" href="#where_value_comes_from">Example 9-28</a> passes a value of <code>10</code> as the <code>threshold</code> argument. However, <code>IsGreaterThan</code> has to return before we can invoke the delegate it returns. Since the method for which that <code>threshold</code> variable was an argument has already returned, you might think that the variable would no longer be available by the time we invoke the delegate. In fact, it’s fine, because the compiler does some work on our behalf. If an anonymous function uses local variables that were declared by the containing method, or if it uses that method’s parameters, the compiler generates a class to hold those variables so that they can outlive the method that created them. The compiler generates code in the containing method to create an instance of this class. (Remember, each invocation of a block gets its own set of local variables, so if any locals get pushed into an object to extend their lifetime, a new object will be required for each invocation.) This is one of the reasons why the popular myth that says local variables of value type always live on the stack is not true—in this case, the compiler copies the incoming <code>threshold</code> argument’s value to a field of an object on the heap, and code that uses the <code>threshold</code> variable ends up using that field instead. <a data-type="xref" href="#code_generated_for_an_anonymous_function">Example 9-29</a> shows the generated code that the compiler produces for the anonymous function in <a data-type="xref" href="#using_a_variable_from_the_containing_met">Example 9-26</a>.</p>
<div data-type="example" id="code_generated_for_an_anonymous_function">
<h5><span class="label">Example 9-29. </span>Code generated for an anonymous function</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="na">[CompilerGenerated]</code>
<code class="k">private</code> <code class="k">sealed</code> <code class="k">class</code> <code class="p">&lt;&gt;</code><code class="n">c__DisplayClass0_0</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="kt">int</code> <code class="n">threshold</code><code class="p">;</code>

    <code class="k">public</code> <code class="kt">bool</code> <code class="p">&lt;</code><code class="n">IsGreaterThan</code><code class="p">&gt;</code><code class="n">b__0</code><code class="p">(</code><code class="kt">int</code> <code class="k">value</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="k">return</code> <code class="p">(</code><code class="k">value</code> <code class="p">&gt;</code> <code class="k">this</code><code class="p">.</code><code class="n">threshold</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>The class and method names all begin with characters that are illegal in C# identifiers, to ensure that this compiler-generated code cannot clash with anything we write—this <a data-primary="unspeakable names" data-type="indexterm" id="idm45884810235648"/>is technically an <em>unspeakable name</em>. (The exact names are not fixed, by the way—you may find they are slightly different if you try this.) This generated code bears a striking resemblance to the <code>ThresholdComparer</code> class from <a data-type="xref" href="#implicit_instance_delegate">Example 9-8</a>, which is unsurprising, because the goal is the same: the delegate needs some method that it can refer to, and that method’s behavior depends on a value that is not fixed. Anonymous functions are not a feature of the runtime’s type system, so the compiler has to generate a class to provide this kind of behavior on top of the CLR’s basic delegate functionality.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Local functions (described in <a data-type="xref" href="ch03.xhtml#ch_types">Chapter 3</a>) can also access the local variables of their containing methods. Normally, this doesn’t change those variables’ lifetimes, because the local function is inaccessible outside of its containing method. However, if you create a delegate that refers to a local function, this means it might be invoked after the containing method returns, so the compiler will then perform the same trick that it does for anonymous functions, enabling variables to live on after the outer method returns.</p>
</div>
<p>Once you know that this is what’s really happening when you write an anonymous function, it follows naturally that the inner method is able not just to read the variable but also to modify it. This variable is just a field in an object that two methods—the anonymous function and the containing method—have access to. <a data-type="xref" href="#modifying_a_captured_variable">Example 9-30</a> uses this to maintain a count that is updated from an anonymous function.</p>
<div data-type="example" id="modifying_a_captured_variable">
<h5><span class="label">Example 9-30. </span>Modifying a captured variable</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">static</code> <code class="k">void</code> <code class="nf">Calculate</code><code class="p">(</code><code class="kt">int</code><code class="p">[]</code> <code class="n">nums</code><code class="p">)</code>
<code class="p">{</code>
    <code class="kt">int</code> <code class="n">zeroEntryCount</code> <code class="p">=</code> <code class="m">0</code><code class="p">;</code>
    <code class="kt">int</code><code class="p">[]</code> <code class="n">nonZeroNums</code> <code class="p">=</code> <code class="n">Array</code><code class="p">.</code><code class="n">FindAll</code><code class="p">(</code>
        <code class="n">nums</code><code class="p">,</code>
        <code class="n">v</code> <code class="p">=&gt;</code>
        <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="n">v</code> <code class="p">==</code> <code class="m">0</code><code class="p">)</code>
            <code class="p">{</code>
                <code class="n">zeroEntryCount</code> <code class="p">+=</code> <code class="m">1</code><code class="p">;</code>
                <code class="k">return</code> <code class="k">false</code><code class="p">;</code>
            <code class="p">}</code>
            <code class="k">else</code>
            <code class="p">{</code>
                <code class="k">return</code> <code class="k">true</code><code class="p">;</code>
            <code class="p">}</code>
        <code class="p">});</code>
    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"Number of zero entries: {zeroEntryCount}"</code><code class="p">);</code>
    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"First non-zero entry: {nonZeroNums[0]}"</code><code class="p">);</code>
<code class="p">}</code></pre></div>
<p>Everything in scope for the containing method is also in scope for anonymous functions. If the containing method is an instance method, this includes any instance members of the type, so your anonymous function could access fields, properties, and methods. (The compiler supports this by adding a field to the generated class to hold a copy of the <code>this</code> reference.) The compiler puts only what it needs to in generated classes of the kind shown in <a data-type="xref" href="#code_generated_for_an_anonymous_function">Example 9-29</a>, and if you don’t use variables or instance members from the containing scope, it might be able to generate a static method.</p>
<p><a data-primary="FindAll method" data-type="indexterm" id="idm45884810146256"/>The <code>FindAll</code> method in the preceding examples does not hold onto the delegate after it returns—any callbacks will happen while <code>FindAll</code> runs. Not everything works that way, though. Some APIs perform asynchronous work and will call you back at some point in the future, by which time the containing method may have returned. This means that any variables captured by the anonymous function will live longer than the containing method. In general, this is fine, because all of the captured variables live in an object on the heap, so it’s not as though the anonymous function is relying on a stack frame that is no longer present. The one thing you need to be careful of, though, is explicitly releasing resources before callbacks have finished. <a data-type="xref" href="#premature_disposal">Example 9-31</a> shows an easy mistake to make. This uses an asynchronous, callback-based API to download the resource at a particular URL via HTTP. (This calls the <code>ContinueWith</code> method on the <code>Task&lt;Stream&gt;</code> returned by <code>HttpClient.GetStreamAsync</code>, passing a delegate that will be invoked once the HTTP response comes back. This method is part of the Task Parallel Library described in <a data-type="xref" href="ch16.xhtml#ch_multithreading">Chapter 16</a>.)<a data-primary="HttpClient class" data-type="indexterm" id="idm45884810069664"/></p>
<div data-type="example" id="premature_disposal">
<h5><span class="label">Example 9-31. </span>Premature disposal</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">HttpClient</code> <code class="n">http</code> <code class="p">=</code> <code class="n">GetHttpClient</code><code class="p">();</code>
<code class="k">using</code> <code class="p">(</code><code class="n">FileStream</code> <code class="n">file</code> <code class="p">=</code> <code class="n">File</code><code class="p">.</code><code class="n">OpenWrite</code><code class="p">(</code><code class="s">@"c:\temp\page.txt"</code><code class="p">))</code>
<code class="p">{</code>
    <code class="n">http</code><code class="p">.</code><code class="n">GetStreamAsync</code><code class="p">(</code><code class="s">"https://endjin.com/"</code><code class="p">)</code>
        <code class="p">.</code><code class="n">ContinueWith</code><code class="p">((</code><code class="n">Task</code><code class="p">&lt;</code><code class="n">Stream</code><code class="p">&gt;</code> <code class="n">t</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">t</code><code class="p">.</code><code class="n">Result</code><code class="p">.</code><code class="n">CopyToAsync</code><code class="p">(</code><code class="n">file</code><code class="p">));</code>
<code class="p">}</code> <code class="c1">// Will probably dispose FileStream before callback runs</code></pre></div>
<p>The <code>using</code> statement in this example will dispose the <code>FileStream</code> as soon as execution reaches the point at which the <code>file</code> variable goes out of scope in the outer method. The problem is that this <code>file</code> variable is also used in an anonymous function, which will in all likelihood run after the thread executing that outer method has left that <code>using</code> statement’s block. The compiler has no understanding of when the inner block will run—it doesn’t know whether that’s a synchronous callback like <code>Array.FindAll</code> uses or an asynchronous one. So it cannot do anything special here—it just calls <code>Dispose</code> at the end of the block, as that’s what our code told it to do.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The asynchronous language features discussed in <a data-type="xref" href="ch17.xhtml#ch_asynchronous_language_features">Chapter 17</a> can help avoid this sort of problem. When you use those to consume APIs that present this kind of <code>Task</code>-based pattern, the compiler can then know exactly how long things remain in scope. This enables the compiler to generate continuation callbacks for you, and as part of this, it can arrange for a <code>using</code> statement to call <code>Dispose</code> at the correct moment.</p>
</div>
<p>In performance-critical code, you may need to bear the costs of anonymous functions in mind. If the anonymous function uses variables from the outer scope, then in addition to the delegate object that you create to refer to the anonymous function, you may be creating an additional one: an instance of the generated class to hold shared local variables. The compiler will reuse these variable holders when it can—if one method contains two anonymous functions, they may be able to share an object, for example. Even with this sort of optimization, you’re still creating additional objects, increasing the pressure on the GC. (And in some cases you can end up creating this object even if you never hit the code path that creates the delegate.) It’s not particularly expensive—these are typically small objects—but if you’re up against a particularly oppressive performance problem, you might be able to eke out some small improvements by writing things in a more long-winded fashion in order to reduce the number of object allocations.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Local functions do not always incur this same overhead. When a local function uses its outer method’s variables, it does not extend their lifetime. The compiler therefore doesn’t need to create an object on the heap to hold the shared variables. It still creates a type to hold all the shared variables, but it defines this as a <code>struct</code> that it passes by reference as a hidden <code>in</code> argument, avoiding the need for a heap block. (If you create a delegate that refers to a local function, it can no longer use this optimization, and it reverts to the same strategy it uses for anonymous functions, putting shared variables in an object on the heap.)</p>
</div>
<p>More subtly, using an outer scope’s local variables in an anonymous function will extend the liveness of those variables, which may mean the GC will take longer to detect when objects those variables refer to are no longer in use. As you may recall from <a data-type="xref" href="ch07.xhtml#ch_object_lifetime">Chapter 7</a>, the CLR analyzes your code to work out when variables are in use so that it can free objects without waiting for the variables that refer to them to go out of scope. This enables the memory used by some objects to be reclaimed significantly earlier, particularly in methods that take a long time to complete. But liveness analysis applies only to conventional local variables. It cannot be applied for variables that are used in an anonymous function, because the compiler transforms those variables into fields. (From the CLR’s perspective, they are not local variables at all.) Since C# typically puts all of these transformed variables for a particular scope into a single object, you will find that none of the objects these variables refer to can be reclaimed until the method completes and the object containing the variables becomes unreachable itself. This can mean that in some cases there may be a measurable benefit to setting a local variable to <code>null</code> when you’re done with it, enabling that particular object’s memory to be reclaimed at the next GC. (Normally, that would be bad advice, and even with anonymous functions it might not have a useful effect in practice. You should only do this if performance testing demonstrates a clear advantage. But it’s worth investigating in cases where you’re seeing GC-related performance problems and you make heavy use of long-running anonymous functions.)</p>
<p>You can easily avoid these potential performance downsides in anonymous functions: just don’t use captured variables. If an anonymous function never tries to use anything from its containing scope, the C# compiler won’t engage the corresponding mechanisms, completely avoiding all the overhead. You can tell the compiler that you are intending to avoid capturing variables by annotating it with the <code>static</code> keyword, as <a data-type="xref" href="#avoiding_capture">Example 9-32</a> shows. Just as an ordinary <code>static</code> method does not have implicit access to an instance of its defining type, a <code>static</code> anonymous function has no access to its containing scope. This use of <code>static</code> doesn’t change how code is generated—any anonymous function that does not rely on capture will avoid all capture-related overheads, regardless of whether it was marked as <code>static</code>. This just asks the compiler to report errors if you inadvertently attempt to use variables from the function’s containing scope.</p>
<div data-type="example" id="avoiding_capture">
<h5><span class="label">Example 9-32. </span>Opting out of variable capture with <code>static</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">static</code> <code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">IsGreaterThan10</code><code class="p">()</code> <code class="p">=&gt;</code> <code class="k">static</code> <code class="k">value</code> <code class="p">=&gt;</code> <code class="k">value</code> <code class="p">&gt;</code> <code class="m">10</code><code class="p">;</code></pre></div>
<p>Variable capture can also occasionally lead to bugs, particularly due to a subtle scope-related issue with <code>for</code> loops. (<code>foreach</code> loops don’t have this problem.) <a data-type="xref" href="#problematic_variable_capture_in_a_for_lo">Example 9-33</a> runs into this problem.</p>
<div data-type="example" id="problematic_variable_capture_in_a_for_lo">
<h5><span class="label">Example 9-33. </span>Problematic variable capture in a <code>for</code> loop</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">static</code> <code class="k">void</code> <code class="nf">Caught</code><code class="p">()</code>
<code class="p">{</code>
    <code class="kt">var</code> <code class="n">greaterThanN</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Predicate</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;[</code><code class="m">10</code><code class="p">];</code>
    <code class="k">for</code> <code class="p">(</code><code class="kt">int</code> <code class="n">i</code> <code class="p">=</code> <code class="m">0</code><code class="p">;</code> <code class="n">i</code> <code class="p">&lt;</code> <code class="n">greaterThanN</code><code class="p">.</code><code class="n">Length</code><code class="p">;</code> <code class="p">++</code><code class="n">i</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">greaterThanN</code><code class="p">[</code><code class="n">i</code><code class="p">]</code> <code class="p">=</code> <code class="k">value</code> <code class="p">=&gt;</code> <code class="k">value</code> <code class="p">&gt;</code> <code class="n">i</code><code class="p">;</code> <code class="c1">// Bad use of i</code>
    <code class="p">}</code>

    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">greaterThanN</code><code class="p">[</code><code class="m">5</code><code class="p">](</code><code class="m">20</code><code class="p">));</code>
    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">greaterThanN</code><code class="p">[</code><code class="m">5</code><code class="p">](</code><code class="m">6</code><code class="p">));</code>
<code class="p">}</code></pre></div>
<p>This example initializes an array of <code>Predicate&lt;int&gt;</code> delegates, where each delegate tests whether the value is greater than some number. (You wouldn’t have to use arrays to see the problem I’m about to describe, by the way. Your loop might instead pass the delegates it creates into one of the mechanisms described in <a data-type="xref" href="ch16.xhtml#ch_multithreading">Chapter 16</a> that enable parallel processing by running the code on multiple threads. But arrays make it easier to show the problem.) Specifically, it compares the value with <code>i</code>, the loop counter that decides where in the array each delegate goes, so you might expect the element at index 5 to refer to a method that compares its argument with 5. If that were so, this code would show <code>True</code> twice. In fact, it displays <code>True</code> and then <code>False</code>. It turns out that <a data-type="xref" href="#problematic_variable_capture_in_a_for_lo">Example 9-33</a> produces an array of delegates where every single element compares its argument with 10.</p>
<p>This usually surprises people when they encounter it. With hindsight, it’s easy enough to see why this happens when you know how the C# compiler enables an anonymous function to use variables from its containing scope. The <code>for</code> loop declares the <code>i</code> variable, and because it is used not only by the containing <code>Caught</code> method but also by each delegate the loop creates, the compiler will generate a class similar to the one in <a data-type="xref" href="#code_generated_for_an_anonymous_function">Example 9-29</a>, and the variable will live in a field of that class. Since the variable comes into scope when the loop starts, and remains in scope for the duration of the loop, the compiler will create one instance of that generated class, and it will be shared by all of the delegates. So, as the loop increments <code>i</code>, this modifies the behavior of all of the delegates, because they all use that same <code>i</code> variable.</p>
<p>Fundamentally, the problem is that there’s only one <code>i</code> variable here. You can fix the code by introducing a new variable inside the loop. <a data-type="xref" href="#modifying_a_loop_to_capture_the_current">Example 9-34</a> copies the value of <code>i</code> into another local variable, <code>current</code>, which does not come into scope until an iteration is under way, and goes out of scope at the end of each iteration. So, although there is only one <code>i</code> variable, which lasts for as long as the loop runs, we get what is effectively a new <code>current</code> variable each time around the loop. Because each delegate gets its own distinct <code>current</code> variable, this modification means that each delegate in the array compares its argument with a different value—the value that the loop counter had for that particular iteration.</p>
<div data-type="example" id="modifying_a_loop_to_capture_the_current">
<h5><span class="label">Example 9-34. </span>Modifying a loop to capture the current value</h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="k">for</code> <code class="p">(</code><code class="kt">int</code> <code class="n">i</code> <code class="p">=</code> <code class="m">0</code><code class="p">;</code> <code class="n">i</code> <code class="p">&lt;</code> <code class="n">greaterThanN</code><code class="p">.</code><code class="n">Length</code><code class="p">;</code> <code class="p">+</code><code class="p">+</code><code class="n">i</code><code class="p">)</code>
<code class="p">{</code>
    <strong><code class="kt">int</code> <code class="n">current</code> <code class="p">=</code> <code class="n">i</code><code class="p">;</code></strong>
    <code class="n">greaterThanN</code><code class="p">[</code><code class="n">i</code><code class="p">]</code> <code class="p">=</code> <code class="k">value</code> <code class="p">=</code><code class="p">&gt;</code> <code class="k">value</code> <code class="p">&gt;</code> <code class="n">current</code><code class="p">;</code>
<code class="p">}</code></pre></div>
<p>The compiler still generates a class similar to the one in <a data-type="xref" href="#code_generated_for_an_anonymous_function">Example 9-29</a> to hold the <code>current</code> variable that’s shared by the inline and containing methods, but this time, it will create a new instance of that class each time around the loop in order to give each anonymous function a different instance of that variable. (When you use a <code>foreach</code> loop, the scoping rules are a little different: its iteration variable’s scope is per iteration, meaning that it’s logically a different instance of the variable each time around the loop, so there’s no need to add an extra variable inside the loop as we had to with <code>for</code>.)</p>
<p>You may be wondering what would happen if you wrote an anonymous function that used variables at multiple scopes. <a data-type="xref" href="#capturing_variables_at_different_scopes">Example 9-35</a> declares a variable called <code>offset</code> before the loop, and the lambda uses both that and a variable whose scope lasts for only one iteration.</p>
<div data-type="example" id="capturing_variables_at_different_scopes">
<h5><span class="label">Example 9-35. </span>Capturing variables at different scopes</h5>
<pre data-code-language="csharp" data-type="programlisting">
<strong><code class="kt">int</code> <code class="n">offset</code> <code class="p">=</code> <code class="m">10</code><code class="p">;</code></strong>
<code class="k">for</code> <code class="p">(</code><code class="kt">int</code> <code class="n">i</code> <code class="p">=</code> <code class="m">0</code><code class="p">;</code> <code class="n">i</code> <code class="p">&lt;</code> <code class="n">greaterThanN</code><code class="p">.</code><code class="n">Length</code><code class="p">;</code> <code class="p">+</code><code class="p">+</code><code class="n">i</code><code class="p">)</code>
<code class="p">{</code>
    <code class="kt">int</code> <code class="n">current</code> <code class="p">=</code> <code class="n">i</code><code class="p">;</code>
    <strong><code class="n">greaterThanN</code><code class="p">[</code><code class="n">i</code><code class="p">]</code> <code class="p">=</code> <code class="k">value</code> <code class="p">=</code><code class="p">&gt;</code> <code class="k">value</code> <code class="p">&gt;</code> <code class="p">(</code><code class="n">current</code> <code class="p">+</code> <code class="n">offset</code><code class="p">)</code><code class="p">;</code></strong>
<code class="p">}</code></pre></div>
<p>In that case, the compiler would generate two classes, one to hold any per-iteration shared variables (<code>current</code>, in this example) and one to hold those whose scope spans the whole loop (<code>offset</code>, in this case). Each delegate’s target object would contain inner scope variables, and that would contain a reference to the outer scope.</p>
<p><a data-type="xref" href="#delegates_and_captured_scopes">Figure 9-1</a> shows roughly how this would work, although it has been simplified to show just the first five items. The <code>greaterThanN</code> variable contains a reference to an array. Each array element contains a reference to a delegate. Each delegate refers to the same method, but each one has a different target object, which is how each delegate can capture a different instance of the <code>current</code> variable. Each of these target objects refers to a single object containing the <code>offset</code> variable captured from the scope outside of the loop.<a data-startref="ix_ch09-asciidoc19" data-type="indexterm" id="idm45884809675200"/><a data-startref="ix_ch09-asciidoc18" data-type="indexterm" id="idm45884809674496"/><a data-startref="ix_ch09-asciidoc17" data-type="indexterm" id="idm45884809673824"/></p>
<figure><div class="figure" id="delegates_and_captured_scopes">
<img alt="" height="562" src="assets/pc10_0901.png" width="600"/>
<h6><span class="label">Figure 9-1. </span>Delegates and captured scopes</h6>
</div></figure>
</div></section>
<section data-pdf-bookmark="Lambdas and Expression Trees" data-type="sect2"><div class="sect2" id="lambdas_and_expression_trees">
<h2>Lambdas and Expression Trees</h2>
<p><a data-primary="anonymous functions" data-secondary="lambdas and expression trees" data-type="indexterm" id="ix_ch09-asciidoc20"/><a data-primary="expression trees, lambdas and" data-type="indexterm" id="ix_ch09-asciidoc21"/><a data-primary="lambda expressions" data-type="indexterm" id="ix_ch09-asciidoc22"/>Lambdas have an additional trick up their sleeves beyond providing delegates. Some lambdas produce a data structure that represents code. <a data-primary="Expression&lt;T&gt; type" data-type="indexterm" id="idm45884809634656"/>This occurs when you use the lambda syntax in a context that requires an <code>Expression&lt;T&gt;</code>, where <code>T</code> is a delegate type. <code>Expression&lt;T&gt;</code> itself is not a delegate type; it is a special type in the runtime libraries (in the <code>System.Linq.Expressions</code> namespace) that triggers this alternative handling of lambdas in the compiler. <a data-type="xref" href="#a_lambda_expression">Example 9-36</a> uses this type.</p>
<div data-type="example" id="a_lambda_expression">
<h5><span class="label">Example 9-36. </span>A lambda expression</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">Expression</code><code class="p">&lt;</code><code class="n">Func</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">,</code> <code class="kt">bool</code><code class="p">&gt;&gt;</code> <code class="n">greaterThanZero</code> <code class="p">=</code> <code class="k">value</code> <code class="p">=&gt;</code> <code class="k">value</code> <code class="p">&gt;</code> <code class="m">0</code><code class="p">;</code></pre></div>
<p>This example looks similar to some of the lambdas and delegates I’ve shown already in this chapter, but the compiler handles this very differently. It will not generate a method—there will be no compiled IL representing the lambda’s body. Instead, the compiler will produce code similar to that in <a data-type="xref" href="#what_the_compiler_does_with_a_lambda_exp">Example 9-37</a>.<a data-primary="typeof operator" data-secondary="examples of use" data-type="indexterm" id="idm45884809609984"/></p>
<div data-type="example" id="what_the_compiler_does_with_a_lambda_exp">
<h5><span class="label">Example 9-37. </span>What the compiler does with a lambda expression</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">ParameterExpression</code> <code class="n">valueParam</code> <code class="p">=</code> <code class="n">Expression</code><code class="p">.</code><code class="n">Parameter</code><code class="p">(</code><code class="k">typeof</code><code class="p">(</code><code class="kt">int</code><code class="p">),</code> <code class="s">"value"</code><code class="p">);</code>
<code class="n">ConstantExpression</code> <code class="n">constantZero</code> <code class="p">=</code> <code class="n">Expression</code><code class="p">.</code><code class="n">Constant</code><code class="p">(</code><code class="m">0</code><code class="p">);</code>
<code class="n">BinaryExpression</code> <code class="n">comparison</code> <code class="p">=</code> <code class="n">Expression</code><code class="p">.</code><code class="n">GreaterThan</code><code class="p">(</code><code class="n">valueParam</code><code class="p">,</code> <code class="n">constantZero</code><code class="p">);</code>
<code class="n">Expression</code><code class="p">&lt;</code><code class="n">Func</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">,</code> <code class="kt">bool</code><code class="p">&gt;&gt;</code> <code class="n">greaterThanZero</code> <code class="p">=</code>
    <code class="n">Expression</code><code class="p">.</code><code class="n">Lambda</code><code class="p">&lt;</code><code class="n">Func</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">,</code> <code class="kt">bool</code><code class="p">&gt;&gt;(</code><code class="n">comparison</code><code class="p">,</code> <code class="n">valueParam</code><code class="p">);</code></pre></div>
<p>This code calls various factory functions provided by the <code>Expression</code> class to produce an object for each subexpression in the lambda. This starts with the simple operands—the <code>value</code> parameter and the constant value <code>0</code>. These are fed into an object representing the “greater than” comparison expression, which in turn becomes the body of an object representing the whole lambda expression.</p>
<p>The ability to produce an object model for an expression makes it possible to write an API where the behavior is controlled by the structure and content of an expression. For example, some data access APIs can take an expression similar to the ones produced by Examples <a data-type="xref" data-xrefstyle="select:labelnumber" href="#a_lambda_expression">9-36</a> and
<a data-type="xref" data-xrefstyle="select:labelnumber" href="#what_the_compiler_does_with_a_lambda_exp">9-37</a> and use it to generate part of a <a data-primary="database access, LINQ and" data-type="indexterm" id="idm45884809534624"/>database query. I’ll be talking about C#’s integrated query features in <a data-type="xref" href="ch10.xhtml#ch_linq">Chapter 10</a>, but <a data-type="xref" href="#expressions_and_database_queries">Example 9-38</a> gives a flavor of how a lambda expression can be used as the basis of a query.</p>
<div data-type="example" id="expressions_and_database_queries">
<h5><span class="label">Example 9-38. </span>Expressions and database queries</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">expensiveProducts</code> <code class="p">=</code> <code class="n">dbContext</code><code class="p">.</code><code class="n">Products</code><code class="p">.</code><code class="n">Where</code><code class="p">(</code><code class="n">p</code> <code class="p">=&gt;</code> <code class="n">p</code><code class="p">.</code><code class="n">ListPrice</code> <code class="p">&gt;</code> <code class="m">3000</code><code class="p">);</code></pre></div>
<p><a data-primary="Entity Framework (EF)" data-type="indexterm" id="idm45884809441568"/><a data-primary="EF (Entity Framework)" data-type="indexterm" id="idm45884809476848"/>This example happens to use a Microsoft library called the Entity Framework, but various other data access technologies support the same approach. In this example, the <code>Where</code> method takes an argument of type <code>Expression&lt;Func&lt;Product,bool&gt;&gt;</code>.<sup><a data-type="noteref" href="ch09.xhtml#CHP-9-FN-4" id="CHP-9-FN-4-marker">7</a></sup> <code>Product</code> is a class that corresponds to an entity in the database, but the important part here is the use of <code>Expression&lt;T&gt;</code>. That means that the compiler will generate code that creates a tree of objects whose structure corresponds to that lambda expression. The <code>Where</code> method processes this expression tree, generating a SQL query that includes this clause: <code>WHERE [Extent1].[ListPrice] &gt; cast(3000 as decimal(18))</code>. So, although I wrote my query as a C# expression, the work required to find matching objects will all happen on my database server.</p>
<p>Expression trees were added to C# to enable this sort of query handling as part of the set of features known collectively as <em>LINQ</em> (which is the subject of <a data-type="xref" href="ch10.xhtml#ch_linq">Chapter 10</a>). However, as with most LINQ-related features, it’s possible to use them for other things. <a data-primary="Moq library" data-type="indexterm" id="idm45884809456592"/>For example, a popular .NET library used in automated testing called <a href="https://github.com/moq">Moq</a> exploits this. It creates fake implementations of interfaces for test purposes, and it uses lambda expressions to provide a simple API for configuring how those fakes should behave. <a data-primary="Mock&lt;T&gt; class" data-type="indexterm" id="idm45884809455136"/><a data-type="xref" href="#moq_example">Example 9-39</a> uses Moq’s <code>Mock&lt;T&gt;</code> class to create a fake implementation of .NET’s <code>IEqualityComparer&lt;string&gt;</code> interface. The code calls the <code>Setup</code> method, which takes an expression indicating a specific invocation we’d like to define special handling for—in this case, if the fake’s implementation of <code>IEqualityComparer&lt;string&gt;.Equals</code> is called with the arguments of <code>"Color"</code> and <code>"Colour"</code>, we’d like it to return <code>true</code>.</p>
<div data-type="example" id="moq_example">
<h5><span class="label">Example 9-39. </span>Use of lambda expressions by the Moq library</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">fakeComparer</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Mock</code><code class="p">&lt;</code><code class="n">IEqualityComparer</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;&gt;();</code>
<code class="n">fakeComparer</code>
    <code class="p">.</code><code class="n">Setup</code><code class="p">(</code><code class="n">c</code> <code class="p">=&gt;</code> <code class="n">c</code><code class="p">.</code><code class="n">Equals</code><code class="p">(</code><code class="s">"Color"</code><code class="p">,</code> <code class="s">"Colour"</code><code class="p">))</code>
    <code class="p">.</code><code class="n">Returns</code><code class="p">(</code><code class="k">true</code><code class="p">);</code></pre></div>
<p>If that argument to <code>Setup</code> were just a delegate, there would be no way for Moq to inspect it. But because it’s an expression tree, Moq is able to delve into it and find out what we’ve asked for.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Unfortunately, expression trees are an area of C# that have lagged behind the rest of the language. They were introduced in C# 3.0, and various language features added since then, such as support for tuples and asynchronous expressions, can’t be used in an expression tree because the object model has no way to represent them<a data-startref="ix_ch09-asciidoc22" data-type="indexterm" id="idm45884809369040"/><a data-startref="ix_ch09-asciidoc21" data-type="indexterm" id="idm45884809368336"/><a data-startref="ix_ch09-asciidoc20" data-type="indexterm" id="idm45884809367664"/>.<a data-startref="ix_ch09-asciidoc14" data-type="indexterm" id="idm45884809366864"/></p>
</div>
</div></section>
</div></section>
<section data-pdf-bookmark="Events" data-type="sect1"><div class="sect1" id="events-id1">
<h1>Events</h1>
<p><a data-primary="events" data-type="indexterm" id="ix_ch09-asciidoc23"/>Sometimes it is useful for objects to be able to provide notifications of when interesting things have happened—in a client-side UI framework, you will want to know when the user clicks one of your application’s buttons, for example. Delegates provide the basic callback mechanism required for notifications, but there are many ways you could go about using them. Should the delegate be passed as a method argument, a constructor argument, or perhaps as a property? How should you support unsubscribing from notifications? The CTS formalizes the answers to these questions through a special kind of class member called an <em>event</em>, and C# has syntax for working with events. <a data-type="xref" href="#a_class_with_an_event">Example 9-40</a> shows a class with one event member.</p>
<div data-type="example" id="a_class_with_an_event">
<h5><span class="label">Example 9-40. </span>A class with an event</h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="k">public</code> <code class="k">class</code> <code class="nc">Eventful</code>
<code class="p">{</code>
    <strong><code class="k">public</code> <code class="k">event</code> <code class="n">Action</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code><code class="p">?</code> <code class="n">Announcement</code><code class="p">;</code></strong>

    <code class="k">public</code> <code class="k">void</code> <code class="nf">Announce</code><code class="p">(</code><code class="kt">string</code> <code class="n">message</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">Announcement</code><code class="p">?</code><code class="p">.</code><code class="n">Invoke</code><code class="p">(</code><code class="n">message</code><code class="p">)</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>As with all members, you can start with an accessibility specifier, and it will default to <code>private</code> if you leave that off. Next, the <code>event</code> keyword singles this out as an event. Then there’s the event’s type, which can be any delegate type. I’ve used <code>Action&lt;string&gt;</code>, although as you’ll soon see, this is an unorthodox choice. Finally, we put the member name, so this example defines an event called <code>Announcement</code>.</p>
<p>To handle an event, you must provide a delegate of the right type, and you must use the <code>+=</code> syntax to attach that delegate as the handler. <a data-type="xref" href="#handling_events">Example 9-41</a> uses a lambda, but you can use any expression that produces, or is implicitly convertible to, a delegate of the type the event requires.</p>
<div data-type="example" id="handling_events">
<h5><span class="label">Example 9-41. </span>Handling events</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">source</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Eventful</code><code class="p">();</code>
<code class="n">source</code><code class="p">.</code><code class="n">Announcement</code> <code class="p">+=</code> <code class="n">m</code> <code class="p">=&gt;</code> <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Announcement: "</code> <code class="p">+</code> <code class="n">m</code><code class="p">);</code></pre></div>
<p>As well as defining an event, <a data-type="xref" href="#a_class_with_an_event">Example 9-40</a> also shows how to <em>raise</em> it—that is, how to invoke all the handlers that have been attached to the event. Its <code>Announce</code> uses the same syntax we would use if <code>Announcement</code> were a field containing a delegate that we wanted to invoke. In fact, as far as the code inside the class is concerned, that’s exactly what an event looks like—it appears to be a field. I’ve chosen to use the delegate’s <code>Invoke</code> member explicitly here instead of writing <code>Announcement(message)</code> because this lets me use the null-conditional operator (<code>?.</code>). This causes the compiler to generate code that invokes the delegate only if it is not null. Otherwise I would have had to write an <code>if</code> statement verifying that the field is not null before invoking it.</p>
<p>So why do we need a special member type if this looks just like a field? Well, it looks like a field only from inside the defining class. Code outside of the class cannot raise the event, so the code shown in <a data-type="xref" href="#how_not_to_raise_an_event">Example 9-42</a> will not compile.</p>
<div data-type="example" id="how_not_to_raise_an_event">
<h5><span class="label">Example 9-42. </span>How not to raise an event</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">source</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Eventful</code><code class="p">();</code>
<code class="n">source</code><code class="p">.</code><code class="n">Announcement</code><code class="p">(</code><code class="s">"Will this work?"</code><code class="p">);</code> <code class="c1">// No, this will not even compile</code></pre></div>
<p>From the outside, the only things you can do to an event are to attach a handler using <code>+=</code> and to remove one using <code>-=</code>. The syntax for adding and removing event handlers is unusual in that it’s the only case in C# in which you get to use <code>+=</code> and <code>-=</code> without the corresponding standalone <code>+</code> or <code>-</code> operators being available. The actions performed by <code>+=</code> and <code>-=</code> on events both turn out to be method calls in disguise. Just as properties are really pairs of methods with a special syntax, so are events. They are similar in concept to the code shown in <a data-type="xref" href="#the_approximate_effect_of_declaring_an_e">Example 9-43</a>. (In fact, the real code includes some moderately complex lock-free, thread-safe code. I’ve not shown this because the multithreading obscures the basic intent.) This won’t have quite the same effect, because the <code>event</code> keyword adds metadata to the type identifying the methods as being an event, so this is just for illustration.</p>
<div data-type="example" id="the_approximate_effect_of_declaring_an_e">
<h5><span class="label">Example 9-43. </span>The approximate effect of declaring an event</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">private</code> <code class="n">Action</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;?</code> <code class="n">Announcement</code><code class="p">;</code>

<code class="c1">// Not the actual code.</code>
<code class="c1">// The real code is more complex, to tolerate concurrent calls.</code>
<code class="k">public</code> <code class="k">void</code> <code class="nf">add_Announcement</code><code class="p">(</code><code class="n">Action</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">handler</code><code class="p">)</code>
<code class="p">{</code>
    <code class="n">Announcement</code> <code class="p">+=</code> <code class="n">handler</code><code class="p">;</code>
<code class="p">}</code>
<code class="k">public</code> <code class="k">void</code> <code class="nf">remove_Announcement</code><code class="p">(</code><code class="n">Action</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">handler</code><code class="p">)</code>
<code class="p">{</code>
    <code class="n">Announcement</code> <code class="p">-=</code> <code class="n">handler</code><code class="p">;</code>
<code class="p">}</code></pre></div>
<p>Just as with properties, events exist mainly to offer a convenient, distinctive syntax and to make it easier for tools to know how to present the features that classes offer. Events are particularly important for UI elements. In most UI frameworks, the objects representing interactive elements can often raise a wide range of events, <span class="keep-together">corresponding</span> to various forms of input such as keyboard, mouse, or touch. There are also often events relating to behavior specific to a particular control, such as selecting a new item in a list. Because the CTS defines a standard idiom by which elements can expose events, visual UI designers, such as the ones built into Visual Studio, can display the available events and offer to generate handlers for you.</p>
<section data-pdf-bookmark="Standard Event Delegate Pattern" data-type="sect2"><div class="sect2" id="standard_event_delegate_pattern">
<h2>Standard Event Delegate Pattern</h2>
<p><a data-primary="Action&lt;T&gt; delegate type" data-type="indexterm" id="idm45884809119184"/><a data-primary="delegates" data-secondary="standard event delegate pattern" data-type="indexterm" id="idm45884809118144"/><a data-primary="events" data-secondary="standard event delegate pattern" data-type="indexterm" id="idm45884809117296"/><a data-primary="EventArgs class" data-type="indexterm" id="idm45884809116448"/><a data-primary="EventHandler delegate type" data-type="indexterm" id="idm45884809115840"/>The event in <a data-type="xref" href="#a_class_with_an_event">Example 9-40</a> is unusual in that it uses the <code>Action&lt;T&gt;</code> delegate type. This is perfectly legal, but in practice, you will rarely see that, because almost all events use delegate types that conform to a particular pattern. This pattern requires the delegate’s method signature to have two parameters. The first parameter’s type is <code>object</code>, and the second’s type is either <code>EventArgs</code> or some type derived from <code>EventArgs</code>. <a data-type="xref" href="#the_eventhandler_delegate_type">Example 9-44</a> shows the <code>EventHandler</code> delegate type in the <code>System</code> namespace, which is the simplest and most widely used example of this pattern.</p>
<div data-type="example" id="the_eventhandler_delegate_type">
<h5><span class="label">Example 9-44. </span>The <code>EventHandler</code> delegate type</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">delegate</code> <code class="k">void</code> <code class="nf">EventHandler</code><code class="p">(</code><code class="kt">object</code> <code class="n">sender</code><code class="p">,</code> <code class="n">EventArgs</code> <code class="n">e</code><code class="p">);</code></pre></div>
<p>The first parameter is usually called <code>sender</code>, because the event source passes a reference to itself for this argument. This means that if you attach a single delegate to multiple event sources, that handler can always know which source raised any particular notification.</p>
<p>The second parameter provides a place to put information specific to the event. For example, WPF UI elements define various events for handling mouse input that use more specialized delegate types, such as <code>MouseButtonEventHandler</code>, with signatures that specify a corresponding specialized event parameter that offers details about the event. For example, <code>MouseButtonEventArgs</code> defines a <code>GetPosition</code> method that tells you where the mouse was when the button was clicked, and it defines various other properties offering further detail, including <code>ClickCount</code> and <code>Timestamp</code>.</p>
<p>Whatever the specialized type of the second parameter may be, it will always derive from the base <code>EventArgs</code> type. That base type is not very interesting—it does not add members beyond the standard ones provided by <code>object</code>. However, it does make it possible to write a general-purpose method that can be attached to any event that uses this pattern. The rules for delegate compatibility mean that even if the delegate type specifies a second parameter of type <code>MouseButtonEventArgs</code>, a method whose second parameter is of type <code>EventArgs</code> is an acceptable target. This can occasionally be useful for code generation or other infrastructure scenarios. However, the main benefit of the standard event pattern is simply one of familiarity—experienced C# developers generally expect events to work this way.</p>
</div></section>
<section data-pdf-bookmark="Custom Add and Remove Methods" data-type="sect2"><div class="sect2" id="custom_add_and_remove_methods">
<h2>Custom Add and Remove Methods</h2>
<p><a data-primary="add methods, custom" data-type="indexterm" id="ix_ch09-asciidoc24"/><a data-primary="events" data-secondary="custom add and remove methods" data-type="indexterm" id="ix_ch09-asciidoc25"/><a data-primary="remove methods (events)" data-type="indexterm" id="ix_ch09-asciidoc26"/>Sometimes, you might not want to use the default event implementation generated by the C# compiler. For example, a class may define a large number of events, most of which will not be used on the majority of instances. UI frameworks often have this characteristic. A WPF UI can have thousands of elements, every one of which offers over 100 events, but you normally attach handlers only to a few of these elements, and even with these, you handle only a fraction of the events on offer. It is inefficient for every element to dedicate a field to every available event in this case.</p>
<p>Using the default field-based implementation for large numbers of rarely used events could add hundreds of bytes to the footprint of each element in a UI, which can have a discernible effect on performance. (In a typical WPF application, this could add up to a few hundred thousand bytes. That might not sound like much given modern computers’ memory capacities, but it can put your code in a place where it is no longer able to make efficient use of the CPU’s cache, causing a nosedive in application responsiveness. Even if the cache is several megabytes in size, the fastest parts of the cache are usually much smaller, and wasting a few hundred kilobytes in a critical data structure can make a world of difference to performance.)</p>
<p>Another reason you might want to eschew the default compiler-generated event implementation is that you may want more sophisticated semantics when raising events. <a data-primary="event bubbling" data-type="indexterm" id="idm45884809080752"/>For example, WPF supports <em>event bubbling</em>: if a UI element does not handle certain events, they will be offered to the parent element, then the parent’s parent, and so on up the tree until a handler is found or it reaches the top. Although it would be possible to implement this sort of scheme with the standard event implementation C# supplies, much more efficient strategies are possible when event handlers are relatively sparse.</p>
<p>To support these scenarios, C# lets you provide your own add and remove methods for an event. It will look just like a normal event from the outside—anyone using your class will use the same <code>+=</code> and <code>-=</code> syntax to add and remove handlers—and it won’t be possible to tell that it provides a custom implementation. <a data-type="xref" href="#custom_add_and_remove_for_sparse_events">Example 9-45</a> shows a class with two events, and it uses a single dictionary, shared across all instances of the class, to keep track of which events have been handled on which objects. The approach is extensible to larger numbers of events—the dictionary uses pairs of objects as the key, so each entry represents a particular (source, event) pair. (This is not production-quality code, by the way. It’s not safe for multithreaded use, and it will also leak memory when a <code>ScarceEventSource</code> instance that still has event handlers attached falls out of use. This example just illustrates how custom event handlers look; it’s not a fully engineered solution.)</p>
<div data-type="example" id="custom_add_and_remove_for_sparse_events">
<h5><span class="label">Example 9-45. </span>Custom <code>add</code> and <code>remove</code> for sparse events</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">ScarceEventSource</code>
<code class="p">{</code>
    <code class="c1">// One dictionary shared by all instances of this class,</code>
    <code class="c1">// tracking all handlers for all events.</code>
    <code class="c1">// Beware of memory leaks - this code is for illustration only.</code>
    <code class="k">private</code> <code class="k">static</code> <code class="k">readonly</code>
     <code class="n">Dictionary</code><code class="p">&lt;(</code><code class="n">ScarceEventSource</code><code class="p">,</code> <code class="kt">object</code><code class="p">),</code> <code class="n">EventHandler</code><code class="p">&gt;</code> <code class="n">_eventHandlers</code>
      <code class="p">=</code> <code class="k">new</code><code class="p">();</code>

    <code class="c1">// Objects used as keys to identify particular events in the dictionary.</code>
    <code class="k">private</code> <code class="k">static</code> <code class="k">readonly</code> <code class="kt">object</code> <code class="n">EventOneId</code> <code class="p">=</code> <code class="k">new</code><code class="p">();</code>
    <code class="k">private</code> <code class="k">static</code> <code class="k">readonly</code> <code class="kt">object</code> <code class="n">EventTwoId</code> <code class="p">=</code> <code class="k">new</code><code class="p">();</code>


    <code class="k">public</code> <code class="k">event</code> <code class="n">EventHandler</code> <code class="n">EventOne</code>
    <code class="p">{</code>
        <code class="k">add</code>
        <code class="p">{</code>
            <code class="n">AddEvent</code><code class="p">(</code><code class="n">EventOneId</code><code class="p">,</code> <code class="k">value</code><code class="p">);</code>
        <code class="p">}</code>
        <code class="k">remove</code>
        <code class="p">{</code>
            <code class="n">RemoveEvent</code><code class="p">(</code><code class="n">EventOneId</code><code class="p">,</code> <code class="k">value</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">}</code>

    <code class="k">public</code> <code class="k">event</code> <code class="n">EventHandler</code> <code class="n">EventTwo</code>
    <code class="p">{</code>
        <code class="k">add</code>
        <code class="p">{</code>
            <code class="n">AddEvent</code><code class="p">(</code><code class="n">EventTwoId</code><code class="p">,</code> <code class="k">value</code><code class="p">);</code>
        <code class="p">}</code>
        <code class="k">remove</code>
        <code class="p">{</code>
            <code class="n">RemoveEvent</code><code class="p">(</code><code class="n">EventTwoId</code><code class="p">,</code> <code class="k">value</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">}</code>

    <code class="k">public</code> <code class="k">void</code> <code class="nf">RaiseBoth</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="n">RaiseEvent</code><code class="p">(</code><code class="n">EventOneId</code><code class="p">,</code> <code class="n">EventArgs</code><code class="p">.</code><code class="n">Empty</code><code class="p">);</code>
        <code class="n">RaiseEvent</code><code class="p">(</code><code class="n">EventTwoId</code><code class="p">,</code> <code class="n">EventArgs</code><code class="p">.</code><code class="n">Empty</code><code class="p">);</code>
    <code class="p">}</code>

    <code class="k">private</code> <code class="p">(</code><code class="n">ScarceEventSource</code><code class="p">,</code> <code class="kt">object</code><code class="p">)</code> <code class="n">MakeKey</code><code class="p">(</code><code class="kt">object</code> <code class="n">eventId</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="n">eventId</code><code class="p">);</code>

    <code class="k">private</code> <code class="k">void</code> <code class="nf">AddEvent</code><code class="p">(</code><code class="kt">object</code> <code class="n">eventId</code><code class="p">,</code> <code class="n">EventHandler</code> <code class="n">handler</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="kt">var</code> <code class="n">key</code> <code class="p">=</code> <code class="n">MakeKey</code><code class="p">(</code><code class="n">eventId</code><code class="p">);</code>
        <code class="n">_eventHandlers</code><code class="p">.</code><code class="n">TryGetValue</code><code class="p">(</code><code class="n">key</code><code class="p">,</code> <code class="k">out</code> <code class="n">EventHandler</code><code class="p">?</code> <code class="n">entry</code><code class="p">);</code>
        <code class="n">entry</code> <code class="p">+=</code> <code class="n">handler</code><code class="p">;</code>
        <code class="n">_eventHandlers</code><code class="p">[</code><code class="n">key</code><code class="p">]</code> <code class="p">=</code> <code class="n">entry</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">private</code> <code class="k">void</code> <code class="nf">RemoveEvent</code><code class="p">(</code><code class="kt">object</code> <code class="n">eventId</code><code class="p">,</code> <code class="n">EventHandler</code> <code class="n">handler</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="kt">var</code> <code class="n">key</code> <code class="p">=</code> <code class="n">MakeKey</code><code class="p">(</code><code class="n">eventId</code><code class="p">);</code>
        <code class="n">EventHandler</code><code class="p">?</code> <code class="n">entry</code> <code class="p">=</code> <code class="n">_eventHandlers</code><code class="p">[</code><code class="n">key</code><code class="p">];</code>
        <code class="n">entry</code> <code class="p">-=</code> <code class="n">handler</code><code class="p">;</code>
        <code class="k">if</code> <code class="p">(</code><code class="n">entry</code> <code class="p">==</code> <code class="k">null</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="n">_eventHandlers</code><code class="p">.</code><code class="n">Remove</code><code class="p">(</code><code class="n">key</code><code class="p">);</code>
        <code class="p">}</code>
        <code class="k">else</code>
        <code class="p">{</code>
            <code class="n">_eventHandlers</code><code class="p">[</code><code class="n">key</code><code class="p">]</code> <code class="p">=</code> <code class="n">entry</code><code class="p">;</code>
        <code class="p">}</code>
    <code class="p">}</code>

    <code class="k">private</code> <code class="k">void</code> <code class="nf">RaiseEvent</code><code class="p">(</code><code class="kt">object</code> <code class="n">eventId</code><code class="p">,</code> <code class="n">EventArgs</code> <code class="n">e</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="kt">var</code> <code class="n">key</code> <code class="p">=</code> <code class="n">MakeKey</code><code class="p">(</code><code class="n">eventId</code><code class="p">);</code>
        <code class="k">if</code> <code class="p">(</code><code class="n">_eventHandlers</code><code class="p">.</code><code class="n">TryGetValue</code><code class="p">(</code><code class="n">key</code><code class="p">,</code> <code class="k">out</code> <code class="n">EventHandler</code><code class="p">?</code> <code class="n">handler</code><code class="p">))</code>
        <code class="p">{</code>
            <code class="n">handler</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="n">e</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>The syntax for custom events is reminiscent of the full property syntax: we add a block after the member declaration that contains the two members, although they are called <code>add</code> and <code>remove</code> instead of <code>get</code> and <code>set</code>. (Unlike with properties, you must always supply both methods.) This disables the generation of the field that would normally hold the event, meaning that the <code>ScarceEventSource</code> class has no instance fields at all—instances of this type are as small as it’s possible for an object to be.</p>
<p>The price for this small memory footprint is a considerable increase in complexity; I’ve written about 16 times as many lines of code as I would have needed with compiler-generated events, and we’d need even more to fix the shortcomings described earlier. Moreover, this technique provides an improvement only if the events really are not handled most of the time—if I attached handlers to both events for every instance of this class, the dictionary-based storage would consume more memory than simply having a field for each event in each instance of the class. So you should consider this sort of custom event handling only if you either need nonstandard event-raising behavior or are very sure that you really will be saving memory, and that the savings are worthwhile.<a data-startref="ix_ch09-asciidoc26" data-type="indexterm" id="idm45884808708624"/><a data-startref="ix_ch09-asciidoc25" data-type="indexterm" id="idm45884808707920"/><a data-startref="ix_ch09-asciidoc24" data-type="indexterm" id="idm45884808707248"/></p>
</div></section>
<section data-pdf-bookmark="Events and the Garbage Collector" data-type="sect2"><div class="sect2" id="events_and_the_garbage_collector">
<h2>Events and the Garbage Collector</h2>
<p><a data-primary="events" data-secondary="garbage collector and" data-type="indexterm" id="ix_ch09-asciidoc27"/><a data-primary="garbage collector/garbage collection (GC)" data-secondary="events and" data-type="indexterm" id="ix_ch09-asciidoc28"/>As far as the GC is concerned, delegates are normal objects like any other. If the GC discovers that a delegate instance is reachable, then it will inspect the <code>Target</code> property, and whichever object that refers to will also be considered reachable, along with whatever objects that object in turn refers to. Although there is nothing remarkable about this, there are situations in which leaving event handlers attached can cause objects to hang around in memory when you might have expected them to be collected by the GC.</p>
<p>There’s nothing intrinsic to delegates and events that makes them unusually likely to defeat the GC. If you do get an event-related memory leak, it will have the same structure as any other .NET memory leak: starting from a root reference, there will be some chain of references that keeps an object reachable even after you’ve finished using it. Despite this, events often get special blame for memory leaks, and that’s because they are often used in ways that can cause problems.</p>
<p>For example, suppose your application maintains some object model representing its state and that your UI code is in a separate layer that makes use of that underlying model, adapting the information it contains for presentation on screen. This sort of layering is usually advisable—it’s a bad idea to intermingle code that deals with user interactions and code that implements the application’s logic. But a problem can arise if the underlying model advertises changes in state that the UI needs to reflect. If these changes are advertised through events, your UI code will typically attach handlers to those events.</p>
<p>Now imagine that someone closes one of your application’s windows. You would hope that the objects representing that window’s UI would all be detected as unreachable the next time the GC runs. The UI framework is likely to have attempted to make that possible. For example, WPF ensures that each instance of its <code>Window</code> class is reachable for as long as the corresponding window is open, but once the window has been closed, it stops holding references to the window, to enable all of the UI objects for that window to be collected.</p>
<p>However, if you handle an event from your main application’s model with a method in a <code>Window</code>-derived class, and if you do not explicitly remove that handler when the window is closed, you will have a problem. As long as your application is still 
<span class="keep-together">running,</span> something somewhere will presumably be keeping your application’s underlying model reachable. This means that the target objects of any delegates held by your application model (e.g., delegates that were added as event handlers) will continue to be reachable, preventing the GC from freeing them. So, if a <code>Window</code>-derived object for the now-closed window is still handling events from your application model, that window—and all of the UI elements it contains—will still be reachable and will not be garbage collected.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>There’s a persistent myth that this sort of event-based memory leak has something to do with circular references. In fact, GC copes perfectly well with circular references. It’s true that there are often circular references in these scenarios, but they’re not the issue. The problem is caused by accidentally keeping objects reachable after you no longer need them. Doing that will cause problems regardless of whether circular references are present.</p>
</div>
<p>You can deal with this by ensuring that if your UI layer ever attaches handlers to objects that will stay alive for a long time, you remove those handlers when the relevant UI element is no longer in use. Alternatively, you could use weak references to ensure that if your event source is the only thing holding a reference to the target, it doesn’t keep it alive. WPF can help you with this—it provides a <code>WeakEventManager</code> class that allows you to handle an event in such a way that the handling object is able to be garbage collected without needing to unsubscribe from the event. WPF uses this technique itself when databinding the UI to a data source that provides property change notification events.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Although event-related leaks often arise in UIs, they can occur anywhere. As long as an event source remains reachable, all of its attached handlers will also remain reachable.<a data-startref="ix_ch09-asciidoc28" data-type="indexterm" id="idm45884808838096"/><a data-startref="ix_ch09-asciidoc27" data-type="indexterm" id="idm45884808837392"/></p>
</div>
</div></section>
<section data-pdf-bookmark="Events Versus Delegates" data-type="sect2"><div class="sect2" id="events_versus_delegates">
<h2>Events Versus Delegates</h2>
<p><a data-primary="delegates" data-secondary="events versus" data-type="indexterm" id="idm45884808664640"/><a data-primary="events" data-secondary="delegates versus" data-type="indexterm" id="idm45884808663760"/>Some APIs provide notifications through events, while others just use delegates directly. How should you decide which approach to use? In some cases, the decision may be made for you because you want to support some particular idiom. For example, if you want your API to support the asynchronous features in C#, you will need to implement the pattern described in <a data-type="xref" href="ch17.xhtml#ch_asynchronous_language_features">Chapter 17</a>, which uses delegates, but not events, for completion callbacks. Events, on the other hand, provide a clear way to subscribe and unsubscribe, which will make them a better choice in some situations. Convention is another consideration: if you are writing a UI element, events will most likely be appropriate, because that’s the predominant idiom.</p>
<p>In cases where constraints or conventions do not provide an answer, you need to think about how the callback will be used. If there will be multiple subscribers for a notification, an event could be the best choice. This is not absolutely necessary, because any delegate is capable of multicast behavior, but by convention, this behavior is usually offered through events. If users of your class will need to remove the handler at some point, events are also likely to be a good choice. That being said, the <code>IObservable</code> interface also supports multicast and unsubscription and might be a better choice if you need more advanced functionality. This interface is part of the Reactive Extensions for .NET and is described in <a data-type="xref" href="ch11.xhtml#ch_reactive_extensions">Chapter 11</a>.</p>
<p>You would typically pass a delegate as an argument to a method or constructor if it only makes sense to have a single target method. For example, if the delegate type has a non-<code>void</code> return value that the API depends on (such as the <code>bool</code> returned by the predicate passed to <code>Array.FindAll</code>), it makes no sense to have multiple targets or zero targets. An event is the wrong idiom here, because its subscription-oriented model considers it perfectly normal to attach either no handlers or multiple handlers.</p>
<p>Occasionally, scenarios arise in which it might make sense to have either zero handlers or one handler, but never more than one. For example, take WPF’s <code>CollectionView</code> class, which can sort, group, and filter data from a collection. You configure filtering by providing a <code>Predicate&lt;object&gt;</code>. This is not passed as a constructor argument, because filtering is optional, so instead, the class defines a <code>Filter</code> property. An event would be inappropriate here, partly because <code>Predicate&lt;object&gt;</code> does not fit the usual event delegate pattern, but mainly because the class needs an unambiguous answer of yes or no, so it does not want to support multiple targets. (The fact that all delegate types support multicast means that it’s still possible to supply multiple targets, of course. But the decision to use a property rather than an event signals the fact that it’s not useful to attempt to provide multiple callbacks here.)<a data-startref="ix_ch09-asciidoc23" data-type="indexterm" id="idm45884808655408"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Delegates Versus Interfaces" data-type="sect1"><div class="sect1" id="delegates_versus_interfaces">
<h1>Delegates Versus Interfaces</h1>
<p><a data-primary="comparison" data-type="indexterm" id="idm45884808652880"/><a data-primary="delegates" data-secondary="interfaces versus" data-type="indexterm" id="idm45884808651952"/><a data-primary="interfaces" data-secondary="delegates versus" data-type="indexterm" id="idm45884808651008"/>Back at the start of this chapter, I argued that delegates offer a less cumbersome mechanism for callbacks and notifications than interfaces do. So why do some APIs require callers to implement an interface to enable callbacks? Why do we have <code>IComparer&lt;T&gt;</code> and not a delegate? <a data-primary="Comparison&lt;T&gt; delegate type" data-type="indexterm" id="idm45884808649296"/><a data-primary="IComparer&lt;T&gt; interface" data-type="indexterm" id="idm45884808648592"/>Actually, we have both—there’s a delegate type called <code>Comparison&lt;T&gt;</code>, which is supported as an alternative by many of the APIs that accept an <code>IComparer&lt;T&gt;</code>. Arrays and <code>List&lt;T&gt;</code> have overloads of their <code>Sort</code> methods that take either.</p>
<p>There are some situations in which the object-oriented approach may be preferable to using delegates. An object that implements <code>IComparer&lt;T&gt;</code> could provide properties to adjust the way the comparison works (e.g., the ability to select between various sorting criteria). You may want to collect and summarize information across multiple callbacks, and although you can do that through captured variables, it may be easier to get the information back out again at the end if it’s available through properties of an object.</p>
<p>This is really a decision for whoever is writing the code that is being called back, and not for the developer writing the code that makes the call. Delegates ultimately are more flexible, because they allow the consumer of the API to decide how to structure their code, whereas an interface imposes constraints. However, if an interface <span class="keep-together">happens</span> to align with the abstractions you want, delegates can seem like an irritating extra detail. This is why some APIs present both options, such as the sorting APIs that accept either an <code>IComparer&lt;T&gt;</code> or a <code>Comparison&lt;T&gt;</code>.</p>
<p>Interfaces might be preferable to delegates if you need to provide multiple related callbacks. The Reactive Extensions for .NET define an abstraction for notifications that includes the ability to know when you’ve reached the end of a sequence of events or when there has been an error, so in that model, subscribers implement an interface with three methods—<code>OnNext</code>, <code>OnCompleted</code>, and <code>OnError</code>. It makes sense to use an interface, because all three methods are typically required for a complete subscription.</p>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="summary-id8">
<h1>Summary</h1>
<p>Delegates are objects that provide a reference to a method, which can be either a static or an instance method. With instance methods, the delegate also holds a reference to the target object, so the code that invokes the delegate does not need to supply a target. Delegates can also refer to multiple methods, although that complicates matters if the delegate’s return type is not <code>void</code>. While delegate types get special handling from the CLR, they are still just reference types, meaning that a reference to a delegate can be passed as an argument, returned from a method, and stored in a field, variable, or property. A delegate type defines a signature for the target method. This is represented through the type’s <code>Invoke</code> method, but C# can hide this, offering a syntax in which you can invoke a delegate expression directly without explicitly referring to <code>Invoke</code>. You can construct a delegate that refers to any method with a compatible signature. You can also get C# to do more of the work for you—if you use the lambda syntax to create an anonymous function, C# will supply a suitable declaration for you and can also do work behind the scenes to make variables in the containing method available to the inner one. Delegates are the basis of events, which provide a formalized publish/subscribe model for notifications.</p>
<p>One C# feature that makes particularly extensive use of delegates is LINQ, which is the subject of the next chapter.</p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45884812227040"><sup><a href="ch09.xhtml#idm45884812227040-marker">1</a></sup> Before C# 10.0, the compiler didn’t pick one for you, and this example would have produced a compiler error. If you come across code that goes out of its way to specify a delegate type that the compiler would have chosen anyway, it was probably written before C# 10.0 came out.</p><p data-type="footnote" id="idm45884811784544"><sup><a href="ch09.xhtml#idm45884811784544-marker">2</a></sup> ILDASM ships with Visual Studio. At the time of writing, Microsoft doesn’t provide a cross-platform version, but you could use <a href="https://oreil.ly/ILSpy">the open source project ILSpy</a>.</p><p data-type="footnote" id="idm45884811364704"><sup><a href="ch09.xhtml#idm45884811364704-marker">3</a></sup> You may recall that generic type <em>definitions</em> can use the <code>in</code> and <code>out</code> keywords, but that’s different. It indicates when the type <em>parameter</em> is contra- or covariant in a generic type. You can’t use <code>in</code> or <code>out</code> when you supply a specific <em>argument</em> for a type parameter.</p><p data-type="footnote" id="CHP-9-FN-2"><sup><a href="ch09.xhtml#CHP-9-FN-2-marker">4</a></sup> Alternatively, you may just be one of nature’s dynamic language enthusiasts, with an allergy to expressing semantics through static types. If that’s the case, C# may not be the language for you.</p><p data-type="footnote" id="idm45884811070912"><sup><a href="ch09.xhtml#idm45884811070912-marker">5</a></sup> <code>IntPtr</code> is a value type typically used for opaque handle values. You also sometimes see it in interop scenarios—on the rare occasions that you see a raw handle from an OS API in .NET, it may be represented as an <code>IntPtr</code>, although in many cases this has been superseded by <code>SafeHandle</code>.</p><p data-type="footnote" id="CHP-9-FN-3"><sup><a href="ch09.xhtml#CHP-9-FN-3-marker">6</a></sup> Unhelpfully, there are two similar terms that somewhat arbitrarily mean almost but not quite the same thing. The C# documentation uses the term <em>anonymous function</em> as the general term for either kind of method expression. <em>Anonymous method</em> would be a better name for this because not all of these things are strictly functions—they can have a <code>void</code> return—but by the time Microsoft needed a general term for these things, that name was already taken.</p><p data-type="footnote" id="CHP-9-FN-4"><sup><a href="ch09.xhtml#CHP-9-FN-4-marker">7</a></sup> You may be surprised to see <code>Func&lt;Product,bool&gt;</code> here and not <code>Predicate&lt;Product&gt;</code>. The <code>Where</code> method is part of a .NET feature called LINQ that makes extensive use of delegates. To avoid defining huge numbers of new delegate types, LINQ uses <code>Func</code> types, and for consistency across the API, it prefers <code>Func</code> even when other standard types would fit.</p></div></div></section></div></body></html>