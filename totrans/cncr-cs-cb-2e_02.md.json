["```cs\nasync Task<T> DelayResult<T>(T result, TimeSpan delay)\n{\n  await Task.Delay(delay);\n  return result;\n}\n```", "```cs\nasync Task<string> DownloadStringWithRetries(HttpClient client, string uri)\n{\n  // Retry after 1 second, then after 2 seconds, then 4.\n  TimeSpan nextDelay = TimeSpan.FromSeconds(1);\n  for (int i = 0; i != 3; ++i)\n  {\n    try\n    {\n      return await client.GetStringAsync(uri);\n    }\n    catch\n    {\n    }\n\n    await Task.Delay(nextDelay);\n    nextDelay = nextDelay + nextDelay;\n  }\n\n  // Try one last time, allowing the error to propagate.\n  return await client.GetStringAsync(uri);\n}\n```", "```cs\nasync Task<string> DownloadStringWithTimeout(HttpClient client, string uri)\n{\n  using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(3));\n  Task<string> downloadTask = client.GetStringAsync(uri);\n  Task timeoutTask = Task.Delay(Timeout.InfiniteTimeSpan, cts.Token);\n\n  Task completedTask = await Task.WhenAny(downloadTask, timeoutTask);\n  if (completedTask == timeoutTask)\n    return null;\n  return await downloadTask;\n}\n```", "```cs\ninterface IMyAsyncInterface\n{\n  Task<int> GetValueAsync();\n}\n\nclass MySynchronousImplementation : IMyAsyncInterface\n{\n  public Task<int> GetValueAsync()\n  {\n    return Task.FromResult(13);\n  }\n}\n```", "```cs\ninterface IMyAsyncInterface\n{\n  Task DoSomethingAsync();\n}\n\nclass MySynchronousImplementation : IMyAsyncInterface\n{\n  public Task DoSomethingAsync()\n  {\n    return Task.CompletedTask;\n  }\n}\n```", "```cs\nTask<T> NotImplementedAsync<T>()\n{\n  return Task.FromException<T>(new NotImplementedException());\n}\n```", "```cs\nTask<int> GetValueAsync(CancellationToken cancellationToken)\n{\n  if (cancellationToken.IsCancellationRequested)\n    return Task.FromCanceled<int>(cancellationToken);\n  return Task.FromResult(13);\n}\n```", "```cs\ninterface IMyAsyncInterface\n{\n  Task DoSomethingAsync();\n}\n\nclass MySynchronousImplementation : IMyAsyncInterface\n{\n  public Task DoSomethingAsync()\n  {\n    try\n    {\n      DoSomethingSynchronously();\n      return Task.CompletedTask;\n    }\n    catch (Exception ex)\n    {\n      return Task.FromException(ex);\n    }\n  }\n}\n```", "```cs\nprivate static readonly Task<int> zeroTask = Task.FromResult(0);\nTask<int> GetValueAsync()\n{\n  return zeroTask;\n}\n```", "```cs\nasync Task MyMethodAsync(IProgress<double> progress = null)\n{\n  bool done = false;\n  double percentComplete = 0;\n  while (!done)\n  {\n    ...\n    progress?.Report(percentComplete);\n  }\n}\n```", "```cs\nasync Task CallMyMethodAsync()\n{\n  var progress = new Progress<double>();\n  progress.ProgressChanged += (sender, args) =>\n  {\n    ...\n  };\n  await MyMethodAsync(progress);\n}\n```", "```cs\nTask task1 = Task.Delay(TimeSpan.FromSeconds(1));\nTask task2 = Task.Delay(TimeSpan.FromSeconds(2));\nTask task3 = Task.Delay(TimeSpan.FromSeconds(1));\n\nawait Task.WhenAll(task1, task2, task3);\n```", "```cs\nTask<int> task1 = Task.FromResult(3);\nTask<int> task2 = Task.FromResult(5);\nTask<int> task3 = Task.FromResult(7);\n\nint[] results = await Task.WhenAll(task1, task2, task3);\n\n// \"results\" contains { 3, 5, 7 }\n```", "```cs\nasync Task<string> DownloadAllAsync(HttpClient client,\n    IEnumerable<string> urls)\n{\n  // Define the action to do for each URL.\n  var downloads = urls.Select(url => client.GetStringAsync(url));\n  // Note that no tasks have actually started yet\n  //  because the sequence is not evaluated.\n\n  // Start all URLs downloading simultaneously.\n  Task<string>[] downloadTasks = downloads.ToArray();\n  // Now the tasks have all started.\n\n  // Asynchronously wait for all downloads to complete.\n  string[] htmlPages = await Task.WhenAll(downloadTasks);\n\n  return string.Concat(htmlPages);\n}\n```", "```cs\nasync Task ThrowNotImplementedExceptionAsync()\n{\n  throw new NotImplementedException();\n}\n\nasync Task ThrowInvalidOperationExceptionAsync()\n{\n  throw new InvalidOperationException();\n}\n\nasync Task ObserveOneExceptionAsync()\n{\n  var task1 = ThrowNotImplementedExceptionAsync();\n  var task2 = ThrowInvalidOperationExceptionAsync();\n\n  try\n  {\n    await Task.WhenAll(task1, task2);\n  }\n  catch (Exception ex)\n  {\n    // \"ex\" is either NotImplementedException or InvalidOperationException.\n    ...\n  }\n}\n\nasync Task ObserveAllExceptionsAsync()\n{\n  var task1 = ThrowNotImplementedExceptionAsync();\n  var task2 = ThrowInvalidOperationExceptionAsync();\n\n  Task allTasks = Task.WhenAll(task1, task2);\n  try\n  {\n    await allTasks;\n  }\n  catch\n  {\n    AggregateException allExceptions = allTasks.Exception;\n    ...\n  }\n}\n```", "```cs\n// Returns the length of data at the first URL to respond.\nasync Task<int> FirstRespondingUrlAsync(HttpClient client,\n    string urlA, string urlB)\n{\n  // Start both downloads concurrently.\n  Task<byte[]> downloadTaskA = client.GetByteArrayAsync(urlA);\n  Task<byte[]> downloadTaskB = client.GetByteArrayAsync(urlB);\n\n  // Wait for either of the tasks to complete.\n  Task<byte[]> completedTask =\n      await Task.WhenAny(downloadTaskA, downloadTaskB);\n\n  // Return the length of the data retrieved from that URL.\n  byte[] data = await completedTask;\n  return data.Length;\n}\n```", "```cs\nasync Task<int> DelayAndReturnAsync(int value)\n{\n  await Task.Delay(TimeSpan.FromSeconds(value));\n  return value;\n}\n\n// Currently, this method prints \"2\", \"3\", and \"1\".\n// The desired behavior is for this method to print \"1\", \"2\", and \"3\".\nasync Task ProcessTasksAsync()\n{\n  // Create a sequence of tasks.\n  Task<int> taskA = DelayAndReturnAsync(2);\n  Task<int> taskB = DelayAndReturnAsync(3);\n  Task<int> taskC = DelayAndReturnAsync(1);\n  Task<int>[] tasks = new[] { taskA, taskB, taskC };\n\n  // Await each task in order.\n  foreach (Task<int> task in tasks)\n  {\n    var result = await task;\n    Trace.WriteLine(result);\n  }\n}\n```", "```cs\nasync Task<int> DelayAndReturnAsync(int value)\n{\n  await Task.Delay(TimeSpan.FromSeconds(value));\n  return value;\n}\n\nasync Task AwaitAndProcessAsync(Task<int> task)\n{\n  int result = await task;\n  Trace.WriteLine(result);\n}\n\n// This method now prints \"1\", \"2\", and \"3\".\nasync Task ProcessTasksAsync()\n{\n  // Create a sequence of tasks.\n  Task<int> taskA = DelayAndReturnAsync(2);\n  Task<int> taskB = DelayAndReturnAsync(3);\n  Task<int> taskC = DelayAndReturnAsync(1);\n  Task<int>[] tasks = new[] { taskA, taskB, taskC };\n\n  IEnumerable<Task> taskQuery =\n      from t in tasks select AwaitAndProcessAsync(t);\n  Task[] processingTasks = taskQuery.ToArray();\n\n  // Await all processing to complete\n  await Task.WhenAll(processingTasks);\n}\n```", "```cs\nasync Task<int> DelayAndReturnAsync(int value)\n{\n  await Task.Delay(TimeSpan.FromSeconds(value));\n  return value;\n}\n\n// This method now prints \"1\", \"2\", and \"3\".\nasync Task ProcessTasksAsync()\n{\n  // Create a sequence of tasks.\n  Task<int> taskA = DelayAndReturnAsync(2);\n  Task<int> taskB = DelayAndReturnAsync(3);\n  Task<int> taskC = DelayAndReturnAsync(1);\n  Task<int>[] tasks = new[] { taskA, taskB, taskC };\n\n  Task[] processingTasks = tasks.Select(async t =>\n  {\n    var result = await t;\n    Trace.WriteLine(result);\n  }).ToArray();\n\n  // Await all processing to complete\n  await Task.WhenAll(processingTasks);\n}\n```", "```cs\nasync Task<int> DelayAndReturnAsync(int value)\n{\n  await Task.Delay(TimeSpan.FromSeconds(value));\n  return value;\n}\n\n// This method now prints \"1\", \"2\", and \"3\".\nasync Task UseOrderByCompletionAsync()\n{\n  // Create a sequence of tasks.\n  Task<int> taskA = DelayAndReturnAsync(2);\n  Task<int> taskB = DelayAndReturnAsync(3);\n  Task<int> taskC = DelayAndReturnAsync(1);\n  Task<int>[] tasks = new[] { taskA, taskB, taskC };\n\n  // Await each one as they complete.\n  foreach (Task<int> task in tasks.OrderByCompletion())\n  {\n    int result = await task;\n    Trace.WriteLine(result);\n  }\n}\n```", "```cs\nasync Task ResumeOnContextAsync()\n{\n  await Task.Delay(TimeSpan.FromSeconds(1));\n\n  // This method resumes within the same context.\n}\n\nasync Task ResumeWithoutContextAsync()\n{\n  await Task.Delay(TimeSpan.FromSeconds(1)).ConfigureAwait(false);\n\n  // This method discards its context when it resumes.\n}\n```", "```cs\nasync Task ThrowExceptionAsync()\n{\n  await Task.Delay(TimeSpan.FromSeconds(1));\n  throw new InvalidOperationException(\"Test\");\n}\n\nasync Task TestAsync()\n{\n  try\n  {\n    await ThrowExceptionAsync();\n  }\n  catch (InvalidOperationException)\n  {\n  }\n}\n```", "```cs\nasync Task ThrowExceptionAsync()\n{\n  await Task.Delay(TimeSpan.FromSeconds(1));\n  throw new InvalidOperationException(\"Test\");\n}\n\nasync Task TestAsync()\n{\n  // The exception is thrown by the method and placed on the task.\n  Task task = ThrowExceptionAsync();\n  try\n  {\n    // The exception is re-raised here, where the task is awaited.\n    await task;\n  }\n  catch (InvalidOperationException)\n  {\n    // The exception is correctly caught here.\n  }\n}\n```", "```cs\nsealed class MyAsyncCommand : ICommand\n{\n  async void ICommand.Execute(object parameter)\n  {\n    await Execute(parameter);\n  }\n\n  public async Task Execute(object parameter)\n  {\n    ... // Asynchronous command implementation goes here.\n  }\n\n  ... // Other members (CanExecute, etc.)\n}\n```", "```cs\nstatic class Program\n{\n  static void Main(string[] args)\n  {\n    try\n    {\n      AsyncContext.Run(() => MainAsync(args));\n    }\n    catch (Exception ex)\n    {\n      Console.Error.WriteLine(ex);\n    }\n  }\n\n  // BAD CODE!!!\n  // In the real world, do not use async void unless you have to.\n  static async void MainAsync(string[] args)\n  {\n    ...\n  }\n}\n```", "```cs\npublic async ValueTask<int> MethodAsync()\n{\n  await Task.Delay(100); // asynchronous work.\n  return 13;\n}\n```", "```cs\npublic ValueTask<int> MethodAsync()\n{\n  if (CanBehaveSynchronously)\n    return new ValueTask<int>(13);\n  return new ValueTask<int>(SlowMethodAsync());\n}\n\nprivate Task<int> SlowMethodAsync();\n```", "```cs\nprivate Func<Task> _disposeLogic;\n\npublic ValueTask DisposeAsync()\n{\n  if (_disposeLogic == null)\n    return default;\n\n  // Note: this simple example is not threadsafe;\n  //  if multiple threads call DisposeAsync,\n  //  the logic could run more than once.\n  Func<Task> logic = _disposeLogic;\n  _disposeLogic = null;\n  return new ValueTask(logic());\n}\n```", "```cs\nValueTask<int> MethodAsync();\n\nasync Task ConsumingMethodAsync()\n{\n  int value = await MethodAsync();\n}\n```", "```cs\nValueTask<int> MethodAsync();\n\nasync Task ConsumingMethodAsync()\n{\n  ValueTask<int> valueTask = MethodAsync();\n  ... // other concurrent work\n  int value = await valueTask;\n}\n```", "```cs\nValueTask<int> MethodAsync();\n\nasync Task ConsumingMethodAsync()\n{\n  Task<int> task = MethodAsync().AsTask();\n  ... // other concurrent work\n  int value = await task;\n  int anotherValue = await task;\n}\n```", "```cs\nValueTask<int> MethodAsync();\n\nasync Task ConsumingMethodAsync()\n{\n  Task<int> task1 = MethodAsync().AsTask();\n  Task<int> task2 = MethodAsync().AsTask();\n  int[] results = await Task.WhenAll(task1, task2);\n}\n```"]