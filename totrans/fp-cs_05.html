<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xml:lang="en"
      lang="en"
      xmlns="http://www.w3.org/1999/xhtml"
      xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>Functional Programming with C#</title>
<link rel="stylesheet" type="text/css" href="override_v1.css"/>
<link rel="stylesheet" type="text/css" href="epub.css"/>
</head>
<body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 5. Higher-Order Functions"><div class="chapter" id="Chapter5_Beginning">
<h1><span class="label">Chapter 5. </span>Higher-Order Functions</h1>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45400867416736">
<h1>A Note for Early Release Readers</h1>
<p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p>

<p>This will be the fifth chapter of the final book. Please note that the GitHub repo will be made active later on.</p>

<p>If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the editor at <a href="mailto:jleonard@oreilly.com">jleonard@oreilly.com</a>.</p>
</div></aside>

<p>Welcome back my friends to the show that never ends.</p>

<p>This chapter, we’re looking at uses for higher-order functions.  I’m going to look at novel ways to use them in C# to save yourself effort, and to make code that is less likely to fail.</p>

<p>But, what <em>are</em> Higher-order functions?</p>

<p>Higher-order Functions is a slightly odd name for something very simple. In fact you’ve likely been using them for some time if you’ve spent much time working with LINQ. They come in two flavors, here’s the first:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="kt">var</code> <code class="n">liberatorCrew</code> <code class="p">=</code> <code class="k">new</code> <code class="p">[]</code>
<code class="p">{</code>
 <code class="s">"Roj Blake"</code><code class="p">,</code>
 <code class="s">"Kerr Avon"</code><code class="p">,</code>
 <code class="s">"Vila Restal"</code><code class="p">,</code>
 <code class="s">"Jenna Stannis"</code><code class="p">,</code>
 <code class="s">"Cally"</code><code class="p">,</code>
 <code class="s">"Olag Gan"</code><code class="p">,</code>
 <code class="s">"Zen"</code>
<code class="p">};</code>
<code class="kt">var</code> <code class="n">filteredList</code> <code class="p">=</code> <code class="n">liberatorCrew</code><code class="p">.</code><code class="n">Where</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code><code class="p">.</code><code class="n">First</code><code class="p">()</code> <code class="p">&gt;</code> <code class="sc">'M'</code><code class="p">);</code></pre>

<p>Passed into the <code>Where</code> function there is an arrow expression - which is just a shorthand for writing out an unnamed function.  The long-hand version would look like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="n">function</code> <code class="kt">bool</code> <code class="nf">IsGreaterThanM</code><code class="p">(</code><code class="kt">char</code> <code class="n">c</code><code class="p">)</code>
<code class="p">{</code>
 <code class="k">return</code> <code class="n">c</code> <code class="p">&gt;</code> <code class="sc">'m'</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>So here, the function has been passed around as the parameter to another function, to be executed elsewhere inside it.</p>

<p>This is another example of the use of higher-order functions:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="n">Func</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">,</code> <code class="kt">int</code><code class="p">&gt;</code> <code class="n">MakeAddFunc</code><code class="p">(</code><code class="kt">int</code> <code class="n">x</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">y</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">+</code> <code class="n">y</code><code class="p">;</code></pre>

<p>Notice here that there are two arrows, not one.  We’re taking an integer <em>x</em> and from that returning a new function.  In that new function references to <em>x</em> will be filled in with whatever was provided when MakeAddFunc was called originally.</p>

<p>For example:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="kt">var</code> <code class="n">addTenFunction</code> <code class="p">=</code> <code class="n">MakeAddFunc</code><code class="p">(</code><code class="m">10</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">answer</code> <code class="p">=</code> <code class="n">addTenFunction</code><code class="p">(</code><code class="m">5</code><code class="p">);</code>
<code class="c1">// answer is 15</code></pre>

<p>By passing 10 into <code>MakeAddFunc</code> in the example above, I created a new function whose function is simply to add 10 to whatever addtional integer you pass into it.</p>

<p>In short a higher-order function is a function with one or more of the following properties:</p>

<ul>
<li>
<p>Accepts a function as a parameter</p>
</li>
<li>
<p>Returns a function as its return type</p>
</li>
</ul>

<p>In C# this is all typically done with either a <code>Func</code> (for functions with a return type) or <code>Action</code> (for functions that return void) delegate types.</p>

<p>It’s a fairly simple idea, and even easier to implement - but the effect they can have on your codebase is incredible.</p>

<p>In this chapter I’m going to walk through ways of using Higher-Order Functions to improve your daily coding.</p>

<p>I’ll also be looking quite a bit into a next-level usage of Higher-Order functions called Combinators.  These enable passing around functions in a way that creates a more complex - and useful - behavior.  They’re called that incidentally, because they originate from a mathematical technique called Combinatory Logic.  You won’t need to worry about ever hearing that term again, or about any references to advanced maths - I’m not going there.  It’s just in case you were curious…​</p>






<section data-type="sect1" data-pdf-bookmark="A Problem Report"><div class="sect1" id="idm45400867230208">
<h1>A Problem Report</h1>

<p>To get started, we’ll look at a bit of problem code.  Let’s imagine that your company have asked you for a function to take a data store of some kind (an XML file, a JSON file, who knows.  Doesn’t matter), summarise how many there are of each possible value, then transmit that data on to somewhere else.  On top of that, they want a separate message to be sent in the event that no data was found at all.  I run a really, really loose ship, so let’s keep things fun, and imagine you work for the Evil Galactic Empire™ and you are cataloguing Rebel Alliance ships on your radar.</p>

<p>The code might look something like this:</p>

<pre data-type="programlisting" data-code-language="csharp"> <code class="k">public</code> <code class="k">void</code> <code class="nf">SendEnemyShipWeaponrySummary</code><code class="p">()</code>
 <code class="p">{</code>
  <code class="k">try</code>
  <code class="p">{</code>
    <code class="kt">var</code> <code class="n">enemyShips</code> <code class="p">=</code> <code class="k">this</code><code class="p">.</code><code class="n">DataStore</code><code class="p">.</code><code class="n">GetEnemyShips</code><code class="p">();</code>
    <code class="kt">var</code> <code class="n">summaryNumbers</code> <code class="p">=</code> <code class="n">enemyShips</code><code class="p">.</code><code class="n">GroupBy</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code><code class="p">.</code><code class="n">Type</code><code class="p">)</code>
                                    <code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="n">Type</code><code class="p">:</code> <code class="n">x</code><code class="p">.</code><code class="n">Key</code><code class="p">,</code> <code class="n">Count</code><code class="p">:</code> <code class="n">x</code><code class="p">.</code><code class="n">Count</code><code class="p">()));</code>
    <code class="kt">var</code> <code class="n">report</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Report</code>
    <code class="p">{</code>
        <code class="n">Title</code> <code class="p">=</code> <code class="s">"Enemy Ship Type"</code><code class="p">,</code>
        <code class="n">Rows</code> <code class="p">=</code> <code class="n">summaryNumbers</code><code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">X</code> <code class="p">=&gt;</code> <code class="k">new</code> <code class="n">ReportItem</code>
        <code class="p">{</code>
            <code class="n">ColumnOne</code> <code class="p">=</code> <code class="n">X</code><code class="p">.</code><code class="n">Type</code><code class="p">,</code>
            <code class="n">ColumnTwo</code> <code class="p">=</code> <code class="n">X</code><code class="p">.</code><code class="n">Count</code><code class="p">.</code><code class="n">ToString</code><code class="p">()</code>
        <code class="p">})</code>
    <code class="p">};</code>

    <code class="k">if</code> <code class="p">(!</code><code class="n">report</code><code class="p">.</code><code class="n">Rows</code><code class="p">.</code><code class="n">Any</code><code class="p">())</code>
        <code class="k">this</code><code class="p">.</code><code class="n">CommunicationSystem</code><code class="p">.</code><code class="n">SendNoDataWarning</code><code class="p">();</code>
    <code class="k">else</code>
        <code class="k">this</code><code class="p">.</code><code class="n">CommunicationSystem</code><code class="p">.</code><code class="n">SendReport</code><code class="p">(</code><code class="n">report</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="k">catch</code> <code class="p">(</code><code class="n">Exception</code> <code class="n">e</code><code class="p">)</code>
  <code class="p">{</code>
   <code class="k">this</code><code class="p">.</code><code class="n">Logger</code><code class="p">.</code><code class="n">LogError</code><code class="p">(</code><code class="n">e</code><code class="p">,</code>
   <code class="err">$</code><code class="s">"An error occurred in {nameof(SendEnemyShipWeaponrySummary)}: {e.Message}"</code><code class="p">);</code>
  <code class="p">}</code>
 <code class="p">}</code></pre>

<p>This is fine, isn’t it?  Isn’t it?  Well, think about this scenario.  You’re sitting at your desk, eating your daily pot noodle<sup><a data-type="noteref" id="idm45400867135648-marker" href="ch05.html#idm45400867135648">1</a></sup>, when you notice that - Jurassic Park style - there is a rhythmic ripple appearing in your coffee.  This signals the arrival of your worst nightmare.  Your boss!  Let’s imagine that your boss is - thinking totally at random here - a tall, deep-voiced gentleman in a black cape and with appauling asthma.  He also really hates it when people displease him.  <em>Really</em> hates it.</p>

<p>He’s happy with the first function you created.  For this you can breath a sigh of relief.  But now he wants a second function.  This one is going to create another summary, but this time of the level of weaponry in each ship.  Whether they are unarmed, lightly armed, heavily armed or capable of destroying planets.  That sort of thing.</p>

<p>Easy, you think.  The boss will be so impressed with how quickly I do this.  So, you do what seems easiest <code>Ctrl+C</code>, then <code>Ctrl+V</code> to copy &amp; paste the original, change the name, change the property you’re summarising, and you end up with something like this:</p>

<pre data-type="programlisting" data-code-language="csharp"> <code class="k">public</code> <code class="k">void</code> <code class="nf">GenerateEnemyShipWeaponrySummary</code><code class="p">()</code>
 <code class="p">{</code>
  <code class="k">try</code>
  <code class="p">{</code>
    <code class="kt">var</code> <code class="n">enemyShips</code> <code class="p">=</code> <code class="k">this</code><code class="p">.</code><code class="n">DataStore</code><code class="p">.</code><code class="n">GetEnemyShips</code><code class="p">();</code>
    <code class="kt">var</code> <code class="n">summaryNumbers</code> <code class="p">=</code> <code class="n">enemyShips</code><code class="p">.</code><code class="n">GroupBy</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code><code class="p">.</code><code class="n">WeaponryLevel</code><code class="p">)</code>
                                    <code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="n">Type</code><code class="p">:</code> <code class="n">x</code><code class="p">.</code><code class="n">Key</code><code class="p">,</code> <code class="n">Count</code><code class="p">:</code> <code class="n">x</code><code class="p">.</code><code class="n">Count</code><code class="p">()));</code>
    <code class="kt">var</code> <code class="n">report</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Report</code>
    <code class="p">{</code>
        <code class="n">Title</code> <code class="p">=</code> <code class="s">"Enemy Ship Weaponry Level"</code><code class="p">,</code>
        <code class="n">Rows</code> <code class="p">=</code> <code class="n">summaryNumbers</code><code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">X</code> <code class="p">=&gt;</code> <code class="k">new</code> <code class="n">ReportItem</code>
        <code class="p">{</code>
            <code class="n">ColumnOne</code> <code class="p">=</code> <code class="n">X</code><code class="p">.</code><code class="n">Type</code><code class="p">,</code>
            <code class="n">ColumnTwo</code> <code class="p">=</code> <code class="n">X</code><code class="p">.</code><code class="n">Count</code><code class="p">.</code><code class="n">ToString</code><code class="p">()</code>
        <code class="p">})</code>
    <code class="p">};</code>

    <code class="k">if</code> <code class="p">(!</code><code class="n">report</code><code class="p">.</code><code class="n">Rows</code><code class="p">.</code><code class="n">Any</code><code class="p">())</code>
        <code class="k">this</code><code class="p">.</code><code class="n">CommunicationSystem</code><code class="p">.</code><code class="n">SendNoDataWarning</code><code class="p">();</code>
    <code class="k">else</code>
        <code class="k">this</code><code class="p">.</code><code class="n">CommunicationSystem</code><code class="p">.</code><code class="n">SendReport</code><code class="p">(</code><code class="n">report</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="k">catch</code> <code class="p">(</code><code class="n">Exception</code> <code class="n">e</code><code class="p">)</code>
  <code class="p">{</code>
   <code class="k">this</code><code class="p">.</code><code class="n">Logger</code><code class="p">.</code><code class="n">LogError</code><code class="p">(</code><code class="n">e</code><code class="p">,</code>
   <code class="err">$</code><code class="s">"An error occurred in {nameof(GenerateEnemyShipWeaponrySummary)}: {e.Message}"</code><code class="p">);</code>
  <code class="p">}</code>
 <code class="p">}</code></pre>

<p>Five seconds of work, and a day or two of leaning on your figurative shovel with the odd complaint out-loud of how hard the work is here, all while you secretly work on today’s Wordle.  Job done, and slaps on the back all round, right?  Right?</p>

<p>Well…​.There are a couple of problems with this approach.</p>

<p>First, let’s think about unit testing.  As good, upstanding code citizens, we unit test all of our code.  Imagine we’d unit tested the snot out of that first function.  When we copied &amp; pasted the second in, what was the level of unit test coverage at that point?</p>

<p>I’ll give you a clue - it was between zero and zero.  You could copy and paste the tests too, and that would be fine, but that’s now an awful lot more code that we’re copying and pasting every time.</p>

<p>This isn’t an approach that scales up well.  What if our boss wanted another function after this one, and another, and another.  What if we ended being asked for 50 functions?  Or 100?!?  That’s a lot of code.  You’d end up with something thousands of lines long, not something I’d be keen to support.</p>

<p>It gets worse when you consider something that happened to me near the beginnning of my career.  I was working for an organisation that had a desktop application that carried out a series of complex calculations for each customer, based on a few input parameters.  Each year, the rules changed, but the old rule bases had to be replicated because it might be necessary to see what would have been calculated in a previous year.</p>

<p>So, the folks that had been developing the app before I joined the team had copied a whole chunk of code every year.  Made a few little changes, added a link somewhere to the new version, and voilà.  Job done.</p>

<p>I was tasked with making these annual changes one year, so off I went, young, innocent and raring to make a difference to the world.  When I was making my changes, I noticed something odd.  There was a weird error with a field that wasn’t anything to do with my changes.  I fixed the bug, but then a thought occurred to me that made my heart sink…​</p>

<p>I checked every previous version of the codebase for each previous year and found that nearly all of them had the same bug.   It had been introduced about 10 years ago, and every devleoper since then had replicated the bug precisely.  So, I had to fix it 10 times over, increasing the testing effort by an order of magnitude.</p>

<p>With this in mind, ask yourself - did copying and pasting really save you any time?  I routinely work on apps that stay in existence for decades, and which show no sign of being put out to pasture any time soon.</p>

<p>When I decide where to make time-saving measures for coding work, I try and look over the whole life of the application, and try to keep in mind what the consequences might be for a decision a decade on.</p>

<p>To return to the subject at hand, how would I have used Higher-order functions to solve this problem?  Well, are you sitting comfortably?  Then I’ll begin…​</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Thunks"><div class="sect1" id="idm45400867229264">
<h1>Thunks</h1>

<p>A bundle of code that carries a stored calculation, which can be executed later on request is properly known as a <em>Thunk</em>.  Same as the sound a plank of wood makes when it smacks you in the side of the head.  There’s an argument to be had as to whether that hurts your head more or less than reading this book!</p>

<p>Here in C#, <code>Func</code> delegates are again the way that we’d implement this.  We can write functions that take <code>Func</code> delegates as parameter values, to allow for certain calculations in our function to be left effectively blank, and which can be filled in from the outside world, via an arrow function.</p>

<p>Although there is a serious, proper, mathematical term for this technique, I like calling them doughnut functions, because it’s more descriptive.  They’re like normal functions, but with a hole in the middle!  A hole I’d ask someone else to fill in with the necessary functionality.</p>

<p>This is one potential way to refactor the problem report function:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">void</code> <code class="nf">SendEnemyShipWeaponrySummary</code><code class="p">()</code> <code class="p">=&gt;</code>
  <code class="n">GenerateSummary</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code><code class="p">.</code><code class="n">Type</code><code class="p">,</code> <code class="s">"Enemy Ship Type Summary"</code><code class="p">);</code>

<code class="k">public</code> <code class="k">void</code> <code class="nf">GenerateEnemyShipWeaponryLevelSummary</code><code class="p">()</code> <code class="p">=&gt;</code>
  <code class="n">GenerateSummary</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code><code class="p">.</code><code class="n">WeaponryLevel</code><code class="p">,</code> <code class="s">"Enemy Ship WeaponryLevel"</code><code class="p">);</code>

<code class="k">private</code> <code class="k">void</code> <code class="nf">GenerateSummary</code><code class="p">(</code><code class="n">Func</code><code class="p">&lt;</code><code class="n">EnemyShip</code><code class="p">,</code> <code class="kt">string</code><code class="p">&gt;</code> <code class="n">summarySelector</code><code class="p">,</code> <code class="kt">string</code> <code class="n">reportName</code><code class="p">)</code>
<code class="p">{</code>
  <code class="k">try</code>
  <code class="p">{</code>
    <code class="kt">var</code> <code class="n">enemyShips</code> <code class="p">=</code> <code class="k">this</code><code class="p">.</code><code class="n">DataStore</code><code class="p">.</code><code class="n">GetEnemyShips</code><code class="p">();</code>
    <code class="kt">var</code> <code class="n">summaryNumbers</code> <code class="p">=</code> <code class="n">enemyShips</code><code class="p">.</code><code class="n">GroupBy</code><code class="p">(</code><code class="n">summarySelector</code><code class="p">)</code>
                                    <code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="n">Type</code><code class="p">:</code> <code class="n">x</code><code class="p">.</code><code class="n">Key</code><code class="p">,</code> <code class="n">Count</code><code class="p">:</code> <code class="n">x</code><code class="p">.</code><code class="n">Count</code><code class="p">()));</code>
    <code class="kt">var</code> <code class="n">report</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Report</code>
    <code class="p">{</code>
      <code class="n">Title</code> <code class="p">=</code> <code class="n">reportName</code><code class="p">,</code>
      <code class="n">Rows</code> <code class="p">=</code> <code class="n">summaryNumbers</code><code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">X</code> <code class="p">=&gt;</code> <code class="k">new</code> <code class="n">ReportItem</code>
      <code class="p">{</code>
          <code class="n">ColumnOne</code> <code class="p">=</code> <code class="n">X</code><code class="p">.</code><code class="n">Type</code><code class="p">,</code>
          <code class="n">ColumnTwo</code> <code class="p">=</code> <code class="n">X</code><code class="p">.</code><code class="n">Count</code><code class="p">.</code><code class="n">ToString</code><code class="p">()</code>
      <code class="p">})</code>
  <code class="p">};</code>

  <code class="k">if</code> <code class="p">(!</code><code class="n">report</code><code class="p">.</code><code class="n">Rows</code><code class="p">.</code><code class="n">Any</code><code class="p">())</code>
   <code class="k">this</code><code class="p">.</code><code class="n">CommunicationSystem</code><code class="p">.</code><code class="n">SendNoDataWarning</code><code class="p">();</code>
  <code class="k">else</code>
   <code class="k">this</code><code class="p">.</code><code class="n">CommunicationSystem</code><code class="p">.</code><code class="n">SendReport</code><code class="p">(</code><code class="n">report</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="k">catch</code> <code class="p">(</code><code class="n">Exception</code> <code class="n">e</code><code class="p">)</code>
  <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="n">Logger</code><code class="p">.</code><code class="n">LogError</code><code class="p">(</code><code class="n">e</code><code class="p">,</code>
    <code class="err">$</code><code class="s">"An error occurred in {nameof(GenerateSummary)}, report: {reportName}, message: {e.Message}"</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p>In this, revised version, we’ve gained a few advantages.</p>

<p>Firstly, the number of additional lines per new report is just one!  That’s a much tidier codebase, and easier to read.  The code is kept very close to the intent of the new function - i.e. be the same as the first, but with a few changes.</p>

<p>Secondly, after unit testing function 1, when we create function 2, the unit test level is still close to 100%.  The only difference functionally is the report name, and the field to be summarised.</p>

<p>Lastly, any enhancements or bug fixes to the base function will be shared between all report functions simultaniously.  That’s a lot of benefit for relatively little effort.  There’s also a very high degree of confidence that if one report function tests well, that all of the others will be the same.</p>

<p>One could actually walk away from this version happy.  But, if it were me, I’d actually consider going a step further and exposing the private version with its <code>Func</code> parameters on the interface for whatever wants to use it.</p>

<p>Something like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">interface</code> <code class="n">IGenerateReports</code>
<code class="p">{</code>
 <code class="k">void</code> <code class="nf">GenerateSummary</code><code class="p">(</code><code class="n">Func</code><code class="p">&lt;</code><code class="n">EnemyShip</code><code class="p">,</code> <code class="kt">string</code><code class="p">&gt;</code> <code class="n">summarySelector</code><code class="p">,</code> <code class="kt">string</code> <code class="n">reportName</code><code class="p">)</code>
<code class="p">}</code></pre>

<p>The implementation would be the private function from the previous code sample made public instead.   This way there’s no need to ever modify the interface or implementing class again, at least not if all that’s wanted is an additional report for a different field.</p>

<p>This makes the business of creating reports something that can be done entirely arbitrarily by whatever code module consumes this class.  It saves a lot of the burdon of maintaining the report set from developers like ourselves, and puts it more in the hands of the teams that care about the reports themselves.  Imagine the sheer number of Requests for Change that will now never need to come to a development team.</p>

<p>If you wanted to be really wild, you could expose further <code>Func</code> parameters as <code>Func&lt;ReportLine,string&gt;</code> to allow users of the report class to define  custom formatting.  You could also use <code>Action</code> parameters to allow for bespoke logging or event handling.  This is just in my silly, made-up reporting class.  The possibilities for the use of higher-order functions in this way are endless.</p>

<p>Despite being a functional programming feature, this is keeping us squarely in line with the <em>O</em> of the SOLID Principles of Object-Oriented design<sup><a data-type="noteref" id="idm45400866574816-marker" href="ch05.html#idm45400866574816">2</a></sup> - the Open/Closed principle, which states a module should be open to extension, but closed to modification.</p>

<p>It’s surprising how well OO and functional programming can complement each other in C#.  I often think it’s important for developers to make sure they are adept at both paradigms, so they know how to use them together effectively.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Chaining Functions"><div class="sect1" id="Chapter5_map_combinator">
<h1>Chaining Functions</h1>

<p>Allow me to introduce you to the best friend you never knew you needed - the Map function. This function is also commonly referred to as Chain and Pipe, but for the sake of consistency, we’ll call it Map throughout this book.  I’m afraid that there’s a tendency for a lot of functional structures to have many names in use, depending on the programming language and implementation.  I’ll try and point out whenever this is the case.</p>

<p>Now, I’m British, and there’s a cliché about British people that we like talking about the weather.  It’s entirely true.  Our country is one that’s been known to go through 4 seasons in a single day, so the weather is a constant source of fascination to us.</p>

<p>I used to work for an American company, once upon a time, and when I did, the topic of conversation with my colleagues over video call would often turn inevitably to the subject of the weather.  They’d tell me that the temperature outside was around 100 degrees.  I work in celcius, so to me this sounds rather suspiciously like the boiling point of water.  Given that my colleagues were not screamning as their blood boiled away into steam, I suspected something else was at work.  It was, of course, that they were working in Fahrenheit, so I had to convert this to something I understood with the following formula:</p>

<ul>
<li>
<p>subtract 32</p>
</li>
<li>
<p>Then, multiply by 5</p>
</li>
<li>
<p>Then, divide by 9</p>
</li>
</ul>

<p>Which gives a temperature in Celcius of around 38 degrees, which is warm and toasty, but for the most part safe for human life.</p>

<p>How could I code this process in exactly that multi-step operation, then finish by returning a formatted string?  I <em>could</em> stick it all together into a single line like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="kt">string</code> <code class="nf">FahrenheitToCelcius</code><code class="p">(</code><code class="kt">decimal</code> <code class="n">tempInF</code><code class="p">)</code> <code class="p">=&gt;</code>
  <code class="n">Math</code><code class="p">.</code><code class="n">Round</code><code class="p">(((</code><code class="n">tempInF</code><code class="p">-</code><code class="m">32</code><code class="p">)</code> <code class="p">*</code><code class="m">5</code> <code class="p">/</code> <code class="m">9</code><code class="p">),</code> <code class="m">2</code><code class="p">)</code> <code class="p">+</code> <code class="s">"°C"</code><code class="p">;</code></pre>

<p>Not very readable though, is it?  Honestly, I probably wouldn’t make too much fuss about that in production code, but I’m demonstrating a technique, and I don’t want to get bogged down, so bear with me.</p>

<p>The multi-step way to write this out is like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="kt">string</code> <code class="nf">FahrenheitToCelcius</code><code class="p">(</code><code class="kt">decimal</code> <code class="n">tempInF</code><code class="p">)</code>
<code class="p">{</code>
 <code class="kt">var</code> <code class="n">a</code> <code class="p">=</code> <code class="n">tempInF</code> <code class="p">-</code> <code class="m">32</code><code class="p">;</code>
 <code class="kt">var</code> <code class="n">b</code> <code class="p">=</code> <code class="n">a</code> <code class="p">*</code> <code class="m">5</code><code class="p">;</code>
 <code class="kt">var</code> <code class="n">c</code> <code class="p">=</code> <code class="n">b</code> <code class="p">/</code> <code class="m">9</code><code class="p">;</code>
 <code class="kt">var</code> <code class="n">d</code> <code class="p">=</code> <code class="n">Math</code><code class="p">.</code><code class="n">Round</code><code class="p">(</code><code class="n">c</code><code class="p">,</code> <code class="m">2</code><code class="p">);</code>
 <code class="kt">var</code> <code class="n">returnValue</code> <code class="p">=</code> <code class="n">d</code> <code class="p">+</code> <code class="s">"°C"</code><code class="p">;</code>
 <code class="k">return</code> <code class="n">returnValue</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>This is much more readable, and easier to maintain, but it still has an issue.  We’re creating variables that are essential intended to be used a single time and then thrown away.  In this little function it’s not terribly relevant, but what if this were a gigantic thousand-line function?  What if instead of a little decimal variable like these, there was a large, complex object instead?  All the way down at line 1000, that variable - which is never intended to be used again - is still in scope, and holding up memory.  It’s also a little messy to create a variable you aren’t planning to make any use of beyond the next line.  This is where Map comes in.</p>

<p>Map is somewhat like the LINQ <code>Select</code> function, except instead of operating on each element of an Enumerable, it operates on an object.  Any object.  You pass it a Lambda arrow function just the same as with <code>Select</code> except that your <em>x</em> parameter refers to the base object.  If you applied it to an Enumerable, the <em>x</em> parameter would refer to the entire enumerable, not indivudual elements thereof.</p>

<p>Here’s what my modified Fahrenheit conversion would look:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="kt">string</code> <code class="nf">FahrenheitToCelcius</code><code class="p">(</code><code class="kt">decimal</code> <code class="n">tempInF</code><code class="p">)</code>  <code class="p">=&gt;</code>
	<code class="n">tempInF</code><code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">-</code> <code class="m">32</code><code class="p">)</code>
			<code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">*</code> <code class="m">5</code><code class="p">)</code>
			<code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">/</code> <code class="m">9</code><code class="p">)</code>
			<code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">Math</code><code class="p">.</code><code class="n">Round</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="m">2</code><code class="p">))</code>
			<code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">+</code> <code class="s">"°C"</code><code class="p">);</code></pre>

<p>Same exact functionality, same friendly, multi-stage operation, but no throw-away variables.  Each of those arrow functions is executed, then once completed, their contents are subject for Garbage Collection.  The decimal <em>x</em> that is multiplied by 5 is subject for disposal when the next arrow function takes a copy of its result and divides that by 9.</p>

<p>Here’s how you implement Map:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">static</code> <code class="k">class</code> <code class="nc">MapExtensionMethods</code>
<code class="p">{</code>
	<code class="k">public</code> <code class="k">static</code> <code class="n">TOut</code> <code class="n">Map</code><code class="p">&lt;</code><code class="n">TIn</code><code class="p">,</code> <code class="n">TOut</code><code class="p">&gt;(</code><code class="k">this</code> <code class="n">TIn</code> <code class="n">@this</code><code class="p">,</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">TIn</code><code class="p">,</code> <code class="n">TOut</code><code class="p">&gt;</code> <code class="n">f</code><code class="p">)</code> <code class="p">=&gt;</code>
		<code class="n">f</code><code class="p">(</code><code class="n">@this</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>It’s tiny, isn’t it?  Despite that, I use this partiular method quite a lot.  Whenever I want to do a multi-step transformaton of data.  It makes it easier to convert whole function bodies into simple arrow functions, like my Map-based FahrenheitToCelcius function, above.</p>

<p>There are far more advanced versions of this method, which includes things like error handling, and which I’ll be getting onto in Chapter 7.  For now though, this is a fantastic little toy that you can start playing with right away.  Uncle Simon’s early Christmas gift to you.  Ho, ho, ho.</p>

<p>There is a simpler implementation of Map possible, if you don’t want to change types with each transformation.  This is cleaner and more concise, if it suits your needs.</p>

<p>It could be implemented like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">static</code> <code class="n">T</code> <code class="n">Map</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;(</code><code class="k">this</code> <code class="n">T</code> <code class="n">@this</code><code class="p">,</code> <code class="k">params</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">T</code><code class="p">,</code><code class="n">T</code><code class="p">&gt;[]</code> <code class="n">transformations</code><code class="p">)</code> <code class="p">=&gt;</code>
 <code class="n">transformations</code><code class="p">.</code><code class="n">Aggregate</code><code class="p">(</code><code class="n">@this</code><code class="p">,</code> <code class="p">(</code><code class="n">agg</code><code class="p">,</code> <code class="n">x</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">x</code><code class="p">(</code><code class="n">agg</code><code class="p">));</code></pre>

<p>Using that, the basic Fahrenheit to Celcius transformation would be something like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="kt">decimal</code> <code class="nf">FahrenheitToCelcius</code><code class="p">(</code><code class="kt">decimal</code> <code class="n">tempInF</code><code class="p">)</code>  <code class="p">=&gt;</code>
	<code class="n">tempInF</code><code class="p">.</code><code class="n">Map</code><code class="p">(</code>
	 <code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">-</code> <code class="m">32</code><code class="p">,</code>
	 <code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">*</code> <code class="m">5</code><code class="p">,</code>
	 <code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">/</code> <code class="m">9</code>
	 <code class="n">x</code> <code class="p">=&gt;</code> <code class="n">Math</code><code class="p">.</code><code class="n">Round</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="m">2</code><code class="p">);</code></pre>

<p>This might be worth using to save a little bit of boilerplate in simpler cases, like the temperature conversion.  See Chapter 8 later on Currying for some ideas on how to make this look even better.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Fork Combinator"><div class="sect1" id="idm45400866131088">
<h1>Fork Combinator</h1>

<p>I’ve also heard this one called “Converge”.  I like “Fork” though, it’s more descriptive of how exactly it works.  A Fork combinator is used to taka a single value, then process it in multiple ways, simultaniously, then join up all of those separate strands into a single, final value.  It can be used to simplify some fairly complex multi-step calculations into a single line of code.</p>

<p>The process is going to run roughly like this:</p>

<ul>
<li>
<p>Start with a single value</p>
</li>
<li>
<p>Feed it into a set of “prong” functions - each of which act on the original input in isolation to produce some sort of output</p>
</li>
<li>
<p>A “join” function takes the result of the prongs and merges it into a final result.</p>
</li>
</ul>

<p>Here are a few examples of how I might use it.</p>

<p>If you want to specify the number of arguments in your function definition - rather than having an unspecified number of prongs from an array, then it’s possible to use a Fork to calculate an average value:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="kt">var</code> <code class="n">numbers</code> <code class="p">=</code> <code class="k">new</code> <code class="p">[]</code> <code class="p">{</code> <code class="m">4</code><code class="p">,</code> <code class="m">8</code><code class="p">,</code> <code class="m">15</code><code class="p">,</code> <code class="m">16</code><code class="p">,</code> <code class="m">23</code><code class="p">,</code> <code class="m">42</code> <code class="p">}</code>
<code class="kt">var</code> <code class="n">average</code> <code class="p">=</code> <code class="n">numbers</code><code class="p">.</code><code class="n">Fork</code><code class="p">(</code>
 <code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code><code class="p">.</code><code class="n">Sum</code><code class="p">(),</code>
 <code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code><code class="p">.</code><code class="n">Count</code><code class="p">(),</code>
 <code class="p">(</code><code class="n">s</code><code class="p">,</code> <code class="n">c</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">s</code> <code class="p">/</code> <code class="n">c</code>
<code class="p">);</code>
<code class="c1">// average = 18</code></pre>

<p>or here’s a blast from the past, a Fork you can use to calculate the Hypotenuse of a triangle:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="kt">var</code> <code class="n">triangle</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Triangle</code><code class="p">(</code><code class="m">100</code><code class="p">,</code> <code class="m">200</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">hypotenuse</code> <code class="p">=</code> <code class="n">triangle</code><code class="p">.</code><code class="n">Fork</code><code class="p">(</code>
 <code class="n">x</code> <code class="p">=&gt;</code> <code class="n">Math</code><code class="p">.</code><code class="n">Pow</code><code class="p">(</code><code class="n">x</code><code class="p">.</code><code class="n">A</code><code class="p">,</code> <code class="m">2</code><code class="p">),</code>
 <code class="n">x</code> <code class="p">=&gt;</code> <code class="n">Math</code><code class="p">.</code><code class="n">Pow</code><code class="p">(</code><code class="n">x</code><code class="p">.</code><code class="n">B</code><code class="p">,</code> <code class="m">2</code><code class="p">),</code>
 <code class="p">(</code><code class="n">a2</code><code class="p">,</code> <code class="n">b2</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">Math</code><code class="p">.</code><code class="n">Sqrt</code><code class="p">(</code><code class="n">a2</code> <code class="p">+</code> <code class="n">b2</code><code class="p">)</code>
<code class="p">);</code></pre>

<p>The implementation looks like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">static</code> <code class="k">class</code> <code class="nc">ext</code>
<code class="p">{</code>
	<code class="k">public</code> <code class="k">static</code> <code class="n">TOut</code> <code class="n">Fork</code><code class="p">&lt;</code><code class="n">TIn</code><code class="p">,</code> <code class="n">T1</code><code class="p">,</code> <code class="n">T2</code><code class="p">,</code> <code class="n">TOut</code><code class="p">&gt;(</code>
	  <code class="k">this</code> <code class="n">TIn</code> <code class="n">@this</code><code class="p">,</code>
	  <code class="n">Func</code><code class="p">&lt;</code><code class="n">TIn</code><code class="p">,</code> <code class="n">T1</code><code class="p">&gt;</code> <code class="n">f1</code><code class="p">,</code>
	  <code class="n">Func</code><code class="p">&lt;</code><code class="n">TIn</code><code class="p">,</code> <code class="n">T2</code><code class="p">&gt;</code> <code class="n">f2</code><code class="p">,</code>
	  <code class="n">Func</code><code class="p">&lt;</code><code class="n">T1</code><code class="p">,</code><code class="n">T2</code><code class="p">,</code><code class="n">TOut</code><code class="p">&gt;</code> <code class="n">fout</code><code class="p">)</code>
	<code class="p">{</code>
		<code class="kt">var</code> <code class="n">p1</code> <code class="p">=</code> <code class="n">f1</code><code class="p">(</code><code class="n">@this</code><code class="p">);</code>
		<code class="kt">var</code> <code class="n">p2</code> <code class="p">=</code> <code class="n">f2</code><code class="p">(</code><code class="n">@this</code><code class="p">);</code>
		<code class="kt">var</code> <code class="n">result</code> <code class="p">=</code> <code class="n">fout</code><code class="p">(</code><code class="n">p1</code><code class="p">,</code> <code class="n">p2</code><code class="p">);</code>
		<code class="k">return</code> <code class="n">result</code><code class="p">;</code>
	<code class="p">}</code>
<code class="p">}</code></pre>

<p>Note that having two generic types, one for each prong, means that any combination of types can be returned by those functions.</p>

<p>You could easily go out and write versions of this for any number of parameters beyond two as well, but each additional parameter you want to consider would require an additional extension method.</p>

<p>If you wanted to go further, and have an unlimited number of “prongs”, then provided you are OK with having the same intermediate type generated by each, that’s easily done:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">static</code> <code class="k">class</code> <code class="nc">ForkExtensionMethods</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="k">static</code> <code class="n">TEnd</code> <code class="n">Fork</code><code class="p">&lt;</code><code class="n">TStart</code><code class="p">,</code> <code class="n">TMiddle</code><code class="p">,</code> <code class="n">TEnd</code><code class="p">&gt;(</code>
  <code class="k">this</code> <code class="n">TStart</code> <code class="n">@this</code><code class="p">,</code>
  <code class="n">Func</code><code class="p">&lt;</code><code class="n">TMiddle</code><code class="p">,</code> <code class="n">TEnd</code><code class="p">&gt;</code> <code class="n">joinFunction</code><code class="p">,</code>
  <code class="k">params</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">TStart</code><code class="p">,</code> <code class="n">TMiddle</code><code class="p">&gt;[]</code> <code class="n">prongs</code>
 <code class="p">)</code>
<code class="p">{</code>
 <code class="kt">var</code> <code class="n">intermediateValues</code> <code class="p">=</code> <code class="n">prongs</code><code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code><code class="p">(</code><code class="n">@this</code><code class="p">));</code>
 <code class="kt">var</code> <code class="n">returnValue</code> <code class="p">=</code> <code class="n">joinFunction</code><code class="p">(</code><code class="n">intermediateValues</code><code class="p">);</code>
 <code class="k">return</code> <code class="n">returnValue</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>We could use this, for instance, to create a text description based on an object:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="kt">var</code> <code class="n">personData</code> <code class="p">=</code> <code class="k">this</code><code class="p">.</code><code class="n">personRepository</code><code class="p">.</code><code class="n">GetPerson</code><code class="p">(</code><code class="m">24601</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">description</code> <code class="p">=</code> <code class="n">personData</code><code class="p">.</code><code class="n">Fork</code><code class="p">(</code>
 <code class="n">prongs</code> <code class="p">=&gt;</code> <code class="kt">string</code><code class="p">.</code><code class="n">Join</code><code class="p">(</code><code class="n">Environment</code><code class="p">.</code><code class="n">NewLine</code><code class="p">,</code> <code class="n">prongs</code><code class="p">),</code>
 <code class="n">x</code> <code class="p">=&gt;</code> <code class="s">"My name is "</code> <code class="p">+</code> <code class="n">x</code><code class="p">.</code><code class="n">FirstName</code> <code class="p">+</code> <code class="s">" "</code> <code class="p">+</code> <code class="n">x</code><code class="p">.</code><code class="n">LastName</code><code class="p">,</code>
 <code class="n">x</code> <code class="p">=&gt;</code> <code class="s">"I am "</code> <code class="p">+</code> <code class="n">x</code><code class="p">.</code><code class="n">Age</code> <code class="p">+</code> <code class="s">" years old."</code><code class="p">,</code>
 <code class="n">x</code> <code class="p">=&gt;</code> <code class="s">"I live in "</code> <code class="p">+</code> <code class="n">x</code><code class="p">.</code><code class="n">Address</code><code class="p">.</code><code class="n">Town</code>
<code class="p">)</code>

<code class="c1">// This might, for example, produce:</code>
<code class="c1">//</code>
<code class="c1">// My name is Jean Valjean</code>
<code class="c1">// I am 30 years old</code>
<code class="c1">// I live in Montreuil-sur-mer</code></pre>

<p>With this Fork example, it’s easy enough to add as many more lines of description as we want, but maintaining the same level of complexity, and readability.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Alt Combinator"><div class="sect1" id="chapter_5_alt_combinator">
<h1>Alt Combinator</h1>

<p>I’ve also seen this referred to as “Or”, “Alternate” and “Alternation”.   It’s used to bind together a set of functions to achieve the same end, but which should be tried one after the other until one of them returns a value.</p>

<p>Think of it as working like “Try method A, if that doesn’t work, try method B, if that doesn’t work, try method C, if that doesn’t work I suppose we’re out of luck”.</p>

<p>Let’s try and imagine a scenario where we might want to find something by trying multiple methods:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="kt">var</code> <code class="n">jamesBond</code> <code class="p">=</code> <code class="s">"007"</code>
 <code class="p">.</code><code class="n">Alt</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="k">this</code><code class="p">.</code><code class="n">hotelService</code><code class="p">.</code><code class="n">ScanGuestsForSpies</code><code class="p">(</code><code class="n">x</code><code class="p">),</code>
 <code class="n">x</code> <code class="p">=&gt;</code> <code class="k">this</code><code class="p">.</code><code class="n">airportService</code><code class="p">.</code><code class="n">CheckPassengersForSpies</code><code class="p">(</code><code class="n">x</code><code class="p">),</code>
 <code class="n">x</code> <code class="p">=&gt;</code> <code class="k">this</code><code class="p">.</code><code class="n">barService</code><code class="p">.</code><code class="n">CheckGutterForDrunkSpies</code><code class="p">(</code><code class="n">x</code><code class="p">));</code>

 <code class="k">if</code><code class="p">(</code><code class="n">jamesBond</code> <code class="p">!=</code> <code class="k">null</code><code class="p">)</code>
  <code class="k">this</code><code class="p">.</code><code class="n">deathTrapService</code><code class="p">.</code><code class="n">CauseHorribleDeath</code><code class="p">(</code><code class="n">jamesBond</code><code class="p">);</code></pre>

<ul>
<li>
<p>So long as one of those three methods returns a value corresponding to a hard-drinking, boderline-misogynist, thuggish employee of the British Government, then the jamesBond variable won’t be null.  Whichever function returned a value first is the last function to be run.</p>
</li>
</ul>

<p>So how do we implement this function before we find our enemy has scarpered?  Like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">static</code> <code class="n">TOut</code> <code class="n">Alt</code><code class="p">&lt;</code><code class="n">TIn</code><code class="p">,</code> <code class="n">TOut</code><code class="p">&gt;(</code><code class="k">this</code> <code class="n">TIn</code> <code class="n">@this</code><code class="p">,</code> <code class="k">params</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">TIn</code><code class="p">,</code> <code class="n">TOut</code><code class="p">&gt;[]</code> <code class="n">args</code><code class="p">)</code> <code class="p">=&gt;</code>
	<code class="n">args</code><code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code><code class="p">(</code><code class="n">@this</code><code class="p">))</code>
	<code class="p">.</code><code class="n">First</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">!=</code> <code class="k">null</code><code class="p">);</code></pre>

<p>Remember here that the LINQ <code>Select</code> function operates on a lazy-loading principle, so even though I appear to be converting the whole of the <code>Func</code> array into concrete types, I’m not, because the <code>First</code> function will prevent any elements from being executed after one of them has returned a non-null value.  Isn’t LINQ great?</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Compose"><div class="sect1" id="idm45400865558416">
<h1>Compose</h1>

<p>A common feature of functional languages is the ability to build up a higher-order function from a collection of smaller functions.  Any process that involves combinging functions is called <em>Composing</em>.</p>

<p>There are JavaScript libraries like RamdaJS<sup><a data-type="noteref" id="idm45400865400736-marker" href="ch05.html#idm45400865400736">3</a></sup> that have terrific composing features available, but C#’s strong typing actually works against it in this instance.</p>

<p>There are a few methods for composing functions in C#.  The first is the most simple, just using basic Map functions, as described earlier in this chapter:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="kt">var</code> <code class="n">input</code> <code class="p">=</code> <code class="m">100</code><code class="n">M</code><code class="p">;</code>
<code class="kt">var</code> <code class="n">f</code> <code class="p">=</code> <code class="p">(</code><code class="kt">decimal</code> <code class="n">x</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">x</code><code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">-</code> <code class="m">32</code><code class="p">)</code>
  <code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">*</code> <code class="m">5</code><code class="p">)</code>
  <code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">/</code> <code class="m">9</code><code class="p">)</code>
  <code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">Math</code><code class="p">.</code><code class="n">Round</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="m">2</code><code class="p">))</code>
  <code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="err">$</code><code class="s">"{x} degrees"</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">output</code> <code class="p">=</code> <code class="n">f</code><code class="p">(</code><code class="n">input</code><code class="p">);</code>
<code class="c1">// output = "37.78 degrees"</code></pre>

<p><em>f</em> here is a composed higher-order function.  There are 5 functions (e.g. x ⇒ x - 32, those steps of the calculation) used to create it, which are described as anonymous lambda expressions.  They combine, like lego bricks, to form a larger, more complex behavior.</p>

<p>A valid question at this point - What’s the point of composing functions?</p>

<p>The answer is that you don’t necesarily have to do the whole thing all in once.  You could build it in pieces, and then ultimately create many functions using the same base pieces.</p>

<p>Imagine now that I want to also hold a <code>Func</code> delegate that represented the opposite conversion - we’d end up with two functions like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="kt">var</code> <code class="n">input</code> <code class="p">=</code> <code class="m">100</code><code class="n">M</code><code class="p">;</code>
<code class="kt">var</code> <code class="n">fahrenheitToCelcius</code> <code class="p">=</code> <code class="p">(</code><code class="kt">decimal</code> <code class="n">x</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">x</code><code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">-</code> <code class="m">32</code><code class="p">)</code>
  <code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">*</code> <code class="m">5</code><code class="p">)</code>
  <code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">/</code> <code class="m">9</code><code class="p">)</code>
  <code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">Math</code><code class="p">.</code><code class="n">Round</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="m">2</code><code class="p">))</code>
  <code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="err">$</code><code class="s">"{x} degrees"</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">output</code> <code class="p">=</code> <code class="n">fahrenheitToCelcius</code><code class="p">(</code><code class="n">input</code><code class="p">);</code>
<code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">output</code><code class="p">);.</code>
<code class="c1">// 37.78 degrees</code>

<code class="kt">var</code> <code class="n">input2</code> <code class="p">=</code> <code class="m">37.78</code><code class="n">M</code><code class="p">;</code>
<code class="kt">var</code> <code class="n">celciusToFahrenheit</code> <code class="p">=</code>	<code class="p">(</code><code class="kt">decimal</code> <code class="n">x</code><code class="p">)</code> <code class="p">=&gt;</code>
 <code class="n">x</code><code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">*</code> <code class="m">9</code><code class="p">)</code>
 <code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">/</code> <code class="m">5</code><code class="p">)</code>
 <code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">+</code> <code class="m">32</code><code class="p">)</code>
 <code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">Math</code><code class="p">.</code><code class="n">Round</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="m">2</code><code class="p">))</code>
 <code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="err">$</code><code class="s">"{x} degrees"</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">output2</code> <code class="p">=</code> <code class="n">celciusToFahrenheit</code><code class="p">(</code><code class="n">input2</code><code class="p">);</code>
<code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">output2</code><code class="p">);</code>
<code class="c1">// 100.00 degrees</code></pre>

<p>The last two lines of each function are actually identical.  Isn’t it a bit wasteful to repeat them each time?  We can actually eliminate the repetition using a Compose function:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="kt">var</code> <code class="n">formatDecimal</code> <code class="p">=</code> <code class="p">(</code><code class="kt">decimal</code> <code class="n">x</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">x</code>
 <code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">Math</code><code class="p">.</code><code class="n">Round</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="m">2</code><code class="p">))</code>
 <code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="err">$</code><code class="s">"{x} degrees"</code><code class="p">);</code>

<code class="kt">var</code> <code class="n">input</code> <code class="p">=</code> <code class="m">100</code><code class="n">M</code><code class="p">;</code>
<code class="kt">var</code> <code class="n">celciusToFahrenheit</code> <code class="p">=</code> <code class="p">(</code><code class="kt">decimal</code> <code class="n">x</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">x</code><code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">-</code> <code class="m">32</code><code class="p">)</code>
  <code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">*</code> <code class="m">5</code><code class="p">)</code>
  <code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">/</code> <code class="m">9</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">fToCFormatted</code> <code class="p">=</code> <code class="n">celciusToFahrenheit</code><code class="p">.</code><code class="n">Compose</code><code class="p">(</code><code class="n">formatDecimal</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">output</code> <code class="p">=</code> <code class="n">fToCFormatted</code><code class="p">(</code><code class="n">input</code><code class="p">);</code>
<code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">output</code><code class="p">);</code>

<code class="kt">var</code> <code class="n">input2</code> <code class="p">=</code> <code class="m">37.78</code><code class="n">M</code><code class="p">;</code>
<code class="kt">var</code> <code class="n">celciusToFahrenheit</code> <code class="p">=</code>	<code class="p">(</code><code class="kt">decimal</code> <code class="n">x</code><code class="p">)</code> <code class="p">=&gt;</code>
 <code class="n">x</code><code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">*</code> <code class="m">9</code><code class="p">)</code>
 <code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">/</code> <code class="m">5</code><code class="p">)</code>
 <code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">+</code> <code class="m">32</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">cToFFormatted</code> <code class="p">=</code> <code class="n">celciusToFahrenheit</code><code class="p">.</code><code class="n">Compose</code><code class="p">(</code><code class="n">formatDecimal</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">output2</code> <code class="p">=</code> <code class="n">cToFFormatted</code><code class="p">(</code><code class="n">input2</code><code class="p">);</code>
<code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">output2</code><code class="p">);</code></pre>

<p>Functionally, these new versions using Compose are identical to the previous versions exclusively using Map.</p>

<p>The Compose function performs nearly the same task as Map, with the subtle difference that we’re ultimately producing a <code>Func</code> delegate at the end, not a final value.  This is the code that performs the Compose process:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">static</code> <code class="k">class</code> <code class="nc">ComposeExtensionMethods</code>
<code class="p">{</code>
	<code class="k">public</code> <code class="k">static</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">TIn</code><code class="p">,</code> <code class="n">NewTOut</code><code class="p">&gt;</code> <code class="n">Compose</code><code class="p">&lt;</code><code class="n">TIn</code><code class="p">,</code> <code class="n">OldTOut</code><code class="p">,</code> <code class="n">NewTOut</code><code class="p">&gt;(</code>
	 <code class="k">this</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">TIn</code><code class="p">,</code> <code class="n">OldTOut</code><code class="p">&gt;</code> <code class="n">@this</code><code class="p">,</code>
	 <code class="n">Func</code><code class="p">&lt;</code><code class="n">OldTOut</code><code class="p">,</code> <code class="n">NewTOut</code><code class="p">&gt;</code> <code class="n">f</code><code class="p">)</code> <code class="p">=&gt;</code>
		<code class="n">x</code> <code class="p">=&gt;</code> <code class="n">f</code><code class="p">(</code><code class="n">@this</code><code class="p">(</code><code class="n">x</code><code class="p">));</code>
<code class="p">}</code></pre>

<p>By using the Compose, we’ve eliminated some unnecessary replication.  Any improvements to the Format process will be shared by both <code>Func</code> delegate objects simultaniously.</p>

<p>There is a limitation, however.  In C#, extension methods can’t be attached to lambda expressions or to functions directly.  We can attach an extension to a lambda expression if it’s referenced as a <code>Func</code> or <code>Action</code> delegate, but for that to happen it first needs to be assigned to a variable where it will be automatically set as a delegate type for us.  This is why its necessary in the examples above to assigned the chains of <code>Map</code> functions to a variable before calling <code>Compose</code> - otherwise it would be possible to simply call <code>Compose</code> at the end of the <code>Map</code> chain and save ourselves a variable assignment.</p>

<p>This process is not unlike reusing code via inheritance in Object-Oriented programming, except it’s done at the individual line level, and requires quite significantly less boilerplate to achieve.   It also keeps these similar, related pieces of code together, rather than them having to necessarily be spread out over separate classes and files.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Transduce"><div class="sect1" id="idm45400865402576">
<h1>Transduce</h1>

<p>A Transducer is a way of combining list-based operations, like Select and Where, with some form of aggregation to perform multiple transformations to a list of values, before finally collapsing it down into a single, final value.</p>

<p>While Compose is a useful feature, it has some limitations.  It effectively only ever takes the place of a Map function - i.e. it acts on the object as a whole, and it can’t perform LINQ operations on Enumerables.  You <em>could</em> Compose an array and put Select and Where operations inside each, but honestly that looks pretty messy:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="kt">var</code> <code class="n">numbers</code> <code class="p">=</code> <code class="k">new</code> <code class="p">[]</code> <code class="p">{</code> <code class="m">4</code><code class="p">,</code> <code class="m">8</code><code class="p">,</code> <code class="m">15</code><code class="p">,</code> <code class="m">16</code><code class="p">,</code> <code class="m">23</code><code class="p">,</code> <code class="m">42</code> <code class="p">};</code>
<code class="kt">var</code> <code class="n">add5</code> <code class="p">=</code> <code class="p">(</code><code class="n">IEnumerable</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">x</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">x</code><code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">y</code> <code class="p">=&gt;</code> <code class="n">y</code> <code class="p">+</code> <code class="m">5</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">Add5MultiplyBy10</code> <code class="p">=</code> <code class="n">add5</code><code class="p">.</code><code class="n">Compose</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code><code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">y</code> <code class="p">=&gt;</code> <code class="n">y</code> <code class="p">*</code> <code class="m">10</code><code class="p">));</code>

<code class="kt">var</code> <code class="n">numbersGreaterThan100</code> <code class="p">=</code> <code class="n">Add5MultiplyBy10</code><code class="p">.</code><code class="n">Compose</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code><code class="p">.</code><code class="n">Where</code><code class="p">(</code><code class="n">y</code> <code class="p">=&gt;</code> <code class="n">y</code> <code class="p">&gt;</code> <code class="m">100</code><code class="p">));</code>

<code class="kt">var</code> <code class="n">composeMessage</code> <code class="p">=</code> <code class="n">numbersGreaterThan100</code><code class="p">.</code><code class="n">Compose</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="kt">string</code><code class="p">.</code><code class="n">Join</code><code class="p">(</code><code class="s">","</code><code class="p">,</code> <code class="n">x</code><code class="p">));</code>
<code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Output = "</code> <code class="p">+</code> <code class="n">composeMessage</code><code class="p">(</code><code class="n">numbers</code><code class="p">));</code>
<code class="c1">// Output = 130,200,210,280,470</code></pre>

<p>If you’re happy with that, the by all means use it.  There’s nothing wrong with it per se, aside from being rather inelegant.</p>

<p>There is another structure that we can use though - Transduce.  A Transduce operation acts on an array and represents all of the stages of a functional flow:</p>

<ul>
<li>
<p>Filter (i.e. <code>.Where</code>) - Reduce the number of elements</p>
</li>
<li>
<p>Transform (i.e. <code>.Select</code>) - Convert them to a new form</p>
</li>
<li>
<p>Aggregate (i.e. Erm..actually is <em>is</em> Aggregate) - whittle down the collection of many items to a single item using these rules</p>
</li>
</ul>

<p>There are many ways this could be implemented in C#, but here’s one possibility:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">static</code> <code class="n">TFinalOut</code> <code class="n">Transduce</code><code class="p">&lt;</code><code class="n">TIn</code><code class="p">,</code> <code class="n">TFilterOut</code><code class="p">,</code> <code class="n">TFinalOut</code><code class="p">&gt;(</code>
	<code class="k">this</code> <code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">TIn</code><code class="p">&gt;</code> <code class="n">@this</code><code class="p">,</code>
	<code class="n">Func</code><code class="p">&lt;</code><code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">TIn</code><code class="p">&gt;,</code> <code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">TFilterOut</code><code class="p">&gt;&gt;</code> <code class="n">transformer</code><code class="p">,</code>
	<code class="n">Func</code><code class="p">&lt;</code><code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">TFilterOut</code><code class="p">&gt;,</code> <code class="n">TFinalOut</code><code class="p">&gt;</code> <code class="n">aggregator</code><code class="p">)</code> <code class="p">=&gt;</code>
		<code class="n">aggregator</code><code class="p">(</code><code class="n">transformer</code><code class="p">(</code><code class="n">@this</code><code class="p">));</code></pre>

<p>This extension method takes a transformer method - which can be any combination of <code>Select</code> and <code>Where</code> the user defines to transform the Enumerable ultimately from one form and size, to another.  The method also takes an aggregator, which converts the output of the transformer into a single value.</p>

<p>This is how the compose function I defined above could be implemented with this version of the Transduce method:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="kt">var</code> <code class="n">numbers</code> <code class="p">=</code> <code class="k">new</code> <code class="p">[]</code> <code class="p">{</code> <code class="m">4</code><code class="p">,</code> <code class="m">8</code><code class="p">,</code> <code class="m">15</code><code class="p">,</code> <code class="m">16</code><code class="p">,</code> <code class="m">23</code><code class="p">,</code> <code class="m">42</code> <code class="p">};</code>

<code class="c1">// N.B - I could make this a single line with brackets, but</code>
<code class="c1">// I find this more readable, and it's functionally identical due</code>
<code class="c1">// to lazy evaluation of Enumerables</code>
<code class="kt">var</code> <code class="n">transformer</code> <code class="p">=</code> <code class="p">(</code><code class="n">IEnumerable</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">x</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">x</code>
	<code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">y</code> <code class="p">=&gt;</code> <code class="n">y</code> <code class="p">+</code> <code class="m">5</code><code class="p">)</code>
	<code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">y</code> <code class="p">=&gt;</code> <code class="n">y</code> <code class="p">*</code> <code class="m">10</code><code class="p">)</code>
	<code class="p">.</code><code class="n">Where</code><code class="p">(</code><code class="n">y</code> <code class="p">=&gt;</code> <code class="n">y</code> <code class="p">&gt;</code> <code class="m">100</code><code class="p">);</code>

<code class="kt">var</code> <code class="n">aggregator</code> <code class="p">=</code> <code class="p">(</code><code class="n">IEnumerable</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">x</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="kt">string</code><code class="p">.</code><code class="n">Join</code><code class="p">(</code><code class="s">", "</code><code class="p">,</code> <code class="n">x</code><code class="p">);</code>

<code class="kt">var</code> <code class="n">output</code> <code class="p">=</code> <code class="n">numbers</code><code class="p">.</code><code class="n">Transduce</code><code class="p">(</code><code class="n">transformer</code><code class="p">,</code> <code class="n">aggregator</code><code class="p">);</code>
<code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Output = "</code> <code class="p">+</code> <code class="n">output</code><code class="p">);</code>
<code class="c1">// Output = 130, 200, 210, 280, 470</code></pre>

<p>Alternatively, if you’d prefer to handle everything as <code>Func</code> delegates, so that you can reuse the Transducer function, it could be written in this way:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="kt">var</code> <code class="n">numbers</code> <code class="p">=</code> <code class="k">new</code> <code class="p">[]</code> <code class="p">{</code> <code class="m">4</code><code class="p">,</code> <code class="m">8</code><code class="p">,</code> <code class="m">15</code><code class="p">,</code> <code class="m">16</code><code class="p">,</code> <code class="m">23</code><code class="p">,</code> <code class="m">42</code> <code class="p">};</code>
<code class="kt">var</code> <code class="n">transformer</code> <code class="p">=</code> <code class="p">(</code><code class="n">IEnumerable</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">x</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">x</code>
	<code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">y</code> <code class="p">=&gt;</code> <code class="n">y</code> <code class="p">+</code> <code class="m">5</code><code class="p">)</code>
	<code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">y</code> <code class="p">=&gt;</code> <code class="n">y</code> <code class="p">*</code> <code class="m">10</code><code class="p">)</code>
	<code class="p">.</code><code class="n">Where</code><code class="p">(</code><code class="n">y</code> <code class="p">=&gt;</code> <code class="n">y</code> <code class="p">&gt;</code> <code class="m">100</code><code class="p">);</code>

<code class="kt">var</code> <code class="n">aggregator</code> <code class="p">=</code> <code class="p">(</code><code class="n">IEnumerable</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">x</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="kt">string</code><code class="p">.</code><code class="n">Join</code><code class="p">(</code><code class="s">", "</code><code class="p">,</code> <code class="n">x</code><code class="p">);</code>

<code class="kt">var</code> <code class="n">transducer</code> <code class="p">=</code> <code class="n">transformer</code><code class="p">.</code><code class="n">ToTransducer</code><code class="p">(</code><code class="n">aggregator</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">output2</code> <code class="p">=</code> <code class="n">transducer</code><code class="p">(</code><code class="n">numbers</code><code class="p">);</code>
<code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Output = "</code> <code class="p">+</code> <code class="n">output2</code><code class="p">);</code></pre>

<p>This is the updated extension method:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">static</code> <code class="k">class</code> <code class="nc">TransducerExtensionMethod</code>
<code class="p">{</code>
	<code class="k">public</code> <code class="k">static</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">TIn</code><code class="p">&gt;,</code> <code class="n">NewTOut</code><code class="p">&gt;</code> <code class="n">ToTransducer</code><code class="p">&lt;</code><code class="n">TIn</code><code class="p">,</code> <code class="n">OldTOut</code><code class="p">,</code> <code class="n">NewTOut</code><code class="p">&gt;(</code>
		<code class="k">this</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">TIn</code><code class="p">&gt;,</code>
		<code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">OldTOut</code><code class="p">&gt;&gt;</code> <code class="n">@this</code><code class="p">,</code>
		<code class="n">Func</code><code class="p">&lt;</code><code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">OldTOut</code><code class="p">&gt;,</code> <code class="n">NewTOut</code><code class="p">&gt;</code> <code class="n">aggregator</code><code class="p">)</code> <code class="p">=&gt;</code>
			<code class="n">x</code> <code class="p">=&gt;</code> <code class="n">aggregator</code><code class="p">(</code><code class="n">@this</code><code class="p">(</code><code class="n">x</code><code class="p">));</code>
<code class="p">}</code></pre>

<p>We’ve now generated a <code>Func</code> delegate variable that can be used as a function on as many arrays of integers as we want, and that single <code>Func</code> will perfom any number of transformations and filters required, then aggregate the array down to a single, final value.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Tap"><div class="sect1" id="idm45400864777248">
<h1>Tap</h1>

<p>A common concern I hear raised about chains of functions is that it’s impossible to perform logging within them - excepting that you make one of the links in the chain a reference to a separate function that does have logging calls within it.</p>

<p>There is a technique in functional programming that can be used to inspect the contents of a function chain at any point - a Tap function.</p>

<p>A Tap function is a bit like a wire tap<sup><a data-type="noteref" id="idm45400864138112-marker" href="ch05.html#idm45400864138112">4</a></sup> in old detective films.  Something that allows a stream of information to be monitored and acted on, but without disrupting or altering it.</p>

<p>The way to implement a Tap is like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">static</code> <code class="k">class</code> <code class="nc">Extensions</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="k">static</code> <code class="n">T</code> <code class="n">Tap</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;(</code><code class="k">this</code> <code class="n">T</code> <code class="n">@this</code><code class="p">,</code> <code class="n">Action</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="n">action</code><code class="p">)</code>
 <code class="p">{</code>
  <code class="n">action</code><code class="p">(</code><code class="n">@this</code><code class="p">);</code>
  <code class="k">return</code> <code class="n">@this</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>An <code>Action</code> delegate is effectively like a void returning function.  In this instance it accepts a single parameter - a generic type, T.  The Tap function passes the current value of the object in the chain into the Action, where logging can take place, then returns an unmodified copy of that same object.</p>

<p>You could use it like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="kt">var</code> <code class="n">input</code> <code class="p">=</code> <code class="m">100</code><code class="n">M</code><code class="p">;</code>
<code class="kt">var</code> <code class="n">fahrenheitToCelcius</code> <code class="p">=</code> <code class="p">(</code><code class="kt">decimal</code> <code class="n">x</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">x</code><code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">-</code> <code class="m">32</code><code class="p">)</code>
  <code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">*</code> <code class="m">5</code><code class="p">)</code>
  <code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">/</code> <code class="m">9</code><code class="p">)</code>
  <code class="p">.</code><code class="n">Tap</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="k">this</code><code class="p">.</code><code class="n">logger</code><code class="p">.</code><code class="n">LogInformation</code><code class="p">(</code><code class="s">"the un-rounded value is "</code> <code class="p">+</code> <code class="n">x</code><code class="p">))</code>
  <code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">Math</code><code class="p">.</code><code class="n">Round</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="m">2</code><code class="p">))</code>
  <code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="err">$</code><code class="s">"{x} degrees"</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">output</code> <code class="p">=</code> <code class="n">fahrenheitToCelcius</code><code class="p">(</code><code class="n">input</code><code class="p">);</code>
<code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">output</code><code class="p">);</code>
<code class="c1">// 37.78 degrees</code></pre>

<p>In this new version of the Fahrenheit to Celcius functional chain, I’m now Tapping into it after the basic calculation is completed, but before I start rounding and formatting to string.</p>

<p>I added a call to a logger in the Tap, but you could switch that for a <code>Console.WriteLine</code> or whatever else you’d like.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Try/Catch"><div class="sect1" id="idm45400864140144">
<h1>Try/Catch</h1>

<p>There are several more advanced structures in functional programming for handling errors.  If you just want something quick and easy you can quickly implement in a few lines of code, but which has its limitations, keep reading.  Otherwise, try having a look ahead at the next chapter on Discriminated Unions, and the chapter after on advanced functional structures.  There’s plenty to be found there on handling errors without side effects.</p>

<p>For now though, let’s see what we can do with a few simple lines of code…​</p>

<p>In theory, in the middle of functional-style code, there shouldn’t be any errors possible.  If everything is done in line with the functional principles of side-effect free code, immutable variables, etc. then you should be safe.  On the fringes though, there are always interactions that might be considered unsafe.</p>

<p>Let’s imagine you have a scenario in which you want to run a lookup in an external system with an integer Id.  This external system could be a database, a web api, a flat file on a network share, anything at all.  The thing all of these possibilities have in common though, is that any of them can fail for many reasons, few, if any, of which are the fault of the devleoper.</p>

<p>There could be network issues, hardware issues on the local or remote computers, inadvertent human intervention.  The list goes on…​</p>

<p>This is how you’d usually deal with that situation in Object Oriented code:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="n">pubic</code> <code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">Snack</code><code class="p">&gt;</code> <code class="n">GetSnackByType</code><code class="p">(</code><code class="kt">int</code> <code class="n">typeId</code><code class="p">)</code>
<code class="p">{</code>
 <code class="k">try</code>
 <code class="p">{</code>
  <code class="kt">var</code> <code class="n">returnValue</code> <code class="p">=</code> <code class="k">this</code><code class="p">.</code><code class="n">DataStore</code><code class="p">.</code><code class="n">GetSnackByType</code><code class="p">(</code><code class="n">typeId</code><code class="p">);</code>
  <code class="k">return</code> <code class="n">returnValue</code><code class="p">;</code>
 <code class="p">}</code>
 <code class="k">catch</code><code class="p">(</code><code class="n">Exception</code> <code class="n">e</code><code class="p">)</code>
 <code class="p">{</code>
  <code class="k">this</code><code class="p">.</code><code class="n">logger</code><code class="p">.</code><code class="n">LogError</code><code class="p">(</code><code class="n">e</code><code class="p">,</code> <code class="err">$</code><code class="s">"There aren't any pork scratchings left!"</code><code class="p">);</code>
  <code class="k">return</code> <code class="n">Enumerable</code><code class="p">.</code><code class="n">Empty</code><code class="p">&lt;</code><code class="n">Snack</code><code class="p">&gt;()</code>
 <code class="p">}</code>
<code class="p">}</code></pre>

<p>There are two things I dislike about this code block.  The first is how much boilerplate we have to bulk out the code with.  There’s a lot of industrial-strength coding we have to add to protect ourselves from problems that we didn’t cause.</p>

<p>The other issue is with try/catch blocks themselves.  It breaks the order of operations, moving execution of the program from where we were to some potentially hard-to-find location.  In this case, it’s a nice, simple, compact little function and the location of the Catch is easy to determine.  I’ve worked in codebases though where the Catch was several layers of functions higher than the place the fault occurred.  Bugs were common in that codebase because assumptions were made about certains lines of code being reached when they weren’t due to the strange positioning of the Try/Catch block.</p>

<p>I probably wouldn’t honestly have too many issues with the code block above in production, but left unchecked, bad coding practices can leak in.  There’s nothing in the code that’s preventing future coders from introducing multi-level nested functions in here.</p>

<p>I think the best solution is to use an approach that removes all of the boilerplate, and makes it hard, or even impossible, to introduce bad code structure later.</p>

<p>Something like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="n">pubic</code> <code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">Snack</code><code class="p">&gt;</code> <code class="n">GetSnackByType</code><code class="p">(</code><code class="kt">int</code> <code class="n">typeId</code><code class="p">)</code>
<code class="p">{</code>
 <code class="kt">var</code> <code class="n">result</code> <code class="p">=</code> <code class="n">typeId</code><code class="p">.</code><code class="n">MapWithTryCatch</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="n">DataStore</code><code class="p">.</code><code class="n">GetSnackByType</code><code class="p">)</code>
   <code class="p">??</code> <code class="n">Enumerable</code><code class="p">.</code><code class="n">Empty</code><code class="p">&lt;</code><code class="n">Snack</code><code class="p">&gt;();</code>
 <code class="k">return</code> <code class="n">result</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>What I’m doing is running a Map function with an embedded Try/Catch.  The new Map function either returns a value if everything worked, or <code>null</code> if there was a failure.</p>

<p>The extension method looks like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">static</code> <code class="k">class</code> <code class="nc">Extensions</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="k">static</code> <code class="n">TOut</code> <code class="n">MapWithTryCatch</code><code class="p">&lt;</code><code class="n">TIn</code><code class="p">,</code><code class="n">TOut</code><code class="p">&gt;(</code><code class="k">this</code> <code class="n">TIn</code> <code class="n">@this</code><code class="p">,</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">TIn</code><code class="p">,</code><code class="n">TOut</code><code class="p">&gt;</code> <code class="n">f</code><code class="p">)</code>
 <code class="p">{</code>
  <code class="k">try</code>
  <code class="p">{</code>
   <code class="k">return</code> <code class="nf">f</code><code class="p">(</code><code class="n">@this</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="k">catch</code><code class="p">()</code>
  <code class="p">{</code>
   <code class="k">return</code> <code class="k">default</code><code class="p">;</code>
  <code class="p">}</code>
 <code class="p">}</code>
<code class="p">}</code></pre>

<p>This isn’t quite a perfect solution though.  What about error logging?  This is committing the cardinal sin of swallowing error messages unlogged.</p>

<p>There are a few ways you could think about solving this.  Any of these are equally fine, so proceed as your fancy takes you.</p>

<p>One option is to instead have an extension method that takes an ILogger instance to return a <code>Func</code> delegate containing the Try/Catch functionality.  Something like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">static</code> <code class="k">class</code> <code class="nc">TryCatchExtensionMethods</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="k">static</code> <code class="n">TOut</code> <code class="n">CreateTryCatch</code><code class="p">&lt;</code><code class="n">TIn</code><code class="p">,</code><code class="n">TOut</code><code class="p">&gt;(</code><code class="k">this</code> <code class="n">TIn</code> <code class="n">@this</code><code class="p">,</code> <code class="n">ILogger</code> <code class="n">logger</code><code class="p">)</code>
 <code class="p">{</code>
  <code class="n">Func</code><code class="p">&lt;</code><code class="n">TIn</code><code class="p">,</code><code class="n">TOut</code><code class="p">&gt;</code> <code class="n">f</code> <code class="p">=&gt;</code>
  <code class="p">{</code>
   <code class="k">try</code>
   <code class="p">{</code>
    <code class="k">return</code> <code class="nf">f</code><code class="p">(</code><code class="n">@this</code><code class="p">);</code>
   <code class="p">}</code>
   <code class="k">catch</code><code class="p">(</code><code class="n">Exception</code> <code class="n">e</code><code class="p">)</code>
   <code class="p">{</code>
    <code class="n">logger</code><code class="p">.</code><code class="n">LogError</code><code class="p">(</code><code class="n">e</code><code class="p">,</code> <code class="s">"An error occurred"</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">default</code><code class="p">;</code>
   <code class="p">}</code>
  <code class="p">}</code>
 <code class="p">}</code>
<code class="p">}</code></pre>

<p>The usage would be pretty similar:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">Snack</code><code class="p">&gt;</code> <code class="n">GetSnackByType</code><code class="p">(</code><code class="kt">int</code> <code class="n">typeId</code><code class="p">)</code>
<code class="p">{</code>
 <code class="kt">var</code> <code class="n">tryCatch</code> <code class="p">=</code> <code class="n">typeId</code><code class="p">.</code><code class="n">CreateTryCatch</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="n">logger</code><code class="p">);</code>
 <code class="kt">var</code> <code class="n">result</code> <code class="p">=</code> <code class="n">tryCatch</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="n">DataStore</code><code class="p">.</code><code class="n">GetSnackByType</code><code class="p">)</code>
   <code class="p">??</code> <code class="n">Enumerable</code><code class="p">.</code><code class="n">Empty</code><code class="p">&lt;</code><code class="n">Snack</code><code class="p">&gt;();</code>
 <code class="k">return</code> <code class="n">result</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>Only a single additional line of boilerplate added, and now logging is being done.  Sadly there isn’t anything specific we can add in the message besides the error itself.  The extension method doesn’t know where it’s called from, or the context of the error, which is perfect for re-using the method all over the codebase.</p>

<p>If you don’t want the try/catch being aware of the <code>ILogger</code> interface, or you want to provide a custom error message every time, then we need to look at something a little more complicated to handle error messaging.</p>

<p>One option is to return a meta-data object which contains the return value of the function that’s being executed, and a bit of data about whether things worked, whether there were errors and what they were.  Something like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">class</code> <code class="nc">ExecutionResult</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="n">T</code> <code class="n">Result</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="n">init</code><code class="p">;</code> <code class="p">}</code>
 <code class="k">public</code> <code class="n">Exception</code> <code class="n">Error</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="n">init</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">static</code> <code class="k">class</code> <code class="nc">Extensions</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="k">static</code> <code class="n">ExtensionResult</code><code class="p">&lt;</code><code class="n">TOut</code><code class="p">&gt;</code> <code class="n">MapWithTryCatch</code><code class="p">&lt;</code><code class="n">TIn</code><code class="p">,</code><code class="n">TOut</code><code class="p">&gt;(</code><code class="k">this</code> <code class="n">TIn</code> <code class="n">@this</code><code class="p">,</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">TIn</code><code class="p">,</code><code class="n">TOut</code><code class="p">&gt;</code> <code class="n">f</code><code class="p">)</code>
 <code class="p">{</code>
  <code class="k">try</code>
  <code class="p">{</code>
   <code class="kt">var</code> <code class="n">result</code> <code class="p">=</code> <code class="n">f</code><code class="p">(</code><code class="n">@this</code><code class="p">);</code>
   <code class="k">return</code> <code class="k">new</code> <code class="n">ExecutionResult</code><code class="p">&lt;</code><code class="n">TOut</code><code class="p">&gt;</code>
   <code class="p">{</code>
    <code class="n">Result</code> <code class="p">=</code> <code class="n">result</code>
   <code class="p">};</code>
  <code class="p">}</code>
  <code class="k">catch</code><code class="p">(</code><code class="n">Exception</code> <code class="n">e</code><code class="p">)</code>
  <code class="p">{</code>
   <code class="k">return</code> <code class="k">new</code> <code class="n">ExecutionResult</code><code class="p">&lt;</code><code class="n">TOut</code><code class="p">&gt;</code>
   <code class="p">{</code>
    <code class="n">Error</code> <code class="p">=</code> <code class="n">e</code>
   <code class="p">};</code>
  <code class="p">}</code>
 <code class="p">}</code>
<code class="p">}</code></pre>

<p>I don’t really like this approach. It’s breaking one of the SOLID principles of Object-Oriented design - the Interface Segregation Principle.  Well sort of.  Techically that applies to Interfaces, but I try to apply it everywhere.  Even if I do write functional code.  The idea is that we shouldn’t be forced to include something in a class or interface that we don’t actually need.  Here, we’re forcing a successful run to include an <code>Exception</code> property that it’ll never need, and likewise, a failure run will have to include the Result property it’ll never need.</p>

<p>There are other ways you could do this, but I’m making it simple, and either returning a version of the <code>ExecutionResult</code> class with the result, or else a <code>default</code> value of Result and the Exception returned.</p>

<p>This means I can call it like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="n">pubic</code> <code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">Snack</code><code class="p">&gt;</code> <code class="n">GetSnackByType</code><code class="p">(</code><code class="kt">int</code> <code class="n">typeId</code><code class="p">)</code>
<code class="p">{</code>
 <code class="kt">var</code> <code class="n">result</code> <code class="p">=</code> <code class="n">typeId</code><code class="p">.</code><code class="n">MapWithTryCatch</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="n">DataStore</code><code class="p">.</code><code class="n">GetSnackByType</code><code class="p">);</code>
 <code class="k">if</code><code class="p">(</code><code class="n">result</code><code class="p">.</code><code class="n">Value</code> <code class="p">==</code> <code class="k">null</code><code class="p">)</code>
 <code class="p">{</code>
  <code class="k">this</code><code class="p">.</code><code class="n">Logger</code><code class="p">.</code><code class="n">LogException</code><code class="p">(</code><code class="n">result</code><code class="p">.</code><code class="n">Error</code><code class="p">,</code> <code class="s">"We ran out of jammy dodgers!"</code><code class="p">);</code>
  <code class="k">return</code> <code class="n">Enumerable</code><code class="p">.</code><code class="n">Empty</code><code class="p">&lt;</code><code class="n">Snack</code><code class="p">&gt;();</code>
 <code class="p">}</code>

 <code class="k">return</code> <code class="n">result</code><code class="p">.</code><code class="n">Result</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>The unnecessary fields aside, there’s another issue with this approach - the onus is now on the developer using the Try/Catch function to add additional boilerplate to check for errors.</p>

<p>Skip ahead to the next chapter for an alternative way of handling this sort of return value in a more purely functional manner.  For now though, here’s a slightly cleaner way of handling it.</p>

<p>First, I’ll add in another extension method.  One that attaches to the ExecutionResult object this time:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">static</code> <code class="n">T</code> <code class="n">OnError</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;(</code><code class="k">this</code> <code class="n">ExecutionResult</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="n">@this</code><code class="p">,</code> <code class="n">Action</code><code class="p">&lt;</code><code class="n">Exception</code><code class="p">&gt;</code> <code class="n">errorHandler</code><code class="p">)</code>
 <code class="p">{</code>
<code class="k">if</code> <code class="p">(</code><code class="n">@this</code><code class="p">.</code><code class="n">Error</code> <code class="p">!=</code> <code class="k">null</code><code class="p">)</code>
<code class="n">errorHandler</code><code class="p">(</code><code class="n">@this</code><code class="p">.</code><code class="n">Error</code><code class="p">);</code>
<code class="k">return</code> <code class="n">@this</code><code class="p">.</code><code class="n">Result</code><code class="p">;</code>
 <code class="p">}</code></pre>

<p>What I’m doing here is first checking whether there’s an error.  If there is, then execute the user-defined <code>Action</code> - which will presumably be a logging operation.  It finishes by unwrapping the ExecutionResult into just its actual returned data object.</p>

<p>All of that means you can now handle the Try/Catch like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">Snack</code><code class="p">&gt;</code> <code class="n">GetSnackByTypeId</code><code class="p">(</code><code class="kt">int</code> <code class="n">typeId</code><code class="p">)</code> <code class="p">=&gt;</code>
	<code class="n">typeId</code><code class="p">.</code><code class="n">MapWithTryCatch</code><code class="p">(</code><code class="n">DataStore</code><code class="p">.</code><code class="n">GetSnackByType</code><code class="p">)</code>
		<code class="p">.</code><code class="n">OnError</code><code class="p">(</code><code class="n">e</code> <code class="p">=&gt;</code> <code class="k">this</code><code class="p">.</code><code class="n">Logger</code><code class="p">.</code><code class="n">LogError</code><code class="p">(</code><code class="n">e</code><code class="p">,</code> <code class="s">"We ran out of custard creams!"</code><code class="p">));</code></pre>

<p>It’s far from a perfect solution, but without moving on another level in functional theory, it’s workable and elegant enough that it’s not setting off my internal perfectionist.  It also forces the user to consider error handling when using this, which can only be a good thing!</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Handling Nulls"><div class="sect1" id="idm45400863156016">
<h1>Handling Nulls</h1>

<p>Aren’t null reference exceptions annoying?  If you want someone to blame, it’s a guy called Tony Hoare who invented the concept of Null back in the 60s.  Actually, let’s not blame anyone.  I’m sure he’s a lovely person, beloved by everyone that knows him.  In any case, we can hopefully all agree that null reference exceptions are an absolute pain in the preverbial.</p>

<p>So, is there a functional way to deal with them?  If you’ve read this far, you probably know that the answer will be a resounding “yes!”<sup><a data-type="noteref" id="idm45400863100640-marker" href="ch05.html#idm45400863100640">5</a></sup>.</p>

<p>The <em>Unless</em> function takes in a boolean condition and an <code>Action</code> delegate, and only executes the <code>Action</code> if the boolean is false - i.e. the <code>Action</code> is always executed <em>unless</em> the condition is true.</p>

<p>The most common usage for something like this is - you guessed it - checking for null.</p>

<p>Here’s an example of exactly the sort of code I’m trying to replace.  This is a rarely-seen bit of source code for a Dalek<sup><a data-type="noteref" id="idm45400863096432-marker" href="ch05.html#idm45400863096432">6</a></sup>:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">void</code> <code class="nf">BusinessAsUsual</code><code class="p">()</code>
<code class="p">{</code>
 <code class="kt">var</code> <code class="n">enemies</code> <code class="p">=</code> <code class="k">this</code><code class="p">.</code><code class="n">scanner</code><code class="p">.</code><code class="n">FindLifeforms</code><code class="p">(</code><code class="err">'</code><code class="n">all</code><code class="err">'</code><code class="p">);</code>
 <code class="k">foreach</code><code class="p">(</code><code class="kt">var</code> <code class="n">e</code> <code class="k">in</code> <code class="n">enemies</code><code class="p">)</code>
 <code class="p">{</code>
  <code class="k">this</code><code class="p">.</code><code class="n">Gun</code><code class="p">.</code><code class="n">Blast</code><code class="p">(</code><code class="n">e</code><code class="p">.</code><code class="n">Coordinates</code><code class="p">.</code><code class="n">Longitude</code><code class="p">,</code> <code class="n">e</code><code class="p">.</code><code class="n">Coordinates</code><code class="p">.</code><code class="n">Latitude</code><code class="p">);</code>
  <code class="k">this</code><code class="p">.</code><code class="n">Speech</code><code class="p">.</code><code class="n">ScreamAt</code><code class="p">(</code><code class="n">e</code><code class="p">,</code> <code class="s">"EXTERMINATE"</code><code class="p">);</code>
 <code class="p">}</code>
<code class="p">}</code></pre>

<p>This is all well and good, and probably leaves a lot of people killed by a psychotic mutant in a mobile pepper-pot shaped tank.  But, what if the Coordinates object was null for some reason?  That’s right - null reference exception.</p>

<p>This is where we make this functional, and introduce an Unless function to prevent the exception from occuring.  This is what unless looks like:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">static</code> <code class="k">class</code> <code class="nc">UnlessExtensionMethods</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="k">void</code> <code class="n">Unless</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;(</code><code class="k">this</code> <code class="n">T</code> <code class="n">@this</code><code class="p">,</code> <code class="n">Func</code><code class="p">&lt;</code><code class="kt">bool</code><code class="p">&gt;</code> <code class="n">condition</code><code class="p">,</code> <code class="n">Action</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="n">f</code><code class="p">)</code>
 <code class="p">{</code>
  <code class="k">if</code><code class="p">(!</code><code class="n">condition</code><code class="p">(</code><code class="n">@this</code><code class="p">)</code>
  <code class="p">{</code>
   <code class="n">f</code><code class="p">(</code><code class="n">@this</code><code class="p">);</code>
  <code class="p">}</code>
 <code class="p">}</code>
<code class="p">}</code></pre>

<p>It has to be a void, unfortunately.  If we swapped the <code>Action</code> for a <code>Func</code>, then it’s fine to return the result of the <code>Func</code> from the extension method.  What about when condition is true though, and we don’t execute?  What do I return then?  There isn’t really an answer to that question.</p>

<p>This is how I’d use it to make my new, super-duper, even more deadly functional Dalek:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">void</code> <code class="nf">BusinessAsUsual</code><code class="p">()</code>
<code class="p">{</code>
 <code class="kt">var</code> <code class="n">enemies</code> <code class="p">=</code> <code class="k">this</code><code class="p">.</code><code class="n">scanner</code><code class="p">.</code><code class="n">FindLifeforms</code><code class="p">(</code><code class="err">'</code><code class="n">all</code><code class="err">'</code><code class="p">);</code>

 <code class="k">foreach</code><code class="p">(</code><code class="kt">var</code> <code class="n">e</code> <code class="k">in</code> <code class="n">enemies</code><code class="p">)</code>
 <code class="p">{</code>
  <code class="n">e</code><code class="p">.</code><code class="n">unless</code><code class="p">(</code>
   <code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code><code class="p">.</code><code class="n">Coordinates</code> <code class="p">==</code> <code class="k">null</code><code class="p">,</code>
   <code class="n">x</code> <code class="p">=&gt;</code> <code class="k">this</code><code class="p">.</code><code class="n">Gun</code><code class="p">.</code><code class="n">Blast</code><code class="p">(</code><code class="n">e</code><code class="p">.</code><code class="n">Coordinates</code><code class="p">.</code><code class="n">Longitude</code><code class="p">,</code> <code class="n">e</code><code class="p">.</code><code class="n">Coordinates</code><code class="p">.</code><code class="n">Latitude</code><code class="p">)</code>
  <code class="p">)</code>

 <code class="c1">// May as well do this anyway, since we're here.</code>
  <code class="k">this</code><code class="p">.</code><code class="n">Speech</code><code class="p">.</code><code class="n">ScreamAt</code><code class="p">(</code><code class="n">e</code><code class="p">,</code> <code class="s">"EXTERMINATE"</code><code class="p">);</code>
 <code class="p">}</code>
<code class="p">}</code></pre>

<p>Using this, a null Coordinates object won’t result in an exception, the gun simply won’t be fired.</p>

<p>There are more ways to prevent null exceptions coming over the next few chapters - ways that require more advanced coding and a little theory, but which are much more thorough in the way they work.  Stay tuned.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Update an Enumerable"><div class="sect1" id="idm45400863101648">
<h1>Update an Enumerable</h1>

<p>I’m going to finish off this section with a useful.  It involves updating an element in an Enumerable without changing any data at all!</p>

<p>The thing to remember about enumerables is that they are designed to make use of “lazy evaluation” - i.e. they don’t actually convert from a set of functions pointing at a data source to actual data until the last possible moment.  Quite often, the use of <code>Select</code> functions doesn’t trigger an evaluation, so we can use them to effectively create filters sitting between the data source and the place in the code in which enumeration of the data will actually take place.</p>

<p>Here’s an example of altering an Enumerable, so that the item at position x is replaced:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="kt">var</code> <code class="n">sourceData</code> <code class="p">=</code> <code class="k">new</code> <code class="p">[]</code>
<code class="p">{</code>
 <code class="s">"Hello"</code><code class="p">,</code> <code class="s">"Doctor"</code><code class="p">,</code> <code class="s">"Yesterday"</code><code class="p">,</code> <code class="s">"Today"</code><code class="p">,</code> <code class="s">"Tomorrow"</code><code class="p">,</code> <code class="s">"Continue"</code>
<code class="p">}</code>

<code class="kt">var</code> <code class="n">updatedData</code> <code class="p">=</code> <code class="n">sourceData</code><code class="p">.</code><code class="n">ReplaceAt</code><code class="p">(</code><code class="m">1</code><code class="p">,</code> <code class="s">"Darkness, my old friend"</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">finalString</code> <code class="p">=</code> <code class="kt">string</code><code class="p">.</code><code class="n">Join</code><code class="p">(</code><code class="s">" "</code><code class="p">,</code> <code class="n">updatedData</code><code class="p">);</code>
<code class="c1">// Hello Darkness, my old friend Yesterday Today Tomorrow Continue</code></pre>

<p>What I’ve done is call a function to replace the element at position 1 (i.e. “Doctor”) with a new value.  Despite having two variables, nothing is actually done to the source data at all.  The variable SourceData remains the same after this code snippet has come to the end.  Further to that, no replacement  is actually made until calling <code>string.Join</code>, because that’s the very moment at which concrete values are required.</p>

<p>This is how it’s done:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">static</code> <code class="k">class</code> <code class="nc">Extensions</code>
<code class="p">{</code>
  <code class="k">public</code> <code class="k">static</code> <code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="n">ReplaceAt</code><code class="p">(</code><code class="k">this</code> <code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="n">@this</code><code class="p">,</code>
    <code class="kt">int</code> <code class="n">loc</code><code class="p">,</code>
    <code class="n">T</code> <code class="n">replacement</code><code class="p">)</code> <code class="p">=&gt;</code>
    <code class="n">@this</code><code class="p">.</code><code class="n">Select</code><code class="p">((</code><code class="n">x</code><code class="p">,</code> <code class="n">i</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">i</code> <code class="p">==</code> <code class="n">loc</code> <code class="p">?</code> <code class="n">replacement</code> <code class="p">:</code> <code class="n">x</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>This Enumerable, returned here, actually points at the original Enumerable and gets its values from there, but with one crucial difference.  If the index of the element ever equals the user-defined value (1, the second element, in our example).  All other values are passed through, unaltered.</p>

<p>If you were so inclined, you could provide a function to perform the update - giving the user the ability to base the new version of the data item on the old that is being replaced.</p>

<p>This is how you’d achieve that:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">static</code> <code class="k">class</code> <code class="nc">Extensions</code>
<code class="p">{</code>
  <code class="k">public</code> <code class="k">static</code> <code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="n">ReplaceAt</code><code class="p">(</code><code class="k">this</code> <code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="n">@this</code><code class="p">,</code>
    <code class="kt">int</code> <code class="n">loc</code><code class="p">,</code>
    <code class="n">Func</code><code class="p">&lt;</code><code class="n">T</code><code class="p">,</code> <code class="n">T</code><code class="p">&gt;</code> <code class="n">replacement</code><code class="p">)</code> <code class="p">=&gt;</code>
    <code class="n">@this</code><code class="p">.</code><code class="n">Select</code><code class="p">((</code><code class="n">x</code><code class="p">,</code> <code class="n">i</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">i</code> <code class="p">==</code> <code class="n">loc</code> <code class="p">?</code> <code class="n">replacement</code><code class="p">(</code><code class="n">x</code><code class="p">)</code> <code class="p">:</code> <code class="n">x</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>Easy enough to use too:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="kt">var</code> <code class="n">sourceData</code> <code class="p">=</code> <code class="k">new</code> <code class="p">[]</code>
<code class="p">{</code>
 <code class="s">"Hello"</code><code class="p">,</code> <code class="s">"Doctor"</code><code class="p">,</code> <code class="s">"Yesterday"</code><code class="p">,</code> <code class="s">"Today"</code><code class="p">,</code> <code class="s">"Tomorrow"</code><code class="p">,</code> <code class="s">"Continue"</code>
<code class="p">}</code>

<code class="kt">var</code> <code class="n">updatedData</code> <code class="p">=</code> <code class="n">sourceData</code><code class="p">.</code><code class="n">ReplaceAt</code><code class="p">(</code><code class="m">1</code><code class="p">,</code> <code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">+</code> <code class="s">" Who"</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">finalString</code> <code class="p">=</code> <code class="kt">string</code><code class="p">.</code><code class="n">Join</code><code class="p">(</code><code class="s">" "</code><code class="p">,</code> <code class="n">updatedData</code><code class="p">);</code>
<code class="c1">// Hello Doctor Who Yesterday Today Tomorrow Continue</code></pre>

<p>It’s also possible that we don’t know the Id of the element we want to update - in fact there could be multiple items to update.  This is an alternative Enumerable update function based on providing a T to Bool converting <code>Func</code> to identify the records that should be updated.</p>

<p>This example is based on board games - one of my favorite hobbies - much to the annoyance of my ever-patient wife!  In this scenario there is a Tag property on the BoardGame object, which contains meta data tags describing the game (“family”, “co-op”, “complex”, stuff like that) which will be used by a search engine app.  It’s been decided that another tag should be added to games suitable for 1 player - “solo”.</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="kt">var</code> <code class="n">sourceData</code> <code class="p">=</code> <code class="k">this</code><code class="p">.</code><code class="n">DataStore</code><code class="p">.</code><code class="n">GetBoardGames</code><code class="p">();</code>

<code class="kt">var</code> <code class="n">updatedData</code> <code class="p">=</code> <code class="n">sourceData</code><code class="p">.</code><code class="n">ReplaceWhen</code><code class="p">(</code>
		<code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code><code class="p">.</code><code class="n">NumberOfPlayersAllowed</code><code class="p">.</code><code class="n">Contains</code><code class="p">(</code><code class="m">1</code><code class="p">),</code>
		<code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="n">with</code> <code class="p">{</code> <code class="n">Tags</code> <code class="p">=</code> <code class="n">x</code><code class="p">.</code><code class="n">Tags</code><code class="p">.</code><code class="n">Append</code><code class="p">(</code><code class="s">"solo"</code><code class="p">)</code> <code class="p">});</code>
<code class="k">this</code><code class="p">.</code><code class="n">DataStore</code><code class="p">.</code><code class="n">Save</code><code class="p">(</code><code class="n">updatedData</code><code class="p">);</code></pre>

<p>The implementation is a variation on code we’ve already covered:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">static</code> <code class="k">class</code> <code class="nc">ReplaceWhenExtensions</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="k">static</code> <code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="n">ReplaceWhen</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;(</code><code class="k">this</code> <code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="n">@this</code><code class="p">,</code>
  <code class="n">Func</code><code class="p">&lt;</code><code class="n">T</code><code class="p">,</code> <code class="kt">bool</code><code class="p">&gt;</code> <code class="n">shouldReplace</code><code class="p">,</code>
  <code class="n">Func</code><code class="p">&lt;</code><code class="n">T</code><code class="p">,</code> <code class="n">T</code><code class="p">&gt;</code> <code class="n">replacement</code><code class="p">)</code> <code class="p">=&gt;</code>
  <code class="n">@this</code><code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">shouldReplace</code><code class="p">(</code><code class="n">x</code><code class="p">)</code> <code class="p">?</code> <code class="n">replacement</code><code class="p">(</code><code class="n">x</code><code class="p">)</code> <code class="p">:</code> <code class="n">x</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>This function can be used to replace the need for many instances of If-statements, and reduce them down to simpler, more predictable operations.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="idm45400862840400">
<h1>Conclusion</h1>

<p>In this chapter we looked at various ways to use the concept of higher-order functions to develop ways to provide rich functionality to our codebase, avoiding the need for Object-Oriented style statements.</p>

<p>Do get in touch if you have any ideas of your own for higher-order function uses. You never know, it might end up in a future edition of this book!</p>

<p>In the next chapter, we’ll be looking at Discriminated Unions, and how this functional concept can help to better model concepts in your codebase, and remove the need for a lot of defensive code typically needed with non-functional projects.  Enjoy!</p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45400867135648"><sup><a href="ch05.html#idm45400867135648-marker">1</a></sup> Ideally the hotest, spiciest flavor you can find. Flames should be shooting from your mouth as you eat!</p><p data-type="footnote" id="idm45400866574816"><sup><a href="ch05.html#idm45400866574816-marker">2</a></sup> Read more about it here: <a href="https://en.wikipedia.org/wiki/SOLID" class="bare"><em class="hyperlink">https://en.wikipedia.org/wiki/SOLID</em></a> - or if you prefer video then here’s one presented by yours truly: <a href="https://www.youtube.com/watch?v=0vJb_B47J6U" class="bare"><em class="hyperlink">https://www.youtube.com/watch?v=0vJb_B47J6U</em></a></p><p data-type="footnote" id="idm45400865400736"><sup><a href="ch05.html#idm45400865400736-marker">3</a></sup> See it for yourself here: <a href="https://ramdajs.com/" class="bare"><em class="hyperlink">https://ramdajs.com/</em></a></p><p data-type="footnote" id="idm45400864138112"><sup><a href="ch05.html#idm45400864138112-marker">4</a></sup> I’d guess that’s where they get their name</p><p data-type="footnote" id="idm45400863100640"><sup><a href="ch05.html#idm45400863100640-marker">5</a></sup> Also, congratulations for making it this far.  Although it probably didn’t take you anywhere so much time as it did me!!</p><p data-type="footnote" id="idm45400863096432"><sup><a href="ch05.html#idm45400863096432-marker">6</a></sup> For the non-initiated, these are the main baddies in the British SF TV series Doctor Who.  See them in action here: <a href="https://www.youtube.com/watch?v=d77jOE2Cjx8" class="bare"><em class="hyperlink">https://www.youtube.com/watch?v=d77jOE2Cjx8</em></a></p></div></div></section></div>
</div>
</body>
</html>