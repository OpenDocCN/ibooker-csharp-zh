["```cs\npublic static int GetIndexOfFirstNonEmptyBin(int[] bins) =>\n    Array.FindIndex(bins, IsGreaterThanZero);\n\nprivate static bool IsGreaterThanZero(int value) => value > 0;\n```", "```cs\npublic static int FindIndex<T>(\n      T[] array,\n      `Predicate``<``T``>` `match`)\n```", "```cs\npublic delegate bool Predicate<in T>(T obj);\n```", "```cs\nvar p = IsGreaterThanZero;\n```", "```cs\nvar p = new Predicate<int>(IsGreaterThanZero);\n```", "```cs\nPredicate<int> p = IsGreaterThanZero;\n```", "```cs\ninternal class Program\n{\n    static void Main(string[] args)\n    {\n        `Predicate``<``int``>` `p1` `=` `Tests``.``IsGreaterThanZero``;`\n        `Predicate``<``int``>` `p2` `=` `Tests``.``IsLessThanZero``;`\n    }\n}\n\ninternal class Tests\n{\n    public static bool IsGreaterThanZero(int value) => value > 0;\n\n    public static bool IsLessThanZero(int value) => value < 0;\n}\n```", "```cs\npublic class ThresholdComparer\n{\n    public int Threshold { get; set; }\n\n    public bool IsGreaterThan(int value) => value > Threshold;\n\n    public Predicate<int> GetIsGreaterThanPredicate() => IsGreaterThan;\n}\n```", "```cs\nvar zeroThreshold = new ThresholdComparer { Threshold = 0 };\nvar tenThreshold = new ThresholdComparer { Threshold = 10 };\nvar hundredThreshold = new ThresholdComparer { Threshold = 100 };\n\nPredicate<int> greaterThanZero = zeroThreshold.IsGreaterThan;\nPredicate<int> greaterThanTen = tenThreshold.IsGreaterThan;\nPredicate<int> greaterThanOneHundred = hundredThreshold.IsGreaterThan;\n```", "```cs\nMethodInfo m = typeof(ThresholdComparer).GetMethod(\"IsGreaterThan\")!;\nvar greaterThanZero = (Predicate<int>) m.CreateDelegate(\n    typeof(Predicate<int>), zeroThreshold);\n```", "```cs\nPredicate<int> megaPredicate1 =\n    greaterThanZero + greaterThanTen + greaterThanOneHundred;\n\nPredicate<int> megaPredicate2 = greaterThanZero;\nmegaPredicate2 += greaterThanTen;\nmegaPredicate2 += greaterThanOneHundred;\n```", "```cs\npublic static void CallMeRightBack(Predicate<int> userCallback)\n{\n    `bool` `result` `=` `userCallback``(``42``)``;`\n    Console.WriteLine(result);\n}\n```", "```cs\npublic delegate void Action();\npublic delegate void Action<in T1>(T1 arg1);\npublic delegate void Action<in T1, in T2 >(T1 arg1, T2 arg2);\npublic delegate void Action<in T1, in T2, in T3>(T1 arg1, T2 arg2, T3 arg3);\n```", "```cs\npublic delegate TResult Func<out TResult>();\npublic delegate TResult Func<in T1, out TResult>(T1 arg1);\npublic delegate TResult Func<in T1, in T2, out TResult>(T1 arg1, T2 arg2);\npublic delegate TResult Func<in T1, in T2, in T3, out TResult>(\n    T1 arg1, T2 arg2, T3 arg3);\n```", "```cs\npublic static bool IsLongString(object o)\n{\n    return o is string s && s.Length > 20;\n}\n\nstatic void Main(string[] args)\n{\n    Predicate<object> po = IsLongString;\n    `Predicate``<``string``>` `ps` `=` `po``;`\n    Console.WriteLine(ps(\"Too short\"));\n}\n```", "```cs\nPredicate<string> pred = IsLongString;\nFunc<string, bool> f = pred;  // Will fail with compiler error\n```", "```cs\npublic Predicate(object target, IntPtr method);\n\npublic bool Invoke(T obj);\n\npublic IAsyncResult BeginInvoke(T obj, AsyncCallback callback, object state);\npublic bool EndInvoke(IAsyncResult result);\n```", "```cs\npublic static void CallMeRightBack(Predicate<int> userCallback)\n{\n    bool result = userCallback.Invoke(42);\n    Console.WriteLine(result);\n}\n```", "```cs\npublic static void CallMeMaybe(Action<int>? userCallback)\n{\n    userCallback?.Invoke(42);\n}\n```", "```cs\npublic static int GetIndexOfFirstNonEmptyBin(int[] bins)\n{\n    return Array.FindIndex(\n        bins,\n        `delegate` `(``int` `value``)` `{` `return` `value` `>` `0``;` `}`\n    );\n}\n```", "```cs\npublic static int GetIndexOfFirstNonEmptyBin(int[] bins)\n{\n    return Array.FindIndex(\n        bins,\n        `value` `=``>` `value` `>` `0`\n    );\n}\n```", "```cs\nPredicate<int> p1 = value => value > 0;\nPredicate<int> p2 = (value) => value > 0;\nPredicate<int> p3 = (int value) => value > 0;\nPredicate<int> p4 = value => { return value > 0; };\nPredicate<int> p5 = (value) => { return value > 0; };\nPredicate<int> p6 = (int value) => { return value > 0; };\nPredicate<int> p7 = bool (value) => value > 0;\nPredicate<int> p8 = bool (int value) => value > 0;\nPredicate<int> p9 = bool (value) => { return value > 0; };\nPredicate<int> pA = bool (int value) => { return value > 0; };\n```", "```cs\nFunc<bool> isAfternoon = () => DateTime.Now.Hour >= 12;\n```", "```cs\nEventHandler clickHandler = delegate { Debug.WriteLine(\"Clicked!\"); };\n```", "```cs\nEventHandler clickHandler = (_, _) => Debug.WriteLine(\"Clicked!\");\n```", "```cs\npublic static Predicate<int> IsGreaterThan(int threshold)\n{\n    return value => value > threshold;\n}\n```", "```cs\npublic static Predicate<int> IsGreaterThan(int threshold) =>\n    value => value > threshold;\n```", "```cs\nPredicate<int> greaterThanTen = IsGreaterThan(10);\nbool result = greaterThanTen(200);\n```", "```cs\n[CompilerGenerated]\nprivate sealed class <>c__DisplayClass0_0\n{\n    public int threshold;\n\n    public bool <IsGreaterThan>b__0(int value)\n    {\n        return (value > this.threshold);\n    }\n}\n```", "```cs\nstatic void Calculate(int[] nums)\n{\n    int zeroEntryCount = 0;\n    int[] nonZeroNums = Array.FindAll(\n        nums,\n        v =>\n        {\n            if (v == 0)\n            {\n                zeroEntryCount += 1;\n                return false;\n            }\n            else\n            {\n                return true;\n            }\n        });\n    Console.WriteLine($\"Number of zero entries: {zeroEntryCount}\");\n    Console.WriteLine($\"First non-zero entry: {nonZeroNums[0]}\");\n}\n```", "```cs\nHttpClient http = GetHttpClient();\nusing (FileStream file = File.OpenWrite(@\"c:\\temp\\page.txt\"))\n{\n    http.GetStreamAsync(\"https://endjin.com/\")\n        .ContinueWith((Task<Stream> t) => t.Result.CopyToAsync(file));\n} // Will probably dispose FileStream before callback runs\n```", "```cs\npublic static Predicate<int> IsGreaterThan10() => static value => value > 10;\n```", "```cs\npublic static void Caught()\n{\n    var greaterThanN = new Predicate<int>[10];\n    for (int i = 0; i < greaterThanN.Length; ++i)\n    {\n        greaterThanN[i] = value => value > i; // Bad use of i\n    }\n\n    Console.WriteLine(greaterThanN[5](20));\n    Console.WriteLine(greaterThanN[5](6));\n}\n```", "```cs\nfor (int i = 0; i < greaterThanN.Length; ++i)\n{\n    `int` `current` `=` `i``;`\n    greaterThanN[i] = value => value > current;\n}\n```", "```cs\n`int` `offset` `=` `10``;`\nfor (int i = 0; i < greaterThanN.Length; ++i)\n{\n    int current = i;\n    `greaterThanN``[``i``]` `=` `value` `=``>` `value` `>` `(``current` `+` `offset``)``;`\n}\n```", "```cs\nExpression<Func<int, bool>> greaterThanZero = value => value > 0;\n```", "```cs\nParameterExpression valueParam = Expression.Parameter(typeof(int), \"value\");\nConstantExpression constantZero = Expression.Constant(0);\nBinaryExpression comparison = Expression.GreaterThan(valueParam, constantZero);\nExpression<Func<int, bool>> greaterThanZero =\n    Expression.Lambda<Func<int, bool>>(comparison, valueParam);\n```", "```cs\nvar expensiveProducts = dbContext.Products.Where(p => p.ListPrice > 3000);\n```", "```cs\nvar fakeComparer = new Mock<IEqualityComparer<string>>();\nfakeComparer\n    .Setup(c => c.Equals(\"Color\", \"Colour\"))\n    .Returns(true);\n```", "```cs\npublic class Eventful\n{\n    `public` `event` `Action``<``string``>``?` `Announcement``;`\n\n    public void Announce(string message)\n    {\n        Announcement?.Invoke(message);\n    }\n}\n```", "```cs\nvar source = new Eventful();\nsource.Announcement += m => Console.WriteLine(\"Announcement: \" + m);\n```", "```cs\nvar source = new Eventful();\nsource.Announcement(\"Will this work?\"); // No, this will not even compile\n```", "```cs\nprivate Action<string>? Announcement;\n\n// Not the actual code.\n// The real code is more complex, to tolerate concurrent calls.\npublic void add_Announcement(Action<string> handler)\n{\n    Announcement += handler;\n}\npublic void remove_Announcement(Action<string> handler)\n{\n    Announcement -= handler;\n}\n```", "```cs\npublic delegate void EventHandler(object sender, EventArgs e);\n```", "```cs\npublic class ScarceEventSource\n{\n    // One dictionary shared by all instances of this class,\n    // tracking all handlers for all events.\n    // Beware of memory leaks - this code is for illustration only.\n    private static readonly\n     Dictionary<(ScarceEventSource, object), EventHandler> _eventHandlers\n      = new();\n\n    // Objects used as keys to identify particular events in the dictionary.\n    private static readonly object EventOneId = new();\n    private static readonly object EventTwoId = new();\n\n    public event EventHandler EventOne\n    {\n        add\n        {\n            AddEvent(EventOneId, value);\n        }\n        remove\n        {\n            RemoveEvent(EventOneId, value);\n        }\n    }\n\n    public event EventHandler EventTwo\n    {\n        add\n        {\n            AddEvent(EventTwoId, value);\n        }\n        remove\n        {\n            RemoveEvent(EventTwoId, value);\n        }\n    }\n\n    public void RaiseBoth()\n    {\n        RaiseEvent(EventOneId, EventArgs.Empty);\n        RaiseEvent(EventTwoId, EventArgs.Empty);\n    }\n\n    private (ScarceEventSource, object) MakeKey(object eventId) => (this, eventId);\n\n    private void AddEvent(object eventId, EventHandler handler)\n    {\n        var key = MakeKey(eventId);\n        _eventHandlers.TryGetValue(key, out EventHandler? entry);\n        entry += handler;\n        _eventHandlers[key] = entry;\n    }\n\n    private void RemoveEvent(object eventId, EventHandler handler)\n    {\n        var key = MakeKey(eventId);\n        EventHandler? entry = _eventHandlers[key];\n        entry -= handler;\n        if (entry == null)\n        {\n            _eventHandlers.Remove(key);\n        }\n        else\n        {\n            _eventHandlers[key] = entry;\n        }\n    }\n\n    private void RaiseEvent(object eventId, EventArgs e)\n    {\n        var key = MakeKey(eventId);\n        if (_eventHandlers.TryGetValue(key, out EventHandler? handler))\n        {\n            handler(this, e);\n        }\n    }\n}\n```"]