["```cs\nnamespace Learning.Blazor.ComponentModels;\n\npublic record ContactComponentModel() ![1](assets/1.png)\n{\n [Required] ![2](assets/2.png)\n    public string? FirstName { get; set; } = null!;\n [Required]\n    public string? LastName { get; set; } = null!;\n [RegexEmailAddress(IsRequired = true)] ![3](assets/3.png)\n    public string? EmailAddress { get; set; } = null!;\n [Required]\n    public string? Subject { get; set; } = null!;\n [RequiredAcceptance] ![4](assets/4.png)\n    public bool AgreesToTerms { get; set; }\n [Required]\n    public string? Message { get; set; } = null!;\n\n    public AreYouHumanMath NotRobot { get; } =\n        AreYouHumanMath.CreateNew(MathOperator.Subtraction); ![5](assets/5.png)\n\n    public string RobotQuestion => NotRobot.GetQuestion();\n\n    public static implicit operator ContactRequest( ![6](assets/6.png)\n        ContactComponentModel model) =>\n        new(model.FirstName!,\n            model.LastName!,\n            model.EmailAddress!,\n            model.Subject!,\n            model.Message!);\n}\n```", "```cs\nusing System.Text.RegularExpressions;\n\nnamespace Learning.Blazor.DataAnnotations;\n [\n    AttributeUsage( ![1](assets/1.png) AttributeTargets.Property |\n        AttributeTargets.Field |\n        AttributeTargets.Parameter,\n        AllowMultiple = false)\n]\npublic sealed class RegexEmailAddressAttribute : DataTypeAttribute\n{\n    internal static readonly Regex EmailExpression = ![2](assets/2.png)\n        new(\"^([a-zA-Z0-9_\\\\-\\\\.]+)@\" +\n        \"((\\\\[[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.)\" +\n        \"|(([a-zA-Z0-9\\\\-]+\\\\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\\\\]?)$\",\n            RegexOptions.CultureInvariant | RegexOptions.Singleline);\n\n    /// <summary>\n    /// Gets or sets a value indicating if an email is required.\n    /// </summary>\n    /// <remarks>Defaults to <c>true</c>.</remarks>\n    public bool IsRequired { get; set; } = true; ![3](assets/3.png)\n\n    public RegexEmailAddressAttribute()\n        : base(DataType.EmailAddress) ![4](assets/4.png)\n    {\n    }\n\n    public override bool IsValid(object? value) ![5](assets/5.png)\n    {\n        if (value is null)\n        {\n            return !IsRequired;\n        }\n\n        return value is string valueAsString\n            && EmailExpression.IsMatch(valueAsString);\n    }\n}\n```", "```cs\nnamespace Learning.Blazor.DataAnnotations;\n [\n    AttributeUsage( ![1](assets/1.png) AttributeTargets.Property |\n        AttributeTargets.Field |\n        AttributeTargets.Parameter,\n        AllowMultiple = false)\n]\npublic sealed class RequiredAcceptanceAttribute : DataTypeAttribute\n{\n    public RequiredAcceptanceAttribute()\n        : base(DataType.Custom) ![2](assets/2.png)\n    {\n    }\n\n    public override bool IsValid(object? value) ![3](assets/3.png)\n    {\n        if (value is null)\n        {\n            return false;\n        }\n\n        return bool.TryParse(value.ToString(), out var isAccepted)\n            && isAccepted;\n    }\n}\n```", "```cs\n@page \"/contact\" ![1](assets/1.png) @attribute [AllowAnonymous]\n@inherits LocalizableComponentBase<Contact>\n\n<PageTitle>@Localizer[\"Contact\"]</PageTitle>\n\n<section class=\"section\">\n    <h1 class=\"is-size-3 pb-3\">@Localizer[\"Contact\"]</h1>\n\n    <EditForm class=\"pb-4\" Context=\"cxt\" EditContext=\"_editContext\" ![2](assets/2.png)\n              OnValidSubmit=@(async c => await OnValidSubmitAsync(c))>\n        <DataAnnotationsValidator />\n\n        <!-- Email address -->\n        <FieldInput> ![3](assets/3.png)\n            <FieldLabelContent> @Localizer[\"Email\"] <i class=\"pl-4 far fa-lg\n                    @cxt.GetValidityCss(() => _model.EmailAddress)\"></i>\n            </FieldLabelContent>\n            <FieldControlContent>\n                <InputText @ref=\"_emailInput\"\n                    @bind-Value=\"_model.EmailAddress\" class=\"input\"\n                    readonly=@_isEmailReadonly disabled=@_isEmailReadonly\n                    placeholder=\"@Localizer[\"EmailPlaceholder\"]\" />\n                <span class=\"icon is-small is-left\">\n                    <i class=\"fas fa-envelope\"></i>\n                </span>\n            </FieldControlContent>\n        </FieldInput>\n        <!-- First and last name --> ![4](assets/4.png)\n        <div class=\"field is-horizontal\">\n            <div class=\"field-label is-normal\">\n                <label class=\"label\"> @Localizer[\"From\"] <i class=\"pl-4 far fa-lg\n                        @cxt.GetValidityCss(\n                            () => _model.FirstName,\n                            () => _model.LastName)\"></i>\n                </label>\n            </div>\n            <div class=\"field-body\">\n                <div class=\"field\">\n                    <p class=\"control is-expanded has-icons-left\">\n                        <InputText @ref=\"_firstNameInput\"\n                            @bind-Value=\"_model.FirstName\" class=\"input\"\n                            placeholder=\"@Localizer[\"FirstName\"]\" />\n                        <span class=\"icon is-small is-left\">\n                            <i class=\"fas fa-user\"></i>\n                        </span>\n                    </p>\n                </div>\n                <div class=\"field\">\n                    <p class=\"control is-expanded has-icons-left\">\n                        <InputText @bind-Value=\"_model.LastName\" class=\"input\"\n                                   placeholder=\"@Localizer[\"LastName\"]\" />\n                        <span class=\"icon is-small is-left\">\n                            <i class=\"fas fa-user\"></i>\n                        </span>\n                    </p>\n                </div>\n            </div>\n        </div>\n        <!-- Subject -->\n        <FieldInput> ![5](assets/5.png)\n            <FieldLabelContent> @Localizer[\"Subject\"] <i class=\"pl-4 far fa-lg\n                    @cxt.GetValidityCss(() => _model.Subject)\"></i>\n            </FieldLabelContent>\n            <FieldControlContent>\n                <InputText @bind-Value=\"_model.Subject\" class=\"input\"\n                    placeholder=\"@Localizer[\"SubjectPlaceholder\"]\" />\n                <span class=\"icon is-small is-left\">\n                    <i class=\"fas fa-info-circle\"></i>\n                </span>\n            </FieldControlContent>\n        </FieldInput>\n        <!-- Message -->\n        <FieldInput ControlClasses=@(Array.Empty<string>())> <FieldLabelContent> @Localizer[\"Message\"] <i class=\"pl-4 far fa-lg\n                    @cxt.GetValidityCss(() => _model.Message)\"></i>\n            </FieldLabelContent>\n            <FieldControlContent>\n                <AdditiveSpeechRecognitionComponent ![6](assets/6.png)\n                    SpeechRecognitionStarted=OnRecognitionStarted\n                    SpeechRecognitionStopped=OnRecognitionStopped\n                    SpeechRecognized=OnSpeechRecognized />\n                <InputTextArea @bind-Value=\"_model.Message\" class=\"textarea\"\n                    readonly=@_isMessageReadonly disabled=@_isMessageReadonly\n                    placeholder=\"@Localizer[\"MessagePlaceholder\"]\" />\n            </FieldControlContent>\n        </FieldInput>\n        <!-- Agree to terms -->\n        <FieldInput ControlClasses=@(Array.Empty<string>())> ![7](assets/7.png)\n            <FieldLabelContent> @Localizer[\"AgreeToTerms\"] <i class=\"pl-4 far fa-lg\n                    @cxt.GetValidityCss(() => _model.AgreesToTerms)\"></i>\n            </FieldLabelContent>\n            <FieldControlContent>\n                <label class=\"checkbox\">\n                    <InputCheckbox @bind-Value=\"_model.AgreesToTerms\" /> @Localizer[\"TermsAndConditions\"] <a href=\"/termsandconditions\" target=\"_blank\"\n                        rel=\"noopener noreferrer\">\n                        <i class=\"fas fa-external-link-alt\"></i>\n                    </a>\n                </label>\n            </FieldControlContent>\n        </FieldInput>\n        <!-- Send button --> ![8](assets/8.png)\n        <div class=\"field is-horizontal\">\n            <div class=\"field-label\">\n                <!-- Left empty for spacing -->\n            </div>\n            <div class=\"field-body\">\n                <div class=\"field is-grouped\">\n                    <button class=\"button is-success is-large\" type=\"submit\">\n                        <span class=\"icon\">\n                            <i class=\"fas fa-paper-plane\"></i>\n                        </span>\n                        <span>@Localizer[\"Send\"]</span>\n                    </button>\n                </div>\n            </div>\n        </div>\n    </EditForm>\n</section>\n\n<VerificationModalComponent @ref=\"_modalComponent\" ![9](assets/9.png)\n    VerificationAttempted=@OnVerificationAttempted />\n```", "```cs\nnamespace Learning.Blazor.Extensions;\n\npublic static class EditContextExtensions\n{\n    /// <summary>\n    /// Maps the given <paramref name=\"accessor\"/>\n    /// expression to the resulting CSS.\n    /// </summary>\n    public static string GetValidityCss<T>( ![1](assets/1.png)\n        this EditContext context,\n        Expression<Func<T?>> accessor)\n    {\n        var css = context?.FieldCssClass(accessor);\n        return GetValidityCss(\n            IsValid(css),\n            IsInvalid(css),\n            IsModified(css));\n    }\n\n    /// <summary>\n    /// Maps the given <paramref name=\"accessorOne\"/> and\n    /// <paramref name=\"accessorTwo\"/> expressions to\n    /// the resulting CSS.\n    /// </summary>\n    public static string GetValidityCss<TOne, TTwo>( ![2](assets/2.png)\n        this EditContext context,\n        Expression<Func<TOne?>> accessorOne,\n        Expression<Func<TTwo?>> accessorTwo)\n    {\n        var cssOne = context?.FieldCssClass(accessorOne);\n        var cssTwo = context?.FieldCssClass(accessorTwo);\n        return GetValidityCss(\n            IsValid(cssOne) && IsValid(cssTwo),\n            IsInvalid(cssOne) || IsInvalid(cssTwo),\n            IsModified(cssOne) && IsModified(cssTwo));\n    }\n\n    /// <summary>\n    /// Maps the given validation states into corresponding CSS classes.\n    /// </summary>\n    public static string GetValidityCss( ![3](assets/3.png)\n        bool isValid, bool isInvalid, bool isModified) =>\n        (isValid, isInvalid) switch\n        {\n            (true, false) when isModified => \"fa-check-circle has-text-success\",\n            (false, true) when isModified => \"fa-times-circle has-text-danger\",\n\n            _ => \"fa-question-circle\"\n        };\n\n    private static bool IsValid(string? css) => ![4](assets/4.png)\n        IsContainingClass(css, \"valid\") && !IsInvalid(css);\n\n    private static bool IsInvalid(string? css) => ![5](assets/5.png)\n        IsContainingClass(css, \"invalid\");\n\n    private static bool IsModified(string? css) => ![6](assets/6.png)\n        IsContainingClass(css, \"modified\");\n\n    private static bool IsContainingClass(string? css, string name) =>\n        css?.Contains(name, StringComparison.OrdinalIgnoreCase) ?? false;\n}\n```", "```cs\nnamespace Learning.Blazor.Pages\n{\n    public sealed partial class Contact ![1](assets/1.png)\n    {\n        private EditContext _editContext = null!;\n        private ContactComponentModel _model = new();\n        private InputText _emailInput = null!;\n        private InputText _firstNameInput = null!;\n        private VerificationModalComponent _modalComponent = null!;\n        private bool _isEmailReadonly = false;\n        private bool _isMessageReadonly = false;\n [Inject]\n        public IHttpClientFactory HttpFactory { get; set; } = null!;\n\n        protected override async Task OnInitializedAsync() ![2](assets/2.png)\n        {\n            // Initializes the \"User\" instance.\n            await base.OnInitializedAsync();\n            InitializeModelAndContext();\n        }\n\n        private void InitializeModelAndContext() ![3](assets/3.png)\n        {\n            if (User is { Identity.IsAuthenticated: true })\n            {\n                _model = _model with\n                {\n                    EmailAddress = User.GetFirstEmailAddress()\n                };\n                _isEmailReadonly = _model.EmailAddress is not null\n                    && RegexEmailAddressAttribute.EmailExpression.IsMatch(\n                        _model.EmailAddress);\n            }\n\n            _editContext = new(_model);\n        }\n\n        protected override async Task OnAfterRenderAsync(bool firstRender) ![4](assets/4.png)\n        {\n            if (firstRender)\n            {\n                var input = _isEmailReadonly ? _firstNameInput : _emailInput;\n                await (input?.Element?.FocusAsync(preventScroll: true)\n                    ?? ValueTask.CompletedTask);\n            }\n        }\n\n        private void OnRecognitionStarted() => _isMessageReadonly = true; ![5](assets/5.png)\n\n        private void OnRecognitionStopped(\n            SpeechRecognitionErrorEvent? error) =>\n            _isMessageReadonly = false;\n\n        private void OnSpeechRecognized(string transcript) ![6](assets/6.png)\n        {\n            _model.Message = _model.Message switch\n            {\n                null => transcript,\n                _ => $\"{_model.Message.Trim()} {transcript}\".Trim()\n            };\n\n            _editContext.NotifyFieldChanged(\n                _editContext.Field(nameof(_model.Message)));\n        }\n\n        private Task OnValidSubmitAsync(EditContext context) => ![7](assets/7.png)\n            _modalComponent.PromptAsync(context);\n\n        private async Task OnVerificationAttempted( ![8](assets/8.png)\n            (bool IsVerified, object? State) attempt)\n        {\n            if (attempt.IsVerified)\n            {\n                var client =\n                    HttpFactory.CreateClient(HttpClientNames.ServerApi);\n\n                using var response =\n                    await client.PostAsJsonAsync<ContactRequest>(\n                    \"api/contact\",\n                    _model,\n                    DefaultJsonSerialization.Options);\n\n                if (response.IsSuccessStatusCode)\n                {\n                    AppState?.ContactPageSubmitted?.Invoke(_model);\n                    _model = new();\n                    InitializeModelAndContext();\n                    await InvokeAsync(StateHasChanged);\n                }\n            }\n        }\n    }\n}\n```", "```cs\n<div class=\"field is-horizontal\">\n    <div class=\"field-label @LabelSpecifierClass\">\n        <label class=\"label\"> @FieldLabelContent ![1](assets/1.png)\n        </label>\n    </div>\n    <div class=\"field-body\">\n        <div class=\"field @ControlSpecifierClass\">\n            <p class=\"control @ControlClasses.ToSpaceDelimitedString()\"> @FieldControlContent ![2](assets/2.png)\n            </p>\n        </div>\n    </div>\n</div> @code { ![3](assets/3.png) [Parameter]\n    public string? LabelSpecifierClass { get; set; } = \"is-normal\";\n\n    [Parameter]\n    public string? ControlSpecifierClass { get; set; }\n\n    [Parameter]\n    public RenderFragment? FieldLabelContent { get; set; }\n\n    [Parameter, EditorRequired]\n    public RenderFragment? FieldControlContent { get; set; }\n\n    [Parameter]\n    public string[]? ControlClasses { get; set; } = new string[]\n    {\n        \"is-expanded\", \"has-icons-left\"\n    };\n}\n```", "```cs\nlet _recognition = null; ![1](assets/1.png)\n\n/**\n * Cancels any active speech recognition session,\n * considered best practice to properly clean up.\n * @param {boolean} isAborted\n */\nexport const cancelSpeechRecognition = (isAborted) => { ![2](assets/2.png)\n    if (_recognition !== null) {\n        if (isAborted) {\n            _recognition.abort();\n        } else {\n            _recognition.stop();\n        }\n        _recognition = null;\n    }\n};\n\n/**\n * Starts recognizing speech in the browser and registers\n * all the callbacks for the given dotnetObj in context.\n * @param {any} dotnetObj\n * @param {string} lang The BCP47 tag for the language.\n * @param {string} key Used for round-trip verification and callback-receipts.\n * @param {string} onResultMethodName Incremental recognition results callback.\n * @param {string | null} onErrorMethodName Recognition error callback.\n * @param {string | null} onStartMethodName Recognition started callback.\n * @param {string | null} onEndMethodName Recognition ended callback.\n */\nexport const recognizeSpeech = ![3](assets/3.png)\n    (dotnetObj, lang, key, onResultMethodName,\n        onErrorMethodName, onStartMethodName, onEndMethodName) => {\n        if (!dotnetObj || !onResultMethodName) {\n            return;\n        }\n\n        cancelSpeechRecognition(true);\n\n        _recognition =\n            new webkitSpeechRecognition() || new SpeechRecognition();\n        _recognition.continuous = true;\n        _recognition.interimResults = true;\n        _recognition.lang = lang;\n\n        if (onStartMethodName) {\n            _recognition.onstart = () => { ![4](assets/4.png)\n                dotnetObj.invokeMethod(onStartMethodName, key);\n            };\n        }\n        if (onEndMethodName) {\n            _recognition.onend = () => {\n                dotnetObj.invokeMethod(onEndMethodName, key);\n            };\n        }\n        if (onErrorMethodName) {\n            _recognition.onerror = (error) => {\n                dotnetObj.invokeMethod(onErrorMethodName, key, error);\n            };\n        }\n        _recognition.onresult = (result) => { ![5](assets/5.png)\n            let transcript = '';\n            let isFinal = false;\n            for (let i = result.resultIndex; i < result.results.length; ++i) {\n                transcript += result.results[i][0].transcript;\n                if (result.results[i].isFinal) {\n                    isFinal = true;\n                }\n            }\n            if (isFinal) {\n                const punctuation = transcript.endsWith('.') ? '' : '.';\n                const replaced =\n                    transcript.replace(/\\S/, str => str.toLocaleUpperCase());\n                transcript =\n                    `${replaced}${punctuation}`;\n            }\n            dotnetObj.invokeMethod(\n                onResultMethodName, key, transcript, isFinal);\n        };\n        _recognition.start();\n    };\n\nwindow.addEventListener('beforeunload', _ => { ![6](assets/6.png)\n    cancelSpeechRecognition(true);\n});\n```", "```cs\nnamespace Microsoft.JSInterop; ![1](assets/1.png)\n\npublic interface ISpeechRecognitionService : IAsyncDisposable ![2](assets/2.png)\n{\n    Task InitializeModuleAsync(); ![3](assets/3.png)\n\n    void CancelSpeechRecognition(bool isAborted); ![4](assets/4.png)\n\n    IDisposable RecognizeSpeech( ![5](assets/5.png)\n        string language,\n        Action<string> onRecognized,\n        Action<SpeechRecognitionErrorEvent>? onError = null,\n        Action? onStarted = null,\n        Action? onEnded = null);\n}\n```", "```cs\nnamespace Microsoft.JSInterop;\n\ninternal sealed class DefaultSpeechRecognitionService ![1](assets/1.png)\n    : ISpeechRecognitionService\n{\n    const string ContentFolder = \"_content\"; ![2](assets/2.png)\n    const string Package = \"Blazor.SpeechRecognition.WebAssembly\";\n    const string Module = \"blazorators.speechRecognition.js\";\n\n    readonly IJSInProcessRuntime _javaScript;\n    readonly SpeechRecognitionCallbackRegistry _callbackRegistry = new();\n\n    IJSInProcessObjectReference? _speechRecognitionModule;\n    SpeechRecognitionSubject? _speechRecognition;\n\n    public DefaultSpeechRecognitionService(\n        IJSInProcessRuntime javaScript) => _javaScript = javaScript;\n\n    void InitializeSpeechRecognitionSubject()\n    {\n        if (_speechRecognition is not null) ![3](assets/3.png)\n        {\n            CancelSpeechRecognition(false);\n            _speechRecognition.Dispose();\n        }\n\n        _speechRecognition = SpeechRecognitionSubject.Factory(\n            _callbackRegistry.InvokeOnRecognized);\n    }\n\n    /// <inheritdoc />\n    public async Task InitializeModuleAsync() => ![4](assets/4.png)\n        _speechRecognitionModule =\n            await _javaScript.InvokeAsync<IJSInProcessObjectReference>(\n                \"import\",\n                $\"./{ContentFolder}/{Package}/{Module}\");\n\n    /// <inheritdoc />\n    public void CancelSpeechRecognition( ![5](assets/5.png)\n        bool isAborted) =>\n        _speechRecognitionModule?.InvokeVoid(\n            \"cancelSpeechRecognition\",\n            isAborted);\n\n    /// <inheritdoc />\n    public IDisposable RecognizeSpeech( ![6](assets/6.png)\n        string language,\n        Action<string> onRecognized,\n        Action<SpeechRecognitionErrorEvent>? onError,\n        Action? onStarted,\n        Action? onEnded)\n    {\n        InitializeSpeechRecognitionSubject();\n\n        var key = Guid.NewGuid();\n        _callbackRegistry.RegisterOnRecognized(key, onRecognized);\n        if (onError is not null)\n            _callbackRegistry.RegisterOnError(key, onError);\n        if (onStarted is not null)\n            _callbackRegistry.RegisterOnStarted(key, onStarted);\n        if (onEnded is not null)\n            _callbackRegistry.RegisterOnEnded(key, onEnded);\n\n        _speechRecognitionModule?.InvokeVoid(\n            \"recognizeSpeech\",\n            DotNetObjectReference.Create(this),\n            language,\n            key,\n            nameof(OnSpeechRecognized),\n            nameof(OnRecognitionError),\n            nameof(OnStarted),\n            nameof(OnEnded));\n\n        return _speechRecognition!;\n    }\n [JSInvokable]\n    public void OnStarted(string key) => ![7](assets/7.png)\n        _callbackRegistry.InvokeOnStarted(key);\n [JSInvokable]\n    public void OnEnded(string key) =>\n        _callbackRegistry.InvokeOnEnded(key);\n [JSInvokable]\n    public void OnRecognitionError(\n        string key, SpeechRecognitionErrorEvent errorEvent) =>\n        _callbackRegistry.InvokeOnError(key, errorEvent);\n [JSInvokable]\n    public void OnSpeechRecognized( ![8](assets/8.png)\n        string key, string transcript, bool isFinal) =>\n        _speechRecognition?.RecognitionReceived(\n            new SpeechRecognitionResult(key, transcript, isFinal));\n\n    async ValueTask IAsyncDisposable.DisposeAsync()\n    {\n        _speechRecognition?.Dispose();\n        _speechRecognition = null;\n\n        if (_speechRecognitionModule is not null)\n        {\n            await _speechRecognitionModule.DisposeAsync();\n            _speechRecognitionModule = null;\n        }\n    }\n}\n```", "```cs\nnamespace Microsoft.JSInterop;\n\ninternal sealed class SpeechRecognitionSubject : IDisposable ![1](assets/1.png)\n{\n    readonly Subject<SpeechRecognitionResult> _speechRecognitionSubject = new();\n    readonly IObservable<(string, string)> _speechRecognitionObservable;\n    readonly IDisposable _speechRecognitionSubscription;\n    readonly Action<string, string> _observer;\n\n    private SpeechRecognitionSubject( ![2](assets/2.png)\n        Action<string, string> observer)\n    {\n        _observer = observer;\n        _speechRecognitionObservable =\n            _speechRecognitionSubject.AsObservable()\n                .Where(r => r.IsFinal)\n                .Select(r => (r.Key, r.Transcript));\n\n        _speechRecognitionSubscription =\n            _speechRecognitionObservable.Subscribe(\n                ((string Key, string SpeechRecognition) tuple) =>\n                    _observer(tuple.Key, tuple.SpeechRecognition));\n    }\n\n    internal static SpeechRecognitionSubject Factory( ![3](assets/3.png)\n        Action<string, string> observer) => new(observer);\n\n    internal void RecognitionReceived( ![4](assets/4.png)\n        SpeechRecognitionResult recognition) =>\n        _speechRecognitionSubject.OnNext(recognition);\n\n    public void Dispose() => _speechRecognitionSubscription.Dispose(); ![5](assets/5.png)\n}\n```", "```cs\nnamespace Microsoft.JSInterop;\n\ninternal sealed class SpeechRecognitionCallbackRegistry ![1](assets/1.png)\n{\n    readonly ConcurrentDictionary<Guid, Action<string>>\n        _onResultCallbackRegister = new();\n    readonly ConcurrentDictionary<Guid, Action<SpeechRecognitionErrorEvent>>\n        _onErrorCallbackRegister = new();\n    readonly ConcurrentDictionary<Guid, Action>\n        _onStartedCallbackRegister = new();\n    readonly ConcurrentDictionary<Guid, Action>\n        _onEndedCallbackRegister = new();\n\n    internal void RegisterOnRecognized( ![2](assets/2.png)\n        Guid key, Action<string> callback) =>\n        _onResultCallbackRegister[key] = callback;\n\n    internal void RegisterOnError( ![3](assets/3.png)\n        Guid key, Action<SpeechRecognitionErrorEvent> callback) =>\n        _onErrorCallbackRegister[key] = callback;\n\n    internal void RegisterOnStarted(\n        Guid key, Action callback) =>\n        _onStartedCallbackRegister[key] = callback;\n\n    internal void RegisterOnEnded(\n        Guid key, Action callback) =>\n        _onEndedCallbackRegister[key] = callback;\n\n    internal void InvokeOnRecognized( ![4](assets/4.png)\n        string key, string transcript) =>\n        OnInvokeCallback(\n            key, _onResultCallbackRegister,\n            callback => callback?.Invoke(transcript));\n\n    internal void InvokeOnError( ![5](assets/5.png)\n        string key, SpeechRecognitionErrorEvent error) =>\n        OnInvokeCallback(\n            key, _onErrorCallbackRegister,\n            callback => callback?.Invoke(error));\n\n    internal void InvokeOnStarted(string key) =>\n        OnInvokeCallback(\n            key, _onStartedCallbackRegister,\n            callback => callback?.Invoke());\n\n    internal void InvokeOnEnded(string key) =>\n        OnInvokeCallback(\n            key, _onEndedCallbackRegister,\n            callback => callback?.Invoke());\n\n    static void OnInvokeCallback<T>( ![6](assets/6.png)\n        string key,\n        ConcurrentDictionary<Guid, T> callbackRegister,\n        Action<T?> handleCallback)\n    {\n        if (key is null or { Length: 0 } ||\n            callbackRegister is null or { Count: 0 })\n        {\n            return;\n        }\n\n        if (Guid.TryParse(key, out var guid) &&\n            callbackRegister.TryRemove(guid, out var callback))\n        {\n            handleCallback?.Invoke(callback);\n        }\n    }\n}\n```", "```cs\nusing RecognitionError = Microsoft.JSInterop.SpeechRecognitionErrorEvent;\n\nnamespace Learning.Blazor.Components\n{\n    public sealed partial class AdditiveSpeechRecognitionComponent\n        : IAsyncDisposable ![1](assets/1.png)\n    {\n        IDisposable? _recognitionSubscription;\n        SpeechRecognitionErrorEvent? _error = null;\n        bool _isRecognizing = false;\n\n        string _dynamicCSS => _isRecognizing ? \"is-flashing\" : \"\";\n [Inject] ![2](assets/2.png)\n        private ISpeechRecognitionService SpeechRecognition\n        {\n            get;\n            set;\n        } = null!;\n [Parameter] ![3](assets/3.png)\n        public EventCallback SpeechRecognitionStarted { get; set; }\n [Parameter] ![4](assets/4.png)\n        public EventCallback<RecognitionError?> SpeechRecognitionStopped\n        {\n            get;\n            set;\n        }\n [Parameter, EditorRequired] ![5](assets/5.png)\n        public EventCallback<string> SpeechRecognized { get; set; }\n\n        protected override async Task OnAfterRenderAsync(bool firstRender)\n        {\n            if (firstRender)\n            {\n                await SpeechRecognition.InitializeModuleAsync(); ![6](assets/6.png)\n            }\n        }\n\n        void OnRecognizeButtonClick() ![7](assets/7.png)\n        {\n            if (_isRecognizing)\n            {\n                SpeechRecognition.CancelSpeechRecognition(false);\n            }\n            else\n            {\n                var bcp47Tag = Culture.CurrentCulture.Name;\n                _recognitionSubscription?.Dispose();\n                _recognitionSubscription = SpeechRecognition.RecognizeSpeech(\n                    bcp47Tag,\n                    OnRecognized,\n                    OnError,\n                    OnStarted,\n                    OnEnded);\n            }\n        }\n\n        void OnRecognized(string transcript) => ![8](assets/8.png)\n            _ = SpeechRecognized.TryInvokeAsync(transcript, this);\n\n        void OnError(SpeechRecognitionErrorEvent recognitionError)\n        {\n            (_isRecognizing, _error) = (false, recognitionError);\n            _ = SpeechRecognitionStopped.TryInvokeAsync(_error, this);\n        }\n\n        void OnStarted()\n        {\n            _isRecognizing = true;\n            _ = SpeechRecognitionStarted.TryInvokeAsync(this);\n        }\n\n        public void OnEnded()\n        {\n            _isRecognizing = false;\n            _ = SpeechRecognitionStopped.TryInvokeAsync(_error, this);\n        }\n\n        ValueTask IAsyncDisposable.DisposeAsync()\n        {\n            _recognitionSubscription?.Dispose();\n            return SpeechRecognition.DisposeAsync();\n        }\n    }\n}\n```"]