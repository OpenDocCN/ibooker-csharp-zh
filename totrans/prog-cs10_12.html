<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 12. Assemblies" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_assemblies">
<h1><span class="label">Chapter 12. </span>Assemblies</h1>
<p><a data-primary="assemblies" data-type="indexterm" id="ix_ch12-asciidoc0"/>So far in this book, I’ve used the term <em>component</em> to describe either a library or an executable. It’s now time to look more closely at exactly what that means. In .NET the unit of deployment for a software component is called an <em>assembly</em>, and it is typically a <em>.dll</em> or <em>.exe</em> file. Assemblies are an important aspect of the type system, because each type is identified not just by its name and namespace but also by its containing assembly. Assemblies provide a kind of encapsulation that operates at a larger scale than individual types, thanks to the <code>internal</code> accessibility specifier, which works at the assembly level.</p>
<p><a data-primary="assembly loader" data-type="indexterm" id="idm45884796245920"/>The runtime provides an <em>assembly loader</em>, which automatically finds and loads the assemblies a program needs. To ensure that the loader can find the right components, assemblies have structured names that include version information, and they can optionally contain a globally unique element to prevent ambiguity.</p>
<p><a data-primary="Visual Studio" data-secondary="assemblies and" data-type="indexterm" id="idm45884796244384"/><a data-primary="dotnet command line tool" data-secondary="dotnet new" data-type="indexterm" id="idm45884796243408"/>Most of the C# project types in Visual Studio’s “Create a new project” dialog produce a single assembly as their main output, as do most of the project templates available from the command line with <code>dotnet new</code>. When you build a project, it will often put additional files in the output folder too, such as copies of any assemblies that your code relies on that are not built into the .NET runtime, and other files needed by your application. (For example, a website project will typically need to produce CSS and script files in addition to server-side code.) But there will usually be a particular assembly that is the build target of your project, containing all of the types your project defines along with the code those types contain.</p>
<section class="less_space pagebreak-before" data-pdf-bookmark="Anatomy of an Assembly" data-type="sect1"><div class="sect1" id="anatomy_of_an_assembly">
<h1>Anatomy of an Assembly</h1>
<p><a data-primary="assemblies" data-secondary="anatomy of" data-type="indexterm" id="ix_ch12-asciidoc1"/>Assemblies use the Win32 <a data-primary="PE (Portable Executable) file format" data-type="indexterm" id="idm45884796238432"/><a data-primary="Portable Executable (PE) file format" data-type="indexterm" id="idm45884796237792"/>Portable Executable (PE) file format, the same format that <a data-primary="executables" data-type="indexterm" id="idm45884796236976"/>executables (EXEs) and dynamic link libraries (DLLs) have always used in modern versions of Windows.<sup><a data-type="noteref" href="ch12.xhtml#fn32" id="fn32-marker">1</a></sup> It is “portable” in the sense that the same basic file format is used across different CPU architectures. Non-.NET PE files are generally architecture-specific, but .NET assemblies often aren’t. Even if you’re running .NET on Linux or macOS, it’ll still use this Windows-based format—most .NET assemblies run on all supported operating systems, so we use the same file format everywhere.</p>
<p>The C# compiler produces an assembly as its output, with an extension of either <em>.dll</em> or <em>.exe</em>. Tools that understand the PE file format will recognize a .NET assembly as a valid, but rather dull, PE file. The CLR essentially uses PE files as containers for a .NET-specific data format, so to classic Win32 tools, a C# DLL will not appear to export any APIs. Remember that C# compiles to a binary intermediate language (IL), which is not directly executable. The normal Windows mechanisms for loading and running the code in an executable or DLL won’t work with IL, because that can run only with the help of the CLR. Similarly, .NET defines its own format for encoding metadata and does not use the PE format’s native capability for exporting entry points or importing the services of other DLLs.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a data-primary="AoT (ahead-of-time) compilation" data-type="indexterm" id="idm45884796232480"/><a data-primary="ahead-of-time (AoT) compilation" data-type="indexterm" id="idm45884796231760"/>The ahead-of-time (AoT) compilation tools in the .NET SDK can add native executable code to your assemblies later in the build process, but with <em>Ready to Run</em> assemblies (as the output of these AoT tools are called), even the embedded native code is loaded and executed under the control of the CLR and is directly accessible only to managed code.</p>
</div>
<p>In most cases, you won’t build .NET assemblies with an extension of <em>.exe</em>. Even project types that produce directly runnable outputs (such as console or WPF applications) produce a <em>.dll</em> as their primary output. They also generate an executable file too, but it’s not a .NET assembly. <a data-primary="bootstrapping executables" data-type="indexterm" id="idm45884796228384"/>It’s just a bootstrapper that starts the runtime and then loads and executes your application’s main assembly. By default, the type of bootstrapper you get depends on what OS you build on—for example, if you build on Windows, you’ll get a Windows <em>.exe</em> bootstrapper, whereas on Linux it will be an executable in the ELF format.<sup><a data-type="noteref" href="ch12.xhtml#idm45884796226928" id="idm45884796226928-marker">2</a></sup> (The exception to this is when you target the .NET Framework. Since that supports only Windows, it doesn’t need different 
<span class="keep-together">bootstrappers</span> for different operating systems, so these projects produce a .NET assembly with an extension of <em>.exe</em> that incorporates the bootstrapper.)</p>
<section data-pdf-bookmark=".NET Metadata" data-type="sect2"><div class="sect2" id="dotnet_metadata">
<h2>.NET Metadata</h2>
<p><a data-primary="assemblies" data-secondary=".NET metadata" data-secondary-sortas="NET metadata" data-type="indexterm" id="idm45884796223584"/>As well as containing the compiled IL, an assembly contains <em>metadata</em>, which provides a full description of all of the types it defines, whether public or private. The CLR needs to have complete knowledge of all the types your code uses to be able to make sense of the IL and turn it into running code—the binary format for IL frequently refers to the containing assembly’s metadata and is meaningless without it. The reflection API, which is the subject of <a data-type="xref" href="ch13.xhtml#ch_reflection">Chapter 13</a>, makes the information in this metadata available to your code.</p>
</div></section>
<section data-pdf-bookmark="Resources" data-type="sect2"><div class="sect2" id="resources">
<h2>Resources</h2>
<p><a data-primary="assemblies" data-secondary="resources" data-type="indexterm" id="idm45884796219040"/><a data-primary="GetManifestResourceStream" data-type="indexterm" id="idm45884796218064"/>You can embed binary resources in a DLL alongside the code and metadata. Client-side applications might do this with bitmaps, for example. To embed a file, you can add it to a project, select it in Solution Explorer, and then use the Properties panel to set its Build Action to Embedded Resource. This embeds a copy of the entire file into the component. To extract the resource at runtime, you use the <code>Assembly</code> class’s <code>GetManifestResourceStream</code> method, which is part of the reflection API described in <a data-type="xref" href="ch13.xhtml#ch_reflection">Chapter 13</a>. However, in practice, you wouldn’t normally use this facility directly—most applications use embedded resources through a localizable mechanism that I’ll describe later in this chapter.</p>
<p>So, in summary, an assembly contains a comprehensive set of metadata describing all the types it defines; it holds all of the IL for those types’ methods, and it can optionally embed any number of binary streams. This is typically all packaged up into a single PE file. However, that is not always the whole story.</p>
</div></section>
<section data-pdf-bookmark="Multifile Assemblies" data-type="sect2"><div class="sect2" id="multifile_assemblies">
<h2>Multifile Assemblies</h2>
<p><a data-primary="assemblies" data-secondary="multifile" data-type="indexterm" id="idm45884796213424"/>The old (but still supported) Windows-only .NET Framework allows an assembly to span multiple files. <a data-primary="modules, in multifile assemblies" data-type="indexterm" id="idm45884796212208"/>You can split the code and metadata across multiple <em>modules</em>, and it is also possible for some binary streams that are logically embedded in an assembly to be put in separate files. This feature is rarely used, and neither .NET Core nor its successors (including the current version of .NET) support it. However, it’s necessary to know about it because some of its consequences persist. In particular, parts of the design of the reflection API (<a data-type="xref" href="ch13.xhtml#ch_reflection">Chapter 13</a>) make no sense unless you know about this feature.</p>
<p>With a multifile assembly, there’s always one main file that represents the assembly. <a data-primary="assembly manifest" data-type="indexterm" id="idm45884796209504"/>This will be a PE file, and it contains a particular element of the metadata called the <em>assembly manifest</em>. This is not to be confused with the Win32-style manifest that most executables contain. The assembly manifest is just a description of what’s in the assembly, including a list of any external modules or other external files; in a multimodule assembly, the manifest describes which types are defined in which files. When writing code that uses the types in an assembly directly, you generally didn’t need to care whether it was split across multiple modules, because the runtime would inspect the manifest and automatically load whichever modules were needed. Multiple modules were typically only an issue for code that inspected the structure of a component using reflection.</p>
</div></section>
<section data-pdf-bookmark="Other PE Features" data-type="sect2"><div class="sect2" id="other_pe_features">
<h2>Other PE Features</h2>
<p>Although C# does not use the classic Win32 mechanisms for representing code or exporting APIs in EXEs and DLLs, there are still a couple of old-school features of the PE format that assemblies can use.</p>
<section data-pdf-bookmark="Win32-style resources" data-type="sect3"><div class="sect3" id="win32-style_resources">
<h3>Win32-style resources</h3>
<p><a data-primary="assemblies" data-secondary="Win32-style resources" data-type="indexterm" id="idm45884796204368"/>.NET defines its own mechanism for embedding binary resources, and a localization API built on top of that, so for the most part it makes no use of the PE file format’s intrinsic support for embedding resources. There’s nothing stopping you from putting classic Win32-style resources into a .NET component—the C# compiler offers various command-line switches that do this. However, there’s no .NET API for accessing these resources at runtime from within your application, which is why you’d normally use .NET’s own resource system. But there are some exceptions.</p>
<p>Windows expects to find certain resources in executables. For example, it defines a way to embed version information as an unmanaged resource. C# assemblies normally do this, but you don’t need to define a version resource explicitly. The compiler can generate one for you, as I show in <a data-type="xref" href="#version">“Version”</a>. This ensures that if an end user looks at your assembly’s properties in Windows File Explorer, they will be able to see the version number. (By convention, .NET assemblies typically contain this Win32-style version information whether they target just Windows or can run on any platform.)</p>
<p>Windows <em>.exe</em> files typically contain two additional Win32 resources. You may want to define a custom icon for your application to control how it appears on the task bar or in Windows File Explorer. This requires you to embed the icon in the Win32 way, because File Explorer doesn’t know how to extract .NET resources. You can do this by adding an <code>&lt;ApplicationIcon&gt;</code> property to your <em>.csproj</em> file. If you’re using Visual Studio, it provides a way to set this through the project’s properties pages. Also, if you’re writing a classic Windows desktop application or console application (whether written with .NET or not), <a data-primary="application manifest" data-type="indexterm" id="idm45884796199520"/>it should supply an application manifest. Without this, Windows will presume that your application was written before 2006<sup><a data-type="noteref" href="ch12.xhtml#fn34" id="fn34-marker">3</a></sup> and will modify or disable certain features for backward compatibility. The manifest also needs to be present if you are writing a desktop application and you want it to pass certain Microsoft certification requirements. This kind of manifest has to be embedded as a Win32 resource. The .NET SDK will add a manifest with default settings by default, but if you need to customize it (e.g., because you’re writing a console application that will need to run with elevated privileges), you can specify a manifest with an <code>&lt;ApplicationManifest&gt;</code> property in your <em>.csproj</em> file (or again, with the project properties pages in Visual Studio).</p>
<p>Remember that with .NET and .NET Core, the main assembly is a <em>.dll</em>, even for Windows desktop applications, and when you target Windows, the build process produces a separate <em>.exe</em> that launches the .NET runtime and then loads that assembly. As far as Windows is concerned, this bootstrapper is your application, so the icon and manifest resources will end up in this bootstrapping assembly. But if you target the .NET Framework, there will be no separate bootstrapper, so these resources end up in the main assembly.</p>
</div></section>
<section data-pdf-bookmark="Console versus GUI" data-type="sect3"><div class="sect3" id="console_versus_gui">
<h3>Console versus GUI</h3>
<p><a data-primary="assemblies" data-secondary="console versus GUI" data-type="indexterm" id="idm45884796193728"/>Windows makes a distinction between console applications and Windows applications. <a data-primary="subsystems, .exe files and" data-type="indexterm" id="idm45884796192624"/>To be precise, the PE format requires a <em>.exe</em> file to specify a <em>subsystem</em>, and back in the old days of Windows NT, this enabled the use of multiple operating system <em>personalities</em>—early versions included a POSIX subsystem, for example. So these days, PE files target one of just three subsystems, and one of those is for kernel-mode device drivers. The two user-mode options used today select between Windows graphical user interface (GUI) and Windows console applications. The principal difference is that Windows will show a console window when running the latter (or if you run it from a command prompt, it will just use the existing console window), but a Windows GUI application does not get a console window.</p>
<p>You can select between these subsystems with an <code>&lt;OutputType&gt;</code> property in your project file set to <code>Exe</code> or <code>WinExe</code>, or in Visual Studio you can use the “Output type” drop-down list in the project properties. (The output type defaults to <code>Library</code>, or “Class Library” in Visual Studio’s UI. This builds a DLL, but since the subsystem is determined when a process launches, it makes no difference whether a DLL targets the Windows Console or Windows GUI subsystem. The <code>Library</code> setting always targets the former.) If you target the .NET Framework, this subsystem setting applies to the <em>.exe</em> file that is built as your application’s main assembly, and with newer versions of .NET, it will apply to the bootstrapper <em>.exe</em>. (As it happens, it will also apply to the main assembly <em>.dll</em> that the bootstrapper loads, but this has no effect because the subsystem is determined by the <em>.exe</em> for which the process is launched.)<a data-startref="ix_ch12-asciidoc1" data-type="indexterm" id="idm45884796185296"/></p>
</div></section>
</div></section>
</div></section>
<section data-pdf-bookmark="Type Identity" data-type="sect1"><div class="sect1" id="type_identity">
<h1>Type Identity</h1>
<p><a data-primary="assemblies" data-secondary="type identity" data-type="indexterm" id="ix_ch12-asciidoc2"/><a data-primary="type identity" data-secondary="assemblies and" data-type="indexterm" id="ix_ch12-asciidoc3"/>As a C# developer, your first point of contact with assemblies will usually be the fact that they form part of a type’s identity. When you write a class, it will end up in an assembly. When you use a type from the runtime libraries or from some other library, your project will need a reference to the assembly that contains the type before you can use it.</p>
<p>This is not always obvious when using system types. The build system automatically adds references to various runtime library assemblies, so most of the time, you will not need to add a reference before you can use a runtime library type, and since you do not normally refer to a type’s assembly explicitly in the source code, it’s not immediately obvious that the assembly is a mandatory part of what it takes to pinpoint a type. But despite not being explicit in the code, the assembly has to be part of a type’s identity, because there’s nothing stopping you or anyone else from defining new types that have the same name as existing types. For example, you could define a class called <code>System.String</code> in your project. This is a bad idea, and the compiler will warn you that this introduces ambiguity, but it won’t stop you. And even though your class will have the exact same fully qualified name as the built-in string type, the compiler and the runtime can still distinguish between these types.</p>
<p>Whenever you use a type, either explicitly by name (e.g., in a variable or parameter declaration) or implicitly through an expression, the C# compiler knows exactly what type you’re referring to, meaning it knows which assembly defined the type. So it is able to distinguish between the <code>System.String</code> intrinsic to .NET and a <code>System.String</code> unhelpfully defined in your own component. The C# scoping rules mean that an explicit reference to <code>System.String</code> identifies the one that you defined in your own project, because local types effectively hide ones of the same name in external assemblies. If you use the <code>string</code> keyword, that always refers to the built-in type. You’ll also be using the built-in type when you use a string literal, or if you call an API that returns a string. <a data-type="xref" href="#what_type_is_a_piece_of_string">Example 12-1</a> illustrates this—it defines its own <code>System.String</code> and then uses a generic method that displays the type and assembly name for the static type of whatever argument you pass it. (This uses the reflection API, which is described in <a data-type="xref" href="ch13.xhtml#ch_reflection">Chapter 13</a>.)<a data-primary="typeof operator" data-secondary="examples of use" data-type="indexterm" id="idm45884796173392"/></p>
<div data-type="example" id="what_type_is_a_piece_of_string">
<h5><span class="label">Example 12-1. </span>What type is a piece of string?</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">using</code> <code class="nn">System</code><code class="p">;</code>

<code class="c1">// Never do this!</code>
<code class="k">namespace</code> <code class="nn">System</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">class</code> <code class="nc">String</code>
    <code class="p">{</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="k">class</code> <code class="nc">Program</code>
<code class="p">{</code>
    <code class="k">static</code> <code class="k">void</code> <code class="nf">Main</code><code class="p">(</code><code class="kt">string</code><code class="p">[]</code> <code class="n">args</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">System</code><code class="p">.</code><code class="n">String</code><code class="p">?</code> <code class="n">s</code> <code class="p">=</code> <code class="k">null</code><code class="p">;</code>
        <code class="n">ShowStaticTypeNameAndAssembly</code><code class="p">(</code><code class="n">s</code><code class="p">);</code>
        <code class="kt">string?</code> <code class="n">s2</code> <code class="p">=</code> <code class="k">null</code><code class="p">;</code>
        <code class="n">ShowStaticTypeNameAndAssembly</code><code class="p">(</code><code class="n">s2</code><code class="p">);</code>
        <code class="n">ShowStaticTypeNameAndAssembly</code><code class="p">(</code><code class="s">"String literal"</code><code class="p">);</code>
        <code class="n">ShowStaticTypeNameAndAssembly</code><code class="p">(</code><code class="n">Environment</code><code class="p">.</code><code class="n">OSVersion</code><code class="p">.</code><code class="n">VersionString</code><code class="p">);</code>
    <code class="p">}</code>

    <code class="k">static</code> <code class="k">void</code> <code class="n">ShowStaticTypeNameAndAssembly</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;(</code><code class="n">T</code> <code class="n">item</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">Type</code> <code class="n">t</code> <code class="p">=</code> <code class="k">typeof</code><code class="p">(</code><code class="n">T</code><code class="p">);</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code>
            <code class="err">$</code><code class="s">"Type: {t.FullName}. Assembly {t.Assembly.FullName}."</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>The <code>Main</code> method in this example tries each of the ways of working with strings I just described, and it writes out the following:</p>
<pre data-type="programlisting">Type: System.String. Assembly TypeIdentity, Version=1.0.0.0, Culture=neutral,
 PublicKeyToken=null.
Type: System.String. Assembly System.Private.CoreLib, Version=6.0.0.0,
 Culture=neutral, PublicKeyToken=7cec85d7bea7798e.
Type: System.String. Assembly System.Private.CoreLib, Version=6.0.0.0,
 Culture=neutral, PublicKeyToken=7cec85d7bea7798e.
Type: System.String. Assembly System.Private.CoreLib, Version=6.0.0.0,
 Culture=neutral, PublicKeyToken=7cec85d7bea7798e.</pre>
<p>The explicit use of <code>System.String</code> ended up with my type, and the rest all used the system-defined string type. This demonstrates that the C# compiler can cope with multiple types with the same name. This also shows that IL is able to make that distinction. IL’s binary format ensures that every reference to a type identifies the containing assembly. But just because you can create and use multiple identically named types doesn’t mean you should. Because you do not usually name the containing assembly explicitly in C#, it’s a particularly bad idea to introduce pointless collisions by defining, say, your own <code>System.String</code> class. (As it happens, in a pinch you can resolve this sort of collision if you really need to—see the sidebar <a data-type="xref" href="#extern_aliases">“Extern Aliases”</a> for details—but it’s better to avoid it.)</p>
<p>By the way, if you run <a data-type="xref" href="#what_type_is_a_piece_of_string">Example 12-1</a> on .NET Framework, you’ll see <code>mscorlib</code> in place of <code>System.Private.CoreLib</code>. .NET Core changed which assemblies many runtime library types live in. You might be wondering how this can work with .NET Standard, which enables you to write a single DLL that can run on .NET 
<span class="keep-together">Framework,</span> .NET Core, and .NET. How could a .NET Standard component correctly identify a type that lives in different assemblies on different targets? <a data-primary="type forwarding" data-type="indexterm" id="idm45884796063504"/>The answer is that .NET has a <em>type forwarding</em> feature in which references to types in one assembly can be redirected to some other assembly at runtime. (A type forwarder is just an assembly-level attribute that describes where the real type definition can be found. Attributes are the subject of <a data-type="xref" href="ch14.xhtml#ch_attributes">Chapter 14</a>.) .NET Standard components reference neither <code>mscorlib</code> nor <code>System.Private.CoreLib</code>—they are built as though runtime library types are defined in an assembly called <code>netstandard</code>. Each .NET runtime supplies a <code>netstandard</code> implementation that forwards to the appropriate types at runtime. In fact, even code built directly for .NET Core or .NET often ends 
<span class="keep-together">up using type forwarding.</span> If you inspect the compiled output, you’ll find that it 
<span class="keep-together">expects most runtime</span> library types to be defined in an assembly called <code>System​.Runtime</code>, and it’s only through type forwarding that these end up using types in 
<span class="keep-together"><code>System.Private.CoreLib</code>.</span></p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="extern_aliases">
<h5>Extern Aliases</h5>
<p><a data-primary="assemblies" data-secondary="extern aliases" data-type="indexterm" id="idm45884796022112"/><a data-primary="extern aliases" data-type="indexterm" id="idm45884796021136"/><a data-primary="type identity" data-secondary="extern aliases" data-type="indexterm" id="idm45884796020464"/>When multiple types with the same name are in scope, C# normally uses the one from the nearest scope, which is why a locally defined <code>System.String</code> can hide the built-in type of the same name. It’s unwise to introduce this sort of name clash in the first place, but occasionally you can end up with this problem when external libraries that you depend on have made bad naming decisions. If that’s where you are, C# offers a mechanism that lets you specify the assembly you want. You can define an <em>extern alias</em>.</p>
<p>In <a data-type="xref" href="ch01.xhtml#ch_introducing_csharp">Chapter 1</a>, I showed type aliases defined with the <code>using</code> keyword that make it easier to refer to types that have the same simple name but different namespaces. An extern alias makes it possible to distinguish between types with the same fully qualified name in different assemblies.</p>
<p>To define an extern alias, you need to add an <code>Aliases</code> element inside the relevant element in your <em>.csproj</em> file. Depending on whether the target component is a NuGet package, another project, or a plain DLL, that will be a <code>PackageReference</code>, <code>ProjectReference</code>, or <code>Reference</code> element, respectively. As a child of that element, add an <code>Aliases</code> element containing the name (or a comma-separated list of names) to use, e.g., <code>&lt;Aliases&gt;A1&lt;/Aliases&gt;</code>. If you’re using Visual Studio, it can do this for you: expand the Dependencies list in Solution Explorer and then expand either the Packages, Projects, or Assemblies section and select a reference. You can then set the alias for that reference in the Properties panel. If you define an alias of <code>A1</code> for one assembly and <code>A2</code> for another, you can then declare that you want to use these aliases by putting the following at the top of a C# file:</p>
<pre data-type="programlisting">extern alias A1;
extern alias A2;</pre>
<p>With these in place, you can qualify type names with <code>A1::</code> or <code>A2::</code> followed by the fully qualified name. This tells the compiler that you want to use types defined by the assembly (or assemblies) associated with that alias, even if some other type of the same name would otherwise have been in scope.</p>
</div></aside>
<p>If it’s a bad idea to have multiple types with the same name, why does .NET make it possible in the first place? In fact, supporting name collisions was not the goal; it’s just a side effect of the fact that .NET makes the assembly part of the type. The assembly needs to be part of the type definition so that the CLR can know which assembly to load for you at runtime when you first use some feature of that type.<a data-startref="ix_ch12-asciidoc3" data-type="indexterm" id="idm45884796008480"/><a data-startref="ix_ch12-asciidoc2" data-type="indexterm" id="idm45884796007744"/></p>
</div></section>
<section data-pdf-bookmark="Loading Assemblies" data-type="sect1"><div class="sect1" id="loading_assemblies">
<h1>Loading Assemblies</h1>
<p><a data-primary="assemblies" data-secondary="loading" data-type="indexterm" id="ix_ch12-asciidoc4"/>You may have been alarmed earlier when I said that the build system automatically adds references to all the runtime library components available on your target framework. Perhaps you wondered how you might go about removing some of these in the name of efficiency. As far as runtime overhead is concerned, you do not need to worry. The C# compiler effectively ignores any references to built-in assemblies that your project never uses, so there’s no danger of loading DLLs that you don’t need. (It is, however, worth removing references to unused components that are <em>not</em> built into .NET to avoid copying unneeded DLLs when you deploy the app—there’s no sense in making deployments larger than they need to be. But unused references to DLLs that are already installed as part of .NET cost you nothing.)</p>
<p>Even if C# didn’t strip out unused references at compile time, there would still be no risk of unnecessary loading of unused DLLs. The CLR does not attempt to load assemblies until your application first needs them. Most applications do not exercise every possible code path each time they execute, so it’s fairly common for significant portions of the code in your application not to run. Your program may even finish its work having left entire classes unused—perhaps classes that get involved only when an unusual error condition arises. If the only place you use a particular assembly is inside a method of such a class, that assembly won’t get loaded.</p>
<p>The CLR has some discretion for deciding exactly what it means to “use” a particular assembly. If a method contains any code that refers to a particular type (e.g., it declares a variable of that type or it contains expressions that use the type implicitly), then the CLR may consider that type to be used when that method first runs even if you don’t get to the part that really uses it. Consider <a data-type="xref" href="#type_loading_and_conditional_execution">Example 12-2</a>.</p>
<div data-type="example" id="type_loading_and_conditional_execution">
<h5><span class="label">Example 12-2. </span>Type loading and conditional execution</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">static</code> <code class="n">IComparer</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">GetComparer</code><code class="p">(</code><code class="kt">bool</code> <code class="n">useStandardOrdering</code><code class="p">)</code>
<code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="n">useStandardOrdering</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="k">return</code> <code class="n">StringComparer</code><code class="p">.</code><code class="n">CurrentCulture</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">else</code>
    <code class="p">{</code>
        <code class="k">return</code> <code class="k">new</code> <code class="nf">MyCustomComparer</code><code class="p">();</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p><a data-primary="comparison" data-type="indexterm" id="idm45884795982896"/>Depending on its argument, this function either returns an object provided by the runtime libraries’ <code>StringComparer</code> or constructs a new object of type <code>MyCustom​Com⁠parer</code>. The <code>StringComparer</code> type is defined in the same assembly as core types such as <code>int</code> and <code>string</code>, so that will have been loaded when our program started. But suppose the other type, <code>MyCustomComparer</code>, was defined in a separate assembly from my application, called <code>ComparerLib</code>. Obviously, if this <code>GetComparer</code> method is called with an argument of <code>false</code>, the CLR will need to load <code>ComparerLib</code> if it hasn’t already. But what’s slightly more surprising is that it will probably load <code>ComparerLib</code> the first time this method is called even if the argument is <code>true</code>. To be able to JIT compile this <code>GetComparer</code> method, the CLR will need access to the <code>MyCustomComparer</code> type definition—for one thing it will need to check that the type really has a zero-argument constructor. (Obviously <a data-type="xref" href="#type_loading_and_conditional_execution">Example 12-2</a> wouldn’t compile in that case, but it’s possible that code was compiled against a different version of <code>ComparerLib</code> than is present at runtime.) The JIT compiler’s operation is an implementation detail, so it’s not fully documented and could change from one version to the next, but it seems to operate one method at a time. So simply invoking this method is likely to be enough to trigger the loading of the <code>ComparerLib</code> assembly.</p>
<p>This raises the question of how .NET finds assemblies. If assemblies can be loaded implicitly as a result of running a method, we don’t necessarily have a chance to tell the runtime where to find them. So .NET has a mechanism for this.</p>
<section data-pdf-bookmark="Assembly Resolution" data-type="sect2"><div class="sect2" id="idm45884795929424">
<h2>Assembly Resolution</h2>
<p><a data-primary="assemblies" data-secondary="assembly resolution" data-type="indexterm" id="ix_ch12-asciidoc5"/><a data-primary="assembly resolution" data-type="indexterm" id="ix_ch12-asciidoc6"/>When the runtime needs to load an assembly, it goes through a process called <em>assembly resolution</em>. In some cases you will tell .NET to load a particular assembly (e.g., when you first run an application), but the majority are loaded implicitly. The exact mechanism depends on a couple of factors: whether you target .NET/.NET Core or the older .NET Framework, and, if the former, whether your application is <em>self-contained</em>.</p>
<p>.NET (and its predecessor, .NET Core) supports two deployment options for applications: <em>self-contained</em> and <em>framework-dependent</em>. <a data-primary="self-contained applications" data-type="indexterm" id="idm45884795922656"/>When you publish a self-contained application, it includes a complete copy of the runtime and the runtime libraries. <a data-type="xref" href="#publishing_self_contained_app">Example 12-3</a> shows the command line for building an application this way—if you run this from the folder containing a <em>.csproj</em> file, it will compile the project and then produce a <em>publish</em> folder containing your compiled code and a complete copy of a suitable version of .NET. (The version will depend on your project’s configured target framework. Generally, your project file will specify a major and minor version, e.g., <code>net6.0</code>, and then the SDK will copy the latest patch version that is installed on your machine. The available versions will be determined by what versions of the .NET SDK you have installed.) The <code>-r</code> switch indicates the platform and processor architecture to build for. The CLR for Linux is necessarily somewhat different from the one for Windows, and the macOS one is different again. Moreover, for each of the supported operating systems there are versions of .NET available for more than one CPU architecture. (64-bit Intel and 64-bit ARM is supported for all three. Windows and Linux additionally get .NET runtimes targeting 32-bit Intel architecture CPUs and 32-bit ARM CPUs.) The parts of the .NET runtime that contain native runnable binary code are different in each case, so when you ask for a self-contained deployment, the build system needs to know which one to copy. <a data-primary="RID (Runtime Identifier)" data-type="indexterm" id="idm45884795918912"/><a data-primary="Runtime Identifier (RID)" data-type="indexterm" id="idm45884795918240"/><a data-primary="dotnet command line tool" data-secondary="dotnet publish" data-type="indexterm" id="idm45884795917600"/>The <code>-r</code> switch specifies this with something called a <em>Runtime Identifier</em> (RID). <a data-type="xref" href="#publishing_self_contained_app">Example 12-3</a> selects the runtime for Windows running on 64-bit Intel architecture CPUs. (It is possible for RIDs to be more detailed to indicate that your application has minimum version requirements. For example, the first part can be <code>win10</code> instead of just <code>win</code>; for macOS we could use <code>osx-x64</code>, but we can be more specific, e.g., <code>osx.10.15-x64</code>.)</p>
<div data-type="example" id="publishing_self_contained_app">
<h5><span class="label">Example 12-3. </span>Publishing a self-contained application</h5>
<pre data-type="programlisting">dotnet publish -c Release -r win-x64 --self-contained true</pre></div>
<p>When you build this way, assembly resolution is pretty straightforward because everything—your application’s own assemblies, any external libraries you depend on, all of the system assemblies built into .NET, and the CLR itself—ends up in one folder. (At the time of writing, that amounts to a little over 68 MB for a simple “Hello, World!” console application for this target architecture on .NET 6.0.)</p>
<p>There are two main advantages to self-contained deployment. First, there is no need to install .NET on target machines—the application can just run directly because it contains its own copy of .NET. Second, you know exactly what version of .NET and which versions of all DLLs you are running against. Microsoft goes to great lengths to ensure backward compatibility with new releases, but breaking changes can sometimes occur, and a self-contained deployment can be one way out if you find that your application stops working after an update to .NET. With self-contained deployment, unless the application directs the CLR to look elsewhere, everything will load from the application folder, including all assemblies built into .NET.</p>
<p>But what if you don’t want to put an entire copy of .NET into your build output? <a data-primary="framework-dependent application" data-type="indexterm" id="idm45884795910144"/>The default build behavior for applications is to create a framework-dependent executable. (There’s a variation on this called <em>framework-dependent deployment</em>, which is almost the same thing, except it omits the bootstrapper executable. To run a framework-dependent deployment, you will need to use the <code>dotnet</code> command-line tool to launch the runtime, which will then run your application. This has the advantage of being completely platform independent; the bootstrapper in a framework-dependent executable deployment is always OS specific. But it is less convenient—you can’t run the build output without the <code>dotnet</code> tool.) In this case, your code relies on a suitable version of .NET already being installed on the machine. The build output will contain your own application assembly, and may contain assemblies your application depends on, but it will not contain any of the libraries built into .NET.</p>
<p>Framework-dependent applications necessarily use a more complex resolution mechanism than self-contained ones. When such an application starts up, it will first determine exactly which version of .NET to run. This won’t necessarily be the version your application was built against, and there are various options to configure exactly which is chosen. By default, if the same <code><em>Major</em>.<em>Minor</em></code> version is available, that will be used. E.g., if a framework-dependent application built for .NET Core 5.0 runs on a machine with .NET Core versions <code>3.1.20</code>, <code>5.0.11</code>, and <code>6.0.0</code> installed, it will run on <code>5.0.11</code>. In cases where such a match isn’t available, but a major version number match is, it will typically roll forward to that; e.g., if the app targets 3.0, and the machine has only <code>3.1.20</code>, it will run on <code>3.1.20</code>. It is also possible to run on a higher major version number than the app was built against (e.g., build for 3.1 but run on 6.0) but only by explicitly requesting this through configuration.</p>
<p>The chosen runtime version selects not just the CLR but also the assemblies making up the parts of the runtime libraries built into .NET. You can typically find all the installed runtime versions in the <em>C:\Program Files\dotnet\shared\Micro⁠soft.NET​Core.App\</em> folder on Windows, <em>/usr/local/share/dotnet/shared/Microsoft​.NET⁠Core.App</em> on macOS, or <em>/usr/share/dotnet/shared/Microsoft.NETCore.App</em> on Linux, with version-based subfolders such as <em>6.0.0</em>. (You should not rely on these paths—the files may move in future versions of .NET.) The assembly resolution process will look in this version-specific folder, and this is how framework-dependent applications get to use built-in .NET assemblies.</p>
<p>If you poke around these folders, you may notice other folders under <em>shared</em>, such as <em>Microsoft.AspNetCore.App</em>. It turns out that this mechanism is not just for the runtime libraries built into .NET—it is also possible to install the assemblies for whole frameworks. .NET applications declare that they are using a particular application framework. (The build tools automatically produce a file called 
<span class="keep-together"><em>YourApp.runtimeconfig.json</em></span> in your build output declaring the framework you are using. Console apps specify <code>Microsoft.NETCore.App</code>, whereas a web application will specify <code>Microsoft.AspNetCore.App</code>.) This enables applications that target specific Microsoft frameworks not to have to include a complete copy of all of the framework’s DLLs even though that framework is not part of .NET itself.</p>
<p>If you install the plain .NET runtime, you will get just <code>Microsoft.NETCore.App</code> and none of the application frameworks. So applications that target frameworks such as ASP.NET Core or WPF will be unable to run if they are built in the default way, because that presumes that those frameworks will be preinstalled on target machines, and the assembly resolution process will fail to find framework-specific components. The .NET SDK installs these additional framework components, so you won’t see this problem on your development machine, but you might see it when deploying at runtime. You can tell the build tools to include the framework’s components, but this is not normally necessary. If you run your application on a public cloud service such as Azure, these generally preinstall relevant framework components, so in practice you will usually only run into this situation if you are configuring a server yourself or when deploying desktop applications. For those cases, Microsoft offers installers for the .NET runtime that also include the components for web or desktop frameworks.</p>
<p>The <em>shared</em> folder in the <em>dotnet</em> installation folder is not one you should modify yourself. It is intended only for Microsoft’s own frameworks. However, it is possible to install additional system-wide components if you want, because .NET also supports something called the <a data-primary="dotnet command line tool" data-secondary="dotnet store" data-type="indexterm" id="idm45884795894592"/><a data-primary="runtime package store" data-type="indexterm" id="idm45884795893648"/><em>runtime package store</em>. This is an additional directory structured in much the same way as the <em>shared</em> folder just described. You can build a suitable directory layout with the <code>dotnet store</code> command, and if you set the 
<span class="keep-together"><code>DOTNET_SHARED_STORE</code></span> environment variable, the CLR will look in there during assembly resolution. This enables you to play the same trick as is possible with Microsoft’s frameworks: you can build applications that depend on a set of components without needing to include them in your build output, as long as you’ve arranged for those components to be preinstalled on the target machine.</p>
<p>Aside from looking in these two locations for common frameworks, the CLR will also look in the application’s own directory during assembly resolution, just as it would for a self-contained application. Also, the CLR has some mechanisms for enabling updates to be applied. For example, on Windows, it is possible for Microsoft to push out critical updates to .NET components via Windows Update.</p>
<p>But broadly speaking, the basic process of assembly resolution for framework-dependent applications is that implicit assembly loading occurs either from your application directory or from a shared set of components installed on the machine. This is also true for applications running on the older .NET Framework, although the mechanisms are a bit different. It has something called the <em>Global Assembly Cache</em> (GAC), which effectively combines the functionality provided by both of the shared stores in .NET. It is less flexible, because the store location is fixed; .NET’s use of an environment variable opens up the possibility of different shared stores for different applications.<a data-startref="ix_ch12-asciidoc6" data-type="indexterm" id="idm45884795889344"/><a data-startref="ix_ch12-asciidoc5" data-type="indexterm" id="idm45884795888640"/></p>
</div></section>
<section data-pdf-bookmark="Explicit Loading" data-type="sect2"><div class="sect2" id="explicit_loading">
<h2>Explicit Loading</h2>
<p><a data-primary="assemblies" data-secondary="explicit loading" data-type="indexterm" id="idm45884795886384"/>Although the CLR will load assemblies automatically, you can also load them explicitly. For example, if you are creating an application that supports plug-ins, during development you will not know exactly what components you will load at runtime. The whole point of a plug-in system is that it’s extensible, so you’d probably want to load all the DLLs in a particular folder. (You would need to use reflection to discover and make use of the types in those DLLs, as <a data-type="xref" href="ch13.xhtml#ch_reflection">Chapter 13</a> describes.)</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p><a data-primary="dynamic loading" data-type="indexterm" id="idm45884795883600"/><a data-primary="Universal Windows Platform (UWP)" data-type="indexterm" id="idm45884795882896"/><a data-primary="UWP (Universal Windows Platform)" data-type="indexterm" id="idm45884795882256"/>In some scenarios, dynamic loading is restricted. For example, apps built using the UWP and installed from Microsoft’s store can only run code from the components that ship as part of the application. This is because Microsoft runs various tests on these store apps designed to avoid security and stability problems, for which they need access to all of your app’s code. The ability to download and run external code would defeat these checks.</p>
</div>
<p>If you know the full path of an assembly, loading it is very straightforward: you call the <code>Assembly</code> class’s static <code>LoadFrom</code> method, passing the path of the file. The path can be relative to the current directory, or it can be absolute. This static method returns an instance of the <code>Assembly</code> class, which is part of the reflection API. It provides ways of discovering and using the types defined by the assembly.</p>
<p>Occasionally, you might want to load a component explicitly (e.g., to use it via reflection) without wanting to specify the path. For example, you might want to load a particular assembly from the runtime libraries. You should never hardcode the location for a system component—they tend to move from one version of .NET to the next. <a data-primary="typeof operator" data-secondary="assemblies" data-type="indexterm" id="idm45884795878976"/>If your project has a reference to the relevant assembly and you know the name of a type it defines, you can write <code>typeof(TheType).Assembly</code>. But if that’s not an option, you should use the <code>Assembly.Load</code> method, passing the name of the assembly.</p>
<p><code>Assembly.Load</code> uses exactly the same mechanism as implicitly triggered loading. So you can refer to either a component that you’ve installed alongside your application or a system component. In either case, you should specify a full name, which 
<span class="keep-together">must contain name</span> and version information, e.g., <code>ComparerLib, Version=1.0.0.0, Cul⁠ture=neutral, PublicKeyToken=null</code>.</p>
<p>The .NET Framework version of the CLR remembers which assemblies were loaded with <code>LoadFrom</code>. If an assembly loaded in this way triggers the implicit loading of further assemblies, the CLR will search the location from which that assembly was loaded. This means that if your application keeps plug-ins in a separate folder that the CLR would not normally look in, those plug-ins could install other components that they depend on in that same plug-in folder. The CLR will then find them without needing further calls to <code>LoadFrom</code>, even though it would not normally have looked in that folder for an implicitly triggered load. However, .NET and .NET Core do not support this behavior. They provide a different mechanism to support plug-in scenarios.</p>
</div></section>
<section data-pdf-bookmark="Isolation and Plug-ins with AssemblyLoadContext" data-type="sect2"><div class="sect2" id="assembly_load_context">
<h2>Isolation and Plug-ins with AssemblyLoadContext</h2>
<p><a data-primary="assemblies" data-secondary="isolation and plug-ins with AssemblyLoadContext" data-type="indexterm" id="ix_ch12-asciidoc7"/><a data-primary="AssemblyLoadContext" data-type="indexterm" id="ix_ch12-asciidoc8"/>.NET Core introduced a type called <code>AssemblyLoadContext</code>. It enables a degree of isolation between groups of assemblies within a single application.<sup><a data-type="noteref" href="ch12.xhtml#idm45884795868336" id="idm45884795868336-marker">4</a></sup> This solves a problem that can arise in applications that support a plug-in model.</p>
<p>If a plug-in depends on some component that the hosting application also uses, but each wants a different version, this can cause problems if you use the simple mechanisms described in the preceding section. Typically, the .NET runtime <em>unifies</em> these references, loading just a single version. In any cases where the types in that shared component are part of the plug-in interface, this is exactly what you need: if an application requires plug-ins to implement some interface that relies on types from, say, the <code>Newtonsoft.Json</code> library, it’s important that the application and the plug-ins all agree on which version of that library is in use.</p>
<p>But unification can cause problems with components used as implementation details, and not as part of the API between the application and its plug-ins. If the host application uses, say, v3.1 of <code>Microsoft.Extensions.Logging</code> internally, and a plug-in uses v6.0 of the same component, there’s no particular need to unify this to a single version choice at runtime—there would be no harm in the application and plug-in each using the version they require. Unification could cause problems: forcing the plug-in to use v3.1 would cause exceptions at runtime if it attempted to use features only present in v6.0. Forcing the application to use v6.0 could also cause problems because major version number changes often imply that a breaking change was introduced.</p>
<p>To avoid these kinds of problems, you can introduce custom assembly load contexts. You can write a class that derives from <code>AssemblyLoadContext</code>, and for each of these that you instantiate, the .NET runtime creates a corresponding load context that supports loading of different versions of assemblies than may already have been loaded by the application. You can define the exact policy you require by overloading the <code>Load</code> method, as <a data-type="xref" href="#plugin_load_context">Example 12-4</a> shows.</p>
<div data-type="example" id="plugin_load_context">
<h5><span class="label">Example 12-4. </span>A custom <code>AssemblyLoadContext</code> for plug-ins</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">using</code> <code class="nn">System.Reflection</code><code class="p">;</code>
<code class="k">using</code> <code class="nn">System.Runtime.Loader</code><code class="p">;</code>

<code class="k">namespace</code> <code class="nn">HostApp</code><code class="p">;</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">PlugInLoadContext</code> <code class="p">:</code> <code class="n">AssemblyLoadContext</code>
<code class="p">{</code>
    <code class="k">private</code> <code class="k">readonly</code> <code class="n">AssemblyDependencyResolver</code> <code class="n">_resolver</code><code class="p">;</code>
    <code class="k">private</code> <code class="k">readonly</code> <code class="n">ICollection</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">_plugInApiAssemblyNames</code><code class="p">;</code>

    <code class="k">public</code> <code class="nf">PlugInLoadContext</code><code class="p">(</code>
        <code class="kt">string</code> <code class="n">pluginPath</code><code class="p">,</code>
        <code class="n">ICollection</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">plugInApiAssemblies</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">_resolver</code> <code class="p">=</code> <code class="k">new</code> <code class="n">AssemblyDependencyResolver</code><code class="p">(</code><code class="n">pluginPath</code><code class="p">);</code>
        <code class="n">_plugInApiAssemblyNames</code> <code class="p">=</code> <code class="n">plugInApiAssemblies</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">protected</code> <code class="k">override</code> <code class="n">Assembly</code> <code class="nf">Load</code><code class="p">(</code><code class="n">AssemblyName</code> <code class="n">assemblyName</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="k">if</code> <code class="p">(!</code><code class="n">_plugInApiAssemblyNames</code><code class="p">.</code><code class="n">Contains</code><code class="p">(</code><code class="n">assemblyName</code><code class="p">.</code><code class="n">Name</code><code class="p">!))</code>
        <code class="p">{</code>
            <code class="kt">string?</code> <code class="n">assemblyPath</code> <code class="p">=</code> <code class="n">_resolver</code><code class="p">.</code><code class="n">ResolveAssemblyToPath</code><code class="p">(</code><code class="n">assemblyName</code><code class="p">);</code>
            <code class="k">if</code> <code class="p">(</code><code class="n">assemblyPath</code> <code class="p">!=</code> <code class="k">null</code><code class="p">)</code>
            <code class="p">{</code>
                <code class="k">return</code> <code class="nf">LoadFromAssemblyPath</code><code class="p">(</code><code class="n">assemblyPath</code><code class="p">);</code>
            <code class="p">}</code>
        <code class="p">}</code>

        <code class="k">return</code> <code class="n">AssemblyLoadContext</code><code class="p">.</code><code class="n">Default</code><code class="p">.</code><code class="n">LoadFromAssemblyName</code><code class="p">(</code>
            <code class="n">assemblyName</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>This takes the location of the plug-in DLL, along with a list of the names of any special assemblies where the plug-in must use the same version as the host application. (This would include interfaces defining types used in your plug-in interface. You don’t need to include assemblies that are included as part of .NET itself—these are always unified, even if you use custom load contexts.) The runtime will call this class’s <code>Load</code> method each time an assembly is loaded in this context. This code checks to see whether the assembly being loaded is one of the special ones that must be common to plug-ins and the host application. If not, this looks in the plug-in’s folder to see if the plug-in has supplied its own version of that assembly. In cases where it will not use an assembly from the plug-in folder (either because the plug-in hasn’t supplied this particular assembly or because it is one of the special ones), this context defers to <code>AssemblyLoadContext.Default</code>, meaning that the application host and plug-in use the same assemblies in these cases. <a data-type="xref" href="#using_plugin_load_context">Example 12-5</a> shows this in use.<a data-primary="typeof operator" data-secondary="assemblies" data-type="indexterm" id="idm45884795853904"/></p>
<div data-type="example" id="using_plugin_load_context">
<h5><span class="label">Example 12-5. </span>Using the plug-in load context</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">Assembly</code><code class="p">[]</code> <code class="n">plugInApiAssemblies</code> <code class="p">=</code>
<code class="p">{</code>
    <code class="k">typeof</code><code class="p">(</code><code class="n">IPlugIn</code><code class="p">).</code><code class="n">Assembly</code><code class="p">,</code>
    <code class="k">typeof</code><code class="p">(</code><code class="n">JsonReader</code><code class="p">).</code><code class="n">Assembly</code>
<code class="p">};</code>
<code class="kt">var</code> <code class="n">plugInAssemblyNames</code> <code class="p">=</code> <code class="k">new</code> <code class="n">HashSet</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;(</code>
    <code class="n">plugInApiAssemblies</code><code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">a</code> <code class="p">=&gt;</code> <code class="n">a</code><code class="p">.</code><code class="n">GetName</code><code class="p">().</code><code class="n">Name</code><code class="p">!));</code>

<code class="kt">var</code> <code class="n">ctx</code> <code class="p">=</code> <code class="k">new</code> <code class="n">PlugInLoadContext</code><code class="p">(</code><code class="n">plugInDllPath</code><code class="p">,</code> <code class="n">plugInAssemblyNames</code><code class="p">);</code>
<code class="n">Assembly</code> <code class="n">plugInAssembly</code> <code class="p">=</code> <code class="n">ctx</code><code class="p">.</code><code class="n">LoadFromAssemblyPath</code><code class="p">(</code><code class="n">plugInDllPath</code><code class="p">);</code></pre></div>
<p>This builds a list of assemblies that the plug-in and application must share, and passes their names into the plug-in context, along with a path to the plug-in DLL. Any DLLs that the plug-in depends on and that are copied into the same folder as the plug-in will be loaded, unless they are in that list, in which case the plug-in will use the same assembly as the host application itself<a data-startref="ix_ch12-asciidoc8" data-type="indexterm" id="idm45884795619120"/><a data-startref="ix_ch12-asciidoc7" data-type="indexterm" id="idm45884795594400"/>.<a data-startref="ix_ch12-asciidoc4" data-type="indexterm" id="idm45884795593664"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Assembly Names" data-type="sect1"><div class="sect1" id="assembly_names">
<h1>Assembly Names</h1>
<p><a data-primary="assemblies" data-secondary="names" data-type="indexterm" id="ix_ch12-asciidoc9"/>Assembly names are structured. <a data-primary="simple name" data-type="indexterm" id="idm45884795590080"/>They always include a <em>simple name</em>, which is the name by which you would normally refer to the DLL, such as <em>MyLibrary</em> or 
<span class="keep-together"><em>System.Runtime</em>.</span> This is usually the same as the filename but without the extension. It doesn’t technically have to be,<sup><a data-type="noteref" href="ch12.xhtml#fn35" id="fn35-marker">5</a></sup> but the assembly resolution mechanism assumes that it is. Assembly names always include a version number. <a data-primary="public key token" data-type="indexterm" id="idm45884795585776"/>There are also some optional components, including the <em>public key token</em>, a string of hexadecimal digits, which makes it possible to give an assembly a unique name.</p>
<section data-pdf-bookmark="Strong Names" data-type="sect2"><div class="sect2" id="strong_names">
<h2>Strong Names</h2>
<p><a data-primary="assemblies" data-secondary="strong names" data-type="indexterm" id="ix_ch12-asciidoc10"/>If an assembly’s name includes a public key token, it is said to be a <em>strong name</em>. Microsoft advises that any .NET component that targets .NET Framework and is published for shared use (e.g., made available via NuGet) should have a strong name. However, if you are writing a new component that will only run on .NET Core or .NET, there are no benefits to strong naming, because these newer runtimes essentially ignore the public key token.</p>
<p>Since the purpose of strong naming is to make the name unique, you may be wondering why assemblies do not simply use a Globally Unique Identifier (GUID). The answer is that historically, strong names also did another job: they were designed to provide some degree of assurance that the assembly has not been tampered with. Early versions of .NET checked strongly named assemblies for tampering at runtime, but these checks were removed because they imposed a considerable runtime overhead, often for little or no benefit. Microsoft’s documentation now explicitly advises against treating strong names as a security feature. However, in order to understand and use strong names, you need to know how they were originally meant to work.</p>
<p>As the terminology suggests, an assembly name’s public key token has a connection with cryptography. It is the hexadecimal representation of a 64-bit hash of a public key. Strongly named assemblies are required to contain a copy of the full public key from which the hash was generated. The assembly file format also provides space for a digital signature, generated with the corresponding private key.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45884795579536">
<h5>Asymmetric Encryption</h5>
<p><a data-primary="assemblies" data-secondary="asymmetric encryption" data-type="indexterm" id="idm45884795578336"/><a data-primary="asymmetric encryption" data-type="indexterm" id="idm45884795577360"/><a data-primary="encryption, asymmetric" data-type="indexterm" id="idm45884795576688"/>If you’re not familiar with asymmetric encryption, this is not the place for a thorough introduction, but here’s a very rough summary. Strong names use an encryption algorithm called RSA, which works with a pair of keys: the public key and the private key. Messages encrypted with the public key can be decrypted only with the private key, and vice versa. This enables the creation of a digital signature for an assembly: to sign an assembly, you calculate a hash of its contents and then encrypt that hash with the private key. This signature is then copied into the assembly, and its validity can be verified by anyone with access to the public key—they can calculate the hash of the assembly’s contents themselves, and they can decrypt your signature with the public key, and if the results are different, the signature is invalid, implying either that it was not produced by the owner of the private key or that the file has been modified since the signature was generated, so the file is suspect. The mathematics of encryption are such that it is thought to be essentially impossible to create a valid-looking signature unless you have access to the private key, and it’s also essentially impossible to modify the assembly without modifying the hash. And in cryptography, “essentially impossible” means “theoretically possible but too computationally expensive to be practical, unless some major unexpected breakthrough in number theory or perhaps quantum computing emerges, rendering most current cryptosystems useless.”</p>
</div></aside>
<p>The uniqueness of a strong name relies on the fact that key generation systems use cryptographically secure random-number generators, and the chances of two people generating two key pairs with the same public key token are vanishingly small. The assurance that the assembly has not been tampered with comes from the fact that a strongly named assembly must be signed, and only someone in possession of the private key can generate a valid signature. Any attempt to modify the assembly after signing it will invalidate the signature.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a data-primary="Authenticode" data-type="indexterm" id="idm45884795573184"/>The signature associated with a strong name is independent of Authenticode, a longer-established code signing mechanism in Windows. These serve different purposes. Authenticode provides traceability, because the public key is wrapped in a certificate that tells you something about where the code came from. With a strong name’s public key token, all you get is a number, so unless you happen to know who owns that token, it tells you nothing. Authenticode lets you ask, “Where did this component come from?” A public key token lets you say, “This is the component I want.” It’s common for a single .NET component to use both mechanisms.</p>
</div>
<p>If an assembly’s private key becomes public knowledge, anyone can generate valid-looking assemblies with the corresponding key token. Some open source projects deliberately publish both keys so that anyone can build the components from source. This completely abandons any security the key token could offer, but that’s fine because Microsoft now recommends that we not treat strong names as a security feature. The practice of publishing your strong naming private key recognizes that it is useful to have a unique name, even without a guarantee of authenticity. .NET Core (and thus .NET) took this one step further, by making it possible for components to have a strong name without needing to use a private key at all. In keeping with Microsoft’s adoption of open source development, this means you can now build and use your own versions of Microsoft-authored components that have the same strong name, even though Microsoft has not published its private key. See the next sidebar, <a href="#strong_name_keys_and_public_signing">“Strong Name Keys and Public Signing”</a>, for information on how to work with keys.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="strong_name_keys_and_public_signing">
<h5>Strong Name Keys and Public Signing</h5>
<p><a data-primary="assemblies" data-secondary="public signing" data-type="indexterm" id="idm45884795569696"/>There are three popular approaches for working with strong names. The simplest is to use the real names throughout the development process and to copy the public and private keys to all developers’ machines so that they can sign the assemblies every time they build. This approach is viable only if you don’t want to keep the private key secret, because it’s easy for developers to compromise the secrecy of the private key either accidentally or deliberately. Since strong names no longer offer security, there’s nothing wrong with this. However, some organizations nonetheless attempt to keep their private keys secret as a matter of policy, so you may encounter other ways of working.</p>
<p>Another approach is to use a completely different set of keys during development, switching to the real name only for designated release builds. This avoids the need for all developers to have a copy of the real private key, but it can cause confusion, because developers may end up with two sets of components on their machines, one with development names and one with real names.</p>
<p>The third approach is to use the real names across the board, but instead of signing every build just filling the part of the file reserved for the signature with 0 values. <a data-primary="Public Signing" data-type="indexterm" id="idm45884795567760"/>.NET and .NET Core call this <em>Public Signing</em>, and it’s more of a convention than a feature: it works because these runtimes never check the signatures of strongly named assemblies. (.NET Framework does still check signatures in certain cases. For example, to install an assembly in the GAC, it must have a strong name with a valid signature. It has a slightly more complex mechanism called <em>Delay Signing</em>, which makes you jump through a few more hoops, but the effect is the same: developers can compile assemblies that have the real strong names without then needing to generate signatures.)</p>
<p>You can generate a key file for a strong name with a command-line utility called <em>sn</em> (short for <em>strong name</em>).</p>
</div></aside>
<p><a data-primary="mscorlib assembly" data-type="indexterm" id="idm45884795564496"/>Microsoft uses the same token on most of the assemblies in the runtime libraries. (Many groups at Microsoft produce .NET components, so this token is common only to the components that are part of .NET, not for Microsoft as a whole.) Here’s the full name of <code>mscorlib</code>, a system assembly that offers definitions of various core types such as <code>System.String</code>:</p>
<pre data-type="programlisting">mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</pre>
<p>By the way, that’s the right name even for the latest versions of .NET at the time of writing. The <code>Version</code> is <code>4.0.0.0</code> even though .NET Framework is now on v4.8, and .NET on 6.0. (In .NET and .NET Core, <code>mscorlib</code> contains nothing but type forwarders, because the relevant types have moved, mostly to <code>System.Private.CoreLib</code>. And while that real home of these types is now on version <code>6.0.0.0</code>, the <code>mscorlib</code> version number remains the same.) Assembly version numbers have technical significance, so Microsoft does not always update the version number in the names of library components in step with the marketing version numbers—the versions don’t necessarily even match on the major number. The .NET 3.5 version of <code>mscorlib</code> had a version number of <code>2.0.0.0</code>, for example.</p>
<p>While the public key token is an optional part of an assembly’s name, the version is mandatory.<a data-startref="ix_ch12-asciidoc10" data-type="indexterm" id="idm45884795556992"/></p>
</div></section>
<section data-pdf-bookmark="Version" data-type="sect2"><div class="sect2" id="version">
<h2>Version</h2>
<p><a data-primary="assemblies" data-secondary="version number in name" data-type="indexterm" id="ix_ch12-asciidoc11"/><a data-primary="versioning" data-secondary="assembly names" data-type="indexterm" id="ix_ch12-asciidoc12"/>All assembly names include a four-part version number. When an assembly name is represented as a string (e.g., when you pass one as an argument to <code>Assembly.Load</code>), the version consists of four decimal integers separated by dots (e.g., <code>4.0.0.0</code>). The binary format that IL uses for assembly names and references limits the range of these numbers—each part must fit in a 16-bit unsigned integer (a <code>ushort</code>), and the highest allowable value in a version part is actually one less than the maximum value that would fit, making the highest legal version number <code>65534.65534.65534.65534</code>.</p>
<p>Each of the four parts has a name. From left to right, they are the <em>major version</em>, the <em>minor version</em>, the <em>build</em>, and the <em>revision</em>. However, there’s no particular significance to any of these names. Some developers use certain conventions, but nothing checks or enforces them. A common convention is that any change in the public API requires a change to either the major or minor version number, and a change likely to break existing code should involve a change of the major number. (Marketing is another popular reason for a major version change.) If an update is not intended to make any visible changes to behavior (except, perhaps, fixing a bug), changing the build number is sufficient. The revision number could be used to distinguish between two components that you believe were built against the same source but not at the same time. Alternatively, some people relate the version numbers to branches in source control, so a change in just the revision number might indicate a patch applied to a version that has long since stopped getting major updates. However, you’re free to make up your own meanings. As far as the CLR is concerned, there’s really only one interesting thing you can do with a version number, which is to compare it with some other version number—either they match or one is higher than the other.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a data-primary="NuGet" data-type="indexterm" id="idm45884795545120"/>NuGet packages also have version numbers, and these do not need to be connected in any way to assembly versions. Many package authors make them similar by convention, but this is not universal. NuGet <em>does</em> treat the components of a package version number as having particular significance: it has adopted the widely used <em>semantic versioning</em> rules. This uses versions with three parts, named major, minor, and patch.</p>
</div>
<p>Version numbers in runtime library assembly names ignore all the conventions I have just described. Most of the components had the same version number (<code>2.0.0.0</code>) across four major updates. With .NET 4.0, everything changed to <code>4.0.0.0</code>, which is still in use with the latest version of .NET Framework (4.8), at the time of writing. .NET Core 3.1 also uses 4 as the major version of most of its runtime library components. <a data-primary=".NET 6.0" data-primary-sortas="NET 6.0" data-secondary="version numbers in runtime library assembly names" data-type="indexterm" id="idm45884795541888"/>In .NET 6.0, many of these components now have a matching major version of 6, but as you’ve seen with its copy of <code>mscorlib</code>, that’s not universal.</p>
<p>You typically specify the version number by adding a <code>&lt;Version&gt;</code> element inside a <code>&lt;PropertyGroup&gt;</code> of your <em>.csproj</em> file. (Visual Studio also offers a UI for this: if you open the Properties page for the project, its Package section lets you configure various naming-related settings. The “Package version” field sets the version.) The build system uses this in two ways: it sets the version number on the assembly, but, if you generate a NuGet package for your project, by default it will also use this same version number for the package, and since NuGet version numbers have three parts, you normally specify just three numbers here, and the fourth part of the assembly version will default to zero. (If you really want to specify all four digits, consult the documentation for how to set the assembly and NuGet versions separately.)</p>
<p>The build system tells the compiler which version number to use for the assembly name via an assembly-level attribute. I’ll describe attributes in more detail in <a data-type="xref" href="ch14.xhtml#ch_attributes">Chapter 14</a>, but this one’s pretty straightforward. If you want to find it, the build system typically generates a file called <em>ProjectName.AssemblyInfo.cs</em> in a subfolder of your project’s <em>obj</em> folder. This contains various attributes describing details about the assembly, including an <code>AssemblyVersion</code> attribute, such as the one shown in <a data-type="xref" href="#specifying_an_assembly_version">Example 12-6</a>.</p>
<div data-type="example" id="specifying_an_assembly_version">
<h5><span class="label">Example 12-6. </span>Specifying an assembly’s version</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="na">[assembly: System.Reflection.AssemblyVersion("1.0.0.0")]</code></pre></div>
<p>The C# compiler provides special handling for this attribute—it does not apply it blindly as it would most attributes. It parses the version number and embeds it in the way required by .NET’s metadata format. It also checks that the string conforms to the expected format and that the numbers are in the allowed range.</p>
<p>By the way, the version that forms part of an assembly’s name is distinct from the one stored using the standard Win32 mechanism for embedding versions. Most .NET files contain both kinds. By default, the build system will use the <code>&lt;Version&gt;</code> setting for both, but it’s common for the file version to change more frequently. This was particularly important with .NET Framework, in which only a single instance of any major version can be installed at once—if a machine has .NET Framework 4.7.2 installed and you install .NET Framework 4.8, that will replace version 4.7.2. (.NET and .NET Core don’t do this—you can install any number of versions side by side on a single computer.) This in-place updating combined with Microsoft’s tendency to keep assembly versions the same across releases could make it hard to work out exactly what is installed, at which point the file version becomes important. On a computer with .NET Framework 4.0 sp1 installed, its version of <em>mscorlib.dll</em> had a Win32 version number of <code>4.0.30319.239</code>, but if you’ve installed .NET 4.8, this changes to <code>4.8.4420.0</code>, but the assembly version remains at <code>4.0.0.0</code>. (As service packs and other updates are released, the last part will keep climbing.)</p>
<p>By default, the build system will use the <code>&lt;Version&gt;</code> for both the assembly and Windows file versions, but if you want to set the file version separately, you can add a <code>&lt;FileVersion&gt;</code> to your project file. (Visual Studio’s project properties Package section also lets you set this.) Under the covers, this works with another attribute that gets special handling from the compiler, <code>AssemblyFileVersion</code>. It causes the compiler to embed a Win32 version resource in the file, so this is the version number users see if they right-click your assembly in Windows Explorer and show the 
<span class="keep-together">file properties.</span></p>
<p>This file version is usually a more appropriate place to put a version number that identifies the build provenance than the version that goes into the assembly name. The latter is really a declaration of the supported API version, and any updates that are designed to be fully backward compatible should probably leave it unaltered and should change only the file version.</p>
</div></section>
<section data-pdf-bookmark="Version Numbers and Assembly Loading" data-type="sect2"><div class="sect2" id="version_numbers_and_assembly_loading">
<h2>Version Numbers and Assembly Loading</h2>
<p><a data-primary="assemblies" data-secondary="version numbers and assembly loading" data-type="indexterm" id="idm45884795495584"/><a data-primary="versioning" data-secondary="version numbers and assembly loading" data-type="indexterm" id="idm45884795494416"/><a data-primary="mscorlib assembly" data-type="indexterm" id="idm45884795493504"/>Since version numbers are part of an assembly’s name (and therefore its identity), they are also, ultimately, part of a type’s identity. The <code>System.String</code> in <code>mscorlib</code> version <code>2.0.0.0</code> is not the same thing as the type of the same name in <code>mscorlib</code> version <code>4.0.0.0</code>.</p>
<p>The handling of assembly version numbers changed with .NET Core. In .NET Framework, when you load a strongly named assembly by name (either implicitly by using types it defines or explicitly with <code>Assembly.Load</code>), the CLR requires the <span class="keep-together">version</span> number to be an exact match.<sup><a data-type="noteref" href="ch12.xhtml#fn36" id="fn36-marker">6</a></sup> .NET Core relaxed this, so if the version on disk has a version number equal to or higher than the version requested, it will use it. There are two factors behind this change. The first is that the .NET development ecosystem has come to rely on NuGet (which didn’t even exist for most of the first decade of .NET’s existence), meaning that it has become increasingly common to depend on fairly large numbers of external components. Second, the rate of change has increased—in the early days we would often need to wait for years between new releases of .NET components. (Security patches and other bug fixes might turn up more often, but new functionality would tend to emerge slowly, and typically in big chunks, as part of a whole wave of updates to the runtime, frameworks, and development tools.) But today, it can be rare for an application to go for as long as a month without the version of some component somewhere changing. .NET Framework’s strict versioning policy now looks unhelpful. (In fact, there are parts of the build system dedicated to digging through your NuGet dependencies, working out the specific versions of each component you’re using, and automatically generating a configuration file with a vast number of version substitution rules telling the CLR to use those versions no matter which version any single assembly says it wants. So even if you target the .NET Framework, the build system will, by default, effectively disable strict versioning.)</p>
<p>Another change is that .NET Framework only takes assembly versions into account for strongly named assemblies. .NET Core and .NET check that the version number of the assembly on disk is equal to or greater than the required version regardless of whether the target assembly is strongly named.<a data-startref="ix_ch12-asciidoc12" data-type="indexterm" id="idm45884795518352"/><a data-startref="ix_ch12-asciidoc11" data-type="indexterm" id="idm45884795517648"/></p>
</div></section>
<section data-pdf-bookmark="Culture" data-type="sect2"><div class="sect2" id="culture">
<h2>Culture</h2>
<p><a data-primary="assemblies" data-secondary="culture component of names" data-type="indexterm" id="ix_ch12-asciidoc13"/><a data-primary="culture, assembly names and" data-type="indexterm" id="ix_ch12-asciidoc14"/>So far we’ve seen that assembly names include a simple name, a version number, and optionally a public key token. They also have a <em>culture</em> component. (A culture represents a language and a set of conventions, such as currency, spelling variations, and date formats.) This is not optional, although the most common value for this is the default: <code>neutral</code>, indicating that the assembly contains no culture-specific code or data. The culture is usually set to something else only on assemblies that contain culture-specific resources. The culture of an assembly’s name is designed to support localization of resources such as images and strings. To show how, I’ll need to explain the localization mechanism that uses it.</p>
<p>All assemblies can contain embedded binary streams. (You can put text in these streams, of course. You just have to pick a suitable encoding.) <a data-primary="ResourceManager class" data-type="indexterm" id="ix_ch12-asciidoc15"/>The <code>Assembly</code> class in the reflection API provides a way to work directly with these, but it’s more common to use the <code>ResourceManager</code> class in the <code>System.Resources</code> namespace. This is far more convenient than working with the raw binary streams, because the <code>ResourceManager</code> defines a container format that allows a single stream to hold any number of strings, images, sound files, and other binary items, and Visual Studio has a built-in editor for working with this container format. The reason I’m mentioning all of this in the middle of a section that’s ostensibly about assembly names is that <code>ResourceManager</code> also provides localization support, and the assembly name’s culture is part of that mechanism. To demonstrate how this works, I’ll walk you through a quick example.</p>
<p>The easiest way to use the <code>ResourceManager</code> is to add a resource file in the <em>.resx</em> format to your project. (This is not the format used at runtime. It’s an XML format that gets compiled into the binary format required by <code>ResourceManager</code>. It’s easier to work with text than binary in most source control systems. It also makes it possible to work with these files if you’re using an editor without built-in support for the format.) To add one of these from Visual Studio’s Add New Item dialog, select the Visual C#→General category, and then choose Resources File. I’ll call mine <em>MyResources.resx</em>. Visual Studio will show its resource editor, which opens in string editing mode, as <a data-type="xref" href="#resource_file_editor_in_string_mode">Figure 12-1</a> shows. As you can see, I’ve defined a single string with a name of <code>ColString</code> and a value of <code>Color</code>.</p>
<figure><div class="figure" id="resource_file_editor_in_string_mode">
<img alt="Resource file editor in string mode" height="174" src="assets/pc10_1201.png" width="600"/>
<h6><span class="label">Figure 12-1. </span>Resource file editor in string mode</h6>
</div></figure>
<p>I can retrieve this value at runtime. The build system generates a wrapper class for each <em>.resx</em> file you add, with a static property for each resource you define. This makes it very easy to look up a string resource, as <a data-type="xref" href="#retrieving_a_resource_with_the_wrapper_c">Example 12-7</a> shows.</p>
<div data-type="example" id="retrieving_a_resource_with_the_wrapper_c">
<h5><span class="label">Example 12-7. </span>Retrieving a resource with the wrapper class</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">string</code> <code class="n">colText</code> <code class="p">=</code> <code class="n">MyResources</code><code class="p">.</code><code class="n">ColString</code><code class="p">;</code></pre></div>
<p>The wrapper class hides the details, which is usually convenient, but in this case, the details are the whole reason I’m demonstrating a resource file, so I’ve shown how to use the <code>ResourceManager</code> directly in <a data-type="xref" href="#retrieving_a_resource_at_runtime">Example 12-8</a>. I’ve included the entire source for the file, because namespaces are significant here—the build tools prepend your project’s default namespace to the embedded resource stream name, so I’ve had to ask for <code>ResourceExample.MyResources</code> instead of just <code>MyResources</code>. (If I had put the resources in a subfolder, the tools would also include the name of that folder in the resource stream name.)<a data-primary="typeof operator" data-secondary="assemblies" data-type="indexterm" id="idm45884795468096"/></p>
<div data-type="example" id="retrieving_a_resource_at_runtime">
<h5><span class="label">Example 12-8. </span>Retrieving a resource at runtime</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">using</code><code> </code><code class="nn">System.Resources</code><code class="p">;</code><code>
</code><code>
</code><code class="k">namespace</code><code> </code><code class="nn">ResourceExample</code><code class="p">;</code><code>
</code><code>
</code><code class="k">class</code><code> </code><code class="nc">Program</code><code>
</code><code class="p">{</code><code>
</code><code>    </code><code class="k">static</code><code> </code><code class="k">void</code><code> </code><code class="nf">Main</code><code class="p">(</code><code class="kt">string</code><code class="p">[</code><code class="p">]</code><code> </code><code class="n">args</code><code class="p">)</code><code>
</code><code>    </code><code class="p">{</code><code>
</code><code>        </code><strong><code class="kt">var</code><code> </code><code class="n">rm</code><code> </code><code class="p">=</code><code> </code><code class="k">new</code><code> </code><code class="n">ResourceManager</code><code class="p">(</code></strong><code>
</code><code>            </code><strong><code class="s">"ResourceExample.MyResources"</code><code class="p">,</code><code> </code><code class="k">typeof</code><code class="p">(</code><code class="n">Program</code><code class="p">)</code><code class="p">.</code><code class="n">Assembly</code><code class="p">)</code><code class="p">;</code></strong><code>
</code><code>        </code><strong><code class="kt">string</code><code> </code><code class="n">colText</code><code> </code><code class="p">=</code><code> </code><code class="n">rm</code><code class="p">.</code><code class="n">GetString</code><code class="p">(</code><code class="s">"ColString"</code><code class="p">)</code><code class="p">!</code><code class="p">;</code></strong><code>
</code><code>        </code><code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"And now in "</code><code> </code><code class="p">+</code><code> </code><code class="n">colText</code><code class="p">)</code><code class="p">;</code><code>
</code><code>    </code><code class="p">}</code><code>
</code><code class="p">}</code></pre></div>
<p>So far, this is just a rather long-winded way of getting hold of the string <code>"Color"</code>. However, now that we’ve got a <code>ResourceManager</code> involved, I can define some localized resources. Being British, I have strong opinions on the correct way to spell the word <em>color</em>. They are not consistent with O’Reilly’s editorial policy, and in any case I’m happy to adapt my work for my predominantly American readership. But a program can do better—it should be able to provide different spellings for different audiences. (And taking it a step further, it should be able to change the language entirely for countries in which some form of English is not the predominant language.) In fact, my program already contains all the code it needs to support localized spellings of the word <em>color</em>. I just need to provide it with the alternative text.</p>
<p>I can do this by adding a second resource file with a carefully chosen name: 
<span class="keep-together"><em>MyResources.en-GB.resx</em>.</span> That’s almost the same as the original but with an extra 
<span class="keep-together"><em>.en-GB</em></span> before the <em>.resx</em> extension. That is short for English-Great Britain, and it is the standardized (albeit politically tone-deaf) name of the culture for my home. (The name for the culture that denotes English-speaking parts of the US is <em>en-US</em>.) Having added such a file to my project, I can add a string entry with the same name as before, <code>ColString</code>, but this time with the correct (where I’m sitting<sup><a data-type="noteref" href="ch12.xhtml#fn37" id="fn37-marker">7</a></sup>) value of <code>Colour</code>. If you run the application on a machine configured with a British locale, it will use the British spelling. The odds are that your machine is not configured for this locale, so if you want to try this, you can add the code in <a data-type="xref" href="#forcing_a_nondefault_culture">Example 12-9</a> at the very start of the <code>Main</code> method in <a data-type="xref" href="#retrieving_a_resource_at_runtime">Example 12-8</a> to force .NET to use the British culture when looking up resources.</p>
<div data-type="example" id="forcing_a_nondefault_culture">
<h5><span class="label">Example 12-9. </span>Forcing a nondefault culture</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">Thread</code><code class="p">.</code><code class="n">CurrentThread</code><code class="p">.</code><code class="n">CurrentUICulture</code> <code class="p">=</code>
    <code class="k">new</code> <code class="n">System</code><code class="p">.</code><code class="n">Globalization</code><code class="p">.</code><code class="n">CultureInfo</code><code class="p">(</code><code class="s">"en-GB"</code><code class="p">);</code></pre></div>
<p>How does this relate to assemblies? Well, if you look at the compiled output, you’ll see that, as well as the usual executable file and related debug files, the build process has created a subdirectory called <em>en-GB</em>, which contains an assembly file called <em>ResourceExample.resources.dll</em>. (<em>ResourceExample</em> is the name of my project. If you created a project called <em>SomethingElse</em>, you’d see <em>SomethingElse.resources.dll</em>.) That assembly’s name will look like this:</p>
<pre data-type="programlisting">ResourceExample.resources, Version=1.0.0.0, Culture=en-GB, PublicKeyToken=null</pre>
<p>The version number and public key token will match those for the main project—in my example, I’ve left the default version number, and I’ve not given my assembly a strong name. But notice the <code>Culture</code>. Instead of the usual <code>neutral</code> value, I’ve got <code>en-GB</code>, the same culture string I specified in the filename for the second resource file I added. <a data-primary="satellite resource assemblies" data-type="indexterm" id="idm45884795303056"/>If you add more resource files with other culture names, you’ll get a folder containing a culture-specific assembly for each culture you specify. These are called <em>satellite resource assemblies</em>.</p>
<p>When you first ask a <code>ResourceManager</code> for a resource, it will look for a satellite resource assembly with the same culture as the thread’s current UI culture. So it would attempt to load an assembly using the name shown a couple of paragraphs ago. If it doesn’t find that, it tries a more generic culture name—if it fails to find <code>en-GB</code> resources, it will look for a culture called just <code>en</code>, denoting the English language without specifying any particular region. Only if it finds neither (or if it finds matching assemblies, but they do not contain the resource being looked up) does it fall back to the neutral resource built into the main assembly.</p>
<p>The CLR’s assembly loader looks in different places when a nonneutral culture is specified. It looks in a subdirectory named for the culture. That’s why the build process placed my satellite resource assembly in an <em>en-GB</em> folder.</p>
<p>The search for culture-specific resources incurs some runtime costs. These are not large, but if you’re writing an application that will never be localized, you might want to avoid paying the price for a feature you’re not using. You might still want to use the <code>ResourceManager</code>, however—it’s a more convenient way to embed resources than using assembly manifest resource streams directly. The way to avoid the costs is to tell .NET that the resources built directly into your main assembly are the right ones for a particular culture. You can do this with the assembly-level attribute shown in <a data-type="xref" href="#specifying_the_culture_for_built-in_reso">Example 12-10</a>.</p>
<div data-type="example" id="specifying_the_culture_for_built-in_reso">
<h5><span class="label">Example 12-10. </span>Specifying the culture for built-in resources</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="na">[assembly: NeutralResourcesLanguage("en-US")]</code></pre></div>
<p>When an application with that attribute runs on a machine in the usual US locale, the <code>ResourceManager</code> will not attempt to search for resources. It will just go straight for the ones compiled into your main<a data-startref="ix_ch12-asciidoc15" data-type="indexterm" id="idm45884795252928"/> assembly<a data-startref="ix_ch12-asciidoc14" data-type="indexterm" id="idm45884795292512"/><a data-startref="ix_ch12-asciidoc13" data-type="indexterm" id="idm45884795291904"/>.<a data-startref="ix_ch12-asciidoc9" data-type="indexterm" id="idm45884795291168"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Protection" data-type="sect1"><div class="sect1" id="protection">
<h1>Protection</h1>
<p><a data-primary="assemblies" data-secondary="protection" data-type="indexterm" id="idm45884795289504"/>In <a data-type="xref" href="ch03.xhtml#ch_types">Chapter 3</a>, I described some of the accessibility specifiers you can apply to types and their members, such as <code>private</code> or <code>public</code>. In <a data-type="xref" href="ch06.xhtml#ch_inheritance">Chapter 6</a>, I showed some of the additional mechanisms available when you use inheritance. It’s worth quickly revisiting these features, because assemblies play a part.</p>
<p><a data-primary="internal members" data-type="indexterm" id="idm45884795263440"/><a data-primary="internal types" data-type="indexterm" id="idm45884795262736"/>Also in <a data-type="xref" href="ch03.xhtml#ch_types">Chapter 3</a>, I introduced the <code>internal</code> keyword and said that classes and methods with this accessibility are available only within the same <em>component</em>, a slightly vague term that I chose because I had not yet introduced assemblies. 
<span class="keep-together">Now that it’s clear</span> what an assembly is, it’s safe for me to say that a more precise 
<span class="keep-together">description</span> of the <code>internal</code> keyword is that it indicates that a member or type should be accessible only to code in the same assembly.<sup><a data-type="noteref" href="ch12.xhtml#fn38" id="fn38-marker">8</a></sup> Likewise, <code>protected internal</code> members are available to code in derived types, and also to code defined in the same assembly, and the similar but more restrictive <code>protected private</code> protection level makes members available only to code that is in a derived type that is defined in the same assembly.</p>
</div></section>
<section data-pdf-bookmark="Target Frameworks and .NET Standard" data-type="sect1"><div class="sect1" id="targets_and_net_standard">
<h1>Target Frameworks and .NET Standard</h1>
<p><a data-primary=".NET 6.0" data-primary-sortas="NET 6.0" data-secondary="target frameworks and .NET Standard" data-type="indexterm" id="idm45884795234240"/><a data-primary=".NET Standard" data-primary-sortas="NET Standard" data-type="indexterm" id="idm45884795232688"/><a data-primary="assemblies" data-secondary="target frameworks and .NET Standard" data-type="indexterm" id="idm45884795231744"/><a data-primary="target frameworks" data-type="indexterm" id="idm45884795230832"/>One of the decisions you need to make for each assembly that you build is the target framework or frameworks you will support. Each <em>.csproj</em> file will have either a <code>&lt;TargetFramework&gt;</code> element indicating the target or a <code>&lt;TargetFrameworks&gt;</code> element containing a list of frameworks. The particular target is indicated with a <em>target framework moniker</em> (TFM). For example, <code>netcoreapp3.1</code> identifies .NET Core 3.1, and then with .NET 5.0 the naming convention changed, so we have <code>net5.0</code> and <code>net6.0</code> for .NET 5.0 and .NET 6.0, respectively. For the .NET Framework 4.6.2, 4.7.2, and 4.8, the TFMs are <code>net462</code>, <code>net472</code>, and <code>net48</code>, respectively. When you list multiple target frameworks, you will get multiple assemblies when you build, each in its own subfolder named for the TFM. The SDK effectively builds the project multiple times.</p>
<p>If you need to provide different code for each target platform (perhaps because you can only implement certain functionality on newer target versions), you might need to use conditional compilation (described in <a data-type="xref" href="ch02.xhtml#compilation_symbols">“Compilation Symbols”</a>). But in cases where the same code works for all targets, it might make sense to build for a single target, .NET Standard. As I described in <a data-type="xref" href="ch01.xhtml#ch_introducing_csharp">Chapter 1</a>, the various versions of .NET Standard define common subsets of the .NET runtime libraries that are available across multiple versions of .NET. I said that if you need to target both .NET (or .NET Core) and .NET Framework, the best choice today is typically .NET Standard 2.0 (which has a TFM of <code>netstandard2.0</code>). However, it’s worth being aware of the other options, particularly if you’re looking to make your component available to the widest possible audience.</p>
<p>.NET libraries published on NuGet may decide to target the lowest version of .NET Standard that they can if they want to ensure the broadest reach. Versions 1.1 through 1.6 gradually added more functionality in exchange for supporting a smaller range of targets. (For example, if you want to use a .NET Standard 1.3 component on .NET Framework, it needs to be .NET Framework 4.6 or later; targeting .NET Standard 1.4 requires .NET Framework 4.61 or later.) .NET Standard 2.0 was a larger leap forward and marked an important point in .NET Standard’s evolution: according to Microsoft’s current plans, this will be the highest version number able to run on .NET Framework. Versions of .NET Framework from 4.7.2 onward fully support it, but .NET Standard 2.1 will not run on any version of .NET Framework now or in the future. It will run on .NET Core 3.0 and 3.1 and .NET 5.0 and later. Mono v6.4 and later support it too. But this is the end of the road for the classic .NET Framework. In practice, .NET Standard 2.0 is currently a popular choice with component authors because it enables the component to run on all recently released versions of .NET while providing access to a very broad set of features.</p>
<p>All of this has caused a certain amount of confusion, and you might be pleased to know that the unification brought by .NET 6.0 simplifies things. If you don’t need to support .NET Framework, you can just target .NET 6.0, ignoring .NET Standard. Mono can run components that target .NET 6.0, and .NET NativeAot is planning to, so targeting .NET 6.0 will cover most runtimes.</p>
<p>What does this all mean for C# developers? If you are writing code that will never be used outside of a particular project, you will normally just target the latest version of .NET, unless you need some Windows-specific feature it doesn’t offer, in which case you might target .NET Framework. Either way, you will be able to use any NuGet package that targets .NET Standard, up to and including v2.0 (which means the overwhelming majority of what’s on NuGet will be available to you).</p>
<p>If you are writing libraries that you intend to share, and if you want your components to be available to the largest audience possible, you should target .NET Standard unless you absolutely need some feature that is only available in a particular runtime. .NET Standard 2.0 is a reasonable choice—you could open your library up to a wider audience by dropping to a lower version, but today, the versions of .NET that support .NET Standard 2.0 are widely available, so you would only contemplate targeting older versions if you need to support developers still using older .NET Frameworks. (Microsoft does this in most of its NuGet libraries, but you don’t necessarily have to tie yourself to the same regime of support for older versions.) Microsoft provides a useful guide to which versions of the various .NET implementations support the various <a href="https://oreil.ly/ok1ay">.NET Standard versions</a>. If you want to use certain newer features (such as the memory-efficient types described in <a data-type="xref" href="ch18.xhtml#ch_memory_efficiency">Chapter 18</a>), you may need to target a more recent version of .NET Standard, with 2.1 being the latest at the time of writing, but be aware that this rules out running on .NET Framework. At that point, you might as well just target .NET Core 3.1 or a later version of .NET, because .NET Standard has little to offer in the newly unified post-.NET-Framework world. In any case, the development tools will ensure that you only use APIs available in whichever version of .NET or .NET Standard you declare support for.</p>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="summary-assemblies">
<h1>Summary</h1>
<p>An assembly is a deployable unit, almost always a single file, typically with a <em>.dll</em> or <em>.exe</em> extension. It is a container for types and code. A type belongs to exactly one assembly, and that assembly forms part of the type’s identity—the .NET runtime can distinguish between two types with the same name in the same namespace if they are defined in different assemblies. Assemblies have a composite name consisting of a simple textual name, a four-part version number, a culture string, and optionally a public key token. Assemblies with a public key token are called <em>strongly named assemblies</em>, giving them a globally unique name. Assemblies can either be deployed alongside the application that uses them or stored in a machine-wide repository. (In .NET Framework, that repository is the Global Assembly Cache, and assemblies must be strongly named to use this. .NET and .NET Core provide shared copies of built-in assemblies, and depending on how you install these newer runtimes, they may also have shared copies of frameworks such as ASP.NET Core and WPF. And you can optionally set up a separate runtime package store containing other shared assemblies to avoid having to include them in application folders.)</p>
<p>The runtime can load assemblies automatically on demand, which typically happens the first time you run a method that contains some code that depends on a type defined in the relevant assembly. You can also load assemblies explicitly if you 
<span class="keep-together">need to.</span><a data-startref="ix_ch12-asciidoc0" data-type="indexterm" id="idm45884795213616"/></p>
<p>As I mentioned earlier, every assembly contains comprehensive metadata describing the types it contains. In the next chapter, I’ll show how you can get access to this metadata at runtime.</p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="fn32"><sup><a href="ch12.xhtml#fn32-marker">1</a></sup> I’m using <em>modern</em> in a very broad sense here—Windows NT introduced PE support in 1993.</p><p data-type="footnote" id="idm45884796226928"><sup><a href="ch12.xhtml#idm45884796226928-marker">2</a></sup> With suitable build settings you can produce bootstrappers for all supported targets regardless of which OS you build on.</p><p data-type="footnote" id="fn34"><sup><a href="ch12.xhtml#fn34-marker">3</a></sup> This was the year Windows Vista shipped. Application manifests existed before then, but this was the first version of Windows to treat their absence as signifying legacy code.</p><p data-type="footnote" id="idm45884795868336"><sup><a href="ch12.xhtml#idm45884795868336-marker">4</a></sup> This is not available in .NET Framework or .NET Standard. <a data-primary="appdomains" data-type="indexterm" id="idm45884795867776"/>Isolation was typically managed with <em>appdomains</em> on .NET Framework, an older mechanism that is not supported in .NET or .NET Core.</p><p data-type="footnote" id="fn35"><sup><a href="ch12.xhtml#fn35-marker">5</a></sup> If you use <code>Assembly.LoadFrom</code>, the CLR does not care whether the filename matches the simple name.</p><p data-type="footnote" id="fn36"><sup><a href="ch12.xhtml#fn36-marker">6</a></sup> It’s possible to configure the CLR to substitute a specific different version, but even then, the loaded assembly has to have the exact version specified by the configuration.</p><p data-type="footnote" id="fn37"><sup><a href="ch12.xhtml#fn37-marker">7</a></sup> Hove, England.</p><p data-type="footnote" id="fn38"><sup><a href="ch12.xhtml#fn38-marker">8</a></sup> Internal items are also available to <em>friend assemblies</em>, meaning any assemblies referred to with an  <span class="keep-together"><code>InternalsVisibleTo</code></span> attribute, as described in <a data-type="xref" href="ch14.xhtml#ch_attributes">Chapter 14</a>.</p></div></div></section></div></body></html>