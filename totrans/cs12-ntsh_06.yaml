- en: Chapter 6\. .NET Fundamentals
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章 .NET 基础
- en: Many of the core facilities that you need when programming are provided not
    by the C# language but by types in the .NET BCL. In this chapter, we cover types
    that help with fundamental programming tasks, such as virtual equality comparison,
    order comparison, and type conversion. We also cover the basic .NET types, such
    as `String`, `DateTime`, and `Enum`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程时，大多数核心设施不是由 C# 语言提供，而是由 .NET BCL 中的类型提供。本章中，我们涵盖了一些帮助进行基本编程任务的类型，例如虚拟相等比较、顺序比较和类型转换。我们还涵盖了基本的
    .NET 类型，如 `String`、`DateTime` 和 `Enum`。
- en: 'The types in this section reside in the `System` namespace, with the following
    exceptions:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的类型位于 `System` 命名空间中，以下是一些例外：
- en: '`StringBuilder` is defined in `System.Text`, as are the types for *text encodings*.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StringBuilder` 在 `System.Text` 中定义，包括 *文本编码* 的类型。'
- en: '`CultureInfo` and associated types are defined in `System.Globalization`.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CultureInfo` 及其关联类型在 `System.Globalization` 中定义。'
- en: '`XmlConvert` is defined in `System.Xml`.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XmlConvert` 在 `System.Xml` 中定义。'
- en: String and Text Handling
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串和文本处理
- en: Char
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Char
- en: 'A C# `char` represents a single Unicode character and aliases the `System.Char`
    struct. In [Chapter 2](ch02.html#chash_language_basics), we described how to express
    `char` literals:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: C# 的 `char` 表示单个 Unicode 字符，并别名为 `System.Char` 结构体。在 [第 2 章](ch02.html#chash_language_basics)
    中，我们描述了如何表示 `char` 文字：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`System.Char` defines a range of static methods for working with characters,
    such as `ToUpper`, `ToLower`, and `IsWhiteSpace`. You can call these through either
    the `System.Char` type or its `char` alias:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Char` 定义了一系列静态方法，用于处理字符，如 `ToUpper`、`ToLower` 和 `IsWhiteSpace`。您可以通过
    `System.Char` 类型或其 `char` 别名调用这些方法：'
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`ToUpper` and `ToLower` honor the end user’s locale, which can lead to subtle
    bugs. The following expression evaluates to `false` in Turkey:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToUpper` 和 `ToLower` 遵循最终用户的语言环境，这可能导致一些微妙的 bug。在土耳其，以下表达式评估为 `false`：'
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The reason is because in Turkey, `char.ToUpper (''i'')` is `''İ''` (notice
    the dot on top!). To avoid this problem, `System.Char` (and `System.String`) also
    provides culture-invariant versions of `ToUpper` and `ToLower` ending with the
    word “Invariant.” These always apply English culture rules:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在土耳其，`char.ToUpper('i')` 是 `'İ'`（请注意上面的点！）。为了避免这个问题，`System.Char`（以及 `System.String`）还提供了以
    “Invariant” 结尾的文化不变版本的 `ToUpper` 和 `ToLower`，这些始终应用英语文化规则：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is a shortcut for:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个快捷方式：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For more on locales and culture, see [“Formatting and Parsing”](#formatting_and_parsing).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有关语言环境和文化的更多信息，请参阅 [“格式化和解析”](#formatting_and_parsing)。
- en: Most of `char`’s remaining static methods are related to categorizing characters.
    [Table 6-1](#static_methods_for_categorizing_charact) lists these.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 `char` 的其他静态方法与字符分类有关。 [表 6-1](#static_methods_for_categorizing_charact)
    列出了这些方法。
- en: Table 6-1\. Static methods for categorizing characters
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-1 静态方法用于对字符进行分类
- en: '| Static method | Characters included | Unicode categories included |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 静态方法 | 包含的字符 | 包含的 Unicode 类别 |'
- en: '| --- | --- | --- |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `IsLetter` | A–Z, a–z, and letters of other alphabets | `UpperCaseLetter`
    `LowerCaseLetter`'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '| `IsLetter` | A–Z、a–z 和其他字母 | `UpperCaseLetter` `LowerCaseLetter`'
- en: '`TitleCaseLetter`'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`TitleCaseLetter`'
- en: '`ModifierLetter`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`ModifierLetter`'
- en: '`OtherLetter` |'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`OtherLetter` |'
- en: '| `IsUpper` | Uppercase letters | `UpperCaseLetter` |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `IsUpper` | 大写字母 | `UpperCaseLetter` |'
- en: '| `IsLower` | Lowercase letters | `LowerCaseLetter` |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `IsLower` | 小写字母 | `LowerCaseLetter` |'
- en: '| `IsDigit` | 0–9 plus digits of other alphabets | `DecimalDigitNumber` |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `IsDigit` | 0–9 及其他字母的数字 | `DecimalDigitNumber` |'
- en: '| `IsLetterOrDigit` | Letters plus digits | (`IsLetter`, `IsDigit`) |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `IsLetterOrDigit` | 字母加上数字 | (`IsLetter`, `IsDigit`) |'
- en: '| `IsNumber` | All digits plus Unicode fractions and Roman numeral symbols
    | `DecimalDigitNumber` `LetterNumber`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '| `IsNumber` | 所有数字加上 Unicode 分数和罗马数字符号 | `DecimalDigitNumber` `LetterNumber`'
- en: '`OtherNumber` |'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`OtherNumber` |'
- en: '| `IsSeparator` | Space plus all Unicode separator characters | `LineSeparator`
    `ParagraphSeparator` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `IsSeparator` | 空格加上所有 Unicode 分隔符字符 | `LineSeparator` `ParagraphSeparator`
    |'
- en: '| `IsWhiteSpace` | All separators plus `\n`, `\r`, `\t`, `\f`, and `\v` | `LineSeparator`
    `ParagraphSeparator` |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `IsWhiteSpace` | 所有分隔符加上 `\n`、`\r`、`\t`、`\f` 和 `\v` | `LineSeparator` `ParagraphSeparator`
    |'
- en: '| `IsPunctuation` | Symbols used for punctuation in Western and other alphabets
    | `DashPunctuation` `ConnectorPunctuation`'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '| `IsPunctuation` | 用于西方及其他字母表中的标点符号的符号 | `DashPunctuation` `ConnectorPunctuation`'
- en: '`InitialQuotePunctuation`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`InitialQuotePunctuation`'
- en: '`FinalQuotePunctuation` |'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '| `FinalQuotePunctuation` |'
- en: '| `IsSymbol` | Most other printable symbols | `MathSymbol` `ModifierSymbol`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '| `IsSymbol` | 大多数其他可打印符号 | `MathSymbol` `ModifierSymbol`'
- en: '`OtherSymbol` |'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`OtherSymbol` |'
- en: '| `IsControl` | Nonprintable “control” characters below 0x20, such as `\r`,
    `\n`, `\t`, `\0`, and characters between 0x7F and 0x9A | (None) |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `IsControl` | 0x20 以下的不可打印“控制”字符，例如 `\r`、`\n`、`\t`、`\0`，以及 0x7F 和 0x9A 之间的字符
    | (无) |'
- en: For more granular categorization, `char` provides a static method called `GetUnicodeCategory`;
    this returns a `UnicodeCategory` enumeration whose members are shown in the rightmost
    column of [Table 6-1](#static_methods_for_categorizing_charact).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更细粒度的分类，`char` 提供了一个名为 `GetUnicodeCategory` 的静态方法；它返回一个 `UnicodeCategory`
    枚举，其成员显示在 [表 6-1](#static_methods_for_categorizing_charact) 的最右列中。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'By explicitly casting from an integer, it’s possible to produce a `char` outside
    the allocated Unicode set. To test a character’s validity, call `char.GetUnicodeCategory`:
    if the result is `UnicodeCategory.OtherNotAssigned`, the character is invalid.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过显式从整数转换，可以生成超出分配的 Unicode 集的 `char`。要测试字符的有效性，请调用 `char.GetUnicodeCategory`：如果结果为
    `UnicodeCategory.OtherNotAssigned`，则该字符无效。
- en: 'A `char` is 16 bits wide—enough to represent any Unicode character in the *Basic
    Multilingual Plane*. To go beyond this, you must use surrogate pairs: we describe
    the methods for doing this in [“Text Encodings and Unicode”](#text_encodings_and_unicode).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `char` 宽度为 16 位 —— 足以表示基本多文种平面中的任何 Unicode 字符。要超出这一范围，必须使用代理对：我们将在 [“文本编码和
    Unicode”](#text_encodings_and_unicode) 中描述执行此操作的方法。
- en: String
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: A C# `string` (`== System.String`) is an immutable (unchangeable) sequence of
    characters. In [Chapter 2](ch02.html#chash_language_basics), we described how
    to express string literals, perform equality comparisons, and concatenate two
    strings. This section covers the remaining functions for working with strings,
    exposed through the static and instance members of the `System.String` class.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: C# `string` (`== System.String`) 是一个不可变（无法改变）的字符序列。在 [第二章](ch02.html#chash_language_basics)
    中，我们描述了如何表示字符串字面量，进行相等性比较以及连接两个字符串。本节介绍了其余处理字符串的函数，这些函数通过 `System.String` 类的静态和实例成员公开。
- en: Constructing strings
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造字符串
- en: 'The simplest way to construct a string is to assign a literal, as we saw in
    [Chapter 2](ch02.html#chash_language_basics):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 构造字符串的最简单方式是分配一个字面量，正如我们在 [第二章](ch02.html#chash_language_basics) 中看到的：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To create a repeating sequence of characters, you can use `string`’s constructor:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个重复的字符序列，您可以使用 `string` 的构造函数：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can also construct a string from a `char` array. The `ToCharArray` method
    does the reverse:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从 `char` 数组构造字符串。`ToCharArray` 方法则执行相反操作：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`string`’s constructor is also overloaded to accept various (unsafe) pointer
    types, in order to create strings from types such as `char*`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`string` 的构造函数还可以重载以接受各种（不安全的）指针类型，以便从诸如 `char*` 等类型创建字符串。'
- en: Null and empty strings
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空和空字符串
- en: 'An empty string has a length of zero. To create an empty string, you can use
    either a literal or the static `string.Empty` field; to test for an empty string,
    you can either perform an equality comparison or test its `Length` property:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 空字符串的长度为零。要创建空字符串，可以使用字面量或静态 `string.Empty` 字段；要测试空字符串，可以执行相等性比较或测试其 `Length`
    属性：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Because strings are reference types, they can also be `null`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符串是引用类型，它们也可以为 `null`：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The static `string.IsNullOrEmpty` method is a useful shortcut for testing whether
    a given string is either null or empty.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 静态 `string.IsNullOrEmpty` 方法是测试给定字符串是否为 null 或空的一个便捷方法。
- en: Accessing characters within a string
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问字符串中的字符
- en: 'A string’s indexer returns a single character at the given index. As with all
    functions that operate on strings, this is zero-indexed:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的索引器返回给定索引处的单个字符。与所有操作字符串的函数一样，这是从零开始的索引：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`string` also implements `IEnumerable<char>`, so you can `foreach` over its
    characters:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`string` 还实现了 `IEnumerable<char>`，因此您可以对其字符进行 `foreach` 循环：'
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Searching within strings
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在字符串中搜索
- en: 'The simplest methods for searching within strings are `StartsWith`, `EndsWith`,
    and `Contains`. These all return `true` or `false`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串中进行搜索的最简单方法是使用 `StartsWith`、`EndsWith` 和 `Contains`。这些方法都返回 `true` 或 `false`：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'These methods are overloaded to let you specify a `StringComparison` enum to
    control case and culture sensitivity (see [“Ordinal versus culture comparison”](#ordinal_versus_culture_comparison)).
    The default is to perform a case-sensitive match using rules applicable to the
    current (localized) culture. The following instead performs a case-insensitive
    search using the *invariant* culture’s rules:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法还重载了让您可以指定 `StringComparison` 枚举以控制大小写和区域性敏感性（参见[“按序数与文化比较”](#ordinal_versus_culture_comparison)）。默认情况下，使用适用于当前（本地化）文化的规则执行区分大小写的匹配。以下示例使用
    *不变的* 区域性规则执行不区分大小写的搜索：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`IndexOf` returns the first position of a given character or substring (or
    `−1` if the substring isn’t found):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`IndexOf` 返回给定字符或子字符串的第一个位置（如果未找到子字符串，则返回 `-1`）：'
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`IndexOf` is also overloaded to accept a `startPosition` (an index from which
    to begin searching) as well as a `StringComparison` enum:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`IndexOf` 还重载了以接受 `startPosition`（开始搜索的索引）和 `StringComparison` 枚举：'
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`LastIndexOf` is like `IndexOf`, but it works backward through the string.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`LastIndexOf` 类似于 `IndexOf`，但它是从字符串的末尾向前搜索。'
- en: '`IndexOfAny` returns the first matching position of any one of a set of characters:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`IndexOfAny` 返回一组字符中任意一个匹配字符的第一个位置：'
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`LastIndexOfAny` does the same in the reverse direction.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`LastIndexOfAny` 在相反的方向上执行相同的操作。'
- en: Manipulating strings
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操纵字符串
- en: Because `String` is immutable, all the methods that “manipulate” a string return
    a new one, leaving the original untouched (the same goes for when you reassign
    a string variable).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `String` 是不可变的，所有“操纵”字符串的方法都会返回一个新的字符串，而原始字符串保持不变（当重新分配字符串变量时也是如此）。
- en: '`Substring` extracts a portion of a string:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Substring` 提取字符串的一部分：'
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you omit the length, you get the remainder of the string:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略长度，则获取字符串的剩余部分：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`Insert` and `Remove` insert or remove characters at a specified position:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`Insert` 和 `Remove` 在指定位置插入或删除字符：'
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`PadLeft` and `PadRight` pad a string to a given length with a specified character
    (or a space if unspecified):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`PadLeft` 和 `PadRight` 使用指定的字符（如果未指定，则使用空格）将字符串填充到给定长度：'
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If the input string is longer than the padding length, the original string is
    returned unchanged.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入字符串比填充长度长，则返回原始字符串而不做任何更改。
- en: '`TrimStart` and `TrimEnd` remove specified characters from the beginning or
    end of a string; `Trim` does both. By default, these functions remove whitespace
    characters (including spaces, tabs, new lines, and Unicode variations of these):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`TrimStart` 和 `TrimEnd` 从字符串的开头或结尾移除指定的字符；`Trim` 同时执行这两种操作。默认情况下，这些函数移除空白字符（包括空格、制表符、换行符和这些字符的
    Unicode 变体）：'
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`Replace` replaces all (non-overlapping) occurrences of a particular character
    or substring:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Replace` 替换特定字符或子字符串的所有（非重叠）出现：'
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`ToUpper` and `ToLower` return uppercase and lowercase versions of the input
    string. By default, they honor the user’s current language settings; `ToUpperInvariant`
    and `ToLowerInvariant` always apply English alphabet rules.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToUpper` 和 `ToLower` 返回输入字符串的大写和小写版本。默认情况下，它们遵循用户当前的语言设置；`ToUpperInvariant`
    和 `ToLowerInvariant` 总是应用英语字母规则。'
- en: Splitting and joining strings
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串的拆分和连接
- en: '`Split` divides a string into pieces:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`Split` 将字符串分割成多个部分：'
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'By default, `Split` uses whitespace characters as delimiters; it’s also overloaded
    to accept a `params` array of `char` or `string` delimiters. `Split` also optionally
    accepts a `StringSplitOptions` enum, which has an option to remove empty entries:
    this is useful when words are separated by several delimiters in a row.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`Split` 使用空白字符作为分隔符；它还重载了以接受 `params` 字符数组或字符串分隔符数组。`Split` 还可以选择接受 `StringSplitOptions`
    枚举，该枚举有一个选项来移除空条目：当单词之间使用多个分隔符分隔时，这很有用。
- en: 'The static `Join` method does the reverse of `Split`. It requires a delimiter
    and string array:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 静态 `Join` 方法与 `Split` 相反。它需要一个分隔符和字符串数组：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The static `Concat` method is similar to `Join` but accepts only a `params`
    string array and applies no separator. `Concat` is exactly equivalent to the `+`
    operator (the compiler, in fact, translates `+` to `Concat`):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 静态 `Concat` 方法类似于 `Join`，但仅接受 `params` 字符串数组并且不应用分隔符。`Concat` 实际上等同于 `+` 运算符（事实上，编译器将
    `+` 转换为 `Concat`）：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: String.Format and composite format strings
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: String.Format 和复合格式字符串
- en: The static `Format` method provides a convenient way to build strings that embed
    variables. The embedded variables (or values) can be of any type; the `Format`
    simply calls `ToString` on them.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 静态 `Format` 方法提供了一种方便的方式来构建嵌入变量的字符串。嵌入的变量（或值）可以是任何类型；`Format` 简单地对它们调用 `ToString`。
- en: 'The master string that includes the embedded variables is called a *composite
    format string*. When calling `String.Format`, you provide a composite format string
    followed by each of the embedded variables:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 包含嵌入变量的主字符串称为*组合格式字符串*。调用`String.Format`时，您提供一个组合格式字符串，后跟每个嵌入变量：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: (And that’s Celsius!)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: （这是摄氏度！）
- en: 'We can use interpolated string literals to the same effect (see [“String Type”](ch02.html#string_type)).
    Just precede the string with the `$` symbol and put the expressions in braces:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用插值字符串字面量以同样的效果（参见[“String Type”](ch02.html#string_type)）。只需在字符串前加上`$`符号，并将表达式放在大括号中：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Each number in curly braces is called a *format item*. The number corresponds
    to the argument position and is optionally followed by:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号中的每个数字称为*格式项*。数字对应于参数位置，可选地跟随以下内容：
- en: A comma and a *minimum width* to apply
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逗号和*最小宽度*应用
- en: A colon and a *format string*
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冒号和*格式字符串*
- en: 'The minimum width is useful for aligning columns. If the value is negative,
    the data is left-aligned; otherwise, it’s right-aligned:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最小宽度对于对齐列非常有用。如果值为负，则数据左对齐；否则，右对齐：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here’s the result:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here’s the equivalent without using `string.Format`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不使用`string.Format`的等效形式：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The credit limit is formatted as currency by virtue of the `"C"` format string.
    We describe format strings in detail in [“Formatting and Parsing”](#formatting_and_parsing).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`"C"`格式字符串，信用限额以货币形式进行格式化。我们在[“Formatting and Parsing”](#formatting_and_parsing)中详细描述格式字符串。
- en: Comparing Strings
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较字符串
- en: In comparing two values, .NET differentiates the concepts of *equality comparison*
    and *order comparison*. Equality comparison tests whether two instances are semantically
    the same; order comparison tests which of two (if any) instances comes first when
    arranging them in ascending or descending sequence.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较两个值时，.NET区分*相等比较*和*顺序比较*的概念。相等比较测试两个实例是否语义上相同；顺序比较测试这两个（如果有的话）实例在按升序或降序排列时谁先出现。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Equality comparison is not a *subset* of order comparison; the two systems have
    different purposes. It’s legal, for instance, to have two unequal values in the
    same ordering position. We resume this topic in [“Equality Comparison”](ch04.html#equality_comparison-id00016).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 相等比较不是顺序比较的*子集*；这两个系统有不同的目的。例如，在相同的排序位置上允许有两个不相等的值。我们在[“Equality Comparison”](ch04.html#equality_comparison-id00016)中恢复这个主题。
- en: For string equality comparison, you can use the `==` operator or one of `string`’s
    `Equals` methods. The latter are more versatile because they allow you to specify
    options such as case insensitivity.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字符串的相等比较，您可以使用`==`运算符或`string`的`Equals`方法之一。后者更加灵活，因为它们允许您指定选项，如不区分大小写。
- en: Warning
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Another difference is that `==` does not work reliably on strings if the variables
    are cast to the `object` type. We explain why this is so in [“Equality Comparison”](ch04.html#equality_comparison-id00016).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个区别是，如果将变量强制转换为`object`类型，则`==`在字符串上不可靠。我们在[“Equality Comparison”](ch04.html#equality_comparison-id00016)中解释了这一点。
- en: For string order comparison, you can use either the `CompareTo` instance method
    or the static `Compare` and `CompareOrdinal` methods. These return a positive
    or negative number, or zero, depending on whether the first value comes after,
    before, or alongside the second.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字符串顺序比较，您可以使用`CompareTo`实例方法或静态的`Compare`和`CompareOrdinal`方法。这些方法根据第一个值是否在第二个值之后、之前或与其并列返回正数、负数或零。
- en: Before going into the details of each, we need to examine .NET’s underlying
    string comparison algorithms.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细讨论每个之前，我们需要检查.NET的底层字符串比较算法。
- en: Ordinal versus culture comparison
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 顺序与文化比较
- en: 'There are two basic algorithms for string comparison: *ordinal* and *culture
    sensitive*. Ordinal comparisons interpret characters simply as numbers (according
    to their numeric Unicode value); culture-sensitive comparisons interpret characters
    with reference to a particular alphabet. There are two special cultures: the “current
    culture,” which is based on settings picked up from the computer’s control panel,
    and the “invariant culture,” which is the same on every computer (and closely
    matches American culture).'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串比较有两种基本算法：*顺序*和*文化敏感*。顺序比较将字符简单地解释为数字（根据它们的数值Unicode值）；文化敏感比较则根据特定的字母表解释字符。有两种特殊的文化：基于从计算机控制面板获取的设置的“当前文化”，以及在每台计算机上相同的“不变文化”（与美国文化接近）。
- en: 'For equality comparison, both ordinal and culture-specific algorithms are useful.
    For ordering, however, culture-specific comparison is nearly always preferable:
    to order strings alphabetically, you need an alphabet. Ordinal relies on the numeric
    Unicode point values, which happen to put English characters in alphabetical order—but
    even then, not exactly as you might expect. For example, assuming case sensitivity,
    consider the strings `"Atom"`, `"atom"`, and `"Zamia"`. The invariant culture
    puts them in the following order:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于相等比较，无论是序数还是特定文化的算法都很有用。然而，对于排序来说，特定文化的比较几乎总是更可取的：要按字母顺序排序字符串，你需要一个字母表。序数依赖于数字Unicode点值，这恰好按照英文字符的字母顺序排列，但即使如此，也不完全如你所期望的那样。例如，假设区分大小写，请考虑字符串`"Atom"`、`"atom"`和`"Zamia"`。不变文化将它们按以下顺序排列：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Ordinal arranges them instead as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 序数则将它们安排如下：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is because the invariant culture encapsulates an alphabet, which considers
    uppercase characters adjacent to their lowercase counterparts (aAbBcCdD...). The
    ordinal algorithm, however, puts all the uppercase characters first, and then
    all lowercase characters (A...Z, a...z). This is essentially a throwback to the
    ASCII character set invented in the 1960s.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为不变文化封装了一个包括大写字符邻近其小写对应物的字母表（aAbBcCdD...）。然而，序数算法将所有大写字符放在前面，然后所有小写字符（A...Z，a...z）。这本质上是对上世纪60年代发明的ASCII字符集的回溯。
- en: String equality comparison
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串相等比较
- en: Despite ordinal’s limitations, `string`’s `==` operator always performs *ordinal
    case-sensitive* comparison. The same goes for the instance version of `string.Equals`
    when called without arguments; this defines the “default” equality comparison
    behavior for the `string` type.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管序数有其局限性，`string`的`==`运算符总是执行*序数区分大小写*比较。调用时没有参数的`string.Equals`的实例版本也是如此；这定义了`string`类型的“默认”相等比较行为。
- en: Note
  id: totrans-138
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The ordinal algorithm was chosen for `string`’s `==` and `Equals` functions
    because it’s both highly efficient and *deterministic*. String equality comparison
    is considered fundamental and is performed far more frequently than order comparison.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 序数算法被选为`string`的`==`和`Equals`函数的算法，因为它既高效又*确定性*。字符串的相等比较被认为是基础性的，并且比顺序比较频繁得多。
- en: A “strict” notion of equality is also consistent with the general use of the
    `==` operator.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: “严格”的相等概念也与`==`运算符的一般使用一致。
- en: 'The following methods allow culture-aware or case-insensitive comparisons:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法允许特定文化感知或不区分大小写的比较：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The static version is advantageous in that it still works if one or both of
    the strings are `null`. `StringComparison` is an `enum` defined as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 静态版本的优势在于，即使其中一个或两个字符串为`null`，它仍然可以工作。`StringComparison`被定义为以下的`enum`：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'For example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: (The result of the third example is determined by the computer’s current language
    settings.)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: （第三个示例的结果取决于计算机的当前语言设置。）
- en: String order comparison
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串顺序比较
- en: '`String`’s `CompareTo` instance method performs *culture-sensitive*, *case-sensitive*
    order comparison. Unlike the `==` operator, `CompareTo` does not use ordinal comparison:
    for ordering, a culture-sensitive algorithm is much more useful. Here’s the method’s
    definition:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`的`CompareTo`实例方法执行*特定文化*、*区分大小写*的顺序比较。与`==`运算符不同，`CompareTo`不使用序数比较：对于排序，特定文化的算法要更有用。这里是该方法的定义：'
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-151
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `CompareTo` instance method implements the generic `IComparable` interface,
    a standard comparison protocol used across the .NET libraries. This means `string`’s
    `CompareTo` defines the default ordering behavior of strings in such applications
    as sorted collections, for instance. For more information on `IComparable`, see
    [“Order Comparison”](#order_comparison).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 实例方法`CompareTo`实现了通用的`IComparable`接口，这是.NET库中使用的标准比较协议。这意味着`string`的`CompareTo`定义了在排序集合等应用中字符串的默认排序行为。有关`IComparable`的更多信息，请参阅[“顺序比较”](#order_comparison)。
- en: 'For other kinds of comparison, you can call the static `Compare` and `CompareOrdinal`
    methods:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他类型的比较，可以调用静态的`Compare`和`CompareOrdinal`方法：
- en: '[PRE37]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The last two methods are simply shortcuts for calling the first two methods.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个方法只是调用前两个方法的简便方法。
- en: 'All of the order comparison methods return a positive number, a negative number,
    or zero depending on whether the first value comes after, before, or alongside
    the second value:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的顺序比较方法返回一个正数、一个负数或零，具体取决于第一个值是在第二个值之后、之前还是相同：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following performs a case-insensitive comparison using the current culture:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下使用当前文化进行不区分大小写比较：
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'By supplying a `CultureInfo` object, you can plug in any alphabet:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供一个 `CultureInfo` 对象，你可以插入任何字母表：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: StringBuilder
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: StringBuilder
- en: The `StringBuilder` class (`System.Text` namespace) represents a mutable (editable)
    string. With a `StringBuilder`, you can `Append`, `Insert`, `Remove`, and `Replace`
    substrings without replacing the whole `StringBuilder`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringBuilder` 类（`System.Text` 命名空间）表示一个可变（可编辑）字符串。使用 `StringBuilder`，可以在不替换整个
    `StringBuilder` 的情况下 `Append`、`Insert`、`Remove` 和 `Replace` 子字符串。'
- en: '`StringBuilder`’s constructor optionally accepts an initial string value as
    well as a starting size for its internal capacity (default is 16 characters).
    If you go beyond this, `StringBuilder` automatically resizes its internal structures
    to accommodate (at a slight performance cost) up to its maximum capacity (default
    is `int.MaxValue`).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringBuilder` 的构造函数可选择接受一个初始字符串值以及其内部容量的起始大小（默认为 16 个字符）。如果超出此范围，`StringBuilder`
    会自动调整其内部结构以容纳（稍微降低性能）最大容量（默认为 `int.MaxValue`）。'
- en: 'A popular use of `StringBuilder` is to build up a long string by repeatedly
    calling `Append`. This approach is much more efficient than repeatedly concatenating
    ordinary string types:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `StringBuilder` 的一个流行用法是通过重复调用 `Append` 来构建长字符串。这种方法比重复连接普通字符串类型要高效得多：
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To get the final result, call `ToString()`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取最终结果，请调用 `ToString()`：
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`AppendLine` performs an `Append` that adds a new line sequence (`"\r\n"` in
    Windows). `AppendFormat` accepts a composite format string, just like `String.Format`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppendLine` 执行一个 `Append`，添加一个新行序列（在 Windows 下是 `"\r\n"`）。`AppendFormat` 接受一个复合格式字符串，就像
    `String.Format` 一样。'
- en: In addition to the `Insert`, `Remove`, and `Replace` methods (`Replace` works
    like string’s `Replace`), `StringBuilder` defines a `Length` property and a writable
    indexer for getting/setting individual characters.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `Insert`、`Remove` 和 `Replace` 方法（`Replace` 的工作方式类似于字符串的 `Replace`），`StringBuilder`
    定义了一个 `Length` 属性和一个可写索引器来获取/设置单个字符。
- en: To clear the contents of a `StringBuilder`, either instantiate a new one or
    set its `Length` to zero.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要清除 `StringBuilder` 的内容，可以实例化一个新的或将其 `Length` 设置为零。
- en: Warning
  id: totrans-172
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Setting a `StringBuilder`’s `Length` to zero doesn’t shrink its *internal* capacity.
    So, if the `StringBuilder` previously contained one million characters, it will
    continue to occupy around two megabytes of memory after zeroing its `Length`.
    If you want to release the memory, you must create a new `StringBuilder` and allow
    the old one to drop out of scope (and be garbage-collected).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `StringBuilder` 的 `Length` 设置为零不会减小其*内部*容量。因此，如果 `StringBuilder` 以前包含一百万个字符，将其长度设置为零后，它仍将占用大约两兆字节的内存。如果要释放内存，必须创建一个新的
    `StringBuilder`，并允许旧的 `StringBuilder` 超出作用域（并被垃圾回收）。
- en: Text Encodings and Unicode
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本编码和 Unicode
- en: 'A *character set* is an allocation of characters, each with a numeric code,
    or *code point*. There are two character sets in common use: Unicode and ASCII.
    Unicode has an address space of approximately one million characters, of which
    about 100,000 are currently allocated. Unicode covers most spoken world languages
    as well as some historical languages and special symbols. The ASCII set is simply
    the first 128 characters of the Unicode set, which covers most of what you see
    on a US-style keyboard. ASCII predates Unicode by 30 years and is still sometimes
    used for its simplicity and efficiency: each character is represented by one byte.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符集* 是字符分配，每个字符都有一个数字代码或*代码点*。常用的字符集有两种：Unicode 和 ASCII。Unicode 的地址空间约为一百万个字符，目前分配约十万个。Unicode
    覆盖大多数世界语言以及一些历史语言和特殊符号。ASCII 集仅是 Unicode 集的前 128 个字符，覆盖大部分美式键盘上的内容。ASCII 比 Unicode
    早 30 年，有时因其简单和高效而仍在使用：每个字符用一个字节表示。'
- en: The .NET type system is designed to work with the Unicode character set. ASCII
    is implicitly supported, though, by virtue of being a subset of Unicode.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 类型系统设计用于与 Unicode 字符集配合工作。ASCII 隐式支持，因为它是 Unicode 的子集。
- en: A *text encoding* maps characters from their numeric code point to a binary
    representation. In .NET, text encodings come into play primarily when dealing
    with text files or streams. When you read a text file into a string, a *text encoder*
    translates the file data from binary into the internal Unicode representation
    that the `char` and `string` types expect. A text encoding can restrict what characters
    can be represented as well as affect storage efficiency.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*文本编码*将字符从其数字代码点映射到二进制表示。在.NET中，文本编码主要用于处理文本文件或流。将文本文件读入字符串时，*文本编码器*将文件数据从二进制转换为`char`和`string`类型期望的内部Unicode表示。文本编码可以限制可以表示的字符，并影响存储效率。'
- en: 'There are two categories of text encoding in .NET:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中有两类文本编码：
- en: Those that map Unicode characters to another character set
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Unicode字符映射到另一个字符集的编码
- en: Those that use standard Unicode encoding schemes
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准Unicode编码方案的编码
- en: 'The first category contains legacy encodings such as IBM’s EBCDIC and 8-bit
    character sets with extended characters in the upper-128 region that were popular
    prior to Unicode (identified by a code page). The ASCII encoding is also in this
    category: it encodes the first 128 characters and drops everything else. This
    category contains the *nonlegacy* GB18030, as well, which is the mandatory standard
    for applications written in China—or sold to China—since 2000.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 第一类包含传统编码，如IBM的EBCDIC和扩展字符集的8位字符集，这些字符集在Unicode之前非常流行（由代码页标识）。ASCII编码也属于此类：它编码前128个字符并丢弃其他所有内容。此类还包含*非遗留*GB18030，这是自2000年以来在中国编写或销售的应用程序的强制标准。
- en: 'In the second category are UTF-8, UTF-16, and UTF-32 (and the obsolete UTF-7).
    Each differs in space efficiency. UTF-8 is the most space-efficient for most kinds
    of text: it uses *between one and four bytes* to represent each character. The
    first 128 characters require only a single byte, making it compatible with ASCII.
    UTF-8 is the most popular encoding for text files and streams (particularly on
    the internet), and it is the default for stream input/output (I/O) in .NET (in
    fact, it’s the default for almost everything that implicitly uses an encoding).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第二类是UTF-8、UTF-16和UTF-32（以及已废弃的UTF-7）。每种编码在空间效率上有所不同。对于大多数文本，UTF-8是最空间高效的：它使用*一到四个字节*来表示每个字符。前128个字符仅需一个字节，使其与ASCII兼容。UTF-8是最流行的文本文件和流编码（特别是在互联网上），并且是.NET中流输入/输出（I/O）的默认编码（事实上，它是几乎所有隐式使用编码的默认值）。
- en: UTF-16 uses one or two 16-bit words to represent each character. This is what
    .NET uses internally to represent characters and strings. Some programs also write
    files in UTF-16.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-16使用一个或两个16位字来表示每个字符。这是.NET内部用于表示字符和字符串的方式。一些程序还以UTF-16编写文件。
- en: 'UTF-32 is the least space-efficient: it maps each code point directly to 32
    bits, so every character consumes four bytes. UTF-32 is rarely used for this reason.
    It does, however, make random access very easy because every character takes an
    equal number of bytes.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-32是最不空间高效的：它直接将每个代码点映射到32位，因此每个字符占用四个字节。由于这个原因，UTF-32很少被使用。然而，它确实使随机访问非常容易，因为每个字符占用相同数量的字节。
- en: Obtaining an Encoding object
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取一个Encoding对象
- en: 'The `Encoding` class in `System.Text` is the common base type for classes that
    encapsulate text encodings. There are several subclasses—their purpose is to encapsulate
    families of encodings with similar features. The most common encodings can be
    obtained through dedicated static properties on `Encoding`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Text`中的`Encoding`类是封装文本编码的常见基类型。有几个子类——它们的目的是封装具有类似特性的编码族。最常见的编码可以通过`Encoding`上的专用静态属性获取：'
- en: '| Encoding name | Static property on Encoding |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 编码名称 | Encoding上的静态属性 |'
- en: '| --- | --- |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| UTF-8 | `Encoding.UTF8` |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| UTF-8 | `Encoding.UTF8` |'
- en: '| UTF-16 | `Encoding.Unicode` (*not* `UTF16`) |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| UTF-16 | `Encoding.Unicode`（*不是* `UTF16`） |'
- en: '| UTF-32 | `Encoding.UTF32` |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| UTF-32 | `Encoding.UTF32` |'
- en: '| ASCII | `Encoding.ASCII` |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| ASCII | `Encoding.ASCII` |'
- en: 'You can obtain other encodings by calling `Encoding.GetEncoding` with a standard
    Internet Assigned Numbers Authority (IANA) Character Set name:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用标准的互联网分配的数字字符集（IANA）名称调用`Encoding.GetEncoding`来获取其他编码：
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The static `GetEncodings` method returns a list of all supported encodings
    along with their standard IANA names:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的`GetEncodings`方法返回所有支持的编码列表，以及它们的标准IANA名称：
- en: '[PRE44]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The other way to obtain an encoding is to directly instantiate an encoding
    class. Doing so allows you to set various options via constructor arguments, including:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种获取编码的方法是直接实例化编码类。这样做允许您通过构造函数参数设置各种选项，包括：
- en: Whether to throw an exception if an invalid byte sequence is encountered when
    decoding. The default is false.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否在解码时遇到无效字节序列时抛出异常。默认值为false。
- en: Whether to encode/decode UTF-16/UTF-32 with the most significant bytes first
    (*big endian*) or the least significant bytes first (*little endian*). The default
    is *little endian*, the standard on the Windows operating system.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否以最重要的字节优先（*大端序*）或最不重要的字节优先（*小端序*）编码/解码UTF-16/UTF-32。默认是*小端序*，在Windows操作系统上是标准的。
- en: Whether to emit a byte-order mark (a prefix that indicates *endianness*).
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否发出字节顺序标记（指示*字节顺序*的前缀）。
- en: Encoding for file and stream I/O
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于文件和流I/O的编码
- en: 'The most common application for an `Encoding` object is to control how text
    is read and written to a file or stream. For example, the following writes “Testing…”
    to a file called *data.txt* in UTF-16 encoding:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`Encoding`对象的最常见应用是控制如何将文本读取和写入文件或流。例如，以下代码以UTF-16编码将“Testing…”写入名为*data.txt*的文件：'
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If you omit the final argument, `WriteAllText` applies the ubiquitous UTF-8
    encoding.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略最后一个参数，`WriteAllText`将应用普遍使用的UTF-8编码。
- en: Note
  id: totrans-205
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: UTF-8 is the default text encoding for all file and stream I/O.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8是所有文件和流I/O的默认文本编码。
- en: We resume this subject in [Chapter 15](ch15.html#streams_and_isoliduso), in
    [“Stream Adapters”](ch15.html#stream_adapters).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第15章](ch15.html#streams_and_isoliduso)，[“流适配器”](ch15.html#stream_adapters)中继续讨论这个主题。
- en: Encoding to byte arrays
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编码为字节数组
- en: 'You can also use an `Encoding` object to go to and from a byte array. The `GetBytes`
    method converts from `string` to `byte[]` with the given encoding; `GetString`
    converts from `byte[]` to `string`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`Encoding`对象在字节数组和字符串之间进行转换。`GetBytes`方法使用给定的编码将`string`转换为`byte[]`；`GetString`方法将`byte[]`转换为`string`：
- en: '[PRE46]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: UTF-16 and surrogate pairs
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UTF-16和代理对
- en: 'Recall that .NET stores characters and strings in UTF-16\. Because UTF-16 requires
    one or two 16-bit words per character, and a `char` is only 16 bits in length,
    some Unicode characters require two `char`s to represent. This has a couple of
    consequences:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 记得.NET将字符和字符串存储在UTF-16中。因为UTF-16每个字符需要一个或两个16位字，而`char`长度仅为16位，所以一些Unicode字符需要两个`char`来表示。这有几个后果：
- en: A string’s `Length` property can be greater than its real character count.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串的`Length`属性可能大于其实际字符数。
- en: A single `char` is not always enough to fully represent a Unicode character.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个`char`并不总是足以完全表示一个Unicode字符。
- en: Most applications ignore this because nearly all commonly used characters fit
    into a section of Unicode called the *Basic Multilingual Plane* (BMP), which requires
    only one 16-bit word in UTF-16\. The BMP covers several dozen world languages
    and includes more than 30,000 Chinese characters. Excluded are characters of some
    ancient languages, symbols for musical notation, some less common Chinese characters,
    and most emojis.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序忽略此问题，因为几乎所有常用字符都适合Unicode的一个部分，称为*基本多语言平面*（BMP），在UTF-16中只需要一个16位字。BMP涵盖几十种世界语言，包括超过30,000个中文字符。不包括某些古代语言的字符，音乐符号，一些不常见的中文字符以及大多数表情符号。
- en: 'If you need to support two-word characters, the following static methods in
    `char` convert a 32-bit code point to a string of two `char`s, and back again:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要支持双字字符，`char`中的以下静态方法将32位代码点转换为两个`char`的字符串，并反向转换回去：
- en: '[PRE47]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Two-word characters are called *surrogates*. They are easy to spot because
    each word is in the range 0xD800 to 0xDFFF. You can use the following static methods
    in `char` to assist:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 两字字符称为*代理对*。它们很容易识别，因为每个字都在0xD800到0xDFFF范围内。您可以使用`char`中的以下静态方法来辅助：
- en: '[PRE48]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `StringInfo` class in the `System.Globalization` namespace also provides
    a range of methods and properties for working with two-word characters.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Globalization`命名空间中的`StringInfo`类还提供了一系列处理双字字符的方法和属性。'
- en: Characters outside the BMP typically require special fonts and have limited
    operating system support.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: BMP之外的字符通常需要特殊字体，并且操作系统支持有限。
- en: Dates and Times
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期和时间
- en: 'The following immutable structs in the `System` namespace do the job of representing
    dates and times:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`System`命名空间中的以下不可变结构体负责表示日期和时间：'
- en: '`DateTime`, `DateTimeOffset`, `TimeSpan`, `DateOnly`, `TimeOnly`'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTime`、`DateTimeOffset`、`TimeSpan`、`DateOnly`、`TimeOnly`'
- en: C# doesn’t define any special keywords that map to these types.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: C#没有定义任何特殊的关键字来映射到这些类型。
- en: TimeSpan
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间间隔
- en: A `TimeSpan` represents an interval of time—or a time of the day. In the latter
    role, it’s simply the “clock” time (without the date), which is equivalent to
    the time since midnight, assuming no daylight saving transition. A `TimeSpan`
    has a resolution of 100 ns, has a maximum value of about 10 million days, and
    can be positive or negative.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`TimeSpan`表示一段时间间隔或一天中的时间。在后一种角色中，它只是“时钟”时间（不包括日期），它等于从午夜开始的时间，假设没有夏令时过渡。`TimeSpan`的分辨率为100纳秒，最大值约为1000万天，可以为正或负。'
- en: 'There are three ways to construct a `TimeSpan`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种构造`TimeSpan`的方法：
- en: Through one of the constructors
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过其中一个构造函数
- en: By calling one of the static `From`… methods
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用其中一个静态的`From`…方法
- en: By subtracting one `DateTime` from another
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将一个`DateTime`减去另一个
- en: 'Here are the constructors:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是构造函数：
- en: '[PRE49]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The static `From`… methods are more convenient when you want to specify an
    interval in just a single unit, such as minutes, hours, and so on:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要仅使用单个单位（如分钟、小时等）指定间隔时，静态的`From`…方法更方便：
- en: '[PRE50]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'For example:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE51]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`TimeSpan` overloads the `<` and `>` operators as well as the `+` and `-` operators.
    The following expression evaluates to a `TimeSpan` of 2.5 hours:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`TimeSpan`重载了`<`和`>`运算符以及`+`和`-`运算符。以下表达式计算为2.5小时的`TimeSpan`：'
- en: '[PRE52]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The next expression evaluates to one second short of 10 days:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个表达式计算为比10天短一秒：
- en: '[PRE53]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Using this expression, we can illustrate the integer properties `Days`, `Hours`,
    `Minutes`, `Seconds`, and `Milliseconds`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个表达式，我们可以说明整数属性`Days`、`Hours`、`Minutes`、`Seconds`和`Milliseconds`：
- en: '[PRE54]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In contrast, the `Total`... properties return values of type `double` describing
    the entire time span:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`Total`...属性返回类型为`double`的值，描述整个时间跨度：
- en: '[PRE55]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The static `Parse` method does the opposite of `ToString`, converting a string
    to a `TimeSpan`. `TryParse` does the same but returns `false` rather than throwing
    an exception if the conversion fails. The `XmlConvert` class also provides `TimeSpan`/string
    conversion methods that follow standard XML formatting protocols.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的`Parse`方法执行与`ToString`相反的操作，将字符串转换为`TimeSpan`。`TryParse`也执行相同的操作，但如果转换失败，则返回`false`而不是抛出异常。`XmlConvert`类还提供了`TimeSpan`/字符串转换方法，遵循标准的XML格式化协议。
- en: The default value for a `TimeSpan` is `TimeSpan.Zero`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`TimeSpan`的默认值是`TimeSpan.Zero`。'
- en: '`TimeSpan` can also be used to represent the time of the day (the elapsed time
    since midnight). To obtain the current time of day, call `DateTime.Now.TimeOfDay`.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`TimeSpan`也可以用来表示一天中的时间（自午夜以来经过的时间）。要获取当前时间，请调用`DateTime.Now.TimeOfDay`。'
- en: DateTime and DateTimeOffset
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DateTime和DateTimeOffset
- en: '`DateTime` and `DateTimeOffset` are immutable structs for representing a date
    and, optionally, a time. They have a resolution of 100 ns and a range covering
    the years 0001 through 9999.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTime`和`DateTimeOffset`是表示日期和（可选）时间的不可变结构体。它们的分辨率为100纳秒，范围涵盖0001年至9999年。'
- en: '`DateTimeOffset` is functionally similar to `DateTime`. Its distinguishing
    feature is that it also stores a Coordinated Universal Time (UTC) offset; this
    allows more meaningful results when comparing values across different time zones.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTimeOffset`在功能上类似于`DateTime`。其特点是它还存储一个协调世界时（UTC）偏移量；这在跨不同时区比较值时可以得到更有意义的结果。'
- en: Choosing between DateTime and DateTimeOffset
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在选择DateTime和DateTimeOffset之间
- en: '`DateTime` and `DateTimeOffset` differ in how they handle time zones. A `DateTime`
    incorporates a three-state flag indicating whether the `DateTime` is relative
    to the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTime`和`DateTimeOffset`在处理时区时有所不同。`DateTime`包含一个三态标志，指示`DateTime`是否相对于以下内容：'
- en: The local time on the current computer
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前计算机上的本地时间
- en: UTC (the modern equivalent of Greenwich Mean Time)
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UTC（格林尼治标准时间的现代等价物）
- en: Unspecified
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未指定的
- en: 'A `DateTimeOffset` is more specific—it stores the offset from UTC as a `TimeSpan`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTimeOffset`更具体一些—它将偏移量从UTC存储为`TimeSpan`：'
- en: '[PRE56]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This influences equality comparisons, which is the main factor in choosing
    between `DateTime` and `DateTimeOffset`. Specifically:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这会影响到相等比较，这是在选择`DateTime`和`DateTimeOffset`之间的主要因素。具体来说：
- en: '`DateTime` ignores the three-state flag in comparisons and considers two values
    equal if they have the same year, month, day, hour, minute, and so on.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DateTime`在比较中忽略了三态标志，并且认为如果它们具有相同的年、月、日、小时、分钟等，则两个值相等。'
- en: '`DateTimeOffset` considers two values equal if they refer to the *same point
    in time*.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DateTimeOffset`认为如果它们引用*同一时间点*，则两个值相等。'
- en: Warning
  id: totrans-262
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Daylight Saving Time can make this distinction important even if your application
    doesn’t need to handle multiple geographic time zones.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 夏令时使得这种区别变得重要，即使您的应用程序不需要处理多个地理时区。
- en: 'So, `DateTime` considers the following two values different, whereas `DateTimeOffset`
    considers them equal:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`DateTime` 认为以下两个值是不同的，而 `DateTimeOffset` 认为它们是相等的：
- en: '[PRE57]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In most cases, `DateTimeOffset`’s equality logic is preferable. For example,
    in calculating which of two international events is more recent, a `DateTimeOffset`
    implicitly gives the correct answer. Similarly, a hacker plotting a Distributed
    Denial of Service attack would reach for a `DateTimeOffset`! To do the same with
    `DateTime` requires standardizing on a single time zone (typically UTC) throughout
    your application. This is problematic for two reasons:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，`DateTimeOffset` 的相等逻辑更可取。例如，在计算两个国际事件中哪个更近时，`DateTimeOffset` 会隐式地给出正确答案。同样，计划进行分布式拒绝服务攻击的黑客也会选择
    `DateTimeOffset`！要使用 `DateTime` 实现相同效果，则需要在应用程序中统一使用单一时区（通常是 UTC）。这有两个问题：
- en: To be friendly to the end user, UTC `DateTime`s require explicit conversion
    to local time prior to formatting.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了对最终用户友好，UTC `DateTime` 需要在格式化之前显式转换为本地时间。
- en: It’s easy to forget and incorporate a local `DateTime`.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很容易忘记并纳入本地 `DateTime`。
- en: '`DateTime` is better, though, at specifying a value relative to the local computer
    at runtime—for example, if you want to schedule an archive at each of your international
    offices for next Sunday, at 3 A.M. local time (when there’s least activity). Here,
    `DateTime` would be more suitable because it would respect each site’s local time.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTime` 更好，尤其是在运行时相对于本地计算机指定值时——例如，如果您希望在每个国际办事处都安排下周日凌晨3点进行存档（当活动最少时）。在这种情况下，`DateTime`
    更合适，因为它会尊重每个地点的本地时间。'
- en: Note
  id: totrans-270
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Internally, `DateTimeOffset` uses a short integer to store the UTC offset in
    minutes. It doesn’t store any regional information, so there’s nothing present
    to indicate whether an offset of +08:00, for instance, refers to Singapore time
    or Perth time.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`DateTimeOffset` 使用短整数以分钟为单位存储 UTC 偏移量。它不存储任何地区信息，因此没有任何信息可以表明例如 +08:00
    的偏移量是指新加坡时间还是珀斯时间。
- en: We revisit time zones and equality comparison in more depth in [“Dates and Time
    Zones”](#dates_and_time_zones).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[“日期和时区”](#dates_and_time_zones)中深入探讨了时区和相等比较。
- en: Note
  id: totrans-273
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: SQL Server 2008 introduced direct support for `DateTimeOffset` through a new
    data type of the same name.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: SQL Server 2008 通过同名的新数据类型直接支持了 `DateTimeOffset`。
- en: Constructing a DateTime
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建 DateTime
- en: '`DateTime` defines constructors that accept integers for the year, month, and
    day—and optionally, the hour, minute, second, millisecond (and microsecond, from
    .NET 7):'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTime` 定义了构造函数，接受整数参数作为年、月、日——可选的还有时、分、秒、毫秒（从 .NET 7 开始，还包括微秒）：'
- en: '[PRE58]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If you specify only a date, the time is implicitly set to midnight (0:00).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只指定日期，时间会被默认设置为午夜（0:00）。
- en: 'The `DateTime` constructors also allow you to specify a `DateTimeKind`—an enum
    with the following values:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTime` 构造函数还允许您指定 `DateTimeKind`——一个包含以下值的枚举：'
- en: '[PRE59]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This corresponds to the three-state flag described in the preceding section.
    `Unspecified` is the default, and it means that the `DateTime` is time-zone-agnostic.
    `Local` means relative to the local time zone on the current computer. A local
    `DateTime` does not include information about *which particular time zone* it
    refers to, or, unlike `DateTimeOffset`, the numeric offset from UTC.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应于前一节描述的三态标志。`Unspecified` 是默认值，表示 `DateTime` 是时区无关的。`Local` 表示相对于当前计算机上的本地时区。本地
    `DateTime` 不包含有关其所指的具体时区的信息，或者说，不像 `DateTimeOffset` 那样包含与 UTC 的数值偏移量。
- en: A `DateTime`’s `Kind` property returns its `DateTimeKind`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTime` 的 `Kind` 属性返回其 `DateTimeKind`。'
- en: '`DateTime`’s constructors are also overloaded to accept a `Calendar` object,
    as well. This allows you to specify a date using any of the `Calendar` subclasses
    defined in `System.Globalization`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTime` 的构造函数还有重载形式，可以接受一个 `Calendar` 对象。这允许您使用 `System.Globalization` 中定义的任何
    `Calendar` 子类来指定日期：'
- en: '[PRE60]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: (The formatting of the date in this example depends on your computer’s control
    panel settings.) A `DateTime` always uses the default Gregorian calendar—this
    example, a one-time conversion, takes place during construction. To perform computations
    using another calendar, you must use the methods on the `Calendar` subclass itself.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: （本示例中的日期格式取决于计算机的控制面板设置。）`DateTime` 总是使用默认的公历日历——这个示例，一次性的转换，在构造时进行。要使用另一个日历进行计算，必须使用子类
    `Calendar` 自身的方法。
- en: You can also construct a `DateTime` with a single *ticks* value of type `long`,
    where *ticks* is the number of 100-ns intervals from midnight 01/01/0001.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用 `long` 类型的单个 *ticks* 值构造一个 `DateTime`，其中 *ticks* 是从公元 0001 年 01 月 01 日午夜开始的
    100 纳秒间隔数。
- en: For interoperability, `DateTime` provides the static `FromFileTime` and `FromFileTimeUtc`
    methods for converting from a Windows file time (specified as a `long`) and `FromOADate`
    for converting from an OLE automation date/time (specified as a `double`).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 为了互操作性，`DateTime` 提供了静态的 `FromFileTime` 和 `FromFileTimeUtc` 方法，用于从 Windows 文件时间（指定为
    `long`）和 `FromOADate` 方法转换从 OLE 自动化日期/时间（指定为 `double`）。
- en: To construct a `DateTime` from a string, call the static `Parse` or `ParseExact`
    method. Both methods accept optional flags and format providers; `ParseExact`
    also accepts a format string. We discuss parsing in greater detail in [“Formatting
    and Parsing”](#formatting_and_parsing).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字符串构造 `DateTime`，调用静态的 `Parse` 或 `ParseExact` 方法。这两种方法都接受可选的标志和格式提供程序；`ParseExact`
    还接受一个格式字符串。我们将在[“格式化和解析”](#formatting_and_parsing)中更详细地讨论解析。
- en: Constructing a DateTimeOffset
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造 DateTimeOffset
- en: '`DateTimeOffset` has a similar set of constructors. The difference is that
    you also specify a UTC offset as a `TimeSpan`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTimeOffset` 有一组类似的构造函数。区别在于，还需指定一个 UTC 偏移量作为 `TimeSpan`：'
- en: '[PRE61]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `TimeSpan` must amount to a whole number of minutes; otherwise, an exception
    is thrown.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`TimeSpan` 必须是整数分钟；否则，会引发异常。'
- en: '`DateTimeOffset` also has constructors that accept a `Calendar` object, a `long`
    *ticks* value, and static `Parse` and `ParseExact` methods that accept a string.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTimeOffset` 还有一些构造函数接受 `Calendar` 对象、`long` 类型的 *ticks* 值，以及静态的 `Parse`
    和 `ParseExact` 方法接受一个字符串。'
- en: 'You can construct a `DateTimeOffset` from an existing `DateTime` either by
    using these constructors:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下构造函数之一从现有的 `DateTime` 构造一个 `DateTimeOffset`：
- en: '[PRE62]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'or with an implicit cast:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用隐式转换：
- en: '[PRE63]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Note
  id: totrans-298
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The implicit cast from `DateTime` to `DateTimeOffset` is handy because most
    of the .NET BCL supports `DateTime`—not `DateTimeOffset`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `DateTime` 到 `DateTimeOffset` 的隐式转换非常方便，因为大多数 .NET BCL 支持 `DateTime` — 而不支持
    `DateTimeOffset`。
- en: 'If you don’t specify an offset, it’s inferred from the `DateTime` value using
    these rules:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不指定偏移量，它将从 `DateTime` 值中推断使用以下规则：
- en: If the `DateTime` has a `DateTimeKind` of `Utc`, the offset is zero.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `DateTime` 的 `DateTimeKind` 是 `Utc`，则偏移量为零。
- en: If the `DateTime` has a `DateTimeKind` of `Local` or `Unspecified` (the default),
    the offset is taken from the current local time zone.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `DateTime` 的 `DateTimeKind` 是 `Local` 或 `Unspecified`（默认值），则偏移量取自当前的本地时区。
- en: 'To convert in the other direction, `DateTimeOffset` provides three properties
    that return values of type `DateTime`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 转换到另一个方向时，`DateTimeOffset` 提供三个属性返回 `DateTime` 类型的值：
- en: The `UtcDateTime` property returns a `DateTime` in UTC time.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UtcDateTime` 属性返回 UTC 时间中的 `DateTime`。'
- en: The `LocalDateTime` property returns a `DateTime` in the current local time
    zone (converting it if necessary).
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalDateTime` 属性返回当前本地时区的 `DateTime`（如果需要，进行转换）。'
- en: The `DateTime` property returns a `DateTime` in whatever zone it was specified,
    with a `Kind` of `Unspecified` (i.e., it returns the UTC time plus the offset).
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DateTime` 属性返回一个 `DateTime`，在指定的任何区域，具有 `Kind` 为 `Unspecified`（即，它返回 UTC 时间加上偏移量）。'
- en: The current DateTime/DateTimeOffset
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当前的 DateTime/DateTimeOffset
- en: 'Both `DateTime` and `DateTimeOffset` have a static `Now` property that returns
    the current date and time:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTime` 和 `DateTimeOffset` 都有一个静态的 `Now` 属性，返回当前日期和时间：'
- en: '[PRE64]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`DateTime` also provides a `Today` property that returns just the date portion:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTime` 还提供一个 `Today` 属性，只返回日期部分：'
- en: '[PRE65]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The static `UtcNow` property returns the current date and time in UTC:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的 `UtcNow` 属性返回当前的 UTC 时间和日期：
- en: '[PRE66]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The precision of all these methods depends on the operating system and is typically
    in the 10 to 20 ms region.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法的精度取决于操作系统，通常在 10 到 20 毫秒的范围内。
- en: Working with dates and times
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理日期和时间
- en: '`DateTime` and `DateTimeOffset` provide a similar set of instance properties
    that return various date/time elements:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTime` 和 `DateTimeOffset` 提供一组类似的实例属性，返回不同的日期/时间元素：'
- en: '[PRE67]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '`DateTimeOffset` also has an `Offset` property of type `TimeSpan`.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTimeOffset` 还有一个 `Offset` 属性，类型为 `TimeSpan`。'
- en: 'Both types provide the following instance methods to perform computations (most
    accept an argument of type `double` or `int`):'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 两种类型提供以下实例方法来执行计算（大多数接受 `double` 或 `int` 类型的参数）：
- en: '[PRE68]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: These all return a new `DateTime` or `DateTimeOffset`, and they take into account
    such things as leap years. You can pass in a negative value to subtract.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都会返回一个新的 `DateTime` 或 `DateTimeOffset`，并考虑诸如闰年等因素。您可以传入负值来进行减法运算。
- en: 'The `Add` method adds a `TimeSpan` to a `DateTime` or `DateTimeOffset`. The
    `+` operator is overloaded to do the same job:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`Add` 方法将 `TimeSpan` 添加到 `DateTime` 或 `DateTimeOffset` 中。`+` 运算符重载以执行相同的操作：'
- en: '[PRE69]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'You can also subtract a `TimeSpan` from a `DateTime`/`DateTimeOffset` and subtract
    one `DateTime`/`DateTimeOffset` from another. The latter gives you a `TimeSpan`:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从 `DateTime`/`DateTimeOffset` 中减去 `TimeSpan`，以及从一个 `DateTime`/`DateTimeOffset`
    中减去另一个 `DateTime`/`DateTimeOffset`。后者会返回一个 `TimeSpan`：
- en: '[PRE70]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Formatting and parsing datetimes
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式化和解析日期时间
- en: 'Calling `ToString` on a `DateTime` formats the result as a *short date* (all
    numbers) followed by a *long time* (including seconds); for example:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `DateTime` 上调用 `ToString` 时，格式化结果将作为 *短日期*（所有数字）后跟 *长时间*（包括秒）；例如：
- en: '[PRE71]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The operating system’s control panel, by default, determines such things as
    whether the day, month, or year comes first, the use of leading zeros, and whether
    12- or 24-hour time is used.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统的控制面板默认确定诸如日期、月份或年份的顺序，前导零的使用以及是否使用12小时或24小时制。
- en: 'Calling `ToString` on a `DateTimeOffset` is the same, except that the offset
    is also returned:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `DateTimeOffset` 上调用 `ToString` 时，除了返回偏移量之外，还会返回相同的内容：
- en: '[PRE72]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `ToShortDateString` and `ToLongDateString` methods return just the date
    portion. The long date format is also determined by the control panel; an example
    is “Wednesday, 11 November 2015.” `ToShortTimeString` and `ToLongTimeString` return
    just the time portion, such as 17:10:10 (the former excludes seconds).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToShortDateString` 和 `ToLongDateString` 方法仅返回日期部分。长日期格式也由控制面板确定；例如：“2015年11月11日
    星期三”。`ToShortTimeString` 和 `ToLongTimeString` 方法仅返回时间部分，例如17:10:10（前者不包括秒）。'
- en: These four just-described methods are actually shortcuts to four different *format
    strings*. `ToString` is overloaded to accept a format string and provider, allowing
    you to specify a wide range of options and control how regional settings are applied.
    We describe this in [“Formatting and Parsing”](#formatting_and_parsing).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个刚才描述的方法实际上是四个不同的 *格式字符串* 的快捷方式。`ToString` 被重载以接受格式字符串和提供程序，允许您指定广泛的选项并控制如何应用区域设置。我们在
    [“格式化和解析”](#格式化和解析) 中描述了这一点。
- en: Warning
  id: totrans-334
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: '`DateTime`s and `DateTimeOffset`s can be misparsed if the culture settings
    differ from those in force when formatting takes place. You can avoid this problem
    by using `ToString` in conjunction with a format string that ignores culture settings
    (such as “o”):'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果区域设置设置与格式化时不同，则可能会误解 `DateTime` 和 `DateTimeOffset`。您可以通过使用忽略区域设置的格式字符串（如“o”）与
    `ToString` 结合使用来避免此问题：
- en: '[PRE73]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The static `Parse`/`TryParse` and `ParseExact`/`TryParseExact` methods do the
    reverse of `ToString`, converting a string to a `DateTime` or `DateTimeOffset`.
    These methods are also overloaded to accept a format provider. The `Try`* methods
    return `false` instead of throwing a `FormatException`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的 `Parse`/`TryParse` 和 `ParseExact`/`TryParseExact` 方法执行 `ToString` 的反操作，将字符串转换为
    `DateTime` 或 `DateTimeOffset`。这些方法还被重载以接受格式提供程序。`Try`* 方法在转换失败时返回 `false` 而不是抛出
    `FormatException`。
- en: Null DateTime and DateTimeOffset values
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空的 DateTime 和 DateTimeOffset 值
- en: 'Because `DateTime` and `DateTimeOffset` are structs, they are not intrinsically
    nullable. When you need nullability, there are two ways around this:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `DateTime` 和 `DateTimeOffset` 是结构体，它们本身不可为空。当你需要可空性时，有两种方法可以解决这个问题：
- en: Use a `Nullable` type (i.e., `DateTime?` or `DateTimeOffset?`).
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可空类型（即 `DateTime?` 或 `DateTimeOffset?`）。
- en: Use the static field `DateTime.MinValue` or `DateTimeOffset.MinValue` (the *default
    values* for these types).
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用静态字段 `DateTime.MinValue` 或 `DateTimeOffset.MinValue`（这些类型的 *默认值*）。
- en: A nullable type is usually the best approach because the compiler helps to prevent
    mistakes. `DateTime.MinValue` is useful for backward compatibility with code written
    prior to C# 2.0 (when nullable value types were introduced).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 可空类型通常是最佳选择，因为编译器可以帮助防止错误。`DateTime.MinValue` 对于与早于 C# 2.0 的代码向后兼容（当时引入了可空值类型）非常有用。
- en: Warning
  id: totrans-343
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Calling `ToUniversalTime` or `ToLocalTime` on a `DateTime.MinValue` can result
    in it no longer being `DateTime.MinValue` (depending on which side of GMT you
    are on). If you’re right on GMT (England, outside daylight saving), the problem
    won’t arise at all because local and UTC times are the same. This is your compensation
    for the English winter!
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `DateTime.MinValue` 上调用 `ToUniversalTime` 或 `ToLocalTime` 可能导致它不再是 `DateTime.MinValue`（取决于你位于
    GMT 的哪一侧）。如果你正好在 GMT 上（如英格兰，在夏令时之外），这个问题将不会出现，因为本地时间和 UTC 时间相同。这是你对英国冬季的补偿！
- en: DateOnly and TimeOnly
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DateOnly 和 TimeOnly
- en: The `DateOnly` and `TimeOnly` structs (from .NET 6) exist for when you *only*
    want to represent a date or time.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateOnly` 和 `TimeOnly` 结构体（来自 .NET 6）存在的目的是当你*仅仅*想表示日期或时间时使用。'
- en: '`DateOnly` is similar to `DateTime`, but without a time component. `DateOnly`
    also lacks `DateTimeKind`; in effect, it’s always `Unspecified` and has no concept
    of `Local` or `Utc`. The historical alternative to `DateOnly` was to use `DateTime`
    with a zero time (midnight). The difficulty with this approach is that equality
    comparisons fail when a non-zero time find its way into your code.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateOnly` 类似于 `DateTime`，但没有时间部分。`DateOnly` 也缺乏 `DateTimeKind`；实际上，它总是 `Unspecified`，没有
    `Local` 或 `Utc` 的概念。`DateOnly` 的历史替代方案是使用零时间（午夜）的 `DateTime`。这种方法的困难之处在于，当非零时间出现在你的代码中时，相等性比较会失败。'
- en: '`TimeOnly` is similar to `DateTime`, but without a date component. `TimeOnly`
    is intended for capturing the time of day and is suitable for applications such
    as recording alarm times or opening hours.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`TimeOnly` 类似于 `DateTime`，但没有日期部分。`TimeOnly` 用于捕捉一天中的时间，适用于记录闹钟时间或营业时间等应用。'
- en: Dates and Time Zones
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期和时区
- en: In this section, we examine in more detail how time zones influence `DateTime`
    and `DateTimeOffset`. We also look at the `TimeZoneInfo` type, which provides
    information on time zone offsets and Daylight Saving Time.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们更详细地探讨了时区如何影响 `DateTime` 和 `DateTimeOffset`。我们还研究了 `TimeZoneInfo` 类型，该类型提供有关时区偏移和夏令时信息的信息。
- en: DateTime and Time Zones
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DateTime 和时区
- en: '`DateTime` is simplistic in its handling of time zones. Internally, it stores
    a `DateTime` using two pieces of information:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTime` 在处理时区时是简单的。在内部，它使用两个信息来存储 `DateTime`：'
- en: A 62-bit number, indicating the number of ticks since 1/1/0001
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 62 位数字，表示自公元 1/1/0001 起的 ticks 数量
- en: A 2-bit enum, indicating the `DateTimeKind` (`Unspecified`, `Local`, or `Utc`)
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 2 位枚举，表示 `DateTimeKind`（`Unspecified`，`Local` 或 `Utc`）
- en: 'When you compare two `DateTime` instances, only their *ticks* values are compared;
    their `DateTimeKind`s are ignored:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 当你比较两个 `DateTime` 实例时，只比较它们的 *ticks* 值；它们的 `DateTimeKind` 将被忽略：
- en: '[PRE74]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The instance methods `ToUniversalTime`/`ToLocalTime` convert to universal/local
    time. These apply the computer’s current time zone settings and return a new `DateTime`
    with a `DateTimeKind` of `Utc` or `Local`. No conversion happens if you call `ToUniversalTime`
    on a `DateTime` that’s already `Utc`, or `ToLocalTime` on a `DateTime` that’s
    already `Local`. You will get a conversion, however, if you call `ToUniversalTime`
    or `ToLocalTime` on a `DateTime` that’s `Unspecified`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 实例方法 `ToUniversalTime`/`ToLocalTime` 将转换为通用/本地时间。这些方法应用于计算机当前的时区设置，并返回一个带有 `DateTimeKind`
    为 `Utc` 或 `Local` 的新 `DateTime`。如果在已经是 `Utc` 的 `DateTime` 上调用 `ToUniversalTime`，或者在已经是
    `Local` 的 `DateTime` 上调用 `ToLocalTime`，则不会发生转换。但是，如果在 `Unspecified` 的 `DateTime`
    上调用 `ToUniversalTime` 或 `ToLocalTime`，则会进行转换。
- en: 'You can construct a `DateTime` that differs from another only in `Kind` with
    the static `DateTime.SpecifyKind` method:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用静态方法 `DateTime.SpecifyKind` 构造一个在 `Kind` 方面与另一个不同的 `DateTime`：
- en: '[PRE75]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: DateTimeOffset and Time Zones
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DateTimeOffset 和时区
- en: Internally, `DateTimeOffset` comprises a `DateTime` field whose value is always
    in UTC, and a 16-bit integer field for the UTC offset in minutes. Comparisons
    look only at the (UTC) `DateTime`; the `Offset` is used primarily for formatting.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`DateTimeOffset` 包含一个 `DateTime` 字段，其值始终为 UTC，并且一个 16 位整数字段表示 UTC 偏移量（以分钟计）。比较仅考虑（UTC）`DateTime`；`Offset`
    主要用于格式化。
- en: 'The `ToUniversalTime`/`ToLocalTime` methods return a `DateTimeOffset` representing
    the same point in time but with a UTC or local offset. Unlike with `DateTime`,
    these methods don’t affect the underlying date/time value, only the offset:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToUniversalTime`/`ToLocalTime` 方法返回一个 `DateTimeOffset`，表示同一时间点但带有 UTC 或本地偏移量。与
    `DateTime` 不同的是，这些方法不会影响基础的日期/时间值，只影响偏移量：'
- en: '[PRE76]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'To include the `Offset` in the comparison, you must use the `EqualsExact` method:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 要在比较中包含 `Offset`，必须使用 `EqualsExact` 方法：
- en: '[PRE77]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: TimeZoneInfo
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TimeZoneInfo
- en: The `TimeZoneInfo` class provides information on time zone names, UTC offsets,
    and Daylight Saving Time rules.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`TimeZoneInfo`类提供有关时区名称、UTC偏移和夏令时规则的信息。'
- en: TimeZone
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时区
- en: The static `TimeZone.CurrentTimeZone` method returns a `TimeZone`
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法`TimeZone.CurrentTimeZone`返回一个`TimeZone`
- en: '[PRE78]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The `GetDaylightChanges` method returns specific Daylight Saving Time information
    for a given year:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetDaylightChanges`方法返回给定年份的特定夏令时信息：'
- en: '[PRE79]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: TimeZoneInfo
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TimeZoneInfo
- en: 'The static `TimeZoneInfo.Local` method returns a `TimeZoneInfo` object based
    on the current local settings. The following demonstrates the result if run in
    California:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法`TimeZoneInfo.Local`根据当前本地设置返回一个`TimeZoneInfo`对象。以下演示了在加利福尼亚运行时的结果：
- en: '[PRE80]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `IsDaylightSavingTime` and `GetUtcOffset` methods work as follows:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsDaylightSavingTime`和`GetUtcOffset`方法的工作方式如下：'
- en: '[PRE81]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'You can obtain a `TimeZoneInfo` for any of the world’s time zones by calling
    `Find​Sys⁠temTimeZoneById` with the zone ID. We’ll switch to Western Australia
    for reasons that will soon become clear:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用`Find​Sys⁠temTimeZoneById`并传入时区ID来获取世界任何时区的`TimeZoneInfo`。我们将因很快会变得清楚的原因而切换到西澳大利亚：
- en: '[PRE82]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The `Id` property corresponds to the value passed to `FindSystemTimeZoneById`.
    The static `GetSystemTimeZones` method returns all world time zones; hence, you
    can list all valid zone ID strings as follows:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`Id`属性对应于传递给`FindSystemTimeZoneById`的值。静态的`GetSystemTimeZones`方法返回所有世界时区；因此，您可以列出所有有效的时区ID字符串如下：'
- en: '[PRE83]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Note
  id: totrans-382
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can also create a custom time zone by calling `TimeZoneInfo.CreateCustomTimeZone`.
    Because `TimeZoneInfo` is immutable, you must pass in all the relevant data as
    method arguments.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过调用`TimeZoneInfo.CreateCustomTimeZone`创建自定义时区。由于`TimeZoneInfo`是不可变的，您必须将所有相关数据作为方法参数传入。
- en: You can serialize a predefined or custom time zone to a (semi) human-readable
    string by calling `ToSerializedString`—and deserialize it by calling `TimeZoneInfo.FromSerializedString`.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用`ToSerializedString`将预定义或自定义时区序列化为（半）人类可读的字符串，并通过调用`TimeZoneInfo.FromSerializedString`进行反序列化。
- en: The static `ConvertTime` method converts a `DateTime` or `DateTimeOffset` from
    one time zone to another. You can include either just a destination `TimeZoneInfo`,
    or both source and destination `TimeZoneInfo` objects. You can also convert directly
    from or to UTC with the methods `ConvertTimeFromUtc` and `ConvertTimeToUtc`.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法`ConvertTime`将`DateTime`或`DateTimeOffset`从一个时区转换到另一个时区。您可以只包括目标`TimeZoneInfo`，或同时包括源和目标`TimeZoneInfo`对象。您还可以使用`ConvertTimeFromUtc`和`ConvertTimeToUtc`方法直接与UTC进行转换。
- en: 'For working with Daylight Saving Time, `TimeZoneInfo` provides the following
    additional methods:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理夏令时，`TimeZoneInfo`提供以下额外方法：
- en: '`IsInvalidTime` returns `true` if a `DateTime` is within the hour (or delta)
    that’s skipped when the clocks move forward.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`DateTime`处于时钟前进时被跳过的一小时（或增量）内，则`IsInvalidTime`返回`true`。
- en: '`IsAmbiguousTime` returns `true` if a `DateTime` or `DateTimeOffset` is within
    the hour (or delta) that’s repeated when the clocks move back.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`DateTime`或`DateTimeOffset`处于时钟倒退时重复的一小时（或增量）内，则`IsAmbiguousTime`返回`true`。
- en: '`GetAmbiguousTimeOffsets` returns an array of `TimeSpan`s representing the
    valid offset choices for an ambiguous `DateTime` or `DateTimeOffset`.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetAmbiguousTimeOffsets`返回一个`TimeSpan`数组，表示模糊的`DateTime`或`DateTimeOffset`的有效偏移选择。'
- en: 'You can’t obtain simple dates from a `TimeZoneInfo` indicating the start and
    end of Daylight Saving Time. Instead, you must call `GetAdjustmentRules`, which
    returns a declarative summary of all daylight saving rules that apply to all years.
    Each rule has a `DateStart` and `DateEnd` indicating the date range within which
    the rule is valid:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 您无法从`TimeZoneInfo`获取夏令时开始和结束的简单日期。而是必须调用`GetAdjustmentRules`，该方法返回适用于所有年份的所有夏令时规则的声明性摘要。每个规则都有一个`DateStart`和`DateEnd`，指示规则有效的日期范围：
- en: '[PRE84]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Western Australia first introduced Daylight Saving Time in 2006, *midseason*
    (and then rescinded it in 2009). This required a special rule for the first year;
    hence, there are two rules:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 西澳大利亚于2006年首次引入夏令时，*在赛季中期*（然后在2009年撤销）。这需要在第一年制定特别规则；因此，存在两个规则：
- en: '[PRE85]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Each `AdjustmentRule` has a `DaylightDelta` property of type `TimeSpan` (this
    is one hour in almost every case) and properties called `DaylightTransitionStart`
    and `DaylightTransitionEnd`. The latter two are of type `TimeZoneInfo.TransitionTime`,
    which has the following properties:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`AdjustmentRule`都有一个`DaylightDelta`属性，类型为`TimeSpan`（几乎每种情况下为一小时），以及名为`DaylightTransitionStart`和`DaylightTransitionEnd`的属性。后两者的类型为`TimeZoneInfo.TransitionTime`，具有以下属性：
- en: '[PRE86]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'A transition time is somewhat complicated in that it needs to represent both
    fixed and floating dates. An example of a floating date is “the last Sunday in
    March.” Here are the rules for interpreting a transition time:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 过渡时间有点复杂，因为它需要同时表示固定日期和浮动日期。浮动日期的一个示例是“三月的最后一个星期日”。以下是解释过渡时间的规则：
- en: If, for an end transition, `IsFixedDateRule` is `true`, `Day` is `1`, `Month`
    is `1`, and `TimeOfDay` is `DateTime.MinValue`, there is no end to Daylight Saving
    Time in that year (this can happen only in the southern hemisphere, upon the initial
    introduction of daylight saving time to a region).
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果对于结束过渡，`IsFixedDateRule`为`true`，`Day`为`1`，`Month`为`1`，`TimeOfDay`为`DateTime.MinValue`，则在该年中没有夏令时的结束（这仅可能发生在南半球，在向该地区引入夏令时时）。
- en: Otherwise, if `IsFixedDateRule` is `true`, the `Month`, `Day`, and `TimeOfDay`
    properties determine the start or end of the adjustment rule.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，如果`IsFixedDateRule`为`true`，则`Month`、`Day`和`TimeOfDay`属性确定调整规则的开始或结束。
- en: Otherwise, if `IsFixedDateRule` is `false`, the `Month`, `DayOfWeek`, `Week`,
    and `TimeOfDay` properties determine the start or end of the adjustment rule.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，如果`IsFixedDateRule`为`false`，则`Month`、`DayOfWeek`、`Week`和`TimeOfDay`属性确定调整规则的开始或结束。
- en: 'In the last case, `Week` refers to the week of the month, with “5” meaning
    the last week. We can demonstrate this by enumerating the adjustment rules for
    our `wa` time zone:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一种情况下，`Week`指的是月中的第几周，“5”表示最后一周。我们可以通过枚举我们`wa`时区的调整规则来证明这一点：
- en: '[PRE87]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'In `FormatTransitionTime`, we honor the rules just described:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FormatTransitionTime`中，我们遵循刚才描述的规则：
- en: '[PRE88]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Daylight Saving Time and DateTime
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 夏令时和DateTime
- en: If you use a `DateTimeOffset` or a UTC `DateTime`, equality comparisons are
    unimpeded by the effects of Daylight Saving Time. But with local `DateTime`s,
    daylight saving can be problematic.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`DateTimeOffset`或UTC `DateTime`，则等式比较不受夏令时影响的影响。但是对于本地的`DateTime`，夏令时可能会带来问题。
- en: 'We can summarize the rules as follows:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以总结规则如下：
- en: Daylight saving affects local time but not UTC time.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 夏令时影响本地时间，但不影响UTC时间。
- en: When the clocks turn back, comparisons that rely on time moving forward will
    break if (and only if) they use local `DateTime`s.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当时钟回拨时，依赖时间向前移动的比较会中断，但仅当它们使用本地`DateTime`时。
- en: You can always reliably round-trip between UTC and local times (on the same
    computer)—even as the clocks turn back.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您始终可以在UTC和本地时间之间（在同一台计算机上）可靠地往返（即使时钟回拨）。
- en: 'The `IsDaylightSavingTime` tells you whether a given local `DateTime` is subject
    to Daylight Saving Time. UTC times always return `false`:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsDaylightSavingTime`告诉您给定的本地`DateTime`是否适用于夏令时。UTC时间始终返回`false`：'
- en: '[PRE89]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Assuming `dto` is a `DateTimeOffset`, the following expression does the same:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`dto`是一个`DateTimeOffset`，则以下表达式也会产生相同效果：
- en: '[PRE90]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The end of Daylight Saving Time presents a particular complication for algorithms
    that use local time, because when the clocks go back, the same hour (or more precisely,
    `Delta`) repeats itself.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 夏令时的结束对使用本地时间的算法提出了特定的复杂性问题，因为当时钟回拨时，同一小时（或更精确地说，`Delta`）会重复。
- en: Note
  id: totrans-415
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can reliably compare any two `DateTime`s by first calling `ToUniversalTime`
    on each. This strategy fails if (and only if) exactly one of them has a `DateTimeKind`
    of `Unspecified`. This potential for failure is another reason for favoring `DateTimeOffset`.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过首先在每个`DateTime`上调用`ToUniversalTime`来可靠地比较任何两个`DateTime`。如果它们中正好有一个的`DateTimeKind`为`Unspecified`，则此策略会失败。这种失败的可能性是支持`DateTimeOffset`的另一个原因。
- en: Formatting and Parsing
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化和解析
- en: 'Formatting means converting *to* a string; parsing means converting *from*
    a string. The need to format or parse arises frequently in programming, in a variety
    of situations. Hence, .NET provides a variety of mechanisms:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化意味着将*转换为*字符串；解析意味着从字符串*转换为*。在编程中，经常需要进行格式化或解析，在各种情况下。因此，.NET提供了多种机制：
- en: '`ToString` and `Parse`'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToString`和`Parse`'
- en: These methods provide default functionality for many types.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法为许多类型提供默认功能。
- en: Format providers
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 格式提供程序
- en: These manifest as additional `ToString` (and `Parse`) methods that accept a
    *format string* and/or a *format provider*. Format providers are highly flexible
    and culture-aware. .NET includes format providers for the numeric types and `DateTime`/`DateTimeOffset`.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这些表现为额外的`ToString`（和`Parse`）方法，这些方法接受*格式字符串*和/或*格式提供程序*。格式提供程序非常灵活且与文化相关。.NET包含用于数字类型和`DateTime`/`DateTimeOffset`的格式提供程序。
- en: '`XmlConvert`'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`XmlConvert`'
- en: This is a static class with methods that format and parse while honoring XML
    standards. `XmlConvert` is also useful for general-purpose conversion when you
    need culture independence or you want to preempt misparsing. `XmlConvert` supports
    the numeric types, `bool`, `DateTime`, `DateTimeOffset`, `TimeSpan`, and `Guid`.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个静态类，具有遵守XML标准的格式化和解析方法。`XmlConvert`在需要文化独立性或希望预防误解析时也非常有用。`XmlConvert`支持数字类型、`bool`、`DateTime`、`DateTimeOffset`、`TimeSpan`和`Guid`。
- en: Type converters
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换器
- en: These target designers and XAML parsers.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 这些目标设计者和XAML解析器。
- en: In this section, we discuss the first two mechanisms, focusing particularly
    on format providers. We then describe `XmlConvert`, type converters, and other
    conversion mechanisms.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了前两种机制，特别关注格式提供者。然后我们描述了`XmlConvert`、类型转换器和其他转换机制。
- en: ToString and Parse
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ToString和Parse
- en: 'The simplest formatting mechanism is the `ToString` method. It gives meaningful
    output on all simple value types (`bool`, `DateTime`, `DateTimeOffset`, `TimeSpan`,
    `Guid`, and all the numeric types). For the reverse operation, each of these types
    defines a static `Parse` method:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的格式化机制是`ToString`方法。它对所有简单值类型（`bool`、`DateTime`、`DateTimeOffset`、`TimeSpan`、`Guid`以及所有数值类型）都提供了有意义的输出。对于逆操作，每种类型都定义了一个静态的`Parse`方法：
- en: '[PRE91]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'If the parsing fails, a `FormatException` is thrown. Many types also define
    a `TryParse` method, which returns `false` if the conversion fails rather than
    throwing an exception:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 如果解析失败，将抛出`FormatException`。许多类型还定义了`TryParse`方法，如果转换失败，则返回`false`而不是抛出异常：
- en: '[PRE92]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'If you don’t care about the output and want to test only whether parsing would
    succeed, you can use a discard:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不关心输出，并且只想测试解析是否成功，您可以使用抛弃：
- en: '[PRE93]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: If you anticipate an error, calling `TryParse` is faster and more elegant than
    calling `Parse` in an exception handling block.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如果预期可能出错，调用`TryParse`比在异常处理块中调用`Parse`更快且更优雅。
- en: 'The `Parse` and `TryParse` methods on `DateTime`(`Offset`) and the numeric
    types respect local culture settings; you can change this by specifying a `CultureInfo`
    object. Specifying invariant culture is often a good idea. For instance, parsing
    “1.234” into a `double` gives us 1234 in Germany:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DateTime`（`Offset`）和数值类型上，`Parse`和`TryParse`方法遵循本地文化设置；您可以通过指定`CultureInfo`对象来更改这一点。通常指定不变文化是个好主意。例如，在德国将“1.234”解析为`double`会得到1234：
- en: '[PRE94]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'This is because in Germany, the period indicates a thousands separator rather
    than a decimal point. Specifying *invariant culture* fixes this:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在德国，句点表示千位分隔符而不是小数点。指定*不变文化*可以修复这个问题：
- en: '[PRE95]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The same applies when calling `ToString()`:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`ToString()`时情况也是如此：
- en: '[PRE96]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Note
  id: totrans-442
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: From .NET 8, the .NET numeric and date/time types (as well as other simple types)
    allow direct formatting and parsing of UTF-8, via new `TryFormat` and `Parse`/`TryParse`
    methods that operate on a byte array or `Span<byte>` (see [Chapter 23](ch23.html#spanless_thantgreater_than_and-id00089)).
    In high-performance scenarios, this can be more efficient than working with ordinary
    (UTF-16) strings and performing a separate UTF-8 encoding/decoding.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 从.NET 8开始，.NET数字和日期/时间类型（以及其他简单类型）允许直接使用UTF-8进行格式化和解析，通过新的`TryFormat`和`Parse`/`TryParse`方法，这些方法操作字节数组或`Span<byte>`（见[第23章](ch23.html#spanless_thantgreater_than_and-id00089)）。在高性能场景中，这比使用普通（UTF-16）字符串并执行单独的UTF-8编码/解码更有效率。
- en: Format Providers
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式化提供者
- en: Sometimes, you need more control over how formatting and parsing take place.
    There are dozens of ways to format a `DateTime(Offset)`, for instance. Format
    providers allow extensive control over formatting and parsing, and are supported
    for numeric types and date/times. Format providers are also used by user interface
    controls for formatting and parsing.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您需要更多控制格式化和解析的方式。例如，有多种方法可以格式化`DateTime(Offset)`。格式提供者允许在格式化和解析方面进行广泛控制，并且支持数字类型和日期/时间。格式提供者也被用户界面控件用于格式化和解析。
- en: 'The gateway to using a format provider is `IFormattable`. All numeric types—and
    `DateTime(Offset)`—implement this interface:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 使用格式提供者的入口是`IFormattable`。所有数值类型和`DateTime(Offset)`都实现了这个接口：
- en: '[PRE97]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The first argument is the *format string*; the second is the *format provider*.
    The format string provides instructions; the format provider determines how the
    instructions are translated. For example:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是*格式字符串*；第二个是*格式提供者*。格式字符串提供指令；格式提供者确定如何翻译这些指令。例如：
- en: '[PRE98]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Here, `"C"` is a format string that indicates *currency*, and the `NumberFormatInfo`
    object is a format provider that determines how currency—and other numeric representations—are
    rendered. This mechanism allows for globalization.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`"C"` 是指示*货币*格式的格式字符串，而 `NumberFormatInfo` 对象是一个格式提供程序，决定如何呈现货币和其他数字表示。这种机制支持全球化。
- en: Note
  id: totrans-451
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: All format strings for numbers and dates are listed in [“Standard Format Strings
    and Parsing Flags”](#standard_format_strings_and_parsing_fla).
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 所有数字和日期的格式字符串都列在[“标准格式字符串和解析标志”](#standard_format_strings_and_parsing_fla)中。
- en: 'If you specify a `null` format string or provider, a default is applied. The
    default format provider is `CultureInfo.CurrentCulture`, which, unless reassigned,
    reflects the computer’s runtime control panel settings. For example, on this computer:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定了 `null` 格式字符串或提供程序，将应用默认设置。默认格式提供程序是 `CultureInfo.CurrentCulture`，除非重新分配，它反映计算机的运行时控制面板设置。例如，在这台计算机上：
- en: '[PRE99]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'For convenience, most types overload `ToString` such that you can omit a `null`
    provider:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 为方便起见，大多数类型都重载了 `ToString` 方法，这样您可以省略 `null` 提供程序：
- en: '[PRE100]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Calling `ToString` on a `DateTime`(`Offset`) or a numeric type with no arguments
    is equivalent to using a default format provider, with an empty format string.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `DateTime`（`Offset`）或无参数的数值类型上调用 `ToString` 等同于使用默认格式提供程序和空格式字符串。
- en: '.NET defines three format providers (all of which implement `IFormatProvider`):'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 定义了三种格式提供程序（它们都实现了 `IFormatProvider` 接口）：
- en: '[PRE101]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Note
  id: totrans-460
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: All `enum` types are also formattable, though there’s no special `IFormatProvider`
    class.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 `enum` 类型也都可格式化，尽管没有特殊的 `IFormatProvider` 类。
- en: Format providers and CultureInfo
  id: totrans-462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式提供程序和 CultureInfo
- en: Within the context of format providers, `CultureInfo` acts as an indirection
    mechanism for the other two format providers, returning a `NumberFormatInfo` or
    `Date​Ti⁠meFormatInfo` object applicable to the culture’s regional settings.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在格式提供程序的上下文中，`CultureInfo` 作为其他两个格式提供程序的间接机制，返回适用于文化区域设置的 `NumberFormatInfo`
    或 `Date​Ti⁠meFormatInfo` 对象。
- en: 'In the following example, we request a specific culture (*en*glish language
    in *G*reat *B*ritain):'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们请求特定的文化（*英*国*英*语）：
- en: '[PRE102]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: This executes using the default `NumberFormatInfo` object applicable to the
    en-GB culture.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用适用于 en-GB 文化的默认 `NumberFormatInfo` 对象执行。
- en: 'The next example formats a `DateTime` with invariant culture. Invariant culture
    is always the same, regardless of the computer’s settings:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例使用不变文化格式化一个 `DateTime`。不变文化始终保持不变，不管计算机的设置如何：
- en: '[PRE103]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Note
  id: totrans-469
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Invariant culture is based on American culture, with the following differences:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 不变文化基于美国文化，具有以下区别：
- en: The currency symbol is ☼ instead of $.
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 货币符号是 ☼ 而不是 $。
- en: Dates and times are formatted with leading zeros (though still with the month
    first).
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期和时间格式化为带有前导零的格式（虽然月份仍然是第一个）。
- en: Time uses the 24-hour format rather than an AM/PM designator.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间使用24小时制而不是AM/PM指示符。
- en: Using NumberFormatInfo or DateTimeFormatInfo
  id: totrans-474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 NumberFormatInfo 或 DateTimeFormatInfo
- en: 'In the next example, we instantiate a `NumberFormatInfo` and change the group
    separator from a comma to a space. We then use it to format a number to three
    decimal places:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们实例化一个 `NumberFormatInfo` 并将组分隔符从逗号更改为空格。然后我们使用它将一个数字格式化为三位小数：
- en: '[PRE104]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The initial settings for a `NumberFormatInfo` or `DateTimeFormatInfo` are based
    on the invariant culture. Sometimes, however, it’s more useful to choose a different
    starting point. To do this, you can `Clone` an existing format provider:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '`NumberFormatInfo` 或 `DateTimeFormatInfo` 的初始设置基于不变文化。然而，有时选择不同的起始点更有用。要做到这一点，您可以克隆一个现有的格式提供程序：'
- en: '[PRE105]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: A cloned format provider is always writable—even if the original was read-only.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆的格式提供程序始终是可写的，即使原始格式提供程序是只读的。
- en: Composite formatting
  id: totrans-480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复合格式化
- en: 'Composite format strings allow you to combine variable substitution with format
    strings. The static `string.Format` method accepts a composite format string (we
    illustrated this in [“String.Format and composite format strings”](#stringdotformat_and_composite_format_st)):'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 复合格式字符串允许您将变量替换与格式字符串结合使用。静态方法 `string.Format` 接受一个复合格式字符串（我们在[“String.Format
    和复合格式字符串”](#stringdotformat_and_composite_format_st)中演示了这一点）：
- en: '[PRE106]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The `Console` class itself overloads its `Write` and `WriteLine` methods to
    accept composite format strings, allowing us to shorten this example slightly:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '`Console` 类本身重载了其 `Write` 和 `WriteLine` 方法，以接受复合格式字符串，允许我们稍微简化此示例：'
- en: '[PRE107]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: You can also append a composite format string to a `StringBuilder` (via `AppendFormat`),
    and to a `TextWriter` for I/O (see [Chapter 15](ch15.html#streams_and_isoliduso)).
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将复合格式字符串附加到`StringBuilder`（通过`AppendFormat`），以及用于I/O的`TextWriter`（参见[第15章](ch15.html#streams_and_isoliduso)）。
- en: '`string.Format` accepts an optional format provider. A simple application for
    this is to call `ToString` on an arbitrary object while passing in a format provider:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '`string.Format`接受一个可选的格式提供程序。这个的简单应用就是对任意对象调用`ToString`并传入一个格式提供程序：'
- en: '[PRE108]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'This is equivalent to the following:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于以下内容：
- en: '[PRE109]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Parsing with format providers
  id: totrans-490
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用格式提供程序进行解析
- en: There’s no standard interface for parsing through a format provider. Instead,
    each participating type overloads its static `Parse` (and `TryParse`) method to
    accept a format provider, and optionally, a `NumberStyles` or `DateTimeStyles`
    enum.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 没有用于遍历格式提供程序的标准接口。相反，每个参与的类型都会重载其静态`Parse`（和`TryParse`）方法以接受格式提供程序，以及可选的`NumberStyles`或`DateTimeStyles`枚举。
- en: '`NumberStyles` and `DateTimeStyles` control how parsing works: they let you
    specify such things as whether parentheses or a currency symbol can appear in
    the input string. (By default, the answer to both questions is *no*.) For example:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '`NumberStyles`和`DateTimeStyles`控制解析的方式：它们允许您指定诸如输入字符串中是否可以出现括号或货币符号等内容。 （默认情况下，对这两个问题的答案都是*否*。）例如：'
- en: '[PRE110]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The next section lists all `NumberStyles` and `DateTimeStyles` members as well
    as the default parsing rules for each type.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节列出了所有`NumberStyles`和`DateTimeStyles`成员以及每种类型的默认解析规则。
- en: IFormatProvider and ICustomFormatter
  id: totrans-495
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IFormatProvider和ICustomFormatter
- en: 'All format providers implement `IFormatProvider`:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 所有格式提供程序都实现了`IFormatProvider`：
- en: '[PRE111]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The purpose of this method is to provide indirection—this is what allows `CultureInfo`
    to defer to an appropriate `NumberFormatInfo` or `DateTimeFormatInfo` object to
    do the work.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的目的是提供间接性——这使得`CultureInfo`可以推迟到适当的`NumberFormatInfo`或`DateTimeFormatInfo`对象来完成工作。
- en: 'By implementing `IFormatProvider`—along with `ICustomFormatter`—you can also
    write your own format provider that works in conjunction with existing types.
    `ICustomFormatter` defines a single method, as follows:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现`IFormatProvider`和`ICustomFormatter`，您还可以编写自己的格式提供程序，与现有类型一起使用。`ICustomFormatter`定义了一个方法，如下所示：
- en: '[PRE112]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The following custom format provider writes numbers as words:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的自定义格式提供程序将数字写成单词：
- en: '[PRE113]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Notice that in the `Format` method, we used `string.Format`—with `InvariantCulture`—to
    convert the input number to a string. It would have been simpler just to call
    `ToString()` on `arg`, but then `CurrentCulture` would have been used, instead.
    The reason for needing the invariant culture is evident a few lines later:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`Format`方法中，我们使用了`string.Format`——并使用了`InvariantCulture`——来将输入的数字转换为字符串。只需调用`arg.ToString()`会更简单，但那样会使用`CurrentCulture`。稍后几行代码之后需要使用不变文化的原因很明显：
- en: '[PRE114]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: It’s critical here that the number string comprises only the characters `0123456789-.`
    and not any internationalized versions of these.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 这里至关重要的是，数字字符串仅包含字符`0123456789-.`，而不包含任何这些字符的国际化版本。
- en: 'Here’s an example of using `WordyFormatProvider`:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`WordyFormatProvider`的示例：
- en: '[PRE115]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: You can use custom format providers only in composite format strings.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 您只能在复合格式字符串中使用自定义格式提供程序。
- en: Standard Format Strings and Parsing Flags
  id: totrans-509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准格式字符串和解析标志
- en: 'The standard format strings control how a numeric type or `DateTime`/`DateTimeOffset`
    is converted to a string. There are two kinds of format strings:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 标准格式字符串控制如何将数字类型或`DateTime`/`DateTimeOffset`转换为字符串。有两种类型的格式字符串：
- en: Standard format strings
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 标准格式字符串
- en: With these, you provide general guidance. A standard format string consists
    of a single letter, followed, optionally, by a digit (whose meaning depends on
    the letter). An example is `"C"` or `"F2"`.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些，您可以提供一般性指导。标准格式字符串由单个字母组成，后面可以跟一个数字（其含义取决于字母）。例如`"C"`或`"F2"`。
- en: Custom format strings
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义格式字符串
- en: With these, you micromanage every character with a template. An example is `"0:#.000E+00"`.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些模板，您可以微观管理每个字符。例如`"0:#.000E+00"`。
- en: Custom format strings are unrelated to custom format providers.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义格式字符串与自定义格式提供程序无关。
- en: Numeric Format Strings
  id: totrans-516
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字格式字符串
- en: '[Table 6-2](#standard_numeric_format_strings) lists all standard numeric format
    strings.'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 6-2](#standard_numeric_format_strings)列出了所有标准数字格式字符串。'
- en: Table 6-2\. Standard numeric format strings
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-2\. 标准数字格式字符串
- en: '| Letter | Meaning | Sample input | Result | Notes |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
  zh: '| 字母 | 含义 | 示例输入 | 结果 | 注释 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-520
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `G` or `g` | “General” | `1.2345, "G"` `0.00001, "G"`'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '| `G` 或 `g` | “一般” | `1.2345, "G"` `0.00001, "G"`'
- en: '`0.00001, "g"`'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '`0.00001, "g"`'
- en: '`1.2345, "G3"`'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '`1.2345, "G3"`'
- en: '`12345, "G3"` | `1.2345` `1E-05`'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '`12345, "G3"` | `1.2345` `1E-05`'
- en: '`1e-05`'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '`1e-05`'
- en: '`1.23`'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '`1.23`'
- en: '`1.23E04` | Switches to exponential notation for small or large numbers. `G3`
    limits precision to three digits in *total* (before + after point). |'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '`1.23E04` | 切换为小数点表示法以处理小数或大数。`G3`限制总体精度为三位数（小数点前后之和）。 |'
- en: '| `F` | Fixed point | `2345.678, "F2"` `2345.6, "F2"` | `2345.68` `2345.60`
    | `F2` rounds to two decimal places. |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
  zh: '| `F` | 固定小数点 | `2345.678, "F2"` `2345.6, "F2"` | `2345.68` `2345.60` | `F2`四舍五入至小数点后两位。
    |'
- en: '| `N` | Fixed point with *group separator* (“Numeric”) | `2345.678, "N2"` `2345.6,
    "N2"` | `2,345.68` `2,345.60` | As above, with group (1,000s) separator (details
    from format provider). |'
  id: totrans-529
  prefs: []
  type: TYPE_TB
  zh: '| `N` | *数值*，带有分组分隔符的固定小数点 | `2345.678, "N2"` `2345.6, "N2"` | `2,345.68` `2,345.60`
    | 如上，带有分组（千分位）分隔符（详细信息来自格式提供者）。 |'
- en: '| `D` | Pad with leading zeros | `123, "D5"` `123, "D1"` | `00123` `123` |
    For integral types only. `D5` pads left to five digits; does not truncate. |'
  id: totrans-530
  prefs: []
  type: TYPE_TB
  zh: '| `D` | 填充前导零 | `123, "D5"` `123, "D1"` | `00123` `123` | 仅适用于整数类型。`D5`填充左边至五位数，不截断。
    |'
- en: '| `E` or `e` | Force exponential notation | `56789, "E"` `56789, "e"`'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '| `E` 或 `e` | 强制指数表示法 | `56789, "E"` `56789, "e"`'
- en: '`56789, "E2"` | `5.678900E+004` `5.678900e+004`'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '`56789, "E2"` | `5.678900E+004` `5.678900e+004`'
- en: '`5.68E+004` | Six-digit default precision. |'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '`5.68E+004` | 六位默认精度。 |'
- en: '| `C` | Currency | `1.2, "C"` `1.2, "C4"` | `$1.20` `$1.2000` | `C` with no
    digit uses default number of D.P. from format provider. |'
  id: totrans-534
  prefs: []
  type: TYPE_TB
  zh: '| `C` | 货币 | `1.2, "C"` `1.2, "C4"` | `$1.20` `$1.2000` | 不带数字的`C`使用格式提供者的默认小数位数。
    |'
- en: '| `P` | Percent | `.503, "P"` `.503, "P0"` | `50.30%` `50%` | Uses symbol and
    layout from format provider. Decimal places can optionally be overridden. |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
  zh: '| `P` | 百分比 | `.503, "P"` `.503, "P0"` | `50.30%` `50%` | 使用符号和布局来自格式提供者。小数位数可以选择性地被覆盖。
    |'
- en: '| `X` or `x` | Hexadecimal | `47, "X"` `47, "x"`'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '| `X` 或 `x` | 十六进制 | `47, "X"` `47, "x"`'
- en: '`47, "X4"` | `2F` `2f`'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '`47, "X4"` | `2F` `2f`'
- en: '`002F` | `X` for uppercase hex digits; `x` for lowercase hex digits. Integrals
    only. |'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '`002F` | 大写十六进制数字的`X`；小写十六进制数字的`x`。仅适用于整数。 |'
- en: '| `R` or `G9/G17` | Round-trip | `1f / 3f, "R"` | `0.3333333**43**` | Use `R`
    for `BigInteger`, `G17` for `double`, or `G9` for `float`. |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
  zh: '| `R` 或 `G9/G17` | 循环转换 | `1f / 3f, "R"` | `0.3333333**43**` | 使用`R`表示`BigInteger`，`G17`表示`double`，或`G9`表示`float`。
    |'
- en: 'Supplying no numeric format string (or a null or blank string) is equivalent
    to using the `"G"` standard format string followed by no digit. This exhibits
    the following behavior:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 不提供数字格式字符串（或空字符串）等效于使用`"G"`标准格式字符串，其后不跟数字。表现如下：
- en: Numbers smaller than 10^(−4) or larger than the type’s precision are expressed
    in exponential (scientific) notation.
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字小于10^(−4)或大于类型精度的数字在指数（科学）表示法中表达。
- en: The two decimal places at the limit of `float` or `double`’s precision are rounded
    away to mask the inaccuracies inherent in conversion to decimal from their underlying
    binary form.
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点数或双精度的两位小数位在极限处被四舍五入，以掩盖从其底层二进制形式到十进制的转换中固有的不准确性。
- en: Note
  id: totrans-543
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: The automatic rounding just described is usually beneficial and goes unnoticed.
    However, it can cause trouble if you need to round-trip a number—in other words,
    convert it to a string and back again (maybe repeatedly) while preserving value
    equality. For this reason, the `R`, `G17`, and `G9` format strings exist to circumvent
    this implicit rounding.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才描述的自动四舍五入通常是有益的并且不易察觉的。然而，如果需要循环转换数字——也就是说，将其转换为字符串然后再转回去（可能是重复多次），这可能会引发问题。因此，存在`R`、`G17`和`G9`格式字符串以避免这种隐式四舍五入。
- en: '[Table 6-3](#custom_numeric_format_strings) lists custom numeric format strings.'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 6-3](#custom_numeric_format_strings) 列出了自定义数字格式字符串。'
- en: Table 6-3\. Custom numeric format strings
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-3\. 自定义数字格式字符串
- en: '| Specifier | Meaning | Sample input | Result | Notes |'
  id: totrans-547
  prefs: []
  type: TYPE_TB
  zh: '| 指示符 | 含义 | 示例输入 | 结果 | 注释 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-548
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `#` | Digit placeholder | `12.345, ".##"` `12.345, ".####"` | `12.35` `12.345`
    | Limits digits after D.P. |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '| `#` | 数字占位符 | `12.345, ".##"` `12.345, ".####"` | `12.35` `12.345` | 限制小数点后的数字位数。
    |'
- en: '| `0` | Zero placeholder | `12.345, ".00"` `12.345, ".0000"`'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '| `0` | 零占位符 | `12.345, ".00"` `12.345, ".0000"`'
- en: '`99, "000.00"` | `12.35` `12.3450`'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '`99, "000.00"` | `12.35` `12.3450`'
- en: '`099.00` | As above, but also pads with zeros before and after D.P. |'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '`099.00` | 如上，但还在小数点前后填充零。 |'
- en: '| `.` | Decimal point |  |  | Indicates D.P. Actual symbol comes from `NumberFormatInfo`.
    |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '| `.` | 小数点 |  |  | 表示小数点。实际符号来自`NumberFormatInfo`。 |'
- en: '| `,` | Group separator | `1234, "#,###,###"` `1234, "0,000,000"` | `1,234`
    `0,001,234` | Symbol comes from `NumberFormatInfo`. |'
  id: totrans-554
  prefs: []
  type: TYPE_TB
  zh: '| `,` | 分组分隔符 | `1234, "#,###,###"` `1234, "0,000,000"` | `1,234` `0,001,234`
    | 符号来自`NumberFormatInfo`。'
- en: '| `,` (as above) | Multiplier | `1000000, "#,"` `1000000, "#,,` | `1000` `1`
    | If comma is at end or before D.P., it acts as a multiplier—dividing result by
    1,000, 1,000,000, etc. |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
  zh: '| `,`（如上所示） | 倍数器 | `1000000, "#,"` `1000000, "#,,` | `1000` `1` | 如果逗号位于小数点之前或之后，则作为乘法器—将结果除以1,000、1,000,000等。'
- en: '| `%` | Percent notation | `0.6, "00%"` | `60%` | First multiplies by 100 and
    then substitutes percent symbol obtained from `NumberFormatInfo`. |'
  id: totrans-556
  prefs: []
  type: TYPE_TB
  zh: '| `%` | 百分比表示 | `0.6, "00%"` | `60%` | 首先乘以100，然后用从`NumberFormatInfo`获取的百分号替换。'
- en: '| `E0, e0, E+0, e+0 E-0, e-0` | Exponent notation | `1234, "0E0"` `1234, "0E+0"`'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '| `E0, e0, E+0, e+0 E-0, e-0` | 指数表示 | `1234, "0E0"` `1234, "0E+0"`'
- en: '`1234, "0.00E00"`'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '`1234, "0.00E00"`'
- en: '`1234, "0.00e00"` | `1E3` `1E+3`'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '`1234, "0.00e00"` | `1E3` `1E+3`'
- en: '`1.23E03`'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '`1.23E03`'
- en: '`1.23e03` |  |'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '`1.23e03` |  |'
- en: '| `\` | Literal character quote | `50, @"\#0"` | `#50` | Use in conjunction
    with an `@` prefix on the string—or use `\\` |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '| `\` | 字面字符引用 | `50, @"\#0"` | `#50` | 与字符串上的`@`前缀一起使用或使用`\\` |'
- en: '| `''xx''''xx''` | Literal string quote | `50, "0 ''...''"` | `50 ...` |  |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '| `''xx''''xx''` | 字面字符串引用 | `50, "0 ''...''"` | `50 ...` |  |'
- en: '| `;` | Section separator | `15, "#;(#);zero"` | `15` | (If positive) |'
  id: totrans-564
  prefs: []
  type: TYPE_TB
  zh: '| `;` | 分节符 | `15, "#;(#);zero"` | `15` | （如果为正） |'
- en: '|  |  | `-5, "#;(#);zero"` | `(5)` | (If negative) |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `-5, "#;(#);zero"` | `(5)` | （如果为负） |'
- en: '|  |  | `0, "#;(#);zero"` | `zero` | (If zero) |'
  id: totrans-566
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `0, "#;(#);zero"` | `zero` | （如果为零） |'
- en: '| Any other char | Literal | `35.2, "$0 . 00c"` | `$35 . 20c` |  |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
  zh: '| 任何其他字符 | 字面 | `35.2, "$0 . 00c"` | `$35 . 20c` |  |'
- en: NumberStyles
  id: totrans-568
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`NumberStyles`'
- en: 'Each numeric type defines a static `Parse` method that accepts a `NumberStyles`
    argument. `NumberStyles` is a flags enum that lets you determine how the string
    is read as it’s converted to a numeric type. It has the following combinable members:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 每种数值类型都定义了一个接受`NumberStyles`参数的静态`Parse`方法。`NumberStyles`是一个标志枚举，允许您确定将字符串转换为数值类型时如何读取它。它具有以下可组合的成员：
- en: '[PRE116]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '`NumberStyles` also defines these composite members:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '`NumberStyles`还定义了以下复合成员：'
- en: '[PRE117]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Except for `None`, all composite values include `AllowLeadingWhite` and `Allow​Trai⁠lingWhite`.
    [Figure 6-1](#composite_numberstyles) shows their remaining makeup, with the most
    useful three emphasized.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`None`，所有复合值均包括`AllowLeadingWhite`和`Allow​Trai⁠lingWhite`。[图 6-1](#composite_numberstyles)显示其余的组成部分，最有用的三个部分被强调。
- en: '![Composite NumberStyles](assets/cn10_0601.png)'
  id: totrans-574
  prefs: []
  type: TYPE_IMG
  zh: '![复合NumberStyles](assets/cn10_0601.png)'
- en: Figure 6-1\. Composite NumberStyles
  id: totrans-575
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-1\. 复合NumberStyles
- en: When you call `Parse` without specifying any flags, the defaults illustrated
    in [Figure 6-2](#default_parsing_flags_for_numeric_types) are applied.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用`Parse`而不指定任何标志时，将应用[图 6-2](#default_parsing_flags_for_numeric_types)中说明的默认值。
- en: '![Default parsing flags for numeric types](assets/cn10_0602.png)'
  id: totrans-577
  prefs: []
  type: TYPE_IMG
  zh: '![数值类型的默认解析标志](assets/cn10_0602.png)'
- en: Figure 6-2\. Default parsing flags for numeric types
  id: totrans-578
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-2\. 数值类型的默认解析标志
- en: 'If you don’t want the defaults shown in [Figure 6-2](#default_parsing_flags_for_numeric_types),
    you must explicitly specify `NumberStyles`:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不希望显示在[图 6-2](#default_parsing_flags_for_numeric_types)中显示的默认值，则必须显式指定`NumberStyles`：
- en: '[PRE118]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Because we didn’t specify a format provider, this example works with your local
    currency symbol, group separator, decimal point, and so on. The next example is
    hardcoded to work with the euro sign and a blank group separator for currencies:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们没有指定格式提供程序，所以这个示例将与您的本地货币符号、分组分隔符、小数点等一起工作。下一个示例硬编码为与欧元符号和空白分组分隔符一起工作：
- en: '[PRE119]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Date/Time Format Strings
  id: totrans-583
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日期/时间格式字符串
- en: 'Format strings for `DateTime`/`DateTimeOffset` can be divided into two groups
    based on whether they honor culture and format provider settings. [Table 6-4](#culture_sensitive_datesolidustime_forma)
    lists those that do; [Table 6-5](#culture_insensitive_datesolidustime_for) lists
    those that don’t. The sample output comes from formatting the following `DateTime`
    (with *invariant culture*, in the case of [Table 6-4](#culture_sensitive_datesolidustime_forma)):'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTime`/`DateTimeOffset`的格式字符串可以根据是否遵循文化和格式提供程序设置分为两组。[表 6-4](#culture_sensitive_datesolidustime_forma)列出了遵循的那些；[表 6-5](#culture_insensitive_datesolidustime_for)列出了不遵循的那些。样本输出来自格式化以下`DateTime`（使用*不变文化*，在[表 6-4](#culture_sensitive_datesolidustime_forma)的情况下）：'
- en: '[PRE120]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Table 6-4\. Culture-sensitive date/time format strings
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-4\. 文化敏感的日期/时间格式字符串
- en: '| **Format string** | **Meaning** | **Sample output** |'
  id: totrans-587
  prefs: []
  type: TYPE_TB
  zh: '| **格式字符串** | **含义** | **样本输出** |'
- en: '| --- | --- | --- |'
  id: totrans-588
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `d` | Short date | `01/02/2000` |'
  id: totrans-589
  prefs: []
  type: TYPE_TB
  zh: '| `d` | 短日期 | `2000年1月2日` |'
- en: '| `D` | Long date | `Sunday, 02 January 2000` |'
  id: totrans-590
  prefs: []
  type: TYPE_TB
  zh: '| `D` | 长日期 | `2000年1月2日 星期日` |'
- en: '| `t` | Short time | `17:18` |'
  id: totrans-591
  prefs: []
  type: TYPE_TB
  zh: '| `t` | 短时间 | `17:18` |'
- en: '| `T` | Long time | `17:18:19` |'
  id: totrans-592
  prefs: []
  type: TYPE_TB
  zh: '| `T` | 长时间 | `17:18:19` |'
- en: '| `f` | Long date + short time | `Sunday, 02 January 2000 17:18` |'
  id: totrans-593
  prefs: []
  type: TYPE_TB
  zh: '| `f` | 长日期 + 短时间 | `2000年1月2日 星期日 17:18` |'
- en: '| `F` | Long date + long time | `Sunday, 02 January 2000 17:18:19` |'
  id: totrans-594
  prefs: []
  type: TYPE_TB
  zh: '| `F` | 长日期 + 长时间 | `2000年1月2日 星期日 17:18:19` |'
- en: '| `g` | Short date + short time | `01/02/2000 17:18` |'
  id: totrans-595
  prefs: []
  type: TYPE_TB
  zh: '| `g` | 短日期 + 短时间 | `2000/01/02 17:18` |'
- en: '| `G` (default) | Short date + long time | `01/02/2000 17:18:19` |'
  id: totrans-596
  prefs: []
  type: TYPE_TB
  zh: '| `G`（默认）| 短日期 + 长时间 | `2000/01/02 17:18:19` |'
- en: '| `m, M` | Month and day | `02 January` |'
  id: totrans-597
  prefs: []
  type: TYPE_TB
  zh: '| `m, M` | 月和日 | `1月2日` |'
- en: '| `y, Y` | Year and month | `January 2000` |'
  id: totrans-598
  prefs: []
  type: TYPE_TB
  zh: '| `y, Y` | 年和月 | `2000年1月` |'
- en: Table 6-5\. Culture-insensitive date/time format strings
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-5\. 与文化无关的日期/时间格式字符串
- en: '| Format string | Meaning | Sample output | Notes |'
  id: totrans-600
  prefs: []
  type: TYPE_TB
  zh: '| 格式字符串 | 含义 | 示例输出 | 备注 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-601
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `o` | Round-trippable | `2000-01-02T17:18:19.0000000` | Will append time
    zone information unless `DateTimeKind` is `Unspecified` |'
  id: totrans-602
  prefs: []
  type: TYPE_TB
  zh: '| `o` | 回溯 | `2000-01-02T17:18:19.0000000` | 除非`DateTimeKind`是`Unspecified`，否则将附加时区信息
    |'
- en: '| `r`, `R` | RFC 1123 standard | `Sun, 02 Jan 2000 17:18:19 GMT` | You must
    explicitly convert to UTC with `DateTime.ToUniversalTime` |'
  id: totrans-603
  prefs: []
  type: TYPE_TB
  zh: '| `r`, `R` | RFC 1123标准 | `2000年1月2日 星期日 17:18:19 GMT` | 您必须使用`DateTime.ToUniversalTime`显式转换为UTC
    |'
- en: '| `s` | Sortable; ISO 8601 | `2000-01-02T17:18:19` | Compatible with text-based
    sorting |'
  id: totrans-604
  prefs: []
  type: TYPE_TB
  zh: '| `s` | 可排序；ISO 8601 | `2000-01-02T17:18:19` | 与基于文本的排序兼容 |'
- en: '| `u` | “Universal” sortable | `2000-01-02 17:18:19Z` | Similar to above; must
    explicitly convert to UTC |'
  id: totrans-605
  prefs: []
  type: TYPE_TB
  zh: '| `u` | “通用”可排序 | `2000-01-02 17:18:19Z` | 与上述类似；必须显式转换为UTC |'
- en: '| `U` | UTC | `Sunday, 02 January 2000 17:18:19` | Long date + short time,
    converted to UTC |'
  id: totrans-606
  prefs: []
  type: TYPE_TB
  zh: '| `U` | UTC | `2000年1月2日 星期日 17:18:19` | 长日期 + 短时间，转换为UTC |'
- en: The format strings `"r"`, `"R"`, and `"u"` emit a suffix that implies UTC; yet
    they don’t automatically convert a local to a UTC `DateTime` (so you must do the
    conversion yourself). Ironically, `"U"` automatically converts to UTC, but doesn’t
    write a time zone suffix! In fact, `"o"` is the only format specifier in the group
    that can write an unambiguous `DateTime` without intervention.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 格式字符串`"r"`、`"R"`和`"u"`会生成一个暗示UTC的后缀；然而，它们不会自动将本地时间转换为UTC `DateTime`（因此您必须自行进行转换）。具有讽刺意味的是，`"U"`会自动转换为UTC，但不会写入时区后缀！实际上，`"o"`是该组中唯一可以在不需要干预的情况下编写清晰的`DateTime`的格式说明符。
- en: '`DateTimeFormatInfo` also supports custom format strings: these are analogous
    to numeric custom format strings. The list is extensive and is available online
    in Microsoft’s documentation. Here’s an example of a custom format string:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTimeFormatInfo`也支持自定义格式字符串：这些类似于数字自定义格式字符串。列表非常广泛，并且可以在微软的文档中在线获取。以下是一个自定义格式字符串的示例：'
- en: '[PRE121]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Parsing and misparsing DateTimes
  id: totrans-610
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析和误解析日期时间
- en: 'Strings that put the month or day first are ambiguous and can easily be misparsed—particularly
    if you have global customers. This is not a problem in user interface controls,
    because the same settings are in force when parsing as when formatting. But when
    writing to a file, for instance, day/month misparsing can be a real problem. There
    are two solutions:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 将月份或日期放在前面的字符串是模棱两可的，很容易被误解析，特别是对全球客户而言。这在用户界面控件中不是问题，因为在解析时与格式化时使用相同的设置。但是在写入文件时，例如，日期/月份误解析可能会是一个真正的问题。有两个解决方案：
- en: Always state the same explicit culture when formatting and parsing (e.g., invariant
    culture).
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在格式化和解析时始终指定相同的显式文化（例如，不变文化）。
- en: Format `DateTime` and `DateTimeOffset`s in a manner *independent* of culture.
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以*独立*于文化的方式格式化`DateTime`和`DateTimeOffset`。
- en: 'The second approach is more robust—particularly if you choose a format that
    puts the four-digit year first: such strings are much more difficult to misparse
    by another party. Further, strings formatted with a *standards-compliant* year-first
    format (such as `"o"`) can parse correctly alongside locally formatted strings—rather
    like a “universal donor.” (Dates formatted with `"s"` or `"u"` have the further
    benefit of being sortable.)'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法更为健壮，特别是如果选择一个将四位数年份放在首位的格式，这样的字符串更难以被其他方误解析。此外，采用符合标准的年份优先格式（如`"o"`）格式化的字符串可以与本地格式化的字符串正确解析，就像“全球供应者”一样。（使用`"s"`或`"u"`格式化的日期还具有可排序的进一步好处。）
- en: 'To illustrate, suppose that we generate a culture-insensitive `DateTime` string
    `s` as follows:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 举例说明，假设我们生成一个与文化无关的`DateTime`字符串`s`如下：
- en: '[PRE122]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Note
  id: totrans-617
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `"o"` format string includes milliseconds in the output. The following
    custom format string gives the same result as `"o"`, but without milliseconds:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '`"o"`格式字符串在输出中包含毫秒。以下自定义格式字符串与`"o"`给出相同结果，但不包含毫秒：'
- en: '[PRE123]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'We can reparse this in two ways. `ParseExact` demands strict compliance with
    the specified format string:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以两种方式重新解析这个。`ParseExact` 要求严格遵守指定的格式字符串：
- en: '[PRE124]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: (You can achieve a similar result with `XmlConvert`’s `ToString` and `ToDateTime`
    methods.)
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: （您可以使用 `XmlConvert` 的 `ToString` 和 `ToDateTime` 方法实现类似的结果。）
- en: '`Parse`, however, implicitly accepts both the `"o"` format and the `CurrentCulture`
    format:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Parse` 隐式接受 `"o"` 格式和 `CurrentCulture` 格式：
- en: '[PRE125]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: This works with both `DateTime` and `DateTimeOffset`.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于 `DateTime` 和 `DateTimeOffset`。
- en: Note
  id: totrans-626
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`ParseExact` is usually preferable if you know the format of the string that
    you’re parsing. It means that if the string is incorrectly formatted, an exception
    will be thrown—which is usually better than risking a misparsed date.'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道正在解析的字符串的格式，通常最好使用 `ParseExact`。这意味着如果字符串格式不正确，将会抛出异常，这通常比冒险误解析日期要好。
- en: DateTimeStyles
  id: totrans-628
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DateTimeStyles
- en: '`DateTimeStyles` is a flags enum that provides additional instructions when
    calling `Parse` on a `DateTime`(`Offset`). Here are its members:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTimeStyles` 是一个标志枚举，在调用 `DateTime`（`Offset`）的 `Parse` 时提供额外的指令。以下是它的成员：'
- en: '[PRE126]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'There is also a composite member, `AllowWhiteSpaces`:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个复合成员，`AllowWhiteSpaces`：
- en: '[PRE127]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The default is `None`. This means that extra whitespace is normally prohibited
    (whitespace that’s part of a standard `DateTime` pattern is exempt).
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 默认是 `None`。这意味着通常禁止额外的空白（标准 `DateTime` 模式中的空白除外）。
- en: '`AssumeLocal` and `AssumeUniversal` apply if the string doesn’t have a time
    zone suffix (such as `Z` or `+9:00`). `AdjustToUniversal` still honors time zone
    suffixes, but then converts to UTC using the current regional settings.'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符串没有时区后缀（例如 `Z` 或 `+9:00`），则 `AssumeLocal` 和 `AssumeUniversal` 会应用。`AdjustToUniversal`
    仍然遵循时区后缀，但是使用当前区域设置转换为 UTC。
- en: If you parse a string comprising a time but no date, today’s date is applied
    by default. If you apply the `NoCurrentDateDefault` flag, however, it instead
    uses 1st January 0001.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 如果解析的字符串只包含时间而没有日期，则默认应用今天的日期。然而，如果应用了 `NoCurrentDateDefault` 标志，则使用 0001 年
    1 月 1 日。
- en: Enum Format Strings
  id: totrans-636
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举格式字符串
- en: 'In [“Enums”](ch03.html#enums-id00013), we described formatting and parsing
    enum values. [Table 6-6](#enum_format_strings-id00066) lists each format string
    and the result of applying it to the following expression:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“Enums”](ch03.html#enums-id00013)中，我们描述了枚举值的格式化和解析。[表 6-6](#enum_format_strings-id00066)列出了每个格式字符串及其应用于以下表达式的结果：
- en: '[PRE128]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Table 6-6\. Enum format strings
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-6\. 枚举格式字符串
- en: '| Format string | Meaning | Sample output | Notes |'
  id: totrans-640
  prefs: []
  type: TYPE_TB
  zh: '| 格式字符串 | 含义 | 示例输出 | 注释 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-641
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `G` or `g` | “General” | `Red` | Default |'
  id: totrans-642
  prefs: []
  type: TYPE_TB
  zh: '| `G` 或 `g` | “通用” | `Red` | 默认 |'
- en: '| `F` or `f` | Treat as though `Flags` attribute were present | `Red` | Works
    on combined members even if `enum` has no `Flags` attribute |'
  id: totrans-643
  prefs: []
  type: TYPE_TB
  zh: '| `F` 或 `f` | 如同存在 `Flags` 属性一样处理 | `Red` | 即使 `enum` 没有 `Flags` 属性，也适用于组合成员
    |'
- en: '| `D` or `d` | Decimal value | `12` | Retrieves underlying integral value |'
  id: totrans-644
  prefs: []
  type: TYPE_TB
  zh: '| `D` 或 `d` | 十进制值 | `12` | 检索基础整数值 |'
- en: '| `X` or `x` | Hexadecimal value | `0000000C` | Retrieves underlying integral
    value |'
  id: totrans-645
  prefs: []
  type: TYPE_TB
  zh: '| `X` 或 `x` | 十六进制值 | `0000000C` | 检索基础整数值 |'
- en: Other Conversion Mechanisms
  id: totrans-646
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他转换机制
- en: 'In the previous two sections, we covered format providers—.NET’s primary mechanism
    for formatting and parsing. Other important conversion mechanisms are scattered
    through various types and namespaces. Some convert to and from `string`, and some
    do other kinds of conversions. In this section, we discuss the following topics:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两节中，我们讨论了格式提供程序——.NET 的主要格式化和解析机制。其他重要的转换机制散布在各种类型和命名空间中。一些转换成和从 `string`，而一些进行其他类型的转换。在本节中，我们讨论以下主题：
- en: 'The `Convert` class and its functions:'
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Convert` 类及其函数：'
- en: Real to integral conversions that round rather than truncate
  id: totrans-649
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实数到整数的转换，而不是截断
- en: Parsing numbers in base 2, 8, and 16
  id: totrans-650
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制、八进制和十六进制中的数字解析
- en: Dynamic conversions
  id: totrans-651
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态转换
- en: Base-64 translations
  id: totrans-652
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Base-64 翻译
- en: '`XmlConvert` and its role in formatting and parsing for XML'
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XmlConvert` 及其在 XML 格式化和解析中的角色'
- en: Type converters and their role in formatting and parsing for designers and XAML
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型转换器及其在设计师和 XAML 格式化和解析中的角色
- en: '`BitConverter`, for binary conversions'
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BitConverter`，用于二进制转换'
- en: Convert
  id: totrans-656
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Convert
- en: '.NET calls the following types *base types*:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 将以下类型称为*基本类型*：
- en: '`bool`, `char`, `string`, `System.DateTime`, and `System.DateTimeOffset`'
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool`、`char`、`string`、`System.DateTime` 和 `System.DateTimeOffset`'
- en: All the C# numeric types
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的 C# 数字类型
- en: 'The static `Convert` class defines methods for converting every base type to
    every other base type. Unfortunately, most of these methods are useless: either
    they throw exceptions or they are redundant alongside implicit casts. Among the
    clutter, however, are some useful methods, listed in the following sections.'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的`Convert`类定义了将每个基本类型转换为其他每个基本类型的方法。不幸的是，大多数这些方法是无用的：它们要么抛出异常，要么与隐式转换并列。然而，在这些混乱之中，也有一些有用的方法，列在以下各节中。
- en: Note
  id: totrans-661
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: All base types (explicitly) implement `IConvertible`, which defines methods
    for converting to every other base type. In most cases, the implementation of
    each of these methods simply calls a method in `Convert`. On rare occasions, it
    can be useful to write a method that accepts an argument of type `IConvertible`.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 所有基本类型（显式地）实现了`IConvertible`接口，该接口定义了转换为其他所有基本类型的方法。在大多数情况下，这些方法的实现只是调用了`Convert`中的一个方法。在罕见情况下，编写一个接受`IConvertible`类型参数的方法可能会很有用。
- en: Rounding real to integral conversions
  id: totrans-663
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将实数四舍五入到整数的转换
- en: 'In [Chapter 2](ch02.html#chash_language_basics), we saw how implicit and explicit
    casts allow you to convert between numeric types. In summary:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](ch02.html#chash_language_basics)中，我们看到了隐式和显式转换如何允许您在数值类型之间进行转换。总结如下：
- en: Implicit casts work for nonlossy conversions (e.g., `int` to `double`).
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式转换适用于非损失转换（例如，`int`到`double`）。
- en: Explicit casts are required for lossy conversions (e.g., `double` to `int`).
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于损失转换（例如，`double`到`int`），需要显式强制转换。
- en: 'Casts are optimized for efficiency; hence, they *truncate* data that won’t
    fit. This can be a problem when converting from a real number to an integer, because
    often you want to *round* rather than truncate. `Convert`’s numerical conversion
    methods address just this issue—they always *round*:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 强制转换被优化以提高效率；因此，它们会*截断*无法容纳的数据。当从实数转换为整数时，这可能会成为问题，因为通常希望*四舍五入*而不是截断。`Convert`的数值转换方法正好解决了这个问题——它们总是*四舍五入*：
- en: '[PRE129]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '`Convert` uses *banker’s rounding*, which snaps midpoint values to even integers
    (this avoids positive or negative bias). If banker’s rounding is a problem, first
    call `Math.Round` on the real number: this accepts an additional argument that
    allows you to control midpoint rounding.'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '`Convert`使用*银行家舍入*，将中间值舍入为偶数（避免正负偏差）。如果银行家舍入成为问题，首先在实数上调用`Math.Round`：它接受一个额外的参数，允许您控制中间值的舍入。'
- en: Parsing numbers in base 2, 8, and 16
  id: totrans-670
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在二进制2、8和16的基础上解析数字
- en: 'Hidden among the `To(*integral-type*)` methods are overloads that parse numbers
    in another base:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 在`To(*integral-type*)`方法中隐藏着一些重载，用于在另一种基数中解析数字：
- en: '[PRE130]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: The second argument specifies the base. It can be any base you like—as long
    as it’s 2, 8, 10, or 16!
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数指定了基数。它可以是您喜欢的任何基数——只要是2、8、10或16！
- en: Dynamic conversions
  id: totrans-674
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态转换
- en: 'Occasionally, you need to convert from one type to another, but you don’t know
    what the types are until runtime. For this, the `Convert` class provides a `ChangeType`
    method:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔需要从一种类型转换为另一种类型，但直到运行时才知道类型。对此，`Convert`类提供了一个`ChangeType`方法：
- en: '[PRE131]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'The source and target types must be one of the “base” types. `ChangeType` also
    accepts an optional `IFormatProvider` argument. Here’s an example:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 源类型和目标类型必须是“基本”类型之一。`ChangeType`还接受一个可选的`IFormatProvider`参数。以下是一个示例：
- en: '[PRE132]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: An example of when this might be useful is in writing a deserializer that can
    work with multiple types. It can also convert any enum to its integral type (see
    [“Enums”](ch03.html#enums-id00013)).
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是在编写可以处理多种类型的反序列化器时可能会有用。它还可以将任何枚举类型转换为其整数类型（参见[“枚举”](ch03.html#enums-id00013)）。
- en: A limitation of `ChangeType` is that you cannot specify a format string or parsing
    flag.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChangeType`的一个限制是您无法指定格式字符串或解析标志。'
- en: Base-64 conversions
  id: totrans-681
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Base-64转换
- en: Sometimes, you need to include binary data such as a bitmap within a text document
    such as an XML file or email message. Base 64 is a ubiquitous means of encoding
    binary data as readable characters, using 64 characters from the ASCII set.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您需要在文本文档（如XML文件或电子邮件消息）中包含二进制数据，例如位图。Base 64是一种将二进制数据编码为可读字符的普遍方式，使用ASCII集的64个字符。
- en: '`Convert`’s `ToBase64String` method converts from a byte array to base 64;
    `FromBase64String` does the reverse.'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '`Convert`的`ToBase64String`方法将字节数组转换为Base 64；`FromBase64String`则执行相反操作。'
- en: XmlConvert
  id: totrans-684
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XmlConvert
- en: If you’re dealing with data that’s originated from or destined for an XML file,
    `XmlConvert` (in the `System.Xml` namespace) provides the most suitable methods
    for formatting and parsing. The methods in `XmlConvert` handle the nuances of
    XML formatting without needing special format strings. For instance, `true` in
    XML is “true” and not “True.” The .NET BCL internally uses `XmlConvert` extensively.
    `XmlConvert` is also good for general-purpose, culture-independent serialization.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 如果处理来自或去向 XML 文件的数据，`XmlConvert`（位于 `System.Xml` 命名空间中）提供了最适合的格式化和解析方法。`XmlConvert`
    中的方法处理 XML 格式的细微差别，无需特殊的格式字符串。例如，XML 中的 `true` 是 "true" 而不是 "True"。.NET BCL 内部广泛使用
    `XmlConvert`。`XmlConvert` 也非常适合通用、与文化无关的序列化。
- en: 'The formatting methods in `XmlConvert` are all provided as overloaded `ToString`
    methods; the parsing methods are called `ToBoolean`, `ToDateTime`, and so on:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '`XmlConvert` 中的格式化方法都作为重载的 `ToString` 方法提供；解析方法称为 `ToBoolean`、`ToDateTime`
    等：'
- en: '[PRE133]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The methods that convert to and from `DateTime` accept an `XmlDateTimeSerializationMode`
    argument. This is an `enum` with the following values:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 转换至和从 `DateTime` 的方法接受一个 `XmlDateTimeSerializationMode` 参数。这是一个枚举，包含以下值：
- en: '[PRE134]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '`Local` and `Utc` cause a conversion to take place when formatting (if the
    `DateTime` is not already in that time zone). The time zone is then appended to
    the string:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '`Local` 和 `Utc` 在格式化时引发转换（如果 `DateTime` 尚未处于该时区）。然后将时区附加到字符串后面：'
- en: '[PRE135]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '`Unspecified` strips away any time-zone information embedded in the `DateTime`
    (i.e., `DateTimeKind`) before formatting. `RoundtripKind` honors the `DateTime`’s
    `DateTimeKind`—so when it’s reparsed, the resultant `DateTime` struct will be
    exactly as it was originally.'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '`Unspecified` 在格式化之前去除嵌入在 `DateTime` 中的任何时区信息（即 `DateTimeKind`）。`RoundtripKind`
    尊重 `DateTime` 的 `DateTimeKind` ——因此，当重新解析时，结果的 `DateTime` 结构将与最初的完全一致。'
- en: Type Converters
  id: totrans-693
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型转换器
- en: Type converters are designed to format and parse in design-time environments.
    They also parse values in Extensible Application Markup Language (XAML) documents—as
    used in Windows Presentation Foundation (WPF).
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换器旨在设计时环境中格式化和解析。它们还解析 Extensible Application Markup Language (XAML) 文档中的值——在
    Windows Presentation Foundation (WPF) 中使用。
- en: In .NET, there are more than 100 type converters—covering such things as colors,
    images, and URIs. In contrast, format providers are implemented for only a handful
    of simple value types.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中，有超过 100 种类型转换器——涵盖颜色、图像和URI等内容。相比之下，格式提供程序仅针对少数简单值类型实现。
- en: Type converters typically parse strings in a variety of ways—without needing
    hints. For instance, in a WPF application in Visual Studio, if you assign a control
    a background color by typing `"Beige"` into the appropriate property window, `Color`’s
    type converter figures out that you’re referring to a color name and not an RGB
    string or system color. This flexibility can sometimes make type converters useful
    in contexts outside of designers and XAML documents.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换器通常以多种方式解析字符串——无需提示。例如，在 Visual Studio 的 WPF 应用程序中，如果将控件的背景颜色设为属性窗口中的 `"Beige"`，`Color`
    类型转换器会识别出您指的是颜色名称，而不是 RGB 字符串或系统颜色。这种灵活性有时会使得类型转换器在设计师和 XAML 文档之外的环境中也很有用。
- en: 'All type converters subclass `TypeConverter` in `System.ComponentModel`. To
    obtain a `TypeConverter`, call `TypeDescriptor.GetConverter`. The following obtains
    a `TypeConverter` for the `Color` type (in the `System.Drawing` namespace):'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类型转换器都是 `System.ComponentModel` 中 `TypeConverter` 的子类。要获取 `TypeConverter`，请调用
    `TypeDescriptor.GetConverter`。以下是获取 `Color` 类型（位于 `System.Drawing` 命名空间中）的 `TypeConverter`
    的示例：
- en: '[PRE136]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Among many other methods, `TypeConverter` defines methods to `ConvertToString`
    and `ConvertFromString`. We can call these as follows:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '`TypeConverter` 定义了诸多方法，例如 `ConvertToString` 和 `ConvertFromString`。我们可以这样调用：'
- en: '[PRE137]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: By convention, type converters have names ending in *Converter* and are usually
    in the same namespace as the type they’re converting. A type links to its converter
    via a `TypeConverterAttribute`, allowing designers to pick up converters automatically.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，类型转换器的名称以 *Converter* 结尾，通常与其转换的类型位于同一命名空间。通过 `TypeConverterAttribute`，类型链接到其转换器，允许设计者自动选择转换器。
- en: Type converters can also provide design-time services such as generating standard
    value lists for populating a drop-down list in a designer or assisting with code
    serialization.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换器还可以提供设计时服务，例如生成标准值列表，以便在设计器中填充下拉列表或帮助代码序列化。
- en: BitConverter
  id: totrans-703
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BitConverter
- en: 'Most base types can be converted to a byte array, by calling `BitConverter`.`GetBytes`:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数基本类型都可以通过调用 `BitConverter`.`GetBytes` 转换为字节数组：
- en: '[PRE138]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '`BitConverter` also provides methods, such as `ToDouble`, for converting in
    the other direction.'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '`BitConverter` 还提供了方法，如 `ToDouble`，用于反向转换。'
- en: The `decimal` and `DateTime`(`Offset`) types are not supported by `BitConverter`.
    You can, however, convert a `decimal` to an `int` array by calling `decimal.GetBits`.
    To go the other way around, `decimal` provides a constructor that accepts an `int`
    array.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '`BitConverter` 不支持 `decimal` 和 `DateTime`（`Offset`） 类型。但是，你可以通过调用 `decimal.GetBits`
    将 `decimal` 转换为 `int` 数组。反向转换时，`decimal` 提供了接受 `int` 数组的构造函数。'
- en: In the case of `DateTime`, you can call `ToBinary` on an instance—this returns
    a `long` (upon which you can then use `BitConverter`). The static `DateTime.FromBinary`
    method does the reverse.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `DateTime`，你可以在实例上调用 `ToBinary` 方法 —— 这将返回一个 `long`（之后可以使用 `BitConverter`）。静态的
    `DateTime.FromBinary` 方法执行反向操作。
- en: Globalization
  id: totrans-709
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全球化
- en: 'There are two aspects to *internationalizing* an application: *globalization*
    and *localization*.'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序 *国际化* 的两个方面是 *全球化* 和 *本地化*。
- en: '*Globalization* is concerned with three tasks (in decreasing order of importance):'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '*全球化* 关注三个任务（按重要性递减排序）：'
- en: Making sure that your program doesn’t *break* when run in another culture
  id: totrans-712
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的程序在运行在其他文化环境时不会 *中断*。
- en: Respecting a local culture’s formatting rules; for instance, when displaying
    dates
  id: totrans-713
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尊重本地文化的格式化规则，例如在显示日期时。
- en: Designing your program so that it picks up culture-specific data and strings
    from satellite assemblies that you can later write and deploy
  id: totrans-714
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计你的程序，使其能够从后续编写和部署的卫星程序集中获取特定文化的数据和字符串。
- en: '*Localization* means concluding that last task by writing satellite assemblies
    for specific cultures. You can do this *after* writing your program (we cover
    the details in [“Resources and Satellite Assemblies”](ch17.html#resources_and_satellite_assemblies)).'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '*本地化* 意味着通过为特定文化编写卫星程序集来完成最后一个任务。你可以在编写程序之后进行此操作（我们在 [“资源和卫星程序集”](ch17.html#resources_and_satellite_assemblies)
    中详细介绍）。'
- en: .NET helps you with the second task by applying culture-specific rules by default.
    We’ve already seen how calling `ToString` on a `DateTime` or number respects local
    formatting rules. Unfortunately, this makes it easy to fail the first task and
    have your program break because you’re expecting dates or numbers to be formatted
    according to an assumed culture. The solution, as we’ve seen, is either to specify
    a culture (such as the invariant culture) when formatting and parsing or to use
    culture-independent methods such as those in `XmlConvert`.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 默认应用文化特定规则帮助你完成第二项任务。我们已经看到，在 `DateTime` 或数字上调用 `ToString` 会尊重本地格式化规则。不幸的是，这使得在期望日期或数字按照假定的文化格式化时易于失败并导致程序中断。正如我们所见，解决方法要么是在格式化和解析时指定文化（如不变文化），要么使用像
    `XmlConvert` 中那样的文化独立方法。
- en: Globalization Checklist
  id: totrans-717
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全球化检查表
- en: 'We’ve already covered the important points in this chapter. Here’s a summary
    of the essential work required:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本章中涵盖了重要的要点。以下是所需工作的要点总结：
- en: Understand Unicode and text encodings (see [“Text Encodings and Unicode”](#text_encodings_and_unicode)).
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 Unicode 和文本编码（参见 [“文本编码和 Unicode”](#text_encodings_and_unicode)）。
- en: 'Be mindful that methods such as `ToUpper` and `ToLower` on `char` and `string`
    are culture sensitive: use `ToUpperInvariant`/`ToLowerInvariant` unless you want
    culture sensitivity.'
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意，对于 `char` 和 `string` 上的 `ToUpper` 和 `ToLower` 方法是具有文化敏感性的：除非你需要文化敏感性，否则请使用
    `ToUpperInvariant` / `ToLowerInvariant`。
- en: Favor culture-independent formatting and parsing mechanisms for `DateTime` and
    `DateTimeOffset`s such as `ToString("o")` and `XmlConvert`.
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偏好独立于文化的日期时间格式化和解析机制，如 `ToString("o")` 和 `XmlConvert`，对于 `DateTime` 和 `DateTimeOffset`
    类型。
- en: Otherwise, specify a culture when formatting/parsing numbers or date/times (unless
    you *want* local-culture behavior).
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，在格式化/解析数字或日期/时间时请指定文化（除非你 *希望* 使用本地文化行为）。
- en: Testing
  id: totrans-723
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试
- en: 'You can test against different cultures by reassigning `Thread`’s `CurrentCulture`
    property (in `System.Threading`). The following changes the current culture to
    Turkey:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重新分配 `Thread` 的 `CurrentCulture` 属性（位于 `System.Threading` 中），你可以针对不同的文化进行测试。以下更改当前文化为土耳其：
- en: '[PRE139]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Turkey is a particularly good test case because:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 土耳其是一个特别好的测试案例，因为：
- en: '`"i".ToUpper() != "I"` and `"I".ToLower() != "i"`.'
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"i".ToUpper() != "I"` 和 `"I".ToLower() != "i"`。'
- en: Dates are formatted as day.month.year (note the period separator).
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期以天.月.年格式化（注意点号分隔符）。
- en: The decimal point indicator is a comma instead of a period.
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十进制点指示符为逗号而非句点。
- en: 'You can also experiment by changing the number and date formatting settings
    in the Windows Control Panel: these are reflected in the default culture (`CultureInfo.CurrentCulture`).'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过更改 Windows 控制面板中的数字和日期格式设置来进行实验：这些会反映在默认文化 (`CultureInfo.CurrentCulture`)
    中。
- en: '`CultureInfo.GetCultures()` returns an array of all available cultures.'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '`CultureInfo.GetCultures()` 返回所有可用文化的数组。'
- en: Note
  id: totrans-732
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`Thread` and `CultureInfo` also support a `CurrentUICulture` property. This
    is concerned more with localization, which we cover in [Chapter 17](ch17.html#assemblies).'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread` 和 `CultureInfo` 还支持 `CurrentUICulture` 属性。这更多关注本地化，我们在 [第 17 章](ch17.html#assemblies)
    中会讨论。'
- en: Working with Numbers
  id: totrans-734
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理数字
- en: Conversions
  id: totrans-735
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换
- en: We covered numeric conversions in previous chapters and sections; [Table 6-7](#summary_of_numeric_conversions)
    summarizes all of the options.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前几章节中已经讨论了数值转换；[表 6-7](#summary_of_numeric_conversions) 总结了所有选项。
- en: Table 6-7\. Summary of numeric conversions
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-7\. 数值转换摘要
- en: '| Task | Functions | Examples |'
  id: totrans-738
  prefs: []
  type: TYPE_TB
  zh: '| 任务 | 函数 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-739
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Parsing base 10 numbers | `Parse` `TryParse` | `double d = double.Parse ("3.5");`
    `int i;`'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '| 解析十进制数字 | `Parse` `TryParse` | `double d = double.Parse ("3.5");` `int i;`'
- en: '`bool ok = int.TryParse ("3", out i);` |'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '`bool ok = int.TryParse ("3", out i);` |'
- en: '| Parsing from base 2, 8, or 16 | `Convert.ToIntegral` | `int i = Convert.ToInt32
    ("1E", 16);` |'
  id: totrans-742
  prefs: []
  type: TYPE_TB
  zh: '| 解析二进制、八进制或十六进制 | `Convert.ToIntegral` | `int i = Convert.ToInt32 ("1E", 16);`
    |'
- en: '| Formatting to hexadecimal | `ToString ("X")` | `string hex = 45.ToString
    ("X");` |'
  id: totrans-743
  prefs: []
  type: TYPE_TB
  zh: '| 格式化为十六进制 | `ToString ("X")` | `string hex = 45.ToString ("X");` |'
- en: '| Lossless numeric conversion | Implicit cast | `int i = 23;` `double d = i;`
    |'
  id: totrans-744
  prefs: []
  type: TYPE_TB
  zh: '| 无损数值转换 | 隐式类型转换 | `int i = 23;` `double d = i;` |'
- en: '| *Truncating* numeric conversion | Explicit cast | `double d = 23.5;` `int
    i = (int) d;` |'
  id: totrans-745
  prefs: []
  type: TYPE_TB
  zh: '| 截断数值转换 | 显式类型转换 | `double d = 23.5;` `int i = (int) d;` |'
- en: '| *Rounding* numeric conversion (real to integral) | `Convert.ToIntegral` |
    `double d = 23.5;` `int i = Convert.ToInt32 (d);` |'
  id: totrans-746
  prefs: []
  type: TYPE_TB
  zh: '| *截断* 数值转换（实数到整数） | `Convert.ToIntegral` | `double d = 23.5;` `int i = Convert.ToInt32
    (d);` |'
- en: Math
  id: totrans-747
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Math
- en: '[Table 6-8](#methods_in_the_static_math_class) lists the key members of the
    static `Math` class. The trigonometric functions accept arguments of type `double`;
    other methods such as `Max` are overloaded to operate on all numeric types. The
    `Math` class also defines the mathematical constants `E` (*e*) and `PI`.'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 6-8](#methods_in_the_static_math_class) 列出了静态 `Math` 类的关键成员。三角函数接受 `double`
    类型的参数；其他方法如 `Max` 已重载以操作所有数值类型。`Math` 类还定义了数学常数 `E`（*e*）和 `PI`。'
- en: Table 6-8\. Methods in the static Math class
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-8\. 静态 Math 类中的方法
- en: '| Category | Methods |'
  id: totrans-750
  prefs: []
  type: TYPE_TB
  zh: '| 分类 | 方法 |'
- en: '| --- | --- |'
  id: totrans-751
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Rounding | `Round`, `Truncate`, `Floor`, `Ceiling` |'
  id: totrans-752
  prefs: []
  type: TYPE_TB
  zh: '| 四舍五入 | `Round`, `Truncate`, `Floor`, `Ceiling` |'
- en: '| Maximum/minimum | `Max`, `Min` |'
  id: totrans-753
  prefs: []
  type: TYPE_TB
  zh: '| 最大值/最小值 | `Max`, `Min` |'
- en: '| Absolute value and sign | `Abs`, `Sign` |'
  id: totrans-754
  prefs: []
  type: TYPE_TB
  zh: '| 绝对值和符号 | `Abs`, `Sign` |'
- en: '| Square root | `Sqrt` |'
  id: totrans-755
  prefs: []
  type: TYPE_TB
  zh: '| 平方根 | `Sqrt` |'
- en: '| Raising to a power | `Pow`, `Exp` |'
  id: totrans-756
  prefs: []
  type: TYPE_TB
  zh: '| 求幂 | `Pow`, `Exp` |'
- en: '| Logarithm | `Log`, `Log10` |'
  id: totrans-757
  prefs: []
  type: TYPE_TB
  zh: '| 对数 | `Log`, `Log10` |'
- en: '| Trigonometric | `Sin`, `Cos`, `Tan`, `Sinh`, `Cosh`, `Tanh`,'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '| 三角函数 | `Sin`, `Cos`, `Tan`, `Sinh`, `Cosh`, `Tanh`,'
- en: '`Asin`, `Acos`, `Atan` |'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: '`Asin`, `Acos`, `Atan` |'
- en: 'The `Round` method lets you specify the number of decimal places with which
    to round as well as how to handle midpoints (away from zero, or with banker’s
    rounding). `Floor` and `Ceiling` round to the nearest integer: `Floor` always
    rounds down, and `Ceiling` always rounds up—even with negative numbers.'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '`Round` 方法允许你指定小数点后的位数以及如何处理中点（远离零或者使用银行家舍入法）。`Floor` 和 `Ceiling` 四舍五入到最近的整数：`Floor`
    总是向下舍入，`Ceiling` 总是向上舍入，即使是负数也是如此。'
- en: '`Max` and `Min` accept only two arguments. If you have an array or sequence
    of numbers, use the `Max` and `Min` extension methods in `System.Linq.Enumerable`.'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: '`Max` 和 `Min` 只接受两个参数。如果你有一个数组或者数列，可以使用 `System.Linq.Enumerable` 中的 `Max` 和
    `Min` 扩展方法。'
- en: BigInteger
  id: totrans-762
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BigInteger
- en: The `BigInteger` struct is a specialized numeric type. It resides in the `System.Numerics`
    namespace and allows you to represent an arbitrarily large integer without any
    loss of precision.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: '`BigInteger` 结构体是一种专门的数值类型。它位于 `System.Numerics` 命名空间中，允许你表示任意大的整数而不会丢失精度。'
- en: 'C# doesn’t provide native support for `BigInteger`, so there’s no way to represent
    `BigInteger` literals. You can, however, implicitly convert from any other integral
    type to a `BigInteger`:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: C# 并不原生支持 `BigInteger`，因此没有办法表示 `BigInteger` 字面量。不过，你可以从任何其他整数类型隐式转换为 `BigInteger`：
- en: '[PRE140]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'To represent a bigger number, such as one googol (10^(100)), you can use one
    of `BigInteger`’s static methods, such as `Pow` (raise to the power):'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 要表示更大的数字，例如一万亿（10^(100)），可以使用`BigInteger`的静态方法之一，如`Pow`（乘方）：
- en: '[PRE141]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Alternatively, you can `Parse` a string:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过`Parse`解析一个字符串：
- en: '[PRE142]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Calling `ToString()` on this prints every digit:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 对其调用`ToString()`会打印每个数字：
- en: '[PRE143]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'You can perform potentially lossy conversions between `BigInteger` and the
    standard numeric types by using the explicit cast operator:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用显式转换运算符在`BigInteger`和标准数值类型之间进行潜在的损失转换：
- en: '[PRE144]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The output from this demonstrates the loss of precision:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 这样输出显示了精度的损失：
- en: '[PRE145]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '`BigInteger` overloads all the arithmetic operators including remainder (`%`)
    as well as the comparison and equality operators.'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '`BigInteger`重载了所有算术运算符，包括余数（`%`）以及比较和相等运算符。'
- en: 'You can also construct a `BigInteger` from a byte array. The following code
    generates a 32-byte random number suitable for cryptography and then assigns it
    to a `BigInteger`:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以从字节数组构造一个`BigInteger`。以下代码生成一个适用于密码学的32字节随机数，然后将其分配给`BigInteger`：
- en: '[PRE146]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: The advantage of storing such a number in a `BigInteger` over a byte array is
    that you get value-type semantics. Calling `ToByteArray` converts a `BigInteger`
    back to a byte array.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 将这样的数存储在`BigInteger`中的优点是获得值类型语义。调用`ToByteArray`将`BigInteger`转换回字节数组。
- en: Half
  id: totrans-780
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Half
- en: The `Half` struct is a 16-bit floating point type, and was introduced with .NET
    5\. `Half` is intended mainly for interoperating with graphics card processors
    and does not have native support in most CPUs.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: '`Half`结构体是一个16位浮点类型，并且在.NET 5中引入。`Half`主要用于与图形处理器的互操作，大多数CPU不原生支持。'
- en: 'You can convert between `Half` and `float` or `double` via an explicit cast:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过显式转换在`Half`和`float`或`double`之间进行转换：
- en: '[PRE147]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: There are no arithmetic operations defined for this type, so you must convert
    to another type such as `float` or `double` in order to perform calculations.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 此类型未定义算术运算，因此必须转换为另一种类型，如`float`或`double`，才能执行计算。
- en: '`Half` has a range of -65500 to 65500:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: '`Half`的范围是从-65500到65500：'
- en: '[PRE148]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Note the loss of precision at the maximum range:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在最大范围时的精度损失：
- en: '[PRE149]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Complex
  id: totrans-789
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复数
- en: The `Complex` struct is another specialized numeric type that represents complex
    numbers with real and imaginary components of type `double`. `Complex` resides
    in the namespace (along with `BigInteger`).
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '`Complex`结构体是另一种专门的数值类型，表示具有`double`类型的实部和虚部的复数。`Complex`位于（以及`BigInteger`）命名空间中。'
- en: 'To use `Complex`, instantiate the struct, specifying the real and imaginary
    values:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`Complex`，实例化结构体，指定实部和虚部值：
- en: '[PRE150]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: There are also implicit conversions from the standard numeric types.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 也有从标准数值类型的隐式转换。
- en: 'The `Complex` struct exposes properties for the real and imaginary values as
    well as the phase and magnitude:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: '`Complex`结构体公开了用于实部和虚部以及相位和幅度的属性：'
- en: '[PRE151]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'You can also construct a `Complex` number by specifying magnitude and phase:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过指定幅度和相位来构造`Complex`数：
- en: '[PRE152]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The standard arithmetic operators are overloaded to work on `Complex` numbers:'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 标准算术运算符被重载以在`Complex`数上工作：
- en: '[PRE153]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'The `Complex` struct exposes static methods for more advanced functions, including
    the following:'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '`Complex`结构体公开了静态方法，用于更高级的函数，包括以下内容：'
- en: Trigonometric (`Sin`, `Asin`, `Sinh`, `Tan`, etc.)
  id: totrans-801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三角函数（`Sin`，`Asin`，`Sinh`，`Tan`等）
- en: Logarithms and exponentiations
  id: totrans-802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数和指数
- en: '`Conjugate`'
  id: totrans-803
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Conjugate`'
- en: Random
  id: totrans-804
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Random
- en: The `Random` class generates a pseudorandom sequence of random `byte`s, `integer`s,
    or `double`s.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '`Random`类生成伪随机序列的随机`byte`，`integer`或`double`。'
- en: 'To use `Random`, you first instantiate it, optionally providing a seed to initiate
    the random number series. Using the same seed guarantees the same series of numbers
    (if run under the same CLR version), which is sometimes useful when you want reproducibility:'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`Random`，首先实例化它，可选择提供种子来启动随机数序列。使用相同的种子保证了相同的数列（如果在相同的CLR版本下运行），有时在需要可再现性时很有用。
- en: '[PRE154]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: If you don’t want reproducibility, you can construct `Random` with no seed;
    in that case, it uses the current system time to make one up.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不想要可再现性，可以使用无种子构造`Random`；在这种情况下，它使用当前系统时间生成一个种子。
- en: Warning
  id: totrans-809
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Because the system clock has limited granularity, two `Random` instances created
    close together (typically within 10 ms) will yield the same sequence of values.
    A common trap is to instantiate a new `Random` object every time you need a random
    number rather than reusing the *same* object.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 因为系统时钟的精度有限，两个在短时间内（通常在 10 毫秒内）创建的 `Random` 实例将产生相同的值序列。一个常见的陷阱是每次需要随机数时实例化一个新的
    `Random` 对象，而不是重用*同一个*对象。
- en: A good pattern is to declare a single static `Random` instance. In multithreaded
    scenarios, however, this can cause trouble because `Random` objects are not thread-safe.
    We describe a workaround in [“Thread-Local Storage”](ch21.html#thread_local_storage).
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的模式是声明单个静态的 `Random` 实例。然而，在多线程场景中，这可能会引起麻烦，因为 `Random` 对象不是线程安全的。我们在[“线程本地存储”](ch21.html#thread_local_storage)中描述了一种解决方法。
- en: Calling `Next(*n*)` generates a random integer between 0 and `*n*−1`. `NextDouble`
    generates a random `double` between 0 and 1\. `NextBytes` fills a byte array with
    random values.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `Next(*n*)` 生成介于 0 和 `*n*−1` 之间的随机整数。`NextDouble` 生成介于 0 和 1 之间的随机 `double`。`NextBytes`
    用随机值填充字节数组。
- en: 'From .NET 8, the `Random` class includes a `GetItems` method, which picks *n*
    random items from a collection. The following code picks two random numbers from
    a collection of five:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 从 .NET 8 开始，`Random` 类包括一个 `GetItems` 方法，从集合中随机选择 *n* 个项目。以下代码从五个项目的集合中选择两个随机数：
- en: '[PRE155]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: From .NET 8, there’s also a `Shuffle` method to randomize the order of items
    within an array or span.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 从 .NET 8 开始，还有一个 `Shuffle` 方法，用于在数组或 span 中随机化项目的顺序。
- en: '`Random` is not considered random enough for high-security applications such
    as cryptography. For this, .NET provides a *cryptographically strong* random number
    generator, in the `System.Security.Cryptography` namespace. Here’s how to use
    it:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: '`Random` 不被认为对于密码学等高安全性应用程序足够随机。为此，.NET 在 `System.Security.Cryptography` 命名空间中提供了*密码强度随机数生成器*。以下是如何使用它：'
- en: '[PRE156]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'The downside is that it’s less flexible: filling a byte array is the only means
    of obtaining random numbers. To obtain an integer, you must use `BitConverter`:'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点在于它的灵活性较差：填充字节数组是获取随机数的唯一手段。要获得整数，必须使用 `BitConverter`：
- en: '[PRE157]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: BitOperations
  id: totrans-820
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BitOperations
- en: 'The `System.Numerics.BitOperations` class (from .NET 6) exposes the following
    methods to help with base-2 operations:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Numerics.BitOperations` 类（来自 .NET 6）公开了以下方法，以帮助进行基数为2的操作：'
- en: '`IsPow2`'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsPow2`'
- en: Returns true if a number is a power of 2
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个数字是2的幂，则返回 true
- en: '`LeadingZeroCount`/`TrailingZeroCount`'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: '`LeadingZeroCount`/`TrailingZeroCount`'
- en: Returns the number of leading zeros, when formatted as a base-2 32-bit or 64-bit
    unsigned integer
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 返回前导零的数量，以32位或64位无符号整数的二进制格式
- en: '`Log2`'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: '`Log2`'
- en: Returns the integer base-2 log of an unsigned integer
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 返回无符号整数的基数为2的对数
- en: '`PopCount`'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: '`PopCount`'
- en: Returns the number of bits set to 1 in an unsigned integer
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 返回无符号整数中设置为1的位数
- en: '`RotateLeft`/`RotateRight`'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: '`RotateLeft`/`RotateRight`'
- en: Performs a bitwise left/right rotation
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 执行按位左/右旋转
- en: '`RoundUpToPowerOf2`'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '`RoundUpToPowerOf2`'
- en: Rounds an unsigned integer up to the closest power of 2
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 将无符号整数四舍五入到最接近的2的幂
- en: Enums
  id: totrans-834
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: 'In [Chapter 3](ch03.html#creating_types_in_chash), we described C#’s enum type
    and showed how to combine members, test equality, use logical operators, and perform
    conversions. .NET extends C#’s support for enums through the `System.Enum` type.
    This type has two roles:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](ch03.html#creating_types_in_chash)，我们描述了 C# 的枚举类型，并展示了如何组合成员、测试相等性、使用逻辑运算符和执行转换。.NET
    通过 `System.Enum` 类型扩展了对 C# 枚举的支持。这个类型有两个角色：
- en: Providing type unification for all `enum` types
  id: totrans-836
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为所有 `enum` 类型提供类型统一
- en: Defining static utility methods
  id: totrans-837
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义静态实用方法
- en: '*Type unification* means that you can implicitly cast any enum member to a
    `System.Enum` instance:'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型统一*意味着你可以隐式地将任何枚举成员转换为 `System.Enum` 实例：'
- en: '[PRE158]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: The static utility methods on `System.Enum` are primarily related to performing
    conversions and obtaining lists of members.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Enum` 上的静态实用方法主要与执行转换和获取成员列表相关。'
- en: Enum Conversions
  id: totrans-841
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举转换
- en: 'There are three ways to represent an enum value:'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方法来表示枚举值：
- en: As an `enum` member
  id: totrans-843
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 `enum` 成员
- en: As its underlying integral value
  id: totrans-844
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为其底层整数值
- en: As a string
  id: totrans-845
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一个字符串
- en: In this section, we describe how to convert between each.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们描述了如何在它们之间进行转换。
- en: Enum to integral conversions
  id: totrans-847
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举到整数转换
- en: 'Recall that an explicit cast converts between an `enum` member and its integral
    value. An explicit cast is the correct approach if you know the `enum` type at
    compile time:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，显式转换在 `enum` 成员与其整数值之间进行转换。如果在编译时知道 `enum` 类型，则显式转换是正确的方法：
- en: '[PRE159]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'You can cast a `System.Enum` instance to its integral type in the same way.
    The trick is to first cast to an `object` and then the integral type:'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以相同的方式将`System.Enum`实例强制转换为其整数类型。诀窍是首先将其转换为`object`，然后再转换为整数类型：
- en: '[PRE160]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'This relies on you knowing the integral type: the method we just wrote would
    crash if passed an `enum` whose integral type was `long`. To write a method that
    works with an `enum` of any integral type, you can take one of three approaches.
    The first is to call `Convert.ToDecimal`:'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 这依赖于您知道整数类型：如果传递的枚举的整数类型是`long`，刚刚编写的方法将崩溃。要编写一个适用于任何整数类型枚举的方法，您可以采取以下三种方法之一。第一种是调用`Convert.ToDecimal`：
- en: '[PRE161]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'This works because every integral type (including `ulong`) can be converted
    to decimal without loss of information. The second approach is to call `Enum.GetUnderlyingType`
    in order to obtain the `enum`’s integral type, and then call `Convert.ChangeType`:'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为每种整数类型（包括`ulong`）都可以在不丢失信息的情况下转换为十进制。第二种方法是调用`Enum.GetUnderlyingType`来获取枚举的整数类型，然后调用`Convert.ChangeType`：
- en: '[PRE162]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'This preserves the original integral type, as the following example shows:'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 这保留了原始的整数类型，如下例所示：
- en: '[PRE163]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: Note
  id: totrans-858
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Our `GetBoxedIntegralType` method in fact performs no value conversion; rather,
    it *reboxes* the same value in another type. It translates an integral value in
    *enum-type* clothing to an integral value in *integral-type* clothing. We describe
    this further in [“How Enums Work”](#how_enums_work).
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`GetBoxedIntegralType`方法实际上不执行值转换；相反，它*重新装箱*相同值到另一种类型中。它将枚举类型中的整数值转换为整数类型的值。我们在[“枚举如何工作”](#how_enums_work)中进一步描述了这一点。
- en: 'The third approach is to call `Format` or `ToString` specifying the `"d"` or
    `"D"` format string. This gives you the `enum`’s integral value as a string, and
    it is useful when writing custom serialization formatters:'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法是调用`Format`或`ToString`并指定`"d"`或`"D"`格式字符串。这将给出枚举的整数值作为字符串，适用于编写自定义序列化格式化程序时非常有用：
- en: '[PRE164]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Integral to enum conversions
  id: totrans-862
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数到枚举转换
- en: '`Enum.ToObject` converts an integral value to an `enum` instance of the given
    type:'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enum.ToObject`将整数值转换为给定类型的`enum`实例：'
- en: '[PRE165]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'This is the dynamic equivalent of the following:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 这是以下内容的动态等价物：
- en: '[PRE166]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '`ToObject` is overloaded to accept all integral types as well as `object`.
    (The latter works with any boxed integral type.)'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToObject`被重载以接受所有整数类型以及`object`。（后者适用于任何装箱整数类型。）'
- en: String conversions
  id: totrans-868
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串转换
- en: To convert an `enum` to a string, you can either call the static `Enum.Format`
    method or call `ToString` on the instance. Each method accepts a format string,
    which can be `"G"` for default formatting behavior, `"D"` to emit the underlying
    integral value as a string, `"X"` for the same in hexadecimal, or `"F"` to format
    combined members of an enum without the `Flags` attribute. We listed examples
    of these in [“Standard Format Strings and Parsing Flags”](#standard_format_strings_and_parsing_fla).
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`enum`转换为字符串，您可以调用静态的`Enum.Format`方法或在实例上调用`ToString`方法。每种方法都接受一个格式字符串，可以是`"G"`以获取默认格式行为，`"D"`以将底层整数值作为字符串输出，`"X"`以十六进制输出相同值，或者`"F"`以格式化带有`Flags`属性的枚举的组合成员。我们在[“标准格式字符串和解析标志”](#standard_format_strings_and_parsing_fla)中列出了这些的示例。
- en: '`Enum.Parse` converts a string to an `enum`. It accepts the `enum` type and
    a string that can include multiple members:'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enum.Parse`将字符串转换为`enum`。它接受`enum`类型和可以包含多个成员的字符串：'
- en: '[PRE167]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: An optional third argument lets you perform case-insensitive parsing. An `ArgumentException`
    is thrown if the member is not found.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的第三个参数允许您执行不区分大小写的解析。如果未找到成员，则会抛出`ArgumentException`。
- en: Enumerating Enum Values
  id: totrans-873
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举枚举值
- en: '`Enum.GetValues` returns an array comprising all members of a particular `enum`
    type:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enum.GetValues`返回一个包含特定`enum`类型的所有成员的数组：'
- en: '[PRE168]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Composite members such as `LeftRight = Left | Right` are included, too.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 也包括`LeftRight = Left | Right`等复合成员。
- en: '`Enum.GetNames` performs the same function, but returns an array of *strings*.'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enum.GetNames`执行相同的功能，但返回一个*字符串*数组。'
- en: Note
  id: totrans-878
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Internally, the CLR implements `GetValues` and `GetNames` by reflecting over
    the fields in the `enum`’s type. The results are cached for efficiency.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，CLR通过反射枚举类型中的字段来实现`GetValues`和`GetNames`。结果被缓存以提高效率。
- en: How Enums Work
  id: totrans-880
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举如何工作
- en: The semantics of `enum`s are enforced largely by the compiler. In the CLR, there’s
    no runtime difference between an `enum` instance (when unboxed) and its underlying
    integral value. Further, an `enum` definition in the CLR is merely a subtype of
    `System.Enum` with static integral-type fields for each member. This makes the
    ordinary use of an `enum` highly efficient, with a runtime cost matching that
    of integral constants.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`的语义主要由编译器强制执行。在CLR中，当`enum`实例（未装箱时）与其基础整数值之间没有运行时差异。此外，CLR中的`enum`定义仅仅是`System.Enum`的一个子类型，每个成员都有静态的整数类型字段。这使得`enum`的普通使用非常高效，其运行时成本与整数常量相匹配。'
- en: 'The downside of this strategy is that `enum`s can provide *static* but not
    *strong* type safety. We saw an example of this in [Chapter 3](ch03.html#creating_types_in_chash):'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略的缺点是`enum`可以提供*静态*但不是*强大*的类型安全性。我们在[第3章](ch03.html#creating_types_in_chash)中看到了一个例子：
- en: '[PRE169]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: When the compiler is unable to perform validation (as in this example), there’s
    no backup from the runtime to throw an exception.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器无法执行验证（如本例中），运行时没有备用方法抛出异常。
- en: 'What we said about there being no runtime difference between an `enum` instance
    and its integral value might seem at odds with the following:'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的`enum`实例与其整数值之间在运行时没有差异，可能与以下内容相矛盾：
- en: '[PRE170]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Given the nature of an `enum` instance at runtime, you’d expect this to print
    `2` and `Int32`! The reason for its behavior is down to some more compile-time
    trickery. C# explicitly *boxes* an `enum` instance before calling its virtual
    methods—such as `ToString` or `GetType`. And when an `enum` instance is boxed,
    it gains a runtime wrapping that references its `enum` type.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到运行时`enum`实例的特性，您可能期望它打印出`2`和`Int32`！其行为的原因在于一些更多的编译时技巧。在调用其虚拟方法（如`ToString`或`GetType`）之前，C#明确地*装箱*一个`enum`实例。当`enum`实例被装箱时，它获得了一个运行时包装，引用其`enum`类型。
- en: The Guid Struct
  id: totrans-888
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Guid`结构体'
- en: 'The `Guid` struct represents a globally unique identifier: a 16-byte value
    that, when generated, is almost certainly unique in the world. `Guid`s are often
    used for keys of various sorts, in applications and databases. There are 2^(128),
    or 3.4 × 10^(38), unique `Guids`.'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: '`Guid`结构体代表一个全局唯一标识符：一个16字节的值，在生成时几乎可以肯定地是世界上唯一的。`Guid`经常用于各种应用程序和数据库的键。有2^(128)，或3.4
    × 10^(38)个唯一的`Guids`。'
- en: 'The static `Guid.NewGuid` method generates a unique `Guid`:'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的`Guid.NewGuid`方法生成一个唯一的`Guid`：
- en: '[PRE171]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'To instantiate an existing value, you use one of the constructors. The two
    most useful constructors are:'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 要实例化一个现有的值，可以使用其中一个构造函数。最常用的两个构造函数是：
- en: '[PRE172]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'When represented as a string, a `Guid` is formatted as a 32-digit hexadecimal
    number, with optional hyphens after the 8th, 12th, 16th, and 20th digits. The
    whole string can also be optionally wrapped in brackets or braces:'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为字符串表示时，`Guid`以32位十六进制数字格式化，第8、12、16和20位数字后可以加入可选的连字符。整个字符串也可以选择用方括号或花括号括起来：
- en: '[PRE173]'
  id: totrans-895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Being a struct, a `Guid` honors value-type semantics; hence, the equality operator
    works in the preceding example.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: '`Guid`作为一个结构体，遵循值类型语义；因此，等号运算符在上述示例中有效。'
- en: The `ToByteArray` method converts a `Guid` to a byte array.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToByteArray`方法将`Guid`转换为字节数组。'
- en: The static `Guid.Empty` property returns an empty `Guid` (all zeros). This is
    often used in place of `null`.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的`Guid.Empty`属性返回一个空的`Guid`（全为零）。这经常用于代替`null`。
- en: Equality Comparison
  id: totrans-899
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等值比较
- en: 'Until now, we’ve assumed that the `==` and `!=` operators are all there is
    to equality comparison. The issue of equality, however, is more complex and subtler,
    sometimes requiring the use of additional methods and interfaces. This section
    explores the standard C# and .NET protocols for equality, focusing particularly
    on two questions:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 目前为止，我们假设`==`和`!=`操作符是等值比较的全部内容。然而，等值的问题更加复杂和微妙，有时需要使用额外的方法和接口。本节探讨了等值的标准C#和.NET协议，特别关注两个问题：
- en: When are `==` and `!=` adequate—and inadequate—for equality comparison, and
    what are the alternatives?
  id: totrans-901
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么情况下使用`==`和`!=`来进行等值比较是合适的，而何时是不合适的，并且还有什么替代方法？
- en: How and when should you customize a type’s equality logic?
  id: totrans-902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何和何时自定义类型的等值逻辑？
- en: But before exploring the details of equality protocols and how to customize
    them, we first must look at the preliminary concept of value versus referential
    equality.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 但在探索等值协议的细节和如何定制它们之前，我们首先必须看一下值类型与引用类型等值的初步概念。
- en: Value Versus Referential Equality
  id: totrans-904
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值类型与引用类型的等值比较
- en: 'There are two kinds of equality:'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的等值：
- en: Value equality
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型的等值
- en: Two values are *equivalent* in some sense.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 两个值在某种意义上是 *等价* 的。
- en: Referential equality
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 引用相等性
- en: Two references refer to *exactly the same object*.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 两个引用引用*完全相同的对象*。
- en: 'Unless overridden:'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 除非被覆盖：
- en: Value types use *value equality*.
  id: totrans-911
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值类型使用 *值相等性*。
- en: Reference types use *referential equality*. (This is overridden with anonymous
    types and records.)
  id: totrans-912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用类型使用 *引用相等性*。（匿名类型和记录类型会覆盖这一点。）
- en: 'Value types, in fact, can use *only* value equality (unless boxed). A simple
    demonstration of value equality is to compare two numbers:'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型实际上可以使用 *只有* 值相等性（除非装箱）。展示值相等性的一个简单示例是比较两个数字：
- en: '[PRE174]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'A more elaborate demonstration is to compare two `DateTimeOffset` structs.
    The following prints `True` because the two `DateTimeOffset`s refer to the *same
    point in time* and so are considered equivalent:'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的演示是比较两个 `DateTimeOffset` 结构。以下输出 `True`，因为两个 `DateTimeOffset` 引用的是*相同的时间点*，因此被视为等价：
- en: '[PRE175]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: Note
  id: totrans-917
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`DateTimeOffset` is a struct whose equality semantics have been tweaked. By
    default, structs exhibit a special kind of value equality called *structural equality*
    in which two values are considered equal if all of their members are equal. (You
    can see this by creating a struct and calling its `Equals` method; more on this
    later.)'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTimeOffset` 是一个结构体，其相等性语义已经被调整。默认情况下，结构体展示一种特殊的值相等性，称为 *结构相等性*，如果它们的所有成员都相等，则被视为相等。（您可以通过创建一个结构体并调用其
    `Equals` 方法来查看这一点；稍后会详细介绍。）'
- en: 'Reference types exhibit referential equality by default. In the following example,
    `f1` and `f2` are not equal, despite their objects having identical content:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型默认展示引用相等性。在下面的示例中，`f1` 和 `f2` 不相等，尽管它们的对象具有相同的内容：
- en: '[PRE176]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'In contrast, `f3` and `f1` are equal because they reference the same object:'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`f3` 和 `f1` 相等，因为它们引用相同的对象：
- en: '[PRE177]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Later in this section, we explain how you can *customize* reference types to
    exhibit value equality. An example of this is the `Uri` class in the `System`
    namespace:'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的后面，我们将解释如何 *定制* 引用类型以展示值相等性。一个例子是 `System` 命名空间中的 `Uri` 类：
- en: '[PRE178]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'The `string` class exhibits similar behavior:'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: '`string` 类也展示类似的行为：'
- en: '[PRE179]'
  id: totrans-926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Standard Equality Protocols
  id: totrans-927
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准相等性协议
- en: 'There are three standard protocols that types can implement for equality comparison:'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 类型可以实现三种标准协议进行相等性比较：
- en: The `==` and `!=` operators
  id: totrans-929
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`==` 和 `!=` 运算符'
- en: The virtual `Equals` method in `object`
  id: totrans-930
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object` 中的虚拟 `Equals` 方法'
- en: The `IEquatable<T>` interface
  id: totrans-931
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IEquatable<T>` 接口'
- en: In addition, there are the *pluggable* protocols and the `IStructuralEquatable`
    interface, which we describe in [Chapter 7](ch07.html#collections-id00055).
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有 *可插入* 的协议和 `IStructuralEquatable` 接口，我们在 [第7章](ch07.html#collections-id00055)
    中描述。
- en: == and !=
  id: totrans-933
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: == 和 !=
- en: 'We’ve already seen in many examples how the standard `==` and `!=` operators
    perform equality/inequality comparisons. The subtleties with `==` and `!=` arise
    because they are *operators*; thus, they are statically resolved (in fact, they
    are implemented as `static` functions). So, when you use `==` or `!=`, C# makes
    a *compile-time* decision as to which type will perform the comparison, and no
    `virtual` behavior comes into play. This is normally desirable. In the following
    example, the compiler hardwires `==` to the `int` type because `x` and `y` are
    both `int`:'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在许多示例中看到标准的 `==` 和 `!=` 运算符如何执行相等性/不相等性比较。 `==` 和 `!=` 的微妙之处在于它们是 *运算符*；因此，它们是静态解析的（实际上，它们被实现为
    `static` 函数）。因此，当您使用 `==` 或 `!=` 时，C# 在编译时决定哪种类型执行比较，并且没有 `virtual` 行为参与。这通常是可取的。在下面的示例中，编译器将
    `==` 硬编码为 `int` 类型，因为 `x` 和 `y` 都是 `int`：
- en: '[PRE180]'
  id: totrans-935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'But in the next example, the compiler wires the `==` operator to the `object`
    type:'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 但在下一个示例中，编译器将 `==` 操作符硬编码为 `object` 类型：
- en: '[PRE181]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: Because `object` is a class (and so a reference type), `object`’s `==` operator
    uses *referential equality* to compare `x` and `y`. The result is `false` because
    `x` and `y` each refer to different boxed objects on the heap.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `object` 是一个类（因此是引用类型），`object` 的 `==` 运算符使用 *引用相等性* 来比较 `x` 和 `y`。结果是 `false`，因为
    `x` 和 `y` 各自引用堆上不同的装箱对象。
- en: The virtual Object.Equals method
  id: totrans-939
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 虚拟的 Object.Equals 方法
- en: 'To correctly equate `x` and `y` in the preceding example, we can use the virtual
    `Equals` method. `Equals` is defined in `System.Object` and so is available to
    all types:'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中正确地使 `x` 和 `y` 相等，我们可以使用虚拟的 `Equals` 方法。 `Equals` 定义在 `System.Object`
    中，因此对所有类型都可用：
- en: '[PRE182]'
  id: totrans-941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '`Equals` is resolved at runtime—according to the object’s actual type. In this
    case, it calls `Int32`’s `Equals` method, which applies *value equality* to the
    operands, returning `true`. With reference types, `Equals` performs referential
    equality comparison by default; with structs, `Equals` performs structural comparison
    by calling `Equals` on each of its fields.'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: '`Equals` 是在运行时解析的——根据对象的实际类型。在这种情况下，它调用 `Int32` 的 `Equals` 方法，这适用于*值相等性*的操作数，返回
    `true`。对于引用类型，`Equals` 默认执行引用相等性比较；对于结构体，`Equals` 通过调用每个字段的 `Equals` 方法执行结构比较。'
- en: 'Hence, `Equals` is suitable for equating two objects in a type-agnostic fashion.
    The following method equates two objects of any type:'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Equals` 适用于以类型不可知的方式比较两个对象。以下方法将等同于任何类型的两个对象：
- en: '[PRE183]'
  id: totrans-944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'There is one case, however, in which this fails. If the first argument is `null`,
    you get a `NullReferenceException`. Here’s the fix:'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个情况是失败的。如果第一个参数是 `null`，将会得到 `NullReferenceException`。以下是修复方法：
- en: '[PRE184]'
  id: totrans-946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Or, more succinctly:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更简洁地说：
- en: '[PRE185]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: The static object.Equals method
  id: totrans-949
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态的 object.Equals 方法
- en: 'The `object` class provides a static helper method that does the work of `AreEqual`
    in the preceding example. Its name is `Equals`—just like the virtual method—but
    there’s no conflict because it accepts *two* arguments:'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: '`object` 类提供了一个静态帮助方法，在前面例子中的 `AreEqual` 中执行的工作。它的名字是 `Equals` —— 就像虚拟方法一样——但没有冲突，因为它接受*两个*参数：'
- en: '[PRE186]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'This provides a null-safe equality comparison algorithm for when the types
    are unknown at compile time:'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 这为在编译时类型未知时提供了一个空安全的等式比较算法：
- en: '[PRE187]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'A useful application is when writing generic types. The following code will
    not compile if `object.Equals` is replaced with the `==` or `!=` operator:'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写泛型类型时，一个有用的应用场景是。如果将 `object.Equals` 替换为 `==` 或 `!=` 运算符，则以下代码将无法编译：
- en: '[PRE188]'
  id: totrans-955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: Operators are prohibited here because the compiler cannot bind to the static
    method of an unknown type.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 在此禁止使用运算符，因为编译器无法绑定到未知类型的静态方法。
- en: Note
  id: totrans-957
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'A more elaborate way to implement this comparison is with the `EqualityComparer<T>`
    class. This has the advantage of avoiding boxing:'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的实现方法是使用 `EqualityComparer<T>` 类进行比较。这样做的好处是避免装箱：
- en: '[PRE189]'
  id: totrans-959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: We discuss `EqualityComparer<T>` in more detail in [Chapter 7](ch07.html#collections-id00055)
    (see [“Plugging in Equality and Order”](ch07.html#plugging_in_equality_and_order)).
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第 7 章](ch07.html#collections-id00055)中更详细地讨论了 `EqualityComparer<T>`（请参见[“插入等式和顺序”](ch07.html#plugging_in_equality_and_order)）。
- en: The static object.ReferenceEquals method
  id: totrans-961
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态的 object.ReferenceEquals 方法
- en: 'Occasionally, you need to force referential equality comparison. The static
    `object.ReferenceEquals` method does just that:'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您需要强制执行引用相等性比较。静态的 `object.ReferenceEquals` 方法正是为此而设计的：
- en: '[PRE190]'
  id: totrans-963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: You might want to do this because it’s possible for `Widget` to override the
    virtual `Equals` method such that `w1.Equals(w2)` would return `true`. Further,
    it’s possible for `Widget` to overload the `==` operator so that `w1==w2` would
    also return `true`. In such cases, calling `object.ReferenceEquals` guarantees
    normal referential equality semantics.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想要这样做，因为 `Widget` 可以重写虚拟 `Equals` 方法以使 `w1.Equals(w2)` 返回 `true`。此外，`Widget`
    可以重载 `==` 运算符，使得 `w1==w2` 也会返回 `true`。在这种情况下，调用 `object.ReferenceEquals` 可以保证正常的引用相等性语义。
- en: Note
  id: totrans-965
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Another way to force referential equality comparison is to cast the values to
    `object` and then apply the `==` operator.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种强制执行引用相等性比较的方法是将值转换为 `object`，然后应用 `==` 运算符。
- en: The IEquatable<T> interface
  id: totrans-967
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`IEquatable<T>` 接口'
- en: 'A consequence of calling `object.Equals` is that it forces boxing on value
    types. This is undesirable in highly performance-sensitive scenarios because boxing
    is relatively expensive compared to the actual comparison. A solution was introduced
    in C# 2.0, with the `IEquatable<T>` interface:'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `object.Equals` 的后果是在值类型上强制执行装箱。在高度性能敏感的情景中，这是不理想的，因为与实际比较相比，装箱相对昂贵。C# 2.0
    中引入了一个解决方案，即 `IEquatable<T>` 接口：
- en: '[PRE191]'
  id: totrans-969
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'The idea is that `IEquatable<T>`, when implemented, gives the same result as
    calling `object`’s virtual `Equals` method—but more quickly. Most basic .NET types
    implement `IEquatable<T>`. You can use `IEquatable<T>` as a constraint in a generic
    type:'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 其思想是，当实现时，`IEquatable<T>` 的结果与调用 `object` 的虚拟 `Equals` 方法相同——但更快。大多数基本的 .NET
    类型实现了 `IEquatable<T>`。您可以在泛型类型中使用 `IEquatable<T>` 作为约束条件：
- en: '[PRE192]'
  id: totrans-971
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: If we remove the generic constraint, the class would still compile, but `a.Equals(b)`
    would instead bind to the slower `object.Equals` (slower assuming `T` was a value
    type).
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们移除泛型约束，类仍然可以编译，但 `a.Equals(b)` 将绑定到较慢的 `object.Equals`（假设 `T` 是值类型时）。
- en: When Equals and == are not equal
  id: totrans-973
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当`Equals`和`==`不相等时
- en: 'We said earlier that it’s sometimes useful for `==` and `Equals` to apply different
    definitions of equality. For example:'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前说过，有时让`==`和`Equals`应用不同的相等性定义是很有用的。例如：
- en: '[PRE193]'
  id: totrans-975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'The `double` type’s `==` operator enforces that one `NaN` can never equal anything
    else—even another `NaN`. This is most natural from a mathematical perspective,
    and it reflects the underlying CPU behavior. The `Equals` method, however, is
    obliged to apply *reflexive* equality; in other words:'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: '`double`类型的`==`运算符强制一个`NaN`永远不能等于其他任何东西，即使是另一个`NaN`。从数学角度来看，这是最自然的，并且反映了底层CPU的行为。然而，`Equals`方法却必须应用*自反相等性*；换句话说：'
- en: '`x.Equals (x)` must *always* return true.'
  id: totrans-977
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x.Equals(x)`必须*始终*返回true。'
- en: Collections and dictionaries rely on `Equals` behaving this way; otherwise,
    they could not find an item they previously stored.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 集合和字典依赖于`Equals`的这种行为；否则，它们无法找到之前存储的项。
- en: 'Having `Equals` and `==` apply different definitions of equality is actually
    quite rare with value types. A more common scenario is with reference types; this
    happens when the author customizes `Equals` so that it performs value equality
    while leaving `==` to perform (default) referential equality. The `StringBuilder`
    class does exactly that:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 当作者定制`Equals`以执行值相等性而保留`==`以执行（默认）引用相等性时，值类型之间应用不同的相等性定义实际上是相当罕见的。更常见的情况是在引用类型中；当作者定制`Equals`使其执行值相等性而保留`==`执行（默认）引用相等性时，就会发生这种情况。`StringBuilder`类正是如此：
- en: '[PRE194]'
  id: totrans-980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: Let’s now look at how to customize equality.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何定制相等性。
- en: Equality and Custom Types
  id: totrans-982
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平等性和自定义类型
- en: 'Recall default equality comparison behavior:'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾默认的相等性比较行为：
- en: Value types use *value equality*.
  id: totrans-984
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值类型使用*值相等性*。
- en: Reference types use *referential equality* unless overridden (as is the case
    with anonymous types and records).
  id: totrans-985
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用类型使用*引用相等性*，除非被覆盖（如匿名类型和记录类型）。
- en: 'Further:'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 此外：
- en: A struct’s `Equals` method applies *structural value equality* by default (i.e.,
    it compares each field in the struct).
  id: totrans-987
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体的`Equals`方法默认应用*结构值相等性*（即比较结构体中的每个字段）。
- en: 'Sometimes, it makes sense to override this behavior when writing a type. There
    are two cases for doing so:'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当编写一个类型时，覆盖此行为是有意义的。有两种情况可以这样做：
- en: To change the meaning of equality
  id: totrans-989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变相等性的含义
- en: To speed up equality comparisons for structs
  id: totrans-990
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了加快结构体的相等性比较
- en: Changing the meaning of equality
  id: totrans-991
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改变相等性的含义
- en: 'Changing the meaning of equality makes sense when the default behavior of `==`
    and `Equals` is unnatural for your type and is *not what a consumer would expect*.
    An example is `DateTimeOffset`, a struct with two private fields: a UTC `DateTime`
    and a numeric integer offset. If you were writing this type, you’d probably want
    to ensure that equality comparisons considered only the UTC `DateTime` field and
    not the offset field. Another example is numeric types that support `NaN` values
    such as `float` and `double`. If you were implementing such types yourself, you’d
    want to ensure that `NaN`-comparison logic was supported in equality comparisons.'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 当默认的`==`和`Equals`行为对你的类型来说不自然且*不符合消费者期望*时，改变相等性的含义是有意义的。一个例子是`DateTimeOffset`，一个包含两个私有字段的结构体：一个UTC
    `DateTime`和一个数值整数偏移量。如果你正在编写这种类型，你可能希望确保相等性比较仅考虑UTC `DateTime`字段而不考虑偏移字段。另一个例子是支持`NaN`值的数值类型，如`float`和`double`。如果你自己实现这样的类型，你会希望确保在相等性比较中支持`NaN`比较逻辑。
- en: With classes, it’s sometimes more natural to offer *value equality* as the default
    instead of *referential equality*. This is often the case with small classes that
    hold a simple piece of data, such as `System.Uri` (or `System.String`).
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类来说，有时候将*值相等性*作为默认选项而不是*引用相等性*更加自然。这在持有简单数据的小类（如`System.Uri`或`System.String`）中经常发生。
- en: With records, the compiler automatically implements structural equality (by
    comparing each field). Sometimes, however, this will include fields that you don’t
    want to compare, or objects that require special comparison logic, such as collections.
    The process of overriding equality with records is slightly different because
    records follow a special pattern that’s designed to play well with its rules for
    inheritance.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 对于记录类型，编译器会自动实现结构相等性（通过比较每个字段）。然而，有时这将包括你不想比较的字段，或者需要特殊比较逻辑的对象，比如集合。用记录类型覆盖相等性的过程略有不同，因为记录类型遵循一种特殊的模式，旨在与其继承规则完美配合。
- en: Speeding up equality comparisons with structs
  id: totrans-995
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加快结构体的相等性比较
- en: The default *structural equality* comparison algorithm for structs is relatively
    slow. Taking over this process by overriding `Equals` can improve performance
    by a factor of five. Overloading the `==` operator and implementing `IEquatable<T>`
    allows unboxed equality comparisons, and this can speed things up by a factor
    of five again.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 对于结构的默认*结构相等*比较算法相对较慢。 通过重写`Equals`来接管此过程可以将性能提升五倍。 重载`==`运算符并实现`IEquatable<T>`允许未装箱的相等比较，这可以再次加快五倍速度。
- en: Note
  id: totrans-997
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Overriding equality semantics for reference types doesn’t benefit performance.
    The default algorithm for referential equality comparison is already very fast
    because it simply compares two 32- or 64-bit references.
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 重写引用类型的相等语义对性能没有好处。 引用相等比较的默认算法已经非常快速，因为它只是比较两个32位或64位引用。
- en: There’s another, rather peculiar case for customizing equality, and that’s to
    improve a struct’s hashing algorithm for better performance in a hashtable. This
    comes as a result of the fact that equality comparison and hashing are joined
    at the hip. We examine hashing in a moment.
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 对于优化结构的哈希算法来说，还有另一个相当奇特的情况，这可以改善哈希表中结构的性能。 这是由于相等比较和哈希在某种程度上是相关联的。 我们稍后会详细讨论哈希。
- en: How to override equality semantics
  id: totrans-1000
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何重写相等语义
- en: 'To override equality with classes or structs, here are the steps:'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 要重写类或结构的相等性，以下是步骤：
- en: Override `GetHashCode()` and `Equals()`.
  id: totrans-1002
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`GetHashCode()`和`Equals()`。
- en: (Optionally) overload `!=` and `==`.
  id: totrans-1003
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （可选）重载`!=`和`==`。
- en: (Optionally) implement `IEquatable<T>`.
  id: totrans-1004
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （可选）实现`IEquatable<T>`。
- en: 'The process is different (and simpler) with records because the compiler already
    overrides the equality methods and operators in line with its own special pattern.
    If you want to intervene, you must conform to this pattern, which means writing
    an `Equals` method with a signature like this:'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 与记录不同（也更简单），因为编译器已经按照自己的特殊模式重写了相等方法和运算符。 如果你想介入，你必须符合这个模式，这意味着写一个像这样的`Equals`方法：
- en: '[PRE195]'
  id: totrans-1006
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: Notice that `Equals` is `virtual` (not `override`) and accepts the actual record
    type (`Test` in this case, and not `object`). The compiler will recognize that
    your method has the “correct” signature and will patch it in.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Equals`是`virtual`（而不是`override`），并且接受实际的记录类型（在这种情况下是`Test`，而不是`object`）。
    编译器将识别您的方法具有“正确”的签名，并将其修补入其中。
- en: You must also override `GetHashCode()`, just as you would with classes or structs.
    You don’t need to (and shouldn’t) overload `!=` and `==`, or implement `IEquatable<T>`,
    because this is already done for you.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 你还必须重写`GetHashCode()`，就像你为类或结构体所做的一样。 你不需要（也不应该）重载`!=`和`==`，或者实现`IEquatable<T>`，因为这些已经为你完成。
- en: Overriding GetHashCode
  id: totrans-1009
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重写`GetHashCode`
- en: 'It might seem odd that `System.Object`—with its small footprint of members—defines
    a method with a specialized and narrow purpose. `GetHashCode` is a virtual method
    in `Object` that fits this description; it exists primarily for the benefit of
    just the following two types:'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Object` ——具有成员的小足迹 ——定义了一个专门且狭窄目的的方法，可能会显得有些奇怪。 `GetHashCode`是`Object`中的一个虚方法，符合这一描述；它主要有利于以下两种类型：'
- en: '[PRE196]'
  id: totrans-1011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: These are *hashtables*—collections for which each element has a key used for
    storage and retrieval. A hashtable applies a very specific strategy for efficiently
    allocating elements based on their key. This requires that each key have an `Int32`
    number, or *hash code*. The hash code need not be unique for each key, but should
    be as varied as possible for good hashtable performance. Hashtables are considered
    important enough that `GetHashCode` is defined in `System.Object`—so that every
    type can emit a hash code.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是*哈希表* ——每个元素都有用于存储和检索的键的集合。 哈希表应用非常具体的策略来基于它们的键高效地分配元素。 这要求每个键有一个`Int32`数，或者*哈希码*。
    哈希码不必对每个键唯一，但为了好的哈希表性能，应尽可能多样化。 哈希表被认为非常重要，以至于`GetHashCode`在`System.Object`中被定义
    ——这样每种类型都可以生成一个哈希码。
- en: Note
  id: totrans-1013
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We describe hashtables in detail in [Chapter 7](ch07.html#collections-id00055).
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第7章](ch07.html#collections-id00055)中详细描述了哈希表。
- en: Both reference and value types have default implementations of `GetHashCode`,
    meaning that you don’t need to override this method—*unless you override* `Equals`.
    (And if you override `GetHashCode`, you will almost certainly want to also override
    `Equals`.)
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型和值类型都有`GetHashCode`的默认实现，这意味着你不需要重写这个方法 —— *除非你重写* `Equals`。（如果你重写`GetHashCode`，你几乎肯定也想重写`Equals`。）
- en: 'Here are the other rules for overriding `object.GetHashCode`:'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 对于重写`object.GetHashCode`的其他规则如下：
- en: It must return the same value on two objects for which `Equals` returns `true`
    (hence, `GetHashCode` and `Equals` are overridden together).
  id: totrans-1017
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于两个对象，如果`Equals`返回`true`，则它们必须返回相同的值（因此，一起重写`GetHashCode`和`Equals`）。
- en: It must not throw exceptions.
  id: totrans-1018
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能抛出异常。
- en: It must return the same value if called repeatedly on the same object (unless
    the object has *changed*).
  id: totrans-1019
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在同一对象上重复调用，则必须返回相同的值（除非对象已*更改*）。
- en: For maximum performance in hashtables, you should write `GetHashCode` so as
    to minimize the likelihood of two different values returning the same hashcode.
    This gives rise to the third reason for overriding `Equals` and `GetHashCode`
    on structs, which is to provide a more efficient hashing algorithm than the default.
    The default implementation for structs is at the discretion of the runtime and
    can be based on every field in the struct.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在哈希表中获得最大性能，应编写`GetHashCode`以尽量减少两个不同值返回相同哈希码的可能性。这引出了在`struct`上重写`Equals`和`GetHashCode`的第三个原因，即提供比默认更高效的哈希算法。结构体的默认实现由运行时自行决定，并且可以基于结构体中的每个字段。
- en: In contrast, the default `GetHashCode` implementation for *classes* is based
    on an internal object token, which is unique for each instance in the CLR’s current
    implementation.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，*类*的默认`GetHashCode`实现基于内部对象令牌，在CLR当前实现中对每个实例都是唯一的。
- en: Warning
  id: totrans-1022
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: If an object’s hashcode changes after it’s been added as a key to a dictionary,
    the object will no longer be accessible in the dictionary. You can preempt this
    by basing hashcode calculations on immutable fields.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象在添加为字典键之后其哈希码更改，则该对象将不再可访问字典中。您可以通过将哈希码计算基于不可变字段来预防此问题。
- en: We provide a complete example illustrating how to override `GetHashCode` shortly.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个完整的示例，说明如何很快地重写`GetHashCode`。
- en: Overriding Equals
  id: totrans-1025
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重写Equals
- en: 'The axioms for `object.Equals` are as follows:'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: '`object.Equals`的公理如下：'
- en: An object cannot equal `null` (unless it’s a nullable type).
  id: totrans-1027
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象不能等于`null`（除非它是可空类型）。
- en: Equality is *reflexive* (an object equals itself).
  id: totrans-1028
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相等性是*自反*的（对象等于自身）。
- en: Equality is *commutative* (if `a.Equals(b)`, then `b.Equals(a)`).
  id: totrans-1029
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相等性是*交换*的（如果`a.Equals(b)`，则`b.Equals(a)`）。
- en: Equality is *transitive* (if `a.Equals(b)` and `b.Equals(c)`, then `a.Equals(c)`).
  id: totrans-1030
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相等性是*传递*的（如果`a.Equals(b)`和`b.Equals(c)`，则`a.Equals(c)`）。
- en: Equality operations are repeatable and reliable (they don’t throw exceptions).
  id: totrans-1031
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相等操作是可重复且可靠的（它们不会抛出异常）。
- en: Overloading == and !=
  id: totrans-1032
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重载==和!=
- en: In addition to overriding `Equals`, you can optionally overload the equality
    and inequality operators. This is nearly always done with structs because the
    consequence of not doing so is that the `==` and `!=` operators will simply not
    work on your type.
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 除了重写`Equals`之外，您还可以选择重载相等和不相等运算符。这几乎总是在`struct`中完成，因为不这样做的后果是`==`和`!=`运算符在您的类型上根本不起作用。
- en: 'With classes, there are two ways to proceed:'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类，有两种方法可以继续：
- en: Leave `==` and `!=` alone—so that they apply referential equality.
  id: totrans-1035
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留`==`和`!=`不变——使其适用于引用相等。
- en: Overload `==` and `!=` in line with `Equals`.
  id: totrans-1036
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载`==`和`!=`以与`Equals`保持一致。
- en: 'The first approach is most common with custom types—especially *mutable* types.
    It ensures that your type follows the expectation that `==` and `!=` should exhibit
    referential equality with reference types, and this avoids confusing consumers.
    We saw an example earlier:'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法在自定义类型中最为常见，特别是*可变*类型。它确保您的类型遵循`==`和`!=`应表现为引用类型的引用相等的预期，这样可以避免使消费者困惑。我们之前看过一个例子：
- en: '[PRE197]'
  id: totrans-1038
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: The second approach makes sense with types for which a consumer would never
    want referential equality. These are typically immutable—such as the `string`
    and `System.Uri` classes—and are sometimes good candidates for `struct`s.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法在消费者永远不希望引用相等的类型（通常是不可变的，如`string`和`System.Uri`类）时是有意义的，并且有时是`struct`的良好候选者。
- en: Note
  id: totrans-1040
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Although it’s possible to overload `!=` such that it means something other than
    `!(==)`, this is rarely done in practice. An example is with the types defined
    in the `System.Data.SqlTypes` namespace that represent native column types in
    SQL Server. These follow the null comparison logic of databases, whereby the `=`
    and `<>` operators (`==` and `!=` in C#) both return null if either operand is
    null.
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以重载`!=`以使其意味着不同于`!(==)`，但在实践中很少这样做。一个例子是在`System.Data.SqlTypes`命名空间中定义的类型，它们表示SQL
    Server中的本机列类型。这些遵循数据库的空比较逻辑，即如果任一操作数为空，则`=`和`<>`运算符（在C#中为`==`和`!=`）都返回null。
- en: Implementing IEquatable<T>
  id: totrans-1042
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现IEquatable<T>
- en: For completeness, it’s also good to implement `IEquatable<T>` when overriding
    `Equals`. Its results should always match those of the overridden object’s `Equals`
    method. Implementing `IEquatable<T>` comes at no programming cost if you structure
    your `Equals` method implementation as in the example that follows in a moment.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，当重写`Equals`时，实现`IEquatable<T>`也是个好主意。其结果应始终与重写对象的`Equals`方法匹配。如果你将`Equals`方法的实现结构化如下面的示例，实现`IEquatable<T>`并不会增加编程成本。
- en: 'An example: the Area struct'
  id: totrans-1044
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个示例：Area结构体
- en: Imagine that we need a struct to represent an area whose width and height are
    interchangeable. In other words, 5 × 10 is equal to 10 × 5\. (Such a type would
    be suitable in an algorithm that arranges rectangular shapes.)
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们需要一个结构体来表示一个宽度和高度可互换的区域。换句话说，5 × 10等于10 × 5。（这样的类型在安排矩形形状的算法中很合适。）
- en: 'Here’s the complete code:'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是完整的代码：
- en: '[PRE198]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: Note
  id: totrans-1048
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: From C# 10, you can shortcut the process with records. By declaring this as
    a `record struct`, you can remove all the code following the constructor.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 10开始，你可以通过记录类型来简化这个过程。通过将其声明为`record struct`，你可以删除构造函数后面的所有代码。
- en: In implementing `GetHashCode`, we used .NET’s `HashCode.Combine` function to
    produce a composite hashcode. (Before that function existed, a popular approach
    was to multiply each value by some prime number and then add them together.)
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现`GetHashCode`时，我们使用了.NET的`HashCode.Combine`函数来生成一个复合哈希码。（在该函数存在之前，一种流行的方法是将每个值乘以某个质数，然后将它们相加。）
- en: 'Here’s a demonstration of the `Area` struct:'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`Area`结构的演示：
- en: '[PRE199]'
  id: totrans-1052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: Pluggable equality comparers
  id: totrans-1053
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可插拔的相等性比较器
- en: If you want a type to take on different equality semantics just for a specific
    scenario, you can use a pluggable `IEqualityComparer`. This is particularly useful
    in conjunction with the standard collection classes, and we describe it in the
    following chapter, in [“Plugging in Equality and Order”](ch07.html#plugging_in_equality_and_order).
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望某个类型在特定场景下具有不同的相等语义，可以使用可插拔的`IEqualityComparer`。这在与标准集合类结合使用时特别有用，我们将在下一章中描述它，即在[“插入相等性和排序”](ch07.html#plugging_in_equality_and_order)中。
- en: Order Comparison
  id: totrans-1055
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序比较
- en: 'As well as defining standard protocols for equality, C# and .NET define two
    standard protocols for determining the order of one object relative to another:'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定义相等的标准协议外，C#和.NET还定义了两个用于确定一个对象相对于另一个对象顺序的标准协议：
- en: The `IComparable` interfaces (`IComparable` and `IComparable<T>`)
  id: totrans-1057
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IComparable`接口（`IComparable`和`IComparable<T>`）'
- en: The `>` and `<` operators
  id: totrans-1058
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>` 和 `<` 运算符'
- en: 'The `IComparable` interfaces are used by general-purpose sorting algorithms.
    In the following example, the static `Array.Sort` method works because `System.String`
    implements the `IComparable` interfaces:'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 通用排序算法使用`IComparable`接口。在下面的示例中，静态的`Array.Sort`方法之所以有效，是因为`System.String`实现了`IComparable`接口：
- en: '[PRE200]'
  id: totrans-1060
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: The `<` and `>` operators are more specialized, and they are intended mostly
    for numeric types. Because they are statically resolved, they can translate to
    highly efficient bytecode, suitable for computationally intensive algorithms.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: '`<` 和 `>` 运算符更加专门化，主要用于数值类型。由于它们是静态解析的，它们可以转换为高效的字节码，非常适合计算密集型算法。'
- en: .NET also provides pluggable ordering protocols, via the `IComparer` interfaces.
    We describe these in the final section of [Chapter 7](ch07.html#collections-id00055).
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: .NET还通过`IComparer`接口提供了可插拔的排序协议。我们在[第7章](ch07.html#collections-id00055)的最后一节中描述了这些内容。
- en: IComparable
  id: totrans-1063
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IComparable
- en: 'The `IComparable` interfaces are defined as follows:'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: '`IComparable`接口定义如下：'
- en: '[PRE201]'
  id: totrans-1065
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'The two interfaces represent the same functionality. With value types, the
    generic type-safe interface is faster than the nongeneric interface. In both cases,
    the `CompareTo` method works as follows:'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个接口代表相同的功能。对于值类型，泛型类型安全的接口比非泛型接口更快。无论哪种情况，`CompareTo`方法的工作方式如下：
- en: If `a` comes after `b`, `a.CompareTo(b)` returns a positive number.
  id: totrans-1067
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`a`在`b`之后，`a.CompareTo(b)`返回一个正数。
- en: If `a` is the same as `b`, `a.CompareTo(b)` returns `0`.
  id: totrans-1068
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`a`等同于`b`，`a.CompareTo(b)`返回`0`。
- en: If `a` comes before `b`, `a.CompareTo(b)` returns a negative number.
  id: totrans-1069
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`a`在`b`之前，`a.CompareTo(b)`返回一个负数。
- en: 'For example:'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE202]'
  id: totrans-1071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: Most of the base types implement both `IComparable` interfaces. These interfaces
    are also sometimes implemented when writing custom types. We provide an example
    shortly.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数基本类型都同时实现了`IComparable`接口。在编写自定义类型时，有时也会实现这些接口。我们很快会提供一个示例。
- en: IComparable versus Equals
  id: totrans-1073
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IComparable与Equals
- en: 'Consider a type that both overrides `Equals` and implements the `IComparable`
    interfaces. You’d expect that when `Equals` returns `true`, `CompareTo` should
    return `0`. And you’d be right. But here’s the catch:'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个既重写了`Equals`又实现了`IComparable`接口的类型。你期望当`Equals`返回`true`时，`CompareTo`应该返回`0`。而且你是对的。但这里有个要注意的地方：
- en: When `Equals` returns `false`, `CompareTo` can return what it likes (as long
    as it’s internally consistent)!
  id: totrans-1075
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`Equals`返回`false`时，`CompareTo`可以返回它喜欢的结果（只要内部一致即可）！
- en: In other words, equality can be “fussier” than comparison, but not vice versa
    (violate this and sorting algorithms will break). So, `CompareTo` can say, “All
    objects are equal,” whereas `Equals` says, “But some are more equal than others!”
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，相等性可以比比较性“苛刻”，但反之则不然（违反这一点将导致排序算法出错）。因此，`CompareTo`可以说：“所有对象都是相等的”，而`Equals`则说：“但有些对象比其他对象更相等！”
- en: A great example of this is `System.String`. `String`’s `Equals` method and `==`
    operator use *ordinal* comparison, which compares the Unicode point values of
    each character. Its `CompareTo` method, however, uses a *culture-dependent* comparison,
    which sometimes puts more than one character into the same sorting position.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.String`就是一个很好的例子。`String`的`Equals`方法和`==`运算符使用*序数*比较，即比较每个字符的Unicode点值。然而，它的`CompareTo`方法使用*与文化相关*的比较，有时会将多个字符放入同一排序位置。'
- en: 'In [Chapter 7](ch07.html#collections-id00055), we discuss the pluggable ordering
    protocol, `IComparer`, which allows you to specify an alternative ordering algorithm
    when sorting or instantiating a sorted collection. A custom `IComparer` can further
    extend the gap between `CompareTo` and `Equals`—a case-insensitive string comparer,
    for instance, will return `0` when comparing `"A"` and `"a"`. The reverse rule
    still applies, however: `CompareTo` can never be fussier than `Equals`.'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html#collections-id00055)中，我们讨论了可插拔的排序协议`IComparer`，它允许在排序或实例化排序集合时指定替代排序算法。自定义的`IComparer`可以进一步扩展`CompareTo`和`Equals`之间的差距——例如，不区分大小写的字符串比较器在比较`"A"`和`"a"`时会返回`0`。然而，反向规则仍然适用：`CompareTo`永远不能比`Equals`更苛刻。
- en: Note
  id: totrans-1079
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'When implementing the `IComparable` interfaces in a custom type, you can avoid
    running afoul of this rule by writing the first line of `CompareTo` as follows:'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 当实现自定义类型中的`IComparable`接口时，可以通过将`CompareTo`的第一行编写如下，避免违反此规则：
- en: '[PRE203]'
  id: totrans-1081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: After that, it can return what it likes, as long as it’s consistent!
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 在那之后，它可以返回它喜欢的结果，只要一致即可！
- en: < and >
  id: totrans-1083
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: < and >
- en: 'Some types define `<` and `>` operators; for instance:'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 有些类型定义了`<`和`>`运算符，例如：
- en: '[PRE204]'
  id: totrans-1085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: You can expect the `<` and `>` operators, when implemented, to be functionally
    consistent with the `IComparable` interfaces. This is standard practice across
    .NET.
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以期望实现了`IComparable`接口的类型，一旦实现了`<`和`>`运算符，它们在功能上与接口是一致的。这在.NET中是标准做法。
- en: It’s also standard practice to implement the `IComparable` interfaces whenever
    `<` and `>` are overloaded, although the reverse is not true. In fact, most .NET
    types that implement `IComparable` *do not* overload `<` and `>`. This differs
    from the situation with equality for which it’s normal to overload `==` when overriding
    `Equals`.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了`IComparable`接口是标准做法，只要重载了`<`和`>`运算符，尽管反之并非如此。事实上，大多数实现了`IComparable`接口的.NET类型*不*重载`<`和`>`。这与重载`==`以及覆盖`Equals`时的情况不同。
- en: 'Typically, `>` and `<` are overloaded only when:'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，只有在
- en: A type has a strong intrinsic concept of “greater than” and “less than” (versus
    `IComparable`’s broader concepts of “comes before” and “comes after”).
  id: totrans-1089
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类型具有强烈的内在“大于”和“小于”的概念（相对于`IComparable`更广泛的“在之前”和“在之后”的概念）。
- en: There is only one way *or context* in which to perform the comparison.
  id: totrans-1090
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有一种*或上下文*执行比较的方式。
- en: The result is invariant across cultures.
  id: totrans-1091
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果在所有文化中都是不变的。
- en: '`System.String` doesn’t satisfy the last point: the results of string comparisons
    can vary according to language. Hence, `string` doesn’t support the `>` and `<`
    operators:'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.String`不能满足最后一点：字符串比较的结果可以根据语言而变化。因此，`string`不支持`>`和`<`运算符：'
- en: '[PRE205]'
  id: totrans-1093
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: Implementing the IComparable Interfaces
  id: totrans-1094
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现IComparable接口
- en: 'In the following struct representing a musical note, we implement the `IComparable`
    interfaces as well as overloading the `<` and `>` operators. For completeness,
    we also override `Equals`/`GetHashCode` and overload `==` and `!=`:'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下表示音符的结构体中，我们实现了`IComparable`接口，并重载了`<`和`>`运算符。为了完整性，我们还重写了`Equals`/`GetHashCode`并重载了`==`和`!=`：
- en: '[PRE206]'
  id: totrans-1096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: Utility Classes
  id: totrans-1097
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实用类
- en: Console
  id: totrans-1098
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制台
- en: 'The static `Console` class handles standard input/output for console-based
    applications. In a command-line (console) application, the input comes from the
    keyboard via `Read`, `ReadKey`, and `ReadLine`, and the output goes to the text
    window via `Write` and `WriteLine`. You can control the window’s position and
    dimensions with the properties `WindowLeft`, `WindowTop`, `WindowHeight`, and
    `WindowWidth`. You can also change the `BackgroundColor` and `ForegroundColor`
    properties and manipulate the cursor with the `CursorLeft`, `CursorTop`, and `CursorSize`
    properties:'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 静态`Console`类用于处理控制台应用程序的标准输入/输出。在命令行（控制台）应用程序中，输入来自键盘，通过`Read`，`ReadKey`和`ReadLine`方法，输出则通过`Write`和`WriteLine`方法显示在文本窗口中。你可以使用`WindowLeft`，`WindowTop`，`WindowHeight`和`WindowWidth`属性控制窗口的位置和尺寸。还可以更改`BackgroundColor`和`ForegroundColor`属性，并使用`CursorLeft`，`CursorTop`和`CursorSize`属性操纵光标：
- en: '[PRE207]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: The `Write` and `WriteLine` methods are overloaded to accept a composite format
    string (see `String.Format` in [“String and Text Handling”](#string_and_text_handling)).
    However, neither method accepts a format provider, so you’re stuck with `CultureInfo​.Cur⁠rentCulture`.
    (The workaround, of course, is to explicitly call `string.Format`.)
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Write`和`WriteLine`方法支持复合格式字符串重载（参见[“字符串和文本处理”](#string_and_text_handling)中的`String.Format`）。但是，这两种方法均不接受格式提供程序，因此你将使用`CultureInfo.CurrentCulture`。（当然，解决方法是显式调用`string.Format`。）'
- en: The `Console.Out` property returns a `TextWriter`. Passing `Console.Out` to
    a method that expects a `TextWriter` is a useful way to get that method to write
    to the `Console` for diagnostic purposes.
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Console.Out`属性返回一个`TextWriter`。将`Console.Out`传递给期望`TextWriter`的方法是一个将该方法用于诊断目的写入`Console`的有用方式。'
- en: 'You can also redirect the `Console`’s input and output streams via the `SetIn`
    and `SetOut` methods:'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过`SetIn`和`SetOut`方法重定向`Console`的输入和输出流：
- en: '[PRE208]'
  id: totrans-1104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: In [Chapter 15](ch15.html#streams_and_isoliduso), we describe how streams and
    text writers work.
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第15章](ch15.html#streams_and_isoliduso)中，我们描述了流和文本写入器的工作方式。
- en: Note
  id: totrans-1106
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When running WPF or Windows Forms applications under Visual Studio, the `Console`’s
    output is automatically redirected to Visual Studio’s output window (in debug
    mode). This can make `Console.Write` useful for diagnostic purposes; although
    in most cases, the `Debug` and `Trace` classes in the `System.Diagnostics` namespace
    are more appropriate (see [Chapter 13](ch13.html#diagnostic)).
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio下运行WPF或Windows Forms应用程序时，`Console`的输出会自动重定向到Visual Studio的输出窗口（调试模式下）。这使得`Console.Write`在诊断目的上非常有用；尽管在大多数情况下，`System.Diagnostics`命名空间中的`Debug`和`Trace`类更为适合（参见[第13章](ch13.html#diagnostic)）。
- en: Environment
  id: totrans-1108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境
- en: 'The static `System.Environment` class provides a range of useful properties:'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 静态`System.Environment`类提供了一系列有用的属性：
- en: Files and folders
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 文件和文件夹
- en: '`CurrentDirectory`, `SystemDirectory`, `CommandLine`'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: '`CurrentDirectory`, `SystemDirectory`, `CommandLine`'
- en: Computer and operating system
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机和操作系统
- en: '`MachineName`, `ProcessorCount`, `OSVersion`, `NewLine`'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: '`MachineName`, `ProcessorCount`, `OSVersion`, `NewLine`'
- en: User logon
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 用户登录
- en: '`UserName`, `UserInteractive`, `UserDomainName`'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserName`, `UserInteractive`, `UserDomainName`'
- en: Diagnostics
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 诊断
- en: '`TickCount`, `StackTrace`, `WorkingSet`, `Version`'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: '`TickCount`, `StackTrace`, `WorkingSet`, `Version`'
- en: You can obtain additional folders by calling `GetFolderPath`; we describe this
    in [“File and Directory Operations”](ch15.html#file_and_directory_operations)
    in [Chapter 15](ch15.html#streams_and_isoliduso).
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用`GetFolderPath`获取额外的文件夹；我们在[“文件和目录操作”](ch15.html#file_and_directory_operations)中描述了这一点，位于[第15章](ch15.html#streams_and_isoliduso)。
- en: 'You can access OS environment variables (what you see when you type “set” at
    the command prompt) with the following three methods: `GetEnvironmentVariable`,
    `GetEnvironmentVariables`, and `SetEnvironmentVariable`.'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下三种方法访问操作系统环境变量（在命令提示符下键入“set”时看到的内容）：`GetEnvironmentVariable`，`GetEnvironmentVariables`和`SetEnvironmentVariable`。
- en: The `ExitCode` property lets you set the return code—for when your program is
    called from a command or batch file—and the `FailFast` method terminates a program
    immediately, without performing cleanup.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExitCode`属性允许你设置返回代码，用于从命令或批处理文件调用程序时；`FailFast`方法立即终止程序，无需执行清理操作。'
- en: The `Environment` class available to Windows Store apps offers just a limited
    number of members (`ProcessorCount`, `NewLine`, and `FailFast`).
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 可供Windows Store应用程序使用的`Environment`类只提供了有限数量的成员（`ProcessorCount`，`NewLine`和`FailFast`）。
- en: Process
  id: totrans-1122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程
- en: The `Process` class in `System.Diagnostics` allows you to launch a new process.
    (In [Chapter 13](ch13.html#diagnostic), we describe how you can also use it to
    interact with other processes running on the computer).
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Diagnostics` 中的 `Process` 类允许您启动新进程。（在 [第13章](ch13.html#diagnostic)
    中，我们描述了如何使用它与计算机上运行的其他进程进行交互）。'
- en: Warning
  id: totrans-1124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'For security reasons, the `Process` class is not available to Windows Store
    apps, and you cannot start arbitrary processes. Instead, you must use the `Windows.System.Launcher`
    class to “launch” a URI or file to which you have access; for example:'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 出于安全原因，`Process` 类不适用于 Windows Store 应用程序，您不能启动任意进程。相反，您必须使用 `Windows.System.Launcher`
    类来“启动”您可以访问的URI或文件；例如：
- en: '[PRE209]'
  id: totrans-1126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: This opens the URI or file, using whatever program is associated with the URI
    scheme or file extension. Your program must be in the foreground for this to work.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用与URI方案或文件扩展关联的任何程序打开URI或文件。要使此功能正常工作，您的程序必须处于前台。
- en: 'The static `Process.Start` method has several overloads; the simplest accepts
    a simple filename with optional arguments:'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的 `Process.Start` 方法有多个重载；最简单的接受一个简单的文件名及可选参数：
- en: '[PRE210]'
  id: totrans-1129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'The most flexible overload accepts a `ProcessStartInfo` instance. With this,
    you can capture and redirect the launched process’s input, output, and error output
    (if you leave `UseShellExecute` as `false`). The following captures the output
    of calling `ipconfig`:'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 最灵活的重载接受一个 `ProcessStartInfo` 实例。通过这个实例，您可以捕获和重定向启动进程的输入、输出和错误输出（如果将 `UseShellExecute`
    保持为 `false`）。以下是调用 `ipconfig` 并捕获输出的示例：
- en: '[PRE211]'
  id: totrans-1131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: If you don’t redirect output, `Process.Start` executes the program in parallel
    to the caller. If you want to wait for the new process to complete, you can call
    `WaitForExit` on the `Process` object, with an optional timeout.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不重定向输出，`Process.Start` 会并行执行程序。如果希望等待新进程完成，可以在 `Process` 对象上调用 `WaitForExit`，并可选择设置超时时间。
- en: Redirecting output and error streams
  id: totrans-1133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重定向输出和错误流
- en: With `UseShellExecute` false (the default in .NET), you can capture the standard
    input, output, and error streams and then write/read these streams via the `StandardInput`,
    `StandardOutput`, and `StandardError` properties.
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `UseShellExecute` 为 false（在 .NET 中的默认值），您可以捕获标准输入、输出和错误流，然后通过 `StandardInput`、`StandardOutput`
    和 `StandardError` 属性写入/读取这些流。
- en: 'A difficulty arises when you need to redirect both the standard output and
    standard error streams, in that you can’t usually know in which order to read
    data from each (because you don’t know in advance how the data will be interleaved).
    The solution is to read from both streams at once, which you can accomplish by
    reading from (at least) one of the streams *asynchronously*. Here’s how to do
    this:'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要重定向标准输出和标准错误流时会遇到困难，因为通常无法预知应按哪个顺序从每个流中读取数据（因为不知道数据将如何交错）。解决方案是同时从两个流中读取数据，您可以通过异步读取从（至少）其中一个流实现。以下是如何实现这一点的方式：
- en: Handle the `OutputDataReceived` and/or `ErrorDataReceived` events. These events
    fire when output/error data is received.
  id: totrans-1136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 `OutputDataReceived` 和/或 `ErrorDataReceived` 事件。这些事件在接收到输出/错误数据时触发。
- en: Call `BeginOutputReadLine` and/or `BeginErrorReadLine`. This enables the aforementioned
    events.
  id: totrans-1137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `BeginOutputReadLine` 和/或 `BeginErrorReadLine`。这样可以启用上述事件。
- en: 'The following method runs an executable while capturing both the output and
    error streams:'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法在运行可执行文件的同时捕获输出和错误流：
- en: '[PRE212]'
  id: totrans-1139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: UseShellExecute
  id: totrans-1140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UseShellExecute
- en: Warning
  id: totrans-1141
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: In .NET 5+ (and .NET Core), the default for `UseShellExecute` is false, whereas
    in .NET Framework, it was true. Because this is a breaking change, it’s worth
    checking all calls to `Process.Start` when porting code from .NET Framework.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 5+（以及 .NET Core）中，默认值为 `UseShellExecute` 为 false，而在 .NET Framework 中，默认值为
    true。因为这是一个破坏性变更，当从 .NET Framework 迁移代码时，值得检查对 `Process.Start` 的所有调用。
- en: 'The `UseShellExecute` flag changes how the CLR starts the process. With `UseShellExecute`
    true, you can do the following:'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseShellExecute` 标志会改变CLR如何启动进程。如果 `UseShellExecute` 为 true，您可以执行以下操作：'
- en: Specify a path to a file or document rather than an executable (resulting in
    the operating system opening the file or document with its associated application)
  id: totrans-1144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定文件或文档的路径，而不是可执行文件（导致操作系统使用其关联的应用程序打开文件或文档）
- en: Specify a URL (resulting in the operating system navigating to that URL in the
    default web browser)
  id: totrans-1145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定一个URL（导致操作系统在默认浏览器中导航到该URL）
- en: (Windows only) Specify a Verb (such as “runas”, to run the process with administrative
    elevation)
  id: totrans-1146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （仅限Windows）指定一个动词（例如“runas”，以使用管理员权限运行进程）
- en: The drawback is that you cannot redirect the input or output streams. Should
    you need to do so—while launching a file or document—a workaround is to set `UseShellExecute`
    to false and invoke the command-line process (cmd.exe) with the “/c” switch, as
    we did earlier when calling *ipconfig*.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点在于无法重定向输入或输出流。如果需要在启动文件或文档时这样做，一种解决方法是将 `UseShellExecute` 设置为 false 并使用 “/c”
    开关调用命令行进程（cmd.exe），就像我们在调用 *ipconfig* 时所做的那样。
- en: Under Windows, `UseShellExecute` instructs the CLR to use the Windows *ShellExecute*
    function instead of the *CreateProcess* function. Under Linux, `UseShellExecute`
    instructs the CLR to call *xdg-open*, *gnome-open*, or *kfmclient*.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 下，`UseShellExecute` 指示 CLR 使用 Windows 的 *ShellExecute* 函数而不是 *CreateProcess*
    函数。在 Linux 下，`UseShellExecute` 指示 CLR 调用 *xdg-open*、*gnome-open* 或 *kfmclient*。
- en: AppContext
  id: totrans-1149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AppContext
- en: 'The static `System.AppContext` class exposes two useful properties:'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的 `System.AppContext` 类公开了两个有用的属性：
- en: '`BaseDirectory` returns the folder in which the application started. This folder
    is important for resolving assemblies (finding and loading dependencies) and locating
    configuration files (such as *appsettings.json*).'
  id: totrans-1151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BaseDirectory` 返回应用程序启动的文件夹。此文件夹对于解析程序集（查找和加载依赖项）和定位配置文件（如 *appsettings.json*）至关重要。'
- en: '`TargetFrameworkName` tells you the name and version of the .NET runtime that
    the application targets (as specified in its *.runtimeconfig.json* file). This
    might be older than the runtime actually in use.'
  id: totrans-1152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TargetFrameworkName` 告诉您应用程序针对的 .NET 运行时的名称和版本（如其 *.runtimeconfig.json* 文件中指定）。这可能比实际使用的运行时旧。'
- en: In addition, the `AppContext` class manages a global string-keyed dictionary
    of Boolean values, intended to offer library writers a standard mechanism for
    allowing consumers to switch new features on or off. This untyped approach makes
    sense with experimental features that you want to keep undocumented to the majority
    of users.
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`AppContext` 类管理一个全局的字符串键字典，存储布尔值，旨在为库编写者提供一个标准机制，以允许消费者开启或关闭新功能。这种无类型的方法对于希望保持未公开文档的实验性功能是合理的。
- en: 'The consumer of a library requests that you enable a feature as follows:'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 某个库的消费者要求您按以下方式启用一个功能：
- en: '[PRE213]'
  id: totrans-1155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'Code within that library can then check for that switch as follows:'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后库内的代码可以按以下方式检查该开关：
- en: '[PRE214]'
  id: totrans-1157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '`TryGetSwitch` returns false if the switch is undefined; this lets you distinguish
    an undefined switch from one whose value is set to false, should this be necessary.'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开关未定义，`TryGetSwitch` 将返回 false；这使您能够区分未定义开关和其值设置为 false 的开关，如果有必要的话。
- en: Note
  id: totrans-1159
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Ironically, the design of `TryGetSwitch` illustrates how not to write APIs.
    The `out` parameter is unnecessary, and the method should instead return a nullable
    `bool` whose value is true, false, or null for undefined. This would then enable
    the following use:'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 具有讽刺意味的是，`TryGetSwitch` 的设计展示了如何不编写 API。`out` 参数是不必要的，方法应该返回一个可空的 `bool`，其值为
    true、false 或对未定义的值为 null。这将使以下用法成为可能：
- en: '[PRE215]'
  id: totrans-1161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
