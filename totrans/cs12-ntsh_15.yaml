- en: Chapter 15\. Streams and I/O
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter describes the fundamental types for input and output in .NET,
    with emphasis on the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The .NET stream architecture and how it provides a consistent programming interface
    for reading and writing across a variety of I/O types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes for manipulating files and directories on disk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specialized streams for compression, named pipes, and memory-mapped files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter concentrates on the types in the `System.IO` namespace, the home
    of lower-level I/O functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Stream Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The .NET stream architecture centers on three concepts: backing stores, decorators,
    and adapters, as shown in [Figure 15-1](#stream_architecture-id00092).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *backing store* is the endpoint that makes input and output useful, such
    as a file or network connection. Precisely, it is either or both of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A source from which bytes can be sequentially read
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A destination to which bytes can be sequentially written
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Stream architecture](assets/cn10_1501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-1\. Stream architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A backing store is of no use, though, unless exposed to the programmer. A `Stream`
    is the standard .NET class for this purpose; it exposes a standard set of methods
    for reading, writing, and positioning. Unlike an array, for which all the backing
    data exists in memory at once, a stream deals with data serially—either one byte
    at a time or in blocks of a manageable size. Hence, a stream can use a small,
    fixed amount of memory regardless of the size of its backing store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Streams fall into two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Backing store streams
  prefs: []
  type: TYPE_NORMAL
- en: These are hardwired to a particular type of backing store, such as `FileStream`
    or `NetworkStream`.
  prefs: []
  type: TYPE_NORMAL
- en: Decorator streams
  prefs: []
  type: TYPE_NORMAL
- en: These feed off another stream, transforming the data in some way, such as `DeflateStream`
    or `CryptoStream`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Decorator streams have the following architectural benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: They liberate backing store streams from needing to implement such features
    as compression and encryption themselves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streams don’t suffer a change of interface when decorated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You connect decorators at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can chain decorators together (e.g., a compressor followed by an encryptor).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both backing store and decorator streams deal exclusively in bytes. Although
    this is flexible and efficient, applications often work at higher levels such
    as text or XML. *Adapters* bridge this gap by wrapping a stream in a class with
    specialized methods typed to a particular format. For example, a text reader exposes
    a `ReadLine` method; an XML writer exposes a `WriteAttributes` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: An adapter wraps a stream, just like a decorator. Unlike a decorator, however,
    an adapter is not *itself* a stream; it typically hides the byte-oriented methods
    completely.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, backing store streams provide the raw data; decorator streams
    provide transparent binary transformations such as encryption; adapters offer
    typed methods for dealing in higher-level types such as strings and XML.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 15-1](#stream_architecture-id00092) illustrates their associations.
    To compose a chain, you simply pass one object into another’s constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The abstract `Stream` class is the base for all streams. It defines methods
    and properties for three fundamental operations: *reading*, *writing*, and *seeking*,
    as well as for administrative tasks such as closing, flushing, and configuring
    timeouts (see [Table 15-1](#stream_class_members)).'
  prefs: []
  type: TYPE_NORMAL
- en: Table 15-1\. Stream class members
  prefs: []
  type: TYPE_NORMAL
- en: '| Category | Members |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Reading | `public abstract bool CanRead { get; }` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `public abstract int Read (byte[] buffer, int offset, int count)` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `public virtual int ReadByte();` |'
  prefs: []
  type: TYPE_TB
- en: '| Writing | `public abstract bool CanWrite { get; }` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `public abstract void Write (byte[] buffer, int offset, int count);` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `public virtual void WriteByte (byte value);` |'
  prefs: []
  type: TYPE_TB
- en: '| Seeking | `public abstract bool CanSeek { get; }` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `public abstract long Position { get; set; }` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `public abstract void SetLength (long value);` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `public abstract long Length { get; }` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `public abstract long Seek (long offset, SeekOrigin origin);` |'
  prefs: []
  type: TYPE_TB
- en: '| Closing/flushing | `public virtual void Close();` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `public void Dispose();` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `public abstract void Flush();` |'
  prefs: []
  type: TYPE_TB
- en: '| Timeouts | `public virtual bool CanTimeout { get; }` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `public virtual int ReadTimeout { get; set; }` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `public virtual int WriteTimeout { get; set; }` |'
  prefs: []
  type: TYPE_TB
- en: '| Other | `public static readonly Stream Null; // "Null" stream` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `public static Stream Synchronized (Stream stream);` |'
  prefs: []
  type: TYPE_TB
- en: There are also asynchronous versions of the `Read` and `Write` methods, both
    of which return `Task`s and optionally accept a cancellation token, and overloads
    that work with `Span<T>` and `Memory<T>` types that we describe in [Chapter 23](ch23.html#spanless_thantgreater_than_and-id00089).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we use a file stream to read, write, and seek:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Reading or writing asynchronously is simply a question of calling `ReadAsync`/`WriteAsync`
    instead of `Read`/`Write`, and `await`ing the expression (we must also add the
    `async` keyword to the calling method, as we described in [Chapter 14](ch14.html#concurrency_and_asynchron)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The asynchronous methods make it easy to write responsive and scalable applications
    that work with potentially slow streams (particularly network streams), without
    tying up a thread.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For the sake of brevity, we’ll continue to use synchronous methods for most
    of the examples in this chapter; however, we recommend the asynchronous `Read`/`Write`
    operations as preferable in most scenarios involving network I/O.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and Writing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A stream can support reading, writing, or both. If `CanWrite` returns `false`,
    the stream is read-only; if `CanRead` returns `false`, the stream is write-only.
  prefs: []
  type: TYPE_NORMAL
- en: '`Read` receives a block of data from the stream into an array. It returns the
    number of bytes received, which is always either less than or equal to the `count`
    argument. If it’s less than `count`, it means that either the end of the stream
    has been reached or the stream is giving you the data in smaller chunks (as is
    often the case with network streams). In either case, the balance of bytes in
    the array will remain unwritten, their previous values preserved.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'With `Read`, you can be certain you’ve reached the end of the stream only when
    the method returns `0`. So, if you have a 1,000-byte stream, the following code
    might fail to read it all into memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `Read` method could read anywhere from 1 to 1,000 bytes, leaving the balance
    of the stream unread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the correct way to read a 1,000-byte stream via the `Read` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To make this easier, from .NET 7, the `Stream` class includes helper methods
    called `ReadExactly` and `ReadAtLeast` (and async versions of each). The following
    reads exactly 1,000 bytes from the stream (throwing an exception if the stream
    ends before then):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The last line is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The `BinaryReader` type provides another solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If the stream is less than 1,000 bytes long, the byte array returned reflects
    the actual stream size. If the stream is seekable, you can read its entire contents
    by replacing `1000` with `(int)s.Length`.
  prefs: []
  type: TYPE_NORMAL
- en: We describe the `BinaryReader` type further in [“Stream Adapters”](#stream_adapters).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ReadByte` method is simpler: it reads just a single byte, returning −1
    to indicate the end of the stream. `ReadByte` actually returns an `int` rather
    than a `byte` because the latter cannot return −1.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Write` and `WriteByte` methods send data to the stream. If they are unable
    to send the specified bytes, an exception is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the `Read` and `Write` methods, the `offset` argument refers to the index
    in the `buffer` array at which reading or writing begins, not the position within
    the stream.
  prefs: []
  type: TYPE_NORMAL
- en: Seeking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A stream is seekable if `CanSeek` returns `true`. With a seekable stream (such
    as a file stream), you can query or modify its `Length` (by calling `SetLength`)
    and at any time change the `Position` at which you’re reading or writing. The
    `Position` property is relative to the beginning of the stream; the `Seek` method,
    however, allows you to move relative to the current position or the end of the
    stream.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Changing the `Position` on a `FileStream` typically takes a few microseconds.
    If you’re doing this millions of times in a loop, the `MemoryMappedFile` class
    might be a better choice than a `FileStream` (see [“Memory-Mapped Files”](#memory_mapped_files)).
  prefs: []
  type: TYPE_NORMAL
- en: With a nonseekable stream (such as an encryption stream), the only way to determine
    its length is to read it completely through. Furthermore, if you need to reread
    a previous section, you must close the stream and start afresh with a new one.
  prefs: []
  type: TYPE_NORMAL
- en: Closing and Flushing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Streams must be disposed after use to release underlying resources such as
    file and socket handles. A simple way to guarantee this is by instantiating streams
    within `using` blocks. In general, streams follow standard disposal semantics:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Dispose` and `Close` are identical in function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disposing or closing a stream repeatedly causes no error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closing a decorator stream closes both the decorator and its backing store stream.
    With a chain of decorators, closing the outermost decorator (at the head of the
    chain) closes the whole lot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some streams internally buffer data to and from the backing store to lessen
    round-tripping and so improve performance (file streams are a good example of
    this). This means that data you write to a stream might not hit the backing store
    immediately; it can be delayed as the buffer fills up. The `Flush` method forces
    any internally buffered data to be written immediately. `Flush` is called automatically
    when a stream is closed, so you never need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Timeouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A stream supports read and write timeouts if `CanTimeout` returns `true`. Network
    streams support timeouts; file and memory streams do not. For streams that support
    timeouts, the `ReadTimeout` and `WriteTimeout` properties determine the desired
    timeout in milliseconds, where `0` means no timeout. The `Read` and `Write` methods
    indicate that a timeout has occurred by throwing an exception.
  prefs: []
  type: TYPE_NORMAL
- en: The asynchronous `ReadAsync`/`WriteAsync` methods do not support timeouts; instead
    you can pass a cancellation token into these methods.
  prefs: []
  type: TYPE_NORMAL
- en: Thread Safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a rule, streams are not thread-safe, meaning that two threads cannot concurrently
    read or write to the same stream without possible error. The `Stream` class offers
    a simple workaround via the static `Synchronized` method. This method accepts
    a stream of any type and returns a thread-safe wrapper. The wrapper works by obtaining
    an exclusive lock around each read, write, or seek, ensuring that only one thread
    can perform such an operation at a time. In practice, this allows multiple threads
    to simultaneously append data to the same stream—other kinds of activities (such
    as concurrent reading) require additional locking to ensure that each thread accesses
    the desired portion of the stream. We discuss thread safety fully in [Chapter 21](ch21.html#advanced_threadin).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: From .NET 6, you can use the `RandomAccess` class for performant thread-safe
    file I/O operations. `RandomAccess` also lets you pass in multiple buffers to
    improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: Backing Store Streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Figure 15-2](#backing_store_streams-id00053) shows the key backing store streams
    provided by .NET. A “null stream” is also available via the `Stream`’s static
    `Null` field. Null streams can be useful when writing unit tests.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Backing store streams](assets/cn10_1502.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-2\. Backing store streams
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the following sections, we describe `FileStream` and `MemoryStream`; in the
    final section in this chapter, we describe `IsolatedStorageStream`. In [Chapter 16](ch16.html#networking-id00041),
    we cover `NetworkStream`.
  prefs: []
  type: TYPE_NORMAL
- en: FileStream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier in this section, we demonstrated the basic use of a `FileStream` to
    read and write bytes of data. Let’s now examine the special features of this class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you’re still using Universal Windows Platform [UWP], you can also do file
    I/O with the types in `Windows.Storage`. We describe this in the online supplement
    at [*http://www.albahari.com/nutshell*](http://www.albahari.com/nutshell).
  prefs: []
  type: TYPE_NORMAL
- en: Constructing a FileStream
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The simplest way to instantiate a `FileStream` is to use one of the following
    static façade methods on the `File` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`OpenWrite` and `Create` differ in behavior if the file already exists. `Create`
    truncates any existing content; `OpenWrite` leaves existing content intact with
    the stream positioned at zero. If you write fewer bytes than were previously in
    the file, `OpenWrite` leaves you with a mixture of old and new content.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also directly instantiate a `FileStream`. Its constructors provide
    access to every feature, allowing you to specify a filename or low-level file
    handle, file creation and access modes, and options for sharing, buffering, and
    security. The following opens an existing file for read/write access without overwriting
    it (the `using` keyword ensures it is disposed when `fs` exits scope):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We look closer at `FileMode` shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying a filename
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A filename can be either absolute (e.g., *c:\temp\test.txt—or in Unix, /tmp/test.txt*)
    or relative to the current directory (e.g., *test.txt* or *temp\test.txt*). You
    can access or change the current directory via the static `Environment.CurrentDirectory`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When a program starts, the current directory might or might not coincide with
    that of the program’s executable. For this reason, you should never rely on the
    current directory for locating additional runtime files packaged along with your
    executable.
  prefs: []
  type: TYPE_NORMAL
- en: '`AppDomain.CurrentDomain.BaseDirectory` returns the *application base directory*,
    which in normal cases is the folder containing the program’s executable. To specify
    a filename relative to this directory, you can call `Path.Combine`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can read and write across a Windows network via a Universal Naming Convention
    (UNC) path, such as *\\JoesPC\PicShare\pic.jpg* or *\\10.1.1.2\PicShare\pic.jpg*.
    (To access a Windows file share from macOS or Unix, mount it to your filesystem
    following instructions specific to your OS, and then open it using an ordinary
    path from C#).
  prefs: []
  type: TYPE_NORMAL
- en: Specifying a FileMode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All of `FileStream`’s constructors that accept a filename also require a `FileMode`
    enum argument. [Figure 15-3](#choosing_a_filemode) shows how to choose a `FileMode`,
    and the choices yield results akin to calling a static method on the `File` class.
  prefs: []
  type: TYPE_NORMAL
- en: '![Choosing a FileMode](assets/cn10_1503.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-3\. Choosing a FileMode
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`File.Create` and `FileMode.Create` will throw an exception if used on hidden
    files. To overwrite a hidden file, you must delete and re-create it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Constructing a `FileStream` with just a filename and `FileMode` gives you (with
    just one exception) a readable writable stream. You can request a downgrade if
    you also supply a `FileAccess` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following returns a read-only stream, equivalent to calling `File.OpenRead`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`FileMode.Append` is the odd one out: with this mode, you get a *write-only*
    stream. To append with read-write support, you must instead use `FileMode.Open`
    or `FileMode.OpenOrCreate` and then seek the end of the stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Advanced FileStream features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are other optional arguments you can include when constructing a `FileStream`:'
  prefs: []
  type: TYPE_NORMAL
- en: A `FileShare` enum describing how much access to grant other processes wanting
    to dip into the same file before you’ve finished (`None`, `Read` [default], `ReadWrite`,
    or `Write`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The size, in bytes, of the internal buffer (default is currently 4 KB).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A flag indicating whether to defer to the operating system for asynchronous
    I/O.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `FileOptions` flags enum for requesting operating system encryption (`Encrypted`),
    automatic deletion upon closure for temporary files (`DeleteOnClose`), and optimization
    hints (`RandomAccess` and `SequentialScan`). There is also a `WriteThrough` flag
    that requests that the OS disable write-behind caching; this is for transactional
    files or logs. Flags not supported by the underlying OS are silently ignored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Opening a file with `FileShare.ReadWrite` allows other processes or users to
    simultaneously read and write to the same file. To avoid chaos, you can all agree
    to lock specified portions of the file before reading or writing, using these
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`Lock` throws an exception if part or all of the requested file section has
    already been locked.'
  prefs: []
  type: TYPE_NORMAL
- en: MemoryStream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`MemoryStream` uses an array as a backing store. This partly defeats the purpose
    of having a stream because the entire backing store must reside in memory at once.
    `MemoryStream` is still useful when you need random access to a nonseekable stream.
    If you know the source stream will be of a manageable size, you can copy it into
    a `MemoryStream` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can convert a `MemoryStream` to a byte array by calling `ToArray`. The `GetBuffer`
    method does the same job more efficiently by returning a direct reference to the
    underlying storage array; unfortunately, this array is usually longer than the
    stream’s real length.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Closing and flushing a `MemoryStream` is optional. If you close a `MemoryStream`,
    you can no longer read or write to it, but you are still permitted to call `ToArray`
    to obtain the underlying data. `Flush` does absolutely nothing on a memory stream.
  prefs: []
  type: TYPE_NORMAL
- en: You can find further `MemoryStream` examples in [“Compression Streams”](#compression_streams)
    and in [“Overview”](ch20.html#overview-id00067).
  prefs: []
  type: TYPE_NORMAL
- en: PipeStream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`PipeStream` provides a simple means by which one process can communicate with
    another through the operating system’s *pipes* protocol. There are two kinds of
    pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous pipe (faster)
  prefs: []
  type: TYPE_NORMAL
- en: Allows one-way communication between a parent and child process on the same
    computer
  prefs: []
  type: TYPE_NORMAL
- en: Named pipe (more flexible)
  prefs: []
  type: TYPE_NORMAL
- en: Allows two-way communication between arbitrary processes on the same computer
    or different computers across a network
  prefs: []
  type: TYPE_NORMAL
- en: 'A pipe is good for interprocess communication (IPC) on a single computer: it
    doesn’t rely on a network transport, which means no network protocol overhead,
    and it has no issues with firewalls.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Pipes are stream-based, so one process waits to receive a series of bytes while
    another process sends them. An alternative is for processes to communicate via
    a block of shared memory; we describe how to do this in [“Memory-Mapped Files”](#memory_mapped_files).
  prefs: []
  type: TYPE_NORMAL
- en: '`PipeStream` is an abstract class with four concrete subtypes. Two are used
    for anonymous pipes and the other two for named pipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous pipes
  prefs: []
  type: TYPE_NORMAL
- en: '`AnonymousPipeServerStream` and `AnonymousPipeClientStream`'
  prefs: []
  type: TYPE_NORMAL
- en: Named pipes
  prefs: []
  type: TYPE_NORMAL
- en: '`NamedPipeServerStream` and `NamedPipeClientStream`'
  prefs: []
  type: TYPE_NORMAL
- en: Named pipes are simpler to use, so we describe them first.
  prefs: []
  type: TYPE_NORMAL
- en: Named pipes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With named pipes, the parties communicate through a pipe of the same name.
    The protocol defines two distinct roles: the client and server. Communication
    happens between the client and server as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The server instantiates a `NamedPipeServerStream` and then calls `WaitForConnection`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client instantiates a `NamedPipeClientStream` and then calls `Connect` (with
    an optional timeout).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two parties then read and write the streams to communicate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates a server that sends a single byte (100)
    and then waits to receive a single byte:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the corresponding client code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Named pipe streams are bidirectional by default, so either party can read or
    write their stream. This means that the client and server must agree on some protocol
    to coordinate their actions, so both parties don’t end up sending or receiving
    at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'There also needs to be agreement on the length of each transmission. Our example
    was trivial in this regard, because we bounced just a single byte in each direction.
    To help with messages longer than one byte, pipes provide a *message* transmission
    mode (Windows only). If this is enabled, a party calling `Read` can know when
    a message is complete by checking the `IsMessageComplete` property. To demonstrate,
    we begin by writing a helper method that reads a whole message from a message-enabled
    `PipeStream`—in other words, reads until `IsMessageComplete` is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: (To make this asynchronous, replace “`s.Read`” with “`await s.ReadAsync`”.)
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You cannot determine whether a `PipeStream` has finished reading a message simply
    by waiting for `Read` to return 0\. This is because, unlike most other stream
    types, pipe streams and network streams have no definite end. Instead, they temporarily
    “dry up” between message transmissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can activate message transmission mode. On the server, this is done
    by specifying `PipeTransmissionMode.Message` when constructing the stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'On the client, we activate message transmission mode by setting `ReadMode`
    after calling `Connect`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Message mode is supported only on Windows. Other platforms throw `PlatformNotSupportedException`.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous pipes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An anonymous pipe provides a one-way communication stream between a parent and
    child process. Instead of using a system-wide name, anonymous pipes tune in through
    a private handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with named pipes, there are distinct client and server roles. The system
    of communication is a little different, however, and proceeds as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The server instantiates an `AnonymousPipeServerStream`, committing to a `PipeDirection`
    of `In` or `Out`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server calls `GetClientHandleAsString` to obtain an identifier for the pipe,
    which it then passes to the client (typically as an argument when starting the
    child process).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The child process instantiates an `AnonymousPipeClientStream`, specifying the
    opposite `PipeDirection`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server releases the local handle that was generated in Step 2, by calling
    `DisposeLocalCopyOfClientHandle`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The parent and child processes communicate by reading/writing the stream.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Because anonymous pipes are unidirectional, a server must create two pipes
    for bidirectional communication. The following Console program creates two pipes
    (input and output) and then starts up a child process. It then sends a single
    byte to the child process, and receives a single byte in return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As with named pipes, the client and server must coordinate their sending and
    receiving and agree on the length of each transmission. Anonymous pipes don’t,
    unfortunately, support message mode, so you must implement your own protocol for
    message length agreement. One solution is to send, in the first four bytes of
    each transmission, an integer value defining the length of the message to follow.
    The `BitConverter` class provides methods for converting between an integer and
    an array of four bytes.
  prefs: []
  type: TYPE_NORMAL
- en: BufferedStream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`BufferedStream` decorates, or wraps, another stream with buffering capability,
    and it is one of a number of decorator stream types in .NET, all of which are
    illustrated in [Figure 15-4](#decorator_streams).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Decorator streams](assets/cn10_1504.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-4\. Decorator streams
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Buffering improves performance by reducing round trips to the backing store.
    Here’s how we wrap a `FileStream` in a 20 KB `BufferedStream`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the underlying stream advances 20,000 bytes after reading just
    one byte, thanks to the read-ahead buffering. We could call `ReadByte` another
    19,999 times before the `FileStream` would be hit again.
  prefs: []
  type: TYPE_NORMAL
- en: Coupling a `BufferedStream` to a `FileStream`, as in this example, is of limited
    value because `FileStream` already has built-in buffering. Its only use might
    be in enlarging the buffer on an already constructed `FileStream`.
  prefs: []
  type: TYPE_NORMAL
- en: Closing a `BufferedStream` automatically closes the underlying backing store
    stream.
  prefs: []
  type: TYPE_NORMAL
- en: Stream Adapters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `Stream` deals only in bytes; to read or write data types such as strings,
    integers, or XML elements, you must plug in an adapter. Here’s what .NET provides:'
  prefs: []
  type: TYPE_NORMAL
- en: Text adapters (for string and character data)
  prefs: []
  type: TYPE_NORMAL
- en: '`TextReader`, `TextWriter`'
  prefs: []
  type: TYPE_NORMAL
- en: '`StreamReader`, `StreamWriter`'
  prefs: []
  type: TYPE_NORMAL
- en: '`StringReader`, `StringWriter`'
  prefs: []
  type: TYPE_NORMAL
- en: Binary adapters (for primitive types such as `int`, `bool`, `string`, and `float`)
  prefs: []
  type: TYPE_NORMAL
- en: '`BinaryReader`, `BinaryWriter`'
  prefs: []
  type: TYPE_NORMAL
- en: XML adapters (covered in [Chapter 11](ch11.html#other_xml_and_json_technologies))
  prefs: []
  type: TYPE_NORMAL
- en: '`XmlReader`, `XmlWriter`'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 15-5](#readers_and_writers) illustrates the relationships between these
    types.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Readers and writers](assets/cn10_1505.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-5\. Readers and writers
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Text Adapters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`TextReader` and `TextWriter` are the abstract base classes for adapters that
    deal exclusively with characters and strings. Each has two general-purpose implementations
    in .NET:'
  prefs: []
  type: TYPE_NORMAL
- en: '`StreamReader`/`StreamWriter`'
  prefs: []
  type: TYPE_NORMAL
- en: Uses a `Stream` for its raw data store, translating the stream’s bytes into
    characters or strings
  prefs: []
  type: TYPE_NORMAL
- en: '`StringReader`/`StringWriter`'
  prefs: []
  type: TYPE_NORMAL
- en: Implements `TextReader`/`TextWriter` using in-memory strings
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 15-2](#textreader_members) lists `TextReader`’s members by category.
    `Peek` returns the next character in the stream without advancing the position.
    Both `Peek` and the zero-argument version of `Read` return −1 if at the end of
    the stream; otherwise, they return an integer that can be cast directly to a `char`.
    The overload of `Read` that accepts a `char[]` buffer is identical in functionality
    to the `ReadBlock` method. `ReadLine` reads until reaching either a CR (character
    13) or LF (character 10), or a CR+LF pair in sequence. It then returns a string,
    discarding the CR/LF characters.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 15-2\. TextReader members
  prefs: []
  type: TYPE_NORMAL
- en: '| Category | Members |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Reading one char | `public virtual int Peek(); // Cast the result to a char`
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | `public virtual int Read(); // Cast the result to a char` |'
  prefs: []
  type: TYPE_TB
- en: '| Reading many chars | `public virtual int Read (char[] buffer, int index,
    int count);` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `public virtual int ReadBlock (char[] buffer, int index, int count);`
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | `public virtual string ReadLine();` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `public virtual string ReadToEnd();` |'
  prefs: []
  type: TYPE_TB
- en: '| Closing | `public virtual void Close();` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `public void Dispose(); // Same as Close` |'
  prefs: []
  type: TYPE_TB
- en: '| Other | `public static readonly TextReader Null;` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `public static TextReader Synchronized (TextReader reader);` |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`Environment.NewLine` returns the new-line sequence for the current OS.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On Windows, this is `"\r\n"` (think “ReturN”) and is loosely modeled on a mechanical
    typewriter: a CR (character 13) followed by an LF (character 10). Reverse the
    order and you’ll get either two new lines or none!'
  prefs: []
  type: TYPE_NORMAL
- en: On Unix and macOS, it’s simply `"\n"`.
  prefs: []
  type: TYPE_NORMAL
- en: '`TextWriter` has analogous methods for writing, as shown in [Table 15-3](#textwriter_members).
    The `Write` and `WriteLine` methods are additionally overloaded to accept every
    primitive type, plus the `object` type. These methods simply call the `ToString`
    method on whatever is passed in (optionally through an `IFormatProvider` specified
    either when calling the method or when constructing the `TextWriter`).'
  prefs: []
  type: TYPE_NORMAL
- en: Table 15-3\. TextWriter members
  prefs: []
  type: TYPE_NORMAL
- en: '| Category | Members |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Writing one char | `public virtual void Write (char value);` |'
  prefs: []
  type: TYPE_TB
- en: '| Writing many chars | `public virtual void Write (string value);` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `public virtual void Write (char[] buffer, int index, int count);` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `public virtual void Write (string format, params object[] arg);` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `public virtual void WriteLine (string value);` |'
  prefs: []
  type: TYPE_TB
- en: '| Closing and flushing | `public virtual void Close();` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `public void Dispose(); // Same as Close` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `public virtual void Flush();` |'
  prefs: []
  type: TYPE_TB
- en: '| Formatting and encoding | `public virtual IFormatProvider FormatProvider
    { get; }` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `public virtual string NewLine { get; set; }` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `public abstract Encoding Encoding { get; }` |'
  prefs: []
  type: TYPE_TB
- en: '| Other | `public static readonly TextWriter Null;` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `public static TextWriter Synchronized (TextWriter writer);` |'
  prefs: []
  type: TYPE_TB
- en: '`WriteLine` simply appends the given text with `Environment.NewLine`. You can
    change this via the `NewLine` property (this can be useful for interoperability
    with Unix file formats).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As with `Stream`, `TextReader` and `TextWriter` offer task-based asynchronous
    versions of their read/write methods.
  prefs: []
  type: TYPE_NORMAL
- en: StreamReader and StreamWriter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the following example, a `StreamWriter` writes two lines of text to a file,
    and then a `StreamReader` reads the file back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Because text adapters are so often coupled with files, the `File` class provides
    the static methods `CreateText`, `AppendText`, and `OpenText` to shortcut the
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This also illustrates how to test for the end of a file (viz. `reader.Peek()`).
    Another option is to read until `reader.ReadLine` returns null.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also read and write other types such as integers, but because `TextWriter`
    invokes `ToString` on your type, you must parse a string when reading it back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Character encodings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`TextReader` and `TextWriter` are by themselves just abstract classes with
    no connection to a stream or backing store. The `StreamReader` and `StreamWriter`
    types, however, are connected to an underlying byte-oriented stream, so they must
    convert between characters and bytes. They do so through an `Encoding` class from
    the `System.Text` namespace, which you choose when constructing the `StreamReader`
    or `StreamWriter`. If you choose none, the default UTF-8 encoding is used.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you explicitly specify an encoding, `StreamWriter` will, by default, write
    a prefix to the start of the stream to identity the encoding. This is usually
    undesirable, and you can prevent it by constructing the encoding as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The second argument tells the `StreamWriter` (or `StreamReader`) to throw an
    exception if it encounters bytes that do not have a valid string translation for
    their encoding, which matches its default behavior if you do not specify an encoding.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest of the encodings is ASCII because each character is represented
    by one byte. The ASCII encoding maps the first 127 characters of the Unicode set
    into its single byte, covering what you see on a US-style keyboard. Most other
    characters, including specialized symbols and non-English characters, cannot be
    represented and are converted to the □ character. The default UTF-8 encoding can
    map all allocated Unicode characters, but it is more complex. The first 127 characters
    encode to a single byte, for ASCII compatibility; the remaining characters encode
    to a variable number of bytes (most commonly two or three). Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The word “but” is followed not by a stock-standard hyphen but by the longer
    em dash (—) character, U+2014\. This is the one that won’t get you into trouble
    with your book editor! Let’s examine the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the em dash is outside the first 127 characters of the Unicode set,
    it requires more than a single byte to encode in UTF-8 (in this case, three).
    UTF-8 is efficient with the Western alphabet as most popular characters consume
    just one byte. It also downgrades easily to ASCII simply by ignoring all bytes
    above 127\. Its disadvantage is that seeking within a stream is troublesome because
    a character’s position does not correspond to its byte position in the stream.
    An alternative is UTF-16 (labeled just “Unicode” in the `Encoding` class). Here’s
    how we write the same string with UTF-16:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Technically, UTF-16 uses either two or four bytes per character (there are close
    to a million Unicode characters allocated or reserved, so two bytes is not always
    enough). However, because the C# `char` type is itself only 16 bits wide, a UTF-16
    encoding will always use exactly two bytes per .NET `char`. This makes it easy
    to jump to a particular character index within a stream.
  prefs: []
  type: TYPE_NORMAL
- en: UTF-16 uses a two-byte prefix to identify whether the byte pairs are written
    in a “little-endian” or “big-endian” order (the least significant byte first or
    the most significant byte first). The default little-endian order is standard
    for Windows-based systems.
  prefs: []
  type: TYPE_NORMAL
- en: StringReader and StringWriter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `StringReader` and `StringWriter` adapters don’t wrap a stream at all;
    instead, they use a string or `StringBuilder` as the underlying data source. This
    means no byte translation is required—in fact, the classes do nothing you couldn’t
    easily achieve with a string or `StringBuilder` coupled with an index variable.
    Their advantage, though, is that they share a base class with `StreamReader`/`StreamWriter`.
    For instance, suppose that we have a string containing XML and want to parse it
    with an `XmlReader`. The `XmlReader.Create` method accepts one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A `URI`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Stream`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `TextReader`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, how do we XML-parse our string? Because `StringReader` is a subclass of
    `TextReader`, we’re in luck. We can instantiate and pass in a `StringReader` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Binary Adapters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`BinaryReader` and `BinaryWriter` read and write native data types: `bool`,
    `byte`, `char`, `decimal`, `float`, `double`, `short`, `int`, `long`, `sbyte`,
    `ushort`, `uint`, and `ulong`, as well as `string`s and arrays of the primitive
    data types.'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike `StreamReader` and `StreamWriter`, binary adapters store primitive data
    types efficiently because they are represented in memory. So, an `int` uses four
    bytes; a `double` uses eight bytes. Strings are written through a text encoding
    (as with `StreamReader` and `StreamWriter`) but are length-prefixed in order to
    make it possible to read back a series of strings without needing special delimiters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we have a simple type, defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add the following methods to `Person` to save/load its data to/from
    a stream using binary adapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`BinaryReader` can also read into byte arrays. The following reads the entire
    contents of a seekable stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is more convenient than reading directly from a stream because it doesn’t
    require a loop to ensure that all data has been read.
  prefs: []
  type: TYPE_NORMAL
- en: Closing and Disposing Stream Adapters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You have four choices in tearing down stream adapters:'
  prefs: []
  type: TYPE_NORMAL
- en: Close the adapter only
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the adapter and then close the stream
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (For writers) Flush the adapter and then close the stream
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (For readers) Close just the stream
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`Close` and `Dispose` are synonymous with adapters, just as they are with streams.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Options 1 and 2 are semantically identical because closing an adapter automatically
    closes the underlying stream. Whenever you nest `using` statements, you’re implicitly
    taking option 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Because the nest disposes from the inside out, the adapter is first closed,
    and then the stream. Furthermore, if an exception is thrown within the adapter’s
    constructor, the stream still closes. It’s hard to go wrong with nested `using`
    statements!
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Never close a stream before closing or flushing its writer—you’ll amputate any
    data that’s buffered in the adapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Options 3 and 4 work because adapters are in the unusual category of *optionally*
    disposable objects. An example of when you might choose not to dispose an adapter
    is when you’ve finished with the adapter but you want to leave the underlying
    stream open for subsequent use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here, we write to a file, reposition the stream, and then read the first byte
    before closing the stream. If we disposed the `StreamWriter`, it would also close
    the underlying `FileStream`, causing the subsequent read to fail. The proviso
    is that we call `Flush` to ensure that the `StreamWriter`’s buffer is written
    to the underlying stream.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Stream adapters—with their optional disposal semantics—do not implement the
    extended disposal pattern where the finalizer calls `Dispose`. This allows an
    abandoned adapter to evade automatic disposal when the garbage collector catches
    up with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s also a constructor on `StreamReader`/`StreamWriter` that instructs
    it to keep the stream open after disposal. Consequently, we can rewrite the preceding
    example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Compression Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Two general-purpose compression streams are provided in the `System.IO.Compression`
    namespace: `DeflateStream` and `GZipStream`. Both use a popular compression algorithm
    similar to that of the ZIP format. They differ in that `GZipStream` writes an
    additional protocol at the start and end—including a CRC to detect errors. `GZipStream`
    also conforms to a standard recognized by other software.'
  prefs: []
  type: TYPE_NORMAL
- en: .NET also includes `BrotliStream`, which implements the *Brotli* compression
    algorithm. `BrotliStream` is more than 10 times slower than `DeflateStream` and
    `GZipStream` but achieves a better compression ratio. (The performance hit applies
    only to compression—decompression performs very well.)
  prefs: []
  type: TYPE_NORMAL
- en: 'All three streams allow reading and writing, with the following provisos:'
  prefs: []
  type: TYPE_NORMAL
- en: You always *write* to the stream when compressing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You always *read* from the stream when decompressing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DeflateStream`, `GZipStream`, and `BrotliStream` are decorators; they compress
    or decompress data from another stream that you supply in construction. In the
    following example, we compress and decompress a series of bytes using a `FileStream`
    as the backing store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'With `DeflateStream`, the compressed file is 102 bytes: slightly larger than
    the original (`BrotliStream` would compress it to 73 bytes). Compression works
    poorly with “dense,” nonrepetitive binary data (and worst of all with encrypted
    data, which lacks regularity by design). It works well with most text files; in
    the next example, we compress and decompress a text stream composed of 1,000 words
    chosen randomly from a small sentence with the *Brotli* algorithm. This also demonstrates
    chaining a backing store stream, a decorator stream, an adapter (as depicted at
    the start of the chapter in [Figure 15-1](#stream_architecture-id00092)), and
    the use of asynchronous methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `BrotliStream` compresses efficiently to 808 bytes—less than one
    byte per word. (For comparison, `DeflateStream` compresses the same data to 885
    bytes.)
  prefs: []
  type: TYPE_NORMAL
- en: Compressing in Memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you need to compress entirely in memory. Here’s how to use a `MemoryStream`
    for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `using` statement around the `DeflateStream` closes it in a textbook fashion,
    flushing any unwritten buffers in the process. This also closes the `MemoryStream`
    it wraps—meaning we must then call `ToArray` to extract its data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an alternative that avoids closing the `MemoryStream` and uses the asynchronous
    read and write methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The additional flag sent to `DeflateStream`’s constructor instructs it to not
    follow the usual protocol of taking the underlying stream with it in disposal.
    In other words, the `MemoryStream` is left open, allowing us to position it back
    to zero and reread it.
  prefs: []
  type: TYPE_NORMAL
- en: Unix gzip File Compression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`GZipStream`’s compression algorithm is popular on Unix systems as a file compression
    format. Each source file is compressed into a separate target file with a *.gz*
    extension.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following methods do the work of the Unix command-line gzip and gunzip
    utilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The following compresses a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'And the following decompresses it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Working with ZIP Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ZipArchive` and `ZipFile` classes in `System.IO.Compression` support the
    ZIP compression format. The advantage of the ZIP format over `DeflateStream` and
    `GZipStream` is that it also acts as a container for multiple files and is compatible
    with ZIP files created with Windows Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: '`ZipArchive` works with streams, whereas `ZipFile` addresses the more common
    scenario of working with files. (`ZipFile` is a static helper class for `ZipArchive`.)'
  prefs: []
  type: TYPE_NORMAL
- en: '`ZipFile`’s `CreateFromDirectory` method adds all the files in a specified
    directory into a ZIP file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '`ExtractToDirectory` does the opposite and extracts a ZIP file to a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: (From .NET 8, you can also specify a `Stream` instead of a zip file path.)
  prefs: []
  type: TYPE_NORMAL
- en: When compressing, you can specify whether to optimize for file size or speed
    as well as whether to include the name of the source directory in the archive.
    Enabling the latter option in our example would create a subdirectory in the archive
    called *MyFolder* into which the compressed files would go.
  prefs: []
  type: TYPE_NORMAL
- en: '`ZipFile` has an `Open` method for reading/writing individual entries. This
    returns a `ZipArchive` object (which you can also obtain by instantiating `ZipArchive`
    with a `Stream` object). When calling `Open`, you must specify a filename and
    indicate whether you want to `Read`, `Create`, or `Update` the archive. You can
    then enumerate existing entries via the `Entries` property or find a particular
    file by calling `GetEntry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '`ZipArchiveEntry` also has a `Delete` method, an `ExtractToFile` method (this
    is actually an extension method in the `ZipFileExtensions` class), and an `Open`
    method that returns a readable/writable `Stream`. You can create new entries by
    calling `CreateEntry` (or the `CreateEntryFromFile` extension method) on the `ZipArchive`.
    The following creates the archive *d:\zz.zip*, to which it adds *foo.dll*, under
    a directory structure within the archive called *bin\X86*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: You could do the same thing entirely in memory by constructing `ZipArchive`
    with a `MemoryStream`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Tar Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The types in the `System.Formats.Tar` namespace (from .NET 7) support the *.tar*
    archive format, popular on Unix systems for bundling multiple files. To create
    a *.tar* file (a *tarball*), call `TarFile.CreateFromDirectory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: (The third argument indicates whether to include the base directory name in
    the archive entries.)
  prefs: []
  type: TYPE_NORMAL
- en: 'To extract a tarball, call `TarFile.ExtractToDirectory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: (The third argument indicates whether to overwrite existing files.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Both of these methods let you specify a `Stream` instead of a *.tar* filepath.
    In the following example, we write the tarball to a memory stream, and then use
    `GZipStream` to compress that stream to a *.tar.gz* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '(Compressing a *.tar* into a *.tar.gz* is useful because the *.tar* format
    does not itself incorporate compression, unlike the *.zip* format.) We can extract
    the *.tar.gz* file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also access the API at a more granular level with the `TarReader` and
    `TarWriter` classes. The following illustrates the use of `TarReader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: File and Directory Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `System.IO` namespace provides a set of types for performing “utility”
    file and directory operations, such as copying and moving, creating directories,
    and setting file attributes and permissions. For most features, you can choose
    between either of two classes, one offering static methods and the other instance
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Static classes
  prefs: []
  type: TYPE_NORMAL
- en: '`File` and `Directory`'
  prefs: []
  type: TYPE_NORMAL
- en: Instance-method classes (constructed with a file or directory name)
  prefs: []
  type: TYPE_NORMAL
- en: '`FileInfo` and `DirectoryInfo`'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, there’s a static class called `Path`. This does nothing to files
    or directories; instead, it provides string manipulation methods for filenames
    and directory paths. `Path` also assists with temporary files.
  prefs: []
  type: TYPE_NORMAL
- en: The File Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`File` is a static class whose methods all accept a filename. The filename
    can be either relative to the current directory or fully qualified with a directory.
    Here are its methods (all `public` and `static`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '`Move` throws an exception if the destination file already exists; `Replace`
    does not. Both methods allow the file to be renamed as well as moved to another
    directory.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Delete` throws an `UnauthorizedAccessException` if the file is marked read-only;
    you can tell this in advance by calling `GetAttributes`. It also throws that exception
    if the OS denies delete permission for that file to your process. Here are all
    the members of the `FileAttribute` enum that `GetAttributes` returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Members in this enum are combinable. Here’s how to toggle a single file attribute
    without upsetting the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`FileInfo` offers an easier way to change a file’s read-only flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Compression and encryption attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This feature is Windows-only and requires the NuGet package `System.Management`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Compressed` and `Encrypted` file attributes correspond to the compression
    and encryption checkboxes on a file or directory’s Properties dialog box in Windows
    Explorer. This type of compression and encryption is *transparent* in that the
    OS does all the work behind the scenes, allowing you to read and write plain data.
  prefs: []
  type: TYPE_NORMAL
- en: 'You cannot use `SetAttributes` to change a file’s `Compressed` or `Encrypted`
    attributes—it fails silently if you try! The workaround is simple in the latter
    case: you instead call the `Encrypt()` and `Decrypt()` methods in the `File` class.
    With compression, it’s more complicated; one solution is to use the Windows Management
    Instrumentation (WMI) API in `System.Management`. The following method compresses
    a directory, returning `0` if successful (or a WMI error code if not):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: To uncompress, replace `CompressEx` with `UncompressEx`.
  prefs: []
  type: TYPE_NORMAL
- en: Transparent encryption relies on a key seeded from the logged-in user’s password.
    The system is robust to password changes performed by the authenticated user,
    but if a password is reset via an administrator, data in encrypted files is unrecoverable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Transparent encryption and compression require special filesystem support. NTFS
    (used most commonly on hard drives) supports these features; CDFS (on CD-ROMs)
    and FAT (on removable media cards) do not.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can determine whether a volume supports compression and encryption with
    Win32 interop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Windows file security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This feature is Windows-only and requires the NuGet package `System.IO.FileSystem.AccessControl`.
  prefs: []
  type: TYPE_NORMAL
- en: The `FileSecurity` class allow you to query and change the OS permissions assigned
    to users and roles (namespace `System.Security.AccessControl`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we list a file’s existing permissions and then assign Write
    permission to the “Users” group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We give another example, later, in [“Special Folders”](#special_folders).
  prefs: []
  type: TYPE_NORMAL
- en: Unix file security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From .NET 7, the `File` class includes the methods `GetUnix​Fi⁠leMode` and
    `SetUnix​Fi⁠leMode` to get and set file permissions on Unix systems. The `Directory.CreateDirectory`
    method is also now overloaded to accept a Unix file mode, and it’s possible to
    specify a file mode when creating a file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The Directory Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The static `Directory` class provides a set of methods analogous to those in
    the `File` class—for checking whether a directory exists (`Exists`), moving a
    directory (`Move`), deleting a directory (`Delete`), getting/setting times of
    creation or last access, and getting/setting security permissions. Furthermore,
    `Directory` exposes the following static methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The last three methods are potentially more efficient than the `Get*` variants
    because they’re lazily evaluated—fetching data from the file system as you enumerate
    the sequence. They’re particularly well suited to LINQ queries.
  prefs: []
  type: TYPE_NORMAL
- en: The `Enumerate*` and `Get*` methods are overloaded to also accept `search​Pat⁠tern`
    (string) and `searchOption` (enum) parameters. If you specify `SearchOp⁠tion​.SearchAllSubDirectories`,
    a recursive subdirectory search is performed. The `*FileSystemEntries` methods
    combine the results of `*Files` with `*Directories`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how to create a directory if it doesn’t already exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: FileInfo and DirectoryInfo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The static methods on `File` and `Directory` are convenient for executing a
    single file or directory operation. If you need to call a series of methods in
    a row, the `FileInfo` and `DirectoryInfo` classes provide an object model that
    makes the job easier.
  prefs: []
  type: TYPE_NORMAL
- en: '`FileInfo` offers most of the `File`’s static methods in instance form—with
    some additional properties such as `Extension`, `Length`, `IsReadOnly`, and `Directory`—for
    returning a `DirectoryInfo` object. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how to use `DirectoryInfo` to enumerate files and subdirectories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The static `Path` class defines methods and fields for working with paths and
    filenames.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming this setup code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'we can demonstrate `Path`’s methods and fields with the following expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Expression | Result (Windows, then Unix) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Directory.GetCurrentDirectory()` | `k:\demo\` or `/demo` |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.IsPathRooted (file)` | `False` |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.IsPathRooted (path)` | `True` |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.GetPathRoot (path)` | `c:\` or `/` |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.GetDirectoryName (path)` | `c:\mydir` or `/mydir` |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.GetFileName (path)` | `myfile.txt` |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.GetFullPath (file)` | `k:\demo\myfile.txt` or `/demo/myfile.txt` |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.Combine (dir, file)` | `c:\mydir\myfile.txt` or `/mydir/myfile.txt`
    |'
  prefs: []
  type: TYPE_TB
- en: '| **File extensions:** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.HasExtension (file)` | `True` |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.GetExtension (file)` | `.txt` |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.GetFileNameWithoutExtension (file)` | `myfile` |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.ChangeExtension (file, ".log")` | `myfile.log` |'
  prefs: []
  type: TYPE_TB
- en: '| **Separators and characters:** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.DirectorySeparatorChar` | `\` or `/` |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.AltDirectorySeparatorChar` | `/` |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.PathSeparator` | `;` or`:` |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.VolumeSeparatorChar` | `:` or `/` |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.GetInvalidPathChars()` | chars 0 to 31 and `"<>&#124;`eor 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.GetInvalidFileNameChars()` | chars 0 to 31 and `"<>&#124;:*?\/` or
    0 and `/` |'
  prefs: []
  type: TYPE_TB
- en: '| **Temporary files:** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.GetTempPath()` | *<local user folder>*\`Temp` or */tmp/* |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.GetRandomFileName()` | `*d2dwuzjf.dnp*` |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.GetTempFileName()` | *<local user folder>*\`Temp`\`*tmp14B.tmp*` or
    */tmp/*`*tmpubSUYO.tmp*` |'
  prefs: []
  type: TYPE_TB
- en: '`Combine` is particularly useful: it allows you to combine a directory and
    filename—or two directories—without first having to check whether a trailing path
    separator is present, and it automatically uses the correct path separator for
    the OS. It provides overloads that accept up to four directory and/or filenames.'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetFullPath` converts a path relative to the current directory to an absolute
    path. It accepts values such as *..\..\file.txt*.'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetRandomFileName` returns a genuinely unique 8.3-character filename, without
    actually creating any file. `GetTempFileName` generates a temporary filename using
    an autoincrementing counter that repeats every 65,000 files. It then creates a
    zero-byte file of this name in the local temporary directory.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You must delete the file generated by `GetTempFileName` when you’re done; otherwise,
    it will eventually throw an exception (after your 65,000th call to `GetTempFileName`).
    If this is a problem, you can instead `Combine GetTempPath` with `GetRandomFileName`.
    Just be careful not to fill up the user’s hard drive!
  prefs: []
  type: TYPE_NORMAL
- en: Special Folders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One thing missing from `Path` and `Directory` is a means to locate folders
    such as *My Documents*, *Program Files*, *Application Data*, and so on. This is
    provided instead by the `GetFolderPath` method in the `System.Environment` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '`Environment.SpecialFolder` is an enum whose values encompass all special directories
    in Windows, such as `AdminTools`, `ApplicationData`, `Fonts`, `History`, `SendTo`,
    `StartMenu`, and so on. Everything is covered here except the .NET runtime directory,
    which you can obtain as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Most of the special folders have no path assigned on Unix systems. The following
    have paths on Ubuntu Linux 18.04 Desktop: `ApplicationData`, `CommonApplicationData`,
    `Desktop`, `DesktopDirectory`, `LocalApplicationData`, `MyDocuments`, `MyMusic`,
    `MyPictures`, `MyVideos`, `Templates`, and `UserProfile`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of particular value on Windows systems is `ApplicationData`, where you can
    store settings that travel with a user across a network (if roaming profiles are
    enabled on the network domain); `LocalApplicationData`, which is for nonroaming
    data (specific to the logged-in user); and `CommonApplicationData`, which is shared
    by every user of the computer. Writing application data to these folders is considered
    preferable to using the Windows Registry. The standard protocol for storing data
    in these folders is to create a subdirectory with the name of your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s a horrible trap when using `CommonApplicationData`: if a user starts
    your program with administrative elevation and your program then creates folders
    and files in `CommonApplicationData`, that user might lack permissions to replace
    those files later, when run under a restricted Windows login. (A similar problem
    exists when switching between restricted-permission accounts.) You can work around
    it by creating the desired folder (with permissions assigned to everyone) as part
    of your setup.'
  prefs: []
  type: TYPE_NORMAL
- en: Another place to write configuration and log files is to the application’s base
    directory, which you can obtain with `AppDomain.CurrentDomain.BaseDirectory`.
    This is not recommended, however, because the OS is likely to deny your application
    permissions to write to this folder after initial installation (without administrative
    elevation).
  prefs: []
  type: TYPE_NORMAL
- en: Querying Volume Information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can query the drives on a computer with the `DriveInfo` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The static `GetDrives` method returns all mapped drives, including CD-ROMs,
    media cards, and network connections. `DriveType` is an enum with the following
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Catching Filesystem Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `FileSystemWatcher` class lets you monitor a directory (and optionally,
    subdirectories) for activity. `FileSystemWatcher` has events that fire when files
    or subdirectories are created, modified, renamed, and deleted, as well as when
    their attributes change. These events fire regardless of the user or process performing
    the change. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Because `FileSystemWatcher` raises events on a separate thread, you must exception-handle
    the event handling code to prevent an error from taking down the application.
    For more information, see [“Exception Handling”](ch14.html#exception_handling).
  prefs: []
  type: TYPE_NORMAL
- en: The `Error` event does not inform you of filesystem errors; instead, it indicates
    that the `FileSystemWatcher`’s event buffer overflowed because it was overwhelmed
    by `Changed`, `Created`, `Deleted`, or `Renamed` events. You can change the buffer
    size via the `InternalBufferSize` property.
  prefs: []
  type: TYPE_NORMAL
- en: '`IncludeSubdirectories` applies recursively. So, if you create a `FileSystemWatcher`
    on *C:\* with `IncludeSubdirectories true`, its events will fire when a file or
    directory changes anywhere on the hard drive.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A trap in using `FileSystemWatcher` is to open and read newly created or updated
    files before the file has been fully populated or updated. If you’re working in
    conjunction with some other software that’s creating files, you might need to
    consider some strategy to mitigate this, such as creating files with an unwatched
    extension and then renaming them after they’re fully written.
  prefs: []
  type: TYPE_NORMAL
- en: OS Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All applications are subject to OS restrictions, based on the user’s login privileges.
    These restrictions affect file I/O as well as other capabilities, such as access
    to the Windows Registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Windows and Unix, there are two types of accounts:'
  prefs: []
  type: TYPE_NORMAL
- en: An administrative/superuser account that imposes no restrictions in accessing
    the local computer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A limited permissions account that restricts administrative functions and visibility
    of other users’ data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On Windows, a feature called User Account Control (UAC) means that administrators
    receive two tokens or “hats” when logging in: an administrative hat and an ordinary
    user hat. By default, programs run wearing the ordinary user hat—with restricted
    permissions—unless the program requests *administrative elevation*. The user must
    then approve the request in the dialog box that’s presented.'
  prefs: []
  type: TYPE_NORMAL
- en: On Unix, users typically log in with restricted accounts. That is also true
    for administrators to lessen the probability of inadvertently damaging the system.
    When a user needs to run a command that requires elevated permissions, they precede
    the command with `sudo` (short for “super-user do”).
  prefs: []
  type: TYPE_NORMAL
- en: '*By default*, your application will run with restricted user privileges. This
    means that you must either:'
  prefs: []
  type: TYPE_NORMAL
- en: Write your application such that it can run without administrative privileges.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demand administrative elevation in the application manifest (Windows only),
    or detect the lack of required privileges and alert the user to restart the application
    as an administrator/super-user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first option is safer and more convenient for the user. Designing your program
    to run without administrative privileges is easy in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find out whether you’re running under an administrative account as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: With UAC enabled on Windows, this returns `true` only if the current process
    has administrative elevation. On Linux, it returns `true` only if the current
    process is running as super-user (e.g., *sudo myapp*).
  prefs: []
  type: TYPE_NORMAL
- en: Running in a Standard User Account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the key things that you *cannot* do in a standard user account:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write to the following directories:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OS folder (typically *\Windows* or */bin, /sbin, ...*) and subdirectories
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The program files folder (*\Program Files* or */usr/bin, /opt*) and subdirectories
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The root of the OS drive (e.g., *C:\* or */*)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Write to the HKEY_LOCAL_MACHINE branch of the Registry (Windows)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read performance monitoring (WMI) data (Windows)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, as an ordinary Windows user (or even as an administrator), you
    might be refused access to files or resources that belong to other users. Windows
    uses a system of Access Control Lists (ACLs) to protect such resources—you can
    query and assert your own rights in the ACLs via types in `System.Security.AccessControl`.
    ACLs can also be applied to cross-process wait handles, described in [Chapter 21](ch21.html#advanced_threadin).
  prefs: []
  type: TYPE_NORMAL
- en: If you’re refused access to anything as a result of OS security, the CLR detects
    the failure and throws an `UnauthorizedAccessException` (rather than failing silently).
  prefs: []
  type: TYPE_NORMAL
- en: 'In most cases, you can deal with standard user restrictions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Write files to their recommended locations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid using the Registry for information that can be stored in files (aside
    from the HKEY_CURRENT_USER hive, which you will have read/write access to on Windows
    only).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register ActiveX or COM components during setup (Windows only).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The recommended location for user documents is `SpecialFolder.MyDocuments`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The recommended location for configuration files that a user might need to modify
    outside of your application is `SpecialFolder.ApplicationData` (current user only)
    or `SpecialFolder.CommonApplicationData` (all users). You typically create subdirectories
    within these folders, based on your organization and product name.
  prefs: []
  type: TYPE_NORMAL
- en: Administrative Elevation and Virtualization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With an *application manifest*, you can request that Windows prompt the user
    for administrative elevation whenever running your program (Linux ignores this
    request):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: (We describe application manifests in more detail in [Chapter 17](ch17.html#assemblies).)
  prefs: []
  type: TYPE_NORMAL
- en: If you replace `requireAdministrator` with `asInvoker`, it instructs Windows
    that administrative elevation is *not* required. The effect is almost the same
    as not having an application manifest at all—except that *virtualization* is disabled.
    Virtualization is a temporary measure introduced with Windows Vista to help old
    applications run correctly without administrative privileges. The absence of an
    application manifest with a `requestedExecutionLevel` element activates this backward-compatibility
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: Virtualization comes into play when an application writes to the *Program Files*
    or *Windows* directory, or the HKEY_LOCAL_MACHINE area of the Registry. Instead
    of throwing an exception, changes are redirected to a separate location on the
    hard disk where they can’t affect the original data. This prevents the application
    from interfering with the OS—or other well-behaved applications.
  prefs: []
  type: TYPE_NORMAL
- en: Memory-Mapped Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Memory-mapped files* provide two key features:'
  prefs: []
  type: TYPE_NORMAL
- en: Efficient random access to file data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to share memory between different processes on the same computer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The types for memory-mapped files reside in the `System.IO.MemoryMappedFiles`
    namespace. Internally, they work by wrapping the operating system’s API for memory-mapped
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Memory-Mapped Files and Random File I/O
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although an ordinary `FileStream` allows random file I/O (by setting the stream’s
    `Position` property), it’s optimized for sequential I/O. As a rough rule of thumb:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FileStream`s are approximately 10 times faster than memory-mapped files for
    sequential I/O.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory-mapped files are approximately 10 times faster than `FileStream`s for
    random I/O.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing a `FileStream`’s `Position` can cost several microseconds—which adds
    up if done within a loop. A `FileStream` is also unsuitable for multithreaded
    access—because its position changes as it is read or written.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a memory-mapped file:'
  prefs: []
  type: TYPE_NORMAL
- en: Obtain a `FileStream` as you would ordinarily.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instantiate a `MemoryMappedFile`, passing in the file stream.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `CreateViewAccessor` on the memory-mapped file object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last step gives you a `MemoryMappedViewAccessor` object that provides methods
    for randomly reading and writing simple types, structures, and arrays (more on
    this in [“Working with View Accessors”](#working_with_view_accessors)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following creates a one million–byte file and then uses the memory-mapped
    file API to read and then write a byte at position 500,000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specify a map name and capacity when calling `CreateFromFile`.
    Specifying a non-null map name allows the memory block to be shared with other
    processes (see the following section); specifying a capacity automatically enlarges
    the file to that value. The following creates a 1,000-byte file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Memory-Mapped Files and Shared Memory (Windows)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Under Windows, you can also use memory-mapped files as a means of sharing memory
    between processes on the same computer. One process creates a shared memory block
    by calling `MemoryMappedFile.CreateNew`, and then other processes subscribe to
    that same memory block by calling `MemoryMappedFile.OpenExisting` with the same
    name. Although it’s still referred to as a memory-mapped “file,” it resides entirely
    in memory and has no disk presence.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code creates a 500-byte shared memory-mapped file and writes
    the integer 12345 at position 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code opens that memory-mapped file and reads that integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Cross-Platform Interprocess Shared Memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both Windows and Unix allow multiple processes to memory-map the same file.
    You must exercise care to ensure appropriate file sharing settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Working with View Accessors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Calling `CreateViewAccessor` on a `MemoryMappedFile` gives you a view accessor
    that lets you read/write values at random positions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Read*`/`Write*` methods accept numeric types, `bool`, and `char`, as well
    as arrays and structs that contain value-type elements or fields. Reference types—and
    arrays or structs that contain reference types—are prohibited because they cannot
    map into unmanaged memory. So, if you want to write a string, you must encode
    it into an array of bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we wrote the length first. This means we know how many bytes to
    read back later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example of reading/writing a struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Read` and `Write` methods are surprisingly slow. You can get much better
    performance by directly accessing the underlying unmanaged memory via a pointer.
    Following on from the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Your project must be configured to allow unsafe code. You can do that by editing
    your `.csproj` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The performance advantage of pointers is even more pronounced when working with
    large structures because they let you work directly with the raw data rather than
    using `Read`/`Write` to *copy* data between managed and unmanaged memory. We explore
    this further in [Chapter 24](ch24.html#native_and_com_interoperabilit).
  prefs: []
  type: TYPE_NORMAL
