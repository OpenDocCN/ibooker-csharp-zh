<html><head></head><body><section data-pdf-bookmark="Chapter 12. Synchronization" data-type="chapter" epub:type="chapter"><div class="chapter" id="synchronization">&#13;
<h1><span class="label">Chapter 12. </span>Synchronization</h1>&#13;
&#13;
&#13;
<p>When your <a data-primary="synchronization" data-secondary="when needed" data-type="indexterm" id="ch12over1"/>application makes use of concurrency (as practically all .NET applications do), then you need to watch out for situations in which one piece of code needs to update data while other code needs to access the same data. Whenever this happens, you need to <em>synchronize</em> access to the data. The recipes in this chapter cover the most common types used to synchronize access. However, if you use the other recipes in this book appropriately, you’ll find that a lot of the more common synchronization is already done for you by the respective libraries. Before diving into the synchronization recipes, let’s take a closer look at some common situations where synchronization may or may not be required.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>The synchronization explanations in this section are slightly simplified, but the conclusions are all correct.</p>&#13;
</div>&#13;
&#13;
<p>There <a data-primary="data protection, synchronization for" data-type="indexterm" id="ch12over2"/>are two major types of synchronization: <em>communication</em> and <em>data protection</em>. Communication is used when one piece of code needs to notify another piece of code of some condition (e.g., a new message has arrived). I’ll cover communication more thoroughly in this chapter’s recipes; the remainder of this introduction discusses data protection.</p>&#13;
&#13;
<p>You need to use synchronization to protect shared data when <em>all three</em> of these conditions are true:</p>&#13;
<div class="openblock">&#13;
<ul>&#13;
<li>&#13;
<p>Multiple pieces of code are running concurrently.</p>&#13;
</li>&#13;
<li>&#13;
<p>These pieces are accessing (reading or writing) the same data.</p>&#13;
</li>&#13;
<li>&#13;
<p>At least one piece of code is updating (writing) the data.</p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
&#13;
&#13;
<p>The reason for the first condition should be obvious; if your entire code runs from top to bottom and nothing ever happens concurrently, then you never have to worry about synchronization. This is the case for some simple Console applications, but the vast majority of .NET applications do use <em>some</em> kind of concurrency. The second condition means that if each piece of code has its own local data that it doesn’t <em>share</em>, then there’s no need for synchronization; the local data is never accessed from any other pieces of code. There’s also no need for synchronization if there is shared data but the data never changes, such as if the data is defined using immutable types. The third condition covers scenarios like configuration values and the like that are set at the beginning of the application and then never change. If the shared data is only read, then it doesn’t need synchronization; only data that is both <em>shared</em> and <em>updated</em> needs synchronization.</p>&#13;
&#13;
<p>The purpose of data protection is to provide each piece of code with a consistent view of the data. If one piece of code is updating the data, then you can use synchronization to make those updates appear atomic to the rest of the system.</p>&#13;
&#13;
<p>It <a data-primary="asynchronous programming" data-secondary="synchronization, when needed" data-type="indexterm" id="ch12async"/>takes some practice to learn when synchronization is necessary, so we’ll walk through a few examples before starting the recipes in this chapter. As our first example, consider the following code:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">async</code> <code class="n">Task</code> <code class="nf">MyMethodAsync</code><code class="p">()</code>&#13;
<code class="p">{</code>&#13;
  <code class="kt">int</code> <code class="k">value</code> <code class="p">=</code> <code class="m">10</code><code class="p">;</code>&#13;
  <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">1</code><code class="p">));</code>&#13;
  <code class="k">value</code> <code class="p">=</code> <code class="k">value</code> <code class="p">+</code> <code class="m">1</code><code class="p">;</code>&#13;
  <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">1</code><code class="p">));</code>&#13;
  <code class="k">value</code> <code class="p">=</code> <code class="k">value</code> <code class="p">-</code> <code class="m">1</code><code class="p">;</code>&#13;
  <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">1</code><code class="p">));</code>&#13;
  <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="k">value</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If the <code>MyMethodAsync</code> method is called from a threadpool thread (e.g., from within <code>Task.Run</code>), then the lines of code accessing <code>value</code> may run on separate threadpool threads. But does it need synchronization? No, because none of them can be running at the same time. The method is asynchronous, but it’s also sequential (meaning it progresses one part at a time).</p>&#13;
&#13;
<p>OK, let’s complicate the example a bit. This time we’ll run concurrent asynchronous code:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">private</code> <code class="kt">int</code> <code class="k">value</code><code class="p">;</code>&#13;
&#13;
<code class="k">async</code> <code class="n">Task</code> <code class="nf">ModifyValueAsync</code><code class="p">()</code>&#13;
<code class="p">{</code>&#13;
  <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">1</code><code class="p">));</code>&#13;
  <code class="k">value</code> <code class="p">=</code> <code class="k">value</code> <code class="p">+</code> <code class="m">1</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// WARNING: may require synchronization; see discussion below.</code>&#13;
<code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">ModifyValueConcurrentlyAsync</code><code class="p">()</code>&#13;
<code class="p">{</code>&#13;
  <code class="c1">// Start three concurrent modifications.</code>&#13;
  <code class="n">Task</code> <code class="n">task1</code> <code class="p">=</code> <code class="n">ModifyValueAsync</code><code class="p">();</code>&#13;
  <code class="n">Task</code> <code class="n">task2</code> <code class="p">=</code> <code class="n">ModifyValueAsync</code><code class="p">();</code>&#13;
  <code class="n">Task</code> <code class="n">task3</code> <code class="p">=</code> <code class="n">ModifyValueAsync</code><code class="p">();</code>&#13;
&#13;
  <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">WhenAll</code><code class="p">(</code><code class="n">task1</code><code class="p">,</code> <code class="n">task2</code><code class="p">,</code> <code class="n">task3</code><code class="p">);</code>&#13;
&#13;
  <code class="k">return</code> <code class="k">value</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This code above is starting three modifications that run concurrently. Does it need synchronization? It depends. If you know that the method is called from a GUI or ASP.NET context (or any context that only allows one piece of code to run at a time), synchronization won’t be necessary because when the actual <code>data</code> modification code runs, it runs at a different time than the other two <code>data</code> modifications. For example, if the preceding code is run in a GUI context, there’s only one UI thread that will execute each of the <code>data</code> modifications, so it <em>must</em> do them one at a time. So, if you know the context is a one-at-a-time context, then there’s no synchronization needed. However, if that same method is called from a threadpool thread (e.g., from <code>Task.Run</code>), then synchronization <em>would</em> be necessary. In that case, the three <code>data</code> modifications could run on separate threadpool threads and update <code>data.Value</code> simultaneously, so you would need to synchronize access to <code>data.Value</code>.</p>&#13;
&#13;
<p>Now let’s consider one more wrinkle:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">private</code> <code class="kt">int</code> <code class="k">value</code><code class="p">;</code>&#13;
&#13;
<code class="k">async</code> <code class="n">Task</code> <code class="nf">ModifyValueAsync</code><code class="p">()</code>&#13;
<code class="p">{</code>&#13;
  <code class="kt">int</code> <code class="n">originalValue</code> <code class="p">=</code> <code class="k">value</code><code class="p">;</code>&#13;
  <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">1</code><code class="p">));</code>&#13;
  <code class="k">value</code> <code class="p">=</code> <code class="n">originalValue</code> <code class="p">+</code> <code class="m">1</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Consider what happens if <code>ModifyValueAsync</code> is called multiple times concurrently. Even if it is called from a one-at-a-time context, the data member is shared between each invocation of <code>ModifyValueAsync</code>, and the value may change any time that method does an <code>await</code>. You may want to apply synchronization even in a one-at-a-time context if you want to avoid that kind of sharing. Put another way, to make it so that each call to <code>ModifyValueAsync</code> waits until all previous calls have completed, you’ll need to add synchronization. This is true even if the context ensures that only one thread is used for all the code (i.e., the UI thread). Synchronization in this scenario is a kind of <em>throttling</em> for asynchronous methods (see <a data-type="xref" href="#recipe-async-locks">Recipe 12.2</a>).</p>&#13;
&#13;
<p>Let’s look at one more <code>async</code> example. You can use <code>Task.Run</code> to do what I call “simple parallelism”—a basic kind of parallel processing that doesn’t provide the efficiency and configurability that the true parallelism of <code>Parallel</code>/PLINQ does. The following code updates a shared value using simple parallelism:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="c1">// BAD CODE!!</code>&#13;
<code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">SimpleParallelismAsync</code><code class="p">()</code>&#13;
<code class="p">{</code>&#13;
  <code class="kt">int</code> <code class="k">value</code> <code class="p">=</code> <code class="m">0</code><code class="p">;</code>&#13;
  <code class="n">Task</code> <code class="n">task1</code> <code class="p">=</code> <code class="n">Task</code><code class="p">.</code><code class="n">Run</code><code class="p">(()</code> <code class="p">=&gt;</code> <code class="p">{</code> <code class="k">value</code> <code class="p">=</code> <code class="k">value</code> <code class="p">+</code> <code class="m">1</code><code class="p">;</code> <code class="p">});</code>&#13;
  <code class="n">Task</code> <code class="n">task2</code> <code class="p">=</code> <code class="n">Task</code><code class="p">.</code><code class="n">Run</code><code class="p">(()</code> <code class="p">=&gt;</code> <code class="p">{</code> <code class="k">value</code> <code class="p">=</code> <code class="k">value</code> <code class="p">+</code> <code class="m">1</code><code class="p">;</code> <code class="p">});</code>&#13;
  <code class="n">Task</code> <code class="n">task3</code> <code class="p">=</code> <code class="n">Task</code><code class="p">.</code><code class="n">Run</code><code class="p">(()</code> <code class="p">=&gt;</code> <code class="p">{</code> <code class="k">value</code> <code class="p">=</code> <code class="k">value</code> <code class="p">+</code> <code class="m">1</code><code class="p">;</code> <code class="p">});</code>&#13;
  <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">WhenAll</code><code class="p">(</code><code class="n">task1</code><code class="p">,</code> <code class="n">task2</code><code class="p">,</code> <code class="n">task3</code><code class="p">);</code>&#13;
  <code class="k">return</code> <code class="k">value</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This <a data-primary="thread pool" data-secondary="Task.Run using" data-type="indexterm" id="idm45458687945624"/>code has three separate tasks running on the thread pool (via <code>Task.Run</code>), all modifying the same <code>value</code>. So, our synchronization conditions apply, and we certainly do need synchronization here. Note that we do need synchronization even though <code>value</code> is a local variable; it’s still <em>shared</em> between threads even though it’s local to the one <a data-startref="ch12async" data-type="indexterm" id="idm45458687752584"/>method.</p>&#13;
&#13;
<p>Moving <a data-primary="parallel programming" data-secondary="synchronization, when needed" data-type="indexterm" id="ch12par"/>on to true parallel code, let’s consider an example that uses the <code>Parallel</code> type:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">void</code> <code class="nf">IndependentParallelism</code><code class="p">(</code><code class="n">IEnumerable</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">values</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="n">Parallel</code><code class="p">.</code><code class="n">ForEach</code><code class="p">(</code><code class="n">values</code><code class="p">,</code> <code class="n">item</code> <code class="p">=&gt;</code> <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">item</code><code class="p">));</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Since this code uses <code>Parallel</code>, we must assume the body of the parallel loop (<code>item =&gt; Trace.WriteLine(item)</code>) can be running on multiple threads. However, the body of the loop only reads from its own data; there’s no data sharing between threads here. The <code>Parallel</code> class divides the data among threads so that none of them has to share its data. Each thread running its loop body is independent from all the other threads running the same loop body. So, no synchronization of the preceding code is necessary.</p>&#13;
&#13;
<p>Let’s <a data-primary="aggregation" data-type="indexterm" id="idm45458687722216"/>look at an aggregation example similar to the one covered in <a data-type="xref" href="ch04.html#recipe-parallel-aggregate">Recipe 4.2</a>:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="c1">// BAD CODE!!</code>&#13;
<code class="kt">int</code> <code class="nf">ParallelSum</code><code class="p">(</code><code class="n">IEnumerable</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">values</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="kt">int</code> <code class="n">result</code> <code class="p">=</code> <code class="m">0</code><code class="p">;</code>&#13;
  <code class="n">Parallel</code><code class="p">.</code><code class="n">ForEach</code><code class="p">(</code><code class="n">source</code><code class="p">:</code> <code class="n">values</code><code class="p">,</code>&#13;
      <code class="n">localInit</code><code class="p">:</code> <code class="p">()</code> <code class="p">=&gt;</code> <code class="m">0</code><code class="p">,</code>&#13;
      <code class="n">body</code><code class="p">:</code> <code class="p">(</code><code class="n">item</code><code class="p">,</code> <code class="n">state</code><code class="p">,</code> <code class="n">localValue</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">localValue</code> <code class="p">+</code> <code class="n">item</code><code class="p">,</code>&#13;
      <code class="n">localFinally</code><code class="p">:</code> <code class="n">localValue</code> <code class="p">=&gt;</code> <code class="p">{</code> <code class="n">result</code> <code class="p">+=</code> <code class="n">localValue</code><code class="p">;</code> <code class="p">});</code>&#13;
  <code class="k">return</code> <code class="n">result</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In this example, the code is again using multiple threads; this time, each thread starts with its local value initialized to 0 (<code>() =&gt; 0</code>), and for each input value processed by that thread, it adds the input value to its local value (<code>(item, state, localValue) =&gt; localValue + item</code>). Finally, all the local values are added to the return value (<code>localValue =&gt; { result += localValue; }</code>). The first two steps aren’t problematic because there’s nothing shared between threads; each thread’s local and input values are independent from all other threads’ local and input values. The final step is problematic, however; when each thread’s local value is added to the return value, this is a situation where there’s a shared variable (<code>result</code>) that is accessed by multiple threads and updated by all of them. So, you’d need to use synchronization in that final <a data-startref="ch12par" data-type="indexterm" id="idm45458687575048"/>step (see <a data-type="xref" href="#recipe-locks">Recipe 12.1</a>).</p>&#13;
&#13;
<p>The<a data-primary="dataflow" data-secondary="synchronization, when needed" data-type="indexterm" id="idm45458687573224"/><a data-primary="reactive programming" data-secondary="synchronization, when needed" data-type="indexterm" id="idm45458687572248"/><a data-primary="PLINQ (Parallel LINQ)" data-secondary="synchronization, when needed" data-type="indexterm" id="idm45458687571336"/> PLINQ, dataflow, and reactive libraries are very similar to the <code>Parallel</code> examples: as long as your code is just dealing with its own input, it doesn’t have to worry about synchronization. I find that if I use these libraries appropriately, there’s very little need for me to add synchronization to most of my code.</p>&#13;
&#13;
<p>Lastly, <a data-primary="collections" data-secondary="synchronization, when needed" data-type="indexterm" id="ch12col"/>let’s discuss collections. Remember that the three conditions requiring synchronization are <em>multiple pieces of code</em>, <em>shared data</em>, and <em>data updates</em>.</p>&#13;
&#13;
<p>Immutable <a data-primary="immutable collections" data-secondary="synchronization, when needed" data-type="indexterm" id="idm45458687565928"/>types are naturally threadsafe because they <em>cannot</em> change; it’s not possible to update an immutable collection, so no synchronization is necessary. For example, the following code doesn’t require synchronization because when each separate threadpool thread pushes a value onto the stack, it’s creating a new immutable stack with that value, leaving the original <code>stack</code> unchanged:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">bool</code><code class="p">&gt;</code> <code class="n">PlayWithStackAsync</code><code class="p">()</code>&#13;
<code class="p">{</code>&#13;
  <code class="n">ImmutableStack</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">stack</code> <code class="p">=</code> <code class="n">ImmutableStack</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;.</code><code class="n">Empty</code><code class="p">;</code>&#13;
&#13;
  <code class="n">Task</code> <code class="n">task1</code> <code class="p">=</code> <code class="n">Task</code><code class="p">.</code><code class="n">Run</code><code class="p">(()</code> <code class="p">=&gt;</code> <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">stack</code><code class="p">.</code><code class="n">Push</code><code class="p">(</code><code class="m">3</code><code class="p">).</code><code class="n">Peek</code><code class="p">()));</code>&#13;
  <code class="n">Task</code> <code class="n">task2</code> <code class="p">=</code> <code class="n">Task</code><code class="p">.</code><code class="n">Run</code><code class="p">(()</code> <code class="p">=&gt;</code> <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">stack</code><code class="p">.</code><code class="n">Push</code><code class="p">(</code><code class="m">5</code><code class="p">).</code><code class="n">Peek</code><code class="p">()));</code>&#13;
  <code class="n">Task</code> <code class="n">task3</code> <code class="p">=</code> <code class="n">Task</code><code class="p">.</code><code class="n">Run</code><code class="p">(()</code> <code class="p">=&gt;</code> <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">stack</code><code class="p">.</code><code class="n">Push</code><code class="p">(</code><code class="m">7</code><code class="p">).</code><code class="n">Peek</code><code class="p">()));</code>&#13;
  <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">WhenAll</code><code class="p">(</code><code class="n">task1</code><code class="p">,</code> <code class="n">task2</code><code class="p">,</code> <code class="n">task3</code><code class="p">);</code>&#13;
&#13;
  <code class="k">return</code> <code class="n">stack</code><code class="p">.</code><code class="n">IsEmpty</code><code class="p">;</code> <code class="c1">// Always returns true.</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>When your code uses immutable collections, it’s common to have a shared “root” variable that is not itself immutable. In that case, you <em>do</em> have to use synchronization. In the following code, each thread pushes a value onto the stack (creating a new immutable stack) and then updates the shared root variable; the code <em>does</em> need synchronization to update the <code>stack</code> variable:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="c1">// BAD CODE!!</code>&#13;
<code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">bool</code><code class="p">&gt;</code> <code class="n">PlayWithStackAsync</code><code class="p">()</code>&#13;
<code class="p">{</code>&#13;
  <code class="n">ImmutableStack</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">stack</code> <code class="p">=</code> <code class="n">ImmutableStack</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;.</code><code class="n">Empty</code><code class="p">;</code>&#13;
&#13;
  <code class="n">Task</code> <code class="n">task1</code> <code class="p">=</code> <code class="n">Task</code><code class="p">.</code><code class="n">Run</code><code class="p">(()</code> <code class="p">=&gt;</code> <code class="p">{</code> <code class="n">stack</code> <code class="p">=</code> <code class="n">stack</code><code class="p">.</code><code class="n">Push</code><code class="p">(</code><code class="m">3</code><code class="p">);</code> <code class="p">});</code>&#13;
  <code class="n">Task</code> <code class="n">task2</code> <code class="p">=</code> <code class="n">Task</code><code class="p">.</code><code class="n">Run</code><code class="p">(()</code> <code class="p">=&gt;</code> <code class="p">{</code> <code class="n">stack</code> <code class="p">=</code> <code class="n">stack</code><code class="p">.</code><code class="n">Push</code><code class="p">(</code><code class="m">5</code><code class="p">);</code> <code class="p">});</code>&#13;
  <code class="n">Task</code> <code class="n">task3</code> <code class="p">=</code> <code class="n">Task</code><code class="p">.</code><code class="n">Run</code><code class="p">(()</code> <code class="p">=&gt;</code> <code class="p">{</code> <code class="n">stack</code> <code class="p">=</code> <code class="n">stack</code><code class="p">.</code><code class="n">Push</code><code class="p">(</code><code class="m">7</code><code class="p">);</code> <code class="p">});</code>&#13;
  <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">WhenAll</code><code class="p">(</code><code class="n">task1</code><code class="p">,</code> <code class="n">task2</code><code class="p">,</code> <code class="n">task3</code><code class="p">);</code>&#13;
&#13;
  <code class="k">return</code> <code class="n">stack</code><code class="p">.</code><code class="n">IsEmpty</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Threadsafe <a data-primary="threadsafe collections" data-secondary="synchronization, when needed" data-type="indexterm" id="idm45458687415272"/>collections (e.g., <code>ConcurrentDictionary</code>) are quite different. Unlike immutable collections, threadsafe collections can be updated. But they have all the synchronization they need built in, so you don’t have to worry about synchronizing collection changes. If the following code updated a <code>Dictionary</code> instead of a <code>ConcurrentDictionary</code>, it would need synchronization; but since it’s updating a <code>ConcurrentDictionary</code>, it doesn’t need <a data-startref="ch12over1" data-type="indexterm" id="idm45458687289736"/><a data-startref="ch12over2" data-type="indexterm" id="idm45458687289000"/><a data-startref="ch12col" data-type="indexterm" id="idm45458687288328"/>synchronization:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">ThreadsafeCollectionsAsync</code><code class="p">()</code>&#13;
<code class="p">{</code>&#13;
  <code class="kt">var</code> <code class="n">dictionary</code> <code class="p">=</code> <code class="k">new</code> <code class="n">ConcurrentDictionary</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">,</code> <code class="kt">int</code><code class="p">&gt;();</code>&#13;
&#13;
  <code class="n">Task</code> <code class="n">task1</code> <code class="p">=</code> <code class="n">Task</code><code class="p">.</code><code class="n">Run</code><code class="p">(()</code> <code class="p">=&gt;</code> <code class="p">{</code> <code class="n">dictionary</code><code class="p">.</code><code class="n">TryAdd</code><code class="p">(</code><code class="m">2</code><code class="p">,</code> <code class="m">3</code><code class="p">);</code> <code class="p">});</code>&#13;
  <code class="n">Task</code> <code class="n">task2</code> <code class="p">=</code> <code class="n">Task</code><code class="p">.</code><code class="n">Run</code><code class="p">(()</code> <code class="p">=&gt;</code> <code class="p">{</code> <code class="n">dictionary</code><code class="p">.</code><code class="n">TryAdd</code><code class="p">(</code><code class="m">3</code><code class="p">,</code> <code class="m">5</code><code class="p">);</code> <code class="p">});</code>&#13;
  <code class="n">Task</code> <code class="n">task3</code> <code class="p">=</code> <code class="n">Task</code><code class="p">.</code><code class="n">Run</code><code class="p">(()</code> <code class="p">=&gt;</code> <code class="p">{</code> <code class="n">dictionary</code><code class="p">.</code><code class="n">TryAdd</code><code class="p">(</code><code class="m">5</code><code class="p">,</code> <code class="m">7</code><code class="p">);</code> <code class="p">});</code>&#13;
  <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">WhenAll</code><code class="p">(</code><code class="n">task1</code><code class="p">,</code> <code class="n">task2</code><code class="p">,</code> <code class="n">task3</code><code class="p">);</code>&#13;
&#13;
  <code class="k">return</code> <code class="n">dictionary</code><code class="p">.</code><code class="n">Count</code><code class="p">;</code> <code class="c1">// Always returns 3.</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="12.1 Blocking Locks" data-type="sect1"><div class="sect1" id="recipe-locks">&#13;
<h1>12.1 Blocking Locks</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458687156600">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="synchronization" data-secondary="blocking locks for" data-type="indexterm" id="ch12r1a"/><a data-primary="locks" data-secondary="blocking locks" data-type="indexterm" id="ch12r1b"/>have some shared data and need to safely read and write it from multiple threads.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458687152360">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>The <a data-primary="lock statement" data-type="indexterm" id="ch12r1c"/>best solution for this situation is to use the <code>lock</code> statement. When a thread enters a lock, it’ll prevent any other threads from entering that lock until the lock is released:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">class</code> <code class="nc">MyClass</code>&#13;
<code class="p">{</code>&#13;
  <code class="c1">// This lock protects the _value field.</code>&#13;
  <code class="k">private</code> <code class="k">readonly</code> <code class="kt">object</code> <code class="n">_mutex</code> <code class="p">=</code> <code class="k">new</code> <code class="kt">object</code><code class="p">();</code>&#13;
&#13;
  <code class="k">private</code> <code class="kt">int</code> <code class="n">_value</code><code class="p">;</code>&#13;
&#13;
  <code class="k">public</code> <code class="k">void</code> <code class="nf">Increment</code><code class="p">()</code>&#13;
  <code class="p">{</code>&#13;
    <code class="k">lock</code> <code class="p">(</code><code class="n">_mutex</code><code class="p">)</code>&#13;
    <code class="p">{</code>&#13;
      <code class="n">_value</code> <code class="p">=</code> <code class="n">_value</code> <code class="p">+</code> <code class="m">1</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458687148120">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>There are many other kinds of locks in the .NET framework, such as <code>Monitor</code>, <code>SpinLock</code>, and <code>ReaderWriterLockSlim</code>. In most applications, these lock types should almost never be used directly. In particular, it’s natural for developers to jump to <code>ReaderWriterLockSlim</code> when there is no need for that level of complexity. The basic <code>lock</code> statement handles 99% of cases quite well.</p>&#13;
&#13;
<p>There are four important guidelines when using locks:</p>&#13;
<div class="openblock">&#13;
<ul>&#13;
<li>&#13;
<p>Restrict lock visibility.</p>&#13;
</li>&#13;
<li>&#13;
<p>Document what the lock protects.</p>&#13;
</li>&#13;
<li>&#13;
<p>Minimize code under lock.</p>&#13;
</li>&#13;
<li>&#13;
<p>Never execute arbitrary code while holding a lock.</p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
&#13;
&#13;
<p>First, you should strive to restrict lock visibility. The object used in the <code>lock</code> statement should be a private field and never should be exposed to any method outside the class. There’s usually at most one lock member per type; if you have more than one, consider refactoring that type into separate types. You <em>can</em> lock on any reference type, but I prefer to have a field specifically for use with the <code>lock</code> statement, as in the last example. If you do lock on another instance, be sure that it is private to your class; it should not have been passed in to the constructor or returned from a property getter. You should never <code>lock(this)</code> or lock on any instance of <code>Type</code> or <code>string</code>; these locks can cause deadlocks because they are accessible from other code.</p>&#13;
&#13;
<p>Second, document what the lock protects. This step is easy to overlook when initially writing the code but becomes more important as the code grows in complexity.</p>&#13;
&#13;
<p>Third, do your best to minimize the code that is executed while holding a lock. One thing to watch for is blocking calls; ideally, your code should never block while holding a lock.</p>&#13;
&#13;
<p>Finally, do not ever call arbitrary code under lock. Arbitrary code can include raising events, invoking virtual methods, or invoking delegates. If you must execute arbitrary code, do so after the lock is <a data-startref="ch12r1a" data-type="indexterm" id="idm45458687116824"/><a data-startref="ch12r1b" data-type="indexterm" id="idm45458687116120"/><a data-startref="ch12r1c" data-type="indexterm" id="idm45458687115448"/>released.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458687114520">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="#recipe-async-locks">Recipe 12.2</a> covers <code>async</code>-compatible locks. The <code>lock</code> statement is not compatible with <code>await</code>.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-signals">Recipe 12.3</a> covers signaling between threads. The <code>lock</code> statement is intended to protect shared data, not to send signals between threads.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-throttling">Recipe 12.5</a> covers throttling, which is a generalization of locking. A lock can be thought of as throttling to one at a time.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="12.2 Async Locks" data-type="sect1"><div class="sect1" id="recipe-async-locks">&#13;
<h1>12.2 Async Locks</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458687106360">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="synchronization" data-secondary="asynchronous locks for" data-type="indexterm" id="ch12r2a"/><a data-primary="locks" data-secondary="asynchronous locks" data-type="indexterm" id="ch12r2b"/>have some shared data and need to safely read and write it from multiple code blocks, which may be using <code>await</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458687101608">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>The<a data-primary="SemaphoreSlim type" data-type="indexterm" id="idm45458687100008"/> .NET framework <code>SemaphoreSlim</code> type has been updated in .NET 4.5 to be compatible with <code>async</code>. Here’s how you can use it:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">class</code> <code class="nc">MyClass</code>&#13;
<code class="p">{</code>&#13;
  <code class="c1">// This lock protects the _value field.</code>&#13;
  <code class="k">private</code> <code class="k">readonly</code> <code class="n">SemaphoreSlim</code> <code class="n">_mutex</code> <code class="p">=</code> <code class="k">new</code> <code class="n">SemaphoreSlim</code><code class="p">(</code><code class="m">1</code><code class="p">);</code>&#13;
&#13;
  <code class="k">private</code> <code class="kt">int</code> <code class="n">_value</code><code class="p">;</code>&#13;
&#13;
  <code class="k">public</code> <code class="k">async</code> <code class="n">Task</code> <code class="nf">DelayAndIncrementAsync</code><code class="p">()</code>&#13;
  <code class="p">{</code>&#13;
    <code class="k">await</code> <code class="n">_mutex</code><code class="p">.</code><code class="n">WaitAsync</code><code class="p">();</code>&#13;
    <code class="k">try</code>&#13;
    <code class="p">{</code>&#13;
      <code class="kt">int</code> <code class="n">oldValue</code> <code class="p">=</code> <code class="n">_value</code><code class="p">;</code>&#13;
      <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="n">oldValue</code><code class="p">));</code>&#13;
      <code class="n">_value</code> <code class="p">=</code> <code class="n">oldValue</code> <code class="p">+</code> <code class="m">1</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">finally</code>&#13;
    <code class="p">{</code>&#13;
      <code class="n">_mutex</code><code class="p">.</code><code class="n">Release</code><code class="p">();</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>You <a data-primary="AsyncLock type" data-type="indexterm" id="idm45458687096424"/><a data-primary="Nito.AsyncEx library" data-type="indexterm" id="idm45458687095816"/>can also use the <code>AsyncLock</code> type from the <code>Nito.AsyncEx</code> library, which has a slightly more elegant API:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">class</code> <code class="nc">MyClass</code>&#13;
<code class="p">{</code>&#13;
  <code class="c1">// This lock protects the _value field.</code>&#13;
  <code class="k">private</code> <code class="k">readonly</code> <code class="n">AsyncLock</code> <code class="n">_mutex</code> <code class="p">=</code> <code class="k">new</code> <code class="n">AsyncLock</code><code class="p">();</code>&#13;
&#13;
  <code class="k">private</code> <code class="kt">int</code> <code class="n">_value</code><code class="p">;</code>&#13;
&#13;
  <code class="k">public</code> <code class="k">async</code> <code class="n">Task</code> <code class="nf">DelayAndIncrementAsync</code><code class="p">()</code>&#13;
  <code class="p">{</code>&#13;
    <code class="k">using</code> <code class="p">(</code><code class="k">await</code> <code class="n">_mutex</code><code class="p">.</code><code class="n">LockAsync</code><code class="p">())</code>&#13;
    <code class="p">{</code>&#13;
      <code class="kt">int</code> <code class="n">oldValue</code> <code class="p">=</code> <code class="n">_value</code><code class="p">;</code>&#13;
      <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="n">oldValue</code><code class="p">));</code>&#13;
      <code class="n">_value</code> <code class="p">=</code> <code class="n">oldValue</code> <code class="p">+</code> <code class="m">1</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458686941720">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>The same guidelines from <a data-type="xref" href="#recipe-locks">Recipe 12.1</a> also apply here, specifically:</p>&#13;
<div class="openblock">&#13;
<ul>&#13;
<li>&#13;
<p>Restrict lock visibility.</p>&#13;
</li>&#13;
<li>&#13;
<p>Document what the lock protects.</p>&#13;
</li>&#13;
<li>&#13;
<p>Minimize code under lock.</p>&#13;
</li>&#13;
<li>&#13;
<p>Never execute arbitrary code while holding a lock.</p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
&#13;
&#13;
<p>Keep your lock instances private; do not expose them outside the class. Be sure to clearly document (and carefully think through) exactly what a lock instance protects. Minimize code that is executed while holding a lock. In particular, do not call arbitrary code; this includes raising events, invoking virtual methods, and invoking <a data-startref="ch12r2a" data-type="indexterm" id="idm45458686834232"/><a data-startref="ch12r2b" data-type="indexterm" id="idm45458686833528"/>delegates.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>The <code>AsyncLock</code> type is in the <a href="http://bit.ly/nito-async"><code>Nito.AsyncEx</code></a> NuGet package.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458686830072">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="#recipe-async-signals">Recipe 12.4</a> covers <code>async</code>-compatible signaling. Locks are intended to protect shared data, not act as signals.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-throttling">Recipe 12.5</a> covers throttling, which is a generalization of locking. A lock can be thought of as throttling to one at a time.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="12.3 Blocking Signals" data-type="sect1"><div class="sect1" id="recipe-signals">&#13;
<h1>12.3 Blocking Signals</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458686824360">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="synchronization" data-secondary="blocking signals for" data-type="indexterm" id="ch12r3a"/><a data-primary="notifications" data-secondary="blocking signals" data-type="indexterm" id="ch12r3b"/><a data-primary="signals" data-secondary="blocking signals" data-type="indexterm" id="ch12r3c"/>have to send a notification from one thread to another.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458686818904">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>The <a data-primary="ManualResetEventSlim type" data-type="indexterm" id="idm45458686817608"/>most common and general-purpose cross-thread signal is <code>ManualResetEventSlim</code>. A manual-reset event can be in one of two states: signaled or unsignaled. Any thread may set the event to a signaled state or reset the event to an unsignaled state. A thread may also wait for the event to be signaled.</p>&#13;
&#13;
<p>The following two methods are invoked by separate threads; one thread waits for a signal from the other:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">class</code> <code class="nc">MyClass</code>&#13;
<code class="p">{</code>&#13;
  <code class="k">private</code> <code class="k">readonly</code> <code class="n">ManualResetEventSlim</code> <code class="n">_initialized</code> <code class="p">=</code>&#13;
      <code class="k">new</code> <code class="nf">ManualResetEventSlim</code><code class="p">();</code>&#13;
&#13;
  <code class="k">private</code> <code class="kt">int</code> <code class="n">_value</code><code class="p">;</code>&#13;
&#13;
  <code class="k">public</code> <code class="kt">int</code> <code class="nf">WaitForInitialization</code><code class="p">()</code>&#13;
  <code class="p">{</code>&#13;
    <code class="n">_initialized</code><code class="p">.</code><code class="n">Wait</code><code class="p">();</code>&#13;
    <code class="k">return</code> <code class="n">_value</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="k">public</code> <code class="k">void</code> <code class="nf">InitializeFromAnotherThread</code><code class="p">()</code>&#13;
  <code class="p">{</code>&#13;
    <code class="n">_value</code> <code class="p">=</code> <code class="m">13</code><code class="p">;</code>&#13;
    <code class="n">_initialized</code><code class="p">.</code><code class="n">Set</code><code class="p">();</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458686756232">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p><code>ManualResetEventSlim</code> is a great general-purpose signal from one thread to another, but you should only use it when appropriate. If the “signal” is actually a <em>message</em> sending some piece of data across threads, then consider using a producer/consumer queue. On the other hand, if the signals are just used to coordinate access to shared data, then you should use a lock instead.</p>&#13;
&#13;
<p>There are other thread synchronization signal types in the .NET framework that are less commonly used. If <code>ManualResetEventSlim</code> doesn’t suit your needs, consider <code>AutoResetEvent</code>, <code>CountdownEvent</code>, or <code>Barrier</code>.</p>&#13;
&#13;
<p><code>ManualResetEventSlim</code> is a synchronous signal, so <code>WaitForInitialization</code> will block the calling thread until the signal is sent. If you want to wait for a signal without blocking a thread, then you want an asynchronous signal, as described <a data-startref="ch12r3a" data-type="indexterm" id="idm45458686720232"/><a data-startref="ch12r3b" data-type="indexterm" id="idm45458686719528"/><a data-startref="ch12r3c" data-type="indexterm" id="idm45458686718856"/>in <a data-type="xref" href="#recipe-async-signals">Recipe 12.4</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458686716968">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="ch09.html#recipe-blocking-queues">Recipe 9.6</a> covers blocking producer/consumer queues.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-locks">Recipe 12.1</a> covers blocking locks.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-async-signals">Recipe 12.4</a> covers <code>async</code>-compatible signals.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="12.4 Async Signals" data-type="sect1"><div class="sect1" id="recipe-async-signals">&#13;
<h1>12.4 Async Signals</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458686710168">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="synchronization" data-secondary="asynchronous signals for" data-type="indexterm" id="ch12r4a"/><a data-primary="notifications" data-secondary="asynchronous signals" data-type="indexterm" id="ch12r4b"/><a data-primary="signals" data-secondary="asynchronous signals" data-type="indexterm" id="ch12r4c"/>need to send a notification from one part of the code to another, and the receiver of the notification must wait for it asynchronously.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458686704600">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use <code>TaskCompletionSource&lt;T&gt;</code> to send the notification asynchronously, if the notification only needs to be sent once. The sending code calls <code>TrySetResult</code>, and the receiving code awaits its <code>Task</code> property:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">class</code> <code class="nc">MyClass</code>&#13;
<code class="p">{</code>&#13;
  <code class="k">private</code> <code class="k">readonly</code> <code class="n">TaskCompletionSource</code><code class="p">&lt;</code><code class="kt">object</code><code class="p">&gt;</code> <code class="n">_initialized</code> <code class="p">=</code>&#13;
      <code class="k">new</code> <code class="n">TaskCompletionSource</code><code class="p">&lt;</code><code class="kt">object</code><code class="p">&gt;();</code>&#13;
&#13;
  <code class="k">private</code> <code class="kt">int</code> <code class="n">_value1</code><code class="p">;</code>&#13;
  <code class="k">private</code> <code class="kt">int</code> <code class="n">_value2</code><code class="p">;</code>&#13;
&#13;
  <code class="k">public</code> <code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">WaitForInitializationAsync</code><code class="p">()</code>&#13;
  <code class="p">{</code>&#13;
    <code class="k">await</code> <code class="n">_initialized</code><code class="p">.</code><code class="n">Task</code><code class="p">;</code>&#13;
    <code class="k">return</code> <code class="n">_value1</code> <code class="p">+</code> <code class="n">_value2</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="k">public</code> <code class="k">void</code> <code class="nf">Initialize</code><code class="p">()</code>&#13;
  <code class="p">{</code>&#13;
    <code class="n">_value1</code> <code class="p">=</code> <code class="m">13</code><code class="p">;</code>&#13;
    <code class="n">_value2</code> <code class="p">=</code> <code class="m">17</code><code class="p">;</code>&#13;
    <code class="n">_initialized</code><code class="p">.</code><code class="n">TrySetResult</code><code class="p">(</code><code class="k">null</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>TaskCompletionSource&lt;T&gt;</code> type can be used to asynchronously wait for any kind of situation—in this case, a notification from another part of the code. This works well if the signal is only sent once, but doesn’t work as well if you need to turn the signal off as well as on.</p>&#13;
&#13;
<p>The<a data-primary="AsyncManualResetEvent type" data-type="indexterm" id="idm45458686594584"/><a data-primary="Nito.AsyncEx library" data-type="indexterm" id="idm45458686593832"/> <code>Nito.AsyncEx</code> library contains a type <code>AsyncManualResetEvent</code>, which is an approximate equivalent of <code>ManualResetEvent</code> for asynchronous code. The following example is fabricated, but it shows how to use the <code>AsyncManualResetEvent</code> type:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">class</code> <code class="nc">MyClass</code>&#13;
<code class="p">{</code>&#13;
  <code class="k">private</code> <code class="k">readonly</code> <code class="n">AsyncManualResetEvent</code> <code class="n">_connected</code> <code class="p">=</code>&#13;
      <code class="k">new</code> <code class="nf">AsyncManualResetEvent</code><code class="p">();</code>&#13;
&#13;
  <code class="k">public</code> <code class="k">async</code> <code class="n">Task</code> <code class="nf">WaitForConnectedAsync</code><code class="p">()</code>&#13;
  <code class="p">{</code>&#13;
    <code class="k">await</code> <code class="n">_connected</code><code class="p">.</code><code class="n">WaitAsync</code><code class="p">();</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="k">public</code> <code class="k">void</code> <code class="nf">ConnectedChanged</code><code class="p">(</code><code class="kt">bool</code> <code class="n">connected</code><code class="p">)</code>&#13;
  <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="n">connected</code><code class="p">)</code>&#13;
      <code class="n">_connected</code><code class="p">.</code><code class="n">Set</code><code class="p">();</code>&#13;
    <code class="k">else</code>&#13;
      <code class="n">_connected</code><code class="p">.</code><code class="n">Reset</code><code class="p">();</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458686589880">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Signals are a general-purpose notification mechanism. But if that “signal” is a <em>message</em>, used to send data from one piece of code to another, then consider using a producer/consumer queue. Similarly, do not use general-purpose signals just to coordinate access to shared data; in that situation, use an asynchronous <a data-startref="ch12r4a" data-type="indexterm" id="idm45458686499816"/><a data-startref="ch12r4b" data-type="indexterm" id="idm45458686499112"/><a data-startref="ch12r4c" data-type="indexterm" id="idm45458686498440"/>lock.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>The <code>AsyncManualResetEvent</code> type is in the <a href="http://bit.ly/nito-async"><code>Nito.AsyncEx</code></a> NuGet package.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458686494952">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="ch09.html#recipe-async-queues">Recipe 9.8</a> covers asynchronous producer/consumer queues.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-async-locks">Recipe 12.2</a> covers asynchronous locks.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-signals">Recipe 12.3</a> covers blocking signals, which can be used for notifications across threads.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="12.5 Throttling" data-type="sect1"><div class="sect1" id="recipe-throttling">&#13;
<h1>12.5 Throttling</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458686488664">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="concurrency" data-secondary="throttling" data-type="indexterm" id="ch12r5a"/><a data-primary="throttling" data-secondary="concurrency" data-type="indexterm" id="ch12r5b"/>have highly concurrent code that is actually <em>too</em> concurrent, and you need some way to throttle the concurrency.</p>&#13;
&#13;
<p>Code is too concurrent when parts of the application are unable to keep up with other parts, causing data items to build up and consume memory. In this scenario, throttling parts of the code can prevent memory issues.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458686483384">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>The solution varies based on the type of concurrency your code is doing. These solutions all restrict concurrency to a specific value. Reactive Extensions has more powerful options, such as sliding time windows; throttling for System.Reactive observables is covered more thoroughly in <a data-type="xref" href="ch06.html#recipe-rx-throttle">Recipe 6.4</a>.</p>&#13;
&#13;
<p>Dataflow <a data-primary="parallel programming" data-secondary="throttling" data-type="indexterm" id="idm45458686559960"/><a data-primary="dataflow" data-secondary="throttling" data-type="indexterm" id="idm45458686558952"/><a data-primary="PLINQ (Parallel LINQ)" data-secondary="throttling" data-type="indexterm" id="idm45458686558008"/>and parallel code all have built-in options for throttling concurrency:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="n">IPropagatorBlock</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">,</code> <code class="kt">int</code><code class="p">&gt;</code> <code class="n">DataflowMultiplyBy2</code><code class="p">()</code>&#13;
<code class="p">{</code>&#13;
  <code class="kt">var</code> <code class="n">options</code> <code class="p">=</code> <code class="k">new</code> <code class="n">ExecutionDataflowBlockOptions</code>&#13;
  <code class="p">{</code>&#13;
    <code class="n">MaxDegreeOfParallelism</code> <code class="p">=</code> <code class="m">10</code>&#13;
  <code class="p">};</code>&#13;
&#13;
  <code class="k">return</code> <code class="k">new</code> <code class="n">TransformBlock</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">,</code> <code class="kt">int</code><code class="p">&gt;(</code><code class="n">data</code> <code class="p">=&gt;</code> <code class="n">data</code> <code class="p">*</code> <code class="m">2</code><code class="p">,</code> <code class="n">options</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Using Parallel LINQ (PLINQ)</code>&#13;
<code class="n">IEnumerable</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">ParallelMultiplyBy2</code><code class="p">(</code><code class="n">IEnumerable</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">values</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="k">return</code> <code class="n">values</code><code class="p">.</code><code class="n">AsParallel</code><code class="p">()</code>&#13;
      <code class="p">.</code><code class="n">WithDegreeOfParallelism</code><code class="p">(</code><code class="m">10</code><code class="p">)</code>&#13;
      <code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">item</code> <code class="p">=&gt;</code> <code class="n">item</code> <code class="p">*</code> <code class="m">2</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Using the Parallel class</code>&#13;
<code class="k">void</code> <code class="nf">ParallelRotateMatrices</code><code class="p">(</code><code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">Matrix</code><code class="p">&gt;</code> <code class="n">matrices</code><code class="p">,</code> <code class="kt">float</code> <code class="n">degrees</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="kt">var</code> <code class="n">options</code> <code class="p">=</code> <code class="k">new</code> <code class="n">ParallelOptions</code>&#13;
  <code class="p">{</code>&#13;
    <code class="n">MaxDegreeOfParallelism</code> <code class="p">=</code> <code class="m">10</code>&#13;
  <code class="p">};</code>&#13;
  <code class="n">Parallel</code><code class="p">.</code><code class="n">ForEach</code><code class="p">(</code><code class="n">matrices</code><code class="p">,</code> <code class="n">options</code><code class="p">,</code> <code class="n">matrix</code> <code class="p">=&gt;</code> <code class="n">matrix</code><code class="p">.</code><code class="n">Rotate</code><code class="p">(</code><code class="n">degrees</code><code class="p">));</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Concurrent <a data-primary="asynchronous programming" data-secondary="throttling" data-type="indexterm" id="idm45458686555448"/><a data-primary="SemaphoreSlim type" data-type="indexterm" id="idm45458686554552"/>asynchronous code can be throttled by using <code>SemaphoreSlim</code>:</p>&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">[]&gt;</code> <code class="n">DownloadUrlsAsync</code><code class="p">(</code><code class="n">HttpClient</code> <code class="n">client</code><code class="p">,</code>&#13;
    <code class="n">IEnumerable</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">urls</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="k">using</code> <code class="k">var</code> <code class="n">semaphore</code> <code class="p">=</code> <code class="k">new</code> <code class="n">SemaphoreSlim</code><code class="p">(</code><code class="m">10</code><code class="p">);</code>&#13;
  <code class="n">Task</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;[]</code> <code class="n">tasks</code> <code class="p">=</code> <code class="n">urls</code><code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="k">async</code> <code class="n">url</code> <code class="p">=&gt;</code>&#13;
  <code class="p">{</code>&#13;
    <code class="k">await</code> <code class="n">semaphore</code><code class="p">.</code><code class="n">WaitAsync</code><code class="p">();</code>&#13;
    <code class="k">try</code>&#13;
    <code class="p">{</code>&#13;
      <code class="k">return</code> <code class="k">await</code> <code class="n">client</code><code class="p">.</code><code class="n">GetStringAsync</code><code class="p">(</code><code class="n">url</code><code class="p">);</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">finally</code>&#13;
    <code class="p">{</code>&#13;
      <code class="n">semaphore</code><code class="p">.</code><code class="n">Release</code><code class="p">();</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}).</code><code class="n">ToArray</code><code class="p">();</code>&#13;
  <code class="k">return</code> <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">WhenAll</code><code class="p">(</code><code class="n">tasks</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458686321512">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Throttling may be necessary when you find your code is using too many resources (for example, CPU or network connections). Bear in mind that end users usually have less powerful machines than developers, so it’s better to throttle by a little too much than not <a data-startref="ch12r5a" data-type="indexterm" id="idm45458686273016"/><a data-startref="ch12r5b" data-type="indexterm" id="idm45458686272312"/>enough.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458686271256">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="ch06.html#recipe-rx-throttle">Recipe 6.4</a> covers throttling for reactive code.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>