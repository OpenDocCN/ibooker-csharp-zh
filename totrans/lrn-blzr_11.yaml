- en: Appendix. Learning Blazor App Projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we’ve examined Learning Blazor, an app created for the book. The
    app consists of several projects that serve as isolated bits of functionality.
    The architecture is discussed in [“Perusing the “Learning Blazor” Sample App”](ch01.html#perusing-the-app).
    The source code can be found on [GitHub](https://oreil.ly/learning-blazor-code).
  prefs: []
  type: TYPE_NORMAL
- en: The *learning-blazor.sln* solution file contains several projects that together
    make up the entire application as a cohesive unit. While each project within the
    solution is responsible for its core functionality, orchestrating projects with
    disparate functionality cohesively is a requirement of any successful application.
    The following sections list the primary projects within the solution and provide
    topical details about them.
  prefs: []
  type: TYPE_NORMAL
- en: Web Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The client application, named simply Web.Client, is a Blazor WebAssembly project
    targeting the `Microsoft.NET.Sdk.BlazorWebAssembly` software development kit (SDK).
    The web project is responsible for all of the user interactions and experiences.
    Through pages, client-side routing, form validation, model binding, and component-based
    UIs, the Web.Client project shows the most major features of Blazor. This app
    defines a `Learning.Blazor` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Web API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The client application would be rather boring if not for data. How do web apps
    get data, you might ask? HTTP is the most common approach, but in addition to
    that, our application is also going to make use of ASP.NET Core SignalR with Web
    Sockets for real-time web functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: ASP.NET Core SignalR is an open source library that simplifies adding real-time
    web functionality to apps. It’s used in the sample source code to exemplify real-time
    functionality. For an overview of SignalR, see Microsoft’s [overview of ASP.NET
    Core SignalR](https://oreil.ly/TrV3W).
  prefs: []
  type: TYPE_NORMAL
- en: Again, the sample app uses the Blazor WebAssembly hosting model, but it’s still
    valuable to show real-time web functionality. As such, ASP.NET Core SignalR is
    used, but not in the same way that was previously described when using the Blazor
    Server hosting model.
  prefs: []
  type: TYPE_NORMAL
- en: There is an ASP.NET Core Web API project, named Web.Api, which targets `Microsoft.NET.Sdk.Web`.
    The project will offer up various endpoints on which the client app will rely.
    The API and SignalR endpoints will be protected by Azure Active Directory (Azure
    AD) business-to-consumer (B2C) authentication.
  prefs: []
  type: TYPE_NORMAL
- en: The Web API project uses an in-memory cache to ensure a responsive experience.
    Selective endpoints rely on services that will deterministically yield data from
    either the cache or the raw-HTTP-dependent endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Pwned Web API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Pwned Web API project also relies on the `Microsoft.NET.Sdk.Web` SDK. This
    project exposes the [“Have I Been Pwned”](https://oreil.ly/X0G2E) service functionality
    from Troy Hunt. After a user has provided consent to allow the application to
    use their email address, it is sent to the Pwned service. The API provides details
    that are used to notify the user if their email has been a part of a data breach.
  prefs: []
  type: TYPE_NORMAL
- en: Web Abstractions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a simple C# class library project targeting `Microsoft.NET.Sdk`, the Web.Abstractions
    project defines a few abstractions that will be shared between the client and
    server apps. These contracts will serve as the glue for the SignalR endpoints.
    From the client’s perspective, these abstractions will provide a discoverability
    set of APIs from which the client can subscribe to events and methods with which
    they can communicate back to the server. From the server’s perspective, these
    abstractions solidify the method and event names, ensuring that there are not
    any possible misalignments. This is extremely important and a common pitfall in
    all JavaScript-based SPA development.
  prefs: []
  type: TYPE_NORMAL
- en: Web Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In modern C# application development, it’s common to encapsulate repetitive
    subroutines into extensions. Due to their repetitive nature, utilitarian extension
    methods are a perfect candidate for a shared class library-style project. In our
    case, we’ll use the Web.Extensions project that targets `Microsoft.NET.Sdk`. This
    project provides functionality that will be used throughout most of our other
    projects within our solution, especially both client and server app scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Web HTTP Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another extensions class library focuses on defining defaults for the `HttpClient`
    type. There are several shared class libraries, all of which were making HTTP
    calls—​I wanted all HTTP calls that fail to have a specific retry policy for handling
    transient errors. These policies are defined within the Web.Http.Extensions project
    that targets `Microsoft.NET.Sdk`.
  prefs: []
  type: TYPE_NORMAL
- en: Web Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Serverless programming has become very prevalent over the past decade. Immutable
    infrastructure, resiliency, and scalability are always highly sought-after features.
    Azure Functions are used to wrap my weather services. I decided to use the Open
    Weather Map API, which is free, supports multiple languages, and is rather accurate.
    With an Azure Function app, I can encapsulate my configuration, protect my API
    keys, use dependency injection, and delegate calls to the weather API. This project
    is named Web.Functions, and it targets `Microsoft.NET.Sdk`.
  prefs: []
  type: TYPE_NORMAL
- en: Web Joke Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Life is too short not to enjoy it—we need to laugh more, crack a smile, and
    not take ourselves so seriously. The Web.JokeServices library is responsible for
    aggregating jokes on a pseudorandom schedule. There are collectively three separate
    and free joke APIs that are aggregated in this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Internet Chuck Norris Database](https://oreil.ly/Dmf7N)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[I Can Haz Dad Joke](https://oreil.ly/LMitC)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Random Programming Joke API](https://oreil.ly/U67QS)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Web.Models project is a *shared* library used by many other projects in
    the solution. It contains all of the models used to represent various domain entities,
    such as shared models by services and clients alike. Anything in the app that
    is interacted with specifies a shape and has members that help to uniquely identify
    itself. This is, of course, at the core of object-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: Web Twitter Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To exemplify component library functionality, I chose to create a Twitter component
    Razor library. It’s named Web.TwitterComponents, and the project relies on the
    `Microsoft.NET.Sdk.Razor` SDK. It provides two components, one representing a
    tweet and the other representing a collection of tweets. This project will demonstrate
    how components are templated; it shows a parent-child hierarchy relationship.
    It shows how components can use JavaScript interop and update from asynchronous
    events.
  prefs: []
  type: TYPE_NORMAL
- en: Web Twitter Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Web​.Twit⁠terServices project is consumed by the Web.Api project, not the
    Web.TwitterComponents project. The Twitter services are used in the context of
    background service. Background services provide a means for managing long-running
    operations that function outside the request and response pipeline. As is the
    case with tweet streaming, as filtered tweets occur in real time, our services
    will propagate them accordingly.
  prefs: []
  type: TYPE_NORMAL
