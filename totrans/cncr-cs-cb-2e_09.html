<html><head></head><body><section data-pdf-bookmark="Chapter 9. Collections" data-type="chapter" epub:type="chapter"><div class="chapter" id="collections">&#13;
<h1><span class="label">Chapter 9. </span>Collections</h1>&#13;
&#13;
&#13;
<p>Using <a data-primary="collections" data-secondary="types of" data-type="indexterm" id="ch9over"/>the proper collections is essential in concurrent applications. I’m not talking about the standard collections like <code>List&lt;T&gt;</code>; I assume you already know about those. The purpose of this chapter is to introduce newer collections that are specifically intended for concurrent or asynchronous use.</p>&#13;
&#13;
<p><em>Immutable collections</em> are <a data-primary="immutable collections" data-secondary="overview" data-type="indexterm" id="idm45458695201208"/>collection instances that can never change. At first glance, this sounds completely useless; but they’re actually very useful, even in single-threaded, nonconcurrent applications. Read-only operations (such as enumeration) act directly on the immutable instance. Write operations (such as adding an item) return a new immutable instance instead of changing the existing instance. This isn’t as wasteful as it first sounds because most of the time immutable collections share most of their memory. Furthermore, immutable collections have the advantage of being implicitly safe to access from multiple threads; since they cannot change, they are threadsafe.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Immutable <a data-primary="immutable collections" data-secondary="libraries for" data-type="indexterm" id="idm45458695198424"/><a data-primary="System.Collections.Immutable library" data-type="indexterm" id="idm45458695197416"/><a data-primary="collections" data-secondary="libraries for" data-type="indexterm" id="idm45458695196776"/>collections are in the <a href="http://bit.ly/sys-coll-imm"><code>System.Collections.Immutable</code></a> NuGet package.</p>&#13;
</div>&#13;
&#13;
<p>Immutable collections are new, but they should be considered for new development unless you <em>need</em> a mutable instance. If you’re not familiar with immutable collections, I recommend that you start with <a data-type="xref" href="#recipe-immutable-stacks-queues">Recipe 9.1</a>, even if you don’t need a stack or queue, because I’ll cover several common patterns that all immutable collections follow.</p>&#13;
&#13;
<p>There are special ways to more efficiently construct an immutable collection with lots of existing elements; the example code in these recipes only adds elements one at a time. The MSDN documentation has details on how to efficiently construct immutable collections if you need to speed up your initialization.</p>&#13;
<dl>&#13;
<dt>Threadsafe collections</dt>&#13;
<dd>&#13;
<p>These <a data-primary="concurrent collections" data-seealso="producer/consumer collections; threadsafe collections" data-type="indexterm" id="idm45458695190376"/><a data-primary="threadsafe collections" data-secondary="overview" data-type="indexterm" id="idm45458695189272"/>mutable collection instances can be changed by multiple threads simultaneously. Threadsafe collections use a mixture of fine-grained locks and lock-free techniques to ensure that threads are blocked for a minimal amount of time (and usually aren’t blocked at all). For many threadsafe collections, enumeration of the collection creates a snapshot of the collection and then enumerates that snapshot. The key advantage of threadsafe collections is that they can be accessed safely from multiple threads, yet the operations will only block your code for a short time, if at all.</p>&#13;
</dd>&#13;
<dt>Producer/consumer collections</dt>&#13;
<dd>&#13;
<p>These <a data-primary="producer/consumer collections" data-secondary="overview" data-type="indexterm" id="idm45458695186360"/>mutable collection instances are designed with a specific purpose in mind: to allow (possibly multiple) producers to push items to the collection while allowing (possibly multiple) consumers to pull items out of the collection. So they act as a bridge between producer code and consumer code, and they also have an option to limit the number of items in the collection. Producer/consumer collections can either have a blocking or asynchronous API. For example, when the collection is empty, a blocking producer/consumer collection will block the calling consumer thread until another item is added; but an asynchronous producer/consumer collection will allow the calling consumer thread to asynchronously wait until another item is added.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>There <a data-primary="producer/consumer collections" data-secondary="list of" data-type="indexterm" id="idm45458695183768"/><a data-primary="Channel type" data-type="indexterm" id="idm45458695182744"/><a data-primary="BlockingCollection type" data-type="indexterm" id="idm45458695182072"/><a data-primary="BufferBlock type" data-type="indexterm" id="idm45458695181400"/><a data-primary="AsyncProducerConsumerQueue type" data-type="indexterm" id="idm45458695180728"/><a data-primary="AsyncCollection type" data-type="indexterm" id="idm45458695180040"/>are a number of different producer/consumer collections used in the recipes in this chapter, and different producer/consumer collections have different advantages. <a data-type="xref" href="#producer_consumer_collect">Table 9-1</a> may be helpful in determining which one you should use.</p>&#13;
<table id="producer_consumer_collect">&#13;
<caption><span class="label">Table 9-1. </span>Producer/consumer collections</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Feature</th>&#13;
<th>Channels</th>&#13;
<th>BlockingCollection&lt;T&gt;</th>&#13;
<th>BufferBlock&lt;T&gt;</th>&#13;
<th>AsyncProducer-ConsumerQueue&lt;T&gt;</th>&#13;
<th>AsyncCollection&lt;T&gt;</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Queue semantics</p></td>&#13;
<td><p>✓</p></td>&#13;
<td><p>✓</p></td>&#13;
<td><p>✓</p></td>&#13;
<td><p>✓</p></td>&#13;
<td><p>✓</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Stack/bag semantics</p></td>&#13;
<td><p>✗</p></td>&#13;
<td><p>✓</p></td>&#13;
<td><p>✗</p></td>&#13;
<td><p>✗</p></td>&#13;
<td><p>✓</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Synchronous API</p></td>&#13;
<td><p>✓</p></td>&#13;
<td><p>✓</p></td>&#13;
<td><p>✓</p></td>&#13;
<td><p>✓</p></td>&#13;
<td><p>✓</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Asynchronous API</p></td>&#13;
<td><p>✓</p></td>&#13;
<td><p>✗</p></td>&#13;
<td><p>✓</p></td>&#13;
<td><p>✓</p></td>&#13;
<td><p>✓</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Drop items when full</p></td>&#13;
<td><p>✓</p></td>&#13;
<td><p>✗</p></td>&#13;
<td><p>✗</p></td>&#13;
<td><p>✗</p></td>&#13;
<td><p>✗</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Tested by Microsoft</p></td>&#13;
<td><p>✓</p></td>&#13;
<td><p>✓</p></td>&#13;
<td><p>✓</p></td>&#13;
<td><p>✗</p></td>&#13;
<td><p>✗</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Channels <a data-primary="collections" data-secondary="libraries for" data-type="indexterm" id="idm45458695147688"/>can be found in the <a href="http://bit.ly/sys-thrd-chanls"><code>System.Threading.Channels</code></a> NuGet package,&#13;
<code>BufferBlock&lt;T&gt;</code> in the NuGet package for  <a href="http://bit.ly/nuget-df"><code>System.Threading.Tasks.Dataflow</code></a>, and <code>AsyncProducerConsumerQueue&lt;T&gt;</code> and <code>AsyncCollection&lt;T&gt;</code> in the NuGet <a data-startref="ch9over" data-type="indexterm" id="idm45458695143704"/>package for <a href="http://bit.ly/nito-async"><code>Nito.AsyncEx</code></a>.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="9.1 Immutable Stacks and Queues" data-type="sect1"><div class="sect1" id="recipe-immutable-stacks-queues">&#13;
<h1>9.1 Immutable Stacks and Queues</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458695140200">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="immutable collections" data-secondary="stacks" data-type="indexterm" id="ch9r1a"/><a data-primary="stacks" data-secondary="immutable" data-type="indexterm" id="ch9r1b"/><a data-primary="immutable collections" data-secondary="queues" data-type="indexterm" id="ch9r1c"/><a data-primary="queues" data-secondary="immutable" data-type="indexterm" id="ch9r1d"/>need a stack or queue that does not change very often and can be accessed by multiple threads safely.</p>&#13;
&#13;
<p>For example, a queue can be used as a sequence of operations to perform, and a stack can be used as a sequence of undo operations.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458695132920">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Immutable stacks and queues are the simplest immutable collections. They behave very similarly to the standard <code>Stack&lt;T&gt;</code> and <code>Queue&lt;T&gt;</code>. Performance-wise, immutable stacks and queues have the same time complexity as standard stacks and queues; however, in simple scenarios where the collections are updated frequently, the standard stacks and queues are faster.</p>&#13;
&#13;
<p>Stacks <a data-primary="ImmutableStack type" data-type="indexterm" id="idm45458695129768"/>are a first-in, last-out data structure. The following code creates an empty immutable stack, pushes two items, enumerates the items, and then pops an item:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="n">ImmutableStack</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">stack</code> <code class="p">=</code> <code class="n">ImmutableStack</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;.</code><code class="n">Empty</code><code class="p">;</code>&#13;
<code class="n">stack</code> <code class="p">=</code> <code class="n">stack</code><code class="p">.</code><code class="n">Push</code><code class="p">(</code><code class="m">13</code><code class="p">);</code>&#13;
<code class="n">stack</code> <code class="p">=</code> <code class="n">stack</code><code class="p">.</code><code class="n">Push</code><code class="p">(</code><code class="m">7</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// Displays "7" followed by "13".</code>&#13;
<code class="k">foreach</code> <code class="p">(</code><code class="kt">int</code> <code class="n">item</code> <code class="k">in</code> <code class="n">stack</code><code class="p">)</code>&#13;
  <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">item</code><code class="p">);</code>&#13;
&#13;
<code class="kt">int</code> <code class="n">lastItem</code><code class="p">;</code>&#13;
<code class="n">stack</code> <code class="p">=</code> <code class="n">stack</code><code class="p">.</code><code class="n">Pop</code><code class="p">(</code><code class="k">out</code> <code class="n">lastItem</code><code class="p">);</code>&#13;
<code class="c1">// lastItem == 7</code></pre>&#13;
&#13;
<p>Note in the example that we keep overwriting the local variable <code>stack</code>. Immutable collections follow a pattern where they return an updated collection; the original collection reference is unchanged. This means that once you have a reference to a particular immutable collection instance, it’ll never change. Consider the following example:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="n">ImmutableStack</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">stack</code> <code class="p">=</code> <code class="n">ImmutableStack</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;.</code><code class="n">Empty</code><code class="p">;</code>&#13;
<code class="n">stack</code> <code class="p">=</code> <code class="n">stack</code><code class="p">.</code><code class="n">Push</code><code class="p">(</code><code class="m">13</code><code class="p">);</code>&#13;
<code class="n">ImmutableStack</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">biggerStack</code> <code class="p">=</code> <code class="n">stack</code><code class="p">.</code><code class="n">Push</code><code class="p">(</code><code class="m">7</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// Displays "7" followed by "13".</code>&#13;
<code class="k">foreach</code> <code class="p">(</code><code class="kt">int</code> <code class="n">item</code> <code class="k">in</code> <code class="n">biggerStack</code><code class="p">)</code>&#13;
  <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">item</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// Only displays "13".</code>&#13;
<code class="k">foreach</code> <code class="p">(</code><code class="kt">int</code> <code class="n">item</code> <code class="k">in</code> <code class="n">stack</code><code class="p">)</code>&#13;
  <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">item</code><code class="p">);</code></pre>&#13;
&#13;
<p>Under the covers, the two stacks are sharing the memory used to contain the item <code>13</code>. This kind of implementation is very efficient while enabling you to easily snapshot the current state. Each immutable collection instance is naturally threadsafe, but immutable collections can also be used in single-threaded applications. In my experience, immutable collections are especially useful when the code is more functional or when you need to store a large number of snapshots and want them to share memory as much as possible.</p>&#13;
&#13;
<p>Queues <a data-primary="ImmutableQueue type" data-type="indexterm" id="idm45458694976168"/>are similar to stacks, except they are a first-in, first-out data structure. The following code creates an empty immutable queue, enqueues two items, enumerates the items, and then dequeues an item:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="n">ImmutableQueue</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">queue</code> <code class="p">=</code> <code class="n">ImmutableQueue</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;.</code><code class="n">Empty</code><code class="p">;</code>&#13;
<code class="n">queue</code> <code class="p">=</code> <code class="n">queue</code><code class="p">.</code><code class="n">Enqueue</code><code class="p">(</code><code class="m">13</code><code class="p">);</code>&#13;
<code class="n">queue</code> <code class="p">=</code> <code class="n">queue</code><code class="p">.</code><code class="n">Enqueue</code><code class="p">(</code><code class="m">7</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// Displays "13" followed by "7".</code>&#13;
<code class="k">foreach</code> <code class="p">(</code><code class="kt">int</code> <code class="n">item</code> <code class="k">in</code> <code class="n">queue</code><code class="p">)</code>&#13;
  <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">item</code><code class="p">);</code>&#13;
&#13;
<code class="kt">int</code> <code class="n">nextItem</code><code class="p">;</code>&#13;
<code class="n">queue</code> <code class="p">=</code> <code class="n">queue</code><code class="p">.</code><code class="n">Dequeue</code><code class="p">(</code><code class="k">out</code> <code class="n">nextItem</code><code class="p">);</code>&#13;
<code class="c1">// Displays "13".</code>&#13;
<code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">nextItem</code><code class="p">);</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458694941784">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>This <a data-primary="immutable collections" data-secondary="overview" data-type="indexterm" id="idm45458694876504"/>recipe introduced the two simplest immutable collections, the stack and the queue. It also covered several important design philosophies that are true for <em>all</em> immutable collections:</p>&#13;
<div class="openblock">&#13;
<ul>&#13;
<li>&#13;
<p>An instance of an immutable collection never changes.</p>&#13;
</li>&#13;
<li>&#13;
<p>Since it never changes, it is naturally threadsafe.</p>&#13;
</li>&#13;
<li>&#13;
<p>When you call a modifying method on an immutable collection, the new modified collection is returned.</p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Even <a data-primary="threadsafe collections" data-secondary="immutable collections as" data-type="indexterm" id="idm45458694869832"/>though immutable collections are threadsafe, <em>references</em> to immutable collections are <em>not</em> threadsafe. A variable that refers to an immutable collection needs the same synchronization protections as any other variable (see <a data-type="xref" href="ch12.html#synchronization">Chapter 12</a>).</p>&#13;
</div>&#13;
&#13;
<p>Immutable collections are ideal for sharing state. They don’t, however, work as well as communication conduits. In particular, don’t use an immutable queue to communicate between threads; producer/consumer queues work much better for <a data-startref="ch9r1a" data-type="indexterm" id="idm45458694866088"/><a data-startref="ch9r1b" data-type="indexterm" id="idm45458694865384"/><a data-startref="ch9r1c" data-type="indexterm" id="idm45458694864712"/><a data-startref="ch9r1d" data-type="indexterm" id="idm45458694864040"/>that.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p><code>ImmutableStack&lt;T&gt;</code> and <code>ImmutableQueue&lt;T&gt;</code> can be found in the <a href="http://bit.ly/sys-coll-imm"><code>System.Collections.Immutable</code></a> NuGet package.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458694860392">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="#recipe-blocking-queues">Recipe 9.6</a> covers threadsafe (blocking) mutable queues.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-blocking-stacks-bags">Recipe 9.7</a> covers threadsafe (blocking) mutable stacks.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-async-queues">Recipe 9.8</a> covers async-compatible mutable queues.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-async-stacks-bags">Recipe 9.11</a> covers async-compatible mutable stacks.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-blocking-async-queues">Recipe 9.12</a> covers blocking/asynchronous mutable queues.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="9.2 Immutable Lists" data-type="sect1"><div class="sect1" id="recipe-immutable-lists">&#13;
<h1>9.2 Immutable Lists</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458694851624">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="immutable collections" data-secondary="lists" data-type="indexterm" id="ch9r2a"/><a data-primary="lists, immutable" data-type="indexterm" id="ch9r2b"/>need a data structure you can index into that does not change very often and can be accessed by multiple threads safely.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458694847512">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>A list is a general-purpose data structure that can be used for all kinds of application states. Immutable lists do allow indexing, but you need to be aware of the performance characteristics. They’re not just a drop-in replacement for <code>List&lt;T&gt;</code>.</p>&#13;
&#13;
<p><code>ImmutableList&lt;T&gt;</code> <a data-primary="ImmutableList type" data-type="indexterm" id="idm45458694844568"/>does support similar methods as <code>List&lt;T&gt;</code>, as the following example shows:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="n">ImmutableList</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">list</code> <code class="p">=</code> <code class="n">ImmutableList</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;.</code><code class="n">Empty</code><code class="p">;</code>&#13;
<code class="n">list</code> <code class="p">=</code> <code class="n">list</code><code class="p">.</code><code class="n">Insert</code><code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="m">13</code><code class="p">);</code>&#13;
<code class="n">list</code> <code class="p">=</code> <code class="n">list</code><code class="p">.</code><code class="n">Insert</code><code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="m">7</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// Displays "7" followed by "13".</code>&#13;
<code class="k">foreach</code> <code class="p">(</code><code class="kt">int</code> <code class="n">item</code> <code class="k">in</code> <code class="n">list</code><code class="p">)</code>&#13;
  <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">item</code><code class="p">);</code>&#13;
&#13;
<code class="n">list</code> <code class="p">=</code> <code class="n">list</code><code class="p">.</code><code class="n">RemoveAt</code><code class="p">(</code><code class="m">1</code><code class="p">);</code></pre>&#13;
&#13;
<p>The immutable list is internally organized as a binary tree so that immutable list instances may maximize the amount of memory they share with other instances. As a result, there are performance differences between <code>ImmutableList&lt;T&gt;</code> and <code>List&lt;T&gt;</code> for some common operations (<a data-type="xref" href="#performance_imm_lists">Table 9-2</a>).</p>&#13;
<table id="performance_imm_lists">&#13;
<caption><span class="label">Table 9-2. </span>Performance difference of immutable lists</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Operation</th>&#13;
<th>List&lt;T&gt;</th>&#13;
<th>ImmutableList&lt;T&gt;</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Add</p></td>&#13;
<td><p>amortized O(1)</p></td>&#13;
<td><p>O(log N)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Insert</p></td>&#13;
<td><p>O(N)</p></td>&#13;
<td><p>O(log N)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>RemoveAt</p></td>&#13;
<td><p>O(N)</p></td>&#13;
<td><p>O(log N)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Item[index]</p></td>&#13;
<td><p>O(1)</p></td>&#13;
<td><p>O(log N)</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Of note, the indexing operation for <code>ImmutableList&lt;T&gt;</code> is O(log N), not O(1), as you may expect. If you’re replacing <code>List&lt;T&gt;</code> with <code>ImmutableList&lt;T&gt;</code> in existing code, you’ll need to consider how your algorithms access items in the collection.</p>&#13;
&#13;
<p>This means that you should use <code>foreach</code> instead of <code>for</code> whenever possible. A <code>foreach</code> loop over an <code>ImmutableList&lt;T&gt;</code> executes in O(N) time, while a <code>for</code> loop over the same collection executes in O(N * log N) time:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="c1">// The best way to iterate over an ImmutableList&lt;T&gt;.</code>&#13;
<code class="k">foreach</code> <code class="p">(</code><code class="kt">var</code> <code class="n">item</code> <code class="k">in</code> <code class="n">list</code><code class="p">)</code>&#13;
  <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">item</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// This will also work, but it will be much slower.</code>&#13;
<code class="k">for</code> <code class="p">(</code><code class="kt">int</code> <code class="n">i</code> <code class="p">=</code> <code class="m">0</code><code class="p">;</code> <code class="n">i</code> <code class="p">!=</code> <code class="n">list</code><code class="p">.</code><code class="n">Count</code><code class="p">;</code> <code class="p">++</code><code class="n">i</code><code class="p">)</code>&#13;
  <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">list</code><code class="p">[</code><code class="n">i</code><code class="p">]);</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458694616056">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p><code>ImmutableList&lt;T&gt;</code> is a good general-purpose data structure, but because of its performance differences, you can’t blindly replace all your <code>List&lt;T&gt;</code> uses with it. <code>List&lt;T&gt;</code> is commonly used by default—it’s the one you use unless you <em>need</em> a different collection. <code>ImmutableList&lt;T&gt;</code> isn’t quite that ubiquitous; you’ll need to consider the other immutable collections carefully and choose the one that makes the most sense for your <a data-startref="ch9r2a" data-type="indexterm" id="idm45458694656120"/><a data-startref="ch9r2b" data-type="indexterm" id="idm45458694655416"/>situation.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p><code>ImmutableList&lt;T&gt;</code> is in the <a href="http://bit.ly/sys-coll-imm"><code>System.Collections.Immutable</code></a> NuGet package.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458694652216">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="#recipe-immutable-stacks-queues">Recipe 9.1</a> covers immutable stacks and queues, which are like lists that only allow certain elements to be accessed.</p>&#13;
&#13;
<p>The<a data-primary="online resources" data-secondary="immutable lists" data-type="indexterm" id="idm45458694649736"/> <a href="http://bit.ly/msdn-iml">MSDN documentation on <code>ImmutableList&lt;T&gt;.Builder</code></a> covers an efficient way to populate an immutable list.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="9.3 Immutable Sets" data-type="sect1"><div class="sect1" id="recipe-immutable-sets">&#13;
<h1>9.3 Immutable Sets</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458694645608">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="sets, immutable" data-type="indexterm" id="ch9r3a"/><a data-primary="immutable collections" data-secondary="sets, hash and sorted" data-type="indexterm" id="ch9r3b"/><a data-primary="hash sets" data-type="indexterm" id="ch9r3c"/><a data-primary="sorted sets" data-type="indexterm" id="ch9r3d"/>need a data structure that does not need to store duplicates, does not change very often, and can be accessed by multiple threads safely.</p>&#13;
&#13;
<p>For example, an index of words from a file would be a good use case for a set.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458694639208">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>There <a data-primary="ImmutableHashSet type" data-type="indexterm" id="idm45458694637640"/><a data-primary="ImmutableSortedSet type" data-type="indexterm" id="idm45458694636904"/>are two immutable set types: <code>ImmutableHashSet&lt;T&gt;</code> is a collection of unique items, and <code>ImmutableSortedSet&lt;T&gt;</code> is a <em>sorted</em> collection of unique items. Both types have a similar interface:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="n">ImmutableHashSet</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">hashSet</code> <code class="p">=</code> <code class="n">ImmutableHashSet</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;.</code><code class="n">Empty</code><code class="p">;</code>&#13;
<code class="n">hashSet</code> <code class="p">=</code> <code class="n">hashSet</code><code class="p">.</code><code class="n">Add</code><code class="p">(</code><code class="m">13</code><code class="p">);</code>&#13;
<code class="n">hashSet</code> <code class="p">=</code> <code class="n">hashSet</code><code class="p">.</code><code class="n">Add</code><code class="p">(</code><code class="m">7</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// Displays "7" and "13" in an unpredictable order.</code>&#13;
<code class="k">foreach</code> <code class="p">(</code><code class="kt">int</code> <code class="n">item</code> <code class="k">in</code> <code class="n">hashSet</code><code class="p">)</code>&#13;
  <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">item</code><code class="p">);</code>&#13;
&#13;
<code class="n">hashSet</code> <code class="p">=</code> <code class="n">hashSet</code><code class="p">.</code><code class="n">Remove</code><code class="p">(</code><code class="m">7</code><code class="p">);</code></pre>&#13;
&#13;
<p>Only the sorted set allows indexing into it like a list:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="n">ImmutableSortedSet</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">sortedSet</code> <code class="p">=</code> <code class="n">ImmutableSortedSet</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;.</code><code class="n">Empty</code><code class="p">;</code>&#13;
<code class="n">sortedSet</code> <code class="p">=</code> <code class="n">sortedSet</code><code class="p">.</code><code class="n">Add</code><code class="p">(</code><code class="m">13</code><code class="p">);</code>&#13;
<code class="n">sortedSet</code> <code class="p">=</code> <code class="n">sortedSet</code><code class="p">.</code><code class="n">Add</code><code class="p">(</code><code class="m">7</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// Displays "7" followed by "13".</code>&#13;
<code class="k">foreach</code> <code class="p">(</code><code class="kt">int</code> <code class="n">item</code> <code class="k">in</code> <code class="n">sortedSet</code><code class="p">)</code>&#13;
  <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">item</code><code class="p">);</code>&#13;
<code class="kt">int</code> <code class="n">smallestItem</code> <code class="p">=</code> <code class="n">sortedSet</code><code class="p">[</code><code class="m">0</code><code class="p">];</code>&#13;
<code class="c1">// smallestItem == 7</code>&#13;
&#13;
<code class="n">sortedSet</code> <code class="p">=</code> <code class="n">sortedSet</code><code class="p">.</code><code class="n">Remove</code><code class="p">(</code><code class="m">7</code><code class="p">);</code></pre>&#13;
&#13;
<p>Unsorted sets and sorted sets have similar performance (see <a data-type="xref" href="#performance_of_sets">Table 9-3</a>).</p>&#13;
<table id="performance_of_sets">&#13;
<caption><span class="label">Table 9-3. </span>Performance of immutable sets</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Operation</th>&#13;
<th>ImmutableHashSet&lt;T&gt;</th>&#13;
<th>ImmutableSortedSet&lt;T&gt;</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Add</p></td>&#13;
<td><p>O(log N)</p></td>&#13;
<td><p>O(log N)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Remove</p></td>&#13;
<td><p>O(log N)</p></td>&#13;
<td><p>O(log N)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Item[index]</p></td>&#13;
<td><p>n/a</p></td>&#13;
<td><p>O(log N)</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>However, I recommend you use an unsorted set unless you know it needs to be sorted. Many types only support basic equality and not full comparison, so an unsorted set can be used for many more types than a sorted set.</p>&#13;
&#13;
<p>One important note about the sorted set is that its indexing is O(log N), not O(1), just like <code>ImmutableList&lt;T&gt;</code>, which is covered in <a data-type="xref" href="#recipe-immutable-lists">Recipe 9.2</a>. This means that the same caveat applies in this situation: you should use <code>foreach</code> instead of <code>for</code> whenever possible with an <code>ImmutableSortedSet&lt;T&gt;</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458694450184">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Immutable sets are useful data structures, but populating a large immutable set can be slow. Most immutable collections have special builders that can be used to construct them quickly in a mutable way and then convert them into an immutable collection. This is true for many immutable collections, but I’ve found them most useful for immutable <a data-startref="ch9r3a" data-type="indexterm" id="idm45458694448456"/><a data-startref="ch9r3b" data-type="indexterm" id="idm45458694447752"/><a data-startref="ch9r3c" data-type="indexterm" id="idm45458694447080"/><a data-startref="ch9r3d" data-type="indexterm" id="idm45458694446408"/>sets.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p><code>ImmutableHashSet&lt;T&gt;</code> and <code>ImmutableSortedSet&lt;T&gt;</code> are in the NuGet <a href="http://bit.ly/sys-coll-imm"><code>System.Collections.Immutable</code></a> package.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458694442632">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="#recipe-blocking-stacks-bags">Recipe 9.7</a> covers threadsafe mutable bags, which are similar to sets.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-async-stacks-bags">Recipe 9.11</a> covers async-compatible mutable bags.</p>&#13;
&#13;
<p>The<a data-primary="online resources" data-secondary="immutable sets" data-type="indexterm" id="idm45458694438984"/> <a href="http://bit.ly/msdn-imh">MSDN documentation on <code>ImmutableHashSet&lt;T&gt;.Builder</code></a> covers an efficient way to populate an immutable hash set.</p>&#13;
&#13;
<p>The <a href="http://bit.ly/msdn-ims">MSDN documentation on <code>ImmutableSortedSet&lt;T&gt;.Builder</code></a> covers an efficient way to populate an immutable sorted set.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="9.4 Immutable Dictionaries" data-type="sect1"><div class="sect1" id="recipe-immutable-dictionaries">&#13;
<h1>9.4 Immutable Dictionaries</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458694433656">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="immutable collections" data-secondary="dictionaries, sorted and unsorted" data-type="indexterm" id="ch9r4a"/><a data-primary="dictionaries" data-secondary="immutable, sorted and unsorted" data-type="indexterm" id="ch9r4b"/>need a key/value collection that does not change very often and can be accessed by multiple threads safely. For example, you may want to store reference data in a <em>lookup collection</em>; the reference data rarely changes but should be available to different threads.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458694428824">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>There <a data-primary="ImmutableDictionary type" data-type="indexterm" id="idm45458694427032"/><a data-primary="ImmutableSortedDictionary type" data-type="indexterm" id="idm45458694426328"/>are two immutable dictionary types: <code>ImmutableDictionary&lt;TKey, TValue&gt;</code> and <code>ImmutableSortedDictionary&lt;TKey, TValue&gt;</code>. As you may be able to guess from their names, while the items in <code>ImmutableDictionary</code> have an unpredictable order, <code>ImmutableSortedDictionary</code> ensures that its elements are sorted.</p>&#13;
&#13;
<p>Both of these collection types have very similar members:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="n">ImmutableDictionary</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">,</code> <code class="kt">string</code><code class="p">&gt;</code> <code class="n">dictionary</code> <code class="p">=</code>&#13;
    <code class="n">ImmutableDictionary</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">,</code> <code class="kt">string</code><code class="p">&gt;.</code><code class="n">Empty</code><code class="p">;</code>&#13;
<code class="n">dictionary</code> <code class="p">=</code> <code class="n">dictionary</code><code class="p">.</code><code class="n">Add</code><code class="p">(</code><code class="m">10</code><code class="p">,</code> <code class="s">"Ten"</code><code class="p">);</code>&#13;
<code class="n">dictionary</code> <code class="p">=</code> <code class="n">dictionary</code><code class="p">.</code><code class="n">Add</code><code class="p">(</code><code class="m">21</code><code class="p">,</code> <code class="s">"Twenty-One"</code><code class="p">);</code>&#13;
<code class="n">dictionary</code> <code class="p">=</code> <code class="n">dictionary</code><code class="p">.</code><code class="n">SetItem</code><code class="p">(</code><code class="m">10</code><code class="p">,</code> <code class="s">"Diez"</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// Displays "10Diez" and "21Twenty-One" in an unpredictable order.</code>&#13;
<code class="k">foreach</code> <code class="p">(</code><code class="n">KeyValuePair</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">,</code> <code class="kt">string</code><code class="p">&gt;</code> <code class="n">item</code> <code class="k">in</code> <code class="n">dictionary</code><code class="p">)</code>&#13;
  <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">item</code><code class="p">.</code><code class="n">Key</code> <code class="p">+</code> <code class="n">item</code><code class="p">.</code><code class="n">Value</code><code class="p">);</code>&#13;
&#13;
<code class="kt">string</code> <code class="n">ten</code> <code class="p">=</code> <code class="n">dictionary</code><code class="p">[</code><code class="m">10</code><code class="p">];</code>&#13;
<code class="c1">// ten == "Diez"</code>&#13;
&#13;
<code class="n">dictionary</code> <code class="p">=</code> <code class="n">dictionary</code><code class="p">.</code><code class="n">Remove</code><code class="p">(</code><code class="m">21</code><code class="p">);</code></pre>&#13;
&#13;
<p>Note the use of <code>SetItem</code>. In a mutable dictionary, you could try doing something like <code>dictionary[key] = item</code>, but immutable dictionaries must return the updated immutable dictionary, so they use the <code>SetItem</code> method instead:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="n">ImmutableSortedDictionary</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">,</code> <code class="kt">string</code><code class="p">&gt;</code> <code class="n">sortedDictionary</code> <code class="p">=</code>&#13;
    <code class="n">ImmutableSortedDictionary</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">,</code> <code class="kt">string</code><code class="p">&gt;.</code><code class="n">Empty</code><code class="p">;</code>&#13;
<code class="n">sortedDictionary</code> <code class="p">=</code> <code class="n">sortedDictionary</code><code class="p">.</code><code class="n">Add</code><code class="p">(</code><code class="m">10</code><code class="p">,</code> <code class="s">"Ten"</code><code class="p">);</code>&#13;
<code class="n">sortedDictionary</code> <code class="p">=</code> <code class="n">sortedDictionary</code><code class="p">.</code><code class="n">Add</code><code class="p">(</code><code class="m">21</code><code class="p">,</code> <code class="s">"Twenty-One"</code><code class="p">);</code>&#13;
<code class="n">sortedDictionary</code> <code class="p">=</code> <code class="n">sortedDictionary</code><code class="p">.</code><code class="n">SetItem</code><code class="p">(</code><code class="m">10</code><code class="p">,</code> <code class="s">"Diez"</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// Displays "10Diez" followed by "21Twenty-One".</code>&#13;
<code class="k">foreach</code> <code class="p">(</code><code class="n">KeyValuePair</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">,</code> <code class="kt">string</code><code class="p">&gt;</code> <code class="n">item</code> <code class="k">in</code> <code class="n">sortedDictionary</code><code class="p">)</code>&#13;
  <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">item</code><code class="p">.</code><code class="n">Key</code> <code class="p">+</code> <code class="n">item</code><code class="p">.</code><code class="n">Value</code><code class="p">);</code>&#13;
&#13;
<code class="kt">string</code> <code class="n">ten</code> <code class="p">=</code> <code class="n">sortedDictionary</code><code class="p">[</code><code class="m">10</code><code class="p">];</code>&#13;
<code class="c1">// ten == "Diez"</code>&#13;
&#13;
<code class="n">sortedDictionary</code> <code class="p">=</code> <code class="n">sortedDictionary</code><code class="p">.</code><code class="n">Remove</code><code class="p">(</code><code class="m">21</code><code class="p">);</code></pre>&#13;
&#13;
<p>Unsorted dictionaries and sorted dictionaries have similar performance, but I recommend you use an unordered dictionary unless you need your elements to be sorted (see <a data-type="xref" href="#performance_dictionaries">Table 9-4</a>). Unsorted dictionaries can be a little faster overall. Furthermore, unsorted dictionaries can be used with any key types, whereas sorted dictionaries require their key types to be fully comparable.</p>&#13;
<table id="performance_dictionaries">&#13;
<caption><span class="label">Table 9-4. </span>Performance of immutable dictionaries</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Operation</th>&#13;
<th>ImmutableDictionary&lt;TK,TV&gt;</th>&#13;
<th>ImmutableSortedDictionary&lt;TK,TV&gt;</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Add</p></td>&#13;
<td><p>O(log N)</p></td>&#13;
<td><p>O(log N)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>SetItem</p></td>&#13;
<td><p>O(log N)</p></td>&#13;
<td><p>O(log N)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Item[key]</p></td>&#13;
<td><p>O(log N)</p></td>&#13;
<td><p>O(log N)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Remove</p></td>&#13;
<td><p>O(log N)</p></td>&#13;
<td><p>O(log N)</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458694141672">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>In my experience, dictionaries are a common and useful tool when dealing with application state. They can be used in any kind of key/value or lookup scenario.</p>&#13;
&#13;
<p>Like other immutable collections, immutable dictionaries have a builder mechanism for efficient construction if the dictionary contains many elements. For example, if you load your initial reference data at startup, you should use the builder mechanism to construct the initial immutable dictionary. On the other hand, if your reference data is gradually built up during your application’s execution, then using the regular immutable dictionary <code>Add</code> method is likely <a data-startref="ch9r4a" data-type="indexterm" id="idm45458694138872"/><a data-startref="ch9r4b" data-type="indexterm" id="idm45458694138136"/>acceptable.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p><code>ImmutableDictionary&lt;TK, TV&gt;</code> and <code>ImmutableSortedDictionary&lt;TK, TV&gt;</code> are in the <a href="http://bit.ly/sys-coll-imm"><code>System.Collections.Immutable</code></a> NuGet package.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458694134280">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="#recipe-threadsafe-dictionaries">Recipe 9.5</a> covers threadsafe mutable dictionaries.</p>&#13;
&#13;
<p>The<a data-primary="online resources" data-secondary="immutable dictionaries" data-type="indexterm" id="idm45458694131768"/> <a href="http://bit.ly/msdn-imd">MSDN documentation on <code>ImmutableDictionary&lt;TK,TV&gt;.Builder</code></a> covers an efficient way to populate an immutable dictionary.</p>&#13;
&#13;
<p>The <a href="http://bit.ly/msdn-isd">MSDN documentation on <code>ImmutableSortedDictionary&lt;TK,TV&gt;.Builder</code></a> covers an efficient way to populate an immutable sorted dictionary.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="9.5 Threadsafe Dictionaries" data-type="sect1"><div class="sect1" id="recipe-threadsafe-dictionaries">&#13;
<h1>9.5 Threadsafe Dictionaries</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458694126168">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="threadsafe collections" data-secondary="dictionaries" data-type="indexterm" id="ch9r5a"/><a data-primary="dictionaries" data-secondary="threadsafe" data-type="indexterm" id="ch9r5b"/>have a key/value collection (e.g., an in-memory cache) that you need to keep in sync, even though multiple threads are both reading from and writing to it.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458694121752">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>The<a data-primary="ConcurrentDictionary type" data-type="indexterm" id="idm45458694120056"/> <code>ConcurrentDictionary&lt;TKey, TValue&gt;</code> type in the .NET framework is a true gem of a data structure. It’s threadsafe, using a mixture of fine-grained locks and lock-free techniques to ensure fast access in the vast majority of scenarios.</p>&#13;
&#13;
<p>Its API does take a bit of getting used to. It’s very different from the standard <code>Dictionary&lt;TKey, TValue&gt;</code> type, since it must deal with concurrent access from multiple threads. But once you have learned the basics in this recipe, you’ll find <code>ConcurrentDictionary&lt;TKey, TValue&gt;</code> to be one of the most useful collection types.</p>&#13;
&#13;
<p>First, let’s learn how to write a value to the collection. To set the value of a key, you can use <code>AddOrUpdate</code>:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">dictionary</code> <code class="p">=</code> <code class="k">new</code> <code class="n">ConcurrentDictionary</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">,</code> <code class="kt">string</code><code class="p">&gt;();</code>&#13;
<code class="kt">string</code> <code class="n">newValue</code> <code class="p">=</code> <code class="n">dictionary</code><code class="p">.</code><code class="n">AddOrUpdate</code><code class="p">(</code><code class="m">0</code><code class="p">,</code>&#13;
    <code class="n">key</code> <code class="p">=&gt;</code> <code class="s">"Zero"</code><code class="p">,</code>&#13;
    <code class="p">(</code><code class="n">key</code><code class="p">,</code> <code class="n">oldValue</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="s">"Zero"</code><code class="p">);</code></pre>&#13;
&#13;
<p><code>AddOrUpdate</code> is a bit complex because it must do several things, depending on the current contents of the concurrent dictionary. The first method argument is the key. The second argument is a delegate that transforms the key (in this case, <code>0</code>) into a value to be added to the dictionary (in this case, <code>"Zero"</code>). This delegate is only invoked if the key doesn’t exist in the dictionary. The third argument is another delegate that transforms the key (<code>0</code>) and the old value into an updated value to be stored in the dictionary (<code>"Zero"</code>). This delegate is only invoked if the key does exist in the dictionary. <code>AddOrUpdate</code> returns the new value for that key (the same value that was returned by one of the delegates).</p>&#13;
&#13;
<p>Now for the part that really bends your brain: in order for the concurrent dictionary to work properly, <code>AddOrUpdate</code> <em>might</em> have to invoke either (or both) delegates multiple times. This is very rare, but it <em>can</em> happen. So your delegates should be simple and fast and not cause side effects. This means that your delegate should only create the value; it shouldn’t change any other variables in your application. The same principle holds for all delegates you pass to methods on <code>ConcurrentDictionary&lt;TKey, TValue&gt;</code>.</p>&#13;
&#13;
<p>There are several other ways to add values to a dictionary. One shortcut is to just use indexing syntax:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="c1">// Using the same "dictionary" as above.</code>&#13;
<code class="c1">// Adds (or updates) key 0 to have the value "Zero".</code>&#13;
<code class="n">dictionary</code><code class="p">[</code><code class="m">0</code><code class="p">]</code> <code class="p">=</code> <code class="s">"Zero"</code><code class="p">;</code></pre>&#13;
&#13;
<p>Indexing syntax is less powerful; it doesn’t give you the ability to update a value based on the existing value. The syntax is simpler and works fine, however, if you already have the value you want to store in the dictionary.</p>&#13;
&#13;
<p>Let’s look at how to read a value. This can be easily done via <code>TryGetValue</code>:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="c1">// Using the same "dictionary" as above.</code>&#13;
<code class="kt">bool</code> <code class="n">keyExists</code> <code class="p">=</code> <code class="n">dictionary</code><code class="p">.</code><code class="n">TryGetValue</code><code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="k">out</code> <code class="kt">string</code> <code class="n">currentValue</code><code class="p">);</code></pre>&#13;
&#13;
<p><code>TryGetValue</code> will return <code>true</code> and set the <code>out</code> value if the key was found in the dictionary. If the key wasn’t found, <code>TryGetValue</code> will return <code>false</code>. You can also use indexing syntax to read values, but I find that much less useful because it’ll throw an exception if a key isn’t found. Keep in mind that a concurrent dictionary has multiple threads reading, updating, adding, and removing values; in many situations, it’s difficult to know whether a key exists or not until you attempt to read it.</p>&#13;
&#13;
<p>Removing values is just as easy as reading them:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="c1">// Using the same "dictionary" as above.</code>&#13;
<code class="kt">bool</code> <code class="n">keyExisted</code> <code class="p">=</code> <code class="n">dictionary</code><code class="p">.</code><code class="n">TryRemove</code><code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="k">out</code> <code class="kt">string</code> <code class="n">removedValue</code><code class="p">);</code></pre>&#13;
&#13;
<p><code>TryRemove</code> is almost identical to <code>TryGetValue</code>, except (of course) it removes the key/value pair if the key was found in the dictionary.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458694121160">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Although <code>ConcurrentDictionary&lt;TKey, TValue&gt;</code> is threadsafe, that doesn’t mean its operations are atomic. If multiple threads call <code>AddOrUpdate</code> concurrently, it’s possible for both of them to detect that the key isn’t present, and both of them concurrently execute their delegate that creates a new value.</p>&#13;
&#13;
<p>I think <code>ConcurrentDictionary&lt;TKey, TValue&gt;</code> is awesome, mainly because of the incredibly powerful <code>AddOrUpdate</code> method. However, it doesn’t fit the bill in every situation. <code>ConcurrentDictionary&lt;TKey, TValue&gt;</code> is best when you have multiple threads reading and writing to a shared collection. If the updates are not constant (if they’re more rare), then <code>ImmutableDictionary&lt;TKey, TValue&gt;</code> may be a better choice.</p>&#13;
&#13;
<p><code>ConcurrentDictionary&lt;TKey, TValue&gt;</code> is best in a shared-data situation, where multiple threads share the same collection. If some threads only add elements and other threads only remove elements, you’d be better served by a producer/consumer <span class="keep-together">collection.</span></p>&#13;
&#13;
<p><code>ConcurrentDictionary&lt;TKey, TValue&gt;</code> isn’t the only threadsafe collection. The BCL also provides <code>ConcurrentStack&lt;T&gt;</code>, <code>ConcurrentQueue&lt;T&gt;</code>, and <code>ConcurrentBag&lt;T&gt;</code>. Threadsafe collections are commonly used as producer/consumer collections, which will be covered in the rest of this <a data-startref="ch9r5a" data-type="indexterm" id="idm45458693924424"/><a data-startref="ch9r5b" data-type="indexterm" id="idm45458693923720"/>chapter.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458693922920">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="#recipe-immutable-dictionaries">Recipe 9.4</a> covers immutable dictionaries, which are ideal if the contents of the dictionary change very rarely.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="9.6 Blocking Queues" data-type="sect1"><div class="sect1" id="recipe-blocking-queues">&#13;
<h1>9.6 Blocking Queues</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458693918792">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="threadsafe collections" data-secondary="blocking queues" data-type="indexterm" id="ch9r6a"/><a data-primary="producer/consumer collections" data-secondary="blocking queues" data-type="indexterm" id="ch9r6b"/><a data-primary="queues" data-secondary="blocking" data-type="indexterm" id="ch9r6c"/>need a conduit to pass messages or data from one thread to another. For example, one thread could be loading data, which it pushes down the conduit as it loads; meanwhile, there are other threads on the receiving end of the conduit that receive the data and process it.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458693913080">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>The<a data-primary="BlockingCollection type" data-type="indexterm" id="idm45458693911384"/> .NET type <code>BlockingCollection&lt;T&gt;</code> was designed to be this kind of conduit. By default, <code>BlockingCollection&lt;T&gt;</code> is a blocking queue, providing first-in, first-out behavior.</p>&#13;
&#13;
<p>A blocking queue needs to be shared by multiple threads, and it’s usually defined as a private, read-only field:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">private</code> <code class="k">readonly</code> <code class="n">BlockingCollection</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">_blockingQueue</code> <code class="p">=</code>&#13;
    <code class="k">new</code> <code class="n">BlockingCollection</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;();</code></pre>&#13;
&#13;
<p>Usually, <a data-primary="producer threads" data-type="indexterm" id="idm45458693876952"/><a data-primary="consumer threads" data-type="indexterm" id="idm45458693876424"/>a thread will <em>either</em> add items to the collection <em>or</em> remove items from the collection, but not both. Threads that add items are called <em>producer threads</em>, and threads that remove items are called <em>consumer threads</em>.</p>&#13;
&#13;
<p>Producer threads can add items by calling <code>Add</code>, and when the producer thread is finished (when all items have been added), it can then finish the collection by calling <code>CompleteAdding</code>. This notifies the collection that no more items will be added to it, and the collection can then inform its consumers that there are no more items.</p>&#13;
&#13;
<p>Here’s a simple example of a producer that adds two items and then marks the collection complete:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="n">_blockingQueue</code><code class="p">.</code><code class="n">Add</code><code class="p">(</code><code class="m">7</code><code class="p">);</code>&#13;
<code class="n">_blockingQueue</code><code class="p">.</code><code class="n">Add</code><code class="p">(</code><code class="m">13</code><code class="p">);</code>&#13;
<code class="n">_blockingQueue</code><code class="p">.</code><code class="n">CompleteAdding</code><code class="p">();</code></pre>&#13;
&#13;
<p>Consumer threads usually run in a loop, waiting for the next item and then processing it. If you take the producer code and put it in a separate thread (e.g., via <code>Task.Run</code>), then you can consume those items like this:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="c1">// Displays "7" followed by "13".</code>&#13;
<code class="k">foreach</code> <code class="p">(</code><code class="kt">int</code> <code class="n">item</code> <code class="k">in</code> <code class="n">_blockingQueue</code><code class="p">.</code><code class="n">GetConsumingEnumerable</code><code class="p">())</code>&#13;
  <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">item</code><code class="p">);</code></pre>&#13;
&#13;
<p>If you want to have multiple consumers, <code>GetConsumingEnumerable</code> can be called from multiple threads at the same time. However, each item is only passed to one of those threads. When the collection is completed, the enumerable completes.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458693912488">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>The preceding examples all use <code>GetConsumingEnumerable</code> for the consumer threads; this is the most common scenario. However, there’s also a <code>Take</code> member that enables a consumer to just consume a single item rather than run a loop consuming all the items.</p>&#13;
&#13;
<p>When you use conduits like this, you do need to consider what happens if your producers run faster than your consumers. If you’re producing items faster than you can consume them, then you may need to throttle your queue.</p>&#13;
&#13;
<p>Blocking queues are great when you have a separate thread (such as a threadpool thread) acting as a producer or consumer. They’re not as great when you want to access the conduit asynchronously—for example, if a UI thread wants to act as a consumer. <a data-type="xref" href="#recipe-async-queues">Recipe 9.8</a> covers asynchronous queues.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Whenever you introduce a conduit like this into your application, consider switching to the TPL Dataflow library. A lot of the time, using TPL Dataflow is simpler than building your own conduits and background threads.</p>&#13;
</div>&#13;
&#13;
<p><code>BufferBlock&lt;T&gt;</code> from <a data-primary="BufferBlock type" data-type="indexterm" id="idm45458693778728"/>TPL Dataflow can act like a blocking queue, and TPL Dataflow allows building a pipeline or mesh for processing. In many simpler cases, though, ordinary blocking queues like <code>BlockingCollection&lt;T&gt;</code> are the appropriate design choice.</p>&#13;
&#13;
<p>You <a data-primary="AsyncProducerConsumerQueue type" data-type="indexterm" id="idm45458693776648"/>could also use <code>AsyncEx</code> library’s <code>AsyncProducerConsumerQueue&lt;T&gt;</code>, which can act like a <a data-startref="ch9r6a" data-type="indexterm" id="idm45458693774952"/><a data-startref="ch9r6b" data-type="indexterm" id="idm45458693774248"/><a data-startref="ch9r6c" data-type="indexterm" id="idm45458693773576"/>blocking queue.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458693772776">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="#recipe-blocking-stacks-bags">Recipe 9.7</a> covers blocking stacks and bags, if you want a similar conduit without first-in, first-out semantics.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-async-queues">Recipe 9.8</a> covers queues that have asynchronous rather than blocking APIs.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-blocking-async-queues">Recipe 9.12</a> covers queues that have both asynchronous and blocking APIs.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-queue-throttle">Recipe 9.9</a> covers queues that throttle their number of items.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="9.7 Blocking Stacks and Bags" data-type="sect1"><div class="sect1" id="recipe-blocking-stacks-bags">&#13;
<h1>9.7 Blocking Stacks and Bags</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458693765400">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="threadsafe collections" data-secondary="blocking stacks and bags" data-type="indexterm" id="ch9r7a"/><a data-primary="producer/consumer collections" data-secondary="blocking stacks and bags" data-type="indexterm" id="ch9r7b"/><a data-primary="stacks" data-secondary="blocking" data-type="indexterm" id="ch9r7c"/><a data-primary="bags" data-secondary="blocking" data-type="indexterm" id="ch9r7d"/>need a conduit to pass messages or data from one thread to another, but you don’t want (or need) the conduit to have first-in, first-out semantics.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458693738376">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>The<a data-primary="BlockingCollection type" data-type="indexterm" id="idm45458693737000"/> .NET type <code>BlockingCollection&lt;T&gt;</code> acts as a blocking queue by default, but it can also act like any kind of producer/consumer collection. It’s actually a wrapper around a threadsafe collection that implements <code>IProducerConsumerCollection&lt;T&gt;</code>.</p>&#13;
&#13;
<p>So, you can create a <code>BlockingCollection&lt;T&gt;</code> with last-in, first-out (stack) semantics or unordered (bag) semantics:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="n">BlockingCollection</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">_blockingStack</code> <code class="p">=</code> <code class="k">new</code> <code class="n">BlockingCollection</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;(</code>&#13;
    <code class="k">new</code> <code class="n">ConcurrentStack</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;());</code>&#13;
<code class="n">BlockingCollection</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">_blockingBag</code> <code class="p">=</code> <code class="k">new</code> <code class="n">BlockingCollection</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;(</code>&#13;
    <code class="k">new</code> <code class="n">ConcurrentBag</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;());</code></pre>&#13;
&#13;
<p>It’s important to keep in mind that there are now race conditions around the ordering of the items. If you let the same producer code execute before any consumer code, and then execute the consumer code after the producer code, then the order of the items will be exactly like a stack:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="c1">// Producer code</code>&#13;
<code class="n">_blockingStack</code><code class="p">.</code><code class="n">Add</code><code class="p">(</code><code class="m">7</code><code class="p">);</code>&#13;
<code class="n">_blockingStack</code><code class="p">.</code><code class="n">Add</code><code class="p">(</code><code class="m">13</code><code class="p">);</code>&#13;
<code class="n">_blockingStack</code><code class="p">.</code><code class="n">CompleteAdding</code><code class="p">();</code>&#13;
&#13;
<code class="c1">// Consumer code</code>&#13;
<code class="c1">// Displays "13" followed by "7".</code>&#13;
<code class="k">foreach</code> <code class="p">(</code><code class="kt">int</code> <code class="n">item</code> <code class="k">in</code> <code class="n">_blockingStack</code><code class="p">.</code><code class="n">GetConsumingEnumerable</code><code class="p">())</code>&#13;
  <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">item</code><code class="p">);</code></pre>&#13;
&#13;
<p>When the producer code and consumer code are on different threads (which is the usual case), the consumer always gets the most recently added item next. For example, the producer could add <code>7</code>, the consumer could take <code>7</code>, the producer could add <code>13</code>, and the consumer could take <code>13</code>. The consumer does <em>not</em> wait for <code>CompleteAdding</code> to be called before it returns the first item.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458693700648">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>The same considerations around throttling that apply to blocking queues also apply to blocking stacks and bags. If your producers run faster than your consumers and you need to limit the memory usage of your blocking stack/bag, you can use throttling as shown in <a data-type="xref" href="#recipe-queue-throttle">Recipe 9.9</a>.</p>&#13;
&#13;
<p>This recipe uses <code>GetConsumingEnumerable</code> for the consumer code; this is the most common scenario. There is also a <code>Take</code> member that enables a consumer to just consume a single item rather than run a loop consuming all the items.</p>&#13;
&#13;
<p>If you want to access shared stacks or bags asynchronously rather than by blocking (for example, having your UI thread act as a consumer), <a data-startref="ch9r7a" data-type="indexterm" id="idm45458693623304"/><a data-startref="ch9r7b" data-type="indexterm" id="idm45458693622600"/><a data-startref="ch9r7c" data-type="indexterm" id="idm45458693621928"/><a data-startref="ch9r7d" data-type="indexterm" id="idm45458693621256"/>see <a data-type="xref" href="#recipe-async-stacks-bags">Recipe 9.11</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458693619400">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="#recipe-blocking-queues">Recipe 9.6</a> covers blocking queues, which are much more commonly used than blocking stacks or bags.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-async-stacks-bags">Recipe 9.11</a> covers asynchronous stacks and bags.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="9.8 Asynchronous Queues" data-type="sect1"><div class="sect1" id="recipe-async-queues">&#13;
<h1>9.8 Asynchronous Queues</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458693614136">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="producer/consumer collections" data-secondary="asynchronous queues" data-type="indexterm" id="ch9r8a"/><a data-primary="queues" data-secondary="asynchronous" data-type="indexterm" id="ch9r8b"/>need a conduit to pass messages or data from one part of code to another in a first-in, first-out manner, without blocking threads.</p>&#13;
&#13;
<p>For example, one piece of code could be loading data, which it pushes down the conduit as it loads; meanwhile, the UI thread is receiving the data and displaying it.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458693609176">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>What you need is a queue with an asynchronous API. There is no type like this in the core .NET framework, but there are a couple of options available from NuGet.</p>&#13;
&#13;
<p>The <a data-primary="Channel type" data-type="indexterm" id="idm45458693606856"/>first option is to use Channels. Channels are a modern library for asynchronous producer/consumer collections, with a nice emphasis on high performance for high-volume scenarios. Producers generally write items to a channel using <code>WriteAsync</code>, and when they are all done producing, one of them calls <code>Complete</code> to notify the channel that there won’t be any more items in the future, like this:</p>&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="n">Channel</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">queue</code> <code class="p">=</code> <code class="n">Channel</code><code class="p">.</code><code class="n">CreateUnbounded</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;();</code>&#13;
&#13;
<code class="c1">// Producer code</code>&#13;
<code class="n">ChannelWriter</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">writer</code> <code class="p">=</code> <code class="n">queue</code><code class="p">.</code><code class="n">Writer</code><code class="p">;</code>&#13;
<code class="k">await</code> <code class="n">writer</code><code class="p">.</code><code class="n">WriteAsync</code><code class="p">(</code><code class="m">7</code><code class="p">);</code>&#13;
<code class="k">await</code> <code class="n">writer</code><code class="p">.</code><code class="n">WriteAsync</code><code class="p">(</code><code class="m">13</code><code class="p">);</code>&#13;
<code class="n">writer</code><code class="p">.</code><code class="n">Complete</code><code class="p">();</code>&#13;
&#13;
<code class="c1">// Consumer code</code>&#13;
<code class="c1">// Displays "7" followed by "13".</code>&#13;
<code class="n">ChannelReader</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">reader</code> <code class="p">=</code> <code class="n">queue</code><code class="p">.</code><code class="n">Reader</code><code class="p">;</code>&#13;
<code class="k">await</code> <code class="k">foreach</code> <code class="p">(</code><code class="kt">int</code> <code class="k">value</code> <code class="k">in</code> <code class="n">reader</code><code class="p">.</code><code class="n">ReadAllAsync</code><code class="p">())</code>&#13;
  <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="k">value</code><code class="p">);</code></pre>&#13;
&#13;
<p>This more natural consumer code uses asynchronous streams; see <a data-type="xref" href="ch03.html#async-streams">Chapter 3</a> for more information. As of this writing, asynchronous streams are only available on the newest .NET platforms; older platforms can use the following pattern:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="c1">// Consumer code (older platforms)</code>&#13;
<code class="c1">// Displays "7" followed by "13".</code>&#13;
<code class="n">ChannelReader</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">reader</code> <code class="p">=</code> <code class="n">queue</code><code class="p">.</code><code class="n">Reader</code><code class="p">;</code>&#13;
<code class="k">while</code> <code class="p">(</code><code class="k">await</code> <code class="n">reader</code><code class="p">.</code><code class="n">WaitToReadAsync</code><code class="p">())</code>&#13;
  <code class="k">while</code> <code class="p">(</code><code class="n">reader</code><code class="p">.</code><code class="n">TryRead</code><code class="p">(</code><code class="k">out</code> <code class="kt">int</code> <code class="k">value</code><code class="p">))</code>&#13;
    <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="k">value</code><code class="p">);</code></pre>&#13;
&#13;
<p>Note the double <code>while</code> loop in the consumer code for older platforms; this is normal. <code>WaitToReadAsync</code> will asynchronously wait until an item is available or the channel has been marked complete; it returns <code>true</code> when there is an item available to be read. <code>TryRead</code> will attempt to read an item (immediately and synchronously), returning <code>true</code> if an item was read. If <code>TryRead</code> returns <code>false</code>, this could be because there’s no item available <em>right now</em>, or it could be because the channel has been marked complete and there will never be any more items. So, when <code>TryRead</code> returns <code>false</code>, the inner <code>while</code> loop exits and the consumer again calls <code>WaitToReadAsync</code>, which will return <code>false</code> if the channel has been marked complete.</p>&#13;
&#13;
<p>Another <a data-primary="BufferBlock type" data-type="indexterm" id="idm45458693499496"/>producer/consumer queue option is to use <code>BufferBlock&lt;T&gt;</code> from the TPL Dataflow library. <code>BufferBlock&lt;T&gt;</code> is quite similar to a channel. The following example shows how to declare a <code>BufferBlock&lt;T&gt;</code>, what the producer code looks like, and what the consumer code looks like:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">_asyncQueue</code> <code class="p">=</code> <code class="k">new</code> <code class="n">BufferBlock</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;();</code>&#13;
&#13;
<code class="c1">// Producer code</code>&#13;
<code class="k">await</code> <code class="n">_asyncQueue</code><code class="p">.</code><code class="n">SendAsync</code><code class="p">(</code><code class="m">7</code><code class="p">);</code>&#13;
<code class="k">await</code> <code class="n">_asyncQueue</code><code class="p">.</code><code class="n">SendAsync</code><code class="p">(</code><code class="m">13</code><code class="p">);</code>&#13;
<code class="n">_asyncQueue</code><code class="p">.</code><code class="n">Complete</code><code class="p">();</code>&#13;
&#13;
<code class="c1">// Consumer code</code>&#13;
<code class="c1">// Displays "7" followed by "13".</code>&#13;
<code class="k">while</code> <code class="p">(</code><code class="k">await</code> <code class="n">_asyncQueue</code><code class="p">.</code><code class="n">OutputAvailableAsync</code><code class="p">())</code>&#13;
  <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="k">await</code> <code class="n">_asyncQueue</code><code class="p">.</code><code class="n">ReceiveAsync</code><code class="p">());</code></pre>&#13;
&#13;
<p>The example consumer code uses <code>OutputAvailableAsync</code>, which is really only useful if you have just a single consumer. If you have multiple consumers, it is possible that <code>OutputAvailableAsync</code> will return <code>true</code> for more than one consumer even though there is only one item. If the queue is completed, then <code>ReceiveAsync</code> will throw <code>InvalidOperationException</code>. So if you have multiple consumers, the consumer code usually looks more like the following:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">while</code> <code class="p">(</code><code class="k">true</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="kt">int</code> <code class="n">item</code><code class="p">;</code>&#13;
  <code class="k">try</code>&#13;
  <code class="p">{</code>&#13;
    <code class="n">item</code> <code class="p">=</code> <code class="k">await</code> <code class="n">_asyncQueue</code><code class="p">.</code><code class="n">ReceiveAsync</code><code class="p">();</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">catch</code> <code class="p">(</code><code class="n">InvalidOperationException</code><code class="p">)</code>&#13;
  <code class="p">{</code>&#13;
    <code class="k">break</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
  <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">item</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>You can also use the <code>AsyncProducerConsumerQueue&lt;T&gt;</code> type from the <code>Nito.AsyncEx</code> NuGet library. The API is similar to but not exactly the same as <code>BufferBlock&lt;T&gt;</code>:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">_asyncQueue</code> <code class="p">=</code> <code class="k">new</code> <code class="n">AsyncProducerConsumerQueue</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;();</code>&#13;
&#13;
<code class="c1">// Producer code</code>&#13;
<code class="k">await</code> <code class="n">_asyncQueue</code><code class="p">.</code><code class="n">EnqueueAsync</code><code class="p">(</code><code class="m">7</code><code class="p">);</code>&#13;
<code class="k">await</code> <code class="n">_asyncQueue</code><code class="p">.</code><code class="n">EnqueueAsync</code><code class="p">(</code><code class="m">13</code><code class="p">);</code>&#13;
<code class="n">_asyncQueue</code><code class="p">.</code><code class="n">CompleteAdding</code><code class="p">();</code>&#13;
&#13;
<code class="c1">// Consumer code</code>&#13;
<code class="c1">// Displays "7" followed by "13".</code>&#13;
<code class="k">while</code> <code class="p">(</code><code class="k">await</code> <code class="n">_asyncQueue</code><code class="p">.</code><code class="n">OutputAvailableAsync</code><code class="p">())</code>&#13;
  <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="k">await</code> <code class="n">_asyncQueue</code><code class="p">.</code><code class="n">DequeueAsync</code><code class="p">());</code></pre>&#13;
&#13;
<p>This consumer code also uses <code>OutputAvailableAsync</code> and has the same problems as <code>BufferBlock&lt;T&gt;</code>. If you have multiple consumers, the consumer code usually looks more like the following:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">while</code> <code class="p">(</code><code class="k">true</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="kt">int</code> <code class="n">item</code><code class="p">;</code>&#13;
  <code class="k">try</code>&#13;
  <code class="p">{</code>&#13;
    <code class="n">item</code> <code class="p">=</code> <code class="k">await</code> <code class="n">_asyncQueue</code><code class="p">.</code><code class="n">DequeueAsync</code><code class="p">();</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">catch</code> <code class="p">(</code><code class="n">InvalidOperationException</code><code class="p">)</code>&#13;
  <code class="p">{</code>&#13;
    <code class="k">break</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
  <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">item</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458693608552">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>I recommend using Channels for asynchronous producer/consumer queues whenever possible. They have multiple sampling options in addition to throttling, and they are highly optimized. However, if your application logic can be expressed as a “pipeline” through which data flows, then TPL Dataflow may be a more natural fit. The final option is <code>AsyncProducerConsumerQueue&lt;T&gt;</code>, which may make sense if your application is already using other types<a data-startref="ch9r8a" data-type="indexterm" id="idm45458693245784"/><a data-startref="ch9r8b" data-type="indexterm" id="idm45458693245112"/> from <code>AsyncEx</code>.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Channels can be found in the <a href="http://bit.ly/sys-thrd-chanls"><code>System.Threading.Channels</code></a> NuGet package.&#13;
The <code>BufferBlock&lt;T&gt;</code> type is in the <a href="http://bit.ly/nuget-df"><code>System.Threading.Tasks.Dataflow</code></a> NuGet package.&#13;
The <code>AsyncProducerConsumerQueue&lt;T&gt;</code> type is in the <a href="http://bit.ly/nito-async"><code>Nito.AsyncEx</code></a> NuGet package.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458693238952">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="#recipe-blocking-queues">Recipe 9.6</a> covers producer/consumer queues with blocking semantics rather than asynchronous semantics.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-blocking-async-queues">Recipe 9.12</a> covers producer/consumer queues that have <em>both</em> blocking and asynchronous semantics.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-blocking-stacks-bags">Recipe 9.7</a> covers asynchronous stacks and bags if you want a similar conduit without first-in, first-out semantics.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="9.9 Throttling Queues" data-type="sect1"><div class="sect1" id="recipe-queue-throttle">&#13;
<h1>9.9 Throttling Queues</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458693199704">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="producer/consumer collections" data-secondary="throttling queues" data-type="indexterm" id="ch9r9a"/><a data-primary="queues" data-secondary="throttling" data-type="indexterm" id="ch9r9b"/><a data-primary="throttling" data-secondary="queues" data-type="indexterm" id="idm45458693195880"/>have a producer/consumer queue, and your producers might run faster than your consumers, which would cause undesired memory usage. You also want to keep all the queue items, so you need a way to throttle the producers.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458693194312">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>When you use producer/consumer queues, you do need to consider what happens if your producers run faster than your consumers, unless you’re sure that your consumers will <em>always</em> run faster. If you’re producing items faster than you can consume them, then you may need to throttle your queue. You can throttle a queue by designating a maximum number of elements. When<a data-primary="backpressure" data-secondary="with queues" data-type="indexterm" id="idm45458693191800"/> a queue is “full,” it applies backpressure to the producers, blocking them until there is more room in the queue.</p>&#13;
&#13;
<p>Channels <a data-primary="Channel type" data-type="indexterm" id="idm45458693190184"/>can be throttled by creating a bounded channel rather than an unbounded channel. Since channels are asynchronous, producers will be asynchronously throttled:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="n">Channel</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">queue</code> <code class="p">=</code> <code class="n">Channel</code><code class="p">.</code><code class="n">CreateBounded</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;(</code><code class="m">1</code><code class="p">);</code>&#13;
<code class="n">ChannelWriter</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">writer</code> <code class="p">=</code> <code class="n">queue</code><code class="p">.</code><code class="n">Writer</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// This Write completes immediately.</code>&#13;
<code class="k">await</code> <code class="n">writer</code><code class="p">.</code><code class="n">WriteAsync</code><code class="p">(</code><code class="m">7</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// This Write (asynchronously) waits for the 7 to be removed</code>&#13;
<code class="c1">// before it enqueues the 13.</code>&#13;
<code class="k">await</code> <code class="n">writer</code><code class="p">.</code><code class="n">WriteAsync</code><code class="p">(</code><code class="m">13</code><code class="p">);</code>&#13;
&#13;
<code class="n">writer</code><code class="p">.</code><code class="n">Complete</code><code class="p">();</code></pre>&#13;
&#13;
<p><code>BufferBlock&lt;T&gt;</code> has<a data-primary="BufferBlock type" data-type="indexterm" id="idm45458693187160"/> built-in support for throttling, explored in more detail in <a data-type="xref" href="ch05.html#recipe-dataflow-throttling">Recipe 5.4</a>. With dataflow blocks, you set the <code>BoundedCapacity</code> option:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">queue</code> <code class="p">=</code> <code class="k">new</code> <code class="n">BufferBlock</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;(</code>&#13;
    <code class="k">new</code> <code class="n">DataflowBlockOptions</code> <code class="p">{</code> <code class="n">BoundedCapacity</code> <code class="p">=</code> <code class="m">1</code> <code class="p">});</code>&#13;
&#13;
<code class="c1">// This Send completes immediately.</code>&#13;
<code class="k">await</code> <code class="n">queue</code><code class="p">.</code><code class="n">SendAsync</code><code class="p">(</code><code class="m">7</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// This Send (asynchronously) waits for the 7 to be removed</code>&#13;
<code class="c1">// before it enqueues the 13.</code>&#13;
<code class="k">await</code> <code class="n">queue</code><code class="p">.</code><code class="n">SendAsync</code><code class="p">(</code><code class="m">13</code><code class="p">);</code>&#13;
&#13;
<code class="n">queue</code><code class="p">.</code><code class="n">Complete</code><code class="p">();</code></pre>&#13;
&#13;
<p>The producer in the preceding code snippet uses the asynchronous <code>SendAsync</code> API; the same approach works for the synchronous <code>Post</code> API.</p>&#13;
&#13;
<p>The<a data-primary="AsyncProducerConsumerQueue type" data-type="indexterm" id="idm45458693031752"/> <code>AsyncEx</code> type <code>AsyncProducerConsumerQueue&lt;T&gt;</code> has support for throttling. Just construct the queue with the appropriate value:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">queue</code> <code class="p">=</code> <code class="k">new</code> <code class="n">AsyncProducerConsumerQueue</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;(</code><code class="n">maxCount</code><code class="p">:</code> <code class="m">1</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// This Enqueue completes immediately.</code>&#13;
<code class="k">await</code> <code class="n">queue</code><code class="p">.</code><code class="n">EnqueueAsync</code><code class="p">(</code><code class="m">7</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// This Enqueue (asynchronously) waits for the 7 to be removed</code>&#13;
<code class="c1">// before it enqueues the 13.</code>&#13;
<code class="k">await</code> <code class="n">queue</code><code class="p">.</code><code class="n">EnqueueAsync</code><code class="p">(</code><code class="m">13</code><code class="p">);</code>&#13;
&#13;
<code class="n">queue</code><code class="p">.</code><code class="n">CompleteAdding</code><code class="p">();</code></pre>&#13;
&#13;
<p>Blocking <a data-primary="BlockingCollection type" data-type="indexterm" id="idm45458693028632"/>producer/consumer queues also support throttling. You can use <code>BlockingCollection&lt;T&gt;</code> to throttle the number of items by passing the appropriate value when you create it:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">queue</code> <code class="p">=</code> <code class="k">new</code> <code class="n">BlockingCollection</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;(</code><code class="n">boundedCapacity</code><code class="p">:</code> <code class="m">1</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// This Add completes immediately.</code>&#13;
<code class="n">queue</code><code class="p">.</code><code class="n">Add</code><code class="p">(</code><code class="m">7</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// This Add waits for the 7 to be removed before it adds the 13.</code>&#13;
<code class="n">queue</code><code class="p">.</code><code class="n">Add</code><code class="p">(</code><code class="m">13</code><code class="p">);</code>&#13;
&#13;
<code class="n">queue</code><code class="p">.</code><code class="n">CompleteAdding</code><code class="p">();</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458692947688">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Throttling is necessary whenever producers can run faster than consumers. One scenario you must consider is whether it’s possible for producers to run faster than consumers if your application is running on different hardware than yours. Some throttling is usually necessary to ensure your application will run on future hardware and/or cloud instances, which are generally more constrained than developer machines.</p>&#13;
&#13;
<p>Throttling will cause backpressure on the producers, slowing them down to ensure that consumers are able to process all items, without causing undue memory pressure. If you don’t need to process <em>every</em> item, you can choose to sample instead of throttle. See <a data-type="xref" href="#recipe-queue-sample">Recipe 9.10</a> for sampling producer/consumer <a data-startref="ch9r9a" data-type="indexterm" id="idm45458692904248"/><a data-startref="ch9r9b" data-type="indexterm" id="idm45458692903576"/>queues.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Channels are in the <a href="http://bit.ly/sys-thrd-chanls"><code>System.Threading.Channels</code></a> NuGet package.&#13;
The <code>BufferBlock&lt;T&gt;</code> type is in the <a href="http://bit.ly/nuget-df"><code>System.Threading.Tasks.Dataflow</code></a> NuGet package.&#13;
The <code>AsyncProducerConsumerQueue&lt;T&gt;</code> type is in the <a href="http://bit.ly/nito-async"><code>Nito.AsyncEx</code></a> NuGet package.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458692897880">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="#recipe-async-queues">Recipe 9.8</a> covers basic asynchronous producer/consumer queue usage.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-blocking-queues">Recipe 9.6</a> covers basic synchronous producer/consumer queue usage.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-queue-sample">Recipe 9.10</a> covers sampling producer/consumer queues, an alternative to throttling.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="9.10 Sampling Queues" data-type="sect1"><div class="sect1" id="recipe-queue-sample">&#13;
<h1>9.10 Sampling Queues</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458692891656">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="producer/consumer collections" data-secondary="sampling queues" data-type="indexterm" id="ch9r10a"/><a data-primary="queues" data-secondary="sampling" data-type="indexterm" id="ch9r10b"/>have a producer/consumer queue, but your producers may run faster than your consumers, which is causing undesired memory usage. You don’t need to keep all the queue items; you need a way to filter the queue items so that the slower producers only need to process the important ones.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458692887144">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Channels <a data-primary="Channel type" data-type="indexterm" id="idm45458692885608"/>are the easiest way to apply sampling to input items. One common example is to always take the latest <em>n</em> items, discarding the oldest items once the queue is full:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="n">Channel</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">queue</code> <code class="p">=</code> <code class="n">Channel</code><code class="p">.</code><code class="n">CreateBounded</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;(</code>&#13;
    <code class="k">new</code> <code class="nf">BoundedChannelOptions</code><code class="p">(</code><code class="m">1</code><code class="p">)</code>&#13;
    <code class="p">{</code>&#13;
      <code class="n">FullMode</code> <code class="p">=</code> <code class="n">BoundedChannelFullMode</code><code class="p">.</code><code class="n">DropOldest</code><code class="p">,</code>&#13;
    <code class="p">});</code>&#13;
<code class="n">ChannelWriter</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">writer</code> <code class="p">=</code> <code class="n">queue</code><code class="p">.</code><code class="n">Writer</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// This Write completes immediately.</code>&#13;
<code class="k">await</code> <code class="n">writer</code><code class="p">.</code><code class="n">WriteAsync</code><code class="p">(</code><code class="m">7</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// This Write also completes immediately.</code>&#13;
<code class="c1">// The 7 is discarded unless a consumer has already retrieved it.</code>&#13;
<code class="k">await</code> <code class="n">writer</code><code class="p">.</code><code class="n">WriteAsync</code><code class="p">(</code><code class="m">13</code><code class="p">);</code></pre>&#13;
&#13;
<p>This is an easy way to tame input streams, keeping them from flooding your consumers.</p>&#13;
&#13;
<p>There are other <code>BoundedChannelFullMode</code> options as well. For example, if you wanted the <em>oldest</em> items to be preserved, you could discard any new items once the channel is full:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="n">Channel</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">queue</code> <code class="p">=</code> <code class="n">Channel</code><code class="p">.</code><code class="n">CreateBounded</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;(</code>&#13;
    <code class="k">new</code> <code class="nf">BoundedChannelOptions</code><code class="p">(</code><code class="m">1</code><code class="p">)</code>&#13;
    <code class="p">{</code>&#13;
      <code class="n">FullMode</code> <code class="p">=</code> <code class="n">BoundedChannelFullMode</code><code class="p">.</code><code class="n">DropWrite</code><code class="p">,</code>&#13;
    <code class="p">});</code>&#13;
<code class="n">ChannelWriter</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">writer</code> <code class="p">=</code> <code class="n">queue</code><code class="p">.</code><code class="n">Writer</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// This Write completes immediately.</code>&#13;
<code class="k">await</code> <code class="n">writer</code><code class="p">.</code><code class="n">WriteAsync</code><code class="p">(</code><code class="m">7</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// This Write also completes immediately.</code>&#13;
<code class="c1">// The 13 is discarded unless a consumer has already retrieved the 7.</code>&#13;
<code class="k">await</code> <code class="n">writer</code><code class="p">.</code><code class="n">WriteAsync</code><code class="p">(</code><code class="m">13</code><code class="p">);</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458692798088">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Channels are great for doing simple sampling like this. A particularly useful option in many situations is <code>BoundedChannelFullMode.DropOldest</code>. More complex sampling would need to be done by the consumers themselves.</p>&#13;
&#13;
<p>If you need to do time-based sampling, such as “only 10 items per second,” use System.Reactive. System.Reactive has natural operators for working with <a data-startref="ch9r10a" data-type="indexterm" id="idm45458692723384"/><a data-startref="ch9r10b" data-type="indexterm" id="idm45458692722680"/>time.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Channels are located in the <a href="http://bit.ly/sys-thrd-chanls"><code>System.Threading.Channels</code></a> NuGet package.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458692719672">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="#recipe-queue-throttle">Recipe 9.9</a> covers throttling channels, which limits the number of items in the channel by blocking producers rather than dropping items.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-async-queues">Recipe 9.8</a> covers basic channel usage, including producer and consumer code.</p>&#13;
&#13;
<p><a data-type="xref" href="ch06.html#recipe-rx-throttle">Recipe 6.4</a> covers throttling and sampling using <code>System.Reactive</code>, which supports time-based sampling.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="9.11 Asynchronous Stacks and Bags" data-type="sect1"><div class="sect1" id="recipe-async-stacks-bags">&#13;
<h1>9.11 Asynchronous Stacks and Bags</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458692712856">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="producer/consumer collections" data-secondary="asynchronous stacks and bags" data-type="indexterm" id="ch9r11a"/><a data-primary="stacks" data-secondary="asynchronous" data-type="indexterm" id="ch9r11b"/><a data-primary="bags" data-secondary="asynchronous" data-type="indexterm" id="ch9r11c"/>need a conduit to pass messages or data from one part of code to another, but you don’t want (or need) the conduit to have first-in, first-out semantics.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458692707176">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>The<a data-primary="AsyncCollection type" data-type="indexterm" id="idm45458692705256"/> <code>Nito.AsyncEx</code> library provides a type <code>AsyncCollection&lt;T&gt;</code>, which acts like an asynchronous queue by default, but it can also act like any kind of producer/consumer collection. The wrapper around an <code>IProducerConsumerCollection&lt;T&gt;</code>, <code>AsyncCollection&lt;T&gt;</code> is also the <code>async</code> equivalent of the .NET <code>BlockingCollection&lt;T&gt;</code>, which is covered in <a data-type="xref" href="#recipe-blocking-stacks-bags">Recipe 9.7</a>.</p>&#13;
&#13;
<p><code>AsyncCollection&lt;T&gt;</code> supports last-in, first-out (stack) or unordered (bag) semantics, based on whatever collection you pass to its constructor:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">_asyncStack</code> <code class="p">=</code> <code class="k">new</code> <code class="n">AsyncCollection</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;(</code>&#13;
    <code class="k">new</code> <code class="n">ConcurrentStack</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;());</code>&#13;
<code class="kt">var</code> <code class="n">_asyncBag</code> <code class="p">=</code> <code class="k">new</code> <code class="n">AsyncCollection</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;(</code>&#13;
    <code class="k">new</code> <code class="n">ConcurrentBag</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;());</code></pre>&#13;
&#13;
<p>Note that there’s a race condition around the ordering of items in the stack. If all producers complete before consumers start, then the order of items is like a regular stack:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="c1">// Producer code</code>&#13;
<code class="k">await</code> <code class="n">_asyncStack</code><code class="p">.</code><code class="n">AddAsync</code><code class="p">(</code><code class="m">7</code><code class="p">);</code>&#13;
<code class="k">await</code> <code class="n">_asyncStack</code><code class="p">.</code><code class="n">AddAsync</code><code class="p">(</code><code class="m">13</code><code class="p">);</code>&#13;
<code class="n">_asyncStack</code><code class="p">.</code><code class="n">CompleteAdding</code><code class="p">();</code>&#13;
&#13;
<code class="c1">// Consumer code</code>&#13;
<code class="c1">// Displays "13" followed by "7".</code>&#13;
<code class="k">while</code> <code class="p">(</code><code class="k">await</code> <code class="n">_asyncStack</code><code class="p">.</code><code class="n">OutputAvailableAsync</code><code class="p">())</code>&#13;
  <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="k">await</code> <code class="n">_asyncStack</code><code class="p">.</code><code class="n">TakeAsync</code><code class="p">());</code></pre>&#13;
&#13;
<p>When both producers and consumers are executing concurrently (which is the usual case), the consumer will always get the most recently added item next. This will cause the collection as a whole to act not quite like a stack. Of course, the bag collection has no ordering at all.</p>&#13;
&#13;
<p><code>AsyncCollection&lt;T&gt;</code> has support for throttling, which is necessary if producers may add to the collection faster than the consumers can remove from it. Just construct the collection with the appropriate value:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">_asyncStack</code> <code class="p">=</code> <code class="k">new</code> <code class="n">AsyncCollection</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;(</code>&#13;
    <code class="k">new</code> <code class="n">ConcurrentStack</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;(),</code> <code class="n">maxCount</code><code class="p">:</code> <code class="m">1</code><code class="p">);</code></pre>&#13;
&#13;
<p>Now the same producer code will asynchronously wait as needed:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="c1">// This Add completes immediately.</code>&#13;
<code class="k">await</code> <code class="n">_asyncStack</code><code class="p">.</code><code class="n">AddAsync</code><code class="p">(</code><code class="m">7</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// This Add (asynchronously) waits for the 7 to be removed</code>&#13;
<code class="c1">// before it enqueues the 13.</code>&#13;
<code class="k">await</code> <code class="n">_asyncStack</code><code class="p">.</code><code class="n">AddAsync</code><code class="p">(</code><code class="m">13</code><code class="p">);</code>&#13;
&#13;
<code class="n">_asyncStack</code><code class="p">.</code><code class="n">CompleteAdding</code><code class="p">();</code></pre>&#13;
&#13;
<p>The example consumer code uses <code>OutputAvailableAsync</code>, which has the same limitation described in <a data-type="xref" href="#recipe-async-queues">Recipe 9.8</a>. If you have multiple consumers, the consumer code usually looks more like the following:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">while</code> <code class="p">(</code><code class="k">true</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="kt">int</code> <code class="n">item</code><code class="p">;</code>&#13;
  <code class="k">try</code>&#13;
  <code class="p">{</code>&#13;
    <code class="n">item</code> <code class="p">=</code> <code class="k">await</code> <code class="n">_asyncStack</code><code class="p">.</code><code class="n">TakeAsync</code><code class="p">();</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">catch</code> <code class="p">(</code><code class="n">InvalidOperationException</code><code class="p">)</code>&#13;
  <code class="p">{</code>&#13;
    <code class="k">break</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
  <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">item</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458692706584">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p><code>AsyncCollection&lt;T&gt;</code> is just the asynchronous equivalent of <code>BlockingCollection&lt;T&gt;</code> with a slightly <a data-startref="ch9r11a" data-type="indexterm" id="idm45458692423272"/><a data-startref="ch9r11b" data-type="indexterm" id="idm45458692422536"/><a data-startref="ch9r11c" data-type="indexterm" id="idm45458692421864"/>different API.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>The <code>AsyncCollection&lt;T&gt;</code> type is in the <a href="http://bit.ly/nito-async"><code>Nito.AsyncEx</code></a> NuGet package.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458692418376">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="#recipe-async-queues">Recipe 9.8</a> covers asynchronous queues, which are much more common than asynchronous stacks or bags.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-blocking-stacks-bags">Recipe 9.7</a> covers synchronous (blocking) stacks and bags.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="9.12 Blocking/Asynchronous Queues" data-type="sect1"><div class="sect1" id="recipe-blocking-async-queues">&#13;
<h1>9.12 Blocking/Asynchronous Queues</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458692413128">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="producer/consumer collections" data-secondary="blocking/asynchronous queues" data-type="indexterm" id="ch9r12a"/><a data-primary="queues" data-secondary="blocking/asynchronous" data-type="indexterm" id="ch9r12b"/>need a conduit to pass messages or data from one part of code to another in a first-in, first-out manner, and you need the flexibility to treat either the producer end or the consumer end as synchronous or asynchronous.</p>&#13;
&#13;
<p>For example, a background thread may be loading data and pushing it into the conduit, and you want the background thread to synchronously block if the conduit is too full. At the same time, the UI thread is receiving data from the conduit, and you want the UI thread to asynchronously pull data from the conduit so the UI remains responsive.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458692407912">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>After looking at blocking queues in <a data-type="xref" href="#recipe-blocking-queues">Recipe 9.6</a> and asynchronous queues in <a data-type="xref" href="#recipe-async-queues">Recipe 9.8</a>, now we’ll learn about a few queue types that support both blocking and asynchronous APIs.</p>&#13;
&#13;
<p>The <a data-primary="BufferBlock type" data-type="indexterm" id="idm45458692403784"/><a data-primary="ActionBlock type" data-type="indexterm" id="idm45458692403048"/>first is <code>BufferBlock&lt;T&gt;</code> and <code>ActionBlock&lt;T&gt;</code> from the TPL Dataflow NuGet library. <code>BufferBlock&lt;T&gt;</code> can be easily used as an asynchronous producer/consumer queue (see <a data-type="xref" href="#recipe-async-queues">Recipe 9.8</a> for more details):</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">queue</code> <code class="p">=</code> <code class="k">new</code> <code class="n">BufferBlock</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;();</code>&#13;
&#13;
<code class="c1">// Producer code</code>&#13;
<code class="k">await</code> <code class="n">queue</code><code class="p">.</code><code class="n">SendAsync</code><code class="p">(</code><code class="m">7</code><code class="p">);</code>&#13;
<code class="k">await</code> <code class="n">queue</code><code class="p">.</code><code class="n">SendAsync</code><code class="p">(</code><code class="m">13</code><code class="p">);</code>&#13;
<code class="n">queue</code><code class="p">.</code><code class="n">Complete</code><code class="p">();</code>&#13;
&#13;
<code class="c1">// Consumer code for a single consumer</code>&#13;
<code class="k">while</code> <code class="p">(</code><code class="k">await</code> <code class="n">queue</code><code class="p">.</code><code class="n">OutputAvailableAsync</code><code class="p">())</code>&#13;
  <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="k">await</code> <code class="n">queue</code><code class="p">.</code><code class="n">ReceiveAsync</code><code class="p">());</code>&#13;
&#13;
<code class="c1">// Consumer code for multiple consumers</code>&#13;
<code class="k">while</code> <code class="p">(</code><code class="k">true</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="kt">int</code> <code class="n">item</code><code class="p">;</code>&#13;
  <code class="k">try</code>&#13;
  <code class="p">{</code>&#13;
    <code class="n">item</code> <code class="p">=</code> <code class="k">await</code> <code class="n">queue</code><code class="p">.</code><code class="n">ReceiveAsync</code><code class="p">();</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">catch</code> <code class="p">(</code><code class="n">InvalidOperationException</code><code class="p">)</code>&#13;
  <code class="p">{</code>&#13;
    <code class="k">break</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">item</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>As you can see in the following example, <code>BufferBlock&lt;T&gt;</code> also supports a synchronous API for both producers and consumers:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">queue</code> <code class="p">=</code> <code class="k">new</code> <code class="n">BufferBlock</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;();</code>&#13;
&#13;
<code class="c1">// Producer code</code>&#13;
<code class="n">queue</code><code class="p">.</code><code class="n">Post</code><code class="p">(</code><code class="m">7</code><code class="p">);</code>&#13;
<code class="n">queue</code><code class="p">.</code><code class="n">Post</code><code class="p">(</code><code class="m">13</code><code class="p">);</code>&#13;
<code class="n">queue</code><code class="p">.</code><code class="n">Complete</code><code class="p">();</code>&#13;
&#13;
<code class="c1">// Consumer code</code>&#13;
<code class="k">while</code> <code class="p">(</code><code class="k">true</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="kt">int</code> <code class="n">item</code><code class="p">;</code>&#13;
  <code class="k">try</code>&#13;
  <code class="p">{</code>&#13;
    <code class="n">item</code> <code class="p">=</code> <code class="n">queue</code><code class="p">.</code><code class="n">Receive</code><code class="p">();</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">catch</code> <code class="p">(</code><code class="n">InvalidOperationException</code><code class="p">)</code>&#13;
  <code class="p">{</code>&#13;
    <code class="k">break</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">item</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The consumer code using <code>BufferBlock&lt;T&gt;</code> is rather awkward, since it isn’t the “dataflow way” of writing code. The TPL Dataflow library includes a number of blocks that can be linked together, enabling you to define a reactive mesh. In this case, a producer/consumer queue completing with a particular action can be defined using <code>ActionBlock&lt;T&gt;</code>:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="c1">// Consumer code is passed to queue constructor.</code>&#13;
<code class="n">ActionBlock</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">queue</code> <code class="p">=</code> <code class="k">new</code> <code class="n">ActionBlock</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;(</code><code class="n">item</code> <code class="p">=&gt;</code> <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">item</code><code class="p">));</code>&#13;
&#13;
<code class="c1">// Asynchronous producer code</code>&#13;
<code class="k">await</code> <code class="n">queue</code><code class="p">.</code><code class="n">SendAsync</code><code class="p">(</code><code class="m">7</code><code class="p">);</code>&#13;
<code class="k">await</code> <code class="n">queue</code><code class="p">.</code><code class="n">SendAsync</code><code class="p">(</code><code class="m">13</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// Synchronous producer code</code>&#13;
<code class="n">queue</code><code class="p">.</code><code class="n">Post</code><code class="p">(</code><code class="m">7</code><code class="p">);</code>&#13;
<code class="n">queue</code><code class="p">.</code><code class="n">Post</code><code class="p">(</code><code class="m">13</code><code class="p">);</code>&#13;
<code class="n">queue</code><code class="p">.</code><code class="n">Complete</code><code class="p">();</code></pre>&#13;
&#13;
<p>If the TPL Dataflow library isn’t available on your desired platform(s), then there is an <code>AsyncProducerConsumerQueue&lt;T&gt;</code> type in <code>Nito.AsyncEx</code> that also supports both synchronous and asynchronous methods:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">queue</code> <code class="p">=</code> <code class="k">new</code> <code class="n">AsyncProducerConsumerQueue</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;();</code>&#13;
&#13;
<code class="c1">// Asynchronous producer code</code>&#13;
<code class="k">await</code> <code class="n">queue</code><code class="p">.</code><code class="n">EnqueueAsync</code><code class="p">(</code><code class="m">7</code><code class="p">);</code>&#13;
<code class="k">await</code> <code class="n">queue</code><code class="p">.</code><code class="n">EnqueueAsync</code><code class="p">(</code><code class="m">13</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// Synchronous producer code</code>&#13;
<code class="n">queue</code><code class="p">.</code><code class="n">Enqueue</code><code class="p">(</code><code class="m">7</code><code class="p">);</code>&#13;
<code class="n">queue</code><code class="p">.</code><code class="n">Enqueue</code><code class="p">(</code><code class="m">13</code><code class="p">);</code>&#13;
&#13;
<code class="n">queue</code><code class="p">.</code><code class="n">CompleteAdding</code><code class="p">();</code>&#13;
&#13;
<code class="c1">// Asynchronous single consumer code</code>&#13;
<code class="k">while</code> <code class="p">(</code><code class="k">await</code> <code class="n">queue</code><code class="p">.</code><code class="n">OutputAvailableAsync</code><code class="p">())</code>&#13;
  <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="k">await</code> <code class="n">queue</code><code class="p">.</code><code class="n">DequeueAsync</code><code class="p">());</code>&#13;
&#13;
<code class="c1">// Asynchronous multi-consumer code</code>&#13;
<code class="k">while</code> <code class="p">(</code><code class="k">true</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="kt">int</code> <code class="n">item</code><code class="p">;</code>&#13;
  <code class="k">try</code>&#13;
  <code class="p">{</code>&#13;
    <code class="n">item</code> <code class="p">=</code> <code class="k">await</code> <code class="n">queue</code><code class="p">.</code><code class="n">DequeueAsync</code><code class="p">();</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">catch</code> <code class="p">(</code><code class="n">InvalidOperationException</code><code class="p">)</code>&#13;
  <code class="p">{</code>&#13;
    <code class="k">break</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
  <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">item</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Synchronous consumer code</code>&#13;
<code class="k">foreach</code> <code class="p">(</code><code class="kt">int</code> <code class="n">item</code> <code class="k">in</code> <code class="n">queue</code><code class="p">.</code><code class="n">GetConsumingEnumerable</code><code class="p">())</code>&#13;
  <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">item</code><code class="p">);</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458692407288">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>I recommend using <code>BufferBlock&lt;T&gt;</code> or <code>ActionBlock&lt;T&gt;</code> if possible because the TPL Dataflow library has been more extensively tested than the <code>Nito.AsyncEx</code> library. However, <code>AsyncProducerConsumerQueue&lt;T&gt;</code> may be useful if your application is already using other types from the <code>AsyncEx</code> library.</p>&#13;
&#13;
<p>It <a data-primary="Channel type" data-type="indexterm" id="idm45458691964248"/>is also possible to use <code>System.Threading.Channels</code> synchronously, but only indirectly. Their natural API is asynchronous, but since they are threadsafe collections, you can force them to work synchronously by wrapping your production or consumption code inside a <code>Task.Run</code> and then blocking on the task returned from <code>Task.Run</code>, like this:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="n">Channel</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">queue</code> <code class="p">=</code> <code class="n">Channel</code><code class="p">.</code><code class="n">CreateBounded</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;(</code><code class="m">10</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// Producer code</code>&#13;
<code class="n">ChannelWriter</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">writer</code> <code class="p">=</code> <code class="n">queue</code><code class="p">.</code><code class="n">Writer</code><code class="p">;</code>&#13;
<code class="n">Task</code><code class="p">.</code><code class="n">Run</code><code class="p">(</code><code class="k">async</code> <code class="p">()</code> <code class="p">=&gt;</code>&#13;
<code class="p">{</code>&#13;
  <code class="k">await</code> <code class="n">writer</code><code class="p">.</code><code class="n">WriteAsync</code><code class="p">(</code><code class="m">7</code><code class="p">);</code>&#13;
  <code class="k">await</code> <code class="n">writer</code><code class="p">.</code><code class="n">WriteAsync</code><code class="p">(</code><code class="m">13</code><code class="p">);</code>&#13;
  <code class="n">writer</code><code class="p">.</code><code class="n">Complete</code><code class="p">();</code>&#13;
<code class="p">}).</code><code class="n">GetAwaiter</code><code class="p">().</code><code class="n">GetResult</code><code class="p">();</code>&#13;
&#13;
<code class="c1">// Consumer code</code>&#13;
<code class="n">ChannelReader</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">reader</code> <code class="p">=</code> <code class="n">queue</code><code class="p">.</code><code class="n">Reader</code><code class="p">;</code>&#13;
<code class="n">Task</code><code class="p">.</code><code class="n">Run</code><code class="p">(</code><code class="k">async</code> <code class="p">()</code> <code class="p">=&gt;</code>&#13;
<code class="p">{</code>&#13;
  <code class="k">while</code> <code class="p">(</code><code class="k">await</code> <code class="n">reader</code><code class="p">.</code><code class="n">WaitToReadAsync</code><code class="p">())</code>&#13;
    <code class="k">while</code> <code class="p">(</code><code class="n">reader</code><code class="p">.</code><code class="n">TryRead</code><code class="p">(</code><code class="k">out</code> <code class="kt">int</code> <code class="k">value</code><code class="p">))</code>&#13;
      <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="k">value</code><code class="p">);</code>&#13;
<code class="p">}).</code><code class="n">GetAwaiter</code><code class="p">().</code><code class="n">GetResult</code><code class="p">();</code></pre>&#13;
&#13;
<p>TPL Dataflow blocks, <code>AsyncProducerConsumerQueue&lt;T&gt;</code>, and Channels all support throttling by passing options during construction. Throttling is necessary when you have producers that push items faster than your consumers can consume them, which could cause your application to take up large amounts of <a data-startref="ch9r12a" data-type="indexterm" id="idm45458691959752"/><a data-startref="ch9r12b" data-type="indexterm" id="idm45458691803992"/>memory.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>The <code>BufferBlock&lt;T&gt;</code> and <code>ActionBlock&lt;T&gt;</code> types are in the <a href="http://bit.ly/nuget-df"><code>System.Threading.Tasks.Dataflow</code></a> NuGet package.&#13;
The <code>AsyncProducerConsumerQueue&lt;T&gt;</code> type is in the <a href="http://bit.ly/nito-async"><code>Nito.AsyncEx</code></a> NuGet package.&#13;
Channels are in the <a href="http://bit.ly/sys-thrd-chanls"><code>System.Threading.Channels</code></a> NuGet package.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458691798056">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="#recipe-blocking-queues">Recipe 9.6</a> covers blocking producer/consumer queues.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-async-queues">Recipe 9.8</a> covers asynchronous producer/consumer queues.</p>&#13;
&#13;
<p><a data-type="xref" href="ch05.html#recipe-dataflow-throttling">Recipe 5.4</a> covers throttling dataflow blocks.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>