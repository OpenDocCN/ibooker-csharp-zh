- en: Chapter 6\. Exemplifying Real-Time Web Functionality
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章。实时Web功能的示例
- en: No web user wants to hit refresh constantly for the latest information. They
    want everything right now, automatically. Real-time web functionality is very
    common, and most modern apps require it. Many apps rely on live data to provide
    pertinent information to their users as soon as it becomes available. In this
    chapter, you’ll learn how to implement real-time web functionality using ASP.NET
    Core SignalR (or just SignalR). You’ll then find out how to create a server-side
    (`Hub`) that will expose many live data points, such as real-time alerts and notifications,
    a messaging system for live-user interactions, and a joinable active Twitter stream.
    Finally, you’ll learn how to consume this data from our Blazor WebAssembly app,
    which will respond to and interact with these live data points in compelling ways.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 没有网络用户希望不断刷新以获取最新信息。他们希望立即自动获取所有内容。实时Web功能非常普遍，大多数现代应用程序都需要。许多应用程序依赖实时数据，以便在其变为可用时向用户提供相关信息。在本章中，您将学习如何使用ASP.NET
    Core SignalR（或仅SignalR）实现实时Web功能。然后，您将了解如何创建一个服务器端（`Hub`），该服务器端将公开许多实时数据点，例如实时警报和通知，用于实时用户交互的消息系统，以及可加入的活动Twitter流。最后，您将学习如何从我们的Blazor
    WebAssembly应用程序中消耗这些数据，并以引人注目的方式响应和与这些实时数据点交互。
- en: Defining the Server-Side Events
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义服务器端事件
- en: For your Blazor app to have real-time web functionalities, you need a way for
    it to receive live data. That’s where SignalR comes in. Real-time browser-to-server
    protocols such as WebSockets or Server-Side Events can be complex to implement.
    SignalR provides an abstraction layer over these protocols and reduces the complexity
    with a succinct API. To handle the many clients to a single server, SignalR introduces
    the hub as a proxy between the clients and the server. In a hub, you define methods
    that can be called directly from clients. Likewise, the server can call methods
    on any of the connected clients. With a hub, you can define methods from the client
    to the server or server to the client—this is a two-way (duplex) communication.
    There is also a cloud-ready implementation of SignalR, called [Azure SignalR Service](https://oreil.ly/C8Vae).
    This service removes the need to manage backplanes that handle scalability and
    client connectivity.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 要使您的Blazor应用程序具有实时Web功能，您需要一种方式让其接收实时数据。这就是SignalR的用武之地。实时浏览器到服务器的协议，例如WebSockets或服务器端事件，可能很难实现。SignalR通过简洁的API提供了这些协议的抽象层，并减少了复杂性。为了处理单个服务器上的多个客户端，SignalR引入了hub作为客户端和服务器之间的代理。在hub中，您可以定义可以直接从客户端调用的方法。同样，服务器可以在任何连接的客户端上调用方法。有了hub，您可以定义从客户端到服务器或服务器到客户端的方法——这是双向（双工）通信。还有一个名为[Azure
    SignalR Service](https://oreil.ly/C8Vae)的云就绪实现。此服务消除了管理处理可扩展性和客户端连接性的后端处理的需要。
- en: The point of doing this is to allow your app to have real-time alerts, a messaging
    system for live-user interactions, and a joinable active Twitter stream. SignalR
    makes all of this possible.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的目的是允许您的应用程序具有实时警报，用于实时用户交互的消息系统和可加入的活动Twitter流。SignalR使所有这些成为可能。
- en: This concept of one machine calling into another is known as a *remote procedure
    call* (RPC). All communication to the server requires an authentication token.
    Without a valid authentication token, the connection will not be established or
    maintained. With a valid token, the communication between the Web.Client app and
    the HTTP endpoints that it relies on is going to establish an open line where
    messages can be sent and received unsolicited from either process over network
    boundaries in real time. The optimal scenario is when both processes negotiate
    and agree upon the usage of WebSockets as the communication transport.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一个机器调用另一个机器的概念称为*远程过程调用*（RPC）。所有发送到服务器的通信都需要认证令牌。没有有效的认证令牌，连接将无法建立或维持。有了有效的令牌，Web.Client
    应用程序与其依赖的HTTP端点之间的通信将建立一个开放的线路，可以实时发送和接收消息，而不论任何一个过程跨越网络边界。最佳情况是，这两个过程协商并同意使用WebSockets作为通信传输方式。
- en: Exposing Twitter Streams and Chat Functionality
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公开Twitter流和聊天功能
- en: The following examples highlight a live stream of tweets and a presence-aware
    chat implementation, as shown in Figures [6-1](#tweets-page) and [6-2](#chat-page-welcome).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例突出显示了推文的实时流和一个有在场感知的聊天实现，如图[6-1](#tweets-page)和[6-2](#chat-page-welcome)所示。
- en: '![](assets/lblz_0601.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lblz_0601.png)'
- en: Figure 6-1\. `Tweets` page rendering
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-1。`Tweets`页面渲染
- en: '![](assets/lblz_0602.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lblz_0602.png)'
- en: Figure 6-2\. `Chat` page rendering
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-2\. `Chat` 页面渲染
- en: 'The Learning Blazor model app makes use of a single notification hub that manages
    all of the real-time functionality. In the model app, the Web.Api project contains
    the SignalR hub definition. It defines a single `NotificationHub` class, but there
    are three files in total. Each of these files represents a `partial` implementation
    of the `NotificationHub` object. The domain-specific segments are encapsulated
    within their file, for example, the *NotificationHub.Chat.cs* and *NotificationHub.Tweets.cs*.
    Let’s examine the *NotificationHub.cs* C# file first:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Learning Blazor 模型应用程序使用单个管理所有实时功能的通知中心。 在模型应用程序中，Web.Api 项目包含 SignalR 中心定义。
    它定义了一个名为 `NotificationHub` 的单个类，但总共有三个文件。 每个文件代表 `NotificationHub` 对象的 `partial`
    实现。 领域特定的段在其文件中封装，例如 *NotificationHub.Chat.cs* 和 *NotificationHub.Tweets.cs*。
    让我们首先检查 *NotificationHub.cs* C# 文件：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO1-1)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO1-1)'
- en: '`NotificationHub` is protected by the apps Azure AD B2C tenant.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`NotificationHub` 受应用程序的 Azure AD B2C 租户保护。'
- en: '[![2](assets/2.png)](#co_exemplifying_real_time_web_functionality_CO1-2)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_exemplifying_real_time_web_functionality_CO1-2)'
- en: The `override Task OnConnectedAsync` method is implemented as an expression
    that sends an event `HubServerEventNames.UserLoggedIn` to all the connected clients.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`override Task OnConnectedAsync` 方法被实现为将事件 `HubServerEventNames.UserLoggedIn`
    发送给所有连接的客户端的表达式。'
- en: '[![3](assets/3.png)](#co_exemplifying_real_time_web_functionality_CO1-3)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_exemplifying_real_time_web_functionality_CO1-3)'
- en: The `override Task OnDisconnectedAsync` method expects an error.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`override Task OnDisconnectedAsync` 方法预期出现错误。'
- en: 'A valid authentication token must be provided from one of the configured third-party
    authentication providers, and the claims of the request must be a part of the
    `"User.ApiAccess"` scope. `NotificationHub` is a descendant of the framework-provided
    `Hub` class. This is a requirement for a SignalR server: they must expose a hub
    endpoint. The primary functionality in this file is the constructor (`.ctor`)
    definition and the overrides for handling connection and disconnection events.
    The other hub partials are domain-specific. This class defines several fields:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 必须从配置的第三方身份验证提供程序之一提供有效的身份验证令牌，并且请求的声明必须是 `"User.ApiAccess"` 范围的一部分。 `NotificationHub`
    是框架提供的 `Hub` 类的后代。 这是 SignalR 服务器的要求：它们必须公开一个中心端点。 该文件的主要功能是构造函数（`.ctor`）定义和处理连接和断开连接事件的覆盖。
    其他中心局部是特定于领域的。 该类定义了几个字段：
- en: '`ITwitterService _twitterService`'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`ITwitterService _twitterService`'
- en: This service relies on the [`TweetInvi` NuGet package](https://oreil.ly/wcZVs).
    It manages streaming Twitter APIs and streams filtered on specific hashtags and
    handles.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务依赖于 [`TweetInvi` NuGet package](https://oreil.ly/wcZVs)。 它管理流式传输的 Twitter
    API，并处理特定标签和句柄的流。
- en: '`IStringLocalizer<Shared> _localizer`'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`IStringLocalizer<Shared> _localizer`'
- en: The `Shared` class contains resources for the `NotificationHub` that are localized.
    Certain generic messages are translated for the alert and notification system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shared` 类包含本地化的 `NotificationHub` 资源。 某些通用消息已翻译为警报和通知系统。'
- en: '`string _userName`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`string _userName`'
- en: The hub has a single user in context. This user is the representation of the
    deserialized tokens from the authentication connection—in other words, the user
    who is currently interacting with the hub.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 中心上下文中只有一个用户。 该用户是来自认证连接的反序列化令牌的表示—换句话说，当前与中心交互的用户。
- en: '`string[]? _userEmail`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`string[]? _userEmail`'
- en: The hub’s user also has one or more email addresses.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 该中心的用户还具有一个或多个电子邮件地址。
- en: 'The event is a `Notification<Actor>`. The generic notification object is a
    `record class` with a user name and an array of email addresses. These events
    are somewhat generic, so they can be shared by different interested parties on
    the client. There are some additional features the model app requires to provide
    a feature-rich chat room experience. You’ll learn a nice clean way to implement
    the “user is typing” indicator, create and share custom rooms, edit sent messages,
    and so on in this chapter. These same features can be reused in your Blazor apps
    by using similar code. Let’s explore the *NotificationHub.Chat.cs* C# file as
    it shows the hub’s implementation of the chat functionality:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是一个`Notification<Actor>`。泛型通知对象是一个`record class`，包含用户名和电子邮件地址数组。这些事件有些通用，因此可以由客户端上的不同利益相关者共享。模型应用程序还需要一些附加功能，以提供丰富的聊天室体验。在本章中，您将学习一种干净的方法来实现“用户正在输入”指示器，创建和共享自定义房间，编辑发送的消息等等。通过使用类似的代码，这些相同的功能可以在您的Blazor应用程序中重复使用。让我们探索*C#文件*
    `NotificationHub.Chat.cs` ，因为它展示了聊天功能的中心的实现：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO2-1)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO2-1)'
- en: The `ToggleUserTyping` method alters the state of a client chat user.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToggleUserTyping`方法改变客户端聊天用户的状态。'
- en: '[![2](assets/2.png)](#co_exemplifying_real_time_web_functionality_CO2-2)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_exemplifying_real_time_web_functionality_CO2-2)'
- en: The `PostOrUpdateMessage` method posts a message to the chat room.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`PostOrUpdateMessage`方法将消息发布到聊天室中。'
- en: '[![3](assets/3.png)](#co_exemplifying_real_time_web_functionality_CO2-3)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_exemplifying_real_time_web_functionality_CO2-3)'
- en: The `JoinChat` method adds the client to the chat room.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`JoinChat`方法将客户端添加到聊天室中。'
- en: '[![4](assets/4.png)](#co_exemplifying_real_time_web_functionality_CO2-4)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_exemplifying_real_time_web_functionality_CO2-4)'
- en: The `LeaveChat` method removes the client from the chat room.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`LeaveChat`方法将客户端从聊天室中移除。'
- en: The `ToggleUserTyping` method accepts a `bool` value that indicates if the contextual
    user’s connection is actively typing in the chat room. This signals the `HubServer​E⁠ventNames.UserTyping`
    event sending out a `Notification<ActorAction>` object that represents the user
    and their typing status as a message.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToggleUserTyping`方法接受一个`bool`值，指示上下文用户是否正在聊天室中积极输入。这会触发`HubServerEventNames.UserTyping`事件，向外发送一个表示用户及其输入状态的`Notification<ActorAction>`对象作为消息。'
- en: The `PostOrUpdateMessage` method defines `room` and `message` `string` parameters
    and an optional `id`. If the `id` is `null`, a new globally unique identifier
    (GUID) is assigned to the message. The message contains the message text, the
    user who sent it, and whether the message is considered edited. This is used for
    both creating and updating user chat messages.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`PostOrUpdateMessage`方法定义了`room`和`message` `string`参数，以及一个可选的`id`。如果`id`为`null`，则将全局唯一标识符（GUID）分配给消息。消息包含消息文本、发送消息的用户以及消息是否被视为已编辑。这用于创建和更新用户聊天消息。'
- en: The `JoinChat` method requires a `room`. When called, the current connection
    is added to either a new or existing SignalR group with the matching room name.
    The method then lets the current caller know that the `HubServerEventNames.MessageReceived`
    event has fired, sending a welcome message to the chat room. This event sends
    a `Notification<ActorMessage>`. All clients have access to this custom generic
    notification model; it’s part of the Web.Models project. This is perfect because
    the clients can share these models, and serialization just works. This is far
    different than your typical JavaScript development, where you’d struggle to maintain
    the ever-changing shapes of API objects.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`JoinChat`方法需要一个`room`。调用时，当前连接将被添加到具有匹配房间名称的新建或现有SignalR组中。然后，该方法会告知当前调用者`HubServerEventNames.MessageReceived`事件已触发，向聊天室发送欢迎消息。此事件会发送一个`Notification<ActorMessage>`。所有客户端都可以访问此自定义泛型通知模型；它是Web.Models项目的一部分。这非常完美，因为客户端可以共享这些模型，并且序列化工作正常。这与您典型的JavaScript开发大不相同，后者需要努力维护API对象的不断变化的形状。'
- en: The `LeaveChat` method is the companion to the `JoinChat` functionality. This
    is intentional—you need a way to exit a `room` once you’ve joined it from the
    client. This happens in the `LeaveChat` method where `HubServerEventNames.MessageReceived`
    is sent from chat. The current contextual user’s connection to the SignalR hub
    instance removes them from the chat room. That specific group is sent an automated
    message with a bot user name and a localized message.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`LeaveChat` 方法是`JoinChat`功能的伴侣。这是有意的——一旦从客户端加入房间，您需要一种退出`room`的方式。这在`LeaveChat`方法中发生，其中从聊天发送`HubServerEventNames.MessageReceived`。当前上下文用户连接到SignalR中心实例中移除他们从聊天室。该特定组将使用机器人用户名和本地化消息发送自动化消息。'
- en: 'The chat functionality is taking shape. Imagine now that your app requires
    access to a live Twitter feed. The model app provides an example of how to do
    this too. With a requirement for Twitter-specific functionality that is communicated
    in real time, consider the *NotificationHub.Tweets.cs* C# file hub implementation:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天功能正在形成。现在想象一下，你的应用程序需要访问实时 Twitter 动态。模型应用程序提供了如何实现这一点的示例。需要特定于 Twitter 的功能，通过实时通信来传达，考虑*C#文件*中的*NotificationHub.Tweets.cs*实现：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO3-1)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO3-1)'
- en: The `JoinTweets` method adds the client to the `Tweets` group.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`JoinTweets` 方法将客户端添加到 `Tweets` 组中。'
- en: '[![2](assets/2.png)](#co_exemplifying_real_time_web_functionality_CO3-2)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_exemplifying_real_time_web_functionality_CO3-2)'
- en: The `LeaveTweets` method removes the client from the `Tweets` group.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`LeaveTweets` 方法从 `Tweets` 组中移除客户端。'
- en: '[![3](assets/3.png)](#co_exemplifying_real_time_web_functionality_CO3-3)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_exemplifying_real_time_web_functionality_CO3-3)'
- en: The `StartTweetStream` method starts the tweet stream.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`StartTweetStream` 方法启动推文流。'
- en: 'The RPCs in the tweets hub bring together the ability to join the tweet stream.
    When this fires, the current connection joins the `HubGroupNames.Tweets` group.
    The scoped `_twitterService` is asked a few questions, such as what the current
    streaming status is and if there are any tweets in memory:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Tweets hub中的RPC汇集了加入推文流的能力。当这发生时，当前连接加入`HubGroupNames.Tweets`组。局部作用域的`_twitterService`被问及一些问题，例如当前流状态是什么，内存中是否有推文：
- en: When the current Twitter streaming status is not `null` and has a value, it’s
    assigned to `status` variables. This `status` flows to all connected clients,
    as they’re notified of the current Twitter `StreamingStatus`.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当当前Twitter流状态不为`null`并且具有值时，它被分配给`status`变量。这个`status`流向所有连接的客户端，因为他们被通知当前Twitter`StreamingStatus`。
- en: When there are tweets in memory, all connected clients are notified of the tweets
    as a `List<TweetContents>` collection.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当内存中有推文时，所有连接的客户端都会被通知推文，作为`List<TweetContents>`集合。
- en: The `LeaveTweets` method removes the contextual connection from the `HubGroupNames.Tweets`
    group. The `StartTweetStream` is idempotent as it can be called multiple times
    without changing the state of the first successful call to start the tweet stream.
    This is represented as an asynchronous operation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`LeaveTweets` 方法从 `HubGroupNames.Tweets` 组中移除上下文连接。`StartTweetStream` 是幂等的，可以多次调用而不改变状态，第一次成功调用开始推文流。这是一个异步操作的表示。'
- en: You’re probably starting to wonder where the live tweets are coming from. We’ll
    cover that next when we look at the background service.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能开始想知道实时推文来自哪里了。下一步我们将在后台服务中查看。
- en: Writing Contextual RPC and Inner-Process Communication
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写上下文RPC和进程内通信
- en: The Web.Api project of our model app is responsible for exposing an HTTP API
    surface area, so it’s scoped to handle requests and provide responses. We’re going
    to explore how to use an `IHubContext`, which allows our background service to
    communicate with the `NotificationHub` implementation. Beyond that, the model
    app shows a SignalR `/notifications` endpoint, which is handled by the collective
    representation of all `partial NotificationHub class` implementations. As for
    the live-streaming aspect of this application, we rely on a Twitter service, but
    we need a way to listen for events. Within an ASP.NET Core app, you can use a
    `Background​Ser⁠vice`, which runs in the same process but outside the request
    and response pipeline. SignalR provides a mechanism to access `NotificationHub`
    through an `IHub​Context` interface. This all comes together as shown in [Figure 6-3](#web-api-server).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模型应用程序的Web.Api项目负责暴露HTTP API表面，因此它的范围包括处理请求和提供响应。我们将探讨如何使用`IHubContext`，它允许我们的后台服务与`NotificationHub`实现通信。此外，模型应用程序显示了一个由所有`partial
    NotificationHub class`实现共同表示的SignalR`/notifications`端点。关于此应用程序的实时流方面，我们依赖于Twitter服务，但我们需要一种监听事件的方法。在ASP.NET
    Core应用程序中，您可以使用`Background​Ser⁠vice`，它在同一进程中运行，但在请求和响应管道之外。SignalR提供了一种通过`IHub​Context`接口访问`NotificationHub`的机制。所有这些都如图[6-3](#web-api-server)所示。
- en: '![](assets/lblz_0603.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lblz_0603.png)'
- en: Figure 6-3\. The Web.Api server project
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-3。Web.Api服务器项目
- en: 'Let’s look at the *TwitterWorkerService.cs* C# file next:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们看看*C#*文件*TwitterWorkerService.cs*：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO4-1)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO4-1)'
- en: '`TwitterWorkerService` implements `BackgroundService`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`TwitterWorkerService`实现了`BackgroundService`。'
- en: '[![2](assets/2.png)](#co_exemplifying_real_time_web_functionality_CO4-2)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_exemplifying_real_time_web_functionality_CO4-2)'
- en: The constructor takes the `ITwitterService` and `IHubContext` as parameters.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受`ITwitterService`和`IHubContext`作为参数。
- en: '[![3](assets/3.png)](#co_exemplifying_real_time_web_functionality_CO4-3)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_exemplifying_real_time_web_functionality_CO4-3)'
- en: The `ExecuteAsync` method is the main entry point for the service.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecuteAsync`方法是服务的主要入口点。'
- en: '[![4](assets/4.png)](#co_exemplifying_real_time_web_functionality_CO4-4)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_exemplifying_real_time_web_functionality_CO4-4)'
- en: The `OnStatusUpdated` method is called when `_twitterService` fires the `StatusUpdated`
    event.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当`_twitterService`触发`StatusUpdated`事件时，将调用`OnStatusUpdated`方法。
- en: '[![5](assets/5.png)](#co_exemplifying_real_time_web_functionality_CO4-5)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_exemplifying_real_time_web_functionality_CO4-5)'
- en: '`OnTweetReceived` handles the `TweetReceived` event, notifying all clients
    in the `HubGroupNames.Tweets` group.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnTweetReceived`处理`TweetReceived`事件，并通知`HubGroupNames.Tweets`组中的所有客户端。'
- en: '`TwitterWorkerService` is a descendant of `BackgroundService`. Background services
    are long-lived apps that execute in a loop but with access to the notification
    hub’s context, and they can send messages through their connected clients. This
    class defines two fields:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`TwitterWorkerService`是`BackgroundService`的后代。后台服务是长期运行的应用程序，它们在循环中执行，但可以通过其连接的客户端访问通知中心，并且可以通过它们发送消息。此类定义了两个字段：'
- en: '`ITwitterService _twitterService`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`_twitterService`为`ITwitterService`'
- en: This is the same service that was used in the `NotificationHub` for in-memory
    streaming status and tweets. It can now handle events from the underlying `TweetInvi`’s
    filtered streams.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这项服务用于`NotificationHub`中的内存流状态和推文，现在也可以处理来自底层`TweetInvi`过滤流的事件。
- en: '`IHubContext<NotificationHub> _hubContext`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`_hubContext`为`IHubContext<NotificationHub>`'
- en: This object is used to send messages out to connected clients of the SignalR
    server hub.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象用于向SignalR服务器中连接的客户端发送消息。
- en: The `TwitterWorkerService` constructor declares the values as parameters. The
    DI framework will provide the service and hub context objects. They’re positionally
    assigned using an immediate deconstruction of a tuple literal from the `.ctor`
    parameters. `_twitterService` has its `StatusUpdated` and `TweetReceived` event
    handlers assigned. The Twitter service exposes an eventing mechanism and fires
    an event when a tweet is received. In C# you can subscribe a delegate to events
    that will serve as a callback. There is no need to unsubscribe from the events
    because the app will not stop unless the entire app is torn down. In that case,
    we’re not holding on to any unsubscribed events—the entire process is being terminated.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`TwitterWorkerService`构造函数将值声明为参数。依赖注入框架将提供服务和中心上下文对象。它们使用元组字面量的立即解构进行位置分配。`_twitterService`有其`StatusUpdated`和`TweetReceived`事件处理程序分配。Twitter服务暴露了一个事件机制，并在接收到推文时触发事件。在C#中，您可以订阅一个委托到事件，它将作为回调函数。不需要取消订阅事件，因为除非整个应用程序被关闭，否则应用程序不会停止。在这种情况下，我们没有持有任何未订阅的事件——整个过程正在终止。'
- en: The `ExecuteAsync` method is implemented as a signal that the app can perform
    its task. This just spins, listening for the stopping token’s cancellation request.
    It just delays and listens in an asynchronous loop.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecuteAsync`方法被实现为应用程序可以执行其任务的信号。这只是在异步循环中延迟和监听停止令牌的取消请求。'
- en: When the `_twitterService.OnStatusUpdated` event fires, an update on the current
    streaming status is sent to all subscribers. All contextual clients in the `HubGroupNames.Tweets`
    group are sent the `HubServerEventNames.StatusUpdated` event. The notification
    is `StreamingStatus`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当`_twitterService.OnStatusUpdated`事件触发时，向所有订阅者发送当前流状态的更新。`HubGroupNames.Tweets`组中的所有上下文客户端都会收到`HubServerEventNames.StatusUpdated`事件。通知是`StreamingStatus`。
- en: The `_twitterService.OnTweetReceived` event is handled when a new `Tweet​Con⁠tents
    tweet` object is received. These `tweet` contents are sent from the `Hub​ServerEventNames.TweetReceived`
    event. They are also sent over to the same group named `HubGroupNames.Tweets`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 处理`_twitterService.OnTweetReceived`事件时，当接收到新的`TweetContents`对象时。这些推文内容从`HubServerEventNames.TweetReceived`事件发送。它们也发送到名为`HubGroupNames.Tweets`的同一组中。
- en: The server functionality is complete. With this, we can serve up a SignalR connection
    over a negotiated `/notifications` endpoint. Each client negotiates what protocol
    and transport they speak. A SignalR transport is the communication handler, such
    as WebSockets, Server-Sent Events, and Long Polling. There are various ways in
    which clients can talk to servers and vice versa. This usually follows a fallback
    convention of preferred defaults to less than preferred. The good news is that
    most modern browser environments support WebSockets, which are highly performant.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器功能已完成。通过此功能，我们可以通过协商的`/notifications`端点提供SignalR连接。每个客户端协商他们要使用的协议和传输方式。SignalR传输是通信处理程序，例如WebSockets、服务器发送事件和长轮询。客户端和服务器可以以各种方式进行通信。这通常遵循首选默认到次优的回退约定。好消息是，大多数现代浏览器环境支持高性能的WebSockets。
- en: Configuring the Hub Endpoint
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Hub端点
- en: 'For the functionality of the hub to be exposed as a consumable route, it has
    to configure how clients will communicate with it. There are a few things that
    need to be configured:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使得中心功能作为可消费的路由公开，必须配置客户端如何与其通信。有几个需要配置的事项：
- en: The desired message and transport protocols (may require additional NuGet packages)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所需的消息和传输协议（可能需要额外的NuGet包）
- en: The mapping of `NotificationHub` to the `/notifications` endpoint
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`NotificationHub`映射到`/notifications`端点
- en: The registration of `TwitterWorkerService` as a hosted service (`Background​Ser⁠vice`)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`TwitterWorkerService`注册为托管服务（`BackgroundService`）
- en: Since the Web.Api project targets the `net6.0` TFM and specifies `<Project Sdk="Microsoft.NET.Sdk.Web">`,
    SignalR is implicitly referenced as part of the SDK’s meta-package. For an overview
    of SDKs in .NET, see Microsoft’s [“.NET Project SDKs” documentation](https://oreil.ly/T4WRW).
    The default message protocol is JSON (text-based protocol), which is human-readable
    and convenient for debugging. However, it is far more efficient to use MessagePack,
    which is a binary protocol, and messages are usually half the size.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Web.Api 项目目标为 `net6.0` TFM，并指定 `<Project Sdk="Microsoft.NET.Sdk.Web">`，SignalR
    隐式引用为 SDK 的元包。有关 .NET 中 SDK 的概述，请参阅 Microsoft 的 [“.NET Project SDKs” 文档](https://oreil.ly/T4WRW)。默认的消息协议是
    JSON（基于文本的协议），适合人类阅读和方便调试。但是，使用 MessagePack 更高效，它是一种二进制协议，消息通常大小减半。
- en: 'The *Web.Api.csproj* XML file includes the following among other package references:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*Web.Api.csproj* XML 文件包含以下内容，以及其他的包引用：'
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO5-1)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO5-1)'
- en: The `Microsoft.AspNetCore.SignalR.Protocols.MessagePack` NuGet package reference
    is included.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 包含了 `Microsoft.AspNetCore.SignalR.Protocols.MessagePack` NuGet 包引用。
- en: This exposes the MessagePack binary protocol. The client has to also configure
    MessagePack for this protocol to be used or it will fall back to the default text-based
    JSON protocol.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这暴露了 MessagePack 二进制协议。客户端也必须为该协议配置 MessagePack，否则将回退到默认的基于文本的 JSON 协议。
- en: 'In the Web.Api project’s `Startup` class, we add SignalR and map the `NotificationHub`
    to the `"/notifications"` endpoint. Consider the *Startup.cs* C# file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web.Api 项目的 `Startup` 类中，我们添加了 SignalR，并将 `NotificationHub` 映射到 `"/notifications"`
    终端。考虑 *Startup.cs* C# 文件：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `Startup` class is `partial`, and it defines only the `_configuration`
    field and the constructor that accepts the configuration. By convention, a startup
    object has two methods:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`Startup` 类是 `partial`，仅定义了 `_configuration` 字段和接受配置的构造函数。按照约定，启动对象有两种方法：'
- en: '`ConfigureServices(IServiceCollection services)`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfigureServices(IServiceCollection services)`'
- en: This method is responsible for registering services on the service collection
    (commonly achieved with helper `Add{DomainService}` extension methods).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法负责在服务集合上注册服务（通常使用帮助器的 `Add{DomainService}` 扩展方法来实现）。
- en: '`Configure(IApplicationBuilder app, IWebHostEnvironment env)`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Configure(IApplicationBuilder app, IWebHostEnvironment env)`'
- en: This method is responsible for configuring services for usage (commonly achieved
    with helper `Use{DomainService}` extension methods).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法负责配置服务的使用（通常使用帮助器的 `Use{DomainService}` 扩展方法来实现）。
- en: 'First, we add SignalR in the *Startup.ConfigureServices.cs* C# file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 *Startup.ConfigureServices.cs* C# 文件中添加 SignalR：
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO6-1)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO6-1)'
- en: '`IServiceCollection` has services added to it.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`IServiceCollection` 中添加了服务。'
- en: '[![2](assets/2.png)](#co_exemplifying_real_time_web_functionality_CO6-2)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_exemplifying_real_time_web_functionality_CO6-2)'
- en: '`JwtBearerOptions` are configured.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 配置了 `JwtBearerOptions`。
- en: '[![3](assets/3.png)](#co_exemplifying_real_time_web_functionality_CO6-3)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_exemplifying_real_time_web_functionality_CO6-3)'
- en: The `SignalR` service is configured to show detailed errors and adds `MessagePack`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 配置了 `SignalR` 服务以显示详细错误，并添加了 `MessagePack`。
- en: Authentication middleware is added, and this should look a bit familiar by now—it’s
    configured using the same Azure AD B2C tenant shown in previous chapters. It is
    configured to use the `"name"` as the name claim type. Since our Blazor WebAssembly
    app makes requests to different origins, our API needs to allow CORS.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了身份验证中间件，这应该看起来有点熟悉了——它使用了前几章中展示的相同 Azure AD B2C 租户进行配置。它配置为使用 `"name"` 作为名称声明类型。由于我们的
    Blazor WebAssembly 应用程序向不同的来源发出请求，我们的 API 需要允许 CORS。
- en: SignalR is added, using the `.AddSignalR` extension method. Chained fluently
    on this call is a call to `AddMessagePackProtocol`, and as the name signifies,
    this will add MessagePack as the desired SignalR message protocol.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了 SignalR，使用 `.AddSignalR` 扩展方法。在此调用链上链式地调用了 `AddMessagePackProtocol`，正如其名称所示，这将添加
    MessagePack 作为期望的 SignalR 消息协议。
- en: 'After adding these services to the startup routine, now we can configure them.
    Let’s have a look at the *Startup.Configure.cs* C# file:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些服务添加到启动例程后，现在我们可以对它们进行配置。让我们看看 *Startup.Configure.cs* C# 文件：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO7-1)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO7-1)'
- en: The `Configure` method is a convention of ASP.NET Core web apps. It configures
    services for DI.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Configure` 方法是 ASP.NET Core web 应用程序的一个约定。它配置了依赖注入的服务。'
- en: '[![2](assets/2.png)](#co_exemplifying_real_time_web_functionality_CO7-2)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_exemplifying_real_time_web_functionality_CO7-2)'
- en: The Web.Api project supports request localization, which is similar to localization
    detailed in [Chapter 5](ch05.html#chapter-five) with translation resource files
    and the `IString​Local⁠izer<T>` abstraction.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Web.Api 项目支持请求本地化，类似于 [第 5 章](ch05.html#chapter-five) 中详细介绍的本地化，使用翻译资源文件和 `IString​Local⁠izer<T>`
    抽象。
- en: '[![3](assets/3.png)](#co_exemplifying_real_time_web_functionality_CO7-3)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_exemplifying_real_time_web_functionality_CO7-3)'
- en: '`NotificationHub` is mapped to its endpoint.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`NotificationHub` 映射到其终端点。'
- en: The `Configure` functionality starts by conditionally using the developer exception
    page when the current runtime environment is configured as `"Development"`. HTTPs
    redirection is used, which enforces the `https://` scheme for the API. The use
    of routing enables endpoint middleware services. Next, the model app’s CORS that
    was previously added is now being used.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`Configure` 功能从根据当前运行时环境配置为 `"Development"` 条件性地使用开发者异常页面开始。使用 HTTPs 重定向，强制
    API 使用 `https://` 方案。使用路由功能启用终端点中间件服务。接下来，之前添加的模型应用程序的 CORS 现在正在使用。'
- en: 'In the previous chapter, we explored the concepts of localization. In the Web.Api
    project, we use a variation of the same approach. While all resource files use
    the same mechanics in this project, the concept of localization from a Web API
    project requires a request-specific middleware that will automatically set the
    appropriate `Culture` based on the HTTP request itself. The configuration routine
    specifies the use of several more middleware services:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们探讨了本地化的概念。在 Web.Api 项目中，我们使用了相同方法的变体。虽然在本项目中所有资源文件都使用相同的机制，但是在 Web API
    项目中，本地化的概念需要一个特定于请求的中间件，该中间件将根据 HTTP 请求自动设置适当的 `Culture`。配置过程指定了使用几个更多的中间件服务：
- en: '`UseAuthentication`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseAuthentication`'
- en: Uses the added Azure AD B2C tenant
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用添加的 Azure AD B2C 租户
- en: '`UseAuthorization`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseAuthorization`'
- en: Allows APIs to be decorated with `Authorize` attributes, which require an authenticated
    user
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 允许 API 使用 `Authorize` 属性进行装饰，要求经过身份验证的用户
- en: '`ResponseCaching`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResponseCaching`'
- en: Allows APIs to declaratively specify caching behavior
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 允许 API 声明性地指定缓存行为
- en: The call to `UseEndpoints` is required for SignalR, as `NotificationHub` is
    mapped to the `"/notifications"` endpoint. With that in place, the project is
    ready to serve many connected clients concurrently.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `UseEndpoints` 对于 SignalR 是必需的，因为 `NotificationHub` 映射到 `"/notifications"`
    终端点。有了这些设置，项目已准备好同时为多个连接的客户端提供服务。
- en: In the next section, we will examine how this data is ingested by the client
    app.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将研究客户端应用程序如何接收这些数据。
- en: Consuming Real-Time Data on the Client
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在客户端消费实时数据
- en: Getting back to the Web.Client project, the model app for this book uses real-time
    data in several components and pages. To avoid opening multiple connections to
    the server from a single client, a shared approach for the hub connection is used.
    Each client will have exactly one `SharedHubConnection` instance. The `SharedHub​Con⁠nection`
    class has several implementations, and it’s responsible for managing a single
    framework-provided `HubConnection` that is shared by several components. Before
    we can use a `HubConnection`, we must first configure the client to support this
    type. The `SharedHubConnection` class shares a single `HubConnection` instance,
    and it’s responsible for managing the connection in a thread-safe manner.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 Web.Client 项目，本书的示范应用在多个组件和页面中使用实时数据。为了避免从单个客户端向服务器打开多个连接，使用了一种共享的方法来处理
    hub 连接。每个客户端将具有一个 `SharedHubConnection` 实例。`SharedHubConnection` 类有几个实现，负责以线程安全的方式管理一个由框架提供的共享的
    `HubConnection`。在使用 `HubConnection` 之前，我们必须首先配置客户端以支持此类型。`SharedHubConnection`
    类共享一个 `HubConnection` 实例，并负责以线程安全的方式管理连接。
- en: Configuring the Client
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置客户端
- en: 'To configure SignalR on the client, our Web.Client project has to include two
    NuGet package references:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要在客户端配置 SignalR，我们的 Web.Client 项目必须包含两个 NuGet 包引用：
- en: '[`Microsoft.AspNetCore.SignalR.Client`](https://oreil.ly/P1bXb)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Microsoft.AspNetCore.SignalR.Client`](https://oreil.ly/P1bXb)'
- en: '[`Microsoft.AspNetCore.SignalR.Protocols.MessagePack`](https://oreil.ly/oZLi1)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Microsoft.AspNetCore.SignalR.Protocols.MessagePack`](https://oreil.ly/oZLi1)'
- en: In addition to these packages, the custom `SharedHubConnection` class was registered
    as a singleton with the client’s service provider, enabling it as a resolvable
    service through DI. This was initially discussed in [“The Web.Client ConfigureServices
    Functionality”](ch04.html#web-client-configure-services). Only a single instance
    of this service will exist for the lifetime of the client app. This is an important
    detail as it shares a connection state with all of the consuming components and
    pages. Next, we’ll look at the `SharedHubConnection` implementation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些包之外，自定义的`SharedHubConnection`类被注册为客户端的服务提供程序中的单例，使其通过 DI 成为可解析的服务。这最初在[“Web.Client
    ConfigureServices 功能”](ch04.html#web-client-configure-services)中讨论过。这个服务的生命周期内只会存在一个实例。这是一个重要的细节，因为它与所有消费组件和页面共享连接状态。接下来，我们将看一下`SharedHubConnection`的实现。
- en: Sharing a Hub Connection
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享 Hub 连接
- en: 'The `SharedHubConnection` class is used by any component or page within the
    client app that needs to talk to the SignalR server, regardless of whether the
    component needs to push data to the server or whether the client subscribes to
    server events or both. The *SharedHubConnection.cs* C# contains the logic for
    sharing a single framework-provided `HubConnection`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`SharedHubConnection`类被客户端应用程序中需要与 SignalR 服务器通信的任何组件或页面使用，无论组件是否需要向服务器推送数据，还是客户端订阅服务器事件或两者兼有。*SharedHubConnection.cs*
    C# 包含了共享单个框架提供的`HubConnection`的逻辑：'
- en: '[PRE8]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO8-1)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO8-1)'
- en: '`SharedHubConnection` is a `sealed partial class`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`SharedHubConnection`是一个`sealed partial class`。'
- en: '[![2](assets/2.png)](#co_exemplifying_real_time_web_functionality_CO8-2)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_exemplifying_real_time_web_functionality_CO8-2)'
- en: '`SharedHubConnection` defines several fields that are used to help manage the
    shared hub connection.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`SharedHubConnection`定义了几个字段，用于帮助管理共享的 hub 连接。'
- en: '[![3](assets/3.png)](#co_exemplifying_real_time_web_functionality_CO8-3)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_exemplifying_real_time_web_functionality_CO8-3)'
- en: The `SharedHubConnection` constructor initializes supporting fields from the
    defined parameters.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`SharedHubConnection` 构造函数从定义的参数初始化支持字段。'
- en: '[![4](assets/4.png)](#co_exemplifying_real_time_web_functionality_CO8-4)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_exemplifying_real_time_web_functionality_CO8-4)'
- en: '`SharedHubConnection` explicitly implements the `IAsyncDisposable.Dispose​A⁠sync`
    method.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`SharedHubConnection`显式实现了`IAsyncDisposable.Dispose​A⁠sync`方法。'
- en: First off, notice that `SharedHubConnection` is an implementation of the `IAsync​Dis⁠posable`
    interface. This enables the `SharedHubConnection` class to clean up any managed
    resources that need to be released asynchronously.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意`SharedHubConnection`是`IAsync​Dis⁠posable`接口的实现。这使得`SharedHubConnection`类能够异步清理需要释放的任何托管资源。
- en: 'Then the class defines several fields that are initialized during construction
    (or inline). They’re described as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后类定义了几个在构造过程中（或内联）初始化的字段。它们的描述如下：
- en: '`IServiceProvider _serviceProvider`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`IServiceProvider _serviceProvider`'
- en: The service provider from the client app.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序的服务提供程序。
- en: '`ILogger<SharedHubConnection> _logger`'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`ILogger<SharedHubConnection> _logger`'
- en: A logger instance specific to `SharedHubConnection`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特定于`SharedHubConnection`的日志记录器实例。
- en: '`CultureService _cultureService`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`CultureService _cultureService`'
- en: Used to populate the “Accept-Language” HTTP header for requests made from the
    hub connection.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 用于为从 hub 连接发出的请求填充“Accept-Language”HTTP 头。
- en: '`HubConnection _hubConnection`'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`HubConnection _hubConnection`'
- en: The framework-provided representation of the client’s connection to the server’s
    hub.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端连接到服务器 hub 的框架提供的表示。
- en: '`SemaphoreSlim _lock`'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`SemaphoreSlim _lock`'
- en: An asynchronous locking mechanism used for thread-safe concurrent access. This
    lock is used in the shared `StartAsync` method command that is detailed later
    in this chapter.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 用于线程安全并发访问的异步锁定机制。这个锁在后面详细介绍的共享`StartAsync`方法命令中使用。
- en: The `_logger` field has access to several custom logging extension methods.
    These extension methods call into cached delegates created from the framework-provided
    `LoggerMessage.Define` factory methods. This is used as a performance optimization
    to avoid creating a new delegate each time a log message is logged.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`_logger`字段可以访问几个自定义的日志记录扩展方法。这些扩展方法调用从框架提供的`LoggerMessage.Define`工厂方法创建的缓存委托。这是一种性能优化，避免每次记录日志消息时都创建一个新的委托。'
- en: The connection state is represented by the underlying `HubConnection.State`
    as a calculated property named `State`. When `_hubConnection` is `null`, the state
    is shown as `Disconnected`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 连接状态由底层 `HubConnection.State` 计算属性 `State` 表示。当 `_hubConnection` 为 `null` 时，状态显示为
    `Disconnected`。
- en: 'Additional states include the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 其他状态包括以下内容：
- en: '`Connected`'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`已连接`'
- en: The client and server are connected.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器已连接。
- en: '`Connecting`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`连接中`'
- en: The connection is being established.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正在建立连接。
- en: '`Reconnecting`'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`重新连接`'
- en: The connection is being reconnected.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正在重新连接。
- en: Next, the `SharedHubConnection` constructor assigns several fields from the
    constructor’s parameters. From the client’s configured options object, the Web
    API server URL is used along with the `"/notifications"` route to instantiate
    the notification hub `Uri`. The `_hubConnection` field is instantiated using the
    builder pattern and the corresponding `HubConnectionBuilder` object.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`SharedHubConnection` 构造函数从构造函数的参数中分配了几个字段。从客户端配置的选项对象中，使用 Web API 服务器 URL
    以及 `"/notifications"` 路由来实例化通知中心的 `Uri`。使用生成器模式和相应的 `HubConnectionBuilder` 对象实例化
    `_hubConnection` 字段。
- en: The hub URL is used with the builder instance, and the hub connection has its
    options configured through the `WithUrl` method overload. `AccessTokenProvider`
    is assigned to a delegate used to get the contextual access token asynchronously.
    The default request HTTP headers are updated, adding the `"Accept-Language"` header
    with a value of the currently configured ISO two-letter language name. This ensures
    that the SignalR server connection knows to return the appropriately localized
    content to the connected client. The builder configures automatic reconnection
    and the MessagePack protocol just before calling `Build`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用生成器实例和 Hub 连接，通过 `WithUrl` 方法重载配置了其选项。将 `AccessTokenProvider` 分配给用于异步获取上下文访问令牌的委托。更新默认的请求
    HTTP 标头，添加 `"Accept-Language"` 标头，并使用当前配置的 ISO 两字母语言名称作为值。这确保 SignalR 服务器连接知道返回适当的本地化内容给连接的客户端。生成器在调用
    `Build` 之前配置了自动重连和 MessagePack 协议。
- en: Using the `_hubConnection` instance, the `Closed`, `Reconnected`, and `Reconnecting`
    events are subscribed to. The various connection states are communicated through
    these events. Their corresponding event handlers are all fairly similar. The app
    conditionally logs their occurrence.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `_hubConnection` 实例，订阅了 `Closed`、`Reconnected` 和 `Reconnecting` 事件。通过这些事件传达了各种连接状态。它们各自的事件处理程序都非常相似。应用程序有条件地记录它们的发生。
- en: Finally, the `DisposeAsync` functionality unsubscribes from the `_hubConnection`
    events and then cascades disposal of the connection and the locking mechanism
    used for synchronization.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`DisposeAsync`功能取消订阅 `_hubConnection` 的事件，然后级联处理连接和用于同步的锁定机制的释放。
- en: Shared hub connection authentication
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享中心连接认证
- en: 'The `SharedHubConnection` use is `partial`, and there are several other implementations
    to consider. The `GetAccessTokenValueAsync` delegate was assigned when building
    the `_hubConnection` instance, and that functionality is implemented in the *SharedHubConnection.Tokens.cs*
    C# file:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`SharedHubConnection` 的使用是 `partial` 的，还有其他几个实现要考虑。在构建 `_hubConnection` 实例时分配了
    `GetAccessTokenValueAsync` 委托，该功能在 *SharedHubConnection.Tokens.cs* C# 文件中实现：'
- en: '[PRE9]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `SharedHubConnection` class was registered as a singleton, but the framework-provided
    `IAccessTokenProvider` is a scoped service. This is why the constructor couldn’t
    require `IAccessTokenProvider` directly; instead, it needs `IServiceProvider`.
    With the `_serviceProvider` instance, a call to `CreateScope` is used to create
    a scope in which we can resolve `IAccessTokenProvider`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`SharedHubConnection` 类被注册为单例，但框架提供的 `IAccessTokenProvider` 是一个作用域服务。这就是为什么构造函数不能直接要求
    `IAccessTokenProvider`；相反，它需要 `IServiceProvider`。使用 `_serviceProvider` 实例，调用 `CreateScope`
    创建一个作用域，以便解析 `IAccessTokenProvider`。'
- en: Tip
  id: totrans-175
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Normally, you will not need to use `IServiceProvider` directly. The `SharedHubConnection`
    class is a singleton, and `IAccessToken​Pro⁠vider` is a scoped service. `IServiceProvider`
    is used to resolve `IAccessTokenProvider` when the `SharedHubConnection` object
    starts communicating with a server.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，您不需要直接使用 `IServiceProvider`。`SharedHubConnection` 类是一个单例，并且 `IAccessTokenProvider`
    是一个作用域服务。当 `SharedHubConnection` 对象开始与服务器通信时，使用 `IServiceProvider` 解析 `IAccessTokenProvider`。
- en: With `tokenProvider`, we call `RequestAccessToken`. If the `result` has an access
    token, it is returned. If `GetAccessTokenValueAsync` is unable to get `accessToken`,
    it is logged, and `null` is returned. The access token is used to authenticate
    the connected Blazor client with the server hub.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `tokenProvider`，我们调用 `RequestAccessToken`。如果 `result` 有一个访问令牌，则返回它。如果 `GetAccessTokenValueAsync`
    无法获取 `accessToken`，则记录并返回 `null`。访问令牌用于对接的 Blazor 客户端与服务器 Hub 进行身份验证。
- en: Shared hub connection initiation
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享的 Hub 连接初始化
- en: 'Due to the shared nature of this class, the start functionality needs to be
    implemented in a thread-safe way. Any consumer can safely call `StartAsync` to
    initiate the connection from the client to the server. This happens in the *SharedHubConnection​.Com⁠mands.cs*
    C# file:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此类的共享性质，启动功能需要以线程安全的方式实现。任何消费者都可以安全地调用 `StartAsync` 以从客户端启动到服务器的连接。这发生在 *SharedHubConnection​.Com⁠mands.cs*
    C# 文件中：
- en: '[PRE10]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO9-1)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO9-1)'
- en: The `StartAsync` method defines an optional cancellation `token`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`StartAsync` 方法定义了一个可选的取消 `token`。'
- en: When a call to `StartAsync` is made, the `SemaphoreSlim _lock` variable has
    its `WaitAsync` method called, which completes when the semaphore is entered.
    This is an important detail because it alleviates the concerns of multiple components
    calling `StartAsync` concurrently by ensuring that all callers execute sequentially.
    In other words, imagine three components call `StartAsync` at the same time. This
    asynchronous locking mechanism ensures that the first component to enter and start
    `_hubConnection` is the only component that will call `_hubConnection.StartAsync`.
    The other two components will log that they were unable to start the connection
    to the server’s hub, as it was already started.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `StartAsync` 时，`SemaphoreSlim _lock` 变量调用其 `WaitAsync` 方法，该方法在进入信号量时完成。这是一个重要的细节，因为它通过确保所有调用者顺序执行来缓解多个组件并发调用
    `StartAsync` 的问题。换句话说，想象三个组件同时调用 `StartAsync`。这种异步锁定机制确保第一个进入并启动 `_hubConnection`
    的组件是唯一调用 `_hubConnection.StartAsync` 的组件。其他两个组件将记录它们无法启动与服务器 Hub 的连接，因为它已经启动。
- en: Shared hub connection chat
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享的 Hub 连接聊天
- en: 'Next, let’s look at how `SharedHubConnection` implements the chat functionality.
    You can see how this is defined in the *SharedHubConnection.Chat.cs* C# file:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `SharedHubConnection` 如何实现聊天功能。您可以在 *SharedHubConnection.Chat.cs*
    C# 文件中看到其定义：
- en: '[PRE11]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO10-1)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO10-1)'
- en: The `JoinChatAsync` method is an example of an operation that can be called
    from the client and invokes a method on the server.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`JoinChatAsync` 方法是一个示例，可从客户端调用，并在服务器上调用一个方法。'
- en: '[![2](assets/2.png)](#co_exemplifying_real_time_web_functionality_CO10-2)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_exemplifying_real_time_web_functionality_CO10-2)'
- en: The `SubscribeToUserLoggedIn` method is an example of an event that is fired
    from the server, and clients can listen by subscribing to them.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`SubscribeToUserLoggedIn` 方法是一个示例事件，从服务器触发，客户端可以通过订阅来监听它们。'
- en: 'The chat functionality relies on two shared helper classes:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天功能依赖于两个共享的辅助类：
- en: '`HubClientMethodNames`'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`HubClientMethodNames`'
- en: Defines method names that are invocable from a connected client on the server
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了可以从连接的客户端上调用的方法名称
- en: '`HubServerEventNames`'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`HubServerEventNames`'
- en: Defines event names (and parameter details) from the SignalR hub that a client
    can subscribe to
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了客户端可以订阅的来自 SignalR Hub 的事件名称（及其参数详情）
- en: The additional functionality is implemented using these classes. Each client
    method delegates out to a corresponding overload of the `_hubConnection.Invoke​A⁠sync`
    method, passing the appropriate method name and arguments. Meanwhile, each server
    event is subscribed from an assigned function that acts as its callback handler.
    This is possible using the appropriate `_hubConnection.On` overload. These subscriptions
    are represented as an `IDisposable` that is returned, and it’s the caller’s responsibility
    to unsubscribe by calling `Dispose` on any subscriptions it may have made. Consuming
    components will be able to join and leave chat rooms, post and update messages
    in said chat rooms, and share whether they’re currently typing. Likewise, these
    components will be able to receive notifications when another user is typing,
    when a user has logged in or out, and when a message has been received.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的功能是通过这些类来实现的。每个客户端方法都委托给 `_hubConnection.Invoke​A⁠sync` 方法的对应重载，传递适当的方法名称和参数。与此同时，每个服务器事件都订阅了一个分配的函数，作为其回调处理程序。这是通过适当的
    `_hubConnection.On` 重载实现的。这些订阅被表示为返回的 `IDisposable`，调用者有责任通过调用 `Dispose` 在可能进行的任何订阅上取消订阅。消费组件将能够加入和离开聊天室，在这些聊天室中发布和更新消息，并共享他们当前是否正在输入。同样，这些组件将能够在另一个用户输入时接收通知，用户登录或退出时接收通知，以及收到消息时接收通知。
- en: Shared hub connection tweets
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享的 hub 连接推文
- en: 'The final bit of functionality that is implemented in this `SharedHubConnection`
    is tweet streaming, and it’s defined in the *SharedHubConnection.Tweets.cs* C#
    file:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个功能位于 `SharedHubConnection` 中实现，它在 *SharedHubConnection.Tweets.cs* 的 C# 文件中定义：
- en: '[PRE12]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO11-1)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO11-1)'
- en: The *Tweet* implementation relies on `HubClientMethodNames` to invoke hub connection
    methods, given their name and arguments.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*推特* 实现依赖于 `HubClientMethodNames` 来调用 hub 连接方法，给定它们的名称和参数。'
- en: '[![2](assets/2.png)](#co_exemplifying_real_time_web_functionality_CO11-2)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_exemplifying_real_time_web_functionality_CO11-2)'
- en: Similarly, `HubServerEventNames` are used to subscribe to named events from
    the server, given a handler.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`HubServerEventNames` 用于从服务器订阅命名事件，给定处理程序。
- en: By encapsulating the logic for each domain-specific feature, the corresponding
    `partial` implementations of `SharedHubConnection` expose more meaningful methods
    to the consumers. The framework-provided `HubConnection`, while used internally
    within this class, is abstracted away. Instead, by using `SharedHubConnection`,
    a consumer can call more explicitly named and meaningful methods.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通过封装每个特定于领域的功能的逻辑，`SharedHubConnection` 的相应 `partial` 实现向消费者公开了更有意义的方法。虽然在该类内部使用了框架提供的
    `HubConnection`，但它已经被抽象掉了。因此，通过使用 `SharedHubConnection`，消费者可以调用更明确命名和有意义的方法。
- en: Consuming Real-Time Data in Components
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在组件中消费实时数据
- en: The only thing that is left to do is to consume the shared hub connection where
    it’s needed in the consuming components. Each domain-specific feature, whether
    it’s a small component or a page, will rely on `SharedHubConnection` to provide
    the necessary functionality.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一剩下要做的就是在消费组件中使用共享的 hub 连接。每个特定于领域的功能，无论是小组件还是页面，都将依赖于 `SharedHubConnection`
    来提供必要的功能。
- en: 'The SignalR real-time data powers three of our model app’s components: `NotificationComponent`,
    `Tweets`, and `Chat` pages. The notification system is capable of receiving notifications
    for the following events:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR 实时数据支持我们模型应用程序的三个组件：`NotificationComponent`、`Tweets` 和 `Chat` 页面。通知系统能够接收以下事件的通知：
- en: When a user logs in or out of the app
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户登录或退出应用程序时
- en: When there’s an important weather alert for your current location, such as a
    severe weather warning
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你当前位置有重要的天气警报，如严重天气警告时
- en: If your email address has been part of a data breach (this refers to the “Have
    I Been Pwned” functionality of the app), as shown in [Figure 6-4](#pwned-notification)
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的电子邮件地址曾经参与过数据泄露（这指的是应用程序的“Have I Been Pwned”功能），如[图 6-4](#pwned-notification)所示。
- en: '![](assets/lblz_0604.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lblz_0604.png)'
- en: Figure 6-4\. A pwned notification
  id: totrans-212
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-4\. 一个 pwned 通知
- en: All notifications are dismissible, but only some are actionable. For example,
    a notification that informs you as to whether you’ve been part of a data breach
    provides a link. If you decide to follow the link, it will take you to the `/pwned`
    subroute in the app that will show you all of the data breaches your email is
    part of.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 所有通知都可以取消，但只有一些可以操作。例如，一个通知会告诉您是否涉及到数据泄露，并提供一个链接。如果您决定访问链接，它将带您到应用程序中的 `/pwned`
    子路由，展示您的电子邮件参与的所有数据泄露。
- en: The app has a `Tweets` page dedicated to live Twitter content that’s streamed
    in real time. We’re going to focus in depth on one of the consuming components.
    With that knowledge, you will be able to review the others yourself. Let’s take
    a look at the chat functionality.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序有一个专门用于实时推特内容的 `Tweets` 页面。我们将深入研究其中一个消费组件。有了这些知识，您可以自行审查其他内容。让我们来看看聊天功能。
- en: 'The `Chat` component defines the `@page` directive, which means it’s a *page*.
    It’s navigable at the `/chat` route. Consider the *Chat.razor* file:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chat` 组件定义了 `@page` 指令，这意味着它是一个 *页面*。可以通过 `/chat` 路由导航到它。考虑 *Chat.razor* 文件：'
- en: '[PRE13]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO12-1)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO12-1)'
- en: The `Chat` page has a route template of `"/chat/{room?}"`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chat` 页面的路由模板为 `"/chat/{room?}"`。'
- en: '[![2](assets/2.png)](#co_exemplifying_real_time_web_functionality_CO12-2)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_exemplifying_real_time_web_functionality_CO12-2)'
- en: Each chat room has a single pair of inputs for the chat room message and a send
    button.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 每个聊天室只有一个聊天室消息输入框和一个发送按钮。
- en: '[![3](assets/3.png)](#co_exemplifying_real_time_web_functionality_CO12-3)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_exemplifying_real_time_web_functionality_CO12-3)'
- en: When there are one or more users actively typing, we display specialized messages
    to indicate this to participants in the chat room.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个或多个用户正在输入时，我们会显示专门的消息，以向聊天室的参与者指示这一情况。
- en: '[![4](assets/4.png)](#co_exemplifying_real_time_web_functionality_CO12-4)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_exemplifying_real_time_web_functionality_CO12-4)'
- en: A collection of chat room messages are iterated over and passed to `ChatMessageComponent`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一组聊天室消息被迭代并传递给 `ChatMessageComponent`。
- en: The `Chat` page’s route template allows for an optional room parameter. This
    value is implicitly bound to the component’s corresponding `Room` property. Route
    templates are powerful, and we have a lot of flexibility. This allows users of
    our client app to share and bookmark rooms. They can invite their friends and
    interact in real time. For more information about route constraints, see Microsoft’s
    [“ASP.NET Core Blazor Routing and Navigation” documentation](https://oreil.ly/397Vn).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chat` 页面的路由模板允许使用可选的房间参数。该值隐式绑定到组件对应的 `Room` 属性。路由模板非常强大，我们具有很大的灵活性。这使得我们客户端应用程序的用户可以共享和书签房间，邀请朋友实时互动。有关路由约束的更多信息，请参见微软的
    [“ASP.NET Core Blazor 路由和导航”文档](https://oreil.ly/397Vn)。'
- en: The chat room functionality enables users to edit messages they’ve sent; this
    is a nice feature to have. It lets the chat user fix typos or update what they’re
    trying to express as needed. Messages are, however, not persisted. This is intentional;
    every interaction is live, and if you leave, so too do the messages. It imposes
    an either *be in the moment or don’t bother* mentality. The progression of sending
    a message with a typo, from correcting it to sending it, is an interactive experience.
    To visualize this, see Figures [6-5](#chat-room-typo), [6-6](#chat-room-typo-edit),
    and [6-7](#chat-room-typo-edited).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天室功能允许用户编辑他们发送的消息；这是一个很好的功能。它允许聊天用户纠正拼写错误或根据需要更新表达的内容。然而，消息不会被永久保存，这是有意为之的；每个交互都是实时的，如果您离开，消息也会消失。这强调了
    *要么专注当下，要么别浪费时间* 的思维方式。从发送有拼写错误的消息到纠正并发送的过程是一个交互式的体验。要查看这一过程，请参见图 [6-5](#chat-room-typo)、[6-6](#chat-room-typo-edit)
    和 [6-7](#chat-room-typo-edited)。
- en: '![](assets/lblz_0605.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lblz_0605.png)'
- en: Figure 6-5\. Chat room message typo
  id: totrans-228
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-5\. 聊天室消息拼写错误
- en: '![](assets/lblz_0606.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lblz_0606.png)'
- en: Figure 6-6\. Chat room message editing
  id: totrans-230
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-6\. 聊天室消息编辑
- en: '![](assets/lblz_0607.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lblz_0607.png)'
- en: Figure 6-7\. Chat room message edited
  id: totrans-232
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-7\. 聊天室消息编辑
- en: Programmatically speaking, not persisting messages makes the app a bit less
    complex. The primary concern is the user’s ability to interact with the `Chat`
    room by creating or updating their chat messages. The user enters their message
    in `<input type="text">` and sends the message using the `<a class="button">`
    HTML elements. `input` has its native `spellcheck` attribute set to `true`. This
    enables the element to provide help to the user, ensuring the spelling accuracy
    of their messages. The user can send a message using the Enter key. The send button
    is an explicit user request, as opposed to the more passive or implicit nature
    of pressing the Enter key, but they’re functionally equivalent.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 程序上来说，不持久化消息会使应用稍微简化。主要关注点在于用户通过创建或更新他们的聊天消息来与`Chat`房间互动。用户在`<input type="text">`中输入他们的消息，并使用`<a
    class="button">` HTML元素发送消息。`input`具有其本地的`spellcheck`属性设置为`true`。这使得元素能够为用户提供帮助，确保他们消息的拼写准确性。用户可以使用Enter键发送消息。发送按钮是明确的用户请求，而不是按Enter键的更被动或隐式的性质，但它们在功能上是等效的。
- en: As part of the real-time functionality, when the users in the same chat room
    are typing a message, their client apps are debouncing their input.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 作为实时功能的一部分，当同一聊天室中的用户正在输入消息时，他们的客户端应用程序正在消除他们的输入。
- en: When the user first starts typing, a notification is triggered using SignalR
    to let interested chat room participants know that the user is typing. Each time
    they type a nonterminating key, after a specific amount of time like 750 milliseconds
    or so, the app sends a cancellation. The UX is such that you can see not only
    that someone in the chat room is typing but also their names. This is depicted
    in [Figure 6-8](#debounce-diagram).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户首次开始输入时，会触发一个通知，使用SignalR让感兴趣的聊天室参与者知道用户正在输入。每当他们键入一个非终止键后，经过大约750毫秒的特定时间，应用程序发送一个取消。用户体验是，您不仅可以看到聊天室中有人正在输入，还可以看到他们的名字。这在[图6-8](#debounce-diagram)中描述。
- en: '![](assets/lblz_0608.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lblz_0608.png)'
- en: Figure 6-8\. The debounce state machine diagram
  id: totrans-237
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-8。抑制状态机图表
- en: 'The `Chat` page maintains a .NET `Dictionary<Guid, ActorMessage>` named `_messages`.
    This collection is tethered to the receiving of SignalR events from `NotificationHub`
    on the server through the generic `Notification<T> where T : notnull` and `T`
    represents the type for the `Payload` property. When communicated as `NotificationType.Chat`,
    the `T` type is `ActorMessage`. An actor message is used to represent the message
    from a user and their intent. These messages can reflect a message in multiple
    ways, whether the user is editing a message or whether the message is a general
    greeting. The messages are uniquely identifiable and immutable. A message has
    a sense of ownership in that there’s a username associated with a message. Consider
    the *Actors.cs* C# file:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chat`页面维护了一个名为`.NET `Dictionary<Guid, ActorMessage>`的集合`_messages`。这个集合通过来自服务器`NotificationHub`的SignalR事件接收到`Notification<T>
    where T : notnull`和`T`表示`Payload`属性的类型。当通信为`NotificationType.Chat`时，`T`类型为`ActorMessage`。演员消息用于表示来自用户及其意图的消息。这些消息可以以多种方式反映消息，无论用户是否正在编辑消息，或者消息是否是一般的问候语。这些消息具有唯一标识且不可变。消息具有所有权的感觉，因为消息关联有用户名。考虑*C#*文件*Actors.cs*：'
- en: '[PRE14]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This file contains three `record class` definitions: one base `Actor` and two
    descendants, `ActorAction` and `ActorMessage`. Each message in the `_messages`
    collection is iterated over in reverse order. This displays the messages in ascending
    order from the time they were posted, which is common in all chat apps. The `ActorAction`
    class sets the user’s typing status to either `true` or `false`. These `message`
    objects are passed to the custom `<ChatMessageComponent>`. This component is defined
    in the *ChatMessageComponent.razor* file. Let’s have a look at that first:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件包含三个`record class`定义：一个基本的`Actor`和两个后代，`ActorAction`和`ActorMessage`。在`_messages`集合中的每条消息按逆序迭代。这显示了消息按它们发布的时间的升序显示，这在所有聊天应用中都很常见。`ActorAction`类将用户的输入状态设置为`true`或`false`。这些`message`对象被传递给自定义的`<ChatMessageComponent>`。这个组件在*ChatMessageComponent.razor*文件中定义。让我们先看看那个：
- en: '[PRE15]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO13-1)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO13-1)'
- en: Each message is represented as an `<a id="@Message.Id">...</a>` anchor element.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 每条消息表示为`<a id="@Message.Id">...</a>`锚元素。
- en: '[![2](assets/2.png)](#co_exemplifying_real_time_web_functionality_CO13-2)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_exemplifying_real_time_web_functionality_CO13-2)'
- en: The framework-provided `MarkupString` is used to render a C# `string` as HTML.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 框架提供的 `MarkupString` 用于将 C# `string` 渲染为 HTML。
- en: '[![3](assets/3.png)](#co_exemplifying_real_time_web_functionality_CO13-3)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_exemplifying_real_time_web_functionality_CO13-3)'
- en: The component dynamically applies a style from the `_dynamicCss` calculated
    property.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 组件动态应用 `_dynamicCss` 计算属性中的样式。
- en: '[![4](assets/4.png)](#co_exemplifying_real_time_web_functionality_CO13-4)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_exemplifying_real_time_web_functionality_CO13-4)'
- en: The `StartEditAsync()` method is used to signal to the parent `Chat` page that
    this component is editing a message.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`StartEditAsync()` 方法用于向父 `Chat` 页面发信号，表明此组件正在编辑消息。'
- en: '`ChatMessageComponent` is used to represent a single chat message. If the component
    is created with `IsEditable` set to `true`, the user can edit the message within
    this component. If a message has been edited before, it’s appropriately styled
    to indicate that to the users of the chat room. When the user is not permitted
    to edit a message, the `is-unselectable` style is applied.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChatMessageComponent` 用于表示单个聊天消息。如果创建该组件时将 `IsEditable` 设置为 `true`，则用户可以在该组件内编辑消息。如果消息之前已被编辑过，则会适当地应用样式来向聊天室用户指示。如果用户无权编辑消息，则应用
    `is-unselectable` 样式。'
- en: 'Next, let’s explore how the `Chat` page is implemented as a few C# partial
    classes. Consider the *Chat.razor.cs* C# file:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `Chat` 页面的实现，它由几个 C# 部分类组成。考虑 *Chat.razor.cs* C# 文件：
- en: '[PRE16]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO14-1)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO14-1)'
- en: The `Chat` implementation maintains a `Stack<IDisposable>` named `_subscriptions`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chat` 的实现维护了一个名为 `_subscriptions` 的 `Stack<IDisposable>`。'
- en: '[![2](assets/2.png)](#co_exemplifying_real_time_web_functionality_CO14-2)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_exemplifying_real_time_web_functionality_CO14-2)'
- en: The `ShareHubConnection HubConnection` property is injected.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注入了 `ShareHubConnection HubConnection` 属性。
- en: '[![3](assets/3.png)](#co_exemplifying_real_time_web_functionality_CO14-3)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_exemplifying_real_time_web_functionality_CO14-3)'
- en: The class provides an `override` of the `OnInitializedAsync` method.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 该类提供了对 `OnInitializedAsync` 方法的 `override`。
- en: '[![4](assets/4.png)](#co_exemplifying_real_time_web_functionality_CO14-4)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_exemplifying_real_time_web_functionality_CO14-4)'
- en: The `OnAfterRenderAsync` lifecycle event method is used to set the focus on
    the message input.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `OnAfterRenderAsync` 生命周期事件方法将焦点设置在消息输入框上。
- en: '[![5](assets/5.png)](#co_exemplifying_real_time_web_functionality_CO14-5)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_exemplifying_real_time_web_functionality_CO14-5)'
- en: An explicit implementation of `IAsyncDisposable.DisposeAsync` performs cleanup.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`IAsyncDisposable.DisposeAsync` 的显式实现执行清理操作。'
- en: The first implementation `partial` that we observe of the `Chat` component class
    implements `IAsyncDisposable`. The component exposes a `[Parameter] public string?
    Room` property. This is automatically bound (meaning its value is provided by
    the framework from a corresponding segment in the browser’s URL) to the navigation
    route. In other words, if the user visits `/chat/MyCoolChatRoom`, this `Room`
    property will have a value of `"MyCoolChatRoom"`. When there isn’t a room name
    specified, the default room name of `"public"` is used.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们观察到的 `Chat` 组件类的第一个实现 `partial` 实现了 `IAsyncDisposable`。该组件公开了一个 `[Parameter]
    public string? Room` 属性。这是自动绑定的（意味着其值由框架从浏览器 URL 中相应的段提供）。换句话说，如果用户访问 `/chat/MyCoolChatRoom`，则此
    `Room` 属性将具有值 `"MyCoolChatRoom"`。当没有指定房间名时，默认房间名为 `"public"`。
- en: 'When the component is initialized, it subscribes to the following events:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件初始化时，它订阅以下事件：
- en: '`HubConnection.SubscribeToMessageReceived`'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`HubConnection.SubscribeToMessageReceived`'
- en: The `OnMessageReceivedAsync` method is the handler.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnMessageReceivedAsync` 方法是处理程序。'
- en: '`HubConnection.SubscribeToUserTyping`'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`HubConnection.SubscribeToUserTyping`'
- en: The `OnUserTypingAsync` method is the handler.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnUserTypingAsync` 方法是处理程序。'
- en: 'When the component is disposed of, it will leave the current chat room but
    issue the appropriate `HubConnection.LeaveChatAsync` method call. There’s a stack
    of `_subscriptions` that will be unsubscribed from as well. The next `Chat` implementation
    `partial` is defined in the *Chat.razor.Messages.cs* C# file:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件被销毁时，它将离开当前聊天室，但会发出适当的 `HubConnection.LeaveChatAsync` 方法调用。还有一个 `_subscriptions`
    栈将被取消订阅。下一个 `Chat` 实现的部分定义在 *Chat.razor.Messages.cs* C# 文件中：
- en: '[PRE17]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO15-1)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO15-1)'
- en: '`_messages` are represented as a collection of key/value pairs.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`_messages` 被表示为键值对的集合。'
- en: '[![2](assets/2.png)](#co_exemplifying_real_time_web_functionality_CO15-2)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_exemplifying_real_time_web_functionality_CO15-2)'
- en: The `OnMessageReceivedAsync` method is the event handler for when messages are
    received from the hub connection.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnMessageReceivedAsync` 方法是从 hub 连接接收消息时的事件处理程序。'
- en: '[![3](assets/3.png)](#co_exemplifying_real_time_web_functionality_CO15-3)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_exemplifying_real_time_web_functionality_CO15-3)'
- en: When the user is typing and they lift their key, the `OnKeyUpAsync` method is
    fired.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户正在输入并抬起键时，将触发 `OnKeyUpAsync` 方法。
- en: '[![4](assets/4.png)](#co_exemplifying_real_time_web_functionality_CO15-4)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_exemplifying_real_time_web_functionality_CO15-4)'
- en: To send a message, the `SendMessageAsync` method is used.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送消息，使用 `SendMessageAsync` 方法。
- en: '[![5](assets/5.png)](#co_exemplifying_real_time_web_functionality_CO15-5)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_exemplifying_real_time_web_functionality_CO15-5)'
- en: When the chat room user owns a message, they can start editing the message with
    the `OnEditMessageAsync` method.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当聊天室用户拥有消息时，他们可以使用 `OnEditMessageAsync` 方法开始编辑消息。
- en: The `Chat/Messages` implementation is all about how messages are managed. From
    the collection of `_messages` to a single `_message` and `_messageId`, this class
    contains class-scoped fields for maintaining the state of chat messages. The `_isSending`
    value is used to signify that a message is being sent. `_messageInput` is a framework-provided
    `ElementReference`. When the component is rendered for the first time, `_messageInput`
    is focused on using the `FocusAsync` extension method.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chat/Messages` 实现涵盖了消息管理的方方面面。从 `_messages` 的集合到单个 `_message` 和 `_messageId`，该类包含了用于维护聊天消息状态的类作用域字段。
    `_isSending` 值用于表示正在发送消息。 `_messageInput` 是框架提供的 `ElementReference`。当组件第一次渲染时，通过
    `FocusAsync` 扩展方法聚焦于 `_messageInput`。'
- en: The `Chat.OwnsMessage` method accepts a `user` parameter and compares it to
    the current user in context. This prevents anyone from editing messages that they
    don’t have ownership of. When a message is received, the `OnMessageReceivedAsync`
    method is called. Since this can happen at any time, the method needs to call
    `StateHasChanged`. The `_messages` collection is updated with the incoming message
    and a `JavaScript` call to the `ScrollIntoViewAsync` method given the `Id` of
    the `message.Payload`. This is a JavaScript interop call using a named extension
    method pattern.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chat.OwnsMessage` 方法接受一个 `user` 参数，并将其与上下文中的当前用户进行比较。这样可以防止任何人编辑他们没有所有权的消息。当接收到消息时，将调用
    `OnMessageReceivedAsync` 方法。由于这可能发生在任何时候，该方法需要调用 `StateHasChanged`。`_messages`
    集合通过传入消息进行更新，并使用 `JavaScript` 调用 `ScrollIntoViewAsync` 方法，给定 `message.Payload`
    的 `Id`。这是使用命名扩展方法模式的 JavaScript 互操作调用。'
- en: As the user types their chat messages, the `OnKeyUpAsync` method is invoked.
    If the user is currently sending a message as determined by the `_isSending` bit,
    it’s a NOOP (a no operation, meaning it does nothing). However, when the user
    presses the Enter key, the message is sent. The `SendMessageAsync` method early
    exits if a message is already being sent or if there is no message at all. When
    there is a message to send, the `HubConnection.PostOrUpdateMessageAsync` method
    is called.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入他们的聊天消息时，将调用 `OnKeyUpAsync` 方法。如果用户当前正在发送消息（由 `_isSending` 位确定），则为 NOOP（即不执行任何操作）。但是，当用户按下
    Enter 键时，消息将被发送。如果消息已经在发送或根本没有消息，`SendMessageAsync` 方法将提前退出。当有消息要发送时，将调用 `HubConnection.PostOrUpdateMessageAsync`
    方法。
- en: 'If the user decides to edit a message, the `OnEditMessageAsync` method first
    ensures that the user owns the message. `_message` and `_messageId` are assigned
    from the message being edited, and focus is returned to the message input. The
    final bit of `Chat` functionality is that of the debounce implementation. For
    that, take a look at the *Chat.razor.Debounce.cs* C# file:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户决定编辑消息，`OnEditMessageAsync` 方法首先确保用户拥有该消息。 `_message` 和 `_messageId` 被分配给正在编辑的消息，并将焦点返回到消息输入框。最后一部分
    `Chat` 功能是 debounce 实现。要了解更多，请查看 *Chat.razor.Debounce.cs* C# 文件：
- en: '[PRE18]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO16-1)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_exemplifying_real_time_web_functionality_CO16-1)'
- en: The debounce implementation maintains `HashSet<Actor> _usersTyping`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: debounce 实现维护 `HashSet<Actor> _usersTyping`。
- en: '[![2](assets/2.png)](#co_exemplifying_real_time_web_functionality_CO16-2)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_exemplifying_real_time_web_functionality_CO16-2)'
- en: The `Chat` constructor wires up the `_debounceTimer.Elapsed` event.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chat` 构造函数连接了 `_debounceTimer.Elapsed` 事件。'
- en: '[![3](assets/3.png)](#co_exemplifying_real_time_web_functionality_CO16-3)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_exemplifying_real_time_web_functionality_CO16-3)'
- en: The `InitiateDebounceUserIsTypingAsync` method is responsible for restarting
    `_debounceTimer` and calling `SetIsTypingAsync` with `true`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`InitiateDebounceUserIsTypingAsync`方法负责重新启动`_debounceTimer`并调用`SetIsTypingAsync`以设置为`true`。'
- en: '[![4](assets/4.png)](#co_exemplifying_real_time_web_functionality_CO16-4)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_exemplifying_real_time_web_functionality_CO16-4)'
- en: The `OnUserTypingAsync` method handles the event that is fired when people in
    the chat room are typing.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnUserTypingAsync`方法处理聊天室中有人输入时触发的事件。'
- en: '[![5](assets/5.png)](#co_exemplifying_real_time_web_functionality_CO16-5)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_exemplifying_real_time_web_functionality_CO16-5)'
- en: The `SetIsTypingAsync` method conditionally toggles a value representing the
    state of whether the user is typing.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetIsTypingAsync`方法有条件地切换一个表示用户是否正在输入状态的值。'
- en: '[![6](assets/6.png)](#co_exemplifying_real_time_web_functionality_CO16-6)'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_exemplifying_real_time_web_functionality_CO16-6)'
- en: The `TryGetUsersTypingText` helper method gets a message to display when users
    are typing.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`TryGetUsersTypingText`辅助方法获取显示用户正在输入时的消息。'
- en: '[![7](assets/7.png)](#co_exemplifying_real_time_web_functionality_CO16-7)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_exemplifying_real_time_web_functionality_CO16-7)'
- en: After the allotted amount of debounce time, the `OnDebounceElapsed` method is
    called, thus clearing the typing status.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在分配的抖动时间之后，将调用`OnDebounceElapsed`方法，从而清除输入状态。
- en: The `Chat/Debounce` implementation manages the collection of `_usersTyping`,
    `_debounceTimer` (which comes from the `System.Timers.Timer` namespace), and a
    value indicating whether or not the user `_isTyping`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chat/Debounce`实现管理`_usersTyping`集合、来自`System.Timers.Timer`命名空间的`_debounceTimer`以及表示用户是否正在输入的值。'
- en: When the `OnUserTypingAsync` method is called, the `Notification<ActorAction>`
    parameter provides a value as to whether the user is typing. The user is either
    added or removed from the `_usersTyping` collection. The `TryGetUsersTypingText`
    helper message relies on the current state of the `_usersTyping` collection and
    `Localizer` to format messages. For example, if my friends Carol and Chad were
    both typing a message, the UI would look similar to [Figure 6-9](#chat-room).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`OnUserTypingAsync`方法时，`Notification<ActorAction>`参数提供了用户是否正在输入的值。用户将被添加或从`_usersTyping`集合中移除。`TryGetUsersTypingText`辅助消息依赖于`_usersTyping`集合的当前状态和`Localizer`来格式化消息。例如，如果我的朋友Carol和Chad都在输入消息，UI看起来类似于[图 6-9](#chat-room)。
- en: '![](assets/lblz_0609.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lblz_0609.png)'
- en: Figure 6-9\. The chat room with multiple people typing
  id: totrans-303
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-9\. 多人输入消息的聊天室
- en: Summary
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to implement real-time web functionality using
    ASP.NET Core SignalR. You saw how to cleanly separate domain responsibilities
    making extensive use of C# partial classes. We walked through the source code
    for a feature-rich server-side SignalR implementation, complete with `Hub` and
    `IHub​Con⁠text<T>` within a `BackgroundService`. You learned possible ways to
    create real-time alerts and notifications, a messaging system for live-user interactions,
    and a joinable active Twitter stream. Finally, you learned how to consume this
    data from our Blazor WebAssembly app while focusing on a feature-rich chat app.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何使用ASP.NET Core SignalR实现实时Web功能。您看到了如何清晰地分离领域责任，充分利用C#部分类。我们逐步介绍了功能丰富的服务器端SignalR实现的源代码，包括在`BackgroundService`中的`Hub`和`IHub​Con⁠text<T>`。您学习了创建实时警报和通知的可能方法，一个用于实时用户交互的消息系统以及一个可加入的活跃Twitter流的方法。最后，您学习了如何从我们的Blazor
    WebAssembly应用程序中消费这些数据，重点放在功能丰富的聊天应用上。
- en: In the next chapter, you’ll learn a valid use case for C# source generators.
    You’ll see how well-known JavaScript Web APIs can be used to source generate extension
    method implementations, fulfilling JavaScript interop functionality. You’ll learn
    how this specifically applies to the `localStorage` JavaScript API.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习C#源生成器的一个有效用例。您将看到如何使用众所周知的JavaScript Web API来生成扩展方法的实现，实现JavaScript互操作功能。您将学习如何将此特定应用于`localStorage`
    JavaScript API。
