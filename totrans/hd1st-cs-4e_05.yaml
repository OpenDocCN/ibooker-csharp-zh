- en: 'Chapter 3\. Objects…get oriented!: *Making code make sense*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章。对象...定位：*让代码变得有意义*
- en: '![Images](assets/103fig01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/103fig01.png)'
- en: '**Every program you write solves a problem.**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**你编写的每个程序都解决一个问题。**'
- en: When you’re building a program, it’s always a good idea to start by thinking
    about what problem your program’s supposed to solve. That’s why objects are really
    useful. They let you structure your code based on the problem it’s solving so
    that you can spend your time thinking about the problem you need to work on rather
    than getting bogged down in the mechanics of writing code. When you use objects
    right—and really put some thought into how you design them—you end up with code
    that’s intuitive to write, and easy to read and change.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建一个程序时，首先考虑你的程序应该解决的问题总是个好主意。这就是为什么对象非常有用。它们允许你根据解决问题的方式来组织你的代码，这样你可以花时间思考你需要解决的问题，而不是陷入编写代码的细节中。当你正确使用对象，并真正考虑如何设计它们时，你最终会得到易于编写、阅读和修改的代码。
- en: If code is useful, it gets reused
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果代码有用，它会被重用
- en: Developers have been reusing code since the earliest days of programming, and
    it’s not hard to see why. If you’ve written a class for one program, and you have
    another program that needs code that does exactly the same thing, then it makes
    sense to **reuse** the same class in your new program.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员自编程早期以来就一直在重用代码，而且很容易理解为什么会这样。如果你为一个程序编写了一个类，并且有另一个需要执行完全相同操作的程序，那么在新程序中重用相同的类是有意义的。
- en: '![Images](assets/104fig01.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/104fig01.png)'
- en: Some methods take parameters and return a value
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些方法接受参数并返回一个值
- en: 'You’ve seen methods that do things, like the SetUpGame method in [#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin)
    that sets up your game. Methods can do more than that: they can use **parameters**
    to get input, do something with that input, and then generate output with a **return
    value** that can be used by the statement that called the method.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了一些执行任务的方法，比如在[#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin)中的SetUpGame方法，它设置了你的游戏。方法不仅仅可以这样做：它们可以使用**参数**获取输入，对输入进行处理，然后生成具有**返回值**的输出，该返回值可以被调用方法使用的语句所使用。
- en: '![Images](assets/105fig01.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/105fig01.png)'
- en: Parameters are values that the method uses as input. They’re declared as variables
    that are included in the method declaration (between the parentheses). The return
    value is a value that’s calculated or generated inside the method, and sent back
    to the statement that called that method. The type of the return value (like *string*
    or *int*) is called the **return type**. If a method has a return type, then it
    must use a `**return**` **statement**.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是方法用作输入的值。它们被声明为包含在方法声明中的变量（在括号之间）。返回值是在方法内部计算或生成的值，并发送回调用该方法的语句。返回值的类型（如*string*或*int*）称为**返回类型**。如果一个方法有返回类型，则必须使用`**return**`
    **语句**。
- en: 'Here’s an example of a method with two int parameters and an int return type:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个具有两个int参数和一个int返回类型的方法的示例：
- en: '![Images](assets/105fig02.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/105fig02.png)'
- en: The method takes two **parameters** called `**factor1**` and `**factor2**`.
    It uses the multiplication operator `*****` to calculate the result, which it
    returns using the `**return**` keyword.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受名为`**factor1**`和`**factor2**`的两个**参数**。它使用乘法运算符`*****`来计算结果，并使用`**return**`关键字返回结果。
- en: 'This code calls the Multiply method and stores the result in a variable called
    `**area**`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码调用Multiply方法，并将结果存储在名为`**area**`的变量中：
- en: '![Images](assets/105fig03.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/105fig03.png)'
- en: Let’s build a program that picks some cards
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们构建一个挑选卡片的程序
- en: 'In the first project in this chapter, you’re going to build a .NET Core console
    app called PickRandomCards that lets you pick random playing cards. Here’s what
    its structure will look like:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一个项目中，你将构建一个名为PickRandomCards的.NET Core控制台应用程序，该程序允许你随机选择扑克牌。下面是它的结构：
- en: '![Images](assets/106fig01.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/106fig01.png)'
- en: 'Your PickSomeCards method will use string values to represent playing cards.
    If you want to pick five cards, you’ll call it like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你的PickSomeCards方法将使用字符串值来表示扑克牌。如果你想挑选五张牌，你可以像这样调用它：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `**cards**` variable has a type that you haven’t seen yet. The square brackets
    `**[]**` mean that it’s an **array of strings**. Arrays let you use a single variable
    to store multiple values—in this case, strings with playing cards. Here’s an example
    of a string array that the PickSomeCards method might return:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`**cards**` 变量有一种您还没见过的类型。方括号 `**[]**` 表示它是一个**字符串数组**。数组允许您使用单个变量存储多个值——在本例中，是带有纸牌的字符串。这里是
    PickSomeCards 方法可能返回的字符串数组示例：'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This is an array of five strings. Your card picker app will create arrays like
    this to represent a number of randomly selected cards.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含五个字符串的数组。您的卡片选择器应用程序将创建类似这样的数组来表示随机选择的卡片。
- en: '![Images](assets/106fig03.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/106fig03.png)'
- en: After your array is generated, you’ll use a `**foreach**` loop to write it to
    the console.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 生成数组后，您将使用一个 `**foreach**` 循环将其写入控制台。
- en: Create your PickRandomCards console app
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的 PickRandomCards 控制台应用程序
- en: '**Do this!**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**做这个！**'
- en: 'Let’s use what you’ve learned so far to create a program that picks a number
    of random cards. Open Visual Studio and **create a new Console App project called
    PickRandomCards**. Your program will include a class called CardPicker. Here’s
    a class diagram that shows its name and methods:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用您迄今学到的知识来创建一个选择随机卡片的程序。打开 Visual Studio 并 **创建一个名为 PickRandomCards 的新控制台应用程序项目**。您的程序将包括一个名为
    CardPicker 的类。以下是显示其名称和方法的类图：
- en: '![Images](assets/107fig01.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/107fig01.png)'
- en: Right-click on the PickRandomCards project in the Solution Explorer and **choose
    Add >> Class…** in Windows (or Add >> New Class… in macOS) from the pop-up menu.
    Visual Studio will prompt you for a class name—choose *CardPicker.cs*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中右键单击 PickRandomCards 项目，选择 Windows 中的 **添加 >> Class…**（或 macOS 中的
    **添加 >> New Class…**）来弹出菜单。Visual Studio 将提示您输入一个类名——选择 *CardPicker.cs*。
- en: '![Images](assets/107fig02.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/107fig02.png)'
- en: 'Visual Studio will create a brand-new class in your project called CardPicker:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 将在您的项目中创建一个名为 CardPicker 的全新类：
- en: '![Images](assets/107fig03.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/107fig03.png)'
- en: 'Your new class is empty—it starts with class `**CardPicker**` and a pair of
    curly braces, but there’s nothing inside them. **Add a new method called PickSomeCards**.
    Here’s what your class should look like:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您的新类是空的——它以类 `**CardPicker**` 和一对花括号开始，但里面什么都没有。**添加一个名为 PickSomeCards 的新方法**。您的类应该如下所示：
- en: '![Images](assets/107fig04.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/107fig04.png)'
- en: Finish your PickSomeCards method
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成您的 PickSomeCards 方法
- en: '**Now do this!**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**现在做这个！**'
- en: '***Your PickSomeCards method needs a return statement, so let’s add one.***
    Go ahead and fill in the rest of the method—and now that it uses a `**return**`
    statement to return a string array value, the error goes away:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***您的 PickSomeCards 方法需要一个返回语句，让我们添加一个。*** 继续填写方法的其余部分——现在它使用了一个 `**return**`
    语句来返回字符串数组值，错误消失了：'
- en: '[PRE2]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You made the red squiggly error underlines go away by returning a value with
    a type that matches the return type of the method.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过返回与方法的返回类型匹配的值，您使红色波浪线错误消失了。
- en: '***Generate the missing methods.*** Your code now has different errors because
    it doesn’t have RandomValue or RandomSuit methods. Generate these methods just
    like you did in [#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin).
    Use the Quick Actions icon in the left margin of the code editor—when you click
    it, you’ll see options to generate both methods:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***生成缺失的方法。*** 现在您的代码由于缺少 RandomValue 或 RandomSuit 方法而出现不同的错误。像在 [#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin)
    中一样生成这些方法。在代码编辑器左侧边缘使用快速操作图标——单击它时，您将看到生成这两个方法的选项：'
- en: '![Images](assets/108fig02.png)'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Images](assets/108fig02.png)'
- en: 'Go ahead and generate them. Your class should now have RandomValue and RandomSuit
    methods:'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 继续生成它们。您的类现在应该有 RandomValue 和 RandomSuit 方法：
- en: '[PRE3]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You used the IDE to generate these methods. It’s OK if they’re not in the same
    order—the order of the methods in a class doesn’t matter.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您使用 IDE 生成了这些方法。如果它们不按顺序排列也没关系——类中方法的顺序无关紧要。
- en: '***Use* *return*** ***statements to build out your RandomSuit and RandomValue
    methods.***'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***使用* *return*** ***语句来构建您的 RandomSuit 和 RandomValue 方法。***'
- en: A method can have more than one `**return**` statement, and when it executes
    one of those statements it immediately returns—and *does not execute* *any more
    statements in the method*.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个方法可以有多个 `**return**` 语句，当执行其中一个语句时，它立即返回，并且*不会执行* *方法中的任何其他语句*。
- en: 'Here’s an example of how you could take advantage of return statements in a
    program. Let’s imagine that you’re building a card game, and you need methods
    to generate random card suits or values. We’ll start by creating a random number
    generator, just like we used in the animal matching game in the first chapter.
    Add it just below the class declaration:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个利用返回语句的程序示例。想象一下，你正在制作一个卡牌游戏，需要方法来生成随机的卡牌花色或值。我们将从创建一个随机数生成器开始，就像我们在第一章的动物匹配游戏中使用的那样。将其添加到类声明的下面：
- en: '[PRE4]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now add code to your RandomSuit method that takes advantage of `**return**`
    statements to stop executing the method as soon as it finds a match. The random
    number generator’s Next method can take two parameters: `**random.Next(1, 5)**`
    returns a number that’s at least 1 but less than 5 (in other words, a random number
    from 1 to 4). Your RandomSuit method will use this to choose a random playing
    card suit:'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，在你的 RandomSuit 方法中添加代码，利用 `**return**` 语句尽快停止执行方法。随机数生成器的 Next 方法可以接受两个参数：`**random.Next(1,
    5)**` 返回的数字至少为 1，但小于 5（换句话说，从 1 到 4 的随机数）。你的 RandomSuit 方法将使用这个来选择一个随机的纸牌花色：
- en: '![Images](assets/109fig01.png)'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/109fig01.png)'
- en: 'Here’s a RandomValue method that generates a random value. See if you can figure
    out how it works:'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个生成随机值的 RandomValue 方法。看看你能否弄清楚它是如何工作的：
- en: '[PRE5]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: '**Notice how we’re returning `value.ToString()` and not just `value`? That’s
    because `value` is an int variable, but the RandomValue method was declared with
    a string return type, so we need to convert `value` to a string. You can add `**.ToString()**`
    to any variable or value to convert it to a string.**'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**注意我们为什么返回 `value.ToString()` 而不只是 `value`？因为 `value` 是一个整数变量，但 RandomValue
    方法声明为字符串返回类型，所以我们需要将 `value` 转换为字符串。你可以为任何变量或值添加 `**.ToString()**` 来将其转换为字符串。**'
- en: The return statement causes your method to stop immediately and go back to the
    statement that called it.
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回语句会导致你的方法立即停止并返回到调用它的语句。
- en: Your finished CardPicker class
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你完成的 CardPicker 类
- en: 'Here’s the code for your finished CardPicker class. It should live inside a
    namespace that matches your project’s name:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你完成的 CardPicker 类的代码。它应该位于与项目名称匹配的命名空间中：
- en: '![Images](assets/110fig01.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/110fig01.png)'
- en: Note
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: '**While you’re working on your program’s Main method, take a look at its return
    type. What do you think is going on there?**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**当你在编写程序的 Main 方法时，请看一下它的返回类型。你觉得那里在发生什么？**'
- en: Ana’s working on her next game
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安娜正在开发她的下一个游戏
- en: '![Images](assets/113fig02.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/113fig02.png)'
- en: Meet Ana. She’s an indie game developer. Her last game sold thousands of copies,
    and now she’s getting started on her next one.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 认识一下安娜。她是一名独立游戏开发者。她的上一款游戏销售了成千上万份，现在她正在着手她的下一款游戏。
- en: '![Images](assets/113fig01.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/113fig01.png)'
- en: 'Ana’s started working on some **prototypes**. She’s been working on the code
    for the alien enemies that the player has to avoid in one exciting part of the
    game, where the player needs to escape from their hideout while the aliens search
    for them. Ana’s written several methods that define the enemy behavior: searching
    the last location the player was spotted, giving up the search after a while if
    the player wasn’t found, and capturing the player if the enemy gets too close.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 安娜已经开始着手一些**原型**。她一直在编写 alien enemies 的代码，这是游戏中一个激动人心的部分，玩家需要在外星人搜索他们的藏身处时逃脱。安娜编写了几种定义敌人行为的方法：搜索玩家被发现的最后位置，一段时间后放弃搜索（如果找不到玩家），并在敌人靠近时捕获玩家。
- en: '![Images](assets/113fig03.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/113fig03.png)'
- en: Ana’s game is evolving…
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安娜的游戏正在演变中…
- en: The humans versus aliens idea is pretty good, but Ana’s not 100% sure that’s
    the direction she wants to go in. She’s also thinking about a nautical game where
    the player has to evade pirates. Or maybe it’s a zombie survival game set on a
    creepy farm. In all three of those ideas, she thinks the enemies will have different
    graphics, but their behavior can be driven by the same methods.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 人类对抗外星人的想法挺不错的，但安娜并不完全确定她想要走这个方向。她还在考虑一个海洋游戏，玩家必须躲避海盗。或者可能是一个设定在诡异农场上的僵尸生存游戏。在这三个想法中，她认为敌人会有不同的图形，但它们的行为可以由相同的方法驱动。
- en: '![Images](assets/114fig01.png)![Images](assets/114fig01a.png)![Images](assets/114fig02.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/114fig01.png)![图片](assets/114fig01a.png)![图片](assets/114fig02.png)'
- en: '**…so how can Ana make things easier for herself?**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**…那么安娜如何让自己更轻松一些呢？**'
- en: Ana’s not sure which direction the game should go in, so she wants to make a
    few different prototypes—and she wants them all to have the same code for the
    enemies, with the SearchForPlayer, StopSearching, SpottedPlayer, CommunicatePlayerLocation,
    and CapturePlayer methods. She’s got her work cut out for her.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 安娜不确定游戏应该朝哪个方向发展，所以她想制作几个不同的原型，并希望它们所有的敌人代码都一样，包括 SearchForPlayer、StopSearching、SpottedPlayer、CommunicatePlayerLocation
    和 CapturePlayer 方法。她的工作任务很多。
- en: '![Images](assets/115fig01.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/115fig01.png)'
- en: Build a paper prototype for a classic game
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为一个经典游戏建立一个纸板原型
- en: Paper prototypes are really useful for helping you figure out how a game will
    work before you start building it, which can save you a lot of time. There’s a
    fast way to get started building them—all you need is some paper and a pen or
    pencil. Start by choosing your favorite classic game. Platform games work especially
    well, so we chose one of the **most popular, most recognizable** classic video
    games ever made... but you can choose any game you’d like! Here’s what to do next.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 纸板原型在你开始构建游戏之前，帮助你理清游戏运作方式的非常有用，这能够节省很多时间。有一个快速的开始方法——你只需要一些纸和一支笔或铅笔。首先选择你最喜欢的经典游戏。平台游戏特别适合，所以我们选择了有史以来**最受欢迎、最能被认出来**的经典视频游戏之一……但你可以选择任何你喜欢的游戏！接下来该做什么，看这里。
- en: '**Draw this!**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**画这个！**'
- en: '**Draw the background on a piece of paper.** Start your prototype by creating
    the background. In our prototype, the ground, bricks, and pipe don’t move, so
    we drew them on the paper. We also added the score, time, and other text at the
    top.'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在一张纸上画背景。** 通过创建背景开始你的原型。在我们的原型中，地面、砖块和管道不会移动，所以我们在纸上画了它们。我们还在顶部添加了得分、时间和其他文本。'
- en: '**Tear small scraps of paper and draw the moving parts.** In our prototype,
    we drew the characters, the piranha plant, the mushroom, the fire flower, and
    the coins on separate scraps. If you’re not an artist, that’s absolutely fine!
    Just draw stick figures and rough shapes. Nobody else ever has to see this!'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**撕下小纸片并画出移动的部分。** 在我们的原型中，我们分别在不同的纸片上画了角色、食人花、蘑菇、火焰花和硬币。如果你不是艺术家，没关系！只需画出简单的人物和粗略的形状。别人永远不会看到这些！'
- en: '**“Play” the game.** This is the fun part! Try to simulate player movement.
    Drag the player around the page. Make the non-player characters move too. It helps
    to spend a few minutes playing the game, then go back to your prototype and see
    if you can really reproduce the motion as closely as possible. (It will feel a
    little weird at first, but that’s OK!)'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**“玩”这个游戏。** 这是有趣的部分！尝试模拟玩家移动。在页面上拖动玩家。让非玩家角色也移动。花几分钟玩游戏，然后回到你的原型，看看是否能尽可能精确地重现动作。（一开始可能会感觉有点奇怪，但没关系！）'
- en: '![Images](assets/116fig02.png)'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/116fig02.png)'
- en: '![Images](assets/117fig01.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/117fig01.png)'
- en: '**Yes! A paper prototype is a great first step for any project.**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**是的！纸板原型是任何项目的一个很好的第一步。**'
- en: If you’re building a desktop app, a mobile app, or any other project that has
    a user interface, building a paper prototype is a great way to get started. Sometimes
    you need to create a few paper prototypes before you get the hang of it. That’s
    why we started with a paper prototype for a classic game…because that’s a great
    way to learn how to build paper prototypes. **Prototyping is a really valuable
    skill for any kind of developer**, not just a game developer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在开发桌面应用程序、移动应用程序或任何其他具有用户界面的项目，制作一个纸板原型是一个很好的开始方式。有时候你需要创建几个纸板原型才能掌握窍门。这就是为什么我们从一个经典游戏的纸板原型开始……因为这是学习如何制作纸板原型的一个很好的方式。**原型设计是任何类型开发者的一项非常有价值的技能，不仅仅是游戏开发者。**
- en: Note
  id: totrans-87
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: All of the tools and ideas in “Game design... and beyond” sections are important
    programming skills that go way beyond just game development—but we’ve found that
    they’re easier to learn when you try them with games first.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: “游戏设计与更多”部分中的所有工具和想法都是重要的编程技能，不仅限于游戏开发，但我们发现当你首次尝试用游戏时，它们更容易学习。
- en: 'Up next: build a WPF version of your card picking app'
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来：构建你的卡片选择应用程序的 WPF 版本
- en: 'In the next project, you’ll build a WPF app called PickACardUI. Here’s what
    it will look like:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个项目中，你将构建一个名为 PickACardUI 的 WPF 应用程序。以下是它的外观：
- en: '![Images](assets/118fig01.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/118fig01.png)'
- en: Your PickACardUI app will let you use a Slider control to choose the number
    of random cards to pick. When you’ve selected the number of cards, you’ll click
    a button to pick them and add them to a ListBox.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 PickACardUI 应用程序将允许你使用一个滑块控件选择要随机选取的卡片数量。当你选择了卡片数量后，点击按钮即可将它们添加到一个列表框中。
- en: 'Here’s how the window will be laid out:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口的布局如下：
- en: '![Images](assets/118fig02.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/118fig02.png)'
- en: Note
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**We won’t keep reminding you to add your projects to source control—but we
    still think it’s a really good idea to create a GitHub account and publish all
    of your projects to it!**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们不会一直提醒您将项目添加到源代码控制，但我们仍然认为创建一个GitHub账户并将所有项目发布到其中是一个非常好的主意！**'
- en: '![Images](assets/118fig03.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/118fig03.png)'
- en: Note
  id: totrans-98
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There are ASP.NET Core versions of all of the WPF projects in this book that
    feature screenshots from Visual Studio for Mac.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中所有WPF项目都有ASP.NET Core版本，其中包含来自Visual Studio for Mac的屏幕截图。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Go to the Visual Studio for Mac Learner’s Guide for the Mac version of this
    project.**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**转到Visual Studio for Mac学习指南，了解此项目的Mac版本。**'
- en: A StackPanel is a container that stacks other controls
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: StackPanel是一个容器，可以堆叠其他控件
- en: 'Your WPF app will use a Grid to lay out its controls, just like you used in
    your matching game. Before you start writing code, let’s take a closer look at
    the two controls in the upper-left cell of the grid:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您的WPF应用程序将使用一个Grid来布局其控件，就像您在匹配游戏中使用的一样。在开始编写代码之前，让我们仔细看看网格的左上角单元格中的两个控件：
- en: '![Images](assets/119fig01.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/119fig01.png)'
- en: 'So how do we stack them on top of each other like that? We ***could*** try
    putting them in the same cell in the grid:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们怎样才能把它们像那样叠放在一起？我们***可以***尝试把它们放在网格的同一个单元格中：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-107
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This is XAML for a Slider control. We’ll take a closer look at it when you put
    your form together.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Slider控件的XAML。当您组合表单时，我们将更仔细地看一下它。
- en: 'But that just causes them to overlap each other:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 但这只会导致它们重叠在一起：
- en: '![Images](assets/119fig03.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/119fig03.png)'
- en: That’s where a **StackPanel control** comes in handy. A StackPanel is a container
    control—like a Grid, its job is to contain other controls and make sure they go
    in the right place in the window. While the Grid lets you arrange controls in
    rows and columns, a StackPanel lets you arrange controls ***in a horizontal or
    vertical stack***.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是**StackPanel控件**的作用。StackPanel是一个容器控件，就像Grid一样，它的工作是容纳其他控件并确保它们在窗口中放置在正确的位置。虽然Grid允许您将控件排列在行和列中，但StackPanel允许您将控件***在水平或垂直堆栈中排列***。
- en: 'Let’s take the same Label and Slider controls, but this time use a StackPanel
    to lay them out so the Label is stacked on top of the Slider. Notice that we moved
    the alignment and margin properties to the StackPanel—we want the panel itself
    to be centered, with a margin around it:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用相同的Label和Slider控件，但这次使用StackPanel来布局它们，以便Label堆叠在Slider上。请注意，我们将对齐和边距属性移到了StackPanel上——我们希望面板本身居中，并且周围有一些边距：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The StackPanel will make the controls in the cell look the way we want them
    to:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: StackPanel将使单元格中的控件看起来符合我们的要求：
- en: '![Images](assets/119fig05.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/119fig05.png)'
- en: '***So that’s how the project will work. Now let’s get started building it!***'
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '***这就是项目的工作方式。现在让我们开始构建它！***'
- en: Reuse your CardPicker class in a new WPF app
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在新的WPF应用程序中重用您的CardPicker类
- en: If you’ve written a class for one program, you’ll often want to use the same
    behavior in another. That’s why one of the big advantages of using classes is
    that they make it easier to **reuse** your code. Let’s give your card picker app
    a shiny new user interface, but keep the same behavior by reusing your CardPicker
    class.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您为一个程序编写了一个类，通常会希望在另一个程序中使用相同的行为。这就是使用类的一个重要优势之一，它们使得**重用**您的代码更加容易。让我们为您的卡片选择器应用程序提供一个全新的用户界面，但通过重用您的CardPicker类来保持相同的行为。
- en: '***Reuse this!***'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '***重用这个！***'
- en: '**Create a new WPF app called PickACardUI.**'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个名为PickACardUI的新WPF应用程序。**'
- en: 'You’ll follow exactly the same steps that you used to create your animal matching
    game in [#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin):'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您将完全按照创建动物匹配游戏时使用的步骤来完成您的应用程序[#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin)：
- en: Open Visual Studio and create a new project.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开Visual Studio并创建一个新项目。
- en: Select **WPF App (.NET Core)**.
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择**WPF应用程序（.NET Core）**。
- en: Name your new app **PickACardUI**. Visual Studio will create the project, adding
    *MainWindow.xaml* and *MainWindow.xaml.cs* files that have the namespace PickACardUI.
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的新应用程序命名为**PickACardUI**。Visual Studio将创建该项目，并添加带有命名空间PickACardUI的*MainWindow.xaml*和*MainWindow.xaml.cs*文件。
- en: '**Add the CardPicker class that you created for your Console App project.**'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加您为控制台应用程序项目创建的CardPicker类。**'
- en: Right-click on the project name and choose **Add >> Existing Item…** from the
    menu.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 右键单击项目名称，从菜单中选择**添加 >> 现有项…**。
- en: '![Images](assets/120fig02.png)'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/120fig02.png)'
- en: Navigate to the folder with your console app and select *CardPicker.cs* to add
    it to your project. Your WPF project should now have a copy of the *CardPicker.cs*
    file from your console app.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导航到包含你的控制台应用程序的文件夹，选择 *CardPicker.cs* 将它添加到你的项目中。你的 WPF 项目现在应该有一个来自你的控制台应用程序的
    *CardPicker.cs* 文件的副本。
- en: '**Change the namespace for the CardPicker class.**'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**更改 CardPicker 类的命名空间。**'
- en: '**Double-click on *CardPicker.cs*** in the Solution Explorer. It still has
    the namespace from the console app. **Change the namespace** to match your project
    name. The IntelliSense pop-up will suggest the namespace PickACardUI—**press Tab
    to accept the suggestion**:'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 双击解决方案资源管理器中的 *CardPicker.cs*。它仍然带有控制台应用程序的命名空间。**将命名空间更改**以匹配你的项目名称。IntelliSense
    弹出窗口将建议 PickACardUI 命名空间 — **按 Tab 键接受建议**：
- en: '![Images](assets/120fig03.png)'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图像](assets/120fig03.png)'
- en: 'Now your CardPicker class should be in the PickACardUI namespace:'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在你的 CardPicker 类应该在 PickACardUI 命名空间中：
- en: '[PRE8]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***Congratulations, you’ve reused your CardPicker class!*** You should see
    the class in the Solution Explorer, and you’ll be able to use it in the code for
    your WPF app.'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '***恭喜，你已经重用了你的 CardPicker 类！*** 你应该在解决方案资源管理器中看到这个类，并且你可以在你的 WPF 应用程序的代码中使用它。'
- en: Use a Grid and StackPanel to lay out the main window
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Grid 和 StackPanel 布局主窗口
- en: Back in [#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin)
    you used a Grid to lay out your animal matching game. Take a few minutes and flip
    back through the part of the chapter where you laid out the grid, because you’re
    going to do the same thing to lay out your window.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin)，你使用了
    Grid 布局你的动物匹配游戏。花几分钟翻回到你布局网格的章节，因为你将使用相同的方法来布局你的窗口。
- en: '**Set up the rows and columns.** Follow the same steps from [#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin)
    to **add two rows and two columns** to your grid. If you get the steps right,
    you should see these row and column definitions just below the `**<Grid>**` tag
    in the XAML:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置行和列。** 按照[#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin)的相同步骤来
    **添加两行和两列** 到你的网格中。如果步骤正确，你应该看到这些行和列的定义就在 XAML 中 `<Grid>` 标签下面：'
- en: '[PRE9]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can use the Visual Studio designer to add two equal rows and two equal columns.
    If you run into trouble, you can just type the XAML directly into the editor.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以使用 Visual Studio 的设计器添加两个相等的行和两个相等的列。如果遇到问题，可以直接在编辑器中输入 XAML 代码。
- en: '**Add the StackPanel.** It’s a little difficult to work with an empty StackPanel
    in the visual XAML designer because it’s hard to click on, so we’ll do this in
    the XAML code editor. **Double-click on StackPanel in the Toolbox** to add an
    empty StackPanel to the grid. You should see:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加 StackPanel。** 在可视化 XAML 设计器中使用空的 StackPanel 有点困难，因为很难点击，所以我们将在 XAML 代码编辑器中完成这个任务。**双击工具箱中的
    StackPanel**，将一个空的 StackPanel 添加到网格中。你应该看到：'
- en: '[PRE10]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![Images](assets/121fig02.png)'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图像](assets/121fig02.png)'
- en: '**Set the StackPanel’s properties.** When you double-clicked on StackPanel
    in the Toolbox, it added ***a StackPanel with no properties***. By default it’s
    in the upper-left cell in the grid, so now we just want to set its alignment and
    margin. **Click on the StackPanel tag *in the XAML editor*** to select it. Once
    it’s selected in the code editor, you’ll see its properties in the Properties
    window. Set the vertical and horizontal alignment to `**Center**` and all of the
    margins to `**20**`.'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置 StackPanel 的属性。** 当你在工具箱中双击 StackPanel 时，它添加了***一个没有属性的 StackPanel***。默认情况下它位于网格的左上角单元格中，所以现在我们只需要设置它的对齐和边距。**在
    XAML 编辑器中点击 StackPanel 标签**来选择它。一旦在代码编辑器中选中它，你会在属性窗口中看到它的属性。将垂直和水平对齐设置为 `**Center**`，并将所有边距设置为
    `**20**`。'
- en: '![Images](assets/121fig03.png)'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图像](assets/121fig03.png)'
- en: 'You should now have a StackPanel like this in your XAML code:'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在你的 XAML 代码中应该有这样一个 StackPanel：
- en: '[PRE11]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This means all of the margins are set to 20\. You might also see the Margin
    property set to “20, 20, 20, 20”—it means the same thing.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着所有的边距都设置为 20。你可能还会看到 Margin 属性设置为 “20, 20, 20, 20” — 它的意思是一样的。
- en: Lay out your Card Picker desktop app’s window
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局你的 Card Picker 桌面应用程序窗口
- en: Lay out your new card picker app’s window so it has the user controls on the
    left and displays the picked cards on the right. You’ll use a **StackPanel** in
    the upper-left cell. It’s a **container**, which means it contains other controls,
    just like a Grid. But instead of laying the controls out in cells, it stacks them
    either horizontally or vertically. Once your StackPanel is laid out with a Label
    and Slider, you’ll add ListBox control, just like the one you used in [#dive_into_chash_statementscomma_classesc](ch02.html#dive_into_chash_statementscomma_classesc).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 布局新卡片选择器应用程序的窗口，使其左侧有用户控件，并在右侧显示选择的卡片。您将在左上角单元格中使用 **StackPanel**。它是一个 **容器**，意味着它包含其他控件，就像
    Grid 一样。但是它不是将控件放在单元格中，而是垂直或水平地堆叠它们。一旦您的 StackPanel 布局完成，其中包含一个 Label 和一个 Slider，您将添加
    ListBox 控件，就像您在[#dive_into_chash_statementscomma_classesc](ch02.html#dive_into_chash_statementscomma_classesc)中使用的那个一样。
- en: '**Add a Label and Slider to your StackPanel.**'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**向 StackPanel 添加标签和滑块。**'
- en: '***Design this!***'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '***设计它！***'
- en: A StackPanel is a container. When a StackPanel doesn’t contain any other controls,
    *you can’t see it in the designer*, which makes it hard to drag controls onto
    it. Luckily, it’s just as fast to add controls to it as it is to set its properties.
    **Click on the StackPanel to select it.**
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: StackPanel 是一个容器。当 StackPanel 不包含任何其他控件时，*您无法在设计器中看到它*，这使得很难将控件拖放到其上。幸运的是，向其中添加控件与设置其属性一样快速。**点击
    StackPanel 以选中它。**
- en: '![Images](assets/122fig01.png)'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图像](assets/122fig01.png)'
- en: While the StackPanel is selected, **double-click on Label in the Toolbox** to
    put a new Label control *inside the StackPanel*. The Label will appear in the
    designer, and a `**Label**` tag will appear in the XAML code editor.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选中 StackPanel，**在工具箱中双击 Label**，将一个新的标签控件 *放置在 StackPanel 内部*。标签将出现在设计器中，并在
    XAML 代码编辑器中会出现一个`**Label**`标记。
- en: Next, expand the *All WPF Controls* section in the Toolbox and **double-click
    on Slider**. Your upper-left cell should now have a StackPanel that contains a
    Label stacked on top of a Slider.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，在工具箱中展开*所有 WPF 控件*部分，并**双击滑块**。现在您的左上角单元格应该有一个 StackPanel，其中包含一个在顶部堆叠的标签和一个滑块。
- en: '**Set the properties for the Label and Slider controls.**'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置标签和滑块控件的属性。**'
- en: 'Now that your StackPanel has a Label and a Slider, you just need to set their
    properties:'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，您的 StackPanel 已经有了一个标签和一个滑块，您只需要设置它们的属性：
- en: Click on the Label in the designer. Expand the Common section in the Properties
    window and set its content to `**How many cards should I pick?**`—then expand
    the Text section and set its font size to `**20px**`.
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设计器中点击标签。展开“通用”部分，在属性窗口中将其内容设置为`**我应该选择多少张卡片？**`—然后展开“文本”部分，将其字体大小设置为`**20px**`。
- en: Press Escape to deselect the Label, then **click on the Slider in the designer**
    to select it. Use the Name box at the top of the Properties window to change its
    name to `**numberOfCards**`.
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按 Esc 键取消选择 Label，然后在设计器中**点击滑块**以选中它。使用属性窗口顶部的名称框将其名称更改为`**numberOfCards**`。
- en: Expand the Layout section and use the square (![Images](assets/122fig02.png))
    to reset the width.
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展开“布局”部分，使用方形（![图像](assets/122fig02.png)）重置宽度。
- en: Expand the Common section and set its Maximum property to `**15**`, Minimum
    to `**1**`, AutoToolTipPlacement to `**TopLeft**`, and TickPlacement to `**BottomRight**`.
    Then click the caret (![Images](assets/122fig03.png)) to expand the Layout section
    and expose additional properties, including the IsSnapToTickEnabled property.
    Set it to `**True**`.
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展开“通用”部分，并将其最大属性设置为`**15**`，最小属性设置为`**1**`，自动工具提示放置设置为`**TopLeft**`，刻度放置设置为`**BottomRight**`。然后点击插入点（![图像](assets/122fig03.png)）展开“布局”部分，并显示其他属性，包括IsSnapToTickEnabled属性。将其设置为`**True**`。
- en: Let’s make ticks a little easier to see. Expand the Brush section in the Properties
    window and **click on the large rectangle to the right of Foreground**—this will
    let you use the color selector to choose the foreground color for the slider.
    Click in the R box and set it to `**0**`, then set G and B to `**0**` as well.
    The Foreground box should now be black, and the tick marks under the slider should
    be black.
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让刻度线更易于看见。在属性窗口中展开“笔刷”部分，**点击前景右侧的大矩形**—这将让您使用颜色选择器选择滑块的前景颜色。点击R框，并将其设置为`**0**`，然后将G和B也设置为`**0**`。前景框现在应该是黑色，滑块下的刻度线应该是黑色的。
- en: 'The XAML should look like this—if you’re having trouble with the designer,
    just edit the XAML directly:'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: XAML 应该如下所示——如果您在设计器中遇到问题，可以直接编辑 XAML：
- en: '[PRE12]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Add a Button to the lower-left cell.**'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**向左下角单元格添加一个按钮。**'
- en: 'Drag a Button out of the toolbox and into the lower-left cell of the grid and
    set its properties:'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从工具箱拖动一个按钮到网格的左下角，并设置其属性：
- en: Expand the Common section and set its Content property to `**Pick some cards**`.
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展开通用部分并将其内容属性设置为`**Pick some cards**`。
- en: Expand the Text section and set its font size to `**20px**`.
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展开文本部分并将其字体大小设置为`**20px**`。
- en: Expand the Layout section. Reset its margins, width, and height. Then set its
    vertical and horizontal alignment to `**Center**` (![Images](assets/123fig01.png)
    and ![Images](assets/123fig02.png)).
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展开布局部分。重置其边距、宽度和高度。然后将其垂直和水平对齐设置为`**Center**`（![图像](assets/123fig01.png) 和 ![图像](assets/123fig02.png)）。
- en: 'The XAML for your Button control should look like this:'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的按钮控件的XAML应该如下所示：
- en: '[PRE13]'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Add a ListBox that fills the right half of the window by spanning two rows.**'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加一个ListBox，占据窗口右半部分并跨两行。**'
- en: 'Drag a ListBox control into the upper-right cell and set its properties:'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将一个ListBox控件拖到右上角的单元格中，并设置其属性：
- en: Use the Name box at the top of the Properties window to set the ListBox’s name
    to `**listOfCards**`.
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性窗口顶部的名称框，将ListBox的名称设置为`**listOfCards**`。
- en: Expand the Text section and set its font size to `**20px**`.
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展开文本部分并将其字体大小设置为`**20px**`。
- en: Expand the Layout section. Set its margins to `**20**`, just like you did with
    the StackPanel control. Make sure its width, height, horizontal alignment, and
    vertical alignment are reset.
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展开布局部分。将其边距设置为`**20**`，就像你在StackPanel控件中所做的一样。确保其宽度、高度、水平对齐和垂直对齐被重置。
- en: 'Make sure Row is set to 0 and Column is set to 1\. Then **set the RowSpan to
    2** so that the ListBox takes up the entire column and stretches across both rows:'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保行设置为0，并设置列为1。然后**将RowSpan设置为2**，使ListBox占据整个列并跨越两行：
- en: '![Images](assets/123fig04.png)'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图像](assets/123fig04.png)'
- en: 'The XAML for your ListBox control should look like this:'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的ListBox控件的XAML应该如下所示：
- en: '[PRE14]'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: It’s OK if this value is just “20” instead of “20, 20, 20, 20”—that means the
    same thing.
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果这个值只是“20”而不是“20, 20, 20, 20”，那意思是一样的。
- en: '**Set the window title and size.**'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置窗口标题和大小。**'
- en: 'When you create a new WPF app, Visual Studio creates a main window that’s 450
    pixels wide and 800 pixels tall with the title “Main Window.” Let’s resize it,
    just like you did with the animal matching game:'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你创建一个新的WPF应用程序时，Visual Studio会创建一个主窗口，宽度为450像素，高度为800像素，标题为“主窗口”。让我们调整它的大小，就像你在动物配对游戏中所做的一样：
- en: Click on the window’s title bar in the designer to select the window.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设计器中点击窗口的标题栏以选择窗口。
- en: Use the Layout section to set the width to `**300**`.
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用布局部分将宽度设置为`**300**`。
- en: Use the Common section to set the title to `**Card Picker**`.
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通用部分将标题设置为`**Card Picker**`。
- en: 'Scroll to the top of the XAML editor and look at the last line of the `**Window**`
    tag. You should see these properties:'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 滚动到XAML编辑器的顶部，查看`**Window**`标记的最后一行。你应该看到这些属性：
- en: '[PRE15]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Add a Click event handler to your Button control.**'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为你的按钮控件添加一个Click事件处理程序。**'
- en: 'The **code-behind**—tthe C# code in *MainWindow.xaml.cs* that’s joined to your
    XAML—consists of a single method. Double-click on the button in the designer—the
    IDE will add a method called Button_Click and make it the Click event handler,
    just like it did in [#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin).
    Here’s the code for your new method:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**代码后端** ——连接到你的XAML的*MainWindow.xaml.cs*中的C#代码——由一个方法组成。在设计器中双击按钮——IDE将添加一个名为Button_Click的方法，并将其设置为Click事件处理程序，就像在[#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin)中所做的那样。这是你的新方法的代码：'
- en: '[PRE16]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The C# code joined to your XAML window that contains the event handlers is called
    the code-behind.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与你的XAML窗口连接的C#代码，包含事件处理程序，称为代码后端。
- en: '**Now run your app.** Use the slider to choose the number of random cards to
    pick, then press the button to add them to the ListBox. ***Nice work!***'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**现在运行你的应用程序。** 使用滑块选择随机选取的卡片数量，然后按按钮将它们添加到ListBox中。***干得好！***'
- en: '![Images](assets/124fig02.png)'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图像](assets/124fig02.png)'
- en: Ana’s prototypes look great…
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ana的原型看起来很棒…
- en: Ana found out that whether her player was being chased by an alien, a pirate,
    a zombie, or an evil killer clown, she could use the same methods from her Enemy
    class to make them work. Her game is starting to shape up.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Ana发现，无论她的玩家是被外星人、海盗、僵尸还是邪恶的杀人小丑追逐，她都可以使用与她的Enemy类相同的方法来使它们工作。她的游戏开始形成。
- en: '![Images](assets/125fig01.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/125fig01.png)'
- en: …but what if she wants more than one enemy?
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: …但如果她想要多于一个敌人呢？
- en: And that’s great…until Ana wants more than one enemy, which is all there was
    in each of her early prototypes. What should she do to add a second or third enemy
    to her game?
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 而这很棒...直到 Ana 想要更多的敌人，这是她早期原型中的全部内容。她应该怎么做才能在游戏中添加第二或第三个敌人呢？
- en: Ana *could* copy the Enemy class code and paste it into two more class files.
    Then her program could use methods to control three different enemies at once.
    Technically, we’re reusing the code…right?
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Ana *可能* 将 Enemy 类的代码复制并粘贴到另外两个类文件中。然后她的程序可以使用方法同时控制三个不同的敌人。从技术上讲，我们正在重复使用代码...对吗？
- en: Hey Ana, what do you think of that idea?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，Ana，你觉得这个主意怎么样？
- en: '![Images](assets/125fig02.png)![Images](assets/125fig02a.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/125fig02.png)![图片](assets/125fig02a.png)'
- en: '**Maintaining three copies of the same code is really messy.**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**维护三份相同代码真的很混乱。**'
- en: 'A lot of problems you have to solve need a way to represent one ***thing***
    a bunch of different times. In this case, it’s an enemy in a game, but it could
    be songs in a music player app, or contacts in a social media app. Those all have
    one thing in common: they always need to treat the same kind of thing in the same
    way, no matter how many of that thing they’re dealing with. Let’s see if we can
    find a better solution.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 许多你需要解决的问题需要一种方式来多次表示一个 ***事物***。在这种情况下，它是游戏中的一个敌人，但它可能是音乐播放器应用中的歌曲，或者社交媒体应用中的联系人。它们都有一个共同点：无论处理多少这样的事物，它们总是需要以相同的方式对待相同类型的事物。让我们看看能否找到一个更好的解决方案。
- en: Ana can use objects to solve her problem
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ana 可以使用对象来解决她的问题
- en: '**Objects** are C#’s tool that you use to work with a bunch of similar things.
    Ana can use objects to program her Enemy class just once, and use it *as many
    times as she wants* in a program.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象** 是 C# 中用来处理一堆相似事物的工具。Ana 可以仅编写一次 Enemy 类，并在程序中*任意次数*使用它。'
- en: '![Images](assets/126fig01.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/126fig01.png)'
- en: You use a class to build an object
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类来构建对象
- en: A class is like a blueprint for an object. If you wanted to build five identical
    houses in a suburban housing development, you wouldn’t ask an architect to draw
    up five identical sets of blueprints. You’d just use one blueprint to build five
    houses.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 类就像对象的蓝图。如果你想在郊区住宅开发中建造五座相同的房子，你不会让建筑师绘制五套相同的蓝图。你只需使用一个蓝图来建造五座房子。
- en: '![Images](assets/127fig01.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/127fig01.png)'
- en: '**A class defines its members, just like a blueprint defines the layout of
    the house. You can use one blueprint to make any number of houses, and you can
    use one class to make any number of objects.**'
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**类定义其成员，就像蓝图定义房屋的布局一样。你可以使用一个蓝图制作任意数量的房屋，也可以使用一个类制作任意数量的对象。**'
- en: An object gets its methods from its class
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象从其类中获取其方法
- en: Once you build a class, you can create as many objects as you want from it using
    the `**new**` statement. When you do this, every method in your class becomes
    part of the object.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你建立了一个类，你可以使用 `**new**` 语句从中创建任意数量的对象。这样做时，类中的每个方法都成为对象的一部分。
- en: '![Images](assets/127fig02.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/127fig02.png)'
- en: When you create a new object from a class, it’s called an instance of that class
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当你从一个类创建一个新对象时，它被称为该类的一个实例
- en: You use the **`new` keyword** to create an object. All you need is a variable
    to use with it. Use the class as the variable type to declare the variable, so
    instead of int or bool, you’ll use a class like House or Enemy.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **`new` 关键字** 创建对象。你只需一个变量来使用它。使用类作为变量类型来声明该变量，所以不是用 int 或 bool，而是像 House
    或 Enemy 这样的类。
- en: Note
  id: totrans-220
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: in-stance, noun.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 实例，名词。
- en: an example or one occurrence of something. *The IDE search-andreplace feature
    finds every **instance** of a word and changes it to another.*
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子或某事物的一个发生。*IDE 的搜索替换功能找到每个 **实例** 单词并将其更改为另一个。*
- en: '![Images](assets/128fig01.png)![Images](assets/128fig02.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/128fig01.png)![图片](assets/128fig02.png)'
- en: '**Yes! You’ve already created instances in your own code.**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**是的！你已经在自己的代码中创建了实例。**'
- en: 'Go back to your animal matching program and look for this line of code:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 回到你的动物匹配程序，找到这行代码：
- en: '[PRE17]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You created an instance of the Random class, and then you called its Next method.
    Now look at your CardPicker class and find the `**new**` statement. You’ve been
    using objects this whole time!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建了 Random 类的一个实例，然后调用了它的 Next 方法。现在看看你的 CardPicker 类，找到 `**new**` 语句。你一直在使用对象！
- en: A better solution for Ana…brought to you by objects
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 Ana 提供的更好解决方案...由对象提供
- en: Ana used objects to reuse the code in the Enemy class without all that messy
    copying that would’ve left duplicate code all over her project. Here’s how she
    did it.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Ana 使用对象来重用 Enemy 类中的代码，避免了在项目中到处复制代码的混乱。她是这样做的。
- en: Ana created a Level class that stored the enemies in an **Enemy array** called
    `**enemies**`, just like you used string arrays to store cards and animal emoji.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ana 创建了一个名为`**enemies**`的**Enemy 数组**存储的 Level 类，就像你用字符串数组存储卡片和动物表情符号一样。
- en: '![Images](assets/129fig01.png)'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/129fig01.png)'
- en: She used a loop that called `**new**` statements to create new instances of
    the Enemy class for the level and add them to an array of enemies.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 她使用了一个循环调用`**new**`语句为关卡创建 Enemy 类的新实例，并将它们添加到一个敌人数组中。
- en: '![Images](assets/129fig02.png)'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/129fig02.png)'
- en: She called methods of each Enemy instance during every frame update to implement
    the enemy behavior.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 她在每帧更新期间调用每个 Enemy 实例的方法来实现敌人的行为。
- en: '![Images](assets/129fig03.png)'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/129fig03.png)'
- en: '**When you create a new instance of a class, it’s called instantiating that
    class.**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**当你创建一个类的新实例时，称为实例化该类。**'
- en: '![Images](assets/130fig01.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/130fig01.png)'
- en: '**That’s right, we didn’t.**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**没错，我们确实没有。**'
- en: Some game prototypes are really simple, while others are much more complicated—but
    complicated programs ***follow the same patterns*** as simple ones. Ana’s game
    program is an example of how someone would use objects in real life. And this
    doesn’t just apply to game development! No matter what kind of program you’re
    building, you’ll use objects in exactly the same way that Ana did in her game.
    Ana’s example is just the starting point for getting this concept into your brain.
    We’ll give you ***lots more examples*** over the rest of the chapter—and this
    concept is so important that we’ll revisit it in future chapters, too.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一些游戏原型非常简单，而另一些则更加复杂，但复杂的程序 ***遵循与简单程序相同的模式***。Ana 的游戏程序就是一个使用对象的现实生活示例。这不仅适用于游戏开发！无论你构建什么类型的程序，你都会像
    Ana 在她的游戏中那样使用对象。Ana 的例子只是把这个概念引入你的大脑的起点。在本章的其余部分，我们将给你 ***更多的例子*** —— 而这个概念如此重要，我们在未来的章节中也会再次讨论它。
- en: Theory and practice
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理论与实践
- en: Speaking of patterns, here’s a pattern that you’ll see over and over again throughout
    the book. We’ll introduce a concept or idea (like objects) over the course of
    a few pages, using pictures and short code excerpts to demonstrate the idea. This
    is your opportunity to take a step back and try to understand what’s going on
    without having to worry about getting a program to work.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到模式，这是本书中会反复出现的模式。我们会在几页内介绍一个概念或思想（比如对象），使用图片和简短的代码片段来演示这个想法。这是你有机会退后一步，试着理解发生的事情，而不必担心让程序工作。
- en: '![Images](assets/130fig02.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/130fig02.png)'
- en: An instance uses fields to keep track of things
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个实例使用字段来跟踪事物
- en: 'You’ve seen how classes can contain fields as well as methods. We just saw
    how you used the `**static**` keyword to declare a field in your CardPicker class:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到类可以包含字段以及方法。我们刚刚看到你如何在 CardPicker 类中使用`**static**`关键字声明一个字段：
- en: '[PRE18]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: What happens if you take away that `**static**` keyword? Then the field becomes
    an **instance field**, and every time you instantiate the class the new instance
    that was created *gets its own copy* of that field.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你去掉`**static**`关键字会发生什么？然后这个字段就成为了 **实例字段**，每次实例化类时，新创建的实例 *得到它自己的副本*。
- en: Note
  id: totrans-247
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Sometimes people think the word “instantiate” sounds a little weird, but it
    makes sense when you think about what it means.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候人们认为“实例化”这个词听起来有点奇怪，但是当你想想它的意思时就会明白。
- en: When we want to include fields a class diagram, we’ll draw a horizontal line
    in the box. The fields go above the line, and methods go below the line.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要在类图中包含字段时，我们会在框中画一条水平线。字段在线上方，而方法在线下方。
- en: '![Images](assets/133fig01.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/133fig01.png)'
- en: Methods are what an object does. Fields are what the object knows.
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法是对象做什么的。字段是对象知道什么的。
- en: 'When Ana’s prototype created three instances of her Enemy class, each of those
    objects was used to keep track of a different enemy in the game. Every instance
    keeps separate copies of the same data: setting a field on the enemy2 instance
    won’t have any effect on the enemy1 or enemy3 instances.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Ana 的原型创建了三个 Enemy 类的实例时，每个对象都用于跟踪游戏中的不同敌人。每个实例都保留相同数据的单独副本：在 enemy2 实例上设置字段不会对
    enemy1 或 enemy3 实例产生任何影响。
- en: '![Images](assets/133fig02.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/133fig02.png)'
- en: An object’s behavior is defined by its methods, and it uses fields to keep track
    of its state.
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对象的行为由其方法定义，并使用字段来跟踪其状态。
- en: '![Images](assets/134fig01.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/134fig01.png)'
- en: '**Yes! That’s why you used the `**static**` keyword in your declarations.**'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**是的！这就是为什么你在声明中使用了 `**static**` 关键字。**'
- en: 'Take another look at the first few lines of your CardPicker class:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 再看一下你的 CardPicker 类的前几行：
- en: '[PRE19]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When you use the `**static**` keyword to declare a field or method in a class,
    you don’t need an instance of that class to access it. You just called your method
    like this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `**static**` 关键字在类中声明字段或方法时，你不需要该类的实例来访问它。你只需像这样调用你的方法：
- en: '[PRE20]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'That’s how you call static methods. If you take away the `**static**` keyword
    from the PickSomeCards method declaration, then you’ll have to create an instance
    of CardPicker in order to call the method. Other than that distinction, static
    methods are just like object methods: they can take arguments, they can return
    values, and they live in classes.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何调用静态方法的。如果从 PickSomeCards 方法声明中去掉 `**static**` 关键字，那么你需要创建一个 CardPicker
    的实例才能调用该方法。除此之外，静态方法和对象方法一样：它们可以接受参数、返回值，并且存在于类中。
- en: When a field is static **there’s only one copy of it, and it’s shared by all
    instances**. So if you created multiple instances of CardPicker, they would all
    share the same *random* field. You can even mark your **whole class** as static,
    and then all of its members **must** be static too. If you try to add a nonstatic
    method to a static class, your program won’t build.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当字段是静态的**时，只有一个副本，它被所有实例共享**。因此，如果你创建了多个 CardPicker 实例，它们将共享同一个*random*字段。你甚至可以将**整个类**标记为静态，那么所有成员**必须**也是静态的。如果你尝试向静态类添加非静态方法，你的程序将无法构建。
- en: When a field is static, there’s only one copy of it shared by all instances.
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当字段是静态的时候，只有一个副本被所有实例共享。
- en: Note
  id: totrans-264
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The *= operator tells C# to take whatever’s on the left of the operator and
    multiply it by whatever’s on the right, so this will update the Height field.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`*=` 操作符告诉 C# 使用操作符左侧的内容与右侧的内容相乘，因此这将更新 Height 字段。'
- en: Thanks for the memory
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 感谢记忆
- en: When your program creates an object, it lives in a part of the computer’s memory
    called the **heap**. When your code creates an object with a `**new**` statement,
    C# immediately reserves space in the heap so it can store the data for that object.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的程序创建一个对象时，它会存放在计算机内存的一部分，称为**堆**。当你的代码使用 `**new**` 语句创建一个对象时，C# 立即在堆中预留空间来存储该对象的数据。
- en: '![Images](assets/136fig01.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/136fig01.png)'
- en: '**When your program creates a new object, it gets added to the heap.**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**当程序创建一个新对象时，它被添加到堆中。**'
- en: What’s on your program’s mind
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的程序在想什么
- en: 'Let’s take a closer look at the program in the “Sharpen your pencil” exercise,
    starting with the first line of the Main method. It’s actually **two statements**
    combined into one:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看“磨砺你的铅笔”练习中的程序，从 Main 方法的第一行开始。实际上这是**两个语句**合并成一个：
- en: '![Images](assets/137fig01.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/137fig01.png)'
- en: 'Next, let’s look closely at what the heap looks like after each group of statements
    is executed:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们仔细看看每组语句执行后堆的样子：
- en: '![Images](assets/137fig02.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/137fig02.png)'
- en: Sometimes code can be difficult to read
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有时代码会很难阅读
- en: You may not realize it, but you’re constantly making choices about how to structure
    your code. Do you use one method to do something? Do you split it into more than
    one? Do you even need a new method at all? The choices you make about methods
    can make your code much more intuitive—or if you’re not careful, much more convoluted.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能没有意识到，但你在不断地做出关于如何组织你的代码的选择。你是使用一个方法来完成某件事吗？你把它分成多个方法了吗？你甚至需要一个新的方法吗？你对方法的选择可以使你的代码更加直观——或者如果不小心的话，会变得更加混乱。
- en: 'Here’s a nice, compact chunk of code from a control program that runs a machine
    that makes candy bars:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个运行制造巧克力棒机器的控制程序中的一小段精简代码：
- en: '[PRE21]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Extremely compact code can be especially problematic
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 极其精简的代码可能会特别棘手
- en: 'Take a second and look at that code. Can you figure out what it does? Don’t
    feel bad if you can’t—it’s very difficult to read! Here are a few reasons why:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 再看一眼那段代码。你能弄清楚它是做什么的吗？如果你无法弄清楚，别难过——它确实非常难读！以下是几个原因：
- en: 'We can see a few variable names: `**tb**`, `**ics**`, `**m**`. These are terrible
    names! We have no idea what they do. And what’s that T class for?'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以看到几个变量名：`**tb**`, `**ics**`, `**m**`。这些名字太糟糕了！我们不知道它们具体做什么。那个 T 类是用来干嘛的？
- en: The chkTemp method returns an integer…but what does it do? We can guess maybe
    it has something to do with checking the temperature of…something?
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chkTemp` 方法返回一个整数……但它是干什么的？也许我们可以猜测它可能与检查某物的温度有关？'
- en: The clsTrpV method has one parameter. Do we know what that parameter is supposed
    to be? Why is it 2? What is that 160 number for?
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clsTrpV` 方法有一个参数。我们知道这个参数应该是什么吗？为什么是2？那个160的数字是干什么用的？'
- en: '![Images](assets/138fig01.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/138fig01.png)'
- en: '**C# and .NET are everywhere…and we mean everywhere**.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**C# 和 .NET 无处不在……真的是无处不在**。'
- en: Have you ever played with a Raspberry PI? It’s a low-cost computer on a single
    board, and computers like it can be found inside all sorts of machinery. Thanks
    to Windows IoT (or Internet of Things), your C# code can run on them. There’s
    a free version for prototyping, so you can start playing with hardware any time.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你玩过树莓派吗？它是一款单板低成本电脑，类似它的计算机可以在各种机械中找到。借助Windows IoT（物联网），您的C#代码可以在这些设备上运行。有一个免费的原型版本，所以您随时可以开始玩硬件。
- en: 'You can learn more about .NET IoT apps here: [https://dotnet.microsoft.com/apps/iot](https://dotnet.microsoft.com/apps/iot).'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里了解更多关于.NET IoT 应用的信息：[https://dotnet.microsoft.com/apps/iot](https://dotnet.microsoft.com/apps/iot)。
- en: Most code doesn’t come with a manual
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大多数代码并不附带手册
- en: Those statements don’t give you any hints about why the code’s doing what it’s
    doing. In this case, the programmer was happy with the results because she was
    able to get it all into one method. But making your code as compact as possible
    isn’t really useful! Let’s break it up into methods to make it easier to read,
    and make sure the classes are given names that make sense.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这些声明并不为您提供任何有关代码为何这样做的提示。在这种情况下，程序员因为能够将所有内容放入一个方法中而感到满意。但尽可能使代码尽可能紧凑并不是真正有用的！让我们将其拆分为方法以使其更易读，并确保类名给出有意义的名称。
- en: We’ll start by figuring out what the code is supposed to do. Luckily, we happen
    to know that this code is part of an **embedded system**, or a controller that’s
    part of a larger electrical or mechanical system. And we happen to have documentation
    for this code—specifically, the manual that the programmers used when they originally
    built the system.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从搞清楚代码的预期功能开始。幸运的是，我们知道这段代码是嵌入式系统的一部分，或者是较大电气或机械系统的控制器。而且我们碰巧有这段代码的文档——特别是当程序员最初构建系统时使用的手册。
- en: '![Images](assets/139fig01.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/139fig01.png)'
- en: 'We can compare the code with the manual that tells us what the code is supposed
    to do. Adding comments can definitely help us understand what it’s supposed to
    do:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将代码与告诉我们代码预期功能的手册进行比较。添加注释绝对可以帮助我们理解它预期做什么：
- en: '[PRE22]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-294
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: Adding extra line breaks to your code in some places can make it easier to read.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些地方为代码添加额外的换行可以使其更易读。
- en: Use intuitive class and method names
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用直观的类和方法名称
- en: 'That page from the manual made it a lot easier to understand the code. It also
    gave us some great hints about how to make our code easier to understand. Let’s
    take a look at the first two lines:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 那来自手册的页面使我们更容易理解了代码。它还为我们提供了一些使代码更易于理解的好建议。让我们先看一下前两行代码：
- en: '[PRE23]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The comment we added explains a lot. Now we know why the conditional test checks
    the variable `**t**` against 160—the manual says that any temperature above 160°C
    means the nougat is too hot. It turns out that `**m**` is a class that controls
    the candy maker, with static methods to check the nougat temperature and check
    the air system.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的注释解释了很多。现在我们知道为什么条件测试将变量`**t**`与160比较——手册说明，任何高于160°C的温度意味着牛轧糖太热了。原来`**m**`是一个控制糖果制造机的类，具有用于检查牛轧糖温度和检查空气系统的静态方法。
- en: 'So let’s put the temperature check into a method, and choose names for the
    class and the methods that make their purpose obvious. We’ll move these first
    two lines into their own method that returns a Boolean value, true if the nougat
    is too hot or false if it’s OK:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 将温度检查放入一个方法中，并选择使类和方法名称显而易见其目的。我们将这前两行移到一个方法中，该方法返回布尔值，如果牛轧糖太热则返回true，否则返回false：
- en: '[PRE24]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-302
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: When we rename the class “CandyBarMaker” and the method “CheckNougatTemperature”
    it starts to make the code easier to understand.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将类重命名为“CandyBarMaker”，方法重命名为“CheckNougatTemperature”时，代码开始变得更易理解。
- en: Note
  id: totrans-304
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: Notice how the C in CandyBarMaker is uppercase? If we always start class names
    with an uppercase letter and variables with lowercase ones, it’s easier to tell
    when you’re calling a static method versus using an instance.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 注意看，CandyBarMaker 中的 C 是大写的吗？如果我们总是以大写字母开头来命名类名，以小写字母开头来命名变量，那么当您调用静态方法时与使用实例时，就更容易区分了。
- en: Did you notice the special `///` comments above the method? That’s called an
    *XML Documentation Comment*. The IDE uses those comments to show you documentation
    for methods—like the documentation you saw when you used the IntelliSense window
    to figure out which method from the Random class to use.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 您注意到方法上面的特殊`///`注释了吗？这被称为*XML文档注释*。IDE使用这些注释向您显示方法的文档，就像您使用IntelliSense窗口查找Random类中的方法时看到的文档一样。
- en: 'What does the manual say to do if the nougat is too hot? It tells us to perform
    the candy isolation cooling system (or CICS) vent procedure. So let’s make another
    method, and choose an obvious name for the T class (which turns out to control
    the turbine) and the ics class (which controls the isolation cooling system, and
    has two static methods to fill and vent the system), and cap it all off with some
    brief XML documentation:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果nougat太热，手册上说要做什么？它告诉我们执行糖果隔离冷却系统（或CICS）vent过程。因此，让我们再做一个方法，并为T类（控制涡轮）和ics类（控制隔离冷却系统，并有两个静态方法填充和vent系统）选择一个明显的名称，并在一些简短的XML文档中结束：
- en: '[PRE25]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-309
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When your method is declared with a void return type, that means it doesn’t
    return a value and it doesn’t need a return statement. All of the methods you
    wrote in the last chapter used the void keyword!
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的方法声明为 void 返回类型时，这意味着它不返回任何值，也不需要 return 语句。在上一章中编写的所有方法都使用了 void 关键字！
- en: 'Now that we have the IsNougatTooHot and DoCICSVentProcedure methods, we can
    ***rewrite the original confusing code as a single method***—and we can give it
    a name that makes clear exactly what it does:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了IsNougatTooHot和DoCICSVentProcedure方法，我们可以***将原来令人困惑的代码重写为单一方法***—并且我们可以为它取一个能清楚地表明其功能的名称：
- en: '[PRE26]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now the code is a lot more intuitive! Even if you don’t know that the CICS vent
    procedure needs to be run if the nougat is too hot, **it’s a lot more obvious
    what this code is doing**.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码更加直观了！即使您不知道如果nougat太热，CICS vent 过程需要运行，**代码正在做什么也更加明显**。
- en: '![Images](assets/141fig01.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/141fig01.png)'
- en: Note
  id: totrans-315
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Use class diagrams to plan out your classes**'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用类图来规划您的类**'
- en: A class diagram is valuable tool for designing your code BEFORE you start writing
    it. Write the name of the class at the top of the diagram. Then write each method
    in the box at the bottom. Now you can see all of the parts of the class at a glance—and
    that’s your first chance to spot problems that might make your code difficult
    to use or understand later.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 类图是在开始编写代码之前设计您的代码的有价值工具。在图表的顶部写类的名称。然后在底部的框中写每个方法。现在您可以一眼看到类的所有部分—这是您首次发现可能使您的代码难以使用或理解的问题的机会。
- en: '![Images](assets/142fig01.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/142fig01.png)'
- en: '**That’s right. When you change the structure of your code without altering
    its behavior, it’s called** refactoring.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**没错。当您改变代码的结构而不改变其行为时，这被称为**重构。'
- en: Great developers write code that’s as easy as possible to understand, even after
    they haven’t looked at it for a long time. Comments can help, but nothing beats
    choosing intuitive names for your methods, classes, variables, and fields.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的开发人员编写的代码尽可能易于理解，即使在很长一段时间后再次查看也是如此。注释可以帮助，但没有什么比为您的方法、类、变量和字段选择直观名称更好的了。
- en: You can make your code easier to read and write by thinking about the problem
    your code was built to solve. If you choose names for your methods that make sense
    to someone who understands that problem, then your code will be a lot easier to
    decipher and develop. No matter how well we plan our code, we almost never get
    things exactly right the first time.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 通过考虑您的代码构建的问题，您可以使代码更易于阅读和编写。如果您为您的方法选择了对理解该问题的人有意义的名称，那么您的代码将更容易解释和开发。无论我们如何精心计划我们的代码，我们几乎永远不会一开始就完全正确。
- en: That’s why ***advanced developers constantly refactor their code***. They’ll
    move code into methods and give them names that make sense. They’ll rename variables.
    Any time they see code that isn’t 100% obvious, they’ll take a few minutes to
    refactor it. They know it’s worth taking the time to do it now, because it will
    make it easier to add more code in an hour (or a day, a month, or a year!).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么***高级开发人员不断重构他们的代码***。他们会将代码移到方法中，并赋予它们有意义的名称。他们会重命名变量。每当他们看到不完全明显的代码时，他们会花几分钟来重构它。他们知道现在花时间做这些事情是值得的，因为这会使他们在一小时（或一天、一个月或一年！）后更容易添加更多的代码。
- en: Build a class to work with some guys
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个类来与一些家伙一起工作
- en: Joe and Bob lend each other money all the time. Let’s create a class to keep
    track of how much cash they each have. We’ll start with an overview of what we’ll
    build.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 乔和鲍勃经常互相借钱。让我们创建一个类来跟踪他们各自有多少现金。我们将从概述我们将构建的内容开始。
- en: '**We’ll create two instances of a “Guy” class.**'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们将创建两个“Guy”类的实例。**'
- en: 'We’ll use two Guy variables called `**joe**` and `**bob**` to keep track of
    each of our instances. Here’s what the heap will look like after they’re created:'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用两个Guy变量称为`**joe**`和`**bob**`来跟踪我们的每个实例。在它们创建后，堆看起来是这样的：
- en: '![Images](assets/146fig01.png)![Images](assets/146fig04.png)'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/146fig01.png)![图片](assets/146fig04.png)'
- en: '**We’ll set each Guy object’s Cash and Name fields.**'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们将设置每个Guy对象的Cash和Name字段。**'
- en: The two objects represent different guys, each with his own name and a different
    amount of cash in his pocket. Each guy has a Name field that keeps track of his
    name, and a Cash field that has the number of bucks in his pocket.
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这两个对象代表不同的家伙，每个人都有自己的名字和口袋里的现金数量。每个家伙都有一个Name字段来跟踪他的名字，以及一个Cash字段来记录他口袋里的钱数。
- en: '![Images](assets/146fig02.png)'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/146fig02.png)'
- en: '**We’ll add methods to give and receive cash.**'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们将添加方法来给和接收现金。**'
- en: We’ll make a guy give cash from his pocket (and reduce his Cash field) by calling
    his GiveCash method, which will return the amount of cash he gave. We’ll make
    him receive cash and add it to his pocket (increasing his Cash field) by calling
    his ReceiveCash method, which returns the amount of cash he received.
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将通过调用他的 GiveCash 方法使一个家伙从口袋里给现金（并减少他的 Cash 字段），该方法将返回他给出的现金量。我们将通过调用他的 ReceiveCash
    方法使他接收现金并将其添加到他的口袋中（增加他的 Cash 字段），该方法将返回他接收的现金量。
- en: '![Images](assets/146fig03.png)'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/146fig03.png)'
- en: '[PRE27]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-335
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The Name and Cash fields keep track of the guy’s name and how much cash he has
    in his pocket.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: Name 和 Cash 字段跟踪这个家伙的名字和他口袋里有多少现金。
- en: Note
  id: totrans-337
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Sometimes you want to ask an object to perform a task, like printing a description
    of itself to the console.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，您想要要求一个对象执行一个任务，比如将其描述打印到控制台上。
- en: Note
  id: totrans-339
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The GiveCash and ReceiveCash methods verify that the amount they’re being asked
    to give or receive is valid. That way you can’t ask a guy to receive a negative
    number, which would cause him to lose cash.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: GiveCash 和 ReceiveCash 方法验证它们被要求给出或接收的金额是否有效。这样一来，您就不能要求一个家伙接收一个负数，这会导致他损失现金。
- en: '**Compare the comments in this code to the class diagrams and illustrations
    of the Guy objects. If something doesn’t make sense at first, take the time to
    really understand it.**'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '**将此代码中的注释与Guy对象的类图和插图进行比较。如果一开始有些地方不太明白，请花时间真正理解它。**'
- en: There’s an easier way to initialize objects with C#
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有一种更简单的方法来使用C#初始化对象
- en: Almost every object that you create needs to be initialized in some way. The
    Guy object is no exception—it’s useless until you set its Name and Cash fields.
    It’s so common to have to initialize fields that C# gives you a shortcut for doing,
    it called an **object initializer**. The IDE’s IntelliSense will help you do it.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个您创建的对象都需要以某种方式初始化。Guy对象也不例外——在设置其 Name 和 Cash 字段之前它是无用的。初始化字段是如此常见，以至于C#为您提供了一个快捷方式，称为**对象初始化器**。IDE的智能感知将帮助您完成它。
- en: 'You’re about to do an exercise where you create two Guy objects. You ***could***
    use one `**new**` statement and two more statements to set its fields:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 您即将进行一个练习，创建两个Guy对象。您***可以***使用一个`**new**`语句和两个更多的语句来设置它的字段：
- en: '[PRE28]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***Instead***, type this: `**Guy joe = new Guy() {**`'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '***而是***，输入这个：`**Guy joe = new Guy() {**`'
- en: Object initializers save you time and make your code more compact and easier
    to read…and the IDE helps you write them.
  id: totrans-347
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对象初始化器可以节省您的时间，使您的代码更加紧凑和易于阅读……而且IDE可以帮助您编写它们。
- en: 'As soon as you add the left curly bracket, the IDE will pop up an IntelliSense
    window that shows all of the fields that you can initialize:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您添加左花括号，IDE 将弹出 IntelliSense 窗口，显示您可以初始化的所有字段：
- en: '![Images](assets/148fig01.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/148fig01.png)'
- en: 'Choose the Name field, set it to 50, and add a comma:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 Name 字段，将其设置为 50，并添加逗号：
- en: '[PRE29]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now type a space—another IntelliSense window will pop up with the remaining
    field to set:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在键入一个空格，另一个 IntelliSense 窗口将弹出，显示剩余的字段设置：
- en: '![Images](assets/148fig02.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/148fig02.png)'
- en: 'Set the Name field and add the semicolon. You now have a single statement that
    initializes your object:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 Name 字段并添加分号。现在您有一个初始化对象的单个语句：
- en: '[PRE30]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-356
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This new declaration does the same thing as the three lines of code at the top
    of the page, but it’s shorter and easier to read.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新声明与页面顶部的三行代码执行相同的操作，但更简洁易读。
- en: '![Images](assets/148fig03.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/148fig03.png)'
- en: Note
  id: totrans-359
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**First, it will call each Guy object’s WriteMyInfo method. Then it will read
    an amount from the input and ask who to give the cash to. It will call one Guy
    object’s GiveCash method, then the other Guy object’s ReceiveCash method. It will
    keep going until the user enters a blank line.**'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '**首先，它将调用每个 Guy 对象的 WriteMyInfo 方法。然后，它将从输入读取一个金额，并询问要将现金给谁。它将调用一个 Guy 对象的
    GiveCash 方法，然后调用另一个 Guy 对象的 ReceiveCash 方法。直到用户输入空行为止，它将继续执行。**'
- en: Note
  id: totrans-361
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Don’t move on to the next part of the exercise until you have the first part
    working and you understand what’s going on. It’s worth taking a few minutes to
    use the debugger to step through the program and make sure you really get it.**'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**在开始下一部分练习之前，请确保第一部分运行良好，并理解发生了什么。花几分钟使用调试器逐步执行程序，确保您真正理解。**'
- en: Use the C# Interactive window to run C# code
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 C# 交互窗口运行 C# 代码
- en: 'If you just want to run some C# code, you don’t always need to create a new
    project in Visual Studio. Any C# code entered into the **C# Interactive window**
    is run immediately. You can open it by choosing View >> Other Windows >> C# Interactive.
    Try it now, and **paste in the code** from the exercise solution. You can run
    it by typing this and pressing enter: `**Program.Main(new string[]**`'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想运行一些 C# 代码，不必总是在 Visual Studio 中创建新项目。任何输入到**C# 交互窗口**的 C# 代码都会立即运行。您可以通过选择“视图
    >> 其他窗口 >> C# 交互”来打开它。现在尝试一下，并**粘贴来自练习解决方案的代码**。您可以输入此代码并按 Enter 键运行它：`**Program.Main(new
    string[]**`
- en: '![Images](assets/154fig01.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/154fig01.png)'
- en: You can also run an interactive C# session from the command line. On Windows,
    search the Start menu for `**developer command prompt**`, start it, and then type
    `**csi**`. On macOS or Linux, run `**csharp**` to start the Mono C# Shell. In
    both cases, you can paste the Pizzazz, Abracadabra, and Program classes from the
    previous exercise directly into the prompt, then run `**Program.Main(new string[]
    {})**` to run your console app’s entry point.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以从命令行运行交互式的 C# 会话。在 Windows 上，搜索“开始”菜单以获取**开发人员命令提示符**，启动它，然后输入`**csi**`。在
    macOS 或 Linux 上，运行`**csharp**`以启动 Mono C# Shell。在这两种情况下，您都可以直接将前面练习中的 Pizzazz、Abracadabra
    和 Program 类粘贴到提示符中，然后运行`**Program.Main(new string[] {})**`来运行您的控制台应用程序的入口点。
