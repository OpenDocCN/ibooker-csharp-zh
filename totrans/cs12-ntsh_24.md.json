["```cs\nint MessageBox (HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType);\n```", "```cs\nusing System;\nusing System.Runtime.InteropServices;\n\nMessageBox (IntPtr.Zero,\n            \"Please do not press this again.\", \"Attention\", 0);\n\n[DllImport(\"user32.dll\")]\nstatic extern int MessageBox (IntPtr hWnd, string text, string caption,\n                              int type);\n```", "```cs\nConsole.WriteLine ($\"User ID: {getuid()}\");\n\n[DllImport(\"libc\")]\nstatic extern uint getuid();\n```", "```cs\n[DllImport(\"...\")]\nstatic extern int Foo ( [MarshalAs (UnmanagedType.LPStr)] string s );\n```", "```cs\nStringBuilder s = new StringBuilder (256);\nGetWindowsDirectory (s, 256);\nConsole.WriteLine (s);\n\n[DllImport(\"kernel32.dll\")]\nstatic extern int GetWindowsDirectory (StringBuilder sb, int maxChars);\n```", "```cs\nvar sb = new StringBuilder (256);\nConsole.WriteLine (getcwd (sb, sb.Capacity));\n\n[DllImport(\"libc\")]\nstatic extern string getcwd (StringBuilder buf, int size);\n```", "```cs\n[DllImport (\"kernel32.dll\", CharSet = CharSet.Unicode)]\nstatic extern int GetWindowsDirectory (char[] buffer, int maxChars);\n```", "```cs\nstring GetWindowsDirectory()\n{\n  var array = ArrayPool<char>.Shared.Rent (256);\n  try\n  {\n    int length = GetWindowsDirectory (array, 256);\n    return new string (array, 0, length).ToString();\n  }\n  finally { ArrayPool<char>.Shared.Return (array); }\n}\n```", "```cs\nvoid GetSystemTime (LPSYSTEMTIME lpSystemTime);\n```", "```cs\ntypedef struct _SYSTEMTIME {\n  WORD wYear;\n  WORD wMonth;\n  WORD wDayOfWeek;\n  WORD wDay;\n  WORD wHour;\n  WORD wMinute;\n  WORD wSecond;\n  WORD wMilliseconds;\n} SYSTEMTIME, *PSYSTEMTIME;\n```", "```cs\nusing System;\nusing System.Runtime.InteropServices;\n\n[StructLayout(LayoutKind.Sequential)]\nclass SystemTime\n{\n   public ushort Year;\n   public ushort Month;\n   public ushort DayOfWeek;\n   public ushort Day;\n   public ushort Hour;\n   public ushort Minute;\n   public ushort Second;\n   public ushort Milliseconds;\n}\n```", "```cs\nSystemTime t = new SystemTime();\nGetSystemTime (t);\nConsole.WriteLine (t.Year);\n\n[DllImport(\"kernel32.dll\")]\nstatic extern void GetSystemTime (SystemTime t);\n```", "```cs\nConsole.WriteLine (GetSystemTime());\n\nstatic DateTime GetSystemTime()\n{\n  DateTime startOfUnixTime = \n    new DateTime(1970, 1, 1, 0, 0, 0, 0, System.DateTimeKind.Utc);\n\n  Timespec tp = new Timespec();\n  int success = clock_gettime (0, ref tp);\n  if (success != 0) throw new Exception (\"Error checking the time.\");\n  return startOfUnixTime.AddSeconds (tp.tv_sec).ToLocalTime();  \n}\n\n[DllImport(\"libc\")]\nstatic extern int clock_gettime (int clk_id, ref Timespec tp);\n\n[StructLayout(LayoutKind.Sequential)]\nstruct Timespec\n{\n  public long tv_sec;   /* seconds */\n  public long tv_nsec;  /* nanoseconds */\n}\n```", "```cs\n[DllImport(\"kernel32.dll\")]\nstatic extern void GetSystemTime (out SystemTime t);\n```", "```cs\nstatic extern void Foo ( [In] int[] array);\n```", "```cs\n[DllImport (\"MyLib.dll\", CallingConvention=CallingConvention.Cdecl)]\nstatic extern void SomeFunc (...)\n```", "```cs\nBOOL EnumWindows (WNDENUMPROC lpEnumFunc, LPARAM lParam);\n```", "```cs\nBOOL CALLBACK EnumWindowsProc (HWND hwnd, LPARAM lParam);\n```", "```cs\ndelegate*<IntPtr, IntPtr, bool>\n```", "```cs\nusing System;\nusing System.Runtime.InteropServices;\n\nunsafe\n{\n  EnumWindows (&PrintWindow, IntPtr.Zero);\n\n  [DllImport (\"user32.dll\")]\n  static extern int EnumWindows (\n    delegate*<IntPtr, IntPtr, bool> hWnd, IntPtr lParam);\n\n  static bool PrintWindow (IntPtr hWnd, IntPtr lParam)\n  {\n    Console.WriteLine (hWnd.ToInt64());\n    return true;\n  }\n}\n```", "```cs\nusing System;\nusing System.Runtime.CompilerServices;\nusing System.Runtime.InteropServices;\n\nunsafe\n{\n  EnumWindows (&PrintWindow, IntPtr.Zero);\n\n  [DllImport (\"user32.dll\")]\n  static extern int EnumWindows (\n    delegate* unmanaged <IntPtr, IntPtr, byte> hWnd, IntPtr lParam);\n\n  [UnmanagedCallersOnly]\n  static byte PrintWindow (IntPtr hWnd, IntPtr lParam)\n  {\n    Console.WriteLine (hWnd.ToInt64());\n    return 1;\n  }\n}\n```", "```cs\n[StructLayout (LayoutKind.Sequential, CharSet=CharSet.Unicode)]\n```", "```cs\n[UnmanagedCallersOnly (CallConvs = new[] { typeof (CallConvStdcall) })]\nstatic byte PrintWindow (IntPtr hWnd, IntPtr lParam) ...\n```", "```cs\ndelegate* unmanaged[Stdcall] <IntPtr, IntPtr, byte> hWnd, IntPtr lParam);\n```", "```cs\nclass CallbackFun\n{\n delegate bool EnumWindowsCallback (IntPtr hWnd, IntPtr lParam);\n\n  [DllImport(\"user32.dll\")]\n  static extern int EnumWindows (EnumWindowsCallback hWnd, IntPtr lParam);\n\n  static bool PrintWindow (IntPtr hWnd, IntPtr lParam)\n  {\n    Console.WriteLine (hWnd.ToInt64());\n    return true;\n  }\n  static readonly EnumWindowsCallback printWindowFunc = PrintWindow;\n\n  static void Main() => EnumWindows (printWindowFunc, IntPtr.Zero);\n}\n```", "```cs\n[UnmanagedFunctionPointer (CallingConvention.Cdecl)]\ndelegate void MyCallback (int foo, short bar);\n```", "```cs\n[DllImport (\"winmm.dll\")]\npublic static extern uint midiOutShortMsg (IntPtr handle, uint message);\n```", "```cs\n[StructLayout (LayoutKind.Explicit)]\npublic struct NoteMessage\n{\n  [FieldOffset(0)] public uint PackedMsg;    // 4 bytes long\n\n  [FieldOffset(0)] public byte Channel;      // FieldOffset also at 0\n  [FieldOffset(1)] public byte Note;\n  [FieldOffset(2)] public byte Velocity;\n}\n```", "```cs\nNoteMessage n = new NoteMessage();\nConsole.WriteLine (n.PackedMsg);    // 0\n\nn.Channel = 10;\nn.Note = 100;\nn.Velocity = 50;\nConsole.WriteLine (n.PackedMsg);    // 3302410\n\nn.PackedMsg = 3328010;\nConsole.WriteLine (n.Note);         // 200\n```", "```cs\nusing System;\nusing System.Runtime.InteropServices;\nusing System.ComponentModel;\n\npublic sealed class SharedMem : IDisposable\n{\n  // Here we're using enums because they're safer than constants\n\n  enum FileProtection : uint      // constants from winnt.h\n  {\n    ReadOnly = 2,\n    ReadWrite = 4\n  }\n\n  enum FileRights : uint          // constants from WinBASE.h\n  {\n    Read = 4,\n    Write = 2,\n    ReadWrite = Read + Write\n  }\n\n  static readonly IntPtr NoFileHandle = new IntPtr (-1);\n\n  [DllImport (\"kernel32.dll\", SetLastError = true)]\n  static extern IntPtr CreateFileMapping (IntPtr hFile,\n                                          int lpAttributes,\n                                          FileProtection flProtect,\n                                          uint dwMaximumSizeHigh,\n                                          uint dwMaximumSizeLow,\n                                          string lpName);\n\n  [DllImport (\"kernel32.dll\", SetLastError=true)]\n  static extern IntPtr OpenFileMapping (FileRights dwDesiredAccess,\n                                        bool bInheritHandle,\n                                        string lpName);\n\n  [DllImport (\"kernel32.dll\", SetLastError = true)]\n  static extern IntPtr MapViewOfFile (IntPtr hFileMappingObject,\n                                      FileRights dwDesiredAccess,\n                                      uint dwFileOffsetHigh,\n                                      uint dwFileOffsetLow,\n                                      uint dwNumberOfBytesToMap);\n\n  [DllImport (\"Kernel32.dll\", SetLastError = true)]\n  static extern bool UnmapViewOfFile (IntPtr map);\n\n  [DllImport (\"kernel32.dll\", SetLastError = true)]\n  static extern int CloseHandle (IntPtr hObject);\n\n  IntPtr fileHandle, fileMap;\n\n  public IntPtr Root => fileMap;\n\n  public SharedMem (string name, bool existing, uint sizeInBytes)\n  {\n    if (existing)\n      fileHandle = OpenFileMapping (FileRights.ReadWrite, false, name);\n    else\n      fileHandle = CreateFileMapping (NoFileHandle, 0,\n                                      FileProtection.ReadWrite,\n                                      0, sizeInBytes, name);\n    if (fileHandle == IntPtr.Zero)\n      throw new Win32Exception();\n\n    // Obtain a read/write map for the entire file\n    fileMap = MapViewOfFile (fileHandle, FileRights.ReadWrite, 0, 0, 0);\n\n    if (fileMap == IntPtr.Zero)\n      throw new Win32Exception();\n  }\n\n  public void Dispose()\n  {\n    if (fileMap != IntPtr.Zero) UnmapViewOfFile (fileMap);\n    if (fileHandle != IntPtr.Zero) CloseHandle (fileHandle);\n    fileMap = fileHandle = IntPtr.Zero;\n  }\n}\n```", "```cs\nusing (SharedMem sm = new SharedMem (\"MyShare\", false, 1000))\n{\n  IntPtr root = sm.Root;\n  // I have shared memory!\n\n  Console.ReadLine();         // Here's where we start a second app...\n}\n```", "```cs\nusing (SharedMem sm = new SharedMem (\"MyShare\", true, 1000))\n{\n  IntPtr root = sm.Root;\n  // I have the same shared memory!\n  // ...\n}\n```", "```cs\n[StructLayout (LayoutKind.Sequential)]\nunsafe struct MySharedData\n{\n  public int Value;\n  public char Letter;\n  public fixed float Numbers [50];\n}\n```", "```cs\nstatic unsafe void Main() => Console.WriteLine (sizeof (MySharedData));\n```", "```cs\nMySharedData d;\nMySharedData* data = &d;       // Get the address of d\n\ndata->Value = 123;\ndata->Letter = 'X';\ndata->Numbers[10] = 1.45f;\n\nor:\n\n// Allocate the array on the stack:\nMySharedData* data = stackalloc MySharedData[1];\n\ndata->Value = 123;\ndata->Letter = 'X';\ndata->Numbers[10] = 1.45f;\n```", "```cs\nMySharedData* data = (MySharedData*)\n  Marshal.AllocHGlobal (sizeof (MySharedData)).ToPointer();\n\ndata->Value = 123;\ndata->Letter = 'X';\ndata->Numbers[10] = 1.45f;\n```", "```cs\nMarshal.FreeHGlobal (new IntPtr (data));\n```", "```cs\nstatic unsafe void Main()\n{\n  using (SharedMem sm = new SharedMem (\"MyShare\", false, \n                          (uint) sizeof (MySharedData)))\n  {\n    void* root = sm.Root.ToPointer();\n    MySharedData* data = (MySharedData*) root;\n\n    data->Value = 123;\n    data->Letter = 'X';\n    data->Numbers[10] = 1.45f;\n    Console.WriteLine (\"Written to shared memory\");\n\n    Console.ReadLine();\n\n    Console.WriteLine (\"Value is \" + data->Value);\n    Console.WriteLine (\"Letter is \" + data->Letter);\n    Console.WriteLine (\"11th Number is \" + data->Numbers[10]);\n    Console.ReadLine();\n  }\n}\n```", "```cs\nusing (MemoryMappedFile mmFile =\n       MemoryMappedFile.CreateNew (\"MyShare\", 1000))\nusing (MemoryMappedViewAccessor accessor =\n       mmFile.CreateViewAccessor())\n{\n  byte* pointer = null;\n  accessor.SafeMemoryMappedViewHandle.AcquirePointer\n   (ref pointer);\n  void* root = pointer;\n  ...\n}\n```", "```cs\nstatic unsafe void Main()\n{\n  using (SharedMem sm = new SharedMem (\"MyShare\", true, \n                          (uint) sizeof (MySharedData)))  \n  {\n    void* root = sm.Root.ToPointer();\n    MySharedData* data = (MySharedData*) root;\n\n    Console.WriteLine (\"Value is \" + data->Value);\n    Console.WriteLine (\"Letter is \" + data->Letter);\n    Console.WriteLine (\"11th Number is \" + data->Numbers[10]);\n\n    // Our turn to update values in shared memory!\n    data->Value++;\n    data->Letter = '!';\n    data->Numbers[10] = 987.5f;\n    Console.WriteLine (\"Updated shared memory\");\n    Console.ReadLine();\n  }\n}\n```", "```cs\n// First program:\n\nWritten to shared memory\nValue is 124\nLetter is !\n11th Number is 987.5\n\n// Second program:\n\nValue is 123\nLetter is X\n11th Number is 1.45\nUpdated shared memory\n```", "```cs\n[StructLayout (LayoutKind.Sequential)]\nunsafe struct MySharedData\n{\n  ...\n  // Allocate space for 200 chars (i.e., 400 bytes).\n  const int MessageSize = 200;\n  fixed char message [MessageSize];\n\n  // One would most likely put this code into a helper class:\n  public string Message\n  {\n    get { fixed (char* cp = message) return new string (cp); }\n    set\n    {\n      fixed (char* cp = message)\n      {\n        int i = 0;\n        for (; i < value.Length && i < MessageSize - 1; i++)\n          cp [i] = value [i];\n\n        // Add the null terminator\n        cp [i] = '\\0';\n      }\n    }\n  }\n}\n```", "```cs\nobject obj = new MySharedData();\n```", "```cs\npublic class Foo\n{\n  public string Test() => \"Hello, world\";\n}\n```", "```cs\n  public string Test (string s) => $\"Hello, world {s}\";\n```", "```cs\npublic interface IFoo { string Test(); }\n```", "```cs\npublic interface IFoo2 { string Test (string s); }\n```", "```cs\nusing System;\nusing Excel = Microsoft.Office.Interop.Excel;\n\nvar excel = new Excel.Application();\nexcel.Visible = true;\nexcel.WindowState = Excel.XlWindowState.xlMaximized;\nExcel.Workbook workBook = excel.Workbooks.Add();\n((Excel.Range)excel.Cells[1, 1]).Font.FontStyle = \"Bold\";\n((Excel.Range)excel.Cells[1, 1]).Value2 = \"Hello World\";\nworkBook.SaveAs (@\"d:\\temp.xlsx\");\n```", "```cs\n<ItemGroup>\n  <COMReference Include=\"Microsoft.Office.Excel.dll\">\n    ...\n    <EmbedInteropTypes>true</EmbedInteropTypes>\n  </COMReference>\n</ItemGroup>\n```", "```cs\nvar missing = System.Reflection.Missing.Value;\n\nworkBook.SaveAs (@\"d:\\temp.xlsx\", missing, missing, missing, missing,\n  missing, Excel.XlSaveAsAccessMode.xlNoChange, missing, missing,\n  missing, missing, missing);\n```", "```cs\nworkBook.SaveAs (@\"d:\\temp.xlsx\");\n```", "```cs\nworkBook.SaveAs (@\"d:\\test.xlsx\", Password:\"foo\");\n```", "```cs\nobject filename = \"foo.doc\";\nobject notUsed1 = Missing.Value;\nobject notUsed2 = Missing.Value;\nobject notUsed3 = Missing.Value;\n...\nOpen (ref filename, ref notUsed1, ref notUsed2, ref notUsed3, ...);\n```", "```cs\nword.Open (\"foo.doc\");\n```", "```cs\nmyComObject.Foo [123] = \"Hello\";\n```", "```cs\nType excelAppType = Type.GetTypeFromProgID (\"Excel.Application\", true);\ndynamic excel = Activator.CreateInstance (excelAppType);\nexcel.Visible = true;\ndynamic wb = excel.Workbooks.Add();\nexcel.Cells [1, 1].Value2 = \"foo\";\n```", "```cs\nexcel.Cells [1, 1].Font.FontStyle = \"Bold\";\n```", "```cs\nvar range = (Excel.Range) excel.Cells [1, 1];\nrange.Font.FontStyle = \"Bold\";\n```", "```cs\nExcel.Range range = excel.Cells [1, 1];\nrange.Font.FontStyle = \"Bold\";\n```", "```cs\nnamespace MyCom\n{\n  [ComVisible(true)]\n  [Guid (\"226E5561-C68E-4B2B-BD28-25103ABCA3B1\")]  // Change this GUID\n  [InterfaceType (ComInterfaceType.InterfaceIsIUnknown)]\n  public interface IServer\n  {\n    int Fibonacci();\n  }\n}\n```", "```cs\nnamespace MyCom\n{\n  [ComVisible(true)]\n  [Guid (\"09E01FCD-9970-4DB3-B537-0EC555967DD9\")]  // Change this GUID\n  public class Server\n  {\n    public ulong Fibonacci (ulong whichTerm)\n    {\n      if (whichTerm < 1) throw new ArgumentException (\"...\");\n      ulong a = 0;\n      ulong b = 1;\n      for (ulong i = 0; i < whichTerm; i++)\n      {\n        ulong tmp = a;\n        a = b;\n        b = tmp + b;\n      }\n      return a;\n    }\n  }\n}\n```", "```cs\n<PropertyGroup>\n <EnableComHosting>true</EnableComHosting>\n</PropertyGroup>\n```", "```cs\nREM Save file as ComClient.vbs\nDim obj\nSet obj = CreateObject(\"MyCom.Server\")\n\nresult = obj.Fibonacci(12)\nWscript.Echo result\n```", "```cs\n<PropertyGroup>\n  <TargetFramework>netcoreapp3.0</TargetFramework>\n  <EnableComHosting>true</EnableComHosting>\n <EnableRegFreeCom>true</EnableRegFreeCom>\n</PropertyGroup>\n```"]