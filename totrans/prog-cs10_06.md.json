["```cs\npublic class Derived : SomeClass\n{\n}\n\npublic class AlsoDerived : SomeClass, IDisposable\n{\n    public void Dispose() { }\n}\n```", "```cs\npublic class Base\n{\n}\n\npublic class Derived : Base\n{\n}\n\npublic class MoreDerived : Derived\n{\n}\n```", "```cs\npublic static void UseAsDerived(Base baseArg)\n{\n    var d = (Derived) baseArg;\n\n    // ...go on to do something with d\n}\n```", "```cs\npublic static void MightUseAsDerived(Base b)\n{\n    var d = b as Derived;\n\n    if (d != null)\n    {\n        // ...go on to do something with d\n    }\n}\n```", "```cs\npublic static void MightUseAsDerived(Base b)\n{\n    if (b is Derived d)\n    {\n        // ...go on to do something with d\n    }\n}\n```", "```cs\ninterface IBase1\n{\n    void Base1Method();\n}\n\ninterface IBase2\n{\n    void Base2Method();\n}\n\ninterface IBoth : IBase1, IBase2\n{\n    void Method3();\n}\n```", "```cs\npublic class Impl : IBoth\n{\n    public void Base1Method()\n    {\n    }\n\n    public void Base2Method()\n    {\n    }\n\n    public void Method3()\n    {\n    }\n}\n```", "```cs\npublic class GenericBase1<T>\n{\n    public T? Item { get; set; }\n}\n\npublic class GenericBase2<TKey, TValue>\n    where TValue : class\n{\n    public TKey? Key { get; set; }\n    public TValue? Value { get; set; }\n}\n\npublic class NonGenericDerived : GenericBase1<string>\n{\n}\n\npublic class GenericDerived<T> : GenericBase1<T>\n{\n}\n\npublic class MixedDerived<T> : GenericBase2<string, T>\n    where T : class\n{\n}\n```", "```cs\npublic class SelfAsTypeArgument : IComparable<SelfAsTypeArgument>\n{\n    // ...implementation removed for clarity\n}\n\npublic class Curious<T>\n    where T : Curious<T>\n{\n}\n```", "```cs\npublic static void UseBase(Base b)\n{\n}\n```", "```cs\npublic static void AllYourBase(IEnumerable<Base> bases)\n{\n}\n```", "```cs\nIEnumerable<Derived> derivedItems = new[] { new Derived(), new Derived() };\nAllYourBase(derivedItems);\n```", "```cs\npublic static void AddBase(ICollection<Base> bases)\n{\n    bases.Add(new Base());\n}\n```", "```cs\nICollection<Derived> derivedList = new List<Derived>();\nAddBase(derivedList);  // Will not compile\n```", "```cs\npublic interface IEnumerable<out T> : IEnumerable\n```", "```cs\npublic class Shape\n{\n    public Rect BoundingBox { get; set; }\n}\n\npublic class RoundedRectangle : Shape\n{\n    public double CornerRadius { get; set; }\n}\n```", "```cs\npublic class BoxAreaComparer : IComparer<Shape>\n{\n    public int Compare(Shape? x, Shape? y)\n    {\n        if (x is null)\n        {\n            return y is null ? 0 : -1;\n        }\n        if (y is null)\n        {\n            return 1;\n        }\n\n        double xArea = x.BoundingBox.Width * x.BoundingBox.Height;\n        double yArea = y.BoundingBox.Width * y.BoundingBox.Height;\n\n        return Math.Sign(xArea - yArea);\n    }\n}\n\npublic class CornerSharpnessComparer : IComparer<RoundedRectangle>\n{\n    public int Compare(RoundedRectangle? x, RoundedRectangle? y)\n    {\n        if (x is null)\n        {\n            return y is null ? 0 : -1;\n        }\n        if (y is null)\n        {\n            return 1;\n        }\n\n        // Smaller corners are sharper, so smaller radius is \"greater\" for\n        // the purpose of this comparison, hence the backward subtraction.\n        return Math.Sign(y.CornerRadius - x.CornerRadius);\n    }\n}\n```", "```cs\npublic interface IComparer<in T>\n```", "```cs\npublic static void UseBaseArray(Base[] bases)\n{\n    bases[0] = new Base();\n}\n```", "```cs\nDerived[] derivedBases = { new Derived(), new Derived() };\nUseBaseArray(derivedBases);\n```", "```cs\npublic class BaseWithVirtual\n{\n    `public` `virtual` `void` `ShowMessage``(``)`\n    {\n        Console.WriteLine(\"Hello from BaseWithVirtual\");\n    }\n}\n```", "```cs\npublic static void CallVirtualMethod(BaseWithVirtual o)\n{\n    o.ShowMessage();\n}\n```", "```cs\npublic class DeriveWithoutOverride : BaseWithVirtual\n{\n}\n\npublic class DeriveAndOverride : BaseWithVirtual\n{\n    public override void ShowMessage()\n    {\n        Console.WriteLine(\"This is an override\");\n    }\n}\n```", "```cs\nCallVirtualMethod(new BaseWithVirtual());\nCallVirtualMethod(new DeriveWithoutOverride());\nCallVirtualMethod(new DeriveAndOverride());\n```", "```cs\nHello from BaseWithVirtual\nHello from BaseWithVirtual\nThis is an override\n```", "```cs\npublic class Product { }\npublic class Book : Product { }\n\npublic class ProductSourceBase\n{\n    public virtual Product Get() { return new Product(); }\n}\n\npublic class BookSource : ProductSourceBase\n{\n    public override Book Get() { return new Book(); }\n}\n```", "```cs\npublic abstract class AbstractBase\n{\n    public abstract void ShowMessage();\n}\n```", "```cs\npublic abstract class MustBeComparable : IComparable<string>\n{\n    public abstract int CompareTo(string? other);\n}\n```", "```cs\npublic class LibraryBase\n{\n}\n```", "```cs\npublic class CustomerDerived : LibraryBase\n{\n    public void Start()\n    {\n        Console.WriteLine(\"Derived type's Start method\");\n    }\n}\n```", "```cs\npublic class LibraryBase\n{\n    public virtual void Start() { }\n}\n```", "```cs\nwarning CS0114: 'CustomerDerived.Start()' hides inherited member\n'LibraryBase.Start()'. To make the current member override that implementation,\nadd the override keyword. Otherwise add the new keyword.\n```", "```cs\nvar d = new CustomerDerived();\nLibraryBase b = d;\n\nd.Start();\nb.Start();\n```", "```cs\npublic class CustomerDerived : LibraryBase\n{\n    `public` `new` `void` `Start``(``)`\n    {\n        Console.WriteLine(\"Derived type's Start method\");\n    }\n}\n```", "```cs\npublic interface ISet<T> : ICollection<T>\n{\n    new bool Add(T item);\n    // ...other members omitted for clarity\n}\n```", "```cs\npublic class FixedToString\n{\n    public sealed override string ToString() => \"Arf arf!\";\n}\n```", "```cs\npublic sealed class EndOfTheLine\n{\n}\n```", "```cs\npublic class CustomerDerived : LibraryBase\n{\n    public override void Start()\n    {\n        Console.WriteLine(\"Derived type's Start method\");\n        `base``.``Start``(``)``;`\n    }\n}\n```", "```cs\npublic class BaseWithZeroArgCtor\n{\n    public BaseWithZeroArgCtor()\n    {\n        Console.WriteLine(\"Base constructor\");\n    }\n}\n\npublic class DerivedNoDefaultCtor : BaseWithZeroArgCtor\n{\n    public DerivedNoDefaultCtor(int i)\n    {\n        Console.WriteLine(\"Derived constructor\");\n    }\n}\n```", "```cs\nBase constructor\nDerived constructor\n```", "```cs\npublic class BaseNoDefaultCtor\n{\n    public BaseNoDefaultCtor(int i)\n    {\n        Console.WriteLine(\"Base constructor: \" + i);\n    }\n}\n\npublic class DerivedCallingBaseCtor : BaseNoDefaultCtor\n{\n    public DerivedCallingBaseCtor()\n        `:` `base``(``123``)`\n    {\n        Console.WriteLine(\"Derived constructor (default)\");\n    }\n\n    public DerivedCallingBaseCtor(int i)\n        `:` `base``(``i``)`\n    {\n        Console.WriteLine(\"Derived constructor: \" + i);\n    }\n}\n```", "```cs\npublic class BaseInit\n{\n    protected static int Init(string message)\n    {\n        Console.WriteLine(message);\n        return 1;\n    }\n\n    private int b1 = Init(\"Base field b1\");\n\n    public BaseInit()\n    {\n        Init(\"Base constructor\");\n    }\n\n    private int b2 = Init(\"Base field b2\");\n}\n\npublic class DerivedInit : BaseInit\n{\n    private int d1 = Init(\"Derived field d1\");\n\n    public DerivedInit()\n    {\n        Init(\"Derived constructor\");\n    }\n\n    private int d2 = Init(\"Derived field d2\");\n}\n```", "```cs\nDerived field d1\nDerived field d2\nBase field b1\nBase field b2\nBase constructor\nDerived constructor\n```", "```cs\npublic abstract record OptionallyLabeled\n{\n    public string? Label { get; init; }\n}\n\npublic record OptionallyLabeledItem : OptionallyLabeled;\n\npublic record Product(string Name) : OptionallyLabeled;\n```", "```cs\nvar unlabeled = new OptionallyLabeledItem();\nvar labeled = new OptionallyLabeledItem\n{\n    Label = \"New, improved!\"\n};\n\nvar unlabeledProduct = new Product(\"Book\");\nvar labeledProduct = new Product(\"Shirt\")\n{\n    Label = \"Half price\"\n};\n```", "```cs\npublic abstract record Colorful(string Color);\n\npublic record LightBulb(string Color, int Lumens) : Colorful(Color);\n```", "```cs\npublic record FordModelT() : Colorful(\"Black\");\n```", "```cs\nvar commonModelT = new FordModelT();\nvar lateModelT = new FordModelT { Color = \"Green\" };\n```", "```cs\npublic record RedDelicious : Colorful\n{\n    public RedDelicious() : base(\"Red\")\n    { }\n}\n```", "```cs\npublic record LabeledDemographic : OptionallyLabeled\n{\n    public LabeledDemographic(string label)\n    {\n        Label = label;\n    }\n\n    public void Deconstruct(out string? label) => label = Label;\n}\n```", "```cs\nOptionallyLabeled Discount(OptionallyLabeled item)\n{\n    return item with\n    {\n        Label = \"60% off!\"\n    };\n}\n```", "```cs\nConsole.WriteLine(Discount(new OptionallyLabeledItem()));\nConsole.WriteLine(Discount(new Product(\"Sweater\")));\n```", "```cs\nOptionallyLabeledItem { Label = 60% off! }\nProduct { Label = 60% off!, Name = Sweater }\n```"]