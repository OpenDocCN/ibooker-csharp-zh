["```cs\npublic static string FetchUrl(string relativeUri)\n{\n    var baseUri = new Uri(\"https://endjin.com/\");\n    var fullUri = new Uri(baseUri, relativeUri);\n    var w = new HttpClient();\n    HttpResponseMessage response = w.Send(\n        new HttpRequestMessage(HttpMethod.Get, fullUri));\n    return new StreamReader(response.Content.ReadAsStream()).ReadToEnd();\n}\n```", "```cs\nstatic void Main()\n{\n    var numbers = new List<string>();\n    long total = 0;\n    for (int i = 1; i < 100_000; ++i)\n    {\n        numbers.Add(i.ToString());\n        total += i;\n    }\n    Console.WriteLine(\"Total: {total}, average: {total / numbers.Count}\");\n}\n```", "```cs\npublic class WeakCache<TKey, TValue>\n    where TKey : notnull\n    where TValue : class\n{\n    private readonly Dictionary<TKey, WeakReference<TValue>> _cache = new ();\n\n    public void Add(TKey key, TValue value)\n    {\n        _cache.Add(key, new WeakReference<TValue>(value));\n    }\n\n    public bool TryGetValue(\n        TKey key, [NotNullWhen(true)] out TValue? cachedItem)\n    {\n        if (_cache.TryGetValue(key, out WeakReference<TValue>? entry))\n        {\n            bool isAlive = entry.TryGetTarget(out cachedItem);\n            if (!isAlive)\n            {\n                _cache.Remove(key);\n            }\n            return isAlive;\n        }\n        else\n        {\n            cachedItem = null;\n            return false;\n        }\n    }\n}\n```", "```cs\ninternal class Program\n{\n    private static WeakCache<string, byte[]> cache = new ();\n    private static byte[]? data = new byte[100];\n\n    private static void Main(string[] args)\n    {\n        AddData();\n        CheckStillAvailable();\n\n        GC.Collect();\n        CheckStillAvailable();\n\n        SetOnlyRootToNull();\n        GC.Collect();\n        CheckNoLongerAvailable();\n    }\n\n [MethodImpl(MethodImplOptions.NoInlining)]\n    private static void AddData()\n    {\n        cache.Add(\"d\", data!);\n    }\n\n [MethodImpl(MethodImplOptions.NoInlining)]\n    private static void CheckStillAvailable()\n    {\n        Console.WriteLine(\"Retrieval: \" +\n            cache.TryGetValue(\"d\", out byte[]? fromCache));\n        Console.WriteLine(\"Same ref?  \" +\n            object.ReferenceEquals(data, fromCache));\n    }\n\n [MethodImpl(MethodImplOptions.NoInlining)]\n    private static void SetOnlyRootToNull()\n    {\n        data = null;\n    }\n\n [MethodImpl(MethodImplOptions.NoInlining)]\n    private static void CheckNoLongerAvailable()\n    {\n        byte[]? fromCache;\n        Console.WriteLine(\"Retrieval: \" + cache.TryGetValue(\"d\", out fromCache));\n        Console.WriteLine(\"Null?  \" + (fromCache == null));\n    }\n}\n```", "```cs\nRetrieval: True\nSame ref?  True\nRetrieval: True\nSame ref?  True\nRetrieval: False\nNull?  True\n```", "```cs\npublic class GreedyObject\n{\n    public int[] MyData = new int[100_000];\n}\n```", "```cs\n<PropertyGroup>\n  <ServerGarbageCollection>true</ServerGarbageCollection>\n</PropertyGroup>\n```", "```cs\npublic class LetMeKnowMineEnd\n{\n    ~LetMeKnowMineEnd()\n    {\n        Console.WriteLine(\"Goodbye, cruel world\");\n    }\n}\n```", "```cs\npublic interface IDisposable\n{\n    void Dispose();\n}\n```", "```cs\nusing (StreamReader reader = File.OpenText(@\"C:\\temp\\File.txt\"))\n{\n    Console.WriteLine(reader.ReadToEnd());\n}\n```", "```cs\n{\n    StreamReader reader = File.OpenText(@\"C:\\temp\\File.txt\");\n    try\n    {\n        Console.WriteLine(reader.ReadToEnd());\n    }\n    finally\n    {\n        if (reader != null)\n        {\n            ((IDisposable) reader).Dispose();\n        }\n    }\n}\n```", "```cs\nusing StreamReader reader = File.OpenText(@\"C:\\temp\\File.txt\");\nConsole.WriteLine(reader.ReadToEnd());\n```", "```cs\nusing (Stream source = File.OpenRead(@\"C:\\temp\\File.txt\"))\nusing (Stream copy = File.Create(@\"C:\\temp\\Copy.txt\"))\n{\n    source.CopyTo(copy);\n}\n```", "```cs\nforeach (string file in Directory.EnumerateFiles(@\"C:\\temp\"))\n{\n    Console.WriteLine(file);\n}\n```", "```cs\n{\n    IEnumerator<string> e =\n        Directory.EnumerateFiles(@\"C:\\temp\").GetEnumerator();\n    try\n    {\n        while (e.MoveNext())\n        {\n            string file = e.Current;\n            Console.WriteLine(file);\n        }\n    }\n    finally\n    {\n        if (e != null)\n        {\n            ((IDisposable) e).Dispose();\n        }\n    }\n}\n```", "```cs\npublic sealed class Logger : IDisposable\n{\n    private StreamWriter? _file;\n\n    public Logger(string filePath)\n    {\n        _file = File.CreateText(filePath);\n    }\n\n    public void Dispose()\n    {\n        if (_file != null)\n        {\n            _file.Dispose();\n            _file = null;\n        }\n    }\n    // A real class would go on to do something with the StreamWriter, of course\n}\n```", "```cs\npublic class MyFunkyStream : Stream\n{\n    // For illustration purposes only. Usually better to avoid this whole\n    // pattern and to use some type derived from SafeHandle instead.\n    private IntPtr _myCustomLibraryHandle;\n    private Logger? _log;\n\n    protected override void Dispose(bool disposing)\n    {\n        base.Dispose(disposing);\n\n        if (_myCustomLibraryHandle != IntPtr.Zero)\n        {\n            MyCustomLibraryInteropWrapper.Close(_myCustomLibraryHandle);\n            _myCustomLibraryHandle = IntPtr.Zero;\n        }\n        if (disposing)\n        {\n            if (_log != null)\n            {\n                _log.Dispose();\n                _log = null;\n            }\n        }\n    }\n\n    // ...overloads of Stream's abstract methods would go here\n}\n```", "```cs\nstatic void Show(object o)\n{\n    Console.WriteLine(o.ToString());\n}\n\nint num = 42;\nShow(num);\n```", "```cs\n// Not a real box but similar in effect.\npublic class Box<T>\n    where T : struct\n{\n    public readonly T Value;\n    public Box(T v)\n    {\n        Value = v;\n    }\n\n    public override string? ToString() => Value.ToString();\n    public override bool Equals(object? obj) => Value.Equals(obj);\n    public override int GetHashCode() => Value.GetHashCode();\n}\n```", "```cs\nif (o is int i)\n{\n    Console.WriteLine(i * 2);\n}\n```", "```cs\nstatic void CallDispose(IDisposable o)\n{\n    o.Dispose();\n}\n\nDisposableValue dv = new ();\nConsole.WriteLine(\"Passing value variable:\");\nCallDispose(dv);\nCallDispose(dv);\nCallDispose(dv);\n\nIDisposable id = dv;\nConsole.WriteLine(\"Passing interface variable:\");\nCallDispose(id);\nCallDispose(id);\nCallDispose(id);\n\nConsole.WriteLine(\"Calling Dispose directly on value variable:\");\ndv.Dispose();\ndv.Dispose();\ndv.Dispose();\n\nConsole.WriteLine(\"Passing value variable:\");\nCallDispose(dv);\nCallDispose(dv);\nCallDispose(dv);\n\npublic struct DisposableValue : IDisposable\n{\n    private bool _disposedYet;\n\n    public void Dispose()\n    {\n        if (!_disposedYet)\n        {\n            Console.WriteLine(\"Disposing for first time\");\n            _disposedYet = true;\n        }\n        else\n        {\n            Console.WriteLine(\"Was already disposed\");\n        }\n    }\n}\n```", "```cs\nPassing value variable:\nDisposing for first time\nDisposing for first time\nDisposing for first time\n```", "```cs\nPassing interface variable:\nDisposing for first time\nWas already disposed\nWas already disposed\n```", "```cs\nCalling Dispose directly on value variable:\nDisposing for first time\nWas already disposed\nWas already disposed\n```", "```cs\nPassing value variable:\nWas already disposed\nWas already disposed\nWas already disposed\n```", "```cs\nobject boxed = 42;\nint? nv = boxed as int?;\nint? nv2 = (int?) boxed;\nint v = (int) boxed;\n```"]