- en: Chapter 19\. Dynamic Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 4](ch04.html#advanced_chash) explained how dynamic binding works in
    the C# language. In this chapter, we look briefly at the *Dynamic Language Runtime*
    (DLR) and then explore the following dynamic programming patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic member overload resolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom binding (implementing dynamic objects)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic language interoperability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In [Chapter 24](ch24.html#native_and_com_interoperabilit), we describe how `dynamic`
    can improve COM interoperability.
  prefs: []
  type: TYPE_NORMAL
- en: The types in this chapter reside in the `System.Dynamic` namespace, except for
    `CallSite<>`, which resides in `System.Runtime.CompilerServices`.
  prefs: []
  type: TYPE_NORMAL
- en: The Dynamic Language Runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# relies on the DLR to perform dynamic binding.
  prefs: []
  type: TYPE_NORMAL
- en: Contrary to its name, the DLR is not a dynamic version of the CLR. Rather, it’s
    a library that sits atop the CLR—just like any other library such as *System.Xml.dll*.
    Its primary role is to provide runtime services to *unify* dynamic programming—in
    both statically and dynamically typed languages. Hence, languages such as C#,
    Visual Basic, IronPython, and IronRuby all use the same protocol for calling functions
    dynamically. This allows them to share libraries and call code written in other
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: The DLR also makes it relatively easy to write new dynamic languages in .NET.
    Instead of having to emit Intermediate Language (IL), dynamic language authors
    work at the level of *expression trees* (the same expression trees in `System.Linq.Expressions`
    that we talked about in [Chapter 8](ch08.html#linq_queries)).
  prefs: []
  type: TYPE_NORMAL
- en: The DLR further ensures that all consumers get the benefit of *call-site caching*,
    an optimization whereby the DLR prevents unnecessarily repeating the potentially
    expensive member resolution decisions made during dynamic binding.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Member Overload Resolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Calling a statically known method with dynamically typed arguments defers member
    overload resolution from compile time to runtime. This is useful in simplifying
    certain programming tasks—such as simplifying the *Visitor* design pattern. It’s
    also useful in working around limitations imposed by C#’s static typing.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying the Visitor Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In essence, the *Visitor* pattern allows you to “add” a method to a class hierarchy
    without altering existing classes. Although useful, this pattern in its static
    incarnation is subtle and unintuitive compared to most other design patterns.
    It also requires that visited classes be made “visitor-friendly” by exposing an
    `Accept` method, which can be impossible if the classes are not under your control.
  prefs: []
  type: TYPE_NORMAL
- en: 'With dynamic binding, you can achieve the same goal more easily—and without
    needing to modify existing classes. To illustrate, consider the following class
    hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose that we want to write a method that programmatically exports a `Person`’s
    details to an XML `XElement`. The most obvious solution is to write a virtual
    method called `ToXElement()` in the `Person` class that returns an `XElement`
    populated with a `Person`’s properties. We would then override it in `Customer`
    and `Employee` classes such that the `XElement` was also populated with `CreditLimit`
    and `Salary`. This pattern can be problematic, however, for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: You might not own the `Person`, `Customer`, and `Employee` classes, making it
    impossible to add methods to them. (And extension methods wouldn’t give polymorphic
    behavior.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Person`, `Customer`, and `Employee` classes might already be quite big.
    A frequent antipattern is the “God Object,” in which a class such as `Person`
    attracts so much functionality that it becomes a nightmare to maintain. A good
    antidote is to avoid adding functions to `Person` that don’t need to access `Person`’s
    private state. A `ToXElement` method might be an excellent candidate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With dynamic member overload resolution, we can write the `ToXElement` functionality
    in a separate class, without resorting to ugly switches based on type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `DynamicVisit` method performs a dynamic dispatch—calling the most specific
    version of `Visit` as determined at runtime. Notice the line in boldface, in which
    we call `DynamicVisit` on each person in the `Friends` collection. This ensures
    that if a friend is a `Customer` or `Employee`, the correct overload is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can demonstrate this class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Variations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you plan more than one visitor class, a useful variation is to define an
    abstract base class for visitors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Subclasses then don’t need to define their own `DynamicVisit` method: all they
    do is override the versions of `Visit` whose behavior they want to specialize.
    This also has the advantages of centralizing the methods that encompass the `Person`
    hierarchy and allowing implementers to call base methods more naturally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You then can even subclass `ToXElementPersonVisitor` itself.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymously Calling Members of a Generic Type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The strictness of C#’s static typing is a double-edged sword. On the one hand,
    it enforces a degree of correctness at compile time. On the other hand, it occasionally
    makes certain kinds of code difficult or impossible to express, at which point
    you must resort to reflection. In these situations, dynamic binding is a cleaner
    and faster alternative to reflection.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example is when you need to work with an object of type `G<T>` where `T`
    is unknown. We can illustrate this by defining the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose that we then write a method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This method won’t compile: you can’t invoke members of *unbound* generic types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dynamic binding offers two means by which we can work around this. The first
    is to access the `Value` member dynamically as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This has the (potential) advantage of working with any object that defines
    a `Value` field or property. However, there are a couple of problems. First, catching
    an exception in this manner is somewhat messy and inefficient (and there’s no
    way to ask the DLR in advance, “Will this operation succeed?”). Second, this approach
    wouldn’t work if `Foo` were an interface (say, `IFoo<T>`) and either of the following
    conditions were true:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Value` was implemented explicitly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type that implemented `IFoo<T>` was inaccessible (more on this soon)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A better solution is to write an overloaded helper method called `GetFooValue`
    and to call it using *dynamic member overload resolution*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we overloaded `GetFooValue` to accept an `object` parameter, which
    acts as a fallback for any type. At runtime, the C# dynamic binder will pick the
    best overload when calling `GetFooValue` with a dynamic argument. If the object
    in question is not based on `Foo<T>`, it will choose the object-parameter overload
    instead of throwing an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: An alternative is to write just the first `GetFooValue` overload and then catch
    the `RuntimeBinderException`. The advantage is that it distinguishes the case
    of `foo.Value` being null. The disadvantage is that it incurs the performance
    overhead of throwing and catching an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 18](ch18.html#reflection_and_metadata), we solved the same problem
    with an interface using reflection—with a lot more effort (see [“Anonymously Calling
    Members of a Generic Interface”](ch18.html#ch18-anonymously_calling_members_of_a_gener)).
    The example we used was to design a more powerful version of `ToString()` that
    could understand objects such as `IEnumerable` and `IGrouping<,>`. Here’s the
    same example solved more elegantly using dynamic binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here it is in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we used dynamic *member overload resolution* to solve this problem.
    If we instead did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'it would fail because LINQ’s `GroupBy` operator returns a type implementing
    `IGrouping<,>`, which itself is internal and therefore inaccessible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Even though the `Key` property is declared `public`, its containing class caps
    it at `internal`, making it accessible only via the `IGrouping<,>` interface.
    And as is explained in [Chapter 4](ch04.html#advanced_chash), there’s no way to
    instruct the DLR to bind to that interface when invoking the `Value` member dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Dynamic Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An object can provide its binding semantics by implementing `IDynamicMetaObjectProvider`—or
    more easily by subclassing `DynamicObject`, which provides a default implementation
    of this interface. This is demonstrated briefly in [Chapter 4](ch04.html#advanced_chash)
    via the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: DynamicObject
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding example, we overrode `TryInvokeMember`, which allows the consumer
    to invoke a method on the dynamic object—such as a `Quack` or `Waddle`. `DynamicObject`
    exposes other virtual methods that enable consumers to use other programming constructs
    as well. The following correspond to constructs that have representations in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Programming construct |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `TryInvokeMember` | Method |'
  prefs: []
  type: TYPE_TB
- en: '| `TryGetMember`, `TrySetMember` | Property or field |'
  prefs: []
  type: TYPE_TB
- en: '| `TryGetIndex`, `TrySetIndex` | Indexer |'
  prefs: []
  type: TYPE_TB
- en: '| `TryUnaryOperation` | Unary operator such as `!` |'
  prefs: []
  type: TYPE_TB
- en: '| `TryBinaryOperation` | Binary operator such as `==` |'
  prefs: []
  type: TYPE_TB
- en: '| `TryConvert` | Conversion (cast) to another type |'
  prefs: []
  type: TYPE_TB
- en: '| `TryInvoke` | Invocation on the object itself—e.g., `d("foo")` |'
  prefs: []
  type: TYPE_TB
- en: These methods should return `true` if successful. If they return `false`, the
    DLR will fall back to the language binder, looking for a matching member on the
    `Dynamic​Ob⁠ject` (subclass) itself. If this fails, a `RuntimeBinderException`
    is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can illustrate `TryGetMember` and `TrySetMember` with a class that lets
    us dynamically access an attribute in an `XElement` (`System.Xml.Linq`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following does a similar thing for `System.Data.IDataRecord`, making it
    easier to use data readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following demonstrates `TryBinaryOperation` and `TryInvoke`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`DynamicObject` also exposes some virtual methods for the benefit of dynamic
    languages. In particular, overriding `GetDynamicMemberNames` allows you to return
    a list of all member names that your dynamic object provides.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Another reason to implement `GetDynamicMemberNames` is that Visual Studio’s
    debugger makes use of this method to display a view of a dynamic object.
  prefs: []
  type: TYPE_NORMAL
- en: ExpandoObject
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another simple application of `DynamicObject` would be to write a dynamic class
    that stored and retrieved objects in a dictionary, keyed by string. However, this
    functionality is already provided via the `ExpandoObject` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`ExpandoObject` implements `IDictionary<string,object>`—so we can continue
    our example and do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Interoperating with Dynamic Languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although C# supports dynamic binding via the `dynamic` keyword, it doesn’t
    go as far as allowing you to execute an expression described in a string at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is because the code to translate a string into an expression tree requires
    a lexical and semantic parser. These features are built into the C# compiler and
    are not available as a runtime service. At runtime, C# merely provides a *binder*,
    which instructs the DLR how to interpret an already-built expression tree.
  prefs: []
  type: TYPE_NORMAL
- en: True dynamic languages such as IronPython and IronRuby do allow you to execute
    an arbitrary string, and this is useful in tasks such as scripting, writing dynamic
    configuration systems, and implementing dynamic rules engines. So, although you
    can write most of your application in C#, it can be useful to call out to a dynamic
    language for such tasks. In addition, you might want to use an API that is written
    in a dynamic language where no equivalent functionality is available in a .NET
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The Roslyn scripting NuGet package *Microsoft.CodeAnalysis.CSharp.Scripting*
    provides an API that lets you execute a C# string, although it does so by first
    compiling your code into a program. The compilation overhead makes it slower than
    Python interop, unless you intend to execute the same expression repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we use IronPython to evaluate an expression created
    at runtime from within C#. You could use the following script to write a calculator.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To run this code, add the NuGet packages *Dynamic​LanguageRuntime* (not to be
    confused with the *System.Dynamic.Runtime* package) and *IronPython* to your application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we’re passing a string into Python, the expression will be evaluated
    according to Python’s rules and not C#’s. It also means that we can use Python’s
    language features, such as lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Passing State Between C# and a Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To pass variables from C# to Python, a few more steps are required. The following
    example illustrates those steps and could be the basis of a rules engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also get variables back by calling `GetVariable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we specified `SourceCodeKind.SingleStatement` in the second example
    (rather than `Expression`) to inform the engine that we want to execute a statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Types are automatically marshaled between the .NET and Python worlds. You can
    even access members of .NET objects from the scripting side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
