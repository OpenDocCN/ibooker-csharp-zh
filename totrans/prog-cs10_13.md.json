["```cs\nclass Program\n{\n    static void Main()\n    {\n        `Assembly` `me` `=` `typeof``(``Program``)``.``Assembly``;`\n        Console.WriteLine(me.FullName);\n    }\n}\n```", "```cs\nType? nt = someAssembly.GetType(\"MyLib.ContainingType+Inside\");\n```", "```cs\nobject? o = asm.CreateInstance(\n    \"MyApp.WithConstructor\",\n    false,\n    BindingFlags.Public | BindingFlags.Instance,\n    null,\n    new object[] { \"Constructor argument\" },\n    null,\n    null);\n```", "```cs\nclass Base\n{\n    public void Foo()\n    {\n    }\n}\n\nclass Derived : Base\n{\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        MemberInfo bf = typeof(Base).GetMethod(\"Foo\")!;\n        MemberInfo df = typeof(Derived).GetMethod(\"Foo\")!;\n\n        Console.WriteLine(\"Base    Declaring: {0}, Reflected: {1}\",\n                          bf.DeclaringType, bf.ReflectedType);\n        Console.WriteLine(\"Derived Declaring: {0}, Reflected: {1}\",\n                          df.DeclaringType, df.ReflectedType);\n    }\n}\n```", "```cs\nBase    Declaring: Base, Reflected: Base\nDerived Declaring: Base, Reflected: Derived\n```", "```cs\npublic int Count\n{\n    get;\n    private set;\n}\n```", "```cs\n// Won't compile but arguably should\nint Count\n{\n    public get;\n    private set;\n}\n```", "```cs\nType stringType = typeof(string);\nType disposableType = typeof(IDisposable);\n```", "```cs\nSystem.String, mscorlib, Version=4.0.0.0, Culture=neutral,\n PublicKeyToken=b77a5c561934e089\n```", "```cs\nSystem.String, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral,\n PublicKeyToken=7cec85d7bea7798e\n```", "```cs\nType stringType = typeof(string);\nType objectType = typeof(object);\nConsole.WriteLine(stringType.IsAssignableFrom(objectType));\nConsole.WriteLine(objectType.IsAssignableFrom(stringType));\n```", "```cs\npublic static object? CreateAndInvokeMethod(\n  string typeName, string member, params object[] args)\n{\n    Type t = Type.GetType(typeName)\n        ?? throw new ArgumentException(\n            $\"Type {typeName} not found\", nameof(typeName));\n    object instance = Activator.CreateInstance(t)!;\n    return t.InvokeMember(\n      member,\n      BindingFlags.Instance | BindingFlags.Public | BindingFlags.InvokeMethod,\n      null,\n      instance,\n      args);\n}\n```", "```cs\nType bound = typeof(List<int>);\nType unbound = typeof(List<>);\n```", "```cs\npublic static object? CreateAndInvokeMethod(\n  string typeName, string member, params object[] args)\n{\n    Type t = Type.GetType(typeName)\n        ?? throw new ArgumentException(\n            $\"Type {typeName} not found\", nameof(typeName));\n    object instance = Activator.CreateInstance(t)!;\n    `MethodInfo` `m` `=` `t``.``GetMethod``(``member``)`\n        ?? throw new ArgumentException(\n            $\"Method {member} not found\", nameof(member));\n    `return` `m``.``Invoke``(``instance``,` `args``)``;`\n}\n```", "```cs\nclass NotVeryInteresting\n{\n}\n\nclass MyReflectionContext : CustomReflectionContext\n{\n    protected override IEnumerable<PropertyInfo> AddProperties(Type type)\n    {\n        if (type == typeof(NotVeryInteresting))\n        {\n            var fakeProp = CreateProperty(\n                MapType(typeof(string).GetTypeInfo()),\n                \"FakeProperty\",\n                o => \"FakeValue\",\n                (o, v) => Console.WriteLine($\"Setting value: {v}\"));\n\n            return new[] { fakeProp };\n        }\n        else\n        {\n            return base.AddProperties(type);\n        }\n    }\n}\n```", "```cs\nvar ctx = new MyReflectionContext();\nTypeInfo mappedType = ctx.MapType(typeof(NotVeryInteresting).GetTypeInfo());\n\nforeach (PropertyInfo prop in mappedType.DeclaredProperties)\n{\n    Console.WriteLine($\"{prop.Name} ({prop.PropertyType.Name})\");\n}\n```"]