<html><head></head><body><section class="pagenumrestart" data-pdf-bookmark="Chapter 1. Blazing into Blazor" data-type="chapter" epub:type="chapter"><div class="chapter" id="chapter-one">
<h1><span class="label">Chapter 1. </span>Blazing into Blazor</h1>


<p>Node.js reshaped the world of modern web app development. Its success is attributed in part to the popularity of JavaScript, of course. JavaScript now runs on both the client and the server alike, thanks to Node. This is why Blazor will be so successful—C# is now capable of running in the browser with WebAssembly. To .NET developers, there is a huge potential because there are a great many C# server apps in existence today. There are many opportunities for .NET developers to create amazing user experiences with Blazor.</p>

<p>For the first time, .NET developers can use their existing C# skills to build all sorts of apps on the web. This blurs the lines between backend and frontend developers and expands app development for the web. With modern web app development, you want your apps to be responsive on both desktop and mobile browsers. Modern web apps are much more sophisticated and rich in content than their predecessors and boast real-time web functionality, progressive web app (PWA) <a data-primary="progressive web apps (PWAs)" data-type="indexterm" id="idm46365048249904"/><a data-primary="PWAs (progressive web apps)" data-type="indexterm" id="idm46365048249136"/>capabilities, and beautifully orchestrated user interactions.</p>

<p>In this chapter, you’ll learn about the origins of .NET web app development and the birth of Blazor. You’ll explore the <a data-primary="SPA (single-page application)" data-secondary="frameworks" data-type="indexterm" id="idm46365048633376"/><a data-primary="single-page application" data-see="SPA" data-type="indexterm" id="idm46365048632384"/>variations of single-page application (SPA) frameworks and see how .NET solidified its place in the web ecosystem. I’ll answer many of the questions you may have about <em>why</em> Blazor is a viable option and discuss its hosting models. Finally, you’ll get your first look at the Learning Blazor sample application. This sample application will be used throughout the book, with each chapter demonstrating various features of Blazor and using the app to follow along.</p>






<section data-pdf-bookmark="The Origin of Blazor" data-type="sect1"><div class="sect1" id="idm46365048630800">
<h1>The Origin of Blazor</h1>

<p>In 1996, Active Server Pages (ASP) from Microsoft <a data-primary="ASP (Active Server Pages)" data-type="indexterm" id="idm46365048629072"/><a data-primary=".NET Framework" data-primary-sortas="NET Framework" data-type="indexterm" id="idm46365048628352"/><a data-primary="Active Server Pages (ASP)" data-type="indexterm" id="idm46365048627408"/><a data-primary="WebForms" data-type="indexterm" id="idm46365048415904"/><a data-primary="ASP.NET Web Forms" data-type="indexterm" id="idm46365048415232"/><a data-primary="Blazor" data-secondary="history" data-type="indexterm" id="bzsy"/>offered the first server-side scripting language and engine for dynamic web pages. As .NET Framework evolved, ASP.NET was born, and with it emerged ASP.NET Web Forms (WebForms). WebForms was (and still is) used by many who enjoy what .NET was capable of.</p>

<p>When ASP.NET Model View Controller (MVC) was first <a data-primary="MVC (Model View Controller)" data-type="indexterm" id="idm46365048412832"/><a data-primary="Model View Controller (MVC)" data-type="indexterm" id="idm46365048412112"/><a data-primary="ASP.NET Model View Controller (MVC)" data-type="indexterm" id="idm46365048411424"/>released in 2006, it made WebForms look sluggish in comparison. MVC brought ASP.NET developers closer to less-abstracted web development. By having a closer alignment to web standards, MVC introduced the model-view-controller pattern of ASP.NET, which helped to address the issue of managing ASP.NET post-back state. At the time, this was a sore point in the developer community. Developers didn’t like the fact that WebForms carried the additional state for all the controls on the page along with <code>&lt;form&gt;</code> post data. WebForms fabricated statefulness with View State and other state mechanisms that contradicted the nature of HTTP. MVC focused on testability, emphasizing to developers the importance of sustainability. This was a paradigm shift from 
<span class="keep-together">WebForms.</span></p>

<p>In 2010, the Razor view engine was <a data-primary="Razor" data-secondary="view engine" data-type="indexterm" id="idm46365048409248"/><a data-primary="Razor" data-seealso="specific Razor files" data-type="indexterm" id="idm46365045268416"/>introduced to serve as one of several view engine options to use with ASP.NET MVC. Razor is a markup syntax that melds HTML and C# and is used for templating. As a side-product of MVC, ASP.NET Web API grew in popularity, and developers embraced the power of .NET. Web API started being accepted as the standard for building .NET-based HTTP services. All the while, the Razor view engine was evolving, strengthening, and maturing.</p>

<p>Eventually, with the Razor view engine using MVC as a <a data-primary="performance as a feature" data-type="indexterm" id="idm46365045266736"/>basis, Razor Pages <a data-primary="Razor" data-secondary="Pages" data-type="indexterm" id="idm46365045265888"/>took to the stage. Innovations from ASP.NET Core made a lot of this possible. The team’s eager push for <em>performance as a feature</em> is evident with the <a href="https://oreil.ly/Ff8lV">TechEmpower benchmark results</a>, where ASP.NET Core continues to climb ahead. Kestrel <a data-primary="Kestrel" data-type="indexterm" id="idm46365045263536"/><a data-primary="ASP.NET Core" data-secondary="performance as a feature" data-type="indexterm" id="idm46365045262864"/>is the cross-platform web server that’s included and enabled by default in ASP.NET Core project templates. It’s one of the fastest web servers in existence as of 2022—capable of serving more than 4 million requests per second.</p>

<p>ASP.NET Core offers first-class <a data-primary="ASP.NET Core" data-type="indexterm" id="idm46365048711264"/>citizenship to all of the fundamentals you’d expect in modern development, such as (but not limited to) dependency injection, strongly typed configurations, feature-rich logging, localization, authentication, authorization, and hosting. Razor Pages lean more toward true components and build on Web API infrastructure.</p>

<p>After Razor Pages came Blazor, a name <a data-primary="Blazor" data-secondary="naming" data-type="indexterm" id="idm46365048710048"/>inspired by combining “browser” and “Razor.” Blazor (clever name, isn’t it?) is the first of its kind for .NET, a SPA framework. Blazor takes <a data-primary="WebAssembly" data-type="indexterm" id="idm46365048708944"/>advantage of WebAssembly (Wasm), which is a binary instruction format for a stack-based virtual machine. <a href="https://webassembly.org">WebAssembly</a> is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. WebAssembly allows .NET web apps to truly compete with JavaScript-based SPA frameworks. It’s C# running in the client browser with WebAssembly and the Mono .NET runtime.</p>

<p>According to Steve Sanderson, he created Blazor because <a data-primary="Sanderson, Steve" data-type="indexterm" id="idm46365048706944"/>he was inspired to get .NET running on WebAssembly. He had a breakthrough <a data-primary="DNA (Dot Net Anywhere)" data-type="indexterm" id="idm46365048706112"/><a data-primary="Dot Net Anywhere (DNA)" data-type="indexterm" id="idm46365048705440"/>when he discovered Dot Net 
<span class="keep-together">Anywhere (DNA),</span> an alternative .NET runtime that could easily be compiled to Web­Assembly with <a href="https://emscripten.org">Emscripten</a>, a complete compiler toolchain to WebAssembly, with a special focus on speed, size, and the web platform.</p>

<p>This was the path that led to the creation of one of the first working prototypes of .NET running in the browser without a plug-in. After Steve Sanderson delivered an amazing demonstration of this functioning .NET app in the browser, other Microsoft stakeholders started supporting the idea. This took .NET a step further as an ecosystem and a step closer to what we know as Blazor today.</p>

<p>Now that we’ve discussed how Blazor came to be, let’s talk about how it’s able to bring apps to life and the different ways <a data-primary="Blazor" data-secondary="history" data-startref="bzsy" data-type="indexterm" id="idm46365048643328"/>they can be hosted.</p>
</div></section>













<section data-pdf-bookmark="Blazor Hosting" data-type="sect1"><div class="sect1" id="idm46365048641696">
<h1>Blazor Hosting</h1>

<p>There are three primary Blazor hosting models: Blazor Server, Blazor WebAssembly, and Blazor Hybrid. While this book covers Blazor WebAssembly, Blazor Server and Blazor Hybrid are valid alternative approaches in their own right.</p>








<section data-pdf-bookmark="Blazor Server" data-type="sect2"><div class="sect2" id="idm46365048639888">
<h2>Blazor Server</h2>

<p>With Blazor Server, when a client browser <a data-primary="Blazor Server" data-type="indexterm" id="blzsv"/><a data-primary="hosting" data-secondary="Blazor Server" data-type="indexterm" id="htbzv"/>makes the initial request to the web server, the server executes .NET code to generate an HTML response dynamically. HTML is returned and subsequent requests are made to fetch CSS and JavaScript as specified in the HTML document. Once the scripts are loaded and running, client-side routing and other UI updates are made possible with an ASP.NET Core SignalR connection. ASP.NET Core SignalR offers bidirectional communication between client and server, sending messages in real time. This technology is used to communicate <a data-primary="Document Object Model (DOM)" data-type="indexterm" id="idm46365048636000"/>changes to the Document Object Model (DOM) on the client browser—without a page refresh.</p>

<p>There are advantages to using Blazor Server as a hosting model over Blazor 
<span class="keep-together">WebAssembly:</span></p>

<ul>
<li>
<p>The download size is smaller than Blazor WebAssembly because the app is rendered on the server.</p>
</li>
<li>
<p>The component code isn’t served to clients, only the resulting HTML and some JavaScript to talk to the server.</p>
</li>
<li>
<p>Server capabilities are present with the Blazor Server hosting model because the app technically runs on the server.</p>
</li>
</ul>

<p>For additional information on Blazor Server, see Microsoft’s <a href="https://oreil.ly/rwMaU">“ASP.NET Core Blazor Hosting Models” documentation</a>.</p>

<p><a data-type="xref" href="#blazor_server_hosting">Figure 1-1</a> shows the server and the client. The server is where Blazor code runs, and it is comprised of Razor components running on .NET. The client is responsible for rendering HTML. The client JavaScript communicates user interactions to the server, which then performs logic before sending a list of HTML changes (deltas) back to the client <a data-primary="Blazor Server" data-startref="blzsv" data-type="indexterm" id="idm46365048648896"/><a data-primary="hosting" data-secondary="Blazor Server" data-startref="htbzv" data-type="indexterm" id="idm46365048647952"/>to update its view.</p>

<figure><div class="figure" id="blazor_server_hosting">
<img alt="lblz 0101" src="assets/lblz_0101.png"/>
<h6><span class="label">Figure 1-1. </span>Blazor Server hosting model</h6>
</div></figure>
</div></section>













<section data-pdf-bookmark="Blazor WebAssembly" data-type="sect2"><div class="sect2" id="idm46365048549952">
<h2>Blazor WebAssembly</h2>

<p>With Blazor WebAssembly, when a client browser <a data-primary="Blazor WebAssembly" data-type="indexterm" id="bzwasb"/><a data-primary="hosting" data-secondary="Blazor WebAssembly" data-type="indexterm" id="htzss"/>makes the initial request to the web server, the server returns a static HTML view of what the app would display to the user if already running; this gives users a faster time-to-first render and allows search engines to crawl your app’s content. As the user views the statically rendered content, the resources needed to run the app within the client are downloaded in the background. As part of a Blazor WebAssembly app’s HTML, there will be a <code>&lt;link&gt;</code> element that requests <a data-primary="blazor.webassembly.js file" data-type="indexterm" id="idm46365048545616"/>the <em>blazor.webassembly.js</em> file. This file executes and starts loading WebAssembly, which acts as a bootstrap that requests .NET binaries from 
<span class="keep-together">the server.</span> Once your app is downloaded locally and running inside the browser, changes to the DOM, such as updating data values on the page, occur as new data is retrieved from API calls. This is covered in detail in <a data-type="xref" href="ch02.html#app_startup">“App Startup and Bootstrapping”</a>.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Being mindful of the hosting model is important. With Blazor WebAssembly hosting, all of your C# code is executed on the client. This means that you should avoid using any code that requires server-side functionality, and you should avoid sensitive data such as passwords, API keys, or other confidential information.</p>
</div>

<p>When using the Blazor WebAssembly hosting model, you can choose to create a Blazor ASP.NET Core-hosted application or a standalone application that can be published as just a set of static files (obviously, this will not support server-side pre-rendering for search engines and improved UX). With the ASP.NET Core <em>hosted</em> solution, ASP.NET Core is <a data-primary="ASP.NET Core" data-secondary="hosted solution" data-type="indexterm" id="idm46365048540656"/><a data-primary="ASP.NET Core" data-secondary="standalone model" data-type="indexterm" id="idm46365048370656"/>responsible for serving the app as well as providing a Web API in a client/server architecture. The application for this book uses the <em>standalone</em> model <a data-primary="Azure Static Web Apps" data-type="indexterm" id="idm46365048369200"/>and is deployed to Azure Static Web Apps. In other words, the application is served as a set of static files. The data used to drive the app is available as several Web API endpoints that are deployed either as containers or as simple fault-tolerant pass-thru APIs with monitoring. We’re also using Azure Functions as a <a data-primary="Azure Functions" data-type="indexterm" id="idm46365048368336"/>serverless architecture for local, current, and up-to-date weather data.</p>

<p><a data-type="xref" href="#blazor_webassembly_hosting">Figure 1-2</a> shows only the client. The client is responsible for everything in this scenario, and the site can be served statically.</p>

<figure><div class="figure" id="blazor_webassembly_hosting">
<img alt="lblz 0102" src="assets/lblz_0102.png"/>
<h6><span class="label">Figure 1-2. </span>Blazor WebAssembly hosting model</h6>
</div></figure>

<p>With the standalone approach, the ability to leverage serverless cloud functionality with Azure Functions is helpful. Microservice capabilities such as this work great together with ASP.NET Core Web APIs and Blazor WebAssembly standalone scenarios and together serve as a desirable target for deployment with Azure Static Web Apps. Static web servers deliver static files, which is less computationally expensive than computing a request that then has to dynamically render HTML to then return as a response.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>While this book is focused on developing a Blazor WebAssembly application that is hosted as static files, it’s important to note that this is not the only option. I prefer to develop Blazor WebAssembly applications that are statically hosted. For additional information on the hosting model, see Microsoft’s <a href="https://oreil.ly/xuL8J">“ASP.NET Core Blazor Hosting Models” documentation</a>.</p>
</div>

<p>With the Blazor WebAssembly hosting model, you can write C# that runs inside. With WebAssembly, a “binary instruction format” means that we’re talking about byte code. WebAssembly sits atop a “stack-based virtual machine.” Instructions are added (pushed) into the stack, while results are removed (popped) from the stack. WebAssembly is a “portable compilation target.” This means it’s possible to take C, C++, Rust, C#, and other nontraditional web programming languages and target WebAssembly for their compilation. This results in WebAssembly binaries, which are web-runnable based on <a data-primary="Blazor WebAssembly" data-startref="bzwasb" data-type="indexterm" id="idm46365048361808"/><a data-primary="hosting" data-secondary="Blazor WebAssembly" data-startref="htzss" data-type="indexterm" id="idm46365048360832"/>open standards but from programming languages other than JavaScript.</p>
</div></section>













<section data-pdf-bookmark="Blazor Hybrid" data-type="sect2"><div class="sect2" id="idm46365047795040">
<h2>Blazor Hybrid</h2>

<p>Blazor Hybrid is beyond the scope of <a data-primary="Blazor Hybrid" data-type="indexterm" id="idm46365047793744"/><a data-primary="hosting" data-secondary="Blazor Hybrid" data-type="indexterm" id="idm46365047793040"/>this book. Its purpose is geared toward creating native client experiences for desktop and mobile <a data-primary=".NET Multiplatform App UI" data-primary-sortas="NET Multiplatform App UI" data-type="indexterm" id="idm46365047791856"/>devices, and it works well with .NET Multiplatform App UI (MAUI). For more information about Blazor Hybrid, see Microsoft’s <a href="https://oreil.ly/pubzs">“ASP.NET Core Blazor Hybrid” documentation</a>.</p>
</div></section>





</div></section>













<section data-pdf-bookmark="Single-Page Applications, Redefined" data-type="sect1"><div class="sect1" id="single-page-apps-redefined">
<h1>Single-Page Applications, Redefined</h1>

<p>Blazor is the only .NET-based SPA framework in <a data-primary="SPA (single-page application)" data-secondary="JavaScript" data-type="indexterm" id="spkj"/>existence. The fact that we can use .NET to write SPAs cannot be overstated. There are many popular JavaScript SPA frameworks including (but not limited to) the following:</p>

<ul>
<li>
<p><a href="https://angular.io">Angular</a></p>
</li>
<li>
<p><a href="https://reactjs.org">React</a></p>
</li>
<li>
<p><a href="https://vuejs.org">VueJS</a></p>
</li>
<li>
<p><a href="https://svelte.dev">Svelte</a></p>
</li>
</ul>

<p>These are <em>all</em> based on JavaScript, whereas Blazor isn’t. The list is nonexhaustive—there are many more JavaScript-based SPA frameworks and even more non-SPA JavaScript frameworks, for that matter! JavaScript has ruled the browser as the exclusive programming language of the web for well over 20 years. It’s a very flexible programming language and is among the most popular in the world. In its infancy, the language was prototyped in a few weeks by Brendan Eich—it’s amazing how far it’s come since then.</p>

<p>Stack Overflow manages a professional <a data-primary="Stack Overflow" data-type="indexterm" id="idm46365042442576"/>developer annual survey, and in 2021, over 58,000 professional developers and more than 83,000 total developers voted JavaScript as the most commonly used programming language. That marked the ninth year in a row that JavaScript was the most commonly used programming language.<sup><a data-type="noteref" href="ch01.html#idm46365042441744" id="idm46365042441744-marker">1</a></sup> The close second was HTML/CSS. If you combine these totals, the web app platform has a solid future.</p>

<p>One perceived disadvantage of JavaScript is that without definitive types, developers have to either code defensively or face the potential consequences of runtime errors. One way to help address this is by using TypeScript.</p>

<p>TypeScript was <a data-primary="TypeScript" data-type="indexterm" id="idm46365042439056"/><a data-primary="Hejlsberg, Anders" data-type="indexterm" id="idm46365042438320"/><a data-primary="C#" data-type="indexterm" id="idm46365042437648"/><a data-primary="Turbo Pascal" data-type="indexterm" id="idm46365042436976"/><a data-primary="Delphi" data-type="indexterm" id="idm46365042436304"/>created by Anders Hejlsberg (who was also the lead architect of C#, chief engineer of Turbo Pascal, and chief architect of Delphi—he’s a programming language genius!). TypeScript provides a type system that enables language services to reason about the intent of your code.</p>

<p>With TypeScript, you write generic type-safe code using all of the latest ECMAScript standards and <a data-primary="ECMAScript standards" data-type="indexterm" id="idm46365042435008"/>prototyped features. The best part is that your code is backward compatible to ES3. TypeScript is a superset of JavaScript, meaning that any valid JavaScript is also valid TypeScript. TypeScript provides static typing (type system) and a powerful language service that provides features to your favorite IDEs. This makes programming with JavaScript less error-prone, which cannot be understated. TypeScript is more like a developer tool than it is a programming language, but it has incredible language features. When it compiles, all your types go away, and you’re left with just JavaScript. Try to think of TypeScript as a way to make debugging and refactoring substantially easier and more reliable. With TypeScript, you have one of the most advanced flow analysis tools in the world, and far more advanced language features than JavaScript alone. All web developers know that Angular rivals React in the popularity of JavaScript-based SPAs—this is no surprise. I believe a lot of Angular’s competitive edge was directly correlated to adopting TypeScript far sooner than React did.</p>

<p>Blazor, unlike JavaScript-based SPAs, is built atop .NET. While TypeScript might help developers to be more productive with JavaScript, one of the primary reasons that Blazor has a bright future is its interoperability with C#. C# has long had most of the benefits that TypeScript offered to JavaScript development and more. Not only does C# also have an excellent type system, but it is even better at catching errors at compile time. TypeScript’s static type system is “duck typed” (if it looks like a duck and sounds like a duck, then treat it like a duck), whereas C# has a strict type system that ensures the object you are passing is an instance of a duck type. C# has always prioritized the developer experience with flow analysis, statement completion, a feature-full ecosystem, and reliable refactoring. C# is a modern, object-oriented first, and type-safe programming language that is constantly evolving and maturing, further expanding its capabilities. It is open source, and new features are often inspired and influenced, and sometimes even
developed, by the developer community.</p>

<p>All that being said, Blazor provides interop with JavaScript as well. You can call JavaScript from your Blazor code, and you can call .NET code from your JavaScript code. This is a useful <a data-primary="SPA (single-page application)" data-secondary="JavaScript" data-startref="spkj" data-type="indexterm" id="idm46365048844864"/>feature to leverage existing JavaScript utilitarian functionality and JavaScript APIs.</p>
</div></section>













<section data-pdf-bookmark="Why Adopt Blazor" data-type="sect1"><div class="sect1" id="idm46365048843168">
<h1>Why Adopt Blazor</h1>

<p>There are interesting new scenarios <a data-primary="Blazor" data-secondary="reasons to adopt" data-type="indexterm" id="blzdpt"/>specific to WebAssembly that were not realistically achievable with JavaScript alone. It’s easy to imagine applications being delivered over the web to your browser, powered by WebAssembly for more elaborate and resource-intensive use cases. If you haven’t heard of AutoCAD before, it’s computer-aided design software that architects, engineers, and construction professionals rely on to create 2D and 3D drawings. It’s a desktop application, but imagine being able to run a program like this natively in a web browser. Imagine audio and video editing, running or playing robust and resource-taxing games all in the browser. Web­Assembly does allow us to reimagine the web a bit. The web app platform holistically might be the next delivery mechanism for a generation of software development. The web app development platform continues to evolve, grow, and mature. Internet-based data processing and ingestion systems thrive because of their connectivity to the world. The web app development platform serves as the median that bridges a developer’s imagination and a user’s desire.</p>

<p>Developers can continue to extend their C# and Razor skills into SPA development rather than having to learn an additional language and rendering framework. C# developers who previously weren’t inclined to write SPA apps are now switching from MVC to SPA simply because “it’s just more C#.” Additionally, the code-sharing potential is great. Rather than ensuring your C# API contracts on the server are manually kept in sync with your TypeScript definitions, you can simply use the same contracts file, along with all the <code>DataAnnotation</code> validators too.</p>

<p>I believe that in the coming years, we will start seeing more and more WebAssembly-powered applications. Blazor WebAssembly will be .NET’s solution of choice.</p>








<section data-pdf-bookmark=".NET’s Potential in the Browser" data-type="sect2"><div class="sect2" id="idm46365048837344">
<h2>.NET’s Potential in the Browser</h2>

<p>At my first developer job out of college, I was the most junior developer on a team of developer leads or architects. I vividly recall being seated in a cube farm alone; neighboring cubes were empty. But all the surrounding offices were filled with the rest of the team.</p>

<p>I was working in the automotive <a data-primary=".NET" data-primary-sortas="NET" data-secondary="SerialPort class" data-type="indexterm" id="idm46365048835184"/><a data-primary="OBD (onboard diagnostics) protocols" data-type="indexterm" id="idm46365048833936"/><a data-primary="onboard diagnostics (OBD) protocols" data-type="indexterm" id="idm46365048725248"/>industry, and we were implementing a low-level communication standard known as the onboard diagnostics (OBD) protocols. We were doing so with the .NET <code>SerialPort</code> class. We were writing applications that performed state testing for vehicle emissions. In the US, most states mandate that vehicles of a certain age have annual emissions tests to ensure their ability to be registered. The idea is rather simple: evaluate the vehicle’s various conditions. For example, a vehicle could have hardware triggering state changes, which propagate through the firmware, each wire transmitting information as it happens. The OBD system sits in the onboard vehicle computers, which can relay this information to interested parties. Your “check engine” light, for example, is a diagnostic code from the OBD system.</p>

<p>The apps were primarily built as <a data-primary="WinForms" data-type="indexterm" id="idm46365048723472"/>Windows Forms (WinForms) applications, and there were a few web service apps too. But this meant the app was limited to the .NET Framework and Windows at the time—in other words, it wasn’t cross-platform. The application had to communicate with various web services to persist the data and pull lookup data points. At the time, it would have been unimaginable to write something like this and deploy it as a web app; it had to be WinForms on Windows.</p>

<p>Now, however, it is very easy to imagine this application being rewritten as a web app with Blazor WebAssembly. The Mono .NET runtime <a data-primary="Mono .NET runtime" data-type="indexterm" id="idm46365048722112"/>is what makes writing cross-platform .NET apps possible.</p>

<p>Try to imagine how it might be straightforward to implement the same .NET <code>SerialPort</code> object that we were using in WinForms in Blazor WebAssembly instead. The corresponding implementation could hypothetically rely on WebAssembly interop with the native JavaScript Web Serial APIs. This kind of cross-platform functionality already exists with other implementations, such as the .NET <code>HttpClient</code> in Blazor WebAssembly. With Blazor WebAssembly, our compilation target is WebAssembly, and the Mono runtime’s implementation is the <code>fetch</code> Web API. You see, .NET has the entire web as its playground now.</p>
</div></section>













<section data-pdf-bookmark=".NET Is Here to Stay" data-type="sect2"><div class="sect2" id="idm46365048719376">
<h2>.NET Is Here to Stay</h2>

<p>WebAssembly is supported in all major browsers <a data-primary="WebAssembly" data-type="indexterm" id="idm46365048718048"/>and covers nearly 95% of all users according to the <a href="https://oreil.ly/ixdKk">“Can I Use <em>WebAssembly</em>?” web page</a>. It’s the future of the web, and you’ll continue to see developers building applications using this technology.</p>

<p>.NET isn’t going anywhere either. Microsoft continues to move forward at staggering speeds, with release cadences that are predictable and profound. The web developer community is extremely strong, and the software development industry as a whole recognizes ASP.NET Core as one of the best options for modern and enterprise-friendly web app dev platforms. JavaScript is still a necessity, but it’s de­em⁠pha­sized from your perspective because WebAssembly relies on it today and they play very nicely together. The <a href="https://oreil.ly/EKjC7">WebAssembly website states</a>, “It is expected that JavaScript and WebAssembly will be used together in several configurations.”</p>
</div></section>













<section data-pdf-bookmark="Familiarity" data-type="sect2"><div class="sect2" id="idm46365048714416">
<h2>Familiarity</h2>

<p>If you’re a C# developer, great! If you’re a JavaScript developer, awesome! Bring these existing skills to the table, and Blazor will feel very familiar with both sets of lenses. This way, you can keep using your HTML and CSS skills and your favorite CSS libraries, and you’re free to work smoothly with existing JavaScript packages. JavaScript development is deemphasized, however, as you’ll code in C#. C# is from Microsoft and is heavily influenced by the .NET developer community. In my opinion, C# is one of the best programming languages.</p>

<p>If you’re coming from a web development background, you’re more than likely used to client-side routing, event handling, HTML templating of some sort, and component authoring. Everything that you’ve grown to love about web development is still at the forefront of Blazor development. Blazor development is easy and intuitive. Additionally, Blazor provides various isolation models for both JavaScript and CSS. You can scope JavaScript and CSS to individual components. You can continue to use your favorite CSS preprocessor too. You’re entirely free to pick whichever CSS framework you prefer.</p>
</div></section>













<section data-pdf-bookmark="Safe and Secure" data-type="sect2"><div class="sect2" id="idm46365048711872">
<h2>Safe and Secure</h2>

<p>Long before WebAssembly, there was <a data-primary="security" data-type="indexterm" id="idm46365047433232"/><a data-primary="plug-in-based architecture" data-type="indexterm" id="idm46365047432528"/>another web-based technology that I’d be remiss not to mention. Microsoft Silverlight was a plug-in powered by the .NET Framework. Silverlight was an app framework designed for writing and running rich web applications. Silverlight relied on the Netscape Plugin Application Programming Interface (NPAPI), which has long since been deprecated. The plug-in architecture proved to be a security concern, and all of the major browsers started phasing 
<span class="keep-together">out support</span> of NPAPI. This led to the demise of Silverlight, but rest assured: Web­Assembly <em>is not</em> a plug-in-based architecture.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>WebAssembly is every bit as secure as JavaScript. WebAssembly plays within the same security sandbox as all browser-based JavaScript execution environments. Because of this, WebAssembly’s security context is identical to that of JavaScript.</p>
</div>
</div></section>













<section data-pdf-bookmark="Code Reuse" data-type="sect2"><div class="sect2" id="idm46365047429200">
<h2>Code Reuse</h2>

<p>SPA developers have been <a data-primary="code" data-secondary="reuse" data-type="indexterm" id="cdrus"/>fighting an uphill battle for years. These developers consume web API endpoints that define a payload in a certain shape. The consuming client-side code (the SPA app) has to model the same shape; however, this is error-prone as the API can change the shape of the response whenever it needs to. The client would have to know when these changes are made and then adapt, and this is tedious! Blazor can alleviate that concern by sharing models from .NET Web APIs with the Blazor client app. I cannot stress the importance of this enough. Sharing the models from a class library with both the server and the client is like having your cake and eating it too.</p>

<p>As a developer who has played on both sides of the development experience, from building APIs to consuming them on client apps, I think the act of synchronizing model definitions carries with it a great sense of tedium. I refer to this as “synchronization fatigue.” Synchronization fatigue wears hard on developers, who grow frustrated with manually mapping server and client models. This is especially true when you have to map type systems from different languages—that’s never fun. This problem existed in backend development too, reading data from a storage medium, such as the file system or database. Mapping the shape of <a data-primary="ORMs (object-relational mappers)" data-type="indexterm" id="idm46365047425824"/><a data-primary="object-relational mappers (ORMs)" data-type="indexterm" id="idm46365047425056"/>something stored in a database to match a .NET object is a solved problem; object-relational mappers (ORMs) do this for us.</p>

<p>For years and years, I leaned on tooling to help catch common errors, where the server would change the shape of an API endpoint’s data structure and the client app would break. Sure, you could try to use API versioning—but if we’re honest with each other, that has its own set of complexities. Tooling simply wasn’t enough, and it was very difficult to prevent synchronization fatigue. Occasionally, wild ideas would emerge to combat these concerns, but you have to ask yourself, “Is there a better way?” The answer is “Yes, with Blazor, there is!”</p>

<p>Entire .NET libraries can be shared and consumed in both server-side and client-side scenarios. Making use of existing logic, functionality, and capabilities allows developers to focus on innovating more because they’re not required to reinvent the wheel. Also, developers don’t have to waste time maintaining two different languages, manually mapping models delivered over from a server to a client browser. You can make use of common extension methods, models, and utilitarian functions that can all be easily encapsulated, tested, and shared. This alone actually has an implicit and perhaps less obvious quality. You see, a single team can write the client, the server, and the abstraction together. This allows for rapid innovation in your app development process because there will be so much common code that can be reused and shared. Think of this as tons of apps being written all around the world by multiple teams, where at least one team is relying on another team. It’s a common development <a data-primary="code" data-secondary="reuse" data-startref="cdrus" data-type="indexterm" id="idm46365047422720"/>problem domain, where one team takes a dependency of the output from another. But it’s not a necessity with Blazor, because it’s all C#!</p>
</div></section>













<section data-pdf-bookmark="Tooling" data-type="sect2"><div class="sect2" id="idm46365047421056">
<h2>Tooling</h2>

<p>As developers, we have many options when it comes <a data-primary="tooling" data-type="indexterm" id="tlng"/>to tooling. Choosing the right tool for the job is just as important as the job itself. You wouldn’t use a screwdriver to hammer in a nail, would you? The development team’s productivity is always a major concern for application development. If your team fumbles about or struggles to get common programming tasks done, the entire project can and will eventually fail. With Blazor development, you can use proven developer tooling such as the following:</p>

<ul>
<li>
<p>Visual Studio</p>
</li>
<li>
<p>Visual Studio for Mac</p>
</li>
<li>
<p>Visual Studio Code</p>
</li>
</ul>

<p>Mileage may vary based on your OS. On Windows, Visual Studio is great. On macOS, it’s probably easier to use Visual Studio Code. JetBrains’ Rider is another amazing .NET development environment. The point is that as a developer, you have plenty of really good options. Whichever IDE you decide on, it needs to work well with the .NET ecosystem. Modern IDEs power developers to be their most 
<span class="keep-together">productive.</span> C# is powered by Roslyn (the .NET Compiler Platform), and while it’s opaque to you, the developer, we’re spoiled with features such as these:</p>
<dl>
<dt>Statement completion (IntelliSense)</dt>
<dd>
<p>As you type, the IDE shows pick lists of all <a data-primary="IntelliSense" data-type="indexterm" id="idm46365048605504"/><a data-primary="statement completion" data-type="indexterm" id="idm46365048604800"/>the applicable and contextual members, providing semantic guidelines and more rapid code discoverability.
Developer documentation enabled by triple-slash comments further advances code comprehension and readability.</p>
</dd>
<dt>AI-assisted IntelliSense (AI, IntelliCode)</dt>
<dd>
<p>As you type, the IDE offers suggestions to <a data-primary="AI (artificial intelligence)" data-type="indexterm" id="idm46365048602624"/><a data-primary="artificial intelligence (AI)" data-type="indexterm" id="idm46365048601952"/><a data-primary="IntelliCode" data-type="indexterm" id="idm46365048601264"/>complete your code based on model-driven predictions, which are learned from all 100+ star open source code repositories on GitHub.</p>
</dd>
<dt>GitHub Copilot (AI pair programmer)</dt>
<dd>
<p>As you type, the IDE suggests entire lines <a data-primary="GitHub Copilot" data-type="indexterm" id="idm46365048599008"/>or functions, trained by billions of lines of public code.</p>
</dd>
<dt>Refactoring</dt>
<dd>
<p>Quickly and reliably ensure <a data-primary="refactoring" data-type="indexterm" id="idm46365048577168"/>consuming references downstream are appropriately updated, from changing method signatures, member names, and types across projects within a solution to adding C# modernization efforts that enhance source code execution, performance, readability, and the latest C# features.</p>
</dd>
<dt>Built-in and extensible code analyzers</dt>
<dd>
<p>Detect common pitfalls or missteps in source <a data-primary="code analyzers" data-type="indexterm" id="idm46365048574992"/>code, and quickly light up the developer experience with warnings, suggestions, and even errors. In other words, write cool code.</p>
</dd>
<dt>Code generators</dt>
<dd>
<p>One code generator <a data-primary="code generators" data-type="indexterm" id="idm46365048572736"/>example is auto equality implementations with record types; this technology has allowed for the reimagining of what’s possible.</p>
</dd>
</dl>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46365048606960">
<h5>The Art of Debugging</h5>
<p>A good .NET IDE will have a great debugging experience; it’s a requirement for IDEs that value adoption. The best developers are amazing at debugging. They’re always debugging, refactoring, testing, tweaking…perfecting. It’s almost an obsession. Reflecting on this, we’re telling a machine to remember our intentions, and whenever a user asks something of our apps, it interprets our intentions and appeases the user. It’s beautiful—we can speak to computers, and they listen. I can’t get my three sons to do that all the time. Many things make up good developers, but this, I promise, will set you apart. Secretly, we’re all perfectionists, and debugging is a major part of that. Features like Hot Reload and Edit and Continue are really useful.</p>
</div></aside>

<p>You can also utilize the .NET CLI, which is a cross-platform <a data-primary=".NET CLI" data-primary-sortas="NET CLI" data-type="indexterm" id="idm46365048569536"/><a data-primary="tooling" data-startref="tlng" data-type="indexterm" id="idm46365048568560"/>toolchain for developing .NET workloads. It exposes many commands, such as <code>new</code> (templating), <code>build</code>, <code>restore</code>, <code>publish</code>, <code>run</code>, <code>test</code>, <code>pack</code>, and <code>migrate</code>.</p>
</div></section>













<section data-pdf-bookmark="Open Source Software" data-type="sect2"><div class="sect2" id="idm46365048563968">
<h2>Open Source Software</h2>

<p>Blazor is entirely developed in the open, as part of the <a href="https://oreil.ly/4YS3Z">ASP.NET Core GitHub repository</a>.</p>

<p>Open source software development is the future of software engineering in modern-day development. The reality is <a data-primary="open source software" data-type="indexterm" id="pscw"/>that it’s not <em>really</em> new; it’s just new to .NET as of March 2014. With the birth of the .NET Foundation, developers collaborate openly with negotiated open standards and best practices. Innovation is the only path forward, especially when projects undergo public scrutiny and natural order prevails.</p>

<p>To me, it’s not enough to simply describe .NET as open source. Let me share with you a bit more perspective about the true value proposition and why this is so important. I’ve witnessed .NET APIs being developed, from their inception to fruition—the process is very mature and well established. This applies to Blazor as well because it’s part of the .NET family of open source projects.</p>

<p>Unlike typical projects, open source projects are developed entirely out in the open for the public to see. With .NET, it starts with early discussions, and then an idea emerges. A GitHub issue is used to draft an <a href="https://oreil.ly/0zKRz">ASP.NET Core <code>api-suggestion</code> label</a>. From a suggestion, after it’s been discussed and vetted, it moves into a proposal. The issue containing the proposal transitions to an <a href="https://oreil.ly/ajkuM">ASP.NET Core <code>api-ready-for-review</code> label</a>. The issue captures everything you’d expect for the proposal: the problem statement, use cases, reference syntax, suggested API surface area, example usage, and even links to the comments from the original discussion and idea.</p>

<p>The potential API usually includes bargaining, reasoning, and negotiation. After everyone agrees it’s a good proposal, a draft is finalized with a group of people who participate in the public API design review meeting. The official .NET API design review meeting follows a weekly schedule, streams live on YouTube, and invites developer community members to share their thoughts. As part of the review, notes are captured and GitHub labels applied, and assuming it receives a stamp of approval, the .NET API in question is codified as a snippet. Finally, it moves to <a href="https://oreil.ly/TYc05">ASP.NET Core <code>api-approved</code> label</a>.</p>

<p>From there, the issue serves as a point of reference for pull requests that aim to satisfy the proposal. A developer takes the issue, implements the API, writes unit tests, and creates a pull request (PR). The PR undergoes review, and when it’s merged, the API has to be documented, communicated, breaking changes captured and reported, promoted, shared, analyzed, and so on.</p>

<p>All of this is for a single .NET API, and there are tens of thousands of .NET APIs. You’re in good hands with the strength of all the .NET contributors who are building the best platforms in modern app dev today.</p>

<p>The software development industry is rather fond of open source software development. To me, being able to see how a feature is architected, designed, and implemented is a game-changer. The ability to post issues, propose features, carry on open discussions, maintain Kanban-style projects with automated status updates, collaborate with the dev team and others, and create pull requests are all capabilities that make this software <em>community-centric</em>. This ultimately makes for a better product, without <a data-primary="open source software" data-startref="pscw" data-type="indexterm" id="idm46365048378544"/>question!</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46365048377312">
<h5>Cold Code and Perpetuity</h5>
<p>GitHub values open source very differently <a data-primary="GitHub" data-secondary="open source software and" data-type="indexterm" id="idm46365048375904"/>than most organizations. GitHub has an archive program, in which they preserve snapshots of every active public repository on GitHub. These snapshots will last for 1,000 years in cold storage in the Arctic World Archive. Located closer to the North Pole than the Arctic Circle, the vault is in the Svalbard archipelago. I think it’s so cool (both literally and figuratively) to have code <a data-primary="Blazor" data-secondary="reasons to adopt" data-startref="blzdpt" data-type="indexterm" id="idm46365048374736"/>that’s stored there—it gives open source developers a sense of perpetuity and purpose. I believe that we open source developers are making the world a better place.</p>
</div></aside>
</div></section>





</div></section>













<section data-pdf-bookmark="Your First Blazor App with the .NET CLI" data-type="sect1"><div class="sect1" id="idm46365048842704">
<h1>Your First Blazor App with the .NET CLI</h1>

<p>Enough talk. Let’s jump in and have <a data-primary=".NET CLI" data-primary-sortas="NET CLI" data-secondary="app creation" data-type="indexterm" id="ntcppc"/>you make your very first Blazor app using the .NET CLI. The .NET CLI is cross-platform and works on Windows, Linux, and macOS.  Install the .NET SDK, which includes the .NET CLI and runtime—<a href="https://oreil.ly/zWMCk">available as a free download</a>. Install .NET 6.0 because it’s an LTS version. With the .NET CLI, you’re able to create many .NET workloads. To create a new Blazor WebAssembly application, open a terminal and run the following:</p>

<pre data-type="programlisting">dotnet new blazorwasm -o FirstApp</pre>

<p>The <code>dotnet new</code> command will have created a new Blazor WebAssembly application based on the template.</p>
<div data-type="tip"><h6>Tip</h6>
<p>There are many other templates available to you. .NET is free, open source, and amazing. For additional templates, see Microsoft’s list of <a href="https://oreil.ly/Lg1Nk">.NET default templates for <code>dotnet new</code></a>.</p>
</div>

<p>It will output the project to a <a data-primary="FirstApp directory" data-type="indexterm" id="idm46365048506208"/>newly created <em>FirstApp</em> directory. You should see command output similar to the following:</p>

<pre data-type="programlisting">The template "Blazor WebAssembly App" was created successfully.
This template contains technologies from parties other than Microsoft,
see https://aka.ms/aspnetcore/6.0-third-party-notices for details.</pre>

<p>The template application comprises a single C# file, several <a data-primary="Razor" data-secondary="files, template application" data-type="indexterm" id="idm46365048503856"/>Razor files, CSS files, and an index.html. This application has a few pages, basic navigation, data binding, event handling, and a few other common aspects of typical Blazor application development. Next, you’ll need to change directories. Use the <code>cd</code> command and pass the directory name:</p>

<pre data-type="programlisting">cd FirstApp</pre>








<section data-pdf-bookmark="Build the App" data-type="sect2"><div class="sect2" id="idm46365048501488">
<h2>Build the App</h2>

<p>Once you’re in your new <a data-primary="templates" data-secondary="compiling" data-type="indexterm" id="idm46365048499840"/>application’s directory, the template can be compiled using the following command:</p>

<pre data-type="programlisting">dotnet build</pre>

<p>After the app is compiled (has a successful <code>build</code>), you should see command output similar to the following:</p>

<pre data-type="programlisting">Microsoft (R) Build Engine version 17.0.0+c9eb9dd64 for .NET
Copyright (C) Microsoft Corporation. All rights reserved.

  Determining projects to restore...
  All projects are up-to-date for restore.
  FirstApp -&gt; ..\FirstApp\bin\Debug\net6.0\FirstApp.dll
  FirstApp (Blazor output) -&gt; ..\FirstApp\bin\Debug\net6.0\wwwroot

Build succeeded.
    0 Warning(s)
    0 Error(s)

Time Elapsed 00:00:04.20</pre>
</div></section>













<section data-pdf-bookmark="Install Dev-cert" data-type="sect2"><div class="sect2" id="idm46365048496400">
<h2>Install Dev-cert</h2>

<p>If this is your first time building and <a data-primary="dev-cert" data-type="indexterm" id="idm46365048596864"/>running an ASP.NET Core application, you’ll need to trust the developer self-signed certificate for <code>localhost</code>. This can be done by running the following command:</p>

<pre data-type="programlisting">dotnet dev-certs https --trust</pre>

<p>When prompted, answer “Yes” to install the cert.</p>
<div data-type="tip"><h6>Tip</h6>
<p>If you don’t install and trust the dev-certs, you’ll get a warning that you’ll have to accept due to the site not being secured. If you’re running on a macOS, you’ll likely have to enter your password (twice) to accept the certificate.</p>
</div>
</div></section>













<section data-pdf-bookmark="Run the App" data-type="sect2"><div class="sect2" id="idm46365048593040">
<h2>Run the App</h2>

<p>To run the template app, use the <a data-primary="applications" data-secondary="template, running" data-type="indexterm" id="idm46365048591472"/><a data-primary="templates" data-secondary="running" data-type="indexterm" id="idm46365048590496"/>following command:</p>

<pre data-type="programlisting">dotnet run</pre>

<p>The command output will look similar to the following, and one of the first output lines will show where the app is hosted:</p>

<pre data-type="programlisting">..\FirstApp&gt; dotnet run
Building...
info: Microsoft.Hosting.Lifetime[14]
      Now listening on: https://localhost:7024
info: Microsoft.Hosting.Lifetime[14]
      Now listening on: http://localhost:5090
info: Microsoft.Hosting.Lifetime[0]
      Application started. Press Ctrl+C to shut down.
info: Microsoft.Hosting.Lifetime[0]
      Hosting environment: Development
info: Microsoft.Hosting.Lifetime[0]
      Content root path: ../repos/FirstApp</pre>

<p>The <code>localhost</code> URL is the current device hostname with a randomly available port number. Navigate to the URL with the <code>https://</code> scheme: in my example, <code>https://localhost:7024</code> (yours will likely be different). The app will launch, and you’ll be able to interact with a fully functional Blazor WebAssembly app template as shown in <a data-type="xref" href="#first_template_app">Figure 1-3</a>.</p>

<figure><div class="figure" id="first_template_app">
<img alt="lblz 0103" src="assets/lblz_0103.png"/>
<h6><span class="label">Figure 1-3. </span>First Blazor template app</h6>
</div></figure>

<p>To stop the app from running, end the terminal session. You can close your IDE after you’ve stopped the app from running. This Blazor WebAssembly template is <a href="https://oreil.ly/qVd9M">very well documented</a> and limited in what it shows off.</p>

<p>Now that you know how to start creating your app, you <a data-primary=".NET CLI" data-primary-sortas="NET CLI" data-secondary="app creation" data-startref="ntcppc" data-type="indexterm" id="idm46365048581168"/>might ask, “Where am I supposed to put my code?” I’m glad you asked.</p>
</div></section>





</div></section>













<section data-pdf-bookmark="The Code Must Live On" data-type="sect1"><div class="sect1" id="github-repo">
<h1>The Code Must Live On</h1>

<p>Code is only as good as where it is stored. If your code lives on your machine, and yours alone, that’s where it <a data-primary="code" data-secondary="source code storage" data-type="indexterm" id="scdsg"/><a data-primary="source code" data-see="code" data-type="indexterm" id="idm46365046553296"/>will stay forever. It won’t go anywhere else, and that’s a shame. GitHub provides a hosted solution for version control using Git, and it’s the best of its kind. Call me biased.</p>

<p>All of the source code for this book can be found on <a href="https://oreil.ly/learning-blazor-code">GitHub</a>. If you want to follow along in the code <a data-primary="repository, cloning" data-type="indexterm" id="idm46365046550832"/><a data-primary="cloning, repository" data-type="indexterm" id="idm46365046550128"/>itself, you can clone the repository locally on your machine with the following <a href="https://oreil.ly/7AMOX">git CLI</a> command:</p>

<pre data-type="programlisting">git clone https://github.com/IEvangelist/learning-blazor.git</pre>
<div data-type="tip"><h6>Tip</h6>
<p>This command will clone the repository into <a data-primary="learning-blazor directory" data-type="indexterm" id="idm46365046546784"/>a new directory named <em>learning-blazor</em>. The new directory is from the root of where this command was executed. For more information about cloning a repository, see Git’s <a href="https://oreil.ly/fdnIo"><code>git clone</code> documentation</a>.</p>
</div>

<p>Once you’ve cloned the repository, you can open the solution file or the root directory in your favorite IDE. You can run the app locally if you’d like to explore it before you start the book. You’ll need to read through the <a href="https://oreil.ly/jPOjv">Getting Started</a> markdown file.</p>

<p>Alternatively, you can visit the live site to explore its functionality. Using your favorite web browser, navigate to <a href="https://webassemblyof.net"><em class="hyperlink">https://webassemblyof.net</em></a>. If you have a Twitter, Google, or GitHub account, you could log in to the site and explore the app. If you don’t have one of those kinds of accounts, or if you’d rather not log in with them, you can register for an account. The only requirement is a valid email address that can be verified. A verification email will be sent to the address you provide, and you’ll create a password to use when logging in. In the next section, you’ll learn how this code is version-controlled.</p>

<p class="pagebreak-after">For code to live on, we need to have <a data-primary="version control" data-type="indexterm" id="idm46365046539968"/>version control. Our Blazor application can use GitHub Actions to build, test, analyze, source generate, package, and deploy anything we require. GitHub Actions are explored a bit more in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch05.html#chapter-five">5</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch09.html#chapter-nine">9</a>. GitHub Actions are available for free for up to 2,000 minutes a month and 500 MB of storage. GitHub Actions are enjoyable to create and powerful for automating processes. With the GitHub Action Marketplace, you can discover published actions that you can consume in workflows. A GitHub Action workflow is defined as a YAML file that contains the instructions to run your composed GitHub Actions. For example, whenever code is pushed to the <code>main</code> branch in my GitHub repo, a build validation is triggered. The build validation is defined <a data-primary=".github/workflows/build-validation.yml" data-primary-sortas="github/workflows/build-validation.yml" data-type="indexterm" id="idm46365047417712"/><a data-primary="build-validation.yml" data-type="indexterm" id="idm46365047416704"/>in a YAML file called <em>.github/workflows/build-validation.yml</em>:</p>

<pre class="less_space" data-code-language="yaml" data-type="programlisting"><code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">Build Validation</code>

<code class="nt">on</code><code class="p">:</code>
  <code class="nt">push</code><code class="p">:</code>
    <code class="nt">branches</code><code class="p">:</code> <code class="p-Indicator">[</code> <code class="nv">main</code> <code class="p-Indicator">]</code>
    <code class="nt">paths-ignore</code><code class="p">:</code>
    <code class="p-Indicator">-</code> <code class="s">'**.md'</code>
  <code class="nt">pull_request</code><code class="p">:</code>
    <code class="nt">types</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="nv">opened</code><code class="p-Indicator">,</code> <code class="nv">synchronize</code><code class="p-Indicator">,</code> <code class="nv">reopened</code><code class="p-Indicator">,</code> <code class="nv">closed</code><code class="p-Indicator">]</code>
    <code class="nt">branches</code><code class="p">:</code>
      <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">main</code>  <code class="c1"># only ran on the main branch</code>

<code class="nt">env</code><code class="p">:</code>
  <code class="nt">TEST_USERNAME</code><code class="p">:</code> <code class="l-Scalar-Plain">${{ secrets.TEST_USERNAME }}</code>
  <code class="nt">TEST_PASSWORD</code><code class="p">:</code> <code class="l-Scalar-Plain">${{ secrets.TEST_PASSWORD }}</code>

<code class="nt">jobs</code><code class="p">:</code>
  <code class="nt">build</code><code class="p">:</code>
    <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">build</code>
    <code class="nt">runs-on</code><code class="p">:</code> <code class="l-Scalar-Plain">ubuntu-latest</code>

    <code class="nt">steps</code><code class="p">:</code>
    <code class="p-Indicator">-</code> <code class="nt">uses</code><code class="p">:</code> <code class="l-Scalar-Plain">actions/checkout@v2</code>

    <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">Setup .NET 6.0</code>
      <code class="nt">uses</code><code class="p">:</code> <code class="l-Scalar-Plain">actions/setup-dotnet@v1</code>
      <code class="nt">with</code><code class="p">:</code>
        <code class="nt">dotnet-version</code><code class="p">:</code> <code class="l-Scalar-Plain">6.0.x</code>

    <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">Install dependencies</code>
      <code class="nt">run</code><code class="p">:</code> <code class="l-Scalar-Plain">dotnet restore</code>

    <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">Build</code>
      <code class="nt">run</code><code class="p">:</code> <code class="p-Indicator">|</code>
        <code class="no">dotnet build --configuration Release --no-restore</code>

    <code class="p-Indicator">-</code> <code class="nt">uses</code><code class="p">:</code> <code class="l-Scalar-Plain">actions/setup-node@v1</code>
      <code class="nt">name</code><code class="p">:</code> <code class="s">'Setup</code> <code class="s">Node'</code>
      <code class="nt">with</code><code class="p">:</code>
        <code class="nt">node-version</code><code class="p">:</code> <code class="l-Scalar-Plain">18</code>
        <code class="nt">cache</code><code class="p">:</code> <code class="s">'npm'</code>
        <code class="nt">cache-dependency-path</code><code class="p">:</code> <code class="l-Scalar-Plain">subdir/package-lock.json</code>

    <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="s">'Install</code> <code class="s">Playwright</code> <code class="s">browser</code> <code class="s">dependencies'</code>
      <code class="nt">run</code><code class="p">:</code> <code class="p-Indicator">|</code>
        <code class="no">npx playwright install-deps</code>

    <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">Test</code>
      <code class="nt">run</code><code class="p">:</code> <code class="p-Indicator">|</code>
        <code class="no">dotnet test --no-restore --verbosity normal</code></pre>

<p>From the perspective of <a data-primary="CI/CD (continuous integration/continuous delivery)" data-type="indexterm" id="idm46365042632784"/><a data-primary="continuous integration/continuous delivery (CI/CD)" data-type="indexterm" id="idm46365042632048"/>continuous integration and continuous deployment (CI/CD), this is very powerful.</p>

<p>The preceding GitHub workflow has the following characteristics:</p>

<ul>
<li>
<p>Its <code>name</code> is “Build.”</p>
</li>
<li>
<p>It is triggered <code>on</code> a <code>push</code> to <code>main</code>, when any file in the changeset ends with <em>.cs</em>, <em>.css</em>, <em>.json</em>, <em>.razor</em>, or <em>.csproj</em>.</p>
</li>
<li>
<p>It defines a single <code>build</code> job, which runs on the latest version of Ubuntu. The <code>build</code> job defines several <code>steps</code>:</p>

<ul>
<li>
<p>Check out the repo at the specific commit that triggered the run.</p>
</li>
<li>
<p>Set up .NET 6.0 within the context of the execution environment.</p>
</li>
<li>
<p>Install dependencies via <code>dotnet restore</code>.</p>
</li>
<li>
<p>Compile the code using <code>dotnet build</code>.</p>
</li>
<li>
<p>Test the code using <code>dotnet test</code>.</p>
</li>
</ul>
</li>
</ul>

<p>It’s cool getting to see a simple Blazor app running, but what if I told you that you could learn more about Blazor using the <a href="https://oreil.ly/y22J4">Telerik REPL for Blazor</a>. The Blazor REPL (read-eval-print-loop) is an online program that allows you to write Blazor code in the browser and immediately compile and run it. It’s a great way to learn about Blazor, as it provides an interactive way to explore the code and tighten the feedback loop for rapid development.</p>

<p>This is but one example among several within the application’s GitHub repo. As a developer who is onboarding with the sample application, it is important to understand all of the moving pieces involved. You’ll learn all that there is to know about the source code. Along the way, you’ll also learn how the code is deployed and hosted and the general flow of data. Next, we’re <a data-primary="code" data-secondary="source code storage" data-startref="scdsg" data-type="indexterm" id="idm46365046162832"/>going to get a high-level overview of the application’s architecture.</p>
</div></section>













<section data-pdf-bookmark="Perusing the “Learning Blazor” Sample App" data-type="sect1"><div class="sect1" id="perusing-the-app">
<h1>Perusing the “Learning Blazor” Sample App</h1>

<p>Throughout this book, we’ll be working <a data-primary="Learning Blazor app" data-type="indexterm" id="spapp"/>with the Learning Blazor model app. The best way to learn is to see things in action and get your hands dirty. The app  will teach by providing examples of how to solve various problems. The Learning Blazor model app leverages a microservice architecture. The application wouldn’t be very exciting without some sort of meaningful or practical data. And while it’s thrilling to discuss all the bleeding-edge technologies, it’s much less engaging when the sample source code lacks real-world appeal.</p>

<p class="pagebreak-before">As I said, we’ll go through each of these projects in the coming chapters, but let’s take a high-level look at what these projects do and how they’re put together. This should also give you an idea of all the different things you can do with Blazor and inspire you to write your own apps.</p>

<p>As shown in <a data-type="xref" href="#architecture-diagram">Figure 1-4</a>, the app is architected such that all clients must request access to all APIs through an authentication provider. Once authenticated, the client can access the Web.Api and the Web.PwnedApi. These APIs rely on other services and APIs such as Twitter, ASP.NET Core SignalR, Logic Apps, and in-memory cache. They’re all part of the shared resource group, along with the Azure Static Web App. As a developer, when you push changes to the GitHub repository, various GitHub Actions are conditionally triggered that will deploy the latest code to the corresponding Azure resources. For more information on the <a data-primary="Learning Blazor app" data-startref="spapp" data-type="indexterm" id="idm46365046728096"/>various projects, see the <a data-type="xref" href="app01.html#appendix">Appendix</a>. The sample application targets .NET 6 and uses C# 10.</p>

<figure><div class="figure" id="architecture-diagram">
<img alt="lblz 0104" src="assets/lblz_0104.png"/>
<h6><span class="label">Figure 1-4. </span>Architecture diagram</h6>
</div></figure>
</div></section>













<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46365046724096">
<h1>Summary</h1>

<p>We’ve covered a lot of ground in this chapter. We discussed the origins of Blazor and .NET web app development. From a language standpoint, we’ve compared JavaScript SPAs to those of .NET. I’ve gone over why you’d use Blazor over any other SPA. You created your first Blazor app from a template, and you were introduced to the overall architecture of the Learning Blazor model app for this book. In the next chapter, we’re going to dive into the source code of this app and start talking about Blazor app startup.</p>
</div></section>







<div data-type="footnotes"><p data-type="footnote" id="idm46365042441744"><sup><a href="ch01.html#idm46365042441744-marker">1</a></sup> “Stack Overflow Developer Survey 2021,” Stack Overflow, <a href="https://oreil.ly/bngvt"><em class="hyperlink">https://oreil.ly/bngvt</em></a>.</p></div></div></section></body></html>