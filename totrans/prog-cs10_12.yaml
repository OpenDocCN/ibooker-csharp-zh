- en: Chapter 12\. Assemblies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章\. 程序集
- en: So far in this book, I’ve used the term *component* to describe either a library
    or an executable. It’s now time to look more closely at exactly what that means.
    In .NET the unit of deployment for a software component is called an *assembly*,
    and it is typically a *.dll* or *.exe* file. Assemblies are an important aspect
    of the type system, because each type is identified not just by its name and namespace
    but also by its containing assembly. Assemblies provide a kind of encapsulation
    that operates at a larger scale than individual types, thanks to the `internal`
    accessibility specifier, which works at the assembly level.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我使用术语*组件*来描述库或可执行文件。现在是时候更仔细地看看这究竟意味着什么了。在.NET中，软件组件的部署单位称为*程序集*，通常是一个*.dll*或*.exe*文件。由于每个类型不仅由其名称和命名空间标识，还由其包含的程序集标识，程序集对类型系统是一个重要的方面。由于`internal`可访问性限定符在程序集级别工作，程序集提供了一种比单个类型更大尺度的封装。
- en: The runtime provides an *assembly loader*, which automatically finds and loads
    the assemblies a program needs. To ensure that the loader can find the right components,
    assemblies have structured names that include version information, and they can
    optionally contain a globally unique element to prevent ambiguity.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时提供了一个*程序集加载器*，它会自动查找并加载程序需要的程序集。为了确保加载器能够找到正确的组件，程序集有结构化的名称，包括版本信息，并且可以选择性地包含一个全局唯一的元素，以防止歧义。
- en: Most of the C# project types in Visual Studio’s “Create a new project” dialog
    produce a single assembly as their main output, as do most of the project templates
    available from the command line with `dotnet new`. When you build a project, it
    will often put additional files in the output folder too, such as copies of any
    assemblies that your code relies on that are not built into the .NET runtime,
    and other files needed by your application. (For example, a website project will
    typically need to produce CSS and script files in addition to server-side code.)
    But there will usually be a particular assembly that is the build target of your
    project, containing all of the types your project defines along with the code
    those types contain.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio的“创建新项目”对话框中的大多数C#项目类型以及通过`dotnet new`命令行可用的大多数项目模板都会生成一个单独的程序集作为它们的主要输出。当你构建一个项目时，通常也会将额外的文件放在输出文件夹中，例如任何你的代码依赖但未内置到.NET运行时中的程序集的副本，以及应用程序需要的其他文件。（例如，网站项目通常需要生成CSS和脚本文件，除了服务器端代码。）但通常会有一个特定的程序集作为项目的构建目标，其中包含所有项目定义的类型以及这些类型包含的代码。
- en: Anatomy of an Assembly
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序集的解剖学
- en: Assemblies use the Win32 Portable Executable (PE) file format, the same format
    that executables (EXEs) and dynamic link libraries (DLLs) have always used in
    modern versions of Windows.^([1](ch12.xhtml#fn32)) It is “portable” in the sense
    that the same basic file format is used across different CPU architectures. Non-.NET
    PE files are generally architecture-specific, but .NET assemblies often aren’t.
    Even if you’re running .NET on Linux or macOS, it’ll still use this Windows-based
    format—most .NET assemblies run on all supported operating systems, so we use
    the same file format everywhere.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 程序集使用Win32可移植可执行文件（PE）格式，这与现代Windows版本中的可执行文件（EXE）和动态链接库（DLL）使用的格式相同。^([1](ch12.xhtml#fn32))
    它的“可移植性”体现在同一基本文件格式在不同CPU架构上的使用。非.NET PE文件通常是特定于架构的，但.NET程序集通常不是。即使在Linux或macOS上运行.NET，它仍然使用这种基于Windows的格式——大多数.NET程序集可以在所有支持的操作系统上运行，因此我们在所有地方都使用相同的文件格式。
- en: The C# compiler produces an assembly as its output, with an extension of either
    *.dll* or *.exe*. Tools that understand the PE file format will recognize a .NET
    assembly as a valid, but rather dull, PE file. The CLR essentially uses PE files
    as containers for a .NET-specific data format, so to classic Win32 tools, a C#
    DLL will not appear to export any APIs. Remember that C# compiles to a binary
    intermediate language (IL), which is not directly executable. The normal Windows
    mechanisms for loading and running the code in an executable or DLL won’t work
    with IL, because that can run only with the help of the CLR. Similarly, .NET defines
    its own format for encoding metadata and does not use the PE format’s native capability
    for exporting entry points or importing the services of other DLLs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: C# 编译器生成的输出是一个扩展名为 *.dll* 或 *.exe* 的程序集。理解 PE 文件格式的工具会将 .NET 程序集识别为有效但相对单调的
    PE 文件。CLR 实质上将 PE 文件用作包含 .NET 特定数据格式的容器，所以对于经典的 Win32 工具来说，C# DLL 不会显示为导出任何 API。请记住，C#
    编译为一种二进制中间语言（IL），这种语言不能直接执行。Windows 中用于加载和运行可执行文件或 DLL 的正常机制无法处理 IL，因为只有 CLR 能够运行它。类似地，.NET
    定义了自己的格式来编码元数据，并不使用 PE 格式的原生能力来导出入口点或导入其他 DLL 的服务。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The ahead-of-time (AoT) compilation tools in the .NET SDK can add native executable
    code to your assemblies later in the build process, but with *Ready to Run* assemblies
    (as the output of these AoT tools are called), even the embedded native code is
    loaded and executed under the control of the CLR and is directly accessible only
    to managed code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: .NET SDK 中的提前编译（AoT）工具可以在构建过程后期向你的程序集添加本机可执行代码，但是对于 *Ready to Run* 程序集（这些 AoT
    工具的输出称为），即使是嵌入的本机代码也是在 CLR 控制下加载和执行的，并且只能由托管代码直接访问。
- en: In most cases, you won’t build .NET assemblies with an extension of *.exe*.
    Even project types that produce directly runnable outputs (such as console or
    WPF applications) produce a *.dll* as their primary output. They also generate
    an executable file too, but it’s not a .NET assembly. It’s just a bootstrapper
    that starts the runtime and then loads and executes your application’s main assembly.
    By default, the type of bootstrapper you get depends on what OS you build on—for
    example, if you build on Windows, you’ll get a Windows *.exe* bootstrapper, whereas
    on Linux it will be an executable in the ELF format.^([2](ch12.xhtml#idm45884796226928))
    (The exception to this is when you target the .NET Framework. Since that supports
    only Windows, it doesn’t need different bootstrappers for different operating
    systems, so these projects produce a .NET assembly with an extension of *.exe*
    that incorporates the bootstrapper.)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你不会创建扩展名为 *.exe* 的 .NET 程序集。即使是生成直接可运行输出的项目类型（例如控制台或 WPF 应用程序），它们的主要输出也是一个
    *.dll*。它们也会生成一个可执行文件，但不是 .NET 程序集。它只是一个引导程序，启动运行时，然后加载和执行你的应用程序的主程序集。默认情况下，引导程序的类型取决于你构建的操作系统，例如在
    Windows 上构建时，你将得到一个 Windows 的 *.exe* 引导程序，而在 Linux 上则会得到一个 ELF 格式的可执行文件。^([2](ch12.xhtml#idm45884796226928))（唯一的例外是当你针对
    .NET Framework 时。由于它仅支持 Windows，因此不需要为不同操作系统生成不同的引导程序，因此这些项目将生成一个扩展名为 *.exe* 的
    .NET 程序集，并包含引导程序。）
- en: .NET Metadata
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET 元数据
- en: As well as containing the compiled IL, an assembly contains *metadata*, which
    provides a full description of all of the types it defines, whether public or
    private. The CLR needs to have complete knowledge of all the types your code uses
    to be able to make sense of the IL and turn it into running code—the binary format
    for IL frequently refers to the containing assembly’s metadata and is meaningless
    without it. The reflection API, which is the subject of [Chapter 13](ch13.xhtml#ch_reflection),
    makes the information in this metadata available to your code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 除了包含编译的 IL 外，程序集还包含 *元数据*，它提供了所定义的所有类型（无论是公共的还是私有的）的完整描述。CLR 需要完全了解代码使用的所有类型，以便能够理解
    IL 并将其转换为可运行的代码——IL 的二进制格式经常引用包含程序集的元数据，并且没有元数据 IL 是无意义的。反射 API，即 [第 13 章](ch13.xhtml#ch_reflection)
    的主题，使元数据中的信息可用于你的代码。
- en: Resources
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源
- en: You can embed binary resources in a DLL alongside the code and metadata. Client-side
    applications might do this with bitmaps, for example. To embed a file, you can
    add it to a project, select it in Solution Explorer, and then use the Properties
    panel to set its Build Action to Embedded Resource. This embeds a copy of the
    entire file into the component. To extract the resource at runtime, you use the
    `Assembly` class’s `GetManifestResourceStream` method, which is part of the reflection
    API described in [Chapter 13](ch13.xhtml#ch_reflection). However, in practice,
    you wouldn’t normally use this facility directly—most applications use embedded
    resources through a localizable mechanism that I’ll describe later in this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 DLL 中与代码和元数据一起嵌入二进制资源。例如，客户端应用程序可以这样做来处理位图。要嵌入文件，可以将其添加到项目中，在解决方案资源管理器中选择它，然后使用属性面板将其构建操作设置为嵌入的资源。这样会将整个文件的副本嵌入到组件中。在运行时提取资源时，可以使用
    `Assembly` 类的 `GetManifestResourceStream` 方法，该方法是反射 API 的一部分，详见 [第13章](ch13.xhtml#ch_reflection)。然而，在实践中，通常不会直接使用这个功能——大多数应用程序通过本地化机制使用嵌入资源，我将在本章后面描述。
- en: So, in summary, an assembly contains a comprehensive set of metadata describing
    all the types it defines; it holds all of the IL for those types’ methods, and
    it can optionally embed any number of binary streams. This is typically all packaged
    up into a single PE file. However, that is not always the whole story.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结来说，一个程序集包含了描述其定义的所有类型的全面元数据集合；它保存了所有这些类型方法的 IL，并且可以选择性地嵌入任意数量的二进制流。这通常被打包成一个单独的
    PE 文件。然而，这并不总是故事的全部。
- en: Multifile Assemblies
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多文件程序集
- en: The old (but still supported) Windows-only .NET Framework allows an assembly
    to span multiple files. You can split the code and metadata across multiple *modules*,
    and it is also possible for some binary streams that are logically embedded in
    an assembly to be put in separate files. This feature is rarely used, and neither
    .NET Core nor its successors (including the current version of .NET) support it.
    However, it’s necessary to know about it because some of its consequences persist.
    In particular, parts of the design of the reflection API ([Chapter 13](ch13.xhtml#ch_reflection))
    make no sense unless you know about this feature.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 老式（但仍受支持的）仅限 Windows 的 .NET Framework 允许一个程序集跨多个文件。你可以将代码和元数据分割到多个 *模块* 中，并且还可以将逻辑上嵌入到程序集中的某些二进制流放置在单独的文件中。这个特性很少被使用，并且
    .NET Core 及其后续版本（包括当前版本的 .NET）不支持它。然而，有必要了解它，因为一些后果仍然存在。特别是，反射 API 的设计的某些部分（见
    [第13章](ch13.xhtml#ch_reflection)）在不了解这个特性的情况下是没有意义的。
- en: With a multifile assembly, there’s always one main file that represents the
    assembly. This will be a PE file, and it contains a particular element of the
    metadata called the *assembly manifest*. This is not to be confused with the Win32-style
    manifest that most executables contain. The assembly manifest is just a description
    of what’s in the assembly, including a list of any external modules or other external
    files; in a multimodule assembly, the manifest describes which types are defined
    in which files. When writing code that uses the types in an assembly directly,
    you generally didn’t need to care whether it was split across multiple modules,
    because the runtime would inspect the manifest and automatically load whichever
    modules were needed. Multiple modules were typically only an issue for code that
    inspected the structure of a component using reflection.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在多文件程序集中，总是有一个代表程序集的主文件。这将是一个 PE 文件，并包含元数据的一个特定元素，称为 *程序集清单*。这不应与大多数可执行文件包含的
    Win32 风格清单混淆。程序集清单只是对程序集内容的描述，包括任何外部模块或其他外部文件的列表；在多模块程序集中，清单描述了哪些类型定义在哪些文件中。当编写直接使用程序集中类型的代码时，通常不需要关心它是否跨多个模块，因为运行时会检查清单并自动加载所需的模块。多模块通常只对使用反射检查组件结构的代码是一个问题。
- en: Other PE Features
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他 PE 特性
- en: Although C# does not use the classic Win32 mechanisms for representing code
    or exporting APIs in EXEs and DLLs, there are still a couple of old-school features
    of the PE format that assemblies can use.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 C# 不使用经典的 Win32 机制来表示代码或在 EXE 和 DLL 中导出 API，但程序集仍然可以使用 PE 格式的几个老式特性。
- en: Win32-style resources
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Win32 风格资源
- en: .NET defines its own mechanism for embedding binary resources, and a localization
    API built on top of that, so for the most part it makes no use of the PE file
    format’s intrinsic support for embedding resources. There’s nothing stopping you
    from putting classic Win32-style resources into a .NET component—the C# compiler
    offers various command-line switches that do this. However, there’s no .NET API
    for accessing these resources at runtime from within your application, which is
    why you’d normally use .NET’s own resource system. But there are some exceptions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 定义了自己的二进制资源嵌入机制，并在此基础上构建了本地化 API，因此在大多数情况下，它不使用 PE 文件格式固有的嵌入资源支持。并没有什么阻止你将经典的
    Win32 风格资源放入 .NET 组件中——C# 编译器提供了各种命令行开关来实现这一点。然而，从你的应用程序中运行时访问这些资源没有 .NET API，这就是为什么你通常会使用
    .NET 自己的资源系统。但也有一些例外情况。
- en: Windows expects to find certain resources in executables. For example, it defines
    a way to embed version information as an unmanaged resource. C# assemblies normally
    do this, but you don’t need to define a version resource explicitly. The compiler
    can generate one for you, as I show in [“Version”](#version). This ensures that
    if an end user looks at your assembly’s properties in Windows File Explorer, they
    will be able to see the version number. (By convention, .NET assemblies typically
    contain this Win32-style version information whether they target just Windows
    or can run on any platform.)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 期望在可执行文件中找到某些资源。例如，它定义了一种将版本信息作为非托管资源嵌入的方法。C# 程序集通常会这样做，但你不需要显式定义版本资源。编译器可以为你生成一个，就像我在
    [“Version”](#version) 中展示的那样。这确保了如果最终用户在 Windows 文件资源管理器中查看你的程序集属性，他们将能够看到版本号。（按照惯例，.NET
    程序集通常包含这种 Win32 风格的版本信息，无论它们是否仅针对 Windows 或可以在任何平台上运行。）
- en: Windows *.exe* files typically contain two additional Win32 resources. You may
    want to define a custom icon for your application to control how it appears on
    the task bar or in Windows File Explorer. This requires you to embed the icon
    in the Win32 way, because File Explorer doesn’t know how to extract .NET resources.
    You can do this by adding an `<ApplicationIcon>` property to your *.csproj* file.
    If you’re using Visual Studio, it provides a way to set this through the project’s
    properties pages. Also, if you’re writing a classic Windows desktop application
    or console application (whether written with .NET or not), it should supply an
    application manifest. Without this, Windows will presume that your application
    was written before 2006^([3](ch12.xhtml#fn34)) and will modify or disable certain
    features for backward compatibility. The manifest also needs to be present if
    you are writing a desktop application and you want it to pass certain Microsoft
    certification requirements. This kind of manifest has to be embedded as a Win32
    resource. The .NET SDK will add a manifest with default settings by default, but
    if you need to customize it (e.g., because you’re writing a console application
    that will need to run with elevated privileges), you can specify a manifest with
    an `<ApplicationManifest>` property in your *.csproj* file (or again, with the
    project properties pages in Visual Studio).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Windows *.exe* 文件通常包含两个额外的 Win32 资源。你可能希望为你的应用程序定义一个自定义图标，以控制它在任务栏或 Windows
    文件资源管理器中的显示方式。这需要你以 Win32 的方式嵌入图标，因为文件资源管理器不知道如何提取 .NET 资源。你可以通过在你的 *.csproj*
    文件中添加一个 `<ApplicationIcon>` 属性来实现这一点。如果你使用 Visual Studio，它提供了一种通过项目属性页来设置这一点的方式。另外，如果你正在编写经典的
    Windows 桌面应用程序或控制台应用程序（无论是否使用 .NET 编写），它应该提供一个应用程序清单。没有这个清单，Windows 将假定你的应用程序是在
    2006 年之前编写的^([3](ch12.xhtml#fn34))，并会修改或禁用某些向后兼容性功能。如果你正在编写一个桌面应用程序并且希望它通过某些 Microsoft
    认证要求，那么这种清单也必须存在并作为 Win32 资源嵌入。默认情况下，.NET SDK 会添加一个具有默认设置的清单，但如果需要自定义（例如，因为你正在编写一个需要以提升权限运行的控制台应用程序），你可以在你的
    *.csproj* 文件中指定一个具有 `<ApplicationManifest>` 属性的清单（或者再次通过 Visual Studio 的项目属性页）。
- en: Remember that with .NET and .NET Core, the main assembly is a *.dll*, even for
    Windows desktop applications, and when you target Windows, the build process produces
    a separate *.exe* that launches the .NET runtime and then loads that assembly.
    As far as Windows is concerned, this bootstrapper is your application, so the
    icon and manifest resources will end up in this bootstrapping assembly. But if
    you target the .NET Framework, there will be no separate bootstrapper, so these
    resources end up in the main assembly.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在.NET和.NET Core中，主要的程序集是一个*.dll*，即使是用于Windows桌面应用程序，当你目标是Windows时，构建过程也会生成一个单独的*.exe*文件，它启动.NET运行时，然后加载该程序集。在Windows看来，这个引导程序就是你的应用程序，因此图标和清单资源将最终出现在这个引导程序集中。但如果你的目标是.NET
    Framework，就不会有单独的引导程序，因此这些资源最终会出现在主要的程序集中。
- en: Console versus GUI
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制台与GUI
- en: Windows makes a distinction between console applications and Windows applications.
    To be precise, the PE format requires a *.exe* file to specify a *subsystem*,
    and back in the old days of Windows NT, this enabled the use of multiple operating
    system *personalities*—early versions included a POSIX subsystem, for example.
    So these days, PE files target one of just three subsystems, and one of those
    is for kernel-mode device drivers. The two user-mode options used today select
    between Windows graphical user interface (GUI) and Windows console applications.
    The principal difference is that Windows will show a console window when running
    the latter (or if you run it from a command prompt, it will just use the existing
    console window), but a Windows GUI application does not get a console window.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Windows对控制台应用程序和Windows应用程序进行了区分。准确地说，PE格式要求*.exe*文件指定一个*子系统*，在Windows NT早期的日子里，这使得可以使用多个操作系统*子系统*，例如早期版本包括POSIX子系统。因此，如今的PE文件只针对三个子系统之一，其中之一用于内核模式设备驱动程序。今天使用的两个用户模式选项在Windows图形用户界面(GUI)和Windows控制台应用程序之间进行选择。主要区别在于当运行后者时Windows将显示控制台窗口（或者如果从命令提示符运行它，则只使用现有的控制台窗口），但Windows
    GUI应用程序不会获得控制台窗口。
- en: You can select between these subsystems with an `<OutputType>` property in your
    project file set to `Exe` or `WinExe`, or in Visual Studio you can use the “Output
    type” drop-down list in the project properties. (The output type defaults to `Library`,
    or “Class Library” in Visual Studio’s UI. This builds a DLL, but since the subsystem
    is determined when a process launches, it makes no difference whether a DLL targets
    the Windows Console or Windows GUI subsystem. The `Library` setting always targets
    the former.) If you target the .NET Framework, this subsystem setting applies
    to the *.exe* file that is built as your application’s main assembly, and with
    newer versions of .NET, it will apply to the bootstrapper *.exe*. (As it happens,
    it will also apply to the main assembly *.dll* that the bootstrapper loads, but
    this has no effect because the subsystem is determined by the *.exe* for which
    the process is launched.)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在项目文件中设置`<OutputType>`属性为`Exe`或`WinExe`来在这些子系统之间进行选择，或者在Visual Studio中你可以在项目属性的“输出类型”下拉列表中进行选择。（输出类型默认为`Library`，或者在Visual
    Studio的UI中为“类库”。这会构建一个DLL，但由于子系统是在进程启动时确定的，因此DLL是否目标是Windows控制台或Windows GUI子系统是没有区别的。`Library`设置总是针对前者。）如果你的目标是.NET
    Framework，这个子系统设置将应用于作为你的应用程序主要程序集构建的*.exe*文件，而对于较新版本的.NET，则会应用于引导程序*.exe*。（碰巧的是，它也会应用于引导程序加载的主程序集*.dll*，但这不会产生影响，因为子系统是根据启动进程的*.exe*确定的。）
- en: Type Identity
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型标识
- en: As a C# developer, your first point of contact with assemblies will usually
    be the fact that they form part of a type’s identity. When you write a class,
    it will end up in an assembly. When you use a type from the runtime libraries
    or from some other library, your project will need a reference to the assembly
    that contains the type before you can use it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名C#开发者，你通常会首先接触到的是程序集（assemblies）构成类型标识的一部分这一事实。当你编写一个类时，它将成为一个程序集的一部分。当你使用来自运行时库或其他库的类型时，你的项目需要引用包含该类型的程序集才能使用它。
- en: This is not always obvious when using system types. The build system automatically
    adds references to various runtime library assemblies, so most of the time, you
    will not need to add a reference before you can use a runtime library type, and
    since you do not normally refer to a type’s assembly explicitly in the source
    code, it’s not immediately obvious that the assembly is a mandatory part of what
    it takes to pinpoint a type. But despite not being explicit in the code, the assembly
    has to be part of a type’s identity, because there’s nothing stopping you or anyone
    else from defining new types that have the same name as existing types. For example,
    you could define a class called `System.String` in your project. This is a bad
    idea, and the compiler will warn you that this introduces ambiguity, but it won’t
    stop you. And even though your class will have the exact same fully qualified
    name as the built-in string type, the compiler and the runtime can still distinguish
    between these types.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用系统类型时，这并不总是显而易见的。构建系统会自动添加对各种运行时库程序集的引用，因此大多数情况下，您在使用运行时库类型之前不需要添加引用，并且由于通常不会在源代码中明确引用类型的程序集，因此很难立即意识到程序集是确定类型所需的必要部分。但尽管在代码中并没有明确指定，程序集必须作为类型身份的一部分，因为没有任何东西会阻止您或其他任何人定义与现有类型同名的新类型。例如，您可以在项目中定义一个名为`System.String`的类。这是一个不好的主意，编译器会警告您这样会引入歧义，但不会阻止您这样做。尽管您的类将具有与内置字符串类型完全相同的完全限定名称，编译器和运行时仍然可以区分这些类型。
- en: Whenever you use a type, either explicitly by name (e.g., in a variable or parameter
    declaration) or implicitly through an expression, the C# compiler knows exactly
    what type you’re referring to, meaning it knows which assembly defined the type.
    So it is able to distinguish between the `System.String` intrinsic to .NET and
    a `System.String` unhelpfully defined in your own component. The C# scoping rules
    mean that an explicit reference to `System.String` identifies the one that you
    defined in your own project, because local types effectively hide ones of the
    same name in external assemblies. If you use the `string` keyword, that always
    refers to the built-in type. You’ll also be using the built-in type when you use
    a string literal, or if you call an API that returns a string. [Example 12-1](#what_type_is_a_piece_of_string)
    illustrates this—it defines its own `System.String` and then uses a generic method
    that displays the type and assembly name for the static type of whatever argument
    you pass it. (This uses the reflection API, which is described in [Chapter 13](ch13.xhtml#ch_reflection).)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您使用一个类型时，无论是通过显式名称（例如在变量或参数声明中）还是通过表达式隐式使用，C#编译器都确切地知道您所引用的类型，这意味着它知道哪个程序集定义了该类型。因此，它能够区分.NET内置的`System.String`和您自己组件中不明智定义的`System.String`。C#的作用域规则意味着对`System.String`的显式引用将标识出您在自己项目中定义的类型，因为局部类型有效地隐藏了外部程序集中同名的类型。如果使用`string`关键字，那总是指向内置类型。当您使用字符串字面量或调用返回字符串的API时，也将使用内置类型。[示例 12-1](#what_type_is_a_piece_of_string)展示了这一点——它定义了自己的`System.String`，然后使用了一个显示传递给它的参数的静态类型和程序集名称的通用方法。（这使用了反射API，详见[第13章](ch13.xhtml#ch_reflection)。）
- en: Example 12-1\. What type is a piece of string?
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-1\. 一个字符串是什么类型？
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `Main` method in this example tries each of the ways of working with strings
    I just described, and it writes out the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中的`Main`方法尝试了我刚刚描述的每种处理字符串的方法，并写出了以下内容：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The explicit use of `System.String` ended up with my type, and the rest all
    used the system-defined string type. This demonstrates that the C# compiler can
    cope with multiple types with the same name. This also shows that IL is able to
    make that distinction. IL’s binary format ensures that every reference to a type
    identifies the containing assembly. But just because you can create and use multiple
    identically named types doesn’t mean you should. Because you do not usually name
    the containing assembly explicitly in C#, it’s a particularly bad idea to introduce
    pointless collisions by defining, say, your own `System.String` class. (As it
    happens, in a pinch you can resolve this sort of collision if you really need
    to—see the sidebar [“Extern Aliases”](#extern_aliases) for details—but it’s better
    to avoid it.)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 明确使用 `System.String` 最终导致了我的类型，并且其余部分都使用了系统定义的字符串类型。这表明 C# 编译器能够处理具有相同名称的多个类型。这也显示了
    IL 能够进行区分。IL 的二进制格式确保对类型的每个引用都标识了包含程序集。但仅仅因为你可以创建和使用多个同名类型，并不意味着你应该这样做。因为在 C#
    中通常不会显式命名包含程序集，所以通过定义自己的 `System.String` 类来引入无意义的冲突是一个特别糟糕的主意。（恰好，在必要时你可以解决这种冲突——详见边栏
    [“外部别名”](#extern_aliases) ——但最好避免这样做。）
- en: By the way, if you run [Example 12-1](#what_type_is_a_piece_of_string) on .NET
    Framework, you’ll see `mscorlib` in place of `System.Private.CoreLib`. .NET Core
    changed which assemblies many runtime library types live in. You might be wondering
    how this can work with .NET Standard, which enables you to write a single DLL
    that can run on .NET Framework, .NET Core, and .NET. How could a .NET Standard
    component correctly identify a type that lives in different assemblies on different
    targets? The answer is that .NET has a *type forwarding* feature in which references
    to types in one assembly can be redirected to some other assembly at runtime.
    (A type forwarder is just an assembly-level attribute that describes where the
    real type definition can be found. Attributes are the subject of [Chapter 14](ch14.xhtml#ch_attributes).)
    .NET Standard components reference neither `mscorlib` nor `System.Private.CoreLib`—they
    are built as though runtime library types are defined in an assembly called `netstandard`.
    Each .NET runtime supplies a `netstandard` implementation that forwards to the
    appropriate types at runtime. In fact, even code built directly for .NET Core
    or .NET often ends up using type forwarding. If you inspect the compiled output,
    you’ll find that it expects most runtime library types to be defined in an assembly
    called `System​.Runtime`, and it’s only through type forwarding that these end
    up using types in `System.Private.CoreLib`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，如果你在 .NET Framework 上运行 [示例 12-1](#what_type_is_a_piece_of_string)，你会看到
    `mscorlib` 而不是 `System.Private.CoreLib`。.NET Core 改变了许多运行库类型所在的程序集。你可能会想知道这如何与
    .NET Standard 兼容，它使你能够编写一个单独的 DLL，在 .NET Framework、.NET Core 和 .NET 上都可以运行。一个
    .NET Standard 组件如何能正确识别在不同目标上位于不同程序集中的类型呢？答案是 .NET 具有一种*类型转发*特性，其中对一个程序集中类型的引用可以在运行时重定向到其他程序集中。（类型转发器只是描述真实类型定义所在位置的一个程序集级别属性。属性是
    [第14章](ch14.xhtml#ch_attributes) 的主题。）.NET Standard 组件既不引用 `mscorlib` 也不引用 `System.Private.CoreLib`
    ——它们的构建就好像运行库类型定义在一个名为 `netstandard` 的程序集中一样。每个 .NET 运行时都提供了一个 `netstandard` 实现，在运行时将转发到相应的类型。事实上，即使是直接为
    .NET Core 或 .NET 构建的代码，最终也会使用类型转发。如果你检查编译输出，你会发现它期望大多数运行库类型在名为 `System.Runtime`
    的程序集中定义，并且仅通过类型转发才能使用 `System.Private.CoreLib` 中的类型。
- en: If it’s a bad idea to have multiple types with the same name, why does .NET
    make it possible in the first place? In fact, supporting name collisions was not
    the goal; it’s just a side effect of the fact that .NET makes the assembly part
    of the type. The assembly needs to be part of the type definition so that the
    CLR can know which assembly to load for you at runtime when you first use some
    feature of that type.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在同一名称下有多个类型是个坏主意，那为什么 .NET 一开始就允许这种可能性呢？事实上，支持名称冲突并不是目标；这只是 .NET 将程序集作为类型的一部分的副作用。程序集需要成为类型定义的一部分，这样
    CLR 在你首次使用该类型的功能时就能知道要加载哪个程序集。
- en: Loading Assemblies
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载程序集
- en: You may have been alarmed earlier when I said that the build system automatically
    adds references to all the runtime library components available on your target
    framework. Perhaps you wondered how you might go about removing some of these
    in the name of efficiency. As far as runtime overhead is concerned, you do not
    need to worry. The C# compiler effectively ignores any references to built-in
    assemblies that your project never uses, so there’s no danger of loading DLLs
    that you don’t need. (It is, however, worth removing references to unused components
    that are *not* built into .NET to avoid copying unneeded DLLs when you deploy
    the app—there’s no sense in making deployments larger than they need to be. But
    unused references to DLLs that are already installed as part of .NET cost you
    nothing.)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说构建系统自动向目标框架添加所有可用的运行库组件的引用时，你可能会感到惊讶。也许你会想知道如何在效率名义上删除其中一些。就运行时开销而言，你无需担心。C#
    编译器会有效地忽略你的项目从未使用过的内置程序集的任何引用，因此不会加载你不需要的 DLL 的风险。然而，删除对未构建为 .NET 的未使用组件的引用是值得的——这样在部署应用程序时可以避免复制不需要的
    DLL，毕竟不必使部署变得比必要时更大。但对于已作为 .NET 的一部分安装的未使用 DLL 的引用则毫无成本。
- en: Even if C# didn’t strip out unused references at compile time, there would still
    be no risk of unnecessary loading of unused DLLs. The CLR does not attempt to
    load assemblies until your application first needs them. Most applications do
    not exercise every possible code path each time they execute, so it’s fairly common
    for significant portions of the code in your application not to run. Your program
    may even finish its work having left entire classes unused—perhaps classes that
    get involved only when an unusual error condition arises. If the only place you
    use a particular assembly is inside a method of such a class, that assembly won’t
    get loaded.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在编译时 C# 没有剥离未使用的引用，也不会存在加载未使用的 DLL 的风险。CLR 不会在应用程序首次需要它们之前加载程序集。大多数应用程序在每次执行时并不会涵盖所有可能的代码路径，因此你的应用程序中有相当大部分的代码可能并不会运行。你的程序甚至可能在完成工作时留下整个未使用的类——也许这些类只在出现异常错误条件时才会参与。如果你只在这类方法内部使用某个程序集，那么这个程序集就不会被加载。
- en: The CLR has some discretion for deciding exactly what it means to “use” a particular
    assembly. If a method contains any code that refers to a particular type (e.g.,
    it declares a variable of that type or it contains expressions that use the type
    implicitly), then the CLR may consider that type to be used when that method first
    runs even if you don’t get to the part that really uses it. Consider [Example 12-2](#type_loading_and_conditional_execution).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: CLR 对于决定“使用”特定程序集有一些自主权。如果一个方法包含任何引用特定类型的代码（例如声明该类型的变量或包含隐式使用该类型的表达式），那么当该方法首次运行时
    CLR 可能会认为该类型已被使用，即使你并未真正使用它。参见 [示例 12-2](#type_loading_and_conditional_execution)。
- en: Example 12-2\. Type loading and conditional execution
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-2\. 类型加载和条件执行
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Depending on its argument, this function either returns an object provided by
    the runtime libraries’ `StringComparer` or constructs a new object of type `MyCustom​Com⁠parer`.
    The `StringComparer` type is defined in the same assembly as core types such as
    `int` and `string`, so that will have been loaded when our program started. But
    suppose the other type, `MyCustomComparer`, was defined in a separate assembly
    from my application, called `ComparerLib`. Obviously, if this `GetComparer` method
    is called with an argument of `false`, the CLR will need to load `ComparerLib`
    if it hasn’t already. But what’s slightly more surprising is that it will probably
    load `ComparerLib` the first time this method is called even if the argument is
    `true`. To be able to JIT compile this `GetComparer` method, the CLR will need
    access to the `MyCustomComparer` type definition—for one thing it will need to
    check that the type really has a zero-argument constructor. (Obviously [Example 12-2](#type_loading_and_conditional_execution)
    wouldn’t compile in that case, but it’s possible that code was compiled against
    a different version of `ComparerLib` than is present at runtime.) The JIT compiler’s
    operation is an implementation detail, so it’s not fully documented and could
    change from one version to the next, but it seems to operate one method at a time.
    So simply invoking this method is likely to be enough to trigger the loading of
    the `ComparerLib` assembly.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 根据其参数不同，此函数会返回运行库提供的`StringComparer`对象，或构造一个类型为`MyCustom​Com⁠parer`的新对象。`StringComparer`类型在与核心类型（如`int`和`string`）相同的程序集中定义，因此在我们的程序启动时已加载。但假设另一类型`MyCustomComparer`定义在与我的应用程序分离的名为`ComparerLib`的程序集中。显然，如果以`false`作为参数调用此`GetComparer`方法，CLR将需要在未加载时加载`ComparerLib`。但更令人惊讶的是，即使参数为`true`，CLR也可能在首次调用此方法时加载`ComparerLib`。为了能够JIT编译此`GetComparer`方法，CLR需要访问`MyCustomComparer`类型定义，因为它需要检查该类型确实有一个无参数构造函数。（显然，如果如此，[Example 12-2](#type_loading_and_conditional_execution)将无法编译，但可能的情况是该代码针对的是与运行时不同版本的`ComparerLib`。）JIT编译器的操作是实现细节，因此并未完全记录，且可能因版本而异，但似乎是逐个方法操作。因此，仅调用此方法很可能足以触发`ComparerLib`程序集的加载。
- en: This raises the question of how .NET finds assemblies. If assemblies can be
    loaded implicitly as a result of running a method, we don’t necessarily have a
    chance to tell the runtime where to find them. So .NET has a mechanism for this.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了.NET如何找到程序集的问题。如果程序集可以作为运行方法的结果隐式加载，我们未必有机会告诉运行时在哪里找到它们。因此，.NET有一种机制来处理这个问题。
- en: Assembly Resolution
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序集解析
- en: 'When the runtime needs to load an assembly, it goes through a process called
    *assembly resolution*. In some cases you will tell .NET to load a particular assembly
    (e.g., when you first run an application), but the majority are loaded implicitly.
    The exact mechanism depends on a couple of factors: whether you target .NET/.NET
    Core or the older .NET Framework, and, if the former, whether your application
    is *self-contained*.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行时需要加载一个程序集时，它会经历一个称为*程序集解析*的过程。在某些情况下，你会告诉.NET加载特定的程序集（例如，当你首次运行一个应用程序时），但大部分是隐式加载的。具体的机制取决于几个因素：你是否针对.NET/.NET
    Core或旧版.NET Framework，以及如果是前者，你的应用程序是否是*自包含*的。
- en: '.NET (and its predecessor, .NET Core) supports two deployment options for applications:
    *self-contained* and *framework-dependent*. When you publish a self-contained
    application, it includes a complete copy of the runtime and the runtime libraries.
    [Example 12-3](#publishing_self_contained_app) shows the command line for building
    an application this way—if you run this from the folder containing a *.csproj*
    file, it will compile the project and then produce a *publish* folder containing
    your compiled code and a complete copy of a suitable version of .NET. (The version
    will depend on your project’s configured target framework. Generally, your project
    file will specify a major and minor version, e.g., `net6.0`, and then the SDK
    will copy the latest patch version that is installed on your machine. The available
    versions will be determined by what versions of the .NET SDK you have installed.)
    The `-r` switch indicates the platform and processor architecture to build for.
    The CLR for Linux is necessarily somewhat different from the one for Windows,
    and the macOS one is different again. Moreover, for each of the supported operating
    systems there are versions of .NET available for more than one CPU architecture.
    (64-bit Intel and 64-bit ARM is supported for all three. Windows and Linux additionally
    get .NET runtimes targeting 32-bit Intel architecture CPUs and 32-bit ARM CPUs.)
    The parts of the .NET runtime that contain native runnable binary code are different
    in each case, so when you ask for a self-contained deployment, the build system
    needs to know which one to copy. The `-r` switch specifies this with something
    called a *Runtime Identifier* (RID). [Example 12-3](#publishing_self_contained_app)
    selects the runtime for Windows running on 64-bit Intel architecture CPUs. (It
    is possible for RIDs to be more detailed to indicate that your application has
    minimum version requirements. For example, the first part can be `win10` instead
    of just `win`; for macOS we could use `osx-x64`, but we can be more specific,
    e.g., `osx.10.15-x64`.)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: .NET（及其前身 .NET Core）支持应用程序的两种部署选项：*自包含* 和 *依赖于框架*。当你发布一个自包含的应用程序时，它会包括运行时和运行时库的完整副本。[示例 12-3](#publishing_self_contained_app)
    显示了以这种方式构建应用程序的命令行——如果你从包含 *.csproj* 文件的文件夹运行此命令，它将编译项目，然后生成一个 *publish* 文件夹，其中包含编译代码和适当版本
    .NET 的完整副本。（版本将取决于项目配置的目标框架。通常，项目文件会指定主要和次要版本，例如 `net6.0`，然后 SDK 将复制安装在您的计算机上的最新修补版本。可用版本将由您安装的
    .NET SDK 版本决定。）`-r` 开关指定要构建的平台和处理器架构。Linux 的 CLR 与 Windows 的不同，而 macOS 的则又不同。此外，对于每个支持的操作系统，都有适用于多个
    CPU 架构的 .NET 运行时可用。所有三个操作系统都支持 64 位 Intel 和 64 位 ARM。Windows 和 Linux 还额外获取面向 32
    位 Intel 架构 CPU 和 32 位 ARM CPU 的 .NET 运行时。包含本地可执行二进制代码的 .NET 运行时部分在每种情况下都不同，因此当您要求自包含部署时，构建系统需要知道要复制哪一个。`-r`
    开关使用称为 *Runtime Identifier*（RID）的东西来指定这一点。[示例 12-3](#publishing_self_contained_app)
    选择了适用于运行 Windows 的 64 位 Intel 架构 CPU 的运行时。（RID 可能更详细，以指示您的应用程序具有最低版本要求。例如，第一部分可以是
    `win10` 而不仅仅是 `win`；对于 macOS，我们可以使用 `osx-x64`，但我们可以更具体，例如 `osx.10.15-x64`。）
- en: Example 12-3\. Publishing a self-contained application
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-3\. 发布自包含应用程序
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When you build this way, assembly resolution is pretty straightforward because
    everything—your application’s own assemblies, any external libraries you depend
    on, all of the system assemblies built into .NET, and the CLR itself—ends up in
    one folder. (At the time of writing, that amounts to a little over 68 MB for a
    simple “Hello, World!” console application for this target architecture on .NET
    6.0.)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当你以这种方式构建时，程序集解析变得非常简单，因为所有内容——你的应用程序自身的程序集、你依赖的任何外部库、所有内置于 .NET 中的系统程序集以及 CLR
    本身——都会结束在一个文件夹中。（在撰写本文时，对于 .NET 6.0 的目标架构的一个简单的“Hello, World!”控制台应用程序，总计约为 68
    MB 左右。）
- en: There are two main advantages to self-contained deployment. First, there is
    no need to install .NET on target machines—the application can just run directly
    because it contains its own copy of .NET. Second, you know exactly what version
    of .NET and which versions of all DLLs you are running against. Microsoft goes
    to great lengths to ensure backward compatibility with new releases, but breaking
    changes can sometimes occur, and a self-contained deployment can be one way out
    if you find that your application stops working after an update to .NET. With
    self-contained deployment, unless the application directs the CLR to look elsewhere,
    everything will load from the application folder, including all assemblies built
    into .NET.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 自包含部署有两个主要优点。首先，在目标机器上不需要安装 .NET——应用程序可以直接运行，因为它包含自己的 .NET 副本。其次，您知道确切运行的 .NET
    版本和所有 DLL 的版本。微软非常努力确保向后兼容性与新版本，但有时可能会发生破坏性更改，如果在更新 .NET 后发现应用程序停止工作，自包含部署可能是一个出路。通过自包含部署，除非应用程序指示
    CLR 在其他地方查找，否则一切都将从应用程序文件夹加载，包括所有内置到 .NET 的程序集。
- en: But what if you don’t want to put an entire copy of .NET into your build output?
    The default build behavior for applications is to create a framework-dependent
    executable. (There’s a variation on this called *framework-dependent deployment*,
    which is almost the same thing, except it omits the bootstrapper executable. To
    run a framework-dependent deployment, you will need to use the `dotnet` command-line
    tool to launch the runtime, which will then run your application. This has the
    advantage of being completely platform independent; the bootstrapper in a framework-dependent
    executable deployment is always OS specific. But it is less convenient—you can’t
    run the build output without the `dotnet` tool.) In this case, your code relies
    on a suitable version of .NET already being installed on the machine. The build
    output will contain your own application assembly, and may contain assemblies
    your application depends on, but it will not contain any of the libraries built
    into .NET.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您不想将整个 .NET 复制到生成的输出中呢？应用程序的默认构建行为是创建一个依赖框架的可执行文件。（有一个称为*依赖框架部署*的变体，几乎相同，只是省略了启动器可执行文件。要运行依赖框架部署，您需要使用`dotnet`命令行工具启动运行时，然后运行您的应用程序。这样做的好处是完全与平台无关；依赖框架可执行部署中的启动器始终特定于操作系统。但这样做不太方便——您不能在没有`dotnet`工具的情况下运行生成的输出。）在这种情况下，您的代码依赖于机器上已安装合适版本的
    .NET。生成的输出将包含您自己的应用程序程序集，并可能包含您的应用程序依赖的程序集，但不会包含任何内置到 .NET 的库。
- en: Framework-dependent applications necessarily use a more complex resolution mechanism
    than self-contained ones. When such an application starts up, it will first determine
    exactly which version of .NET to run. This won’t necessarily be the version your
    application was built against, and there are various options to configure exactly
    which is chosen. By default, if the same `*Major*.*Minor*` version is available,
    that will be used. E.g., if a framework-dependent application built for .NET Core
    5.0 runs on a machine with .NET Core versions `3.1.20`, `5.0.11`, and `6.0.0`
    installed, it will run on `5.0.11`. In cases where such a match isn’t available,
    but a major version number match is, it will typically roll forward to that; e.g.,
    if the app targets 3.0, and the machine has only `3.1.20`, it will run on `3.1.20`.
    It is also possible to run on a higher major version number than the app was built
    against (e.g., build for 3.1 but run on 6.0) but only by explicitly requesting
    this through configuration.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖框架应用程序必然使用比自包含应用程序更复杂的解析机制。当这样的应用程序启动时，它首先确定要运行的 .NET 版本。这不一定是您的应用程序构建的版本，并且有各种选项可以配置确切选择的版本。默认情况下，如果可用相同的`*Major*.*Minor*`版本，将使用该版本。例如，如果为
    .NET Core 5.0 构建的依赖框架应用程序在安装了 .NET Core 版本为 `3.1.20`、`5.0.11` 和 `6.0.0` 的机器上运行，则会运行在
    `5.0.11` 上。在找不到这样的匹配的情况下，但是有一个主要版本号匹配的情况下，通常会向前滚动到那个版本；例如，如果应用程序目标为 3.0，而机器上只有
    `3.1.20`，则会在 `3.1.20` 上运行。也可以通过配置显式请求运行高于应用程序构建的主要版本号的更高版本号（例如，为 3.1 构建但在 6.0
    上运行），但是只有通过配置显式请求才能做到这一点。
- en: The chosen runtime version selects not just the CLR but also the assemblies
    making up the parts of the runtime libraries built into .NET. You can typically
    find all the installed runtime versions in the *C:\Program Files\dotnet\shared\Micro⁠soft.NET​Core.App\*
    folder on Windows, */usr/local/share/dotnet/shared/Microsoft​.NET⁠Core.App* on
    macOS, or */usr/share/dotnet/shared/Microsoft.NETCore.App* on Linux, with version-based
    subfolders such as *6.0.0*. (You should not rely on these paths—the files may
    move in future versions of .NET.) The assembly resolution process will look in
    this version-specific folder, and this is how framework-dependent applications
    get to use built-in .NET assemblies.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所选的运行时版本不仅选择CLR，还包括构成内置于.NET中的运行时库部分的程序集。你通常可以在Windows的*C:\Program Files\dotnet\shared\Micro⁠soft.NET​Core.App\*文件夹中找到所有已安装的运行时版本，在macOS上为*/usr/local/share/dotnet/shared/Microsoft​.NET⁠Core.App*，在Linux上为*/usr/share/dotnet/shared/Microsoft.NETCore.App*，其子文件夹基于版本命名，比如*6.0.0*。（你不应依赖这些路径——文件在未来版本的.NET中可能会移动。）程序集解析过程将查找这个特定版本的文件夹，这就是框架相关应用程序如何使用内置的.NET程序集。
- en: If you poke around these folders, you may notice other folders under *shared*,
    such as *Microsoft.AspNetCore.App*. It turns out that this mechanism is not just
    for the runtime libraries built into .NET—it is also possible to install the assemblies
    for whole frameworks. .NET applications declare that they are using a particular
    application framework. (The build tools automatically produce a file called *YourApp.runtimeconfig.json*
    in your build output declaring the framework you are using. Console apps specify
    `Microsoft.NETCore.App`, whereas a web application will specify `Microsoft.AspNetCore.App`.)
    This enables applications that target specific Microsoft frameworks not to have
    to include a complete copy of all of the framework’s DLLs even though that framework
    is not part of .NET itself.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这些文件夹里查找，你可能会注意到*shared*下面的其他文件夹，比如*Microsoft.AspNetCore.App*。事实证明，这种机制不仅适用于内置于.NET中的运行时库——也可以安装整个框架的程序集。.NET应用程序声明它们使用特定的应用程序框架。（构建工具会自动在构建输出中生成一个名为*YourApp.runtimeconfig.json*的文件，声明你正在使用的框架。控制台应用程序指定`Microsoft.NETCore.App`，而Web应用程序则指定`Microsoft.AspNetCore.App`。）这使得针对特定Microsoft框架的应用程序不必包含所有框架DLL的完整副本，即使该框架并非.NET本身的一部分。
- en: If you install the plain .NET runtime, you will get just `Microsoft.NETCore.App`
    and none of the application frameworks. So applications that target frameworks
    such as ASP.NET Core or WPF will be unable to run if they are built in the default
    way, because that presumes that those frameworks will be preinstalled on target
    machines, and the assembly resolution process will fail to find framework-specific
    components. The .NET SDK installs these additional framework components, so you
    won’t see this problem on your development machine, but you might see it when
    deploying at runtime. You can tell the build tools to include the framework’s
    components, but this is not normally necessary. If you run your application on
    a public cloud service such as Azure, these generally preinstall relevant framework
    components, so in practice you will usually only run into this situation if you
    are configuring a server yourself or when deploying desktop applications. For
    those cases, Microsoft offers installers for the .NET runtime that also include
    the components for web or desktop frameworks.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你安装了纯粹的.NET运行时，你将只会得到`Microsoft.NETCore.App`，而没有任何应用程序框架。因此，如果以默认方式构建的应用程序目标框架是如ASP.NET
    Core或WPF等，它们将无法运行，因为这假定这些框架将预安装在目标机器上，而程序集解析过程将无法找到特定框架组件。.NET SDK会安装这些额外的框架组件，因此在开发机器上你不会遇到这个问题，但在部署时可能会遇到。你可以告诉构建工具包含框架的组件，但这通常是不必要的。如果在公共云服务（如Azure）上运行你的应用程序，这些服务通常会预安装相关的框架组件，因此实际上你通常只会在自己配置服务器或部署桌面应用程序时遇到这种情况。对于这些情况，微软提供了包含Web或桌面框架组件的.NET运行时安装程序。
- en: 'The *shared* folder in the *dotnet* installation folder is not one you should
    modify yourself. It is intended only for Microsoft’s own frameworks. However,
    it is possible to install additional system-wide components if you want, because
    .NET also supports something called the *runtime package store*. This is an additional
    directory structured in much the same way as the *shared* folder just described.
    You can build a suitable directory layout with the `dotnet store` command, and
    if you set the `DOTNET_SHARED_STORE` environment variable, the CLR will look in
    there during assembly resolution. This enables you to play the same trick as is
    possible with Microsoft’s frameworks: you can build applications that depend on
    a set of components without needing to include them in your build output, as long
    as you’ve arranged for those components to be preinstalled on the target machine.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*dotnet* 安装文件夹中的*shared* 文件夹不是你应该自行修改的目录。它仅用于微软自己的框架。但是，如果你愿意，可以安装额外的系统范围组件，因为.NET
    还支持称为*运行时包存储*的东西。这是一个额外的目录，结构与刚才描述的*shared* 文件夹类似。你可以使用 `dotnet store` 命令构建一个合适的目录布局，如果设置了
    `DOTNET_SHARED_STORE` 环境变量，CLR 将在程序集解析时查找其中的内容。这使你能够像使用微软的框架一样进行操作：你可以构建依赖于一组组件的应用程序，而无需将它们包含在构建输出中，只要你已经安排在目标机器上预安装这些组件。'
- en: Aside from looking in these two locations for common frameworks, the CLR will
    also look in the application’s own directory during assembly resolution, just
    as it would for a self-contained application. Also, the CLR has some mechanisms
    for enabling updates to be applied. For example, on Windows, it is possible for
    Microsoft to push out critical updates to .NET components via Windows Update.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在这两个位置查找常见的框架之外，CLR 在程序自己的目录中进行程序集解析时，也会进行查找，就像对于自包含应用程序一样。此外，CLR 还有一些机制可以进行更新的启用。例如，在
    Windows 上，微软可以通过 Windows 更新向 .NET 组件推送关键更新。
- en: But broadly speaking, the basic process of assembly resolution for framework-dependent
    applications is that implicit assembly loading occurs either from your application
    directory or from a shared set of components installed on the machine. This is
    also true for applications running on the older .NET Framework, although the mechanisms
    are a bit different. It has something called the *Global Assembly Cache* (GAC),
    which effectively combines the functionality provided by both of the shared stores
    in .NET. It is less flexible, because the store location is fixed; .NET’s use
    of an environment variable opens up the possibility of different shared stores
    for different applications.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 但总体来说，面向框架依赖型应用程序的程序集解析的基本过程是，隐式程序集加载会从你的应用程序目录或安装在机器上的共享组件集合中进行。这对于运行在较旧的 .NET
    Framework 上的应用程序也是适用的，尽管机制略有不同。它有一种称为*全局程序集缓存*（GAC）的东西，它有效地结合了.NET 中两个共享存储提供的功能。这种方式不太灵活，因为存储位置是固定的；.NET
    使用环境变量开放了为不同应用程序提供不同共享存储的可能性。
- en: Explicit Loading
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式加载
- en: Although the CLR will load assemblies automatically, you can also load them
    explicitly. For example, if you are creating an application that supports plug-ins,
    during development you will not know exactly what components you will load at
    runtime. The whole point of a plug-in system is that it’s extensible, so you’d
    probably want to load all the DLLs in a particular folder. (You would need to
    use reflection to discover and make use of the types in those DLLs, as [Chapter 13](ch13.xhtml#ch_reflection)
    describes.)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 CLR 可以自动加载程序集，你也可以显式加载它们。例如，如果你正在创建一个支持插件的应用程序，在开发过程中你可能不知道在运行时会加载哪些组件。插件系统的整个重点在于它是可扩展的，因此你可能希望加载特定文件夹中的所有
    DLL 文件。（你需要使用反射来发现和利用这些 DLL 中的类型，正如[第 13 章](ch13.xhtml#ch_reflection)所描述的。）
- en: Warning
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: In some scenarios, dynamic loading is restricted. For example, apps built using
    the UWP and installed from Microsoft’s store can only run code from the components
    that ship as part of the application. This is because Microsoft runs various tests
    on these store apps designed to avoid security and stability problems, for which
    they need access to all of your app’s code. The ability to download and run external
    code would defeat these checks.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景下，动态加载受到限制。例如，使用 UWP 构建的应用程序并从微软商店安装的应用程序只能运行作为应用程序一部分提供的组件。这是因为微软对这些商店应用程序运行各种测试，旨在避免安全和稳定性问题，为此他们需要访问你应用程序的所有代码。下载和运行外部代码的能力将会打破这些检查。
- en: 'If you know the full path of an assembly, loading it is very straightforward:
    you call the `Assembly` class’s static `LoadFrom` method, passing the path of
    the file. The path can be relative to the current directory, or it can be absolute.
    This static method returns an instance of the `Assembly` class, which is part
    of the reflection API. It provides ways of discovering and using the types defined
    by the assembly.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您知道程序集的完整路径，加载它非常简单：您可以调用`Assembly`类的静态`LoadFrom`方法，并传递文件的路径。路径可以是相对于当前目录的，也可以是绝对的。这个静态方法返回`Assembly`类的一个实例，它是反射
    API 的一部分。它提供了发现和使用程序集定义的类型的方式。
- en: Occasionally, you might want to load a component explicitly (e.g., to use it
    via reflection) without wanting to specify the path. For example, you might want
    to load a particular assembly from the runtime libraries. You should never hardcode
    the location for a system component—they tend to move from one version of .NET
    to the next. If your project has a reference to the relevant assembly and you
    know the name of a type it defines, you can write `typeof(TheType).Assembly`.
    But if that’s not an option, you should use the `Assembly.Load` method, passing
    the name of the assembly.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，您可能希望显式加载一个组件（例如，通过反射使用它），而不想指定路径。例如，您可能希望从运行时库中加载特定的程序集。永远不要硬编码系统组件的位置 ——
    它们往往会从一个 .NET 版本移动到下一个版本。如果您的项目引用了相关程序集并且知道它定义的类型的名称，您可以写`typeof(TheType).Assembly`。但如果这不是一个选择，您应该使用`Assembly.Load`方法，并传递程序集的名称。
- en: '`Assembly.Load` uses exactly the same mechanism as implicitly triggered loading.
    So you can refer to either a component that you’ve installed alongside your application
    or a system component. In either case, you should specify a full name, which must
    contain name and version information, e.g., `ComparerLib, Version=1.0.0.0, Cul⁠ture=neutral,
    PublicKeyToken=null`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Assembly.Load`使用的是与隐式触发加载完全相同的机制。因此，您可以引用安装在应用程序旁边的组件或系统组件。无论哪种情况，您都应该指定一个完整的名称，其中必须包含名称和版本信息，例如，`ComparerLib,
    Version=1.0.0.0, Cul⁠ture=neutral, PublicKeyToken=null`。'
- en: The .NET Framework version of the CLR remembers which assemblies were loaded
    with `LoadFrom`. If an assembly loaded in this way triggers the implicit loading
    of further assemblies, the CLR will search the location from which that assembly
    was loaded. This means that if your application keeps plug-ins in a separate folder
    that the CLR would not normally look in, those plug-ins could install other components
    that they depend on in that same plug-in folder. The CLR will then find them without
    needing further calls to `LoadFrom`, even though it would not normally have looked
    in that folder for an implicitly triggered load. However, .NET and .NET Core do
    not support this behavior. They provide a different mechanism to support plug-in
    scenarios.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework 版本的 CLR 记得使用`LoadFrom`加载了哪些程序集。如果以这种方式加载的程序集触发了隐式加载其他程序集，CLR
    将搜索从该程序集加载的位置。这意味着，如果您的应用程序将插件放在一个CLR通常不会查找的单独文件夹中，那么这些插件可以在同一插件文件夹中安装它们依赖的其他组件。CLR
    将能够在没有进一步调用`LoadFrom`的情况下找到它们，尽管它通常不会在那个文件夹中查找触发的加载。然而，.NET 和 .NET Core 不支持这种行为。它们提供了支持插件场景的不同机制。
- en: Isolation and Plug-ins with AssemblyLoadContext
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 AssemblyLoadContext 进行隔离和插件化
- en: .NET Core introduced a type called `AssemblyLoadContext`. It enables a degree
    of isolation between groups of assemblies within a single application.^([4](ch12.xhtml#idm45884795868336))
    This solves a problem that can arise in applications that support a plug-in model.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 引入了一种称为`AssemblyLoadContext`的类型。它允许在单个应用程序内部的程序集组之间实现一定程度的隔离。^([4](ch12.xhtml#idm45884795868336))
    这解决了在支持插件模型的应用程序中可能出现的问题。
- en: 'If a plug-in depends on some component that the hosting application also uses,
    but each wants a different version, this can cause problems if you use the simple
    mechanisms described in the preceding section. Typically, the .NET runtime *unifies*
    these references, loading just a single version. In any cases where the types
    in that shared component are part of the plug-in interface, this is exactly what
    you need: if an application requires plug-ins to implement some interface that
    relies on types from, say, the `Newtonsoft.Json` library, it’s important that
    the application and the plug-ins all agree on which version of that library is
    in use.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个插件依赖于主机应用程序也使用的某些组件，但每个组件想要不同的版本，如果使用上一节描述的简单机制可能会导致问题。通常，.NET运行时会*统一*这些引用，只加载单个版本。在这种情况下，如果共享组件中的类型是插件接口的一部分，这正是你需要的：如果一个应用程序要求插件实现某些依赖于`Newtonsoft.Json`库的接口类型，重要的是应用程序和插件都同意正在使用的库的版本。
- en: 'But unification can cause problems with components used as implementation details,
    and not as part of the API between the application and its plug-ins. If the host
    application uses, say, v3.1 of `Microsoft.Extensions.Logging` internally, and
    a plug-in uses v6.0 of the same component, there’s no particular need to unify
    this to a single version choice at runtime—there would be no harm in the application
    and plug-in each using the version they require. Unification could cause problems:
    forcing the plug-in to use v3.1 would cause exceptions at runtime if it attempted
    to use features only present in v6.0\. Forcing the application to use v6.0 could
    also cause problems because major version number changes often imply that a breaking
    change was introduced.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，统一可能会对用作实现细节而不是应用程序与其插件之间API的组件造成问题。如果主机应用程序在内部使用`Microsoft.Extensions.Logging`的v3.1版本，而插件使用相同组件的v6.0版本，没有必要在运行时将其统一为单个版本选择——如果应用程序和插件各自使用它们需要的版本，这不会有任何问题。统一可能会引起问题：强制插件使用v3.1将导致运行时异常，如果它尝试使用只存在于v6.0中的功能。强制应用程序使用v6.0也可能会导致问题，因为主要版本号更改通常意味着引入了破坏性更改。
- en: To avoid these kinds of problems, you can introduce custom assembly load contexts.
    You can write a class that derives from `AssemblyLoadContext`, and for each of
    these that you instantiate, the .NET runtime creates a corresponding load context
    that supports loading of different versions of assemblies than may already have
    been loaded by the application. You can define the exact policy you require by
    overloading the `Load` method, as [Example 12-4](#plugin_load_context) shows.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这类问题，你可以引入自定义的程序集加载上下文。你可以编写一个从`AssemblyLoadContext`派生的类，每个实例化的上下文都由.NET运行时创建，支持加载与应用程序可能已加载的不同版本的程序集。通过重载`Load`方法，你可以定义所需的确切策略，就像[示例 12-4](#plugin_load_context)中展示的那样。
- en: Example 12-4\. A custom `AssemblyLoadContext` for plug-ins
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-4\. 一个用于插件的自定义`AssemblyLoadContext`
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This takes the location of the plug-in DLL, along with a list of the names of
    any special assemblies where the plug-in must use the same version as the host
    application. (This would include interfaces defining types used in your plug-in
    interface. You don’t need to include assemblies that are included as part of .NET
    itself—these are always unified, even if you use custom load contexts.) The runtime
    will call this class’s `Load` method each time an assembly is loaded in this context.
    This code checks to see whether the assembly being loaded is one of the special
    ones that must be common to plug-ins and the host application. If not, this looks
    in the plug-in’s folder to see if the plug-in has supplied its own version of
    that assembly. In cases where it will not use an assembly from the plug-in folder
    (either because the plug-in hasn’t supplied this particular assembly or because
    it is one of the special ones), this context defers to `AssemblyLoadContext.Default`,
    meaning that the application host and plug-in use the same assemblies in these
    cases. [Example 12-5](#using_plugin_load_context) shows this in use.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码需要插件 DLL 的位置，以及任何特殊程序集的名称列表，插件需要与主机应用程序使用相同版本的程序集（例如定义插件接口中使用的类型的接口）。您不需要包含作为.NET本身一部分的程序集——即使您使用自定义加载上下文，这些程序集也始终是统一的。运行时将在每次在此上下文中加载程序集时调用此类的`Load`方法。此代码检查正在加载的程序集是否是那些必须对插件和主机应用程序通用的特殊程序集之一。如果不是，则在插件文件夹中查找插件是否提供了该程序集的自己版本。在不使用插件文件夹中的程序集的情况下（要么因为插件没有提供特定的程序集，要么因为它是特殊的程序集之一），此上下文将延迟至`AssemblyLoadContext.Default`，这意味着应用程序主机和插件在这些情况下使用相同的程序集。[示例 12-5](#using_plugin_load_context)展示了此用法。
- en: Example 12-5\. Using the plug-in load context
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-5\. 使用插件加载上下文
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This builds a list of assemblies that the plug-in and application must share,
    and passes their names into the plug-in context, along with a path to the plug-in
    DLL. Any DLLs that the plug-in depends on and that are copied into the same folder
    as the plug-in will be loaded, unless they are in that list, in which case the
    plug-in will use the same assembly as the host application itself.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此处构建了插件和应用程序必须共享的程序集列表，并将它们的名称与插件 DLL 的路径一起传递到插件上下文中。任何插件依赖的 DLL 并且被复制到与插件相同的文件夹中的
    DLL 将被加载，除非它们在该列表中，在这种情况下，插件将使用与主机应用程序本身相同的程序集。
- en: Assembly Names
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序集名称
- en: Assembly names are structured. They always include a *simple name*, which is
    the name by which you would normally refer to the DLL, such as *MyLibrary* or
    *System.Runtime*. This is usually the same as the filename but without the extension.
    It doesn’t technically have to be,^([5](ch12.xhtml#fn35)) but the assembly resolution
    mechanism assumes that it is. Assembly names always include a version number.
    There are also some optional components, including the *public key token*, a string
    of hexadecimal digits, which makes it possible to give an assembly a unique name.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 程序集名称是结构化的。它们总是包含一个*简单名称*，这是您通常用来引用DLL的名称，例如*MyLibrary*或*System.Runtime*。这通常与文件名相同，但没有扩展名。从技术上讲，这并不是必须的，^([5](ch12.xhtml#fn35))，但是程序集解析机制假定它是。程序集名称始终包括版本号。还有一些可选组件，包括*公钥标记*，一个十六进制数字字符串，使得可以为程序集指定唯一名称。
- en: Strong Names
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强名称
- en: If an assembly’s name includes a public key token, it is said to be a *strong
    name*. Microsoft advises that any .NET component that targets .NET Framework and
    is published for shared use (e.g., made available via NuGet) should have a strong
    name. However, if you are writing a new component that will only run on .NET Core
    or .NET, there are no benefits to strong naming, because these newer runtimes
    essentially ignore the public key token.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序集的名称包含公钥标记，则称为*强名称*。Microsoft建议任何针对.NET Framework并发布供共享使用的.NET组件（例如通过NuGet提供）应具有强名称。但是，如果您正在编写仅在.NET
    Core或.NET上运行的新组件，则强命名没有任何好处，因为这些较新的运行时基本上忽略公钥标记。
- en: 'Since the purpose of strong naming is to make the name unique, you may be wondering
    why assemblies do not simply use a Globally Unique Identifier (GUID). The answer
    is that historically, strong names also did another job: they were designed to
    provide some degree of assurance that the assembly has not been tampered with.
    Early versions of .NET checked strongly named assemblies for tampering at runtime,
    but these checks were removed because they imposed a considerable runtime overhead,
    often for little or no benefit. Microsoft’s documentation now explicitly advises
    against treating strong names as a security feature. However, in order to understand
    and use strong names, you need to know how they were originally meant to work.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于强命名的目的是使名称唯一，您可能会想知道为什么程序集不简单地使用全局唯一标识符（GUID）。答案是，从历史上看，强名称还承担了另一个任务：它们旨在提供一定程度的保证，即程序集未被篡改。早期的.NET版本在运行时检查强命名程序集是否被篡改，但由于这些检查带来了相当大的运行时开销，通常几乎没有好处，因此这些检查已被移除。微软的文档现在明确建议不将强名称视为安全功能。但是，为了理解和使用强名称，您需要了解它们最初的工作方式。
- en: As the terminology suggests, an assembly name’s public key token has a connection
    with cryptography. It is the hexadecimal representation of a 64-bit hash of a
    public key. Strongly named assemblies are required to contain a copy of the full
    public key from which the hash was generated. The assembly file format also provides
    space for a digital signature, generated with the corresponding private key.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如术语所示，程序集名称的公钥标记与密码学有关。它是公钥的64位哈希的十六进制表示。要求强名称的程序集包含生成哈希的完整公钥的副本。程序集文件格式还提供了用相应私钥生成的数字签名空间。
- en: The uniqueness of a strong name relies on the fact that key generation systems
    use cryptographically secure random-number generators, and the chances of two
    people generating two key pairs with the same public key token are vanishingly
    small. The assurance that the assembly has not been tampered with comes from the
    fact that a strongly named assembly must be signed, and only someone in possession
    of the private key can generate a valid signature. Any attempt to modify the assembly
    after signing it will invalidate the signature.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 强名称的唯一性依赖于密钥生成系统使用密码学安全的随机数生成器，以及两个人生成具有相同公钥标记的两个密钥对的机会非常小。程序集未被篡改的保证来自于强命名程序集必须被签名，只有拥有私钥的人才能生成有效的签名。任何在签名后修改程序集的尝试都将使签名无效。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The signature associated with a strong name is independent of Authenticode,
    a longer-established code signing mechanism in Windows. These serve different
    purposes. Authenticode provides traceability, because the public key is wrapped
    in a certificate that tells you something about where the code came from. With
    a strong name’s public key token, all you get is a number, so unless you happen
    to know who owns that token, it tells you nothing. Authenticode lets you ask,
    “Where did this component come from?” A public key token lets you say, “This is
    the component I want.” It’s common for a single .NET component to use both mechanisms.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 强名称相关联的签名与Windows中较早的代码签名机制Authenticode独立。它们具有不同的目的。Authenticode提供可追溯性，因为公钥包含在证书中，告诉您代码的来源。而强名称的公钥标记仅仅是一个数字，所以除非您碰巧知道谁拥有该标记，否则它不会告诉您任何信息。Authenticode允许您询问：“这个组件来自哪里？”而公钥标记允许您说：“这就是我想要的组件。”一个单独的.NET组件通常同时使用这两种机制。
- en: If an assembly’s private key becomes public knowledge, anyone can generate valid-looking
    assemblies with the corresponding key token. Some open source projects deliberately
    publish both keys so that anyone can build the components from source. This completely
    abandons any security the key token could offer, but that’s fine because Microsoft
    now recommends that we not treat strong names as a security feature. The practice
    of publishing your strong naming private key recognizes that it is useful to have
    a unique name, even without a guarantee of authenticity. .NET Core (and thus .NET)
    took this one step further, by making it possible for components to have a strong
    name without needing to use a private key at all. In keeping with Microsoft’s
    adoption of open source development, this means you can now build and use your
    own versions of Microsoft-authored components that have the same strong name,
    even though Microsoft has not published its private key. See the next sidebar,
    [“Strong Name Keys and Public Signing”](#strong_name_keys_and_public_signing),
    for information on how to work with keys.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个程序集的私钥变为公共知识，任何人都可以生成具有相应密钥标记的看似有效的程序集。一些开源项目故意发布两个密钥，以便任何人都可以从源代码构建组件。这完全放弃了密钥标记可能提供的任何安全性，但这没关系，因为微软现在建议我们不把强名称视为安全功能。发布你的强命名私钥的做法认识到，即使没有真实性的保证，拥有一个唯一的名称也是有用的。.NET
    Core（因此.NET）更进一步，使组件可以拥有强名称而无需使用私钥。为了与微软采用开源开发的做法一致，这意味着你现在可以构建和使用具有相同强名称的自己版本的微软编写的组件，尽管微软并未发布其私钥。请参阅下一个侧边栏，["强名称密钥和公共签名"](https://wiki.example.org/strong_name_keys_and_public_signing)，了解如何处理密钥的信息。
- en: 'Microsoft uses the same token on most of the assemblies in the runtime libraries.
    (Many groups at Microsoft produce .NET components, so this token is common only
    to the components that are part of .NET, not for Microsoft as a whole.) Here’s
    the full name of `mscorlib`, a system assembly that offers definitions of various
    core types such as `System.String`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 微软在运行时库中的大多数程序集上使用相同的标记。（微软的许多组织生产.NET组件，因此该标记仅用于.NET的组件，而不适用于整个微软。）这里是`mscorlib`的完整名称，这是一个系统程序集，提供了诸如`System.String`等各种核心类型的定义：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By the way, that’s the right name even for the latest versions of .NET at the
    time of writing. The `Version` is `4.0.0.0` even though .NET Framework is now
    on v4.8, and .NET on 6.0\. (In .NET and .NET Core, `mscorlib` contains nothing
    but type forwarders, because the relevant types have moved, mostly to `System.Private.CoreLib`.
    And while that real home of these types is now on version `6.0.0.0`, the `mscorlib`
    version number remains the same.) Assembly version numbers have technical significance,
    so Microsoft does not always update the version number in the names of library
    components in step with the marketing version numbers—the versions don’t necessarily
    even match on the major number. The .NET 3.5 version of `mscorlib` had a version
    number of `2.0.0.0`, for example.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，在撰写本文时，这是即使在最新的.NET版本中也是正确的名称。`Version`是`4.0.0.0`，即使.NET Framework现在是v4.8，.NET是6.0版。（在.NET和.NET
    Core中，`mscorlib`只包含类型转发器，因为相关类型大多数已移至`System.Private.CoreLib`。虽然这些类型的真正家园现在是版本`6.0.0.0`，但`mscorlib`的版本号仍然相同。）程序集版本号具有技术上的重要意义，因此微软并不总是随着市场版本号更新库组件名称中的版本号
    —— 这些版本号甚至在主要版本号上也不一定匹配。例如，.NET 3.5版的`mscorlib`版本号为`2.0.0.0`。
- en: While the public key token is an optional part of an assembly’s name, the version
    is mandatory.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管公共密钥令牌是程序集名称的可选部分，版本是强制的。
- en: Version
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本
- en: All assembly names include a four-part version number. When an assembly name
    is represented as a string (e.g., when you pass one as an argument to `Assembly.Load`),
    the version consists of four decimal integers separated by dots (e.g., `4.0.0.0`).
    The binary format that IL uses for assembly names and references limits the range
    of these numbers—each part must fit in a 16-bit unsigned integer (a `ushort`),
    and the highest allowable value in a version part is actually one less than the
    maximum value that would fit, making the highest legal version number `65534.65534.65534.65534`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的程序集名称都包含一个四部分的版本号。当一个程序集名称被表示为一个字符串（例如，当你将其作为参数传递给`Assembly.Load`时），版本号由四个用点分隔的十进制整数组成（例如，`4.0.0.0`）。IL用于程序集名称和引用的二进制格式限制了这些数字的范围
    —— 每个部分必须适合于一个16位无符号整数（即`ushort`），而版本部分中允许的最大值实际上比适合的最大值小1，因此最高合法版本号是`65534.65534.65534.65534`。
- en: Each of the four parts has a name. From left to right, they are the *major version*,
    the *minor version*, the *build*, and the *revision*. However, there’s no particular
    significance to any of these names. Some developers use certain conventions, but
    nothing checks or enforces them. A common convention is that any change in the
    public API requires a change to either the major or minor version number, and
    a change likely to break existing code should involve a change of the major number.
    (Marketing is another popular reason for a major version change.) If an update
    is not intended to make any visible changes to behavior (except, perhaps, fixing
    a bug), changing the build number is sufficient. The revision number could be
    used to distinguish between two components that you believe were built against
    the same source but not at the same time. Alternatively, some people relate the
    version numbers to branches in source control, so a change in just the revision
    number might indicate a patch applied to a version that has long since stopped
    getting major updates. However, you’re free to make up your own meanings. As far
    as the CLR is concerned, there’s really only one interesting thing you can do
    with a version number, which is to compare it with some other version number—either
    they match or one is higher than the other.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 每个版本号的四个部分都有名称。从左到右，它们是*主版本*、*次版本*、*构建*和*修订*。然而，这些名称没有特定的意义。一些开发人员使用某些约定，但没有任何检查或强制执行。一个常见的约定是，公共
    API 的任何更改都需要更改主版本或次版本号，而可能会破坏现有代码的更改应该涉及主版本号的更改。（市场营销是进行主版本更改的另一个流行原因。）如果更新不打算对行为进行任何可见更改（除非是修复
    bug），则更改构建号就足够了。修订号可以用来区分你认为是针对同一源构建但不是同时构建的两个组件。另外，有些人将版本号与源代码控制中的分支联系起来，因此仅更改修订号可能表示对长期停止获得主要更新的版本应用的修补程序。然而，你可以自由地制定自己的含义。就
    CLR 而言，你真正能做的有趣事情只有一个，那就是将其与其他版本号进行比较——它们要么匹配，要么其中一个比另一个更高。
- en: Note
  id: totrans-98
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'NuGet packages also have version numbers, and these do not need to be connected
    in any way to assembly versions. Many package authors make them similar by convention,
    but this is not universal. NuGet *does* treat the components of a package version
    number as having particular significance: it has adopted the widely used *semantic
    versioning* rules. This uses versions with three parts, named major, minor, and
    patch.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: NuGet 包也有版本号，并且这些版本号不需要以任何方式与程序集版本连接。许多包作者按照约定使它们相似，但这并非普遍规则。NuGet *确实* 将包版本号的组件视为具有特定意义：它采用了广泛使用的*语义化版本*规则。这种规则使用由三个部分组成的版本号，分别称为主版本、次版本和修订版本。
- en: Version numbers in runtime library assembly names ignore all the conventions
    I have just described. Most of the components had the same version number (`2.0.0.0`)
    across four major updates. With .NET 4.0, everything changed to `4.0.0.0`, which
    is still in use with the latest version of .NET Framework (4.8), at the time of
    writing. .NET Core 3.1 also uses 4 as the major version of most of its runtime
    library components. In .NET 6.0, many of these components now have a matching
    major version of 6, but as you’ve seen with its copy of `mscorlib`, that’s not
    universal.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时库程序集名称中的版本号忽略了我刚才描述的所有约定。在四个主要更新中，大多数组件的版本号都是相同的（`2.0.0.0`）。随着 .NET 4.0 的推出，所有东西都变成了`4.0.0.0`，这在撰写本文时仍然是
    .NET Framework（4.8 版本）的最新版本。.NET Core 3.1 也使用 4 作为其大多数运行时库组件的主版本。在 .NET 6.0 中，许多这些组件现在的主版本号都是
    6，但正如你在它的 `mscorlib` 副本中看到的那样，并非普遍适用。
- en: 'You typically specify the version number by adding a `<Version>` element inside
    a `<PropertyGroup>` of your *.csproj* file. (Visual Studio also offers a UI for
    this: if you open the Properties page for the project, its Package section lets
    you configure various naming-related settings. The “Package version” field sets
    the version.) The build system uses this in two ways: it sets the version number
    on the assembly, but, if you generate a NuGet package for your project, by default
    it will also use this same version number for the package, and since NuGet version
    numbers have three parts, you normally specify just three numbers here, and the
    fourth part of the assembly version will default to zero. (If you really want
    to specify all four digits, consult the documentation for how to set the assembly
    and NuGet versions separately.)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你通过在*.csproj*文件的`<PropertyGroup>`中添加一个`<Version>`元素来指定版本号。（Visual Studio也为此提供了一个UI：如果你打开项目的属性页面，其“Package”部分允许你配置各种与命名相关的设置。“Package
    version”字段设置版本号。）构建系统以两种方式使用这个版本号：它在程序集上设置版本号，但如果你为项目生成NuGet包，则默认情况下也会将此相同的版本号用于包，并且由于NuGet版本号有三部分，你通常只在这里指定三个数字，程序集版本的第四部分将默认为零。（如果你真的想指定所有四位数，请参阅如何分别设置程序集和NuGet版本的文档。）
- en: The build system tells the compiler which version number to use for the assembly
    name via an assembly-level attribute. I’ll describe attributes in more detail
    in [Chapter 14](ch14.xhtml#ch_attributes), but this one’s pretty straightforward.
    If you want to find it, the build system typically generates a file called *ProjectName.AssemblyInfo.cs*
    in a subfolder of your project’s *obj* folder. This contains various attributes
    describing details about the assembly, including an `AssemblyVersion` attribute,
    such as the one shown in [Example 12-6](#specifying_an_assembly_version).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过程序集级别的属性，构建系统告诉编译器在程序集名称中使用哪个版本号。我将在[第14章](ch14.xhtml#ch_attributes)更详细地描述属性，但这个属性相当直接。如果你想找到它，构建系统通常会在项目的*obj*文件夹的子文件夹中生成一个名为*ProjectName.AssemblyInfo.cs*的文件。其中包含各种描述程序集详细信息的属性，包括一个`AssemblyVersion`属性，例如在[示例12-6](#specifying_an_assembly_version)中所示。
- en: Example 12-6\. Specifying an assembly’s version
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-6\. 指定程序集的版本
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The C# compiler provides special handling for this attribute—it does not apply
    it blindly as it would most attributes. It parses the version number and embeds
    it in the way required by .NET’s metadata format. It also checks that the string
    conforms to the expected format and that the numbers are in the allowed range.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: C#编译器对此属性提供特殊处理——它不像大多数属性那样盲目应用它。它解析版本号并将其嵌入到.NET元数据格式所需的方式中。它还检查字符串是否符合预期格式，并检查数字是否在允许的范围内。
- en: By the way, the version that forms part of an assembly’s name is distinct from
    the one stored using the standard Win32 mechanism for embedding versions. Most
    .NET files contain both kinds. By default, the build system will use the `<Version>`
    setting for both, but it’s common for the file version to change more frequently.
    This was particularly important with .NET Framework, in which only a single instance
    of any major version can be installed at once—if a machine has .NET Framework
    4.7.2 installed and you install .NET Framework 4.8, that will replace version
    4.7.2\. (.NET and .NET Core don’t do this—you can install any number of versions
    side by side on a single computer.) This in-place updating combined with Microsoft’s
    tendency to keep assembly versions the same across releases could make it hard
    to work out exactly what is installed, at which point the file version becomes
    important. On a computer with .NET Framework 4.0 sp1 installed, its version of
    *mscorlib.dll* had a Win32 version number of `4.0.30319.239`, but if you’ve installed
    .NET 4.8, this changes to `4.8.4420.0`, but the assembly version remains at `4.0.0.0`.
    (As service packs and other updates are released, the last part will keep climbing.)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，组成程序集名称一部分的版本与使用标准的 Win32 机制嵌入版本存储的版本是不同的。大多数 .NET 文件包含这两种版本。默认情况下，构建系统将使用
    `<Version>` 设置两者，但文件版本更频繁地更改是很常见的。这在 .NET Framework 中特别重要，因为一次只能安装一个主要版本的 .NET
    Framework —— 如果一台计算机安装了 .NET Framework 4.7.2，你安装了 .NET Framework 4.8，那么将替换版本 4.7.2。（.NET
    和 .NET Core 不会这样做 —— 你可以在单台计算机上并排安装任意数量的版本。）这种原地更新与微软倾向于在各版本中保持程序集版本相同结合在一起，可能会使确定安装了哪个版本变得困难，此时文件版本变得重要。在安装了
    .NET Framework 4.0 sp1 的计算机上，其 *mscorlib.dll* 的 Win32 版本号是 `4.0.30319.239`，但如果安装了
    .NET 4.8，这将变为 `4.8.4420.0`，但程序集版本仍保持为 `4.0.0.0`。（随着发布服务包和其他更新，最后一部分将不断上升。）
- en: By default, the build system will use the `<Version>` for both the assembly
    and Windows file versions, but if you want to set the file version separately,
    you can add a `<FileVersion>` to your project file. (Visual Studio’s project properties
    Package section also lets you set this.) Under the covers, this works with another
    attribute that gets special handling from the compiler, `AssemblyFileVersion`.
    It causes the compiler to embed a Win32 version resource in the file, so this
    is the version number users see if they right-click your assembly in Windows Explorer
    and show the file properties.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，构建系统将同时使用 `<Version>` 设置程序集和 Windows 文件版本，但如果你想分别设置文件版本，可以在项目文件中添加 `<FileVersion>`。（Visual
    Studio 的项目属性包部分也允许你设置这个。）在内部，这与另一个属性一起工作，编译器会特别处理，`AssemblyFileVersion`。它会导致编译器在文件中嵌入一个
    Win32 版本资源，因此这是用户在 Windows Explorer 中右键单击程序集时看到的版本号。
- en: This file version is usually a more appropriate place to put a version number
    that identifies the build provenance than the version that goes into the assembly
    name. The latter is really a declaration of the supported API version, and any
    updates that are designed to be fully backward compatible should probably leave
    it unaltered and should change only the file version.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件版本通常是放置标识构建来源的版本号的更合适的地方，而不是放置在程序集名称中的版本号。后者实际上是支持的 API 版本的声明，任何设计为完全向后兼容的更新可能应该保持不变，只改变文件版本。
- en: Version Numbers and Assembly Loading
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本号和程序集加载
- en: Since version numbers are part of an assembly’s name (and therefore its identity),
    they are also, ultimately, part of a type’s identity. The `System.String` in `mscorlib`
    version `2.0.0.0` is not the same thing as the type of the same name in `mscorlib`
    version `4.0.0.0`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于版本号是程序集名称（因此是其标识）的一部分，它们也最终是类型标识的一部分。`mscorlib` 中 `System.String` 在版本 `2.0.0.0`
    的不是与版本 `4.0.0.0` 的相同类型。
- en: The handling of assembly version numbers changed with .NET Core. In .NET Framework,
    when you load a strongly named assembly by name (either implicitly by using types
    it defines or explicitly with `Assembly.Load`), the CLR requires the version number
    to be an exact match.^([6](ch12.xhtml#fn36)) .NET Core relaxed this, so if the
    version on disk has a version number equal to or higher than the version requested,
    it will use it. There are two factors behind this change. The first is that the
    .NET development ecosystem has come to rely on NuGet (which didn’t even exist
    for most of the first decade of .NET’s existence), meaning that it has become
    increasingly common to depend on fairly large numbers of external components.
    Second, the rate of change has increased—in the early days we would often need
    to wait for years between new releases of .NET components. (Security patches and
    other bug fixes might turn up more often, but new functionality would tend to
    emerge slowly, and typically in big chunks, as part of a whole wave of updates
    to the runtime, frameworks, and development tools.) But today, it can be rare
    for an application to go for as long as a month without the version of some component
    somewhere changing. .NET Framework’s strict versioning policy now looks unhelpful.
    (In fact, there are parts of the build system dedicated to digging through your
    NuGet dependencies, working out the specific versions of each component you’re
    using, and automatically generating a configuration file with a vast number of
    version substitution rules telling the CLR to use those versions no matter which
    version any single assembly says it wants. So even if you target the .NET Framework,
    the build system will, by default, effectively disable strict versioning.)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序集版本号在.NET Core中有所改变。在.NET Framework中，当你通过名称加载一个强命名程序集（无论是隐式地使用它定义的类型还是显式地使用`Assembly.Load`），CLR要求版本号必须完全匹配。^([6](ch12.xhtml#fn36))
    .NET Core对此进行了放宽，因此如果磁盘上的版本号等于或高于请求的版本号，它将使用它。这一变化背后有两个因素。首先，.NET开发生态系统已经开始依赖NuGet（在.NET存在的第一个十年中甚至不存在），这意味着依赖于大量外部组件变得越来越普遍。其次，变化的速度增加了——在早期，我们通常需要等待多年才能看到.NET组件的新版本发布。（安全补丁和其他错误修复可能会更频繁地出现，但新功能往往会缓慢地以大块的形式作为整个运行时、框架和开发工具更新的一部分出现。）但如今，一个应用程序在一个月内没有某个组件的版本发生变化是很少见的。.NET
    Framework的严格版本策略现在看起来并不实用。（事实上，构建系统的某些部分专门负责浏览您的NuGet依赖项，计算出您正在使用的每个组件的具体版本，并自动生成包含大量版本替换规则的配置文件，告诉CLR使用这些版本，而不管任何单个程序集说它想要的版本是什么。因此，即使您面向.NET
    Framework，构建系统默认情况下也会有效地禁用严格版本控制。）
- en: Another change is that .NET Framework only takes assembly versions into account
    for strongly named assemblies. .NET Core and .NET check that the version number
    of the assembly on disk is equal to or greater than the required version regardless
    of whether the target assembly is strongly named.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个变化是，.NET Framework仅对强命名程序集考虑程序集版本。.NET Core和.NET检查磁盘上程序集的版本号是否等于或大于所需版本，而不管目标程序集是否强命名。
- en: Culture
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文化
- en: 'So far we’ve seen that assembly names include a simple name, a version number,
    and optionally a public key token. They also have a *culture* component. (A culture
    represents a language and a set of conventions, such as currency, spelling variations,
    and date formats.) This is not optional, although the most common value for this
    is the default: `neutral`, indicating that the assembly contains no culture-specific
    code or data. The culture is usually set to something else only on assemblies
    that contain culture-specific resources. The culture of an assembly’s name is
    designed to support localization of resources such as images and strings. To show
    how, I’ll need to explain the localization mechanism that uses it.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到程序集名称包括简单名称、版本号，以及可选的公钥标记。它们还有一个*文化*组件。（文化代表语言和一组约定，如货币、拼写变体和日期格式。）这不是可选的，尽管最常见的值是默认值：`neutral`，表示程序集不包含特定于文化的代码或数据。程序集的文化通常仅在包含特定于文化资源的程序集上设置为其他值。程序集名称的文化旨在支持资源（如图像和字符串）的本地化。为了说明这一点，我需要解释使用它的本地化机制。
- en: All assemblies can contain embedded binary streams. (You can put text in these
    streams, of course. You just have to pick a suitable encoding.) The `Assembly`
    class in the reflection API provides a way to work directly with these, but it’s
    more common to use the `ResourceManager` class in the `System.Resources` namespace.
    This is far more convenient than working with the raw binary streams, because
    the `ResourceManager` defines a container format that allows a single stream to
    hold any number of strings, images, sound files, and other binary items, and Visual
    Studio has a built-in editor for working with this container format. The reason
    I’m mentioning all of this in the middle of a section that’s ostensibly about
    assembly names is that `ResourceManager` also provides localization support, and
    the assembly name’s culture is part of that mechanism. To demonstrate how this
    works, I’ll walk you through a quick example.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所有程序集都可以包含嵌入的二进制流。（当然，你也可以在这些流中放置文本。你只需选择合适的编码。）反射 API 中的 `Assembly` 类提供了直接处理这些流的方法，但更常见的是使用
    `System.Resources` 命名空间中的 `ResourceManager` 类。这比直接处理原始二进制流方便得多，因为 `ResourceManager`
    定义了一个容器格式，允许单个流容纳任意数量的字符串、图像、声音文件和其他二进制项目，并且 Visual Studio 内置了编辑器以处理这种容器格式。我在本节中提到这一切的原因是，`ResourceManager`
    还提供本地化支持，而程序集名称的文化特性是其机制的一部分。为了演示这是如何工作的，我将通过一个快速示例来向你展示。
- en: The easiest way to use the `ResourceManager` is to add a resource file in the
    *.resx* format to your project. (This is not the format used at runtime. It’s
    an XML format that gets compiled into the binary format required by `ResourceManager`.
    It’s easier to work with text than binary in most source control systems. It also
    makes it possible to work with these files if you’re using an editor without built-in
    support for the format.) To add one of these from Visual Studio’s Add New Item
    dialog, select the Visual C#→General category, and then choose Resources File.
    I’ll call mine *MyResources.resx*. Visual Studio will show its resource editor,
    which opens in string editing mode, as [Figure 12-1](#resource_file_editor_in_string_mode)
    shows. As you can see, I’ve defined a single string with a name of `ColString`
    and a value of `Color`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ResourceManager` 的最简单方式是向项目中添加一个 *.resx* 格式的资源文件。（这不是运行时使用的格式。它是一种 XML 格式，会被编译成
    `ResourceManager` 所需的二进制格式。在大多数源代码控制系统中，使用文本比使用二进制更容易。如果你的编辑器不支持该格式，则也可以使用这些文件。）要从
    Visual Studio 的“添加新项”对话框中添加一个此类文件，请选择“Visual C#→通用”类别，然后选择“资源文件”。我将其命名为 *MyResources.resx*。Visual
    Studio 将显示其资源编辑器，以字符串编辑模式打开，正如[图 12-1](#resource_file_editor_in_string_mode)所示。你可以看到，我定义了一个名为
    `ColString` 的字符串，其值为 `Color`。
- en: '![Resource file editor in string mode](assets/pc10_1201.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![字符串模式下的资源文件编辑器](assets/pc10_1201.png)'
- en: Figure 12-1\. Resource file editor in string mode
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-1\. 字符串模式下的资源文件编辑器
- en: I can retrieve this value at runtime. The build system generates a wrapper class
    for each *.resx* file you add, with a static property for each resource you define.
    This makes it very easy to look up a string resource, as [Example 12-7](#retrieving_a_resource_with_the_wrapper_c)
    shows.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以在运行时检索此值。构建系统为你添加的每个 *.resx* 文件生成一个包装类，每个定义的资源都有一个静态属性。这使得查找字符串资源变得非常简单，正如[示例 12-7](#retrieving_a_resource_with_the_wrapper_c)所示。
- en: Example 12-7\. Retrieving a resource with the wrapper class
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-7\. 使用包装类检索资源
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The wrapper class hides the details, which is usually convenient, but in this
    case, the details are the whole reason I’m demonstrating a resource file, so I’ve
    shown how to use the `ResourceManager` directly in [Example 12-8](#retrieving_a_resource_at_runtime).
    I’ve included the entire source for the file, because namespaces are significant
    here—the build tools prepend your project’s default namespace to the embedded
    resource stream name, so I’ve had to ask for `ResourceExample.MyResources` instead
    of just `MyResources`. (If I had put the resources in a subfolder, the tools would
    also include the name of that folder in the resource stream name.)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 包装类隐藏了细节，通常这很方便。但在这种情况下，细节是我演示资源文件的全部原因，因此我展示了如何直接使用 `ResourceManager`，如[示例 12-8](#retrieving_a_resource_at_runtime)所示。我包含了整个文件的源代码，因为命名空间在这里很重要——构建工具会在嵌入资源流的名称前加上项目的默认命名空间，所以我要求使用
    `ResourceExample.MyResources` 而不仅仅是 `MyResources`。（如果我将资源放在子文件夹中，工具也会在资源流名称中包含该文件夹的名称。）
- en: Example 12-8\. Retrieving a resource at runtime
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-8\. 在运行时检索资源
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So far, this is just a rather long-winded way of getting hold of the string
    `"Color"`. However, now that we’ve got a `ResourceManager` involved, I can define
    some localized resources. Being British, I have strong opinions on the correct
    way to spell the word *color*. They are not consistent with O’Reilly’s editorial
    policy, and in any case I’m happy to adapt my work for my predominantly American
    readership. But a program can do better—it should be able to provide different
    spellings for different audiences. (And taking it a step further, it should be
    able to change the language entirely for countries in which some form of English
    is not the predominant language.) In fact, my program already contains all the
    code it needs to support localized spellings of the word *color*. I just need
    to provide it with the alternative text.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这只是一个比较冗长的方法来获取字符串`"Color"`。然而，既然我们牵涉到了`ResourceManager`，我可以定义一些本地化资源了。作为英国人，我对拼写单词*color*的正确方式有强烈的看法。它们与奥莱利的编辑政策不一致，无论如何，我乐意为我的主要读者群（主要是美国人）适应我的工作。但一个程序可以做得更好——它应该能够为不同的受众提供不同的拼写方式。（更进一步，它应该能够在某些英语不是主要语言的国家完全改变语言。）事实上，我的程序已经包含了支持单词*color*本地化拼写所需的所有代码。我只需提供替代文本即可。
- en: 'I can do this by adding a second resource file with a carefully chosen name:
    *MyResources.en-GB.resx*. That’s almost the same as the original but with an extra
    *.en-GB* before the *.resx* extension. That is short for English-Great Britain,
    and it is the standardized (albeit politically tone-deaf) name of the culture
    for my home. (The name for the culture that denotes English-speaking parts of
    the US is *en-US*.) Having added such a file to my project, I can add a string
    entry with the same name as before, `ColString`, but this time with the correct
    (where I’m sitting^([7](ch12.xhtml#fn37))) value of `Colour`. If you run the application
    on a machine configured with a British locale, it will use the British spelling.
    The odds are that your machine is not configured for this locale, so if you want
    to try this, you can add the code in [Example 12-9](#forcing_a_nondefault_culture)
    at the very start of the `Main` method in [Example 12-8](#retrieving_a_resource_at_runtime)
    to force .NET to use the British culture when looking up resources.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以通过添加一个精心选择的第二个资源文件来完成这个任务：*MyResources.en-GB.resx*。这个名字几乎与原始文件名相同，只是在*.resx*扩展名之前多了一个*.en-GB*。这个简称代表英国英语，虽然在政治上有点不敏感，但却是我所在地文化的标准化名称。（用于美国英语的文化名称是*en-US*。）在项目中添加了这样一个文件之后，我可以像之前那样添加一个名为`ColString`的字符串条目，但这次的值是正确的（我所在位置的值^([7](ch12.xhtml#fn37))），即`Colour`。如果你在配置了英国区域设置的计算机上运行应用程序，它将使用英国拼写。你的计算机很可能没有配置这个区域设置，所以如果你想尝试这个功能，你可以在[示例 12-8](#retrieving_a_resource_at_runtime)中的`Main`方法的开头添加[示例 12-9](#forcing_a_nondefault_culture)中的代码，强制.NET在查找资源时使用英国文化。
- en: Example 12-9\. Forcing a nondefault culture
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-9\. 强制使用非默认文化
- en: '[PRE10]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'How does this relate to assemblies? Well, if you look at the compiled output,
    you’ll see that, as well as the usual executable file and related debug files,
    the build process has created a subdirectory called *en-GB*, which contains an
    assembly file called *ResourceExample.resources.dll*. (*ResourceExample* is the
    name of my project. If you created a project called *SomethingElse*, you’d see
    *SomethingElse.resources.dll*.) That assembly’s name will look like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这与程序集有什么关系？如果你查看编译输出，你会看到除了通常的可执行文件和相关的调试文件外，构建过程还创建了一个名为*en-GB*的子目录，其中包含一个名为*ResourceExample.resources.dll*的程序集文件。（*ResourceExample*是我的项目名称。如果你创建了一个名为*SomethingElse*的项目，你会看到*SomethingElse.resources.dll*。）该程序集的名称看起来像这样：
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The version number and public key token will match those for the main project—in
    my example, I’ve left the default version number, and I’ve not given my assembly
    a strong name. But notice the `Culture`. Instead of the usual `neutral` value,
    I’ve got `en-GB`, the same culture string I specified in the filename for the
    second resource file I added. If you add more resource files with other culture
    names, you’ll get a folder containing a culture-specific assembly for each culture
    you specify. These are called *satellite resource assemblies*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 版本号和公钥标记将与主项目相匹配——在我的示例中，我保留了默认版本号，并且没有为我的程序集命名。但请注意`Culture`。我没有使用通常的`neutral`值，而是使用了`en-GB`，这与我添加的第二个资源文件的文件名中指定的文化字符串相同。如果你添加了更多带有其他文化名称的资源文件，你将会得到一个包含每种指定文化的专用程序集的文件夹。这些被称为*卫星资源程序集*。
- en: When you first ask a `ResourceManager` for a resource, it will look for a satellite
    resource assembly with the same culture as the thread’s current UI culture. So
    it would attempt to load an assembly using the name shown a couple of paragraphs
    ago. If it doesn’t find that, it tries a more generic culture name—if it fails
    to find `en-GB` resources, it will look for a culture called just `en`, denoting
    the English language without specifying any particular region. Only if it finds
    neither (or if it finds matching assemblies, but they do not contain the resource
    being looked up) does it fall back to the neutral resource built into the main
    assembly.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当您首次请求`ResourceManager`的资源时，它将查找一个具有与线程当前UI文化相同文化的卫星资源装配体。因此，它会尝试使用几段前显示的名称加载一个装配体。如果找不到，它会尝试一个更通用的文化名称——如果找不到`en-GB`资源，它将尝试寻找一个名为`en`的文化，表示没有指定特定地区的英语语言。只有当两者都找不到（或者找到匹配的装配体，但它们不包含所查找的资源）时，它才会退回到主装配体中的中性资源。
- en: The CLR’s assembly loader looks in different places when a nonneutral culture
    is specified. It looks in a subdirectory named for the culture. That’s why the
    build process placed my satellite resource assembly in an *en-GB* folder.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定非中性文化时，CLR的装配体加载器会查找不同的位置。它会查找一个以该文化命名的子目录。这就是为什么构建过程将我的卫星资源装配体放置在一个*en-GB*文件夹中的原因。
- en: The search for culture-specific resources incurs some runtime costs. These are
    not large, but if you’re writing an application that will never be localized,
    you might want to avoid paying the price for a feature you’re not using. You might
    still want to use the `ResourceManager`, however—it’s a more convenient way to
    embed resources than using assembly manifest resource streams directly. The way
    to avoid the costs is to tell .NET that the resources built directly into your
    main assembly are the right ones for a particular culture. You can do this with
    the assembly-level attribute shown in [Example 12-10](#specifying_the_culture_for_built-in_reso).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为特定文化搜索资源会产生一些运行时成本。这些成本并不大，但如果您正在编写一个永远不会本地化的应用程序，您可能希望避免为您不使用的功能付出代价。然而，您可能仍希望使用`ResourceManager`——它比直接使用装配体清单资源流更方便地嵌入资源。避免这些成本的方法是告诉.NET，直接构建到您的主装配体中的资源适合特定文化。您可以使用[示例
    12-10](#specifying_the_culture_for_built-in_reso)中显示的装配体级属性来实现这一点。
- en: Example 12-10\. Specifying the culture for built-in resources
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-10\. 指定内置资源的文化
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When an application with that attribute runs on a machine in the usual US locale,
    the `ResourceManager` will not attempt to search for resources. It will just go
    straight for the ones compiled into your main assembly.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当带有该属性的应用程序在通常的美国区域设置的计算机上运行时，`ResourceManager`将不会尝试搜索资源。它将直接寻找编译到您的主装配体中的资源。
- en: Protection
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护
- en: In [Chapter 3](ch03.xhtml#ch_types), I described some of the accessibility specifiers
    you can apply to types and their members, such as `private` or `public`. In [Chapter 6](ch06.xhtml#ch_inheritance),
    I showed some of the additional mechanisms available when you use inheritance.
    It’s worth quickly revisiting these features, because assemblies play a part.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第三章](ch03.xhtml#ch_types)中，我描述了可以应用于类型及其成员的一些可访问性限定符，例如`private`或`public`。在[第六章](ch06.xhtml#ch_inheritance)中，我展示了在使用继承时可用的一些附加机制。快速回顾这些功能是值得的，因为装配体发挥了作用。
- en: Also in [Chapter 3](ch03.xhtml#ch_types), I introduced the `internal` keyword
    and said that classes and methods with this accessibility are available only within
    the same *component*, a slightly vague term that I chose because I had not yet
    introduced assemblies. Now that it’s clear what an assembly is, it’s safe for
    me to say that a more precise description of the `internal` keyword is that it
    indicates that a member or type should be accessible only to code in the same
    assembly.^([8](ch12.xhtml#fn38)) Likewise, `protected internal` members are available
    to code in derived types, and also to code defined in the same assembly, and the
    similar but more restrictive `protected private` protection level makes members
    available only to code that is in a derived type that is defined in the same assembly.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 同样在[第三章](ch03.xhtml#ch_types)，我介绍了`internal`关键字，并说具有此可访问性的类和方法仅在*组件*内部可用，这是一个稍微模糊的术语，因为我还没有介绍装配体。现在已经清楚了什么是装配体，我可以安全地说`internal`关键字的更精确描述是指示成员或类型仅对同一装配体中的代码可访问。^([8](ch12.xhtml#fn38))
    同样，`protected internal`成员可供派生类型的代码访问，也可供同一装配体中定义的代码访问，而`protected private`保护级别更为严格，使成员仅对位于同一装配体中定义的派生类型中的代码可用。
- en: Target Frameworks and .NET Standard
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目标框架和 .NET Standard
- en: One of the decisions you need to make for each assembly that you build is the
    target framework or frameworks you will support. Each *.csproj* file will have
    either a `<TargetFramework>` element indicating the target or a `<TargetFrameworks>`
    element containing a list of frameworks. The particular target is indicated with
    a *target framework moniker* (TFM). For example, `netcoreapp3.1` identifies .NET
    Core 3.1, and then with .NET 5.0 the naming convention changed, so we have `net5.0`
    and `net6.0` for .NET 5.0 and .NET 6.0, respectively. For the .NET Framework 4.6.2,
    4.7.2, and 4.8, the TFMs are `net462`, `net472`, and `net48`, respectively. When
    you list multiple target frameworks, you will get multiple assemblies when you
    build, each in its own subfolder named for the TFM. The SDK effectively builds
    the project multiple times.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建每个程序集时，您需要做出的一个决定是选择目标框架或框架。每个 *.csproj* 文件都会有一个 `<TargetFramework>` 元素指示目标，或者一个包含框架列表的
    `<TargetFrameworks>` 元素。特定的目标由 *目标框架代号*（TFM）指示。例如，`netcoreapp3.1` 标识 .NET Core
    3.1，然后随着 .NET 5.0 命名规范的变化，我们有 `net5.0` 和 `net6.0` 分别用于 .NET 5.0 和 .NET 6.0。对于
    .NET Framework 4.6.2、4.7.2 和 4.8，TFMs 分别是 `net462`、`net472` 和 `net48`。当列出多个目标框架时，在构建时将会得到多个程序集，每个程序集位于以
    TFM 命名的自己的子文件夹中。SDK 会有效地多次构建项目。
- en: If you need to provide different code for each target platform (perhaps because
    you can only implement certain functionality on newer target versions), you might
    need to use conditional compilation (described in [“Compilation Symbols”](ch02.xhtml#compilation_symbols)).
    But in cases where the same code works for all targets, it might make sense to
    build for a single target, .NET Standard. As I described in [Chapter 1](ch01.xhtml#ch_introducing_csharp),
    the various versions of .NET Standard define common subsets of the .NET runtime
    libraries that are available across multiple versions of .NET. I said that if
    you need to target both .NET (or .NET Core) and .NET Framework, the best choice
    today is typically .NET Standard 2.0 (which has a TFM of `netstandard2.0`). However,
    it’s worth being aware of the other options, particularly if you’re looking to
    make your component available to the widest possible audience.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要为每个目标平台提供不同的代码（也许是因为只能在更新的目标版本上实现某些功能），您可能需要使用条件编译（在 [“编译符号”](ch02.xhtml#compilation_symbols)
    中描述）。但在同一份代码适用于所有目标的情况下，将代码构建到单个目标，如 .NET Standard，可能是有意义的。正如我在 [第一章](ch01.xhtml#ch_introducing_csharp)
    中描述的那样，各个版本的 .NET Standard 定义了跨多个 .NET 版本可用的 .NET 运行时库的共同子集。我说过，如果您需要同时面向 .NET（或
    .NET Core）和 .NET Framework，今天的最佳选择通常是 .NET Standard 2.0（其 TFM 是 `netstandard2.0`）。然而，了解其他选项也是值得的，特别是如果您希望将组件提供给尽可能广泛的受众。
- en: '.NET libraries published on NuGet may decide to target the lowest version of
    .NET Standard that they can if they want to ensure the broadest reach. Versions
    1.1 through 1.6 gradually added more functionality in exchange for supporting
    a smaller range of targets. (For example, if you want to use a .NET Standard 1.3
    component on .NET Framework, it needs to be .NET Framework 4.6 or later; targeting
    .NET Standard 1.4 requires .NET Framework 4.61 or later.) .NET Standard 2.0 was
    a larger leap forward and marked an important point in .NET Standard’s evolution:
    according to Microsoft’s current plans, this will be the highest version number
    able to run on .NET Framework. Versions of .NET Framework from 4.7.2 onward fully
    support it, but .NET Standard 2.1 will not run on any version of .NET Framework
    now or in the future. It will run on .NET Core 3.0 and 3.1 and .NET 5.0 and later.
    Mono v6.4 and later support it too. But this is the end of the road for the classic
    .NET Framework. In practice, .NET Standard 2.0 is currently a popular choice with
    component authors because it enables the component to run on all recently released
    versions of .NET while providing access to a very broad set of features.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 NuGet 上发布的 .NET 库可能会决定以它们能够支持的最低 .NET Standard 版本为目标，以确保最广泛的覆盖范围。从版本 1.1 到
    1.6，逐步增加了更多功能，作为支持更小范围目标的交换条件。（例如，如果你想在 .NET Framework 上使用一个 .NET Standard 1.3
    组件，需要 .NET Framework 4.6 或更高版本；而目标为 .NET Standard 1.4 需要 .NET Framework 4.61 或更高版本。）.NET
    Standard 2.0 是一个更大的进步，标志着 .NET Standard 进化的重要里程碑：根据微软目前的计划，这将是能在 .NET Framework
    上运行的最高版本号。从 .NET Framework 4.7.2 开始的版本完全支持它，但 .NET Standard 2.1 将不会在任何现在或未来的 .NET
    Framework 版本上运行。它将在 .NET Core 3.0、3.1 以及 .NET 5.0 及以后版本上运行。Mono v6.4 及更高版本也支持它。但这是经典
    .NET Framework 的终结。实际上，目前 .NET Standard 2.0 是组件作者当前流行的选择，因为它使组件能够在所有最近发布的 .NET
    版本上运行，同时提供广泛的功能集。
- en: All of this has caused a certain amount of confusion, and you might be pleased
    to know that the unification brought by .NET 6.0 simplifies things. If you don’t
    need to support .NET Framework, you can just target .NET 6.0, ignoring .NET Standard.
    Mono can run components that target .NET 6.0, and .NET NativeAot is planning to,
    so targeting .NET 6.0 will cover most runtimes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都导致了一定程度的混乱，你可能会高兴地知道，.NET 6.0 带来的统一简化了事情。如果你不需要支持 .NET Framework，可以直接目标
    .NET 6.0，无需考虑 .NET Standard。Mono 可以运行针对 .NET 6.0 的组件，而 .NET NativeAot 也计划支持它，因此目标
    .NET 6.0 将覆盖大多数运行时。
- en: What does this all mean for C# developers? If you are writing code that will
    never be used outside of a particular project, you will normally just target the
    latest version of .NET, unless you need some Windows-specific feature it doesn’t
    offer, in which case you might target .NET Framework. Either way, you will be
    able to use any NuGet package that targets .NET Standard, up to and including
    v2.0 (which means the overwhelming majority of what’s on NuGet will be available
    to you).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 C# 开发人员，这一切意味着什么？如果你正在编写的代码永远不会在特定项目之外使用，通常会直接目标最新版本的 .NET，除非你需要一些它不提供的特定于
    Windows 的功能，此时你可能会目标 .NET Framework。无论哪种方式，你都可以使用任何目标 .NET Standard 的 NuGet 包，包括
    v2.0（这意味着 NuGet 上的绝大多数内容对你都是可用的）。
- en: If you are writing libraries that you intend to share, and if you want your
    components to be available to the largest audience possible, you should target
    .NET Standard unless you absolutely need some feature that is only available in
    a particular runtime. .NET Standard 2.0 is a reasonable choice—you could open
    your library up to a wider audience by dropping to a lower version, but today,
    the versions of .NET that support .NET Standard 2.0 are widely available, so you
    would only contemplate targeting older versions if you need to support developers
    still using older .NET Frameworks. (Microsoft does this in most of its NuGet libraries,
    but you don’t necessarily have to tie yourself to the same regime of support for
    older versions.) Microsoft provides a useful guide to which versions of the various
    .NET implementations support the various [.NET Standard versions](https://oreil.ly/ok1ay).
    If you want to use certain newer features (such as the memory-efficient types
    described in [Chapter 18](ch18.xhtml#ch_memory_efficiency)), you may need to target
    a more recent version of .NET Standard, with 2.1 being the latest at the time
    of writing, but be aware that this rules out running on .NET Framework. At that
    point, you might as well just target .NET Core 3.1 or a later version of .NET,
    because .NET Standard has little to offer in the newly unified post-.NET-Framework
    world. In any case, the development tools will ensure that you only use APIs available
    in whichever version of .NET or .NET Standard you declare support for.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在编写计划共享的库，并且希望您的组件可以提供给尽可能广泛的受众，那么您应该针对 .NET Standard 进行开发，除非您绝对需要某个特定运行时中独有的功能。.NET
    Standard 2.0 是一个合理的选择——通过降低版本，您可以扩大库的受众范围，但是今天，支持 .NET Standard 2.0 的 .NET 版本已经广泛可用，所以只有在需要支持仍在使用旧
    .NET Framework 的开发人员时，才会考虑针对旧版本进行目标定位。（微软在其大多数 NuGet 库中都这样做，但您并不一定要将自己与支持旧版本的同一体系绑定在一起。）微软提供了一个有用的指南，说明各种
    .NET 实现版本支持各种 [.NET Standard 版本](https://oreil.ly/ok1ay)。如果您想使用某些新特性（例如第 [18 章](ch18.xhtml#ch_memory_efficiency)
    中描述的节省内存的类型），可能需要针对更近期的 .NET Standard 版本进行目标定位，目前的最新版本是 2.1，但请注意，这将排除在 .NET Framework
    上运行。在那种情况下，您最好直接将目标设定为 .NET Core 3.1 或更高版本的 .NET，因为 .NET Standard 在新统一的后 .NET
    Framework 世界中提供的功能有限。无论如何，开发工具将确保您只使用您声明支持的 .NET 或 .NET Standard 版本中可用的 API。
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: An assembly is a deployable unit, almost always a single file, typically with
    a *.dll* or *.exe* extension. It is a container for types and code. A type belongs
    to exactly one assembly, and that assembly forms part of the type’s identity—the
    .NET runtime can distinguish between two types with the same name in the same
    namespace if they are defined in different assemblies. Assemblies have a composite
    name consisting of a simple textual name, a four-part version number, a culture
    string, and optionally a public key token. Assemblies with a public key token
    are called *strongly named assemblies*, giving them a globally unique name. Assemblies
    can either be deployed alongside the application that uses them or stored in a
    machine-wide repository. (In .NET Framework, that repository is the Global Assembly
    Cache, and assemblies must be strongly named to use this. .NET and .NET Core provide
    shared copies of built-in assemblies, and depending on how you install these newer
    runtimes, they may also have shared copies of frameworks such as ASP.NET Core
    and WPF. And you can optionally set up a separate runtime package store containing
    other shared assemblies to avoid having to include them in application folders.)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 程序集是一个可部署的单元，几乎总是一个单独的文件，通常使用 *.dll* 或 *.exe* 扩展名。它是类型和代码的容器。每种类型都属于且仅属于一个程序集，而该程序集形成了类型的一部分标识——如果它们在不同的程序集中定义，.NET
    运行时可以区分相同命名空间中具有相同名称的两种类型。程序集有一个复合名称，包括简单的文本名称、一个四部分的版本号、一个文化字符串，以及可选的公钥标记。带有公钥标记的程序集被称为*强命名程序集*，使它们具有全局唯一的名称。程序集可以与使用它们的应用程序一起部署，也可以存储在机器范围的存储库中。（在
    .NET Framework 中，该存储库是全局程序集缓存，必须强命名才能使用。.NET 和 .NET Core 提供了内置程序集的共享副本，根据您如何安装这些更新的运行时，它们也可能具有共享的框架副本，如
    ASP.NET Core 和 WPF。您还可以选择设置一个单独的运行时包存储库，其中包含其他共享程序集，以避免将它们包含在应用程序文件夹中。）
- en: The runtime can load assemblies automatically on demand, which typically happens
    the first time you run a method that contains some code that depends on a type
    defined in the relevant assembly. You can also load assemblies explicitly if you
    need to.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时可以根据需要自动加载程序集，通常是在第一次运行包含某些依赖于相关程序集中定义类型的代码的方法时发生。如果需要，你也可以显式加载程序集。
- en: As I mentioned earlier, every assembly contains comprehensive metadata describing
    the types it contains. In the next chapter, I’ll show how you can get access to
    this metadata at runtime.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，每个程序集都包含详细的元数据描述其包含的类型。在下一章中，我将展示如何在运行时访问这些元数据。
- en: ^([1](ch12.xhtml#fn32-marker)) I’m using *modern* in a very broad sense here—Windows
    NT introduced PE support in 1993.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch12.xhtml#fn32-marker)) 在此，我广义上使用*现代*一词——Windows NT于1993年引入了PE支持。
- en: ^([2](ch12.xhtml#idm45884796226928-marker)) With suitable build settings you
    can produce bootstrappers for all supported targets regardless of which OS you
    build on.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch12.xhtml#idm45884796226928-marker)) 通过适当的构建设置，无论你在哪个操作系统上构建，都可以生成所有支持目标的引导程序。
- en: ^([3](ch12.xhtml#fn34-marker)) This was the year Windows Vista shipped. Application
    manifests existed before then, but this was the first version of Windows to treat
    their absence as signifying legacy code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch12.xhtml#fn34-marker)) 这是Windows Vista发布的年份。应用程序清单在此之前就存在，但这是Windows首次将其缺失视为传统代码的标志。
- en: ^([4](ch12.xhtml#idm45884795868336-marker)) This is not available in .NET Framework
    or .NET Standard. Isolation was typically managed with *appdomains* on .NET Framework,
    an older mechanism that is not supported in .NET or .NET Core.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch12.xhtml#idm45884795868336-marker)) 这在.NET Framework或.NET Standard中不可用。在.NET
    Framework中通常使用*应用程序域*进行隔离，这是一个不支持.NET或.NET Core的旧机制。
- en: ^([5](ch12.xhtml#fn35-marker)) If you use `Assembly.LoadFrom`, the CLR does
    not care whether the filename matches the simple name.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch12.xhtml#fn35-marker)) 如果你使用`Assembly.LoadFrom`，CLR并不关心文件名是否与简单名称匹配。
- en: ^([6](ch12.xhtml#fn36-marker)) It’s possible to configure the CLR to substitute
    a specific different version, but even then, the loaded assembly has to have the
    exact version specified by the configuration.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch12.xhtml#fn36-marker)) 可以配置CLR以替换特定的不同版本，但即使如此，加载的程序集也必须与配置指定的确切版本匹配。
- en: ^([7](ch12.xhtml#fn37-marker)) Hove, England.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch12.xhtml#fn37-marker)) 英格兰，霍夫。
- en: ^([8](ch12.xhtml#fn38-marker)) Internal items are also available to *friend
    assemblies*, meaning any assemblies referred to with an `InternalsVisibleTo` attribute,
    as described in [Chapter 14](ch14.xhtml#ch_attributes).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch12.xhtml#fn38-marker)) 内部项目也适用于*友元程序集*，这意味着任何在`InternalsVisibleTo`属性中引用的程序集，如[第14章](ch14.xhtml#ch_attributes)所述。
