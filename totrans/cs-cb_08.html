<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. Matching with Patterns"><div class="chapter" id="matching_with_patterns">
<h1><span class="label">Chapter 8. </span>Matching with Patterns</h1>


<p><a data-type="indexterm" data-primary="pattern matching" id="ix_ch08-asciidoc0"/>Historically, developers have implemented business rules with various logical checks and comparisons. Sometimes the rules are complex—naturally leading to code that’s difficult to write, read, and maintain. Think about how often you’ve encountered multibranch logic with multivariate comparisons and multiple levels of nesting.</p>

<p>To help ease this complexity, modern programming languages have begun introducing pattern matching—features of the language that help match facts to results with declarative syntax. In C#, pattern matching manifests as a growing list of features added in each new version, especially from C# 7 and later.</p>

<p>The theme of this chapter revolves around hotel scheduling and using patterns for business rules. The criteria is usually around a type of customer such as Bronze, Silver, or Gold, with Gold being the highest level because those customers have more points from more frequent hotel stays.</p>

<p>This chapter discusses pattern matching for properties, tuples, and types. There’s also a couple of sections on logical operations and how they enable and simplify multiconditional patterns. Surprisingly, C# had some form of pattern matching since v1.0. The first section of this chapter discusses the <code>is</code> and <code>as</code> operators and shows the new enhancements to the <code>is</code> operator.</p>






<section data-type="sect1" data-pdf-bookmark="8.1 Converting Instances Safely"><div class="sect1" id="idm45678765314912">
<h1>8.1 Converting Instances Safely</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45678765313872">
<h2>Problem</h2>

<p><a data-type="indexterm" data-primary="instances" data-secondary="converting safely" id="ix_ch08-asciidoc1"/><a data-type="indexterm" data-primary="legacy code, converting instances safely from" id="ix_ch08-asciidoc2"/><a data-type="indexterm" data-primary="pattern matching" data-secondary="converting instances safely" id="ix_ch08-asciidoc3"/>Your legacy code is weakly typed, relies on procedural patterns, and needs to be <span class="keep-together">refactored</span>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45678765308064">
<h2>Solution</h2>

<p>Here’s an interface and implementing classes that produce results we’re looking for:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">interface</code> <code class="n">IRoomSchedule</code>
<code class="p">{</code>
    <code class="k">void</code> <code class="nf">ScheduleRoom</code><code class="p">();</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">GoldSchedule</code> <code class="p">:</code> <code class="n">IRoomSchedule</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">void</code> <code class="nf">ScheduleRoom</code><code class="p">()</code> <code class="p">=&gt;</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Scheduling Gold Room"</code><code class="p">);</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">SilverSchedule</code> <code class="p">:</code> <code class="n">IRoomSchedule</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">void</code> <code class="nf">ScheduleRoom</code><code class="p">()</code> <code class="p">=&gt;</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Scheduling Silver Room"</code><code class="p">);</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">BronzeSchedule</code> <code class="p">:</code> <code class="n">IRoomSchedule</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">void</code> <code class="nf">ScheduleRoom</code><code class="p">()</code> <code class="p">=&gt;</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Scheduling Bronze Room"</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>Here’s a method representing data returned in legacy nontyped instances:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="n">ArrayList</code> <code class="nf">GetWeakTypedSchedules</code><code class="p">()</code>
<code class="p">{</code>
    <code class="kt">var</code> <code class="n">list</code> <code class="p">=</code> <code class="k">new</code> <code class="n">ArrayList</code><code class="p">();</code>

    <code class="n">list</code><code class="p">.</code><code class="n">Add</code><code class="p">(</code><code class="k">new</code> <code class="n">BronzeSchedule</code><code class="p">());</code>
    <code class="n">list</code><code class="p">.</code><code class="n">Add</code><code class="p">(</code><code class="k">new</code> <code class="n">SilverSchedule</code><code class="p">());</code>
    <code class="n">list</code><code class="p">.</code><code class="n">Add</code><code class="p">(</code><code class="k">new</code> <code class="n">GoldSchedule</code><code class="p">());</code>

    <code class="k">return</code> <code class="n">list</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>And this code processes the legacy collection:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="k">void</code> <code class="nf">ProcessLegacyCode</code><code class="p">()</code>
<code class="p">{</code>
    <code class="n">ArrayList</code> <code class="n">schedules</code> <code class="p">=</code> <code class="n">GetWeakTypedSchedules</code><code class="p">();</code>

    <code class="k">foreach</code> <code class="p">(</code><code class="kt">var</code> <code class="n">schedule</code> <code class="k">in</code> <code class="n">schedules</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="n">schedule</code> <code class="k">is</code> <code class="n">IRoomSchedule</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="n">IRoomSchedule</code> <code class="n">roomSchedule</code> <code class="p">=</code> <code class="p">(</code><code class="n">IRoomSchedule</code><code class="p">)</code><code class="n">schedule</code><code class="p">;</code>
            <code class="n">roomSchedule</code><code class="p">.</code><code class="n">ScheduleRoom</code><code class="p">();</code>
        <code class="p">}</code>

        <code class="c1">//</code>
        <code class="c1">// alternatively</code>
        <code class="c1">//</code>

        <code class="n">IRoomSchedule</code> <code class="n">asRoomSchedule</code> <code class="p">=</code> <code class="n">schedule</code> <code class="k">as</code> <code class="n">IRoomSchedule</code><code class="p">;</code>

        <code class="k">if</code> <code class="p">(</code><code class="n">asRoomSchedule</code> <code class="p">!=</code> <code class="k">null</code><code class="p">)</code>
            <code class="n">asRoomSchedule</code><code class="p">.</code><code class="n">ScheduleRoom</code><code class="p">();</code>

        <code class="c1">//</code>
        <code class="c1">// even better</code>
        <code class="c1">//</code>

        <code class="k">if</code> <code class="p">(</code><code class="n">schedule</code> <code class="k">is</code> <code class="n">IRoomSchedule</code> <code class="n">isRoomSchedule</code><code class="p">)</code>
            <code class="n">isRoomSchedule</code><code class="p">.</code><code class="n">ScheduleRoom</code><code class="p">();</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>Here’s more modern code that returns a strongly typed collection:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">IRoomSchedule</code><code class="p">&gt;</code> <code class="n">GetStrongTypedSchedules</code><code class="p">()</code>
<code class="p">{</code>
    <code class="k">return</code> <code class="k">new</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">IRoomSchedule</code><code class="p">&gt;</code>
    <code class="p">{</code>
        <code class="k">new</code> <code class="nf">BronzeSchedule</code><code class="p">(),</code>
        <code class="k">new</code> <code class="nf">SilverSchedule</code><code class="p">(),</code>
        <code class="k">new</code> <code class="nf">GoldSchedule</code><code class="p">()</code>
    <code class="p">};</code>
<code class="p">}</code></pre>

<p>And this code processes the strongly typed collection:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="k">void</code> <code class="nf">ProcessModernCode</code><code class="p">()</code>
<code class="p">{</code>
    <code class="n">List</code><code class="p">&lt;</code><code class="n">IRoomSchedule</code><code class="p">&gt;</code> <code class="n">schedules</code> <code class="p">=</code> <code class="n">GetStrongTypedSchedules</code><code class="p">();</code>

    <code class="k">foreach</code> <code class="p">(</code><code class="kt">var</code> <code class="n">schedule</code> <code class="k">in</code> <code class="n">schedules</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">schedule</code><code class="p">.</code><code class="n">ScheduleRoom</code><code class="p">();</code>

        <code class="k">if</code> <code class="p">(</code><code class="n">schedule</code> <code class="k">is</code> <code class="n">GoldSchedule</code> <code class="n">gold</code><code class="p">)</code>
            <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code>
                <code class="err">$</code><code class="s">"Extra processing for {gold.GetType()}"</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>The <code>Main</code> methods call both the legacy and modern versions:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="k">void</code> <code class="nf">Main</code><code class="p">()</code>
<code class="p">{</code>
    <code class="n">ProcessLegacyCode</code><code class="p">();</code>
    <code class="n">ProcessModernCode</code><code class="p">();</code>
<code class="p">}</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45678765307536">
<h2>Discussion</h2>

<p><a data-type="indexterm" data-primary="as operator" id="idm45678764883296"/><a data-type="indexterm" data-primary="is operator" id="idm45678764882368"/>The <code>as</code> and <code>is</code> operators appeared in C# 1; you’re probably aware of and/or have used them. To recap, the <code>is</code> operator tells whether an object’s type is the same as the type being matched. The <code>as</code> operator performs a conversion of a reference type object to a specified type. The <code>as</code> operator returns <code>null</code> if the converted instance isn’t the specified type. This example also demonstrates a recent C# addition that allows both type checking and conversion with the <code>is</code> operator.</p>

<p>Most of the code we write today uses generic collections and it’s increasingly unnecessary to use weakly typed collections. I’ll go out on a limb here and say that you might adopt a rule of thumb to use generic collections as a default, with the exception being when you can’t avoid using weakly typed collections. One important situation where you have to use weakly typed collections is when maintaining legacy code that already uses them. Generics weren’t added until C# 2, so you might encounter some old code with weakly typed collections. Another example is when you have a library you need or want to use that uses weakly typed collections. In practical terms, you might not want to rewrite that code because of the time and resources required—especially if it’s already tested and working well.</p>

<p>In the solution, the <code>GetWeakTypedSchedules</code> method returns an <code>ArrayList</code>, which is a weakly typed collection because it only operates on instances of type <code>Object</code>. The <code>ProcessLegacyCode</code> method calls <code>GetWeakTypedSchedules</code> and shows how to use the <code>as</code> and <code>is</code> operators.</p>

<p>The first <code>if</code> statement in the <code>foreach</code> loop uses the <code>is</code> operator to determine whether the object is an <code>IRoomSchedule</code>. If so, it uses a cast operator to get an <code>IRoomSchedule</code> instance and calls <code>GetSchedule</code>. You might ask why the <code>is</code> operator is necessary if we already know that the collection contains <code>IRoomSchedule</code> instances—why don’t we just go straight for the conversion? The problem is that there isn’t a guarantee of what the types in that collection are. What if a developer accidentally loads an object that isn’t <code>IRoomSchedule</code> into the collection? The <code>is</code> operator improves the reliability of the code.</p>

<p>An alternative to the <code>is</code> operator is the <code>as</code> operator. In the solution, the <code>schedule as IRoomSchedule</code> performs the conversion. If the result isn’t <code>null</code>, the object is an <code>IRoomSchedule</code>. This approach could perform better because an <code>is</code> operation both checks the type and still requires a conversion, whereas the <code>as</code> operator only requires a conversion and a <code>null</code> check.</p>

<p>The final <code>if</code> statement demonstrates the newer <code>is</code> operator syntax. It does both the type check and conversion, assigning the result to the <code>isRoomSchedule</code> variable. The <code>isRoomSchedule</code> variable is <code>null</code> if <code>schedule</code> wasn’t an <code>IRoomSchedule</code>, but since the <code>is</code> operator returned a <code>bool</code> result, we don’t need to do the extra <code>null</code> check.</p>

<p>The <code>GetStrongTypedSchedules</code> and <code>ProcessModernCode</code> show how you would probably want to write the code today. Notice how it has less ceremony because of the strong typing. Each class implements the same interface, and the collection is that interface, allowing you to write code that operates efficiently on every object.</p>

<p>This example also demonstrates that the new <code>is</code> operator can be useful in current code (not only legacy). In <code>ProcessModernCode</code>, even though all the objects implement <code>IRoomSchedule</code>, the <code>is</code> operator lets us check for <code>GoldSchedule</code> and do some extra processing.<a data-type="indexterm" data-startref="ix_ch08-asciidoc3" id="idm45678764828976"/><a data-type="indexterm" data-startref="ix_ch08-asciidoc2" id="idm45678764828272"/><a data-type="indexterm" data-startref="ix_ch08-asciidoc1" id="idm45678764827600"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="8.2 Catching Filtered Exceptions"><div class="sect1" id="idm45678764826800">
<h1>8.2 Catching Filtered Exceptions</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45678764825888">
<h2>Problem</h2>

<p><a data-type="indexterm" data-primary="exception handling" data-secondary="catching filtered exceptions" id="ix_ch08-asciidoc4"/><a data-type="indexterm" data-primary="filters" data-secondary="catching filtered exceptions" id="ix_ch08-asciidoc5"/><a data-type="indexterm" data-primary="pattern matching" data-secondary="catching filtered exceptions" id="ix_ch08-asciidoc6"/>You need to handle logic for the same exception type with different conditions.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45678764820640">
<h2>Solution</h2>

<p>This is a demo class that throws exceptions:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">class</code> <code class="nc">Scheduler</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">void</code> <code class="nf">ScheduleRoom</code><code class="p">(</code><code class="kt">string</code> <code class="n">arg1</code><code class="p">,</code> <code class="kt">string</code> <code class="n">arg2</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">_</code> <code class="p">=</code> <code class="n">arg1</code> <code class="p">??</code> <code class="k">throw</code> <code class="k">new</code> <code class="n">ArgumentNullException</code><code class="p">(</code><code class="n">nameof</code><code class="p">(</code><code class="n">arg1</code><code class="p">));</code>
        <code class="n">_</code> <code class="p">=</code> <code class="n">arg2</code> <code class="p">??</code> <code class="k">throw</code> <code class="k">new</code> <code class="n">ArgumentNullException</code><code class="p">(</code><code class="n">nameof</code><code class="p">(</code><code class="n">arg2</code><code class="p">));</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>This <code>Main</code> method uses exception filters for clean processing:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="k">void</code> <code class="nf">Main</code><code class="p">()</code>
<code class="p">{</code>
    <code class="k">try</code>
    <code class="p">{</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">Write</code><code class="p">(</code><code class="s">"Choose (1) arg1 or (2) arg2? "</code><code class="p">);</code>
        <code class="kt">string</code> <code class="n">arg</code> <code class="p">=</code> <code class="n">Console</code><code class="p">.</code><code class="n">ReadLine</code><code class="p">();</code>

        <code class="kt">var</code> <code class="n">scheduler</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Scheduler</code><code class="p">();</code>

        <code class="k">if</code> <code class="p">(</code><code class="n">arg</code> <code class="p">==</code> <code class="s">"1"</code><code class="p">)</code>
            <code class="n">scheduler</code><code class="p">.</code><code class="n">ScheduleRoom</code><code class="p">(</code><code class="k">null</code><code class="p">,</code> <code class="s">"arg2"</code><code class="p">);</code>
        <code class="k">else</code>
            <code class="n">scheduler</code><code class="p">.</code><code class="n">ScheduleRoom</code><code class="p">(</code><code class="s">"arg1"</code><code class="p">,</code> <code class="k">null</code><code class="p">);</code>
    <code class="p">}</code>
    <code class="k">catch</code> <code class="p">(</code><code class="n">ArgumentNullException</code> <code class="n">ex1</code><code class="p">)</code>
        <code class="k">when</code> <code class="p">(</code><code class="n">ex1</code><code class="p">.</code><code class="n">ParamName</code> <code class="p">==</code> <code class="s">"arg1"</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Invalid arg1"</code><code class="p">);</code>
    <code class="p">}</code>
    <code class="k">catch</code> <code class="p">(</code><code class="n">ArgumentNullException</code> <code class="n">ex2</code><code class="p">)</code>
        <code class="k">when</code> <code class="p">(</code><code class="n">ex2</code><code class="p">.</code><code class="n">ParamName</code> <code class="p">==</code> <code class="s">"arg2"</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Invalid arg2"</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45678764743312">
<h2>Discussion</h2>

<p>An interesting addition to C#, related to pattern matching, is the exception filter. As you know, <code>catch</code> blocks operate on the type of exception thrown. However, when the same exception type can be thrown for different reasons, sometimes it’s useful to be able to differentiate processing for each reason. While you could add <code>if</code> or <code>switch</code> statements in the <code>catch</code> block, filters offer a clean way to separate and simplify the different logic.</p>

<p>In the solution, we’re interested in filtering <code>ArgumentNullException</code>, depending on which parameter is <code>null</code>. The <code>ScheduleRoom</code> method checks each parameter and throws <code>ArgumentNullException</code> if either is <code>null</code>.</p>

<p>The <code>Main</code> method wraps the call to <code>ScheduleRoom</code> in a <code>try</code>/<code>catch</code> block. This example has two <code>catch</code> blocks, each of type <code>ArgumentNullException</code>. The difference between the two is the filter, specified by the <code>when</code> clause. The parameter to <code>when</code> is a <code>bool</code> expression. In the solution, the expression compares the <code>ParamName</code> to the parameter name it’s designed to handle.<a data-type="indexterm" data-startref="ix_ch08-asciidoc6" id="idm45678764591712"/><a data-type="indexterm" data-startref="ix_ch08-asciidoc5" id="idm45678764591008"/><a data-type="indexterm" data-startref="ix_ch08-asciidoc4" id="idm45678764590336"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="8.3 Simplifying Switch Assignments"><div class="sect1" id="idm45678764589536">
<h1>8.3 Simplifying Switch Assignments</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45678764588592">
<h2>Problem</h2>

<p><a data-type="indexterm" data-primary="code simplification" data-secondary="simplifying switch assignments" id="ix_ch08-asciidoc7"/><a data-type="indexterm" data-primary="pattern matching" data-secondary="simplifying switch assignments" id="ix_ch08-asciidoc8"/><a data-type="indexterm" data-primary="switch statements/switch expressions" data-secondary="simplifying switch assignments" id="ix_ch08-asciidoc9"/>You want to return a value, based on some criteria, but don’t want to return from every <code>switch</code> case.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45678764582720">
<h2>Solution</h2>

<p>Here’s an interface and implementing classes that are results we’re looking for:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">interface</code> <code class="n">IRoomSchedule</code>
<code class="p">{</code>
    <code class="k">void</code> <code class="nf">ScheduleRoom</code><code class="p">();</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">GoldSchedule</code> <code class="p">:</code> <code class="n">IRoomSchedule</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">void</code> <code class="nf">ScheduleRoom</code><code class="p">()</code> <code class="p">=&gt;</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Scheduling Gold Room"</code><code class="p">);</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">SilverSchedule</code> <code class="p">:</code> <code class="n">IRoomSchedule</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">void</code> <code class="nf">ScheduleRoom</code><code class="p">()</code> <code class="p">=&gt;</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Scheduling Silver Room"</code><code class="p">);</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">BronzeSchedule</code> <code class="p">:</code> <code class="n">IRoomSchedule</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">void</code> <code class="nf">ScheduleRoom</code><code class="p">()</code> <code class="p">=&gt;</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Scheduling Bronze Room"</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>This enum is used in upcoming logic:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">enum</code> <code class="n">ScheduleType</code>
<code class="p">{</code>
    <code class="n">None</code><code class="p">,</code>
    <code class="n">Bronze</code><code class="p">,</code>
    <code class="n">Silver</code><code class="p">,</code>
    <code class="n">Gold</code>
<code class="p">}</code></pre>

<p>This class shows the <code>switch</code> statement and new <code>switch</code> expression:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">class</code> <code class="nc">Scheduler</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="n">IRoomSchedule</code> <code class="nf">CreateStatement</code><code class="p">(</code>
        <code class="n">ScheduleType</code> <code class="n">scheduleType</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="k">switch</code> <code class="p">(</code><code class="n">scheduleType</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="k">case</code> <code class="n">ScheduleType</code><code class="p">.</code><code class="n">Gold</code><code class="p">:</code>
                <code class="k">return</code> <code class="k">new</code> <code class="nf">GoldSchedule</code><code class="p">();</code>
            <code class="k">case</code> <code class="n">ScheduleType</code><code class="p">.</code><code class="n">Silver</code><code class="p">:</code>
                <code class="k">return</code> <code class="k">new</code> <code class="nf">SilverSchedule</code><code class="p">();</code>
            <code class="k">case</code> <code class="n">ScheduleType</code><code class="p">.</code><code class="n">Bronze</code><code class="p">:</code>
            <code class="k">default</code><code class="p">:</code>
                <code class="k">return</code> <code class="k">new</code> <code class="nf">BronzeSchedule</code><code class="p">();</code>
        <code class="p">}</code>
    <code class="p">}</code>

    <code class="k">public</code> <code class="n">IRoomSchedule</code> <code class="nf">CreateExpression</code><code class="p">(</code>
        <code class="n">ScheduleType</code> <code class="n">scheduleType</code><code class="p">)</code> <code class="p">=&gt;</code>
            <code class="n">scheduleType</code> <code class="k">switch</code>
            <code class="p">{</code>
                <code class="n">ScheduleType</code><code class="p">.</code><code class="n">Gold</code> <code class="p">=&gt;</code> <code class="k">new</code> <code class="n">GoldSchedule</code><code class="p">(),</code>
                <code class="n">ScheduleType</code><code class="p">.</code><code class="n">Silver</code> <code class="p">=&gt;</code> <code class="k">new</code> <code class="n">SilverSchedule</code><code class="p">(),</code>
                <code class="n">ScheduleType</code><code class="p">.</code><code class="n">Bronze</code> <code class="p">=&gt;</code> <code class="k">new</code> <code class="n">BronzeSchedule</code><code class="p">(),</code>
                <code class="n">_</code> <code class="p">=&gt;</code> <code class="k">new</code> <code class="n">BronzeSchedule</code><code class="p">()</code>
            <code class="p">};</code>
<code class="p">}</code></pre>

<p class="pagebreak-before less_space">The <code>Main</code> method tests the code:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="k">void</code> <code class="nf">Main</code><code class="p">()</code>
<code class="p">{</code>
    <code class="n">Console</code><code class="p">.</code><code class="n">Write</code><code class="p">(</code>
        <code class="s">"Choose (1) Bronze, (2) Silver, or (3) Gold: "</code><code class="p">);</code>
    <code class="kt">string</code> <code class="n">choice</code> <code class="p">=</code> <code class="n">Console</code><code class="p">.</code><code class="n">ReadLine</code><code class="p">();</code>

    <code class="n">Enum</code><code class="p">.</code><code class="n">TryParse</code><code class="p">(</code><code class="n">choice</code><code class="p">,</code> <code class="k">out</code> <code class="n">ScheduleType</code> <code class="n">scheduleType</code><code class="p">);</code>

    <code class="kt">var</code> <code class="n">scheduler</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Scheduler</code><code class="p">();</code>

    <code class="n">IRoomSchedule</code> <code class="n">scheduleStatement</code> <code class="p">=</code>
        <code class="n">scheduler</code><code class="p">.</code><code class="n">CreateStatement</code><code class="p">(</code><code class="n">scheduleType</code><code class="p">);</code>
    <code class="n">scheduleStatement</code><code class="p">.</code><code class="n">ScheduleRoom</code><code class="p">();</code>

    <code class="n">IRoomSchedule</code> <code class="n">scheduleExpression</code> <code class="p">=</code>
        <code class="n">scheduler</code><code class="p">.</code><code class="n">CreateExpression</code><code class="p">(</code><code class="n">scheduleType</code><code class="p">);</code>
    <code class="n">scheduleExpression</code><code class="p">.</code><code class="n">ScheduleRoom</code><code class="p">();</code>
<code class="p">}</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45678764303600">
<h2>Discussion</h2>

<p><a data-type="indexterm" data-primary="switch statements/switch expressions" data-secondary="switch statements versus switch expressions" id="idm45678764302448"/>The <code>switch</code> statement has been around since C# 1, and a recent addition is a <code>switch</code> expression. The main syntactic features of the <code>switch</code> expression are a shorthand notation and the ability to assign a result to a variable. If you think about all the times you’ve used a <code>switch</code> statement, you might have noticed that producing a value or new instance was a common theme. The <code>switch</code> expression streamlines that theme and improves upon it with pattern matching.</p>

<p>The solution has two examples: a <code>switch</code> statement and a <code>switch</code> expression. Both rely on the <code>ScheduleType</code> enum for criteria and produce an <code>IRoomSchedule</code> type, based on that criteria.</p>

<p>The <code>CreateStatement</code> method uses a <code>switch</code> statement, with <code>case</code> clauses for each member of the <code>ScheduleType</code> enum. Notice how it returns the value from the method and that it requires normal block body syntax (with curly braces).</p>

<p>The <code>CreateExpression</code> method uses the new <code>switch</code> expression. Notice that the method can be command body (with arrow), returning the expression. Instead of a parameter in parentheses after the <code>switch</code> keyword, the parameter precedes the <code>switch</code> keyword. Also, instead of <code>case</code> clauses, case pattern matches precede an arrow, with the result expression after the arrow. The default case is the discard <span class="keep-together">pattern</span>, <code>_</code>.</p>

<p>Whenever the parameter matches the case pattern, the <code>switch</code> expression returns the result. In the solution, the patterns are the values of the <code>ScheduleType</code> enum. The result of the <code>switch</code> expression is the result of the method because the command syntax of the method specifies the <code>switch</code> expression.</p>

<p>If you have a use case where there’s logic to process for each case, but don’t need to return, a classic <code>switch</code> statement might make more sense. However, if you can use pattern matching and need to return a value, the <code>switch</code> expression can be an excellent choice.<a data-type="indexterm" data-startref="ix_ch08-asciidoc9" id="idm45678764188368"/><a data-type="indexterm" data-startref="ix_ch08-asciidoc8" id="idm45678764187664"/><a data-type="indexterm" data-startref="ix_ch08-asciidoc7" id="idm45678764186992"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="8.4 Switching on Property Values"><div class="sect1" id="switching_on_property_values">
<h1>8.4 Switching on Property Values</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45678764184544">
<h2>Problem</h2>

<p><a data-type="indexterm" data-primary="pattern matching" data-secondary="switching on property values" id="ix_ch08-asciidoc10"/><a data-type="indexterm" data-primary="properties" data-secondary="switching on property values" id="ix_ch08-asciidoc11"/><a data-type="indexterm" data-primary="switch statements/switch expressions" data-secondary="switching on property values" id="ix_ch08-asciidoc12"/>You need business rules based on strongly typed class properties.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45678764179168">
<h2>Solution</h2>

<p>Here’s a class with properties that we need to evaluate:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">class</code> <code class="nc">Room</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="kt">int</code> <code class="n">Number</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
    <code class="k">public</code> <code class="kt">string</code> <code class="n">RoomType</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
    <code class="k">public</code> <code class="kt">string</code> <code class="n">BedSize</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code></pre>

<p>This enum is the result of the evaluation:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">enum</code> <code class="n">ScheduleType</code>
<code class="p">{</code>
    <code class="n">None</code><code class="p">,</code>
    <code class="n">Bronze</code><code class="p">,</code>
    <code class="n">Silver</code><code class="p">,</code>
    <code class="n">Gold</code>
<code class="p">}</code></pre>

<p>This method gets the data we need:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Room</code><code class="p">&gt;</code> <code class="n">GetRooms</code><code class="p">()</code>
<code class="p">{</code>
    <code class="k">return</code> <code class="k">new</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Room</code><code class="p">&gt;</code>
    <code class="p">{</code>
        <code class="k">new</code> <code class="n">Room</code>
        <code class="p">{</code>
            <code class="n">Number</code> <code class="p">=</code> <code class="m">333</code><code class="p">,</code>
            <code class="n">BedSize</code> <code class="p">=</code> <code class="s">"King"</code><code class="p">,</code>
            <code class="n">RoomType</code> <code class="p">=</code> <code class="s">"Suite"</code>
        <code class="p">},</code>
        <code class="k">new</code> <code class="n">Room</code>
        <code class="p">{</code>
            <code class="n">Number</code> <code class="p">=</code> <code class="m">222</code><code class="p">,</code>
            <code class="n">BedSize</code> <code class="p">=</code> <code class="s">"King"</code><code class="p">,</code>
            <code class="n">RoomType</code> <code class="p">=</code> <code class="s">"Regular"</code>
        <code class="p">},</code>
        <code class="k">new</code> <code class="n">Room</code>
        <code class="p">{</code>
            <code class="n">Number</code> <code class="p">=</code> <code class="m">111</code><code class="p">,</code>
            <code class="n">BedSize</code> <code class="p">=</code> <code class="s">"Queen"</code><code class="p">,</code>
            <code class="n">RoomType</code> <code class="p">=</code> <code class="s">"Regular"</code>
        <code class="p">},</code>
    <code class="p">};</code>
<code class="p">}</code></pre>

<p>This method uses that data and returns an enum, based on matching pattern:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">const</code> <code class="kt">int</code> <code class="n">RoomNotAvailable</code> <code class="p">=</code> <code class="p">-</code><code class="m">1</code><code class="p">;</code>

<code class="k">static</code> <code class="kt">int</code> <code class="nf">AssignRoom</code><code class="p">(</code><code class="n">ScheduleType</code> <code class="n">scheduleType</code><code class="p">)</code>
<code class="p">{</code>
    <code class="k">foreach</code> <code class="p">(</code><code class="kt">var</code> <code class="n">room</code> <code class="k">in</code> <code class="n">GetRooms</code><code class="p">())</code>
    <code class="p">{</code>
        <code class="n">ScheduleType</code> <code class="n">roomType</code> <code class="p">=</code> <code class="n">room</code> <code class="k">switch</code>
        <code class="p">{</code>
            <code class="p">{</code> <code class="n">BedSize</code><code class="p">:</code> <code class="s">"King"</code><code class="p">,</code> <code class="n">RoomType</code><code class="p">:</code> <code class="s">"Suite"</code> <code class="p">}</code>
                <code class="p">=&gt;</code> <code class="n">ScheduleType</code><code class="p">.</code><code class="n">Gold</code><code class="p">,</code>
            <code class="p">{</code> <code class="n">BedSize</code><code class="p">:</code> <code class="s">"King"</code><code class="p">,</code> <code class="n">RoomType</code><code class="p">:</code> <code class="s">"Regular"</code> <code class="p">}</code>
                <code class="p">=&gt;</code> <code class="n">ScheduleType</code><code class="p">.</code><code class="n">Silver</code><code class="p">,</code>
            <code class="p">{</code> <code class="n">BedSize</code><code class="p">:</code> <code class="s">"Queen"</code><code class="p">,</code> <code class="n">RoomType</code><code class="p">:</code> <code class="s">"Regular"</code> <code class="p">}</code>
                <code class="p">=&gt;</code> <code class="n">ScheduleType</code><code class="p">.</code><code class="n">Bronze</code><code class="p">,</code>
            <code class="n">_</code> <code class="p">=&gt;</code> <code class="n">ScheduleType</code><code class="p">.</code><code class="n">Bronze</code>
        <code class="p">};</code>

        <code class="k">if</code> <code class="p">(</code><code class="n">roomType</code> <code class="p">==</code> <code class="n">scheduleType</code><code class="p">)</code>
            <code class="k">return</code> <code class="n">room</code><code class="p">.</code><code class="n">Number</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">return</code> <code class="n">RoomNotAvailable</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>The <code>Main</code> method drives the program:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="k">void</code> <code class="nf">Main</code><code class="p">()</code>
<code class="p">{</code>
    <code class="n">Console</code><code class="p">.</code><code class="n">Write</code><code class="p">(</code>
        <code class="s">"Choose (1) Bronze, (2) Silver, or (3) Gold: "</code><code class="p">);</code>
    <code class="kt">string</code> <code class="n">choice</code> <code class="p">=</code> <code class="n">Console</code><code class="p">.</code><code class="n">ReadLine</code><code class="p">();</code>

    <code class="n">Enum</code><code class="p">.</code><code class="n">TryParse</code><code class="p">(</code><code class="n">choice</code><code class="p">,</code> <code class="k">out</code> <code class="n">ScheduleType</code> <code class="n">scheduleType</code><code class="p">);</code>

    <code class="kt">int</code> <code class="n">roomNumber</code> <code class="p">=</code> <code class="n">AssignRoom</code><code class="p">(</code><code class="n">scheduleType</code><code class="p">);</code>

    <code class="k">if</code> <code class="p">(</code><code class="n">roomNumber</code> <code class="p">==</code> <code class="n">RoomNotAvailable</code><code class="p">)</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Room not available."</code><code class="p">);</code>
    <code class="k">else</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"The room number is {roomNumber}."</code><code class="p">);</code>
<code class="p">}</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45678764178576">
<h2>Discussion</h2>

<p>In the past, a <code>switch</code> statement matched cases with the value of a single parameter. Now, you can do parameter matching based on the values of properties in an object.</p>

<p>The solution uses an instance of the <code>Room</code> class as the parameter to a <code>switch</code> expression in the <code>AssignRoom</code> method. The pattern is an object with the properties of <code>Room</code> and the values to match. The result returned is based on which pattern the properties of the parameter match.</p>

<p>The goal of the program is to find an available room for a customer. The purpose of <code>AssignRoom</code> is to return the first room associated with a specific schedule type. That’s why <code>AssignRoom</code> compares <code>roomType</code> and <code>scheduleType</code>, returning if they match.</p>

<p>Property pattern matching is a nice approach because it’s easy to read. This potentially translates into more maintainable code. One trade-off is that it can be verbose if you’re matching a lot of properties. The next recipe offers shorter syntax.<a data-type="indexterm" data-startref="ix_ch08-asciidoc12" id="idm45678763730624"/><a data-type="indexterm" data-startref="ix_ch08-asciidoc11" id="idm45678763729920"/><a data-type="indexterm" data-startref="ix_ch08-asciidoc10" id="idm45678763729248"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm45678763728448">
<h2>See Also</h2>

<p><a data-type="xref" data-xrefstyle="rec-num-title" href="#switching_on_tuples">Recipe 8.5, “Switching on Tuples”</a></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="8.5 Switching on Tuples"><div class="sect1" id="switching_on_tuples">
<h1>8.5 Switching on Tuples</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45678763724400">
<h2>Problem</h2>

<p><a data-type="indexterm" data-primary="pattern matching" data-secondary="switching on tuples" id="ix_ch08-asciidoc13"/><a data-type="indexterm" data-primary="switch statements/switch expressions" data-secondary="switching on tuples" id="ix_ch08-asciidoc14"/><a data-type="indexterm" data-primary="tuples" data-secondary="switching on" id="ix_ch08-asciidoc15"/>You need business rules and prefer shorter syntax.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45678763719024">
<h2>Solution</h2>

<p>This class is interesting because it has a deconstructor:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">class</code> <code class="nc">Room</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="kt">int</code> <code class="n">Number</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
    <code class="k">public</code> <code class="kt">string</code> <code class="n">RoomType</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
    <code class="k">public</code> <code class="kt">string</code> <code class="n">BedSize</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>

    <code class="k">public</code> <code class="k">void</code> <code class="nf">Deconstruct</code><code class="p">(</code><code class="k">out</code> <code class="kt">string</code> <code class="n">size</code><code class="p">,</code> <code class="k">out</code> <code class="kt">string</code> <code class="n">type</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">size</code> <code class="p">=</code> <code class="n">BedSize</code><code class="p">;</code>
        <code class="n">type</code> <code class="p">=</code> <code class="n">RoomType</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>Here’s an enum that this program will produce:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">enum</code> <code class="n">ScheduleType</code>
<code class="p">{</code>
    <code class="n">None</code><code class="p">,</code>
    <code class="n">Bronze</code><code class="p">,</code>
    <code class="n">Silver</code><code class="p">,</code>
    <code class="n">Gold</code>
<code class="p">}</code></pre>

<p>Here’s the data the program will work with:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Room</code><code class="p">&gt;</code> <code class="n">GetRooms</code><code class="p">()</code>
<code class="p">{</code>
    <code class="k">return</code> <code class="k">new</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Room</code><code class="p">&gt;</code>
    <code class="p">{</code>
        <code class="k">new</code> <code class="n">Room</code>
        <code class="p">{</code>
            <code class="n">Number</code> <code class="p">=</code> <code class="m">333</code><code class="p">,</code>
            <code class="n">BedSize</code> <code class="p">=</code> <code class="s">"King"</code><code class="p">,</code>
            <code class="n">RoomType</code> <code class="p">=</code> <code class="s">"Suite"</code>
        <code class="p">},</code>
        <code class="k">new</code> <code class="n">Room</code>
        <code class="p">{</code>
            <code class="n">Number</code> <code class="p">=</code> <code class="m">222</code><code class="p">,</code>
            <code class="n">BedSize</code> <code class="p">=</code> <code class="s">"King"</code><code class="p">,</code>
            <code class="n">RoomType</code> <code class="p">=</code> <code class="s">"Regular"</code>
        <code class="p">},</code>
        <code class="k">new</code> <code class="n">Room</code>
        <code class="p">{</code>
            <code class="n">Number</code> <code class="p">=</code> <code class="m">111</code><code class="p">,</code>
            <code class="n">BedSize</code> <code class="p">=</code> <code class="s">"Queen"</code><code class="p">,</code>
            <code class="n">RoomType</code> <code class="p">=</code> <code class="s">"Regular"</code>
        <code class="p">},</code>
    <code class="p">};</code>
 <code class="p">}</code></pre>

<p>And this method uses the tuple returned from the class deconstructor to determine which enum to return:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="kt">int</code> <code class="nf">AssignRoom</code><code class="p">(</code><code class="n">ScheduleType</code> <code class="n">scheduleType</code><code class="p">)</code>
<code class="p">{</code>
    <code class="k">foreach</code> <code class="p">(</code><code class="kt">var</code> <code class="n">room</code> <code class="k">in</code> <code class="n">GetRooms</code><code class="p">())</code>
    <code class="p">{</code>
        <code class="n">ScheduleType</code> <code class="n">roomType</code> <code class="p">=</code> <code class="n">room</code> <code class="k">switch</code>
        <code class="p">{</code>
            <code class="p">(</code><code class="s">"King"</code><code class="p">,</code> <code class="s">"Suite"</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">ScheduleType</code><code class="p">.</code><code class="n">Gold</code><code class="p">,</code>
            <code class="p">(</code><code class="s">"King"</code><code class="p">,</code> <code class="s">"Regular"</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">ScheduleType</code><code class="p">.</code><code class="n">Silver</code><code class="p">,</code>
            <code class="p">(</code><code class="s">"Queen"</code><code class="p">,</code> <code class="s">"Regular"</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">ScheduleType</code><code class="p">.</code><code class="n">Bronze</code><code class="p">,</code>
            <code class="n">_</code> <code class="p">=&gt;</code> <code class="n">ScheduleType</code><code class="p">.</code><code class="n">Bronze</code>
        <code class="p">};</code>

        <code class="k">if</code> <code class="p">(</code><code class="n">roomType</code> <code class="p">==</code> <code class="n">scheduleType</code><code class="p">)</code>
            <code class="k">return</code> <code class="n">room</code><code class="p">.</code><code class="n">Number</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">return</code> <code class="n">RoomNotAvailable</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>The <code>Main</code> method drives the program:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="k">void</code> <code class="nf">Main</code><code class="p">()</code>
<code class="p">{</code>
    <code class="n">Console</code><code class="p">.</code><code class="n">Write</code><code class="p">(</code>
        <code class="s">"Choose (1) Bronze, (2) Silver, or (3) Gold: "</code><code class="p">);</code>
    <code class="kt">string</code> <code class="n">choice</code> <code class="p">=</code> <code class="n">Console</code><code class="p">.</code><code class="n">ReadLine</code><code class="p">();</code>

    <code class="n">Enum</code><code class="p">.</code><code class="n">TryParse</code><code class="p">(</code><code class="n">choice</code><code class="p">,</code> <code class="k">out</code> <code class="n">ScheduleType</code> <code class="n">scheduleType</code><code class="p">);</code>

    <code class="kt">int</code> <code class="n">roomNumber</code> <code class="p">=</code> <code class="n">AssignRoom</code><code class="p">(</code><code class="n">scheduleType</code><code class="p">);</code>

    <code class="k">if</code> <code class="p">(</code><code class="n">roomNumber</code> <code class="p">==</code> <code class="n">RoomNotAvailable</code><code class="p">)</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Room not available."</code><code class="p">);</code>
    <code class="k">else</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"The room number is {roomNumber}."</code><code class="p">);</code>
<code class="p">}</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45678763718432">
<h2>Discussion</h2>

<p>Throughout this book, you’ve seen how useful tuples are for situations where you want to manage a set of values without all the ceremony of a custom type. The quick syntax of tuples makes them ideal for simple pattern matching.</p>

<p>In this example, we do have a custom type, <code>Room</code>. Notice that <code>Room</code> has a custom deconstructor, which we’ll use in this solution. The <code>GetRooms</code> method returns a <code>List&lt;Room&gt;</code>. <code>AssignRooms</code> uses that collection. However, because of the deconstructor, we can use each room as a <code>switch</code> expression parameter, which is smart enough to use the deconstructor to produce a tuple for pattern matching.</p>

<p>Except for using tuples through a deconstructor, this demo is the same as <a data-type="xref" href="#switching_on_property_values">Recipe 8.4</a>. In this example, the tuple offered a shorter syntax. The property pattern is more verbose but easier to read. One consideration is that if you’re matching scalar values, like <code>bool</code> or <code>int</code>, the property pattern documents better. If you’re matching strings or enums, a tuple might provide the best of both worlds in terms of readability and shorter syntax. Because the choice between the two approaches is situational, it’s best to evaluate trade-offs in each situation to see what makes sense to you.<a data-type="indexterm" data-startref="ix_ch08-asciidoc15" id="idm45678763266976"/><a data-type="indexterm" data-startref="ix_ch08-asciidoc14" id="idm45678763266272"/><a data-type="indexterm" data-startref="ix_ch08-asciidoc13" id="idm45678763265600"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm45678763264672">
<h2>See Also</h2>

<p><a data-type="xref" data-xrefstyle="rec-num-title" href="#switching_on_property_values">Recipe 8.4, “Switching on Property Values”</a></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="8.6 Switching on Position"><div class="sect1" id="idm45678763262128">
<h1>8.6 Switching on Position</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45678763261008">
<h2>Problem</h2>

<p><a data-type="indexterm" data-primary="pattern matching" data-secondary="switching on position" id="ix_ch08-asciidoc16"/><a data-type="indexterm" data-primary="switch statements/switch expressions" data-secondary="switching on position" id="ix_ch08-asciidoc17"/><a data-type="indexterm" data-primary="tuples" data-secondary="switching on position" id="ix_ch08-asciidoc18"/>You need business rules based on values but don’t want to create a new single-use class.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45678763255536">
<h2>Solution</h2>

<p>This enum is the result we’ll look for:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">enum</code> <code class="n">ScheduleType</code>
<code class="p">{</code>
    <code class="n">None</code><code class="p">,</code>
    <code class="n">Bronze</code><code class="p">,</code>
    <code class="n">Silver</code><code class="p">,</code>
    <code class="n">Gold</code>
<code class="p">}</code></pre>

<p>Here’s a class used for specifying decision criteria:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">class</code> <code class="nc">Room</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="kt">int</code> <code class="n">Number</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
    <code class="k">public</code> <code class="kt">string</code> <code class="n">RoomType</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
    <code class="k">public</code> <code class="kt">string</code> <code class="n">BedSize</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code></pre>

<p>These methods simulate getting data from two sources:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Room</code><code class="p">&gt;</code> <code class="n">GetHotel1Rooms</code><code class="p">()</code>
<code class="p">{</code>
    <code class="k">return</code> <code class="k">new</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Room</code><code class="p">&gt;</code>
    <code class="p">{</code>
        <code class="k">new</code> <code class="n">Room</code>
        <code class="p">{</code>
            <code class="n">Number</code> <code class="p">=</code> <code class="m">333</code><code class="p">,</code>
            <code class="n">BedSize</code> <code class="p">=</code> <code class="s">"King"</code><code class="p">,</code>
            <code class="n">RoomType</code> <code class="p">=</code> <code class="s">"Suite"</code>
        <code class="p">},</code>
        <code class="k">new</code> <code class="n">Room</code>
        <code class="p">{</code>
            <code class="n">Number</code> <code class="p">=</code> <code class="m">111</code><code class="p">,</code>
            <code class="n">BedSize</code> <code class="p">=</code> <code class="s">"Queen"</code><code class="p">,</code>
            <code class="n">RoomType</code> <code class="p">=</code> <code class="s">"Regular"</code>
        <code class="p">},</code>
    <code class="p">};</code>
<code class="p">}</code>

<code class="k">static</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Room</code><code class="p">&gt;</code> <code class="n">GetHotel2Rooms</code><code class="p">()</code>
<code class="p">{</code>
    <code class="k">return</code> <code class="k">new</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Room</code><code class="p">&gt;</code>
    <code class="p">{</code>
        <code class="k">new</code> <code class="n">Room</code>
        <code class="p">{</code>
            <code class="n">Number</code> <code class="p">=</code> <code class="m">222</code><code class="p">,</code>
            <code class="n">BedSize</code> <code class="p">=</code> <code class="s">"King"</code><code class="p">,</code>
            <code class="n">RoomType</code> <code class="p">=</code> <code class="s">"Regular"</code>
        <code class="p">},</code>
    <code class="p">};</code>
<code class="p">}</code></pre>

<p>This method joins those data sources to produce a list of tuples:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code>
    <code class="n">List</code><code class="p">&lt;(</code><code class="kt">int</code> <code class="n">no</code><code class="p">,</code> <code class="kt">string</code> <code class="n">size</code><code class="p">,</code> <code class="kt">string</code> <code class="n">type</code><code class="p">)&gt;</code>
    <code class="n">GetRooms</code><code class="p">()</code>
<code class="p">{</code>
    <code class="kt">var</code> <code class="n">rooms</code> <code class="p">=</code> <code class="n">GetHotel1Rooms</code><code class="p">().</code><code class="n">Union</code><code class="p">(</code><code class="n">GetHotel2Rooms</code><code class="p">());</code>
    <code class="k">return</code>
        <code class="p">(</code><code class="k">from</code> <code class="n">room</code> <code class="k">in</code> <code class="n">rooms</code>
         <code class="k">select</code> <code class="p">(</code>
            <code class="n">room</code><code class="p">.</code><code class="n">Number</code><code class="p">,</code>
            <code class="n">room</code><code class="p">.</code><code class="n">BedSize</code><code class="p">,</code>
            <code class="n">room</code><code class="p">.</code><code class="n">RoomType</code>
         <code class="p">))</code>
        <code class="p">.</code><code class="n">ToList</code><code class="p">();</code>
<code class="p">}</code></pre>

<p>This method shows the business logic based on positional pattern matching:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="kt">int</code> <code class="nf">AssignRoom</code><code class="p">(</code><code class="n">ScheduleType</code> <code class="n">scheduleType</code><code class="p">)</code>
<code class="p">{</code>
    <code class="k">foreach</code> <code class="p">(</code><code class="kt">var</code> <code class="n">room</code> <code class="k">in</code> <code class="n">GetRooms</code><code class="p">())</code>
    <code class="p">{</code>
        <code class="n">ScheduleType</code> <code class="n">roomType</code> <code class="p">=</code> <code class="n">room</code> <code class="k">switch</code>
        <code class="p">{</code>
            <code class="p">(</code><code class="n">_</code><code class="p">,</code> <code class="s">"King"</code><code class="p">,</code> <code class="s">"Suite"</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">ScheduleType</code><code class="p">.</code><code class="n">Gold</code><code class="p">,</code>
            <code class="p">(</code><code class="n">_</code><code class="p">,</code> <code class="s">"King"</code><code class="p">,</code> <code class="s">"Regular"</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">ScheduleType</code><code class="p">.</code><code class="n">Silver</code><code class="p">,</code>
            <code class="p">(</code><code class="n">_</code><code class="p">,</code> <code class="s">"Queen"</code><code class="p">,</code> <code class="s">"Regular"</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">ScheduleType</code><code class="p">.</code><code class="n">Bronze</code><code class="p">,</code>
            <code class="n">_</code> <code class="p">=&gt;</code> <code class="n">ScheduleType</code><code class="p">.</code><code class="n">Bronze</code>
        <code class="p">};</code>

        <code class="k">if</code> <code class="p">(</code><code class="n">roomType</code> <code class="p">==</code> <code class="n">scheduleType</code><code class="p">)</code>
            <code class="k">return</code> <code class="n">room</code><code class="p">.</code><code class="n">no</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">return</code> <code class="n">RoomNotAvailable</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>The <code>Main</code> method drives the process:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="k">void</code> <code class="nf">Main</code><code class="p">()</code>
<code class="p">{</code>
    <code class="n">Console</code><code class="p">.</code><code class="n">Write</code><code class="p">(</code>
        <code class="s">"Choose (1) Bronze, (2) Silver, or (3) Gold: "</code><code class="p">);</code>
    <code class="kt">string</code> <code class="n">choice</code> <code class="p">=</code> <code class="n">Console</code><code class="p">.</code><code class="n">ReadLine</code><code class="p">();</code>

    <code class="n">Enum</code><code class="p">.</code><code class="n">TryParse</code><code class="p">(</code><code class="n">choice</code><code class="p">,</code> <code class="k">out</code> <code class="n">ScheduleType</code> <code class="n">scheduleType</code><code class="p">);</code>

    <code class="kt">int</code> <code class="n">roomNumber</code> <code class="p">=</code> <code class="n">AssignRoom</code><code class="p">(</code><code class="n">scheduleType</code><code class="p">);</code>

    <code class="k">if</code> <code class="p">(</code><code class="n">roomNumber</code> <code class="p">==</code> <code class="n">RoomNotAvailable</code><code class="p">)</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Room not available."</code><code class="p">);</code>
    <code class="k">else</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"The room number is {roomNumber}."</code><code class="p">);</code>
<code class="p">}</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45678763254944">
<h2>Discussion</h2>

<p>The solution here is similar to <a data-type="xref" href="#switching_on_tuples">Recipe 8.5</a>, in that it also uses tuples for pattern matching. This solution differs in that it explores the situation where you have two different sources of data, shown in <code>GetHotel1Rooms</code> and <code>GetHotel2Rooms</code>, simulating what would normally be database queries. This can happen when companies merge or form partnerships and their data is similar but not entirely alike.</p>

<p>The <code>GetRooms</code> method shows how to use the LINQ <code>Union</code> operator to combine the two lists. Rather than create a new type for the combination of values we need, the method builds a collection of tuples.</p>

<p>When <code>AssignRooms</code> calls <code>GetRooms</code>, you don’t need a deconstructor on an object because you’re already working with tuples. This is a useful technique if you’re working with third-party types where you can’t modify their members.</p>

<p>Inside of <code>AssignRoom</code>, the <code>switch</code> expression uses tuples for the match. What’s immediately noticeable here is the first parameter, representing the <code>Room.Number</code> property—there’s a discard symbol for each pattern. Clearly, this could have been omitted in <code>GetRooms</code>, but I wrote it that way to make a couple of points: value positions must match and every value is required.</p>

<p>Tuple patterns require values to be in the proper positions (e.g., you can’t swap <span class="keep-together"><code>Number</code></span> and <code>Size</code>). The position of each pattern value must match the corresponding tuple position. In contrast, property patterns can be in any order and differ between cases.</p>

<p>For tuples, you must include a value for each position of the tuple. Therefore, even if you don’t use a position in a pattern, you must at least specify the discard parameter. Property patterns don’t have this restriction, allowing you to add or ignore whatever properties you want for the pattern.<a data-type="indexterm" data-startref="ix_ch08-asciidoc18" id="idm45678762716944"/><a data-type="indexterm" data-startref="ix_ch08-asciidoc17" id="idm45678762716240"/><a data-type="indexterm" data-startref="ix_ch08-asciidoc16" id="idm45678762715568"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm45678762714768">
<h2>See Also</h2>

<p><a data-type="xref" data-xrefstyle="rec-num-title" href="#switching_on_tuples">Recipe 8.5, “Switching on Tuples”</a></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="8.7 Switching on Value Ranges"><div class="sect1" id="switching_on_value_ranges">
<h1>8.7 Switching on Value Ranges</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45678762710800">
<h2>Problem</h2>

<p><a data-type="indexterm" data-primary="pattern matching" data-secondary="switching on value ranges" id="ix_ch08-asciidoc19"/><a data-type="indexterm" data-primary="value ranges, switching on" id="ix_ch08-asciidoc20"/>Your business rules are continuous, rather than discrete.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45678762706944">
<h2>Solution</h2>

<p>Here’s an interface, as well as implementing classes that are results we’re looking for:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">interface</code> <code class="n">IRoomSchedule</code>
<code class="p">{</code>
    <code class="k">void</code> <code class="nf">ScheduleRoom</code><code class="p">();</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">GoldSchedule</code> <code class="p">:</code> <code class="n">IRoomSchedule</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">void</code> <code class="nf">ScheduleRoom</code><code class="p">()</code> <code class="p">=&gt;</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Scheduling Gold Room"</code><code class="p">);</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">SilverSchedule</code> <code class="p">:</code> <code class="n">IRoomSchedule</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">void</code> <code class="nf">ScheduleRoom</code><code class="p">()</code> <code class="p">=&gt;</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Scheduling Silver Room"</code><code class="p">);</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">BronzeSchedule</code> <code class="p">:</code> <code class="n">IRoomSchedule</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">void</code> <code class="nf">ScheduleRoom</code><code class="p">()</code> <code class="p">=&gt;</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Scheduling Bronze Room"</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>This method uses relational pattern matching to produce results:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">const</code> <code class="kt">int</code> <code class="n">SilverPoints</code> <code class="p">=</code> <code class="m">5000</code><code class="p">;</code>
<code class="k">const</code> <code class="kt">int</code> <code class="n">GoldPoints</code> <code class="p">=</code> <code class="m">20000</code><code class="p">;</code>

<code class="k">static</code> <code class="n">IRoomSchedule</code> <code class="nf">GetSchedule</code><code class="p">(</code><code class="kt">int</code> <code class="n">points</code><code class="p">)</code> <code class="p">=&gt;</code>
    <code class="n">points</code> <code class="k">switch</code>
    <code class="p">{</code>
        <code class="p">&gt;=</code> <code class="n">GoldPoints</code> <code class="p">=&gt;</code> <code class="k">new</code> <code class="n">GoldSchedule</code><code class="p">(),</code>
        <code class="p">&gt;=</code> <code class="n">SilverPoints</code> <code class="p">=&gt;</code> <code class="k">new</code> <code class="n">SilverSchedule</code><code class="p">(),</code>
        <code class="p">&lt;</code> <code class="n">SilverPoints</code> <code class="p">=&gt;</code> <code class="k">new</code> <code class="n">BronzeSchedule</code><code class="p">()</code>
    <code class="p">};</code></pre>

<p>The <code>Main</code> method drives the process:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="k">void</code> <code class="nf">Main</code><code class="p">()</code>
<code class="p">{</code>
    <code class="n">Console</code><code class="p">.</code><code class="n">Write</code><code class="p">(</code><code class="s">"How many points? "</code><code class="p">);</code>
    <code class="kt">string</code> <code class="n">response</code> <code class="p">=</code> <code class="n">Console</code><code class="p">.</code><code class="n">ReadLine</code><code class="p">();</code>

    <code class="k">if</code> <code class="p">(!</code><code class="kt">int</code><code class="p">.</code><code class="n">TryParse</code><code class="p">(</code><code class="n">response</code><code class="p">,</code> <code class="k">out</code> <code class="kt">int</code> <code class="n">points</code><code class="p">))</code>
    <code class="p">{</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"'{response}' is invalid!"</code><code class="p">);</code>
        <code class="k">return</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="n">IRoomSchedule</code> <code class="n">schedule</code> <code class="p">=</code> <code class="n">GetSchedule</code><code class="p">(</code><code class="n">points</code><code class="p">);</code>

    <code class="n">schedule</code><code class="p">.</code><code class="n">ScheduleRoom</code><code class="p">();</code>
<code class="p">}</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45678762522560">
<h2>Discussion</h2>

<p>Previous sections of this chapter explored pattern matching based on discrete values. The pattern had to be exact to match. However, there are a lot of situations where values are continuous, rather than discrete. An example of this is the solution in this section, where hotel customers could have a range of points in their accounts.</p>

<p>In the solution, customers with points from 0 to 4,999 are Bronze. Those with points from 5,000 to 19,999 are Silver. Those with 20,000 points or more are Gold. The <code>SilverPoints</code> and <code>GoldPoints</code> constants in the solution define the boundaries.</p>

<p>The <code>Main</code> method asks how many points a customer has and passes that value to <code>GetSchedule</code>. This value can vary, depending on how many times a person booked a room or used other hotel services. Because of this, <code>GetSchedule</code> uses a <code>switch</code> expression based on those points. Instead of using a discrete pattern for the match, <code>GetSchedule</code> uses relational operators.</p>

<p>The first pattern asks if <code>points</code> is equal to or higher than <code>GoldPoints</code>. If not, <code>points</code> must be less, and the code checks to see if the points are equal to or higher than <span class="keep-together"><code>SilverPoints</code></span>. Since we already evaluated the <code>GoldPoints</code> case, it follows that the range is between <code>SilverPoints</code> and less than <code>GoldPoints</code>. The final case, less than <code>SilverPoints</code>, documents the meaning of Bronze, but you could have easily replaced that with a discard pattern because the other two cases handled every other possibility, and Bronze is all that’s left.<a data-type="indexterm" data-startref="ix_ch08-asciidoc20" id="idm45678762426048"/><a data-type="indexterm" data-startref="ix_ch08-asciidoc19" id="idm45678762425344"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="8.8 Switching with Complex Conditions"><div class="sect1" id="switching_with_complex_conditions">
<h1>8.8 Switching with Complex Conditions</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45678762423312">
<h2>Problem</h2>

<p><a data-type="indexterm" data-primary="pattern matching" data-secondary="switching with complex conditions" id="ix_ch08-asciidoc21"/><a data-type="indexterm" data-primary="switch statements/switch expressions" data-secondary="switching with complex conditions" id="ix_ch08-asciidoc22"/>Your business rules are multiconditional.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45678762419104">
<h2>Solution</h2>

<p>Here’s an interface, as well as implementing classes that are results we’re looking for:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">interface</code> <code class="n">IRoomSchedule</code>
<code class="p">{</code>
    <code class="k">void</code> <code class="nf">ScheduleRoom</code><code class="p">();</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">GoldSchedule</code> <code class="p">:</code> <code class="n">IRoomSchedule</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">void</code> <code class="nf">ScheduleRoom</code><code class="p">()</code> <code class="p">=&gt;</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Scheduling Gold Room"</code><code class="p">);</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">SilverSchedule</code> <code class="p">:</code> <code class="n">IRoomSchedule</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">void</code> <code class="nf">ScheduleRoom</code><code class="p">()</code> <code class="p">=&gt;</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Scheduling Silver Room"</code><code class="p">);</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">BronzeSchedule</code> <code class="p">:</code> <code class="n">IRoomSchedule</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">void</code> <code class="nf">ScheduleRoom</code><code class="p">()</code> <code class="p">=&gt;</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Scheduling Bronze Room"</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>This class describes the criteria to use:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">class</code> <code class="nc">Customer</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="kt">int</code> <code class="n">Points</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>

    <code class="k">public</code> <code class="kt">bool</code> <code class="n">HasFreeUpgrade</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code></pre>

<p>This method generates simulated data with various values to exercise our logic:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Customer</code><code class="p">&gt;</code> <code class="n">GetCustomers</code><code class="p">()</code> <code class="p">=&gt;</code>
    <code class="k">new</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Customer</code><code class="p">&gt;</code>
    <code class="p">{</code>
        <code class="k">new</code> <code class="n">Customer</code>
        <code class="p">{</code>
            <code class="n">Points</code> <code class="p">=</code> <code class="m">25000</code><code class="p">,</code>
            <code class="n">HasFreeUpgrade</code> <code class="p">=</code> <code class="k">false</code>
        <code class="p">},</code>
        <code class="k">new</code> <code class="n">Customer</code>
        <code class="p">{</code>
            <code class="n">Points</code> <code class="p">=</code> <code class="m">10000</code><code class="p">,</code>
            <code class="n">HasFreeUpgrade</code> <code class="p">=</code> <code class="k">true</code>
        <code class="p">},</code>
        <code class="k">new</code> <code class="n">Customer</code>
        <code class="p">{</code>
            <code class="n">Points</code> <code class="p">=</code> <code class="m">1000</code><code class="p">,</code>
            <code class="n">HasFreeUpgrade</code> <code class="p">=</code> <code class="k">true</code>
        <code class="p">},</code>
    <code class="p">};</code></pre>

<p>Here’s a method using complex logic in a <code>switch</code> expression:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="n">IRoomSchedule</code> <code class="nf">GetSchedule</code><code class="p">(</code><code class="n">Customer</code> <code class="n">customer</code><code class="p">)</code> <code class="p">=&gt;</code>
    <code class="n">customer</code> <code class="k">switch</code>
    <code class="p">{</code>
        <code class="n">Customer</code> <code class="n">c</code>
            <code class="k">when</code>
                <code class="n">c</code><code class="p">.</code><code class="n">Points</code> <code class="p">&gt;=</code> <code class="n">GoldPoints</code>
                    <code class="p">||</code>
                <code class="p">(</code><code class="n">c</code><code class="p">.</code><code class="n">Points</code> <code class="p">&gt;=</code> <code class="n">SilverPoints</code> <code class="p">&amp;&amp;</code> <code class="n">c</code><code class="p">.</code><code class="n">HasFreeUpgrade</code><code class="p">)</code>
            <code class="p">=&gt;</code> <code class="k">new</code> <code class="n">GoldSchedule</code><code class="p">(),</code>

        <code class="n">Customer</code> <code class="n">c</code>
            <code class="k">when</code>
                <code class="n">c</code><code class="p">.</code><code class="n">Points</code> <code class="p">&gt;=</code> <code class="n">SilverPoints</code>
                    <code class="p">||</code>
                <code class="p">(</code><code class="n">c</code><code class="p">.</code><code class="n">Points</code> <code class="p">&lt;</code> <code class="n">SilverPoints</code> <code class="p">&amp;&amp;</code> <code class="n">c</code><code class="p">.</code><code class="n">HasFreeUpgrade</code><code class="p">)</code>
            <code class="p">=&gt;</code> <code class="k">new</code> <code class="n">SilverSchedule</code><code class="p">(),</code>

        <code class="n">Customer</code> <code class="n">c</code>
            <code class="k">when</code>
                <code class="n">c</code><code class="p">.</code><code class="n">Points</code> <code class="p">&lt;</code> <code class="n">SilverPoints</code>
            <code class="p">=&gt;</code> <code class="k">new</code> <code class="n">BronzeSchedule</code><code class="p">(),</code>

        <code class="n">_</code> <code class="p">=&gt;</code> <code class="k">new</code> <code class="n">BronzeSchedule</code><code class="p">()</code>
    <code class="p">};</code></pre>

<p>The <code>Main</code> method iterates through results:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="k">void</code> <code class="nf">Main</code><code class="p">()</code>
<code class="p">{</code>
    <code class="k">foreach</code> <code class="p">(</code><code class="kt">var</code> <code class="n">customer</code> <code class="k">in</code> <code class="n">GetCustomers</code><code class="p">())</code>
    <code class="p">{</code>
        <code class="n">IRoomSchedule</code> <code class="n">schedule</code> <code class="p">=</code> <code class="n">GetSchedule</code><code class="p">(</code><code class="n">customer</code><code class="p">);</code>
        <code class="n">schedule</code><code class="p">.</code><code class="n">ScheduleRoom</code><code class="p">();</code>
    <code class="p">}</code>
<code class="p">}</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45678762418512">
<h2>Discussion</h2>

<p>Sometimes conditions are so complex that the techniques shown in earlier sections of this chapter are inadequate for solving the problem. An example is the solution in this section that requires multiple conditions involving more than one property. Here, we use a <code>switch</code> expression with <code>when</code> clauses to specify matches.</p>

<p>This scenario is based on a <code>Customer</code> type, indicating number of points and whether the customer has a free upgrade. The free upgrade could have been from a contest or hotel promotion activity. When scheduling a room, we want to make sure that the customer gets a room commensurate with their point level. Additionally, if they have the free upgrade option, they receive a room that is upgraded to the next higher level. For simplicity, we’re conveniently ignoring whether Gold has a free upgrade.</p>

<p>The <code>GetSchedule</code> method operates on an instance of <code>Customer</code>. Both the cases for Gold and Silver result in a room at that level. Additionally, the <code>||</code> operator says that if <code>customer</code> is at the next lower level, but <code>HasFreeUpgrade</code> is <code>true</code>, then the result is a room at this higher level.</p>

<p>Using logic like this can get complex fast. Notice the use of newlines and other spacing to add symmetry and consistency to reading the result.</p>

<p>While this technique can help when the logic is a bit more complex than a discrete pattern match, you might want to consider a threshold where using <code>if</code> statements might be a better implementation. One consideration is maintenance, because breaking each piece of the logic out can help with debugging, whereas a single expression with multiple conditions might not be immediately obvious.<a data-type="indexterm" data-startref="ix_ch08-asciidoc22" id="idm45678761965984"/><a data-type="indexterm" data-startref="ix_ch08-asciidoc21" id="idm45678761965280"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="8.9 Using Logical Conditions"><div class="sect1" id="idm45678761964480">
<h1>8.9 Using Logical Conditions</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45678761963296">
<h2>Problem</h2>

<p><a data-type="indexterm" data-primary="multiconditional logic" id="ix_ch08-asciidoc23"/><a data-type="indexterm" data-primary="pattern matching" data-secondary="using logical conditions" id="ix_ch08-asciidoc24"/><a data-type="indexterm" data-primary="switch statements/switch expressions" data-secondary="using logical conditions" id="ix_ch08-asciidoc25"/>You want multiconditional logic to be more readable.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45678761958336">
<h2>Solution</h2>

<p>Here’s a class to use as criteria:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">class</code> <code class="nc">Customer</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="kt">int</code> <code class="n">Points</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>

    <code class="k">public</code> <code class="kt">int</code> <code class="n">Month</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code></pre>

<p>This method simulates a data source:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Customer</code><code class="p">&gt;</code> <code class="n">GetCustomers</code><code class="p">()</code> <code class="p">=&gt;</code>
    <code class="k">new</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Customer</code><code class="p">&gt;</code>
    <code class="p">{</code>
        <code class="k">new</code> <code class="n">Customer</code>
        <code class="p">{</code>
            <code class="n">Points</code> <code class="p">=</code> <code class="m">25000</code><code class="p">,</code>
            <code class="n">Month</code> <code class="p">=</code> <code class="m">1</code>
        <code class="p">},</code>
        <code class="k">new</code> <code class="n">Customer</code>
        <code class="p">{</code>
            <code class="n">Points</code> <code class="p">=</code> <code class="m">10000</code><code class="p">,</code>
            <code class="n">Month</code> <code class="p">=</code> <code class="m">12</code>
        <code class="p">},</code>
        <code class="k">new</code> <code class="n">Customer</code>
        <code class="p">{</code>
            <code class="n">Points</code> <code class="p">=</code> <code class="m">10000</code><code class="p">,</code>
            <code class="n">Month</code> <code class="p">=</code> <code class="m">11</code>
        <code class="p">},</code>
        <code class="k">new</code> <code class="n">Customer</code>
        <code class="p">{</code>
            <code class="n">Points</code> <code class="p">=</code> <code class="m">1000</code><code class="p">,</code>
            <code class="n">Month</code> <code class="p">=</code> <code class="m">2</code>
        <code class="p">},</code>
    <code class="p">};</code></pre>

<p>This method implements business rules with conditional logic in a <code>switch</code> <span class="keep-together">expression</span>:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">const</code> <code class="kt">int</code> <code class="n">SilverPoints</code> <code class="p">=</code> <code class="m">5000</code><code class="p">;</code>
<code class="k">const</code> <code class="kt">int</code> <code class="n">GoldPoints</code> <code class="p">=</code> <code class="m">20000</code><code class="p">;</code>

<code class="k">const</code> <code class="kt">int</code> <code class="n">May</code> <code class="p">=</code> <code class="m">5</code><code class="p">;</code>
<code class="k">const</code> <code class="kt">int</code> <code class="n">Sep</code> <code class="p">=</code> <code class="m">9</code><code class="p">;</code>
<code class="k">const</code> <code class="kt">int</code> <code class="n">Dec</code> <code class="p">=</code> <code class="m">12</code><code class="p">;</code>

<code class="k">static</code> <code class="kt">decimal</code> <code class="nf">GetDiscount</code><code class="p">(</code><code class="n">Customer</code> <code class="n">customer</code><code class="p">)</code> <code class="p">=&gt;</code>
    <code class="p">(</code><code class="n">customer</code><code class="p">.</code><code class="n">Points</code><code class="p">,</code> <code class="n">customer</code><code class="p">.</code><code class="n">Month</code><code class="p">)</code> <code class="k">switch</code>
    <code class="p">{</code>
        <code class="p">(&gt;=</code> <code class="n">GoldPoints</code><code class="p">,</code> <code class="n">not</code> <code class="n">Dec</code> <code class="n">and</code> <code class="p">&gt;</code> <code class="n">Sep</code> <code class="n">or</code> <code class="p">&lt;</code> <code class="n">May</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="m">0.15</code><code class="n">m</code><code class="p">,</code>
        <code class="p">(&gt;=</code> <code class="n">GoldPoints</code><code class="p">,</code> <code class="n">Dec</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="m">0.10</code><code class="n">m</code><code class="p">,</code>
        <code class="p">(&gt;=</code> <code class="n">SilverPoints</code><code class="p">,</code> <code class="n">not</code> <code class="p">(</code><code class="n">Dec</code> <code class="n">or</code> <code class="p">&lt;=</code> <code class="n">Sep</code> <code class="n">and</code> <code class="p">&gt;=</code> <code class="n">May</code><code class="p">))</code> <code class="p">=&gt;</code> <code class="m">0.05</code><code class="n">m</code><code class="p">,</code>
        <code class="n">_</code> <code class="p">=&gt;</code> <code class="m">0.0</code><code class="n">m</code>
    <code class="p">};</code></pre>

<p>The <code>Main</code> method drives this process:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="k">void</code> <code class="nf">Main</code><code class="p">()</code>
<code class="p">{</code>
    <code class="k">foreach</code> <code class="p">(</code><code class="kt">var</code> <code class="n">customer</code> <code class="k">in</code> <code class="n">GetCustomers</code><code class="p">())</code>
    <code class="p">{</code>
        <code class="kt">decimal</code> <code class="n">discount</code> <code class="p">=</code> <code class="n">GetDiscount</code><code class="p">(</code><code class="n">customer</code><code class="p">);</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">discount</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45678761650016">
<h2>Discussion</h2>

<p><a data-type="xref" href="#switching_with_complex_conditions">Recipe 8.8</a> described how to add complex logic to <code>switch</code> expressions. By complex, I’m referring to multiple conditions involving two or more properties. This contrasts with simple pattern matching for previous sections of this chapter that used property and tuple patterns. Somewhere in between these contrasting approaches of simple and complex is a moderate approach where you need logic isolated within individual properties.</p>

<p>The properties of interest in this solution are the <code>Points</code> and <code>Month</code> of the <code>Customer</code> class. Similar to earlier sections, the <code>Points</code> property contributes to receiving a room for a customer that has at least a certain number of points. The other condition, <code>Month</code>, is the month when the customer wants to book the room. Because of seasonal supply and demand, some months leave the hotel with more open rooms. Therefore, this application provides incentives, based on points, for customers to book rooms in the months with more open rooms.</p>

<p>In the solution, you can see that there are <code>GoldPoints</code> and <code>SilverPoints</code> constants to tell which level a customer is. Also, there are constants for <code>May</code>, <code>Sep</code>, and <code>Dec</code>—the busy months. The logic will be to give a discount in the months that are not busy.</p>

<p>The pattern for the <code>switch</code> expression in <code>GetDiscount</code> matches on two properties: <code>Points</code> and <code>Month</code>. Notice how this code doesn’t rely on an object deconstructor and the original parameter is a class, rather than a tuple. <code>GetDiscount</code> creates an inline tuple for the <code>switch</code> expression.</p>

<p>The pattern itself relies on relational operators for <code>Points</code>, as in <a data-type="xref" href="#switching_on_value_ranges">Recipe 8.7</a>.</p>

<p>The <code>Month</code> pattern uses the new C# 9 logical operators: <code>and</code>, <code>not</code>, and <code>or</code>. The first expression ensures the customer receives a discount during the winter months, between <code>Sep</code> and <code>May</code>, except for <code>Dec</code>. The second pattern says that a Gold customer still gets a discount in <code>Dec</code>, except that it’s 10% instead of 15%.</p>

<p><a data-type="indexterm" data-primary="DeMorgans Theorem" id="idm45678761578992"/>The last pattern is logically equivalent to the first and uses DeMorgan’s Theorem. That is, it negates the whole result and swaps <code>and</code> with <code>or</code>. Because the last example applies <code>not</code> to the entire expression, it uses parentheses. In the first pattern, <code>not</code> applied to <code>Dec</code> only.<a data-type="indexterm" data-startref="ix_ch08-asciidoc25" id="idm45678761575648"/><a data-type="indexterm" data-startref="ix_ch08-asciidoc24" id="idm45678761574912"/><a data-type="indexterm" data-startref="ix_ch08-asciidoc23" id="idm45678761574240"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm45678761573568">
<h2>See Also</h2>

<p><a data-type="xref" data-xrefstyle="rec-num-title" href="#switching_on_value_ranges">Recipe 8.7, “Switching on Value Ranges”</a></p>

<p><a data-type="xref" data-xrefstyle="rec-num-title" href="#switching_with_complex_conditions">Recipe 8.8, “Switching with Complex Conditions”</a></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="8.10 Switching on Type"><div class="sect1" id="idm45678761570032">
<h1>8.10 Switching on Type</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45678761569088">
<h2>Problem</h2>

<p><a data-type="indexterm" data-primary="pattern matching" data-secondary="switching on type" id="ix_ch08-asciidoc26"/><a data-type="indexterm" data-primary="switch statements/switch expressions" data-secondary="switching on type" id="ix_ch08-asciidoc27"/>You need the type of an object for decision making.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45678761564976">
<h2>Solution</h2>

<p>Here’s an interface, as well as implementing classes that are results we’re looking for:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">interface</code> <code class="n">IRoomSchedule</code>
<code class="p">{</code>
    <code class="k">void</code> <code class="nf">ScheduleRoom</code><code class="p">();</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">GoldSchedule</code> <code class="p">:</code> <code class="n">IRoomSchedule</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">void</code> <code class="nf">ScheduleRoom</code><code class="p">()</code> <code class="p">=&gt;</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Scheduling Gold Room"</code><code class="p">);</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">SilverSchedule</code> <code class="p">:</code> <code class="n">IRoomSchedule</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">void</code> <code class="nf">ScheduleRoom</code><code class="p">()</code> <code class="p">=&gt;</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Scheduling Silver Room"</code><code class="p">);</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">BronzeSchedule</code> <code class="p">:</code> <code class="n">IRoomSchedule</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">void</code> <code class="nf">ScheduleRoom</code><code class="p">()</code> <code class="p">=&gt;</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Scheduling Bronze Room"</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>The following types represent criteria:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">class</code> <code class="nc">Customer</code> <code class="p">{}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">GoldCustomer</code> <code class="p">:</code> <code class="n">Customer</code> <code class="p">{}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">SilverCustomer</code> <code class="p">:</code> <code class="n">Customer</code> <code class="p">{}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">BronzeCustomer</code> <code class="p">:</code> <code class="n">Customer</code> <code class="p">{}</code></pre>

<p>This method simulates a data source:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Customer</code><code class="p">&gt;</code> <code class="n">GetCustomers</code><code class="p">()</code> <code class="p">=&gt;</code>
    <code class="k">new</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Customer</code><code class="p">&gt;</code>
    <code class="p">{</code>
        <code class="k">new</code> <code class="nf">GoldCustomer</code><code class="p">(),</code>
        <code class="k">new</code> <code class="nf">SilverCustomer</code><code class="p">(),</code>
        <code class="k">new</code> <code class="nf">BronzeCustomer</code><code class="p">()</code>
    <code class="p">};</code></pre>

<p>Here’s a method that implements logic based on type pattern matching:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="n">IRoomSchedule</code> <code class="nf">GetSchedule</code><code class="p">(</code><code class="n">Customer</code> <code class="n">customer</code><code class="p">)</code> <code class="p">=&gt;</code>
    <code class="n">customer</code> <code class="k">switch</code>
    <code class="p">{</code>
        <code class="n">GoldCustomer</code> <code class="p">=&gt;</code> <code class="k">new</code> <code class="n">GoldSchedule</code><code class="p">(),</code>
        <code class="n">SilverCustomer</code> <code class="p">=&gt;</code> <code class="k">new</code> <code class="n">SilverSchedule</code><code class="p">(),</code>
        <code class="n">BronzeCustomer</code> <code class="p">=&gt;</code> <code class="k">new</code> <code class="n">BronzeSchedule</code><code class="p">(),</code>
        <code class="n">_</code> <code class="p">=&gt;</code> <code class="k">new</code> <code class="n">BronzeSchedule</code><code class="p">()</code>
    <code class="p">};</code></pre>

<p class="pagebreak-before less_space">The <code>Main</code> method iterates through the data to exercise the pattern matching logic:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="k">void</code> <code class="nf">Main</code><code class="p">()</code>
<code class="p">{</code>
    <code class="k">foreach</code> <code class="p">(</code><code class="kt">var</code> <code class="n">customer</code> <code class="k">in</code> <code class="n">GetCustomers</code><code class="p">())</code>
    <code class="p">{</code>
        <code class="n">IRoomSchedule</code> <code class="n">schedule</code> <code class="p">=</code> <code class="n">GetSchedule</code><code class="p">(</code><code class="n">customer</code><code class="p">);</code>
        <code class="n">schedule</code><code class="p">.</code><code class="n">ScheduleRoom</code><code class="p">();</code>
    <code class="p">}</code>
<code class="p">}</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45678761564384">
<h2>Discussion</h2>

<p>It used to be that the only way to make a decision on type was to either use <code>if</code> statements or convert the object’s type to a <code>string</code> and use a <code>switch</code> statement with <code>string</code> cases. A popular ask for C# over the years was to allow a <code>switch</code> statement with type cases, and now we finally have it.</p>

<p>The solution has a set of classes for <code>GoldCustomer</code>, <code>SilverCustomer</code>, and <code>BronzeCustomer</code>, each deriving from <code>Customer</code>. Our goal in this program is to schedule a room, based on the matching class type.</p>

<p>The <code>GetSchedule</code> method does the scheduling by accepting an object of type <span class="keep-together"><code>Customer</code></span>, and the <code>switch</code> expression has a pattern for each of the classes that derive from <code>Customer</code>. All you need to do is specify the name of each class and the <code>switch</code> expression matches based on the object type<a data-type="indexterm" data-startref="ix_ch08-asciidoc27" id="idm45678761232304"/><a data-type="indexterm" data-startref="ix_ch08-asciidoc26" id="idm45678761231600"/>.<a data-type="indexterm" data-startref="ix_ch08-asciidoc0" id="idm45678761230800"/></p>
</div></section>





</div></section>







</div></section></div></body></html>