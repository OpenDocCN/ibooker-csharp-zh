- en: Chapter 10\. LINQ to XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET provides a number of APIs for working with XML data. The primary choice
    for general-purpose XML document processing is *LINQ to XML*. LINQ to XML comprises
    a lightweight, LINQ-friendly XML document object model (DOM), plus a set of supplementary
    query operators.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we concentrate entirely on LINQ to XML. In [Chapter 11](ch11.html#other_xml_and_json_technologies),
    we cover the forward-only XML reader/writer, and in the [online supplement](http://www.albahari.com/nutshell),
    we cover the types for working with schemas and stylesheets. .NET also includes
    the legacy `XmlDocument`-based DOM, which we don’t cover.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The LINQ to XML DOM is extremely well designed and highly performant. Even without
    LINQ, the LINQ to XML DOM is valuable as a lightweight façade over the low-level
    `XmlReader` and `XmlWriter` classes.
  prefs: []
  type: TYPE_NORMAL
- en: All LINQ to XML types are defined in the `System.Xml.Linq` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Architectural Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section starts with a very brief introduction to the concept of a DOM,
    and then explains the rationale behind LINQ to XML’s DOM.
  prefs: []
  type: TYPE_NORMAL
- en: What Is a DOM?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following XML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As with all XML files, we start with a *declaration* and then a root *element*,
    whose name is `customer`. The `customer` element has two *attributes*, each with
    a name (`id` and `status`) and value (`"123"` and `"archived"`). Within `customer`,
    there are two child elements, `firstname` and `lastname`, each having simple text
    content (`"Joe"` and `"Bloggs"`).
  prefs: []
  type: TYPE_NORMAL
- en: Each of these constructs—declaration, element, attribute, value, and text content—can
    be represented with a class. And if such classes have collection properties for
    storing child content, we can assemble a *tree* of objects to fully describe a
    document. This is called a *Document Object Model*, or DOM.
  prefs: []
  type: TYPE_NORMAL
- en: The LINQ to XML DOM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'LINQ to XML comprises two things:'
  prefs: []
  type: TYPE_NORMAL
- en: An XML DOM, which we call the *X-DOM*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of about 10 supplementary query operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you might expect, the X-DOM consists of types such as `XDocument`, `XElement`,
    and `XAttribute`. Interestingly, the X-DOM types are not tied to LINQ—you can
    load, instantiate, update, and save an X-DOM without ever writing a LINQ query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversely, you could use LINQ to query a DOM created of the older W3C-compliant
    types. However, this would be frustrating and limiting. The distinguishing feature
    of the X-DOM is that it’s *LINQ-friendly*, meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: It has methods that emit useful `IEnumerable` sequences upon which you can query.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its constructors are designed such that you can build an X-DOM tree through
    a LINQ projection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: X-DOM Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Figure 10-1](#core_x_dom_types) shows the core X-DOM types. The most frequently
    used of these types is `XElement`. `XObject` is the root of the *inheritance*
    hierarchy; `XElement` and `XDocument` are roots of the *containership* hierarchy.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Core X-DOM types](assets/cn10_1001.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-1\. Core X-DOM types
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Figure 10-2](#a_simple_x_dom_tree) shows the X-DOM tree created from the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![A simple X-DOM tree](assets/cn10_1002.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-2\. A simple X-DOM tree
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`XObject` is the abstract base class for all XML content. It defines a link
    to the `Parent` element in the containership tree as well as an optional `XDocument`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`XNode` is the base class for most XML content excluding attributes. The distinguishing
    feature of `XNode` is that it can sit in an ordered collection of mixed-type `XNode`s.
    For instance, consider the following XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Within the parent element `<data>`, there’s first an `XText` node (`Hello world`),
    then an `XElement` node, then an `XComment` node, and then a second `XElement`
    node. In contrast, an `XAttribute` will tolerate only other `XAttribute`s as peers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although an `XNode` can access its parent `XElement`, it has no concept of
    *child* nodes: this is the job of its subclass `XContainer`. `XContainer` defines
    members for dealing with children and is the abstract base class for `XElement`
    and `XDocument`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`XElement` introduces members for managing attributes—as well as a `Name` and
    `Value`. In the (fairly common) case of an element having a single `XText` child
    node, the `Value` property on `XElement` encapsulates this child’s content for
    both get and set operations, cutting unnecessary navigation. Thanks to `Value`,
    you can mostly avoid working directly with `XText` nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: '`XDocument` represents the root of an XML tree. More precisely, it *wraps*
    the root `XElement`, adding an `XDeclaration`, processing instructions, and other
    root-level “fluff.” Unlike with the W3C DOM, its use is optional: you can load,
    manipulate, and save an X-DOM without ever creating an `XDocument`! The nonreliance
    on `XDocument` also means that you can efficiently and easily move a node subtree
    to another X-DOM hierarchy.'
  prefs: []
  type: TYPE_NORMAL
- en: Loading and Parsing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both `XElement` and `XDocument` provide static `Load` and `Parse` methods to
    build an X-DOM tree from an existing source:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Load` builds an X-DOM from a file, URI, `Stream`, `TextReader`, or `XmlReader`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Parse` builds an X-DOM from a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In later sections, we describe how to traverse and update an X-DOM. As a quick
    preview, here’s how to manipulate the `config` element we just populated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the result of that last `Console.WriteLine`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`XNode` also provides a static `ReadFrom` method that instantiates and populates
    any type of node from an `XmlReader`. Unlike `Load`, it stops after reading one
    (complete) node, so you can continue to read manually from the `XmlReader` afterward.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also do the reverse and use an `XmlReader` or `XmlWriter` to read or
    write an `XNode`, via its `CreateReader` and `CreateWriter` methods.
  prefs: []
  type: TYPE_NORMAL
- en: We describe XML readers and writers and how to use them with the X-DOM in [Chapter 11](ch11.html#other_xml_and_json_technologies).
  prefs: []
  type: TYPE_NORMAL
- en: Saving and Serializing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Calling `ToString` on any node converts its content to an XML string—formatted
    with line breaks and indentation as we just saw. (You can disable the line breaks
    and indentation by specifying `SaveOptions.DisableFormatting` when calling `ToString`.)
  prefs: []
  type: TYPE_NORMAL
- en: '`XElement` and `XDocument` also provide a `Save` method that writes an X-DOM
    to a file, `Stream`, `TextWriter`, or `XmlWriter`. If you specify a file, an XML
    declaration is automatically written. There is also a `WriteTo` method defined
    in the `XNode` class, which accepts just an `XmlWriter`.'
  prefs: []
  type: TYPE_NORMAL
- en: We describe in more detail the handling of XML declarations when saving in [“Documents
    and Declarations”](#documents_and_declarations).
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating an X-DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rather than using the `Load` or `Parse` methods, you can build an X-DOM tree
    by manually instantiating objects and adding them to a parent via `XContainer`’s
    `Add` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To construct an `XElement` and `XAttribute`, simply provide a name and value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A value is optional when constructing an `XElement`—you can provide just the
    element name and add content later. Notice that when we did provide a value, a
    simple string sufficed—we didn’t need to explicitly create and add an `XText`
    child node. The X-DOM does this work automatically, so you can deal simply with
    “values.”
  prefs: []
  type: TYPE_NORMAL
- en: Functional Construction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our preceding example, it’s difficult to glean the XML structure from the
    code. X-DOM supports another mode of instantiation, called *functional construction*
    (from functional programming). With functional construction, you build an entire
    tree in a single expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This has two benefits. First, the code resembles the shape of the XML. Second,
    it can be incorporated into the `select` clause of a LINQ query. For example,
    the following query projects from an EF Core entity class into an X-DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We examine this further later in this chapter in [“Projecting into an X-DOM”](#projecting_into_an_x_dom).
  prefs: []
  type: TYPE_NORMAL
- en: Specifying Content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functional construction is possible because the constructors for `XElement`
    (and `XDocument`) are overloaded to accept a `params` object array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The same holds true for the `Add` method in `XContainer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Hence, you can specify any number of child objects of any type when building
    or appending an X-DOM. This works because *anything* counts as legal content.
    To see how, we need to examine how each content object is processed internally.
    Here are the decisions made by `XContainer`, in order:'
  prefs: []
  type: TYPE_NORMAL
- en: If the object is `null`, it’s ignored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the object is based on `XNode` or `XStreamingElement`, it’s added as is to
    the `Nodes` collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the object is an `XAttribute`, it’s added to the `Attributes` collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the object is a `string`, it’s wrapped in an `XText` node and added to `Nodes`.^([1](ch10.html#ch01fn11))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the object implements `IEnumerable`, it’s enumerated, and the same rules
    are applied to each element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, the object is converted to a string, wrapped in an `XText` node,
    and then added to `Nodes`.^([2](ch10.html#ch01fn12))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Everything ends up in one of two buckets: `Nodes` or `Attributes`. Furthermore,
    any object is valid content because it can always ultimately call `ToString` on
    it and treat it as an `XText` node.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Before calling `ToString` on an arbitrary type, `XContainer` first tests whether
    it is one of the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If so, it calls an appropriate typed `ToString` method on the `XmlConvert` helper
    class instead of calling `ToString` on the object itself. This ensures that the
    data is round-trippable and compliant with standard XML formatting rules.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic Deep Cloning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a node or attribute is added to an element (whether via functional construction
    or an `Add` method), the node or attribute’s `Parent` property is set to that
    element. A node can have only one parent element: if you add an already parented
    node to a second parent, the node is automatically *deep-cloned*. In the following
    example, each customer has a separate copy of `address`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This automatic duplication keeps X-DOM object instantiation free of side effects—another
    hallmark of functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating and Querying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you might expect, the `XNode` and `XContainer` classes define methods and
    properties for traversing the X-DOM tree. Unlike a conventional DOM, however,
    these functions don’t return a collection that implements `IList<T>`. Instead,
    they return either a single value or a *sequence* that implements `IEnumerable<T>`—upon
    which you are then expected to execute a LINQ query (or enumerate with a `foreach`).
    This allows for advanced queries as well as simple navigation tasks—using familiar
    LINQ query syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Element and attribute names are case sensitive in the X-DOM, just as they are
    in XML.
  prefs: []
  type: TYPE_NORMAL
- en: Child Node Navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Return type | Members | Works on |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `XNode` | `FirstNode { get; }` | `XContainer` |'
  prefs: []
  type: TYPE_TB
- en: '|   | `LastNode { get; }` | `XContainer` |'
  prefs: []
  type: TYPE_TB
- en: '| `IEnumerable<XNode>` | `Nodes()` | `XContainer*` |'
  prefs: []
  type: TYPE_TB
- en: '|   | `DescendantNodes()` | `XContainer*` |'
  prefs: []
  type: TYPE_TB
- en: '|   | `DescendantNodesAndSelf()` | `XElement*` |'
  prefs: []
  type: TYPE_TB
- en: '| `XElement` | `Element (XName)` | `XContainer` |'
  prefs: []
  type: TYPE_TB
- en: '| `IEnumerable<XElement>` | `Elements()` | `XContainer*` |'
  prefs: []
  type: TYPE_TB
- en: '|   | `Elements (XName)` | `XContainer*` |'
  prefs: []
  type: TYPE_TB
- en: '|   | `Descendants()` | `XContainer*` |'
  prefs: []
  type: TYPE_TB
- en: '|   | `Descendants (XName)` | `XContainer*` |'
  prefs: []
  type: TYPE_TB
- en: '|   | `DescendantsAndSelf()` | `XElement*` |'
  prefs: []
  type: TYPE_TB
- en: '|   | `DescendantsAndSelf (XName)` | `XElement*` |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | `HasElements { get; }` | `XElement` |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Functions marked with an asterisk in the third column of this and other tables
    also operate on *sequences* of the same type. For instance, you can call `Nodes`
    on either an `XContainer` or a sequence of `XContainer` objects. This is possible
    because of extension methods defined in `System.Xml.Linq`—the supplementary query
    operators we talked about in the overview.
  prefs: []
  type: TYPE_NORMAL
- en: FirstNode, LastNode, and Nodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`FirstNode` and `LastNode` give you direct access to the first or last child
    node; `Nodes` returns all children as a sequence. All three functions consider
    only direct descendants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Retrieving elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Elements` method returns just the child nodes of type `XElement`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following LINQ query finds the toolbox with the nail gun:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The next example uses a `SelectMany` query to retrieve the hand tools in all
    toolboxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`Elements` itself is equivalent to a LINQ query on `Nodes`. Our preceding query
    could be started as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`Elements` can also return just the elements of a given name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`Elements` is also defined as an extension method accepting `IEnumerable​<XCon⁠tainer>`
    or, more precisely, it accepts an argument of this type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows it to work with sequences of elements, too. Using this method,
    we can rewrite the query that finds the hand tools in all toolboxes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The first call to `Elements` binds to `XContainer`’s instance method; the second
    call to `Elements` binds to the extension method.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving a single element
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The method `Element` (singular) returns the first matching element of the given
    name. `Element` is useful for simple navigation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`Element` is equivalent to calling `Elements()` and then applying LINQ’s `FirstOr​De⁠fault`
    query operator with a name-matching predicate. `Element` returns `null` if the
    requested element doesn’t exist.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`Element("xyz").Value` will throw a `NullReferenceException` if element `xyz`
    does not exist. If you’d prefer a `null` to an exception, either use the null-conditional
    operator—`Element("xyz")?.Value`—or cast the `XElement` to a `string` instead
    of querying its `Value` property. In other words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This works because `XElement` defines an explicit `string` conversion—just for
    this purpose!
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving descendants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`XContainer` also provides `Descendants` and `DescendantNodes` methods that
    return child elements or nodes plus all of their children, and so on (the entire
    tree). `Descendants` accepts an optional element name. Returning to our earlier
    example, we can use `Descendants` to find all of the hand tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Both parent and leaf nodes are included, as the following example demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The next query extracts all comments anywhere within the X-DOM that contain
    the word “careful”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Parent Navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All `XNode`s have a `Parent` property and `Ancestor*XXX*` methods for parent
    navigation. A parent is always an `XElement`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Return type | Members | Works on |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `XElement` | `Parent { get; }` | `XNode` |'
  prefs: []
  type: TYPE_TB
- en: '| `Enumerable<XElement>` | `Ancestors()` | `XNode` |'
  prefs: []
  type: TYPE_TB
- en: '|   | `Ancestors (XName)` | `XNode` |'
  prefs: []
  type: TYPE_TB
- en: '|   | `AncestorsAndSelf()` | `XElement` |'
  prefs: []
  type: TYPE_TB
- en: '|   | `AncestorsAndSelf (XName)` | `XElement` |'
  prefs: []
  type: TYPE_TB
- en: 'If `x` is an `XElement`, the following always prints `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the same is not the case if `x` is an `XDocument`. `XDocument` is
    peculiar: it can have children but can never be anyone’s parent! To access the
    `XDocument`, you instead use the `Document` property; this works on any object
    in the X-DOM tree.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Ancestors` returns a sequence whose first element is `Parent` and whose next
    element is `Parent.Parent`, and so on, until the root element.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can navigate to the root element with the LINQ query `AncestorsAndSelf().Last()`.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to achieve the same thing is to call `Docu⁠ment​.Root`, although
    this works only if an `XDocument` is present.
  prefs: []
  type: TYPE_NORMAL
- en: Peer Node Navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Return type | Members | Defined in |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | `IsBefore (XNode node)` | `XNode` |'
  prefs: []
  type: TYPE_TB
- en: '|   | `IsAfter (XNode node)` | `XNode` |'
  prefs: []
  type: TYPE_TB
- en: '| `XNode` | `PreviousNode { get; }` | `XNode` |'
  prefs: []
  type: TYPE_TB
- en: '|   | `NextNode { get; }` | `XNode` |'
  prefs: []
  type: TYPE_TB
- en: '| `IEnumerable<XNode>` | `NodesBeforeSelf()` | `XNode` |'
  prefs: []
  type: TYPE_TB
- en: '|   | `NodesAfterSelf()` | `XNode` |'
  prefs: []
  type: TYPE_TB
- en: '| `IEnumerable<XElement>` | `ElementsBeforeSelf()` | `XNode` |'
  prefs: []
  type: TYPE_TB
- en: '|   | `ElementsBeforeSelf (XName name)` | `XNode` |'
  prefs: []
  type: TYPE_TB
- en: '|   | `ElementsAfterSelf()` | `XNode` |'
  prefs: []
  type: TYPE_TB
- en: '|   | `ElementsAfterSelf (XName name)` | `XNode` |'
  prefs: []
  type: TYPE_TB
- en: 'With `PreviousNode` and `NextNode` (and `FirstNode`/`LastNode`), you can traverse
    nodes with the feel of a linked list. This is noncoincidental: internally, nodes
    are stored in a linked list.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`XNode` internally uses a *singly* linked list, so `PreviousNode` is not performant.'
  prefs: []
  type: TYPE_NORMAL
- en: Attribute Navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Return type | Members | Defined in |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | `HasAttributes { get; }` | `XElement` |'
  prefs: []
  type: TYPE_TB
- en: '| `XAttribute` | `Attribute (XName name)` | `XElement` |'
  prefs: []
  type: TYPE_TB
- en: '|   | `FirstAttribute { get; }` | `XElement` |'
  prefs: []
  type: TYPE_TB
- en: '|   | `LastAttribute { get; }` | `XElement` |'
  prefs: []
  type: TYPE_TB
- en: '| `IEnumerable<XAttribute>` | `Attributes()` | `XElement` |'
  prefs: []
  type: TYPE_TB
- en: '|   | `Attributes (XName name)` | `XElement` |'
  prefs: []
  type: TYPE_TB
- en: In addition, `XAttribute` defines `PreviousAttribute` and `NextAttribute` properties
    as well as `Parent`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Attributes` method that accepts a name returns a sequence with either zero
    or one element; an element cannot have duplicate attribute names in XML.
  prefs: []
  type: TYPE_NORMAL
- en: Updating an X-DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can update elements and attributes in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Call `SetValue` or reassign the `Value` property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call `SetElementValue` or `SetAttributeValue`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call one of the `Remove*XXX*` methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call one of the `Add*XXX*` or `Replace*XXX*` methods, specifying fresh content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also reassign the `Name` property on `XElement` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Value Updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Members | Works on |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `SetValue (object value)` | `XElement`, `XAttribute` |'
  prefs: []
  type: TYPE_TB
- en: '| `Value { get; set }` | `XElement`, `XAttribute` |'
  prefs: []
  type: TYPE_TB
- en: 'The `SetValue` method replaces an element or attribute’s content with a simple
    value. Setting the `Value` property does the same but accepts string data only.
    We describe both of these functions in detail later in [“Working with Values”](#working_with_values).
    An effect of calling `SetValue` (or reassigning `Value`) is that it replaces all
    child nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Updating Child Nodes and Attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Category | Members | Works on |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Add | `Add (params object[] content)` | `XContainer` |'
  prefs: []
  type: TYPE_TB
- en: '|   | `AddFirst (params object[] content)` | `XContainer` |'
  prefs: []
  type: TYPE_TB
- en: '| Remove | `RemoveNodes()` | `XContainer` |'
  prefs: []
  type: TYPE_TB
- en: '|   | `RemoveAttributes()` | `XElement` |'
  prefs: []
  type: TYPE_TB
- en: '|   | `RemoveAll()` | `XElement` |'
  prefs: []
  type: TYPE_TB
- en: '| Update | `ReplaceNodes (params object[] content)` | `XContainer` |'
  prefs: []
  type: TYPE_TB
- en: '|   | `ReplaceAttributes (params object[] content)` | `XElement` |'
  prefs: []
  type: TYPE_TB
- en: '|   | `ReplaceAll (params object[] content` | `XElement` |'
  prefs: []
  type: TYPE_TB
- en: '|   | `SetElementValue (XName name, object value)` | `XElement` |'
  prefs: []
  type: TYPE_TB
- en: '|   | `SetAttributeValue (XName name, object value)` | `XElement` |'
  prefs: []
  type: TYPE_TB
- en: 'The most convenient methods in this group are the last two: `SetElementValue`
    and `SetAttributeValue`. They serve as shortcuts for instantiating an `XElement`
    or `XAttribute` and then `Add`ing it to a parent, replacing any existing element
    or attribute of that name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`Add` appends a child node to an element or document. `AddFirst` does the same
    thing but inserts at the beginning of the collection rather than the end.'
  prefs: []
  type: TYPE_NORMAL
- en: You can remove all child nodes or attributes in one hit with `RemoveNodes` or
    `RemoveAttributes`. `RemoveAll` is equivalent to calling both methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `Replace*XXX*` methods are equivalent to `Remov`ing and then `Add`ing. They
    take a snapshot of the input, so `e.ReplaceNodes(e.Nodes())` works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Updating Through the Parent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Members | Works on |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `AddBeforeSelf (params object[] content)` | `XNode` |'
  prefs: []
  type: TYPE_TB
- en: '| `AddAfterSelf (params object[] content)` | `XNode` |'
  prefs: []
  type: TYPE_TB
- en: '| `Remove()` | `XNode`, `XAttribute` |'
  prefs: []
  type: TYPE_TB
- en: '| `ReplaceWith (params object[] content)` | `XNode` |'
  prefs: []
  type: TYPE_TB
- en: 'The methods `AddBeforeSelf`, `AddAfterSelf`, `Remove`, and `ReplaceWith` don’t
    operate on the node’s children. Instead, they operate on the collection in which
    the node itself is in. This requires that the node have a parent element—otherwise,
    an exception is thrown. `AddBeforeSelf` and `AddAfterSelf` are useful for inserting
    a node into an arbitrary position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Inserting into an arbitrary position within a long sequence of elements is efficient
    because nodes are stored internally in a linked list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Remove` method removes the current node from its parent. `ReplaceWith`
    does the same and then inserts some other content at the same position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Removing a sequence of nodes or attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Thanks to extension methods in `System.Xml.Linq`, you can also call `Remove`
    on a *sequence* of nodes or attributes. Consider this X-DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following removes all customers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The following removes all archived contacts (so *Chris* disappears):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If we replaced `Elements()` with `Descendants()`, all archived elements throughout
    the DOM would disappear, yielding this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The next example removes all contacts that feature the comment “confidential”
    anywhere in their tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Contrast this with the following simpler query, which strips all comment nodes
    from the tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Internally, the `Remove` method first reads all matching elements into a temporary
    list and then enumerates over the temporary list to perform the deletions. This
    prevents errors that could otherwise result from deleting and querying at the
    same time.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`XElement` and `XAttribute` both have a `Value` property of type `string`.
    If an element has a single `XText` child node, `XElement`’s `Value` property acts
    as a convenient shortcut to the content of that node. With `XAttribute`, the `Value`
    property is simply the attribute’s value.'
  prefs: []
  type: TYPE_NORMAL
- en: Despite the storage differences, the X-DOM provides a consistent set of operations
    for working with element and attribute values.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways to assign a value: call `SetValue` or assign the `Value`
    property. `SetValue` is more flexible because it accepts not just strings but
    other simple data types, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We could have instead just set the element’s `Value` property, but this would
    mean manually converting the `DateTime` to a string. This is more complicated
    than calling `ToString`—it requires the use of `XmlConvert` for an XML-compliant
    result.
  prefs: []
  type: TYPE_NORMAL
- en: When you pass a *value* into `XElement` or `XAttribute`’s constructor, the same
    automatic conversion takes place for nonstring types. This ensures that `DateTime`s
    are correctly formatted; `true` is written in lowercase, and `double.NegativeInfinity`
    is written as “-INF”.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To go the other way around and parse a `Value` back to a base type, you simply
    cast the `XElement` or `XAttribute` to the desired type. It sounds like it shouldn’t
    work—but it does! For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: An element or attribute doesn’t store `DateTime`s or numbers natively—they’re
    always stored as text and then parsed as needed. It also doesn’t “remember” the
    original type, so you must cast it correctly to prevent a runtime error. To make
    your code robust, you can put the cast in a `try`/`catch` block, catching a `Format​Excep⁠tion`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Explicit casts on `XElement` and `XAttribute` can parse to the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: All standard numeric types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string`, `bool`, `DateTime`, `DateTimeOffset`, `TimeSpan`, and `Guid`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Nullable<>` versions of the aforementioned value types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Casting to a nullable type is useful in conjunction with the `Element` and
    `Attribute` methods, because if the requested name doesn’t exist, the cast still
    works. For instance, if `x` has no `timeout` element, the first line generates
    a runtime error and the second line does not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You can factor away the nullable type in the final result with the `??` operator.
    The following evaluates to `1.0` if the `resolution` attribute doesn’t exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Casting to a nullable type won’t get you out of trouble, though, if the element
    or attribute *exists* and has an empty (or improperly formatted) value. For this,
    you must catch a `FormatException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use casts in LINQ queries. The following returns “John”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Casting to a nullable `int` prevents a `NullReferenceException` in the case
    of Anne, who has no `credit` attribute. Another solution would be to add a predicate
    to the `where` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The same principles apply in querying element values.
  prefs: []
  type: TYPE_NORMAL
- en: Values and Mixed Content Nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Given the value of `Value`, you might wonder when you’d ever need to deal directly
    with `XText` nodes. The answer is when you have mixed content. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple `Value` property is not enough to capture `summary`’s content. The
    `summary` element contains three children: an `XText` node, followed by an `XElement`,
    followed by another `XText` node. Here’s how to construct it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, we can still query `summary`’s `Value`—without getting an exception.
    Instead, we get a concatenation of each child’s value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: It’s also legal to reassign `summary`’s `Value`, at the cost of replacing all
    previous children with a single new `XText` node.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic XText Concatenation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you add simple content to an `XElement`, the X-DOM appends to the existing
    `XText` child rather than creating a new one. In the following examples, `e1`
    and `e2` end up with just one child `XText` element whose value is `HelloWorld`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If you specifically create `XText` nodes, however, you end up with multiple
    children:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '`XElement` doesn’t concatenate the two `XText` nodes, so the nodes’ object
    identities are preserved.'
  prefs: []
  type: TYPE_NORMAL
- en: Documents and Declarations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: XDocument
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we said previously, an `XDocument` wraps a root `XElement` and allows you
    to add an `XDeclaration`, processing instructions, a document type, and root-level
    comments. An `XDocument` is optional and can be ignored or omitted: unlike with
    the W3C DOM, it does not serve as glue to keep everything together.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An `XDocument` provides the same functional constructors as `XElement`. And
    because it’s based on `XContainer`, it also supports the `Add*XXX*`, `Remove*XXX*`,
    and `Replace*XXX*` methods. Unlike `XElement`, however, an `XDocument` can accept
    only limited content:'
  prefs: []
  type: TYPE_NORMAL
- en: A single `XElement` object (the “root”)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single `XDeclaration` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single `XDocumentType` object (to reference a document type definition [DTD])
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any number of `XProcessingInstruction` objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any number of `XComment` objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Of these, only the root `XElement` is mandatory in order to have a valid `XDocument`.
    The `XDeclaration` is optional—if omitted, default settings are applied during
    serialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest valid `XDocument` has just a root element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we didn’t include an `XDeclaration` object. The file generated by
    calling `doc.Save` would still contain an XML declaration, however, because one
    is generated by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example produces a simple but correct XHTML file, illustrating all
    the constructs that an `XDocument` can accept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The resultant *test.html* reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '`XDocument` has a `Root` property that serves as a shortcut for accessing a
    document’s single `XElement`. The reverse link is provided by `XObject`’s `Document`
    property, which works for all objects in the tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall that a document’s children have no `Parent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: An `XDeclaration` is not an `XNode` and does not appear in the document’s `Nodes`
    collection—unlike comments, processing instructions, and the root element. Instead,
    it’s assigned to a dedicated property called `Declaration`. This is why “True”
    is repeated four and not five times in the last example.
  prefs: []
  type: TYPE_NORMAL
- en: XML Declarations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A standard XML file starts with a declaration such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'An XML declaration ensures that the file will be correctly parsed and understood
    by a reader. `XElement` and `XDocument` follow these rules in emitting XML declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: Calling `Save` with a filename always writes a declaration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling `Save` with an `XmlWriter` writes a declaration unless the `XmlWriter`
    is instructed otherwise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ToString` method never emits an XML declaration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can instruct an `XmlWriter` not to produce a declaration by setting the
    `OmitXmlDeclaration` and `ConformanceLevel` properties of an `XmlWriterSettings`
    object when constructing the `XmlWriter`. We describe this in [Chapter 11](ch11.html#other_xml_and_json_technologies).
  prefs: []
  type: TYPE_NORMAL
- en: 'The presence or absence of an `XDeclaration` object has no effect on whether
    an XML declaration is written. The purpose of an `XDeclaration` is instead to
    *hint the XML serialization*, in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: What text encoding to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What to put in the XML declaration’s `encoding` and `standalone` attributes
    (should a declaration be written)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XDeclaration`’s constructor accepts three arguments, which correspond to the
    attributes `version`, `encoding`, and `standalone`. In the following example,
    *test.xml* is encoded in UTF-16:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Whatever you specify for the XML version is ignored by the XML writer: it always
    writes `"1.0"`.'
  prefs: []
  type: TYPE_NORMAL
- en: The encoding must use an IETF code such as `"utf-16"`, just as it would appear
    in the XML declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a declaration to a string
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose that we want to serialize an `XDocument` to a `string`, including the
    XML declaration. Because `ToString` doesn’t write a declaration, we’d need to
    use an `XmlWriter` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have UTF-16 in the output, even though we explicitly requested
    UTF-8 in an `XDeclaration`! This might look like a bug, but in fact, `XmlWriter`
    is being remarkably smart. Because we’re writing to a `string` and not a file
    or stream, it’s impossible to apply any encoding other than UTF-16—the format
    in which strings are internally stored. Hence, `XmlWriter` writes `"utf-16"` so
    as not to lie.
  prefs: []
  type: TYPE_NORMAL
- en: 'This also explains why the `ToString` method doesn’t emit an XML declaration.
    Imagine that instead of calling `Save`, you did the following to write an `XDocument`
    to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: As it stands, *data.xml* would lack an XML declaration, making it incomplete
    but still parsable (you can infer the text encoding). But if `ToString()` emitted
    an XML declaration, *data.xml* would actually contain an *incorrect* declaration
    (`encoding="utf-16"`), which might prevent it from being read at all because `WriteAllText`
    encodes using UTF-8.
  prefs: []
  type: TYPE_NORMAL
- en: Names and Namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as .NET types can have namespaces, so too can XML elements and attributes.
  prefs: []
  type: TYPE_NORMAL
- en: XML namespaces achieve two things. First, rather like namespaces in C#, they
    help prevent naming collisions. This can become an issue when you merge data from
    one XML file into another. Second, namespaces assign *absolute* meaning to a name.
    The name “nil,” for instance, could mean anything. Within the *http://www.w3.org/2001/xmlschema-instance*
    namespace, however, “nil” means something equivalent to `null` in C# and comes
    with specific rules on how it can be applied.
  prefs: []
  type: TYPE_NORMAL
- en: Because XML namespaces are a significant source of confusion, we first cover
    namespaces in general, and then move on to how they’re used in LINQ to XML.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces in XML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose that we want to define a `customer` element in the namespace `OReilly.Nutshell.CSharp`.
    There are two ways to proceed. The first is to use the `xmlns` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '**`xmlns` is a special reserved attribute. When used in this manner, it performs
    two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: It specifies a namespace for the element in question.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It specifies a default namespace for all descendant elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This means that in the following example, `address` and `postcode` implicitly
    reside in the `OReilly.Nutshell.CSharp` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want `address` and `postcode` to have *no* namespace, we’d need to do
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Prefixes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The other way to specify a namespace is with a *prefix*. A prefix is an alias
    that you assign to a namespace to save typing. There are two steps in using a
    prefix—*defining* the prefix and *using* it. You can do both together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Two distinct things are happening here. On the right, defines a prefix called
    `nut` and makes it available to this element and all its descendants. On the left,
    `nut:customer` assigns the newly allocated prefix to the `customer` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'A prefixed element *does not* define a default namespace for descendants. In
    the following XML, `firstname` has an empty namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'To give `firstname` the `OReilly.Nutshell.CSharp` prefix, you must do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also define a prefix—or prefixes—for the convenience of your descendants,
    without assigning any of them to the parent element itself. The following defines
    two prefixes, `i` and `z`, while leaving the `customer` element itself with an
    empty namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: If this were the root node, the whole document would have `i` and `z` at its
    fingertips. Prefixes are convenient when elements need to draw from multiple namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that both namespaces in this example are URIs. Using URIs (that you
    own) is standard practice: it ensures namespace uniqueness. So, in real life,
    our `customer` element would more likely be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can assign namespaces to attributes, too. The main difference is that an
    attribute always requires a prefix. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Another difference is that an unqualified attribute always has an empty namespace:
    it never inherits a default namespace from a parent element.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Attributes tend not to need namespaces because their meaning is usually local
    to the element. An exception is with general-purpose or metadata attributes such
    as the `nil` attribute defined by W3C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: This indicates unambiguously that `lastname` is `nil` (`null` in C#) and not
    an empty string. Because we’ve used the standard namespace, a general-purpose
    parsing utility could know with certainty our intention.**  **## Specifying Namespaces
    in the X-DOM
  prefs: []
  type: TYPE_NORMAL
- en: So far in this chapter, we’ve used just simple strings for `XElement` and `XAttribute`
    names. A simple string corresponds to an XML name with an empty namespace—rather
    like a .NET type defined in the global namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of ways to specify an XML namespace. The first is to enclose
    it in braces, before the local name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields the resulting XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The second (and more performant) approach is to use the `XNamespace` and `XName`
    types. Here are their definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Both types define implicit casts from `string`, so the following is legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '`XNamespace` also overloads the `+` operator, allowing you to combine a namespace
    and name into an `XName` without using braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: All constructors and methods in the X-DOM that accept an element or attribute
    name actually accept an `XName` object rather than a `string`. The reason you
    can substitute a string—as in all our examples to date—is because of the implicit
    cast.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifying a namespace is the same whether for an element or an attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The X-DOM and Default Namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The X-DOM ignores the concept of default namespaces until it comes time to
    actually output XML. This means that when you construct a child `XElement`, you
    must give it a namespace explicitly if needed; it *will not* inherit from the
    parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The X-DOM does, however, apply default namespaces when reading and outputting
    XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: If you construct `XElement` children without specifying namespaces, in other
    words
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'you get this result instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Another trap is failing to include a namespace when navigating an X-DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'If you build an X-DOM tree without specifying namespaces, you can subsequently
    assign every element to a single namespace, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Prefixes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The X-DOM treats prefixes just as it treats namespaces: purely as a serialization
    function. This means that you can choose to completely ignore the issue of prefixes—and
    get by! The only reason you might want to do otherwise is for efficiency when
    outputting to an XML file. For example, consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, `XElement` will serialize this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there’s a bit of unnecessary duplication. The solution is *not*
    to change the way you construct the X-DOM, but instead to hint the serializer
    prior to writing the XML. Do this by adding attributes defining prefixes that
    you want to see applied. This is typically done on the root element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'This assigns the prefix “ns1” to our `XNamespace` variable `ns1`, and “ns2”
    to `ns2`. The X-DOM automatically picks up these attributes when serializing and
    uses them to condense the resulting XML. Here’s the result now of calling `ToString`
    on `mix`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Prefixes don’t change the way you construct, query, or update the X-DOM—for
    these activities, you ignore the presence of prefixes and continue to use full
    names. Prefixes come into play only when converting to and from XML files or streams.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prefixes are also honored in serializing attributes. In the following example,
    we record a customer’s date of birth and credit as `"nil"` using the W3C-standard
    attribute. The highlighted line ensures that the prefix is serialized without
    unnecessary namespace repetition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'This is its XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: For brevity, we predeclared the nil `XAttribute` so that we could use it twice
    in building the DOM. You’re allowed to reference the same attribute twice because
    it’s automatically duplicated as required.**  **# Annotations
  prefs: []
  type: TYPE_NORMAL
- en: You can attach custom data to any `XObject` with an annotation. Annotations
    are intended for your own private use and are treated as black boxes by X-DOM.
    If you’ve ever used the `Tag` property on a Windows Forms or Windows Presentation
    Foundation (WPF) control, you’ll be familiar with the concept—the difference is
    that you have multiple annotations, and your annotations can be *privately scoped*.
    You can create an annotation that other types cannot even see—let alone overwrite.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following methods on `XObject` add and remove annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The following methods retrieve annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Each annotation is keyed by its *type*, which must be a reference type. The
    following adds and then retrieves a `string` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: You can add multiple annotations of the same type and then use the `Annotations`
    method to retrieve a *sequence* of matches.
  prefs: []
  type: TYPE_NORMAL
- en: 'A public type such as `string` doesn’t make a great key, however, because code
    in other types can interfere with your annotations. A better approach is to use
    an internal or (nested) private class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove annotations, you must also have access to the key’s type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Projecting into an X-DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we’ve shown how to use LINQ to get data *out* of an X-DOM. You can
    also use LINQ queries to project *into* an X-DOM. The source can be anything over
    which LINQ can query, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: EF Core entity classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A local collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another X-DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Regardless of the source, the strategy is the same in using LINQ to emit an
    X-DOM: first write a *functional construction* expression that produces the desired
    X-DOM shape and then build a LINQ query around the expression.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, suppose that we want to retrieve customers from a database into
    the following XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by writing a functional construction expression for the X-DOM using
    simple literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'We then turn this into a projection and build a LINQ query around it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The call to `AsEnumerable` is required due to a bug in EF Core (a fix is scheduled
    for a later release). After the bug is fixed, removing the call to `AsEnumerable`
    will improve efficiency by preventing a round-trip with each call to `c.Purchases.Count`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see how this works more clearly by constructing the same query in two
    steps. First:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'This inner portion is a normal LINQ query that projects into `XElement`s. Here’s
    the second step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: This constructs the root `XElement`. The only thing unusual is that the content,
    `sqlQuery`, is not a single `XElement` but an `IQueryable<XElement>`, which implements
    `IEnumerable<XElement>`. Remember that in the processing of XML content, collections
    are automatically enumerated. So, each `XElement` is added as a child node.
  prefs: []
  type: TYPE_NORMAL
- en: Eliminating Empty Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose in the preceding example that we also wanted to include details of
    the customer’s most recent high-value purchase. We could do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'This emits empty elements, though, for customers with no high-value purchases.
    (If it were a local query rather than a database query, it would throw a `NullReferenceException`.)
    In such cases, it would be better to omit the `lastBigBuy` node entirely. We can
    achieve this by wrapping the constructor for the `lastBigBuy` element in a conditional
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: For customers with no `lastBigBuy`, a `null` is emitted instead of an empty
    `XElement`. This is what we want, because `null` content is simply ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Streaming a Projection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’re projecting into an X-DOM only to `Save` it (or call `ToString` on
    it), you can improve memory efficiency through an `XStreamingElement`. An `XStreaming​Ele⁠ment`
    is a cut-down version of `XElement` that applies *deferred loading* semantics
    to its child content. To use it, you simply replace the outer `XElement`s with
    `XStreamin⁠g​Element`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: The queries passed into an `XStreamingElement`’s constructor are not enumerated
    until you call `Save`, `ToString`, or `WriteTo` on the element; this prevents
    loading the whole X-DOM into memory at once. The flipside is that the queries
    are reevaluated, should you re-`Save`. Also, you cannot traverse an `XStreamingElement`’s
    child content—it does not expose methods such as `Elements` or `Attributes`.
  prefs: []
  type: TYPE_NORMAL
- en: '`XStreamingElement` is not based on `XObject`—or any other class—because it
    has such a limited set of members. The only members it has, besides `Save`, `ToString`,
    and `WriteTo`, are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An `Add` method, which accepts content like the constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Name` property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XStreamingElement` does not allow you to *read* content in a streamed fashion—for
    this, you must use an `XmlReader` in conjunction with the X-DOM. We describe how
    to do this in [“Patterns for Using XmlReader/XmlWriter”](ch11.html#patterns_for_using_xmlreadersolidusxmlw).'
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch10.html#ch01fn11-marker)) The X-DOM actually optimizes this step internally
    by storing simple text content in a string. The `XTEXT` node is not actually created
    until you call `Nodes( )` on the `XContainer`.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch10.html#ch01fn12-marker)) See [footnote 1](#ch01fn11).**
  prefs: []
  type: TYPE_NORMAL
