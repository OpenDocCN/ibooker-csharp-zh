- en: C# 12 Pocket Reference
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 12 口袋参考书
- en: C# is a general-purpose, type-safe, primarily object-oriented programming language,
    the goal of which is programmer productivity. To this end, the language balances
    simplicity, expressiveness, and performance. C# 12 is designed to work with the
    Microsoft *.NET 8* runtime (whereas C# 11 targets .NET 7, C# 10 targets .NET 6,
    and C# 7 targets Microsoft *.NET Framework* 4.6/4.7/4.8).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C# 是一种通用、类型安全的、主要面向对象的编程语言，其目标是提高程序员的生产力。为此，语言在简单性、表现力和性能之间保持平衡。C# 12 设计用于与
    Microsoft *.NET 8* 运行时配合（而 C# 11 则面向 .NET 7，C# 10 则面向 .NET 6，C# 7 则面向 Microsoft
    *.NET Framework* 4.6/4.7/4.8）。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The programs and code snippets in this book mirror those in Chapters 2 through
    4 of *C# 12 in a Nutshell* and are all available as interactive samples in [*LINQPad*](http://www.linqpad.net).
    Working through these samples in conjunction with the book accelerates learning
    in that you can edit the samples and instantly see the results without needing
    to set up projects and solutions in Visual Studio.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的程序和代码片段与 *C# 12 in a Nutshell* 的第 2 到第 4 章中的代码镜像，并且都可以作为交互式示例在 [*LINQPad*](http://www.linqpad.net)
    中使用。通过与书籍一起使用这些示例，可以加速学习，您可以编辑示例并立即看到结果，无需在 Visual Studio 中设置项目和解决方案。
- en: To download the samples, click the Samples tab in LINQPad and then click “Download
    more samples.” LINQPad is free—go to [*www.linqpad.net*](http://www.linqpad.net).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载示例，请点击 LINQPad 中的 Samples 标签，然后点击“Download more samples”。LINQPad 是免费的，访问
    [*www.linqpad.net*](http://www.linqpad.net)。
- en: A First C# Program
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个 C# 程序
- en: 'Following is a program that multiplies 12 by 30 and prints the result, 360,
    to the screen. The double forward slash indicates that the remainder of a line
    is a *comment*:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个将 12 乘以 30 并将结果 360 打印到屏幕的程序。双斜线表示行的剩余部分是*注释*：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Our program consists of two *statements*. Statements in C# execute sequentially
    and are terminated by a semicolon. The first statement computes the *expression*
    `12 * 30` and stores the result in a *variable*, named `x`, whose type is a 32-bit
    integer (`int`). The second statement calls the `WriteLine` *method* on a *class*
    called `Console`, which is defined in a *namespace* called `System`. This prints
    the variable `x` to a text window on the screen.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序由两个*语句*组成。C# 中的语句按顺序执行，并以分号终止。第一个语句计算*表达式* `12 * 30` 并将结果存储在名为 `x` 的*变量*中，其类型是
    32 位整数 (`int`)。第二个语句在名为 `Console` 的*类*上调用 `WriteLine` *方法*，该类定义在名为 `System` 的*命名空间*中。这将变量
    `x` 打印到屏幕上的文本窗口中。
- en: A method performs a function; a class groups function members and data members
    to form an object-oriented building block. The `Console` class groups members
    that handle command-line input/output (I/O) functionality, such as the `WriteLine`
    method. A class is a kind of *type*, which we examine in [“Type Basics”](#type_basics).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 方法执行一个功能；类将函数成员和数据成员组合成面向对象的构建块。`Console` 类组合了处理命令行输入/输出（I/O）功能的成员，比如 `WriteLine`
    方法。类是一种*类型*，我们在[“类型基础”](#type_basics)中讨论过。
- en: At the outermost level, types are organized into *namespaces*. Many commonly
    used types—including the `Console` class—reside in the `System` namespace. The
    .NET libraries are organized into nested namespaces. For example, the `System.Text`
    namespace contains types for handling text, and `System.IO` contains types for
    input/output.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在最外层，类型被组织到*命名空间*中。许多常用类型，包括 `Console` 类，驻留在 `System` 命名空间中。.NET 库被组织成嵌套命名空间。例如，`System.Text`
    命名空间包含用于处理文本的类型，而 `System.IO` 包含用于输入/输出的类型。
- en: 'Qualifying the `Console` class with the `System` namespace on every use adds
    clutter. The `using` directive lets you avoid this clutter by *importing* a namespace:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次使用时用 `System` 命名空间限定 `Console` 类会增加混乱。`using` 指令允许您通过*导入*一个命名空间来避免这种混乱：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A basic form of code reuse is to write higher-level functions that call lower-level
    functions. We can *refactor* our program with a reusable *method* called `FeetToInches`
    that multiplies an integer by 12, as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 代码重用的基本形式是编写调用低级函数的高级函数。我们可以通过一个可重用的*方法* `FeetToInches` 来*重构*我们的程序，该方法将整数乘以
    12，如下所示：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our method contains a series of statements surrounded by a pair of braces. This
    is called a *statement block*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法包含一系列被大括号包围的语句。这被称为*语句块*。
- en: 'A method can receive *input* data from the caller by specifying *parameters*
    and *output* data back to the caller by specifying a *return type*. Our `FeetToInches`
    method has a parameter for inputting feet, and a return type for outputting inches:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 方法可以通过指定*参数*从调用者那里接收*输入*数据，并通过指定*返回类型*向调用者返回*输出*数据。我们的`FeetToInches`方法具有输入英尺的参数和输出英寸的返回类型：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The *literals* `30` and `100` are the *arguments* passed to the `FeetToInches`
    method.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*字面量* `30` 和 `100` 是传递给`FeetToInches`方法的*参数*。'
- en: 'If a method doesn’t receive input, use empty parentheses. If it doesn’t return
    anything, use the `void` keyword:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法不接收输入，请使用空括号。如果方法不返回任何内容，请使用`void`关键字：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Methods are one of several kinds of functions in C#. Another kind of function
    we used in our example program was the `*` *operator*, which performs multiplication.
    There are also *constructors*, *properties*, *events*, *indexers*, and *finalizers*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是C#中几种函数的一种。我们示例程序中使用的另一种函数是`*` *操作符*，它执行乘法运算。还有*构造函数*、*属性*、*事件*、*索引器*和*终结器*。
- en: Compilation
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译
- en: The C# compiler compiles source code (a set of files with the *.cs* extension)
    into an *assembly*. An assembly is the unit of packaging and deployment in .NET.
    An assembly can be either an *application* or a *library*. A normal console or
    Windows application has an *entry point*, whereas a library does not. The purpose
    of a library is to be called upon (*referenced*) by an application or by other
    libraries. .NET itself is a set of libraries (as well as a runtime environment).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: C#编译器将源代码（一组扩展名为*.cs*的文件）编译成一个*程序集*。程序集是.NET中的打包和部署单元。程序集可以是*应用程序*或*库*。普通控制台或Windows应用程序具有*入口点*，而库则没有。库的目的是被应用程序或其他库*引用*。.NET本身是一组库（以及运行时环境）。
- en: Each of the programs in the preceding section began directly with a series of
    statements (called *top-level statements*). The presence of top-level statements
    implicitly creates an entry point for a console or Windows application. (Without
    top-level statements, a *Main method* denotes an application’s entry point—see
    [“Symmetry of predefined types and custom types”](#symmetry_of_predefined_types_and_custom).)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的节中，每个程序都直接以一系列语句开始（称为*顶级语句*）。顶级语句的存在隐式创建了控制台或Windows应用程序的入口点。（没有顶级语句时，*Main方法*表示应用程序的入口点—参见[“预定义类型和自定义类型的对称性”](#symmetry_of_predefined_types_and_custom)。）
- en: 'To invoke the compiler, you can either use an integrated development environment
    (IDE) such as Visual Studio or Visual Studio Code, or call it manually from the
    command line. To manually compile a console application with .NET, first download
    the .NET 8 SDK, and then create a new project, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用编译器，您可以使用集成开发环境（IDE）如Visual Studio或Visual Studio Code，也可以从命令行手动调用它。要使用.NET手动编译控制台应用程序，首先下载.NET
    8 SDK，然后按以下步骤创建新项目：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This creates a folder called *MyFirstProgram*, which contains a C# file called
    *Program.cs*, which you can then edit. To invoke the compiler, call `dotnet build`
    (or `dotnet run`, which will compile and then run the program). The output will
    be written to a subdirectory under *bin\debug*, which will include *MyFirstProgram.dll*
    (the output assembly) as well as *MyFirstProgram.exe* (which runs the compiled
    program directly).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为*MyFirstProgram*的文件夹，其中包含一个名为*Program.cs*的C#文件，您可以随后编辑。要调用编译器，请调用`dotnet
    build`（或`dotnet run`，它将编译然后运行程序）。输出将写入*bin\debug*子目录下，其中包括*MyFirstProgram.dll*（输出程序集）以及直接运行编译程序的*MyFirstProgram.exe*。
- en: Syntax
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法
- en: 'C# syntax is inspired by C and C++ syntax. In this section, we describe C#’s
    elements of syntax, using the following program:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: C#语法的灵感来源于C和C++语法。在本节中，我们描述了C#语法的各个元素，使用以下程序：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Identifiers and Keywords
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标识符和关键字
- en: '*Identifiers* are names that programmers choose for their classes, methods,
    variables, and so on. Here are the identifiers in our example program, in the
    order in which they appear:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*标识符*是程序员为其类、方法、变量等选择的名称。以下是我们示例程序中标识符的顺序：'
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: An identifier must be a whole word, essentially made up of Unicode characters
    starting with a letter or underscore. C# identifiers are case sensitive. By convention,
    parameters, local variables, and private fields should be in *camel case* (e.g.,
    `myVariable`), and all other identifiers should be in *Pascal case* (e.g., `MyMethod`).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符必须是一个完整的单词，基本上由以字母或下划线开头的 Unicode 字符组成。C# 标识符是区分大小写的。按照惯例，参数、局部变量和私有字段应该是*小驼峰命名法*（例如，`myVariable`），而其他所有标识符应该是*帕斯卡命名法*（例如，`MyMethod`）。
- en: '*Keywords* are names that mean something special to the compiler. There are
    two keywords in our example program, `using` and `int`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*关键字*是对编译器有特殊意义的名称。在我们的示例程序中有两个关键字，`using` 和 `int`。'
- en: 'Most keywords are *reserved*, which means that you can’t use them as identifiers.
    Here is the full list of C# reserved keywords:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数关键字是*保留*的，这意味着你不能把它们用作标识符。以下是所有 C# 保留关键字的完整列表：
- en: '| `abstract` `as`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '| `abstract` `as`'
- en: '`base`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`base`'
- en: '`bool`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`bool`'
- en: '`break`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`'
- en: '`byte`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`byte`'
- en: '`case`'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`case`'
- en: '`catch`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch`'
- en: '`char`'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`char`'
- en: '`checked`'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`checked`'
- en: '`class`'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`class`'
- en: '`const`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`'
- en: '`continue`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`'
- en: '`decimal`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`decimal`'
- en: '`default`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`default`'
- en: '`delegate`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`delegate`'
- en: '`do`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`do`'
- en: '`double`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`double`'
- en: '`else`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`else`'
- en: '`enum` | `event` `explicit`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum` | `event` `explicit`'
- en: '`extern`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`extern`'
- en: '`false`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`false`'
- en: '`finally`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally`'
- en: '`fixed`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`fixed`'
- en: '`float`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`float`'
- en: '`for`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`'
- en: '`foreach`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach`'
- en: '`goto`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`goto`'
- en: '`if`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`'
- en: '`implicit`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`implicit`'
- en: '`in`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`'
- en: '`int`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`int`'
- en: '`interface`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`interface`'
- en: '`internal`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`internal`'
- en: '`is`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`is`'
- en: '`lock`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`lock`'
- en: '`long`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`long`'
- en: '`namespace` | `new` `null`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`namespace` | `new` `null`'
- en: '`object`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`object`'
- en: '`operator`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`operator`'
- en: '`out`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`out`'
- en: '`override`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`override`'
- en: '`params`'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`params`'
- en: '`private`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`private`'
- en: '`protected`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`protected`'
- en: '`public`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`public`'
- en: '`readonly`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`readonly`'
- en: '`record`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`record`'
- en: '`ref`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`ref`'
- en: '`return`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`'
- en: '`sbyte`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`sbyte`'
- en: '`sealed`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`sealed`'
- en: '`short`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`short`'
- en: '`sizeof`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`sizeof`'
- en: '`stackalloc`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`stackalloc`'
- en: '`static` | `string` `struct`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`static` | `string` `struct`'
- en: '`switch`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`'
- en: '`this`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`'
- en: '`throw`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`throw`'
- en: '`true`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`true`'
- en: '`try`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`'
- en: '`typeof`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeof`'
- en: '`uint`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`uint`'
- en: '`ulong`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`ulong`'
- en: '`unchecked`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`unchecked`'
- en: '`unsafe`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`unsafe`'
- en: '`ushort`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`ushort`'
- en: '`using`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`using`'
- en: '`virtual`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`virtual`'
- en: '`void`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`void`'
- en: '`volatile`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`volatile`'
- en: '`while` |'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` |'
- en: Avoiding conflicts
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免冲突
- en: 'If you really want to use an identifier that clashes with a reserved keyword,
    you can do so by qualifying it with the `@` prefix. For instance:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实想使用与保留关键字冲突的标识符，可以通过在其前面加上 `@` 前缀来使用它。例如：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `@` symbol doesn’t form part of the identifier itself. So `@myVariable`
    is the same as `myVariable`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`@` 符号本身不是标识符的一部分。因此 `@myVariable` 和 `myVariable` 是相同的。'
- en: Contextual keywords
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上下文关键字
- en: 'Some keywords are *contextual*, meaning they can also be used as identifiers—without
    an `@` symbol. The contextual keywords are as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有些关键字是*上下文*关键字，这意味着它们也可以作为标识符使用——无需 `@` 符号。这些上下文关键字如下：
- en: '| `add` `alias`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '| `add` `alias`'
- en: '`and`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`and`'
- en: '`ascending`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`ascending`'
- en: '`async`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`'
- en: '`await`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`await`'
- en: '`by`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`by`'
- en: '`descending`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`descending`'
- en: '`dynamic`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynamic`'
- en: '`equals` | `file` `from`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`equals` | `file` `from`'
- en: '`get`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`'
- en: '`global`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`global`'
- en: '`group`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`group`'
- en: '`init`'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`'
- en: '`into`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`into`'
- en: '`join`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`join`'
- en: '`let`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`'
- en: '`managed` | `nameof` `nint`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`managed` | `nameof` `nint`'
- en: '`not`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`not`'
- en: '`notnull`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`notnull`'
- en: '`nuint`'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`nuint`'
- en: '`on`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`on`'
- en: '`or`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`or`'
- en: '`orderby`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`orderby`'
- en: '`partial`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`partial`'
- en: '`remove` | `required` `select`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove` | `required` `select`'
- en: '`set`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`'
- en: '`unmanaged`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`unmanaged`'
- en: '`value`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`value`'
- en: '`var`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`var`'
- en: '`with`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`with`'
- en: '`when`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`when`'
- en: '`where`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`where`'
- en: '`yield` |'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield` |'
- en: With contextual keywords, ambiguity cannot arise within the context in which
    they are used.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上下文关键字，可以在使用它们的上下文中消除歧义。
- en: Literals, Punctuators, and Operators
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字面量、标点符号和操作符
- en: '*Literals* are primitive pieces of data lexically embedded into the program.
    The literals we used in our example program are `12` and `30`. *Punctuators* help
    demarcate the structure of the program. An example is the semicolon, which terminates
    a statement. Statements can wrap multiple lines:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*字面量*是程序中词法上嵌入的原始数据片段。我们在示例程序中使用的字面量是`12`和`30`。*标点符号*帮助标明程序的结构。例如，分号用于终止语句。语句可以跨多行：'
- en: '[PRE9]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'An *operator* transforms and combines expressions. Most operators in C# are
    denoted with a symbol, such as the multiplication operator, `*`. Here are the
    operators in our program:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*操作符*用于转换和组合表达式。C# 中的大多数操作符用符号表示，例如乘法操作符 `*`。以下是我们程序中的操作符：'
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A period denotes a member of something (or a decimal point with numeric literals).
    Parentheses are used when declaring or calling a method; empty parentheses are
    used when the method accepts no arguments. The equals sign performs *assignment*
    (the double equals sign, `==`, performs equality comparison).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 句点表示某物的成员（或数字字面量的小数点）。在声明或调用方法时使用括号；当方法不接受参数时使用空括号。等号执行*赋值*（双等号 `==` 执行相等比较）。
- en: Comments
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: 'C# offers two different styles of source code documentation: *single-line comments*
    and *multiline comments*. A single-line comment begins with a double forward slash
    and continues until the end of the line. For example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: C#提供了两种不同的源代码文档风格：*单行注释*和*多行注释*。单行注释以双斜杠开头，直到行尾。例如：
- en: '[PRE11]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A multiline comment begins with `/*` and ends with `*/`. For example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释以`/*`开头，以`*/`结尾。例如：
- en: '[PRE12]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Comments can embed XML documentation tags (see [“XML Documentation”](#xml_documentation)).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注释可以嵌入XML文档标签（见[“XML文档”](#xml_documentation)）。
- en: Type Basics
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型基础知识
- en: A *type* defines the blueprint for a value. In our example, we used two literals
    of type `int` with values 12 and 30\. We also declared a *variable* of type `int`
    whose name was `x`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型*定义了值的蓝图。在我们的示例中，我们使用了两个`int`类型的文字值，分别为12和30。我们还声明了一个类型为`int`的*变量*，其名称为`x`。'
- en: A *variable* denotes a storage location that can contain different values over
    time. In contrast, a *constant* always represents the same value (more on this
    later).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*变量*表示可以随时间包含不同值的存储位置。相比之下，*常量*始终表示相同的值（稍后详述）。'
- en: All values in C# are an *instance* of a specific type. The meaning of a value,
    and the set of possible values a variable can have, is determined by its type.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，所有的值都是特定类型的*实例*。值的含义以及变量可能具有的可能值集由其类型确定。
- en: Predefined Type Examples
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预定义类型示例
- en: 'Predefined types (also called *built-in* types) are types that are specially
    supported by the compiler. The `int` type is a predefined type for representing
    the set of integers that fit into 32 bits of memory, from −2^(31) to 2^(31)−1\.
    We can perform functions such as arithmetic with instances of the `int` type as
    follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 预定义类型（也称为*内置*类型）是编译器特别支持的类型。`int`类型是用于表示内存中适合32位整数集的预定义类型，范围从−2^(31)到2^(31)−1。我们可以按如下方式对`int`类型的实例执行算术函数：
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Another predefined C# type is `string`. The `string` type represents a sequence
    of characters, such as “.NET” or “[*http://oreilly.com*](http://oreilly.com).
    We can work with strings by calling functions on them, as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个预定义的C#类型是`string`。`string`类型表示字符序列，例如“.NET”或“[*http://oreilly.com*](http://oreilly.com)”。我们可以通过在它们上调用函数来处理字符串，如下所示：
- en: '[PRE14]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The predefined `bool` type has exactly two possible values: `true` and `false`.
    The `bool` type is commonly used to conditionally branch execution flow with an
    `if` statement. For example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 预定义的`bool`类型只有两个可能的值：`true`和`false`。`bool`类型通常用于通过`if`语句有条件地分支执行流程。例如：
- en: '[PRE15]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `System` namespace in .NET contains many important types that are not predefined
    by C# (e.g., `DateTime`).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，`System`命名空间包含许多重要类型，这些类型不是由C#预定义的（例如，`DateTime`）。
- en: Custom Type Examples
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义类型示例
- en: 'Just as you can build complex functions from simple functions, you can build
    complex types from primitive types. In this example, we will define a custom type
    named `UnitConverter`—a class that serves as a blueprint for unit conversions:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 就像您可以从简单函数构建复杂函数一样，您可以从原始类型构建复杂类型。在此示例中，我们将定义一个名为`UnitConverter`的自定义类型——一个作为单位转换蓝图的类：
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Members of a type
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型的成员
- en: A type contains *data members* and *function members*. The data member of `UnitConverter`
    is the *field* called `ratio`. The function members of `UnitConverter` are the
    `Convert` method and the `UnitConverter`’s *constructor*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 类型包含*数据成员*和*函数成员*。`UnitConverter`的数据成员是名为`ratio`的*字段*。`UnitConverter`的函数成员是`Convert`方法和`UnitConverter`的*构造函数*。
- en: Symmetry of predefined types and custom types
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预定义类型和自定义类型的对称性
- en: A beautiful aspect of C# is that predefined types and custom types have few
    differences. The predefined `int` type serves as a blueprint for integers. It
    holds data—32 bits—and provides function members that use that data, such as `ToString`.
    Similarly, our custom `UnitConverter` type acts as a blueprint for unit conversions.
    It holds data—the ratio—and provides function members to use that data.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: C#的一个优点是预定义类型和自定义类型之间几乎没有区别。预定义的`int`类型用作整数的蓝图。它保存数据——32位——并提供使用该数据的函数成员，例如`ToString`。类似地，我们的自定义`UnitConverter`类型充当单位转换的蓝图。它保存比例数据，并提供用于使用该数据的函数成员。
- en: Constructors and instantiation
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数和实例化
- en: Data is created by *instantiating* a type. You can instantiate predefined types
    simply by using a literal such as `12` or `"Hello world"`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*实例化*类型可以创建数据。您可以通过使用文字（例如`12`或`"Hello world"`）简单地实例化预定义类型。'
- en: 'The `new` operator creates instances of a custom type. We started our program
    by creating two instances of the `UnitConverter` type. Immediately after the `new`
    operator instantiates an object, the object’s *constructor* is called to perform
    initialization. A constructor is defined like a method, except that the method
    name and return type are reduced to the name of the enclosing type:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`new` 操作符用于创建自定义类型的实例。我们通过创建两个 `UnitConverter` 类型的实例来启动我们的程序。`new` 操作符实例化对象后，立即调用对象的
    *构造函数* 进行初始化。构造函数类似于方法，不同之处在于方法名和返回类型简化为封闭类型的名称：'
- en: '[PRE17]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Instance versus static members
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实例成员与静态成员
- en: The data members and function members that operate on the *instance* of the
    type are called *instance members*. `UnitConverter`’s `Convert` method and `int`’s
    `ToString` method are examples of instance members. By default, members are instance
    members.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 操作类型 *实例* 的数据成员和函数成员称为 *实例成员*。`UnitConverter` 的 `Convert` 方法和 `int` 的 `ToString`
    方法就是实例成员的例子。默认情况下，成员是实例成员。
- en: Data members and function members that don’t operate on the instance of the
    type can be marked as `static`. To refer to a static member from outside its type,
    you specify its *type* name rather than an *instance*. An example is the `WriteLine`
    method of the `Console` class. Because this is static, we call `Console.WriteLine()`
    and not `new Console().WriteLine()`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 不操作类型实例的数据成员和函数成员可以标记为 `static`。要从其类型外部引用静态成员，需指定其 *类型* 名称，而不是实例。例如 `Console`
    类的 `WriteLine` 方法。因为这是静态的，我们调用 `Console.WriteLine()` 而不是 `new Console().WriteLine()`。
- en: 'In the following code, the instance field `Name` pertains to an instance of
    a particular `Panda`, whereas `Population` pertains to the set of all `Panda`
    instances. We create two instances of the `Panda`, print their names, and then
    print the total population:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，实例字段 `Name` 属于特定 `Panda` 的实例，而 `Population` 属于所有 `Panda` 实例的集合。我们创建了两个
    `Panda` 实例，打印它们的名称，然后打印总体人口：
- en: '[PRE18]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Attempting to evaluate `p1.Population` or `Panda.Name` will generate a compile-time
    error.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试评估 `p1.Population` 或 `Panda.Name` 将生成编译时错误。
- en: The public keyword
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 公共关键字
- en: 'The `public` keyword exposes members to other classes. In this example, if
    the `Name` field in `Panda` was not marked as public, it would be private and
    could not be accessed from outside the class. Marking a member public is how a
    type communicates: “Here is what I want other types to see—everything else is
    my own private implementation details.” In object-oriented terms, we say that
    the public members *encapsulate* the private members of the class.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`public` 关键字将成员暴露给其他类。在此示例中，如果 `Panda` 中的 `Name` 字段未标记为 public，则它将是私有的，无法从类外部访问。将成员标记为
    public 是类型通信的方式：“这里是我希望其他类型看到的内容——其他都是我自己的私有实现细节。”从面向对象的角度来看，我们说公共成员 *封装* 类的私有成员。'
- en: Creating a namespace
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建命名空间
- en: 'Particularly with larger programs, it makes sense to organize types into namespaces.
    Here’s how to define the `Panda` class inside a namespace called `Animals`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是对于较大的程序，将类型组织到命名空间中是有意义的。以下是如何在名为 `Animals` 的命名空间内定义 `Panda` 类：
- en: '[PRE19]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We cover namespaces in detail in [“Namespaces”](#namespaces).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [“命名空间”](#namespaces) 中详细介绍命名空间。
- en: Defining a Main method
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义 Main 方法
- en: 'All of our examples so far have used top-level statements, a feature that was
    introduced in C# 9\. Without top-level statements, a simple console or Windows
    application looks like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的所有示例都使用了顶级语句，这是在 C# 9 中引入的一个功能。没有顶级语句时，简单的控制台或 Windows 应用程序如下所示：
- en: '[PRE20]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the absence of top-level statements, C# looks for a static method called
    `Main`, which becomes the entry point. The `Main` method can be defined inside
    any class (and only one `Main` method can exist).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在不存在顶级语句的情况下，C# 查找名为 `Main` 的静态方法，该方法成为入口点。`Main` 方法可以定义在任何类内（只能存在一个 `Main`
    方法）。
- en: 'The `Main` method can optionally return an integer (rather than `void`) in
    order to return a value to the execution environment (where a nonzero value typically
    indicates an error). The `Main` method can also optionally accept an array of
    strings as a parameter (that will be populated with any arguments passed to the
    executable); for example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法可以选择性地返回整数（而不是 `void`），以便向执行环境返回值（非零值通常表示错误）。`Main` 方法还可以选择性地接受字符串数组作为参数（该数组将填充任何传递给可执行文件的参数）；例如：'
- en: '[PRE21]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-201
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: An array (such as `string[]`) represents a fixed number of elements of a particular
    type. Arrays are specified by placing square brackets after the element type.
    We describe them in [“Arrays”](#arrays).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 数组（如`string[]`）表示特定类型的固定数量元素。通过在元素类型后面放置方括号来指定数组。我们在[“数组”](#arrays)中描述了它们。
- en: (The `Main` method can also be declared `async` and return a `Task` or `Task<int>`
    in support of asynchronous programming—see [“Asynchronous Functions”](#asynchronous_functions).)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: （`Main`方法也可以声明为`async`并返回`Task`或`Task<int>`，以支持异步编程，请参见[“异步函数”](#asynchronous_functions)。）
- en: Top-level statements
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 顶层语句
- en: 'Top-level statements let you avoid the baggage of a static `Main` method and
    a containing class. A file with top-level statements comprises three parts, in
    this order:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层语句允许您避免静态`Main`方法和包含类的负担。一个包含顶层语句的文件由以下三部分组成，顺序如下：
- en: (Optionally) `using` directives
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （可选地）`using`指令
- en: A series of statements, optionally mixed with method declarations
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一系列的语句，可选地与方法声明混合在一起。
- en: (Optionally) Type and namespace declarations
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （可选地）类型和命名空间声明
- en: Everything in Part 2 ends up inside a compiler-generated “main” method, inside
    a compiler-generated class. This means that the methods in your top-level statements
    become *local methods* (we describe the subtleties in [“Local methods”](#local_methods)).
    Top-level statements can optionally return an integer value to the caller, and
    access a “magic” variable of type `string[]` called `args`, corresponding to command-line
    arguments passed by the caller.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分的所有内容最终都会位于由编译器生成的“main”方法内，位于一个由编译器生成的类内。这意味着顶层语句中的方法变成了*本地方法*（我们在[“本地方法”](#local_methods)中描述了细微差别）。顶层语句可以选择向调用者返回一个整数值，并访问一个名为`args`的`string[]`类型的“magic”变量，对应于调用者传递的命令行参数。
- en: As a program can have only one entry point, there can be at most one file with
    top-level statements in a C# project.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于程序只能有一个入口点，在C#项目中最多只能有一个包含顶层语句的文件。
- en: Types and Conversions
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型和转换
- en: 'C# can convert between instances of compatible types. A conversion always creates
    a new value from an existing one. Conversions can be either *implicit* or *explicit*:
    implicit conversions happen automatically, whereas explicit conversions require
    a *cast*. In the following example, we *implicitly* convert an `int` to a `long`
    type (which has twice the bit capacity of an `int`) and *explicitly* cast an `int`
    to a `short` type (which has half the bit capacity of an `int`):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: C#可以在兼容类型的实例之间进行转换。转换总是从现有值创建一个新值。转换可以是*隐式*或*显式*：隐式转换会自动发生，而显式转换需要一个*转换*。在以下示例中，我们*隐式*将`int`转换为`long`类型（其比`int`具有两倍的位容量），并*显式*将`int`转换为`short`类型（其比`int`具有一半的位容量）：
- en: '[PRE22]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In general, implicit conversions are allowed when the compiler can guarantee
    that they will always succeed without loss of information. Otherwise, you must
    perform an explicit cast to convert between compatible types.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一般情况下，当编译器可以保证隐式转换总是成功且不丢失信息时，允许隐式转换。否则，你必须执行显式转换来在兼容类型之间转换。
- en: Value Types Versus Reference Types
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值类型与引用类型
- en: C# types can be divided into *value types* and *reference types*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: C#类型可以分为*值类型*和*引用类型*。
- en: '*Value types* comprise most built-in types (specifically, all numeric types,
    the `char` type, and the `bool` type) as well as custom `struct` and `enum` types.
    *Reference types* comprise all class, array, delegate, and interface types.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*值类型*包括大多数内置类型（具体来说，所有数值类型、`char`类型和`bool`类型），以及自定义的`struct`和`enum`类型。*引用类型*包括所有的类、数组、委托和接口类型。'
- en: The fundamental difference between value types and reference types is how they
    are handled in memory.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型和引用类型的根本区别在于它们在内存中的处理方式。
- en: Value types
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 值类型
- en: The content of a *value type* variable or constant is simply a value. For example,
    the content of the built-in value type `int` is 32 bits of data.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*值类型*变量或常量的内容仅仅是一个值。例如，内置值类型`int`的内容是32位数据。'
- en: 'You can define a custom value type with the `struct` keyword (see [Figure 1](#a_value_type_instance_in_memory)):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`struct`关键字定义自定义值类型（参见[图 1](#a_value_type_instance_in_memory)）：
- en: '[PRE23]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![A value type instance in memory](Images/c12p_0101.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![内存中的值类型实例](Images/c12p_0101.png)'
- en: Figure 1\. A value type instance in memory
  id: totrans-224
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1\. 内存中的值类型实例
- en: 'The assignment of a value type instance always *copies* the instance. For example:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于值类型实例的赋值始终会*复制*该实例。例如：
- en: '[PRE24]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[Figure 2](#assignment_copies_a_value_type_instance) shows that `p1` and `p2`
    have independent storage.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2](#assignment_copies_a_value_type_instance) 显示 `p1` 和 `p2` 具有独立的存储。'
- en: '![Assignment copies a value type instance](Images/c12p_0102.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![赋值复制值类型实例](Images/c12p_0102.png)'
- en: Figure 2\. Assignment copies a value type instance
  id: totrans-229
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2\. 赋值复制值类型实例
- en: Reference types
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用类型
- en: 'A reference type is more complex than a value type, having two parts: an *object*
    and the *reference* to that object. The content of a reference type variable or
    constant is a reference to an object that contains the value. Here is the `Point`
    type from our previous example rewritten as a class (see [Figure 3](#a_reference_type_instance_in_memory)):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型比值类型更复杂，有两部分：*对象* 和指向该对象的*引用*。引用类型变量或常量的内容是指向包含值的对象的引用。以下是我们先前示例中 `Point`
    类的类型重写为类（参见 [图 3](#a_reference_type_instance_in_memory)）：
- en: '[PRE25]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![A reference type instance in memory](Images/c12p_0103.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![内存中的引用类型实例](Images/c12p_0103.png)'
- en: Figure 3\. A reference type instance in memory
  id: totrans-234
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3\. 内存中的引用类型实例
- en: 'Assigning a reference type variable copies the reference, not the object instance.
    This allows multiple variables to refer to the same object—something that’s not
    ordinarily possible with value types. If we repeat the previous example, but with
    `Point` now a class, an operation via `p1` affects `p2`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 将引用类型变量赋值给引用，会复制引用而不是对象实例。这允许多个变量引用同一对象——这在值类型中通常是不可能的。如果我们重复之前的示例，但现在 `Point`
    是一个类，通过 `p1` 进行的操作会影响 `p2`：
- en: '[PRE26]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[Figure 4](#assignment_copies_a_reference) shows that `p1` and `p2` are two
    references that point to the same object.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4](#assignment_copies_a_reference) 显示 `p1` 和 `p2` 是指向同一对象的两个引用。'
- en: '![Assignment copies a reference](Images/c12p_0104.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![赋值复制引用](Images/c12p_0104.png)'
- en: Figure 4\. Assignment copies a reference
  id: totrans-239
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4\. 赋值复制引用
- en: 'Null'
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空
- en: 'A reference can be assigned the literal `null`, indicating that the reference
    points to no object. Assuming `Point` is a class:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将引用分配给字面值 `null`，表示引用指向无对象。假设 `Point` 是一个类：
- en: '[PRE27]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Accessing a member of a null reference generates a runtime error:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 访问空引用的成员会生成运行时错误：
- en: '[PRE28]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-245
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: '**注意**'
- en: In [“Nullable Reference Types”](#nullable_reference_types), we describe a feature
    of C# that reduces accidental `NullReference​Excep⁠tion` errors.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [“可空引用类型”](#nullable_reference_types) 中，我们描述了 C# 的一个功能，可减少意外的 `NullReferenceException`
    错误。
- en: 'In contrast, a value type cannot ordinarily have a null value:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，值类型通常不能具有空值：
- en: '[PRE29]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To work around this, C# has a special construct for representing value-type
    nulls—see [“Nullable Value Types”](#nullable_value_types).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，C# 使用了一种特殊的结构来表示值类型的空值——请参阅 [“可空值类型”](#nullable_value_types)。
- en: Predefined Type Taxonomy
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预定义类型分类
- en: 'The predefined types in C# are as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中的预定义类型如下：
- en: Value types
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型
- en: 'Numeric:'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值：
- en: Signed integer (`sbyte`, `short`, `int`, `long`)
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有符号整数** (`sbyte`, `short`, `int`, `long`)'
- en: Unsigned integer (`byte`, `ushort`, `uint`, `ulong`)
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无符号整数** (`byte`, `ushort`, `uint`, `ulong`)'
- en: Real number (`float`, `double`, `decimal`)
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实数** (`float`, `double`, `decimal`)'
- en: Logical (`bool`)
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逻辑** (`bool`)'
- en: Character (`char`)
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符** (`char`)'
- en: Reference types
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型
- en: String (`string`)
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符串** (`string`)'
- en: Object (`object`)
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象** (`object`)'
- en: 'Predefined types in C# alias .NET types in the `System` namespace. There is
    only a syntactic difference between these two statements:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中的预定义类型是 `.NET` 中 `System` 命名空间的别名。这两个语句之间只有语法上的差异：
- en: '[PRE30]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The set of predefined *value* types excluding `decimal` are known as *primitive
    types* in the Common Language Runtime (CLR). Primitive types are so called because
    they are supported directly via instructions in compiled code, which usually translates
    to direct support on the underlying processor.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在公共语言运行时（CLR）中，排除 `decimal` 的预定义*值*类型被称为*基本类型*。之所以称为基本类型，是因为它们通过编译代码中的指令直接支持，在底层处理器上通常直接转换为支持。
- en: Numeric Types
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数值类型
- en: 'C# has the following predefined numeric types:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: C# 具有以下预定义的数值类型：
- en: '| C# type | System type | Suffix | Size | Range |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| C# 类型 | 系统类型 | 后缀 | 大小 | 范围 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **Integral—signed** |  |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| **整数—有符号** |  |'
- en: '| `sbyte` | `SByte` |  | 8 bits | –2⁷ to 2⁷–1 |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `sbyte` | `SByte` |  | 8 位 | –2⁷ 到 2⁷–1 |'
- en: '| `short` | `Int16` |  | 16 bits | –2^(15) to 2^(15)–1 |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `short` | `Int16` |  | 16 位 | –2^(15) 到 2^(15)–1 |'
- en: '| `int` | `Int32` |  | 32 bits | –2^(31) to 2^(31)–1 |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `int` | `Int32` |  | 32 位 | –2^(31) 到 2^(31)–1 |'
- en: '| `long` | `Int64` | `L` | 64 bits | –2^(63) to 2^(63)–1 |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `long` | `Int64` | `L` | 64 位 | –2^(63) 到 2^(63)–1 |'
- en: '| `nint` | `IntPtr` |  | 32/64 bits |  |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `nint` | `IntPtr` |  | 32/64 位 |  |'
- en: '| **Integral—unsigned** |  |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| **整数—无符号** |  |'
- en: '| `byte` | `Byte` |  | 8 bits | 0 to 2⁸–1 |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | `Byte` |  | 8 位 | 0 到 2⁸–1 |'
- en: '| `ushort` | `UInt16` |  | 16 bits | 0 to 2^(16)–1 |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `ushort` | `UInt16` |  | 16 位 | 0 到 2^(16)–1 |'
- en: '| `uint` | `UInt32` | `U` | 32 bits | 0 to 2^(32)–1 |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `uint` | `UInt32` | `U` | 32 位 | 0 到 2^(32)–1 |'
- en: '| `ulong` | `UInt64` | `UL` | 64 bits | 0 to 2^(64)–1 |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `ulong` | `UInt64` | `UL` | 64 位 | 0 到 2^(64)–1 |'
- en: '| `nuint` | `UIntPtr` |  | 32/64 bits |  |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| `nuint` | `UIntPtr` |  | 32/64 位 |  |'
- en: '| **Real** |  |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| **实数** |  |'
- en: '| `float` | `Single` | `F` | 32 bits | ± (~10^(–45) to 10^(38)) |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `float` | `Single` | `F` | 32 位 | ±（~10^(–45) 到 10^(38)） |'
- en: '| `double` | `Double` | `D` | 64 bits | ± (~10^(–324) to 10^(308)) |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `Double` | `D` | 64 位 | ±（~10^(–324) 到 10^(308)） |'
- en: '| `decimal` | `Decimal` | `M` | 128 bits | ± (~10^(–28) to 10^(28)) |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `decimal` | `Decimal` | `M` | 128 位 | ±（~10^(–28) 到 10^(28)） |'
- en: Of the *integral* types, `int` and `long` are first-class citizens and are favored
    by both C# and the runtime. The other integral types are typically used for interoperability
    or when space efficiency is paramount. The `nint` and `nuint` native-sized integer
    types are sized to match the address space of the process at runtime (32 or 64
    bits). These types can be useful when working with pointers—we describe their
    nuances in Chapter 4 of *C# 12 in a Nutshell* (O’Reilly).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在*整型*类型中，`int`和`long`是一流公民，并且在C#和运行时中受到青睐。其他整型类型通常用于互操作性或在空间效率至关重要时使用。`nint`和`nuint`本地大小的整型被调整为与运行时进程的地址空间匹配（32位或64位）。当处理指针时，这些类型可能很有用——我们在《C#
    12权威指南》（O’Reilly）的第4章中描述了它们的微妙之处。
- en: Of the *real* number types, `float` and `double` are called *floating-point
    types* and are typically used for scientific and graphical calculations. The `decimal`
    type is typically used for financial calculations where base-10-accurate arithmetic
    and high precision are required. (Technically, `decimal` is a floating-point type,
    too, although it’s not generally referred to as such.)
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在*实数*类型中，`float`和`double`被称为*浮点类型*，通常用于科学和图形计算。`decimal`类型通常用于需要基于十进制的精确算术和高精度的财务计算。
    （技术上，`decimal`也是一种浮点类型，尽管通常不这样称呼。）
- en: Numeric Literals
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数值文字
- en: '*Integral-typed literals* can use decimal, hexadecimal, or binary notation;
    hexadecimal is denoted with the `0x` prefix (e.g., `0x7f` is equivalent to `127`),
    and binary is denoted with the `0b` prefix. *Real literals* can use decimal or
    exponential notation such as `1E06`. Underscores may be inserted within (or before)
    a numeric literal to improve readability (e.g., `1_000_000`).'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '*整型文字*可以使用十进制、十六进制或二进制表示法；十六进制以`0x`前缀表示（例如，`0x7f`等同于`127`），二进制以`0b`前缀表示。*实数文字*可以使用十进制或指数表示法，如`1E06`。数字文字中可以插入下划线以提高可读性（例如，`1_000_000`）。'
- en: Numeric literal type inference
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数值文字类型推断
- en: 'By default, the compiler *infers* a numeric literal to be either `double` or
    an integral type:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，编译器*推断*数值文字为`double`或整型：
- en: If the literal contains a decimal point or the exponential symbol (`E`), it
    is a `double`.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文字包含小数点或指数符号（`E`），它是`double`。
- en: 'Otherwise, the literal’s type is the first type in this list that can fit the
    literal’s value: `int`, `uint`, `long`, and `ulong`.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，文字的类型是列表中可以容纳文字值的第一个类型：`int`、`uint`、`long`和`ulong`。
- en: 'For example:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE31]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Numeric suffixes
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数值后缀
- en: 'The *numeric suffixes* listed in the preceding table explicitly define the
    type of a literal:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在上表中列出的*数值后缀*明确定义了文字的类型：
- en: '[PRE32]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The suffixes `U` and `L` are rarely necessary because the `uint`, `long`, and
    `ulong` types can nearly always be either *inferred* or *implicitly converted*
    from `int`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`U`和`L`后缀很少必要，因为`uint`、`long`和`ulong`类型几乎总是可以从`int`推断或隐式转换：'
- en: '[PRE33]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `D` suffix is technically redundant in that all literals with a decimal
    point are inferred to be `double` (and you can always add a decimal point to a
    numeric literal). The `F` and `M` suffixes are the most useful and are mandatory
    when you’re specifying fractional `float` or `decimal` literals. Without suffixes,
    the following would not compile because 4.5 would be inferred to be of type `double`,
    which has no implicit conversion to `float` or `decimal`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，带有`D`后缀的文字是多余的，因为带有小数点的所有文字都被推断为`double`（你可以随时给数字文字加上小数点）。`F`和`M`后缀是最有用的，在指定分数`float`或`decimal`文字时是必需的。没有后缀的话，以下代码不会编译通过，因为`4.5`将被推断为`double`类型，而`double`类型无法隐式转换为`float`或`decimal`：
- en: '[PRE34]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Numeric Conversions
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数值转换
- en: Integral-to-integral conversions
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整型到整型的转换
- en: 'Integral conversions are *implicit* when the destination type can represent
    every possible value of the source type. Otherwise, an *explicit* conversion is
    required. For example:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当目标类型能够表示源类型的每一个可能值时，整数转换是*隐式*的。否则，需要*显式*转换。例如：
- en: '[PRE35]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Real-to-real conversions
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实数到实数的转换
- en: A `float` can be implicitly converted to a `double` because a `double` can represent
    every possible `float` value. The reverse conversion must be explicit.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`float` 可以隐式转换为 `double`，因为 `double` 能够表示每一个可能的 `float` 值。反向转换必须显式进行。'
- en: Conversions between `decimal` and other real types must be explicit.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `decimal` 和其他实数类型之间的转换必须是显式的。
- en: Real-to-integral conversions
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实数到整数的转换
- en: Conversions from integral types to real types are implicit, whereas the reverse
    must be explicit. Converting from a floating-point to an integral type truncates
    any fractional portion; to perform rounding conversions, use the static `System.Convert`
    class.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 从整数类型到实数类型的转换是隐式的，而反向转换必须是显式的。将浮点数转换为整数类型会截断任何小数部分；要执行四舍五入转换，请使用静态的 `System.Convert`
    类。
- en: 'A caveat is that implicitly converting a large integral type to a floating-point
    type preserves *magnitude* but might occasionally lose *precision*:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 一个注意事项是，将大整数类型隐式转换为浮点数类型会保留*大小*，但偶尔可能会失去*精度*：
- en: '[PRE36]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Arithmetic Operators
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术运算符
- en: The arithmetic operators (`+`, `-`, `*`, `/`, `%`) are defined for all numeric
    types except the 8- and 16-bit integral types. The `%` operator evaluates the
    remainder after division.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算符（`+`、`-`、`*`、`/`、`%`）适用于除了 8 位和 16 位整数类型之外的所有数值类型。`%` 运算符在除法后求余数。
- en: Increment and Decrement Operators
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自增和自减运算符
- en: 'The increment and decrement operators (`++`, `--`, respectively) increment
    and decrement numeric types by 1\. The operator can either precede or follow the
    variable, depending on whether you want the variable to be updated *before* or
    *after* the expression is evaluated. For example:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 自增和自减运算符（`++`、`--`）会使数值类型增加或减少 1。操作符可以在变量前或后出现，具体取决于您希望在表达式评估*之前*还是*之后*更新变量。例如：
- en: '[PRE37]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Specialized Integral Operations
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特定的整数操作
- en: Division
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 除法
- en: Division operations on integral types always eliminate the remainder (round
    toward zero). Dividing by a variable whose value is zero generates a runtime error
    (a `DivideByZeroException`). Dividing by the *literal* or *constant* 0 generates
    a compile-time error.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 对整数类型的除法操作总是会消除余数（朝零舍入）。除以一个值为零的变量会生成运行时错误（`DivideByZeroException`）。除以*字面值*或*常量*
    0 会生成编译时错误。
- en: Overflow
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 溢出
- en: 'At runtime, arithmetic operations on integral types can overflow. By default,
    this happens silently—no exception is thrown, and the result exhibits wraparound
    behavior, as though the computation were done on a larger integer type and the
    extra significant bits discarded. For example, decrementing the minimum possible
    `int` value results in the maximum possible `int` value:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，整数类型的算术操作可能会溢出。默认情况下，这种情况会静默发生 —— 不会抛出异常，并且结果会表现为环绕行为，就好像在较大的整数类型上进行计算并且丢弃了额外的有效位。例如，将最小可能的
    `int` 值递减会导致最大可能的 `int` 值：
- en: '[PRE38]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The checked and unchecked operators
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: checked 和 unchecked 操作符
- en: The `checked` operator instructs the runtime to generate an `OverflowException`
    rather than overflowing silently when an integral-typed expression or statement
    exceeds the arithmetic limits of that type. The `checked` operator affects expressions
    with the `++`, `−−`, (unary) `−`, `+`, `−`, `*`, `/`, and explicit conversion
    operators between integral types. Overflow checking incurs a small performance
    cost.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当整型表达式或语句超出其类型的算术限制时，`checked` 操作符会指示运行时生成 `OverflowException` 而不是静默溢出。`checked`
    操作符影响具有 `++`、`--`、（一元）`-`、`+`、`-`、`*`、`/` 和整型类型之间的显式转换运算符的表达式。溢出检查会带来一定的性能成本。
- en: 'You can use `checked` around either an expression or a statement block. For
    example:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在表达式或语句块周围使用 `checked`。例如：
- en: '[PRE39]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You can make arithmetic overflow checking the default for all expressions in
    a program by compiling with the `/checked+` command-line switch (in Visual Studio,
    go to Advanced Build Settings). If you then need to disable overflow checking
    just for specific expressions or statements, you can do so with the `unchecked`
    operator.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用 `/checked+` 命令行开关（在 Visual Studio 中，转到高级构建设置）使算术溢出检查成为程序中所有表达式的默认设置。如果您需要仅针对特定表达式或语句禁用溢出检查，则可以使用
    `unchecked` 操作符。
- en: Bitwise operators
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位运算符
- en: 'C# supports the following bitwise operators:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: C# 支持以下位运算符：
- en: '| Operator | Meaning | Sample expression | Result |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 含义 | 示例表达式 | 结果 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `~` | Complement | `~0xfU` | `0xfffffff0U` |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| `~` | 补码 | `~0xfU` | `0xfffffff0U` |'
- en: '| `&` | And | `0xf0 & 0x33` | `0x30` |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| `&` | 与 | `0xf0 & 0x33` | `0x30` |'
- en: '| `&#124;` | Or | `0xf0 &#124; 0x33` | `0xf3` |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| `|` | 或 | `0xf0 | 0x33` | `0xf3` |'
- en: '| `^` | Exclusive Or | `0xff00 ^ 0x0ff0` | `0xf0f0` |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 异或 | `0xff00 ^ 0x0ff0` | `0xf0f0` |'
- en: '| `<<` | Shift left | `0x20 << 2` | `0x80` |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| `<<` | 左移 | `0x20 << 2` | `0x80` |'
- en: '| `>>` | Shift right | `0x20 >> 1` | `0x10` |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| `>>` | 右移 | `0x20 >> 1` | `0x10` |'
- en: From C# 11, there is also an unsigned shift-right operator (`>>>`). Whereas
    the shift-right operator `(>>`) replicates the high-order bit when operating on
    signed integers, the unsigned shift-right operator (`>>>`) does not.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 11 开始，还有一个无符号右移操作符 (`>>>`)。而右移操作符 (`>>`) 在操作有符号整数时会复制高位位。
- en: 8- and 16-Bit Integral Types
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8 和 16 位整数类型
- en: 'The 8- and 16-bit integral types are `byte`, `sbyte`, `short`, and `ushort`.
    These types lack their own arithmetic operators, so C# implicitly converts them
    to larger types as required. This can cause a compilation error when trying to
    assign the result back to a small integral type:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 8 和 16 位整数类型包括 `byte`、`sbyte`、`short` 和 `ushort`。这些类型缺乏自己的算术运算符，因此 C# 根据需要将它们隐式转换为较大的类型。当试图将结果重新赋给小整数类型时可能会导致编译错误：
- en: '[PRE40]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In this case, `x` and `y` are implicitly converted to `int` so that the addition
    can be performed. This means that the result is also an `int`, which cannot be
    implicitly cast back to a `short` (because it could cause loss of data). To make
    this compile, you must add an explicit cast:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`x` 和 `y` 隐式转换为 `int` 以便执行加法运算。这意味着结果也是一个 `int`，无法隐式转换回 `short`（因为可能会造成数据丢失）。为了使其编译通过，必须添加显式转换：
- en: '[PRE41]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Special Float and Double Values
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊浮点和双精度值
- en: 'Unlike integral types, floating-point types have values that certain operations
    treat specially. These special values are NaN (Not a Number), +∞, −∞, and −0\.
    The `float` and `double` classes have constants for NaN, +∞, and −∞ (as well as
    other values including `MaxValue`, `MinValue`, and `Epsilon`). For example:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 与整数类型不同，浮点类型有些特定操作会对特殊值进行处理。这些特殊值包括 NaN（非数字）、+∞、−∞ 和 −0\. `float` 和 `double`
    类有用于 NaN、+∞ 和 −∞ 的常量（以及包括 `MaxValue`、`MinValue` 和 `Epsilon` 在内的其他值）。例如：
- en: '[PRE42]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Dividing a nonzero number by zero results in an infinite value:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 将非零数除以零会得到一个无限值：
- en: '[PRE43]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Dividing zero by zero, or subtracting infinity from infinity, results in a
    NaN:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 将零除以零，或从无穷大中减去无穷大，结果是 NaN：
- en: '[PRE44]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When you use `==`, a NaN value is never equal to another value, even another
    NaN value. To test whether a value is NaN, you must use the `float.IsNaN` or `double.IsNaN`
    method:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `==` 时，NaN 值永远不等于另一个值，甚至是另一个 NaN 值。要测试一个值是否为 NaN，必须使用 `float.IsNaN` 或 `double.IsNaN`
    方法：
- en: '[PRE45]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When you use `object.Equals`, however, two NaN values are equal:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当使用 `object.Equals` 时，两个 NaN 值是相等的：
- en: '[PRE46]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: double Versus decimal
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: double 和 decimal 的比较
- en: '`double` is useful for scientific computations (such as computing spatial coordinates).
    `decimal` is useful for financial computations and values that are manufactured
    rather than the result of real-world measurements. Here’s a summary of the differences:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`double` 适用于科学计算（如计算空间坐标）。`decimal` 适用于金融计算和制造值，而不是实际测量结果。以下是它们之间的主要区别总结：'
- en: '| Feature | double | decimal |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| 特性 | double | decimal |'
- en: '| --- | --- | --- |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Internal representation | Base 2 | Base 10 |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| 内部表示 | 二进制 | 十进制 |'
- en: '| Precision | 15–16 significant figures | 28–29 significant figures |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| 精度 | 15–16 有效数字 | 28–29 有效数字 |'
- en: '| Range | ±(~10^(−324) to ~10^(308)) | ±(~10^(−28) to ~10^(28)) |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| 范围 | ±(~10^(−324) 到 ~10^(308)) | ±(~10^(−28) 到 ~10^(28)) |'
- en: '| Special values | +0, −0, +∞, −∞, and NaN | None |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| 特殊值 | +0、−0、+∞、−∞ 和 NaN | 无 |'
- en: '| Speed | Native to processor | Non-native to processor (about 10 times slower
    than `double`) |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| 速度 | 本地处理器 | 非本地处理器（比 `double` 慢约 10 倍） |'
- en: Real Number Rounding Errors
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实数舍入误差
- en: '`float` and `double` internally represent numbers in base 2\. For this reason,
    most literals with a fractional component (which are in base 10) will not be represented
    precisely, making them bad for financial calculations. In contrast, `decimal`
    works in base 10 and so can precisely represent fractional numbers such as 0.1
    (whose base-10 representation is nonrecurring).'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`float` 和 `double` 在内部以二进制表示数字。因此，大多数带有小数部分的文字常量（以十进制为基础）不能精确表示，这使它们在财务计算中不合适。相比之下，`decimal`
    使用十进制工作，因此可以精确表示如 0.1 的分数，其十进制表示不会循环。'
- en: Boolean Type and Operators
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔类型和运算符
- en: C#’s `bool` type (aliasing the `System.Boolean` type) is a logical value that
    can be assigned the literal `true` or `false`.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: C#的`bool`类型（别名为`System.Boolean`类型）是一个逻辑值，可以赋予`true`或`false`字面值。
- en: Although a Boolean value requires only one bit of storage, the runtime will
    use one byte of memory because this is the minimum chunk that the runtime and
    processor can efficiently work with. To avoid space inefficiency in the case of
    arrays, .NET provides a `BitArray` class in the `System​.Col⁠lections` namespace
    that is designed to use just one bit per Boolean value.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管布尔值仅需要一位存储空间，但运行时会使用一个字节的内存，因为这是运行时和处理器能有效处理的最小块。为了避免在数组情况下的空间浪费，.NET在`System.Collections`命名空间中提供了`BitArray`类，设计为每个布尔值仅使用一位。
- en: Equality and Comparison Operators
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相等性和比较运算符
- en: '`==` and `!=` test for equality and inequality, respectively, of any type and
    always return a `bool` value. Value types typically have a very simple notion
    of equality:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`==`和`!=`分别测试任何类型的相等和不等，总是返回一个`bool`值。值类型通常具有非常简单的相等概念：'
- en: '[PRE47]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: For reference types, equality, by default, is based on *reference*, as opposed
    to the actual *value* of the underlying object. Therefore, two instances of an
    object with identical data are not considered equal unless the `==` operator for
    that type is specially overloaded to that effect (see [“The object Type”](#the_object_type)
    and [“Operator Overloading”](#operator_overloading)).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 对于引用类型，默认情况下，相等性基于*引用*，而不是底层对象的*值*。因此，除非特别重载了该类型的`==`运算符以反映这一点（参见[“对象类型”](#the_object_type)和[“运算符重载”](#operator_overloading)），否则具有相同数据的两个对象实例不被视为相等。
- en: The equality and comparison operators, `==`, `!=`, `<`, `>`, `>=`, and `<=`,
    work for all numeric types but should be used with caution with real numbers (see
    [“Real Number Rounding Errors”](#real_number_rounding_errors) in the previous
    section). The comparison operators also work on `enum` type members by comparing
    their underlying integral values.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 相等性和比较运算符`==`、`!=`、`<`、`>`、`>=`和`<=`适用于所有数值类型，但在实数中应谨慎使用（参见上一节中的[“实数舍入误差”](#real_number_rounding_errors)）。比较运算符也适用于枚举类型成员，通过比较它们的基础整数值。
- en: Conditional Operators
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件操作符
- en: 'The `&&` and `||` operators test for *and* and *or* conditions, respectively.
    They are frequently used in conjunction with the `!` operator, which expresses
    *not*. In the following example, the `UseUmbrella` method returns `true` if it’s
    rainy or sunny (to protect us from the rain or the sun), as long as it’s not also
    windy (because umbrellas are useless in the wind):'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`&&`和`||`运算符测试*and*和*or*条件，分别。它们经常与`!`运算符一起使用，表示*not*。在以下示例中，`UseUmbrella`方法如果下雨或晴天（保护我们免受雨水或阳光），只要不刮风就返回`true`：'
- en: '[PRE48]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `&&` and `||` operators *short-circuit* evaluation when possible. In the
    preceding example, if it is windy, the expression `(rainy || sunny)` is not even
    evaluated. Short-circuiting is essential in allowing expressions such as the following
    to run without throwing a `NullReferenceException`:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`&&`和`||`运算符在可能时会*短路*评估。在前面的示例中，如果刮风，表达式`(rainy || sunny)`甚至不会被评估。短路对于允许以下表达式运行而不抛出`NullReferenceException`至关重要：'
- en: '[PRE49]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `&` and `|` operators also test for *and* and *or* conditions:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`&`和`|`运算符也测试*and*和*or*条件：'
- en: '[PRE50]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The difference is that they *do not short-circuit*. For this reason, they are
    rarely used in place of conditional operators.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的不同之处在于它们*不会短路*。因此，它们很少用于条件操作符的替代位置。
- en: 'The ternary conditional operator (simply called the *conditional operator*)
    has the form `q ? a : b`, where if condition `q` is true, `a` is evaluated, otherwise
    `b` is evaluated. For example:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '三元条件运算符（简称*条件运算符*）的形式为`q ? a : b`，如果条件`q`为真，则评估`a`，否则评估`b`。例如：'
- en: '[PRE51]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The conditional operator is particularly useful in LINQ queries.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 条件运算符在LINQ查询中特别有用。
- en: Strings and Characters
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串和字符
- en: 'C#’s `char` type (aliasing the `System.Char` type) represents a Unicode character
    and occupies two bytes (UTF-16). A `char` literal is specified inside single quotes:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: C#的`char`类型（别名为`System.Char`类型）表示一个Unicode字符，占据两个字节（UTF-16）。`char`字面值用单引号指定：
- en: '[PRE52]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '*Escape sequences* express characters that cannot be expressed or interpreted
    literally. An escape sequence is a backslash followed by a character with a special
    meaning. For example:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '*转义序列*表示不能以字面方式表达或解释的字符。转义序列是一个反斜杠后跟具有特殊含义的字符。例如：'
- en: '[PRE53]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The escape sequence characters are as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的转义序列如下：
- en: '| Char | Meaning | Value |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| Char | 含义 | 值 |'
- en: '| --- | --- | --- |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `\''` | Single quote | `0x0027` |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| `\''` | 单引号 | `0x0027` |'
- en: '| `\"` | Double quote | `0x0022` |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| `\"` | 双引号 | `0x0022` |'
- en: '| `\\` | Backslash | `0x005C` |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| `\\` | 反斜杠 | `0x005C` |'
- en: '| `\0` | Null | `0x0000` |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| `\0` | 空字符 | `0x0000` |'
- en: '| `\a` | Alert | `0x0007` |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| `\a` | 警报 | `0x0007` |'
- en: '| `\b` | Backspace | `0x0008` |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| `\b` | 退格 | `0x0008` |'
- en: '| `\f` | Form feed | `0x000C` |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| `\f` | 换页符 | `0x000C` |'
- en: '| `\n` | New line | `0x000A` |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| `\n` | 换行 | `0x000A` |'
- en: '| `\r` | Carriage return | `0x000D` |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| `\r` | 回车 | `0x000D` |'
- en: '| `\t` | Horizontal tab | `0x0009` |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| `\t` | 水平制表符 | `0x0009` |'
- en: '| `\v` | Vertical tab | `0x000B` |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| `\v` | 垂直制表符 | `0x000B` |'
- en: 'The `\u` (or `\x`) escape sequence lets you specify any Unicode character via
    its four-digit hexadecimal code:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`\u`（或`\x`）转义序列允许您通过其四位十六进制代码指定任何Unicode字符：'
- en: '[PRE54]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: An implicit conversion from a `char` to a numeric type works for the numeric
    types that can accommodate an unsigned `short`. For other numeric types, an explicit
    conversion is required.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 从`char`到能容纳无符号`short`的数值类型的隐式转换适用于其他数值类型，需要显式转换。
- en: String Type
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串类型
- en: 'C#’s `string` type (aliasing the `System.String` type) represents an immutable
    (unmodifiable) sequence of Unicode characters. A string literal is specified within
    double quotes:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: C#的`string`类型（别名`System.String`类型）表示一种不可变（不可修改）的Unicode字符序列。字符串字面量在双引号内指定：
- en: '[PRE55]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note
  id: totrans-411
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`string` is a reference type rather than a value type. Its equality operators,
    however, follow value type semantics:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`string`是引用类型，而不是值类型。然而，它的相等运算符遵循值类型语义：'
- en: '[PRE56]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The escape sequences that are valid for `char` literals also work within strings:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串内也适用于`char`字面量的转义序列：
- en: '[PRE57]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The cost of this is that whenever you need a literal backslash, you must write
    it twice:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 代价是，每当您需要一个字面的反斜杠时，您必须写两次：
- en: '[PRE58]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To avoid this problem, C# allows *verbatim* string literals. A verbatim string
    literal is prefixed with `@` and does not support escape sequences. The following
    verbatim string is identical to the preceding one:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，C#允许*逐字*字符串字面量。逐字字符串字面量以`@`为前缀，不支持转义序列。以下逐字字符串与前述相同：
- en: '[PRE59]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: A verbatim string literal can also span multiple lines. You can include the
    double-quote character in a verbatim literal by writing it twice.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 逐字字符串字面量也可以跨越多行。您可以通过连续写两次来包含逐字文字中的双引号字符。
- en: Raw string literals (C# 11)
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始字符串字面量（C# 11）
- en: 'Wrapping a string in three or more quote characters (`"""`) creates a *raw
    string literal*. Raw string literals can contain almost any character sequence,
    without escaping or doubling up:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 用三个或更多引号字符（`"""`）包裹字符串会创建一个*原始字符串字面量*。原始字符串字面量几乎可以包含任何字符序列，无需转义或重复：
- en: '[PRE60]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Raw string literals make it easy to represent JSON, XML, and HTML literals,
    as well as regular expressions and source code. Should you need to include three
    (or more) quote characters in the string itself, you can do so by wrapping the
    string in four (or more) quote characters:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 原始字符串字面量使得能够轻松表示JSON、XML和HTML字面量，以及正则表达式和源代码。如果需要在字符串本身中包含三个（或更多）引号字符，则可以用四个（或更多）引号字符包裹该字符串：
- en: '[PRE61]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Multiline raw string literals are subject to special rules. We can represent
    the string `"Line 1\r\nLine 2"` as follows:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 多行原始字符串字面量受到特殊规则的约束。我们可以将字符串`"Line 1\r\nLine 2"`表示如下：
- en: '[PRE62]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Notice that the opening and closing quotes must be on separate lines to the
    string content. Additionally:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，开头和结尾的引号必须位于字符串内容的不同行。此外：
- en: Whitespace following the *opening* `"""` (on the same line) is ignored.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*开头*的`"""`后面的空白会被忽略。
- en: Whitespace preceding the *closing* `"""` (on the same line) is treated as *common
    indentation* and is removed from every line in the string. This lets you include
    indentation for source-code readability (as we did in our example) without that
    indentation becoming part of the string.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*结尾*的`"""`前面的空白被视为*常见缩进*并从字符串的每一行中删除。这使得您可以包含源代码可读性的缩进（就像我们在示例中所做的那样），而不使该缩进成为字符串的一部分。
- en: Raw string literals can be interpolated, subject to special rules described
    in [“String interpolation”](#string_interpolation).
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 原始字符串字面量可以进行插值，受到[“字符串插值”](#string_interpolation)中描述的特殊规则的约束。
- en: String concatenation
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串连接
- en: 'The `+` operator concatenates two strings:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '`+`运算符连接两个字符串：'
- en: '[PRE63]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'One of the operands can be a nonstring value, in which case `ToString` is called
    on that value. For example:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 操作数中的一个可以是非字符串值，在这种情况下，将对该值调用`ToString`。例如：
- en: '[PRE64]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Using the `+` operator repeatedly to build up a string can be inefficient; a
    better solution is to use the `System.Text.StringBuilder` type—this represents
    a mutable (editable) string and has methods to efficiently `Append`, `Insert`,
    `Remove`, and `Replace` substrings.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 反复使用`+`运算符构建字符串可能效率低下；更好的解决方案是使用`System.Text.StringBuilder`类型——它表示可变（可编辑）字符串，并具有有效地`Append`、`Insert`、`Remove`和`Replace`子字符串的方法。
- en: String interpolation
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串插值
- en: 'A string preceded with the `$` character is called an *interpolated string*.
    Interpolated strings can include expressions within braces:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 以`$`字符开头的字符串称为*插值字符串*。插值字符串可以在大括号内包含表达式：
- en: '[PRE65]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Any valid C# expression of any type can appear within the braces, and C# will
    convert the expression to a string by calling its `ToString` method or equivalent.
    You can change the formatting by appending the expression with a colon and a *format
    string* (we describe format strings in Chapter 6 of *C# 12 in a Nutshell*):'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 任何有效的C#表达式可以出现在大括号内，并且C#将通过调用其`ToString`方法或等效方法将表达式转换为字符串。您可以通过在表达式后附加冒号和*格式字符串*（我们在*C#
    12 in a Nutshell*的第6章中描述了格式字符串）来更改格式：
- en: '[PRE66]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'From C# 10, interpolated strings can be constants, as long as the interpolated
    values are constants:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 10开始，插值字符串可以是常量，只要插值的值是常量即可：
- en: '[PRE67]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'From C# 11, interpolated strings are permitted to span multiple lines (whether
    standard or verbatim):'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 11开始，插值字符串可以跨多行（无论是标准还是逐字字符串）：
- en: '[PRE68]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Raw string literals (from C# 11) can also be interpolated:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 原始字符串字面量（从C# 11开始）也可以进行插值：
- en: '[PRE69]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'To include a brace literal in an interpolated string:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 要在插值字符串中包含大括号文字：
- en: With standard and verbatim string literals, repeat the desired brace character.
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准和逐字字符串字面量，重复所需的大括号字符。
- en: With raw string literals, change the interpolation sequence by repeating the
    `$` prefix.
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原始字符串字面量，通过重复`$`前缀来改变插值序列。
- en: 'Using two (or more) `$` characters in a raw string literal prefix changes the
    interpolation sequence from one brace to two (or more) braces. Consider the following
    string:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始字符串字面量的前缀中使用两个（或更多）`$`字符可以改变插值序列，从一个大括号变为两个（或更多）。考虑以下字符串：
- en: '[PRE70]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This evaluates to:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 这将评估为：
- en: '[PRE71]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: String comparisons
  id: totrans-456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串比较
- en: '`string` does not support `<` and `>` operators for comparisons. You must instead
    use `string`’s `CompareTo` method, which returns a positive number, a negative
    number, or zero, depending on whether the first value comes after, before, or
    alongside the second value:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`string`不支持`<`和`>`操作符进行比较。您必须使用`string`的`CompareTo`方法，该方法返回正数、负数或零，具体取决于第一个值出现在第二个值之后、之前还是与第二个值并列：'
- en: '[PRE72]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Searching within strings
  id: totrans-459
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在字符串内搜索
- en: '`string`’s indexer returns a character at a specified position:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '`string`的索引器返回指定位置的字符：'
- en: '[PRE73]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `IndexOf` and `LastIndexOf` methods search for a character within the string.
    The `Contains`, `StartsWith`, and `EndsWith` methods search for a substring within
    the string.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '`IndexOf`和`LastIndexOf`方法用于在字符串中搜索字符。`Contains`、`StartsWith`和`EndsWith`方法用于在字符串中搜索子字符串。'
- en: Manipulating strings
  id: totrans-463
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作字符串
- en: 'Because `string` is immutable, all the methods that “manipulate” a string return
    a new one, leaving the original untouched:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`string`是不可变的，所有“操作”字符串的方法都返回一个新字符串，原始字符串保持不变：
- en: '`Substring` extracts a portion of a string.'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Substring`提取字符串的一部分。'
- en: '`Insert` and `Remove` insert and remove characters at a specified position.'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Insert`和`Remove`在指定位置插入和删除字符。'
- en: '`PadLeft` and `PadRight` add whitespace.'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PadLeft`和`PadRight`添加空格字符。'
- en: '`TrimStart`, `TrimEnd`, and `Trim` remove whitespace.'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TrimStart`、`TrimEnd`和`Trim`移除空白字符。'
- en: The `string` class also defines `ToUpper` and `ToLower` methods for changing
    case, a `Split` method to split a string into substrings (based on supplied delimiters),
    and a static `Join` method to join substrings back into a string.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '`string`类还定义了`ToUpper`和`ToLower`方法以更改大小写，`Split`方法以根据提供的分隔符将字符串拆分为子字符串，并且静态`Join`方法以将子字符串连接回字符串。'
- en: UTF-8 Strings
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UTF-8字符串
- en: 'From C# 11, you can use the `u8` suffix to create string literals encoded in
    UTF-8 rather than UTF-16\. This feature is intended for advanced scenarios such
    as the low-level handling of JSON text in performance hotspots:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 11开始，您可以使用`u8`后缀创建使用UTF-8而不是UTF-16编码的字符串字面量。此功能旨在用于高级场景，例如性能热点中JSON文本的低级处理：
- en: '[PRE74]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The underlying type is `ReadOnlySpan<byte>`, which we cover in Chapter 23 of
    *C# 12 in a Nutshell*. You can convert this to an array by calling the `ToArray()`
    method.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 底层类型是`ReadOnlySpan<byte>`，我们在*C# 12 in a Nutshell*的第23章中介绍了它。您可以通过调用`ToArray()`方法将其转换为数组。
- en: Arrays
  id: totrans-474
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: An *array* represents a fixed number of elements of a particular type. The elements
    in an array are always stored in a contiguous block of memory, providing highly
    efficient access.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组*表示特定类型的固定数量元素。数组中的元素始终存储在连续的内存块中，提供高效的访问。'
- en: 'An array is denoted with square brackets after the element type. The following
    declares an array of five characters:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 数组在元素类型后用方括号表示。以下声明了一个包含五个字符的数组：
- en: '[PRE75]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Square brackets also *index* the array, accessing a particular element by position:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号还*索引*数组，访问特定位置的元素：
- en: '[PRE76]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This prints “e” because array indexes start at 0\. You can use a `for` loop
    statement to iterate through each element in the array. The `for` loop in this
    example cycles the integer `i` from `0` to `4`:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印“e”，因为数组索引从0开始。您可以使用`for`循环语句遍历数组中的每个元素。在这个例子中，`for`循环循环整数`i`从`0`到`4`：
- en: '[PRE77]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Arrays also implement `IEnumerable<T>` (see [“Enumeration and Iterators”](#enumeration_and_iterators)),
    so you can also enumerate members with the `foreach` statement:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 数组还实现了`IEnumerable<T>`（见[“枚举和迭代器”](#enumeration_and_iterators)），因此您也可以使用`foreach`语句枚举成员：
- en: '[PRE78]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'All array indexing is bounds-checked by the runtime. An `IndexOutOfRangeException`
    is thrown if you use an invalid index:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时对所有数组索引进行边界检查。如果使用无效索引，将抛出`IndexOutOfRangeException`：
- en: '[PRE79]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The `Length` property of an array returns the number of elements in the array.
    After an array has been created, its length cannot be changed. The `System.Collection`
    namespace and subnamespaces provide higher-level data structures, such as dynamically
    sized arrays and dictionaries.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的`Length`属性返回数组中的元素数。创建数组后，其长度不可更改。`System.Collection`命名空间和子命名空间提供了更高级的数据结构，如动态大小的数组和字典。
- en: 'An *array initialization expression* lets you declare and populate an array
    in a single step:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组初始化表达式*允许您在一步中声明并填充数组：'
- en: '[PRE80]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Or simply:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 或者简单地说：
- en: '[PRE81]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Note
  id: totrans-491
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'From C# 12, you can use square brackets instead of curly braces:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 12开始，您可以使用方括号代替大括号：
- en: '[PRE82]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This is called a *collection expression* and has the advantage of also working
    when calling methods:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为*集合表达式*，其优点是在调用方法时同样适用：
- en: '[PRE83]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Collection expressions also work with other collection types such as lists and
    sets—see [“Collection Initializers and Collection Expressions”](#collection_initializers_and_collection).
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 集合表达式也适用于其他集合类型，如列表和集合——见[“集合初始化器和集合表达式”](#collection_initializers_and_collection)。
- en: 'All arrays inherit from the `System.Array` class, which defines common methods
    and properties for all arrays. This includes instance properties such as `Length`
    and `Rank`, and static methods to do the following:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 所有数组都继承自`System.Array`类，该类为所有数组定义了常见的方法和属性。这包括实例属性如`Length`和`Rank`，以及用于执行以下操作的静态方法：
- en: Dynamically create an array (`CreateInstance`)
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态创建一个数组（`CreateInstance`）
- en: Get and set elements regardless of the array type (`GetValue`/`SetValue`)
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取和设置元素，无论数组类型如何（`GetValue`/`SetValue`）
- en: Search a sorted array (`BinarySearch`) or an unsorted array (`IndexOf`, `LastIndexOf`,
    `Find`, `FindIndex`, `FindLastIndex`)
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索已排序的数组（`BinarySearch`）或未排序的数组（`IndexOf`，`LastIndexOf`，`Find`，`FindIndex`，`FindLastIndex`）
- en: Sort an array (`Sort`)
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数组进行排序（`Sort`）
- en: Copy an array (`Copy`)
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制数组（`Copy`）
- en: Default Element Initialization
  id: totrans-503
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认元素初始化
- en: 'Creating an array always preinitializes the elements with default values. The
    default value for a type is the result of a bitwise zeroing of memory. For example,
    consider creating an array of integers. Because `int` is a value type, this allocates
    1,000 integers in one contiguous block of memory. The default value for each element
    will be 0:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数组总是用默认值预初始化元素。类型的默认值是内存位清零的结果。例如，考虑创建一个整数数组。因为`int`是值类型，这将在一个连续的内存块中分配1,000个整数。每个元素的默认值将为0：
- en: '[PRE84]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: With reference type elements, the default value is `null`.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 对于引用类型的元素，其默认值为`null`。
- en: 'An array *itself* is always a reference type object, regardless of element
    type. For instance, the following is legal:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 数组*本身*始终是引用类型对象，无论元素类型如何。例如，以下语句是合法的：
- en: '[PRE85]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Indices and Ranges
  id: totrans-509
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引和范围
- en: '*Indices and ranges* (from C# 8) simplify working with elements or portions
    of an array.'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '*索引和范围*（从C# 8开始）简化了使用数组元素或部分的操作。'
- en: Note
  id: totrans-511
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Indices and ranges also work with the CLR types `Span<T>` and `ReadOnlySpan<T>`,
    which provide efficient low-level access to managed or unmanaged memory.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 索引和范围也适用于CLR类型`Span<T>`和`ReadOnlySpan<T>`，它们提供对托管或非托管内存的高效低级访问。
- en: You can also make your own types work with indices and ranges by defining an
    indexer of type `Index` or `Range` (see [“Indexers”](#indexers)).
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过定义类型为`Index`或`Range`的索引器来使自定义类型与索引和范围一起使用（参见[“索引器”](#indexers)）。
- en: Indices
  id: totrans-514
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引
- en: 'Indices let you refer to elements relative to the *end* of an array, with the
    `^` operator. `^1` refers to the last element, `^2` refers to the second-to-last
    element, and so on:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 索引允许您相对于数组的*末尾*引用元素，使用`^`运算符。`^1`指的是最后一个元素，`^2`指的是倒数第二个元素，依此类推：
- en: '[PRE86]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: (`^0` equals the length of the array, so `vowels[^0]` generates an error.)
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: （`^0`等于数组的长度，因此`vowels[^0]`会生成错误。）
- en: 'C# implements indices with the help of the `Index` type, so you can also do
    the following:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: C#借助`Index`类型实现索引，因此您也可以执行以下操作：
- en: '[PRE87]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Ranges
  id: totrans-520
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 范围
- en: 'Ranges let you “slice” an array with the `..` operator:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 范围允许您使用`..`运算符“切片”数组：
- en: '[PRE88]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The second number in the range is *exclusive*, so `..2` returns the elements
    *before* `vowels[2]`.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 范围中的第二个数字是*排除的*，因此`..2`返回`vowels[2]`*之前*的元素。
- en: 'You can also use the `^` symbol in ranges. The following returns the last two
    characters:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在范围中使用`^`符号。以下返回最后两个字符：
- en: '[PRE89]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: (`^0` is valid here because the second number in the range is *exclusive*.)
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: （这里`^0`有效，因为范围中的第二个数字是*排除的*。）
- en: 'C# implements ranges with the help of the `Range` type, so you can also do
    the following:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: C#借助`Range`类型实现范围，因此您也可以执行以下操作：
- en: '[PRE90]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Multidimensional Arrays
  id: totrans-529
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多维数组
- en: 'Multidimensional arrays come in two varieties: *rectangular* and *jagged*.
    Rectangular arrays represent an *n*-dimensional block of memory, and jagged arrays
    are arrays of arrays.'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 多维数组有两种类型：*矩形*和*锯齿*。矩形数组表示一个*n*维内存块，而锯齿数组则是数组的数组。
- en: Rectangular arrays
  id: totrans-531
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 矩形数组
- en: 'To declare rectangular arrays, use commas to separate each dimension. The following
    declares a rectangular two-dimensional array, where the dimensions are 3 × 3:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明矩形数组，请使用逗号分隔每个维度。以下声明一个矩形二维数组，其维度为3 × 3：
- en: '[PRE91]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The `GetLength` method of an array returns the length for a given dimension
    (starting at 0):'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的`GetLength`方法返回给定维度的长度（从0开始）：
- en: '[PRE92]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'A rectangular array can be initialized as follows (to create an array identical
    to the previous example):'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下方式初始化矩形数组（创建与前面示例相同的数组）：
- en: '[PRE93]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: (The code shown in boldface can be omitted in declaration statements such as
    this.)
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: （在此类声明语句中可以省略粗体显示的代码。）
- en: Jagged arrays
  id: totrans-539
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 锯齿数组
- en: 'To declare jagged arrays, use successive square-bracket pairs for each dimension.
    Here is an example of declaring a jagged two-dimensional array, for which the
    outermost dimension is 3:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明锯齿数组，请为每个维度使用连续的方括号对。以下是声明锯齿二维数组的示例，其中最外层维度为3：
- en: '[PRE94]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The inner dimensions aren’t specified in the declaration because, unlike a
    rectangular array, each inner array can be an arbitrary length. Each inner array
    is implicitly initialized to null rather than an empty array. Each inner array
    must be created manually:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明中未指定内部维度，因为与矩形数组不同，每个内部数组的长度都可以是任意的。每个内部数组隐式初始化为null而不是空数组。每个内部数组必须手动创建：
- en: '[PRE95]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'A jagged array can be initialized as follows (to create an array identical
    to the previous example, but with an additional element at the end):'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下方式初始化锯齿数组（创建与前面示例相同的数组，但在末尾增加一个元素）：
- en: '[PRE96]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: (The code shown in boldface can be omitted in declaration statements such as
    this.)
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: （在此类声明语句中可以省略粗体显示的代码。）
- en: Simplified Array Initialization Expressions
  id: totrans-547
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简化的数组初始化表达式
- en: 'We’ve already seen how to simplify array initialization expressions by omitting
    the `new` keyword and type declaration:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何通过省略`new`关键字和类型声明来简化数组初始化表达式：
- en: '[PRE97]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Another approach is to use the `var` keyword, which instructs the compiler
    to implicitly type a local variable. Here are some simple examples:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用`var`关键字，该关键字指示编译器隐式地为局部变量确定类型。以下是一些简单的示例：
- en: '[PRE98]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The same principle can be applied to arrays, except that it can be taken one
    stage further. By omitting the type qualifier after the `new` keyword, the compiler
    infers the array type:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的原理可以应用于数组，但可以进一步进行。通过在`new`关键字后省略类型限定符，编译器推断数组类型：
- en: '[PRE99]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Here’s how we can apply this to multidimensional arrays:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 下面我们来看如何将其应用于多维数组：
- en: '[PRE100]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Variables and Parameters
  id: totrans-556
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量和参数
- en: A *variable* represents a storage location that has a modifiable value. A variable
    can be a *local variable*, *parameter* (*value*, *ref*, *out*, or *in*), *field*
    (*instance* or *static*), or *array element*.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '*变量* 表示具有可修改值的存储位置。变量可以是 *局部变量*、*参数*（*value*、*ref*、*out* 或 *in*）、*字段*（实例或静态）、或
    *数组元素*。'
- en: The Stack and the Heap
  id: totrans-558
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆栈与堆
- en: The *stack* and the *heap* are the places where variables reside. Each has very
    different lifetime semantics.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '*堆栈* 和 *堆* 是变量所在的地方。它们各自具有非常不同的生存期语义。'
- en: Stack
  id: totrans-560
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆栈
- en: 'The *stack* is a block of memory for storing local variables and parameters.
    The stack logically grows and shrinks as a method or function is entered and exited.
    Consider the following method (to avoid distraction, input argument checking is
    ignored):'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '*堆栈* 是用于存储局部变量和参数的内存块。堆栈在逻辑上随着方法或函数的进入和退出而增长和收缩。考虑以下方法（为避免分心，忽略输入参数检查）：'
- en: '[PRE101]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: This method is *recursive*, meaning that it calls itself. Each time the method
    is entered, a new `int` is allocated on the stack, and each time the method exits,
    the `int` is deallocated.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法是 *递归* 的，意味着它会调用自身。每次进入方法时，在堆栈上分配一个新的 `int`，每次退出方法时，该 `int` 被释放。
- en: Heap
  id: totrans-564
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆
- en: The *heap* is the memory in which *objects* (i.e., reference type instances)
    reside. Whenever a new object is created, it is allocated on the heap, and a reference
    to that object is returned. During a program’s execution, the heap starts filling
    up as new objects are created. The runtime has a garbage collector that periodically
    deallocates objects from the heap so your program does not run out of memory.
    An object is eligible for deallocation as soon as it’s not referenced by anything
    that is itself alive.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '*堆* 是对象（即引用类型实例）所在的内存。每当创建一个新对象时，它被分配到堆上，并返回对该对象的引用。在程序执行期间，堆会随着创建新对象而填满。运行时具有垃圾收集器，定期从堆中释放对象，以便程序不会耗尽内存。只要一个对象不被任何活动对象引用，就有资格进行释放。'
- en: Value type instances (and object references) live wherever the variable was
    declared. If the instance was declared as a field within a class type, or as an
    array element, that instance lives on the heap.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型实例（和对象引用）存在于变量声明的位置。如果实例被声明为类类型的字段或数组元素，则该实例存在于堆上。
- en: Note
  id: totrans-567
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can’t explicitly delete objects in C# as you can in C++. An unreferenced
    object is eventually collected by the garbage collector.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中不能像在 C++ 中那样显式删除对象。一个未引用的对象最终会被垃圾收集器收集。
- en: The heap also stores static fields and constants. Unlike objects allocated on
    the heap (which can be garbage-collected), these live until the application domain
    is torn down.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 堆还存储静态字段和常量。与在堆上分配的对象（可以进行垃圾收集）不同，这些对象一直存在，直到应用程序域被拆除。
- en: Definite Assignment
  id: totrans-570
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 明确赋值
- en: 'C# enforces a definite assignment policy. In practice, this means that outside
    of an `unsafe` context, it’s impossible to access uninitialized memory. Definite
    assignment has three implications:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: C# 强制实施明确赋值策略。在实践中，这意味着在 `unsafe` 上下文之外，不可能访问未初始化的内存。明确赋值有三个含义：
- en: Local variables must be assigned a value before they can be read.
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部变量必须在读取之前赋值。
- en: Function arguments must be supplied when a method is called (unless marked optional—see
    [“Optional parameters”](#optional_parameters)).
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用方法时必须提供函数参数（除非标记为可选—参见 [“可选参数”](#optional_parameters)）。
- en: All other variables (such as fields and array elements) are automatically initialized
    by the runtime.
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有其他变量（例如字段和数组元素）都由运行时自动初始化。
- en: 'For example, the following code results in a compile-time error:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码导致编译时错误：
- en: '[PRE102]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The following, however, outputs `0`, because fields are implicitly assigned
    a default value (whether instance or static):'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以下输出 `0`，因为字段隐式分配了默认值（无论是实例还是静态）：
- en: '[PRE103]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Default Values
  id: totrans-579
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认值
- en: All type instances have a default value. The default value for the predefined
    types is the result of a bitwise zeroing of memory and is `null` for reference
    types, `0` for numeric and enum types, `'\0'` for the `char` type, and `false`
    for the `bool` type.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类型实例都有一个默认值。预定义类型的默认值是通过内存按位清零的结果，对于引用类型是 `null`，对于数值和枚举类型是 `0`，对于 `char`
    类型是 `'\0'`，对于 `bool` 类型是 `false`。
- en: 'You can obtain the default value for any type by using the `default` keyword
    (this is particularly useful with generics, as you’ll see later). The default
    value in a custom value type (i.e., `struct`) is the same as the default value
    for each field defined by the custom type:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`default`关键字获取任何类型的默认值（这在与泛型一起使用时特别有用，稍后您将看到）。自定义值类型（即`struct`）的默认值与自定义类型定义的每个字段的默认值相同：
- en: '[PRE104]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Parameters
  id: totrans-583
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数
- en: 'A method can have a sequence of parameters. Parameters define the set of arguments
    that must be provided for that method. In this example, the method `Foo` has a
    single parameter named `p`, of type `int`:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方法可以有一系列参数。参数定义了必须为该方法提供的参数集。在此示例中，方法`Foo`有一个名为`p`的单一参数，类型为`int`：
- en: '[PRE105]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'You can control how parameters are passed with the `ref`, `out`, and `in` modifiers:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`ref`、`out`和`in`修饰符控制参数的传递方式：
- en: '| Parameter modifier | Passed by | Variable must be definitely assigned |'
  id: totrans-587
  prefs: []
  type: TYPE_TB
  zh: '| 参数修改器 | 通过 | 变量必须明确赋值 |'
- en: '| --- | --- | --- |'
  id: totrans-588
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| None | Value | Going *in* |'
  id: totrans-589
  prefs: []
  type: TYPE_TB
  zh: '| None | 值 | 进入*中* |'
- en: '| `ref` | Reference | Going *in* |'
  id: totrans-590
  prefs: []
  type: TYPE_TB
  zh: '| `ref` | 引用 | 进入*中* |'
- en: '| `in` | Reference (read-only) | Going *in* |'
  id: totrans-591
  prefs: []
  type: TYPE_TB
  zh: '| `in` | 引用（只读） | 进入*中* |'
- en: '| `out` | Reference | Going *out* |'
  id: totrans-592
  prefs: []
  type: TYPE_TB
  zh: '| `out` | 引用 | 进入*出* |'
- en: Passing arguments by value
  id: totrans-593
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过值传递参数
- en: 'By default, arguments in C# are *passed by value*, which is by far the most
    common case. This means that a copy of the value is created when it is passed
    to the method:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在C#中，参数是*按值传递*的，这是最常见的情况。这意味着当参数传递给方法时会创建一个值的副本：
- en: '[PRE106]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Assigning `p` a new value does not change the contents of `x`, because `p` and
    `x` reside in different memory locations.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 给`p`赋一个新值不会更改`x`的内容，因为`p`和`x`位于不同的内存位置。
- en: 'Passing a reference type argument by value copies the *reference* but not the
    object. In the following example, `Foo` sees the same `StringBuilder` object we
    instantiated (`sb`) but has an independent *reference* to it. In other words,
    `sb` and `fooSB` are separate variables that reference the same `StringBuilder`
    object:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 通过值传递引用类型参数会复制*引用*而不是对象。在下面的示例中，`Foo`看到了我们实例化的相同`StringBuilder`对象(`sb`)，但对它有独立的*引用*。换句话说，`sb`和`fooSB`是引用同一`StringBuilder`对象的不同变量：
- en: '[PRE107]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Because `fooSB` is a *copy* of a reference, setting it to `null` doesn’t make
    `sb` null. (If, however, `fooSB` was declared and called with the `ref` modifier,
    `sb` *would* become null.)
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`fooSB`是引用的*副本*，将其设置为`null`不会使`sb`为null。（但是，如果`fooSB`被声明并用`ref`修饰符调用，则`sb`将会变为null。）
- en: The ref modifier
  id: totrans-600
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`ref`修饰符'
- en: 'To *pass by reference*, C# provides the `ref` parameter modifier. In the following
    example, `p` and `x` refer to the same memory locations:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 要*按引用传递*，C# 提供了`ref`参数修改器。在下面的示例中，`p`和`x`引用相同的内存位置：
- en: '[PRE108]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Now assigning `p` a new value changes the contents of `x`. Notice how the `ref`
    modifier is required both when writing and calling the method. This makes it very
    clear what’s going on.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 现在给`p`赋一个新值会改变`x`的内容。请注意，写入和调用方法时都需要`ref`修饰符。这使得正在发生的事情非常清晰。
- en: Note
  id: totrans-604
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A parameter can be passed by reference or by value, regardless of whether the
    parameter type is a reference type or a value type.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 无论参数类型是引用类型还是值类型，参数都可以按引用或按值传递。
- en: The out modifier
  id: totrans-606
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`out`修饰符'
- en: 'An `out` argument is like a `ref` argument, except for the following:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '`out`参数类似于`ref`参数，但以下几点不同：'
- en: It need not be assigned before going into the function.
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要在进入函数之前赋值。
- en: It must be assigned before it comes *out* of the function.
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须在函数*退出*之前赋值。
- en: The `out` modifier is most commonly used to get multiple return values back
    from a method.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '`out`修饰符最常用于从方法中获取多个返回值。'
- en: Out variables and discards
  id: totrans-611
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出变量和丢弃
- en: 'From C# 7, you can declare variables on the fly when calling methods with `out`
    parameters:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 7开始，您可以在调用具有`out`参数的方法时即时声明变量：
- en: '[PRE109]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'This is equivalent to:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 这等同于：
- en: '[PRE110]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'When calling methods with multiple `out` parameters, you can use an underscore
    to “discard” any in which you’re uninterested. Assuming `SomeBigMethod` has been
    defined with five `out` parameters, you can ignore all but the third, as follows:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用具有多个`out`参数的方法时，您可以使用下划线“丢弃”您不感兴趣的任何参数。假设`SomeBigMethod`已定义为具有五个`out`参数，则可以忽略除第三个之外的所有参数，如下所示：
- en: '[PRE111]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The in modifier
  id: totrans-618
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`in`修饰符'
- en: From C# 7.2, you can prefix a parameter with the `in` modifier to prevent it
    from being modified within the method. This allows the compiler to avoid the overhead
    of copying the argument prior to passing it in, which can matter in the case of
    large custom value types (see [“Structs”](#structs)).
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 7.2开始，你可以在参数前加上`in`修饰符，以防止其在方法内被修改。这允许编译器避免在传递之前复制参数的开销，这在大型自定义值类型的情况下尤为重要（参见[“Structs”](#structs)）。
- en: The params modifier
  id: totrans-620
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: params修饰符
- en: 'The `params` modifier, if applied to the last parameter of a method, allows
    the method to accept any number of arguments of a particular type. The parameter
    type must be declared as a (single-dimensional) array. For example:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`params`修饰符应用于方法的最后一个参数，该方法将允许接受特定类型的任意数量的参数。参数类型必须声明为（单维）数组。例如：
- en: '[PRE112]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'You can call this as follows:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样调用它：
- en: '[PRE113]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: If there are zero arguments in the `params` position, a zero-length array is
    created.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`params`位置上没有参数，则创建一个长度为零的数组。
- en: 'You can also supply a `params` argument as an ordinary array. The preceding
    call is semantically equivalent to:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将`params`参数作为普通数组提供。前述调用在语义上等同于：
- en: '[PRE114]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Optional parameters
  id: totrans-628
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选参数
- en: 'Methods, constructors, and indexers can declare *optional parameters*. A parameter
    is optional if it specifies a *default value* in its declaration:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 方法、构造函数和索引器可以声明 *可选参数*。如果在其声明中指定了 *默认值*，则该参数是可选的：
- en: '[PRE115]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'You can omit optional parameters when calling the method:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 调用方法时可以省略可选参数：
- en: '[PRE116]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The *default argument* of `23` is actually *passed* to the optional parameter
    `x`—the compiler bakes the value `23` into the compiled code at the *calling*
    side. The preceding call to `Foo` is semantically identical to
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '*默认参数* `23` 实际上 *传递* 给了可选参数 `x` —— 编译器将值 `23` 嵌入到调用方的编译代码中。前述对 `Foo` 的调用在语义上与以下内容相同：'
- en: '[PRE117]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: because the compiler simply substitutes the default value of an optional parameter
    wherever it is used.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 因为编译器简单地在任何使用处替换可选参数的默认值。
- en: Warning
  id: totrans-636
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Adding an optional parameter to a public method that’s called from another assembly
    requires recompilation of both assemblies—just as though the parameter were mandatory.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 向另一个程序集中的公共方法添加可选参数需要重新编译两个程序集——就像该参数是必需的一样。
- en: The default value of an optional parameter must be specified by a constant expression,
    a parameterless constructor of a value type, or a `default` expression. You cannot
    mark optional parameters with `ref` or `out`.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 可选参数的默认值必须由常量表达式、值类型的无参构造函数或`default`表达式指定。你不能用`ref`或`out`标记可选参数。
- en: 'Mandatory parameters must occur *before* optional parameters in both the method
    declaration and the method call (the exception is with `params` arguments, which
    still always come last). In the following example, the explicit value of `1` is
    passed to `x`, and the default value of `0` is passed to `y`:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 强制参数必须在方法声明和方法调用中 *之前* 出现可选参数（例外情况是`params`参数，它们始终出现在最后）。在以下示例中，显式值`1`被传递给`x`，默认值`0`被传递给`y`：
- en: '[PRE118]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: You can do the converse (pass a default value to `x` and an explicit value to
    `y`) by combining optional parameters with *named arguments*.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合可选参数和*命名参数*，你可以进行反向操作（向`x`传递默认值，向`y`传递显式值）。
- en: Named arguments
  id: totrans-642
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名参数
- en: 'Rather than identifying an argument by position, you can identify an argument
    by name. For example:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过名称而不是位置标识一个参数。例如：
- en: '[PRE119]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Named arguments can occur in any order. The following calls to `Foo` are semantically
    identical:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 命名参数可以以任何顺序出现。对`Foo`的以下调用在语义上是相同的：
- en: '[PRE120]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'You can mix named and positional arguments, as long as the named arguments
    appear last:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以混合使用命名参数和位置参数，只要命名参数出现在最后：
- en: '[PRE121]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Named arguments are particularly useful in conjunction with optional parameters.
    For instance, consider the following method:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 命名参数在与可选参数结合使用时特别有用。例如，考虑以下方法：
- en: '[PRE122]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'You can call this, supplying only a value for `d`, as follows:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样调用它，只提供`d`的值：
- en: '[PRE123]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: This is particularly useful when you’re calling COM APIs.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用COM API时特别有用。
- en: var—Implicitly Typed Local Variables
  id: totrans-654
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: var —— 隐式类型的局部变量
- en: 'It is often the case that you declare and initialize a variable in one step.
    If the compiler is able to infer the type from the initialization expression,
    you can use the word `var` in place of the type declaration. For example:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你会一步声明和初始化一个变量。如果编译器能够从初始化表达式中推断出类型，则可以使用 `var` 替代类型声明。例如：
- en: '[PRE124]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'This is precisely equivalent to the following:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下完全等价：
- en: '[PRE125]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Because of this direct equivalence, implicitly typed variables are statically
    typed. For example, the following generates a compile-time error:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这种直接的等价性，隐式类型变量是静态类型的。例如，以下代码会生成编译时错误：
- en: '[PRE126]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: In the section [“Anonymous Types”](#anonymous_types), we describe a scenario
    in which the use of `var` is mandatory.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“匿名类型”](#anonymous_types)章节中，我们描述了使用`var`是强制性的情况。
- en: Target-Typed new Expressions
  id: totrans-662
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标类型化的新表达式
- en: 'Another way to reduce lexical repetition is with *target-typed* `new` *expressions*
    (from C# 9):'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种减少词汇重复的方法是使用*C# 9*中的*目标类型化*`new` *表达式*：
- en: '[PRE127]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'This is precisely equivalent to:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下完全等价：
- en: '[PRE128]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The principle is that you can call `new` without specifying a type name if
    the compiler is able to unambiguously infer it. Target-typed `new` expressions
    are particularly useful when the variable declaration and initialization are in
    different parts of your code. A common example is when you want to initialize
    a field in a constructor:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 原则是，如果编译器能够明确地推断出来，你可以调用`new`而不需要指定类型名称。当变量声明和初始化在代码的不同部分时，目标类型化`new`表达式尤其有用。一个常见的例子是当你想在构造函数中初始化一个字段时：
- en: '[PRE129]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Target-typed `new` expressions are also helpful in the following scenario:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 目标类型化`new`表达式在以下场景中也非常有帮助：
- en: '[PRE130]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Expressions and Operators
  id: totrans-671
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式和运算符
- en: 'An *expression* essentially denotes a value. The simplest kinds of expressions
    are constants (such as `123`) and variables (such as `x`). Expressions can be
    transformed and combined with operators. An *operator* takes one or more input
    *operands* to output a new expression:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*表达式*本质上表示一个值。最简单的表达式是常量（如`123`）和变量（如`x`）。表达式可以通过运算符进行转换和组合。*运算符*接受一个或多个输入*操作数*来输出一个新的表达式：
- en: '[PRE131]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Complex expressions can be built because an operand can itself be an expression,
    such as the operand `(12 * 30)` in the following example:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的表达式可以被构建，因为操作数本身可以是一个表达式，例如下面例子中的操作数`(12 * 30)`：
- en: '[PRE132]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Operators in C# can be classed as *unary*, *binary*, or *ternary*, depending
    on the number of operands they work on (one, two, or three). The binary operators
    always use *infix* notation, in which the operator is placed *between* the two
    operands.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，运算符可以分为*一元*、*二元*或*三元*，取决于它们操作的操作数数量（一个、两个或三个）。二元运算符总是使用*中缀*表示法，其中运算符被放置*在*两个操作数*之间*。
- en: 'Operators that are intrinsic to the basic plumbing of the language are called
    *primary*; an example is the method call operator. An expression that has no value
    is called a *void expression*:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 对于语言基本结构中的内置运算符，称为*主要运算符*；方法调用运算符就是一个例子。一个没有值的表达式称为*空表达式*：
- en: '[PRE133]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Because a void expression has no value, you cannot use it as an operand to
    build more complex expressions:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 因为空表达式没有值，所以你不能将其用作构建更复杂表达式的操作数：
- en: '[PRE134]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Assignment Expressions
  id: totrans-681
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值表达式
- en: 'An *assignment expression* uses the `=` operator to assign the result of another
    expression to a variable. For example:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*赋值表达式*使用`=`运算符将另一个表达式的结果赋给一个变量。例如：
- en: '[PRE135]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'An assignment expression is not a void expression. It actually carries the
    assignment value and so can be incorporated into another expression. In the following
    example, the expression assigns 2 to `x` and 10 to `y`:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值表达式不是一个空表达式。它实际上携带了赋值的值，因此可以并入到另一个表达式中。在下面的例子中，表达式将`2`赋给了`x`，`10`赋给了`y`：
- en: '[PRE136]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'This style of expression can be used to initialize multiple values:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表达方式可以用来初始化多个值：
- en: '[PRE137]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The *compound assignment operators* are syntactic shortcuts that combine assignment
    with another operator. For example:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '*复合赋值运算符*是将赋值与另一个运算符结合的语法快捷方式。例如：'
- en: '[PRE138]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '(A subtle exception to this rule is with *events*, which we describe later:
    the `+=` and `-=` operators here are treated specially and map to the event’s
    `add` and `remove` accessors, respectively.)'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: （这条规则的一个微妙的例外是*事件*，我们稍后描述：这里的`+=`和`-=`运算符被特殊对待，并映射到事件的`add`和`remove`访问器。）
- en: Operator Precedence and Associativity
  id: totrans-691
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运算符优先级和结合性
- en: When an expression contains multiple operators, *precedence* and *associativity*
    determine the order of their evaluation. Operators with higher precedence execute
    before operators of lower precedence. If the operators have the same precedence,
    the operator’s associativity determines the order of evaluation.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个表达式包含多个运算符时，*优先级*和*结合性*决定了它们的求值顺序。优先级较高的运算符比优先级较低的运算符先执行。如果运算符具有相同的优先级，则运算符的结合性决定了求值的顺序。
- en: Precedence
  id: totrans-693
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优先级
- en: The expression `1 + 2 * 3` is evaluated as `1 + (2 * 3)` because `*` has a higher
    precedence than `+`.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 `1 + 2 * 3` 会被评估为 `1 + (2 * 3)`，因为 `*` 的优先级高于 `+`。
- en: Left-associative operators
  id: totrans-695
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 左关联运算符
- en: Binary operators (except for assignment, lambda, and null-coalescing operators)
    are *left-associative*; in other words, they are evaluated from left to right.
    For example, the expression `8/4/2` is evaluated as `(8/4)/2` due to left associativity.
    Of course, you can insert your own parentheses to change evaluation order.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制运算符（赋值、lambda 和 null-coalescing 运算符除外）是*左关联*的；换句话说，它们从左到右进行评估。例如，表达式 `8/4/2`
    会被评估为 `(8/4)/2`。
- en: Right-associative operators
  id: totrans-697
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 右关联运算符
- en: 'The assignment and lambda operators, null-coalescing operator, and (ternary)
    conditional operator are *right-associative*; in other words, they are evaluated
    from right to left. Right associativity allows multiple assignments such as `x=y=3`
    to compile: it works by first assigning `3` to `y` and then assigning the result
    of that expression (`3`) to `x`.'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值、lambda 运算符、null-coalescing 运算符和（三元）条件运算符是*右关联*的；换句话说，它们从右到左进行评估。右关联允许多个赋值，例如
    `x=y=3` 可以编译：它首先将 `3` 赋给 `y`，然后将该表达式的结果 (`3`) 赋给 `x`。
- en: Operator Table
  id: totrans-699
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作符表
- en: The following table lists C#’s operators in order of precedence. Operators listed
    under the same subheading have the same precedence. We explain user-overloadable
    operators in the section [“Operator Overloading”](#operator_overloading).
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 下表按照 C# 操作符的优先级排序。在同一子标题下列出的操作符具有相同的优先级。我们在 [“操作符重载”](#operator_overloading)
    部分解释用户可重载的操作符。
- en: '| Operator symbol | Operator name | Example | Overloadable |  |'
  id: totrans-701
  prefs: []
  type: TYPE_TB
  zh: '| 操作符符号 | 操作符名称 | 示例 | 可重载 |  |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-702
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **Primary (highest precedence)** |  |'
  id: totrans-703
  prefs: []
  type: TYPE_TB
  zh: '| **主要（最高优先级）** |  |'
- en: '| `.` | Member access | `x.y` | No |  |'
  id: totrans-704
  prefs: []
  type: TYPE_TB
  zh: '| `.` | 成员访问 | `x.y` | 否 |  |'
- en: '| `?.` | Null-conditional | `x?.y` | No |  |'
  id: totrans-705
  prefs: []
  type: TYPE_TB
  zh: '| `?.` | 空值条件 | `x?.y` | 否 |  |'
- en: '| `!` (postfix) | Null-forgiving | `x!.y` | No |  |'
  id: totrans-706
  prefs: []
  type: TYPE_TB
  zh: '| `!`（后缀） | 空值容错 | `x!.y` | 否 |  |'
- en: '| `->` | Pointer to struct (unsafe) | `x->y` | No |  |'
  id: totrans-707
  prefs: []
  type: TYPE_TB
  zh: '| `->` | 指向结构体的指针（不安全） | `x->y` | 否 |  |'
- en: '| `()` | Function call | `x()` | No |  |'
  id: totrans-708
  prefs: []
  type: TYPE_TB
  zh: '| `()` | 函数调用 | `x()` | 否 |  |'
- en: '| `[]` | Array/index | `a[x]` | Via indexer |  |'
  id: totrans-709
  prefs: []
  type: TYPE_TB
  zh: '| `[]` | 数组/索引 | `a[x]` | 通过索引器 |  |'
- en: '| `++` | Post-increment | `x++` | Yes |  |'
  id: totrans-710
  prefs: []
  type: TYPE_TB
  zh: '| `++` | 后增量 | `x++` | 是 |  |'
- en: '| `--` | Post-decrement | `x--` | Yes |  |'
  id: totrans-711
  prefs: []
  type: TYPE_TB
  zh: '| `--` | 后减量 | `x--` | 是 |  |'
- en: '| `new` | Create instance | `new Foo()` | No |  |'
  id: totrans-712
  prefs: []
  type: TYPE_TB
  zh: '| `new` | 创建实例 | `new Foo()` | 否 |  |'
- en: '| `stackalloc` | Stack allocation | `stackalloc(10)` | No |  |'
  id: totrans-713
  prefs: []
  type: TYPE_TB
  zh: '| `stackalloc` | 堆栈分配 | `stackalloc(10)` | 否 |  |'
- en: '| `typeof` | Get type from identifier | `typeof(int)` | No |  |'
  id: totrans-714
  prefs: []
  type: TYPE_TB
  zh: '| `typeof` | 根据标识符获取类型 | `typeof(int)` | 否 |  |'
- en: '| `nameof` | Get name of identifier | `nameof(x)` | No |  |'
  id: totrans-715
  prefs: []
  type: TYPE_TB
  zh: '| `nameof` | 获取标识符名称 | `nameof(x)` | 否 |  |'
- en: '| `checked` | Integral overflow check on | `checked(x)` | No |  |'
  id: totrans-716
  prefs: []
  type: TYPE_TB
  zh: '| `checked` | 整数溢出检查开启 | `checked(x)` | 否 |  |'
- en: '| `unchecked` | Integral overflow check off | `unchecked(x)` | No |  |'
  id: totrans-717
  prefs: []
  type: TYPE_TB
  zh: '| `unchecked` | 整数溢出检查关闭 | `unchecked(x)` | 否 |  |'
- en: '| `default` | Default value | `default(char)` | No |  |'
  id: totrans-718
  prefs: []
  type: TYPE_TB
  zh: '| `default` | 默认值 | `default(char)` | 否 |  |'
- en: '| `sizeof` | Get size of struct | `sizeof(int)` | No |  |'
  id: totrans-719
  prefs: []
  type: TYPE_TB
  zh: '| `sizeof` | 获取结构体大小 | `sizeof(int)` | 否 |  |'
- en: '| **Unary** |  |'
  id: totrans-720
  prefs: []
  type: TYPE_TB
  zh: '| **一元** |  |'
- en: '| `await` | Await | `await myTask` | No |  |'
  id: totrans-721
  prefs: []
  type: TYPE_TB
  zh: '| `await` | 等待 | `await myTask` | 否 |  |'
- en: '| `+` | Positive value of | `+x` | Yes |  |'
  id: totrans-722
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 正值 | `+x` | 是 |  |'
- en: '| `-` | Negative value of | `-x` | Yes |  |'
  id: totrans-723
  prefs: []
  type: TYPE_TB
  zh: '| `-` | 负值 | `-x` | 是 |  |'
- en: '| `!` | Not | `!x` | Yes |  |'
  id: totrans-724
  prefs: []
  type: TYPE_TB
  zh: '| `!` | 非 | `!x` | 是 |  |'
- en: '| `~` | Bitwise complement | `~x` | Yes |  |'
  id: totrans-725
  prefs: []
  type: TYPE_TB
  zh: '| `~` | 按位取反 | `~x` | 是 |  |'
- en: '| `++` | Pre-increment | `++x` | Yes |  |'
  id: totrans-726
  prefs: []
  type: TYPE_TB
  zh: '| `++` | 前增量 | `++x` | 是 |  |'
- en: '| `--` | Pre-decrement | `--x` | Yes |  |'
  id: totrans-727
  prefs: []
  type: TYPE_TB
  zh: '| `--` | 前减量 | `--x` | 是 |  |'
- en: '| `()` | Cast | `(int)x` | No |  |'
  id: totrans-728
  prefs: []
  type: TYPE_TB
  zh: '| `()` | 类型转换 | `(int)x` | 否 |  |'
- en: '| `^` | Index from end | `array[^1]` | No |  |'
  id: totrans-729
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 从末尾索引 | `array[^1]` | 否 |  |'
- en: '| `*` | Value at address (unsafe) | `*x` | No |  |'
  id: totrans-730
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 地址处的值（不安全） | `*x` | 否 |  |'
- en: '| `&` | Address of value (unsafe) | `&x` | No |  |'
  id: totrans-731
  prefs: []
  type: TYPE_TB
  zh: '| `&` | 值的地址（不安全） | `&x` | 否 |  |'
- en: '| **Range** |  |'
  id: totrans-732
  prefs: []
  type: TYPE_TB
  zh: '| **范围** |  |'
- en: '| `..` `..^` | Range of indices | `x..y` `x..^y` | No |  |'
  id: totrans-733
  prefs: []
  type: TYPE_TB
  zh: '| `..` `..^` | 索引范围 | `x..y` `x..^y` | 否 |  |'
- en: '| **Switch and with** |  |'
  id: totrans-734
  prefs: []
  type: TYPE_TB
  zh: '| **Switch 和 with** |  |'
- en: '| `switch` | Switch expression | `num switch {` `1 => true,`'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '| `switch` | Switch 表达式 | `num switch {` `1 => true,`'
- en: '`_ => false`'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '`_ => false`'
- en: '`}` | No |  |'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '`}` | 否 |  |'
- en: '| `with` | With expression | `rec with` `{ X = 123 }` | No |  |'
  id: totrans-738
  prefs: []
  type: TYPE_TB
  zh: '| `with` | With 表达式 | `rec with` `{ X = 123 }` | 否 |  |'
- en: '| **Multiplicative** |  |'
  id: totrans-739
  prefs: []
  type: TYPE_TB
  zh: '| **乘法** |  |'
- en: '| `*` | Multiply | `x * y` | Yes |  |'
  id: totrans-740
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 乘法 | `x * y` | 是 |  |'
- en: '| `/` | Divide | `x / y` | Yes |  |'
  id: totrans-741
  prefs: []
  type: TYPE_TB
  zh: '| `/` | 除法 | `x / y` | 是 |  |'
- en: '| `%` | Remainder | `x % y` | Yes |  |'
  id: totrans-742
  prefs: []
  type: TYPE_TB
  zh: '| `%` | 取余 | `x % y` | 是 |  |'
- en: '| **Additive** |  |'
  id: totrans-743
  prefs: []
  type: TYPE_TB
  zh: '| **加法** |  |'
- en: '| `+` | Add | `x + y` | Yes |  |'
  id: totrans-744
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 加法 | `x + y` | 是 |  |'
- en: '| `-` | Subtract | `x - y` | Yes |  |'
  id: totrans-745
  prefs: []
  type: TYPE_TB
  zh: '| `-` | 减法 | `x - y` | 是 |  |'
- en: '| **Shift** |  |'
  id: totrans-746
  prefs: []
  type: TYPE_TB
  zh: '| **移位** |  |'
- en: '| `<<` | Shift left | `x << 1` | Yes |  |'
  id: totrans-747
  prefs: []
  type: TYPE_TB
  zh: '| `<<` | 左移 | `x << 1` | 是 |  |'
- en: '| `>>` | Shift right | `x >> 1` | Yes |  |'
  id: totrans-748
  prefs: []
  type: TYPE_TB
  zh: '| `>>` | 右移 | `x >> 1` | 是 |  |'
- en: '| `>>>` | Unsigned shift right | `x >>> 1` | Yes |  |'
  id: totrans-749
  prefs: []
  type: TYPE_TB
  zh: '| `>>>` | 无符号右移 | `x >>> 1` | 是 |  |'
- en: '| **Relational** |  |'
  id: totrans-750
  prefs: []
  type: TYPE_TB
  zh: '| **关系** |  |'
- en: '| `<` | Less than | `x < y` | Yes |  |'
  id: totrans-751
  prefs: []
  type: TYPE_TB
  zh: '| `<` | 小于 | `x < y` | 是 |  |'
- en: '| `>` | Greater than | `x > y` | Yes |  |'
  id: totrans-752
  prefs: []
  type: TYPE_TB
  zh: '| `>` | 大于 | `x > y` | 是 |  |'
- en: '| `<=` | Less than or equal to | `x <= y` | Yes |  |'
  id: totrans-753
  prefs: []
  type: TYPE_TB
  zh: '| `<=` | 小于或等于 | `x <= y` | 是 |  |'
- en: '| `>=` | Greater than or equal to | `x >= y` | Yes |  |'
  id: totrans-754
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | 大于或等于 | `x >= y` | 是 |  |'
- en: '| `is` | Type is or is subclass of | `x is y` | No |  |'
  id: totrans-755
  prefs: []
  type: TYPE_TB
  zh: '| `is` | 类型为或类型为子类 | `x is y` | 否 |  |'
- en: '| `as` | Type conversion | `x as y` | No |  |'
  id: totrans-756
  prefs: []
  type: TYPE_TB
  zh: '| `as` | 类型转换 | `x as y` | 否 |  |'
- en: '| **Equality** |  |'
  id: totrans-757
  prefs: []
  type: TYPE_TB
  zh: '| **相等性** |  |'
- en: '| `==` | Equals | `x == y` | Yes |  |'
  id: totrans-758
  prefs: []
  type: TYPE_TB
  zh: '| `==` | 等于 | `x == y` | 是 |  |'
- en: '| `!=` | Not equals | `x != y` | Yes |  |'
  id: totrans-759
  prefs: []
  type: TYPE_TB
  zh: '| `!=` | 不等于 | `x != y` | 是 |  |'
- en: '| **Bitwise And** |  |'
  id: totrans-760
  prefs: []
  type: TYPE_TB
  zh: '| **按位与** |  |'
- en: '| `&` | And | `x & y` | Yes |  |'
  id: totrans-761
  prefs: []
  type: TYPE_TB
  zh: '| `&` | 与 | `x & y` | 是 |  |'
- en: '| **Bitwise Xor** |  |'
  id: totrans-762
  prefs: []
  type: TYPE_TB
  zh: '| **按位异或** |  |'
- en: '| `^` | Exclusive Or | `x ^ y` | Yes |  |'
  id: totrans-763
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 异或 | `x ^ y` | 是 |  |'
- en: '| **Bitwise Or** |  |'
  id: totrans-764
  prefs: []
  type: TYPE_TB
  zh: '| **按位或** |  |'
- en: '| `&#124;` | Or | `x &#124; y` | Yes |  |'
  id: totrans-765
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | 或 | `x &#124; y` | 是 |  |'
- en: '| **Conditional And** |  |'
  id: totrans-766
  prefs: []
  type: TYPE_TB
  zh: '| **条件与** |  |'
- en: '| `&&` | Conditional And | `x && y` | Via `&` |  |'
  id: totrans-767
  prefs: []
  type: TYPE_TB
  zh: '| `&&` | 条件与 | `x && y` | 通过 `&` |  |'
- en: '| **Conditional Or** |  |'
  id: totrans-768
  prefs: []
  type: TYPE_TB
  zh: '| **条件或** |  |'
- en: '| `&#124;&#124;` | Conditional Or | `x &#124;&#124; y` | Via `&#124;` |  |'
  id: totrans-769
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;&#124;` | 条件或 | `x &#124;&#124; y` | 通过 `&#124;` |  |'
- en: '| **Null coalescing** |  |'
  id: totrans-770
  prefs: []
  type: TYPE_TB
  zh: '| **空值合并** |  |'
- en: '| `??` | Null coalescing | `x ?? y` | No |  |'
  id: totrans-771
  prefs: []
  type: TYPE_TB
  zh: '| `??` | 空值合并 | `x ?? y` | 否 |  |'
- en: '| **Conditional (Ternary)** |  |'
  id: totrans-772
  prefs: []
  type: TYPE_TB
  zh: '| **条件（三元）** |  |'
- en: '| `? :` | Conditional | `isTrue ? thenThis : elseThis` | No |  |'
  id: totrans-773
  prefs: []
  type: TYPE_TB
  zh: '| `? :` | 条件 | `isTrue ? thenThis : elseThis` | 否 |  |'
- en: '| **Assignment and lambda (lowest precedence)** |  |'
  id: totrans-774
  prefs: []
  type: TYPE_TB
  zh: '| **赋值和 lambda（最低优先级）** |  |'
- en: '| `=` | Assign | `x = y` | No |  |'
  id: totrans-775
  prefs: []
  type: TYPE_TB
  zh: '| `=` | 赋值 | `x = y` | 否 |  |'
- en: '| `*=` | Multiply self by | `x *= 2` | Via `*` |  |'
  id: totrans-776
  prefs: []
  type: TYPE_TB
  zh: '| `*=` | 自身乘法 | `x *= 2` | 通过 `*` |  |'
- en: '| `/=` | Divide self by | `x /= 2` | Via `/` |  |'
  id: totrans-777
  prefs: []
  type: TYPE_TB
  zh: '| `/=` | 自身除法 | `x /= 2` | 通过 `/` |  |'
- en: '| `+=` | Add to self | `x += 2` | Via `+` |  |'
  id: totrans-778
  prefs: []
  type: TYPE_TB
  zh: '| `+=` | 自身加法 | `x += 2` | 通过 `+` |  |'
- en: '| `-=` | Subtract from self | `x -= 2` | Via `-` |  |'
  id: totrans-779
  prefs: []
  type: TYPE_TB
  zh: '| `-=` | 自身减法 | `x -= 2` | 通过 `-` |  |'
- en: '| `<<=` | Shift self left by | `x <<= 2` | Via `<<` |  |'
  id: totrans-780
  prefs: []
  type: TYPE_TB
  zh: '| `<<=` | 自身左移 | `x <<= 2` | 通过 `<<` |  |'
- en: '| `>>=` | Shift self right by | `x >>= 2` | Via `>>` |  |'
  id: totrans-781
  prefs: []
  type: TYPE_TB
  zh: '| `>>=` | 自身右移 | `x >>= 2` | 通过 `>>` |  |'
- en: '| `>>>=` | Unsigned shift self right by | `x >>>= 2` | Via `>>>` |'
  id: totrans-782
  prefs: []
  type: TYPE_TB
  zh: '| `>>>=` | 无符号自身右移 | `x >>>= 2` | 通过 `>>>` |'
- en: '| `&=` | And self by | `x &= 2` | Via `&` |  |'
  id: totrans-783
  prefs: []
  type: TYPE_TB
  zh: '| `&=` | 自身与 | `x &= 2` | 通过 `&` |  |'
- en: '| `^=` | Exclusive-Or self by | `x ^= 2` | Via `^` |  |'
  id: totrans-784
  prefs: []
  type: TYPE_TB
  zh: '| `^=` | 自身异或 | `x ^= 2` | 通过 `^` |  |'
- en: '| `&#124;=` | Or self by | `x &#124;= 2` | Via `&#124;` |  |'
  id: totrans-785
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;=` | 自身或 | `x &#124;= 2` | 通过 `&#124;` |  |'
- en: '| `=>` | Lambda | `x => x + 1` | No |  |'
  id: totrans-786
  prefs: []
  type: TYPE_TB
  zh: '| `=>` | Lambda | `x => x + 1` | 否 |  |'
- en: Null Operators
  id: totrans-787
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空值操作符
- en: 'C# provides three operators to make it easier to work with nulls: the *null-coalescing
    operator*, the *null-conditional operator*, and the *null-coalescing assignment
    operator*.'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: C# 提供了三个操作符，用于更方便地处理空值：*null 合并运算符*，*null 条件运算符* 和 *null 合并赋值运算符*。
- en: Null-Coalescing Operator
  id: totrans-789
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空值合并运算符
- en: 'The `??` operator is the *null**-**coalescing operator*. It says, “If the operand
    to the left is non-null, give it to me; otherwise, give me another value.” For
    example:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '`??` 运算符是 *null**-**合并运算符*。它表示，“如果左边的操作数非空，则将其给我；否则，给我另一个值。”例如：'
- en: '[PRE139]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: If the lefthand expression is non-null, the righthand expression is never evaluated.
    The null-coalescing operator also works with nullable value types (see [“Nullable
    Value Types”](#nullable_value_types)).
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 如果左侧表达式非空，则不会评估右侧表达式。空值合并运算符也适用于可空值类型（参见[“可空值类型”](#nullable_value_types)）。
- en: Null-Coalescing Assignment Operator
  id: totrans-793
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空值合并赋值运算符
- en: 'The `??=` operator (introduced in C# 8) is the *null-coalescing assignment
    operator*. It says, “If the operand to the left is null, assign the right operand
    to the left operand.” Consider the following:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: '`??=` 运算符（C# 8 中引入）是 *null 合并赋值运算符*。它表示，“如果左边的操作数为空，则将右操作数赋给左操作数。”考虑以下示例：'
- en: '[PRE140]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'This is equivalent to:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 这等效于：
- en: '[PRE141]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Null-Conditional Operator
  id: totrans-798
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空值条件运算符
- en: 'The `?.` operator is the *null-conditional* or “Elvis” operator. It allows
    you to call methods and access members just like the standard dot operator, except
    that if the operand on the left is null, the expression evaluates to null instead
    of throwing a `NullReferenceException`:'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '`?.`运算符是*空值条件*或“Elvis”运算符。它允许您调用方法和访问成员，就像标准点运算符一样，但如果左边的操作数为空，则表达式会评估为null，而不是抛出`NullReferenceException`：'
- en: '[PRE142]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'The last line is equivalent to this:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行等同于此内容：
- en: '[PRE143]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Null-conditional expressions also work with indexers:'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 空值条件表达式也适用于索引器：
- en: '[PRE144]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Upon encountering a null, the Elvis operator short-circuits the remainder of
    the expression. In the following example, `s` evaluates to null, even with a standard
    dot operator between `ToString()` and `ToUpper()`:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 遇到空值时，Elvis 运算符会短路表达式的其余部分。在以下示例中，即使在`ToString()`和`ToUpper()`之间使用了标准点运算符，`s`仍然评估为null：
- en: '[PRE145]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Repeated use of Elvis is necessary only if the operand immediately to its left
    might be null. The following expression is robust to both `x` being null and `x.y`
    being null:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在左边的操作数可能为空时，才需要重复使用 Elvis 运算符。以下表达式可以确保`x`为空或者`x.y`为空时也能正常运行：
- en: '[PRE146]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'This is equivalent to the following (except that `x.y` is evaluated only once):'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 这等同于以下内容（不同之处在于`x.y`只会被评估一次）：
- en: '[PRE147]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'The final expression must be capable of accepting a null. The following is
    illegal because `int` cannot accept a null:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的表达式必须能够接受空值。以下示例是非法的，因为`int`不能接受空值：
- en: '[PRE148]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'We can fix this with the use of nullable value types (see [“Nullable Value
    Types”](#nullable_value_types)):'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用可空值类型来修复此问题（参见[“可空值类型”](#nullable_value_types)）：
- en: '[PRE149]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'You can also use the null-conditional operator to call a void method:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用空值条件运算符来调用一个`void`方法：
- en: '[PRE150]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: If `someObject` is null, this becomes a “no-operation” rather than throwing
    a `NullReferenceException`.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`someObject`为空，这将成为“无操作”，而不是抛出`NullReferenceException`。
- en: 'The null-conditional operator can be used with the commonly used type members
    that we describe in [“Classes”](#classes), including *methods*, *fields*, *properties*,
    and *indexers*. It also combines well with the null-coalescing operator:'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 空值条件运算符可以与我们在[“类”](#classes)中描述的常用类型成员一起使用，包括*方法*、*字段*、*属性*和*索引器*。它还可以与空值合并运算符很好地结合使用：
- en: '[PRE151]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Statements
  id: totrans-820
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语句
- en: Functions comprise statements that execute sequentially in the textual order
    in which they appear. A *statement block* is a series of statements appearing
    between braces (the `{}` tokens).
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 函数由按照它们出现的文本顺序依次执行的语句组成。*语句块*是出现在大括号之间的一系列语句（`{}`标记）。
- en: Declaration Statements
  id: totrans-822
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明语句
- en: 'A variable declaration introduces a new variable, optionally initializing it
    with an expression. You can declare multiple variables of the same type in a comma-separated
    list. For example:'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 变量声明引入一个新变量，并可选地使用表达式进行初始化。您可以在逗号分隔的列表中声明多个相同类型的变量。例如：
- en: '[PRE152]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'A constant declaration is like a variable declaration, except that it cannot
    be changed after it has been declared, and the initialization must occur with
    the declaration (more on this in [“Constants”](#constants)):'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 常量声明类似于变量声明，但在声明后不能更改，并且初始化必须与声明同时进行（更多内容请参阅[“常量”](#constants)）：
- en: '[PRE153]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Local variable scope
  id: totrans-827
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 局部变量作用域
- en: The scope of a local variable or local constant variable extends throughout
    the current block. You cannot declare another local variable with the same name
    in the current block or in any nested blocks.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量或局部常量的作用域延伸到当前块。您不能在当前块或任何嵌套块中声明另一个同名的局部变量。
- en: Expression Statements
  id: totrans-829
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式语句
- en: 'Expression statements are expressions that are also valid statements. In practice,
    this means expressions that “do” something; in other words:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式语句是有效的语句也是表达式。实际上，这意味着“做”某事的表达式；换句话说：
- en: Assign or modify a variable
  id: totrans-831
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配或修改变量
- en: Instantiate an object
  id: totrans-832
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化对象
- en: Call a method
  id: totrans-833
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用方法
- en: 'Expressions that do none of these are not valid statements:'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 不执行这些操作的表达式不是有效的语句：
- en: '[PRE154]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'When you call a constructor or a method that returns a value, you’re not obliged
    to use the result. However, unless the constructor or method changes state, the
    statement is useless:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用返回值的构造函数或方法时，您不必使用该结果。但是，除非构造函数或方法更改状态，否则该语句是无用的：
- en: '[PRE155]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Selection Statements
  id: totrans-838
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择语句
- en: Selection statements conditionally control the flow of program execution.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 选择语句有条件地控制程序执行流程。
- en: The if statement
  id: totrans-840
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`if`语句'
- en: 'An `if` statement executes a statement if a `bool` expression is true. For
    example:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句在`bool`表达式为`true`时执行一个语句。例如：'
- en: '[PRE156]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'The statement can be a code block:'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 语句可以是一个代码块：
- en: '[PRE157]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: The else clause
  id: totrans-845
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: else 子句
- en: 'An `if` statement can optionally feature an `else` clause:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句可以选择地包含 `else` 子句：'
- en: '[PRE158]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Within an `else` clause, you can nest another `if` statement:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `else` 子句中，你可以嵌套另一个 `if` 语句：
- en: '[PRE159]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Changing the flow of execution with braces
  id: totrans-850
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过移动大括号来改变执行流程
- en: 'An `else` clause always applies to the immediately preceding `if` statement
    in the statement block. For example:'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: '`else` 子句总是应用于语句块中紧接着的 `if` 语句。例如：'
- en: '[PRE160]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'This is semantically identical to the following:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 这在语义上与以下内容相同：
- en: '[PRE161]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'You can change the execution flow by moving the braces:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 通过移动大括号，你可以改变执行流程：
- en: '[PRE162]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'C# has no “elseif” keyword; however, the following pattern achieves the same
    result:'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: C# 没有“elseif”关键字；然而，以下模式可以达到相同的效果：
- en: '[PRE163]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: The switch statement
  id: totrans-859
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`switch` 语句'
- en: 'Switch statements let you branch program execution based on a selection of
    possible values that a variable might have. Switch statements can result in cleaner
    code than multiple `if` statements because switch statements require an expression
    to be evaluated only once. For instance:'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 语句允许你根据变量可能具有的一组可能值来分支程序执行。与多个 `if` 语句相比，`switch` 语句可以生成更干净的代码，因为
    `switch` 语句只需要评估一次表达式。例如：'
- en: '[PRE164]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'The values in each case expression must be constants, which restricts their
    allowable types to the built-in numeric types and the `bool`, `char`, `string`,
    and `enum` types. At the end of each `case` clause, you must say explicitly where
    execution is to go next with some kind of jump statement. Here are the options:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `case` 表达式中的值必须是常量，这限制了它们允许的类型为内置的数值类型以及 `bool`、`char`、`string` 和 `enum`
    类型。在每个 `case` 子句的末尾，你必须明确指定执行流向下一个跳转语句。以下是选项：
- en: '`break` (jumps to the end of the `switch` statement)'
  id: totrans-863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`break`（跳转到 `switch` 语句的末尾）'
- en: '`goto case *x*` (jumps to another `case` clause)'
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`goto case *x*`（跳转到另一个 `case` 子句）'
- en: '`goto default` (jumps to the `default` clause)'
  id: totrans-865
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`goto default`（跳转到 `default` 子句）'
- en: Any other jump statement—namely, `return`, `throw`, `continue`, or `goto *label*`
  id: totrans-866
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何其他跳转语句，包括 `return`、`throw`、`continue` 或 `goto *label*`
- en: 'When more than one value should execute the same code, you can list the common
    `case`s sequentially:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个值应执行相同代码时，可以顺序列出公共的 `case`：
- en: '[PRE165]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: This feature of a `switch` statement can be pivotal in terms of producing cleaner
    code than multiple `if`-`else` statements.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 语句的这一特性在产生比多个 `if`-`else` 语句更清晰的代码方面可以起到关键作用。'
- en: Switching on types
  id: totrans-870
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在类型上进行 `switch`
- en: 'From C# 7, you can switch on *type*:'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 7 开始，你可以根据 *类型* 进行 `switch`：
- en: '[PRE166]'
  id: totrans-872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: (The `object` type allows for a variable of any type—see [“Inheritance”](#inheritance)
    and [“The object Type”](#the_object_type).)
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: （`object` 类型允许变量具有任何类型 — 见 [“继承”](#inheritance) 和 [“object 类型”](#the_object_type)。）
- en: Each *case* clause specifies a type upon which to match, and a variable upon
    which to assign the typed value if the match succeeds. Unlike with constants,
    there’s no restriction on what types you can use. The optional `when` clause specifies
    a condition that must be satisfied for the case to match.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 *case* 子句指定了要匹配的类型以及要在匹配成功时分配的变量。与常量不同，你可以使用任何类型。可选的 `when` 子句指定了必须满足的条件以使
    `case` 匹配。
- en: The order of the case clauses is relevant when you’re switching on type (unlike
    when you’re switching on constants). An exception to this rule is the `default`
    clause, which is executed last, regardless of where it appears.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在类型上进行 `switch` 时，`case` 子句的顺序是相关的（与在常量上进行 `switch` 不同）。一个例外是 `default` 子句，无论它出现在何处，都是最后执行的。
- en: 'You can stack multiple case clauses. The `Console.WriteLine` in the following
    code will execute for any floating-point type greater than 1,000:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以堆叠多个 `case` 子句。以下代码中的 `Console.WriteLine` 将对大于 1,000 的任何浮点类型执行：
- en: '[PRE167]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: In this example, the compiler lets us consume the variables `f`, `d`, and `m`,
    *only* in the `when` clauses. When we call `Console.WriteLine`, it’s unknown as
    to which one of those three variables will be assigned, so the compiler puts all
    of them out of scope.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，编译器允许我们在 `when` 子句中消耗变量 `f`、`d` 和 `m`，仅在调用 `Console.WriteLine` 时，无法确定将为这三个变量中的哪一个分配值，因此编译器使它们全部超出范围。
- en: Switch expressions
  id: totrans-879
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`switch` 表达式'
- en: 'From C# 8, you can also use `switch` in the context of an *expression*. Assuming
    `cardNumber` is of type `int`, the following illustrates its use:'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 8 开始，你也可以在 *表达式* 的上下文中使用 `switch`。假设 `cardNumber` 的类型是 `int`，下面展示了它的使用方法：
- en: '[PRE168]'
  id: totrans-881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Notice that the `switch` keyword appears *after* the variable name and that
    the case clauses are expressions (terminated by commas) rather than statements.
    You can also switch on multiple values (*tuples*):'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`switch`关键字出现在变量名之后，并且case子句是表达式（以逗号结尾），而不是语句。你也可以对多个值（*tuples*）进行switch：
- en: '[PRE169]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: Iteration Statements
  id: totrans-884
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代语句
- en: C# enables a sequence of statements to execute repeatedly with the `while`,
    `do`-`while`, `for`, and `foreach` statements.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: C#允许使用`while`、`do-while`、`for`和`foreach`语句重复执行一系列语句。
- en: while and do-while loops
  id: totrans-886
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`while`和`do-while`循环'
- en: '`while` loops repeatedly execute a body of code while a `bool` expression is
    true. The expression is tested *before* the body of the loop is executed. For
    example, the following writes `012`:'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环在`bool`表达式为真时重复执行一段代码。表达式在执行循环体之前进行测试。例如，以下输出`012`：'
- en: '[PRE170]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '`do`-`while` loops differ in functionality from `while` loops only in that
    they test the expression *after* the statement block has executed (ensuring that
    the block is always executed at least once). Here’s the preceding example rewritten
    with a `do`-`while` loop:'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: '`do`-`while`循环与`while`循环的功能不同之处仅在于它们在执行语句块后测试表达式（确保语句块至少执行一次）。以下是使用`do`-`while`循环重写的前述示例：'
- en: '[PRE171]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: for loops
  id: totrans-891
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`for`循环'
- en: '`for` loops are like `while` loops with special clauses for *initialization*
    and *iteration* of a loop variable. A `for` loop contains three clauses as follows:'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环类似于`while`循环，但具有用于循环变量的初始化和迭代的特殊子句。`for`循环包含以下三个子句：'
- en: '[PRE172]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: The *init-clause* executes before the loop begins and typically initializes
    one or more *iteration* variables.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: '*init-clause*在循环开始之前执行，通常初始化一个或多个*iteration*变量。'
- en: The *condition-clause* is a `bool` expression that is tested *before* each loop
    iteration. The body executes while this condition is true.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: '*condition-clause*是一个`bool`表达式，在每次循环迭代之前进行测试。当条件为真时，执行循环体。'
- en: The *iteration-clause* is executed *after* each iteration of the body. It’s
    typically used to update the iteration variable.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: '*iteration-clause*在每次执行循环体之后执行。通常用于更新迭代变量。'
- en: 'For example, the following prints the numbers 0 through 2:'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下打印数字0至2：
- en: '[PRE173]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'The following prints the first 10 Fibonacci numbers (where each number is the
    sum of the previous two):'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 以下打印前10个斐波那契数（每个数字是前两个数字的和）：
- en: '[PRE174]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Any of the three parts of the `for` statement can be omitted. You can implement
    an infinite loop such as the following (though `while(true)` can be used instead):'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句的三个部分都可以省略。你可以实现无限循环，例如以下（虽然可以使用`while(true)`替代）：'
- en: '[PRE175]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: foreach loops
  id: totrans-903
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`foreach`循环'
- en: 'The `foreach` statement iterates over each element in an enumerable object.
    Most of the .NET types that represent a set or list of elements are enumerable.
    For example, both an array and a string are enumerable. Here is an example of
    enumerating over the characters in a string, from the first character through
    the last:'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach`语句在可枚举对象中迭代每个元素。大多数表示集合或列表的.NET类型都是可枚举的。例如，数组和字符串都是可枚举的。以下是枚举字符串中字符的示例，从第一个字符到最后一个字符：'
- en: '[PRE176]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: We define enumerable objects in [“Enumeration and Iterators”](#enumeration_and_iterators).
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[“Enumeration and Iterators”](#enumeration_and_iterators)中定义可枚举对象。
- en: Jump Statements
  id: totrans-907
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跳转语句
- en: The C# jump statements are `break`, `continue`, `goto`, `return`, and `throw`.
    We cover the `throw` keyword in [“try Statements and Exceptions”](#try_statements_and_exceptions).
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: C#跳转语句包括`break`、`continue`、`goto`、`return`和`throw`。我们在[“try Statements and Exceptions”](#try_statements_and_exceptions)中讨论`throw`关键字。
- en: The break statement
  id: totrans-909
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: break语句
- en: 'The `break` statement ends the execution of the body of an iteration or `switch`
    statement:'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`语句结束迭代或`switch`语句的执行：'
- en: '[PRE177]'
  id: totrans-911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: The continue statement
  id: totrans-912
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: continue语句
- en: 'The `continue` statement forgoes the remaining statements in the loop and makes
    an early start on the next iteration. The following loop *skips* even numbers:'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`语句放弃循环中剩余的语句，并提前开始下一次迭代。以下循环*跳过*偶数：'
- en: '[PRE178]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: The goto statement
  id: totrans-915
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: goto语句
- en: 'The `goto` statement transfers execution to a label (denoted with a colon suffix)
    within a statement block. The following iterates the numbers 1 through 5, mimicking
    a `for` loop:'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: '`goto`语句将执行转移至语句块内的标签（用冒号后缀表示）。以下迭代1至5的数字，模拟`for`循环：'
- en: '[PRE179]'
  id: totrans-917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: The return statement
  id: totrans-918
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: return语句
- en: 'The `return` statement exits the method and must return an expression of the
    method’s return type if the method is nonvoid:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`语句退出方法，并且如果方法是非void类型，则必须返回方法返回类型的表达式：'
- en: '[PRE180]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: A `return` statement can appear anywhere in a method (except in a `finally`
    block) and can be used more than once.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`语句可以出现在方法中的任何位置（除了`finally`块），并且可以多次使用。'
- en: Namespaces
  id: totrans-922
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间
- en: 'A *namespace* is a domain within which type names must be unique. Types are
    typically organized into hierarchical namespaces—both to avoid naming conflicts
    and to make type names easier to find. For example, the `RSA` type that handles
    public key encryption is defined within the following namespace:'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: '*命名空间*是类型名称必须唯一的域。类型通常组织在层次结构命名空间中，这样既可以避免命名冲突，又可以更容易找到类型名称。例如，处理公钥加密的`RSA`类型定义在以下命名空间中：'
- en: '[PRE181]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'A namespace forms an integral part of a type’s name. The following code calls
    `RSA`’s `Create` method:'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是类型名称的一个重要部分。以下代码调用`RSA`的`Create`方法：
- en: '[PRE182]'
  id: totrans-926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: Note
  id: totrans-927
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Namespaces are independent of assemblies, which are units of deployment such
    as an *.exe* or *.dll*.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间独立于程序集，这些程序集是部署单位，例如*.exe*或*.dll*。
- en: Namespaces also have no impact on member accessibility—`public`, `internal`,
    `private`, and so on.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间对成员的可访问性没有影响 — `public`、`internal`、`private`等等。
- en: 'The `namespace` keyword defines a namespace for types within that block. For
    example:'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: '`namespace`关键字为该块内的类型定义了一个命名空间。例如：'
- en: '[PRE183]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'The dots in the namespace indicate a hierarchy of nested namespaces. The code
    that follows is semantically identical to the preceding example:'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间中的点表示嵌套命名空间的层次结构。接下来的代码在语义上与前面的示例相同：
- en: '[PRE184]'
  id: totrans-933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: You can refer to a type with its *fully qualified name*, which includes all
    namespaces from the outermost to the innermost. For example, you could refer to
    `Class1` in the preceding example as `Outer.Middle.Inner.Class1`.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用*完全限定名称*引用类型，其中包括从最外层到最内层的所有命名空间。例如，您可以将前面示例中的`Class1`称为`Outer.Middle.Inner.Class1`。
- en: Types not defined in any namespace are said to reside in the *global namespace*.
    The global namespace also includes top-level namespaces, such as `Outer` in our
    example.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 未定义在任何命名空间中的类型被称为*全局命名空间*。全局命名空间还包括顶层命名空间，例如我们示例中的`Outer`。
- en: File-Scoped Namespaces
  id: totrans-936
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件范围的命名空间
- en: 'Often, you will want all the types in a file to be defined in one namespace:'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您希望文件中的所有类型都定义在一个命名空间中：
- en: '[PRE185]'
  id: totrans-938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'From C# 10, you can accomplish this with a *file-scoped namespace*:'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 自C# 10起，您可以使用*文件范围的命名空间*实现此目的：
- en: '[PRE186]'
  id: totrans-940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: File-scoped namespaces reduce clutter and eliminate an unnecessary level of
    indentation.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 文件范围的命名空间减少了混乱，并消除了不必要的缩进级别。
- en: The using Directive
  id: totrans-942
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: using指令
- en: 'The `using` directive *imports* a namespace and is a convenient way to refer
    to types without their fully qualified names. For example, you can refer to `Class1`
    in the preceding example as follows:'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: '`using`指令*导入*一个命名空间，是一种方便的方法，可以引用类型而不必使用完全限定名称。例如，您可以像下面这样引用前面示例中的`Class1`：'
- en: '[PRE187]'
  id: totrans-944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: A `using` directive can be nested within a namespace itself to limit the scope
    of the directive.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: '`using`指令可以嵌套在命名空间内本身，以限制指令的作用范围。'
- en: The global using Directive
  id: totrans-946
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局using指令
- en: 'From C# 10, if you prefix a `using` directive with the `global` keyword, the
    directive will apply to all files in the project or compilation unit:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 自C# 10起，如果您在`using`指令前加上`global`关键字，则该指令将应用于项目或编译单元中的所有文件：
- en: '[PRE188]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: This lets you centralize common imports and avoid repeating the same directives
    in every file.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得您可以集中管理常见的导入，避免在每个文件中重复相同的指令。
- en: '`global using` directives must precede nonglobal directives and cannot appear
    inside namespace declarations. The global directive can be used with `using static`.'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: '`global using`指令必须在非全局指令之前，并且不能出现在命名空间声明内。全局指令可以与`using static`一起使用。'
- en: using static
  id: totrans-951
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用静态导入
- en: 'The `using static` directive imports a *type* rather than a namespace. All
    static members of that type can then be used without being qualified with the
    type name. In the following example, we call the `Console` class’s static `WriteLine`
    method:'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: '`using static`指令导入的是一个*类型*而不是命名空间。该类型的所有静态成员可以在不用限定类型名称的情况下使用。在以下示例中，我们调用`Console`类的静态`WriteLine`方法：'
- en: '[PRE189]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: The `using static` directive imports all accessible static members of the type,
    including fields, properties, and nested types. You can also apply this directive
    to enum types (see [“Enums”](#enums)), in which case their members are imported.
    Should an ambiguity arise between multiple static imports, the C# compiler is
    unable to infer the correct type from the context and will generate an error.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: '`using static` 指令导入类型的所有可访问的静态成员，包括字段、属性和嵌套类型。你还可以将此指令应用于枚举类型（见[“枚举”](#enums)），在这种情况下，它们的成员被导入。如果在多个静态导入之间出现歧义，C#
    编译器无法从上下文中推断出正确的类型，并将生成错误。'
- en: Rules Within a Namespace
  id: totrans-955
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间内的规则
- en: Name scoping
  id: totrans-956
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 名称作用域
- en: 'Names declared in outer namespaces can be used unqualified within inner namespaces.
    In this example, `Class1` does not need qualification within `Inner`:'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部命名空间中，可以不带限定地使用外部命名空间中声明的名称。在此示例中，`Class1` 在 `Inner` 中不需要限定：
- en: '[PRE190]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'If you want to refer to a type in a different branch of your namespace hierarchy,
    you can use a partially qualified name. In the following example, we base `SalesReport`
    on `Common.ReportBase`:'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想引用命名空间层次结构中不同分支的类型，可以使用部分限定名称。在以下示例中，我们基于 `Common.ReportBase` 创建 `SalesReport`：
- en: '[PRE191]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: Name hiding
  id: totrans-961
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 名称隐藏
- en: If the same type name appears in both an inner and an outer namespace, the inner
    name wins. To refer to the type in the outer namespace, you must qualify its name.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 如果同一类型名称同时出现在内部和外部命名空间中，则内部名称优先。要引用外部命名空间中的类型，必须限定其名称。
- en: Note
  id: totrans-963
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: All type names are converted to fully qualified names at compile time. Intermediate
    Language (IL) code contains no unqualified or partially qualified names.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类型名称在编译时转换为完全限定名称。中间语言（IL）代码不包含未限定或部分限定的名称。
- en: Repeated namespaces
  id: totrans-965
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重复的命名空间
- en: 'You can repeat a namespace declaration, as long as the type names within the
    namespaces don’t conflict:'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 可以重复命名空间声明，只要命名空间内的类型名称不冲突：
- en: '[PRE192]'
  id: totrans-967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: The classes can even span source files and assemblies.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以跨源文件和程序集。
- en: 'The global:: qualifier'
  id: totrans-969
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局限定符 `global::`
- en: 'Occasionally, a fully qualified type name might conflict with an inner name.
    You can force C# to use the fully qualified type name by prefixing it with `global::`,
    as follows:'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，完全限定的类型名称可能与内部名称冲突。你可以通过在其前面加上 `global::` 强制 C# 使用完全限定的类型名称，如下所示：
- en: '[PRE193]'
  id: totrans-971
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: Aliasing Types and Namespaces
  id: totrans-972
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型和命名空间别名
- en: 'Importing a namespace can result in type-name collision. Rather than importing
    the whole namespace, you can import just the specific types you need, giving each
    type an alias. For example:'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 导入命名空间可能会导致类型名称冲突。与其导入整个命名空间，你可以只导入需要的特定类型，并为每个类型起一个别名。例如：
- en: '[PRE194]'
  id: totrans-974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'An entire namespace can be aliased, as follows:'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下方式给整个命名空间起别名：
- en: '[PRE195]'
  id: totrans-976
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: Alias any type (C# 12)
  id: totrans-977
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型别名（C# 12）
- en: 'From C# 12, the `using` directive can alias any kind of type, including, for
    instance, arrays:'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 自 C# 12 起，`using` 指令可以为任何类型和命名空间起别名，包括例如数组：
- en: '[PRE196]'
  id: totrans-979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: You can also alias tuples (see [“Tuples”](#tuples)).
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以给元组起别名（见[“元组”](#tuples)）。
- en: Classes
  id: totrans-981
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: 'A *class* is the most common kind of reference type. The simplest possible
    class declaration is as follows:'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: '*类* 是最常见的引用类型。最简单的类声明如下：'
- en: '[PRE197]'
  id: totrans-983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'A more complex class optionally has the following:'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的类可选包含以下内容：
- en: '| Preceding the keyword `class` | *Attributes* and *class modifiers*. The non-nested
    class modifiers are `public`, `internal`, `abstract`, `sealed`, `static`, `unsafe`,
    and `partial`. |'
  id: totrans-985
  prefs: []
  type: TYPE_TB
  zh: '| 在关键字 `class` 前 | *特性* 和 *类修饰符*。非嵌套类修饰符包括 `public`、`internal`、`abstract`、`sealed`、`static`、`unsafe`
    和 `partial`。 |'
- en: '| Following `Foo` | *Generic type parameters* and *constraints*, a *base class*,
    and *interfaces*. |'
  id: totrans-986
  prefs: []
  type: TYPE_TB
  zh: '| 在 `Foo` 后面 | *泛型类型参数* 和 *约束*，一个 *基类* 和 *接口*。 |'
- en: '| Within the braces | *Class members* (these are *methods*, *properties*, *indexers*,
    *events*, *fields*, *constructors*, *overloaded operators*, *nested types*, and
    a *finalizer*). |'
  id: totrans-987
  prefs: []
  type: TYPE_TB
  zh: '| 在大括号内 | *类成员*（包括 *方法*、*属性*、*索引器*、*事件*、*字段*、*构造函数*、*重载运算符*、*嵌套类型* 和 *终结器*）。
    |'
- en: Fields
  id: totrans-988
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段
- en: 'A *field* is a variable that is a member of a class or struct. For example:'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: '*字段* 是一个类或结构体的成员变量。例如：'
- en: '[PRE198]'
  id: totrans-990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: A field can have the `readonly` modifier to prevent it from being modified after
    construction. A read-only field can be assigned only in its declaration or within
    the enclosing type’s constructor.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 字段可以使用 `readonly` 修饰符防止其在构造后被修改。只能在声明中或封闭类型的构造函数内为只读字段赋值。
- en: Field initialization is optional. An uninitialized field has a default value
    (`0`, `'\0'`, `null`, `false`). Field initializers run before constructors in
    the order in which they appear.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 字段初始化是可选的。未初始化的字段具有默认值（`0`、`'\0'`、`null`、`false`）。字段初始化程序按其出现顺序在构造函数之前运行。
- en: 'For convenience, you can declare multiple fields of the same type in a comma-separated
    list. This is a convenient way for all the fields to share the same attributes
    and field modifiers. For example:'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 为方便起见，您可以在逗号分隔的列表中声明多个相同类型的字段。这是所有字段共享相同属性和字段修饰符的便捷方式。例如：
- en: '[PRE199]'
  id: totrans-994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: Constants
  id: totrans-995
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量
- en: 'A *constant* is evaluated statically at compile time, and the compiler literally
    substitutes its value whenever used (rather like a macro in C++). A constant can
    be any of the built-in numeric types: `bool`, `char`, `string`, or an enum type.'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: '*常量*在编译时静态评估，编译器在使用时直接替换其值（类似于C++中的宏）。常量可以是任何内置的数值类型：`bool`、`char`、`string`或枚举类型。'
- en: 'A constant is declared with the `const` keyword and must be initialized with
    a value. For example:'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`const`关键字声明常量，并且必须用一个值进行初始化。例如：
- en: '[PRE200]'
  id: totrans-998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'A constant is much more restrictive than a `static readonly` field—both in
    the types you can use and in field initialization semantics. A constant also differs
    from a `static readonly` field in that the evaluation of the constant occurs at
    compile time. Constants can also be declared local to a method:'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 常量比`static readonly`字段更加受限制——无论在您可以使用的类型还是在字段初始化语义上。常量与`static readonly`字段的另一个不同之处在于常量的评估发生在编译时。常量也可以声明为方法的本地变量：
- en: '[PRE201]'
  id: totrans-1000
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: Methods
  id: totrans-1001
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法
- en: A *method* performs an action in a series of statements. A method can receive
    *input* data from the caller by specifying *parameters* and send *output* data
    back to the caller by specifying a *return type*. A method can specify a `void`
    return type, indicating that it doesn’t return any value to its caller. A method
    can also output data back to the caller via `ref` and `out` parameters.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法*通过一系列语句执行操作。方法可以通过指定*参数*接收调用者的*输入*数据，并通过指定*返回类型*向调用者发送*输出*数据。方法可以指定`void`返回类型，表示它不向其调用者返回任何值。方法还可以通过`ref`和`out`参数将数据返回给调用者。'
- en: A method’s *signature* must be unique within the type. A method’s signature
    comprises its name and parameter types in order (but not the parameter *names*
    nor the return type).
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的*签名*必须在类型内是唯一的。方法的签名包括其名称和参数类型的顺序（但不包括参数*名称*和返回类型）。
- en: Expression-bodied methods
  id: totrans-1004
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表达式体方法
- en: 'A method that comprises a single expression, such as the following:'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 一个由单个表达式组成的方法，例如以下内容：
- en: '[PRE202]'
  id: totrans-1006
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'can be written more tersely as an *expression-bodied method*. A fat arrow replaces
    the braces and `return` keyword:'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 可以更简洁地编写为*表达式体方法*。一个胖箭头取代了大括号和`return`关键字：
- en: '[PRE203]'
  id: totrans-1008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'Expression-bodied functions can also have a `void` return type:'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式体函数也可以有`void`返回类型：
- en: '[PRE204]'
  id: totrans-1010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: Local methods
  id: totrans-1011
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地方法
- en: 'You can define a method within another method:'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在另一个方法内定义一个方法：
- en: '[PRE205]'
  id: totrans-1013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: The local method (`Cube`, in this case) is visible only to the enclosing method
    (`WriteCubes`). This simplifies the containing type and instantly signals to anyone
    looking at the code that `Cube` is used nowhere else. Local methods can access
    the local variables and parameters of the enclosing method. This has a number
    of consequences, which we describe in [“Capturing Outer Variables”](#capturing_outer_variables).
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 本地方法（本例中为`Cube`）仅对封闭方法（`WriteCubes`）可见。这简化了包含类型，并立即向查看代码的任何人表明`Cube`在其他地方未被使用。本地方法可以访问封闭方法的本地变量和参数。这带来了许多后果，我们在[“捕获外部变量”](#capturing_outer_variables)中描述。
- en: Local methods can appear within other function kinds, such as property accessors,
    constructors, and so on, and even within other local methods. Local methods can
    be iterators or asynchronous.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 本地方法可以出现在其他函数种类中，例如属性访问器、构造函数等，并且甚至可以出现在其他本地方法中。本地方法可以是迭代器或异步的。
- en: 'Methods declared in top-level statements are implicitly local; we can demonstrate
    this as follows:'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 声明在顶层语句中的方法被隐式地视为本地方法；我们可以如下演示：
- en: '[PRE206]'
  id: totrans-1017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: Static local methods
  id: totrans-1018
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态本地方法
- en: Adding the `static` modifier to a local method (from C# 8) prevents it from
    seeing the local variables and parameters of the enclosing method. This helps
    to reduce coupling and prevents the local method from accidentally referring to
    variables in the containing method.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 将`static`修饰符添加到本地方法（从C# 8开始）可防止其访问封闭方法的本地变量和参数。这有助于减少耦合，并防止本地方法意外地引用包含方法中的变量。
- en: Overloading methods
  id: totrans-1020
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法重载
- en: Warning
  id: totrans-1021
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Local methods cannot be overloaded. This means that methods declared in top-level
    statements (which are treated as local methods) cannot be overloaded.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 局部方法不能重载。这意味着在顶级语句中声明的方法（将其视为局部方法）不能重载。
- en: 'A type can overload methods (have multiple methods with the same name) as long
    as the parameter types are different. For example, the following methods can all
    coexist in the same type:'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 类型可以重载方法（具有相同名称的多个方法），只要参数类型不同即可。例如，以下方法可以共存于同一类型中：
- en: '[PRE207]'
  id: totrans-1024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: Instance Constructors
  id: totrans-1025
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例构造函数
- en: 'Constructors run initialization code on a class or struct. A constructor is
    defined like a method, except that the method name and return type are reduced
    to the name of the enclosing type:'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数在类或结构上运行初始化代码。构造函数定义类似于方法，不同之处在于方法名和返回类型被简化为封闭类型的名称：
- en: '[PRE208]'
  id: totrans-1027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'Single-statement constructors can be written as expression-bodied members:'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 单语句构造函数可以编写为表达式体成员：
- en: '[PRE209]'
  id: totrans-1029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'A class or struct can overload constructors. One overload can call another,
    using the `this` keyword:'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 类或结构可以重载构造函数。一个重载可以调用另一个，使用`this`关键字：
- en: '[PRE210]'
  id: totrans-1031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: When one constructor calls another, the *called constructor* executes first.
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个构造函数调用另一个时，*被调用的构造函数*会首先执行。
- en: 'You can pass an *expression* into another constructor as follows:'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将*表达式*传递给另一个构造函数，如下所示：
- en: '[PRE211]'
  id: totrans-1034
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: The expression itself cannot make use of the `this` reference, for example,
    to call an instance method. It can, however, call static methods.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式本身不能使用`this`引用，例如调用实例方法。不过，它可以调用静态方法。
- en: Implicit parameterless constructors
  id: totrans-1036
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐式无参数构造函数
- en: For classes, the C# compiler automatically generates a parameterless public
    constructor if and only if you do not define any constructors. However, as soon
    as you define at least one constructor, the parameterless constructor is no longer
    automatically generated.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类，只有当您没有定义任何构造函数时，C# 编译器才会自动生成一个无参数的公共构造函数。但是，一旦您定义了至少一个构造函数，无参数构造函数就不再自动生成。
- en: Nonpublic constructors
  id: totrans-1038
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非公共构造函数
- en: Constructors do not need to be public. A common reason to have a nonpublic constructor
    is to control instance creation via a static method call. The static method could
    be used to return an object from a pool rather than creating a new object or to
    return a specialized subclass chosen based on input arguments.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数不需要是公共的。有一个非公共构造函数的常见原因是通过静态方法调用控制实例创建。可以使用静态方法从池中返回对象，而不是创建新对象，或者根据输入参数返回所选的特殊子类。
- en: Deconstructors
  id: totrans-1040
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解构方法
- en: 'Whereas a constructor typically takes a set of values (as parameters) and assigns
    them to fields, a deconstructor (C# 7+) does the reverse and assigns fields back
    to a set of variables. A deconstruction method must be called `Deconstruct` and
    have one or more `out` parameters:'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然构造函数通常接受一组值（作为参数）并将它们分配给字段，但解构函数（C# 7+）则相反，将字段分配回一组变量。解构方法必须称为`Deconstruct`并具有一个或多个`out`参数：
- en: '[PRE212]'
  id: totrans-1042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'To call the deconstructor, you use the following special syntax:'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用解构函数，您需要使用以下特殊语法：
- en: '[PRE213]'
  id: totrans-1044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'The second line is the deconstructing call. It creates two local variables
    and then calls the `Deconstruct` method. Our deconstructing call is equivalent
    to the following:'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行是解构调用。它创建两个局部变量然后调用`Deconstruct`方法。我们的解构调用等同于以下内容：
- en: '[PRE214]'
  id: totrans-1046
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'Deconstructing calls allow implicit typing, so we could shorten our call to:'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 解构调用允许隐式类型转换，因此我们可以缩短我们的调用到：
- en: '[PRE215]'
  id: totrans-1048
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'Or simply:'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 或者简单点：
- en: '[PRE216]'
  id: totrans-1050
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'If the variables into which you’re deconstructing are already defined, omit
    the types altogether; this is called a *deconstructing assignment*:'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要解构的变量已经定义，完全可以省略类型；这称为*解构赋值*：
- en: '[PRE217]'
  id: totrans-1052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: You can offer the caller a range of deconstruction options by overloading the
    `Deconstruct` method.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过重载`Deconstruct`方法为调用者提供一系列解构选项。
- en: Note
  id: totrans-1054
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `Deconstruct` method can be an extension method (see [“Extension Methods”](#extension_methods)).
    This is a useful trick if you want to deconstruct types that you did not author.
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: '`Deconstruct`方法可以是扩展方法（参见[“扩展方法”](#extension_methods)）。如果您想解构未经作者授权的类型，这是一个有用的技巧。'
- en: 'From C# 10, you can mix and match existing and new variables when deconstructing:'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 10 开始，您可以在解构时混合和匹配现有变量和新变量：
- en: '[PRE218]'
  id: totrans-1057
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: Object Initializers
  id: totrans-1058
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象初始化器
- en: 'To simplify object initialization, the accessible fields or properties of an
    object can be initialized via an *object initializer* directly after construction.
    For example, consider the following class:'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化对象初始化，可以在构造后直接通过*对象初始化器*初始化对象的可访问字段或属性。例如，请考虑以下类：
- en: '[PRE219]'
  id: totrans-1060
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'Using object initializers, you can instantiate `Bunny` objects as follows:'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象初始化器，你可以像下面这样实例化`Bunny`对象：
- en: '[PRE220]'
  id: totrans-1062
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: The this Reference
  id: totrans-1063
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: this引用
- en: 'The `this` reference refers to the instance itself. In the following example,
    the `Marry` method uses `this` to set the `partner`’s `mate` field:'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`引用指向实例本身。在以下示例中，`Marry`方法使用`this`来设置`partner`的`mate`字段：'
- en: '[PRE221]'
  id: totrans-1065
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'The `this` reference also disambiguates a local variable or parameter from
    a field. For example:'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`引用还可以将局部变量或参数与字段区分开。例如：'
- en: '[PRE222]'
  id: totrans-1067
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: The `this` reference is valid only within nonstatic members of a class or struct.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`引用仅在类或结构的非静态成员中有效。'
- en: Properties
  id: totrans-1069
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: 'Properties look like fields from the outside, but internally they contain logic,
    like methods do. For example, you can’t determine by looking at the following
    code whether `CurrentPrice` is a field or a property:'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 属性看起来像外部的字段，但内部包含逻辑，就像方法一样。例如，你无法通过查看以下代码确定`CurrentPrice`是字段还是属性：
- en: '[PRE223]'
  id: totrans-1071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'A property is declared like a field but with a `get`/`set` block added. Here’s
    how to implement `CurrentPrice` as a property:'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 属性声明与字段类似，但添加了`get`/`set`块。以下是如何将`CurrentPrice`实现为属性的方法：
- en: '[PRE224]'
  id: totrans-1073
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '`get` and `set` denote property *accessors*. The `get` accessor runs when the
    property is read. It must return a value of the property’s type. The `set` accessor
    runs when the property is assigned. It has an implicit parameter named `value`
    of the property’s type that you typically assign to a private field (in this case,
    `currentPrice`).'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`和`set`表示属性的*访问器*。当读取属性时，`get`访问器运行。它必须返回属性类型的值。当分配属性时，`set`访问器运行。它有一个隐含的名为`value`的参数，通常赋给一个私有字段（在本例中为`currentPrice`）。'
- en: Although properties are accessed in the same way as fields, they differ in that
    they give the implementer complete control over getting and setting its value.
    This control enables the implementer to choose whatever internal representation
    is needed, without exposing the internal details to the user of the property.
    In this example, the `set` method could throw an exception if `value` was outside
    a valid range of values.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然属性的访问方式与字段相同，但它们的区别在于它们允许实现者完全控制获取和设置其值。这种控制使得实现者可以选择所需的内部表示，而不向属性的用户公开内部细节。在这个例子中，如果`value`超出有效值范围，`set`方法可能会抛出异常。
- en: Note
  id: totrans-1076
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Throughout this book, we use public fields to keep the examples free of distraction.
    In a real application, you would typically favor public properties over public
    fields to promote encapsulation.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们使用公共字段来保持示例不被干扰。在真实应用中，你通常会倾向于使用公共属性而不是公共字段来促进封装。
- en: A property is read-only if it specifies only a `get` accessor, and it is write-only
    if it specifies only a `set` accessor. Write-only properties are rarely used.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只指定了`get`访问器，则属性是只读的；如果只指定了`set`访问器，则属性是只写的。很少使用只写属性。
- en: 'A property typically has a dedicated backing field to store the underlying
    data. However, it doesn’t need to; it can instead return a value computed from
    other data:'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 属性通常具有专用的后备字段来存储底层数据。但它不需要这样做；它可以返回从其他数据计算出的值：
- en: '[PRE225]'
  id: totrans-1080
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: Expression-bodied properties
  id: totrans-1081
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表达式体属性
- en: 'You can declare a read-only property, such as the preceding one, more tersely
    as an *expression-bodied property*. A fat arrow replaces all the braces and the
    `get` and `return` keywords:'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将只读属性（如上面的示例）更简洁地声明为*表达式体属性*。一个箭头替换了所有的大括号、`get`和`return`关键字：
- en: '[PRE226]'
  id: totrans-1083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 'From C# 7, `set` accessors can be expression-bodied too:'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 7开始，`set`访问器也可以是表达式体的：
- en: '[PRE227]'
  id: totrans-1085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: Automatic properties
  id: totrans-1086
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动属性
- en: 'The most common implementation for a property is a getter and/or setter that
    simply reads and writes to a private field of the same type as the property. An
    *automatic property* declaration instructs the compiler to provide this implementation.
    We can improve the first example in this section by declaring `CurrentPrice` as
    an automatic property:'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 属性最常见的实现方式是一个简单读取和写入与属性相同类型的私有字段的getter和/或setter。*自动属性*声明指示编译器提供此实现。我们可以通过将`CurrentPrice`声明为自动属性来改进本节中的第一个示例：
- en: '[PRE228]'
  id: totrans-1088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: The compiler automatically generates a private backing field of a compiler-generated
    name that cannot be referred to. The `set` accessor can be marked `private` or
    `protected` if you want to expose the property as read-only to other types.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会自动生成一个不能被引用的具有编译器生成名称的私有后备字段。如果要将属性公开为其他类型的只读属性，可以将`set`访问器标记为`private`或`protected`。
- en: Property initializers
  id: totrans-1090
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性初始化器
- en: 'You can add a *property initializer* to automatic properties, just as with
    fields:'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像处理字段一样向自动属性添加*属性初始化器*：
- en: '[PRE229]'
  id: totrans-1092
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: 'This gives `CurrentPrice` an initial value of 123\. Properties with an initializer
    can be read-only:'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得`CurrentPrice`有了一个初始值为123。具有初始化器的属性可以是只读的：
- en: '[PRE230]'
  id: totrans-1094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: Just as with read-only fields, read-only automatic properties can also be assigned
    in the type’s constructor. This is useful in creating *immutable* (read-only)
    types.
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 就像只读字段一样，只读自动属性也可以在类型的构造函数中分配。这在创建*不可变*（只读）类型时非常有用。
- en: get and set accessibility
  id: totrans-1096
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取和设置的可访问性
- en: 'The `get` and `set` accessors can have different access levels. The typical
    use case for this is to have a `public` property with an `internal` or `private`
    access modifier on the setter:'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`和`set`访问器可以具有不同的访问级别。这种情况的典型用法是在`public`属性上具有`internal`或`private`访问修饰符的`set`访问器：'
- en: '[PRE231]'
  id: totrans-1098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: Notice that you declare the property itself with the more permissive access
    level (`public`, in this case) and add the modifier to the accessor you want to
    be *less* accessible.
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您声明属性本身具有更宽松的访问级别（在此示例中为`public`），并在您希望*更不*可访问的访问器上添加修饰符。
- en: Init-only setters
  id: totrans-1100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅初始化器
- en: 'From C# 9, you can declare a property accessor with `init` instead of `set`:'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 9 开始，你可以声明一个使用`init`而不是`set`的属性访问器：
- en: '[PRE232]'
  id: totrans-1102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'These *init-only* properties act like read-only properties, except that they
    can also be set via an object initializer:'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些*仅初始化*属性的行为类似于只读属性，但也可以通过对象初始化器进行设置：
- en: '[PRE233]'
  id: totrans-1104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'After that, the property cannot be altered:'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，属性将无法更改：
- en: '[PRE234]'
  id: totrans-1106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: Init-only properties cannot even be set from inside their class, except via
    their property initializer, the constructor, or another init-only accessor.
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 仅初始化属性甚至不能从其类内部进行设置，除非通过其属性初始化器、构造函数或另一个仅初始化访问器。
- en: 'The alternative to init-only properties is to have read-only properties that
    you populate via a constructor:'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 替代仅初始化属性的方法是通过构造函数填充只读属性：
- en: '[PRE235]'
  id: totrans-1109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: Should the class be part of a public library, this approach makes versioning
    difficult, in that adding an optional parameter to the constructor at a later
    date breaks binary compatibility with consumers (whereas adding a new init-only
    property breaks nothing).
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类是公共库的一部分，则此方法使得版本控制变得困难，因为在以后的日期向构造函数添加可选参数会破坏与使用者的二进制兼容性（而添加新的仅初始化属性不会破坏任何东西）。
- en: Note
  id: totrans-1111
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Init-only properties have another significant advantage, which is that they
    allow for nondestructive mutation when used in conjunction with records (see [“Records”](#records)).
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 仅初始化属性还有另一个显著的优势，即当与记录一起使用时，它们允许非破坏性变异（见[“Records”](#records)）。
- en: 'Just as with ordinary `set` accessors, init-only accessors can provide an implementation:'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通的`set`访问器一样，初始化访问器也可以提供一个实现：
- en: '[PRE236]'
  id: totrans-1114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'Notice that the `_x` field is read-only: init-only setters are permitted to
    modify `readonly` fields in their own class. (Without this feature, `_x` would
    need to be writable, and the class would fail at being internally immutable.)'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`_x`字段是只读的：仅初始化器允许修改其自身类中的`readonly`字段。如果没有此功能，`_x`需要是可写的，而类在内部将无法完全不可变。
- en: Indexers
  id: totrans-1116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引器
- en: 'Indexers provide a natural syntax for accessing elements in a class or struct
    that encapsulate a list or dictionary of values. Indexers are similar to properties
    but are accessed via an index argument rather than a property name. The `string`
    class has an indexer that lets you access each of its `char` values via an `int`
    index:'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 索引器为访问类或结构中封装的值列表或字典的元素提供了一种自然的语法。索引器类似于属性，但通过索引参数访问而不是属性名。`string`类具有一个索引器，它允许您通过`int`索引访问其每个`char`值：
- en: '[PRE237]'
  id: totrans-1118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'The syntax for using indexers is like that for using arrays, except that the
    index argument(s) can be of any type(s). You can call indexers null-conditionally
    by inserting a question mark before the square bracket (see [“Null Operators”](#null_operators)):'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用索引器的语法与使用数组的语法类似，不同之处在于索引参数可以是任何类型。您可以在方括号之前插入问号来对索引器进行空值条件调用（参见[“Null Operators”](#null_operators)）：
- en: '[PRE238]'
  id: totrans-1120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: Implementing an indexer
  id: totrans-1121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现索引器
- en: 'To write an indexer, define a property called `this`, specifying the arguments
    in square brackets. For example:'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写索引器，定义一个名为`this`的属性，并在方括号中指定参数。例如：
- en: '[PRE239]'
  id: totrans-1123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: 'Here’s how we could use this indexer:'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何使用这个索引器的方式：
- en: '[PRE240]'
  id: totrans-1125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'A type can declare multiple indexers, each with parameters of different types.
    An indexer can also take more than one parameter:'
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 类型可以声明多个索引器，每个索引器可以带有不同类型的参数。索引器还可以接受多个参数：
- en: '[PRE241]'
  id: totrans-1127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: 'If you omit the `set` accessor, an indexer becomes read-only, and expression-bodied
    syntax can be used to shorten its definition:'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略`set`访问器，索引器将变为只读，并且可以使用表达式主体语法来缩短其定义：
- en: '[PRE242]'
  id: totrans-1129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: Using indices and ranges with indexers
  id: totrans-1130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用索引和范围与索引器
- en: 'You can support indices and ranges (see [“Indices and Ranges”](#indices_and_ranges))
    in your own classes by defining an indexer with a parameter type of `Index` or
    `Range`. We could extend our previous example by adding the following indexers
    to the `Sentence` class:'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过定义索引器的参数类型为`Index`或`Range`来支持自己的类中的索引和范围（见[“索引和范围”](#indices_and_ranges)）。我们可以通过向`Sentence`类添加以下索引器来扩展我们之前的示例：
- en: '[PRE243]'
  id: totrans-1132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'This then enables the following:'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 这随后使以下内容成为可能：
- en: '[PRE244]'
  id: totrans-1134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: Primary Constructors (C# 12)
  id: totrans-1135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主构造函数（C# 12）
- en: 'From C# 12, you can include a parameter list directly after a class (or struct)
    declaration:'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 12开始，您可以直接在类（或结构）声明之后包含参数列表：
- en: '[PRE245]'
  id: totrans-1137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'This instructs the compiler to automatically build a *primary constructor*
    using the *primary constructor parameters* (`firstName` and `lastName`) so that
    we can instantiate our class as follows:'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 这会指示编译器使用*主构造函数参数*（`firstName`和`lastName`）自动构建一个*主构造函数*，以便我们可以按以下方式实例化我们的类：
- en: '[PRE246]'
  id: totrans-1139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: Primary constructors are useful for prototyping and other simple scenarios.
    The alternative would be to define fields to store `firstName` and `lastName`
    and then write a constructor to populate them.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 主构造函数非常适用于原型设计和其他简单场景。另一种方法是定义字段来存储`firstName`和`lastName`，然后编写一个构造函数来填充它们。
- en: 'The constructor that C# builds is called primary because any additional constructors
    that you choose to (explicitly) write must invoke it:'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: C#生成的构造函数之所以称为主构造函数，是因为您选择（显式地）编写的任何额外构造函数都必须调用它：
- en: '[PRE247]'
  id: totrans-1142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: This ensures that primary constructor parameters are *always populated*.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了主构造函数参数*始终被填充*。
- en: Note
  id: totrans-1144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: C# also provides *records*, which we cover in [“Records”](#records). Records
    also support primary constructors; however, the compiler takes an extra step with
    records and generates (by default) a public init-only property for each primary
    constructor parameter.
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: C#还提供了*记录*，我们在[“记录”](#records)中介绍。记录也支持主构造函数；但是，编译器会额外处理记录，并默认为每个主构造函数参数生成一个公共的init-only属性。
- en: 'Primary constructors are best suited to simple scenarios due to the following
    limitations:'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 主构造函数最适用于简单的场景，因为以下限制：
- en: You cannot add extra initialization code to a primary constructor.
  id: totrans-1147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不能向主构造函数添加额外的初始化代码。
- en: Although it’s easy to expose a primary constructor parameter as a public property,
    you cannot easily incorporate validation logic unless the property is read-only.
  id: totrans-1148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管很容易将主构造函数参数公开为公共属性，但除非属性是只读的，否则不能轻松地整合验证逻辑。
- en: Primary constructors displace the default parameterless constructor that C#
    would otherwise generate.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 主构造函数取代了C#否则会生成的默认无参数构造函数。
- en: Primary constructor semantics
  id: totrans-1150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主构造函数语义
- en: 'To understand how primary constructors work, consider how an ordinary constructor
    behaves:'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解主构造函数的工作原理，请考虑普通构造函数的行为：
- en: '[PRE248]'
  id: totrans-1152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: When the code inside this constructor finishes executing, parameters `firstName`
    and `lastName` disappear out of scope and cannot be subsequently accessed. In
    contrast, a primary constructor’s parameters do *not* disappear out of scope and
    can be subsequently accessed from anywhere within the class, for the life of the
    object.
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 当此构造函数内部的代码执行完毕后，参数`firstName`和`lastName`将退出作用域，不能随后访问。相比之下，主构造函数的参数不会退出作用域，并且在类的任何地方都可以随后访问，对象的生命周期内有效。
- en: Note
  id: totrans-1154
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Primary constructor parameters are special C# constructs, not *fields*, although
    the compiler does end up generating hidden fields behind the scenes to store their
    values if necessary.
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 主构造函数参数是特殊的C#构造，不是*字段*，尽管编译器最终会在幕后生成隐藏字段来存储它们的值（如果需要）。
- en: Primary constructors and field/property initializers
  id: totrans-1156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主构造函数和字段/属性初始化器
- en: 'The accessibility of primary constructor parameters extends to field and property
    initializers. In the following example, we use field and property initializers
    to assign `firstName` to a public field and `lastName` to a public property:'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 主构造函数参数的可访问性延伸到字段和属性的初始化器。在以下示例中，我们使用字段和属性的初始化器将`firstName`分配给公共字段，将`lastName`分配给公共属性：
- en: '[PRE249]'
  id: totrans-1158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: Masking primary constructor parameters
  id: totrans-1159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遮蔽主构造函数参数
- en: 'Fields (or properties) can reuse primary constructor parameter names:'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 字段（或属性）可以重用主构造函数参数名称：
- en: '[PRE250]'
  id: totrans-1161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: In this scenario, the field or property takes precedence, thereby masking the
    primary constructor parameter, *except* on the righthand side of field and property
    initializers (shown in boldface).
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，字段或属性具有优先权，因此在字段和属性初始化器的右侧（用粗体显示）*以外*，主构造函数参数会被屏蔽。
- en: Note
  id: totrans-1163
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Just like ordinary parameters, primary constructor parameters are writable.
    Masking them with a same-named `readonly` field (as in our example) effectively
    protects them from subsequent modification.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通参数一样，主构造函数参数是可写的。使用同名的`readonly`字段屏蔽它们（就像我们的示例中那样），有效地保护它们免受后续修改。
- en: Validating primary constructor parameters
  id: totrans-1165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证主构造函数参数
- en: 'In [“throw expressions”](#throw_expressions), we will describe how to throw
    exceptions when encountering scenarios such as invalid data. Here’s a preview
    to illustrate how this can be used with primary constructors to validate `lastName`
    upon construction, ensuring that it cannot be null:'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“抛出表达式”](#throw_expressions)中，我们将描述在遇到无效数据等场景时如何抛出异常。以下是一个预览，说明了如何在主构造函数中使用这个技术来验证`lastName`，确保其不为null：
- en: '[PRE251]'
  id: totrans-1167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '(Remember that code within a field or property initializer executes when the
    object is constructed—not when the field or property is accessed.) The same technique
    can also expose `lastName` as a public read-only property:'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: （请记住，在字段或属性初始化器中的代码是在对象构造时执行的，而不是在访问字段或属性时执行。）同样的技术也可以将`lastName`公开为一个只读属性：
- en: '[PRE252]'
  id: totrans-1169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: Static Constructors
  id: totrans-1170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态构造函数
- en: 'A static constructor executes once per *type*, rather than once per *instance*.
    A type can define only one static constructor, and it must be parameterless and
    have the same name as the type:'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 静态构造函数每个*类型*只执行一次，而不是每个*实例*执行一次。类型可以定义一个静态构造函数，它必须是无参数的，并且与类型同名：
- en: '[PRE253]'
  id: totrans-1172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: 'The runtime automatically invokes a static constructor just prior to the type
    being used. Two things trigger this: instantiating the type and accessing a static
    member in the type.'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型被使用之前，运行时会自动调用静态构造函数。这有两个触发条件：实例化该类型和访问该类型中的静态成员。
- en: Warning
  id: totrans-1174
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: If a static constructor throws an unhandled exception, that type becomes *unusable*
    for the life of the application.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果静态构造函数抛出未处理的异常，该类型在应用程序的生命周期内将变得*不可用*。
- en: Note
  id: totrans-1176
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'From C# 9, you can also define *module initializers*, which execute once per
    assembly (when the assembly is first loaded). To define a module initializer,
    write a static void method and then apply the `[ModuleInitializer]` attribute
    to that method:'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 9开始，您还可以定义*模块初始化器*，它在程序集加载时执行一次（当程序集首次加载时）。要定义模块初始化器，编写一个静态void方法，然后将`[ModuleInitializer]`属性应用于该方法：
- en: '[PRE254]'
  id: totrans-1178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: Static field initializers run just *before* the static constructor is called.
    If a type has no static constructor, static field initializers will execute just
    prior to the type being used—or *anytime earlier* at the whim of the runtime.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 静态字段初始化器在调用静态构造函数之前执行。如果类型没有静态构造函数，则静态字段初始化器将在类型被使用之前——或者在运行时的任何早期时间——执行。
- en: Static Classes
  id: totrans-1180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态类
- en: A class marked as `static` cannot be instantiated or subclassed, and must be
    composed solely of static members. The `Sys⁠tem.​Console` and `System.Math` classes
    are good examples of static classes.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为`static`的类无法实例化或继承，并且必须完全由静态成员组成。`Sys⁠tem.​Console`和`System.Math`类是静态类的良好示例。
- en: Finalizers
  id: totrans-1182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终结器
- en: '*Finalizers* are class-only methods that execute before the garbage collector
    reclaims the memory for an unreferenced object. The syntax for a finalizer is
    the name of the class prefixed with the `~` symbol:'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: '*终结器*是仅在类中执行的方法，在垃圾收集器回收未引用对象的内存之前执行。终结器的语法是类名前缀加上`~`符号：'
- en: '[PRE255]'
  id: totrans-1184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: C# translates a finalizer into a method that overrides the `Finalize` method
    in the `object` class. We discuss garbage collection and finalizers fully in Chapter
    12 of *C# 12 in a Nutshell*.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: C#将终结器翻译成一个方法，该方法重写`object`类中的`Finalize`方法。我们在《C# 12入门》的第12章中详细讨论了垃圾收集和终结器。
- en: Single-statement finalizers can be written with expression-bodied syntax.
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用表达式体语法可以编写单语句终结器。
- en: Partial Types and Methods
  id: totrans-1187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分类型和方法
- en: '*Partial types* allow a type definition to be split—typically across multiple
    files. A common scenario is for a partial class to be autogenerated from some
    other source (e.g., a Visual Studio template) and for that class to be augmented
    with additional hand-authored methods. For example:'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: '*部分类型*允许将类型定义拆分-通常跨多个文件。一个常见的场景是从其他源（例如Visual Studio模板）自动生成部分类，并通过额外手动编写的方法来增强该类。例如：'
- en: '[PRE256]'
  id: totrans-1189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: Each participant must have the `partial` declaration.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 每个参与者必须有`partial`声明。
- en: Participants cannot have conflicting members. A constructor with the same parameters,
    for instance, cannot be repeated. Partial types are resolved entirely by the compiler,
    which means that each participant must be available at compile time and must reside
    in the same assembly.
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 参与者不能有冲突的成员。例如，具有相同参数的构造函数不能重复。部分类型完全由编译器解析，这意味着每个参与者必须在编译时可用，并且必须驻留在同一个程序集中。
- en: A base class can be specified on a single participant or on multiple participants
    (as long as the base class that you specify is the same). In addition, each participant
    can independently specify interfaces to implement. We cover base classes and interfaces
    in [“Inheritance”](#inheritance) and [“Interfaces”](#interfaces).
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在单个参与者或多个参与者上指定基类（只要您指定的基类相同）。此外，每个参与者可以独立指定要实现的接口。我们在[“继承”](#inheritance)和[“接口”](#interfaces)中介绍基类和接口。
- en: Partial methods
  id: totrans-1193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部分方法
- en: 'A partial type can contain *partial methods*. These let an autogenerated partial
    type provide customizable hooks for manual authoring. For example:'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 部分类型可以包含*部分方法*。这些方法让自动生成的部分类型为手动编写提供可定制的钩子。例如：
- en: '[PRE257]'
  id: totrans-1195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: 'A partial method consists of two parts: a *definition* and an *implementation*.
    The definition is typically written by a code generator, and the implementation
    is typically manually authored. If an implementation is not provided, the definition
    of the partial method is compiled away (as is the code that calls it). This allows
    autogenerated code to be liberal in providing hooks, without having to worry about
    bloat. Partial methods must be `void` and are implicitly `private`.'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 部分方法由两部分组成：*定义*和*实现*。定义通常由代码生成器编写，实现通常手动编写。如果未提供实现，部分方法的定义将被编译消除（调用它的代码也将被消除）。这允许自动生成的代码在提供钩子时更加自由，而无需担心膨胀。部分方法必须是`void`，并且隐式为`private`。
- en: Extended partial methods
  id: totrans-1197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展的部分方法
- en: '*Extended partial methods* (from C# 9) are designed for the reverse code generation
    scenario, where a programmer defines hooks that a code generator implements. An
    example of where this might occur is with *source generators*, a Roslyn feature
    that lets you feed the compiler an assembly that automatically generates portions
    of your code.'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: '*扩展的部分方法*（来自C# 9）旨在用于反向代码生成场景，程序员在其中定义代码生成器实现的钩子。可能发生这种情况的一个例子是*源生成器*，这是Roslyn的一个功能，允许您向编译器提供一个自动生成代码部分的程序集。'
- en: 'A partial method declaration is *extended* if it begins with an accessibility
    modifier:'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果部分方法声明以可访问性修饰符开头，则它是*扩展的*。
- en: '[PRE258]'
  id: totrans-1200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: 'The presence of the accessibility modifier doesn’t just affect accessibility:
    it tells the compiler to treat the declaration differently.'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 可访问性修饰符的存在不仅影响可访问性：它告诉编译器以不同方式处理声明。
- en: Extended partial methods *must* have implementations; they do not melt away
    if unimplemented. In this example, both `M1` and `M2` must have implementations
    because they each specify accessibility modifiers (`public` and `private`).
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展的部分方法*必须*有实现；如果未实现，它们不会消失。在这个例子中，`M1`和`M2`都必须有实现，因为它们各自指定了可访问性修饰符（`public`和`private`）。
- en: Because they cannot melt away, extended partial methods can return any type
    and can include `out` parameters.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们不会消失，扩展的部分方法可以返回任何类型，并且可以包含`out`参数。
- en: The nameof Operator
  id: totrans-1204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`nameof`运算符'
- en: 'The `nameof` operator returns the name of any symbol (type, member, variable,
    and so on) as a string:'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: '`nameof`运算符将任何符号（类型、成员、变量等）的名称作为字符串返回：'
- en: '[PRE259]'
  id: totrans-1206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: Its advantage over simply specifying a string is that of static type checking.
    Tools such as Visual Studio can understand the symbol reference, so if you rename
    the symbol in question, all of its references will be renamed too.
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 它相对于简单指定字符串的优势在于静态类型检查。诸如Visual Studio之类的工具可以理解符号引用，因此如果您重命名所涉及的符号，所有引用也将被重命名。
- en: 'To specify the name of a type member such as a field or property, include the
    type as well. This works with both static and instance members:'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定类型成员的名称，比如字段或属性，也要包括类型。这适用于静态成员和实例成员：
- en: '[PRE260]'
  id: totrans-1209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: 'This evaluates to `"Length"`. To return `"StringBuilder.Length"`, you would
    do this:'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 这将评估为`"Length"`。要返回`"StringBuilder.Length"`，你需要这样做：
- en: '[PRE261]'
  id: totrans-1211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: Inheritance
  id: totrans-1212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: 'A class can *inherit* from another class to extend or customize the original
    class. Inheriting from a class lets you reuse the functionality in that class
    instead of building it from scratch. A class can inherit from only a single class
    but can itself be inherited by many classes, thus forming a class hierarchy. In
    this example, we begin by defining a class called `Asset`:'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以从另一个类 *继承*，以扩展或自定义原始类。从类继承可以重用该类中的功能，而不是从头开始构建。一个类只能从一个类继承，但本身可以被多个类继承，从而形成类层次结构。在这个例子中，我们首先定义了一个名为
    `Asset` 的类：
- en: '[PRE262]'
  id: totrans-1214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: 'Next, we define classes called `Stock` and `House`, which will inherit from
    `Asset`. `Stock` and `House` get everything an `Asset` has, plus any additional
    members that they define:'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了名为 `Stock` 和 `House` 的类，它们将继承自 `Asset`。`Stock` 和 `House` 获得 `Asset`
    所有的东西，以及它们自己定义的任何额外成员：
- en: '[PRE263]'
  id: totrans-1216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: 'Here’s how we can use these classes:'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用这些类的示例：
- en: '[PRE264]'
  id: totrans-1218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: The *subclasses*, `Stock` and `House`, inherit the `Name` field from the *base
    class*, `Asset`.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: '*子类* `Stock` 和 `House` 从 *基类* `Asset` 继承了 `Name` 字段。'
- en: Subclasses are also called *derived classes*.
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 子类也称为 *派生类*。
- en: Polymorphism
  id: totrans-1221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态性
- en: 'References are *polymorphic*. This means a variable of type *x* can refer to
    an object that subclasses *x*. For instance, consider the following method:'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 引用是 *多态的*。这意味着类型为 *x* 的变量可以引用一个子类 *x* 的对象。例如，考虑以下方法：
- en: '[PRE265]'
  id: totrans-1223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: This method can display both a `Stock` and a `House` because they are both `Asset`s.
    Polymorphism works on the basis that subclasses (`Stock` and `House`) have all
    the features of their base class (`Asset`). The converse, however, is not true.
    If `Display` were rewritten to accept a `House`, you could not pass in an `Asset`.
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法可以显示 `Stock` 和 `House`，因为它们都是 `Asset`。多态性基于子类（`Stock` 和 `House`）具有其基类（`Asset`）的所有特征。然而，反之则不成立。如果将
    `Display` 重写为接受 `House`，则不能传递 `Asset`。
- en: Casting and Reference Conversions
  id: totrans-1225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换和引用转换
- en: 'An object reference can be:'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 对象引用可以是：
- en: Implicitly *upcast* to a base class reference
  id: totrans-1227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式地 *向上转换* 到基类引用
- en: Explicitly *downcast* to a subclass reference
  id: totrans-1228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式地 *向下转换* 到子类引用
- en: 'Upcasting and downcasting between compatible reference types performs *reference
    conversions*: a new reference is created that points to the *same* object. An
    upcast always succeeds; a downcast succeeds only if the object is suitably typed.'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 在兼容的引用类型之间进行上转换和下转换执行 *引用转换*：创建一个指向 *相同* 对象的新引用。上转换始终成功；下转换仅在对象适当类型时才成功。
- en: Upcasting
  id: totrans-1230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上转换
- en: 'An upcast operation creates a base class reference from a subclass reference.
    For example:'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 上转换操作从子类引用创建一个基类引用。例如：
- en: '[PRE266]'
  id: totrans-1232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: 'After the upcast, variable `a` still references the same `Stock` object as
    variable `msft`. The object being referenced is not itself altered or converted:'
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 上转换后，变量 `a` 仍然引用与变量 `msft` 相同的 `Stock` 对象。被引用的对象本身没有被修改或转换：
- en: '[PRE267]'
  id: totrans-1234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: 'Although `a` and `msft` refer to the same object, `a` has a more restrictive
    view on that object:'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `a` 和 `msft` 引用同一个对象，但 `a` 对该对象的视图更为限制：
- en: '[PRE268]'
  id: totrans-1236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: The last line generates a compile-time error because the variable `a` is of
    type `Asset`, even though it refers to an object of type `Stock`. To get to its
    `SharesOwned` field, you must *downcast* the `Asset` to a `Stock`.
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行生成了一个编译时错误，因为变量 `a` 的类型是 `Asset`，即使它引用的是 `Stock` 类型的对象。要访问其 `SharesOwned`
    字段，必须将 `Asset` *下转换* 为 `Stock`。
- en: Downcasting
  id: totrans-1238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下转换
- en: 'A downcast operation creates a subclass reference from a base class reference.
    For example:'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 下转换操作从基类引用创建一个子类引用。例如：
- en: '[PRE269]'
  id: totrans-1240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: 'As with an upcast, only references are affected—not the underlying object.
    A downcast requires an explicit cast because it can potentially fail at runtime:'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 与上转换类似，只影响引用而不影响底层对象。下转换需要显式转换，因为它在运行时可能失败：
- en: '[PRE270]'
  id: totrans-1242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: If a downcast fails, an `InvalidCastException` is thrown. This is an example
    of *runtime type checking* (see [“Static and Runtime Type Checking”](#static_and_runtime_type_checking)).
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个下转换失败，会抛出 `InvalidCastException`。这是一个 *运行时类型检查* 的例子（参见 [“静态类型检查与运行时类型检查”](#static_and_runtime_type_checking)）。
- en: The as operator
  id: totrans-1244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`as` 操作符'
- en: 'The `as` operator performs a downcast that evaluates to `null` (rather than
    throwing an exception) if the downcast fails:'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: '`as` 操作符执行一个下转换，如果下转换失败则返回 `null`（而不是抛出异常）：'
- en: '[PRE271]'
  id: totrans-1246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: 'This is useful when you’re going to subsequently test whether the result is
    `null`:'
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 当你要测试结果是否为 `null` 时，这是非常有用的：
- en: '[PRE272]'
  id: totrans-1248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: The `as` operator cannot perform *custom conversions* (see [“Operator Overloading”](#operator_overloading)),
    and it cannot do numeric conversions.
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: '`as`运算符无法执行*自定义转换*（见[“运算符重载”](#operator_overloading)），也不能进行数值转换。'
- en: The is operator
  id: totrans-1250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`is`运算符'
- en: 'The `is` operator tests whether a reference conversion would succeed—in other
    words, whether an object derives from a specified class (or implements an interface).
    It is often used to test before downcasting:'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: '`is`运算符测试引用转换是否成功——换句话说，对象是否派生自指定的类（或实现接口）。通常用于在向下转换之前进行测试：'
- en: '[PRE273]'
  id: totrans-1252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: The `is` operator also evaluates to true if an unboxing conversion would succeed
    (see [“The object Type”](#the_object_type)). However, it does not consider custom
    or numeric conversions.
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果拆箱转换会成功（见[“对象类型”](#the_object_type)），`is`运算符也会返回true。但它不考虑自定义或数值转换。
- en: 'From C# 7, you can introduce a variable while using the `is` operator:'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 自C# 7开始，您可以在使用`is`运算符时引入变量：
- en: '[PRE274]'
  id: totrans-1255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: 'The variable that you introduce is available for “immediate” consumption and
    remains in scope outside the `is` expression:'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 引入的变量可以被“立即”使用，并且在`is`表达式外保持作用域内：
- en: '[PRE275]'
  id: totrans-1257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: The `is` operator works with other patterns introduced in recent versions of
    C#. For a full discussion, see [“Patterns”](#patterns).
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: '`is`运算符与C#的最新版本中引入的其他模式一起使用。有关详细讨论，请参阅[“模式”](#patterns)。'
- en: Virtual Function Members
  id: totrans-1259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚函数成员
- en: 'A function marked as `virtual` can be *overridden* by subclasses wanting to
    provide a specialized implementation. Methods, properties, indexers, and events
    can all be declared `virtual`:'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为`virtual`的函数可以被子类重写，提供特定的实现。方法、属性、索引器和事件都可以声明为`virtual`：
- en: '[PRE276]'
  id: totrans-1261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '(`Liability => 0` is a shortcut for `{ get { return 0; } }`. See [“Expression-bodied
    properties”](#expression_bodied_properties) for more details on this syntax.)
    A subclass overrides a virtual method by applying the `override` modifier:'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: (`Liability => 0`是`{ get { return 0; } }`的快捷方式。有关此语法的更多详细信息，请参阅[“表达式体属性”](#expression_bodied_properties)。）子类通过应用`override`修饰符来重写虚方法：
- en: '[PRE277]'
  id: totrans-1263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: 'By default, the `Liability` of an `Asset` is `0`. A `Stock` does not need to
    specialize this behavior. However, the `House` specializes the `Liability` property
    to return the value of the `Mortgage`:'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`Asset`的`Liability`为`0`。`Stock`不需要专门化此行为。但是，`House`专门化了`Liability`属性，以返回`Mortgage`的值：
- en: '[PRE278]'
  id: totrans-1265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: The signatures, return types, and accessibility of the virtual and overridden
    methods must be identical. An overridden method can call its base class implementation
    via the `base` keyword (see [“The base Keyword”](#the_base_keyword)).
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 虚方法和重写方法的签名、返回类型和可访问性必须相同。重写方法可以通过`base`关键字调用其基类实现（见[“base关键字”](#the_base_keyword)）。
- en: Covariant returns
  id: totrans-1267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协变返回
- en: From C# 9, you can override a method (or property `get` accessor) such that
    it returns a *more derived* (subclassed) type. For example, you can write a `Clone`
    method in the `Asset` class that returns an `Asset` and override that method in
    the `House` class such that it returns a `House`.
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 自C# 9开始，你可以重写一个方法（或属性`get`访问器），使其返回*更具体*（子类化）的类型。例如，你可以在`Asset`类中编写一个返回`Asset`的`Clone`方法，并在`House`类中重写该方法，使其返回`House`。
- en: 'This is permitted because it does not break the contract that `Clone` must
    return an `Asset`: it returns a `House`, which *is* an `Asset` (and more).'
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 这是允许的，因为它不违反`Clone`必须返回`Asset`的约定：它返回一个`House`，而*House*是一个`Asset`（甚至更多）。
- en: Abstract Classes and Abstract Members
  id: totrans-1270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象类和抽象成员
- en: A class declared as *abstract* can never be instantiated. Instead, only its
    concrete *subclasses* can be instantiated.
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 声明为*abstract*的类永远不能被实例化。相反，只能实例化其具体的*子类*。
- en: 'Abstract classes are able to define *abstract members*. Abstract members are
    like virtual members, except they don’t provide a default implementation. That
    implementation must be provided by the subclass, unless that subclass is also
    declared abstract:'
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类可以定义*抽象成员*。抽象成员类似于虚成员，但它们不提供默认实现。除非子类也声明为抽象类，否则必须由子类提供实现：
- en: '[PRE279]'
  id: totrans-1273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: Subclasses override abstract members just as though they were virtual.
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 子类可以像重写虚方法一样重写抽象成员。
- en: Hiding Inherited Members
  id: totrans-1275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏继承成员
- en: 'A base class and a subclass can define identical members. For example:'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 基类和子类可以定义相同的成员。例如：
- en: '[PRE280]'
  id: totrans-1277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: 'The `Counter` field in class `B` is said to *hide* the `Counter` field in class
    `A`. Usually, this happens by accident, when a member is added to the base type
    *after* an identical member was added to the subtype. For this reason, the compiler
    generates a warning and then resolves the ambiguity as follows:'
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 类`B`中的`Counter`字段被称为*隐藏*类`A`中的`Counter`字段。通常情况下，这种情况是偶然发生的，当在子类型中添加相同成员之后添加基类型时。因此，编译器生成警告，然后按以下方式解决歧义：
- en: References to `A` (at compile time) bind to `A.Counter`.
  id: totrans-1279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`A`的引用（在编译时）绑定到`A.Counter`。
- en: References to `B` (at compile time) bind to `B.Counter`.
  id: totrans-1280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`B`的引用（在编译时）绑定到`B.Counter`。
- en: 'Occasionally, you want to hide a member deliberately, in which case you can
    apply the `new` modifier to the member in the subclass. The `new` modifier does
    nothing more than suppress the compiler warning that would otherwise result:'
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您想要故意隐藏一个成员，在这种情况下，您可以在子类的成员上应用`new`修饰符。`new`修饰符只是抑制了否则会产生的编译器警告：
- en: '[PRE281]'
  id: totrans-1282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: The `new` modifier communicates your intent to the compiler—and other programmers—that
    the duplicate member is not an accident.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`修饰符向编译器和其他程序员表明，重复的成员不是偶然事件。'
- en: Sealing Functions and Classes
  id: totrans-1284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封闭函数和类
- en: 'An overridden function member can *seal* its implementation with the `sealed`
    keyword to prevent it from being overridden by further subclasses. In our earlier
    virtual function member example, we could have sealed `House`’s implementation
    of `Liability`, preventing a class that derives from `House` from overriding `Liability`,
    as follows:'
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 重写的函数成员可以使用`sealed`关键字封闭其实现，防止其被后续的子类重写。在我们之前的虚函数成员示例中，我们可以封闭`House`对`Liability`的实现，从而防止从`House`派生的类重写`Liability`，如下所示：
- en: '[PRE282]'
  id: totrans-1286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: You can also apply the `sealed` modifier to the class itself, to prevent subclassing.
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将`sealed`修饰符应用于类本身，以防止子类化。
- en: The base Keyword
  id: totrans-1288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`base`关键字'
- en: 'The `base` keyword is similar to the `this` keyword. It serves two essential
    purposes: accessing an overridden function member from the subclass and calling
    a base class constructor (see the next section).'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: '`base`关键字类似于`this`关键字。它有两个基本目的：从子类访问重写的函数成员和调用基类构造函数（请参见下一节）。'
- en: 'In this example, `House` uses the `base` keyword to access `Asset`’s implementation
    of `Liability`:'
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`House`使用`base`关键字访问`Asset`的`Liability`实现：
- en: '[PRE283]'
  id: totrans-1291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: With the `base` keyword, we access `Asset`’s `Liability` property *nonvirtually*.
    This means that we will always access `Asset`’s version of this property, regardless
    of the instance’s actual runtime type.
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`base`关键字，我们非虚拟地访问`Asset`的`Liability`属性。这意味着无论实例的实际运行时类型如何，我们始终访问`Asset`的此属性版本。
- en: The same approach works if `Liability` is *hidden* rather than *overridden*.
    (You can also access hidden members by casting to the base class before invoking
    the function.)
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Liability`是*隐藏*而不是*重写*，同样的方法也适用。（在调用函数之前，您可以通过将其强制转换为基类来访问隐藏成员。）
- en: Constructors and Inheritance
  id: totrans-1294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数和继承
- en: 'A subclass must declare its own constructors. For example, assume we define
    `Baseclass` and `Subclass` as follows:'
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 子类必须声明其自己的构造函数。例如，假设我们定义`Baseclass`和`Subclass`如下：
- en: '[PRE284]'
  id: totrans-1296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: 'The following is then illegal:'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 随后的内容是非法的：
- en: '[PRE285]'
  id: totrans-1298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '`Subclass` must “redefine” any constructors that it wants to expose. In doing
    so, it can call any of the base class’s constructors with the `base` keyword:'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subclass`必须“重新定义”它想要公开的任何构造函数。在这样做时，它可以使用`base`关键字调用基类的任何构造函数：'
- en: '[PRE286]'
  id: totrans-1300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: The `base` keyword works rather like the `this` keyword, except that it calls
    a constructor in the base class. Base class constructors always execute first;
    this ensures that *base* initialization occurs before *specialized* initialization.
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: '`base`关键字工作方式类似于`this`关键字，不同之处在于它调用基类中的构造函数。基类构造函数总是首先执行；这确保了*基础*初始化发生在*专门化*初始化之前。'
- en: If a constructor in a subclass omits the `base` keyword, the base type’s *parameterless*
    constructor is implicitly called (if the base class has no accessible parameterless
    constructor, the compiler generates an error).
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果子类中的构造函数省略了`base`关键字，则会隐式调用基类型的*无参数*构造函数（如果基类没有可访问的无参数构造函数，则编译器会生成错误）。
- en: Required members (C# 11)
  id: totrans-1303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 必需成员（C# 11）
- en: 'The requirement for subclasses to invoke a constructor in the base class can
    become burdensome in large class hierarchies if there are many constructors with
    many parameters. Sometimes, the best solution is to avoid constructors altogether
    and rely solely on object initializers to set fields or properties during construction.
    To help with this, you can mark a field or property as `required` (from C# 11):'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在大型类层次结构中，子类需要调用基类的构造函数可能会变得繁琐，特别是当有许多参数和多个构造函数时。有时，最好的解决方案是完全避免构造函数，而是完全依赖对象初始化器在构造过程中设置字段或属性。为了帮助解决这个问题，您可以将字段或属性标记为`required`（来自C#
    11）：
- en: '[PRE287]'
  id: totrans-1305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: 'A required member *must* be populated via an object initializer when constructed:'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 必需成员在构造时必须通过对象初始化器填充：
- en: '[PRE288]'
  id: totrans-1307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: 'Should you wish to also write a constructor, you can apply the `[SetsRequiredMembers]`
    attribute to bypass the required member restriction for that constructor:'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望同时编写一个构造函数，您可以为该构造函数应用`[SetsRequiredMembers]`属性以绕过该构造函数的必需成员限制：
- en: '[PRE289]'
  id: totrans-1309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: Constructor and field initialization order
  id: totrans-1310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数和字段初始化顺序
- en: 'When an object is instantiated, initialization takes place in the following
    order:'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个对象被实例化时，初始化按照以下顺序进行：
- en: 'From subclass to base class:'
  id: totrans-1312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从子类到基类：
- en: Fields are initialized.
  id: totrans-1313
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字段被初始化。
- en: Arguments to base class constructor calls are evaluated.
  id: totrans-1314
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用基类构造函数调用的参数被评估。
- en: 'From base class to subclass:'
  id: totrans-1315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从基类到子类：
- en: Constructor bodies execute.
  id: totrans-1316
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数体执行。
- en: Inheritance with primary constructors
  id: totrans-1317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具有主构造函数的继承
- en: 'Classes with primary constructors can subclass with the following syntax:'
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 具有主构造函数的类可以使用以下语法进行子类化：
- en: '[PRE290]'
  id: totrans-1319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: Overloading and Resolution
  id: totrans-1320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重载和解析
- en: 'Inheritance has an interesting impact on method overloading. Consider the following
    two overloads:'
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: 继承对方法重载有着有趣的影响。考虑以下两个重载：
- en: '[PRE291]'
  id: totrans-1322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: 'When an overload is called, the most specific type has precedence:'
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用一个重载时，最具体的类型优先：
- en: '[PRE292]'
  id: totrans-1324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: 'The particular overload to call is determined statically (at compile time)
    rather than at runtime. The following code calls `Foo(Asset)`, even though the
    runtime type of `a` is `House`:'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 静态地（在编译时）而不是在运行时决定调用特定的重载。下面的代码调用`Foo(Asset)`，尽管`a`的运行时类型是`House`：
- en: '[PRE293]'
  id: totrans-1326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: Note
  id: totrans-1327
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you cast `Asset` to `dynamic` (see [“Dynamic Binding”](#dynamic_binding)),
    the decision as to which overload to call is deferred until runtime and is based
    on the object’s actual type.
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`Asset`转换为`dynamic`（参见[“动态绑定”](#dynamic_binding)），则决定调用哪个重载将推迟到运行时，并基于对象的实际类型进行选择。
- en: The object Type
  id: totrans-1329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象类型
- en: '`object` (`System.Object`) is the ultimate base class for all types. Any type
    can be implicitly upcast to `object`.'
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: '`object`（`System.Object`）是所有类型的最终基类。任何类型都可以隐式向上转型为`object`。'
- en: 'To illustrate how this is useful, consider a general-purpose *stack*. A stack
    is a data structure based on the principle of LIFO—“last in, first out.” A stack
    has two operations: *push* an object on the stack and *pop* an object off the
    stack. Here is a simple implementation that can hold up to 10 objects:'
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这对我们有用，考虑一个通用的*栈*。栈是一种基于LIFO原则的数据结构——“后进先出”。栈有两个操作：*push*将对象推入栈中和*pop*从栈中弹出对象。以下是一个简单的实现，可以容纳最多10个对象：
- en: '[PRE294]'
  id: totrans-1332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: 'Because `Stack` works with the object type, we can `Push` and `Pop` instances
    of *any type* to and from the `Stack`:'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Stack`使用的是对象类型，我们可以向`Stack`中`Push`和`Pop`任何类型的实例：
- en: '[PRE295]'
  id: totrans-1334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '`object` is a reference type, by virtue of being a class. Despite this, value
    types, such as `int`, can also be cast to and from `object`. To make this possible,
    the CLR must perform some special work to bridge the underlying differences between
    value and reference types. This process is called *boxing* and *unboxing*.'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: '`object`是一个引用类型，因为它是一个类。尽管如此，值类型（如`int`）也可以被转换为`object`并从`object`转换回来。为了实现这一点，CLR必须执行一些特殊工作来弥合值类型和引用类型之间的基本差异。这个过程称为*装箱*和*拆箱*。'
- en: Note
  id: totrans-1336
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In [“Generics”](#generics), we describe how to improve our `Stack` class to
    better handle stacks with same-typed elements.
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“泛型”](#generics)中，我们描述了如何改进我们的`Stack`类以更好地处理具有相同类型元素的堆栈。
- en: Boxing and Unboxing
  id: totrans-1338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装箱和拆箱
- en: 'Boxing is the act of casting a value type instance to a reference type instance.
    The reference type can be either the `object` class or an interface (see [“Interfaces”](#interfaces)).
    In this example, we box an `int` into an object:'
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 装箱是将值类型实例转换为引用类型实例的过程。引用类型可以是`object`类或一个接口（见[“接口”](#interfaces)）。在这个例子中，我们将一个`int`装箱为一个对象：
- en: '[PRE296]'
  id: totrans-1340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: 'Unboxing reverses the operation by casting the object back to the original
    value type:'
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: 拆箱通过将对象转换回原始值类型来逆转操作：
- en: '[PRE297]'
  id: totrans-1342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: 'Unboxing requires an explicit cast. The runtime checks that the stated value
    type matches the actual object type, throwing an `InvalidCastException` if the
    check fails. For instance, the following throws an exception because `long` does
    not exactly match `int`:'
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: 拆箱需要显式转换。运行时会检查声明的值类型是否与实际对象类型匹配，如果检查失败则抛出`InvalidCastException`异常。例如，以下代码因为`long`不能精确匹配`int`而抛出异常：
- en: '[PRE298]'
  id: totrans-1344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: 'The following succeeds, however:'
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 然而以下成功：
- en: '[PRE299]'
  id: totrans-1346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: 'As does this:'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于这里：
- en: '[PRE300]'
  id: totrans-1348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: In the last example, `(double)` performs an *unboxing*, and then `(int)` performs
    a *numeric conversion*.
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个例子中，`(double)`执行了*拆箱*操作，然后`(int)`执行了*数值转换*。
- en: 'Boxing *copies* the value type instance into the new object, and unboxing *copies*
    the contents of the object back into a value type instance:'
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: '*装箱*将值类型实例复制到新对象中，而*拆箱*将对象的内容复制回值类型实例：'
- en: '[PRE301]'
  id: totrans-1351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: Static and Runtime Type Checking
  id: totrans-1352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态和运行时类型检查
- en: C# checks types both statically (at compile time) and at runtime.
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: C#在静态（编译时）和运行时都检查类型。
- en: 'Static type checking enables the compiler to verify the correctness of your
    program without running it. The following code will fail because the compiler
    enforces static typing:'
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型检查使得编译器能够在运行程序之前验证其正确性。以下代码会因为编译器强制执行静态类型而失败：
- en: '[PRE302]'
  id: totrans-1355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: 'Runtime type checking is performed by the CLR when you downcast via a reference
    conversion or unboxing:'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过引用转换或拆箱进行向下转换时，CLR执行运行时类型检查：
- en: '[PRE303]'
  id: totrans-1357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: Runtime type checking is possible because each object on the heap internally
    stores a little type token. You can retrieve this token by calling the `GetType`
    method of `object`.
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时类型检查是可能的，因为堆上的每个对象内部都存储了一个小的类型标记。通过调用`object`的`GetType`方法可以检索此标记。
- en: The GetType Method and typeof Operator
  id: totrans-1359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GetType方法和typeof运算符
- en: 'All types in C# are represented at runtime with an instance of `System.Type`.
    There are two basic ways to get a `System.Type` object: call `GetType` on the
    instance or use the `typeof` operator on a type name. `GetType` is evaluated at
    runtime; `typeof` is evaluated statically at compile time.'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，所有类型在运行时都由`System.Type`的实例表示。获取`System.Type`对象有两种基本方式：对实例调用`GetType`方法或者在类型名称上使用`typeof`运算符。`GetType`在运行时评估；`typeof`在编译时静态评估。
- en: '`System.Type` has properties for such things as the type’s name, assembly,
    base type, and so on. For example:'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Type`具有诸如类型名称、程序集、基类型等属性。例如：'
- en: '[PRE304]'
  id: totrans-1362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '`System.Type` also has methods that act as a gateway to the runtime’s reflection
    model—we describe this fully in *C# 12 in a Nutshell*.'
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Type`还有一些方法作为运行时反射模型的入口，我们在*C# 12 in a Nutshell*中详细描述了这一点。'
- en: Object Member Listing
  id: totrans-1364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象成员列表
- en: 'Here are all the members of `object`:'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`object`的所有成员：
- en: '[PRE305]'
  id: totrans-1366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: Equals, ReferenceEquals, and GetHashCode
  id: totrans-1367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Equals、ReferenceEquals和GetHashCode
- en: 'The `Equals` method in the `object` class is similar to the `==` operator except
    that `Equals` is virtual, whereas `==` is static. The following example illustrates
    the difference:'
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: '`object`类中的`Equals`方法与`==`操作符类似，但`Equals`是虚拟的，而`==`是静态的。以下示例说明了它们的区别：'
- en: '[PRE306]'
  id: totrans-1369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: Because `x` and `y` have been cast to the `object` type, the compiler statically
    binds to `object`’s `==` operator, which uses *reference type* semantics to compare
    two instances. (And because `x` and `y` are boxed, they are represented in separate
    memory locations and so are unequal.) The virtual `Equals` method, however, defers
    to the `Int32` type’s `Equals` method, which uses *value type* semantics in comparing
    two values.
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`x`和`y`已转换为`object`类型，编译器静态绑定到`object`的`==`操作符，它使用*引用类型*语义来比较两个实例。（并且因为`x`和`y`被装箱，它们被表示在不同的内存位置，因此是不相等的。）然而，虚拟的`Equals`方法会委托给`Int32`类型的`Equals`方法，在比较两个值时使用*值类型*语义。
- en: 'The static `object.Equals` method simply calls the virtual `Equals` method
    on the first argument—after checking that the arguments are not null:'
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的`object.Equals`方法简单地调用第一个参数的虚拟`Equals`方法，之前会检查参数不为null：
- en: '[PRE307]'
  id: totrans-1372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '`ReferenceEquals` forces a reference type equality comparison (this is occasionally
    useful on reference types for which the `==` operator has been overloaded to do
    otherwise).'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReferenceEquals`强制进行引用类型的相等比较（在一些重载了`==`操作符的引用类型中，偶尔会有用）。'
- en: '`GetHashCode` emits a hash code suitable for use with hashtable-based dictionaries
    such as `System.Collections.Generic.Dictionary` and `System.Collections.Hashtable`.'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetHashCode`生成适用于基于哈希表的字典（如`System.Collections.Generic.Dictionary`和`System.Collections.Hashtable`）的哈希码。'
- en: To customize a type’s equality semantics, you must at a minimum override `Equals`
    and `GetHashCode`. You would also usually overload the `==` and `!=` operators.
    For an example of how to do both, see [“Operator Overloading”](#operator_overloading).
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 要自定义类型的相等语义，至少必须重写`Equals`和`GetHashCode`方法。通常还会重载`==`和`!=`运算符。有关如何执行这两者的示例，请参见[“运算符重载”](#operator_overloading)。
- en: The ToString Method
  id: totrans-1376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ToString方法
- en: 'The `ToString` method returns the default textual representation of a type
    instance. The `ToString` method is overridden by all built-in types:'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToString`方法返回类型实例的默认文本表示。所有内置类型都会重写`ToString`方法：'
- en: '[PRE308]'
  id: totrans-1378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: 'You can override the `ToString` method on custom types as follows:'
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按如下方式重写自定义类型的`ToString`方法：
- en: '[PRE309]'
  id: totrans-1380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: Structs
  id: totrans-1381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体
- en: 'A *struct* is similar to a class, with the following key differences:'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: '*结构体*类似于类，但具有以下关键区别：'
- en: A struct is a value type, whereas a class is a reference type.
  id: totrans-1383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体是一个值类型，而类是一个引用类型。
- en: A struct does not support inheritance (other than implicitly deriving from `object`,
    or more precisely, `System.ValueType`).
  id: totrans-1384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体不支持继承（除了隐式从`object`或更确切地说是`System.ValueType`派生）。
- en: A struct can have all the members that a class can, except for a finalizer,
    and virtual or protected members.
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 一个结构体可以拥有类似于类的所有成员，但不能有析构函数、虚拟或受保护成员。
- en: Warning
  id: totrans-1386
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Prior to C# 10, structs were further prohibited from defining field initializers
    and parameterless constructors. Although this prohibition has now been relaxed—primarily
    for the benefit of record structs (see [“Records”](#records))—it’s worth thinking
    carefully before defining these constructs, as they can result in confusing behavior
    that we’ll describe in [“Struct Construction Semantics”](#struct_construction_semantics).
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 10之前，结构体进一步禁止定义字段初始化程序和无参数构造函数。尽管现在这种禁止已经放宽，主要是为了记录结构体的利益（参见[“记录”](#records)），但在定义这些构造函数之前值得仔细考虑，因为它们可能导致混乱的行为，我们将在[“结构体构造语义”](#struct_construction_semantics)中描述。
- en: A struct is appropriate when value type semantics are desirable. Good examples
    are numeric types, where it is more natural for assignment to copy a value rather
    than a reference. Because a struct is a value type, each instance does not require
    instantiation of an object on the heap (and subsequent collection); this can incur
    useful savings when you’re creating many instances of a type.
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要值类型语义时，结构体是合适的选择。良好的示例是数值类型，其中赋值复制值而不是引用更为自然。因为结构体是值类型，每个实例不需要在堆上实例化对象（以及随后的收集）；在创建许多类型实例时，这可以节省有用的开销。
- en: 'As with any value type, a struct can end up on the heap indirectly, either
    through boxing or by appearing as a field in a class. If we were to instantiate
    `SomeClass` in the following example, field `Y` would refer to a struct on the
    heap:'
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何值类型一样，结构体可以间接地最终出现在堆上，通过装箱或者作为类中字段的一部分。如果我们在以下示例中实例化`SomeClass`，字段`Y`将引用堆上的一个结构体：
- en: '[PRE310]'
  id: totrans-1390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: Similarly, if you were to declare an array of `SomeStruct`, the instance would
    reside on the heap (because arrays are reference types), although the entire array
    would require only a single memory allocation.
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，如果您声明了一个`SomeStruct`的数组，该实例将位于堆上（因为数组是引用类型），尽管整个数组只需要单个内存分配。
- en: From C# 7.2, you can apply the `ref` modifier to a struct to ensure that it
    can be used only in ways that will place it on the stack. This enables further
    compiler optimizations as well as allowing for the [`Span<T>` type](https://oreil.ly/kCark).
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 7.2开始，您可以将`ref`修饰符应用于结构体，以确保它只能以将其放置在堆栈上的方式使用。这不仅能够进一步优化编译器，还允许使用[`Span<T>`类型](https://oreil.ly/kCark)。
- en: Struct Construction Semantics
  id: totrans-1393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构体构造语义
- en: Note
  id: totrans-1394
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Prior to C# 11, every field in a struct had to be explicitly assigned in the
    constructor (or field initializer). This restriction has now been relaxed.
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 11之前，结构体中的每个字段都必须在构造函数（或字段初始化程序）中显式赋值。现在这个限制已经放宽。
- en: 'In addition to any constructors that you define, a struct always has an implicit
    parameterless constructor that performs a bitwise-zeroing of its fields (setting
    them to their default values):'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: 除了您定义的任何构造函数外，结构体始终具有一个隐式的无参数构造函数，该构造函数对其字段执行位清零操作（将它们设置为它们的默认值）：
- en: '[PRE311]'
  id: totrans-1397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: 'Even when you define a parameterless constructor of your own, the implicit
    parameterless constructor still exists, and it can be accessed via the `default`
    keyword:'
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您定义了自己的无参数构造函数，隐式的无参数构造函数仍然存在，并且可以通过`default`关键字访问：
- en: '[PRE312]'
  id: totrans-1399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: 'In this example, we initialized `x` to 1 via a field initializer, and we initialized
    `y` to 1 via the parameterless constructor. And yet with the `default` keyword,
    we were still able to create a `Point` that bypassed both initializations. The
    default constructor can be accessed other ways, too, as the following example
    illustrates:'
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们通过字段初始化器将`x`初始化为1，通过无参数构造函数将`y`初始化为1。然而，使用`default`关键字，我们仍然能够创建一个绕过这两个初始化的`Point`。默认构造函数也可以通过其他方式访问，正如下面的例子所示：
- en: '[PRE313]'
  id: totrans-1401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: A good strategy with structs is to design them such that their `default` value
    is a valid state, thereby making initialization redundant.
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 对于结构体，一个好的策略是设计它们的`default`值是一个有效状态，从而使初始化变得多余。
- en: readonly Structs and Functions
  id: totrans-1403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 只读结构体和函数
- en: 'You can apply the `readonly` modifier to a struct to enforce that all fields
    are `readonly`; this aids in declaring intent as well as allowing the compiler
    more optimization freedom:'
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`readonly`修饰符应用于结构体，以强制所有字段都是`readonly`；这有助于声明意图，并允许编译器更多优化自由度：
- en: '[PRE314]'
  id: totrans-1405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: 'If you need to apply `readonly` at a more granular level, you can apply the
    `readonly` modifier (from C# 8) to a struct’s *functions*. This ensures that if
    the function attempts to modify any field, a compile-time error is generated:'
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在更精细的层次上应用`readonly`，可以将`readonly`修饰符（从C# 8开始）应用于结构的*函数*。这样可以确保如果函数尝试修改任何字段，将生成编译时错误：
- en: '[PRE315]'
  id: totrans-1407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: If a `readonly` function calls a non-`readonly` function, the compiler generates
    a warning (and defensively copies the struct to avoid the possibility of a mutation).
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个`readonly`函数调用一个非`readonly`函数，编译器会生成警告（并防御性地复制结构体，以避免突变的可能性）。
- en: Access Modifiers
  id: totrans-1409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问修饰符
- en: 'To promote encapsulation, a type or type member can limit its *accessibility*
    to other types and other assemblies by adding an *access modifier* to the declaration:'
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 为了促进封装性，类型或类型成员可以通过在声明中添加*访问修饰符*来限制其对其他类型和其他程序集的*可访问性*：
- en: '`public`'
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: '`public`'
- en: Fully accessible. This is the implicit accessibility for members of an enum
    or interface.
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 完全可访问。这是枚举或接口成员的隐式可访问性。
- en: '`internal`'
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: '`internal`'
- en: Accessible only within the containing assembly or friend assemblies. This is
    the default accessibility for non-nested types.
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 只能在包含的程序集或友元程序集中访问。这是非嵌套类型的默认可访问性。
- en: '`private`'
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: '`private`'
- en: Accessible only within the containing type. This is the default accessibility
    for members of a class or struct.
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 只能在包含类型内部访问。这是类或结构体成员的默认可访问性。
- en: '`protected`'
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: '`protected`'
- en: Accessible only within the containing type or subclasses.
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 只能在包含类型或子类中访问。
- en: '`protected internal`'
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: '`protected internal`'
- en: The *union* of `protected` and `internal` accessibility (this is more *permissive*
    than `protected` or `internal` alone in that it makes a member more accessible
    in two ways).
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: '`protected`和`internal`可访问性的*并集*（这比单独的`protected`或`internal`更*宽松*，因为它使成员在两个方面更易访问）。'
- en: '`private protected`'
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: '`private protected`'
- en: The *intersection* of `protected` and `internal` accessibility (this is more
    *restrictive* than `protected` or `internal` alone).
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: '`protected`和`internal`可访问性的*交集*（这比单独的`protected`或`internal`更*严格*）。'
- en: '`file` (from C# 11)'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: '`file`（从C# 11开始）'
- en: Accessible only from within the same file. Intended for use by *source generators*
    (see [“Extended partial methods”](#extended_partial_methods)). This modifier can
    be applied only to type declarations.
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: 只能从同一文件内部访问。用于源代码生成器（见[“扩展局部方法”](#extended_partial_methods)）。此修饰符只能应用于类型声明。
- en: 'In the following example, `Class2` is accessible from outside its assembly;
    `Class1` is not:'
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`Class2`可以从其所在的程序集外部访问；`Class1`则不行：
- en: '[PRE316]'
  id: totrans-1426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '`ClassB` exposes field `x` to other types in the same assembly; `ClassA` does
    not:'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClassB`将字段`x`公开给同一程序集中的其他类型；`ClassA`则不会：'
- en: '[PRE317]'
  id: totrans-1428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: When you’re overriding a base class function, accessibility must be identical
    on the overridden function. The compiler prevents any inconsistent use of access
    modifiers—for example, a subclass itself can be less accessible than a base class
    but not more.
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: 当您覆盖基类函数时，覆盖函数的可访问性必须相同。编译器阻止使用访问修饰符的不一致使用，例如，子类本身可以比基类不可访问，但不能更可访问。
- en: Friend Assemblies
  id: totrans-1430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 友元程序集
- en: 'You can expose `internal` members to other *friend* assemblies by adding the
    `System.Runtime.CompilerServices.InternalsVisibleTo` assembly attribute, specifying
    the name of the friend assembly as follows:'
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过添加`System.Runtime.CompilerServices.InternalsVisibleTo`程序集属性，指定友元程序集的名称，来将`internal`成员暴露给其他*友元*程序集：
- en: '[PRE318]'
  id: totrans-1432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: If the friend assembly is signed with a strong name, you must specify its *full*
    160-byte public key. You can extract this key via a Language Integrated Query
    (LINQ)—an interactive example is given in LINQPad’s free sample library for *C#
    12 in a Nutshell*, under Chapter 3, “Access Modifiers.”
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 如果友元程序集使用强名称签名，您必须指定其*完整*的160字节公钥。您可以通过语言集成查询（LINQ）提取此密钥—可以在LINQPad的* C# 12
    简明教程*的第3章“访问修饰符”中的免费示例库中找到交互式示例。
- en: Accessibility Capping
  id: totrans-1434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可访问性封装
- en: 'A type caps the accessibility of its declared members. The most common example
    of capping is when you have an `internal` type with `public` members. For example:'
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: 类型限制其声明成员的可访问性。最常见的封装示例是当您有一个带有`public`成员的`internal`类型时。例如：
- en: '[PRE319]'
  id: totrans-1436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '`C`’s (default) `internal` accessibility caps `Foo`’s accessibility, effectively
    making `Foo internal`. A common reason `Foo` would be marked `public` is to make
    for easier refactoring, should `C` later be changed to `public`.'
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: '`C`的（默认）`internal`可访问性限制了`Foo`的可访问性，从效果上讲使得`Foo`是`internal`。将`Foo`标记为`public`的常见原因是为了更轻松地进行重构，如果以后将`C`更改为`public`。'
- en: Interfaces
  id: totrans-1438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: 'An *interface* is similar to a class but only *specifies behavior* and does
    not hold state (data). Consequently:'
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: '*接口*类似于类，但仅*指定行为*而不保存状态（数据）。因此：'
- en: Interface members are *all implicitly abstract*. (There are exceptions to this
    rule that we will describe in [“Default Interface Members”](#default_interface_members)
    and [“Static Interface Members”](#static_interface_members).)
  id: totrans-1440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口成员都是*隐式抽象*的。（有一些例外情况，我们将在[“默认接口成员”](#default_interface_members)和[“静态接口成员”](#static_interface_members)中描述。）
- en: A class (or struct) can implement *multiple* interfaces. In contrast, a class
    can inherit from only a *single* class, and a struct cannot inherit at all (aside
    from deriving from `System.ValueType`).
  id: totrans-1441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类（或结构）可以实现*多个*接口。相比之下，类只能从*单个*类继承，结构不能继承（除了从`System.ValueType`派生）。
- en: An interface declaration is like a class declaration, but it (normally) provides
    no implementation for its members, because all its members are implicitly abstract.
    These members will be implemented by the classes and structs that implement the
    interface. An interface can contain only methods, properties, events, and indexers,
    which not coincidentally are precisely the members of a class that can be abstract.
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: 接口声明类似于类声明，但它（通常）不为其成员提供实现，因为其所有成员都是隐式抽象的。这些成员将由实现接口的类和结构实现。接口只能包含方法、属性、事件和索引器，这不是巧合，这些成员恰好是类的成员可以是抽象的。
- en: 'Here is a slightly simplified version of the `IEnumerator` interface, defined
    in `System.Collections`:'
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`System.Collections`中定义的`IEnumerator`接口的稍微简化版本：
- en: '[PRE320]'
  id: totrans-1444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: 'Interface members are always implicitly public and cannot declare an access
    modifier. Implementing an interface means providing a `public` implementation
    for all of its members:'
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: 接口成员始终隐式公共，并且不能声明访问修饰符。实现接口意味着为其所有成员提供一个`public`实现：
- en: '[PRE321]'
  id: totrans-1446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: 'You can implicitly cast an object to any interface that it implements:'
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将对象隐式转换为其实现的任何接口：
- en: '[PRE322]'
  id: totrans-1448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: Extending an Interface
  id: totrans-1449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展一个接口
- en: 'Interfaces can derive from other interfaces. For instance:'
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: 接口可以派生自其他接口。例如：
- en: '[PRE323]'
  id: totrans-1451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '`IRedoable` “inherits” all the members of `IUndoable`.'
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: '`IRedoable`“继承”了`IUndoable`的所有成员。'
- en: Explicit Interface Implementation
  id: totrans-1453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式接口实现
- en: 'Implementing multiple interfaces can sometimes result in a collision between
    member signatures. You can resolve such collisions by *explicitly implementing*
    an interface member. For example:'
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: 实现多个接口有时会导致成员签名冲突。您可以通过*显式实现*接口成员来解决这种冲突。例如：
- en: '[PRE324]'
  id: totrans-1455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: 'Because both `I1` and `I2` have conflicting `Foo` signatures, `Widget` explicitly
    implements `I2`’s `Foo` method. This lets the two methods coexist in one class.
    The only way to call an explicitly implemented member is to cast to its interface:'
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`I1`和`I2`都具有冲突的`Foo`签名，所以`Widget`显式实现了`I2`的`Foo`方法。这样可以让这两个方法在同一个类中共存。调用显式实现的成员的唯一方法是将其转换为其接口：
- en: '[PRE325]'
  id: totrans-1457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: Another reason to explicitly implement interface members is to hide members
    that are highly specialized and distracting to a type’s normal use case. For example,
    a type that implements `ISerializable` would typically want to avoid flaunting
    its `ISerializable` members unless explicitly cast to that interface.
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: 显式实现接口成员的另一个原因是隐藏高度专业化且对类型正常使用案例有干扰的成员。例如，实现`ISerializable`的类型通常希望避免在未明确转换为该接口时展示其`ISerializable`成员。
- en: Implementing Interface Members Virtually
  id: totrans-1459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟实现接口成员
- en: 'An implicitly implemented interface member is, by default, sealed. It must
    be marked `virtual` or `abstract` in the base class in order to be overridden:
    calling the interface member through either the base class or the interface then
    calls the subclass’s implementation.'
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式实现的接口成员默认为密封的。必须在基类中将其标记为`virtual`或`abstract`以便重写：通过基类或接口调用接口成员然后调用子类的实现。
- en: An explicitly implemented interface member cannot be marked `virtual`, nor can
    it be overridden in the usual manner. It can, however, be *reimplemented*.
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: 显式实现的接口成员不能标记为`virtual`，也不能以通常的方式重写。但是可以*重新实现*。
- en: Reimplementing an Interface in a Subclass
  id: totrans-1462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在子类中重新实现接口
- en: A subclass can *reimplement* any interface member already implemented by a base
    class. Reimplementation hijacks a member implementation (when called through the
    interface) and works whether or not the member is `virtual` in the base class.
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: 子类可以*重新实现*任何已由基类实现的接口成员。重新实现会劫持成员实现（通过接口调用时），无论成员在基类中是否为`virtual`都有效。
- en: 'In the following example, `TextBox` implements `IUndoable.Undo` explicitly,
    and so it cannot be marked as `virtual`. To “override” it, `RichTextBox` must
    reimplement `IUndoable`’s `Undo` method:'
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`TextBox`显式实现了`IUndoable.Undo`，因此不能标记为`virtual`。要“覆盖”它，`RichTextBox`必须重新实现`IUndoable`的`Undo`方法：
- en: '[PRE326]'
  id: totrans-1465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: 'Calling the reimplemented member through the interface calls the subclass’s
    implementation:'
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: 通过接口调用重新实现的成员会调用子类的实现：
- en: '[PRE327]'
  id: totrans-1467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: 'In this case, `TextBox` implements the `Undo` method explicitly. If `TextBox`
    instead implemented the `Undo` method implicitly, `RichTextBox` could still reimplement
    the method, but the effects would be nonpervasive in that calling the member through
    the base class would invoke the base implementation:'
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`TextBox`显式实现了`Undo`方法。如果`TextBox`改为隐式实现`Undo`方法，则`RichTextBox`仍然可以重新实现该方法，但在通过基类调用成员时，效果不会普遍：
- en: '[PRE328]'
  id: totrans-1469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: Default Interface Members
  id: totrans-1470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认接口成员
- en: 'From C# 8, you can add a default implementation to an interface member, making
    it optional to implement:'
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 8开始，您可以为接口成员添加默认实现，使其成为可选实现：
- en: '[PRE329]'
  id: totrans-1472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: This is advantageous if you wish to add a member to an interface defined in
    a popular library without breaking (potentially thousands of) implementations.
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望在流行库中定义的接口中添加成员而不破坏（可能有数千个）实现，则这是有利的。
- en: 'Default implementations are always explicit, so if a class implementing `ILogger`
    fails to define a `Log` method, the only way to call it is through the interface:'
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 默认实现始终是显式的，因此如果实现`ILogger`的类未定义`Log`方法，则唯一调用它的方法是通过接口：
- en: '[PRE330]'
  id: totrans-1475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: 'This prevents a problem of multiple implementation inheritance: if the same
    default member is added to two interfaces that a class implements, there is never
    an ambiguity as to which member is called.'
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以防止多重实现继承的问题：如果将同一个默认成员添加到一个类实现的两个接口中，那么调用成员时不会存在歧义。
- en: Static Interface Members
  id: totrans-1477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态接口成员
- en: 'An interface can also declare static members. There are two kinds of static
    interface members:'
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: 接口还可以声明静态成员。有两种类型的静态接口成员：
- en: Static nonvirtual interface members
  id: totrans-1479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态非虚拟接口成员
- en: Static virtual/abstract interface members
  id: totrans-1480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态虚拟/抽象接口成员
- en: Static nonvirtual interface members
  id: totrans-1481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态非虚拟接口成员
- en: 'Static nonvirtual interface members exist mainly to help with writing default
    interface members. They are not implemented by classes or structs; instead, they
    are consumed directly. Along with methods, properties, events, and indexers, static
    nonvirtual members permit fields, which are typically accessed from code inside
    default member implementations:'
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: 静态非虚拟接口成员主要用于帮助编写默认接口成员。它们不由类或结构体实现；而是直接使用。除了方法、属性、事件和索引器之外，静态非虚拟成员还允许字段，这些字段通常从默认成员实现中的代码访问：
- en: '[PRE331]'
  id: totrans-1483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: 'Static nonvirtual interface members are public by default, so they can be accessed
    from the outside:'
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: 静态非虚拟接口成员默认为公共，因此可以从外部访问：
- en: '[PRE332]'
  id: totrans-1485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: You can restrict this by adding an accessibility modifier (such as `private`,
    `protected`, or `internal`).
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过添加访问修饰符（例如`private`、`protected`或`internal`）来限制此功能。
- en: Instance fields are (still) prohibited. This is in line with the principle of
    interfaces, which is to define *behavior*, not *state*.
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: 实例字段（仍然）被禁止。这符合接口的原则，即定义*行为*而非*状态*。
- en: Static virtual/abstract interface members
  id: totrans-1488
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态虚拟/抽象接口成员
- en: 'Static virtual/abstract interface members (from C# 11) are marked with `static
    abstract` or `static virtual` and enable *static polymorphism*, an advanced feature
    that we will discuss fully in [“Static Polymorphism”](#static_polymorphism):'
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: 静态虚拟/抽象接口成员（来自C# 11）标记为`static abstract`或`static virtual`，并启用*静态多态性*，这是我们将在[“静态多态性”](#static_polymorphism)中全面讨论的高级特性：
- en: '[PRE333]'
  id: totrans-1490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: 'An implementing class or struct must implement static abstract members and
    can optionally implement static virtual members:'
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: 实现类或结构必须实现静态抽象成员，并可选择实现静态虚拟成员：
- en: '[PRE334]'
  id: totrans-1492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: In addition to methods, properties, and events, operators and conversions are
    also legal targets for static virtual interface members (see [“Operator Overloading”](#operator_overloading)).
    Static virtual interface members are called through a constrained type parameter;
    we will demonstrate this in [“Static Polymorphism”](#static_polymorphism) and
    [“Generic Math”](#generic_math), after covering generics.
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: 除了方法、属性和事件之外，运算符和转换也是静态虚拟接口成员的合法目标（参见[“运算符重载”](#operator_overloading)）。静态虚拟接口成员通过约束的类型参数调用；我们将在[“静态多态性”](#static_polymorphism)和[“泛型数学”](#generic_math)中演示这一点，之后会讨论泛型。
- en: Enums
  id: totrans-1494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: 'An *enum* is a special value type that lets you specify a group of named numeric
    constants. For example:'
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: '*枚举*是一种特殊的值类型，允许您指定一组命名的数字常量。例如：'
- en: '[PRE335]'
  id: totrans-1496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: 'We can use this enum type as follows:'
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下使用这种枚举类型：
- en: '[PRE336]'
  id: totrans-1498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: 'Each enum member has an underlying integral-type value. By default, the underlying
    values are of type `int`, and the enum members are assigned the constants `0`,
    `1`, `2`... (in their declaration order). You may specify an alternative integral
    type, as follows:'
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: 每个枚举成员都有一个基础的整数类型值。默认情况下，基础值的类型为`int`，枚举成员被分配为常量`0`、`1`、`2`...（按其声明顺序）。您可以指定另一种整数类型，如下所示：
- en: '[PRE337]'
  id: totrans-1500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: 'You may also specify an explicit integer value for each member:'
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以为每个成员指定显式整数值：
- en: '[PRE338]'
  id: totrans-1502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: 'The compiler also lets you explicitly assign *some* of the enum members. The
    unassigned enum members keep incrementing from the last explicit value. The preceding
    example is equivalent to:'
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器还允许您显式分配*一些*枚举成员。未分配的枚举成员从最后一个显式值递增。前面的示例等效于：
- en: '[PRE339]'
  id: totrans-1504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: Enum Conversions
  id: totrans-1505
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举转换
- en: 'You can convert an `enum` instance to and from its underlying integral value
    with an explicit cast:'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用显式转换将`enum`实例转换为其基础整数值，反之亦然：
- en: '[PRE340]'
  id: totrans-1507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: You can also explicitly cast one enum type to another; the translation then
    uses the members’ underlying integral values.
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将一种枚举类型明确转换为另一种；翻译将使用成员的基础整数值。
- en: 'The numeric literal `0` is treated specially in that it does not require an
    explicit cast:'
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 数字文字`0`在特殊处理中不需要显式转换：
- en: '[PRE341]'
  id: totrans-1510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: 'In this particular example, `BorderSide` has no member with an integer value
    of `0`. This does not generate an error: a limitation of enums is that the compiler
    and CLR do not prevent the assignment of integrals whose values fall outside the
    range of members:'
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: 在此特定示例中，`BorderSide`没有具有整数值`0`的成员。这不会生成错误：枚举的限制是，编译器和CLR不会阻止分配超出成员范围的整数值：
- en: '[PRE342]'
  id: totrans-1512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: Flags Enums
  id: totrans-1513
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标志枚举
- en: 'You can combine enum members. To prevent ambiguities, members of a combinable
    enum require explicitly assigned values, typically in powers of two. For example:'
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以组合枚举成员。为了避免歧义，可组合枚举的成员需要显式分配的值，通常是二的幂次方。例如：
- en: '[PRE343]'
  id: totrans-1515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: 'By convention, a combinable enum type is given a plural rather than singular
    name. To work with combined enum values, you use bitwise operators, such as `|`
    and `&`. These operate on the underlying integral values:'
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: 根据惯例，可组合的枚举类型应该使用复数而不是单数名称。要使用组合枚举值，您可以使用按位操作符，例如`|`和`&`。这些操作符适用于基础整数值：
- en: '[PRE344]'
  id: totrans-1517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: The `Flags` attribute should be applied to combinable enum types; if you fail
    to do this, calling `ToString` on an `enum` instance emits a number rather than
    a series of names.
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可组合的枚举类型，应将`Flags`属性应用于其上；如果未执行此操作，则在`enum`实例上调用`ToString`会输出数字而不是一系列名称。
- en: 'For convenience, you can include combination members within an enum declaration
    itself:'
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: 为方便起见，您可以在枚举声明本身中包含组合成员：
- en: '[PRE345]'
  id: totrans-1520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: Enum Operators
  id: totrans-1521
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举操作符
- en: 'The operators that work with enums are:'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: 适用于枚举的操作符包括：
- en: '[PRE346]'
  id: totrans-1523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: The bitwise, arithmetic, and comparison operators return the result of processing
    the underlying integral values. Addition is permitted between an enum and an integral
    type, but not between two enums.
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: 按位、算术和比较操作符返回处理基础整数值的结果。枚举与整数类型之间允许进行加法运算，但不允许两个枚举之间进行加法运算。
- en: Nested Types
  id: totrans-1525
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套类型
- en: 'A *nested type* is declared within the scope of another type. For example:'
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: '*嵌套类型* 声明在另一个类型的范围内。例如：'
- en: '[PRE347]'
  id: totrans-1527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: 'A nested type has the following features:'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套类型具有以下特征：
- en: It can access the enclosing type’s private members and everything else the enclosing
    type can access.
  id: totrans-1529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以访问封闭类型的私有成员以及封闭类型可以访问的其他所有内容。
- en: It can be declared with the full range of access modifiers, rather than just
    `public` and `internal`.
  id: totrans-1530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以声明具有全范围访问修饰符，而不仅限于 `public` 和 `internal`。
- en: The default accessibility for a nested type is `private` rather than `internal`.
  id: totrans-1531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套类型的默认可访问性是 `private` 而不是 `internal`。
- en: Accessing a nested type from outside the enclosing type requires qualification
    with the enclosing type’s name (like when you’re accessing static members).
  id: totrans-1532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从封闭类型外部访问嵌套类型需要使用封闭类型名称进行限定（就像访问静态成员时一样）。
- en: 'For example, to access `Color.Red` from outside our `TopLevel` class, you’d
    need to do this:'
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要从我们的 `TopLevel` 类外部访问 `Color.Red`，你需要这样做：
- en: '[PRE348]'
  id: totrans-1534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: All types can be nested; however, only classes and structs can nest.
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类型都可以嵌套；但是，只有类和结构可以嵌套。
- en: Generics
  id: totrans-1536
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型
- en: 'C# has two separate mechanisms for writing code that are reusable across different
    types: *inheritance* and *generics*. Whereas inheritance expresses reusability
    with a base type, generics express reusability with a “template” that contains
    “placeholder” types. Generics, when compared to inheritance, can *increase type
    safety* and *reduce casting and boxing*.'
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: C# 有两种分离的机制用于编写可在不同类型间重复使用的代码：*继承* 和 *泛型*。继承通过基类型表达重用性，而泛型通过包含“占位符”类型的“模板”表达重用性。与继承相比，泛型可以
    *增加类型安全性* 和 *减少强制转换和装箱*。
- en: Generic Types
  id: totrans-1538
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型类型
- en: 'A *generic type* declares *type parameters*—placeholder types to be filled
    in by the consumer of the generic type, which supplies the *type arguments*. Here
    is a generic type, `Stack<T>`, designed to stack instances of type `T`. `Stack<T>`
    declares a single type parameter `T`:'
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: '*泛型类型* 声明 *类型参数* —— 消费泛型类型的内容提供 *类型参数*。这是一个泛型类型 `Stack<T>`，设计用于堆叠类型为 `T` 的实例。`Stack<T>`
    声明了一个类型参数 `T`：'
- en: '[PRE349]'
  id: totrans-1540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: 'We can use `Stack<T>` as follows:'
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下使用 `Stack<T>`：
- en: '[PRE350]'
  id: totrans-1542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: Note
  id: totrans-1543
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that no downcasts are required in the last two lines, avoiding the possibility
    of a runtime error and eliminating the overhead of boxing/unboxing. This makes
    our generic stack superior to a nongeneric stack that uses `object` in place of
    `T` (see [“The object Type”](#the_object_type) for an example).
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在最后两行不需要向下转换，避免了运行时错误的可能性并消除了装箱/拆箱的开销。这使得我们的泛型栈优于使用 `object` 替代 `T` 的非泛型栈（参见[“对象类型”](#the_object_type)的示例）。
- en: '`Stack<int>` fills in the type parameter `T` with the type argument `int`,
    implicitly creating a type on the fly (the synthesis occurs at runtime). `Stack<int>`
    effectively has the following definition (substitutions appear in bold, with the
    class name hashed out to avoid confusion):'
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stack<int>` 在类型参数 `T` 中填充了类型参数 `int`，隐式地在运行时创建了一个类型（综合在运行时发生）。`Stack<int>`
    的定义如下（替换项以粗体显示，为了避免混淆，类名已经被隐藏）：'
- en: '[PRE351]'
  id: totrans-1546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: Technically, we say that `Stack<T>` is an *open type*, whereas `Stack<int>`
    is a *closed type*. At runtime, all generic type instances are closed—with the
    placeholder types filled in.
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，我们称 `Stack<T>` 是一个 *开放类型*，而 `Stack<int>` 是一个 *闭合类型*。在运行时，所有泛型类型实例都是闭合的，占位符类型已填充。
- en: Generic Methods
  id: totrans-1548
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型方法
- en: 'A *generic method* declares type parameters within the signature of a method.
    With generic methods, many fundamental algorithms can be implemented in a general-purpose
    way. Here is a generic method that swaps the contents of two variables of any
    type `T`:'
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: '*泛型方法* 在方法的签名中声明类型参数。通过泛型方法，可以以通用方式实现许多基本算法。这是一个交换任意类型 `T` 变量内容的泛型方法示例：'
- en: '[PRE352]'
  id: totrans-1550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: 'You can use `Swap<T>` as follows:'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以如下使用 `Swap<T>`：
- en: '[PRE353]'
  id: totrans-1552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: 'Generally, there is no need to supply type arguments to a generic method, because
    the compiler can implicitly infer the type. If there is ambiguity, generic methods
    can be called with the type arguments as follows:'
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，不需要为泛型方法提供类型参数，因为编译器可以隐式推断类型。如果存在歧义，泛型方法可以如下调用带有类型参数：
- en: '[PRE354]'
  id: totrans-1554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: Within a generic *type*, a method is not classed as generic unless it *introduces*
    type parameters (with the angle bracket syntax). The `Pop` method in our generic
    stack merely consumes the type’s existing type parameter, `T`, and is not classed
    as a generic method.
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: 在泛型 *类型* 中，除非以尖括号语法 *引入* 类型参数，否则方法不被视为泛型方法。在我们的泛型栈中，`Pop` 方法仅消耗类型的现有类型参数 `T`，并不被视为泛型方法。
- en: 'Methods and types are the only constructs that can introduce type parameters.
    Properties, indexers, events, fields, constructors, operators, and so on cannot
    declare type parameters, although they can partake in any type parameters already
    declared by their enclosing type. In our generic stack example, for instance,
    we could write an indexer that returns a generic item:'
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: 方法和类型是唯一可以引入类型参数的构造。属性、索引器、事件、字段、构造函数、操作符等不能声明类型参数，尽管它们可以参与其封闭类型已声明的任何类型参数。例如，在我们的通用堆栈示例中，我们可以编写一个返回通用项的索引器：
- en: '[PRE355]'
  id: totrans-1557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: Similarly, constructors can partake in existing type parameters but cannot *introduce*
    them.
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，构造函数可以参与现有的类型参数，但不能*引入*它们。
- en: Declaring Type Parameters
  id: totrans-1559
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明类型参数
- en: 'Type parameters can be introduced in the declaration of classes, structs, interfaces,
    delegates (see [“Delegates”](#delegates)), and methods. You can specify multiple
    type parameters by separating them with commas:'
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: 类型参数可以在类、结构、接口、委托（参见[“委托”](#delegates)）和方法的声明中引入。您可以通过逗号分隔它们来指定多个类型参数：
- en: '[PRE356]'
  id: totrans-1561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: 'To instantiate:'
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化：
- en: '[PRE357]'
  id: totrans-1563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: 'Generic type names and method names can be overloaded as long as the number
    of type parameters differs. For example, the following three type names do not
    conflict:'
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型名称和方法名称可以重载，只要类型参数的数量不同即可。例如，以下三个类型名称不会冲突：
- en: '[PRE358]'
  id: totrans-1565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: Note
  id: totrans-1566
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: By convention, generic types and methods with a *single* type parameter name
    their parameter `T`, as long as the intent of the parameter is clear. With *multiple*
    type parameters, each parameter has a more descriptive name (prefixed by `T`).
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，具有*单一*类型参数的泛型类型和方法将其参数命名为 `T`，只要参数的意图清楚即可。对于*多个*类型参数，每个参数都有一个更具描述性的名称（以
    `T` 为前缀）。
- en: typeof and Unbound Generic Types
  id: totrans-1568
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`typeof` 和未绑定的泛型类型'
- en: 'Open generic types do not exist at runtime: open generic types are closed as
    part of compilation. However, it is possible for an *unbound* generic type to
    exist at runtime—purely as a `Type` object. The only way to specify an unbound
    generic type in C# is with the `typeof` operator:'
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: 开放的泛型类型在运行时不存在：开放的泛型类型作为编译的一部分被关闭。然而，未绑定的泛型类型可以在运行时存在——纯粹作为一个 `Type` 对象。在 C#
    中指定未绑定的泛型类型的唯一方法是使用 `typeof` 运算符：
- en: '[PRE359]'
  id: totrans-1570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: 'You can also use the `typeof` operator to specify a closed type:'
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `typeof` 运算符来指定封闭类型：
- en: '[PRE360]'
  id: totrans-1572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: 'It can specify an open type as well (which is closed at runtime):'
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: 它还可以指定一个开放类型（在运行时关闭）：
- en: '[PRE361]'
  id: totrans-1574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: The default Generic Value
  id: totrans-1575
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认通用值
- en: 'You can use the `default` keyword to get the default value for a generic type
    parameter. The default value for a reference type is `null`, and the default value
    for a value type is the result of bitwise-zeroing the type’s fields:'
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `default` 关键字获取泛型类型参数的默认值。引用类型的默认值为 `null`，值类型的默认值是对类型字段进行按位零操作的结果：
- en: '[PRE362]'
  id: totrans-1577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: 'From C# 7.1, you can omit the type argument for cases in which the compiler
    is able to infer it:'
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 7.1 开始，可以省略类型参数，编译器能够推断出的情况下：
- en: '[PRE363]'
  id: totrans-1579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: Generic Constraints
  id: totrans-1580
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型约束
- en: 'By default, a type parameter can be substituted with any type whatsoever. *Constraints*
    can be applied to a type parameter to require more specific type arguments. There
    are eight kinds of constraints:'
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，类型参数可以用任何类型替换。*约束* 可以应用于类型参数，以要求更具体的类型参数。约束有八种类型：
- en: '[PRE364]'
  id: totrans-1582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: 'In the following example, `GenericClass<T,U>` requires `T` to derive from (or
    be identical to) `SomeClass` and implement `Interface1`, and requires `U` to provide
    a parameterless constructor:'
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，`GenericClass<T,U>` 要求 `T` 派生自（或与）`SomeClass` 相同，并实现 `Interface1`，并要求
    `U` 提供一个无参数的构造函数：
- en: '[PRE365]'
  id: totrans-1584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: Constraints can be applied wherever type parameters are defined, whether in
    methods or in type definitions.
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: 约束可以应用于类型参数定义的任何地方，无论是在方法中还是在类型定义中。
- en: Note
  id: totrans-1586
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A *constraint* is a *restriction*; however, the main purpose of type parameter
    constraints is to enable things that would otherwise be prohibited.
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: '*约束* 是一种*限制*；然而，类型参数约束的主要目的是允许禁止的事情。'
- en: For instance, the constraint `T:Foo` lets you treat instances of `T` as `Foo`,
    and the constraint `T:new()` lets you construct new instances of `T`.
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，约束 `T:Foo` 允许您将 `T` 的实例视为 `Foo`，约束 `T:new()` 允许您构造 `T` 的新实例。
- en: A *base class constraint* specifies that the type parameter must subclass (or
    match) a particular class; an *interface constraint* specifies that the type parameter
    must implement that interface. These constraints allow instances of the type parameter
    to be implicitly converted to that class or interface.
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: '*基类约束*指定类型参数必须是某个类的子类（或匹配）；*接口约束*指定类型参数必须实现该接口。这些约束允许类型参数的实例被隐式转换为该类或接口。'
- en: 'The *class constraint* and *struct constraint* specify that `T` must be a reference
    type or a (non-nullable) value type, respectively. The unmanaged constraint is
    a stronger version of a struct constraint: `T` must be a simple value type or
    a struct that is (recursively) free of any reference types. The *parameterless
    constructor constraint* requires `T` to have a public parameterless constructor
    and allows you to call `new()` on `T`:'
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: '*类约束*和*结构约束*指定`T`必须是引用类型或（非空）值类型。未管理的约束是结构约束的更强版本：`T`必须是简单值类型或递归地不含任何引用类型的结构体。*无参构造约束*要求`T`必须有一个公共的无参构造函数，并允许你在`T`上调用`new()`：'
- en: '[PRE366]'
  id: totrans-1591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: The *naked type constraint* requires one type parameter to derive from (or match)
    another type parameter.
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: '*裸类型约束*要求一个类型参数派生自（或匹配）另一个类型参数。'
- en: Subclassing Generic Types
  id: totrans-1593
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型类型的子类化
- en: 'A generic class can be subclassed just like a nongeneric class. The subclass
    can leave the base class’s type parameters open, as in the following example:'
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类可以像非泛型类一样被子类化。子类可以将基类的类型参数保持开放，如以下示例：
- en: '[PRE367]'
  id: totrans-1595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: 'Or the subclass can close the generic type parameters with a concrete type:'
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: 或子类可以用具体类型关闭泛型类型参数：
- en: '[PRE368]'
  id: totrans-1597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: 'A subtype can also introduce fresh type arguments:'
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: 子类型也可以引入新的类型参数：
- en: '[PRE369]'
  id: totrans-1599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: Self-Referencing Generic Declarations
  id: totrans-1600
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自引用泛型声明
- en: 'A type can name *itself* as the concrete type when closing a type argument:'
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: 类型可以在关闭类型参数时命名*自身*作为具体类型：
- en: '[PRE370]'
  id: totrans-1602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: 'The following are also legal:'
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
  zh: 以下也是合法的：
- en: '[PRE371]'
  id: totrans-1604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: Static Data
  id: totrans-1605
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态数据
- en: 'Static data is unique for each closed type:'
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: 静态数据对于每个封闭类型都是唯一的：
- en: '[PRE372]'
  id: totrans-1607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: Covariance
  id: totrans-1608
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协变性
- en: Note
  id: totrans-1609
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Covariance and contravariance are advanced concepts. The motivation behind their
    introduction into C# was to allow generic interfaces and generics (in particular,
    those defined in .NET, such as `IEnumerable<T>`) to work *more as you’d expect*.
    You can benefit from this without understanding the details behind covariance
    and contravariance.
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: 协变性和逆变性是高级概念。它们引入到C#中的动机是允许泛型接口和泛型（特别是.NET中定义的那些，如`IEnumerable<T>`）工作得更像你期望的那样。你可以在不理解协变性和逆变性背后的细节的情况下受益于此。
- en: Assuming `A` is convertible to `B`, `X` has a covariant type parameter if `X<A>`
    is convertible to `X<B>`.
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`A`可转换为`B`，如果`X<A>`可转换为`X<B>`，则`X`具有协变类型参数。
- en: (With C#’s notion of variance, *convertible* means convertible via an *implicit
    reference conversion*—such as `A` *subclassing* `B`, or `A` *implementing* `B`.
    Numeric conversions, boxing conversions, and custom conversions are not included.)
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: （根据C#的协变性概念，*可转换*意味着通过*隐式引用转换*可转换，比如`A`是`B`的子类，或`A`实现了`B`。数值转换、装箱转换和自定义转换不包括在内。）
- en: 'For instance, type `IFoo<T>` has a covariant `T` if the following is legal:'
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，类型`IFoo<T>`如果以下内容合法，则具有协变`T`：
- en: '[PRE373]'
  id: totrans-1614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: 'Interfaces (and delegates) permit covariant type parameters. To illustrate,
    suppose that the `Stack<T>` class that we wrote at the beginning of this section
    implements the following interface:'
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: 接口（和委托）允许协变类型参数。举例来说，假设我们在本节开始编写的`Stack<T>`类实现了以下接口：
- en: '[PRE374]'
  id: totrans-1616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: 'The `out` modifier on `T` indicates that `T` is used only in *output positions*
    (e.g., return types for methods) and flags the type parameter as *covariant*,
    permitting the following code:'
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: 对`T`上的`out`修饰符表示`T`仅在*输出位置*（例如方法的返回类型）中使用，并标志类型参数为*协变*，允许以下代码：
- en: '[PRE375]'
  id: totrans-1618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: The cast from `bears` to `animals` is permitted by the compiler—by virtue of
    the interface’s type parameter being covariant.
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器允许从`bears`到`animals`的转换—这是通过接口的类型参数是协变而允许的。
- en: Note
  id: totrans-1620
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `IEnumerator<T>` and `IEnumerable<T>` interfaces (see [“Enumeration and
    Iterators”](#enumeration_and_iterators)) are marked with a covariant `T`. This
    allows you to cast `IEnumerable<string>` to `IEnumerable<object>`, for instance.
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: 接口`IEnumerator<T>`和`IEnumerable<T>`（见[“枚举和迭代器”](#enumeration_and_iterators)）标记为协变`T`。这允许你将`IEnumerable<string>`转换为`IEnumerable<object>`，例如。
- en: The compiler will generate an error if you use a covariant type parameter in
    an *input* position (e.g., a parameter to a method or a writable property). The
    purpose of this limitation is to guarantee compile-time type safety. For instance,
    it prevents us from adding a `Push(T)` method to that interface, which consumers
    could abuse with the seemingly benign operation of pushing a camel onto an `IPoppable<Animal>`
    (remember that the underlying type in our example is a stack of bears). To define
    a `Push(T)` method, `T` must in fact be *contravariant*.
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在*输入*位置使用协变类型参数（例如方法的参数或可写属性），编译器将生成错误。此限制的目的是确保编译时类型安全性。例如，它阻止我们向接口添加`Push(T)`方法，消费者可能会误用，试图将骆驼推入`IPoppable<Animal>`（请记住，我们示例中的底层类型是一堆熊）。要定义`Push(T)`方法，`T`必须实际上是*逆变的*。
- en: Note
  id: totrans-1623
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: C# supports covariance (and contravariance) only for elements with *reference
    conversions*—not *boxing conversions*. So, if you wrote a method that accepted
    a parameter of type `IPoppable<object>`, you could call it with `IPoppable<string>`
    but not `IPoppable<int>`.
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: C#仅支持*引用转换*的元素的协变性（和逆变性）—不支持*装箱转换*。因此，如果您编写了一个接受`IPoppable<object>`类型参数的方法，可以使用`IPoppable<string>`但不能使用`IPoppable<int>`调用它。
- en: Contravariance
  id: totrans-1625
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逆变性
- en: 'We previously saw that, assuming that `A` allows an implicit reference conversion
    to `B`, a type `X` has a covariant type parameter if `X<A>` allows a reference
    conversion to `X<B>`. A type is *contravariant* when you can convert in the reverse
    direction—from `X<B>` to `X<A>`. This is supported on interfaces and delegates
    when the type parameter appears only in *input* positions, designated with the
    `in` modifier. Extending our previous example, if the `Stack<T>` class implements
    the following interface:'
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到，假设`A`允许将隐式引用转换为`B`，则类型`X`具有协变类型参数，如果`X<A>`允许将引用转换为`X<B>`。当类型参数仅出现在*输入*位置时，带有`in`修饰符。扩展我们之前的示例，如果`Stack<T>`类实现以下接口：
- en: '[PRE376]'
  id: totrans-1627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: 'we can legally do this:'
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以合法地执行这样的操作：
- en: '[PRE377]'
  id: totrans-1629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: Mirroring covariance, the compiler will report an error if you try to use a
    contravariant type parameter in an output position (e.g., as a return value or
    in a readable property).
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: 反映协变性，如果您尝试在输出位置使用逆变类型参数（例如作为返回值或可读属性），编译器将报告错误。
- en: Delegates
  id: totrans-1631
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 委托
- en: 'A *delegate* wires up a method caller to its target method at runtime. There
    are two aspects to a delegate: *type* and *instance*. A *delegate type* defines
    a *protocol* to which the caller and target will conform, comprising a list of
    parameter types and a return type. A *delegate instance* is an object that refers
    to one (or more) target methods conforming to that protocol.'
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: '*委托*将方法调用者在运行时连接到其目标方法。委托有两个方面：*类型*和*实例*。*委托类型*定义了调用者和目标将符合的*协议*，包括参数类型列表和返回类型。*委托实例*是指向符合该协议的一个（或多个）目标方法的对象。'
- en: 'A delegate instance literally acts as a delegate for the caller: the caller
    invokes the delegate, and then the delegate calls the target method. This indirection
    decouples the caller from the target method.'
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: 委托实例确实充当调用者的代表：调用者调用委托，然后委托调用目标方法。这种间接性将调用者与目标方法解耦。
- en: 'A delegate type declaration is preceded by the keyword `delegate`, but otherwise
    it resembles an (abstract) method declaration. For example:'
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: 委托类型声明之前使用关键字`delegate`，但在其他方面类似于（抽象）方法声明。例如：
- en: '[PRE378]'
  id: totrans-1635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: 'To create a delegate instance, you can assign a method to a delegate variable:'
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建委托实例，可以将方法分配给委托变量：
- en: '[PRE379]'
  id: totrans-1637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: 'Invoking a delegate is just like invoking a method (because the delegate’s
    purpose is merely to provide a level of indirection):'
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: 调用委托就像调用方法一样（因为委托的目的仅是提供一级间接）：
- en: '[PRE380]'
  id: totrans-1639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: 'The statement `Transformer t = Square` is shorthand for the following:'
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: 语句`Transformer t = Square`的速记法如下：
- en: '[PRE381]'
  id: totrans-1641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: 'And `t(3)` is shorthand for this:'
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: 而`t(3)`是以下的速记法：
- en: '[PRE382]'
  id: totrans-1643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: A delegate is similar to a *callback*, a general term that captures constructs
    such as C function pointers.
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: 委托类似于*回调*，是一个通用术语，涵盖了诸如C函数指针之类的结构。
- en: Writing Plug-In Methods with Delegates
  id: totrans-1645
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用委托编写插件方法
- en: 'A delegate variable is assigned a method at runtime. This is useful for writing
    plug-in methods. In this example, we have a utility method named `Transform` that
    applies a transform to each element in an integer array. The `Transform` method
    has a delegate parameter for specifying a plug-in transform:'
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: 委托变量在运行时分配一个方法。这对编写插件方法非常有用。在本示例中，我们有一个名为`Transform`的实用方法，它对整数数组中的每个元素应用变换。`Transform`方法具有一个委托参数，用于指定插件变换：
- en: '[PRE383]'
  id: totrans-1647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: Instance and Static Method Targets
  id: totrans-1648
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例方法和静态方法的目标
- en: A delegate’s target method can be a local, static, or instance method.
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
  zh: 委托的目标方法可以是本地方法、静态方法或实例方法。
- en: When an *instance* method is assigned to a delegate object, the latter must
    maintain a reference not only to the method but also to the *instance* to which
    the method belongs. The `System.Delegate` class’s `Target` property represents
    this instance (and will be null for a delegate referencing a static method).
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
  zh: 当将*实例*方法分配给委托对象时，后者必须保持对方法和方法所属*实例*的引用。`System.Delegate`类的`Target`属性表示此实例（对于引用静态方法的委托，此属性将为null）。
- en: Multicast Delegates
  id: totrans-1651
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多路委托
- en: 'All delegate instances have *multicast* capability. This means that a delegate
    instance can reference not just a single target method but also a list of target
    methods. The `+` and `+=` operators combine delegate instances. For example:'
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: 所有委托实例都具有*多路*能力。这意味着委托实例不仅可以引用单个目标方法，还可以引用目标方法列表。`+`和`+=`运算符结合委托实例。例如：
- en: '[PRE384]'
  id: totrans-1653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: 'The last line is functionally the same as this one:'
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行在功能上与这一行相同：
- en: '[PRE385]'
  id: totrans-1655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: Invoking `d` will now call both `SomeMethod1` and `SomeMethod2`. Delegates are
    invoked in the order in which they are added.
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`d`现在将调用`SomeMethod1`和`SomeMethod2`。委托按添加顺序调用。
- en: 'The `-` and `-=` operators remove the right delegate operand from the left
    delegate operand. For example:'
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
  zh: '`-`和`-=`运算符从左委托操作数中移除右委托操作数。例如：'
- en: '[PRE386]'
  id: totrans-1658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: Invoking `d` will now cause only `SomeMethod2` to be invoked.
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`d`现在只会调用`SomeMethod2`。
- en: Calling `+` or `+=` on a delegate variable with a `null` value is legal, as
    is calling `-=` on a delegate variable with a single target (which will result
    in the delegate instance being `null`).
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
  zh: 在委托变量上调用`+`或`+=`并具有`null`值是合法的，就像在具有单个目标的委托变量上调用`-=`一样（这将导致委托实例为`null`）。
- en: Note
  id: totrans-1661
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Delegates are *immutable*, so when you call `+=` or `-=`, you’re in fact creating
    a *new* delegate instance and assigning it to the existing variable.
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
  zh: 委托是*不可变的*，因此当您调用`+=`或`-=`时，实际上是创建一个*新*的委托实例并将其分配给现有变量。
- en: If a multicast delegate has a nonvoid return type, the caller receives the return
    value from the last method to be invoked. The preceding methods are still called,
    but their return values are discarded. In most scenarios in which multicast delegates
    are used, they have `void` return types, so this subtlety does not arise.
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多路委托具有非`void`返回类型，则调用者将接收最后一个调用的方法的返回值。之前的方法仍会被调用，但它们的返回值会被丢弃。在大多数使用多路委托的场景中，它们具有`void`返回类型，因此不会出现此微妙之处。
- en: All delegate types implicitly derive from `System.MulticastDelegate`, which
    inherits from `System.Delegate`. C# compiles `+`, `-`, `+=`, and `-=` operations
    made on a delegate to the static `Combine` and `Remove` methods of the `System.Delegate`
    class.
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
  zh: 所有委托类型都隐式从`System.MulticastDelegate`派生，后者继承自`System.Delegate`。C#将委托上的`+`、`-`、`+=`和`-=`操作编译为`System.Delegate`类的静态`Combine`和`Remove`方法。
- en: Generic Delegate Types
  id: totrans-1665
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型委托类型
- en: 'A delegate type can contain generic type parameters. For example:'
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
  zh: 委托类型可以包含泛型类型参数。例如：
- en: '[PRE387]'
  id: totrans-1667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: 'Here’s how we could use this delegate type:'
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何使用此委托类型的方式：
- en: '[PRE388]'
  id: totrans-1669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: The Func and Action Delegates
  id: totrans-1670
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Func和Action委托
- en: 'With generic delegates, it becomes possible to write a small set of delegate
    types that are so general they can work for methods of any return type and any
    (reasonable) number of arguments. These delegates are the `Func` and `Action`
    delegates, defined in the `System` namespace (the `in` and `out` annotations indicate
    *variance*, which we cover in the context of delegates shortly):'
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: 使用泛型委托，可以编写一小组非常通用的委托类型，这些委托类型可以适用于任何返回类型和任何（合理的）参数数量的方法。这些委托是在`System`命名空间中定义的`Func`和`Action`委托（`in`和`out`注释指示*变化*，我们很快将在委托上下文中涵盖它）：
- en: '[PRE389]'
  id: totrans-1672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: 'These delegates are extremely general. The `Transformer` delegate in our previous
    example can be replaced with a `Func` delegate that takes a single argument of
    type `T` and returns a same-typed value:'
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
  zh: 这些委托非常通用。在我们之前的示例中，`Transformer`委托可以替换为一个接受类型为`T`的单一参数并返回相同类型值的`Func`委托：
- en: '[PRE390]'
  id: totrans-1674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: The only practical scenarios not covered by these delegates are `ref`/`out`
    and pointer parameters.
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
  zh: 这些委托未涵盖的唯一实际场景是`ref`/`out`和指针参数。
- en: Delegate Compatibility
  id: totrans-1676
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 委托兼容性
- en: 'Delegate types are all incompatible with one another, even if their signatures
    are the same:'
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
  zh: 委托类型彼此都是不兼容的，即使它们的签名相同：
- en: '[PRE391]'
  id: totrans-1678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: 'The following, however, is permitted:'
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，下面是允许的：
- en: '[PRE392]'
  id: totrans-1680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: Delegate instances are considered equal if they have the same type and method
    target(s). For multicast delegates, the order of the method targets is significant.
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: 如果委托实例具有相同的类型和方法目标，则它们被视为相等。对于多播委托，方法目标的顺序是重要的。
- en: Return type variance
  id: totrans-1682
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回类型变异
- en: 'When you call a method, you might get back a type that is more specific than
    what you asked for. This is ordinary polymorphic behavior. In keeping with this,
    a delegate target method might return a more specific type than described by the
    delegate. This is *covariance*:'
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用一个方法时，您可能会得到比您请求的更具体的类型。这是普通的多态行为。保持一致，委托目标方法可能返回比委托描述的更具体的类型。这称为*协变*：
- en: '[PRE393]'
  id: totrans-1684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: The `ObjectRetriever` expects to get back an `object`, but an `object` *subclass*
    will also do because delegate return types are *covariant*.
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObjectRetriever`期望返回一个`object`，但是`object`的*子类*也可以，因为委托的返回类型是*协变*。'
- en: Parameter variance
  id: totrans-1686
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数变异
- en: 'When you call a method, you can supply arguments that have more specific types
    than the parameters of that method. This is ordinary polymorphic behavior. In
    keeping with this, a delegate target method may have *less* specific parameter
    types than described by the delegate. This is called *contravariance*:'
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用一个方法时，您可以提供比该方法参数更具体的参数。这是普通的多态行为。保持一致，委托目标方法的参数类型可能比委托描述的要*更少*具体。这称为*逆变*：
- en: '[PRE394]'
  id: totrans-1688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: Note
  id: totrans-1689
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The standard event pattern is designed to help you take advantage of delegate
    parameter contravariance through its use of the common `EventArgs` base class.
    For example, you can have a single method invoked by two different delegates,
    one passing a `MouseEventArgs` and the other passing a `KeyEventArgs`.
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
  zh: 标准事件模式旨在通过其对共同`EventArgs`基类的使用帮助您利用委托参数的逆变性。例如，您可以有一个单一方法由两个不同的委托调用，一个传递`MouseEventArgs`，另一个传递`KeyEventArgs`。
- en: Type parameter variance for generic delegates
  id: totrans-1691
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 泛型委托的类型参数变异
- en: 'We saw in [“Generics”](#generics) how type parameters can be covariant and
    contravariant for generic interfaces. The same capability also exists for generic
    delegates. If you’re defining a generic delegate type, it’s a good practice to
    do the following:'
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[“泛型”](#generics)中看到了如何对泛型接口的类型参数进行协变和逆变。相同的能力也适用于泛型委托。如果您正在定义一个泛型委托类型，最好按照以下做法：
- en: Mark a type parameter used only on the return value as covariant (`out`)
  id: totrans-1693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将仅用于返回值的类型参数标记为协变的（`out`）
- en: Mark any type parameters used only on parameters as contravariant (`in`)
  id: totrans-1694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将仅用于参数的类型参数标记为逆变的（`in`）
- en: 'Doing so allows conversions to work naturally by respecting inheritance relationships
    between types. The following delegate (defined in the `System` namespace) is covariant
    for `TResult`:'
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此操作允许通过尊重类型之间的继承关系自然进行转换。下面的委托（定义在`System`命名空间中）对于`TResult`是协变的：
- en: '[PRE395]'
  id: totrans-1696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: 'This allows:'
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许：
- en: '[PRE396]'
  id: totrans-1698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: The following delegate (defined in the `System` namespace) is contravariant
    for `T:`
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的委托（定义在`System`命名空间中）对于`T:`是逆变的：
- en: '[PRE397]'
  id: totrans-1700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: 'This allows:'
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许：
- en: '[PRE398]'
  id: totrans-1702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: Events
  id: totrans-1703
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: 'When you’re using delegates, two emergent roles commonly appear: *broadcaster*
    and *subscriber*. The *broadcaster* is a type that contains a delegate field.
    The broadcaster decides when to broadcast, by invoking the delegate. The *subscribers*
    are the method target recipients. A subscriber decides when to start and stop
    listening, by calling `+=` and `-=` on the broadcaster’s delegate. A subscriber
    does not know about, or interfere with, other subscribers.'
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用委托时，通常会出现两个新兴角色：*广播者*和*订阅者*。*广播者*是包含委托字段的类型。广播者通过调用委托来决定何时进行广播。*订阅者*是方法目标接收者。订阅者通过在广播者的委托上调用`+=`和`-=`来决定何时开始和停止监听。订阅者不知道或干扰其他订阅者。
- en: Events are a language feature that formalizes this pattern. An `event` is a
    construct that exposes just the subset of delegate features required for the broadcaster/subscriber
    model. The main purpose of events is to *prevent subscribers from interfering
    with one another*.
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是一种语言特性，正式化了这种模式。`event`是一种只暴露委托功能子集的构造，用于广播者/订阅者模型。事件的主要目的是*防止订阅者互相干扰*。
- en: 'The easiest way to declare an event is to put the `event` keyword in front
    of a delegate member:'
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
  zh: 声明事件的最简单方式是在委托成员前面加上 `event` 关键字：
- en: '[PRE399]'
  id: totrans-1707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: Code within the `Broadcaster` type has full access to `Progress` and can treat
    it as a delegate. Code outside of `Broadcaster` can perform only `+=` and `-=`
    operations on the `Progress` event.
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
  zh: '`Broadcaster` 类型内部的代码可以完全访问 `Progress` 并将其视为委托。在 `Broadcaster` 外部的代码只能对 `Progress`
    事件执行 `+=` 和 `-=` 操作。'
- en: 'In the following example, the `Stock` class fires its `PriceChanged` event
    every time the `Price` of the `Stock` changes:'
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，`Stock` 类在每次 `Stock` 的 `Price` 改变时触发其 `PriceChanged` 事件：
- en: '[PRE400]'
  id: totrans-1710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: 'If we remove the `event` keyword from our example so that `PriceChanged` becomes
    an ordinary delegate field, our example would give the same results. However,
    `Stock` would be less robust in that subscribers could do the following things
    to interfere with one another:'
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从示例中删除 `event` 关键字，使 `PriceChanged` 变为普通委托字段，我们的示例将给出相同的结果。但是，`Stock` 在订阅者之间可能会更不健壮，因为订阅者可以执行以下操作之一来干扰彼此：
- en: Replace other subscribers by reassigning `PriceChanged` (instead of using the
    `+=` operator)
  id: totrans-1712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过重新分配 `PriceChanged`（而不是使用 `+=` 运算符）替换其他订阅者
- en: Clear all subscribers (by setting `PriceChanged` to `null`)
  id: totrans-1713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除所有订阅者（通过将 `PriceChanged` 设置为 `null`）
- en: Broadcast to other subscribers by invoking the delegate
  id: totrans-1714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用委托向其他订阅者广播
- en: Events can be virtual, overridden, abstract, or sealed. They can also be static.
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
  zh: 事件可以是虚拟的、被重写的、抽象的或密封的。它们也可以是静态的。
- en: Standard Event Pattern
  id: totrans-1716
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准事件模式
- en: 'In almost all cases in which events are defined in the .NET library, their
    definition adheres to a standard pattern designed to provide consistency across
    library and user code. Here’s the preceding example refactored with this pattern:'
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有在 .NET 库中定义事件的情况下，它们的定义都遵循一种标准模式，旨在提供对库和用户代码的一致性。以下是使用此模式重构的前述示例：
- en: '[PRE401]'
  id: totrans-1718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: At the core of the standard event pattern is `System.EventArgs`, a predefined
    .NET class with no members (other than the static `Empty` field). `EventArgs`
    is a base class for conveying information for an event. In this example, we subclass
    `EventArgs` to convey the old and new prices when a `PriceChanged` event is fired.
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: 标准事件模式的核心是 `System.EventArgs`，这是一个预定义的 .NET 类，没有其他成员（除了静态的 `Empty` 字段）。 `EventArgs`
    是传递事件信息的基类。在这个示例中，我们子类化 `EventArgs` 来传递价格变化前后的旧值和新值。
- en: 'The generic `System.EventHandler` delegate is also part of .NET and is defined
    as follows:'
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型 `System.EventHandler` 委托也是 .NET 的一部分，定义如下：
- en: '[PRE402]'
  id: totrans-1721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: Note
  id: totrans-1722
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Before C# 2.0 (when generics were added to the language), the solution was
    to instead write a custom event-handling delegate for each `EventArgs` type as
    follows:'
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 2.0 之前（当泛型添加到语言中时），解决方案是为每个 `EventArgs` 类型编写自定义事件处理委托：
- en: '[PRE403]'
  id: totrans-1724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: For historical reasons, most events within the .NET libraries use delegates
    defined in this way.
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: 基于历史原因，.NET 库中的大多数事件使用了这种方式定义的委托。
- en: A protected virtual method named `On`*-*`*event-name*` centralizes firing of
    the event. This allows subclasses to fire the event (which is usually desirable)
    and also allows subclasses to insert code before and after the event is fired.
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 `On`*-*`*event-name*` 的受保护虚拟方法集中了事件的触发。这允许子类触发事件（通常是可取的），还允许子类在事件触发前后插入代码。
- en: 'Here’s how we could use our `Stock` class:'
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何使用我们的 `Stock` 类：
- en: '[PRE404]'
  id: totrans-1728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: 'For events that don’t carry additional information, .NET also provides a nongeneric
    `EventHandler` delegate. We can demonstrate this by rewriting our `Stock` class
    such that the `PriceChanged` event fires *after* the price changes. This means
    that no additional information need be transmitted with the event:'
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不携带附加信息的事件，.NET 还提供了一个非泛型的 `EventHandler` 委托。我们可以通过重写我们的 `Stock` 类来演示这一点，使得
    `PriceChanged` 事件在价格改变后触发。这意味着事件无需传递额外的信息：
- en: '[PRE405]'
  id: totrans-1730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: Note that we also used the `EventArgs.Empty` property—this saves instantiating
    an instance of `EventArgs`.
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还使用了 `EventArgs.Empty` 属性——这样可以节省实例化 `EventArgs` 的开销。
- en: Event Accessors
  id: totrans-1732
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件访问器
- en: 'An event’s *accessors* are the implementations of its `+=` and `-=` functions.
    By default, accessors are implemented implicitly by the compiler. Consider this
    event declaration:'
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
  zh: 事件的 *访问器* 是其 `+=` 和 `-=` 函数的实现。默认情况下，访问器由编译器隐式实现。考虑以下事件声明：
- en: '[PRE406]'
  id: totrans-1734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: 'The compiler converts this to the following:'
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将其转换为以下内容：
- en: A private delegate field
  id: totrans-1736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个私有委托字段
- en: A public pair of event accessor functions, whose implementations forward the
    `+=` and `-=` operations to the private delegate field
  id: totrans-1737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对公共事件访问器函数，其实现将`+=`和`-=`操作转发到私有委托字段
- en: 'You can take over this process by defining *explicit* event accessors. Here’s
    a manual implementation of the `PriceChanged` event from our previous example:'
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过定义*显式*事件访问器来接管这个过程。这里是我们先前示例中`PriceChanged`事件的手动实现：
- en: '[PRE407]'
  id: totrans-1739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: This example is functionally identical to C#’s default accessor implementation
    (except that C# also ensures thread safety around updating the delegate). By defining
    event accessors ourselves, we instruct C# not to generate default field and accessor
    logic.
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例在功能上与C#的默认访问器实现相同（除了C#还确保在更新委托时线程安全）。通过定义事件访问器，我们指示C#不生成默认字段和访问器逻辑。
- en: 'With explicit event accessors, you can apply more complex strategies to the
    storage and access of the underlying delegate. This is useful when the event accessors
    are merely relays for another class that is broadcasting the event, or when explicitly
    implementing an interface that declares an event:'
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
  zh: 使用显式事件访问器时，可以对底层委托的存储和访问应用更复杂的策略。当事件访问器仅仅是向另一个广播事件的类中继时，或者显式实现声明事件的接口时，这非常有用：
- en: '[PRE408]'
  id: totrans-1742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: Lambda Expressions
  id: totrans-1743
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: 'A *lambda expression* is an unnamed method written in place of a delegate instance.
    The compiler immediately converts the lambda expression to either of the following:'
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lambda表达式*是在委托实例的位置上写的无名方法。编译器立即将lambda表达式转换为以下之一：'
- en: A delegate instance.
  id: totrans-1745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个委托实例。
- en: An *expression tree*, of type `Expression<TDelegate>`, representing the code
    inside the lambda expression in a traversable object model. This allows the lambda
    expression to be interpreted later at runtime (we describe the process in Chapter
    8 of *C# 12 in a Nutshell*).
  id: totrans-1746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*表达式树*，类型为`Expression<TDelegate>`，表示lambda表达式内部的代码为可遍历的对象模型。这允许稍后在运行时解释lambda表达式（我们在《C#
    12精要》的第8章中描述了这个过程）。'
- en: 'In the following example, `x => x * x` is a lambda expression:'
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`x => x * x`是一个lambda表达式：
- en: '[PRE409]'
  id: totrans-1748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: Note
  id: totrans-1749
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Internally, the compiler resolves lambda expressions of this type by writing
    a private method and moving the expression’s code into that method.
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，编译器通过编写一个私有方法并将表达式的代码移动到该方法中来解析这种类型的lambda表达式。
- en: 'A lambda expression has the following form:'
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式具有以下形式：
- en: '[PRE410]'
  id: totrans-1752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: For convenience, you can omit the parentheses if and only if there is exactly
    one parameter of an inferable type.
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，如果且仅当有一个可推断类型的参数时，可以省略括号。
- en: 'In our example, there is a single parameter, `x`, and the expression is `x
    * x`:'
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，有一个参数`x`，表达式是`x * x`：
- en: '[PRE411]'
  id: totrans-1755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: Each parameter of the lambda expression corresponds to a delegate parameter,
    and the type of the expression (which can be `void`) corresponds to the return
    type of the delegate.
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式的每个参数对应于一个委托参数，并且表达式的类型（可以是`void`）对应于委托的返回类型。
- en: In our example, `x` corresponds to parameter `i`, and the expression `x * x`
    corresponds to the return type `int`, therefore making it compatible with the
    `Transformer` delegate.
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`x`对应于参数`i`，表达式`x * x`对应于返回类型`int`，因此与`Transformer`委托兼容。
- en: 'A lambda expression’s code can be a *statement block* instead of an expression.
    We can rewrite our example as follows:'
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式的代码可以是*语句块*而不是表达式。我们可以将我们的示例重写如下：
- en: '[PRE412]'
  id: totrans-1759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: 'Lambda expressions are used most commonly with the `Func` and `Action` delegates,
    so you will most often see our earlier expression written as follows:'
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式最常与`Func`和`Action`委托一起使用，因此你会经常看到我们之前的表达式写成如下形式：
- en: '[PRE413]'
  id: totrans-1761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: 'The compiler can usually *infer* the type of lambda parameters contextually.
    When this is not the case, you can specify parameter types explicitly:'
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器通常可以*推断*lambda参数的类型。当情况不是这样时，可以显式指定参数类型：
- en: '[PRE414]'
  id: totrans-1763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: 'Here’s an example of an expression that accepts two parameters:'
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个接受两个参数的表达式示例：
- en: '[PRE415]'
  id: totrans-1765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: 'Assuming `Clicked` is an event of type `EventHandler`, the following attaches
    an event handler via a lambda expression:'
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`Clicked`是`EventHandler`类型的事件，以下通过lambda表达式附加事件处理程序：
- en: '[PRE416]'
  id: totrans-1767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: 'Here’s an example of an expression that takes zero arguments:'
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个接受零个参数的表达式示例：
- en: '[PRE417]'
  id: totrans-1769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: 'From C# 10, the compiler permits implicit typing with lambda expressions that
    can be resolved via the `Func` and `Action` delegates, so we can shorten this
    statement to:'
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 10开始，编译器允许使用可以通过`Func`和`Action`委托解析的lambda表达式进行隐式类型推断，因此我们可以将此语句简化为：
- en: '[PRE418]'
  id: totrans-1771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: 'If the lambda expression has arguments, you must specify their types in order
    to use `var`:'
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 lambda 表达式有参数，则必须指定它们的类型才能使用 `var`：
- en: '[PRE419]'
  id: totrans-1773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: The compiler infers `sqr` to be of type `Func<int,int>`.
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器推断 `sqr` 的类型为 `Func<int,int>`。
- en: Default Lambda Parameters (C# 12)
  id: totrans-1775
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认 Lambda 参数（C# 12）
- en: 'Just as ordinary methods can have optional parameters:'
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
  zh: 就像普通方法可以有可选参数一样：
- en: '[PRE420]'
  id: totrans-1777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: 'so, too, can lambda expressions:'
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，lambda 表达式也可以：
- en: '[PRE421]'
  id: totrans-1779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: This feature is useful with libraries such as ASP.NET Minimal API.
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能对于像 ASP.NET Minimal API 这样的库非常有用。
- en: Capturing Outer Variables
  id: totrans-1781
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获外部变量
- en: 'A lambda expression can reference any variables that are accessible where the
    lambda expression is defined. These are called *outer variables* and can include
    local variables, parameters, and fields:'
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式可以引用在其定义的地方可访问的任何变量。这些称为*外部变量*，可以包括局部变量、参数和字段：
- en: '[PRE422]'
  id: totrans-1783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: 'Outer variables referenced by a lambda expression are called *captured variables*.
    A lambda expression that captures variables is called a *closure*. Captured variables
    are evaluated when the delegate is actually *invoked*, not when the variables
    were *captured*:'
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: 被 lambda 表达式引用的外部变量称为*捕获变量*。捕获变量在实际*调用*委托时进行评估，而不是在捕获变量时：
- en: '[PRE423]'
  id: totrans-1785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: 'Lambda expressions can themselves update captured variables:'
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式本身可以更新捕获的变量：
- en: '[PRE424]'
  id: totrans-1787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: 'Captured variables have their lifetimes extended to that of the delegate. In
    the following example, the local variable `seed` would ordinarily disappear from
    scope when `Natural` finished executing. But because `seed` has been *captured*,
    its lifetime is extended to that of the capturing delegate, `natural`:'
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获变量的生命周期延长到委托的生命周期。在以下示例中，局部变量 `seed` 在 `Natural` 执行完成时通常会从作用域中消失。但因为 `seed`
    被*捕获*，其生命周期延长到捕获委托 `natural` 的生命周期：
- en: '[PRE425]'
  id: totrans-1789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: Variables can also be captured by anonymous methods and local methods. The rules
    for captured variables, in these cases, are the same.
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
  zh: 变量也可以被匿名方法和本地方法捕获。在这些情况下，捕获变量的规则是相同的。
- en: Static lambdas
  id: totrans-1791
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态 lambda
- en: 'From C# 9, you can ensure that a lambda expression, local function, or anonymous
    method doesn’t capture state by applying the `static` keyword. This can be useful
    in micro-optimization scenarios to prevent the (potentially unintentional) memory
    allocation and cleanup of a closure. For example, we can apply the static modifier
    to a lambda expression as follows:'
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 9 开始，您可以通过应用 `static` 关键字来确保 lambda 表达式、本地方法或匿名方法不会捕获状态。这在微优化场景中很有用，以防止（可能是无意的）闭包内存分配和清理。例如，我们可以将
    static 修饰符应用于 lambda 表达式如下：
- en: '[PRE426]'
  id: totrans-1793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: 'If we later tried to modify the lambda expression such that it captured a local
    variable, the compiler will generate an error. This feature is more useful in
    local methods (because a lambda expression itself incurs a memory allocation).
    In the following example, the `Multiply` method cannot access the `factor` variable:'
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
  zh: 如果后来试图修改 lambda 表达式，以便捕获一个局部变量，编译器将会生成一个错误。这个特性在本地方法中更有用（因为 lambda 表达式本身会引起内存分配）。在以下示例中，`Multiply`
    方法无法访问 `factor` 变量：
- en: '[PRE427]'
  id: totrans-1795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: Applying `static` here is also arguably useful as a documentation tool, indicating
    a reduced level of coupling. Static lambdas can still access static variables
    and constants (because these do not require a closure).
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
  zh: 在此应用 `static` 也可以作为文档工具，指示减少耦合的程度。静态 lambda 仍然可以访问静态变量和常量（因为这些不需要闭包）。
- en: Note
  id: totrans-1797
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `static` keyword acts merely as a *check*; it has no effect on the IL that
    the compiler produces. Without the `static` keyword, the compiler does not generate
    a closure unless it needs to (and even then, it has tricks to mitigate the cost).
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
  zh: '`static` 关键字仅作为*检查*；它不影响编译器生成的 IL。如果没有 `static` 关键字，编译器不会生成闭包，除非需要（即使如此，它也有技巧来减少成本）。'
- en: Capturing iteration variables
  id: totrans-1799
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获迭代变量
- en: 'When you capture an iteration variable in a `for` loop, C# treats the iteration
    variable as though it were declared *outside* the loop. This means that the *same*
    variable is captured in each iteration. The following program writes `333` instead
    of `012`:'
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 `for` 循环中捕获迭代变量时，C# 将迭代变量视为在循环*外部*声明。这意味着每次迭代中都会捕获*同一个*变量。以下程序输出 `333` 而不是
    `012`：
- en: '[PRE428]'
  id: totrans-1801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: 'Each closure (shown in boldface) captures the same variable, `i`. (This actually
    makes sense when you consider that `i` is a variable whose value persists between
    loop iterations; you can even explicitly change `i` within the loop body if you
    want.) The consequence is that when the delegates are later invoked, each delegate
    sees `i`’s value at the time of *invocation*—which is 3\. The solution, if we
    want to write `012`, is to assign the iteration variable to a local variable that
    is scoped *within* the loop:'
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
  zh: 每个闭包（以粗体显示）捕获同一个变量 `i`。（这实际上在考虑到 `i` 是一个在循环迭代之间保持其值的变量时是有道理的；你甚至可以在循环体内显式更改
    `i` 的值。）其结果是，当稍后调用委托时，每个委托都会看到调用时 `i` 的值—这是 3\. 如果我们想写 `012`，解决方法是将迭代变量分配给循环内部范围的本地变量：
- en: '[PRE429]'
  id: totrans-1803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: This causes the closure to capture a *different* variable on each iteration.
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致闭包在每次迭代时捕获*不同*的变量。
- en: Note that (from C# 5) the iteration variable in a `foreach` loop is implicitly
    local, so you can safely close over it without needing a temporary variable.
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意（从 C# 5 开始），`foreach` 循环中的迭代变量是隐式局部的，因此可以安全地在其上进行闭包，而无需临时变量。
- en: Lambda Expressions Versus Local Methods
  id: totrans-1806
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda 表达式与本地方法对比
- en: The functionality of local methods (see [“Local methods”](#local_methods)) overlaps
    with that of lambda expressions. Local methods have the advantages of allowing
    for recursion and avoiding the clutter of specifying a delegate. Avoiding the
    indirection of a delegate also makes them slightly more efficient, and they can
    access local variables of the containing method without the compiler having to
    “hoist” the captured variables into a hidden class.
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
  zh: 本地方法（参见[“本地方法”](#local_methods)）的功能与 Lambda 表达式重叠。本地方法的优点在于允许递归并避免指定委托的混乱。避免委托的间接引用也使它们稍微更有效，并且它们可以访问包含方法的局部变量，而无需编译器将捕获的变量提升到隐藏类中。
- en: 'However, in many cases you *need* a delegate, most commonly when calling a
    higher-order function (i.e., a method with a delegate-typed parameter):'
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在许多情况下，你*需要*一个委托，最常见的情况是调用高阶函数（即，带有委托类型参数的方法）：
- en: '[PRE430]'
  id: totrans-1809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: In such cases, you need a delegate anyway, and it’s precisely in these cases
    that lambda expressions are usually terser and cleaner.
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你无论如何都需要一个委托，而恰恰在这些情况下，Lambda 表达式通常更简洁、更清晰。
- en: Anonymous Methods
  id: totrans-1811
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名方法
- en: 'Anonymous methods are a C# 2.0 feature that has been mostly subsumed by lambda
    expressions. An anonymous method is like a lambda expression except that it lacks
    implicitly typed parameters, expression syntax (an anonymous method must always
    be a statement block), and the ability to compile to an expression tree. To write
    an anonymous method, you include the `delegate` keyword followed (optionally)
    by a parameter declaration and then a method body. For example:'
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名方法是 C# 2.0 的一个特性，大多数情况下已被 Lambda 表达式取代。匿名方法类似于 Lambda 表达式，但缺少隐式类型化的参数、表达式语法（匿名方法必须始终是一个语句块）以及编译为表达式树的能力。要编写匿名方法，你需要使用
    `delegate` 关键字，后面（可选）是参数声明，然后是方法体。例如：
- en: '[PRE431]'
  id: totrans-1813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: 'The first line is semantically equivalent to the following lambda expression:'
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行在语义上等同于以下 Lambda 表达式：
- en: '[PRE432]'
  id: totrans-1815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: 'Or simply:'
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
  zh: 或者简单地：
- en: '[PRE433]'
  id: totrans-1817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: 'A unique feature of anonymous methods is that you can omit the parameter declaration
    entirely—even if the delegate expects it. This can be useful in declaring events
    with a default empty handler:'
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名方法的一个独特特性是，你可以完全省略参数声明—即使委托需要它。这在声明带有默认空处理程序的事件时非常有用：
- en: '[PRE434]'
  id: totrans-1819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: 'This avoids the need for a null check before firing the event. The following
    is also legal (notice the lack of parameters):'
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以避免在触发事件前进行空检查。以下也是合法的（注意没有参数）：
- en: '[PRE435]'
  id: totrans-1821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: Anonymous methods capture outer variables in the same way lambda expressions
    do.
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名方法像 Lambda 表达式一样捕获外部变量。
- en: try Statements and Exceptions
  id: totrans-1823
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: try 语句和异常
- en: A `try` statement specifies a code block subject to error-handling or cleanup
    code. The `try` *block* must be followed by one or more `catch` *blocks* and/or
    a `finally` *block*. The `catch` block executes when an error is thrown in the
    `try` block. The `finally` block executes after execution leaves the `try` block
    (or if present, the `catch` block) to perform cleanup code, whether or not an
    exception was thrown.
  id: totrans-1824
  prefs: []
  type: TYPE_NORMAL
  zh: '`try` 语句指定一个可能包含错误处理或清理代码的代码块。`try` *块* 后必须跟随一个或多个 `catch` *块* 和/或一个 `finally`
    *块*。当 `try` 块中抛出错误时，执行 `catch` 块。`finally` 块在执行离开 `try` 块（或如有的话，`catch` 块）后执行清理代码，无论是否抛出异常。'
- en: A `catch` block has access to an `Exception` object that contains information
    about the error. You use a `catch` block to either compensate for the error or
    *rethrow* the exception. You rethrow an exception if you merely want to log the
    problem, or if you want to rethrow a new, higher-level exception type.
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch` 块可以访问包含有关错误信息的 `Exception` 对象。你可以使用 `catch` 块来补偿错误或*重新抛出*异常。如果仅想记录问题，或者想要重新抛出新的更高级别的异常类型，则重新抛出异常。'
- en: A `finally` block adds determinism to your program by always executing no matter
    what. It’s useful for cleanup tasks such as closing network connections.
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally` 块通过始终执行来为程序添加确定性，无论如何。它对于如关闭网络连接等清理任务非常有用。'
- en: 'A `try` statement looks like this:'
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
  zh: '`try` 语句如下所示：'
- en: '[PRE436]'
  id: totrans-1828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: 'Consider the following code:'
  id: totrans-1829
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE437]'
  id: totrans-1830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: 'Because `y` is zero, the runtime throws a `DivideByZeroException` and our program
    terminates. We can prevent this by catching the exception as follows:'
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `y` 为零，运行时抛出 `DivideByZeroException` 并终止我们的程序。我们可以通过以下方式捕获异常来防止这种情况：
- en: '[PRE438]'
  id: totrans-1832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: Note
  id: totrans-1833
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This is a simple example to illustrate exception handling. We could deal with
    this particular scenario better in practice by checking explicitly for the divisor
    being zero before calling `Calc`.
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的示例，用于说明异常处理。在实践中，我们可以通过在调用 `Calc` 之前显式检查除数是否为零来更好地处理这种情况。
- en: Exceptions are relatively expensive to handle, taking hundreds of clock cycles.
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
  zh: 处理异常相对昂贵，需要数百个时钟周期。
- en: 'When an exception is thrown within a `try` statement, the CLR performs a test:'
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 `try` 语句内抛出异常时，CLR 进行测试：
- en: '*Does the* `try` *statement have any compatible* `catch` *blocks?*'
  id: totrans-1837
  prefs: []
  type: TYPE_NORMAL
  zh: '*try* *语句有兼容的*catch*块吗？*'
- en: If so, execution jumps to the compatible `catch` block, followed by the `finally`
    block (if present), and then execution continues normally.
  id: totrans-1838
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有，则执行跳转到兼容的`catch`块，然后是`finally`块（如果存在），然后执行正常继续。
- en: If not, execution jumps directly to the `finally` block (if present), and then
    the CLR looks up the call stack for other `try` blocks and, if found, repeats
    the test.
  id: totrans-1839
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不是，则执行直接跳转到 `finally` 块（如果存在），然后 CLR 查找调用堆栈中的其他 `try` 块，如果找到，则重复测试。
- en: If no function in the call stack takes responsibility for the exception, an
    error dialog is displayed to the user and the program terminates.
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用堆栈中没有任何函数负责异常，则向用户显示错误对话框并终止程序。
- en: The catch Clause
  id: totrans-1841
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: catch 子句
- en: 'A `catch` clause specifies what type of exception to catch. This must be either
    `System.Exception` or a subclass of `System.Exception`. Catching `System.Exception`
    catches all possible errors. This is useful when:'
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch` 子句指定要捕获的异常类型。这必须是 `System.Exception` 或 `System.Exception` 的子类。捕获 `System.Exception`
    可以捕获所有可能的错误。这在以下情况下非常有用：'
- en: Your program can potentially recover regardless of the specific exception type.
  id: totrans-1843
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的程序可能会无论特定异常类型如何都能够恢复。
- en: You plan to rethrow the exception (perhaps after logging it).
  id: totrans-1844
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你计划重新抛出异常（可能在记录日志后）。
- en: Your error handler is the last resort, prior to termination of the program.
  id: totrans-1845
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在程序终止之前，你的错误处理程序是最后的救援。
- en: More typically, though, you catch *specific exception types* in order to avoid
    having to deal with circumstances for which your handler wasn’t designed (e.g.,
    an `OutOfMemoryException`).
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，更典型的情况是，你捕获*特定的异常类型*，以避免处理处理程序未设计的情况（例如 `OutOfMemoryException`）。
- en: 'You can handle multiple exception types with multiple `catch` clauses:'
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过多个 `catch` 子句处理多个异常类型：
- en: '[PRE439]'
  id: totrans-1848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: Only one `catch` clause executes for a given exception. If you want to include
    a safety net to catch more general exceptions (such as `System.Exception`), you
    must put the more specific handlers *first*.
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定异常，只有一个 `catch` 子句执行。如果要包含一个安全网以捕获更一般的异常（如 `System.Exception`），则必须先放置更具体的处理程序*第一*。
- en: 'You can catch an exception without specifying a variable, if you don’t need
    to access its properties:'
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要指定变量即可捕获异常：
- en: '[PRE440]'
  id: totrans-1851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: 'Furthermore, you can omit both the variable and the type (meaning that all
    exceptions will be caught):'
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以省略变量和类型（意味着捕获所有异常）：
- en: '[PRE441]'
  id: totrans-1853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: Exception filters
  id: totrans-1854
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常过滤器
- en: 'You can specify an *exception filter* in a `catch` clause by adding a `when`
    clause:'
  id: totrans-1855
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过添加`when`子句在`catch`子句中指定异常过滤器：
- en: '[PRE442]'
  id: totrans-1856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: 'If a `WebException` is thrown in this example, the Boolean expression following
    the `when` keyword is then evaluated. If the result is false, the `catch` block
    in question is ignored, and any subsequent `catch` clauses are considered. With
    exception filters, it can be meaningful to catch the same exception type again:'
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在此示例中抛出 `WebException`，则会评估 `when` 关键字后面的布尔表达式。如果结果为假，则忽略相应的 `catch` 块，并考虑任何后续的
    `catch` 子句。使用异常筛选器时，捕获相同的异常类型可能很有意义：
- en: '[PRE443]'
  id: totrans-1858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: The Boolean expression in the `when` clause can be side-effecting, such as a
    method that logs the exception for diagnostic purposes.
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
  zh: '`when` 子句中的布尔表达式可能具有副作用，例如记录异常以进行诊断目的的方法。'
- en: The finally Block
  id: totrans-1860
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: finally 块
- en: A `finally` block always executes—whether or not an exception is thrown and
    whether or not the `try` block runs to completion. `finally` blocks are typically
    used for cleanup code.
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally` 块始终执行 —— 无论是否抛出异常以及 `try` 块是否完整运行。`finally` 块通常用于清理代码。'
- en: 'A `finally` block executes either:'
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally` 块执行：'
- en: After a `catch` block finishes
  id: totrans-1863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `catch` 块完成后
- en: After control leaves the `try` block because of a `jump` statement (e.g., `return`
    or `goto`)
  id: totrans-1864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 `jump` 语句（例如 `return` 或 `goto`）导致控制离开 `try` 块后。
- en: After the `try` block ends
  id: totrans-1865
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `try` 块结束后
- en: 'A `finally` block helps add determinism to a program. In the following example,
    the file that we open *always* gets closed, regardless of whether:'
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally` 块有助于为程序增加确定性。在以下示例中，无论是否：'
- en: The `try` block finishes normally.
  id: totrans-1867
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try` 块正常结束。'
- en: Execution returns early because the file is empty (`EndOfStream`).
  id: totrans-1868
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于文件为空(`EndOfStream`)，执行提前返回。
- en: An `IOException` is thrown while the file is being read.
  id: totrans-1869
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在读取文件时抛出 `IOException`。
- en: '[PRE444]'
  id: totrans-1870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: In this example, we closed the file by calling `Dispose` on the `StreamReader`.
    Calling `Dispose` on an object, within a `finally` block, is a standard convention
    throughout .NET and is supported explicitly in C# through the `using` statement.
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们通过在 `StreamReader` 上调用 `Dispose` 来关闭文件。在 .NET 中，调用对象的 `Dispose` 方法是一个标准惯例，并且在
    C# 中通过 `using` 语句得到了显式支持。
- en: The using statement
  id: totrans-1872
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: using 声明
- en: Many classes encapsulate unmanaged resources such as file handles, graphics
    handles, or database connections. These classes implement `System.IDisposable`,
    which defines a single parameterless method named `Dispose` to clean up these
    resources. The `using` statement provides an elegant syntax for calling `Dispose`
    on an `IDisposable` object within a `finally` block.
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
  zh: 许多类封装了不受管理的资源，例如文件句柄、图形句柄或数据库连接。这些类实现了 `System.IDisposable`，它定义了一个名为 `Dispose`
    的无参数方法，用于清理这些资源。`using` 语句提供了一个优雅的语法，用于在 `finally` 块内调用 `IDisposable` 对象的 `Dispose`
    方法。
- en: 'The following:'
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
  zh: 以下：
- en: '[PRE445]'
  id: totrans-1875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: 'is precisely equivalent to:'
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
  zh: 等价于：
- en: '[PRE446]'
  id: totrans-1877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: using declarations
  id: totrans-1878
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: using 声明
- en: 'If you omit the brackets and statement block following a `using` statement,
    it becomes a *using declaration* (C# 8+). The resource is then disposed when execution
    falls outside the *enclosing* statement block:'
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略 `using` 语句后面的括号和语句块，它就成为*using声明*（C# 8+）。当执行流离开*封闭的*语句块时，资源将被处理：
- en: '[PRE447]'
  id: totrans-1880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: In this case, `reader` will be disposed when execution falls outside the `if`
    statement block.
  id: totrans-1881
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当执行流离开 `if` 语句块时，`reader` 将被处理。
- en: Throwing Exceptions
  id: totrans-1882
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抛出异常
- en: 'Exceptions can be thrown either by the runtime or in user code. In this example,
    `Display` throws a `System.ArgumentNul⁠l​Exception`:'
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
  zh: 异常可以由运行时或用户代码抛出。在此示例中，`Display` 抛出 `System.ArgumentNul⁠l​Exception`：
- en: '[PRE448]'
  id: totrans-1884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: throw expressions
  id: totrans-1885
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抛出表达式
- en: 'From C# 7, `throw` can appear as an expression in expression-bodied functions:'
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 7 开始，`throw` 可以作为表达式出现在表达体函数中：
- en: '[PRE449]'
  id: totrans-1887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: 'A `throw` expression can also appear in a ternary conditional expression:'
  id: totrans-1888
  prefs: []
  type: TYPE_NORMAL
  zh: '`throw` 表达式也可以出现在三元条件表达式中：'
- en: '[PRE450]'
  id: totrans-1889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: Rethrowing an exception
  id: totrans-1890
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新抛出异常
- en: 'You can capture and rethrow an exception as follows:'
  id: totrans-1891
  prefs: []
  type: TYPE_NORMAL
  zh: 可以按如下方式捕获并重新抛出异常：
- en: '[PRE451]'
  id: totrans-1892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: Rethrowing in this manner lets you log an error without *swallowing* it. It
    also lets you back out of handling an exception should circumstances turn out
    to be outside what you expected.
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式重新抛出异常，可以在不*吞噬*异常的情况下记录错误。它还允许你在情况超出预期时退出异常处理。
- en: Note
  id: totrans-1894
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If we replaced `throw` with `throw ex`, the example would still work, but the
    `StackTrace` property of the exception would no longer reflect the original error.
  id: totrans-1895
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `throw` 替换为 `throw ex`，示例仍将正常工作，但异常的 `StackTrace` 属性将不再反映原始错误。
- en: 'The other common scenario is to rethrow a more specific or meaningful exception
    type:'
  id: totrans-1896
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的情况是重新抛出更具体或有意义的异常类型：
- en: '[PRE452]'
  id: totrans-1897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: When rethrowing a different exception, you can populate the `InnerException`
    property with the original exception to aid debugging. Nearly all types of exceptions
    provide a constructor for this purpose (such as in our example).
  id: totrans-1898
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新抛出不同的异常时，可以将 `InnerException` 属性填充为原始异常以帮助调试。几乎所有类型的异常都提供了此目的的构造函数（例如我们的示例中）。
- en: Key Properties of System.Exception
  id: totrans-1899
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`System.Exception` 的关键属性'
- en: 'The most important properties of `System.Exception` are the following:'
  id: totrans-1900
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Exception` 的最重要属性如下：'
- en: '`StackTrace`'
  id: totrans-1901
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackTrace`'
- en: A string representing all the methods that are called from the origin of the
    exception to the `catch` block.
  id: totrans-1902
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字符串，表示从异常的起源到 `catch` 块调用的所有方法。
- en: '`Message`'
  id: totrans-1903
  prefs: []
  type: TYPE_NORMAL
  zh: '`Message`'
- en: A string with a description of the error.
  id: totrans-1904
  prefs: []
  type: TYPE_NORMAL
  zh: 一个带有错误描述的字符串。
- en: '`InnerException`'
  id: totrans-1905
  prefs: []
  type: TYPE_NORMAL
  zh: '`InnerException`'
- en: The inner exception (if any) that caused the outer exception. This, itself,
    might have another `InnerException`.
  id: totrans-1906
  prefs: []
  type: TYPE_NORMAL
  zh: 内部异常（如果有）引发了外部异常。这本身可能有另一个 `InnerException`。
- en: Enumeration and Iterators
  id: totrans-1907
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举和迭代器
- en: Enumeration
  id: totrans-1908
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举
- en: 'An *enumerator* is a read-only, forward-only cursor over a *sequence of values*.
    C# treats a type as an enumerator if it does any of the following:'
  id: totrans-1909
  prefs: []
  type: TYPE_NORMAL
  zh: '*枚举器* 是一种只读的、单向的值序列游标。如果 C# 做了以下任何一件事情，则将类型视为枚举器：'
- en: Has a public parameterless method named `MoveNext` and property called `Current`
  id: totrans-1910
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有名为 `MoveNext` 的公共无参数方法和名为 `Current` 的属性
- en: Implements `System.Collections.Generic.IEnumerator<T>`
  id: totrans-1911
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现了 `System.Collections.Generic.IEnumerator<T>`
- en: Implements `System.Collections.IEnumerator`
  id: totrans-1912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现了 `System.Collections.IEnumerator`
- en: 'The `foreach` statement iterates over an *enumerable* object. An enumerable
    object is the logical representation of a sequence. It is not itself a cursor
    but an object that produces cursors over itself. C# treats a type as enumerable
    if it does any of the following (the check is performed in this order):'
  id: totrans-1913
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach` 语句迭代 *可枚举* 对象。可枚举对象是序列的逻辑表示。它本身不是游标，而是生成自身上的游标的对象。如果 C# 做了以下任何一件事情，则将类型视为可枚举（按照此顺序进行检查）：'
- en: Has a public parameterless method named `GetEnumerator` that returns an enumerator
  id: totrans-1914
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有公共的无参数方法 `GetEnumerator`，返回一个枚举器
- en: Implements `System.Collections.Generic.IEnumerable<T>`
  id: totrans-1915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现了 `System.Collections.Generic.IEnumerable<T>`
- en: Implements `System.Collections.IEnumerable`
  id: totrans-1916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现了 `System.Collections.IEnumerable`
- en: (From C# 9) Can bind to an *extension method* named `GetEnumerator` that returns
    an enumerator (see [“Extension Methods”](#extension_methods))
  id: totrans-1917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （自 C# 9 起）可以绑定到名为 `GetEnumerator` 的 *扩展方法*，该方法返回一个枚举器（参见 [“扩展方法”](#extension_methods)）
- en: 'The enumeration pattern is as follows:'
  id: totrans-1918
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举模式如下：
- en: '[PRE453]'
  id: totrans-1919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: 'Here is the high-level way to iterate through the characters in the word *beer*
    using a `foreach` statement:'
  id: totrans-1920
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 `foreach` 语句迭代单词 *beer* 中字符的高级方法：
- en: '[PRE454]'
  id: totrans-1921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: 'Here is the low-level way to iterate through the characters in *beer* without
    using a `foreach` statement:'
  id: totrans-1922
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在不使用 `foreach` 语句的情况下低级迭代单词 *beer* 中字符的方法：
- en: '[PRE455]'
  id: totrans-1923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: If the enumerator implements `IDisposable`, the `foreach` statement also acts
    as a `using` statement, implicitly disposing the enumerator object.
  id: totrans-1924
  prefs: []
  type: TYPE_NORMAL
  zh: 如果枚举器实现了 `IDisposable`，则 `foreach` 语句还充当 `using` 语句，隐式处理枚举器对象。
- en: Collection Initializers and Collection Expressions
  id: totrans-1925
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合初始化器和集合表达式
- en: 'You can instantiate and populate an enumerable object in a single step. For
    example:'
  id: totrans-1926
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以一步实例化和填充可枚举对象。例如：
- en: '[PRE456]'
  id: totrans-1927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: 'From C# 12, you can shorten the last line further with a *collection expression*
    (note the square brackets):'
  id: totrans-1928
  prefs: []
  type: TYPE_NORMAL
  zh: 自 C# 12 起，您可以使用 *集合表达式* 进一步缩短最后一行（请注意方括号）：
- en: '[PRE457]'
  id: totrans-1929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: Note
  id: totrans-1930
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Collection expressions are *target-typed*, meaning that the type of `[1,2,3]`
    depends on the type to which it’s assigned (in this case, `List<int>`). In the
    following example, the target type is an array:'
  id: totrans-1931
  prefs: []
  type: TYPE_NORMAL
  zh: 集合表达式是 *目标类型化* 的，这意味着 `[1,2,3]` 的类型取决于它被分配的类型（在本例中为 `List<int>`）。在下面的示例中，目标类型是数组：
- en: '[PRE458]'
  id: totrans-1932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: 'Target typing means that you can omit the type in other scenarios where the
    compiler can infer it, such as when calling methods:'
  id: totrans-1933
  prefs: []
  type: TYPE_NORMAL
  zh: 目标类型化意味着您可以在编译器可以推断类型的其他情况下省略类型，例如在调用方法时：
- en: '[PRE459]'
  id: totrans-1934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: 'The compiler translates this into the following:'
  id: totrans-1935
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将其转换为以下内容：
- en: '[PRE460]'
  id: totrans-1936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: 'This requires that the enumerable object implements the `System.Collections.IEnumerable`
    interface and that it has an `Add` method that has the appropriate number of parameters
    for the call. You can similarly initialize dictionaries (types that implement
    `System.Collections.IDictionary`) as follows:'
  id: totrans-1937
  prefs: []
  type: TYPE_NORMAL
  zh: 这要求可枚举对象实现 `System.Collections.IEnumerable` 接口，并且具有 `Add` 方法，该方法对于调用具有适当数量参数的方法非常重要。您可以像下面这样初始化字典（实现了
    `System.Collections.IDictionary` 接口的类型）：
- en: '[PRE461]'
  id: totrans-1938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: 'Or, more succinctly:'
  id: totrans-1939
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更简洁地说：
- en: '[PRE462]'
  id: totrans-1940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: The latter is valid not only with dictionaries but with any type for which an
    indexer exists.
  id: totrans-1941
  prefs: []
  type: TYPE_NORMAL
  zh: 后者不仅适用于字典，还适用于任何具有索引器的类型。
- en: Iterators
  id: totrans-1942
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器
- en: 'Whereas a `foreach` statement is a *consumer* of an enumerator, an iterator
    is a *producer* of an enumerator. In this example, we use an iterator to return
    a sequence of Fibonacci numbers (for which each number is the sum of the previous
    two):'
  id: totrans-1943
  prefs: []
  type: TYPE_NORMAL
  zh: 而 `foreach` 语句是枚举器的 *消费者*，迭代器则是枚举器的 *生产者*。在这个例子中，我们使用迭代器来返回斐波那契数列（其中每个数字是前两个数字的和）：
- en: '[PRE463]'
  id: totrans-1944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: Whereas a `return` statement expresses, “Here’s the value you asked me to return
    from this method,” a `yield return` statement expresses, “Here’s the next element
    you asked me to yield from this enumerator.” On each `yield` statement, control
    is returned to the caller, but the callee’s state is maintained so that the method
    can continue executing as soon as the caller enumerates the next element. The
    lifetime of this state is bound to the enumerator, such that the state can be
    released when the caller has finished enumerating.
  id: totrans-1945
  prefs: []
  type: TYPE_NORMAL
  zh: 而 `return` 语句表达“这是你要求我从这个方法返回的值”，`yield return` 语句则表达“这是你要求我从这个枚举器中 `yield`
    的下一个元素”。在每个 `yield` 语句上，控制权返回给调用者，但被调用者的状态保持不变，以便方法可以在调用者枚举下一个元素时继续执行。此状态的生命周期与枚举器绑定，因此当调用者完成枚举时，状态可以被释放。
- en: Note
  id: totrans-1946
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The compiler converts iterator methods into private classes that implement `IEnumerable<T>`
    and/or `IEnumerator<T>`. The logic within the iterator block is “inverted” and
    spliced into the `MoveNext` method and the `Current` property on the compiler-written
    enumerator class, which effectively becomes a state machine. This means that when
    you call an iterator method, all you’re doing is instantiating the compiler-written
    class; none of your code actually runs! Your code runs only when you start enumerating
    over the resultant sequence, typically with a `foreach` statement.
  id: totrans-1947
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将迭代器方法转换为实现 `IEnumerable<T>` 和/或 `IEnumerator<T>` 的私有类。迭代器块内部的逻辑被“反转”并插入到编译器生成的枚举器类的
    `MoveNext` 方法和 `Current` 属性中，它们实际上成为了状态机。这意味着当您调用迭代器方法时，实际上只是实例化了编译器生成的类；您的代码只有在您开始枚举生成的序列时才会运行，通常是使用
    `foreach` 语句。
- en: Iterator Semantics
  id: totrans-1948
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器语义
- en: 'An iterator is a method, property, or indexer that contains one or more `yield`
    statements. An iterator must return one of the following four interfaces (otherwise,
    the compiler will generate an error):'
  id: totrans-1949
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是一个方法、属性或索引器，其中包含一个或多个 `yield` 语句。迭代器必须返回以下四个接口之一（否则编译器将生成错误）：
- en: '[PRE464]'
  id: totrans-1950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: 'Iterators that return an *enumerator* interface tend to be used less often.
    They’re useful when you’re writing a custom collection class: typically, you name
    the iterator `GetEnumerator` and have your class implement `IEnumerable<T>`.'
  id: totrans-1951
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 *enumerator* 接口的迭代器通常使用较少。它们在编写自定义集合类时很有用：通常，您将迭代器命名为 `GetEnumerator` 并让您的类实现
    `IEnumerable<T>`。
- en: Iterators that return an *enumerable* interface are more common—and simpler
    to use because you don’t need to write a collection class. The compiler, behind
    the scenes, writes a private class implementing `IEnumerable<T>` (as well as `IEnumerator<T>`).
  id: totrans-1952
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 *enumerable* 接口的迭代器更常见，并且使用起来更简单，因为您不需要编写集合类。编译器在幕后会生成一个实现 `IEnumerable<T>`（以及
    `IEnumerator<T>`）的私有类。
- en: Multiple yield statements
  id: totrans-1953
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个 yield 语句
- en: 'An iterator can include multiple `yield` statements:'
  id: totrans-1954
  prefs: []
  type: TYPE_NORMAL
  zh: 一个迭代器可以包含多个 `yield` 语句：
- en: '[PRE465]'
  id: totrans-1955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: yield break
  id: totrans-1956
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: yield break
- en: 'A `return` statement is illegal in an iterator block; instead, you must use
    the `yield break` statement to indicate that the iterator block should exit early,
    without returning more elements. We can modify `Foo` as follows to demonstrate:'
  id: totrans-1957
  prefs: []
  type: TYPE_NORMAL
  zh: 在迭代器块中使用 `return` 语句是非法的；相反，您必须使用 `yield break` 语句来指示迭代器块应该提前退出，而不返回更多元素。我们可以修改
    `Foo` 如下所示来演示：
- en: '[PRE466]'
  id: totrans-1958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: Composing Sequences
  id: totrans-1959
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合序列
- en: 'Iterators are highly composable. We can extend our Fibonacci example by adding
    the following method to the class:'
  id: totrans-1960
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器非常易于组合。我们可以通过将以下方法添加到类中来扩展我们的斐波那契示例：
- en: '[PRE467]'
  id: totrans-1961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: 'We can then output even Fibonacci numbers as follows:'
  id: totrans-1962
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下输出偶数斐波那契数：
- en: '[PRE468]'
  id: totrans-1963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: Each element is not calculated until the last moment—when requested by a `MoveNext()`
    operation. [Figure 5](#composing_sequence) shows the data requests and data output
    over time.
  id: totrans-1964
  prefs: []
  type: TYPE_NORMAL
  zh: 每个元素直到最后一刻才计算——在被请求的 `MoveNext()` 操作时。[图 5](#composing_sequence) 展示了随时间推移的数据请求和数据输出。
- en: '![Composing sequences](Images/c12p_0105.png)'
  id: totrans-1965
  prefs: []
  type: TYPE_IMG
  zh: '![组合序列](Images/c12p_0105.png)'
- en: Figure 5\. Composing sequences
  id: totrans-1966
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5\. 组合序列
- en: The composability of the iterator pattern is essential in building LINQ queries.
  id: totrans-1967
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器模式的组合性在构建LINQ查询中至关重要。
- en: Nullable Value Types
  id: totrans-1968
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可空值类型
- en: 'Reference types can represent a nonexistent value with a null reference. Value
    types, however, cannot ordinarily represent null values. For example:'
  id: totrans-1969
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型可以用空引用表示不存在的值。然而，值类型通常不能表示null值。例如：
- en: '[PRE469]'
  id: totrans-1970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: 'To represent null in a value type, you must use a special construct called
    a *nullable type*. A nullable type is denoted with a value type followed by the
    `?` symbol:'
  id: totrans-1971
  prefs: []
  type: TYPE_NORMAL
  zh: 要在值类型中表示null，必须使用称为*可空类型*的特殊构造。可空类型用值类型后跟`?`符号表示：
- en: '[PRE470]'
  id: totrans-1972
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: Nullable<T> Struct
  id: totrans-1973
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Nullable<T> 结构体
- en: '`T?` translates into `System.Nullable<T>`. `Nullable<T>` is a lightweight immutable
    structure, having only two fields, to represent `Value` and `HasValue`. The essence
    of `System.Nullable<T>` is very simple:'
  id: totrans-1974
  prefs: []
  type: TYPE_NORMAL
  zh: '`T?`翻译成`System.Nullable<T>`。`Nullable<T>`是一个轻量级的不可变结构，只有两个字段，用于表示`Value`和`HasValue`。`System.Nullable<T>`的本质非常简单：'
- en: '[PRE471]'
  id: totrans-1975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: 'The following code:'
  id: totrans-1976
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码：
- en: '[PRE472]'
  id: totrans-1977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: 'translates to:'
  id: totrans-1978
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译为：
- en: '[PRE473]'
  id: totrans-1979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: Attempting to retrieve `Value` when `HasValue` is false throws an `InvalidOperationException`.
    `GetValueOrDefault()` returns `Value` if `HasValue` is true; otherwise, it returns
    `new T()` or a specified custom default value.
  id: totrans-1980
  prefs: []
  type: TYPE_NORMAL
  zh: 当`HasValue`为false时尝试检索`Value`会引发`InvalidOperationException`。`GetValueOrDefault()`在`HasValue`为true时返回`Value`；否则返回`new
    T()`或指定的自定义默认值。
- en: The default value of `T?` is `null`.
  id: totrans-1981
  prefs: []
  type: TYPE_NORMAL
  zh: '`T?`的默认值是`null`。'
- en: Nullable Conversions
  id: totrans-1982
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可空类型转换
- en: 'The conversion from `T` to `T?` is implicit, while from `T?` to `T` the conversion
    is explicit. For example:'
  id: totrans-1983
  prefs: []
  type: TYPE_NORMAL
  zh: 从`T`到`T?`的转换是隐式的，而从`T?`到`T`的转换是显式的。例如：
- en: '[PRE474]'
  id: totrans-1984
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: The explicit cast is directly equivalent to calling the nullable object’s `Value`
    property. Hence, an `InvalidOperationException` is thrown if `HasValue` is false.
  id: totrans-1985
  prefs: []
  type: TYPE_NORMAL
  zh: 显式转换直接等同于调用可空对象的`Value`属性。因此，如果`HasValue`为false，则会引发`InvalidOperationException`。
- en: Boxing/Unboxing Nullable Values
  id: totrans-1986
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对可空值类型进行装箱/拆箱
- en: When `T?` is boxed, the boxed value on the heap contains `T`, not `T?`. This
    optimization is possible because a boxed value is a reference type that can already
    express null.
  id: totrans-1987
  prefs: []
  type: TYPE_NORMAL
  zh: 当`T?`被装箱时，堆上的装箱值包含`T`，而不是`T?`。这种优化是可能的，因为装箱值是一个可以表示null的引用类型。
- en: 'C# also permits the unboxing of nullable types with the `as` operator. The
    result will be `null` if the cast fails:'
  id: totrans-1988
  prefs: []
  type: TYPE_NORMAL
  zh: C#也允许使用`as`运算符对可空类型进行拆箱。如果转换失败，则结果将为`null`：
- en: '[PRE475]'
  id: totrans-1989
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: Operator Lifting
  id: totrans-1990
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运算符提升
- en: 'The `Nullable<T>` struct does not define operators such as `<`, `>`, or even
    `==`. Despite this, the following code compiles and executes correctly:'
  id: totrans-1991
  prefs: []
  type: TYPE_NORMAL
  zh: '`Nullable<T>`结构体并未定义诸如`<`、`>`或甚至`==`之类的运算符。尽管如此，以下代码编译并正确执行：'
- en: '[PRE476]'
  id: totrans-1992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: 'This works because the compiler borrows or “lifts” the less-than operator from
    the underlying value type. Semantically, it translates the preceding comparison
    expression into this:'
  id: totrans-1993
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为编译器从基础值类型借用或“提升”了小于运算符。从语义上讲，它将前面的比较表达式转换为：
- en: '[PRE477]'
  id: totrans-1994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: In other words, if both `x` and `y` have values, it compares via `int`’s less-than
    operator; otherwise, it returns `false`.
  id: totrans-1995
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果`x`和`y`都有值，则通过`int`的小于运算符比较；否则返回`false`。
- en: Operator lifting means that you can implicitly use `T`’s operators on `T?`.
    You can define operators for `T?` in order to provide special-purpose null behavior,
    but in the vast majority of cases, it’s best to rely on the compiler automatically
    applying systematic nullable logic for you.
  id: totrans-1996
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符提升意味着您可以隐式地在`T?`上使用`T`的运算符。您可以为`T?`定义运算符，以提供特定的空值行为，但在绝大多数情况下，最好依赖编译器自动为您应用系统化的可空逻辑。
- en: The compiler performs null logic differently depending on the category of operator.
  id: totrans-1997
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器根据运算符的类别在空值逻辑上执行不同的操作。
- en: Equality operators (==, !=)
  id: totrans-1998
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相等运算符 (==, !=)
- en: 'Lifted equality operators handle nulls just like reference types do. This means
    two null values are equal:'
  id: totrans-1999
  prefs: []
  type: TYPE_NORMAL
  zh: 提升的相等运算符处理null值就像引用类型一样。这意味着两个null值是相等的：
- en: '[PRE478]'
  id: totrans-2000
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: 'Further:'
  id: totrans-2001
  prefs: []
  type: TYPE_NORMAL
  zh: 更进一步：
- en: If exactly one operand is null, the operands are unequal.
  id: totrans-2002
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果恰好一个操作数为null，则操作数不相等。
- en: If both operands are non-null, their `Value`s are compared.
  id: totrans-2003
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个操作数均非null，则比较它们的`Value`。
- en: Relational operators (<, <=, >=, >)
  id: totrans-2004
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关系运算符 (<、<=、>=、>)
- en: 'The relational operators work on the principle that it is meaningless to compare
    null operands. This means that comparing a null value to either a null or a non-null
    value returns `false`:'
  id: totrans-2005
  prefs: []
  type: TYPE_NORMAL
  zh: 关系运算符基于不能比较null操作数的原则。这意味着将null值与null或非null值比较会返回`false`：
- en: '[PRE479]'
  id: totrans-2006
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: All other operators (+, −, *, /, %, &, |, ^, <<, >>, +, ++, --, !, ~)
  id: totrans-2007
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 所有其他运算符（+、−、*、/、%、&、|、^、<<、>>、+、++、--、!、~）
- en: 'These operators return null when any of the operands are null. This pattern
    should be familiar to SQL users:'
  id: totrans-2008
  prefs: []
  type: TYPE_NORMAL
  zh: 当任一操作数为空时，这些运算符返回空。这种模式对于 SQL 用户来说应该很熟悉：
- en: '[PRE480]'
  id: totrans-2009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: An exception is when the `&` and `|` operators are applied to `bool?`, which
    we will discuss shortly.
  id: totrans-2010
  prefs: []
  type: TYPE_NORMAL
  zh: 例外情况是当`&`和`|`运算符应用于`bool?`时，我们稍后会讨论。
- en: Mixing nullable and non-nullable types
  id: totrans-2011
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混合可空和非可空类型
- en: 'You can mix and match nullable and non-nullable types (this works because there
    is an implicit conversion from `T` to `T?`):'
  id: totrans-2012
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以混合和匹配可空和非可空类型（这是因为存在从`T`到`T?`的隐式转换）：
- en: '[PRE481]'
  id: totrans-2013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: bool? with & and | Operators
  id: totrans-2014
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`bool?`与`&`和`|`运算符'
- en: 'When supplied operands of type `bool?`, the `&` and `|` operators treat `null`
    as an *unknown value*. So, `null | true` is true, because:'
  id: totrans-2015
  prefs: []
  type: TYPE_NORMAL
  zh: 当提供`bool?`类型的操作数时，`&`和`|`运算符将`null`视为*未知值*。因此，`null | true`为true，因为：
- en: If the unknown value is false, the result would be true.
  id: totrans-2016
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果未知值为false，则结果将为true。
- en: If the unknown value is true, the result would be true.
  id: totrans-2017
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果未知值为true，则结果将为true。
- en: 'Similarly, `null & false` is false. This behavior should be familiar to SQL
    users. The following example enumerates other combinations:'
  id: totrans-2018
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`null & false`为false。这种行为对 SQL 用户来说应该很熟悉。以下示例列举了其他组合：
- en: '[PRE482]'
  id: totrans-2019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: Nullable Types and Null Operators
  id: totrans-2020
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可空类型和空操作符
- en: 'Nullable types work particularly well with the `??` operator (see [“Null-Coalescing
    Operator”](#null_coalescing_operator)). For example:'
  id: totrans-2021
  prefs: []
  type: TYPE_NORMAL
  zh: 可空类型特别适用于`??`运算符（参见[“空合并运算符”](#null_coalescing_operator)）。例如：
- en: '[PRE483]'
  id: totrans-2022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: Using `??` on a nullable value type is equivalent to calling `GetValueOrDefault`
    with an explicit default value, except that the expression for the default value
    is never evaluated if the variable is not null.
  id: totrans-2023
  prefs: []
  type: TYPE_NORMAL
  zh: 在可空值类型上使用`??`等同于使用`GetValueOrDefault`来调用显式默认值，唯一的区别是如果变量不为空，则默认值的表达式不会被评估。
- en: 'Nullable types also work well with the null-conditional operator (see [“Null-Conditional
    Operator”](#null_conditional_operator)). In the following example, `length` evaluates
    to null:'
  id: totrans-2024
  prefs: []
  type: TYPE_NORMAL
  zh: 可空类型也与空条件运算符配合得很好（参见[“空条件运算符”](#null_conditional_operator)）。在以下示例中，`length`评估为空：
- en: '[PRE484]'
  id: totrans-2025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: 'We can combine this with the null-coalescing operator to evaluate to zero instead
    of null:'
  id: totrans-2026
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将此与空合并运算符结合使用，以评估为零而不是空：
- en: '[PRE485]'
  id: totrans-2027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: Nullable Reference Types
  id: totrans-2028
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可空引用类型
- en: Whereas *nullable value types* bring nullability to value types, *nullable reference
    types* (from C# 8) do the opposite. When enabled, they bring (a degree of) *non-nullability*
    to reference types, with the purpose of helping to avoid `NullReference​Excep⁠tion`s.
  id: totrans-2029
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管*可空值类型*将空性引入值类型，*可空引用类型*（来自 C# 8）则相反。启用时，它们将（一定程度的）*非空性*引入引用类型，旨在帮助避免`NullReference​Excep⁠tion`。
- en: Nullable reference types introduce a level of safety that’s enforced purely
    by the compiler in the form of warnings when it detects code that’s at risk of
    generating a `NullReference​Excep⁠tion`.
  id: totrans-2030
  prefs: []
  type: TYPE_NORMAL
  zh: 可空引用类型通过编译器纯粹强制执行安全级别，在检测到有可能生成`NullReference​Excep⁠tion`的代码时生成警告。
- en: 'To enable nullable reference types, you must either add the `Nullable` element
    to your *.csproj* project file (if you want to enable it for the entire project):'
  id: totrans-2031
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用可空引用类型，您必须将`Nullable`元素添加到您的*.csproj*项目文件中（如果要为整个项目启用它）：
- en: '[PRE486]'
  id: totrans-2032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: 'and/or you can use the following directives in your code, in the places where
    it should take effect:'
  id: totrans-2033
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在代码中的适当位置使用以下指令来使其生效：
- en: '[PRE487]'
  id: totrans-2034
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: 'After it is enabled, the compiler makes non-nullability the default: if you
    want a reference type to accept nulls without the compiler generating a warning,
    you must apply the `?` suffix to indicate a *nullable reference type*. In the
    following example, `s1` is non-nullable, whereas `s2` is nullable:'
  id: totrans-2035
  prefs: []
  type: TYPE_NORMAL
  zh: 启用后，编译器将非空性设置为默认值：如果要使引用类型接受空值而不生成警告，必须添加`?`后缀以指示*可空引用类型*。在以下示例中，`s1`是非可空的，而`s2`是可空的：
- en: '[PRE488]'
  id: totrans-2036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: Note
  id: totrans-2037
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Because nullable reference types are compile-time constructs, there’s no runtime
    difference between `string` and `string?`. In contrast, nullable value types introduce
    something concrete into the type system—namely, the `Null​a⁠ble<T>` struct.
  id: totrans-2038
  prefs: []
  type: TYPE_NORMAL
  zh: 因为可空引用类型是编译时构造，所以在`string`和`string?`之间没有运行时差异。相比之下，可空值类型在类型系统中引入了具体内容，即`Null​a⁠ble<T>`结构。
- en: 'The following also generates a warning because `x` is not initialized:'
  id: totrans-2039
  prefs: []
  type: TYPE_NORMAL
  zh: 以下也会生成警告，因为`x`未初始化：
- en: '[PRE489]'
  id: totrans-2040
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: The warning disappears if you initialize `x`, either via a field initializer
    or via code in the constructor.
  id: totrans-2041
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过字段初始化器或构造函数中的代码初始化`x`，警告将消失。
- en: 'The compiler also warns you upon dereferencing a nullable reference type if
    it thinks a `NullReferenceException` might occur. In the following example, accessing
    the string’s `Length` property generates a warning:'
  id: totrans-2042
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译器认为可能会发生`NullReferenceException`，则在对可空引用类型进行解引用时也会向您发出警告。在以下示例中，访问字符串的 `Length`
    属性会生成警告：
- en: '[PRE490]'
  id: totrans-2043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: 'To remove the warning, you can use the *null-forgiving operator* (`!`):'
  id: totrans-2044
  prefs: []
  type: TYPE_NORMAL
  zh: 要消除警告，可以使用*空值忽略运算符* (`!`)：
- en: '[PRE491]'
  id: totrans-2045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: 'Our use of the null-forgiving operator in this example is dangerous in that
    we could end up throwing the very `NullReferen⁠ce​Exception` we were trying to
    avoid in the first place. We could fix it as follows:'
  id: totrans-2046
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中使用的空值忽略运算符是危险的，因为我们最初试图避免的`NullReferen⁠ce​Exception`可能会被抛出。我们可以按如下方式修复它：
- en: '[PRE492]'
  id: totrans-2047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: Notice now that we don’t need the null-forgiving operator. This is because the
    compiler performs static analysis and is smart enough to infer—at least in simple
    cases—when a dereference is safe and there’s no chance of a `NullReferenceException.`
  id: totrans-2048
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请注意，我们不再需要空值忽略运算符。这是因为编译器执行静态分析，并且在简单情况下足够聪明以推断出解引用是安全的，没有`NullReferenceException`的可能。
- en: 'The compiler’s ability to detect and warn is not bulletproof, and there are
    also limits to what’s possible in terms of coverage. For instance, it’s unable
    to know whether an array’s elements have been populated, and so the following
    does not generate a warning:'
  id: totrans-2049
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器检测和警告的能力并不是绝对可靠的，而且在覆盖范围方面也存在限制。例如，它无法知道数组的元素是否已被填充，因此以下情况不会生成警告：
- en: '[PRE493]'
  id: totrans-2050
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: Extension Methods
  id: totrans-2051
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展方法
- en: '*Extension methods* allow an existing type to be extended with new methods
    without altering the definition of the original type. An extension method is a
    static method of a static class, where the `this` modifier is applied to the first
    parameter. The type of the first parameter will be the type that is extended.
    For example:'
  id: totrans-2052
  prefs: []
  type: TYPE_NORMAL
  zh: '*扩展方法* 允许在不改变原始类型定义的情况下为现有类型添加新方法。扩展方法是静态类的静态方法，其中第一个参数应用了 `this` 修饰符。第一个参数的类型将是扩展的类型。例如：'
- en: '[PRE494]'
  id: totrans-2053
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: 'The `IsCapitalized` extension method can be called as though it were an instance
    method on a string, as follows:'
  id: totrans-2054
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsCapitalized` 扩展方法可以被调用，就像它是一个字符串上的实例方法一样，如下所示：'
- en: '[PRE495]'
  id: totrans-2055
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: 'An extension method call, when compiled, is translated back into an ordinary
    static method call:'
  id: totrans-2056
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法调用在编译时会被转换回普通的静态方法调用：
- en: '[PRE496]'
  id: totrans-2057
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: 'Interfaces can be extended, too:'
  id: totrans-2058
  prefs: []
  type: TYPE_NORMAL
  zh: 接口也可以被扩展：
- en: '[PRE497]'
  id: totrans-2059
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: Extension Method Chaining
  id: totrans-2060
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展方法链
- en: 'Extension methods, like instance methods, provide a tidy way to chain functions.
    Consider the following two functions:'
  id: totrans-2061
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法与实例方法一样，提供了一种整洁的方法来链式调用函数。考虑以下两个函数：
- en: '[PRE498]'
  id: totrans-2062
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: '`x` and `y` are equivalent, and both evaluate to `"Sausages"`, but `x` uses
    extension methods, whereas `y` uses static methods:'
  id: totrans-2063
  prefs: []
  type: TYPE_NORMAL
  zh: '`x` 和 `y` 是等价的，都会评估为`"Sausages"`，但 `x` 使用扩展方法，而 `y` 使用静态方法：'
- en: '[PRE499]'
  id: totrans-2064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: Ambiguity and Resolution
  id: totrans-2065
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 歧义和解决方案
- en: Any compatible instance method will always take precedence over an extension
    method—even when the extension method’s parameters are more specifically type-matched.
  id: totrans-2066
  prefs: []
  type: TYPE_NORMAL
  zh: 任何兼容的实例方法总是优先于扩展方法—即使扩展方法的参数更具体匹配类型。
- en: If two extension methods have the same signature, the extension method must
    be called as an ordinary static method to disambiguate the method to call. If
    one extension method has more specific arguments, however, the more specific method
    takes precedence.
  id: totrans-2067
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个扩展方法具有相同的签名，则必须将扩展方法调用为普通静态方法，以消除调用方法的歧义。然而，如果一个扩展方法具有更具体的参数，则更具体的方法优先。
- en: Anonymous Types
  id: totrans-2068
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名类型
- en: 'An *anonymous type* is a simple class created on the fly to store a set of
    values. To create an anonymous type, you use the `new` keyword followed by an
    object initializer, specifying the properties and values the type will contain.
    For example:'
  id: totrans-2069
  prefs: []
  type: TYPE_NORMAL
  zh: '*匿名类型* 是一个简单的类，即时创建用于存储一组值。要创建匿名类型，您使用 `new` 关键字，后跟对象初始化程序，指定类型将包含的属性和值。例如：'
- en: '[PRE500]'
  id: totrans-2070
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: The compiler resolves this by writing a private nested type with read-only properties
    for `Name` (type `string`) and `Age` (type `int`). You must use the `var` keyword
    to reference an anonymous type, because the type’s name is compiler-generated.
  id: totrans-2071
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器通过编写一个私有嵌套类型，为 `Name`（类型为 `string`）和 `Age`（类型为 `int`）生成只读属性来解决这个问题。必须使用 `var`
    关键字引用匿名类型，因为类型名称是由编译器生成的。
- en: 'The property name of an anonymous type can be inferred from an expression that
    is itself an identifier; consider, for example:'
  id: totrans-2072
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名类型的属性名称可以从表达式中推断出，该表达式本身是一个标识符；例如：
- en: '[PRE501]'
  id: totrans-2073
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: 'This is equivalent to:'
  id: totrans-2074
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于：
- en: '[PRE502]'
  id: totrans-2075
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: 'You can create arrays of anonymous types as follows:'
  id: totrans-2076
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像下面这样创建匿名类型的数组：
- en: '[PRE503]'
  id: totrans-2077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: Anonymous types are used primarily when you’re writing LINQ queries.
  id: totrans-2078
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名类型主要用于编写 LINQ 查询时使用。
- en: Anonymous types are immutable, so instances cannot be modified after creation.
    However, from C# 10, you can use the `with` keyword to create a copy with variations,
    as you would with records. See [“Nondestructive Mutation”](#nondestructive_mutation)
    for an example.
  id: totrans-2079
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名类型是不可变的，因此实例在创建后无法修改。然而，从 C# 10 开始，你可以使用 `with` 关键字创建具有变化的副本，就像使用记录一样。请参见[“非破坏性变异”](#nondestructive_mutation)中的示例。
- en: Tuples
  id: totrans-2080
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: Like anonymous types, *tuples* (C# 7+) provide a simple way to store a set of
    values. Tuples were introduced into C# with the main purpose of allowing methods
    to return multiple values without resorting to `out` parameters (something you
    cannot do with anonymous types). Since then, however, *records* have been introduced,
    offering a concise typed approach that we will describe in the following section.
  id: totrans-2081
  prefs: []
  type: TYPE_NORMAL
  zh: 与匿名类型类似，*元组*（C# 7+）提供了一种简单的方法来存储一组值。元组是为了允许方法返回多个值而引入到 C# 中的，而无需使用 `out` 参数（这是匿名类型无法做到的）。然而，此后，*记录*已被引入，提供了一种简洁的类型化方法，我们将在接下来的章节中描述。
- en: 'The simplest way to create a *tuple literal* is to list the desired values
    in parentheses. This creates a tuple with *unnamed* elements:'
  id: totrans-2082
  prefs: []
  type: TYPE_NORMAL
  zh: 创建*元组字面量*的最简单方法是在括号中列出所需的值。这将创建一个具有*未命名*元素的元组：
- en: '[PRE504]'
  id: totrans-2083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: 'Unlike with anonymous types, `var` is optional, and you can specify a *tuple
    type* explicitly:'
  id: totrans-2084
  prefs: []
  type: TYPE_NORMAL
  zh: 与匿名类型不同，`var` 是可选的，并且你可以明确指定*元组类型*：
- en: '[PRE505]'
  id: totrans-2085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: 'This means that you can usefully return a tuple from a method:'
  id: totrans-2086
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以从方法中有用地返回一个元组：
- en: '[PRE506]'
  id: totrans-2087
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: 'Tuples play well with generics, so the following types are all legal:'
  id: totrans-2088
  prefs: []
  type: TYPE_NORMAL
  zh: 元组与泛型兼容，因此以下类型都是合法的：
- en: '[PRE507]'
  id: totrans-2089
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: Tuples are *value types* with *mutable* (read/write) elements. This means that
    you can modify `Item1`, `Item2`, and so on, after creating a tuple.
  id: totrans-2090
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是*值类型*，其元素是*可变*（读写）的。这意味着创建元组后，你可以修改`Item1`、`Item2`等元素。
- en: Naming Tuple Elements
  id: totrans-2091
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名元组元素
- en: 'You can optionally give meaningful names to elements when creating tuple literals:'
  id: totrans-2092
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建元组字面量时，你可以选择为元素指定有意义的名称：
- en: '[PRE508]'
  id: totrans-2093
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: 'You can do the same when specifying *tuple types*:'
  id: totrans-2094
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定*元组类型*时，你也可以这样做：
- en: '[PRE509]'
  id: totrans-2095
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: 'Element names are automatically *inferred* from property or field names:'
  id: totrans-2096
  prefs: []
  type: TYPE_NORMAL
  zh: 元素名称从属性或字段名称*推断*出：
- en: '[PRE510]'
  id: totrans-2097
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: Note
  id: totrans-2098
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Tuples are syntactic sugar for using a family of generic structs called `ValueTuple<T1>`
    and `ValueTuple<T1,T2>`, which have fields named `Item1`, `Item2`, and so on.
    Hence `(string,int)` is an alias for `ValueTuple<string,int>`. This means that
    “named elements” exist only in the source code—and the imagination of the compiler—and
    mostly disappear at runtime.
  id: totrans-2099
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是语法糖，用于使用名为 `ValueTuple<T1>` 和 `ValueTuple<T1,T2>` 的一组泛型结构体，这些结构体具有名为 `Item1`、`Item2`
    等的字段。因此 `(string,int)` 是 `ValueTuple<string,int>` 的别名。这意味着“命名元素”仅存在于源代码中——以及编译器的想象中——并在运行时大多数时候消失。
- en: Deconstructing Tuples
  id: totrans-2100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解构元组
- en: 'Tuples implicitly support the deconstruction pattern (see [“Deconstructors”](#deconstructors)),
    so you can easily *deconstruct* a tuple into individual variables. Consider the
    following:'
  id: totrans-2101
  prefs: []
  type: TYPE_NORMAL
  zh: 元组隐式支持解构模式（参见[“解构器”](#deconstructors)），因此你可以轻松地将元组*解构*为单独的变量。考虑以下示例：
- en: '[PRE511]'
  id: totrans-2102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: 'With the tuple’s deconstructor, you can simplify the code to this:'
  id: totrans-2103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用元组的解构器，你可以将代码简化为这样：
- en: '[PRE512]'
  id: totrans-2104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE512]'
- en: 'The syntax for deconstruction is confusingly similar to the syntax for declaring
    a tuple with named elements! The following highlights the difference:'
  id: totrans-2105
  prefs: []
  type: TYPE_NORMAL
  zh: 解构语法与声明具有命名元素的元组的语法令人困惑地相似！以下突出了它们的区别：
- en: '[PRE513]'
  id: totrans-2106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE513]'
- en: Records
  id: totrans-2107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录
- en: A *record* (from C# 9) is a special kind of class or struct that’s designed
    to work well with immutable (read-only) data. Its most useful feature is allowing
    *nondestructive mutation*, whereby to “modify” an immutable object, you create
    a new one and copy over the data while incorporating your modifications.
  id: totrans-2108
  prefs: []
  type: TYPE_NORMAL
  zh: '*记录*（从 C# 9 开始）是一种特殊的类或结构体，设计用于与不可变（只读）数据良好配合。其最有用的特性是允许*非破坏性变异*，即要“修改”不可变对象，你创建一个新对象，并复制数据同时合并修改。'
- en: Records are also useful in creating types that just combine or hold data. In
    simple cases, they eliminate boilerplate code while honoring *structural equality*
    semantics (two objects are the same if their data is the same), which is usually
    what you want with immutable types.
  id: totrans-2109
  prefs: []
  type: TYPE_NORMAL
  zh: 记录也非常有用，用于创建仅组合或保存数据的类型。在简单情况下，它们消除了样板代码，同时遵循*结构相等*语义（如果它们的数据相同，则两个对象相同），这通常是不可变类型所需的。
- en: A record is purely a C# compile-time construct. At runtime, the CLR sees them
    just as classes or structs (with a bunch of extra “synthesized” members added
    by the compiler).
  id: totrans-2110
  prefs: []
  type: TYPE_NORMAL
  zh: 记录纯粹是C#的编译时构造。在运行时，CLR将它们视为类或结构体（由编译器添加了一堆额外的“合成”成员）。
- en: Defining a Record
  id: totrans-2111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义记录
- en: A record definition is like a class or struct definition and can contain the
    same kinds of members, including fields, properties, methods, and so on. Records
    can implement interfaces, and (class-based) records can subclass other (class-based)
    records.
  id: totrans-2112
  prefs: []
  type: TYPE_NORMAL
  zh: 记录定义类似于类或结构体定义，可以包含相同类型的成员，包括字段、属性、方法等。记录可以实现接口，（基于类的）记录可以子类化其他（基于类的）记录。
- en: 'By default, the underlying type of a record is a class:'
  id: totrans-2113
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，记录的基础类型是一个类：
- en: '[PRE514]'
  id: totrans-2114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE514]'
- en: 'From C# 10, the underlying type of a record can also be a struct:'
  id: totrans-2115
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 10开始，记录的基础类型也可以是结构体：
- en: '[PRE515]'
  id: totrans-2116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: (`record class` is also legal and has the same meaning as `record`.)
  id: totrans-2117
  prefs: []
  type: TYPE_NORMAL
  zh: （`record class`也是合法的，并具有与`record`相同的含义。）
- en: 'A simple record might contain just a bunch of init-only properties, and perhaps
    a constructor:'
  id: totrans-2118
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的记录可能只包含一堆仅初始化的属性，也许还有一个构造函数：
- en: '[PRE516]'
  id: totrans-2119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE516]'
- en: 'Upon compilation, C# transforms the record definition into a class (or struct)
    and performs the following additional steps:'
  id: totrans-2120
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时，C#将记录定义转换为类（或结构体）并执行以下额外步骤：
- en: It writes a protected *copy constructor* (and a hidden *Clone* method) to facilitate
    nondestructive mutation.
  id: totrans-2121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它编写了一个受保护的*复制构造函数*（和一个隐藏的*Clone*方法），以促进非破坏性变异。
- en: It overrides/overloads the equality-related functions to implement structural
    equality.
  id: totrans-2122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它重写/重载了与相等性相关的函数，以实现结构相等性。
- en: It overrides the `ToString()` method (to expand the record’s public properties,
    as with anonymous types).
  id: totrans-2123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它重写了`ToString()`方法（扩展了记录的公共属性，就像匿名类型一样）。
- en: 'The preceding record declaration expands into something like this:'
  id: totrans-2124
  prefs: []
  type: TYPE_NORMAL
  zh: 前述记录声明会展开为类似于这样的内容：
- en: '[PRE517]'
  id: totrans-2125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE517]'
- en: Parameter lists
  id: totrans-2126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数列表
- en: 'A record definition can be shortened through the use of a *parameter list*:'
  id: totrans-2127
  prefs: []
  type: TYPE_NORMAL
  zh: 记录定义可以通过使用*参数列表*来简化：
- en: '[PRE518]'
  id: totrans-2128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE518]'
- en: 'Parameters can include the `in` and `params` modifiers but not `out` or `ref`.
    If a parameter list is specified, the compiler performs the following extra steps:'
  id: totrans-2129
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以包括`in`和`params`修饰符，但不能包括`out`或`ref`。如果指定了参数列表，则编译器会执行以下额外步骤：
- en: It writes an init-only property per parameter (or a writable property, in the
    case of record structs).
  id: totrans-2130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为每个参数编写了一个仅初始化的属性（或者在记录结构体的情况下为可写属性）。
- en: It writes a *primary constructor* to populate the properties.
  id: totrans-2131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它编写了一个*主构造函数*来填充属性。
- en: It writes a deconstructor.
  id: totrans-2132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它编写了一个解构器。
- en: 'This means that we can declare our `Point` record simply as follows:'
  id: totrans-2133
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以简单地如下声明我们的`Point`记录：
- en: '[PRE519]'
  id: totrans-2134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE519]'
- en: 'The compiler will end up generating (almost) exactly what we listed in the
    preceding expansion. A minor difference is that the parameter names in the primary
    constructor will end up as `X` and `Y` instead of `x` and `y`:'
  id: totrans-2135
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器最终生成（几乎）与我们在前述展开中列出的内容完全一致。一个小的区别是主构造函数中的参数名最终会成为`X`和`Y`，而不是`x`和`y`：
- en: '[PRE520]'
  id: totrans-2136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE520]'
- en: Note
  id: totrans-2137
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Also, due to being a *primary constructor*, the parameters `X` and `Y` become
    magically available to any field or property initializers in your record. We discuss
    the subtleties of this later in [“Primary Constructors”](#primary_constructors).
  id: totrans-2138
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，由于是*主构造函数*，参数`X`和`Y`会神奇地在记录中的任何字段或属性初始化器中可用。我们稍后在[“主构造函数”](#primary_constructors)中讨论这个细微之处。
- en: 'Another difference when you define a parameter list is that the compiler also
    generates a deconstructor:'
  id: totrans-2139
  prefs: []
  type: TYPE_NORMAL
  zh: 定义参数列表时的另一个区别是，编译器还会生成一个解构器：
- en: '[PRE521]'
  id: totrans-2140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE521]'
- en: 'Records with parameter lists can be subclassed using the following syntax:'
  id: totrans-2141
  prefs: []
  type: TYPE_NORMAL
  zh: 具有参数列表的记录可以使用以下语法进行子类化：
- en: '[PRE522]'
  id: totrans-2142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE522]'
- en: 'The compiler then emits a primary constructor as follows:'
  id: totrans-2143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，编译器会像这样发出一个主构造函数：
- en: '[PRE523]'
  id: totrans-2144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE523]'
- en: Note
  id: totrans-2145
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Parameter lists offer a nice shortcut when you need a class that simply groups
    together a bunch of values (a *product type* in functional programming), and can
    also be useful for prototyping. They’re not so helpful when you need to add logic
    to the `init` accessors (such as argument validation).
  id: totrans-2146
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要一个简单地将一堆值（在函数式编程中称为*乘积类型*）简单地组合在一起的类时，参数列表提供了一个不错的快捷方式，并且在原型设计中也可能非常有用。但是，当你需要向`init`访问器添加逻辑（例如参数验证）时，它们并不那么有用。
- en: Nondestructive Mutation
  id: totrans-2147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非破坏性变异
- en: 'The most important step that the compiler performs with all records is to write
    a *copy constructor* (and a hidden *Clone* method). This enables nondestructive
    mutation via the `with` keyword:'
  id: totrans-2148
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器对所有记录执行的最重要步骤是编写一个*复制构造函数*（以及一个隐藏的*Clone*方法）。这通过`with`关键字实现了非破坏性的变异：
- en: '[PRE524]'
  id: totrans-2149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE524]'
- en: In this example, `p2` is a copy of `p1` but with its `Y` property set to 4\.
    The benefit is greater when there are more properties.
  id: totrans-2150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，`p2`是`p1`的副本，但其`Y`属性设置为4。当属性更多时，这带来的好处更大。
- en: 'Nondestructive mutation occurs in two phases:'
  id: totrans-2151
  prefs: []
  type: TYPE_NORMAL
  zh: 非破坏性变异分为两个阶段：
- en: First, the *copy constructor* clones the record. By default, it copies each
    of the record’s underlying fields, creating a faithful replica while bypassing
    (the overhead of) any logic in the `init` accessors. All fields are included (public
    and private, as well as the hidden fields that back automatic properties).
  id: totrans-2152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，*复制构造函数*克隆记录。默认情况下，它复制记录的每个底层字段，创建一个忠实的副本，同时绕过（访问器的）任何逻辑。所有字段都包括在内（公共和私有的，以及支持自动属性的隐藏字段）。
- en: Then, each property in the *member initializer list* is updated (this time using
    the `init` accessors).
  id: totrans-2153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，更新*成员初始化器列表*中的每个属性（这次使用`init`访问器）。
- en: 'The compiler translates the following:'
  id: totrans-2154
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将以下内容翻译为：
- en: '[PRE525]'
  id: totrans-2155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE525]'
- en: 'into something functionally equivalent to this:'
  id: totrans-2156
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为以下等效的功能：
- en: '[PRE526]'
  id: totrans-2157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE526]'
- en: (The same code would not compile if you wrote it explicitly because `A` and
    `C` are init-only properties. Furthermore, the copy constructor is *protected*;
    C# works around this by invoking it via a public hidden method that it writes
    into the record called `<Clone>$`.)
  id: totrans-2158
  prefs: []
  type: TYPE_NORMAL
  zh: （如果您明确编写代码，由于`A`和`C`是只读属性，则相同的代码不会编译。此外，复制构造函数是*受保护的*；C#通过调用一个写入到名为`<Clone>$`的记录中的公共隐藏方法来解决此问题。）
- en: 'If necessary, you can define your own *copy constructor*. C# will then use
    your definition instead of writing one itself:'
  id: totrans-2159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，您可以定义自己的*复制构造函数*。C#然后将使用您的定义而不是自己编写一个：
- en: '[PRE527]'
  id: totrans-2160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE527]'
- en: 'When subclassing another record, the copy constructor is responsible for copying
    only its own fields. To copy the base record’s fields, delegate to the base:'
  id: totrans-2161
  prefs: []
  type: TYPE_NORMAL
  zh: 当子类化另一个记录时，复制构造函数负责仅复制其自己的字段。要复制基本记录的字段，请委托给基类：
- en: '[PRE528]'
  id: totrans-2162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE528]'
- en: Primary Constructors
  id: totrans-2163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主构造函数
- en: 'When you define a record with a parameter list, the compiler generates property
    declarations automatically, as well as a *primary constructor* (and a deconstructor).
    This works well in simple cases, and in more complex cases you can omit the parameter
    list and write the property declarations and constructor manually. C# also offers
    the mildly useful intermediate option of defining a parameter list while writing
    some or all of the property declarations yourself:'
  id: totrans-2164
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用参数列表定义记录时，编译器会自动生成属性声明，以及*主构造函数*（和解构函数）。这在简单情况下效果很好，在更复杂的情况下，您可以省略参数列表并手动编写属性声明和构造函数。C#还提供了一个中间选项，即在写一些或所有属性声明的同时定义参数列表：
- en: '[PRE529]'
  id: totrans-2165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE529]'
- en: In this case, we “took over” the `ID` property definition, defining it as read-only
    (instead of init-only), preventing it from partaking in nondestructive mutation.
    If you never need to nondestructively mutate a particular property, making it
    read-only lets you cache computed data in the record without having to code up
    a refresh mechanism.
  id: totrans-2166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们“接管”了`ID`属性的定义，将其定义为只读（而不是只读初始化），防止它参与非破坏性变异。如果您从不需要非破坏性地变异特定属性，则将其设置为只读属性使您能够在记录中缓存计算数据，而无需编写刷新机制。
- en: 'Notice that we needed to include a *property initializer* (in boldface):'
  id: totrans-2167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们需要包含*属性初始化器*（粗体）：
- en: '[PRE530]'
  id: totrans-2168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE530]'
- en: When you “take over” a property declaration, you become responsible for initializing
    its value; the primary constructor no longer does this automatically. (This exactly
    matches the behavior when defining primary constructors on classes or structs.)
    Note that the `ID` in boldface refers to the *primary constructor parameter*,
    not the `ID` property.
  id: totrans-2169
  prefs: []
  type: TYPE_NORMAL
  zh: 当您“接管”属性声明时，您将负责初始化其值；主构造函数不再自动执行此操作。（这与在类或结构上定义主构造函数时的行为完全匹配。）请注意，粗体中的`ID`指的是*主构造函数参数*，而不是`ID`属性。
- en: In keeping with the semantics of primary constructors on classes and structs,
    the primary constructor parameters (`ID`, `Surname`, and `FirstName` in this case)
    are magically visible to all field and property initializers.
  id: totrans-2170
  prefs: []
  type: TYPE_NORMAL
  zh: 与类和结构的主构造函数语义一致，主构造函数参数（在本例中为`ID`、`Surname`和`FirstName`）对所有字段和属性初始化器都是自动可见的。
- en: 'You can also take over a property definition with explicit accessors:'
  id: totrans-2171
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以接管属性定义并使用显式访问器：
- en: '[PRE531]'
  id: totrans-2172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE531]'
- en: Again, the `ID` in boldface refers to the primary constructor parameter, not
    the property. (The reason for there not being an ambiguity is that it’s illegal
    to access properties from initializers.)
  id: totrans-2173
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，粗体中的`ID`指的是主构造函数参数，而不是属性。（没有歧义的原因是从初始化程序访问属性是非法的。）
- en: The fact that we must initialize the `_id` property with `ID` makes this “takeover”
    less useful, in that any logic in the `init` accessor (such as validation) will
    get bypassed by the primary constructor.
  id: totrans-2174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用 `ID` 初始化 `_id` 属性，这使得这种“接管”变得不太有用，因为主构造函数中的任何逻辑（如验证）都将被绕过。
- en: Records and Equality Comparison
  id: totrans-2175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录和相等性比较
- en: 'Just as with structs, anonymous types, and tuples, records provide structural
    equality out of the box, meaning that two records are equal if their fields (and
    automatic properties) are equal:'
  id: totrans-2176
  prefs: []
  type: TYPE_NORMAL
  zh: 正如对结构体、匿名类型和元组一样，记录提供了开箱即用的结构相等性，这意味着如果它们的字段（和自动属性）相等，则两个记录是相等的：
- en: '[PRE532]'
  id: totrans-2177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE532]'
- en: 'The *equality operator* also works with records (as it does with tuples):'
  id: totrans-2178
  prefs: []
  type: TYPE_NORMAL
  zh: '*相等运算符* 也适用于记录（如同适用于元组一样）：'
- en: '[PRE533]'
  id: totrans-2179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE533]'
- en: 'Unlike with classes and structs, you do not (and cannot) override the `object.Equals`
    method if you want to customize equality behavior. Instead, you define a public
    `Equals` method with the following signature:'
  id: totrans-2180
  prefs: []
  type: TYPE_NORMAL
  zh: 与类和结构体不同，如果要自定义相等性行为，您不需要（也不能）重写 `object.Equals` 方法。相反，您需要定义一个公共的 `Equals` 方法，具有以下签名：
- en: '[PRE534]'
  id: totrans-2181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE534]'
- en: The `Equals` method must be `virtual` (not `override`), and it must be *strongly
    typed* such that it accepts the actual record type (`Point` in this case, not
    `object`). Once you get the signature right, the compiler will automatically patch
    in your method.
  id: totrans-2182
  prefs: []
  type: TYPE_NORMAL
  zh: '`Equals` 方法必须是 `virtual`（而不是 `override`），并且它必须是 *强类型* 的，以便接受实际的记录类型（在这种情况下是
    `Point`，而不是 `object`）。一旦您正确地设置了签名，编译器将自动插入您的方法。'
- en: 'As with any type, if you take over equality comparison, you should also override
    `GetHashCode()`. A nice feature of records is that you don’t overload `!=` or
    `==`; nor do you implement `IEquatable<T>`: this is all done for you. We cover
    this topic fully in “Equality Comparison” in Chapter 6 of *C# 12 in a Nutshell*.'
  id: totrans-2183
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何类型一样，如果您接管了相等比较，您也应该重写 `GetHashCode()`。记录的一个好处是，您不需要重载 `!=` 或 `==`，也不需要实现
    `IEquatable<T>`：这一切都由编译器为您完成。我们在《C# 12 简明概述》的第 6 章“相等比较”中详细讨论了这个主题。
- en: Patterns
  id: totrans-2184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模
- en: 'Earlier, we demonstrated how to use the `is` operator to test whether a reference
    conversion will succeed, and then use its converted value:'
  id: totrans-2185
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们演示了如何使用 `is` 运算符测试引用转换是否成功，然后使用其转换后的值：
- en: '[PRE535]'
  id: totrans-2186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE535]'
- en: 'This employs one kind of pattern called a *type pattern*. The `is` operator
    also supports other patterns that were introduced in recent versions of C#. Patterns
    are supported in the following contexts:'
  id: totrans-2187
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了一种称为 *类型模式* 的模式。`is` 运算符还支持其他在最近版本的 C# 中引入的模式。模式在以下上下文中受支持：
- en: After the `is` operator (`*variable* is *pattern*`)
  id: totrans-2188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `is` 运算符之后（`*variable* is *pattern*`）
- en: In switch statements
  id: totrans-2189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `switch` 语句中
- en: In switch expressions
  id: totrans-2190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `switch` 表达式中
- en: We’ve already covered the type pattern in [“Switching on types”](#switching_on_types)
    and [“The is operator”](#the_is_operator). In this section, we cover more advanced
    patterns that were introduced in recent versions of C#.
  id: totrans-2191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[“在类型上进行切换”](#switching_on_types)和[“is 运算符”](#the_is_operator)中介绍了类型模式。在本节中，我们将介绍在最近版本的
    C# 中引入的更高级的模式。
- en: Some of the more specialized patterns are intended for use in switch statements/expressions.
    Here, they reduce the need for `when` clauses and let you use switches where you
    couldn’t previously.
  id: totrans-2192
  prefs: []
  type: TYPE_NORMAL
  zh: 一些更专业的模式旨在在 `switch` 语句/表达式中使用。在这里，它们减少了对 `when` 子句的需求，并让您在以前无法使用 `switch` 的地方使用它们。
- en: var Pattern
  id: totrans-2193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量模式
- en: 'The *var pattern* is a variation of the *type pattern* whereby you replace
    the type name with the `var` keyword. The conversion always succeeds, so its purpose
    is merely to let you reuse the variable that follows:'
  id: totrans-2194
  prefs: []
  type: TYPE_NORMAL
  zh: '*var 模式* 是 *类型模式* 的一种变体，您可以用 `var` 关键字替换类型名称。转换总是成功的，因此它的目的仅仅是让您重用随后的变量：'
- en: '[PRE536]'
  id: totrans-2195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE536]'
- en: 'This is equivalent to:'
  id: totrans-2196
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于：
- en: '[PRE537]'
  id: totrans-2197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE537]'
- en: Constant Pattern
  id: totrans-2198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量模式
- en: 'The *constant pattern* lets you match directly to a constant and is useful
    when working with the `object` type:'
  id: totrans-2199
  prefs: []
  type: TYPE_NORMAL
  zh: '*常量模式* 允许您直接匹配到一个常量，对于与 `object` 类型一起工作时非常有用：'
- en: '[PRE538]'
  id: totrans-2200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE538]'
- en: 'This expression in boldface is equivalent to the following:'
  id: totrans-2201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个加粗的表达式相当于以下内容：
- en: '[PRE539]'
  id: totrans-2202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE539]'
- en: As we’ll see soon, the constant pattern can become more useful with *pattern
    combinators*.
  id: totrans-2203
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将很快看到的那样，常量模式在使用 *模式组合器* 时会更加有用。
- en: Relational Patterns
  id: totrans-2204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系模式
- en: 'From C# 9, you can use the `<`, `>`, `<=`, and `>=` operators in patterns:'
  id: totrans-2205
  prefs: []
  type: TYPE_NORMAL
  zh: 自 C# 9 开始，您可以在模式中使用 `<`、`>`、`<=` 和 `>=` 运算符：
- en: '[PRE540]'
  id: totrans-2206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE540]'
- en: 'This becomes meaningfully useful in a `switch`:'
  id: totrans-2207
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `switch` 中这变得非常有用：
- en: '[PRE541]'
  id: totrans-2208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE541]'
- en: Pattern Combinators
  id: totrans-2209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式组合器
- en: 'From C# 9, you can use the `and`, `or`, and `not` keywords to combine patterns:'
  id: totrans-2210
  prefs: []
  type: TYPE_NORMAL
  zh: 自 C# 9 开始，您可以使用 `and`、`or` 和 `not` 关键字来组合模式：
- en: '[PRE542]'
  id: totrans-2211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE542]'
- en: 'As with the `&&` and `||` operators, `and` has higher precedence than `or`.
    You can override this with parentheses. A nice trick is to combine the `not` combinator
    with the *type pattern* to test whether an object is (not) a type:'
  id: totrans-2212
  prefs: []
  type: TYPE_NORMAL
  zh: 与`&&`和`||`运算符一样，`and`比`or`具有更高的优先级。您可以使用括号覆盖这一点。一个很好的技巧是将`not`组合器与*类型模式*结合起来，以测试对象是否为（不是）某种类型：
- en: '[PRE543]'
  id: totrans-2213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE543]'
- en: 'This looks nicer than:'
  id: totrans-2214
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来比以下方式更好：
- en: '[PRE544]'
  id: totrans-2215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE544]'
- en: Tuple and Positional Patterns
  id: totrans-2216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组和位置模式
- en: 'The *tuple pattern* (introduced in C# 8) matches tuples:'
  id: totrans-2217
  prefs: []
  type: TYPE_NORMAL
  zh: '*元组模式*（C# 8 中引入）匹配元组：'
- en: '[PRE545]'
  id: totrans-2218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE545]'
- en: 'The tuple pattern can be considered a special case of the *positional pattern*
    (C# 8+), which matches any type that exposes a `Deconstruct` method (see [“Deconstructors”](#deconstructors)).
    In the following example, we leverage the `Point` record’s compiler-generated
    deconstructor:'
  id: totrans-2219
  prefs: []
  type: TYPE_NORMAL
  zh: 元组模式可以被视为*位置模式*（C# 8+）的特殊情况，它匹配任何公开`Deconstruct`方法的类型（参见[“解构器”](#deconstructors)）。在以下示例中，我们利用`Point`记录的编译器生成的解构器：
- en: '[PRE546]'
  id: totrans-2220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE546]'
- en: 'You can deconstruct as you match, using the following syntax:'
  id: totrans-2221
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在匹配时解构，使用以下语法：
- en: '[PRE547]'
  id: totrans-2222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE547]'
- en: 'Here’s a switch expression that combines a type pattern with a positional pattern:'
  id: totrans-2223
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个将类型模式与位置模式结合的 switch 表达式：
- en: '[PRE548]'
  id: totrans-2224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE548]'
- en: Property Patterns
  id: totrans-2225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性模式
- en: 'A *property pattern* (C# 8+) matches on one or more of an object’s property
    values:'
  id: totrans-2226
  prefs: []
  type: TYPE_NORMAL
  zh: '*属性模式*（C# 8+）匹配对象的一个或多个属性值：'
- en: '[PRE549]'
  id: totrans-2227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE549]'
- en: 'However, this doesn’t save much over the following:'
  id: totrans-2228
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这与以下方式并没有太大区别：
- en: '[PRE550]'
  id: totrans-2229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE550]'
- en: 'With switch statements and expressions, property patterns are more useful.
    Consider the `System.Uri` class, which represents a URI. It has properties that
    include `Scheme`, `Host`, `Port`, and `IsLoopback`. In writing a firewall, we
    could decide whether to allow or block a URI by employing a switch expression
    that uses property patterns:'
  id: totrans-2230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 switch 语句和表达式，属性模式更有用。考虑`System.Uri`类，它表示一个 URI。它具有的属性包括`Scheme`、`Host`、`Port`和`IsLoopback`。在编写防火墙时，我们可以通过使用使用属性模式的
    switch 表达式来决定是否允许或阻止 URI：
- en: '[PRE551]'
  id: totrans-2231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE551]'
- en: 'You can nest properties, making the following clause legal:'
  id: totrans-2232
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以嵌套属性，使以下子句合法：
- en: '[PRE552]'
  id: totrans-2233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE552]'
- en: 'which, from C# 10, can be simplified to:'
  id: totrans-2234
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 10 开始，可以简化为：
- en: '[PRE553]'
  id: totrans-2235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE553]'
- en: 'You can use other patterns inside property patterns, including the relational
    pattern:'
  id: totrans-2236
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在属性模式中使用其他模式，包括关系模式：
- en: '[PRE554]'
  id: totrans-2237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE554]'
- en: 'You can introduce a variable at the end of a clause and then consume that variable
    in a `when` clause:'
  id: totrans-2238
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在子句末尾引入一个变量，然后在`when`子句中使用该变量：
- en: '[PRE555]'
  id: totrans-2239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE555]'
- en: 'You can also introduce variables at the *property* level:'
  id: totrans-2240
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在*属性*级别引入变量：
- en: '[PRE556]'
  id: totrans-2241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE556]'
- en: 'In this case, however, the following is shorter and simpler:'
  id: totrans-2242
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种情况下，以下方式更短更简单：
- en: '[PRE557]'
  id: totrans-2243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE557]'
- en: List Patterns
  id: totrans-2244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表模式
- en: List patterns (from C# 11) work with any collection type that is countable (with
    a `Count` or `Length` property) and indexable (with an indexer of type `int` or
    `System.Index`).
  id: totrans-2245
  prefs: []
  type: TYPE_NORMAL
  zh: 列表模式（从 C# 11 开始）适用于任何可计数的集合类型（具有`Count`或`Length`属性）和可索引的集合类型（具有`int`或`System.Index`类型的索引器）。
- en: 'A list pattern matches a series of elements in square brackets:'
  id: totrans-2246
  prefs: []
  type: TYPE_NORMAL
  zh: 列表模式匹配方括号中的一系列元素：
- en: '[PRE558]'
  id: totrans-2247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE558]'
- en: 'An underscore matches a single element of any value:'
  id: totrans-2248
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线匹配任何值的单个元素：
- en: '[PRE559]'
  id: totrans-2249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE559]'
- en: 'The `var` pattern also works in matching a single element:'
  id: totrans-2250
  prefs: []
  type: TYPE_NORMAL
  zh: '`var` 模式也适用于匹配单个元素：'
- en: '[PRE560]'
  id: totrans-2251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE560]'
- en: 'Two dots indicate a *slice*. A slice matches zero or more elements:'
  id: totrans-2252
  prefs: []
  type: TYPE_NORMAL
  zh: 两个点表示一个*切片*。切片匹配零个或多个元素：
- en: '[PRE561]'
  id: totrans-2253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE561]'
- en: 'With arrays and other types that support indices and ranges (see [“Indices
    and Ranges”](#indices_and_ranges)), you can follow a slice with a `var` pattern:'
  id: totrans-2254
  prefs: []
  type: TYPE_NORMAL
  zh: 对于支持索引和范围的数组和其他类型（参见[“索引和范围”](#indices_and_ranges)），您可以在切片后跟一个`var`模式：
- en: '[PRE562]'
  id: totrans-2255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE562]'
- en: A list pattern can include at most one slice.
  id: totrans-2256
  prefs: []
  type: TYPE_NORMAL
  zh: 列表模式最多可以包含一个切片。
- en: LINQ
  id: totrans-2257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LINQ
- en: LINQ, or Language Integrated Query, allows you to write structured type-safe
    queries over local object collections and remote data sources. LINQ lets you query
    any collection implementing `IEnumerable<>`, whether an array, list, XML DOM,
    or remote data source (such as a table in SQL Server). LINQ offers the benefits
    of both compile-time type checking and dynamic query composition.
  id: totrans-2258
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ，即 Language Integrated Query，允许您在本地对象集合和远程数据源上编写结构化类型安全的查询。LINQ允许您查询任何实现`IEnumerable<>`的集合，无论是数组、列表、XML
    DOM还是远程数据源（如 SQL Server 中的表）。LINQ提供了编译时类型检查和动态查询组合的好处。
- en: Note
  id: totrans-2259
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A good way to experiment with LINQ is to [download LINQPad](http://www.linqpad.net).
    LINQPad lets you interactively query local collections and SQL databases in LINQ
    without any setup and is preloaded with numerous examples.
  id: totrans-2260
  prefs: []
  type: TYPE_NORMAL
  zh: 一个尝试 LINQ 的好方法是[下载 LINQPad](http://www.linqpad.net)。LINQPad 允许您在 LINQ 中交互式查询本地集合和
    SQL 数据库，无需任何设置，并预装有大量示例。
- en: LINQ Fundamentals
  id: totrans-2261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LINQ 基础知识
- en: 'The basic units of data in LINQ are *sequences* and *elements*. A sequence
    is any object that implements the generic `IEnumerable` interface, and an element
    is each item in the sequence. In the following example, `names` is a sequence,
    and `Tom`, `Dick`, and `Harry` are elements:'
  id: totrans-2262
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 中的基本数据单元是 *序列* 和 *元素*。序列是实现通用 `IEnumerable` 接口的任何对象，而元素是序列中的每个项。在以下示例中，`names`
    是一个序列，`Tom`、`Dick` 和 `Harry` 是元素：
- en: '[PRE563]'
  id: totrans-2263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE563]'
- en: We call a sequence such as this a *local sequence* because it represents a local
    collection of objects in memory.
  id: totrans-2264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这样的序列为*本地序列*，因为它代表内存中的本地对象集合。
- en: A *query operator* is a method that transforms a sequence. A typical query operator
    accepts an *input sequence* and emits a transformed *output sequence*. In the
    `Enumerable` class in `System.Linq`, there are around 40 query operators, all
    implemented as static extension methods. These are called *standard query operators*.
  id: totrans-2265
  prefs: []
  type: TYPE_NORMAL
  zh: '*查询操作符* 是一种转换序列的方法。典型的查询操作符接受一个*输入序列*并发出一个转换后的*输出序列*。在 `System.Linq` 的 `Enumerable`
    类中，有大约 40 个查询操作符，都是作为静态扩展方法实现的。这些称为*标准查询操作符*。'
- en: Note
  id: totrans-2266
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: LINQ also supports sequences that can be dynamically fed from a remote data
    source such as SQL Server. These sequences additionally implement the `IQueryable<>`
    interface and are supported through a matching set of standard query operators
    in the `Queryable` class.
  id: totrans-2267
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 还支持可以动态从远程数据源（如 SQL Server）输入的序列。这些序列还实现了 `IQueryable<>` 接口，并通过 `Queryable`
    类中的一组匹配的标准查询操作符进行支持。
- en: A simple query
  id: totrans-2268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单查询
- en: 'A *query* is an expression that transforms sequences with one or more query
    operators. The simplest query comprises one input sequence and one operator. For
    instance, we can apply the `Where` operator on a simple array to extract those
    names whose length is at least four characters, as follows:'
  id: totrans-2269
  prefs: []
  type: TYPE_NORMAL
  zh: '*查询* 是使用一个或多个查询操作符转换序列的表达式。最简单的查询包括一个输入序列和一个操作符。例如，我们可以在一个简单数组上应用 `Where` 操作符，以提取长度至少为四个字符的名称，如下所示：'
- en: '[PRE564]'
  id: totrans-2270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE564]'
- en: 'Because the standard query operators are implemented as extension methods,
    we can call `Where` directly on `names`, as though it were an instance method:'
  id: totrans-2271
  prefs: []
  type: TYPE_NORMAL
  zh: 因为标准查询操作符是作为扩展方法实现的，所以我们可以直接在 `names` 上调用 `Where`，就像它是一个实例方法一样：
- en: '[PRE565]'
  id: totrans-2272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE565]'
- en: '(For this to compile, you must import the `System.Linq` namespace with a `using`
    directive.) The `Where` method in `System.Linq.Enumerable` has the following signature:'
  id: totrans-2273
  prefs: []
  type: TYPE_NORMAL
  zh: （要使其编译通过，您必须使用 `using` 指令导入 `System.Linq` 命名空间。）`System.Linq.Enumerable` 中的
    `Where` 方法具有以下签名：
- en: '[PRE566]'
  id: totrans-2274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE566]'
- en: '`source` is the *input sequence*; `predicate` is a delegate that is invoked
    on each input *element*. The `Where` method includes all elements in the *output
    sequence* for which the delegate returns `true`. Internally, it’s implemented
    with an iterator—here’s its source code:'
  id: totrans-2275
  prefs: []
  type: TYPE_NORMAL
  zh: '`source` 是*输入序列*；`predicate` 是在每个输入*元素*上调用的委托。`Where` 方法包含所有委托返回 `true` 的*输出序列*中的元素。在内部，它是使用迭代器实现的——这是它的源代码：'
- en: '[PRE567]'
  id: totrans-2276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE567]'
- en: Projecting
  id: totrans-2277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 投影
- en: 'Another fundamental query operator is the `Select` method. This transforms
    (*projects*) each element in the input sequence with a given lambda expression:'
  id: totrans-2278
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个基本的查询操作符是 `Select` 方法。这使用给定的 lambda 表达式转换（*投影*）输入序列中的每个元素：
- en: '[PRE568]'
  id: totrans-2279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE568]'
- en: 'A query can project into an anonymous type:'
  id: totrans-2280
  prefs: []
  type: TYPE_NORMAL
  zh: 查询可以投影为匿名类型：
- en: '[PRE569]'
  id: totrans-2281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE569]'
- en: 'Here’s the result:'
  id: totrans-2282
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果：
- en: '[PRE570]'
  id: totrans-2283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE570]'
- en: Take and Skip
  id: totrans-2284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Take 和 Skip
- en: 'The original ordering of elements within an input sequence is significant in
    LINQ. Some query operators rely on this behavior, such as `Take`, `Skip`, and
    `Reverse`. The `Take` operator outputs the first *x* elements, discarding the
    rest:'
  id: totrans-2285
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LINQ 中，输入序列中元素的原始顺序很重要。某些查询操作符依赖于此行为，如 `Take`、`Skip` 和 `Reverse`。`Take` 操作符输出前
    *x* 个元素，丢弃其余部分：
- en: '[PRE571]'
  id: totrans-2286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE571]'
- en: 'The `Skip` operator ignores the first *x* elements and outputs the rest:'
  id: totrans-2287
  prefs: []
  type: TYPE_NORMAL
  zh: '`Skip` 操作符忽略前 *x* 个元素，并输出其余部分：'
- en: '[PRE572]'
  id: totrans-2288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE572]'
- en: From .NET 6, there are also `TakeLast` and `SkipLast` methods, which take or
    skip the last *n* elements. Additionally, the `Take` method has been overloaded
    to accept a `Range` variable. This overload can subsume the functionality of all
    four methods; for instance, `Take(5..)` is equivalent to `Skip(5)`, and `Take(..^5)`
    is equivalent to `SkipLast(5)`.
  id: totrans-2289
  prefs: []
  type: TYPE_NORMAL
  zh: 从 .NET 6 开始，还有 `TakeLast` 和 `SkipLast` 方法，分别取或跳过最后 *n* 个元素。此外，`Take` 方法已重载以接受
    `Range` 变量。此重载可以包含所有四种方法的功能；例如，`Take(5..)` 等同于 `Skip(5)`，`Take(..^5)` 等同于 `SkipLast(5)`。
- en: Element operators
  id: totrans-2290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元素操作符
- en: 'Not all query operators return a sequence. The *element* operators extract
    one element from the input sequence; examples are `First`, `Last`, `Single`, and
    `ElementAt`:'
  id: totrans-2291
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有查询操作符都返回序列。*元素* 操作符从输入序列中提取一个元素；例如 `First`、`Last`、`Single` 和 `ElementAt`：
- en: '[PRE573]'
  id: totrans-2292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE573]'
- en: All of these operators throw an exception if no elements are present. To avoid
    the exception, use `FirstOrDefault`, `LastOrDefault`, `SingleOrDefault`, or `ElementAtOrDefault`—these
    return `null` (or the `default` value for value types) when no element is found.
  id: totrans-2293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有元素存在，所有这些运算符都会抛出异常。要避免异常，请使用 `FirstOrDefault`, `LastOrDefault`, `SingleOrDefault`
    或 `ElementAtOrDefault` —— 当未找到元素时，它们返回 `null`（或值类型的 `default` 值）。
- en: The `Single` and `SingleOrDefault` methods are equivalent to `First` and `FirstOrDefault`
    except that they throw an exception if there’s more than one match. This behavior
    is useful when you’re querying a database table for a row by primary key.
  id: totrans-2294
  prefs: []
  type: TYPE_NORMAL
  zh: '`Single` 和 `SingleOrDefault` 方法与 `First` 和 `FirstOrDefault` 方法相同，除了如果有多个匹配项则抛出异常。在查询数据库表的主键时，这种行为非常有用。'
- en: 'From .NET 6, there are also `MinBy` and `MaxBy` methods, which return the element
    with the lowest or highest value, as determined by a key selector:'
  id: totrans-2295
  prefs: []
  type: TYPE_NORMAL
  zh: 从 .NET 6 开始，还有 `MinBy` 和 `MaxBy` 方法，根据键选择器返回具有最低或最高值的元素：
- en: '[PRE574]'
  id: totrans-2296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE574]'
- en: Aggregation operators
  id: totrans-2297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 聚合运算符
- en: 'The *aggregation* operators return a scalar value, usually of numeric type.
    The most commonly used aggregation operators are `Count`, `Min`, `Max`, and `Average`:'
  id: totrans-2298
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合运算符返回一个标量值，通常是数值类型。最常用的聚合运算符是 `Count`, `Min`, `Max` 和 `Average`：
- en: '[PRE575]'
  id: totrans-2299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE575]'
- en: '`Count` accepts an optional predicate, which indicates whether to include a
    given element. The following counts all even numbers:'
  id: totrans-2300
  prefs: []
  type: TYPE_NORMAL
  zh: '`Count` 接受一个可选的谓词，指示是否包括给定的元素。以下计算所有偶数的数量：'
- en: '[PRE576]'
  id: totrans-2301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE576]'
- en: 'The `Min`, `Max`, and `Average` operators accept an optional argument that
    transforms each element prior to it being aggregated:'
  id: totrans-2302
  prefs: []
  type: TYPE_NORMAL
  zh: '`Min`, `Max` 和 `Average` 运算符接受一个可选参数，用于在聚合之前转换每个元素：'
- en: '[PRE577]'
  id: totrans-2303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE577]'
- en: 'The following calculates the root mean square of `numbers`:'
  id: totrans-2304
  prefs: []
  type: TYPE_NORMAL
  zh: 以下计算 `numbers` 的均方根：
- en: '[PRE578]'
  id: totrans-2305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE578]'
- en: Quantifiers
  id: totrans-2306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 量词运算符
- en: 'The *quantifiers* return a `bool` value. The quantifiers are `Contains`, `Any`,
    `All`, and `SequenceEquals` (which compares two sequences):'
  id: totrans-2307
  prefs: []
  type: TYPE_NORMAL
  zh: 量词运算符返回一个 `bool` 值。量词运算符包括 `Contains`, `Any`, `All` 和 `SequenceEquals`（比较两个序列）：
- en: '[PRE579]'
  id: totrans-2308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE579]'
- en: Set operators
  id: totrans-2309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合运算符
- en: 'The *set* operators accept two same-typed input sequences. `Concat` appends
    one sequence to another; `Union` does the same but with duplicates removed:'
  id: totrans-2310
  prefs: []
  type: TYPE_NORMAL
  zh: 集合运算符接受两个相同类型的输入序列。`Concat` 将一个序列附加到另一个序列；`Union` 也是如此，但删除重复项：
- en: '[PRE580]'
  id: totrans-2311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE580]'
- en: 'The other two operators in this category are `Intersect` and `Except`:'
  id: totrans-2312
  prefs: []
  type: TYPE_NORMAL
  zh: 此类别中的另外两个运算符是 `Intersect` 和 `Except`：
- en: '[PRE581]'
  id: totrans-2313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE581]'
- en: 'From .NET 6, there are also set operators that take a key selector (`UnionBy`,
    `ExceptBy`, `IntersectBy`). The key selector is used in determining whether an
    element counts as a duplicate:'
  id: totrans-2314
  prefs: []
  type: TYPE_NORMAL
  zh: 从 .NET 6 开始，还有使用键选择器的集合运算符 (`UnionBy`, `ExceptBy`, `IntersectBy`)。键选择器用于确定元素是否被视为重复项：
- en: '[PRE582]'
  id: totrans-2315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE582]'
- en: Deferred Execution
  id: totrans-2316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延迟执行
- en: 'An important feature of many query operators is that they execute not when
    constructed but when *enumerated* (in other words, when `MoveNext` is called on
    its enumerator). Consider the following query:'
  id: totrans-2317
  prefs: []
  type: TYPE_NORMAL
  zh: 许多查询运算符的重要特性是它们在构造时不执行，而是在枚举时执行（换句话说，在其枚举器上调用 `MoveNext` 时）。考虑以下查询：
- en: '[PRE583]'
  id: totrans-2318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE583]'
- en: 'The extra number that we sneaked into the list *after* constructing the query
    is included in the result because it’s not until the `foreach` statement runs
    that any filtering or sorting takes place. This is called *deferred* or *lazy*
    evaluation. Deferred execution decouples query *construction* from query *execution*,
    allowing you to construct a query in several steps, as well as making it possible
    to query a database without retrieving all the rows to the client. All standard
    query operators provide deferred execution, with the following exceptions:'
  id: totrans-2319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在构造查询之后偷偷加入列表中的额外数字，因为直到 `foreach` 语句运行时才进行任何过滤或排序。这被称为延迟或惰性评估。延迟执行将查询的构造与执行分离，允许您在多个步骤中构造查询，还可以在不将所有行检索到客户端的情况下查询数据库。所有标准查询运算符都提供延迟执行，以下是例外：
- en: Operators that return a single element or scalar value (the *element operators*,
    *aggregation operators*, and *quantifiers*)
  id: totrans-2320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回单个元素或标量值的运算符（元素运算符、聚合运算符和量词运算符）
- en: The *conversion* operators `ToArray`, `ToList`, `ToDictionary`, `ToLookup`,
    and `ToHashSet`
  id: totrans-2321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换运算符 `ToArray`, `ToList`, `ToDictionary`, `ToLookup` 和 `ToHashSet`
- en: The conversion operators are handy, in part because they defeat lazy evaluation.
    This can be useful to “freeze” or cache the results at a certain point in time,
    to avoid re-executing a computationally intensive or remotely sourced query such
    as an Entity Framework table. (A side effect of lazy evaluation is that the query
    is reevaluated should you later re-enumerate it.)
  id: totrans-2322
  prefs: []
  type: TYPE_NORMAL
  zh: 转换运算符非常方便，部分原因在于它们避免了惰性求值。这在某些情况下很有用，可以在特定时间点“冻结”或缓存结果，避免重新执行计算密集或远程获取的查询，比如
    Entity Framework 表。（惰性求值的副作用是，如果稍后重新枚举它，查询会被重新评估。）
- en: 'The following example illustrates the `ToList` operator:'
  id: totrans-2323
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了 `ToList` 运算符：
- en: '[PRE584]'
  id: totrans-2324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE584]'
- en: Warning
  id: totrans-2325
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'Subqueries provide another level of indirection. Everything in a subquery is
    subject to deferred execution, including aggregation and conversion methods, because
    the subquery is itself executed only lazily upon demand. Assuming `names` is a
    string array, a subquery looks like this:'
  id: totrans-2326
  prefs: []
  type: TYPE_NORMAL
  zh: 子查询提供了另一层间接引用。子查询中的所有内容都受延迟执行的影响，包括聚合和转换方法，因为子查询本身只有在需要时才会懒惰执行。假设 `names` 是一个字符串数组，子查询如下所示：
- en: '[PRE585]'
  id: totrans-2327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE585]'
- en: Standard Query Operators
  id: totrans-2328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准查询运算符
- en: We can divide the standard query operators (as implemented in the `System.Linq.Enumerable`
    class) into 12 categories, as summarized in [Table 1](#query_operator_categories).
  id: totrans-2329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将标准查询运算符（如在 `System.Linq.Enumerable` 类中实现）分为 12 个类别，如 [Table 1](#query_operator_categories)
    所总结的。
- en: Table 1\. Query operator categories
  id: totrans-2330
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1\. 查询运算符类别
- en: '| Category | Description | Deferred execution? |'
  id: totrans-2331
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | 描述 | 延迟执行？ |'
- en: '| --- | --- | --- |'
  id: totrans-2332
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Filtering | Returns a subset of elements that satisfy a given condition |
    Yes |'
  id: totrans-2333
  prefs: []
  type: TYPE_TB
  zh: '| 过滤 | 返回满足给定条件的元素子集 | 是 |'
- en: '| Projecting | Transforms each element with a lambda function, optionally expanding
    subsequences | Yes |'
  id: totrans-2334
  prefs: []
  type: TYPE_TB
  zh: '| 投影 | 使用 lambda 函数转换每个元素，可选地展开子序列 | 是 |'
- en: '| Joining | Meshes elements of one collection with another, using a time-efficient
    lookup strategy | Yes |'
  id: totrans-2335
  prefs: []
  type: TYPE_TB
  zh: '| 连接 | 使用时间有效的查找策略将一个集合的元素与另一个集合的元素进行网格化 | 是 |'
- en: '| Ordering | Returns a reordering of a sequence | Yes |'
  id: totrans-2336
  prefs: []
  type: TYPE_TB
  zh: '| 排序 | 返回序列的重新排序 | 是 |'
- en: '| Grouping | Groups a sequence into subsequences | Yes |'
  id: totrans-2337
  prefs: []
  type: TYPE_TB
  zh: '| 分组 | 将序列分组为子序列 | 是 |'
- en: '| Set | Accepts two same-typed sequences and returns their commonality, sum,
    or difference | Yes |'
  id: totrans-2338
  prefs: []
  type: TYPE_TB
  zh: '| 集合 | 接受两个相同类型的序列，并返回它们的共同性、和或差异 | 是 |'
- en: '| Element | Picks a single element from a sequence | No |'
  id: totrans-2339
  prefs: []
  type: TYPE_TB
  zh: '| 元素 | 从序列中选择单个元素 | 否 |'
- en: '| Aggregation | Performs a computation over a sequence, returning a scalar
    value (typically a number) | No |'
  id: totrans-2340
  prefs: []
  type: TYPE_TB
  zh: '| 聚合 | 对序列执行计算，返回一个标量值（通常是一个数值） | 否 |'
- en: '| Quantification | Performs a computation over a sequence, returning `true`
    or `false` | No |'
  id: totrans-2341
  prefs: []
  type: TYPE_TB
  zh: '| 量化 | 对序列执行计算，返回 `true` 或 `false` | 否 |'
- en: '| Conversion: Import | Converts a nongeneric sequence to a (queryable) generic
    sequence | Yes |'
  id: totrans-2342
  prefs: []
  type: TYPE_TB
  zh: '| 转换：导入 | 将非泛型序列转换为（可查询的）泛型序列 | 是 |'
- en: '| Conversion: Export | Converts a sequence to an array, list, dictionary, or
    lookup, forcing immediate evaluation | No |'
  id: totrans-2343
  prefs: []
  type: TYPE_TB
  zh: '| 转换：导出 | 将序列转换为数组、列表、字典或查找，强制立即评估 | 否 |'
- en: '| Generation | Manufactures a simple sequence | Yes |'
  id: totrans-2344
  prefs: []
  type: TYPE_TB
  zh: '| 生成 | 制造一个简单的序列 | 是 |'
- en: Tables [2](#filtering_operators) through [13](#generation_operators) summarize
    each query operator. The operators shown in bold have special support in C# (see
    [“Query Expressions”](#query_expressions)).
  id: totrans-2345
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 [2](#filtering_operators) 到 [13](#generation_operators) 总结了每个查询运算符。在 C# 中，加粗显示的运算符具有特殊的支持（参见
    [“查询表达式”](#query_expressions)）。
- en: Table 2\. Filtering operators
  id: totrans-2346
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2\. 过滤运算符
- en: '| Method | Description |'
  id: totrans-2347
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-2348
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `**Where**` | Returns a subset of elements that satisfy a given condition
    |'
  id: totrans-2349
  prefs: []
  type: TYPE_TB
  zh: '| `**Where**` | 返回满足给定条件的元素子集 |'
- en: '| `Take` | Returns the first *x* elements, and discards the rest |'
  id: totrans-2350
  prefs: []
  type: TYPE_TB
  zh: '| `Take` | 返回前 *x* 个元素，并丢弃其余元素 |'
- en: '| `Skip` | Ignores the first *x* elements, and returns the rest |'
  id: totrans-2351
  prefs: []
  type: TYPE_TB
  zh: '| `Skip` | 忽略前 *x* 个元素，并返回其余元素 |'
- en: '| `TakeLast` | Returns the last *x* elements, and discards the rest |'
  id: totrans-2352
  prefs: []
  type: TYPE_TB
  zh: '| `TakeLast` | 返回最后 *x* 个元素，并丢弃其余元素 |'
- en: '| `SkipLast` | Ignores the last *x* elements, and returns the rest |'
  id: totrans-2353
  prefs: []
  type: TYPE_TB
  zh: '| `SkipLast` | 忽略最后 *x* 个元素，并返回其余元素 |'
- en: '| `TakeWhile` | Emits elements from the input sequence until the given predicate
    is true |'
  id: totrans-2354
  prefs: []
  type: TYPE_TB
  zh: '| `TakeWhile` | 发射输入序列中的元素，直到给定的谓词为真 |'
- en: '| `SkipWhile` | Ignores elements from the input sequence until the given predicate
    is true and then emits the rest |'
  id: totrans-2355
  prefs: []
  type: TYPE_TB
  zh: '| `SkipWhile` | 忽略输入序列中的元素，直到给定的谓词为真，然后发射其余元素 |'
- en: '| `Distinct`, `DistinctBy` | Returns a collection that excludes duplicates
    |'
  id: totrans-2356
  prefs: []
  type: TYPE_TB
  zh: '| `Distinct`, `DistinctBy` | 返回排除重复项的集合 |'
- en: Table 3\. Projection operators
  id: totrans-2357
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3\. 投影运算符
- en: '| Method | Description |'
  id: totrans-2358
  prefs: []
  type: TYPE_TB
  zh: '| Method | Description |'
- en: '| --- | --- |'
  id: totrans-2359
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `**Select**` | Transforms each input element with a given lambda expression
    |'
  id: totrans-2360
  prefs: []
  type: TYPE_TB
  zh: '| `**Select**` | 使用给定的 Lambda 表达式转换每个输入元素 |'
- en: '| `**SelectMany**` | Transforms each input element and then flattens and concatenates
    the resultant subsequences |'
  id: totrans-2361
  prefs: []
  type: TYPE_TB
  zh: '| `**SelectMany**` | 转换每个输入元素，然后展平和连接生成的子序列 |'
- en: Table 4\. Joining operators
  id: totrans-2362
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4\. 连接运算符
- en: '| Method | Description |'
  id: totrans-2363
  prefs: []
  type: TYPE_TB
  zh: '| Method | Description |'
- en: '| --- | --- |'
  id: totrans-2364
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `**Join**` | Applies a lookup strategy to match elements from two collections,
    emitting a flat result set |'
  id: totrans-2365
  prefs: []
  type: TYPE_TB
  zh: '| `**Join**` | 应用查找策略匹配来自两个集合的元素，并生成一个平坦的结果集 |'
- en: '| `**GroupJoin**` | As above, but emits a *hierarchical* result set |'
  id: totrans-2366
  prefs: []
  type: TYPE_TB
  zh: '| `**GroupJoin**` | 类似于上面的操作，但生成一个*分层*的结果集 |'
- en: '| `Zip` | Enumerates two sequences in step, returning a sequence that applies
    a function over each element pair |'
  id: totrans-2367
  prefs: []
  type: TYPE_TB
  zh: '| `Zip` | 依次枚举两个序列，并返回一个应用函数到每一对元素上的序列 |'
- en: Table 5\. Ordering operators
  id: totrans-2368
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5\. 排序运算符
- en: '| Method | Description |'
  id: totrans-2369
  prefs: []
  type: TYPE_TB
  zh: '| Method | Description |'
- en: '| --- | --- |'
  id: totrans-2370
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `**OrderBy**`, `**ThenBy**` | Returns the elements sorted in ascending order
    |'
  id: totrans-2371
  prefs: []
  type: TYPE_TB
  zh: '| `**OrderBy**`, `**ThenBy**` | 返回按升序排列的元素 |'
- en: '| `**OrderByDescending**`, `**ThenByDescending**` | Returns the elements sorted
    in descending order |'
  id: totrans-2372
  prefs: []
  type: TYPE_TB
  zh: '| `**OrderByDescending**`, `**ThenByDescending**` | 返回按降序排列的元素 |'
- en: '| `Reverse` | Returns the elements in reverse order |'
  id: totrans-2373
  prefs: []
  type: TYPE_TB
  zh: '| `Reverse` | 返回逆序排列的元素 |'
- en: Table 6\. Grouping operators
  id: totrans-2374
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6\. 分组运算符
- en: '| Method | Description |'
  id: totrans-2375
  prefs: []
  type: TYPE_TB
  zh: '| Method | Description |'
- en: '| --- | --- |'
  id: totrans-2376
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `**GroupBy**` | Groups a sequence into subsequences |'
  id: totrans-2377
  prefs: []
  type: TYPE_TB
  zh: '| `**GroupBy**` | 将序列分组为子序列 |'
- en: '| `Chunk` | Groups a sequence into chunks of a given size |'
  id: totrans-2378
  prefs: []
  type: TYPE_TB
  zh: '| `Chunk` | 将序列分成给定大小的块 |'
- en: Table 7\. Set operators
  id: totrans-2379
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7\. 集合运算符
- en: '| Method | Description |'
  id: totrans-2380
  prefs: []
  type: TYPE_TB
  zh: '| Method | Description |'
- en: '| --- | --- |'
  id: totrans-2381
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Concat` | Concatenates two sequences |'
  id: totrans-2382
  prefs: []
  type: TYPE_TB
  zh: '| `Concat` | 连接两个序列 |'
- en: '| `Union`, `UnionBy` | Concatenates two sequences, removing duplicates |'
  id: totrans-2383
  prefs: []
  type: TYPE_TB
  zh: '| `Union`, `UnionBy` | 连接两个序列并移除重复元素 |'
- en: '| `Intersect`, `IntersectBy` | Returns elements present in both sequences |'
  id: totrans-2384
  prefs: []
  type: TYPE_TB
  zh: '| `Intersect`, `IntersectBy` | 返回两个序列中共有的元素 |'
- en: '| `Except`, `ExceptBy` | Returns elements present in the first sequence but
    not the second |'
  id: totrans-2385
  prefs: []
  type: TYPE_TB
  zh: '| `Except`, `ExceptBy` | 返回只存在于第一个序列中而不在第二个序列中的元素 |'
- en: Table 8\. Element operators
  id: totrans-2386
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8\. 元素运算符
- en: '| Method | Description |'
  id: totrans-2387
  prefs: []
  type: TYPE_TB
  zh: '| Method | Description |'
- en: '| --- | --- |'
  id: totrans-2388
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `First`, `FirstOrDefault` | Returns the first element in the sequence, or
    the first element satisfying a given predicate |'
  id: totrans-2389
  prefs: []
  type: TYPE_TB
  zh: '| `First`, `FirstOrDefault` | 返回序列中的第一个元素，或满足给定条件的第一个元素 |'
- en: '| `Last`, `LastOrDefault` | Returns the last element in the sequence, or the
    last element satisfying a given predicate |'
  id: totrans-2390
  prefs: []
  type: TYPE_TB
  zh: '| `Last`, `LastOrDefault` | 返回序列中的最后一个元素，或满足给定条件的最后一个元素 |'
- en: '| `Single`, `SingleOrDefault` | Equivalent to `First`/`FirstOrDefault` but
    throws an exception if there is more than one match |'
  id: totrans-2391
  prefs: []
  type: TYPE_TB
  zh: '| `Single`, `SingleOrDefault` | 等效于 `First`/`FirstOrDefault`，但如果有多个匹配则抛出异常
    |'
- en: '| `MinBy`, `MaxBy` | Returns the element with the smallest or largest value,
    as determined by a key selector |'
  id: totrans-2392
  prefs: []
  type: TYPE_TB
  zh: '| `MinBy`, `MaxBy` | 返回具有最小或最大值的元素，由键选择器确定 |'
- en: '| `ElementAt`, `ElementAtOrDefault` | Returns the element at the specified
    position |'
  id: totrans-2393
  prefs: []
  type: TYPE_TB
  zh: '| `ElementAt`, `ElementAtOrDefault` | 返回指定位置的元素 |'
- en: '| `DefaultIfEmpty` | Returns a single-value sequence whose value is null or
    `default(TSource)` if the sequence has no elements |'
  id: totrans-2394
  prefs: []
  type: TYPE_TB
  zh: '| `DefaultIfEmpty` | 如果序列为空则返回一个包含单个值的序列，该值为 null 或 `default(TSource)` |'
- en: Table 9\. Aggregation operators
  id: totrans-2395
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9\. 聚合运算符
- en: '| Method | Description |'
  id: totrans-2396
  prefs: []
  type: TYPE_TB
  zh: '| Method | Description |'
- en: '| --- | --- |'
  id: totrans-2397
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Count`, `LongCount` | Returns the total number of elements in the input
    sequence, or the number of elements satisfying a given predicate |'
  id: totrans-2398
  prefs: []
  type: TYPE_TB
  zh: '| `Count`, `LongCount` | 返回输入序列中的元素总数，或满足给定条件的元素数量 |'
- en: '| `Min`, `Max` | Returns the smallest or largest element in the sequence |'
  id: totrans-2399
  prefs: []
  type: TYPE_TB
  zh: '| `Min`, `Max` | 返回序列中的最小或最大元素 |'
- en: '| `Sum`, `Average` | Calculates a numeric sum or average over elements in the
    sequence |'
  id: totrans-2400
  prefs: []
  type: TYPE_TB
  zh: '| `Sum`, `Average` | 计算序列中元素的数值总和或平均值 |'
- en: '| `Aggregate` | Performs a custom aggregation |'
  id: totrans-2401
  prefs: []
  type: TYPE_TB
  zh: '| `Aggregate` | 执行自定义聚合操作 |'
- en: Table 10\. Quantifiers
  id: totrans-2402
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10\. 量词运算符
- en: '| Method | Description |'
  id: totrans-2403
  prefs: []
  type: TYPE_TB
  zh: '| Method | Description |'
- en: '| --- | --- |'
  id: totrans-2404
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Contains` | Returns `true` if the input sequence contains the given element
    |'
  id: totrans-2405
  prefs: []
  type: TYPE_TB
  zh: '| `Contains` | 如果输入序列包含给定元素则返回 `true` |'
- en: '| `Any` | Returns `true` if any elements satisfy the given predicate |'
  id: totrans-2406
  prefs: []
  type: TYPE_TB
  zh: '| `Any` | 如果任何元素满足给定条件则返回 `true` |'
- en: '| `All` | Returns `true` if all elements satisfy the given predicate |'
  id: totrans-2407
  prefs: []
  type: TYPE_TB
  zh: '| `All` | 如果所有元素都满足给定条件则返回 `true` |'
- en: '| `SequenceEqual` | Returns `true` if the second sequence has identical elements
    to the input sequence |'
  id: totrans-2408
  prefs: []
  type: TYPE_TB
  zh: '| `SequenceEqual` | 如果第二个序列与输入序列具有相同的元素，则返回`true` |'
- en: Table 11\. Conversion operators (import)
  id: totrans-2409
  prefs: []
  type: TYPE_NORMAL
  zh: Table 11\. 转换操作符（导入）
- en: '| Method | Description |'
  id: totrans-2410
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-2411
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `OfType` | Converts `IEnumerable` to `IEnumerable<T>`, discarding wrongly
    typed elements |'
  id: totrans-2412
  prefs: []
  type: TYPE_TB
  zh: '| `OfType` | 将`IEnumerable`转换为`IEnumerable<T>`，丢弃类型不正确的元素 |'
- en: '| `**Cast**` | Converts `IEnumerable` to `IEnumerable<T>`, throwing an exception
    if there are any wrongly typed elements |'
  id: totrans-2413
  prefs: []
  type: TYPE_TB
  zh: '| `**Cast**` | 将`IEnumerable`转换为`IEnumerable<T>`，如果有任何类型不正确的元素则抛出异常 |'
- en: Table 12\. Conversion operators (export)
  id: totrans-2414
  prefs: []
  type: TYPE_NORMAL
  zh: Table 12\. 转换操作符（导出）
- en: '| Method | Description |'
  id: totrans-2415
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-2416
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ToArray` | Converts `IEnumerable<T>` to `T[]` |'
  id: totrans-2417
  prefs: []
  type: TYPE_TB
  zh: '| `ToArray` | 将`IEnumerable<T>`转换为`T[]` |'
- en: '| `ToList` | Converts `IEnumerable<T>` to `List<T>` |'
  id: totrans-2418
  prefs: []
  type: TYPE_TB
  zh: '| `ToList` | 将`IEnumerable<T>`转换为`List<T>` |'
- en: '| `ToDictionary` | Converts `IEnumerable<T>` to `Dictionary<TKey,TValue>` |'
  id: totrans-2419
  prefs: []
  type: TYPE_TB
  zh: '| `ToDictionary` | 将`IEnumerable<T>`转换为`Dictionary<TKey,TValue>` |'
- en: '| `ToHashSet` | Converts `IEnumerable<T>` to `HashSet<T>` |'
  id: totrans-2420
  prefs: []
  type: TYPE_TB
  zh: '| `ToHashSet` | 将`IEnumerable<T>`转换为`HashSet<T>` |'
- en: '| `ToLookup` | Converts `IEnumerable<T>` to `ILookup<TKey,TElement>` |'
  id: totrans-2421
  prefs: []
  type: TYPE_TB
  zh: '| `ToLookup` | 将`IEnumerable<T>`转换为`ILookup<TKey,TElement>` |'
- en: '| `AsEnumerable` | Downcasts to `IEnumerable<T>` |'
  id: totrans-2422
  prefs: []
  type: TYPE_TB
  zh: '| `AsEnumerable` | 向下转换为`IEnumerable<T>` |'
- en: '| `AsQueryable` | Casts or converts to `IQueryable<T>` |'
  id: totrans-2423
  prefs: []
  type: TYPE_TB
  zh: '| `AsQueryable` | 强制转换或转换为`IQueryable<T>` |'
- en: Table 13\. Generation operators
  id: totrans-2424
  prefs: []
  type: TYPE_NORMAL
  zh: Table 13\. 生成操作符
- en: '| Method | Description |'
  id: totrans-2425
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-2426
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Empty` | Creates an empty sequence |'
  id: totrans-2427
  prefs: []
  type: TYPE_TB
  zh: '| `Empty` | 创建一个空序列 |'
- en: '| `Repeat` | Creates a sequence of repeating elements |'
  id: totrans-2428
  prefs: []
  type: TYPE_TB
  zh: '| `Repeat` | 创建一个重复元素序列 |'
- en: '| `Range` | Creates a sequence of integers |'
  id: totrans-2429
  prefs: []
  type: TYPE_TB
  zh: '| `Range` | 创建一个整数序列 |'
- en: Chaining Query Operators
  id: totrans-2430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链式查询操作符
- en: 'To build more complex queries, you chain query operators together. For example,
    the following query extracts all strings containing the letter *a*, sorts them
    by length, and then converts the results to uppercase:'
  id: totrans-2431
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建更复杂的查询，您可以将查询操作符链接在一起。例如，以下查询提取所有包含字母*a*的字符串，按长度排序，然后将结果转换为大写：
- en: '[PRE586]'
  id: totrans-2432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE586]'
- en: '`Where`, `OrderBy`, and `Select` are all standard query operators that resolve
    to extension methods in the `Enumerable` class. The `Where` operator emits a filtered
    version of the input sequence, `OrderBy` emits a sorted version of its input sequence,
    and `Select` emits a sequence in which each input element is transformed or *projected*
    with a given lambda expression (`n.To​Up⁠per()` in this case). Data flows from
    left to right through the chain of operators, so the data is first filtered, then
    sorted, then projected. The end result resembles a production line of conveyor
    belts, as illustrated in [Figure 6](#chaining_query_operators).'
  id: totrans-2433
  prefs: []
  type: TYPE_NORMAL
  zh: '`Where`、`OrderBy` 和 `Select` 都是标准查询操作符，对应于`Enumerable`类中的扩展方法。`Where`操作符发出输入序列的筛选版本，`OrderBy`发出其输入序列的排序版本，`Select`发出使用给定Lambda表达式进行变换或*投影*的序列（在本例中为`n.ToUpper()`）。数据通过操作符链从左到右流动，因此首先进行过滤，然后排序，然后投影。最终结果类似于生产线上的传送带，如[图
    6](#chaining_query_operators)所示。'
- en: '![Chaining query operators](Images/c12p_0106.png)'
  id: totrans-2434
  prefs: []
  type: TYPE_IMG
  zh: '![链式查询操作符](Images/c12p_0106.png)'
- en: Figure 6\. Chaining query operators
  id: totrans-2435
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6\. 链式查询操作符
- en: Deferred execution is honored throughout with operators, so no filtering, sorting,
    or projecting takes place until the query is actually enumerated.
  id: totrans-2436
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符始终遵守延迟执行，因此直到实际枚举查询时才进行过滤、排序或投影。
- en: Query Expressions
  id: totrans-2437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询表达式
- en: 'So far, we’ve written queries by calling extension methods in the `Enumerable`
    class. In this book, we describe this as *fluent syntax*. C# also provides special
    language support for writing queries, called *query expressions*. Here’s the preceding
    query expressed as a query expression:'
  id: totrans-2438
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经通过调用`Enumerable`类中的扩展方法编写了查询。在本书中，我们将其描述为*流畅语法*。C#还提供了用于编写查询的特殊语言支持，称为*查询表达式*。以下是前述查询表达为查询表达式的示例：
- en: '[PRE587]'
  id: totrans-2439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE587]'
- en: A query expression always starts with a `from` clause, and ends with either
    a `select` or `group` clause. The `from` clause declares a *range variable* (in
    this case, `n`), which you can think of as traversing the input collection—rather
    like `foreach`. [Figure 7](#query_expression_syntax) illustrates the complete
    syntax.
  id: totrans-2440
  prefs: []
  type: TYPE_NORMAL
  zh: 查询表达式始终以`from`子句开始，并以`select`或`group`子句结束。`from`子句声明一个*范围变量*（在本例中为`n`），您可以将其视为遍历输入集合，类似于`foreach`。[图
    7](#query_expression_syntax)说明了完整的语法结构。
- en: '![Query expression syntax](Images/c12p_0107.png)'
  id: totrans-2441
  prefs: []
  type: TYPE_IMG
  zh: '![查询表达式语法](Images/c12p_0107.png)'
- en: Figure 7\. Query expression syntax
  id: totrans-2442
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7\. 查询表达式语法
- en: Note
  id: totrans-2443
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: If you’re familiar with SQL, LINQ’s query expression syntax—with the `from`
    clause first and the `select` clause last—might look bizarre. Query expression
    syntax is actually more logical because the clauses appear *in the order they’re
    executed*. This allows Visual Studio to prompt you with IntelliSense as you type
    and simplifies the scoping rules for subqueries.
  id: totrans-2444
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉 SQL，LINQ 的查询表达式语法——从 `from` 子句开始，`select` 子句在最后——可能看起来很奇怪。实际上，查询表达式语法更为逻辑，因为子句
    *按执行顺序* 出现。这使得 Visual Studio 在您键入时可以使用 IntelliSense 提示，并简化了子查询的作用域规则。
- en: 'The compiler processes query expressions by translating them to fluent syntax.
    It does this in a fairly mechanical fashion—much like it translates `foreach`
    statements into calls to `GetEnumerator` and `MoveNext`:'
  id: totrans-2445
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器通过将查询表达式转换为流畅语法来处理查询表达式。它以一种相当机械化的方式进行此操作，就像它将 `foreach` 语句转换为对 `GetEnumerator`
    和 `MoveNext` 的调用一样：
- en: '[PRE588]'
  id: totrans-2446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE588]'
- en: The `Where`, `OrderBy`, and `Select` operators then resolve using the same rules
    that would apply if the query were written in fluent syntax. In this case, they
    bind to extension methods in the `Enumerable` class (assuming that you’ve imported
    the `System.Linq` namespace) because `names` implements `IEnumerable<string>`.
    The compiler doesn’t specifically favor the `Enumerable` class, however, when
    translating query syntax. You can think of the compiler as mechanically injecting
    the words *Where*, *OrderBy*, and *Select* into the statement and then compiling
    it as though you’d typed the method names yourself. This offers flexibility in
    how they resolve—the operators in Entity Framework queries, for instance, bind
    instead to the extension methods in the `Queryable` class.
  id: totrans-2447
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`Where`、`OrderBy` 和 `Select` 运算符将使用与在流畅语法中编写查询时相同的规则解析。在这种情况下，它们绑定到 `Enumerable`
    类中的扩展方法（假设已导入了 `System.Linq` 命名空间），因为 `names` 实现了 `IEnumerable<string>`。然而，编译器在转换查询语法时并不专门偏爱
    `Enumerable` 类。您可以将编译器视为在语句中机械地注入 *Where*、*OrderBy* 和 *Select* 这些词，然后编译它，就像您自己键入方法名一样。这样可以灵活地解析它们——例如，Entity
    Framework 查询中的运算符则绑定到 `Queryable` 类中的扩展方法。
- en: Query expressions versus fluent queries
  id: totrans-2448
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询表达式与流畅查询
- en: Query expressions and fluent queries each have advantages.
  id: totrans-2449
  prefs: []
  type: TYPE_NORMAL
  zh: 查询表达式和流畅查询各有其优点。
- en: 'Query expressions support only a small subset of query operators, namely:'
  id: totrans-2450
  prefs: []
  type: TYPE_NORMAL
  zh: 查询表达式仅支持查询运算符的一个小子集，即：
- en: '[PRE589]'
  id: totrans-2451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE589]'
- en: 'For queries that use other operators, you must either write entirely in fluent
    syntax or construct mixed-syntax queries; for example:'
  id: totrans-2452
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用其他运算符的查询，您必须要么完全使用流畅语法编写，要么构建混合语法查询；例如：
- en: '[PRE590]'
  id: totrans-2453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE590]'
- en: This query returns names whose length matches that of the shortest (“Tom” and
    “Jay”). The subquery (in bold) calculates the minimum length of each name and
    evaluates to 3\. We need to use fluent syntax for the subquery, because the `Min`
    operator has no support in query expression syntax. We can, however, still use
    query syntax for the outer query.
  id: totrans-2454
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询返回与最短长度匹配的名称（“Tom” 和 “Jay”）。 **子查询（粗体）** 计算每个名称的最小长度，并计算为 3。我们需要使用流畅语法进行子查询，因为查询表达式语法中不支持
    `Min` 运算符。但是，我们仍然可以在外部查询中使用查询语法。
- en: 'The main advantage of query syntax is that it can radically simplify queries
    that involve the following:'
  id: totrans-2455
  prefs: []
  type: TYPE_NORMAL
  zh: 查询语法的主要优势在于它可以极大地简化涉及以下内容的查询：
- en: A `let` clause for introducing a new variable alongside the range variable
  id: totrans-2456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`let` 关键字用于在范围变量旁引入一个新变量。'
- en: Multiple generators (`SelectMany`) followed by an outer range variable reference
  id: totrans-2457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个生成器（`SelectMany`）后跟外部范围变量引用
- en: A `Join` or `GroupJoin` equivalent followed by an outer range variable reference
  id: totrans-2458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等效于 `Join` 或 `GroupJoin`，然后是外部范围变量引用
- en: The let Keyword
  id: totrans-2459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`let` 关键字'
- en: 'The `let` keyword introduces a new variable alongside the range variable. For
    instance, suppose that you want to list all names whose length, without vowels,
    is greater than two characters:'
  id: totrans-2460
  prefs: []
  type: TYPE_NORMAL
  zh: '`let` 关键字在范围变量旁引入一个新变量。例如，假设您想列出所有长度（去除元音后）大于两个字符的名称：'
- en: '[PRE591]'
  id: totrans-2461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE591]'
- en: 'The output from enumerating this query is:'
  id: totrans-2462
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举此查询的输出为：
- en: '[PRE592]'
  id: totrans-2463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE592]'
- en: The `let` clause performs a calculation on each element, without losing the
    original element. In our query, the subsequent clauses (`where`, `orderby`, and
    `select`) have access to both `n` and `vowelless`. A query can include multiple
    `let` clauses, and they can be interspersed with additional `where` and `join`
    clauses.
  id: totrans-2464
  prefs: []
  type: TYPE_NORMAL
  zh: '`let` 子句对每个元素执行计算，而不会丢失原始元素。在我们的查询中，后续子句（`where`、`orderby` 和 `select`）可以访问
    `n` 和 `vowelless`。一个查询可以包括多个 `let` 子句，并且它们可以与额外的 `where` 和 `join` 子句交替使用。'
- en: 'The compiler translates the `let` keyword by projecting into a temporary anonymous
    type that contains both the original and transformed elements:'
  id: totrans-2465
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器通过投影到一个包含原始和转换元素的临时匿名类型来转换`let`关键字：
- en: '[PRE593]'
  id: totrans-2466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE593]'
- en: Query Continuations
  id: totrans-2467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询继续
- en: 'If you want to add clauses *after* a `select` or `group` clause, you must use
    the `into` keyword to “continue” the query. For instance:'
  id: totrans-2468
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望在`select`或`group`子句*后*添加子句，必须使用`into`关键字来“继续”查询。例如：
- en: '[PRE594]'
  id: totrans-2469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE594]'
- en: Following an `into` clause, the previous range variable is out of scope.
  id: totrans-2470
  prefs: []
  type: TYPE_NORMAL
  zh: 在`into`子句后，前一个范围变量已经超出范围。
- en: 'The compiler simply translates queries with an `into` keyword into a longer
    chain of operators:'
  id: totrans-2471
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器简单地将带有`into`关键字的查询转换为更长的操作链：
- en: '[PRE595]'
  id: totrans-2472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE595]'
- en: (It omits the final `Select(upper=>upper)` because it’s redundant.)
  id: totrans-2473
  prefs: []
  type: TYPE_NORMAL
  zh: （它省略了最后的`Select(upper=>upper)`，因为它是多余的。）
- en: Multiple Generators
  id: totrans-2474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个生成器
- en: 'A query can include multiple generators (`from` clauses). For example:'
  id: totrans-2475
  prefs: []
  type: TYPE_NORMAL
  zh: 查询可以包括多个生成器（`from`子句）。例如：
- en: '[PRE596]'
  id: totrans-2476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE596]'
- en: 'The result is a cross product, rather like you’d get with nested `foreach`
    loops:'
  id: totrans-2477
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个交叉乘积，类似于嵌套的`foreach`循环：
- en: '[PRE597]'
  id: totrans-2478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE597]'
- en: 'When there’s more than one `from` clause in a query, the compiler emits a call
    to `SelectMany`:'
  id: totrans-2479
  prefs: []
  type: TYPE_NORMAL
  zh: 当查询中有多个`from`子句时，编译器会发出对`SelectMany`的调用：
- en: '[PRE598]'
  id: totrans-2480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE598]'
- en: '`SelectMany` performs nested looping. It enumerates every element in the source
    collection (`numbers`), transforming each element with the first lambda expression
    (`letters`). This generates a sequence of *subsequences*, which it then enumerates.
    The final output elements are determined by the second lambda expression (`n.ToString()+l`).'
  id: totrans-2481
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectMany`执行嵌套循环。它枚举源集合（`numbers`）中的每个元素，并使用第一个lambda表达式（`letters`）转换每个元素。这生成一系列*子序列*，然后它枚举这些子序列。最终的输出元素由第二个lambda表达式（`n.ToString()+l`）确定。'
- en: 'If you subsequently apply a `where` clause, you can filter the cross product
    and project a result akin to a *join*:'
  id: totrans-2482
  prefs: []
  type: TYPE_NORMAL
  zh: 如果随后应用了`where`子句，您可以过滤交叉乘积并投影出类似*连接*的结果：
- en: '[PRE599]'
  id: totrans-2483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE599]'
- en: The translation of this query into fluent syntax is more complex, requiring
    a temporary anonymous projection. The ability to perform this translation automatically
    is one of the key benefits of query expressions.
  id: totrans-2484
  prefs: []
  type: TYPE_NORMAL
  zh: 将此查询转换为流畅语法更为复杂，需要一个临时匿名投影。自动执行此转换是查询表达式的关键优势之一。
- en: 'The expression in the second generator is allowed to use the first range variable:'
  id: totrans-2485
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个生成器中的表达式允许使用第一个范围变量：
- en: '[PRE600]'
  id: totrans-2486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE600]'
- en: This works because the expression `fullName.Split` emits a *sequence* (an array
    of strings).
  id: totrans-2487
  prefs: []
  type: TYPE_NORMAL
  zh: 这有效，因为表达式`fullName.Split`生成一个*序列*（字符串数组）。
- en: Multiple generators are used extensively in database queries to flatten parent–child
    relationships and to perform manual joins.
  id: totrans-2488
  prefs: []
  type: TYPE_NORMAL
  zh: 多个生成器在数据库查询中被广泛使用，以展开父子关系并执行手动连接。
- en: Joining
  id: totrans-2489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接
- en: LINQ provides three *joining* operators, the main ones being `Join` and `GroupJoin`,
    which perform keyed lookup-based joins. `Join` and `GroupJoin` support only a
    subset of the functionality you get with multiple generators/`SelectMany`, but
    are more performant with local queries because they use a hashtable-based lookup
    strategy rather than performing nested loops. (With Entity Framework queries,
    the joining operators have no advantage over multiple generators.)
  id: totrans-2490
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ提供了三个*连接*运算符，主要是`Join`和`GroupJoin`，它们执行基于键的查找连接。`Join`和`GroupJoin`仅支持多个生成器/`SelectMany`的部分功能，但在本地查询中更高效，因为它们使用基于哈希表的查找策略，而不是执行嵌套循环。（在Entity
    Framework查询中，连接运算符与多个生成器相比没有优势。）
- en: '`Join` and `GroupJoin` support only *equi-joins* (i.e., the joining condition
    must use the equality operator). There are two methods: `Join` and `GroupJoin`.
    `Join` emits a flat result set, whereas `GroupJoin` emits a hierarchical result
    set.'
  id: totrans-2491
  prefs: []
  type: TYPE_NORMAL
  zh: '`Join`和`GroupJoin`仅支持*等连接*（即连接条件必须使用等号操作符）。有两种方法：`Join`和`GroupJoin`。`Join`生成扁平的结果集，而`GroupJoin`生成分层结果集。'
- en: 'Following is the query expression syntax for a flat join:'
  id: totrans-2492
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于平面连接的查询表达式语法：
- en: '[PRE601]'
  id: totrans-2493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE601]'
- en: 'For example, consider the following collections:'
  id: totrans-2494
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下集合：
- en: '[PRE602]'
  id: totrans-2495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE602]'
- en: 'We could perform a join as follows:'
  id: totrans-2496
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以执行如下的连接操作：
- en: '[PRE603]'
  id: totrans-2497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE603]'
- en: 'The compiler translates this to:'
  id: totrans-2498
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将此转换为：
- en: '[PRE604]'
  id: totrans-2499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE604]'
- en: 'Here’s the result:'
  id: totrans-2500
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果：
- en: '[PRE605]'
  id: totrans-2501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE605]'
- en: 'With local sequences, `Join` and `GroupJoin` are more efficient at processing
    large collections than `SelectMany` because they first preload the inner sequence
    into a keyed hashtable-based lookup. With a database query, however, you could
    achieve the same result equally efficiently as follows:'
  id: totrans-2502
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本地序列，`Join`和`GroupJoin`在处理大型集合时比`SelectMany`更有效，因为它们首先将内部序列预加载到基于键的哈希表查找中。但是，通过数据库查询，您同样可以以以下方式同样高效地实现相同的结果：
- en: '[PRE606]'
  id: totrans-2503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE606]'
- en: GroupJoin
  id: totrans-2504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GroupJoin
- en: '`GroupJoin` does the same work as `Join`, but instead of yielding a flat result,
    it yields a hierarchical result, grouped by each outer element.'
  id: totrans-2505
  prefs: []
  type: TYPE_NORMAL
  zh: '`GroupJoin`与`Join`执行相同的工作，但不是产生一个平坦的结果，而是产生一个按每个外部元素分组的分层结果。'
- en: 'The query expression syntax for `GroupJoin` is the same as for `Join`, but
    is followed by the `into` keyword. Here’s a basic example, using the `customers`
    and `purchases` collections we set up in the previous section:'
  id: totrans-2506
  prefs: []
  type: TYPE_NORMAL
  zh: '`GroupJoin`的查询表达式语法与`Join`相同，但后面跟着`into`关键字。以下是一个基本示例，使用我们在前一节设置的`customers`和`purchases`集合：'
- en: '[PRE607]'
  id: totrans-2507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE607]'
- en: Note
  id: totrans-2508
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'An `into` clause translates to `GroupJoin` only when it appears directly after
    a `join` clause. After a `select` or `group` clause, it means *query continuation*.
    The two uses of the `into` keyword are quite different, although they have one
    feature in common: they both introduce a new query variable.'
  id: totrans-2509
  prefs: []
  type: TYPE_NORMAL
  zh: '`into`子句只有在直接跟在`join`子句之后时才会转换为`GroupJoin`。在`select`或`group`子句之后，它意味着*查询继续*。`into`关键字的这两种用法非常不同，尽管它们有一个共同的特征：它们都引入了一个新的查询变量。'
- en: 'The result is a sequence of sequences—`IEnumerable<IEnumerable<T>>`—which you
    could enumerate as follows:'
  id: totrans-2510
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一系列序列`IEnumerable<IEnumerable<T>>`，您可以如下枚举它们：
- en: '[PRE608]'
  id: totrans-2511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE608]'
- en: 'This isn’t very useful, however, because `outerSeq` has no reference to the
    outer customer. More commonly, you’d reference the outer range variable in the
    projection:'
  id: totrans-2512
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是很有用，因为`outerSeq`没有引用外部的顾客。更常见的是，在投影中引用外部的范围变量：
- en: '[PRE609]'
  id: totrans-2513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE609]'
- en: 'You could obtain the same result (but less efficiently, for local queries)
    by projecting into an anonymous type that included a subquery:'
  id: totrans-2514
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过投影到包含子查询的匿名类型来获得相同的结果（但对于本地查询来说效率较低）：
- en: '[PRE610]'
  id: totrans-2515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE610]'
- en: Zip
  id: totrans-2516
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Zip
- en: '`Zip` is the simplest joining operator. It enumerates two sequences in step
    (like a zipper), returning a sequence based on applying a function over each element
    pair; thus:'
  id: totrans-2517
  prefs: []
  type: TYPE_NORMAL
  zh: '`Zip`是最简单的连接运算符。它以步骤方式枚举两个序列（像拉链一样），根据每个元素对应应用函数，从而得到一个基于以下函数的序列：'
- en: '[PRE611]'
  id: totrans-2518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE611]'
- en: 'produces a sequence with the following elements:'
  id: totrans-2519
  prefs: []
  type: TYPE_NORMAL
  zh: 产生一个包含以下元素的序列：
- en: '[PRE612]'
  id: totrans-2520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE612]'
- en: Extra elements in either input sequence are ignored. `Zip` is not supported
    when you are querying a database.
  id: totrans-2521
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略任一输入序列中的额外元素。在查询数据库时不支持`Zip`。
- en: Ordering
  id: totrans-2522
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序
- en: 'The `orderby` keyword sorts a sequence. You can specify any number of expressions
    upon which to sort:'
  id: totrans-2523
  prefs: []
  type: TYPE_NORMAL
  zh: '`orderby`关键字对序列进行排序。您可以指定任意数量的表达式来进行排序：'
- en: '[PRE613]'
  id: totrans-2524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE613]'
- en: 'This sorts first by length and then by name, yielding this result:'
  id: totrans-2525
  prefs: []
  type: TYPE_NORMAL
  zh: 首先按长度排序，然后按名称排序，得到以下结果：
- en: '[PRE614]'
  id: totrans-2526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE614]'
- en: 'The compiler translates the first `orderby` expression to a call to `OrderBy`,
    and subsequent expressions to a call to `ThenBy`:'
  id: totrans-2527
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将第一个`orderby`表达式转换为对`OrderBy`的调用，将后续表达式转换为对`ThenBy`的调用：
- en: '[PRE615]'
  id: totrans-2528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE615]'
- en: The `ThenBy` operator *refines* rather than *replaces* the previous sorting.
  id: totrans-2529
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThenBy`操作符*细化*而不是*替换*先前的排序。'
- en: 'You can include the `descending` keyword after any of the `orderby` expressions:'
  id: totrans-2530
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在任何`orderby`表达式之后包含`descending`关键字：
- en: '[PRE616]'
  id: totrans-2531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE616]'
- en: 'This translates to the following:'
  id: totrans-2532
  prefs: []
  type: TYPE_NORMAL
  zh: 这转换为以下内容：
- en: '[PRE617]'
  id: totrans-2533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE617]'
- en: Note
  id: totrans-2534
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The ordering operators return an extended type of `IEnumerable<T>` called `IOrderedEnumerable<T>`.
    This interface defines the extra functionality required by the `ThenBy` operator.
  id: totrans-2535
  prefs: []
  type: TYPE_NORMAL
  zh: 排序操作符返回一个扩展类型的`IEnumerable<T>`称为`IOrderedEnumerable<T>`。此接口定义了`ThenBy`操作符所需的额外功能。
- en: Grouping
  id: totrans-2536
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分组
- en: '`GroupBy` organizes a flat input sequence into sequences of *groups*. For example,
    the following groups a sequence of names by their length:'
  id: totrans-2537
  prefs: []
  type: TYPE_NORMAL
  zh: '`GroupBy`将一个平坦的输入序列组织成*组*的序列。例如，以下根据它们的长度将一个名称序列分组：'
- en: '[PRE618]'
  id: totrans-2538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE618]'
- en: 'The compiler translates this query into the following:'
  id: totrans-2539
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将此查询转换为以下内容：
- en: '[PRE619]'
  id: totrans-2540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE619]'
- en: 'Here’s how to enumerate the result:'
  id: totrans-2541
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是枚举结果的方法：
- en: '[PRE620]'
  id: totrans-2542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE620]'
- en: '`Enumerable.GroupBy` works by reading the input elements into a temporary dictionary
    of lists so that all elements with the same key end up in the same sublist. It
    then emits a sequence of *groupings*. A grouping is a sequence with a `Key` property:'
  id: totrans-2543
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enumerable.GroupBy`通过将输入元素读取到一个临时字典的列表中来工作，以便所有具有相同键的元素最终在同一个子列表中。然后它发出一个*分组*的序列。分组是具有`Key`属性的序列：'
- en: '[PRE621]'
  id: totrans-2544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE621]'
- en: 'By default, the elements in each grouping are untransformed input elements,
    unless you specify an `elementSelector` argument. The following projects each
    input element to uppercase:'
  id: totrans-2545
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每个分组中的元素是未转换的输入元素，除非您指定了一个`elementSelector`参数。以下示例将每个输入元素投影为大写：
- en: '[PRE622]'
  id: totrans-2546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE622]'
- en: 'which translates to:'
  id: totrans-2547
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译为：
- en: '[PRE623]'
  id: totrans-2548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE623]'
- en: 'The subcollections are not emitted in order of key. `GroupBy` does no *sorting*
    (in fact, it preserves the original ordering). To sort, you must add an `OrderBy`
    operator (which means first adding an `into` clause, because `group by` ordinarily
    ends a query):'
  id: totrans-2549
  prefs: []
  type: TYPE_NORMAL
  zh: 子集合不按键的顺序发出。`GroupBy`不进行*排序*（事实上，它保留原始顺序）。要排序，必须添加一个`OrderBy`运算符（这意味着首先添加一个`into`子句，因为通常`group
    by`结束一个查询）：
- en: '[PRE624]'
  id: totrans-2550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE624]'
- en: 'Query continuations are often used in a `group by` query. The next query filters
    out groups that have exactly two matches in them:'
  id: totrans-2551
  prefs: []
  type: TYPE_NORMAL
  zh: 查询延续经常在`group by`查询中使用。下一个查询过滤掉那些正好有两个匹配项的组：
- en: '[PRE625]'
  id: totrans-2552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE625]'
- en: Note
  id: totrans-2553
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A `where` after a `group by` is equivalent to `HAVING` in SQL. It applies to
    each subsequence or grouping as a whole rather than the individual elements.
  id: totrans-2554
  prefs: []
  type: TYPE_NORMAL
  zh: '`group by`后的`where`等同于SQL中的`HAVING`。它适用于每个子序列或分组作为整体而不是单个元素。'
- en: OfType and Cast
  id: totrans-2555
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`OfType`和`Cast`'
- en: '`OfType` and `Cast` accept a nongeneric `IEnumerable` collection and emit a
    generic `IEnumerable<T>` sequence that you can subsequently query:'
  id: totrans-2556
  prefs: []
  type: TYPE_NORMAL
  zh: '`OfType`和`Cast`接受一个非泛型的`IEnumerable`集合，并发出一个泛型的`IEnumerable<T>`序列，随后您可以查询该序列：'
- en: '[PRE626]'
  id: totrans-2557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE626]'
- en: This is useful because it allows you to query collections written prior to C#
    2.0 (when `IEnumerable<T>` was introduced), such as `ControlCollection` in `System.Windows.Forms`.
  id: totrans-2558
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有用，因为它允许您查询在C# 2.0之前编写的集合（当时引入了`IEnumerable<T>`），比如`System.Windows.Forms`中的`ControlCollection`。
- en: '`Cast` and `OfType` differ in their behavior when encountering an input element
    that’s of an incompatible type: `Cast` throws an exception, whereas `OfType` ignores
    the incompatible element.'
  id: totrans-2559
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cast`和`OfType`在遇到不兼容类型的输入元素时行为不同：`Cast`抛出异常，而`OfType`忽略不兼容的元素。'
- en: 'The rules for element compatibility follow those of C#’s `is` operator. Here’s
    the internal implementation of `Cast`:'
  id: totrans-2560
  prefs: []
  type: TYPE_NORMAL
  zh: 元素兼容性规则遵循C#的`is`运算符的规则。这是`Cast`的内部实现：
- en: '[PRE627]'
  id: totrans-2561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE627]'
- en: 'C# supports the `Cast` operator in query expressions—simply insert the element
    type immediately after the `from` keyword:'
  id: totrans-2562
  prefs: []
  type: TYPE_NORMAL
  zh: C#支持查询表达式中的`Cast`运算符——只需在`from`关键字后立即插入元素类型：
- en: '[PRE628]'
  id: totrans-2563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE628]'
- en: 'This translates to the following:'
  id: totrans-2564
  prefs: []
  type: TYPE_NORMAL
  zh: 这翻译成如下内容：
- en: '[PRE629]'
  id: totrans-2565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE629]'
- en: Dynamic Binding
  id: totrans-2566
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态绑定
- en: '*Dynamic binding* defers *binding*—the process of resolving types, members,
    and operators—from compile time to runtime. Dynamic binding is useful when at
    compile time *you* know that a certain function, member, or operator exists, but
    the *compiler* does not. This commonly occurs when you are interoperating with
    dynamic languages (such as IronPython) and COM and in scenarios when you might
    otherwise use reflection.'
  id: totrans-2567
  prefs: []
  type: TYPE_NORMAL
  zh: '*动态绑定*延迟了*绑定*—解析类型、成员和运算符的过程—从编译时到运行时。动态绑定在编译时*您*知道某个函数、成员或运算符存在，但*编译器*不知道时非常有用。这通常发生在与动态语言（如IronPython）和COM的互操作以及您可能使用反射的情况下。'
- en: 'A dynamic type is declared by using the contextual keyword `dynamic`:'
  id: totrans-2568
  prefs: []
  type: TYPE_NORMAL
  zh: 动态类型通过使用上下文关键字`dynamic`声明：
- en: '[PRE630]'
  id: totrans-2569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE630]'
- en: A dynamic type instructs the compiler to relax. We expect the runtime type of
    `d` to have a `Quack` method. We just can’t prove it statically. Because `d` is
    dynamic, the compiler defers binding `Quack` to `d` until runtime. Understanding
    what this means requires distinguishing between *static binding* and *dynamic
    binding*.
  id: totrans-2570
  prefs: []
  type: TYPE_NORMAL
  zh: 动态类型指示编译器放松。我们期望`d`的运行时类型具有`Quack`方法。我们只是不能在静态上下文中证明它。因为`d`是动态的，编译器将`Quack`绑定到`d`直到运行时。理解这意味着需要区分*静态绑定*和*动态绑定*。
- en: Static Binding Versus Dynamic Binding
  id: totrans-2571
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态绑定与动态绑定
- en: 'The canonical binding example is mapping a name to a specific function when
    compiling an expression. To compile the following expression, the compiler needs
    to find the implementation of the method named `Quack`:'
  id: totrans-2572
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的绑定示例是在编译表达式时将名称映射到特定函数。要编译以下表达式，编译器需要找到名为`Quack`的方法的实现：
- en: '[PRE631]'
  id: totrans-2573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE631]'
- en: 'Let’s suppose the static type of `d` is `Duck`:'
  id: totrans-2574
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`d`的静态类型是`Duck`：
- en: '[PRE632]'
  id: totrans-2575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE632]'
- en: In the simplest case, the compiler does the binding by looking for a parameterless
    method named `Quack` on `Duck`. Failing that, the compiler extends its search
    to methods taking optional parameters, methods on base classes of `Duck`, and
    extension methods that take `Duck` as its first parameter. If no match is found,
    you’ll get a compilation error. Regardless of what method is bound, the bottom
    line is that the binding is done by the compiler, and the binding utterly depends
    on statically knowing the types of the operands (in this case, `d`). This makes
    it *static binding*.
  id: totrans-2576
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，编译器通过查找`Duck`上名为`Quack`的无参方法来进行绑定。如果失败，编译器会扩展其搜索到带有可选参数的方法、`Duck`的基类方法以及以`Duck`作为第一个参数的扩展方法。如果找不到匹配项，你将会得到一个编译错误。不管绑定了什么方法，最终的结果是绑定是由编译器完成的，并且绑定完全依赖于静态知道操作数的类型（在这种情况下是`d`）。这就是*静态绑定*。
- en: 'Now let’s change the static type of `d` to `object`:'
  id: totrans-2577
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将`d`的静态类型改为`object`：
- en: '[PRE633]'
  id: totrans-2578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE633]'
- en: 'Calling `Quack` gives us a compilation error because although the value stored
    in `d` can contain a method called `Quack`, the compiler cannot know it given
    that the only information it has is the type of the variable, which in this case
    is `object`. But let’s now change the static type of `d` to `dynamic`:'
  id: totrans-2579
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`Quack`会导致编译错误，因为尽管存储在`d`中的值可能包含名为`Quack`的方法，但编译器无法知道这一点，因为它仅仅知道变量的类型，而在这种情况下是`object`。但现在让我们将`d`的静态类型改为`dynamic`：
- en: '[PRE634]'
  id: totrans-2580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE634]'
- en: A `dynamic` type is like `object`—it’s equally nondescriptive about a type.
    The difference is that it lets you use it in ways that aren’t known at compile
    time. A dynamic object binds at runtime based on its runtime type, not its compile-time
    type. When the compiler sees a dynamically bound expression (which in general
    is an expression that contains any value of type `dynamic`), it merely packages
    up the expression such that the binding can be done later at runtime.
  id: totrans-2581
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynamic`类型就像`object`—它同样不描述类型。不同之处在于它允许你以编译时不知道的方式使用它。动态对象基于其运行时类型而不是编译时类型在运行时进行绑定。当编译器看到动态绑定表达式（通常是包含类型为`dynamic`的任何值的表达式），它只是打包表达式以便稍后在运行时进行绑定。'
- en: At runtime, if a dynamic object implements `IDynamicMeta​Ob⁠jectProvider`, that
    interface is used to perform the binding. If not, binding occurs in almost the
    same way as it would have had the compiler known the dynamic object’s runtime
    type. These two alternatives are called *custom binding* and *language binding*.
  id: totrans-2582
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，如果动态对象实现了`IDynamicMeta​Ob⁠jectProvider`，那么这个接口将被用来执行绑定。如果没有，绑定几乎与编译器知道动态对象的运行时类型时的方式相同。这两种选择被称为*自定义绑定*和*语言绑定*。
- en: Custom Binding
  id: totrans-2583
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义绑定
- en: 'Custom binding occurs when a dynamic object implements `IDynamicMetaObjectProvider`
    (IDMOP). Although you can implement IDMOP on types that you write in C#, and this
    is useful to do, the more common case is that you have acquired an IDMOP object
    from a dynamic language that is implemented in .NET on the Dynamic Language Runtime
    (DLR), such as IronPython or IronRuby. Objects from those languages implicitly
    implement IDMOP as a means to directly control the meanings of operations performed
    on them. Here’s a simple example:'
  id: totrans-2584
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义绑定发生在一个动态对象实现了`IDynamicMetaObjectProvider`（IDMOP）时。虽然你可以在你用C#编写的类型上实现IDMOP，并且这样做很有用，但更常见的情况是你从在.NET上实现的动态语言（如IronPython或IronRuby）中获得了一个IDMOP对象。这些语言的对象隐式地实现了IDMOP，作为直接控制在它们上执行的操作意义的一种手段。这里有一个简单的例子：
- en: '[PRE635]'
  id: totrans-2585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE635]'
- en: The `Duck` class doesn’t actually have a `Quack` method. Instead, it uses custom
    binding to intercept and interpret all method calls. We discuss custom binders
    in detail in *C# 12 in a Nutshell*.
  id: totrans-2586
  prefs: []
  type: TYPE_NORMAL
  zh: '`Duck`类实际上没有`Quack`方法。相反，它使用自定义绑定来拦截和解释所有方法调用。我们在*C# 12 in a Nutshell*中详细讨论了自定义绑定器。'
- en: Language Binding
  id: totrans-2587
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语言绑定
- en: 'Language binding occurs when a dynamic object does not implement `IDynamicMetaObjectProvider`.
    Language binding is useful when you are working around imperfectly designed types
    or inherent limitations in the .NET type system. For example, the built-in numeric
    types are imperfect in that they have no common interface. We have seen that methods
    can be bound dynamically; the same is true for operators:'
  id: totrans-2588
  prefs: []
  type: TYPE_NORMAL
  zh: 语言绑定发生在一个动态对象没有实现`IDynamicMetaObjectProvider`时。语言绑定在你处理.NET类型系统中的不完美设计类型或固有限制时非常有用。例如，内置的数值类型不完美，因为它们没有共同的接口。我们已经看到方法可以动态绑定；对于运算符也是如此：
- en: '[PRE636]'
  id: totrans-2589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE636]'
- en: The benefit is obvious—you don’t need to duplicate code for each numeric type.
    However, you lose static type safety, risking runtime exceptions rather than compile-time
    errors.
  id: totrans-2590
  prefs: []
  type: TYPE_NORMAL
  zh: 这带来的好处很明显——您不需要为每种数字类型重复编写代码。但是，您失去了静态类型安全性，冒着运行时异常的风险，而不是编译时错误。
- en: Note
  id: totrans-2591
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Dynamic binding circumvents static type safety but not runtime type safety.
    Unlike with reflection, you cannot circumvent member accessibility rules with
    dynamic binding.
  id: totrans-2592
  prefs: []
  type: TYPE_NORMAL
  zh: 动态绑定规避了静态类型安全性，但没有规避运行时类型安全性。与反射不同，您不能通过动态绑定规避成员可访问性规则。
- en: By design, language runtime binding behaves as similarly as possible to static
    binding, had the runtime types of the dynamic objects been known at compile time.
    In the previous example, the behavior of our program would be identical if we
    hardcoded `Mean` to work with the `int` type. The most notable exception in parity
    between static and dynamic binding is for extension methods, which we discuss
    in [“Uncallable Functions”](#uncallable_functions).
  id: totrans-2593
  prefs: []
  type: TYPE_NORMAL
  zh: 设计上，语言运行时绑定的行为尽可能类似于静态绑定，如果动态对象的运行时类型在编译时已知，则程序行为与硬编码 `Mean` 以适配 `int` 类型的行为相同。静态绑定和动态绑定之间在一致性方面最显著的例外是扩展方法，我们在[“不可调用函数”](#uncallable_functions)中讨论了此问题。
- en: Note
  id: totrans-2594
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Dynamic binding also incurs a performance hit. Because of the DLR’s caching
    mechanisms, however, repeated calls to the same dynamic expression are optimized,
    allowing you to efficiently call dynamic expressions in a loop. This optimization
    brings the typical overhead for a simple dynamic expression on today’s hardware
    down to less than 100 ns.
  id: totrans-2595
  prefs: []
  type: TYPE_NORMAL
  zh: 动态绑定也会带来性能损失。但由于DLR的缓存机制，对相同动态表达式的重复调用进行了优化，允许您在循环中高效地调用动态表达式。这种优化使得在当今硬件上进行简单动态表达式的典型开销降低到少于100
    ns。
- en: RuntimeBinderException
  id: totrans-2596
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RuntimeBinderException
- en: 'If a member fails to bind, a `RuntimeBinderException` is thrown. You can think
    of this as a compile-time error at runtime:'
  id: totrans-2597
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成员绑定失败，将抛出 `RuntimeBinderException`。您可以将其视为运行时的编译时错误：
- en: '[PRE637]'
  id: totrans-2598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE637]'
- en: The exception is thrown because the `int` type has no `Hello` method.
  id: totrans-2599
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出异常是因为 `int` 类型没有 `Hello` 方法。
- en: Runtime Representation of dynamic
  id: totrans-2600
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态的运行时表示
- en: 'There is a deep equivalence between the `dynamic` and `object` types. The runtime
    treats the following expression as `true`:'
  id: totrans-2601
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynamic` 与 `object` 类型之间存在深刻的等价性。运行时将以下表达式视为 `true`：'
- en: '[PRE638]'
  id: totrans-2602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE638]'
- en: 'This principle extends to constructed types and array types:'
  id: totrans-2603
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则适用于构造类型和数组类型：
- en: '[PRE639]'
  id: totrans-2604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE639]'
- en: 'Like an object reference, a dynamic reference can point to an object of any
    type (except pointer types):'
  id: totrans-2605
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于对象引用，动态引用可以指向任何类型的对象（除指针类型外）：
- en: '[PRE640]'
  id: totrans-2606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE640]'
- en: 'Structurally, there is no difference between an object reference and a dynamic
    reference. A dynamic reference simply enables dynamic operations on the object
    it points to. You can convert from `object` to `dynamic` to perform any dynamic
    operation you want on an `object`:'
  id: totrans-2607
  prefs: []
  type: TYPE_NORMAL
  zh: 结构上，对象引用和动态引用没有区别。动态引用简单地允许对其指向的对象进行动态操作。您可以从 `object` 转换为 `dynamic`，以在 `object`
    上执行任何动态操作。
- en: '[PRE641]'
  id: totrans-2608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE641]'
- en: Dynamic Conversions
  id: totrans-2609
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态转换
- en: The `dynamic` type has implicit conversions to and from all other types. For
    a conversion to succeed, the runtime type of the dynamic object must be implicitly
    convertible to the target static type.
  id: totrans-2610
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynamic` 类型与所有其他类型都有隐式转换。为了成功转换，动态对象的运行时类型必须隐式可转换为目标静态类型。'
- en: 'The following example throws a `RuntimeBinderException` because an `int` is
    not implicitly convertible to a `short`:'
  id: totrans-2611
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例抛出 `RuntimeBinderException`，因为 `int` 不能隐式转换为 `short`：
- en: '[PRE642]'
  id: totrans-2612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE642]'
- en: var Versus dynamic
  id: totrans-2613
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`var` 与 `dynamic` 的区别很深。`var` 让 *编译器* 推断类型。'
- en: 'The `var` and `dynamic` types bear a superficial resemblance, but the difference
    is deep:'
  id: totrans-2614
  prefs: []
  type: TYPE_NORMAL
  zh: '`var` 和 `dynamic` 类型在外表上相似，但其内在差异深远：'
- en: '`var` says, “Let the *compiler* figure out the type.”'
  id: totrans-2615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var` 表示，“让 *编译器* 推断类型。”'
- en: '`dynamic` says, “Let the *runtime* figure out the type.”'
  id: totrans-2616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dynamic` 表示，“让 *运行时* 确定类型。”'
- en: 'To illustrate:'
  id: totrans-2617
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子：
- en: '[PRE643]'
  id: totrans-2618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE643]'
- en: Dynamic Expressions
  id: totrans-2619
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态表达式
- en: Fields, properties, methods, events, constructors, indexers, operators, and
    conversions can all be called dynamically.
  id: totrans-2620
  prefs: []
  type: TYPE_NORMAL
  zh: 字段、属性、方法、事件、构造函数、索引器、操作符和转换都可以动态调用。
- en: Trying to consume the result of a dynamic expression with a `void` return type
    is prohibited—just as with a statically typed expression. The difference is that
    the error occurs at runtime.
  id: totrans-2621
  prefs: []
  type: TYPE_NORMAL
  zh: 禁止使用 `void` 返回类型来消耗动态表达式的结果，就像使用静态类型表达式一样。不同之处在于错误发生在运行时。
- en: 'Expressions involving dynamic operands are typically themselves dynamic, since
    the effect of absent type information is cascading:'
  id: totrans-2622
  prefs: []
  type: TYPE_NORMAL
  zh: 通常涉及动态操作数的表达式本身也是动态的，因为缺少类型信息的影响是级联的：
- en: '[PRE644]'
  id: totrans-2623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE644]'
- en: There are a couple of obvious exceptions to this rule. First, casting a dynamic
    expression to a static type yields a static expression. Second, constructor invocations
    always yield static expressions—even when called with dynamic arguments.
  id: totrans-2624
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则有几个明显的例外。首先，将动态表达式强制转换为静态类型会产生静态表达式。其次，构造函数调用始终产生静态表达式——即使使用动态参数调用时也是如此。
- en: In addition, there are a few edge cases for which an expression containing a
    dynamic argument is static, including passing an index to an array and delegate
    creation expressions.
  id: totrans-2625
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些边缘情况，在这些情况下，包含动态参数的表达式是静态的，包括将索引传递给数组和委托创建表达式。
- en: Dynamic Member Overload Resolution
  id: totrans-2626
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态成员重载解析
- en: 'The canonical use case for `dynamic` involves a dynamic *receiver*. This means
    that a dynamic object is the receiver of a dynamic function call:'
  id: totrans-2627
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dynamic`的经典用例涉及动态*接收器*。这意味着动态对象是动态函数调用的接收器：
- en: '[PRE645]'
  id: totrans-2628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE645]'
- en: 'However, dynamic binding is not limited to receivers: the method arguments
    are also eligible for dynamic binding. The effect of calling a function with dynamic
    arguments is to defer overload resolution from compile time to runtime:'
  id: totrans-2629
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，动态绑定不限于接收器：方法参数也适用于动态绑定。使用动态参数调用函数的效果是将重载解析从编译时推迟到运行时：
- en: '[PRE646]'
  id: totrans-2630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE646]'
- en: Runtime overload resolution is also called *multiple dispatch* and is useful
    in implementing design patterns such as *visitor*.
  id: totrans-2631
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时重载解析也称为*多分派*，在实现*访问者*等设计模式中非常有用。
- en: 'If a dynamic receiver is not involved, the compiler can statically perform
    a basic check to see whether the dynamic call will succeed: it checks that a function
    with the right name and number of parameters exists. If no candidate is found,
    you get a compile-time error.'
  id: totrans-2632
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有涉及动态接收器，编译器可以静态地执行基本检查，以查看动态调用是否会成功：它检查是否存在一个名称和参数数目正确的函数。如果找不到候选项，则会得到编译时错误。
- en: 'If a function is called with a mixture of dynamic and static arguments, the
    final choice of method will reflect a mixture of dynamic and static binding decisions:'
  id: totrans-2633
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数被调用时使用了动态和静态参数的混合方式，最终的方法选择将反映动态和静态绑定决策的混合：
- en: '[PRE647]'
  id: totrans-2634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE647]'
- en: The call to `X(o,d)` is dynamically bound because one of its arguments, `d`,
    is `dynamic`. But because `o` is statically known, the binding—even though it
    occurs dynamically—will make use of that. In this case, overload resolution will
    pick the second implementation of `X` due to the static type of `o` and the runtime
    type of `d`. In other words, the compiler is “as static as it can possibly be.”
  id: totrans-2635
  prefs: []
  type: TYPE_NORMAL
  zh: 对`X(o,d)`的调用是动态绑定的，因为它的一个参数`d`是`dynamic`类型。但因为`o`是静态已知的，尽管绑定是动态发生的，它将利用静态类型。在这种情况下，重载解析将由于`o`的静态类型和`d`的运行时类型而选择`X`的第二个实现。换句话说，编译器“尽可能静态”。
- en: Uncallable Functions
  id: totrans-2636
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可调用的函数
- en: 'Some functions cannot be called dynamically. You cannot call the following:'
  id: totrans-2637
  prefs: []
  type: TYPE_NORMAL
  zh: 有些函数无法动态调用。以下情况下不能调用：
- en: Extension methods (via extension method syntax)
  id: totrans-2638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展方法（通过扩展方法语法）
- en: Any member of an interface (via the interface)
  id: totrans-2639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过接口的任何成员（通过接口）
- en: Base members hidden by a subclass
  id: totrans-2640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类隐藏的基类成员
- en: 'This is because dynamic binding requires two pieces of information: the name
    of the function to call, and the object upon which to call the function. However,
    in each of the three uncallable scenarios, an *additional type* is involved, which
    is known only at compile time. And there is no way to specify these additional
    types dynamically.'
  id: totrans-2641
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为动态绑定需要两个信息：要调用的函数的名称，以及要在其上调用函数的对象。然而，在这三种不可调用的情况中，涉及到一个*额外类型*，这种类型只有在编译时才知道。并且没有办法动态指定这些额外的类型。
- en: 'When you are calling extension methods, that additional type is an extension
    class, chosen implicitly by virtue of `using` directives in your source code (which
    disappear after compilation). When calling members via an interface, you communicate
    the additional type via an implicit or explicit cast. (With explicit implementation,
    it’s in fact impossible to call a member without casting to the interface.) A
    similar situation arises when you are calling a hidden base member: you must specify
    an additional type via either a cast or the `base` keyword—and that additional
    type is lost at runtime.'
  id: totrans-2642
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用扩展方法时，这个额外的类型是一个扩展类，根据源代码中的`using`指令（编译后消失）隐式选择。当通过接口调用成员时，可以通过隐式或显式转换来传递这个额外类型。（对于显式实现来说，实际上无法在不进行接口转换的情况下调用成员。）当调用隐藏基类成员时，必须通过转换或`base`关键字来指定额外的类型——并且该额外类型在运行时丢失。
- en: Operator Overloading
  id: totrans-2643
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符重载
- en: You can overload operators to provide more natural syntax for custom types.
    Operator overloading is most appropriately used for implementing custom structs
    that represent fairly primitive data types. For example, a custom numeric type
    is an excellent candidate for operator overloading.
  id: totrans-2644
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以重载运算符以为自定义类型提供更自然的语法。运算符重载最适合用于实现代表相当原始数据类型的自定义结构体。例如，自定义数值类型非常适合运算符重载。
- en: 'You can overload the following symbolic operators:'
  id: totrans-2645
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以重载以下符号运算符：
- en: '[PRE648]'
  id: totrans-2646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE648]'
- en: You can override implicit and explicit conversions (with the `implicit` and
    `explicit` keywords), as you can the `true` and `false` operators.
  id: totrans-2647
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以重写隐式和显式转换（使用`implicit`和`explicit`关键字），以及`true`和`false`运算符。
- en: The compound assignment operators (e.g., `+=`, `/=`) are automatically overridden
    when you override the noncompound operators (e.g., `+`, `/`).
  id: totrans-2648
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重载非复合运算符（例如`+`，`/`）时，复合赋值运算符（例如`+=`，`/=`）会自动被重载。
- en: Operator Functions
  id: totrans-2649
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运算符函数
- en: To overload an operator, you declare an *operator function*. An operator function
    must be static, and at least one of the operands must be the type in which the
    operator function is declared.
  id: totrans-2650
  prefs: []
  type: TYPE_NORMAL
  zh: 要重载运算符，你需要声明一个*运算符函数*。运算符函数必须是静态的，并且其中至少一个操作数必须是声明运算符函数的类型。
- en: 'In the following example, we define a struct called `Note`, representing a
    musical note, and then overload the `+` operator:'
  id: totrans-2651
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们定义了一个名为`Note`的结构体，代表一个音符，并重载了`+`运算符：
- en: '[PRE649]'
  id: totrans-2652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE649]'
- en: 'This overload allows us to add an `int` to a `Note`:'
  id: totrans-2653
  prefs: []
  type: TYPE_NORMAL
  zh: 此重载允许我们将一个`int`加到一个`Note`上：
- en: '[PRE650]'
  id: totrans-2654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE650]'
- en: 'Because we overrode `+`, we can use `+=` too:'
  id: totrans-2655
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们重载了`+`，所以我们也可以使用`+=`：
- en: '[PRE651]'
  id: totrans-2656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE651]'
- en: 'From C# 11, you can also declare a `checked` version that will be called inside
    checked expressions or blocks. These are called *checked operators*:'
  id: totrans-2657
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 11 开始，你也可以声明一个`checked`版本，它将在检查表达式或块内调用。这被称为*checked运算符*：
- en: '[PRE652]'
  id: totrans-2658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE652]'
- en: Overloading Equality and Comparison Operators
  id: totrans-2659
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重载相等性和比较运算符
- en: 'Equality and comparison operators are often overridden when writing structs,
    and in rare cases with classes. Special rules and obligations apply when overloading
    these operators:'
  id: totrans-2660
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写结构体时，经常会重写相等性和比较运算符，在类中则很少见。当重载这些运算符时，会应用特殊的规则和义务：
- en: Pairing
  id: totrans-2661
  prefs: []
  type: TYPE_NORMAL
  zh: 配对
- en: The C# compiler enforces that operators that are logical pairs are both defined.
    These operators are (`== !=`), (`< >`), and (`<= >=`).
  id: totrans-2662
  prefs: []
  type: TYPE_NORMAL
  zh: C# 编译器强制要求逻辑对的运算符都要定义。这些运算符包括(`== !=`)，(`< >`)以及(`<= >=`)。
- en: '`Equals` and `GetHashCode`'
  id: totrans-2663
  prefs: []
  type: TYPE_NORMAL
  zh: '`Equals`和`GetHashCode`'
- en: If you overload `==` and `!=`, you will usually need to override `object`’s
    `Equals` and `GetHashCode` methods so that collections and hashtables will work
    reliably with the type.
  id: totrans-2664
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重载了`==`和`!=`，通常需要重写`object`的`Equals`和`GetHashCode`方法，以便类型可以可靠地与集合和哈希表一起工作。
- en: '`IComparable` and `IComparable<T>`'
  id: totrans-2665
  prefs: []
  type: TYPE_NORMAL
  zh: '`IComparable`和`IComparable<T>`'
- en: If you overload `<` and `>`, you would also typically implement `IComparable`
    and `IComparable<T>`.
  id: totrans-2666
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重载了`<`和`>`，通常还需要实现`IComparable`和`IComparable<T>`。
- en: 'Extending the previous example, here’s how you could overload `Note`’s equality
    operators:'
  id: totrans-2667
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展前面的示例，这是如何重载`Note`的相等运算符的方法：
- en: '[PRE653]'
  id: totrans-2668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE653]'
- en: Custom Implicit and Explicit Conversions
  id: totrans-2669
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义隐式和显式转换
- en: Implicit and explicit conversions are overloadable operators. These conversions
    are typically overloaded to make converting between strongly related types (such
    as numeric types) concise and natural.
  id: totrans-2670
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式和显式转换是可重载的运算符。通常通过重载这些转换来使得在强关联类型（如数值类型）之间转换更加简洁和自然。
- en: As explained in the discussion on types, the rationale behind implicit conversions
    is that they should always succeed and not lose information during conversion.
    Otherwise, explicit conversions should be defined.
  id: totrans-2671
  prefs: []
  type: TYPE_NORMAL
  zh: 正如类型讨论中所解释的，隐式转换的理念在于它们应始终成功，并且在转换过程中不丢失信息。否则，应定义显式转换。
- en: 'In the following example, we define conversions between our musical `Note`
    type and a `double` (which represents the frequency in hertz of that note):'
  id: totrans-2672
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们定义了我们的音乐`Note`类型和`double`之间的转换（表示该音符的频率以赫兹为单位）：
- en: '[PRE654]'
  id: totrans-2673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE654]'
- en: Note
  id: totrans-2674
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'This example is somewhat contrived: in real life, these conversions might be
    better implemented with a `ToFrequency` method and a (static) `FromFrequency`
    method.'
  id: totrans-2675
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例有些假设性：在实际应用中，这些转换可能更适合通过`ToFrequency`方法和（静态）`FromFrequency`方法来实现。
- en: Custom conversions are ignored by the `as` and `is` operators.
  id: totrans-2676
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义转换被`as`和`is`运算符忽略。
- en: Attributes
  id: totrans-2677
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特性
- en: You’re already familiar with the notion of attributing code elements of a program
    with modifiers, such as `virtual` or `ref`. These constructs are built into the
    language. *Attributes* are an extensible mechanism for adding custom information
    to code elements (assemblies, types, members, return values, and parameters).
    This extensibility is useful for services that integrate deeply into the type
    system, without requiring special keywords or constructs in the C# language.
  id: totrans-2678
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经熟悉了使用修饰符（如 `virtual` 或 `ref`）为程序的代码元素添加属性的概念。这些构造已内置于语言中。*属性*是一种可扩展的机制，用于向代码元素（程序集、类型、成员、返回值和参数）添加自定义信息。此可扩展性对于深度集成到类型系统中而无需特殊关键字或构造的服务非常有用。
- en: Attribute Classes
  id: totrans-2679
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性类
- en: 'An attribute is defined by a class that inherits (directly or indirectly) from
    the abstract class `System.Attribute`. To attach an attribute to a code element,
    specify the attribute’s type name in square brackets, before the code element.
    For example, the following attaches `ObsoleteAttribute` to the `Foo` class:'
  id: totrans-2680
  prefs: []
  type: TYPE_NORMAL
  zh: 属性由从抽象类 `System.Attribute` 直接或间接继承的类定义。要将属性附加到代码元素，请在代码元素之前的方括号中指定属性的类型名称。例如，以下示例将
    `ObsoleteAttribute` 附加到 `Foo` 类：
- en: '[PRE655]'
  id: totrans-2681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE655]'
- en: 'This particular attribute is recognized by the compiler and will cause compiler
    warnings if a type or member marked obsolete is referenced. By convention, all
    attribute types end with the word *Attribute*. C# recognizes this and allows you
    to omit the suffix when attaching an attribute:'
  id: totrans-2682
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器识别此特定属性，并且如果引用了标记为过时的类型或成员，则会导致编译器警告。按照惯例，所有属性类型的名称以 *Attribute* 结尾。C# 识别此规则，并允许您在附加属性时省略后缀：
- en: '[PRE656]'
  id: totrans-2683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE656]'
- en: '`ObsoleteAttribute` is a type declared in the `System` namespace as follows
    (simplified for brevity):'
  id: totrans-2684
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObsoleteAttribute` 是在 `System` 命名空间中声明的类型，如下所示（为简洁起见已简化）：'
- en: '[PRE657]'
  id: totrans-2685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE657]'
- en: Named and Positional Attribute Parameters
  id: totrans-2686
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名和位置属性参数
- en: 'Attributes can have parameters. In the following example, we apply `XmlElementAttribute`
    to a class. This attribute instructs `XmlSerializer` (in `System.Xml.Serialization`)
    how an object is represented in XML and accepts several *attribute parameters*.
    The following attribute maps the `CustomerEntity` class to an XML element named
    `Customer`, belonging to the `http://oreilly.com` namespace:'
  id: totrans-2687
  prefs: []
  type: TYPE_NORMAL
  zh: 属性可以具有参数。在以下示例中，我们将 `XmlElementAttribute` 应用于一个类。此属性指示 `XmlSerializer`（位于 `System.Xml.Serialization`
    中）如何在 XML 中表示对象，并接受几个*属性参数*。以下属性将 `CustomerEntity` 类映射到名为 `Customer` 的 XML 元素，属于
    `http://oreilly.com` 命名空间：
- en: '[PRE658]'
  id: totrans-2688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE658]'
- en: 'Attribute parameters fall into one of two categories: positional or named.
    In the preceding example, the first argument is a *positional parameter*; the
    second is a *named parameter*. Positional parameters correspond to parameters
    of the attribute type’s public constructors. Named parameters correspond to public
    fields or public properties on the attribute type.'
  id: totrans-2689
  prefs: []
  type: TYPE_NORMAL
  zh: 属性参数分为两类：位置参数或命名参数。在上述示例中，第一个参数是*位置参数*；第二个是*命名参数*。位置参数对应于属性类型的公共构造函数的参数。命名参数对应于属性类型的公共字段或公共属性。
- en: When specifying an attribute, you must include positional parameters that correspond
    to one of the attribute’s constructors. Named parameters are optional.
  id: totrans-2690
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定属性时，必须包含对应于属性构造函数之一的位置参数。命名参数是可选的。
- en: Attribute Targets
  id: totrans-2691
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性目标
- en: 'Implicitly, the target of an attribute is the code element it immediately precedes,
    which is typically a type or type member. You can also attach attributes, however,
    to an assembly. This requires that you explicitly specify the attribute’s target.
    Here’s an example of using the `CLSCompliant` attribute to specify Common Language
    Specification (CLS) compliance for an entire assembly:'
  id: totrans-2692
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式地，属性的目标是它所紧随的代码元素，通常是类型或类型成员。但是，您也可以将属性附加到程序集。这要求您明确指定属性的目标。以下是使用 `CLSCompliant`
    属性指定整个程序集的公共语言规范（CLS）兼容性的示例：
- en: '[PRE659]'
  id: totrans-2693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE659]'
- en: 'From C# 10, you can apply attributes to the method, parameters, and return
    value of a lambda expression:'
  id: totrans-2694
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 10 开始，您可以将属性应用于 lambda 表达式的方法、参数和返回值：
- en: '[PRE660]'
  id: totrans-2695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE660]'
- en: Specifying Multiple Attributes
  id: totrans-2696
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定多个属性
- en: 'You can specify multiple attributes for a single code element. You can list
    each attribute either within the same pair of square brackets (separated by a
    comma) or in separate pairs of square brackets (or a combination of the two).
    The following two examples are semantically identical:'
  id: totrans-2697
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为单个代码元素指定多个属性。您可以在同一对方括号中列出每个属性（用逗号分隔），也可以分别在不同的方括号对中列出（或两者结合）。以下两个示例在语义上是相同的：
- en: '[PRE661]'
  id: totrans-2698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE661]'
- en: Writing Custom Attributes
  id: totrans-2699
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写自定义属性
- en: 'You can define your own attributes by subclassing `Sys⁠tem​.Attribute`. For
    example, you could use the following custom attribute for flagging a method for
    unit testing:'
  id: totrans-2700
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过子类化`System.Attribute`来定义自己的属性。例如，您可以使用以下自定义属性来标记用于单元测试的方法：
- en: '[PRE662]'
  id: totrans-2701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE662]'
- en: 'Here’s how you could apply the attribute:'
  id: totrans-2702
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何应用该属性的示例：
- en: '[PRE663]'
  id: totrans-2703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE663]'
- en: '`AttributeUsage` is itself an attribute that indicates the construct (or combination
    of constructs) to which the custom attribute can be applied. The `AttributeTargets`
    enum includes such members as `Class`, `Method`, `Parameter`, and `Constructor`
    (as well as `All`, which combines all targets).'
  id: totrans-2704
  prefs: []
  type: TYPE_NORMAL
  zh: '`AttributeUsage` 本身就是一个属性，指示可以应用自定义属性的结构（或结构组合）。 `AttributeTargets` 枚举包括`Class`、`Method`、`Parameter`和`Constructor`（以及`All`，它结合了所有目标）等成员。'
- en: Retrieving Attributes at Runtime
  id: totrans-2705
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在运行时检索属性
- en: 'There are two standard ways to retrieve attributes at runtime:'
  id: totrans-2706
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时检索属性的两种标准方法：
- en: Call `GetCustomAttributes` on any `Type` or `MemberInfo` object
  id: totrans-2707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何`Type`或`MemberInfo`对象上调用`GetCustomAttributes`
- en: Call `Attribute.GetCustomAttribute` or `Attribute.Get​Cus⁠tomAttributes`
  id: totrans-2708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`Attribute.GetCustomAttribute`或`Attribute.GetCustomAttributes`
- en: These latter two methods are overloaded to accept any reflection object that
    corresponds to a valid attribute target (`Type`, `Assembly`, `Module`, `MemberInfo`,
    or `ParameterInfo`).
  id: totrans-2709
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个后续方法都已重载，以接受与有效属性目标（`Type`、`Assembly`、`Module`、`MemberInfo`或`ParameterInfo`）对应的任何反射对象。
- en: 'Here’s how we can enumerate each method in the preceding `Foo` class that has
    a `TestAttribute`:'
  id: totrans-2710
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何枚举前述`Foo`类中具有`TestAttribute`的每个方法：
- en: '[PRE664]'
  id: totrans-2711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE664]'
- en: 'Here’s the output:'
  id: totrans-2712
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出：
- en: '[PRE665]'
  id: totrans-2713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE665]'
- en: Caller Info Attributes
  id: totrans-2714
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用者信息属性
- en: 'You can tag optional parameters with one of three *caller info attributes*,
    which instruct the compiler to feed information obtained from the caller’s source
    code into the parameter’s default value:'
  id: totrans-2715
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用三种*调用者信息属性*之一来标记可选参数，这些属性指示编译器将来自调用方源代码的信息传递到参数的默认值中：
- en: '`[CallerMemberName]` applies the caller’s member name.'
  id: totrans-2716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[CallerMemberName]` 应用于调用方的成员名称。'
- en: '`[CallerFilePath]` applies the path to the caller’s source code file.'
  id: totrans-2717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[CallerFilePath]` 应用于调用方的源代码文件路径。'
- en: '`[CallerLineNumber]` applies the line number in the caller’s source code file.'
  id: totrans-2718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[CallerLineNumber]` 应用于调用方的源代码文件中的行号。'
- en: 'The `Foo` method in the following program demonstrates all three:'
  id: totrans-2719
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的程序中的`Foo`方法演示了所有三种方法：
- en: '[PRE666]'
  id: totrans-2720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE666]'
- en: 'Assuming that our program resides in *c:\source\test\Program.cs*, the output
    would be:'
  id: totrans-2721
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的程序位于*c:\source\test\Program.cs*，则输出将是：
- en: '[PRE667]'
  id: totrans-2722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE667]'
- en: 'As with standard optional parameters, the substitution is done at the *calling
    site*. Hence, our `Main` method is syntactic sugar for this:'
  id: totrans-2723
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准可选参数一样，替换是在*调用点*完成的。因此，我们的`Main`方法对于此是语法糖：
- en: '[PRE668]'
  id: totrans-2724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE668]'
- en: 'Caller info attributes are useful for writing logging functions and for implementing
    change notification patterns. For instance, we can call a method such as the following
    from within a property’s `set` accessor—without having to specify the property’s
    name:'
  id: totrans-2725
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者信息属性对编写日志函数和实现更改通知模式非常有用。例如，我们可以在属性的`set`访问器中调用以下方法，而无需指定属性的名称：
- en: '[PRE669]'
  id: totrans-2726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE669]'
- en: CallerArgumentExpression
  id: totrans-2727
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CallerArgumentExpression
- en: 'A method parameter to which you apply the `[CallerArgumentExpression]` attribute
    captures an argument expression from the call site:'
  id: totrans-2728
  prefs: []
  type: TYPE_NORMAL
  zh: 将`[CallerArgumentExpression]`属性应用于方法参数，以捕获调用点的参数表达式：
- en: '[PRE670]'
  id: totrans-2729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE670]'
- en: 'The main application for this feature is when writing validation and assertion
    libraries. In the following example, an exception is thrown, whose message includes
    the text “2 + 2 == 5.” This aids in debugging:'
  id: totrans-2730
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能的主要应用程序是在编写验证和断言库时。在以下示例中，抛出异常，其消息包含文本“2 + 2 == 5”。这有助于调试：
- en: '[PRE671]'
  id: totrans-2731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE671]'
- en: You can use `[CallerArgumentExpression]` multiple times in order to capture
    multiple argument expressions.
  id: totrans-2732
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以多次使用`[CallerArgumentExpression]`以捕获多个参数表达式。
- en: Asynchronous Functions
  id: totrans-2733
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步函数
- en: The `await` and `async` keywords support *asynchronous programming*, a style
    of programming in which long-running functions do most or all of their work *after*
    returning to the caller. This is in contrast to normal *synchronous* programming,
    in which long-running functions *block* the caller until the operation is complete.
    Asynchronous programming implies *concurrency* because the long-running operation
    continues *in parallel* to the caller. The implementer of an asynchronous function
    initiates this concurrency either through multithreading (for compute-bound operations)
    or via a callback mechanism (for I/O-bound operations).
  id: totrans-2734
  prefs: []
  type: TYPE_NORMAL
  zh: '`await` 和 `async` 关键字支持 *异步编程*，这是一种编程风格，长时间运行的函数在返回给调用者后继续完成大部分或全部工作。这与正常的
    *同步* 编程相反，长时间运行的函数会 *阻塞* 调用者直到操作完成。异步编程意味着 *并发*，因为长时间运行的操作在调用者的同时 *并行* 运行。异步函数的实现者通过多线程（用于计算绑定的操作）或通过回调机制（用于
    I/O 绑定的操作）启动这种并发。'
- en: Note
  id: totrans-2735
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Multithreading, concurrency, and asynchronous programming are large topics.
    We dedicate two chapters to them in *C# 12 in a Nutshell* and discuss them online
    at [*http://albahari.com/threading*](http://albahari.com/threading).
  id: totrans-2736
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程、并发和异步编程是一个广泛的话题。我们在 *C# 12 in a Nutshell* 中专门为它们分配了两章，并在线上讨论它们，网址是 [*http://albahari.com/threading*](http://albahari.com/threading)。
- en: 'For instance, consider the following *synchronous* method, which is long-running
    and compute-bound:'
  id: totrans-2737
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下长时间运行且计算绑定的 *同步* 方法：
- en: '[PRE672]'
  id: totrans-2738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE672]'
- en: 'This method blocks the caller for a few seconds while it runs, before returning
    the result of the calculation to the caller:'
  id: totrans-2739
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法在运行时会阻塞调用者几秒钟，然后将计算结果返回给调用者：
- en: '[PRE673]'
  id: totrans-2740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE673]'
- en: 'The CLR defines a class called `Task<TResult>` (in `System.Threading.Tasks`)
    to encapsulate the concept of an operation that completes in the future. You can
    generate a `Task<TResult>` for a compute-bound operation by calling `Task.Run`,
    which instructs the CLR to run the specified delegate on a separate thread that
    executes in parallel to the caller:'
  id: totrans-2741
  prefs: []
  type: TYPE_NORMAL
  zh: CLR 定义了一个称为 `Task<TResult>`（在 `System.Threading.Tasks` 中）的类来封装未来完成的操作概念。通过调用
    `Task.Run`，你可以为计算绑定的操作生成一个 `Task<TResult>`，该方法指示 CLR 在一个单独的线程上执行指定的委托，并与调用者并行执行：
- en: '[PRE674]'
  id: totrans-2742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE674]'
- en: 'This method is *asynchronous* because it returns immediately to the caller
    while it executes concurrently. However, we need some mechanism to allow the caller
    to specify what should happen when the operation finishes and the result becomes
    available. `Task<TResult>` solves this by exposing a `GetAwaiter` method that
    lets the caller attach a *continuation*:'
  id: totrans-2743
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法是 *异步* 的，因为它立即返回给调用者，同时并发执行。然而，我们需要一些机制来允许调用者指定在操作完成并且结果变得可用时应该发生什么。`Task<TResult>`
    通过公开 `GetAwaiter` 方法来解决这个问题，该方法允许调用者附加一个 *延续*：
- en: '[PRE675]'
  id: totrans-2744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE675]'
- en: This says to the operation, “When you finish, execute the specified delegate.”
    Our continuation first calls `GetResult`, which returns the result of the calculation.
    (Or, if the task *faulted*—threw an exception—calling `GetResult` rethrows that
    exception.) Our continuation then writes out the result via `Console.WriteLine`.
  id: totrans-2745
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉操作：“当你完成时，执行指定的委托。” 我们的延续首先调用 `GetResult`，它返回计算的结果。（或者，如果任务 *失败* —— 抛出异常
    —— 调用 `GetResult` 会重新抛出异常。）然后我们的延续通过 `Console.WriteLine` 输出结果。
- en: The await and async Keywords
  id: totrans-2746
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`await` 和 `async` 关键字'
- en: 'The `await` keyword simplifies the attaching of continuations. Starting with
    a basic scenario, consider the following:'
  id: totrans-2747
  prefs: []
  type: TYPE_NORMAL
  zh: '`await` 关键字简化了连接延续的操作。从一个基本场景开始考虑以下情况：'
- en: '[PRE676]'
  id: totrans-2748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE676]'
- en: 'The compiler expands this into something functionally similar to the following:'
  id: totrans-2749
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将这个展开为与以下功能类似的内容：
- en: '[PRE677]'
  id: totrans-2750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE677]'
- en: Note
  id: totrans-2751
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The compiler also emits code to optimize the scenario of the operation completing
    synchronously (immediately). A common reason for an asynchronous operation completing
    immediately is if it implements an internal caching mechanism and the result is
    already cached.
  id: totrans-2752
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器还会生成代码来优化操作立即完成（同步完成）的场景。异步操作立即完成的常见原因是它实现了内部缓存机制并且结果已经被缓存。
- en: 'Hence, we can call the `ComplexCalculationAsync` method we defined previously,
    like this:'
  id: totrans-2753
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以像这样调用我们之前定义的 `ComplexCalculationAsync` 方法：
- en: '[PRE678]'
  id: totrans-2754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE678]'
- en: 'To compile, we need to add the `async` modifier to the containing method:'
  id: totrans-2755
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译，我们需要在包含方法上添加 `async` 修饰符：
- en: '[PRE679]'
  id: totrans-2756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE679]'
- en: The `async` modifier instructs the compiler to treat `await` as a keyword rather
    than an identifier should an ambiguity arise within that method (this ensures
    that code written prior to C# 5.0 that might use `await` as an identifier will
    still compile without error). The `async` modifier can be applied only to methods
    (and lambda expressions) that return `void` or (as you’ll see later) a `Task`
    or `Task<TResult>`.
  id: totrans-2757
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 修饰符指示编译器将 `await` 视为关键字，而不是标识符，以防在方法内出现歧义（这确保了在 C# 5.0 之前可能使用 `await`
    作为标识符的代码仍能正常编译）。`async` 修饰符仅适用于返回 `void` 或（稍后您将看到的）`Task` 或 `Task<TResult>` 的方法（和
    lambda 表达式）。'
- en: Note
  id: totrans-2758
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `async` modifier is similar to the `unsafe` modifier in that it has no effect
    on a method’s signature or public metadata; it affects only what happens *within*
    the method.
  id: totrans-2759
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 修饰符与 `unsafe` 修饰符类似，它不会影响方法的签名或公共元数据；它只影响方法**内部**发生的事情。'
- en: Methods with the `async` modifier are called *asynchronous functions* because
    they themselves are typically asynchronous. To see why, let’s look at how execution
    proceeds through an asynchronous function.
  id: totrans-2760
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 `async` 修饰符的方法被称为*异步函数*，因为它们本身通常是异步的。要了解原因，请看异步函数如何通过执行过程。
- en: Upon encountering an `await` expression, execution (normally) returns to the
    caller—rather like with `yield return` in an iterator. But before returning, the
    runtime attaches a continuation to the awaited task, ensuring that when the task
    completes, execution jumps back into the method and continues where it left off.
    If the task faults, its exception is rethrown (by virtue of calling `GetResult`);
    otherwise, its return value is assigned to the `await` expression.
  id: totrans-2761
  prefs: []
  type: TYPE_NORMAL
  zh: 遇到 `await` 表达式时，执行（通常）会返回给调用者——类似于迭代器中的 `yield return`。但在返回之前，运行时会将一个继续操作附加到等待的任务上，确保任务完成时，执行会跳回到方法中，并继续之前的位置。如果任务出现故障，则会重新抛出其异常（通过调用
    `GetResult` 方法）；否则，其返回值将分配给 `await` 表达式。
- en: Note
  id: totrans-2762
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The CLR’s implementation of a task awaiter’s `OnCompleted` method ensures that
    by default, continuations are posted through the current *synchronization context*,
    if one is present. In practice, this means that in rich-client UI scenarios (WPF,
    WinUI, and Windows Forms), if you `await` on a UI thread, your code will continue
    on that same thread. This simplifies thread safety.
  id: totrans-2763
  prefs: []
  type: TYPE_NORMAL
  zh: CLR 对任务等待器的 `OnCompleted` 方法的实现默认确保，如果有当前的 *同步上下文*，则会通过它发布继续操作。实际上，这意味着在富客户端
    UI 场景（如 WPF、WinUI 和 Windows Forms）中，如果在 UI 线程上进行 `await`，您的代码将继续在同一线程上执行。这简化了线程安全性。
- en: The expression upon which you `await` is typically a task; however, any object
    with a `GetAwaiter` method that returns an *awaitable object*—implementing `INotifyCompletion.On​Com⁠pleted`
    and with an appropriately typed `GetResult` method (and a `bool IsCompleted` property
    that tests for synchronous completion)—will satisfy the compiler.
  id: totrans-2764
  prefs: []
  type: TYPE_NORMAL
  zh: 您 `await` 的表达式通常是一个任务；然而，任何具有返回一个 *可等待对象* 的 `GetAwaiter` 方法的对象——实现了 `INotifyCompletion.On​Com⁠pleted`
    和具有适当类型的 `GetResult` 方法（以及测试同步完成的 `bool IsCompleted` 属性）——都将满足编译器的要求。
- en: Notice that our `await` expression evaluates to an `int` type; this is because
    the expression that we awaited was a `Task<int>` (whose `GetAwaiter().GetResult()`
    method returns an `int`).
  id: totrans-2765
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们的 `await` 表达式评估为 `int` 类型；这是因为我们等待的表达式是一个 `Task<int>`（其 `GetAwaiter().GetResult()`
    方法返回一个 `int`）。
- en: 'Awaiting a nongeneric task is legal and generates a void expression:'
  id: totrans-2766
  prefs: []
  type: TYPE_NORMAL
  zh: 等待非泛型任务是合法的，并生成一个 `void` 表达式：
- en: '[PRE680]'
  id: totrans-2767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE680]'
- en: '`Task.Delay` is a static method that returns a `Task` that completes in the
    specified number of milliseconds. The *synchronous* equivalent of `Task.Delay`
    is `Thread.Sleep`.'
  id: totrans-2768
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task.Delay` 是一个返回在指定毫秒数后完成的 `Task` 的静态方法。`Task.Delay` 的*同步*等效方法是 `Thread.Sleep`。'
- en: '`Task` is the nongeneric base class of `Task<TResult>` and is functionally
    equivalent to `Task<TResult>` except that it has no result.'
  id: totrans-2769
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task` 是 `Task<TResult>` 的非泛型基类，并且在功能上等效于 `Task<TResult>`，除了它没有结果。'
- en: Capturing Local State
  id: totrans-2770
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获局部状态
- en: The real power of `await` expressions is that they can appear almost anywhere
    in code. Specifically, an `await` expression can appear in place of any expression
    (within an asynchronous function) except for within a `lock` statement or `unsafe`
    context.
  id: totrans-2771
  prefs: []
  type: TYPE_NORMAL
  zh: '`await` 表达式真正的威力在于它们几乎可以出现在代码的任何地方。具体而言，在异步函数中，`await` 表达式可以出现在除了 `lock` 语句或
    `unsafe` 上下文之外的任何表达式的位置。'
- en: 'In the following example, we `await` within a loop:'
  id: totrans-2772
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们在循环中使用了 `await`：
- en: '[PRE681]'
  id: totrans-2773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE681]'
- en: Upon first executing `ComplexCalculationAsync`, execution returns to the caller
    by virtue of the `await` expression. When the method completes (or faults), execution
    resumes where it left off, with the values of local variables and loop counters
    preserved. The compiler achieves this by translating such code into a state machine,
    like it does with iterators.
  id: totrans-2774
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次执行`ComplexCalculationAsync`时，由于`await`表达式，执行返回给调用者。当方法完成（或故障）时，执行会在离开时保持本地变量和循环计数器的值不变。编译器通过将这样的代码转换为状态机来实现这一点，就像它在迭代器中所做的那样。
- en: Without the `await` keyword, the manual use of continuations means that you
    must write something equivalent to a state machine. This is traditionally what
    makes asynchronous programming difficult.
  id: totrans-2775
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有`await`关键字，手动使用延续意味着你必须编写等效于状态机的代码。这通常是异步编程困难的根源。
- en: Writing Asynchronous Functions
  id: totrans-2776
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写异步函数
- en: 'With any asynchronous function, you can replace the `void` return type with
    a `Task` to make the method itself *usefully* asynchronous (and `await`able).
    No further changes are required:'
  id: totrans-2777
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何异步函数，可以将`void`返回类型替换为`Task`，使方法本身变得有用地异步（并且可`await`）。不需要进一步的更改：
- en: '[PRE682]'
  id: totrans-2778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE682]'
- en: 'Notice that we don’t explicitly return a task in the method body. The compiler
    manufactures the task, which it signals upon completion of the method (or upon
    an unhandled exception). This makes it easy to create asynchronous call chains:'
  id: totrans-2779
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在方法体中没有显式返回任务。编译器会创建任务，并在方法完成时（或未处理异常时）发出信号。这使得创建异步调用链变得容易：
- en: '[PRE683]'
  id: totrans-2780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE683]'
- en: (And because `Go` returns a `Task`, `Go` itself is `await`able.) The compiler
    expands asynchronous functions that return tasks into code that (indirectly) uses
    `TaskCompletionSource` to create a task that it then signals or faults.
  id: totrans-2781
  prefs: []
  type: TYPE_NORMAL
  zh: （因为`Go`返回一个`Task`，所以`Go`本身是可以`await`的。）编译器将返回任务的异步函数展开为使用`TaskCompletionSource`间接创建任务的代码。
- en: Note
  id: totrans-2782
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`TaskCompletionSource` is a CLR type that lets you create tasks that you manually
    control, signaling them as complete with a result (or as faulted with an exception).
    Unlike `Task.Run`, `TaskCompletionSource` doesn’t tie up a thread for the duration
    of the operation. It’s also used for writing I/O-bound task-returning methods
    (such as `Task.Delay`).'
  id: totrans-2783
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskCompletionSource`是一个CLR类型，允许你创建可以手动控制的任务，并使用结果（或异常）标记其完成。与`Task.Run`不同，`TaskCompletionSource`不会在操作期间阻塞线程。它还用于编写I/O绑定的任务返回方法（例如`Task.Delay`）。'
- en: The aim is to ensure that when a task-returning asynchronous method finishes,
    execution can jump back to whoever awaited it, via a continuation.
  id: totrans-2784
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是确保当返回任务的异步方法完成时，执行可以通过延续跳回到等待它的地方。
- en: Returning Task<TResult>
  id: totrans-2785
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回`Task<TResult>`
- en: 'You can return a `Task<TResult>` if the method body returns `TResult`:'
  id: totrans-2786
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法体返回`TResult`，可以返回一个`Task<TResult>`：
- en: '[PRE684]'
  id: totrans-2787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE684]'
- en: 'We can demonstrate `GetAnswerToLife` by calling it from `Prin⁠t​AnswerToLife`
    (which is, in turn, called from `Go`):'
  id: totrans-2788
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过从`Go`中调用`PrintAnswerToLife`来演示`GetAnswerToLife`：
- en: '[PRE685]'
  id: totrans-2789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE685]'
- en: 'Asynchronous functions make asynchronous programming similar to synchronous
    programming. Here’s the synchronous equivalent of our call graph, for which calling
    `Go()` gives the same result after blocking for five seconds:'
  id: totrans-2790
  prefs: []
  type: TYPE_NORMAL
  zh: 异步函数使异步编程类似于同步编程。以下是我们调用图的同步等效版本，调用`Go()`会在阻塞五秒后给出相同的结果：
- en: '[PRE686]'
  id: totrans-2791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE686]'
- en: This also illustrates the basic principle of how to design with asynchronous
    functions in C#, which is to write your methods synchronously and then replace
    *synchronous* method calls with *asynchronous* method calls that you `await`.
  id: totrans-2792
  prefs: []
  type: TYPE_NORMAL
  zh: 这也展示了如何在C#中设计异步函数的基本原则，即先以同步方式编写方法，然后将同步方法调用替换为`await`的异步方法调用。
- en: Parallelism
  id: totrans-2793
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行性
- en: We’ve just demonstrated the most common pattern, which is to `await` task-returning
    functions immediately after calling them. This results in sequential program flow
    that’s logically similar to the synchronous equivalent.
  id: totrans-2794
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚演示了最常见的模式，即在调用后立即`await`返回任务的函数。这导致了逻辑上类似于同步等效的顺序程序流。
- en: 'Calling an asynchronous method without awaiting it allows the code that follows
    to execute in parallel. For example, the following executes `PrintAnswerToLife`
    twice, concurrently:'
  id: totrans-2795
  prefs: []
  type: TYPE_NORMAL
  zh: 调用异步方法而不等待它允许随后的代码并行执行。例如，以下代码并发执行`PrintAnswerToLife`两次：
- en: '[PRE687]'
  id: totrans-2796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE687]'
- en: 'By awaiting both operations afterward, we “end” the parallelism at that point
    (and rethrow any exceptions from those tasks). The `Task` class provides a static
    method called `WhenAll` to achieve the same result slightly more efficiently.
    `WhenAll` returns a task that completes when all of the tasks that you pass to
    it complete:'
  id: totrans-2797
  prefs: []
  type: TYPE_NORMAL
  zh: 在之后等待这两个操作，我们在那一点上“结束”了并行性（并重新抛出这些任务的任何异常）。 `Task` 类提供了一个名为 `WhenAll` 的静态方法，以稍微更有效地实现相同的结果。
    `WhenAll` 返回一个任务，在你传递给它的所有任务完成时完成：
- en: '[PRE688]'
  id: totrans-2798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE688]'
- en: '`WhenAll` is called a *task combinator*. (The `Task` class also provides a
    task combinator called `WhenAny`, which completes when *any* of the tasks provided
    to it complete.) We cover the task combinators in detail in *C# 12 in a Nutshell*.'
  id: totrans-2799
  prefs: []
  type: TYPE_NORMAL
  zh: '`WhenAll` 被称为一个*任务组合器*。（`Task` 类还提供了一个任务组合器称为 `WhenAny`，它在提供给它的任何任务完成时完成。）我们在*C#
    12 in a Nutshell*中详细介绍任务组合器。'
- en: Asynchronous Lambda Expressions
  id: totrans-2800
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步 Lambda 表达式
- en: 'We know that ordinary *named* methods can be asynchronous:'
  id: totrans-2801
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道普通的*命名*方法可以是异步的：
- en: '[PRE689]'
  id: totrans-2802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE689]'
- en: 'So, too, can *unnamed* methods (lambda expressions and anonymous methods),
    if preceded by the `async` keyword:'
  id: totrans-2803
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，*未命名*方法（lambda 表达式和匿名方法），如果前面加上 `async` 关键字，也可以是异步的：
- en: '[PRE690]'
  id: totrans-2804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE690]'
- en: 'You can call and await these in the same way:'
  id: totrans-2805
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以相同的方式调用和等待它们：
- en: '[PRE691]'
  id: totrans-2806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE691]'
- en: 'You can use asynchronous lambda expressions when attaching event handlers:'
  id: totrans-2807
  prefs: []
  type: TYPE_NORMAL
  zh: 当附加事件处理程序时，你可以使用异步 lambda 表达式：
- en: '[PRE692]'
  id: totrans-2808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE692]'
- en: 'This is more succinct than the following, which has the same effect:'
  id: totrans-2809
  prefs: []
  type: TYPE_NORMAL
  zh: 这比以下的更简洁，但效果相同：
- en: '[PRE693]'
  id: totrans-2810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE693]'
- en: 'Asynchronous lambda expressions can also return `Task​<TRe⁠sult>`:'
  id: totrans-2811
  prefs: []
  type: TYPE_NORMAL
  zh: 异步 lambda 表达式也可以返回 `Task​<TRe⁠sult>`：
- en: '[PRE694]'
  id: totrans-2812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE694]'
- en: Asynchronous Streams
  id: totrans-2813
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步流
- en: 'With `yield return`, you can write an iterator; with `await`, you can write
    an asynchronous function. *Asynchronous streams* (from C# 8) combine these concepts
    and let you write an iterator that awaits, yielding elements asynchronously. This
    support builds on the following pair of interfaces, which are asynchronous counterparts
    to the enumeration interfaces we described in [“Enumeration and Iterators”](#enumeration_and_iterators):'
  id: totrans-2814
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `yield return`，你可以编写一个迭代器；使用 `await`，你可以编写一个异步函数。*异步流*（来自 C# 8）结合了这些概念，让你能够编写一个等待的迭代器，异步地生成元素。此支持建立在以下一对接口的基础上，它们是我们在[“枚举和迭代器”](#enumeration_and_iterators)中描述的枚举接口的异步对应物：
- en: '[PRE695]'
  id: totrans-2815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE695]'
- en: '`ValueTask<T>` is a struct that wraps `Task<T>` and is behaviorally equivalent
    to `Task<T>`, except that it enables more efficient execution when the task completes
    synchronously (which can happen often when enumerating a sequence). `IAsyncDisposable`
    is an asynchronous version of `IDisposable` and provides an opportunity to perform
    cleanup should you choose to manually implement the interfaces:'
  id: totrans-2816
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValueTask<T>` 是包装 `Task<T>` 的结构体，行为上等效于 `Task<T>`，除了当任务同步完成时能够实现更高效的执行（这在枚举序列时经常发生）。
    `IAsyncDisposable` 是 `IDisposable` 的异步版本，提供了在手动实现接口时执行清理操作的机会：'
- en: '[PRE696]'
  id: totrans-2817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE696]'
- en: Note
  id: totrans-2818
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The act of fetching each element from the sequence (`MoveNextAsync`) is an
    asynchronous operation, so asynchronous streams are suitable when elements arrive
    in a piecemeal fashion (such as when processing data from a video stream). In
    contrast, the following type is more suitable when the sequence *as a whole* is
    delayed, but the elements, when they arrive, arrive all together:'
  id: totrans-2819
  prefs: []
  type: TYPE_NORMAL
  zh: 从序列获取每个元素的操作 (`MoveNextAsync`) 是一个异步操作，因此当元素逐个到达时，异步流非常合适（例如处理来自视频流的数据）。相比之下，以下类型在序列*整体*延迟时更为合适，但元素到达时却是一次性到达：
- en: '[PRE697]'
  id: totrans-2820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE697]'
- en: 'To generate an asynchronous stream, you write a method that combines the principles
    of iterators and asynchronous methods. In other words, your method should include
    both `yield return` and `await`, and it should return `IAsyncEnumerable<T>`:'
  id: totrans-2821
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成一个异步流，你需要编写一个结合了迭代器和异步方法原理的方法。换句话说，你的方法应该包括 `yield return` 和 `await`，并且应该返回
    `IAsyncEnumerable<T>`：
- en: '[PRE698]'
  id: totrans-2822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE698]'
- en: 'To consume an asynchronous stream, use the `await foreach` statement:'
  id: totrans-2823
  prefs: []
  type: TYPE_NORMAL
  zh: 要消费一个异步流，请使用 `await foreach` 语句：
- en: '[PRE699]'
  id: totrans-2824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE699]'
- en: Static Polymorphism
  id: totrans-2825
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态多态
- en: In [“Static virtual/abstract interface members”](#static_virtualsolidusabstract_interface),
    we introduced an advanced feature whereby an interface can define `static virtual`
    or `static abstract` members, which are then implemented as static members by
    classes and structs. Later, in [“Generic Constraints”](#generic_constraints),
    we showed that applying an interface constraint to a type parameter gives a method
    access to that interface’s members. In this section, we’ll demonstrate how this
    enables *static polymorphism*, allowing for features such as generic math.
  id: totrans-2826
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“静态虚拟/抽象接口成员”](#static_virtualsolidusabstract_interface)中，我们介绍了一个高级功能，即接口可以定义`static
    virtual`或`static abstract`成员，然后由类和结构体作为静态成员来实现。稍后，在[“泛型约束”](#generic_constraints)中，我们展示了将接口约束应用于类型参数使方法可以访问该接口成员的方式。在本节中，我们将演示如何通过这种方式实现*静态多态*，从而实现泛型数学功能。
- en: 'To illustrate, consider the following interface, which defines a static method
    to create a random instance of some type `T`:'
  id: totrans-2827
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，考虑以下接口，它定义了一个静态方法来创建某种类型`T`的随机实例：
- en: '[PRE700]'
  id: totrans-2828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE700]'
- en: 'Suppose now that we wish to implement this interface in the following record:'
  id: totrans-2829
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们希望在以下记录中实现此接口：
- en: '[PRE701]'
  id: totrans-2830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE701]'
- en: 'With the help of the `System.Random` class (whose `Next` method generates a
    random integer), we can implement the static `Crea⁠te​Random` method as follows:'
  id: totrans-2831
  prefs: []
  type: TYPE_NORMAL
  zh: 在`System.Random`类的帮助下（其`Next`方法生成随机整数），我们可以实现静态的`CreateRandom`方法如下：
- en: '[PRE702]'
  id: totrans-2832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE702]'
- en: 'To call this method via the interface, we use a *constrained type parameter*.
    The following method creates an array of test data using this approach:'
  id: totrans-2833
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过接口调用此方法，我们使用*受限类型参数*。以下方法使用这种方法创建测试数据的数组：
- en: '[PRE703]'
  id: totrans-2834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE703]'
- en: 'This line of code demonstrates its use:'
  id: totrans-2835
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码行展示了其使用方式：
- en: '[PRE704]'
  id: totrans-2836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE704]'
- en: Our call to the static `CreateRandom` method in `CreateTestData` is *polymorphic*
    because it works not just with `Point` but with any type that implements `ICreateRandom<T>`.
    This is different from *instance* polymorphism, because we don’t need an *instance*
    of `ICreateRandom<T>` on which to call `CreateRandom`; we call `CreateRandom`
    on the type itself.
  id: totrans-2837
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CreateTestData`中对静态`CreateRandom`方法的调用是*多态的*，因为它不仅适用于`Point`，还适用于任何实现`ICreateRandom<T>`的类型。这与*实例*多态不同，因为我们不需要在其上调用`CreateRandom`的`ICreateRandom<T>`的实例；我们在类型本身上调用`CreateRandom`。
- en: Polymorphic Operators
  id: totrans-2838
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态操作符
- en: 'Because operators are essentially static functions (see [“Operator Overloading”](#operator_overloading)),
    operators can also be declared as static virtual interface members:'
  id: totrans-2839
  prefs: []
  type: TYPE_NORMAL
  zh: 因为操作符本质上是静态函数（参见[“运算符重载”](#operator_overloading)），所以操作符也可以声明为静态虚拟接口成员：
- en: '[PRE705]'
  id: totrans-2840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE705]'
- en: Note
  id: totrans-2841
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The *self-referencing* type constraint in this interface definition is necessary
    to satisfy the compiler’s rules for operator overloading. Recall that when defining
    an operator function, at least one of the operands must be the type in which the
    operator function is declared. In this example, our operands are of type `T`,
    whereas the containing type is `IAddable<T>`, so we require a self-referencing
    type constraint to allow `T` to be treated as `IAddable<T>`.
  id: totrans-2842
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个接口定义中的*自引用*类型约束是为了满足编译器对运算符重载的规则。回顾一下，当定义运算符函数时，操作数至少有一个必须是声明该运算符函数的类型。在这个例子中，我们的操作数是类型为`T`，而包含类型是`IAddable<T>`，因此我们需要一个自引用类型约束来允许将`T`视为`IAddable<T>`。
- en: 'Here’s how we can implement the interface:'
  id: totrans-2843
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何实现接口的方法：
- en: '[PRE706]'
  id: totrans-2844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE706]'
- en: 'With a constrained type parameter, we can then write a method that calls our
    addition operator polymorphically (with edge-case handling omitted for brevity):'
  id: totrans-2845
  prefs: []
  type: TYPE_NORMAL
  zh: 通过受限类型参数，我们可以编写一个方法，以多态方式调用我们的加法运算符（为了简洁起见，省略了边缘情况处理）：
- en: '[PRE707]'
  id: totrans-2846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE707]'
- en: Our call to the `+` operator (via the `+=` operator) is polymorphic because
    it binds to `IAddable<T>`, not `Point`. Hence, our `Sum` method works with all
    types that implement `IAddable<T>`.
  id: totrans-2847
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`+`运算符的调用（通过`+=`运算符）是多态的，因为它绑定到`IAddable<T>`，而不是`Point`。因此，我们的`Sum`方法适用于所有实现`IAddable<T>`的类型。
- en: 'Of course, an interface such as `IAddable<T>` would be much more useful if
    it were defined in the .NET runtime, and if all .NET numeric types implemented
    it. Fortunately, this is indeed the case from .NET 7: the `System.Numerics` namespace
    includes (a more sophisticated version of) `IAddable`, along with many other arithmetic
    interfaces—most of which are encompassed by `INumber<TSelf>`.'
  id: totrans-2848
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，像`IAddable<T>`这样的接口如果在.NET运行时中定义，并且所有.NET数值类型都实现了它，那将会更加有用。幸运的是，从.NET 7开始，`System.Numerics`命名空间包含了（更复杂版本的）`IAddable`，以及许多其他算术接口——大部分都包含在`INumber<TSelf>`中。
- en: Generic Math
  id: totrans-2849
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型数学
- en: 'Before .NET 7, code that performed arithmetic had to be hardcoded to a particular
    numeric type such as `int` or `double`. From .NET 7, the `INumber<TSelf>` interface
    was added to unify arithmetic operations across numeric types, allowing generic
    methods such as the following to be written:'
  id: totrans-2850
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 7 之前，执行算术运算的代码必须硬编码为特定的数字类型，例如`int`或`double`。从 .NET 7 开始，新增了`INumber<TSelf>`接口，统一了各种数字类型的算术操作，允许编写如下泛型方法：
- en: '[PRE708]'
  id: totrans-2851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE708]'
- en: '`INumber<TSelf>` is implemented by all real and integral numeric types in .NET
    (as well as `char`). It can be thought of as an umbrella interface, comprising
    other more granular interfaces for each kind of arithmetic operation (addition,
    subtraction, multiplication, division, modulus calculation, comparison, and so
    on), as well as interfaces for parsing and formatting. These interfaces define
    static abstract operators and methods—which allow the `+=` operator (and the call
    to `T.Zero`) to work inside our `Sum` method.'
  id: totrans-2852
  prefs: []
  type: TYPE_NORMAL
  zh: '`INumber<TSelf>` 被 .NET 中所有的实数和整数数字类型（以及`char`）实现。它可以被视为一个总称接口，包括了其他更细粒度的接口，用于每种算术操作（加法、减法、乘法、除法、取模运算、比较等），以及用于解析和格式化的接口。这些接口定义了静态抽象运算符和方法——这些允许在我们的`Sum`方法中使用`+=`运算符（和对`T.Zero`的调用）。'
- en: Unsafe Code and Pointers
  id: totrans-2853
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不安全代码和指针
- en: C# supports direct memory manipulation via pointers within blocks of code marked
    as `unsafe`. Pointer types are useful for interoperating with native APIs, for
    accessing memory outside the managed heap, and in implementing micro-optimizations
    in performance-critical hotspots.
  id: totrans-2854
  prefs: []
  type: TYPE_NORMAL
  zh: C# 支持在标记为`unsafe`的代码块内通过指针进行直接内存操作。指针类型对于与本机 API 进行交互、访问托管堆之外的内存以及在性能关键的热点中实现微优化非常有用。
- en: Projects that include unsafe code must specify `<AllowUnsafeBlocks>true</AllowUnsafeBlocks>`
    in the project file.
  id: totrans-2855
  prefs: []
  type: TYPE_NORMAL
  zh: 包含不安全代码的项目必须在项目文件中指定`<AllowUnsafeBlocks>true</AllowUnsafeBlocks>`。
- en: Pointer Basics
  id: totrans-2856
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针基础知识
- en: 'For every value type or reference type *V*, there is a corresponding pointer
    type *V**. A pointer instance holds the address of a variable. Pointer types can
    be (unsafely) cast to any other pointer type. Following are the main pointer operators:'
  id: totrans-2857
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种值类型或引用类型*V*，都有相应的指针类型*V**。指针实例保存变量的地址。指针类型可以（不安全地）转换为任何其他指针类型。以下是主要的指针运算符：
- en: '| Operator | Meaning |'
  id: totrans-2858
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 含义 |'
- en: '| --- | --- |'
  id: totrans-2859
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `&` | The *address-of* operator returns a pointer to the address of a variable.
    |'
  id: totrans-2860
  prefs: []
  type: TYPE_TB
  zh: '| `&` | *取地址*运算符返回指向变量地址的指针。 |'
- en: '| `*` | The *dereference* operator returns the variable at the address of a
    pointer. |'
  id: totrans-2861
  prefs: []
  type: TYPE_TB
  zh: '| `*` | *解引用*运算符返回指针地址处的变量。 |'
- en: '| `->` | The *pointer-to-member* operator is a syntactic shortcut, in which
    `x->y` is equivalent to `(*x).y`. |'
  id: totrans-2862
  prefs: []
  type: TYPE_TB
  zh: '| `->` | *成员指针*运算符是一种语法快捷方式，其中`x->y`等同于`(*x).y`。 |'
- en: Unsafe Code
  id: totrans-2863
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不安全代码
- en: 'By marking a type, type member, or statement block with the `unsafe` keyword,
    you’re permitted to use pointer types and perform C++-style pointer operations
    on memory within that scope. Here is an example of using pointers to quickly process
    a bitmap:'
  id: totrans-2864
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`unsafe`关键字标记类型、类型成员或语句块，您被允许在该作用域内使用指针类型，并执行 C++ 风格的指针操作。以下是使用指针快速处理位图的示例：
- en: '[PRE709]'
  id: totrans-2865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE709]'
- en: Unsafe code can run faster than a corresponding safe implementation. In this
    case, the code would have required a nested loop with array indexing and bounds
    checking. An unsafe C# method can also be faster than calling an external C function
    because there is no overhead associated with leaving the managed execution environment.
  id: totrans-2866
  prefs: []
  type: TYPE_NORMAL
  zh: 不安全代码可能比相应的安全实现运行更快。在这种情况下，代码需要具有带有数组索引和边界检查的嵌套循环。不安全的 C# 方法也可能比调用外部 C 函数更快，因为没有离开托管执行环境的开销。
- en: The fixed Statement
  id: totrans-2867
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: fixed 语句
- en: The `fixed` statement is required to pin a managed object such as the bitmap
    in the previous example. During the execution of a program, many objects are allocated
    and deallocated from the heap. To avoid unnecessary waste or fragmentation of
    memory, the garbage collector moves objects around. Pointing to an object is futile
    if its address could change while referencing it, so the `fixed` statement instructs
    the garbage collector to “pin” the object and not move it around. This can have
    an impact on the efficiency of the runtime, so you should use fixed blocks only
    briefly, and you should avoid heap allocation within the fixed block.
  id: totrans-2868
  prefs: []
  type: TYPE_NORMAL
  zh: '`fixed`语句用于固定管理对象，例如前面示例中的位图。在程序执行期间，许多对象从堆中分配和释放。为了避免内存的不必要浪费或碎片化，垃圾回收器会移动对象。如果在引用时对象的地址可能会更改，则指向对象是徒劳的，因此`fixed`语句指示垃圾回收器“固定”对象并防止其移动。这可能会影响运行时的效率，因此您应该仅在短时间内使用固定块，并避免在固定块内分配堆内存。'
- en: Within a `fixed` statement, you can get a pointer to a value type, an array
    of value types, or a string. In the case of arrays and strings, the pointer will
    actually point to the first element, which is a value type.
  id: totrans-2869
  prefs: []
  type: TYPE_NORMAL
  zh: 在`fixed`语句中，您可以获取值类型、值类型数组或字符串的指针。对于数组和字符串，指针实际上将指向第一个元素，该元素是值类型。
- en: 'Value types declared inline within reference types require the reference type
    to be pinned, as follows:'
  id: totrans-2870
  prefs: []
  type: TYPE_NORMAL
  zh: 在引用类型内部声明的值类型需要引用类型被固定，如下所示：
- en: '[PRE710]'
  id: totrans-2871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE710]'
- en: The Pointer-to-Member Operator
  id: totrans-2872
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成员指针运算符
- en: 'In addition to the `&` and `*` operators, C# also provides the C++-style `->`
    operator, which you can use on structs:'
  id: totrans-2873
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`&`和`*`运算符外，C#还提供了C++风格的`->`运算符，您可以在结构体上使用它：
- en: '[PRE711]'
  id: totrans-2874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE711]'
- en: The stackalloc Keyword
  id: totrans-2875
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`stackalloc`关键字'
- en: 'You can allocate memory in a block on the stack explicitly with the `stackalloc`
    keyword. Because it is allocated on the stack, its lifetime is limited to the
    execution of the method, just as with any other local variable. The block can
    use the `[]` operator to index into memory:'
  id: totrans-2876
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`stackalloc`关键字显式在堆栈上分配内存块。因为它是在堆栈上分配的，所以它的生存期仅限于方法的执行，就像任何其他局部变量一样。该块可以使用`[]`运算符索引到内存中：
- en: '[PRE712]'
  id: totrans-2877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE712]'
- en: Fixed-Size Buffers
  id: totrans-2878
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 固定大小的缓冲区
- en: 'To allocate a block of memory within a struct, use the `fixed` keyword:'
  id: totrans-2879
  prefs: []
  type: TYPE_NORMAL
  zh: 要在结构体中分配一块内存块，请使用`fixed`关键字：
- en: '[PRE713]'
  id: totrans-2880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE713]'
- en: 'Fixed-size buffers are not arrays: if `Buffer` were an array, it would consist
    of a reference to an object stored on the (managed) heap, rather than 30 bytes
    within the struct itself.'
  id: totrans-2881
  prefs: []
  type: TYPE_NORMAL
  zh: 固定大小的缓冲区不是数组：如果`Buffer`是数组，它将由存储在结构体内部的对象引用组成，而不是结构体本身的30个字节。
- en: The `fixed` keyword is also used in this example to pin the object on the heap
    that contains the buffer (which will be the instance of `UnsafeClass`).
  id: totrans-2882
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中还使用了`fixed`关键字来固定包含缓冲区的堆上对象（这将是`UnsafeClass`的实例）。
- en: void*
  id: totrans-2883
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: void*
- en: 'A *void pointer* (`void*`) makes no assumptions about the type of the underlying
    data and is useful for functions that deal with raw memory. An implicit conversion
    exists from any pointer type to `void*`. A `void*` cannot be dereferenced, and
    arithmetic operations cannot be performed on void pointers. For example:'
  id: totrans-2884
  prefs: []
  type: TYPE_NORMAL
  zh: '*void指针*（`void*`）对底层数据类型不做任何假设，并且对处理原始内存的函数非常有用。任何指针类型都可以隐式转换为`void*`。`void*`无法被解引用，并且不能对void指针执行算术运算。例如：'
- en: '[PRE714]'
  id: totrans-2885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE714]'
- en: Function Pointers
  id: totrans-2886
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数指针
- en: A *function pointer* (from C# 9) is like a delegate but without the indirection
    of a delegate instance; instead, it points directly to a method. A function pointer
    points only to static methods, lacks multicast capability, and requires an `unsafe`
    context (because it bypasses runtime type safety). Its main purpose is to simplify
    and optimize interop with unmanaged APIs (we cover interop in *C# 12 in a Nutshell*).
  id: totrans-2887
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数指针*（来自C# 9）类似于委托，但没有委托实例的间接性；而是直接指向方法。函数指针仅指向静态方法，缺乏多播功能，并且需要`unsafe`上下文（因为它绕过运行时类型安全性）。其主要目的是简化和优化与不受管API的互操作（我们在*C#
    12 in a Nutshell*中介绍了互操作）。'
- en: 'A function pointer type is declared as follows (with the return type appearing
    last):'
  id: totrans-2888
  prefs: []
  type: TYPE_NORMAL
  zh: 函数指针类型声明如下（返回类型最后出现）：
- en: '[PRE715]'
  id: totrans-2889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE715]'
- en: 'This matches a function with this signature:'
  id: totrans-2890
  prefs: []
  type: TYPE_NORMAL
  zh: 这与具有此签名的函数匹配：
- en: '[PRE716]'
  id: totrans-2891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE716]'
- en: 'The `&` operator creates a function pointer from a method group. Here’s a complete
    example:'
  id: totrans-2892
  prefs: []
  type: TYPE_NORMAL
  zh: '`&`运算符从方法组创建函数指针。这里有一个完整的示例：'
- en: '[PRE717]'
  id: totrans-2893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE717]'
- en: 'In this example, `functionPointer` is not an *object* upon which you can call
    a method such as `Invoke` (or with a reference to a `Target` object). Instead,
    it’s a variable that points directly to the target method’s address in memory:'
  id: totrans-2894
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`functionPointer` 不是您可以调用 `Invoke` 方法的 *对象*。而是一个直接指向目标方法内存地址的变量：
- en: '[PRE718]'
  id: totrans-2895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE718]'
- en: Preprocessor Directives
  id: totrans-2896
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预处理器指令
- en: 'Preprocessor directives supply the compiler with additional information about
    regions of code. The most common preprocessor directives are the conditional directives,
    which provide a way to include or exclude regions of code from compilation. For
    example:'
  id: totrans-2897
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理器指令为编译器提供关于代码区域的附加信息。最常见的预处理器指令是条件指令，提供了一种在编译时包含或排除代码区域的方式。例如：
- en: '[PRE719]'
  id: totrans-2898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE719]'
- en: In this class, the statement in `Foo` is compiled as conditionally dependent
    upon the presence of the `DEBUG` symbol. If we remove the `DEBUG` symbol, the
    statement is not compiled. Preprocessor symbols can be defined within a source
    file (as we have done), or within the `<DefineConstants>` element in a project
    file.
  id: totrans-2899
  prefs: []
  type: TYPE_NORMAL
  zh: 在此类中，`Foo` 中的语句在编译时条件依赖于 `DEBUG` 符号的存在。如果我们移除 `DEBUG` 符号，则不会编译该语句。预处理符号可以在源文件内（正如我们所做的）或在项目文件中的
    `<DefineConstants>` 元素内定义。
- en: 'With the `#if` and `#elif` directives, you can use the `||`, `&&`, and `!`
    operators to perform *or*, *and*, and *not* operations on multiple symbols. The
    following directive instructs the compiler to include the code that follows if
    the `TESTMODE` symbol is defined and the `DEBUG` symbol is not defined:'
  id: totrans-2900
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `#if` 和 `#elif` 指令，您可以在多个符号上执行 *或*、*与* 和 *非* 操作使用 `||`、`&&` 和 `!` 操作符。以下指令指示编译器在定义
    `TESTMODE` 符号且未定义 `DEBUG` 符号时包括随后的代码：
- en: '[PRE720]'
  id: totrans-2901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE720]'
- en: Keep in mind, however, that you’re not building an ordinary C# expression, and
    the symbols upon which you operate have absolutely no connection to *variables*—static
    or otherwise.
  id: totrans-2902
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您并非在构建普通的 C# 表达式，并且您操作的符号与 *变量* —— 无论是静态还是其他类型的 —— 没有任何连接。
- en: The `#error` and `#warning` symbols prevent accidental misuse of conditional
    directives by making the compiler generate a warning or error given an undesirable
    set of compilation symbols.
  id: totrans-2903
  prefs: []
  type: TYPE_NORMAL
  zh: '`#error` 和 `#warning` 符号通过使编译器生成警告或错误来防止条件指令的意外误用，给定一个不良的编译符号集。'
- en: '[Table 14](#preprocessor_directives) describes the complete list of preprocessor
    directives.'
  id: totrans-2904
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 14](#preprocessor_directives) 描述了预处理器指令的完整列表。'
- en: Table 14\. Preprocessor directives
  id: totrans-2905
  prefs: []
  type: TYPE_NORMAL
  zh: 表14\. 预处理器指令
- en: '| Preprocessor directive | Action |'
  id: totrans-2906
  prefs: []
  type: TYPE_TB
  zh: '| 预处理器指令 | 动作 |'
- en: '| --- | --- |'
  id: totrans-2907
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `` #define `*symbol*` `` | Defines `*symbol*`. |'
  id: totrans-2908
  prefs: []
  type: TYPE_TB
  zh: '| `` #define `*symbol*` `` | 定义 `*symbol*`。 |'
- en: '| `` #undef `*symbol*` `` | Undefines `*symbol*`. |'
  id: totrans-2909
  prefs: []
  type: TYPE_TB
  zh: '| `` #undef `*symbol*` `` | 取消定义 `*symbol*`。 |'
- en: '| `#if` `*symbol*` `[*operator symbol2*]...` | Conditional compilation (`*operator*`s
    are `==`, `!=`, `&&`, and `&#124;&#124;`). |'
  id: totrans-2910
  prefs: []
  type: TYPE_TB
  zh: '| `#if` `*symbol*` `[*operator symbol2*]...` | 条件编译 (`*operator*` 包括 `==`、`!=`、`&&`
    和 `||`)。 |'
- en: '| `#else` | Executes code to subsequent `#endif`. |'
  id: totrans-2911
  prefs: []
  type: TYPE_TB
  zh: '| `#else` | 执行到后续 `#endif` 的代码。 |'
- en: '| `#elif` `*symbol*` `[*operator symbol2*]` | Combines `#else` branch and `#if`
    test. |'
  id: totrans-2912
  prefs: []
  type: TYPE_TB
  zh: '| `#elif` `*symbol*` `[*operator symbol2*]` | 结合 `#else` 分支和 `#if` 测试。 |'
- en: '| `#endif` | Ends conditional directives. |'
  id: totrans-2913
  prefs: []
  type: TYPE_TB
  zh: '| `#endif` | 结束条件指令。 |'
- en: '| `` #warning `*text*` `` | `*text*` of the warning to appear in compiler output.
    |'
  id: totrans-2914
  prefs: []
  type: TYPE_TB
  zh: '| `` #warning `*text*` `` | `*text*` 的警告将出现在编译器输出中。 |'
- en: '| `` #error `*text*` `` | `*text*` of the error to appear in compiler output.
    |'
  id: totrans-2915
  prefs: []
  type: TYPE_TB
  zh: '| `` #error `*text*` `` | `*text*` 的错误将出现在编译器输出中。 |'
- en: '| ``#line [`*number*` ["`*file*`"] &#124; hidden]`` | `*number*` specifies
    the line in source code; `*file*` is the filename to appear in computer output;
    `hidden` instructs debuggers to skip over code from this point until the next
    `#line` directive. |'
  id: totrans-2916
  prefs: []
  type: TYPE_TB
  zh: '| ``#line [`*number*` ["`*file*`"] &#124; hidden]`` | `*number*` 指定源代码中的行；`*file*`
    是要出现在计算机输出中的文件名；`hidden` 指示调试器跳过此点到下一个 `#line` 指令。 |'
- en: '| `` #region `*name*` `` | Marks the beginning of an outline. |'
  id: totrans-2917
  prefs: []
  type: TYPE_TB
  zh: '| `` #region `*name*` `` | 标记大纲的开始。 |'
- en: '| `#endregion` | Ends an outline region. |'
  id: totrans-2918
  prefs: []
  type: TYPE_TB
  zh: '| `#endregion` | 结束大纲区域。 |'
- en: '| `#pragma warning` | See the next section. |'
  id: totrans-2919
  prefs: []
  type: TYPE_TB
  zh: '| `#pragma warning` | 参见下一节。 |'
- en: '| `` #nullable `*option*` `` | See [“Nullable Reference Types”](#nullable_reference_types).
    |'
  id: totrans-2920
  prefs: []
  type: TYPE_TB
  zh: '| `` #nullable `*option*` `` | 查看[“可空引用类型”](#nullable_reference_types)。 |'
- en: Pragma Warning
  id: totrans-2921
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pragma Warning
- en: The compiler generates a warning when it spots something in your code that seems
    unintentional. Unlike errors, warnings don’t ordinarily prevent your application
    from compiling.
  id: totrans-2922
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器发现您的代码中出现看似不经意的东西时，它会生成警告。与错误不同，警告通常不会阻止应用程序的编译。
- en: Compiler warnings can be extremely valuable in spotting bugs. Their usefulness,
    however, is undermined when you get *false* warnings. In a large application,
    maintaining a good signal-to-noise ratio is essential if the “real” warnings are
    to be noticed.
  id: totrans-2923
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器警告在发现错误时非常有价值。然而，当出现*虚假*警告时，它们的有效性会受到损害。在大型应用程序中，保持良好的信噪比对于注意到“真正”的警告至关重要。
- en: 'To this effect, the compiler allows you to selectively suppress warnings with
    the `#pragma warning` directive. In this example, we instruct the compiler not
    to warn us about the field `Message` not being used:'
  id: totrans-2924
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，编译器允许您使用`#pragma warning`指令有选择地禁止警告。在此示例中，我们指示编译器不要警告我们未使用的字段`Message`：
- en: '[PRE721]'
  id: totrans-2925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE721]'
- en: Omitting the number in the `#pragma warning` directive disables or restores
    all warning codes.
  id: totrans-2926
  prefs: []
  type: TYPE_NORMAL
  zh: 在`#pragma warning`指令中省略编号会禁用或恢复所有警告代码。
- en: If you are thorough in applying this directive, you can compile with the `/warnaserror`
    switch—this instructs the compiler to treat any residual warnings as errors.
  id: totrans-2927
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在应用此指令时彻底，可以使用`/warnaserror`开关进行编译——这指示编译器将任何剩余的警告视为错误。
- en: XML Documentation
  id: totrans-2928
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XML 文档
- en: 'A *documentation comment* is a piece of embedded XML that documents a type
    or member. A documentation comment comes immediately before a type or member declaration
    and starts with three slashes:'
  id: totrans-2929
  prefs: []
  type: TYPE_NORMAL
  zh: '*文档注释*是嵌入的 XML 片段，用于文档化类型或成员。文档注释紧接在类型或成员声明之前，并以三斜杠开始：'
- en: '[PRE722]'
  id: totrans-2930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE722]'
- en: 'Multiline comments can be done like this:'
  id: totrans-2931
  prefs: []
  type: TYPE_NORMAL
  zh: 可以这样编写多行注释：
- en: '[PRE723]'
  id: totrans-2932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE723]'
- en: 'Or like this (notice the extra star at the start):'
  id: totrans-2933
  prefs: []
  type: TYPE_NORMAL
  zh: 或者像这样（注意开头的额外星号）：
- en: '[PRE724]'
  id: totrans-2934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE724]'
- en: 'If you compile with the `/doc` directive (or enable XML documentation in the
    project file), the compiler extracts and collates documentation comments into
    a single XML file. This has two main uses:'
  id: totrans-2935
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`/doc`指令进行编译（或在项目文件中启用 XML 文档），编译器会提取并整理文档注释到一个单独的 XML 文件中。这有两个主要用途：
- en: If placed in the same folder as the compiled assembly, Visual Studio automatically
    reads the XML file and uses the information to provide IntelliSense member listings
    to consumers of the assembly of the same name.
  id: totrans-2936
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果放置在与编译后程序集相同的文件夹中，Visual Studio 会自动读取 XML 文件，并使用信息为同名程序集的消费者提供 IntelliSense
    成员列表。
- en: Third-party tools (such as Sandcastle and NDoc) can transform the XML file into
    an HTML help file.
  id: totrans-2937
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方工具（如 Sandcastle 和 NDoc）可以将 XML 文件转换为 HTML 帮助文件。
- en: Standard XML Documentation Tags
  id: totrans-2938
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准 XML 文档标签
- en: 'Here are the standard XML tags that Visual Studio and documentation generators
    recognize:'
  id: totrans-2939
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Visual Studio 和文档生成器识别的标准 XML 标签：
- en: '`<summary>`'
  id: totrans-2940
  prefs: []
  type: TYPE_NORMAL
  zh: '`<summary>`'
- en: '[PRE725]'
  id: totrans-2941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE725]'
- en: Indicates the tool tip that IntelliSense should display for the type or member.
    Typically, a single phrase or sentence.
  id: totrans-2942
  prefs: []
  type: TYPE_NORMAL
  zh: 指示 IntelliSense 应显示的工具提示，用于类型或成员。通常是一个短语或句子。
- en: '`<remarks>`'
  id: totrans-2943
  prefs: []
  type: TYPE_NORMAL
  zh: '`<remarks>`'
- en: '[PRE726]'
  id: totrans-2944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE726]'
- en: Additional text that describes the type or member. Documentation generators
    pick this up and merge it into the bulk of a type or member’s description.
  id: totrans-2945
  prefs: []
  type: TYPE_NORMAL
  zh: 额外描述类型或成员的文本。文档生成器将其捡起并合并到类型或成员描述的主体中。
- en: '`<param>`'
  id: totrans-2946
  prefs: []
  type: TYPE_NORMAL
  zh: '`<param>`'
- en: '[PRE727]'
  id: totrans-2947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE727]'
- en: Explains a parameter on a method.
  id: totrans-2948
  prefs: []
  type: TYPE_NORMAL
  zh: 解释方法的参数。
- en: '`<returns>`'
  id: totrans-2949
  prefs: []
  type: TYPE_NORMAL
  zh: '`<returns>`'
- en: '[PRE728]'
  id: totrans-2950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE728]'
- en: Explains the return value for a method.
  id: totrans-2951
  prefs: []
  type: TYPE_NORMAL
  zh: 解释方法的返回值。
- en: '`<exception>`'
  id: totrans-2952
  prefs: []
  type: TYPE_NORMAL
  zh: '`<exception>`'
- en: '[PRE729]'
  id: totrans-2953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE729]'
- en: Lists an exception that a method might throw (`cref` refers to the exception
    type).
  id: totrans-2954
  prefs: []
  type: TYPE_NORMAL
  zh: 列出方法可能抛出的异常（`cref`指向异常类型）。
- en: '`<permission>`'
  id: totrans-2955
  prefs: []
  type: TYPE_NORMAL
  zh: '`<permission>`'
- en: '[PRE730]'
  id: totrans-2956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE730]'
- en: Indicates an `IPermission` type required by the documented type or member.
  id: totrans-2957
  prefs: []
  type: TYPE_NORMAL
  zh: 指示文档化类型或成员所需的`IPermission`类型。
- en: '`<example>`'
  id: totrans-2958
  prefs: []
  type: TYPE_NORMAL
  zh: '`<example>`'
- en: '[PRE731]'
  id: totrans-2959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE731]'
- en: Denotes an example (used by documentation generators). This usually contains
    both description text and source code (source code is typically within a `<c>`
    or `<code>` tag).
  id: totrans-2960
  prefs: []
  type: TYPE_NORMAL
  zh: 表示一个示例（由文档生成器使用）。通常包含描述文本和源代码（源代码通常在 `<c>` 或 `<code>` 标签内）。
- en: '`<c>`'
  id: totrans-2961
  prefs: []
  type: TYPE_NORMAL
  zh: '`<c>`'
- en: '[PRE732]'
  id: totrans-2962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE732]'
- en: Indicates an inline code snippet. This tag is usually used within an `<example>`
    block.
  id: totrans-2963
  prefs: []
  type: TYPE_NORMAL
  zh: 指示内联代码片段。此标签通常用于`<example>`块内。
- en: '`<code>`'
  id: totrans-2964
  prefs: []
  type: TYPE_NORMAL
  zh: '`<code>`'
- en: '[PRE733]'
  id: totrans-2965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE733]'
- en: Indicates a multiline code sample. This tag is usually used within an `<example>`
    block.
  id: totrans-2966
  prefs: []
  type: TYPE_NORMAL
  zh: 指示多行代码示例。此标签通常用于`<example>`块内。
- en: '`<see>`'
  id: totrans-2967
  prefs: []
  type: TYPE_NORMAL
  zh: '`<see>`'
- en: '[PRE734]'
  id: totrans-2968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE734]'
- en: Inserts an inline cross-reference to another type or member. HTML documentation
    generators typically convert this to a hyperlink. The compiler emits a warning
    if the type or member name is invalid.
  id: totrans-2969
  prefs: []
  type: TYPE_NORMAL
  zh: 插入对另一个类型或成员的内联交叉引用。HTML 文档生成器通常会将其转换为超链接。如果类型或成员名称无效，编译器会发出警告。
- en: '`<seealso>`'
  id: totrans-2970
  prefs: []
  type: TYPE_NORMAL
  zh: '`<seealso>`'
- en: '[PRE735]'
  id: totrans-2971
  prefs: []
  type: TYPE_PRE
  zh: '[PRE735]'
- en: Cross-references another type or member. Documentation generators typically
    write this into a separate “See Also” section at the bottom of the page.
  id: totrans-2972
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉引用另一个类型或成员。文档生成器通常会将此写入到单独的“另请参阅”部分在页面底部。
- en: '`<paramref>`'
  id: totrans-2973
  prefs: []
  type: TYPE_NORMAL
  zh: '`<paramref>`'
- en: '[PRE736]'
  id: totrans-2974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE736]'
- en: References a parameter from within a `<summary>` or `<remarks>` tag.
  id: totrans-2975
  prefs: []
  type: TYPE_NORMAL
  zh: 引用 `<summary>` 或 `<remarks>` 标记中的参数。
- en: '`<list>`'
  id: totrans-2976
  prefs: []
  type: TYPE_NORMAL
  zh: '`<list>`'
- en: '[PRE737]'
  id: totrans-2977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE737]'
- en: Instructs documentation generators to emit a bulleted, numbered, or table-style
    list.
  id: totrans-2978
  prefs: []
  type: TYPE_NORMAL
  zh: 指导文档生成器生成项目符号、编号或表格样式的列表。
- en: '`<para>`'
  id: totrans-2979
  prefs: []
  type: TYPE_NORMAL
  zh: '`<para>`'
- en: '[PRE738]'
  id: totrans-2980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE738]'
- en: Instructs documentation generators to format the contents into a separate paragraph.
  id: totrans-2981
  prefs: []
  type: TYPE_NORMAL
  zh: 指导文档生成器将内容格式化为单独的段落。
- en: '`<include>`'
  id: totrans-2982
  prefs: []
  type: TYPE_NORMAL
  zh: '`<include>`'
- en: '[PRE739]'
  id: totrans-2983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE739]'
- en: Merges an external XML file that contains documentation. The path attribute
    denotes an XPath query to a specific element in that file.
  id: totrans-2984
  prefs: []
  type: TYPE_NORMAL
  zh: 合并包含文档的外部 XML 文件。路径属性表示该文件中特定元素的 XPath 查询。
