- en: C# 12 Pocket Reference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# is a general-purpose, type-safe, primarily object-oriented programming language,
    the goal of which is programmer productivity. To this end, the language balances
    simplicity, expressiveness, and performance. C# 12 is designed to work with the
    Microsoft *.NET 8* runtime (whereas C# 11 targets .NET 7, C# 10 targets .NET 6,
    and C# 7 targets Microsoft *.NET Framework* 4.6/4.7/4.8).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The programs and code snippets in this book mirror those in Chapters 2 through
    4 of *C# 12 in a Nutshell* and are all available as interactive samples in [*LINQPad*](http://www.linqpad.net).
    Working through these samples in conjunction with the book accelerates learning
    in that you can edit the samples and instantly see the results without needing
    to set up projects and solutions in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: To download the samples, click the Samples tab in LINQPad and then click “Download
    more samples.” LINQPad is free—go to [*www.linqpad.net*](http://www.linqpad.net).
  prefs: []
  type: TYPE_NORMAL
- en: A First C# Program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following is a program that multiplies 12 by 30 and prints the result, 360,
    to the screen. The double forward slash indicates that the remainder of a line
    is a *comment*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Our program consists of two *statements*. Statements in C# execute sequentially
    and are terminated by a semicolon. The first statement computes the *expression*
    `12 * 30` and stores the result in a *variable*, named `x`, whose type is a 32-bit
    integer (`int`). The second statement calls the `WriteLine` *method* on a *class*
    called `Console`, which is defined in a *namespace* called `System`. This prints
    the variable `x` to a text window on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: A method performs a function; a class groups function members and data members
    to form an object-oriented building block. The `Console` class groups members
    that handle command-line input/output (I/O) functionality, such as the `WriteLine`
    method. A class is a kind of *type*, which we examine in [“Type Basics”](#type_basics).
  prefs: []
  type: TYPE_NORMAL
- en: At the outermost level, types are organized into *namespaces*. Many commonly
    used types—including the `Console` class—reside in the `System` namespace. The
    .NET libraries are organized into nested namespaces. For example, the `System.Text`
    namespace contains types for handling text, and `System.IO` contains types for
    input/output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qualifying the `Console` class with the `System` namespace on every use adds
    clutter. The `using` directive lets you avoid this clutter by *importing* a namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A basic form of code reuse is to write higher-level functions that call lower-level
    functions. We can *refactor* our program with a reusable *method* called `FeetToInches`
    that multiplies an integer by 12, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Our method contains a series of statements surrounded by a pair of braces. This
    is called a *statement block*.
  prefs: []
  type: TYPE_NORMAL
- en: 'A method can receive *input* data from the caller by specifying *parameters*
    and *output* data back to the caller by specifying a *return type*. Our `FeetToInches`
    method has a parameter for inputting feet, and a return type for outputting inches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The *literals* `30` and `100` are the *arguments* passed to the `FeetToInches`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a method doesn’t receive input, use empty parentheses. If it doesn’t return
    anything, use the `void` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Methods are one of several kinds of functions in C#. Another kind of function
    we used in our example program was the `*` *operator*, which performs multiplication.
    There are also *constructors*, *properties*, *events*, *indexers*, and *finalizers*.
  prefs: []
  type: TYPE_NORMAL
- en: Compilation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The C# compiler compiles source code (a set of files with the *.cs* extension)
    into an *assembly*. An assembly is the unit of packaging and deployment in .NET.
    An assembly can be either an *application* or a *library*. A normal console or
    Windows application has an *entry point*, whereas a library does not. The purpose
    of a library is to be called upon (*referenced*) by an application or by other
    libraries. .NET itself is a set of libraries (as well as a runtime environment).
  prefs: []
  type: TYPE_NORMAL
- en: Each of the programs in the preceding section began directly with a series of
    statements (called *top-level statements*). The presence of top-level statements
    implicitly creates an entry point for a console or Windows application. (Without
    top-level statements, a *Main method* denotes an application’s entry point—see
    [“Symmetry of predefined types and custom types”](#symmetry_of_predefined_types_and_custom).)
  prefs: []
  type: TYPE_NORMAL
- en: 'To invoke the compiler, you can either use an integrated development environment
    (IDE) such as Visual Studio or Visual Studio Code, or call it manually from the
    command line. To manually compile a console application with .NET, first download
    the .NET 8 SDK, and then create a new project, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This creates a folder called *MyFirstProgram*, which contains a C# file called
    *Program.cs*, which you can then edit. To invoke the compiler, call `dotnet build`
    (or `dotnet run`, which will compile and then run the program). The output will
    be written to a subdirectory under *bin\debug*, which will include *MyFirstProgram.dll*
    (the output assembly) as well as *MyFirstProgram.exe* (which runs the compiled
    program directly).
  prefs: []
  type: TYPE_NORMAL
- en: Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C# syntax is inspired by C and C++ syntax. In this section, we describe C#’s
    elements of syntax, using the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Identifiers and Keywords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Identifiers* are names that programmers choose for their classes, methods,
    variables, and so on. Here are the identifiers in our example program, in the
    order in which they appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: An identifier must be a whole word, essentially made up of Unicode characters
    starting with a letter or underscore. C# identifiers are case sensitive. By convention,
    parameters, local variables, and private fields should be in *camel case* (e.g.,
    `myVariable`), and all other identifiers should be in *Pascal case* (e.g., `MyMethod`).
  prefs: []
  type: TYPE_NORMAL
- en: '*Keywords* are names that mean something special to the compiler. There are
    two keywords in our example program, `using` and `int`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most keywords are *reserved*, which means that you can’t use them as identifiers.
    Here is the full list of C# reserved keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `abstract` `as`'
  prefs: []
  type: TYPE_NORMAL
- en: '`base`'
  prefs: []
  type: TYPE_NORMAL
- en: '`bool`'
  prefs: []
  type: TYPE_NORMAL
- en: '`break`'
  prefs: []
  type: TYPE_NORMAL
- en: '`byte`'
  prefs: []
  type: TYPE_NORMAL
- en: '`case`'
  prefs: []
  type: TYPE_NORMAL
- en: '`catch`'
  prefs: []
  type: TYPE_NORMAL
- en: '`char`'
  prefs: []
  type: TYPE_NORMAL
- en: '`checked`'
  prefs: []
  type: TYPE_NORMAL
- en: '`class`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const`'
  prefs: []
  type: TYPE_NORMAL
- en: '`continue`'
  prefs: []
  type: TYPE_NORMAL
- en: '`decimal`'
  prefs: []
  type: TYPE_NORMAL
- en: '`default`'
  prefs: []
  type: TYPE_NORMAL
- en: '`delegate`'
  prefs: []
  type: TYPE_NORMAL
- en: '`do`'
  prefs: []
  type: TYPE_NORMAL
- en: '`double`'
  prefs: []
  type: TYPE_NORMAL
- en: '`else`'
  prefs: []
  type: TYPE_NORMAL
- en: '`enum` | `event` `explicit`'
  prefs: []
  type: TYPE_NORMAL
- en: '`extern`'
  prefs: []
  type: TYPE_NORMAL
- en: '`false`'
  prefs: []
  type: TYPE_NORMAL
- en: '`finally`'
  prefs: []
  type: TYPE_NORMAL
- en: '`fixed`'
  prefs: []
  type: TYPE_NORMAL
- en: '`float`'
  prefs: []
  type: TYPE_NORMAL
- en: '`for`'
  prefs: []
  type: TYPE_NORMAL
- en: '`foreach`'
  prefs: []
  type: TYPE_NORMAL
- en: '`goto`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if`'
  prefs: []
  type: TYPE_NORMAL
- en: '`implicit`'
  prefs: []
  type: TYPE_NORMAL
- en: '`in`'
  prefs: []
  type: TYPE_NORMAL
- en: '`int`'
  prefs: []
  type: TYPE_NORMAL
- en: '`interface`'
  prefs: []
  type: TYPE_NORMAL
- en: '`internal`'
  prefs: []
  type: TYPE_NORMAL
- en: '`is`'
  prefs: []
  type: TYPE_NORMAL
- en: '`lock`'
  prefs: []
  type: TYPE_NORMAL
- en: '`long`'
  prefs: []
  type: TYPE_NORMAL
- en: '`namespace` | `new` `null`'
  prefs: []
  type: TYPE_NORMAL
- en: '`object`'
  prefs: []
  type: TYPE_NORMAL
- en: '`operator`'
  prefs: []
  type: TYPE_NORMAL
- en: '`out`'
  prefs: []
  type: TYPE_NORMAL
- en: '`override`'
  prefs: []
  type: TYPE_NORMAL
- en: '`params`'
  prefs: []
  type: TYPE_NORMAL
- en: '`private`'
  prefs: []
  type: TYPE_NORMAL
- en: '`protected`'
  prefs: []
  type: TYPE_NORMAL
- en: '`public`'
  prefs: []
  type: TYPE_NORMAL
- en: '`readonly`'
  prefs: []
  type: TYPE_NORMAL
- en: '`record`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ref`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sbyte`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sealed`'
  prefs: []
  type: TYPE_NORMAL
- en: '`short`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sizeof`'
  prefs: []
  type: TYPE_NORMAL
- en: '`stackalloc`'
  prefs: []
  type: TYPE_NORMAL
- en: '`static` | `string` `struct`'
  prefs: []
  type: TYPE_NORMAL
- en: '`switch`'
  prefs: []
  type: TYPE_NORMAL
- en: '`this`'
  prefs: []
  type: TYPE_NORMAL
- en: '`throw`'
  prefs: []
  type: TYPE_NORMAL
- en: '`true`'
  prefs: []
  type: TYPE_NORMAL
- en: '`try`'
  prefs: []
  type: TYPE_NORMAL
- en: '`typeof`'
  prefs: []
  type: TYPE_NORMAL
- en: '`uint`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ulong`'
  prefs: []
  type: TYPE_NORMAL
- en: '`unchecked`'
  prefs: []
  type: TYPE_NORMAL
- en: '`unsafe`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ushort`'
  prefs: []
  type: TYPE_NORMAL
- en: '`using`'
  prefs: []
  type: TYPE_NORMAL
- en: '`virtual`'
  prefs: []
  type: TYPE_NORMAL
- en: '`void`'
  prefs: []
  type: TYPE_NORMAL
- en: '`volatile`'
  prefs: []
  type: TYPE_NORMAL
- en: '`while` |'
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding conflicts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you really want to use an identifier that clashes with a reserved keyword,
    you can do so by qualifying it with the `@` prefix. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `@` symbol doesn’t form part of the identifier itself. So `@myVariable`
    is the same as `myVariable`.
  prefs: []
  type: TYPE_NORMAL
- en: Contextual keywords
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some keywords are *contextual*, meaning they can also be used as identifiers—without
    an `@` symbol. The contextual keywords are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `add` `alias`'
  prefs: []
  type: TYPE_NORMAL
- en: '`and`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ascending`'
  prefs: []
  type: TYPE_NORMAL
- en: '`async`'
  prefs: []
  type: TYPE_NORMAL
- en: '`await`'
  prefs: []
  type: TYPE_NORMAL
- en: '`by`'
  prefs: []
  type: TYPE_NORMAL
- en: '`descending`'
  prefs: []
  type: TYPE_NORMAL
- en: '`dynamic`'
  prefs: []
  type: TYPE_NORMAL
- en: '`equals` | `file` `from`'
  prefs: []
  type: TYPE_NORMAL
- en: '`get`'
  prefs: []
  type: TYPE_NORMAL
- en: '`global`'
  prefs: []
  type: TYPE_NORMAL
- en: '`group`'
  prefs: []
  type: TYPE_NORMAL
- en: '`init`'
  prefs: []
  type: TYPE_NORMAL
- en: '`into`'
  prefs: []
  type: TYPE_NORMAL
- en: '`join`'
  prefs: []
  type: TYPE_NORMAL
- en: '`let`'
  prefs: []
  type: TYPE_NORMAL
- en: '`managed` | `nameof` `nint`'
  prefs: []
  type: TYPE_NORMAL
- en: '`not`'
  prefs: []
  type: TYPE_NORMAL
- en: '`notnull`'
  prefs: []
  type: TYPE_NORMAL
- en: '`nuint`'
  prefs: []
  type: TYPE_NORMAL
- en: '`on`'
  prefs: []
  type: TYPE_NORMAL
- en: '`or`'
  prefs: []
  type: TYPE_NORMAL
- en: '`orderby`'
  prefs: []
  type: TYPE_NORMAL
- en: '`partial`'
  prefs: []
  type: TYPE_NORMAL
- en: '`remove` | `required` `select`'
  prefs: []
  type: TYPE_NORMAL
- en: '`set`'
  prefs: []
  type: TYPE_NORMAL
- en: '`unmanaged`'
  prefs: []
  type: TYPE_NORMAL
- en: '`value`'
  prefs: []
  type: TYPE_NORMAL
- en: '`var`'
  prefs: []
  type: TYPE_NORMAL
- en: '`with`'
  prefs: []
  type: TYPE_NORMAL
- en: '`when`'
  prefs: []
  type: TYPE_NORMAL
- en: '`where`'
  prefs: []
  type: TYPE_NORMAL
- en: '`yield` |'
  prefs: []
  type: TYPE_NORMAL
- en: With contextual keywords, ambiguity cannot arise within the context in which
    they are used.
  prefs: []
  type: TYPE_NORMAL
- en: Literals, Punctuators, and Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Literals* are primitive pieces of data lexically embedded into the program.
    The literals we used in our example program are `12` and `30`. *Punctuators* help
    demarcate the structure of the program. An example is the semicolon, which terminates
    a statement. Statements can wrap multiple lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'An *operator* transforms and combines expressions. Most operators in C# are
    denoted with a symbol, such as the multiplication operator, `*`. Here are the
    operators in our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: A period denotes a member of something (or a decimal point with numeric literals).
    Parentheses are used when declaring or calling a method; empty parentheses are
    used when the method accepts no arguments. The equals sign performs *assignment*
    (the double equals sign, `==`, performs equality comparison).
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C# offers two different styles of source code documentation: *single-line comments*
    and *multiline comments*. A single-line comment begins with a double forward slash
    and continues until the end of the line. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'A multiline comment begins with `/*` and ends with `*/`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Comments can embed XML documentation tags (see [“XML Documentation”](#xml_documentation)).
  prefs: []
  type: TYPE_NORMAL
- en: Type Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *type* defines the blueprint for a value. In our example, we used two literals
    of type `int` with values 12 and 30\. We also declared a *variable* of type `int`
    whose name was `x`.
  prefs: []
  type: TYPE_NORMAL
- en: A *variable* denotes a storage location that can contain different values over
    time. In contrast, a *constant* always represents the same value (more on this
    later).
  prefs: []
  type: TYPE_NORMAL
- en: All values in C# are an *instance* of a specific type. The meaning of a value,
    and the set of possible values a variable can have, is determined by its type.
  prefs: []
  type: TYPE_NORMAL
- en: Predefined Type Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Predefined types (also called *built-in* types) are types that are specially
    supported by the compiler. The `int` type is a predefined type for representing
    the set of integers that fit into 32 bits of memory, from −2^(31) to 2^(31)−1\.
    We can perform functions such as arithmetic with instances of the `int` type as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Another predefined C# type is `string`. The `string` type represents a sequence
    of characters, such as “.NET” or “[*http://oreilly.com*](http://oreilly.com).
    We can work with strings by calling functions on them, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The predefined `bool` type has exactly two possible values: `true` and `false`.
    The `bool` type is commonly used to conditionally branch execution flow with an
    `if` statement. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `System` namespace in .NET contains many important types that are not predefined
    by C# (e.g., `DateTime`).
  prefs: []
  type: TYPE_NORMAL
- en: Custom Type Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as you can build complex functions from simple functions, you can build
    complex types from primitive types. In this example, we will define a custom type
    named `UnitConverter`—a class that serves as a blueprint for unit conversions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Members of a type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A type contains *data members* and *function members*. The data member of `UnitConverter`
    is the *field* called `ratio`. The function members of `UnitConverter` are the
    `Convert` method and the `UnitConverter`’s *constructor*.
  prefs: []
  type: TYPE_NORMAL
- en: Symmetry of predefined types and custom types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A beautiful aspect of C# is that predefined types and custom types have few
    differences. The predefined `int` type serves as a blueprint for integers. It
    holds data—32 bits—and provides function members that use that data, such as `ToString`.
    Similarly, our custom `UnitConverter` type acts as a blueprint for unit conversions.
    It holds data—the ratio—and provides function members to use that data.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors and instantiation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Data is created by *instantiating* a type. You can instantiate predefined types
    simply by using a literal such as `12` or `"Hello world"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `new` operator creates instances of a custom type. We started our program
    by creating two instances of the `UnitConverter` type. Immediately after the `new`
    operator instantiates an object, the object’s *constructor* is called to perform
    initialization. A constructor is defined like a method, except that the method
    name and return type are reduced to the name of the enclosing type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Instance versus static members
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The data members and function members that operate on the *instance* of the
    type are called *instance members*. `UnitConverter`’s `Convert` method and `int`’s
    `ToString` method are examples of instance members. By default, members are instance
    members.
  prefs: []
  type: TYPE_NORMAL
- en: Data members and function members that don’t operate on the instance of the
    type can be marked as `static`. To refer to a static member from outside its type,
    you specify its *type* name rather than an *instance*. An example is the `WriteLine`
    method of the `Console` class. Because this is static, we call `Console.WriteLine()`
    and not `new Console().WriteLine()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, the instance field `Name` pertains to an instance of
    a particular `Panda`, whereas `Population` pertains to the set of all `Panda`
    instances. We create two instances of the `Panda`, print their names, and then
    print the total population:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Attempting to evaluate `p1.Population` or `Panda.Name` will generate a compile-time
    error.
  prefs: []
  type: TYPE_NORMAL
- en: The public keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `public` keyword exposes members to other classes. In this example, if
    the `Name` field in `Panda` was not marked as public, it would be private and
    could not be accessed from outside the class. Marking a member public is how a
    type communicates: “Here is what I want other types to see—everything else is
    my own private implementation details.” In object-oriented terms, we say that
    the public members *encapsulate* the private members of the class.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a namespace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Particularly with larger programs, it makes sense to organize types into namespaces.
    Here’s how to define the `Panda` class inside a namespace called `Animals`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We cover namespaces in detail in [“Namespaces”](#namespaces).
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Main method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All of our examples so far have used top-level statements, a feature that was
    introduced in C# 9\. Without top-level statements, a simple console or Windows
    application looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the absence of top-level statements, C# looks for a static method called
    `Main`, which becomes the entry point. The `Main` method can be defined inside
    any class (and only one `Main` method can exist).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Main` method can optionally return an integer (rather than `void`) in
    order to return a value to the execution environment (where a nonzero value typically
    indicates an error). The `Main` method can also optionally accept an array of
    strings as a parameter (that will be populated with any arguments passed to the
    executable); for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: An array (such as `string[]`) represents a fixed number of elements of a particular
    type. Arrays are specified by placing square brackets after the element type.
    We describe them in [“Arrays”](#arrays).
  prefs: []
  type: TYPE_NORMAL
- en: (The `Main` method can also be declared `async` and return a `Task` or `Task<int>`
    in support of asynchronous programming—see [“Asynchronous Functions”](#asynchronous_functions).)
  prefs: []
  type: TYPE_NORMAL
- en: Top-level statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Top-level statements let you avoid the baggage of a static `Main` method and
    a containing class. A file with top-level statements comprises three parts, in
    this order:'
  prefs: []
  type: TYPE_NORMAL
- en: (Optionally) `using` directives
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A series of statements, optionally mixed with method declarations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (Optionally) Type and namespace declarations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Everything in Part 2 ends up inside a compiler-generated “main” method, inside
    a compiler-generated class. This means that the methods in your top-level statements
    become *local methods* (we describe the subtleties in [“Local methods”](#local_methods)).
    Top-level statements can optionally return an integer value to the caller, and
    access a “magic” variable of type `string[]` called `args`, corresponding to command-line
    arguments passed by the caller.
  prefs: []
  type: TYPE_NORMAL
- en: As a program can have only one entry point, there can be at most one file with
    top-level statements in a C# project.
  prefs: []
  type: TYPE_NORMAL
- en: Types and Conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C# can convert between instances of compatible types. A conversion always creates
    a new value from an existing one. Conversions can be either *implicit* or *explicit*:
    implicit conversions happen automatically, whereas explicit conversions require
    a *cast*. In the following example, we *implicitly* convert an `int` to a `long`
    type (which has twice the bit capacity of an `int`) and *explicitly* cast an `int`
    to a `short` type (which has half the bit capacity of an `int`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In general, implicit conversions are allowed when the compiler can guarantee
    that they will always succeed without loss of information. Otherwise, you must
    perform an explicit cast to convert between compatible types.
  prefs: []
  type: TYPE_NORMAL
- en: Value Types Versus Reference Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C# types can be divided into *value types* and *reference types*.
  prefs: []
  type: TYPE_NORMAL
- en: '*Value types* comprise most built-in types (specifically, all numeric types,
    the `char` type, and the `bool` type) as well as custom `struct` and `enum` types.
    *Reference types* comprise all class, array, delegate, and interface types.'
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental difference between value types and reference types is how they
    are handled in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Value types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The content of a *value type* variable or constant is simply a value. For example,
    the content of the built-in value type `int` is 32 bits of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define a custom value type with the `struct` keyword (see [Figure 1](#a_value_type_instance_in_memory)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![A value type instance in memory](Images/c12p_0101.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1\. A value type instance in memory
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The assignment of a value type instance always *copies* the instance. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 2](#assignment_copies_a_value_type_instance) shows that `p1` and `p2`
    have independent storage.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assignment copies a value type instance](Images/c12p_0102.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2\. Assignment copies a value type instance
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Reference types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A reference type is more complex than a value type, having two parts: an *object*
    and the *reference* to that object. The content of a reference type variable or
    constant is a reference to an object that contains the value. Here is the `Point`
    type from our previous example rewritten as a class (see [Figure 3](#a_reference_type_instance_in_memory)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![A reference type instance in memory](Images/c12p_0103.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3\. A reference type instance in memory
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Assigning a reference type variable copies the reference, not the object instance.
    This allows multiple variables to refer to the same object—something that’s not
    ordinarily possible with value types. If we repeat the previous example, but with
    `Point` now a class, an operation via `p1` affects `p2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 4](#assignment_copies_a_reference) shows that `p1` and `p2` are two
    references that point to the same object.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assignment copies a reference](Images/c12p_0104.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4\. Assignment copies a reference
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Null'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A reference can be assigned the literal `null`, indicating that the reference
    points to no object. Assuming `Point` is a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Accessing a member of a null reference generates a runtime error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In [“Nullable Reference Types”](#nullable_reference_types), we describe a feature
    of C# that reduces accidental `NullReference​Excep⁠tion` errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, a value type cannot ordinarily have a null value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: To work around this, C# has a special construct for representing value-type
    nulls—see [“Nullable Value Types”](#nullable_value_types).
  prefs: []
  type: TYPE_NORMAL
- en: Predefined Type Taxonomy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The predefined types in C# are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Value types
  prefs: []
  type: TYPE_NORMAL
- en: 'Numeric:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signed integer (`sbyte`, `short`, `int`, `long`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Unsigned integer (`byte`, `ushort`, `uint`, `ulong`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Real number (`float`, `double`, `decimal`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical (`bool`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character (`char`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference types
  prefs: []
  type: TYPE_NORMAL
- en: String (`string`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object (`object`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Predefined types in C# alias .NET types in the `System` namespace. There is
    only a syntactic difference between these two statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The set of predefined *value* types excluding `decimal` are known as *primitive
    types* in the Common Language Runtime (CLR). Primitive types are so called because
    they are supported directly via instructions in compiled code, which usually translates
    to direct support on the underlying processor.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C# has the following predefined numeric types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| C# type | System type | Suffix | Size | Range |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Integral—signed** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `sbyte` | `SByte` |  | 8 bits | –2⁷ to 2⁷–1 |'
  prefs: []
  type: TYPE_TB
- en: '| `short` | `Int16` |  | 16 bits | –2^(15) to 2^(15)–1 |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | `Int32` |  | 32 bits | –2^(31) to 2^(31)–1 |'
  prefs: []
  type: TYPE_TB
- en: '| `long` | `Int64` | `L` | 64 bits | –2^(63) to 2^(63)–1 |'
  prefs: []
  type: TYPE_TB
- en: '| `nint` | `IntPtr` |  | 32/64 bits |  |'
  prefs: []
  type: TYPE_TB
- en: '| **Integral—unsigned** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `byte` | `Byte` |  | 8 bits | 0 to 2⁸–1 |'
  prefs: []
  type: TYPE_TB
- en: '| `ushort` | `UInt16` |  | 16 bits | 0 to 2^(16)–1 |'
  prefs: []
  type: TYPE_TB
- en: '| `uint` | `UInt32` | `U` | 32 bits | 0 to 2^(32)–1 |'
  prefs: []
  type: TYPE_TB
- en: '| `ulong` | `UInt64` | `UL` | 64 bits | 0 to 2^(64)–1 |'
  prefs: []
  type: TYPE_TB
- en: '| `nuint` | `UIntPtr` |  | 32/64 bits |  |'
  prefs: []
  type: TYPE_TB
- en: '| **Real** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | `Single` | `F` | 32 bits | ± (~10^(–45) to 10^(38)) |'
  prefs: []
  type: TYPE_TB
- en: '| `double` | `Double` | `D` | 64 bits | ± (~10^(–324) to 10^(308)) |'
  prefs: []
  type: TYPE_TB
- en: '| `decimal` | `Decimal` | `M` | 128 bits | ± (~10^(–28) to 10^(28)) |'
  prefs: []
  type: TYPE_TB
- en: Of the *integral* types, `int` and `long` are first-class citizens and are favored
    by both C# and the runtime. The other integral types are typically used for interoperability
    or when space efficiency is paramount. The `nint` and `nuint` native-sized integer
    types are sized to match the address space of the process at runtime (32 or 64
    bits). These types can be useful when working with pointers—we describe their
    nuances in Chapter 4 of *C# 12 in a Nutshell* (O’Reilly).
  prefs: []
  type: TYPE_NORMAL
- en: Of the *real* number types, `float` and `double` are called *floating-point
    types* and are typically used for scientific and graphical calculations. The `decimal`
    type is typically used for financial calculations where base-10-accurate arithmetic
    and high precision are required. (Technically, `decimal` is a floating-point type,
    too, although it’s not generally referred to as such.)
  prefs: []
  type: TYPE_NORMAL
- en: Numeric Literals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Integral-typed literals* can use decimal, hexadecimal, or binary notation;
    hexadecimal is denoted with the `0x` prefix (e.g., `0x7f` is equivalent to `127`),
    and binary is denoted with the `0b` prefix. *Real literals* can use decimal or
    exponential notation such as `1E06`. Underscores may be inserted within (or before)
    a numeric literal to improve readability (e.g., `1_000_000`).'
  prefs: []
  type: TYPE_NORMAL
- en: Numeric literal type inference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, the compiler *infers* a numeric literal to be either `double` or
    an integral type:'
  prefs: []
  type: TYPE_NORMAL
- en: If the literal contains a decimal point or the exponential symbol (`E`), it
    is a `double`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Otherwise, the literal’s type is the first type in this list that can fit the
    literal’s value: `int`, `uint`, `long`, and `ulong`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Numeric suffixes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *numeric suffixes* listed in the preceding table explicitly define the
    type of a literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The suffixes `U` and `L` are rarely necessary because the `uint`, `long`, and
    `ulong` types can nearly always be either *inferred* or *implicitly converted*
    from `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `D` suffix is technically redundant in that all literals with a decimal
    point are inferred to be `double` (and you can always add a decimal point to a
    numeric literal). The `F` and `M` suffixes are the most useful and are mandatory
    when you’re specifying fractional `float` or `decimal` literals. Without suffixes,
    the following would not compile because 4.5 would be inferred to be of type `double`,
    which has no implicit conversion to `float` or `decimal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Numeric Conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Integral-to-integral conversions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Integral conversions are *implicit* when the destination type can represent
    every possible value of the source type. Otherwise, an *explicit* conversion is
    required. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Real-to-real conversions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `float` can be implicitly converted to a `double` because a `double` can represent
    every possible `float` value. The reverse conversion must be explicit.
  prefs: []
  type: TYPE_NORMAL
- en: Conversions between `decimal` and other real types must be explicit.
  prefs: []
  type: TYPE_NORMAL
- en: Real-to-integral conversions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Conversions from integral types to real types are implicit, whereas the reverse
    must be explicit. Converting from a floating-point to an integral type truncates
    any fractional portion; to perform rounding conversions, use the static `System.Convert`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'A caveat is that implicitly converting a large integral type to a floating-point
    type preserves *magnitude* but might occasionally lose *precision*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Arithmetic Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The arithmetic operators (`+`, `-`, `*`, `/`, `%`) are defined for all numeric
    types except the 8- and 16-bit integral types. The `%` operator evaluates the
    remainder after division.
  prefs: []
  type: TYPE_NORMAL
- en: Increment and Decrement Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The increment and decrement operators (`++`, `--`, respectively) increment
    and decrement numeric types by 1\. The operator can either precede or follow the
    variable, depending on whether you want the variable to be updated *before* or
    *after* the expression is evaluated. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Specialized Integral Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Division
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Division operations on integral types always eliminate the remainder (round
    toward zero). Dividing by a variable whose value is zero generates a runtime error
    (a `DivideByZeroException`). Dividing by the *literal* or *constant* 0 generates
    a compile-time error.
  prefs: []
  type: TYPE_NORMAL
- en: Overflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At runtime, arithmetic operations on integral types can overflow. By default,
    this happens silently—no exception is thrown, and the result exhibits wraparound
    behavior, as though the computation were done on a larger integer type and the
    extra significant bits discarded. For example, decrementing the minimum possible
    `int` value results in the maximum possible `int` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The checked and unchecked operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `checked` operator instructs the runtime to generate an `OverflowException`
    rather than overflowing silently when an integral-typed expression or statement
    exceeds the arithmetic limits of that type. The `checked` operator affects expressions
    with the `++`, `−−`, (unary) `−`, `+`, `−`, `*`, `/`, and explicit conversion
    operators between integral types. Overflow checking incurs a small performance
    cost.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use `checked` around either an expression or a statement block. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You can make arithmetic overflow checking the default for all expressions in
    a program by compiling with the `/checked+` command-line switch (in Visual Studio,
    go to Advanced Build Settings). If you then need to disable overflow checking
    just for specific expressions or statements, you can do so with the `unchecked`
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C# supports the following bitwise operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Meaning | Sample expression | Result |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `~` | Complement | `~0xfU` | `0xfffffff0U` |'
  prefs: []
  type: TYPE_TB
- en: '| `&` | And | `0xf0 & 0x33` | `0x30` |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;` | Or | `0xf0 &#124; 0x33` | `0xf3` |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | Exclusive Or | `0xff00 ^ 0x0ff0` | `0xf0f0` |'
  prefs: []
  type: TYPE_TB
- en: '| `<<` | Shift left | `0x20 << 2` | `0x80` |'
  prefs: []
  type: TYPE_TB
- en: '| `>>` | Shift right | `0x20 >> 1` | `0x10` |'
  prefs: []
  type: TYPE_TB
- en: From C# 11, there is also an unsigned shift-right operator (`>>>`). Whereas
    the shift-right operator `(>>`) replicates the high-order bit when operating on
    signed integers, the unsigned shift-right operator (`>>>`) does not.
  prefs: []
  type: TYPE_NORMAL
- en: 8- and 16-Bit Integral Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The 8- and 16-bit integral types are `byte`, `sbyte`, `short`, and `ushort`.
    These types lack their own arithmetic operators, so C# implicitly converts them
    to larger types as required. This can cause a compilation error when trying to
    assign the result back to a small integral type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, `x` and `y` are implicitly converted to `int` so that the addition
    can be performed. This means that the result is also an `int`, which cannot be
    implicitly cast back to a `short` (because it could cause loss of data). To make
    this compile, you must add an explicit cast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Special Float and Double Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike integral types, floating-point types have values that certain operations
    treat specially. These special values are NaN (Not a Number), +∞, −∞, and −0\.
    The `float` and `double` classes have constants for NaN, +∞, and −∞ (as well as
    other values including `MaxValue`, `MinValue`, and `Epsilon`). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Dividing a nonzero number by zero results in an infinite value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Dividing zero by zero, or subtracting infinity from infinity, results in a
    NaN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'When you use `==`, a NaN value is never equal to another value, even another
    NaN value. To test whether a value is NaN, you must use the `float.IsNaN` or `double.IsNaN`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'When you use `object.Equals`, however, two NaN values are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: double Versus decimal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`double` is useful for scientific computations (such as computing spatial coordinates).
    `decimal` is useful for financial computations and values that are manufactured
    rather than the result of real-world measurements. Here’s a summary of the differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | double | decimal |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Internal representation | Base 2 | Base 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Precision | 15–16 significant figures | 28–29 significant figures |'
  prefs: []
  type: TYPE_TB
- en: '| Range | ±(~10^(−324) to ~10^(308)) | ±(~10^(−28) to ~10^(28)) |'
  prefs: []
  type: TYPE_TB
- en: '| Special values | +0, −0, +∞, −∞, and NaN | None |'
  prefs: []
  type: TYPE_TB
- en: '| Speed | Native to processor | Non-native to processor (about 10 times slower
    than `double`) |'
  prefs: []
  type: TYPE_TB
- en: Real Number Rounding Errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`float` and `double` internally represent numbers in base 2\. For this reason,
    most literals with a fractional component (which are in base 10) will not be represented
    precisely, making them bad for financial calculations. In contrast, `decimal`
    works in base 10 and so can precisely represent fractional numbers such as 0.1
    (whose base-10 representation is nonrecurring).'
  prefs: []
  type: TYPE_NORMAL
- en: Boolean Type and Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C#’s `bool` type (aliasing the `System.Boolean` type) is a logical value that
    can be assigned the literal `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Although a Boolean value requires only one bit of storage, the runtime will
    use one byte of memory because this is the minimum chunk that the runtime and
    processor can efficiently work with. To avoid space inefficiency in the case of
    arrays, .NET provides a `BitArray` class in the `System​.Col⁠lections` namespace
    that is designed to use just one bit per Boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: Equality and Comparison Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`==` and `!=` test for equality and inequality, respectively, of any type and
    always return a `bool` value. Value types typically have a very simple notion
    of equality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: For reference types, equality, by default, is based on *reference*, as opposed
    to the actual *value* of the underlying object. Therefore, two instances of an
    object with identical data are not considered equal unless the `==` operator for
    that type is specially overloaded to that effect (see [“The object Type”](#the_object_type)
    and [“Operator Overloading”](#operator_overloading)).
  prefs: []
  type: TYPE_NORMAL
- en: The equality and comparison operators, `==`, `!=`, `<`, `>`, `>=`, and `<=`,
    work for all numeric types but should be used with caution with real numbers (see
    [“Real Number Rounding Errors”](#real_number_rounding_errors) in the previous
    section). The comparison operators also work on `enum` type members by comparing
    their underlying integral values.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `&&` and `||` operators test for *and* and *or* conditions, respectively.
    They are frequently used in conjunction with the `!` operator, which expresses
    *not*. In the following example, the `UseUmbrella` method returns `true` if it’s
    rainy or sunny (to protect us from the rain or the sun), as long as it’s not also
    windy (because umbrellas are useless in the wind):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `&&` and `||` operators *short-circuit* evaluation when possible. In the
    preceding example, if it is windy, the expression `(rainy || sunny)` is not even
    evaluated. Short-circuiting is essential in allowing expressions such as the following
    to run without throwing a `NullReferenceException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `&` and `|` operators also test for *and* and *or* conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The difference is that they *do not short-circuit*. For this reason, they are
    rarely used in place of conditional operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ternary conditional operator (simply called the *conditional operator*)
    has the form `q ? a : b`, where if condition `q` is true, `a` is evaluated, otherwise
    `b` is evaluated. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The conditional operator is particularly useful in LINQ queries.
  prefs: []
  type: TYPE_NORMAL
- en: Strings and Characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C#’s `char` type (aliasing the `System.Char` type) represents a Unicode character
    and occupies two bytes (UTF-16). A `char` literal is specified inside single quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '*Escape sequences* express characters that cannot be expressed or interpreted
    literally. An escape sequence is a backslash followed by a character with a special
    meaning. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The escape sequence characters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Char | Meaning | Value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `\''` | Single quote | `0x0027` |'
  prefs: []
  type: TYPE_TB
- en: '| `\"` | Double quote | `0x0022` |'
  prefs: []
  type: TYPE_TB
- en: '| `\\` | Backslash | `0x005C` |'
  prefs: []
  type: TYPE_TB
- en: '| `\0` | Null | `0x0000` |'
  prefs: []
  type: TYPE_TB
- en: '| `\a` | Alert | `0x0007` |'
  prefs: []
  type: TYPE_TB
- en: '| `\b` | Backspace | `0x0008` |'
  prefs: []
  type: TYPE_TB
- en: '| `\f` | Form feed | `0x000C` |'
  prefs: []
  type: TYPE_TB
- en: '| `\n` | New line | `0x000A` |'
  prefs: []
  type: TYPE_TB
- en: '| `\r` | Carriage return | `0x000D` |'
  prefs: []
  type: TYPE_TB
- en: '| `\t` | Horizontal tab | `0x0009` |'
  prefs: []
  type: TYPE_TB
- en: '| `\v` | Vertical tab | `0x000B` |'
  prefs: []
  type: TYPE_TB
- en: 'The `\u` (or `\x`) escape sequence lets you specify any Unicode character via
    its four-digit hexadecimal code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: An implicit conversion from a `char` to a numeric type works for the numeric
    types that can accommodate an unsigned `short`. For other numeric types, an explicit
    conversion is required.
  prefs: []
  type: TYPE_NORMAL
- en: String Type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C#’s `string` type (aliasing the `System.String` type) represents an immutable
    (unmodifiable) sequence of Unicode characters. A string literal is specified within
    double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`string` is a reference type rather than a value type. Its equality operators,
    however, follow value type semantics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The escape sequences that are valid for `char` literals also work within strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The cost of this is that whenever you need a literal backslash, you must write
    it twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid this problem, C# allows *verbatim* string literals. A verbatim string
    literal is prefixed with `@` and does not support escape sequences. The following
    verbatim string is identical to the preceding one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: A verbatim string literal can also span multiple lines. You can include the
    double-quote character in a verbatim literal by writing it twice.
  prefs: []
  type: TYPE_NORMAL
- en: Raw string literals (C# 11)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Wrapping a string in three or more quote characters (`"""`) creates a *raw
    string literal*. Raw string literals can contain almost any character sequence,
    without escaping or doubling up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Raw string literals make it easy to represent JSON, XML, and HTML literals,
    as well as regular expressions and source code. Should you need to include three
    (or more) quote characters in the string itself, you can do so by wrapping the
    string in four (or more) quote characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiline raw string literals are subject to special rules. We can represent
    the string `"Line 1\r\nLine 2"` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the opening and closing quotes must be on separate lines to the
    string content. Additionally:'
  prefs: []
  type: TYPE_NORMAL
- en: Whitespace following the *opening* `"""` (on the same line) is ignored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whitespace preceding the *closing* `"""` (on the same line) is treated as *common
    indentation* and is removed from every line in the string. This lets you include
    indentation for source-code readability (as we did in our example) without that
    indentation becoming part of the string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raw string literals can be interpolated, subject to special rules described
    in [“String interpolation”](#string_interpolation).
  prefs: []
  type: TYPE_NORMAL
- en: String concatenation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `+` operator concatenates two strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the operands can be a nonstring value, in which case `ToString` is called
    on that value. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Using the `+` operator repeatedly to build up a string can be inefficient; a
    better solution is to use the `System.Text.StringBuilder` type—this represents
    a mutable (editable) string and has methods to efficiently `Append`, `Insert`,
    `Remove`, and `Replace` substrings.
  prefs: []
  type: TYPE_NORMAL
- en: String interpolation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A string preceded with the `$` character is called an *interpolated string*.
    Interpolated strings can include expressions within braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Any valid C# expression of any type can appear within the braces, and C# will
    convert the expression to a string by calling its `ToString` method or equivalent.
    You can change the formatting by appending the expression with a colon and a *format
    string* (we describe format strings in Chapter 6 of *C# 12 in a Nutshell*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'From C# 10, interpolated strings can be constants, as long as the interpolated
    values are constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'From C# 11, interpolated strings are permitted to span multiple lines (whether
    standard or verbatim):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Raw string literals (from C# 11) can also be interpolated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'To include a brace literal in an interpolated string:'
  prefs: []
  type: TYPE_NORMAL
- en: With standard and verbatim string literals, repeat the desired brace character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With raw string literals, change the interpolation sequence by repeating the
    `$` prefix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using two (or more) `$` characters in a raw string literal prefix changes the
    interpolation sequence from one brace to two (or more) braces. Consider the following
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This evaluates to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: String comparisons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`string` does not support `<` and `>` operators for comparisons. You must instead
    use `string`’s `CompareTo` method, which returns a positive number, a negative
    number, or zero, depending on whether the first value comes after, before, or
    alongside the second value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Searching within strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`string`’s indexer returns a character at a specified position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The `IndexOf` and `LastIndexOf` methods search for a character within the string.
    The `Contains`, `StartsWith`, and `EndsWith` methods search for a substring within
    the string.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because `string` is immutable, all the methods that “manipulate” a string return
    a new one, leaving the original untouched:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Substring` extracts a portion of a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Insert` and `Remove` insert and remove characters at a specified position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PadLeft` and `PadRight` add whitespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TrimStart`, `TrimEnd`, and `Trim` remove whitespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `string` class also defines `ToUpper` and `ToLower` methods for changing
    case, a `Split` method to split a string into substrings (based on supplied delimiters),
    and a static `Join` method to join substrings back into a string.
  prefs: []
  type: TYPE_NORMAL
- en: UTF-8 Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From C# 11, you can use the `u8` suffix to create string literals encoded in
    UTF-8 rather than UTF-16\. This feature is intended for advanced scenarios such
    as the low-level handling of JSON text in performance hotspots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The underlying type is `ReadOnlySpan<byte>`, which we cover in Chapter 23 of
    *C# 12 in a Nutshell*. You can convert this to an array by calling the `ToArray()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An *array* represents a fixed number of elements of a particular type. The elements
    in an array are always stored in a contiguous block of memory, providing highly
    efficient access.
  prefs: []
  type: TYPE_NORMAL
- en: 'An array is denoted with square brackets after the element type. The following
    declares an array of five characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Square brackets also *index* the array, accessing a particular element by position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints “e” because array indexes start at 0\. You can use a `for` loop
    statement to iterate through each element in the array. The `for` loop in this
    example cycles the integer `i` from `0` to `4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Arrays also implement `IEnumerable<T>` (see [“Enumeration and Iterators”](#enumeration_and_iterators)),
    so you can also enumerate members with the `foreach` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'All array indexing is bounds-checked by the runtime. An `IndexOutOfRangeException`
    is thrown if you use an invalid index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The `Length` property of an array returns the number of elements in the array.
    After an array has been created, its length cannot be changed. The `System.Collection`
    namespace and subnamespaces provide higher-level data structures, such as dynamically
    sized arrays and dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'An *array initialization expression* lets you declare and populate an array
    in a single step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Or simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'From C# 12, you can use square brackets instead of curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'This is called a *collection expression* and has the advantage of also working
    when calling methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Collection expressions also work with other collection types such as lists and
    sets—see [“Collection Initializers and Collection Expressions”](#collection_initializers_and_collection).
  prefs: []
  type: TYPE_NORMAL
- en: 'All arrays inherit from the `System.Array` class, which defines common methods
    and properties for all arrays. This includes instance properties such as `Length`
    and `Rank`, and static methods to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically create an array (`CreateInstance`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get and set elements regardless of the array type (`GetValue`/`SetValue`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search a sorted array (`BinarySearch`) or an unsorted array (`IndexOf`, `LastIndexOf`,
    `Find`, `FindIndex`, `FindLastIndex`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sort an array (`Sort`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy an array (`Copy`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default Element Initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating an array always preinitializes the elements with default values. The
    default value for a type is the result of a bitwise zeroing of memory. For example,
    consider creating an array of integers. Because `int` is a value type, this allocates
    1,000 integers in one contiguous block of memory. The default value for each element
    will be 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: With reference type elements, the default value is `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An array *itself* is always a reference type object, regardless of element
    type. For instance, the following is legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Indices and Ranges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Indices and ranges* (from C# 8) simplify working with elements or portions
    of an array.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Indices and ranges also work with the CLR types `Span<T>` and `ReadOnlySpan<T>`,
    which provide efficient low-level access to managed or unmanaged memory.
  prefs: []
  type: TYPE_NORMAL
- en: You can also make your own types work with indices and ranges by defining an
    indexer of type `Index` or `Range` (see [“Indexers”](#indexers)).
  prefs: []
  type: TYPE_NORMAL
- en: Indices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Indices let you refer to elements relative to the *end* of an array, with the
    `^` operator. `^1` refers to the last element, `^2` refers to the second-to-last
    element, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: (`^0` equals the length of the array, so `vowels[^0]` generates an error.)
  prefs: []
  type: TYPE_NORMAL
- en: 'C# implements indices with the help of the `Index` type, so you can also do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Ranges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Ranges let you “slice” an array with the `..` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The second number in the range is *exclusive*, so `..2` returns the elements
    *before* `vowels[2]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the `^` symbol in ranges. The following returns the last two
    characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: (`^0` is valid here because the second number in the range is *exclusive*.)
  prefs: []
  type: TYPE_NORMAL
- en: 'C# implements ranges with the help of the `Range` type, so you can also do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Multidimensional Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Multidimensional arrays come in two varieties: *rectangular* and *jagged*.
    Rectangular arrays represent an *n*-dimensional block of memory, and jagged arrays
    are arrays of arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: Rectangular arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To declare rectangular arrays, use commas to separate each dimension. The following
    declares a rectangular two-dimensional array, where the dimensions are 3 × 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetLength` method of an array returns the length for a given dimension
    (starting at 0):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'A rectangular array can be initialized as follows (to create an array identical
    to the previous example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: (The code shown in boldface can be omitted in declaration statements such as
    this.)
  prefs: []
  type: TYPE_NORMAL
- en: Jagged arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To declare jagged arrays, use successive square-bracket pairs for each dimension.
    Here is an example of declaring a jagged two-dimensional array, for which the
    outermost dimension is 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The inner dimensions aren’t specified in the declaration because, unlike a
    rectangular array, each inner array can be an arbitrary length. Each inner array
    is implicitly initialized to null rather than an empty array. Each inner array
    must be created manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'A jagged array can be initialized as follows (to create an array identical
    to the previous example, but with an additional element at the end):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: (The code shown in boldface can be omitted in declaration statements such as
    this.)
  prefs: []
  type: TYPE_NORMAL
- en: Simplified Array Initialization Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve already seen how to simplify array initialization expressions by omitting
    the `new` keyword and type declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Another approach is to use the `var` keyword, which instructs the compiler
    to implicitly type a local variable. Here are some simple examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The same principle can be applied to arrays, except that it can be taken one
    stage further. By omitting the type qualifier after the `new` keyword, the compiler
    infers the array type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how we can apply this to multidimensional arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Variables and Parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *variable* represents a storage location that has a modifiable value. A variable
    can be a *local variable*, *parameter* (*value*, *ref*, *out*, or *in*), *field*
    (*instance* or *static*), or *array element*.
  prefs: []
  type: TYPE_NORMAL
- en: The Stack and the Heap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *stack* and the *heap* are the places where variables reside. Each has very
    different lifetime semantics.
  prefs: []
  type: TYPE_NORMAL
- en: Stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *stack* is a block of memory for storing local variables and parameters.
    The stack logically grows and shrinks as a method or function is entered and exited.
    Consider the following method (to avoid distraction, input argument checking is
    ignored):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: This method is *recursive*, meaning that it calls itself. Each time the method
    is entered, a new `int` is allocated on the stack, and each time the method exits,
    the `int` is deallocated.
  prefs: []
  type: TYPE_NORMAL
- en: Heap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *heap* is the memory in which *objects* (i.e., reference type instances)
    reside. Whenever a new object is created, it is allocated on the heap, and a reference
    to that object is returned. During a program’s execution, the heap starts filling
    up as new objects are created. The runtime has a garbage collector that periodically
    deallocates objects from the heap so your program does not run out of memory.
    An object is eligible for deallocation as soon as it’s not referenced by anything
    that is itself alive.
  prefs: []
  type: TYPE_NORMAL
- en: Value type instances (and object references) live wherever the variable was
    declared. If the instance was declared as a field within a class type, or as an
    array element, that instance lives on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can’t explicitly delete objects in C# as you can in C++. An unreferenced
    object is eventually collected by the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: The heap also stores static fields and constants. Unlike objects allocated on
    the heap (which can be garbage-collected), these live until the application domain
    is torn down.
  prefs: []
  type: TYPE_NORMAL
- en: Definite Assignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C# enforces a definite assignment policy. In practice, this means that outside
    of an `unsafe` context, it’s impossible to access uninitialized memory. Definite
    assignment has three implications:'
  prefs: []
  type: TYPE_NORMAL
- en: Local variables must be assigned a value before they can be read.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function arguments must be supplied when a method is called (unless marked optional—see
    [“Optional parameters”](#optional_parameters)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All other variables (such as fields and array elements) are automatically initialized
    by the runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the following code results in a compile-time error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The following, however, outputs `0`, because fields are implicitly assigned
    a default value (whether instance or static):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Default Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All type instances have a default value. The default value for the predefined
    types is the result of a bitwise zeroing of memory and is `null` for reference
    types, `0` for numeric and enum types, `'\0'` for the `char` type, and `false`
    for the `bool` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can obtain the default value for any type by using the `default` keyword
    (this is particularly useful with generics, as you’ll see later). The default
    value in a custom value type (i.e., `struct`) is the same as the default value
    for each field defined by the custom type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A method can have a sequence of parameters. Parameters define the set of arguments
    that must be provided for that method. In this example, the method `Foo` has a
    single parameter named `p`, of type `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'You can control how parameters are passed with the `ref`, `out`, and `in` modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter modifier | Passed by | Variable must be definitely assigned |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| None | Value | Going *in* |'
  prefs: []
  type: TYPE_TB
- en: '| `ref` | Reference | Going *in* |'
  prefs: []
  type: TYPE_TB
- en: '| `in` | Reference (read-only) | Going *in* |'
  prefs: []
  type: TYPE_TB
- en: '| `out` | Reference | Going *out* |'
  prefs: []
  type: TYPE_TB
- en: Passing arguments by value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, arguments in C# are *passed by value*, which is by far the most
    common case. This means that a copy of the value is created when it is passed
    to the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Assigning `p` a new value does not change the contents of `x`, because `p` and
    `x` reside in different memory locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Passing a reference type argument by value copies the *reference* but not the
    object. In the following example, `Foo` sees the same `StringBuilder` object we
    instantiated (`sb`) but has an independent *reference* to it. In other words,
    `sb` and `fooSB` are separate variables that reference the same `StringBuilder`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Because `fooSB` is a *copy* of a reference, setting it to `null` doesn’t make
    `sb` null. (If, however, `fooSB` was declared and called with the `ref` modifier,
    `sb` *would* become null.)
  prefs: []
  type: TYPE_NORMAL
- en: The ref modifier
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To *pass by reference*, C# provides the `ref` parameter modifier. In the following
    example, `p` and `x` refer to the same memory locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Now assigning `p` a new value changes the contents of `x`. Notice how the `ref`
    modifier is required both when writing and calling the method. This makes it very
    clear what’s going on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A parameter can be passed by reference or by value, regardless of whether the
    parameter type is a reference type or a value type.
  prefs: []
  type: TYPE_NORMAL
- en: The out modifier
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An `out` argument is like a `ref` argument, except for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It need not be assigned before going into the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must be assigned before it comes *out* of the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `out` modifier is most commonly used to get multiple return values back
    from a method.
  prefs: []
  type: TYPE_NORMAL
- en: Out variables and discards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From C# 7, you can declare variables on the fly when calling methods with `out`
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'When calling methods with multiple `out` parameters, you can use an underscore
    to “discard” any in which you’re uninterested. Assuming `SomeBigMethod` has been
    defined with five `out` parameters, you can ignore all but the third, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: The in modifier
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From C# 7.2, you can prefix a parameter with the `in` modifier to prevent it
    from being modified within the method. This allows the compiler to avoid the overhead
    of copying the argument prior to passing it in, which can matter in the case of
    large custom value types (see [“Structs”](#structs)).
  prefs: []
  type: TYPE_NORMAL
- en: The params modifier
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `params` modifier, if applied to the last parameter of a method, allows
    the method to accept any number of arguments of a particular type. The parameter
    type must be declared as a (single-dimensional) array. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'You can call this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: If there are zero arguments in the `params` position, a zero-length array is
    created.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also supply a `params` argument as an ordinary array. The preceding
    call is semantically equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Optional parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Methods, constructors, and indexers can declare *optional parameters*. A parameter
    is optional if it specifies a *default value* in its declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'You can omit optional parameters when calling the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: The *default argument* of `23` is actually *passed* to the optional parameter
    `x`—the compiler bakes the value `23` into the compiled code at the *calling*
    side. The preceding call to `Foo` is semantically identical to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: because the compiler simply substitutes the default value of an optional parameter
    wherever it is used.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Adding an optional parameter to a public method that’s called from another assembly
    requires recompilation of both assemblies—just as though the parameter were mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: The default value of an optional parameter must be specified by a constant expression,
    a parameterless constructor of a value type, or a `default` expression. You cannot
    mark optional parameters with `ref` or `out`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mandatory parameters must occur *before* optional parameters in both the method
    declaration and the method call (the exception is with `params` arguments, which
    still always come last). In the following example, the explicit value of `1` is
    passed to `x`, and the default value of `0` is passed to `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: You can do the converse (pass a default value to `x` and an explicit value to
    `y`) by combining optional parameters with *named arguments*.
  prefs: []
  type: TYPE_NORMAL
- en: Named arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Rather than identifying an argument by position, you can identify an argument
    by name. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Named arguments can occur in any order. The following calls to `Foo` are semantically
    identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'You can mix named and positional arguments, as long as the named arguments
    appear last:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Named arguments are particularly useful in conjunction with optional parameters.
    For instance, consider the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'You can call this, supplying only a value for `d`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: This is particularly useful when you’re calling COM APIs.
  prefs: []
  type: TYPE_NORMAL
- en: var—Implicitly Typed Local Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is often the case that you declare and initialize a variable in one step.
    If the compiler is able to infer the type from the initialization expression,
    you can use the word `var` in place of the type declaration. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'This is precisely equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Because of this direct equivalence, implicitly typed variables are statically
    typed. For example, the following generates a compile-time error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: In the section [“Anonymous Types”](#anonymous_types), we describe a scenario
    in which the use of `var` is mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: Target-Typed new Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way to reduce lexical repetition is with *target-typed* `new` *expressions*
    (from C# 9):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'This is precisely equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'The principle is that you can call `new` without specifying a type name if
    the compiler is able to unambiguously infer it. Target-typed `new` expressions
    are particularly useful when the variable declaration and initialization are in
    different parts of your code. A common example is when you want to initialize
    a field in a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Target-typed `new` expressions are also helpful in the following scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Expressions and Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An *expression* essentially denotes a value. The simplest kinds of expressions
    are constants (such as `123`) and variables (such as `x`). Expressions can be
    transformed and combined with operators. An *operator* takes one or more input
    *operands* to output a new expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Complex expressions can be built because an operand can itself be an expression,
    such as the operand `(12 * 30)` in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Operators in C# can be classed as *unary*, *binary*, or *ternary*, depending
    on the number of operands they work on (one, two, or three). The binary operators
    always use *infix* notation, in which the operator is placed *between* the two
    operands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Operators that are intrinsic to the basic plumbing of the language are called
    *primary*; an example is the method call operator. An expression that has no value
    is called a *void expression*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Because a void expression has no value, you cannot use it as an operand to
    build more complex expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Assignment Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An *assignment expression* uses the `=` operator to assign the result of another
    expression to a variable. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'An assignment expression is not a void expression. It actually carries the
    assignment value and so can be incorporated into another expression. In the following
    example, the expression assigns 2 to `x` and 10 to `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'This style of expression can be used to initialize multiple values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'The *compound assignment operators* are syntactic shortcuts that combine assignment
    with another operator. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '(A subtle exception to this rule is with *events*, which we describe later:
    the `+=` and `-=` operators here are treated specially and map to the event’s
    `add` and `remove` accessors, respectively.)'
  prefs: []
  type: TYPE_NORMAL
- en: Operator Precedence and Associativity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an expression contains multiple operators, *precedence* and *associativity*
    determine the order of their evaluation. Operators with higher precedence execute
    before operators of lower precedence. If the operators have the same precedence,
    the operator’s associativity determines the order of evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: Precedence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The expression `1 + 2 * 3` is evaluated as `1 + (2 * 3)` because `*` has a higher
    precedence than `+`.
  prefs: []
  type: TYPE_NORMAL
- en: Left-associative operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Binary operators (except for assignment, lambda, and null-coalescing operators)
    are *left-associative*; in other words, they are evaluated from left to right.
    For example, the expression `8/4/2` is evaluated as `(8/4)/2` due to left associativity.
    Of course, you can insert your own parentheses to change evaluation order.
  prefs: []
  type: TYPE_NORMAL
- en: Right-associative operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The assignment and lambda operators, null-coalescing operator, and (ternary)
    conditional operator are *right-associative*; in other words, they are evaluated
    from right to left. Right associativity allows multiple assignments such as `x=y=3`
    to compile: it works by first assigning `3` to `y` and then assigning the result
    of that expression (`3`) to `x`.'
  prefs: []
  type: TYPE_NORMAL
- en: Operator Table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following table lists C#’s operators in order of precedence. Operators listed
    under the same subheading have the same precedence. We explain user-overloadable
    operators in the section [“Operator Overloading”](#operator_overloading).
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator symbol | Operator name | Example | Overloadable |  |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Primary (highest precedence)** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `.` | Member access | `x.y` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '| `?.` | Null-conditional | `x?.y` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '| `!` (postfix) | Null-forgiving | `x!.y` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '| `->` | Pointer to struct (unsafe) | `x->y` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '| `()` | Function call | `x()` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '| `[]` | Array/index | `a[x]` | Via indexer |  |'
  prefs: []
  type: TYPE_TB
- en: '| `++` | Post-increment | `x++` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| `--` | Post-decrement | `x--` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| `new` | Create instance | `new Foo()` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '| `stackalloc` | Stack allocation | `stackalloc(10)` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '| `typeof` | Get type from identifier | `typeof(int)` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '| `nameof` | Get name of identifier | `nameof(x)` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '| `checked` | Integral overflow check on | `checked(x)` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '| `unchecked` | Integral overflow check off | `unchecked(x)` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '| `default` | Default value | `default(char)` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '| `sizeof` | Get size of struct | `sizeof(int)` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '| **Unary** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `await` | Await | `await myTask` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | Positive value of | `+x` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| `-` | Negative value of | `-x` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| `!` | Not | `!x` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| `~` | Bitwise complement | `~x` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| `++` | Pre-increment | `++x` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| `--` | Pre-decrement | `--x` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| `()` | Cast | `(int)x` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | Index from end | `array[^1]` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | Value at address (unsafe) | `*x` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '| `&` | Address of value (unsafe) | `&x` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '| **Range** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `..` `..^` | Range of indices | `x..y` `x..^y` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '| **Switch and with** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `switch` | Switch expression | `num switch {` `1 => true,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`_ => false`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}` | No |  |'
  prefs: []
  type: TYPE_NORMAL
- en: '| `with` | With expression | `rec with` `{ X = 123 }` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '| **Multiplicative** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | Multiply | `x * y` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| `/` | Divide | `x / y` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| `%` | Remainder | `x % y` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| **Additive** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | Add | `x + y` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| `-` | Subtract | `x - y` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| **Shift** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `<<` | Shift left | `x << 1` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| `>>` | Shift right | `x >> 1` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| `>>>` | Unsigned shift right | `x >>> 1` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| **Relational** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `<` | Less than | `x < y` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| `>` | Greater than | `x > y` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| `<=` | Less than or equal to | `x <= y` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| `>=` | Greater than or equal to | `x >= y` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| `is` | Type is or is subclass of | `x is y` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '| `as` | Type conversion | `x as y` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '| **Equality** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `==` | Equals | `x == y` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| `!=` | Not equals | `x != y` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| **Bitwise And** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `&` | And | `x & y` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| **Bitwise Xor** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | Exclusive Or | `x ^ y` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| **Bitwise Or** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;` | Or | `x &#124; y` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| **Conditional And** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `&&` | Conditional And | `x && y` | Via `&` |  |'
  prefs: []
  type: TYPE_TB
- en: '| **Conditional Or** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;&#124;` | Conditional Or | `x &#124;&#124; y` | Via `&#124;` |  |'
  prefs: []
  type: TYPE_TB
- en: '| **Null coalescing** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `??` | Null coalescing | `x ?? y` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '| **Conditional (Ternary)** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `? :` | Conditional | `isTrue ? thenThis : elseThis` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '| **Assignment and lambda (lowest precedence)** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `=` | Assign | `x = y` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '| `*=` | Multiply self by | `x *= 2` | Via `*` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `/=` | Divide self by | `x /= 2` | Via `/` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `+=` | Add to self | `x += 2` | Via `+` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `-=` | Subtract from self | `x -= 2` | Via `-` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `<<=` | Shift self left by | `x <<= 2` | Via `<<` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `>>=` | Shift self right by | `x >>= 2` | Via `>>` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `>>>=` | Unsigned shift self right by | `x >>>= 2` | Via `>>>` |'
  prefs: []
  type: TYPE_TB
- en: '| `&=` | And self by | `x &= 2` | Via `&` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `^=` | Exclusive-Or self by | `x ^= 2` | Via `^` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;=` | Or self by | `x &#124;= 2` | Via `&#124;` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `=>` | Lambda | `x => x + 1` | No |  |'
  prefs: []
  type: TYPE_TB
- en: Null Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C# provides three operators to make it easier to work with nulls: the *null-coalescing
    operator*, the *null-conditional operator*, and the *null-coalescing assignment
    operator*.'
  prefs: []
  type: TYPE_NORMAL
- en: Null-Coalescing Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `??` operator is the *null**-**coalescing operator*. It says, “If the operand
    to the left is non-null, give it to me; otherwise, give me another value.” For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: If the lefthand expression is non-null, the righthand expression is never evaluated.
    The null-coalescing operator also works with nullable value types (see [“Nullable
    Value Types”](#nullable_value_types)).
  prefs: []
  type: TYPE_NORMAL
- en: Null-Coalescing Assignment Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `??=` operator (introduced in C# 8) is the *null-coalescing assignment
    operator*. It says, “If the operand to the left is null, assign the right operand
    to the left operand.” Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Null-Conditional Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `?.` operator is the *null-conditional* or “Elvis” operator. It allows
    you to call methods and access members just like the standard dot operator, except
    that if the operand on the left is null, the expression evaluates to null instead
    of throwing a `NullReferenceException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'The last line is equivalent to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Null-conditional expressions also work with indexers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon encountering a null, the Elvis operator short-circuits the remainder of
    the expression. In the following example, `s` evaluates to null, even with a standard
    dot operator between `ToString()` and `ToUpper()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Repeated use of Elvis is necessary only if the operand immediately to its left
    might be null. The following expression is robust to both `x` being null and `x.y`
    being null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to the following (except that `x.y` is evaluated only once):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'The final expression must be capable of accepting a null. The following is
    illegal because `int` cannot accept a null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'We can fix this with the use of nullable value types (see [“Nullable Value
    Types”](#nullable_value_types)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the null-conditional operator to call a void method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: If `someObject` is null, this becomes a “no-operation” rather than throwing
    a `NullReferenceException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The null-conditional operator can be used with the commonly used type members
    that we describe in [“Classes”](#classes), including *methods*, *fields*, *properties*,
    and *indexers*. It also combines well with the null-coalescing operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions comprise statements that execute sequentially in the textual order
    in which they appear. A *statement block* is a series of statements appearing
    between braces (the `{}` tokens).
  prefs: []
  type: TYPE_NORMAL
- en: Declaration Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A variable declaration introduces a new variable, optionally initializing it
    with an expression. You can declare multiple variables of the same type in a comma-separated
    list. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'A constant declaration is like a variable declaration, except that it cannot
    be changed after it has been declared, and the initialization must occur with
    the declaration (more on this in [“Constants”](#constants)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Local variable scope
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The scope of a local variable or local constant variable extends throughout
    the current block. You cannot declare another local variable with the same name
    in the current block or in any nested blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Expression Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Expression statements are expressions that are also valid statements. In practice,
    this means expressions that “do” something; in other words:'
  prefs: []
  type: TYPE_NORMAL
- en: Assign or modify a variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiate an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call a method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Expressions that do none of these are not valid statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'When you call a constructor or a method that returns a value, you’re not obliged
    to use the result. However, unless the constructor or method changes state, the
    statement is useless:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Selection Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Selection statements conditionally control the flow of program execution.
  prefs: []
  type: TYPE_NORMAL
- en: The if statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An `if` statement executes a statement if a `bool` expression is true. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'The statement can be a code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: The else clause
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An `if` statement can optionally feature an `else` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'Within an `else` clause, you can nest another `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Changing the flow of execution with braces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An `else` clause always applies to the immediately preceding `if` statement
    in the statement block. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'This is semantically identical to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'You can change the execution flow by moving the braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'C# has no “elseif” keyword; however, the following pattern achieves the same
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Switch statements let you branch program execution based on a selection of
    possible values that a variable might have. Switch statements can result in cleaner
    code than multiple `if` statements because switch statements require an expression
    to be evaluated only once. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'The values in each case expression must be constants, which restricts their
    allowable types to the built-in numeric types and the `bool`, `char`, `string`,
    and `enum` types. At the end of each `case` clause, you must say explicitly where
    execution is to go next with some kind of jump statement. Here are the options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`break` (jumps to the end of the `switch` statement)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`goto case *x*` (jumps to another `case` clause)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`goto default` (jumps to the `default` clause)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any other jump statement—namely, `return`, `throw`, `continue`, or `goto *label*`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When more than one value should execute the same code, you can list the common
    `case`s sequentially:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: This feature of a `switch` statement can be pivotal in terms of producing cleaner
    code than multiple `if`-`else` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Switching on types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From C# 7, you can switch on *type*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: (The `object` type allows for a variable of any type—see [“Inheritance”](#inheritance)
    and [“The object Type”](#the_object_type).)
  prefs: []
  type: TYPE_NORMAL
- en: Each *case* clause specifies a type upon which to match, and a variable upon
    which to assign the typed value if the match succeeds. Unlike with constants,
    there’s no restriction on what types you can use. The optional `when` clause specifies
    a condition that must be satisfied for the case to match.
  prefs: []
  type: TYPE_NORMAL
- en: The order of the case clauses is relevant when you’re switching on type (unlike
    when you’re switching on constants). An exception to this rule is the `default`
    clause, which is executed last, regardless of where it appears.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can stack multiple case clauses. The `Console.WriteLine` in the following
    code will execute for any floating-point type greater than 1,000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the compiler lets us consume the variables `f`, `d`, and `m`,
    *only* in the `when` clauses. When we call `Console.WriteLine`, it’s unknown as
    to which one of those three variables will be assigned, so the compiler puts all
    of them out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: Switch expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From C# 8, you can also use `switch` in the context of an *expression*. Assuming
    `cardNumber` is of type `int`, the following illustrates its use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the `switch` keyword appears *after* the variable name and that
    the case clauses are expressions (terminated by commas) rather than statements.
    You can also switch on multiple values (*tuples*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: Iteration Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C# enables a sequence of statements to execute repeatedly with the `while`,
    `do`-`while`, `for`, and `foreach` statements.
  prefs: []
  type: TYPE_NORMAL
- en: while and do-while loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`while` loops repeatedly execute a body of code while a `bool` expression is
    true. The expression is tested *before* the body of the loop is executed. For
    example, the following writes `012`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '`do`-`while` loops differ in functionality from `while` loops only in that
    they test the expression *after* the statement block has executed (ensuring that
    the block is always executed at least once). Here’s the preceding example rewritten
    with a `do`-`while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: for loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`for` loops are like `while` loops with special clauses for *initialization*
    and *iteration* of a loop variable. A `for` loop contains three clauses as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: The *init-clause* executes before the loop begins and typically initializes
    one or more *iteration* variables.
  prefs: []
  type: TYPE_NORMAL
- en: The *condition-clause* is a `bool` expression that is tested *before* each loop
    iteration. The body executes while this condition is true.
  prefs: []
  type: TYPE_NORMAL
- en: The *iteration-clause* is executed *after* each iteration of the body. It’s
    typically used to update the iteration variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following prints the numbers 0 through 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'The following prints the first 10 Fibonacci numbers (where each number is the
    sum of the previous two):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'Any of the three parts of the `for` statement can be omitted. You can implement
    an infinite loop such as the following (though `while(true)` can be used instead):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: foreach loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `foreach` statement iterates over each element in an enumerable object.
    Most of the .NET types that represent a set or list of elements are enumerable.
    For example, both an array and a string are enumerable. Here is an example of
    enumerating over the characters in a string, from the first character through
    the last:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: We define enumerable objects in [“Enumeration and Iterators”](#enumeration_and_iterators).
  prefs: []
  type: TYPE_NORMAL
- en: Jump Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The C# jump statements are `break`, `continue`, `goto`, `return`, and `throw`.
    We cover the `throw` keyword in [“try Statements and Exceptions”](#try_statements_and_exceptions).
  prefs: []
  type: TYPE_NORMAL
- en: The break statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `break` statement ends the execution of the body of an iteration or `switch`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: The continue statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `continue` statement forgoes the remaining statements in the loop and makes
    an early start on the next iteration. The following loop *skips* even numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: The goto statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `goto` statement transfers execution to a label (denoted with a colon suffix)
    within a statement block. The following iterates the numbers 1 through 5, mimicking
    a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: The return statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `return` statement exits the method and must return an expression of the
    method’s return type if the method is nonvoid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: A `return` statement can appear anywhere in a method (except in a `finally`
    block) and can be used more than once.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A *namespace* is a domain within which type names must be unique. Types are
    typically organized into hierarchical namespaces—both to avoid naming conflicts
    and to make type names easier to find. For example, the `RSA` type that handles
    public key encryption is defined within the following namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'A namespace forms an integral part of a type’s name. The following code calls
    `RSA`’s `Create` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Namespaces are independent of assemblies, which are units of deployment such
    as an *.exe* or *.dll*.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces also have no impact on member accessibility—`public`, `internal`,
    `private`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `namespace` keyword defines a namespace for types within that block. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'The dots in the namespace indicate a hierarchy of nested namespaces. The code
    that follows is semantically identical to the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: You can refer to a type with its *fully qualified name*, which includes all
    namespaces from the outermost to the innermost. For example, you could refer to
    `Class1` in the preceding example as `Outer.Middle.Inner.Class1`.
  prefs: []
  type: TYPE_NORMAL
- en: Types not defined in any namespace are said to reside in the *global namespace*.
    The global namespace also includes top-level namespaces, such as `Outer` in our
    example.
  prefs: []
  type: TYPE_NORMAL
- en: File-Scoped Namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often, you will want all the types in a file to be defined in one namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'From C# 10, you can accomplish this with a *file-scoped namespace*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: File-scoped namespaces reduce clutter and eliminate an unnecessary level of
    indentation.
  prefs: []
  type: TYPE_NORMAL
- en: The using Directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `using` directive *imports* a namespace and is a convenient way to refer
    to types without their fully qualified names. For example, you can refer to `Class1`
    in the preceding example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: A `using` directive can be nested within a namespace itself to limit the scope
    of the directive.
  prefs: []
  type: TYPE_NORMAL
- en: The global using Directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From C# 10, if you prefix a `using` directive with the `global` keyword, the
    directive will apply to all files in the project or compilation unit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: This lets you centralize common imports and avoid repeating the same directives
    in every file.
  prefs: []
  type: TYPE_NORMAL
- en: '`global using` directives must precede nonglobal directives and cannot appear
    inside namespace declarations. The global directive can be used with `using static`.'
  prefs: []
  type: TYPE_NORMAL
- en: using static
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `using static` directive imports a *type* rather than a namespace. All
    static members of that type can then be used without being qualified with the
    type name. In the following example, we call the `Console` class’s static `WriteLine`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: The `using static` directive imports all accessible static members of the type,
    including fields, properties, and nested types. You can also apply this directive
    to enum types (see [“Enums”](#enums)), in which case their members are imported.
    Should an ambiguity arise between multiple static imports, the C# compiler is
    unable to infer the correct type from the context and will generate an error.
  prefs: []
  type: TYPE_NORMAL
- en: Rules Within a Namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Name scoping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Names declared in outer namespaces can be used unqualified within inner namespaces.
    In this example, `Class1` does not need qualification within `Inner`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to refer to a type in a different branch of your namespace hierarchy,
    you can use a partially qualified name. In the following example, we base `SalesReport`
    on `Common.ReportBase`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: Name hiding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the same type name appears in both an inner and an outer namespace, the inner
    name wins. To refer to the type in the outer namespace, you must qualify its name.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: All type names are converted to fully qualified names at compile time. Intermediate
    Language (IL) code contains no unqualified or partially qualified names.
  prefs: []
  type: TYPE_NORMAL
- en: Repeated namespaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can repeat a namespace declaration, as long as the type names within the
    namespaces don’t conflict:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: The classes can even span source files and assemblies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The global:: qualifier'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Occasionally, a fully qualified type name might conflict with an inner name.
    You can force C# to use the fully qualified type name by prefixing it with `global::`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: Aliasing Types and Namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Importing a namespace can result in type-name collision. Rather than importing
    the whole namespace, you can import just the specific types you need, giving each
    type an alias. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'An entire namespace can be aliased, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: Alias any type (C# 12)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From C# 12, the `using` directive can alias any kind of type, including, for
    instance, arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: You can also alias tuples (see [“Tuples”](#tuples)).
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A *class* is the most common kind of reference type. The simplest possible
    class declaration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: 'A more complex class optionally has the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Preceding the keyword `class` | *Attributes* and *class modifiers*. The non-nested
    class modifiers are `public`, `internal`, `abstract`, `sealed`, `static`, `unsafe`,
    and `partial`. |'
  prefs: []
  type: TYPE_TB
- en: '| Following `Foo` | *Generic type parameters* and *constraints*, a *base class*,
    and *interfaces*. |'
  prefs: []
  type: TYPE_TB
- en: '| Within the braces | *Class members* (these are *methods*, *properties*, *indexers*,
    *events*, *fields*, *constructors*, *overloaded operators*, *nested types*, and
    a *finalizer*). |'
  prefs: []
  type: TYPE_TB
- en: Fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *field* is a variable that is a member of a class or struct. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: A field can have the `readonly` modifier to prevent it from being modified after
    construction. A read-only field can be assigned only in its declaration or within
    the enclosing type’s constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Field initialization is optional. An uninitialized field has a default value
    (`0`, `'\0'`, `null`, `false`). Field initializers run before constructors in
    the order in which they appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'For convenience, you can declare multiple fields of the same type in a comma-separated
    list. This is a convenient way for all the fields to share the same attributes
    and field modifiers. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: Constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *constant* is evaluated statically at compile time, and the compiler literally
    substitutes its value whenever used (rather like a macro in C++). A constant can
    be any of the built-in numeric types: `bool`, `char`, `string`, or an enum type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A constant is declared with the `const` keyword and must be initialized with
    a value. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: 'A constant is much more restrictive than a `static readonly` field—both in
    the types you can use and in field initialization semantics. A constant also differs
    from a `static readonly` field in that the evaluation of the constant occurs at
    compile time. Constants can also be declared local to a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *method* performs an action in a series of statements. A method can receive
    *input* data from the caller by specifying *parameters* and send *output* data
    back to the caller by specifying a *return type*. A method can specify a `void`
    return type, indicating that it doesn’t return any value to its caller. A method
    can also output data back to the caller via `ref` and `out` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: A method’s *signature* must be unique within the type. A method’s signature
    comprises its name and parameter types in order (but not the parameter *names*
    nor the return type).
  prefs: []
  type: TYPE_NORMAL
- en: Expression-bodied methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A method that comprises a single expression, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'can be written more tersely as an *expression-bodied method*. A fat arrow replaces
    the braces and `return` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: 'Expression-bodied functions can also have a `void` return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: Local methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can define a method within another method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: The local method (`Cube`, in this case) is visible only to the enclosing method
    (`WriteCubes`). This simplifies the containing type and instantly signals to anyone
    looking at the code that `Cube` is used nowhere else. Local methods can access
    the local variables and parameters of the enclosing method. This has a number
    of consequences, which we describe in [“Capturing Outer Variables”](#capturing_outer_variables).
  prefs: []
  type: TYPE_NORMAL
- en: Local methods can appear within other function kinds, such as property accessors,
    constructors, and so on, and even within other local methods. Local methods can
    be iterators or asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods declared in top-level statements are implicitly local; we can demonstrate
    this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: Static local methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding the `static` modifier to a local method (from C# 8) prevents it from
    seeing the local variables and parameters of the enclosing method. This helps
    to reduce coupling and prevents the local method from accidentally referring to
    variables in the containing method.
  prefs: []
  type: TYPE_NORMAL
- en: Overloading methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Local methods cannot be overloaded. This means that methods declared in top-level
    statements (which are treated as local methods) cannot be overloaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'A type can overload methods (have multiple methods with the same name) as long
    as the parameter types are different. For example, the following methods can all
    coexist in the same type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: Instance Constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Constructors run initialization code on a class or struct. A constructor is
    defined like a method, except that the method name and return type are reduced
    to the name of the enclosing type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'Single-statement constructors can be written as expression-bodied members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: 'A class or struct can overload constructors. One overload can call another,
    using the `this` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: When one constructor calls another, the *called constructor* executes first.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can pass an *expression* into another constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: The expression itself cannot make use of the `this` reference, for example,
    to call an instance method. It can, however, call static methods.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit parameterless constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For classes, the C# compiler automatically generates a parameterless public
    constructor if and only if you do not define any constructors. However, as soon
    as you define at least one constructor, the parameterless constructor is no longer
    automatically generated.
  prefs: []
  type: TYPE_NORMAL
- en: Nonpublic constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Constructors do not need to be public. A common reason to have a nonpublic constructor
    is to control instance creation via a static method call. The static method could
    be used to return an object from a pool rather than creating a new object or to
    return a specialized subclass chosen based on input arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Deconstructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Whereas a constructor typically takes a set of values (as parameters) and assigns
    them to fields, a deconstructor (C# 7+) does the reverse and assigns fields back
    to a set of variables. A deconstruction method must be called `Deconstruct` and
    have one or more `out` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: 'To call the deconstructor, you use the following special syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: 'The second line is the deconstructing call. It creates two local variables
    and then calls the `Deconstruct` method. Our deconstructing call is equivalent
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: 'Deconstructing calls allow implicit typing, so we could shorten our call to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: 'Or simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'If the variables into which you’re deconstructing are already defined, omit
    the types altogether; this is called a *deconstructing assignment*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: You can offer the caller a range of deconstruction options by overloading the
    `Deconstruct` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `Deconstruct` method can be an extension method (see [“Extension Methods”](#extension_methods)).
    This is a useful trick if you want to deconstruct types that you did not author.
  prefs: []
  type: TYPE_NORMAL
- en: 'From C# 10, you can mix and match existing and new variables when deconstructing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: Object Initializers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To simplify object initialization, the accessible fields or properties of an
    object can be initialized via an *object initializer* directly after construction.
    For example, consider the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'Using object initializers, you can instantiate `Bunny` objects as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: The this Reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `this` reference refers to the instance itself. In the following example,
    the `Marry` method uses `this` to set the `partner`’s `mate` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'The `this` reference also disambiguates a local variable or parameter from
    a field. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: The `this` reference is valid only within nonstatic members of a class or struct.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Properties look like fields from the outside, but internally they contain logic,
    like methods do. For example, you can’t determine by looking at the following
    code whether `CurrentPrice` is a field or a property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: 'A property is declared like a field but with a `get`/`set` block added. Here’s
    how to implement `CurrentPrice` as a property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '`get` and `set` denote property *accessors*. The `get` accessor runs when the
    property is read. It must return a value of the property’s type. The `set` accessor
    runs when the property is assigned. It has an implicit parameter named `value`
    of the property’s type that you typically assign to a private field (in this case,
    `currentPrice`).'
  prefs: []
  type: TYPE_NORMAL
- en: Although properties are accessed in the same way as fields, they differ in that
    they give the implementer complete control over getting and setting its value.
    This control enables the implementer to choose whatever internal representation
    is needed, without exposing the internal details to the user of the property.
    In this example, the `set` method could throw an exception if `value` was outside
    a valid range of values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Throughout this book, we use public fields to keep the examples free of distraction.
    In a real application, you would typically favor public properties over public
    fields to promote encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: A property is read-only if it specifies only a `get` accessor, and it is write-only
    if it specifies only a `set` accessor. Write-only properties are rarely used.
  prefs: []
  type: TYPE_NORMAL
- en: 'A property typically has a dedicated backing field to store the underlying
    data. However, it doesn’t need to; it can instead return a value computed from
    other data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: Expression-bodied properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can declare a read-only property, such as the preceding one, more tersely
    as an *expression-bodied property*. A fat arrow replaces all the braces and the
    `get` and `return` keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: 'From C# 7, `set` accessors can be expression-bodied too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: Automatic properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most common implementation for a property is a getter and/or setter that
    simply reads and writes to a private field of the same type as the property. An
    *automatic property* declaration instructs the compiler to provide this implementation.
    We can improve the first example in this section by declaring `CurrentPrice` as
    an automatic property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: The compiler automatically generates a private backing field of a compiler-generated
    name that cannot be referred to. The `set` accessor can be marked `private` or
    `protected` if you want to expose the property as read-only to other types.
  prefs: []
  type: TYPE_NORMAL
- en: Property initializers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can add a *property initializer* to automatic properties, just as with
    fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives `CurrentPrice` an initial value of 123\. Properties with an initializer
    can be read-only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: Just as with read-only fields, read-only automatic properties can also be assigned
    in the type’s constructor. This is useful in creating *immutable* (read-only)
    types.
  prefs: []
  type: TYPE_NORMAL
- en: get and set accessibility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `get` and `set` accessors can have different access levels. The typical
    use case for this is to have a `public` property with an `internal` or `private`
    access modifier on the setter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: Notice that you declare the property itself with the more permissive access
    level (`public`, in this case) and add the modifier to the accessor you want to
    be *less* accessible.
  prefs: []
  type: TYPE_NORMAL
- en: Init-only setters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From C# 9, you can declare a property accessor with `init` instead of `set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: 'These *init-only* properties act like read-only properties, except that they
    can also be set via an object initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, the property cannot be altered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: Init-only properties cannot even be set from inside their class, except via
    their property initializer, the constructor, or another init-only accessor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The alternative to init-only properties is to have read-only properties that
    you populate via a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: Should the class be part of a public library, this approach makes versioning
    difficult, in that adding an optional parameter to the constructor at a later
    date breaks binary compatibility with consumers (whereas adding a new init-only
    property breaks nothing).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Init-only properties have another significant advantage, which is that they
    allow for nondestructive mutation when used in conjunction with records (see [“Records”](#records)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as with ordinary `set` accessors, init-only accessors can provide an implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the `_x` field is read-only: init-only setters are permitted to
    modify `readonly` fields in their own class. (Without this feature, `_x` would
    need to be writable, and the class would fail at being internally immutable.)'
  prefs: []
  type: TYPE_NORMAL
- en: Indexers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Indexers provide a natural syntax for accessing elements in a class or struct
    that encapsulate a list or dictionary of values. Indexers are similar to properties
    but are accessed via an index argument rather than a property name. The `string`
    class has an indexer that lets you access each of its `char` values via an `int`
    index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax for using indexers is like that for using arrays, except that the
    index argument(s) can be of any type(s). You can call indexers null-conditionally
    by inserting a question mark before the square bracket (see [“Null Operators”](#null_operators)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: Implementing an indexer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To write an indexer, define a property called `this`, specifying the arguments
    in square brackets. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how we could use this indexer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: 'A type can declare multiple indexers, each with parameters of different types.
    An indexer can also take more than one parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: 'If you omit the `set` accessor, an indexer becomes read-only, and expression-bodied
    syntax can be used to shorten its definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: Using indices and ranges with indexers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can support indices and ranges (see [“Indices and Ranges”](#indices_and_ranges))
    in your own classes by defining an indexer with a parameter type of `Index` or
    `Range`. We could extend our previous example by adding the following indexers
    to the `Sentence` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: 'This then enables the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: Primary Constructors (C# 12)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From C# 12, you can include a parameter list directly after a class (or struct)
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: 'This instructs the compiler to automatically build a *primary constructor*
    using the *primary constructor parameters* (`firstName` and `lastName`) so that
    we can instantiate our class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: Primary constructors are useful for prototyping and other simple scenarios.
    The alternative would be to define fields to store `firstName` and `lastName`
    and then write a constructor to populate them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor that C# builds is called primary because any additional constructors
    that you choose to (explicitly) write must invoke it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that primary constructor parameters are *always populated*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: C# also provides *records*, which we cover in [“Records”](#records). Records
    also support primary constructors; however, the compiler takes an extra step with
    records and generates (by default) a public init-only property for each primary
    constructor parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Primary constructors are best suited to simple scenarios due to the following
    limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: You cannot add extra initialization code to a primary constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although it’s easy to expose a primary constructor parameter as a public property,
    you cannot easily incorporate validation logic unless the property is read-only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Primary constructors displace the default parameterless constructor that C#
    would otherwise generate.
  prefs: []
  type: TYPE_NORMAL
- en: Primary constructor semantics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To understand how primary constructors work, consider how an ordinary constructor
    behaves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: When the code inside this constructor finishes executing, parameters `firstName`
    and `lastName` disappear out of scope and cannot be subsequently accessed. In
    contrast, a primary constructor’s parameters do *not* disappear out of scope and
    can be subsequently accessed from anywhere within the class, for the life of the
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Primary constructor parameters are special C# constructs, not *fields*, although
    the compiler does end up generating hidden fields behind the scenes to store their
    values if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Primary constructors and field/property initializers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The accessibility of primary constructor parameters extends to field and property
    initializers. In the following example, we use field and property initializers
    to assign `firstName` to a public field and `lastName` to a public property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: Masking primary constructor parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Fields (or properties) can reuse primary constructor parameter names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: In this scenario, the field or property takes precedence, thereby masking the
    primary constructor parameter, *except* on the righthand side of field and property
    initializers (shown in boldface).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Just like ordinary parameters, primary constructor parameters are writable.
    Masking them with a same-named `readonly` field (as in our example) effectively
    protects them from subsequent modification.
  prefs: []
  type: TYPE_NORMAL
- en: Validating primary constructor parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [“throw expressions”](#throw_expressions), we will describe how to throw
    exceptions when encountering scenarios such as invalid data. Here’s a preview
    to illustrate how this can be used with primary constructors to validate `lastName`
    upon construction, ensuring that it cannot be null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '(Remember that code within a field or property initializer executes when the
    object is constructed—not when the field or property is accessed.) The same technique
    can also expose `lastName` as a public read-only property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: Static Constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A static constructor executes once per *type*, rather than once per *instance*.
    A type can define only one static constructor, and it must be parameterless and
    have the same name as the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: 'The runtime automatically invokes a static constructor just prior to the type
    being used. Two things trigger this: instantiating the type and accessing a static
    member in the type.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If a static constructor throws an unhandled exception, that type becomes *unusable*
    for the life of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'From C# 9, you can also define *module initializers*, which execute once per
    assembly (when the assembly is first loaded). To define a module initializer,
    write a static void method and then apply the `[ModuleInitializer]` attribute
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: Static field initializers run just *before* the static constructor is called.
    If a type has no static constructor, static field initializers will execute just
    prior to the type being used—or *anytime earlier* at the whim of the runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Static Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A class marked as `static` cannot be instantiated or subclassed, and must be
    composed solely of static members. The `Sys⁠tem.​Console` and `System.Math` classes
    are good examples of static classes.
  prefs: []
  type: TYPE_NORMAL
- en: Finalizers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Finalizers* are class-only methods that execute before the garbage collector
    reclaims the memory for an unreferenced object. The syntax for a finalizer is
    the name of the class prefixed with the `~` symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: C# translates a finalizer into a method that overrides the `Finalize` method
    in the `object` class. We discuss garbage collection and finalizers fully in Chapter
    12 of *C# 12 in a Nutshell*.
  prefs: []
  type: TYPE_NORMAL
- en: Single-statement finalizers can be written with expression-bodied syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Partial Types and Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Partial types* allow a type definition to be split—typically across multiple
    files. A common scenario is for a partial class to be autogenerated from some
    other source (e.g., a Visual Studio template) and for that class to be augmented
    with additional hand-authored methods. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: Each participant must have the `partial` declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Participants cannot have conflicting members. A constructor with the same parameters,
    for instance, cannot be repeated. Partial types are resolved entirely by the compiler,
    which means that each participant must be available at compile time and must reside
    in the same assembly.
  prefs: []
  type: TYPE_NORMAL
- en: A base class can be specified on a single participant or on multiple participants
    (as long as the base class that you specify is the same). In addition, each participant
    can independently specify interfaces to implement. We cover base classes and interfaces
    in [“Inheritance”](#inheritance) and [“Interfaces”](#interfaces).
  prefs: []
  type: TYPE_NORMAL
- en: Partial methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A partial type can contain *partial methods*. These let an autogenerated partial
    type provide customizable hooks for manual authoring. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: 'A partial method consists of two parts: a *definition* and an *implementation*.
    The definition is typically written by a code generator, and the implementation
    is typically manually authored. If an implementation is not provided, the definition
    of the partial method is compiled away (as is the code that calls it). This allows
    autogenerated code to be liberal in providing hooks, without having to worry about
    bloat. Partial methods must be `void` and are implicitly `private`.'
  prefs: []
  type: TYPE_NORMAL
- en: Extended partial methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Extended partial methods* (from C# 9) are designed for the reverse code generation
    scenario, where a programmer defines hooks that a code generator implements. An
    example of where this might occur is with *source generators*, a Roslyn feature
    that lets you feed the compiler an assembly that automatically generates portions
    of your code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A partial method declaration is *extended* if it begins with an accessibility
    modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: 'The presence of the accessibility modifier doesn’t just affect accessibility:
    it tells the compiler to treat the declaration differently.'
  prefs: []
  type: TYPE_NORMAL
- en: Extended partial methods *must* have implementations; they do not melt away
    if unimplemented. In this example, both `M1` and `M2` must have implementations
    because they each specify accessibility modifiers (`public` and `private`).
  prefs: []
  type: TYPE_NORMAL
- en: Because they cannot melt away, extended partial methods can return any type
    and can include `out` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The nameof Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `nameof` operator returns the name of any symbol (type, member, variable,
    and so on) as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: Its advantage over simply specifying a string is that of static type checking.
    Tools such as Visual Studio can understand the symbol reference, so if you rename
    the symbol in question, all of its references will be renamed too.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify the name of a type member such as a field or property, include the
    type as well. This works with both static and instance members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: 'This evaluates to `"Length"`. To return `"StringBuilder.Length"`, you would
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A class can *inherit* from another class to extend or customize the original
    class. Inheriting from a class lets you reuse the functionality in that class
    instead of building it from scratch. A class can inherit from only a single class
    but can itself be inherited by many classes, thus forming a class hierarchy. In
    this example, we begin by defining a class called `Asset`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define classes called `Stock` and `House`, which will inherit from
    `Asset`. `Stock` and `House` get everything an `Asset` has, plus any additional
    members that they define:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how we can use these classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: The *subclasses*, `Stock` and `House`, inherit the `Name` field from the *base
    class*, `Asset`.
  prefs: []
  type: TYPE_NORMAL
- en: Subclasses are also called *derived classes*.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'References are *polymorphic*. This means a variable of type *x* can refer to
    an object that subclasses *x*. For instance, consider the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: This method can display both a `Stock` and a `House` because they are both `Asset`s.
    Polymorphism works on the basis that subclasses (`Stock` and `House`) have all
    the features of their base class (`Asset`). The converse, however, is not true.
    If `Display` were rewritten to accept a `House`, you could not pass in an `Asset`.
  prefs: []
  type: TYPE_NORMAL
- en: Casting and Reference Conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An object reference can be:'
  prefs: []
  type: TYPE_NORMAL
- en: Implicitly *upcast* to a base class reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicitly *downcast* to a subclass reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Upcasting and downcasting between compatible reference types performs *reference
    conversions*: a new reference is created that points to the *same* object. An
    upcast always succeeds; a downcast succeeds only if the object is suitably typed.'
  prefs: []
  type: TYPE_NORMAL
- en: Upcasting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An upcast operation creates a base class reference from a subclass reference.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: 'After the upcast, variable `a` still references the same `Stock` object as
    variable `msft`. The object being referenced is not itself altered or converted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: 'Although `a` and `msft` refer to the same object, `a` has a more restrictive
    view on that object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: The last line generates a compile-time error because the variable `a` is of
    type `Asset`, even though it refers to an object of type `Stock`. To get to its
    `SharesOwned` field, you must *downcast* the `Asset` to a `Stock`.
  prefs: []
  type: TYPE_NORMAL
- en: Downcasting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A downcast operation creates a subclass reference from a base class reference.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: 'As with an upcast, only references are affected—not the underlying object.
    A downcast requires an explicit cast because it can potentially fail at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: If a downcast fails, an `InvalidCastException` is thrown. This is an example
    of *runtime type checking* (see [“Static and Runtime Type Checking”](#static_and_runtime_type_checking)).
  prefs: []
  type: TYPE_NORMAL
- en: The as operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `as` operator performs a downcast that evaluates to `null` (rather than
    throwing an exception) if the downcast fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: 'This is useful when you’re going to subsequently test whether the result is
    `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: The `as` operator cannot perform *custom conversions* (see [“Operator Overloading”](#operator_overloading)),
    and it cannot do numeric conversions.
  prefs: []
  type: TYPE_NORMAL
- en: The is operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `is` operator tests whether a reference conversion would succeed—in other
    words, whether an object derives from a specified class (or implements an interface).
    It is often used to test before downcasting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: The `is` operator also evaluates to true if an unboxing conversion would succeed
    (see [“The object Type”](#the_object_type)). However, it does not consider custom
    or numeric conversions.
  prefs: []
  type: TYPE_NORMAL
- en: 'From C# 7, you can introduce a variable while using the `is` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: 'The variable that you introduce is available for “immediate” consumption and
    remains in scope outside the `is` expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: The `is` operator works with other patterns introduced in recent versions of
    C#. For a full discussion, see [“Patterns”](#patterns).
  prefs: []
  type: TYPE_NORMAL
- en: Virtual Function Members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A function marked as `virtual` can be *overridden* by subclasses wanting to
    provide a specialized implementation. Methods, properties, indexers, and events
    can all be declared `virtual`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '(`Liability => 0` is a shortcut for `{ get { return 0; } }`. See [“Expression-bodied
    properties”](#expression_bodied_properties) for more details on this syntax.)
    A subclass overrides a virtual method by applying the `override` modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the `Liability` of an `Asset` is `0`. A `Stock` does not need to
    specialize this behavior. However, the `House` specializes the `Liability` property
    to return the value of the `Mortgage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: The signatures, return types, and accessibility of the virtual and overridden
    methods must be identical. An overridden method can call its base class implementation
    via the `base` keyword (see [“The base Keyword”](#the_base_keyword)).
  prefs: []
  type: TYPE_NORMAL
- en: Covariant returns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From C# 9, you can override a method (or property `get` accessor) such that
    it returns a *more derived* (subclassed) type. For example, you can write a `Clone`
    method in the `Asset` class that returns an `Asset` and override that method in
    the `House` class such that it returns a `House`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is permitted because it does not break the contract that `Clone` must
    return an `Asset`: it returns a `House`, which *is* an `Asset` (and more).'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract Classes and Abstract Members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A class declared as *abstract* can never be instantiated. Instead, only its
    concrete *subclasses* can be instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Abstract classes are able to define *abstract members*. Abstract members are
    like virtual members, except they don’t provide a default implementation. That
    implementation must be provided by the subclass, unless that subclass is also
    declared abstract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: Subclasses override abstract members just as though they were virtual.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding Inherited Members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A base class and a subclass can define identical members. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Counter` field in class `B` is said to *hide* the `Counter` field in class
    `A`. Usually, this happens by accident, when a member is added to the base type
    *after* an identical member was added to the subtype. For this reason, the compiler
    generates a warning and then resolves the ambiguity as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: References to `A` (at compile time) bind to `A.Counter`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: References to `B` (at compile time) bind to `B.Counter`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Occasionally, you want to hide a member deliberately, in which case you can
    apply the `new` modifier to the member in the subclass. The `new` modifier does
    nothing more than suppress the compiler warning that would otherwise result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: The `new` modifier communicates your intent to the compiler—and other programmers—that
    the duplicate member is not an accident.
  prefs: []
  type: TYPE_NORMAL
- en: Sealing Functions and Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An overridden function member can *seal* its implementation with the `sealed`
    keyword to prevent it from being overridden by further subclasses. In our earlier
    virtual function member example, we could have sealed `House`’s implementation
    of `Liability`, preventing a class that derives from `House` from overriding `Liability`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: You can also apply the `sealed` modifier to the class itself, to prevent subclassing.
  prefs: []
  type: TYPE_NORMAL
- en: The base Keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `base` keyword is similar to the `this` keyword. It serves two essential
    purposes: accessing an overridden function member from the subclass and calling
    a base class constructor (see the next section).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, `House` uses the `base` keyword to access `Asset`’s implementation
    of `Liability`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: With the `base` keyword, we access `Asset`’s `Liability` property *nonvirtually*.
    This means that we will always access `Asset`’s version of this property, regardless
    of the instance’s actual runtime type.
  prefs: []
  type: TYPE_NORMAL
- en: The same approach works if `Liability` is *hidden* rather than *overridden*.
    (You can also access hidden members by casting to the base class before invoking
    the function.)
  prefs: []
  type: TYPE_NORMAL
- en: Constructors and Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A subclass must declare its own constructors. For example, assume we define
    `Baseclass` and `Subclass` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is then illegal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '`Subclass` must “redefine” any constructors that it wants to expose. In doing
    so, it can call any of the base class’s constructors with the `base` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: The `base` keyword works rather like the `this` keyword, except that it calls
    a constructor in the base class. Base class constructors always execute first;
    this ensures that *base* initialization occurs before *specialized* initialization.
  prefs: []
  type: TYPE_NORMAL
- en: If a constructor in a subclass omits the `base` keyword, the base type’s *parameterless*
    constructor is implicitly called (if the base class has no accessible parameterless
    constructor, the compiler generates an error).
  prefs: []
  type: TYPE_NORMAL
- en: Required members (C# 11)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The requirement for subclasses to invoke a constructor in the base class can
    become burdensome in large class hierarchies if there are many constructors with
    many parameters. Sometimes, the best solution is to avoid constructors altogether
    and rely solely on object initializers to set fields or properties during construction.
    To help with this, you can mark a field or property as `required` (from C# 11):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: 'A required member *must* be populated via an object initializer when constructed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: 'Should you wish to also write a constructor, you can apply the `[SetsRequiredMembers]`
    attribute to bypass the required member restriction for that constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: Constructor and field initialization order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When an object is instantiated, initialization takes place in the following
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From subclass to base class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fields are initialized.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Arguments to base class constructor calls are evaluated.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From base class to subclass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Constructor bodies execute.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Inheritance with primary constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Classes with primary constructors can subclass with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: Overloading and Resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inheritance has an interesting impact on method overloading. Consider the following
    two overloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: 'When an overload is called, the most specific type has precedence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: 'The particular overload to call is determined statically (at compile time)
    rather than at runtime. The following code calls `Foo(Asset)`, even though the
    runtime type of `a` is `House`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you cast `Asset` to `dynamic` (see [“Dynamic Binding”](#dynamic_binding)),
    the decision as to which overload to call is deferred until runtime and is based
    on the object’s actual type.
  prefs: []
  type: TYPE_NORMAL
- en: The object Type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`object` (`System.Object`) is the ultimate base class for all types. Any type
    can be implicitly upcast to `object`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate how this is useful, consider a general-purpose *stack*. A stack
    is a data structure based on the principle of LIFO—“last in, first out.” A stack
    has two operations: *push* an object on the stack and *pop* an object off the
    stack. Here is a simple implementation that can hold up to 10 objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `Stack` works with the object type, we can `Push` and `Pop` instances
    of *any type* to and from the `Stack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '`object` is a reference type, by virtue of being a class. Despite this, value
    types, such as `int`, can also be cast to and from `object`. To make this possible,
    the CLR must perform some special work to bridge the underlying differences between
    value and reference types. This process is called *boxing* and *unboxing*.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In [“Generics”](#generics), we describe how to improve our `Stack` class to
    better handle stacks with same-typed elements.
  prefs: []
  type: TYPE_NORMAL
- en: Boxing and Unboxing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Boxing is the act of casting a value type instance to a reference type instance.
    The reference type can be either the `object` class or an interface (see [“Interfaces”](#interfaces)).
    In this example, we box an `int` into an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: 'Unboxing reverses the operation by casting the object back to the original
    value type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: 'Unboxing requires an explicit cast. The runtime checks that the stated value
    type matches the actual object type, throwing an `InvalidCastException` if the
    check fails. For instance, the following throws an exception because `long` does
    not exactly match `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: 'The following succeeds, however:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: 'As does this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: In the last example, `(double)` performs an *unboxing*, and then `(int)` performs
    a *numeric conversion*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Boxing *copies* the value type instance into the new object, and unboxing *copies*
    the contents of the object back into a value type instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: Static and Runtime Type Checking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C# checks types both statically (at compile time) and at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Static type checking enables the compiler to verify the correctness of your
    program without running it. The following code will fail because the compiler
    enforces static typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: 'Runtime type checking is performed by the CLR when you downcast via a reference
    conversion or unboxing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: Runtime type checking is possible because each object on the heap internally
    stores a little type token. You can retrieve this token by calling the `GetType`
    method of `object`.
  prefs: []
  type: TYPE_NORMAL
- en: The GetType Method and typeof Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All types in C# are represented at runtime with an instance of `System.Type`.
    There are two basic ways to get a `System.Type` object: call `GetType` on the
    instance or use the `typeof` operator on a type name. `GetType` is evaluated at
    runtime; `typeof` is evaluated statically at compile time.'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.Type` has properties for such things as the type’s name, assembly,
    base type, and so on. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '`System.Type` also has methods that act as a gateway to the runtime’s reflection
    model—we describe this fully in *C# 12 in a Nutshell*.'
  prefs: []
  type: TYPE_NORMAL
- en: Object Member Listing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are all the members of `object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: Equals, ReferenceEquals, and GetHashCode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Equals` method in the `object` class is similar to the `==` operator except
    that `Equals` is virtual, whereas `==` is static. The following example illustrates
    the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: Because `x` and `y` have been cast to the `object` type, the compiler statically
    binds to `object`’s `==` operator, which uses *reference type* semantics to compare
    two instances. (And because `x` and `y` are boxed, they are represented in separate
    memory locations and so are unequal.) The virtual `Equals` method, however, defers
    to the `Int32` type’s `Equals` method, which uses *value type* semantics in comparing
    two values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The static `object.Equals` method simply calls the virtual `Equals` method
    on the first argument—after checking that the arguments are not null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '`ReferenceEquals` forces a reference type equality comparison (this is occasionally
    useful on reference types for which the `==` operator has been overloaded to do
    otherwise).'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetHashCode` emits a hash code suitable for use with hashtable-based dictionaries
    such as `System.Collections.Generic.Dictionary` and `System.Collections.Hashtable`.'
  prefs: []
  type: TYPE_NORMAL
- en: To customize a type’s equality semantics, you must at a minimum override `Equals`
    and `GetHashCode`. You would also usually overload the `==` and `!=` operators.
    For an example of how to do both, see [“Operator Overloading”](#operator_overloading).
  prefs: []
  type: TYPE_NORMAL
- en: The ToString Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ToString` method returns the default textual representation of a type
    instance. The `ToString` method is overridden by all built-in types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: 'You can override the `ToString` method on custom types as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: Structs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A *struct* is similar to a class, with the following key differences:'
  prefs: []
  type: TYPE_NORMAL
- en: A struct is a value type, whereas a class is a reference type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A struct does not support inheritance (other than implicitly deriving from `object`,
    or more precisely, `System.ValueType`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A struct can have all the members that a class can, except for a finalizer,
    and virtual or protected members.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Prior to C# 10, structs were further prohibited from defining field initializers
    and parameterless constructors. Although this prohibition has now been relaxed—primarily
    for the benefit of record structs (see [“Records”](#records))—it’s worth thinking
    carefully before defining these constructs, as they can result in confusing behavior
    that we’ll describe in [“Struct Construction Semantics”](#struct_construction_semantics).
  prefs: []
  type: TYPE_NORMAL
- en: A struct is appropriate when value type semantics are desirable. Good examples
    are numeric types, where it is more natural for assignment to copy a value rather
    than a reference. Because a struct is a value type, each instance does not require
    instantiation of an object on the heap (and subsequent collection); this can incur
    useful savings when you’re creating many instances of a type.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with any value type, a struct can end up on the heap indirectly, either
    through boxing or by appearing as a field in a class. If we were to instantiate
    `SomeClass` in the following example, field `Y` would refer to a struct on the
    heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, if you were to declare an array of `SomeStruct`, the instance would
    reside on the heap (because arrays are reference types), although the entire array
    would require only a single memory allocation.
  prefs: []
  type: TYPE_NORMAL
- en: From C# 7.2, you can apply the `ref` modifier to a struct to ensure that it
    can be used only in ways that will place it on the stack. This enables further
    compiler optimizations as well as allowing for the [`Span<T>` type](https://oreil.ly/kCark).
  prefs: []
  type: TYPE_NORMAL
- en: Struct Construction Semantics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Prior to C# 11, every field in a struct had to be explicitly assigned in the
    constructor (or field initializer). This restriction has now been relaxed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to any constructors that you define, a struct always has an implicit
    parameterless constructor that performs a bitwise-zeroing of its fields (setting
    them to their default values):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: 'Even when you define a parameterless constructor of your own, the implicit
    parameterless constructor still exists, and it can be accessed via the `default`
    keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we initialized `x` to 1 via a field initializer, and we initialized
    `y` to 1 via the parameterless constructor. And yet with the `default` keyword,
    we were still able to create a `Point` that bypassed both initializations. The
    default constructor can be accessed other ways, too, as the following example
    illustrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: A good strategy with structs is to design them such that their `default` value
    is a valid state, thereby making initialization redundant.
  prefs: []
  type: TYPE_NORMAL
- en: readonly Structs and Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can apply the `readonly` modifier to a struct to enforce that all fields
    are `readonly`; this aids in declaring intent as well as allowing the compiler
    more optimization freedom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to apply `readonly` at a more granular level, you can apply the
    `readonly` modifier (from C# 8) to a struct’s *functions*. This ensures that if
    the function attempts to modify any field, a compile-time error is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: If a `readonly` function calls a non-`readonly` function, the compiler generates
    a warning (and defensively copies the struct to avoid the possibility of a mutation).
  prefs: []
  type: TYPE_NORMAL
- en: Access Modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To promote encapsulation, a type or type member can limit its *accessibility*
    to other types and other assemblies by adding an *access modifier* to the declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public`'
  prefs: []
  type: TYPE_NORMAL
- en: Fully accessible. This is the implicit accessibility for members of an enum
    or interface.
  prefs: []
  type: TYPE_NORMAL
- en: '`internal`'
  prefs: []
  type: TYPE_NORMAL
- en: Accessible only within the containing assembly or friend assemblies. This is
    the default accessibility for non-nested types.
  prefs: []
  type: TYPE_NORMAL
- en: '`private`'
  prefs: []
  type: TYPE_NORMAL
- en: Accessible only within the containing type. This is the default accessibility
    for members of a class or struct.
  prefs: []
  type: TYPE_NORMAL
- en: '`protected`'
  prefs: []
  type: TYPE_NORMAL
- en: Accessible only within the containing type or subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: '`protected internal`'
  prefs: []
  type: TYPE_NORMAL
- en: The *union* of `protected` and `internal` accessibility (this is more *permissive*
    than `protected` or `internal` alone in that it makes a member more accessible
    in two ways).
  prefs: []
  type: TYPE_NORMAL
- en: '`private protected`'
  prefs: []
  type: TYPE_NORMAL
- en: The *intersection* of `protected` and `internal` accessibility (this is more
    *restrictive* than `protected` or `internal` alone).
  prefs: []
  type: TYPE_NORMAL
- en: '`file` (from C# 11)'
  prefs: []
  type: TYPE_NORMAL
- en: Accessible only from within the same file. Intended for use by *source generators*
    (see [“Extended partial methods”](#extended_partial_methods)). This modifier can
    be applied only to type declarations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, `Class2` is accessible from outside its assembly;
    `Class1` is not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '`ClassB` exposes field `x` to other types in the same assembly; `ClassA` does
    not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: When you’re overriding a base class function, accessibility must be identical
    on the overridden function. The compiler prevents any inconsistent use of access
    modifiers—for example, a subclass itself can be less accessible than a base class
    but not more.
  prefs: []
  type: TYPE_NORMAL
- en: Friend Assemblies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can expose `internal` members to other *friend* assemblies by adding the
    `System.Runtime.CompilerServices.InternalsVisibleTo` assembly attribute, specifying
    the name of the friend assembly as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: If the friend assembly is signed with a strong name, you must specify its *full*
    160-byte public key. You can extract this key via a Language Integrated Query
    (LINQ)—an interactive example is given in LINQPad’s free sample library for *C#
    12 in a Nutshell*, under Chapter 3, “Access Modifiers.”
  prefs: []
  type: TYPE_NORMAL
- en: Accessibility Capping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A type caps the accessibility of its declared members. The most common example
    of capping is when you have an `internal` type with `public` members. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '`C`’s (default) `internal` accessibility caps `Foo`’s accessibility, effectively
    making `Foo internal`. A common reason `Foo` would be marked `public` is to make
    for easier refactoring, should `C` later be changed to `public`.'
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An *interface* is similar to a class but only *specifies behavior* and does
    not hold state (data). Consequently:'
  prefs: []
  type: TYPE_NORMAL
- en: Interface members are *all implicitly abstract*. (There are exceptions to this
    rule that we will describe in [“Default Interface Members”](#default_interface_members)
    and [“Static Interface Members”](#static_interface_members).)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class (or struct) can implement *multiple* interfaces. In contrast, a class
    can inherit from only a *single* class, and a struct cannot inherit at all (aside
    from deriving from `System.ValueType`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interface declaration is like a class declaration, but it (normally) provides
    no implementation for its members, because all its members are implicitly abstract.
    These members will be implemented by the classes and structs that implement the
    interface. An interface can contain only methods, properties, events, and indexers,
    which not coincidentally are precisely the members of a class that can be abstract.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a slightly simplified version of the `IEnumerator` interface, defined
    in `System.Collections`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: 'Interface members are always implicitly public and cannot declare an access
    modifier. Implementing an interface means providing a `public` implementation
    for all of its members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: 'You can implicitly cast an object to any interface that it implements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: Extending an Interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Interfaces can derive from other interfaces. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '`IRedoable` “inherits” all the members of `IUndoable`.'
  prefs: []
  type: TYPE_NORMAL
- en: Explicit Interface Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implementing multiple interfaces can sometimes result in a collision between
    member signatures. You can resolve such collisions by *explicitly implementing*
    an interface member. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: 'Because both `I1` and `I2` have conflicting `Foo` signatures, `Widget` explicitly
    implements `I2`’s `Foo` method. This lets the two methods coexist in one class.
    The only way to call an explicitly implemented member is to cast to its interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: Another reason to explicitly implement interface members is to hide members
    that are highly specialized and distracting to a type’s normal use case. For example,
    a type that implements `ISerializable` would typically want to avoid flaunting
    its `ISerializable` members unless explicitly cast to that interface.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Interface Members Virtually
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An implicitly implemented interface member is, by default, sealed. It must
    be marked `virtual` or `abstract` in the base class in order to be overridden:
    calling the interface member through either the base class or the interface then
    calls the subclass’s implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: An explicitly implemented interface member cannot be marked `virtual`, nor can
    it be overridden in the usual manner. It can, however, be *reimplemented*.
  prefs: []
  type: TYPE_NORMAL
- en: Reimplementing an Interface in a Subclass
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A subclass can *reimplement* any interface member already implemented by a base
    class. Reimplementation hijacks a member implementation (when called through the
    interface) and works whether or not the member is `virtual` in the base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, `TextBox` implements `IUndoable.Undo` explicitly,
    and so it cannot be marked as `virtual`. To “override” it, `RichTextBox` must
    reimplement `IUndoable`’s `Undo` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling the reimplemented member through the interface calls the subclass’s
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, `TextBox` implements the `Undo` method explicitly. If `TextBox`
    instead implemented the `Undo` method implicitly, `RichTextBox` could still reimplement
    the method, but the effects would be nonpervasive in that calling the member through
    the base class would invoke the base implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: Default Interface Members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From C# 8, you can add a default implementation to an interface member, making
    it optional to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: This is advantageous if you wish to add a member to an interface defined in
    a popular library without breaking (potentially thousands of) implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Default implementations are always explicit, so if a class implementing `ILogger`
    fails to define a `Log` method, the only way to call it is through the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: 'This prevents a problem of multiple implementation inheritance: if the same
    default member is added to two interfaces that a class implements, there is never
    an ambiguity as to which member is called.'
  prefs: []
  type: TYPE_NORMAL
- en: Static Interface Members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An interface can also declare static members. There are two kinds of static
    interface members:'
  prefs: []
  type: TYPE_NORMAL
- en: Static nonvirtual interface members
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static virtual/abstract interface members
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static nonvirtual interface members
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Static nonvirtual interface members exist mainly to help with writing default
    interface members. They are not implemented by classes or structs; instead, they
    are consumed directly. Along with methods, properties, events, and indexers, static
    nonvirtual members permit fields, which are typically accessed from code inside
    default member implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: 'Static nonvirtual interface members are public by default, so they can be accessed
    from the outside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: You can restrict this by adding an accessibility modifier (such as `private`,
    `protected`, or `internal`).
  prefs: []
  type: TYPE_NORMAL
- en: Instance fields are (still) prohibited. This is in line with the principle of
    interfaces, which is to define *behavior*, not *state*.
  prefs: []
  type: TYPE_NORMAL
- en: Static virtual/abstract interface members
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Static virtual/abstract interface members (from C# 11) are marked with `static
    abstract` or `static virtual` and enable *static polymorphism*, an advanced feature
    that we will discuss fully in [“Static Polymorphism”](#static_polymorphism):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: 'An implementing class or struct must implement static abstract members and
    can optionally implement static virtual members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: In addition to methods, properties, and events, operators and conversions are
    also legal targets for static virtual interface members (see [“Operator Overloading”](#operator_overloading)).
    Static virtual interface members are called through a constrained type parameter;
    we will demonstrate this in [“Static Polymorphism”](#static_polymorphism) and
    [“Generic Math”](#generic_math), after covering generics.
  prefs: []
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An *enum* is a special value type that lets you specify a group of named numeric
    constants. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this enum type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: 'Each enum member has an underlying integral-type value. By default, the underlying
    values are of type `int`, and the enum members are assigned the constants `0`,
    `1`, `2`... (in their declaration order). You may specify an alternative integral
    type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: 'You may also specify an explicit integer value for each member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler also lets you explicitly assign *some* of the enum members. The
    unassigned enum members keep incrementing from the last explicit value. The preceding
    example is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: Enum Conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can convert an `enum` instance to and from its underlying integral value
    with an explicit cast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: You can also explicitly cast one enum type to another; the translation then
    uses the members’ underlying integral values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The numeric literal `0` is treated specially in that it does not require an
    explicit cast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: 'In this particular example, `BorderSide` has no member with an integer value
    of `0`. This does not generate an error: a limitation of enums is that the compiler
    and CLR do not prevent the assignment of integrals whose values fall outside the
    range of members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: Flags Enums
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can combine enum members. To prevent ambiguities, members of a combinable
    enum require explicitly assigned values, typically in powers of two. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: 'By convention, a combinable enum type is given a plural rather than singular
    name. To work with combined enum values, you use bitwise operators, such as `|`
    and `&`. These operate on the underlying integral values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: The `Flags` attribute should be applied to combinable enum types; if you fail
    to do this, calling `ToString` on an `enum` instance emits a number rather than
    a series of names.
  prefs: []
  type: TYPE_NORMAL
- en: 'For convenience, you can include combination members within an enum declaration
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: Enum Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The operators that work with enums are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: The bitwise, arithmetic, and comparison operators return the result of processing
    the underlying integral values. Addition is permitted between an enum and an integral
    type, but not between two enums.
  prefs: []
  type: TYPE_NORMAL
- en: Nested Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A *nested type* is declared within the scope of another type. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: 'A nested type has the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: It can access the enclosing type’s private members and everything else the enclosing
    type can access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be declared with the full range of access modifiers, rather than just
    `public` and `internal`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default accessibility for a nested type is `private` rather than `internal`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing a nested type from outside the enclosing type requires qualification
    with the enclosing type’s name (like when you’re accessing static members).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, to access `Color.Red` from outside our `TopLevel` class, you’d
    need to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: All types can be nested; however, only classes and structs can nest.
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C# has two separate mechanisms for writing code that are reusable across different
    types: *inheritance* and *generics*. Whereas inheritance expresses reusability
    with a base type, generics express reusability with a “template” that contains
    “placeholder” types. Generics, when compared to inheritance, can *increase type
    safety* and *reduce casting and boxing*.'
  prefs: []
  type: TYPE_NORMAL
- en: Generic Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *generic type* declares *type parameters*—placeholder types to be filled
    in by the consumer of the generic type, which supplies the *type arguments*. Here
    is a generic type, `Stack<T>`, designed to stack instances of type `T`. `Stack<T>`
    declares a single type parameter `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use `Stack<T>` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that no downcasts are required in the last two lines, avoiding the possibility
    of a runtime error and eliminating the overhead of boxing/unboxing. This makes
    our generic stack superior to a nongeneric stack that uses `object` in place of
    `T` (see [“The object Type”](#the_object_type) for an example).
  prefs: []
  type: TYPE_NORMAL
- en: '`Stack<int>` fills in the type parameter `T` with the type argument `int`,
    implicitly creating a type on the fly (the synthesis occurs at runtime). `Stack<int>`
    effectively has the following definition (substitutions appear in bold, with the
    class name hashed out to avoid confusion):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: Technically, we say that `Stack<T>` is an *open type*, whereas `Stack<int>`
    is a *closed type*. At runtime, all generic type instances are closed—with the
    placeholder types filled in.
  prefs: []
  type: TYPE_NORMAL
- en: Generic Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *generic method* declares type parameters within the signature of a method.
    With generic methods, many fundamental algorithms can be implemented in a general-purpose
    way. Here is a generic method that swaps the contents of two variables of any
    type `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use `Swap<T>` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: 'Generally, there is no need to supply type arguments to a generic method, because
    the compiler can implicitly infer the type. If there is ambiguity, generic methods
    can be called with the type arguments as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: Within a generic *type*, a method is not classed as generic unless it *introduces*
    type parameters (with the angle bracket syntax). The `Pop` method in our generic
    stack merely consumes the type’s existing type parameter, `T`, and is not classed
    as a generic method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods and types are the only constructs that can introduce type parameters.
    Properties, indexers, events, fields, constructors, operators, and so on cannot
    declare type parameters, although they can partake in any type parameters already
    declared by their enclosing type. In our generic stack example, for instance,
    we could write an indexer that returns a generic item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, constructors can partake in existing type parameters but cannot *introduce*
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring Type Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Type parameters can be introduced in the declaration of classes, structs, interfaces,
    delegates (see [“Delegates”](#delegates)), and methods. You can specify multiple
    type parameters by separating them with commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: 'To instantiate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: 'Generic type names and method names can be overloaded as long as the number
    of type parameters differs. For example, the following three type names do not
    conflict:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: By convention, generic types and methods with a *single* type parameter name
    their parameter `T`, as long as the intent of the parameter is clear. With *multiple*
    type parameters, each parameter has a more descriptive name (prefixed by `T`).
  prefs: []
  type: TYPE_NORMAL
- en: typeof and Unbound Generic Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open generic types do not exist at runtime: open generic types are closed as
    part of compilation. However, it is possible for an *unbound* generic type to
    exist at runtime—purely as a `Type` object. The only way to specify an unbound
    generic type in C# is with the `typeof` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `typeof` operator to specify a closed type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: 'It can specify an open type as well (which is closed at runtime):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: The default Generic Value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use the `default` keyword to get the default value for a generic type
    parameter. The default value for a reference type is `null`, and the default value
    for a value type is the result of bitwise-zeroing the type’s fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: 'From C# 7.1, you can omit the type argument for cases in which the compiler
    is able to infer it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: Generic Constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, a type parameter can be substituted with any type whatsoever. *Constraints*
    can be applied to a type parameter to require more specific type arguments. There
    are eight kinds of constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, `GenericClass<T,U>` requires `T` to derive from (or
    be identical to) `SomeClass` and implement `Interface1`, and requires `U` to provide
    a parameterless constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: Constraints can be applied wherever type parameters are defined, whether in
    methods or in type definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A *constraint* is a *restriction*; however, the main purpose of type parameter
    constraints is to enable things that would otherwise be prohibited.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, the constraint `T:Foo` lets you treat instances of `T` as `Foo`,
    and the constraint `T:new()` lets you construct new instances of `T`.
  prefs: []
  type: TYPE_NORMAL
- en: A *base class constraint* specifies that the type parameter must subclass (or
    match) a particular class; an *interface constraint* specifies that the type parameter
    must implement that interface. These constraints allow instances of the type parameter
    to be implicitly converted to that class or interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *class constraint* and *struct constraint* specify that `T` must be a reference
    type or a (non-nullable) value type, respectively. The unmanaged constraint is
    a stronger version of a struct constraint: `T` must be a simple value type or
    a struct that is (recursively) free of any reference types. The *parameterless
    constructor constraint* requires `T` to have a public parameterless constructor
    and allows you to call `new()` on `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: The *naked type constraint* requires one type parameter to derive from (or match)
    another type parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Subclassing Generic Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A generic class can be subclassed just like a nongeneric class. The subclass
    can leave the base class’s type parameters open, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: 'Or the subclass can close the generic type parameters with a concrete type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: 'A subtype can also introduce fresh type arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: Self-Referencing Generic Declarations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A type can name *itself* as the concrete type when closing a type argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are also legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: Static Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Static data is unique for each closed type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: Covariance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Covariance and contravariance are advanced concepts. The motivation behind their
    introduction into C# was to allow generic interfaces and generics (in particular,
    those defined in .NET, such as `IEnumerable<T>`) to work *more as you’d expect*.
    You can benefit from this without understanding the details behind covariance
    and contravariance.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming `A` is convertible to `B`, `X` has a covariant type parameter if `X<A>`
    is convertible to `X<B>`.
  prefs: []
  type: TYPE_NORMAL
- en: (With C#’s notion of variance, *convertible* means convertible via an *implicit
    reference conversion*—such as `A` *subclassing* `B`, or `A` *implementing* `B`.
    Numeric conversions, boxing conversions, and custom conversions are not included.)
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, type `IFoo<T>` has a covariant `T` if the following is legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: 'Interfaces (and delegates) permit covariant type parameters. To illustrate,
    suppose that the `Stack<T>` class that we wrote at the beginning of this section
    implements the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: 'The `out` modifier on `T` indicates that `T` is used only in *output positions*
    (e.g., return types for methods) and flags the type parameter as *covariant*,
    permitting the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: The cast from `bears` to `animals` is permitted by the compiler—by virtue of
    the interface’s type parameter being covariant.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `IEnumerator<T>` and `IEnumerable<T>` interfaces (see [“Enumeration and
    Iterators”](#enumeration_and_iterators)) are marked with a covariant `T`. This
    allows you to cast `IEnumerable<string>` to `IEnumerable<object>`, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler will generate an error if you use a covariant type parameter in
    an *input* position (e.g., a parameter to a method or a writable property). The
    purpose of this limitation is to guarantee compile-time type safety. For instance,
    it prevents us from adding a `Push(T)` method to that interface, which consumers
    could abuse with the seemingly benign operation of pushing a camel onto an `IPoppable<Animal>`
    (remember that the underlying type in our example is a stack of bears). To define
    a `Push(T)` method, `T` must in fact be *contravariant*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: C# supports covariance (and contravariance) only for elements with *reference
    conversions*—not *boxing conversions*. So, if you wrote a method that accepted
    a parameter of type `IPoppable<object>`, you could call it with `IPoppable<string>`
    but not `IPoppable<int>`.
  prefs: []
  type: TYPE_NORMAL
- en: Contravariance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We previously saw that, assuming that `A` allows an implicit reference conversion
    to `B`, a type `X` has a covariant type parameter if `X<A>` allows a reference
    conversion to `X<B>`. A type is *contravariant* when you can convert in the reverse
    direction—from `X<B>` to `X<A>`. This is supported on interfaces and delegates
    when the type parameter appears only in *input* positions, designated with the
    `in` modifier. Extending our previous example, if the `Stack<T>` class implements
    the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: 'we can legally do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: Mirroring covariance, the compiler will report an error if you try to use a
    contravariant type parameter in an output position (e.g., as a return value or
    in a readable property).
  prefs: []
  type: TYPE_NORMAL
- en: Delegates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A *delegate* wires up a method caller to its target method at runtime. There
    are two aspects to a delegate: *type* and *instance*. A *delegate type* defines
    a *protocol* to which the caller and target will conform, comprising a list of
    parameter types and a return type. A *delegate instance* is an object that refers
    to one (or more) target methods conforming to that protocol.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A delegate instance literally acts as a delegate for the caller: the caller
    invokes the delegate, and then the delegate calls the target method. This indirection
    decouples the caller from the target method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A delegate type declaration is preceded by the keyword `delegate`, but otherwise
    it resembles an (abstract) method declaration. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a delegate instance, you can assign a method to a delegate variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoking a delegate is just like invoking a method (because the delegate’s
    purpose is merely to provide a level of indirection):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: 'The statement `Transformer t = Square` is shorthand for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: 'And `t(3)` is shorthand for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: A delegate is similar to a *callback*, a general term that captures constructs
    such as C function pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Plug-In Methods with Delegates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A delegate variable is assigned a method at runtime. This is useful for writing
    plug-in methods. In this example, we have a utility method named `Transform` that
    applies a transform to each element in an integer array. The `Transform` method
    has a delegate parameter for specifying a plug-in transform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: Instance and Static Method Targets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A delegate’s target method can be a local, static, or instance method.
  prefs: []
  type: TYPE_NORMAL
- en: When an *instance* method is assigned to a delegate object, the latter must
    maintain a reference not only to the method but also to the *instance* to which
    the method belongs. The `System.Delegate` class’s `Target` property represents
    this instance (and will be null for a delegate referencing a static method).
  prefs: []
  type: TYPE_NORMAL
- en: Multicast Delegates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All delegate instances have *multicast* capability. This means that a delegate
    instance can reference not just a single target method but also a list of target
    methods. The `+` and `+=` operators combine delegate instances. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: 'The last line is functionally the same as this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: Invoking `d` will now call both `SomeMethod1` and `SomeMethod2`. Delegates are
    invoked in the order in which they are added.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-` and `-=` operators remove the right delegate operand from the left
    delegate operand. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: Invoking `d` will now cause only `SomeMethod2` to be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Calling `+` or `+=` on a delegate variable with a `null` value is legal, as
    is calling `-=` on a delegate variable with a single target (which will result
    in the delegate instance being `null`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Delegates are *immutable*, so when you call `+=` or `-=`, you’re in fact creating
    a *new* delegate instance and assigning it to the existing variable.
  prefs: []
  type: TYPE_NORMAL
- en: If a multicast delegate has a nonvoid return type, the caller receives the return
    value from the last method to be invoked. The preceding methods are still called,
    but their return values are discarded. In most scenarios in which multicast delegates
    are used, they have `void` return types, so this subtlety does not arise.
  prefs: []
  type: TYPE_NORMAL
- en: All delegate types implicitly derive from `System.MulticastDelegate`, which
    inherits from `System.Delegate`. C# compiles `+`, `-`, `+=`, and `-=` operations
    made on a delegate to the static `Combine` and `Remove` methods of the `System.Delegate`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Generic Delegate Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A delegate type can contain generic type parameters. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how we could use this delegate type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: The Func and Action Delegates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With generic delegates, it becomes possible to write a small set of delegate
    types that are so general they can work for methods of any return type and any
    (reasonable) number of arguments. These delegates are the `Func` and `Action`
    delegates, defined in the `System` namespace (the `in` and `out` annotations indicate
    *variance*, which we cover in the context of delegates shortly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: 'These delegates are extremely general. The `Transformer` delegate in our previous
    example can be replaced with a `Func` delegate that takes a single argument of
    type `T` and returns a same-typed value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: The only practical scenarios not covered by these delegates are `ref`/`out`
    and pointer parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Delegate Compatibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Delegate types are all incompatible with one another, even if their signatures
    are the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: 'The following, however, is permitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: Delegate instances are considered equal if they have the same type and method
    target(s). For multicast delegates, the order of the method targets is significant.
  prefs: []
  type: TYPE_NORMAL
- en: Return type variance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you call a method, you might get back a type that is more specific than
    what you asked for. This is ordinary polymorphic behavior. In keeping with this,
    a delegate target method might return a more specific type than described by the
    delegate. This is *covariance*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: The `ObjectRetriever` expects to get back an `object`, but an `object` *subclass*
    will also do because delegate return types are *covariant*.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter variance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you call a method, you can supply arguments that have more specific types
    than the parameters of that method. This is ordinary polymorphic behavior. In
    keeping with this, a delegate target method may have *less* specific parameter
    types than described by the delegate. This is called *contravariance*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The standard event pattern is designed to help you take advantage of delegate
    parameter contravariance through its use of the common `EventArgs` base class.
    For example, you can have a single method invoked by two different delegates,
    one passing a `MouseEventArgs` and the other passing a `KeyEventArgs`.
  prefs: []
  type: TYPE_NORMAL
- en: Type parameter variance for generic delegates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We saw in [“Generics”](#generics) how type parameters can be covariant and
    contravariant for generic interfaces. The same capability also exists for generic
    delegates. If you’re defining a generic delegate type, it’s a good practice to
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Mark a type parameter used only on the return value as covariant (`out`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mark any type parameters used only on parameters as contravariant (`in`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Doing so allows conversions to work naturally by respecting inheritance relationships
    between types. The following delegate (defined in the `System` namespace) is covariant
    for `TResult`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: The following delegate (defined in the `System` namespace) is contravariant
    for `T:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you’re using delegates, two emergent roles commonly appear: *broadcaster*
    and *subscriber*. The *broadcaster* is a type that contains a delegate field.
    The broadcaster decides when to broadcast, by invoking the delegate. The *subscribers*
    are the method target recipients. A subscriber decides when to start and stop
    listening, by calling `+=` and `-=` on the broadcaster’s delegate. A subscriber
    does not know about, or interfere with, other subscribers.'
  prefs: []
  type: TYPE_NORMAL
- en: Events are a language feature that formalizes this pattern. An `event` is a
    construct that exposes just the subset of delegate features required for the broadcaster/subscriber
    model. The main purpose of events is to *prevent subscribers from interfering
    with one another*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to declare an event is to put the `event` keyword in front
    of a delegate member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: Code within the `Broadcaster` type has full access to `Progress` and can treat
    it as a delegate. Code outside of `Broadcaster` can perform only `+=` and `-=`
    operations on the `Progress` event.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the `Stock` class fires its `PriceChanged` event
    every time the `Price` of the `Stock` changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: 'If we remove the `event` keyword from our example so that `PriceChanged` becomes
    an ordinary delegate field, our example would give the same results. However,
    `Stock` would be less robust in that subscribers could do the following things
    to interfere with one another:'
  prefs: []
  type: TYPE_NORMAL
- en: Replace other subscribers by reassigning `PriceChanged` (instead of using the
    `+=` operator)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clear all subscribers (by setting `PriceChanged` to `null`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Broadcast to other subscribers by invoking the delegate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events can be virtual, overridden, abstract, or sealed. They can also be static.
  prefs: []
  type: TYPE_NORMAL
- en: Standard Event Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In almost all cases in which events are defined in the .NET library, their
    definition adheres to a standard pattern designed to provide consistency across
    library and user code. Here’s the preceding example refactored with this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: At the core of the standard event pattern is `System.EventArgs`, a predefined
    .NET class with no members (other than the static `Empty` field). `EventArgs`
    is a base class for conveying information for an event. In this example, we subclass
    `EventArgs` to convey the old and new prices when a `PriceChanged` event is fired.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generic `System.EventHandler` delegate is also part of .NET and is defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Before C# 2.0 (when generics were added to the language), the solution was
    to instead write a custom event-handling delegate for each `EventArgs` type as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: For historical reasons, most events within the .NET libraries use delegates
    defined in this way.
  prefs: []
  type: TYPE_NORMAL
- en: A protected virtual method named `On`*-*`*event-name*` centralizes firing of
    the event. This allows subclasses to fire the event (which is usually desirable)
    and also allows subclasses to insert code before and after the event is fired.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we could use our `Stock` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: 'For events that don’t carry additional information, .NET also provides a nongeneric
    `EventHandler` delegate. We can demonstrate this by rewriting our `Stock` class
    such that the `PriceChanged` event fires *after* the price changes. This means
    that no additional information need be transmitted with the event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: Note that we also used the `EventArgs.Empty` property—this saves instantiating
    an instance of `EventArgs`.
  prefs: []
  type: TYPE_NORMAL
- en: Event Accessors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An event’s *accessors* are the implementations of its `+=` and `-=` functions.
    By default, accessors are implemented implicitly by the compiler. Consider this
    event declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler converts this to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A private delegate field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A public pair of event accessor functions, whose implementations forward the
    `+=` and `-=` operations to the private delegate field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can take over this process by defining *explicit* event accessors. Here’s
    a manual implementation of the `PriceChanged` event from our previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: This example is functionally identical to C#’s default accessor implementation
    (except that C# also ensures thread safety around updating the delegate). By defining
    event accessors ourselves, we instruct C# not to generate default field and accessor
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'With explicit event accessors, you can apply more complex strategies to the
    storage and access of the underlying delegate. This is useful when the event accessors
    are merely relays for another class that is broadcasting the event, or when explicitly
    implementing an interface that declares an event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: Lambda Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A *lambda expression* is an unnamed method written in place of a delegate instance.
    The compiler immediately converts the lambda expression to either of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A delegate instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An *expression tree*, of type `Expression<TDelegate>`, representing the code
    inside the lambda expression in a traversable object model. This allows the lambda
    expression to be interpreted later at runtime (we describe the process in Chapter
    8 of *C# 12 in a Nutshell*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, `x => x * x` is a lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Internally, the compiler resolves lambda expressions of this type by writing
    a private method and moving the expression’s code into that method.
  prefs: []
  type: TYPE_NORMAL
- en: 'A lambda expression has the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: For convenience, you can omit the parentheses if and only if there is exactly
    one parameter of an inferable type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, there is a single parameter, `x`, and the expression is `x
    * x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: Each parameter of the lambda expression corresponds to a delegate parameter,
    and the type of the expression (which can be `void`) corresponds to the return
    type of the delegate.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, `x` corresponds to parameter `i`, and the expression `x * x`
    corresponds to the return type `int`, therefore making it compatible with the
    `Transformer` delegate.
  prefs: []
  type: TYPE_NORMAL
- en: 'A lambda expression’s code can be a *statement block* instead of an expression.
    We can rewrite our example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: 'Lambda expressions are used most commonly with the `Func` and `Action` delegates,
    so you will most often see our earlier expression written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler can usually *infer* the type of lambda parameters contextually.
    When this is not the case, you can specify parameter types explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example of an expression that accepts two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming `Clicked` is an event of type `EventHandler`, the following attaches
    an event handler via a lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example of an expression that takes zero arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: 'From C# 10, the compiler permits implicit typing with lambda expressions that
    can be resolved via the `Func` and `Action` delegates, so we can shorten this
    statement to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: 'If the lambda expression has arguments, you must specify their types in order
    to use `var`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: The compiler infers `sqr` to be of type `Func<int,int>`.
  prefs: []
  type: TYPE_NORMAL
- en: Default Lambda Parameters (C# 12)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as ordinary methods can have optional parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: 'so, too, can lambda expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: This feature is useful with libraries such as ASP.NET Minimal API.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing Outer Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A lambda expression can reference any variables that are accessible where the
    lambda expression is defined. These are called *outer variables* and can include
    local variables, parameters, and fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: 'Outer variables referenced by a lambda expression are called *captured variables*.
    A lambda expression that captures variables is called a *closure*. Captured variables
    are evaluated when the delegate is actually *invoked*, not when the variables
    were *captured*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: 'Lambda expressions can themselves update captured variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: 'Captured variables have their lifetimes extended to that of the delegate. In
    the following example, the local variable `seed` would ordinarily disappear from
    scope when `Natural` finished executing. But because `seed` has been *captured*,
    its lifetime is extended to that of the capturing delegate, `natural`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: Variables can also be captured by anonymous methods and local methods. The rules
    for captured variables, in these cases, are the same.
  prefs: []
  type: TYPE_NORMAL
- en: Static lambdas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From C# 9, you can ensure that a lambda expression, local function, or anonymous
    method doesn’t capture state by applying the `static` keyword. This can be useful
    in micro-optimization scenarios to prevent the (potentially unintentional) memory
    allocation and cleanup of a closure. For example, we can apply the static modifier
    to a lambda expression as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: 'If we later tried to modify the lambda expression such that it captured a local
    variable, the compiler will generate an error. This feature is more useful in
    local methods (because a lambda expression itself incurs a memory allocation).
    In the following example, the `Multiply` method cannot access the `factor` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: Applying `static` here is also arguably useful as a documentation tool, indicating
    a reduced level of coupling. Static lambdas can still access static variables
    and constants (because these do not require a closure).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `static` keyword acts merely as a *check*; it has no effect on the IL that
    the compiler produces. Without the `static` keyword, the compiler does not generate
    a closure unless it needs to (and even then, it has tricks to mitigate the cost).
  prefs: []
  type: TYPE_NORMAL
- en: Capturing iteration variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you capture an iteration variable in a `for` loop, C# treats the iteration
    variable as though it were declared *outside* the loop. This means that the *same*
    variable is captured in each iteration. The following program writes `333` instead
    of `012`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: 'Each closure (shown in boldface) captures the same variable, `i`. (This actually
    makes sense when you consider that `i` is a variable whose value persists between
    loop iterations; you can even explicitly change `i` within the loop body if you
    want.) The consequence is that when the delegates are later invoked, each delegate
    sees `i`’s value at the time of *invocation*—which is 3\. The solution, if we
    want to write `012`, is to assign the iteration variable to a local variable that
    is scoped *within* the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: This causes the closure to capture a *different* variable on each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Note that (from C# 5) the iteration variable in a `foreach` loop is implicitly
    local, so you can safely close over it without needing a temporary variable.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda Expressions Versus Local Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The functionality of local methods (see [“Local methods”](#local_methods)) overlaps
    with that of lambda expressions. Local methods have the advantages of allowing
    for recursion and avoiding the clutter of specifying a delegate. Avoiding the
    indirection of a delegate also makes them slightly more efficient, and they can
    access local variables of the containing method without the compiler having to
    “hoist” the captured variables into a hidden class.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in many cases you *need* a delegate, most commonly when calling a
    higher-order function (i.e., a method with a delegate-typed parameter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: In such cases, you need a delegate anyway, and it’s precisely in these cases
    that lambda expressions are usually terser and cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Anonymous methods are a C# 2.0 feature that has been mostly subsumed by lambda
    expressions. An anonymous method is like a lambda expression except that it lacks
    implicitly typed parameters, expression syntax (an anonymous method must always
    be a statement block), and the ability to compile to an expression tree. To write
    an anonymous method, you include the `delegate` keyword followed (optionally)
    by a parameter declaration and then a method body. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line is semantically equivalent to the following lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: 'Or simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: 'A unique feature of anonymous methods is that you can omit the parameter declaration
    entirely—even if the delegate expects it. This can be useful in declaring events
    with a default empty handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: 'This avoids the need for a null check before firing the event. The following
    is also legal (notice the lack of parameters):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: Anonymous methods capture outer variables in the same way lambda expressions
    do.
  prefs: []
  type: TYPE_NORMAL
- en: try Statements and Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `try` statement specifies a code block subject to error-handling or cleanup
    code. The `try` *block* must be followed by one or more `catch` *blocks* and/or
    a `finally` *block*. The `catch` block executes when an error is thrown in the
    `try` block. The `finally` block executes after execution leaves the `try` block
    (or if present, the `catch` block) to perform cleanup code, whether or not an
    exception was thrown.
  prefs: []
  type: TYPE_NORMAL
- en: A `catch` block has access to an `Exception` object that contains information
    about the error. You use a `catch` block to either compensate for the error or
    *rethrow* the exception. You rethrow an exception if you merely want to log the
    problem, or if you want to rethrow a new, higher-level exception type.
  prefs: []
  type: TYPE_NORMAL
- en: A `finally` block adds determinism to your program by always executing no matter
    what. It’s useful for cleanup tasks such as closing network connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `try` statement looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `y` is zero, the runtime throws a `DivideByZeroException` and our program
    terminates. We can prevent this by catching the exception as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This is a simple example to illustrate exception handling. We could deal with
    this particular scenario better in practice by checking explicitly for the divisor
    being zero before calling `Calc`.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions are relatively expensive to handle, taking hundreds of clock cycles.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an exception is thrown within a `try` statement, the CLR performs a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Does the* `try` *statement have any compatible* `catch` *blocks?*'
  prefs: []
  type: TYPE_NORMAL
- en: If so, execution jumps to the compatible `catch` block, followed by the `finally`
    block (if present), and then execution continues normally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If not, execution jumps directly to the `finally` block (if present), and then
    the CLR looks up the call stack for other `try` blocks and, if found, repeats
    the test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no function in the call stack takes responsibility for the exception, an
    error dialog is displayed to the user and the program terminates.
  prefs: []
  type: TYPE_NORMAL
- en: The catch Clause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `catch` clause specifies what type of exception to catch. This must be either
    `System.Exception` or a subclass of `System.Exception`. Catching `System.Exception`
    catches all possible errors. This is useful when:'
  prefs: []
  type: TYPE_NORMAL
- en: Your program can potentially recover regardless of the specific exception type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You plan to rethrow the exception (perhaps after logging it).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your error handler is the last resort, prior to termination of the program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More typically, though, you catch *specific exception types* in order to avoid
    having to deal with circumstances for which your handler wasn’t designed (e.g.,
    an `OutOfMemoryException`).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can handle multiple exception types with multiple `catch` clauses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: Only one `catch` clause executes for a given exception. If you want to include
    a safety net to catch more general exceptions (such as `System.Exception`), you
    must put the more specific handlers *first*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can catch an exception without specifying a variable, if you don’t need
    to access its properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, you can omit both the variable and the type (meaning that all
    exceptions will be caught):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: Exception filters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can specify an *exception filter* in a `catch` clause by adding a `when`
    clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: 'If a `WebException` is thrown in this example, the Boolean expression following
    the `when` keyword is then evaluated. If the result is false, the `catch` block
    in question is ignored, and any subsequent `catch` clauses are considered. With
    exception filters, it can be meaningful to catch the same exception type again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: The Boolean expression in the `when` clause can be side-effecting, such as a
    method that logs the exception for diagnostic purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The finally Block
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `finally` block always executes—whether or not an exception is thrown and
    whether or not the `try` block runs to completion. `finally` blocks are typically
    used for cleanup code.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `finally` block executes either:'
  prefs: []
  type: TYPE_NORMAL
- en: After a `catch` block finishes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After control leaves the `try` block because of a `jump` statement (e.g., `return`
    or `goto`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the `try` block ends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `finally` block helps add determinism to a program. In the following example,
    the file that we open *always* gets closed, regardless of whether:'
  prefs: []
  type: TYPE_NORMAL
- en: The `try` block finishes normally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execution returns early because the file is empty (`EndOfStream`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `IOException` is thrown while the file is being read.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we closed the file by calling `Dispose` on the `StreamReader`.
    Calling `Dispose` on an object, within a `finally` block, is a standard convention
    throughout .NET and is supported explicitly in C# through the `using` statement.
  prefs: []
  type: TYPE_NORMAL
- en: The using statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many classes encapsulate unmanaged resources such as file handles, graphics
    handles, or database connections. These classes implement `System.IDisposable`,
    which defines a single parameterless method named `Dispose` to clean up these
    resources. The `using` statement provides an elegant syntax for calling `Dispose`
    on an `IDisposable` object within a `finally` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: 'is precisely equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: using declarations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you omit the brackets and statement block following a `using` statement,
    it becomes a *using declaration* (C# 8+). The resource is then disposed when execution
    falls outside the *enclosing* statement block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `reader` will be disposed when execution falls outside the `if`
    statement block.
  prefs: []
  type: TYPE_NORMAL
- en: Throwing Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exceptions can be thrown either by the runtime or in user code. In this example,
    `Display` throws a `System.ArgumentNul⁠l​Exception`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: throw expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From C# 7, `throw` can appear as an expression in expression-bodied functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: 'A `throw` expression can also appear in a ternary conditional expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: Rethrowing an exception
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can capture and rethrow an exception as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: Rethrowing in this manner lets you log an error without *swallowing* it. It
    also lets you back out of handling an exception should circumstances turn out
    to be outside what you expected.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If we replaced `throw` with `throw ex`, the example would still work, but the
    `StackTrace` property of the exception would no longer reflect the original error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other common scenario is to rethrow a more specific or meaningful exception
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: When rethrowing a different exception, you can populate the `InnerException`
    property with the original exception to aid debugging. Nearly all types of exceptions
    provide a constructor for this purpose (such as in our example).
  prefs: []
  type: TYPE_NORMAL
- en: Key Properties of System.Exception
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most important properties of `System.Exception` are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`StackTrace`'
  prefs: []
  type: TYPE_NORMAL
- en: A string representing all the methods that are called from the origin of the
    exception to the `catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: '`Message`'
  prefs: []
  type: TYPE_NORMAL
- en: A string with a description of the error.
  prefs: []
  type: TYPE_NORMAL
- en: '`InnerException`'
  prefs: []
  type: TYPE_NORMAL
- en: The inner exception (if any) that caused the outer exception. This, itself,
    might have another `InnerException`.
  prefs: []
  type: TYPE_NORMAL
- en: Enumeration and Iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enumeration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An *enumerator* is a read-only, forward-only cursor over a *sequence of values*.
    C# treats a type as an enumerator if it does any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Has a public parameterless method named `MoveNext` and property called `Current`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implements `System.Collections.Generic.IEnumerator<T>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implements `System.Collections.IEnumerator`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `foreach` statement iterates over an *enumerable* object. An enumerable
    object is the logical representation of a sequence. It is not itself a cursor
    but an object that produces cursors over itself. C# treats a type as enumerable
    if it does any of the following (the check is performed in this order):'
  prefs: []
  type: TYPE_NORMAL
- en: Has a public parameterless method named `GetEnumerator` that returns an enumerator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implements `System.Collections.Generic.IEnumerable<T>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implements `System.Collections.IEnumerable`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (From C# 9) Can bind to an *extension method* named `GetEnumerator` that returns
    an enumerator (see [“Extension Methods”](#extension_methods))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The enumeration pattern is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the high-level way to iterate through the characters in the word *beer*
    using a `foreach` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the low-level way to iterate through the characters in *beer* without
    using a `foreach` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: If the enumerator implements `IDisposable`, the `foreach` statement also acts
    as a `using` statement, implicitly disposing the enumerator object.
  prefs: []
  type: TYPE_NORMAL
- en: Collection Initializers and Collection Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can instantiate and populate an enumerable object in a single step. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: 'From C# 12, you can shorten the last line further with a *collection expression*
    (note the square brackets):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Collection expressions are *target-typed*, meaning that the type of `[1,2,3]`
    depends on the type to which it’s assigned (in this case, `List<int>`). In the
    following example, the target type is an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: 'Target typing means that you can omit the type in other scenarios where the
    compiler can infer it, such as when calling methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler translates this into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: 'This requires that the enumerable object implements the `System.Collections.IEnumerable`
    interface and that it has an `Add` method that has the appropriate number of parameters
    for the call. You can similarly initialize dictionaries (types that implement
    `System.Collections.IDictionary`) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, more succinctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: The latter is valid not only with dictionaries but with any type for which an
    indexer exists.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Whereas a `foreach` statement is a *consumer* of an enumerator, an iterator
    is a *producer* of an enumerator. In this example, we use an iterator to return
    a sequence of Fibonacci numbers (for which each number is the sum of the previous
    two):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: Whereas a `return` statement expresses, “Here’s the value you asked me to return
    from this method,” a `yield return` statement expresses, “Here’s the next element
    you asked me to yield from this enumerator.” On each `yield` statement, control
    is returned to the caller, but the callee’s state is maintained so that the method
    can continue executing as soon as the caller enumerates the next element. The
    lifetime of this state is bound to the enumerator, such that the state can be
    released when the caller has finished enumerating.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The compiler converts iterator methods into private classes that implement `IEnumerable<T>`
    and/or `IEnumerator<T>`. The logic within the iterator block is “inverted” and
    spliced into the `MoveNext` method and the `Current` property on the compiler-written
    enumerator class, which effectively becomes a state machine. This means that when
    you call an iterator method, all you’re doing is instantiating the compiler-written
    class; none of your code actually runs! Your code runs only when you start enumerating
    over the resultant sequence, typically with a `foreach` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Iterator Semantics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An iterator is a method, property, or indexer that contains one or more `yield`
    statements. An iterator must return one of the following four interfaces (otherwise,
    the compiler will generate an error):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterators that return an *enumerator* interface tend to be used less often.
    They’re useful when you’re writing a custom collection class: typically, you name
    the iterator `GetEnumerator` and have your class implement `IEnumerable<T>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Iterators that return an *enumerable* interface are more common—and simpler
    to use because you don’t need to write a collection class. The compiler, behind
    the scenes, writes a private class implementing `IEnumerable<T>` (as well as `IEnumerator<T>`).
  prefs: []
  type: TYPE_NORMAL
- en: Multiple yield statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An iterator can include multiple `yield` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: yield break
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `return` statement is illegal in an iterator block; instead, you must use
    the `yield break` statement to indicate that the iterator block should exit early,
    without returning more elements. We can modify `Foo` as follows to demonstrate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: Composing Sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Iterators are highly composable. We can extend our Fibonacci example by adding
    the following method to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then output even Fibonacci numbers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: Each element is not calculated until the last moment—when requested by a `MoveNext()`
    operation. [Figure 5](#composing_sequence) shows the data requests and data output
    over time.
  prefs: []
  type: TYPE_NORMAL
- en: '![Composing sequences](Images/c12p_0105.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5\. Composing sequences
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The composability of the iterator pattern is essential in building LINQ queries.
  prefs: []
  type: TYPE_NORMAL
- en: Nullable Value Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reference types can represent a nonexistent value with a null reference. Value
    types, however, cannot ordinarily represent null values. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: 'To represent null in a value type, you must use a special construct called
    a *nullable type*. A nullable type is denoted with a value type followed by the
    `?` symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: Nullable<T> Struct
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`T?` translates into `System.Nullable<T>`. `Nullable<T>` is a lightweight immutable
    structure, having only two fields, to represent `Value` and `HasValue`. The essence
    of `System.Nullable<T>` is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: 'translates to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: Attempting to retrieve `Value` when `HasValue` is false throws an `InvalidOperationException`.
    `GetValueOrDefault()` returns `Value` if `HasValue` is true; otherwise, it returns
    `new T()` or a specified custom default value.
  prefs: []
  type: TYPE_NORMAL
- en: The default value of `T?` is `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Nullable Conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The conversion from `T` to `T?` is implicit, while from `T?` to `T` the conversion
    is explicit. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: The explicit cast is directly equivalent to calling the nullable object’s `Value`
    property. Hence, an `InvalidOperationException` is thrown if `HasValue` is false.
  prefs: []
  type: TYPE_NORMAL
- en: Boxing/Unboxing Nullable Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When `T?` is boxed, the boxed value on the heap contains `T`, not `T?`. This
    optimization is possible because a boxed value is a reference type that can already
    express null.
  prefs: []
  type: TYPE_NORMAL
- en: 'C# also permits the unboxing of nullable types with the `as` operator. The
    result will be `null` if the cast fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: Operator Lifting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Nullable<T>` struct does not define operators such as `<`, `>`, or even
    `==`. Despite this, the following code compiles and executes correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: 'This works because the compiler borrows or “lifts” the less-than operator from
    the underlying value type. Semantically, it translates the preceding comparison
    expression into this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: In other words, if both `x` and `y` have values, it compares via `int`’s less-than
    operator; otherwise, it returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Operator lifting means that you can implicitly use `T`’s operators on `T?`.
    You can define operators for `T?` in order to provide special-purpose null behavior,
    but in the vast majority of cases, it’s best to rely on the compiler automatically
    applying systematic nullable logic for you.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler performs null logic differently depending on the category of operator.
  prefs: []
  type: TYPE_NORMAL
- en: Equality operators (==, !=)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Lifted equality operators handle nulls just like reference types do. This means
    two null values are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: 'Further:'
  prefs: []
  type: TYPE_NORMAL
- en: If exactly one operand is null, the operands are unequal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If both operands are non-null, their `Value`s are compared.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relational operators (<, <=, >=, >)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The relational operators work on the principle that it is meaningless to compare
    null operands. This means that comparing a null value to either a null or a non-null
    value returns `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: All other operators (+, −, *, /, %, &, |, ^, <<, >>, +, ++, --, !, ~)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These operators return null when any of the operands are null. This pattern
    should be familiar to SQL users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: An exception is when the `&` and `|` operators are applied to `bool?`, which
    we will discuss shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing nullable and non-nullable types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can mix and match nullable and non-nullable types (this works because there
    is an implicit conversion from `T` to `T?`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: bool? with & and | Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When supplied operands of type `bool?`, the `&` and `|` operators treat `null`
    as an *unknown value*. So, `null | true` is true, because:'
  prefs: []
  type: TYPE_NORMAL
- en: If the unknown value is false, the result would be true.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the unknown value is true, the result would be true.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similarly, `null & false` is false. This behavior should be familiar to SQL
    users. The following example enumerates other combinations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: Nullable Types and Null Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Nullable types work particularly well with the `??` operator (see [“Null-Coalescing
    Operator”](#null_coalescing_operator)). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: Using `??` on a nullable value type is equivalent to calling `GetValueOrDefault`
    with an explicit default value, except that the expression for the default value
    is never evaluated if the variable is not null.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nullable types also work well with the null-conditional operator (see [“Null-Conditional
    Operator”](#null_conditional_operator)). In the following example, `length` evaluates
    to null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: 'We can combine this with the null-coalescing operator to evaluate to zero instead
    of null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: Nullable Reference Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whereas *nullable value types* bring nullability to value types, *nullable reference
    types* (from C# 8) do the opposite. When enabled, they bring (a degree of) *non-nullability*
    to reference types, with the purpose of helping to avoid `NullReference​Excep⁠tion`s.
  prefs: []
  type: TYPE_NORMAL
- en: Nullable reference types introduce a level of safety that’s enforced purely
    by the compiler in the form of warnings when it detects code that’s at risk of
    generating a `NullReference​Excep⁠tion`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable nullable reference types, you must either add the `Nullable` element
    to your *.csproj* project file (if you want to enable it for the entire project):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: 'and/or you can use the following directives in your code, in the places where
    it should take effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: 'After it is enabled, the compiler makes non-nullability the default: if you
    want a reference type to accept nulls without the compiler generating a warning,
    you must apply the `?` suffix to indicate a *nullable reference type*. In the
    following example, `s1` is non-nullable, whereas `s2` is nullable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Because nullable reference types are compile-time constructs, there’s no runtime
    difference between `string` and `string?`. In contrast, nullable value types introduce
    something concrete into the type system—namely, the `Null​a⁠ble<T>` struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following also generates a warning because `x` is not initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: The warning disappears if you initialize `x`, either via a field initializer
    or via code in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler also warns you upon dereferencing a nullable reference type if
    it thinks a `NullReferenceException` might occur. In the following example, accessing
    the string’s `Length` property generates a warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove the warning, you can use the *null-forgiving operator* (`!`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: 'Our use of the null-forgiving operator in this example is dangerous in that
    we could end up throwing the very `NullReferen⁠ce​Exception` we were trying to
    avoid in the first place. We could fix it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: Notice now that we don’t need the null-forgiving operator. This is because the
    compiler performs static analysis and is smart enough to infer—at least in simple
    cases—when a dereference is safe and there’s no chance of a `NullReferenceException.`
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler’s ability to detect and warn is not bulletproof, and there are
    also limits to what’s possible in terms of coverage. For instance, it’s unable
    to know whether an array’s elements have been populated, and so the following
    does not generate a warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: Extension Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Extension methods* allow an existing type to be extended with new methods
    without altering the definition of the original type. An extension method is a
    static method of a static class, where the `this` modifier is applied to the first
    parameter. The type of the first parameter will be the type that is extended.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IsCapitalized` extension method can be called as though it were an instance
    method on a string, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: 'An extension method call, when compiled, is translated back into an ordinary
    static method call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: 'Interfaces can be extended, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: Extension Method Chaining
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Extension methods, like instance methods, provide a tidy way to chain functions.
    Consider the following two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: '`x` and `y` are equivalent, and both evaluate to `"Sausages"`, but `x` uses
    extension methods, whereas `y` uses static methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: Ambiguity and Resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any compatible instance method will always take precedence over an extension
    method—even when the extension method’s parameters are more specifically type-matched.
  prefs: []
  type: TYPE_NORMAL
- en: If two extension methods have the same signature, the extension method must
    be called as an ordinary static method to disambiguate the method to call. If
    one extension method has more specific arguments, however, the more specific method
    takes precedence.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An *anonymous type* is a simple class created on the fly to store a set of
    values. To create an anonymous type, you use the `new` keyword followed by an
    object initializer, specifying the properties and values the type will contain.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: The compiler resolves this by writing a private nested type with read-only properties
    for `Name` (type `string`) and `Age` (type `int`). You must use the `var` keyword
    to reference an anonymous type, because the type’s name is compiler-generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The property name of an anonymous type can be inferred from an expression that
    is itself an identifier; consider, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create arrays of anonymous types as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: Anonymous types are used primarily when you’re writing LINQ queries.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous types are immutable, so instances cannot be modified after creation.
    However, from C# 10, you can use the `with` keyword to create a copy with variations,
    as you would with records. See [“Nondestructive Mutation”](#nondestructive_mutation)
    for an example.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like anonymous types, *tuples* (C# 7+) provide a simple way to store a set of
    values. Tuples were introduced into C# with the main purpose of allowing methods
    to return multiple values without resorting to `out` parameters (something you
    cannot do with anonymous types). Since then, however, *records* have been introduced,
    offering a concise typed approach that we will describe in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to create a *tuple literal* is to list the desired values
    in parentheses. This creates a tuple with *unnamed* elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike with anonymous types, `var` is optional, and you can specify a *tuple
    type* explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that you can usefully return a tuple from a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: 'Tuples play well with generics, so the following types are all legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: Tuples are *value types* with *mutable* (read/write) elements. This means that
    you can modify `Item1`, `Item2`, and so on, after creating a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: Naming Tuple Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can optionally give meaningful names to elements when creating tuple literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: 'You can do the same when specifying *tuple types*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: 'Element names are automatically *inferred* from property or field names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Tuples are syntactic sugar for using a family of generic structs called `ValueTuple<T1>`
    and `ValueTuple<T1,T2>`, which have fields named `Item1`, `Item2`, and so on.
    Hence `(string,int)` is an alias for `ValueTuple<string,int>`. This means that
    “named elements” exist only in the source code—and the imagination of the compiler—and
    mostly disappear at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Deconstructing Tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tuples implicitly support the deconstruction pattern (see [“Deconstructors”](#deconstructors)),
    so you can easily *deconstruct* a tuple into individual variables. Consider the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: 'With the tuple’s deconstructor, you can simplify the code to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax for deconstruction is confusingly similar to the syntax for declaring
    a tuple with named elements! The following highlights the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: Records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *record* (from C# 9) is a special kind of class or struct that’s designed
    to work well with immutable (read-only) data. Its most useful feature is allowing
    *nondestructive mutation*, whereby to “modify” an immutable object, you create
    a new one and copy over the data while incorporating your modifications.
  prefs: []
  type: TYPE_NORMAL
- en: Records are also useful in creating types that just combine or hold data. In
    simple cases, they eliminate boilerplate code while honoring *structural equality*
    semantics (two objects are the same if their data is the same), which is usually
    what you want with immutable types.
  prefs: []
  type: TYPE_NORMAL
- en: A record is purely a C# compile-time construct. At runtime, the CLR sees them
    just as classes or structs (with a bunch of extra “synthesized” members added
    by the compiler).
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Record
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A record definition is like a class or struct definition and can contain the
    same kinds of members, including fields, properties, methods, and so on. Records
    can implement interfaces, and (class-based) records can subclass other (class-based)
    records.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the underlying type of a record is a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: 'From C# 10, the underlying type of a record can also be a struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: (`record class` is also legal and has the same meaning as `record`.)
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple record might contain just a bunch of init-only properties, and perhaps
    a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon compilation, C# transforms the record definition into a class (or struct)
    and performs the following additional steps:'
  prefs: []
  type: TYPE_NORMAL
- en: It writes a protected *copy constructor* (and a hidden *Clone* method) to facilitate
    nondestructive mutation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It overrides/overloads the equality-related functions to implement structural
    equality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It overrides the `ToString()` method (to expand the record’s public properties,
    as with anonymous types).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding record declaration expands into something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: Parameter lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A record definition can be shortened through the use of a *parameter list*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters can include the `in` and `params` modifiers but not `out` or `ref`.
    If a parameter list is specified, the compiler performs the following extra steps:'
  prefs: []
  type: TYPE_NORMAL
- en: It writes an init-only property per parameter (or a writable property, in the
    case of record structs).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It writes a *primary constructor* to populate the properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It writes a deconstructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This means that we can declare our `Point` record simply as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler will end up generating (almost) exactly what we listed in the
    preceding expansion. A minor difference is that the parameter names in the primary
    constructor will end up as `X` and `Y` instead of `x` and `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Also, due to being a *primary constructor*, the parameters `X` and `Y` become
    magically available to any field or property initializers in your record. We discuss
    the subtleties of this later in [“Primary Constructors”](#primary_constructors).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another difference when you define a parameter list is that the compiler also
    generates a deconstructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: 'Records with parameter lists can be subclassed using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler then emits a primary constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Parameter lists offer a nice shortcut when you need a class that simply groups
    together a bunch of values (a *product type* in functional programming), and can
    also be useful for prototyping. They’re not so helpful when you need to add logic
    to the `init` accessors (such as argument validation).
  prefs: []
  type: TYPE_NORMAL
- en: Nondestructive Mutation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most important step that the compiler performs with all records is to write
    a *copy constructor* (and a hidden *Clone* method). This enables nondestructive
    mutation via the `with` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `p2` is a copy of `p1` but with its `Y` property set to 4\.
    The benefit is greater when there are more properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nondestructive mutation occurs in two phases:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the *copy constructor* clones the record. By default, it copies each
    of the record’s underlying fields, creating a faithful replica while bypassing
    (the overhead of) any logic in the `init` accessors. All fields are included (public
    and private, as well as the hidden fields that back automatic properties).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, each property in the *member initializer list* is updated (this time using
    the `init` accessors).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The compiler translates the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: 'into something functionally equivalent to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: (The same code would not compile if you wrote it explicitly because `A` and
    `C` are init-only properties. Furthermore, the copy constructor is *protected*;
    C# works around this by invoking it via a public hidden method that it writes
    into the record called `<Clone>$`.)
  prefs: []
  type: TYPE_NORMAL
- en: 'If necessary, you can define your own *copy constructor*. C# will then use
    your definition instead of writing one itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: 'When subclassing another record, the copy constructor is responsible for copying
    only its own fields. To copy the base record’s fields, delegate to the base:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: Primary Constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you define a record with a parameter list, the compiler generates property
    declarations automatically, as well as a *primary constructor* (and a deconstructor).
    This works well in simple cases, and in more complex cases you can omit the parameter
    list and write the property declarations and constructor manually. C# also offers
    the mildly useful intermediate option of defining a parameter list while writing
    some or all of the property declarations yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we “took over” the `ID` property definition, defining it as read-only
    (instead of init-only), preventing it from partaking in nondestructive mutation.
    If you never need to nondestructively mutate a particular property, making it
    read-only lets you cache computed data in the record without having to code up
    a refresh mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we needed to include a *property initializer* (in boldface):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: When you “take over” a property declaration, you become responsible for initializing
    its value; the primary constructor no longer does this automatically. (This exactly
    matches the behavior when defining primary constructors on classes or structs.)
    Note that the `ID` in boldface refers to the *primary constructor parameter*,
    not the `ID` property.
  prefs: []
  type: TYPE_NORMAL
- en: In keeping with the semantics of primary constructors on classes and structs,
    the primary constructor parameters (`ID`, `Surname`, and `FirstName` in this case)
    are magically visible to all field and property initializers.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also take over a property definition with explicit accessors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: Again, the `ID` in boldface refers to the primary constructor parameter, not
    the property. (The reason for there not being an ambiguity is that it’s illegal
    to access properties from initializers.)
  prefs: []
  type: TYPE_NORMAL
- en: The fact that we must initialize the `_id` property with `ID` makes this “takeover”
    less useful, in that any logic in the `init` accessor (such as validation) will
    get bypassed by the primary constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Records and Equality Comparison
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as with structs, anonymous types, and tuples, records provide structural
    equality out of the box, meaning that two records are equal if their fields (and
    automatic properties) are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: 'The *equality operator* also works with records (as it does with tuples):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike with classes and structs, you do not (and cannot) override the `object.Equals`
    method if you want to customize equality behavior. Instead, you define a public
    `Equals` method with the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: The `Equals` method must be `virtual` (not `override`), and it must be *strongly
    typed* such that it accepts the actual record type (`Point` in this case, not
    `object`). Once you get the signature right, the compiler will automatically patch
    in your method.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with any type, if you take over equality comparison, you should also override
    `GetHashCode()`. A nice feature of records is that you don’t overload `!=` or
    `==`; nor do you implement `IEquatable<T>`: this is all done for you. We cover
    this topic fully in “Equality Comparison” in Chapter 6 of *C# 12 in a Nutshell*.'
  prefs: []
  type: TYPE_NORMAL
- en: Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier, we demonstrated how to use the `is` operator to test whether a reference
    conversion will succeed, and then use its converted value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: 'This employs one kind of pattern called a *type pattern*. The `is` operator
    also supports other patterns that were introduced in recent versions of C#. Patterns
    are supported in the following contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: After the `is` operator (`*variable* is *pattern*`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In switch statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In switch expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ve already covered the type pattern in [“Switching on types”](#switching_on_types)
    and [“The is operator”](#the_is_operator). In this section, we cover more advanced
    patterns that were introduced in recent versions of C#.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the more specialized patterns are intended for use in switch statements/expressions.
    Here, they reduce the need for `when` clauses and let you use switches where you
    couldn’t previously.
  prefs: []
  type: TYPE_NORMAL
- en: var Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *var pattern* is a variation of the *type pattern* whereby you replace
    the type name with the `var` keyword. The conversion always succeeds, so its purpose
    is merely to let you reuse the variable that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: Constant Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *constant pattern* lets you match directly to a constant and is useful
    when working with the `object` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: 'This expression in boldface is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: As we’ll see soon, the constant pattern can become more useful with *pattern
    combinators*.
  prefs: []
  type: TYPE_NORMAL
- en: Relational Patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From C# 9, you can use the `<`, `>`, `<=`, and `>=` operators in patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: 'This becomes meaningfully useful in a `switch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: Pattern Combinators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From C# 9, you can use the `and`, `or`, and `not` keywords to combine patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the `&&` and `||` operators, `and` has higher precedence than `or`.
    You can override this with parentheses. A nice trick is to combine the `not` combinator
    with the *type pattern* to test whether an object is (not) a type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks nicer than:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: Tuple and Positional Patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *tuple pattern* (introduced in C# 8) matches tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: 'The tuple pattern can be considered a special case of the *positional pattern*
    (C# 8+), which matches any type that exposes a `Deconstruct` method (see [“Deconstructors”](#deconstructors)).
    In the following example, we leverage the `Point` record’s compiler-generated
    deconstructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: 'You can deconstruct as you match, using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a switch expression that combines a type pattern with a positional pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: Property Patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *property pattern* (C# 8+) matches on one or more of an object’s property
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this doesn’t save much over the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: 'With switch statements and expressions, property patterns are more useful.
    Consider the `System.Uri` class, which represents a URI. It has properties that
    include `Scheme`, `Host`, `Port`, and `IsLoopback`. In writing a firewall, we
    could decide whether to allow or block a URI by employing a switch expression
    that uses property patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: 'You can nest properties, making the following clause legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: 'which, from C# 10, can be simplified to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use other patterns inside property patterns, including the relational
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: 'You can introduce a variable at the end of a clause and then consume that variable
    in a `when` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also introduce variables at the *property* level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, however, the following is shorter and simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: List Patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: List patterns (from C# 11) work with any collection type that is countable (with
    a `Count` or `Length` property) and indexable (with an indexer of type `int` or
    `System.Index`).
  prefs: []
  type: TYPE_NORMAL
- en: 'A list pattern matches a series of elements in square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: 'An underscore matches a single element of any value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: 'The `var` pattern also works in matching a single element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: 'Two dots indicate a *slice*. A slice matches zero or more elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: 'With arrays and other types that support indices and ranges (see [“Indices
    and Ranges”](#indices_and_ranges)), you can follow a slice with a `var` pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: A list pattern can include at most one slice.
  prefs: []
  type: TYPE_NORMAL
- en: LINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LINQ, or Language Integrated Query, allows you to write structured type-safe
    queries over local object collections and remote data sources. LINQ lets you query
    any collection implementing `IEnumerable<>`, whether an array, list, XML DOM,
    or remote data source (such as a table in SQL Server). LINQ offers the benefits
    of both compile-time type checking and dynamic query composition.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A good way to experiment with LINQ is to [download LINQPad](http://www.linqpad.net).
    LINQPad lets you interactively query local collections and SQL databases in LINQ
    without any setup and is preloaded with numerous examples.
  prefs: []
  type: TYPE_NORMAL
- en: LINQ Fundamentals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basic units of data in LINQ are *sequences* and *elements*. A sequence
    is any object that implements the generic `IEnumerable` interface, and an element
    is each item in the sequence. In the following example, `names` is a sequence,
    and `Tom`, `Dick`, and `Harry` are elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: We call a sequence such as this a *local sequence* because it represents a local
    collection of objects in memory.
  prefs: []
  type: TYPE_NORMAL
- en: A *query operator* is a method that transforms a sequence. A typical query operator
    accepts an *input sequence* and emits a transformed *output sequence*. In the
    `Enumerable` class in `System.Linq`, there are around 40 query operators, all
    implemented as static extension methods. These are called *standard query operators*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: LINQ also supports sequences that can be dynamically fed from a remote data
    source such as SQL Server. These sequences additionally implement the `IQueryable<>`
    interface and are supported through a matching set of standard query operators
    in the `Queryable` class.
  prefs: []
  type: TYPE_NORMAL
- en: A simple query
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *query* is an expression that transforms sequences with one or more query
    operators. The simplest query comprises one input sequence and one operator. For
    instance, we can apply the `Where` operator on a simple array to extract those
    names whose length is at least four characters, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the standard query operators are implemented as extension methods,
    we can call `Where` directly on `names`, as though it were an instance method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: '(For this to compile, you must import the `System.Linq` namespace with a `using`
    directive.) The `Where` method in `System.Linq.Enumerable` has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: '`source` is the *input sequence*; `predicate` is a delegate that is invoked
    on each input *element*. The `Where` method includes all elements in the *output
    sequence* for which the delegate returns `true`. Internally, it’s implemented
    with an iterator—here’s its source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: Projecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another fundamental query operator is the `Select` method. This transforms
    (*projects*) each element in the input sequence with a given lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: 'A query can project into an anonymous type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: Take and Skip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The original ordering of elements within an input sequence is significant in
    LINQ. Some query operators rely on this behavior, such as `Take`, `Skip`, and
    `Reverse`. The `Take` operator outputs the first *x* elements, discarding the
    rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Skip` operator ignores the first *x* elements and outputs the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: From .NET 6, there are also `TakeLast` and `SkipLast` methods, which take or
    skip the last *n* elements. Additionally, the `Take` method has been overloaded
    to accept a `Range` variable. This overload can subsume the functionality of all
    four methods; for instance, `Take(5..)` is equivalent to `Skip(5)`, and `Take(..^5)`
    is equivalent to `SkipLast(5)`.
  prefs: []
  type: TYPE_NORMAL
- en: Element operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Not all query operators return a sequence. The *element* operators extract
    one element from the input sequence; examples are `First`, `Last`, `Single`, and
    `ElementAt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: All of these operators throw an exception if no elements are present. To avoid
    the exception, use `FirstOrDefault`, `LastOrDefault`, `SingleOrDefault`, or `ElementAtOrDefault`—these
    return `null` (or the `default` value for value types) when no element is found.
  prefs: []
  type: TYPE_NORMAL
- en: The `Single` and `SingleOrDefault` methods are equivalent to `First` and `FirstOrDefault`
    except that they throw an exception if there’s more than one match. This behavior
    is useful when you’re querying a database table for a row by primary key.
  prefs: []
  type: TYPE_NORMAL
- en: 'From .NET 6, there are also `MinBy` and `MaxBy` methods, which return the element
    with the lowest or highest value, as determined by a key selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: Aggregation operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *aggregation* operators return a scalar value, usually of numeric type.
    The most commonly used aggregation operators are `Count`, `Min`, `Max`, and `Average`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: '`Count` accepts an optional predicate, which indicates whether to include a
    given element. The following counts all even numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Min`, `Max`, and `Average` operators accept an optional argument that
    transforms each element prior to it being aggregated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: 'The following calculates the root mean square of `numbers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: Quantifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *quantifiers* return a `bool` value. The quantifiers are `Contains`, `Any`,
    `All`, and `SequenceEquals` (which compares two sequences):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: Set operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *set* operators accept two same-typed input sequences. `Concat` appends
    one sequence to another; `Union` does the same but with duplicates removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: 'The other two operators in this category are `Intersect` and `Except`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: 'From .NET 6, there are also set operators that take a key selector (`UnionBy`,
    `ExceptBy`, `IntersectBy`). The key selector is used in determining whether an
    element counts as a duplicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: Deferred Execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An important feature of many query operators is that they execute not when
    constructed but when *enumerated* (in other words, when `MoveNext` is called on
    its enumerator). Consider the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: 'The extra number that we sneaked into the list *after* constructing the query
    is included in the result because it’s not until the `foreach` statement runs
    that any filtering or sorting takes place. This is called *deferred* or *lazy*
    evaluation. Deferred execution decouples query *construction* from query *execution*,
    allowing you to construct a query in several steps, as well as making it possible
    to query a database without retrieving all the rows to the client. All standard
    query operators provide deferred execution, with the following exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: Operators that return a single element or scalar value (the *element operators*,
    *aggregation operators*, and *quantifiers*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *conversion* operators `ToArray`, `ToList`, `ToDictionary`, `ToLookup`,
    and `ToHashSet`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The conversion operators are handy, in part because they defeat lazy evaluation.
    This can be useful to “freeze” or cache the results at a certain point in time,
    to avoid re-executing a computationally intensive or remotely sourced query such
    as an Entity Framework table. (A side effect of lazy evaluation is that the query
    is reevaluated should you later re-enumerate it.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates the `ToList` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Subqueries provide another level of indirection. Everything in a subquery is
    subject to deferred execution, including aggregation and conversion methods, because
    the subquery is itself executed only lazily upon demand. Assuming `names` is a
    string array, a subquery looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: Standard Query Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can divide the standard query operators (as implemented in the `System.Linq.Enumerable`
    class) into 12 categories, as summarized in [Table 1](#query_operator_categories).
  prefs: []
  type: TYPE_NORMAL
- en: Table 1\. Query operator categories
  prefs: []
  type: TYPE_NORMAL
- en: '| Category | Description | Deferred execution? |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Filtering | Returns a subset of elements that satisfy a given condition |
    Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Projecting | Transforms each element with a lambda function, optionally expanding
    subsequences | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Joining | Meshes elements of one collection with another, using a time-efficient
    lookup strategy | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Ordering | Returns a reordering of a sequence | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Grouping | Groups a sequence into subsequences | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Set | Accepts two same-typed sequences and returns their commonality, sum,
    or difference | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Element | Picks a single element from a sequence | No |'
  prefs: []
  type: TYPE_TB
- en: '| Aggregation | Performs a computation over a sequence, returning a scalar
    value (typically a number) | No |'
  prefs: []
  type: TYPE_TB
- en: '| Quantification | Performs a computation over a sequence, returning `true`
    or `false` | No |'
  prefs: []
  type: TYPE_TB
- en: '| Conversion: Import | Converts a nongeneric sequence to a (queryable) generic
    sequence | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Conversion: Export | Converts a sequence to an array, list, dictionary, or
    lookup, forcing immediate evaluation | No |'
  prefs: []
  type: TYPE_TB
- en: '| Generation | Manufactures a simple sequence | Yes |'
  prefs: []
  type: TYPE_TB
- en: Tables [2](#filtering_operators) through [13](#generation_operators) summarize
    each query operator. The operators shown in bold have special support in C# (see
    [“Query Expressions”](#query_expressions)).
  prefs: []
  type: TYPE_NORMAL
- en: Table 2\. Filtering operators
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `**Where**` | Returns a subset of elements that satisfy a given condition
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Take` | Returns the first *x* elements, and discards the rest |'
  prefs: []
  type: TYPE_TB
- en: '| `Skip` | Ignores the first *x* elements, and returns the rest |'
  prefs: []
  type: TYPE_TB
- en: '| `TakeLast` | Returns the last *x* elements, and discards the rest |'
  prefs: []
  type: TYPE_TB
- en: '| `SkipLast` | Ignores the last *x* elements, and returns the rest |'
  prefs: []
  type: TYPE_TB
- en: '| `TakeWhile` | Emits elements from the input sequence until the given predicate
    is true |'
  prefs: []
  type: TYPE_TB
- en: '| `SkipWhile` | Ignores elements from the input sequence until the given predicate
    is true and then emits the rest |'
  prefs: []
  type: TYPE_TB
- en: '| `Distinct`, `DistinctBy` | Returns a collection that excludes duplicates
    |'
  prefs: []
  type: TYPE_TB
- en: Table 3\. Projection operators
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `**Select**` | Transforms each input element with a given lambda expression
    |'
  prefs: []
  type: TYPE_TB
- en: '| `**SelectMany**` | Transforms each input element and then flattens and concatenates
    the resultant subsequences |'
  prefs: []
  type: TYPE_TB
- en: Table 4\. Joining operators
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `**Join**` | Applies a lookup strategy to match elements from two collections,
    emitting a flat result set |'
  prefs: []
  type: TYPE_TB
- en: '| `**GroupJoin**` | As above, but emits a *hierarchical* result set |'
  prefs: []
  type: TYPE_TB
- en: '| `Zip` | Enumerates two sequences in step, returning a sequence that applies
    a function over each element pair |'
  prefs: []
  type: TYPE_TB
- en: Table 5\. Ordering operators
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `**OrderBy**`, `**ThenBy**` | Returns the elements sorted in ascending order
    |'
  prefs: []
  type: TYPE_TB
- en: '| `**OrderByDescending**`, `**ThenByDescending**` | Returns the elements sorted
    in descending order |'
  prefs: []
  type: TYPE_TB
- en: '| `Reverse` | Returns the elements in reverse order |'
  prefs: []
  type: TYPE_TB
- en: Table 6\. Grouping operators
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `**GroupBy**` | Groups a sequence into subsequences |'
  prefs: []
  type: TYPE_TB
- en: '| `Chunk` | Groups a sequence into chunks of a given size |'
  prefs: []
  type: TYPE_TB
- en: Table 7\. Set operators
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Concat` | Concatenates two sequences |'
  prefs: []
  type: TYPE_TB
- en: '| `Union`, `UnionBy` | Concatenates two sequences, removing duplicates |'
  prefs: []
  type: TYPE_TB
- en: '| `Intersect`, `IntersectBy` | Returns elements present in both sequences |'
  prefs: []
  type: TYPE_TB
- en: '| `Except`, `ExceptBy` | Returns elements present in the first sequence but
    not the second |'
  prefs: []
  type: TYPE_TB
- en: Table 8\. Element operators
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `First`, `FirstOrDefault` | Returns the first element in the sequence, or
    the first element satisfying a given predicate |'
  prefs: []
  type: TYPE_TB
- en: '| `Last`, `LastOrDefault` | Returns the last element in the sequence, or the
    last element satisfying a given predicate |'
  prefs: []
  type: TYPE_TB
- en: '| `Single`, `SingleOrDefault` | Equivalent to `First`/`FirstOrDefault` but
    throws an exception if there is more than one match |'
  prefs: []
  type: TYPE_TB
- en: '| `MinBy`, `MaxBy` | Returns the element with the smallest or largest value,
    as determined by a key selector |'
  prefs: []
  type: TYPE_TB
- en: '| `ElementAt`, `ElementAtOrDefault` | Returns the element at the specified
    position |'
  prefs: []
  type: TYPE_TB
- en: '| `DefaultIfEmpty` | Returns a single-value sequence whose value is null or
    `default(TSource)` if the sequence has no elements |'
  prefs: []
  type: TYPE_TB
- en: Table 9\. Aggregation operators
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Count`, `LongCount` | Returns the total number of elements in the input
    sequence, or the number of elements satisfying a given predicate |'
  prefs: []
  type: TYPE_TB
- en: '| `Min`, `Max` | Returns the smallest or largest element in the sequence |'
  prefs: []
  type: TYPE_TB
- en: '| `Sum`, `Average` | Calculates a numeric sum or average over elements in the
    sequence |'
  prefs: []
  type: TYPE_TB
- en: '| `Aggregate` | Performs a custom aggregation |'
  prefs: []
  type: TYPE_TB
- en: Table 10\. Quantifiers
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Contains` | Returns `true` if the input sequence contains the given element
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Any` | Returns `true` if any elements satisfy the given predicate |'
  prefs: []
  type: TYPE_TB
- en: '| `All` | Returns `true` if all elements satisfy the given predicate |'
  prefs: []
  type: TYPE_TB
- en: '| `SequenceEqual` | Returns `true` if the second sequence has identical elements
    to the input sequence |'
  prefs: []
  type: TYPE_TB
- en: Table 11\. Conversion operators (import)
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `OfType` | Converts `IEnumerable` to `IEnumerable<T>`, discarding wrongly
    typed elements |'
  prefs: []
  type: TYPE_TB
- en: '| `**Cast**` | Converts `IEnumerable` to `IEnumerable<T>`, throwing an exception
    if there are any wrongly typed elements |'
  prefs: []
  type: TYPE_TB
- en: Table 12\. Conversion operators (export)
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ToArray` | Converts `IEnumerable<T>` to `T[]` |'
  prefs: []
  type: TYPE_TB
- en: '| `ToList` | Converts `IEnumerable<T>` to `List<T>` |'
  prefs: []
  type: TYPE_TB
- en: '| `ToDictionary` | Converts `IEnumerable<T>` to `Dictionary<TKey,TValue>` |'
  prefs: []
  type: TYPE_TB
- en: '| `ToHashSet` | Converts `IEnumerable<T>` to `HashSet<T>` |'
  prefs: []
  type: TYPE_TB
- en: '| `ToLookup` | Converts `IEnumerable<T>` to `ILookup<TKey,TElement>` |'
  prefs: []
  type: TYPE_TB
- en: '| `AsEnumerable` | Downcasts to `IEnumerable<T>` |'
  prefs: []
  type: TYPE_TB
- en: '| `AsQueryable` | Casts or converts to `IQueryable<T>` |'
  prefs: []
  type: TYPE_TB
- en: Table 13\. Generation operators
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Empty` | Creates an empty sequence |'
  prefs: []
  type: TYPE_TB
- en: '| `Repeat` | Creates a sequence of repeating elements |'
  prefs: []
  type: TYPE_TB
- en: '| `Range` | Creates a sequence of integers |'
  prefs: []
  type: TYPE_TB
- en: Chaining Query Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build more complex queries, you chain query operators together. For example,
    the following query extracts all strings containing the letter *a*, sorts them
    by length, and then converts the results to uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: '`Where`, `OrderBy`, and `Select` are all standard query operators that resolve
    to extension methods in the `Enumerable` class. The `Where` operator emits a filtered
    version of the input sequence, `OrderBy` emits a sorted version of its input sequence,
    and `Select` emits a sequence in which each input element is transformed or *projected*
    with a given lambda expression (`n.To​Up⁠per()` in this case). Data flows from
    left to right through the chain of operators, so the data is first filtered, then
    sorted, then projected. The end result resembles a production line of conveyor
    belts, as illustrated in [Figure 6](#chaining_query_operators).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chaining query operators](Images/c12p_0106.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6\. Chaining query operators
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Deferred execution is honored throughout with operators, so no filtering, sorting,
    or projecting takes place until the query is actually enumerated.
  prefs: []
  type: TYPE_NORMAL
- en: Query Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we’ve written queries by calling extension methods in the `Enumerable`
    class. In this book, we describe this as *fluent syntax*. C# also provides special
    language support for writing queries, called *query expressions*. Here’s the preceding
    query expressed as a query expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: A query expression always starts with a `from` clause, and ends with either
    a `select` or `group` clause. The `from` clause declares a *range variable* (in
    this case, `n`), which you can think of as traversing the input collection—rather
    like `foreach`. [Figure 7](#query_expression_syntax) illustrates the complete
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '![Query expression syntax](Images/c12p_0107.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7\. Query expression syntax
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you’re familiar with SQL, LINQ’s query expression syntax—with the `from`
    clause first and the `select` clause last—might look bizarre. Query expression
    syntax is actually more logical because the clauses appear *in the order they’re
    executed*. This allows Visual Studio to prompt you with IntelliSense as you type
    and simplifies the scoping rules for subqueries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler processes query expressions by translating them to fluent syntax.
    It does this in a fairly mechanical fashion—much like it translates `foreach`
    statements into calls to `GetEnumerator` and `MoveNext`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: The `Where`, `OrderBy`, and `Select` operators then resolve using the same rules
    that would apply if the query were written in fluent syntax. In this case, they
    bind to extension methods in the `Enumerable` class (assuming that you’ve imported
    the `System.Linq` namespace) because `names` implements `IEnumerable<string>`.
    The compiler doesn’t specifically favor the `Enumerable` class, however, when
    translating query syntax. You can think of the compiler as mechanically injecting
    the words *Where*, *OrderBy*, and *Select* into the statement and then compiling
    it as though you’d typed the method names yourself. This offers flexibility in
    how they resolve—the operators in Entity Framework queries, for instance, bind
    instead to the extension methods in the `Queryable` class.
  prefs: []
  type: TYPE_NORMAL
- en: Query expressions versus fluent queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Query expressions and fluent queries each have advantages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Query expressions support only a small subset of query operators, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: 'For queries that use other operators, you must either write entirely in fluent
    syntax or construct mixed-syntax queries; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: This query returns names whose length matches that of the shortest (“Tom” and
    “Jay”). The subquery (in bold) calculates the minimum length of each name and
    evaluates to 3\. We need to use fluent syntax for the subquery, because the `Min`
    operator has no support in query expression syntax. We can, however, still use
    query syntax for the outer query.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main advantage of query syntax is that it can radically simplify queries
    that involve the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A `let` clause for introducing a new variable alongside the range variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple generators (`SelectMany`) followed by an outer range variable reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Join` or `GroupJoin` equivalent followed by an outer range variable reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The let Keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `let` keyword introduces a new variable alongside the range variable. For
    instance, suppose that you want to list all names whose length, without vowels,
    is greater than two characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from enumerating this query is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: The `let` clause performs a calculation on each element, without losing the
    original element. In our query, the subsequent clauses (`where`, `orderby`, and
    `select`) have access to both `n` and `vowelless`. A query can include multiple
    `let` clauses, and they can be interspersed with additional `where` and `join`
    clauses.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler translates the `let` keyword by projecting into a temporary anonymous
    type that contains both the original and transformed elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: Query Continuations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to add clauses *after* a `select` or `group` clause, you must use
    the `into` keyword to “continue” the query. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: Following an `into` clause, the previous range variable is out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler simply translates queries with an `into` keyword into a longer
    chain of operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: (It omits the final `Select(upper=>upper)` because it’s redundant.)
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Generators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A query can include multiple generators (`from` clauses). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is a cross product, rather like you’d get with nested `foreach`
    loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: 'When there’s more than one `from` clause in a query, the compiler emits a call
    to `SelectMany`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: '`SelectMany` performs nested looping. It enumerates every element in the source
    collection (`numbers`), transforming each element with the first lambda expression
    (`letters`). This generates a sequence of *subsequences*, which it then enumerates.
    The final output elements are determined by the second lambda expression (`n.ToString()+l`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you subsequently apply a `where` clause, you can filter the cross product
    and project a result akin to a *join*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: The translation of this query into fluent syntax is more complex, requiring
    a temporary anonymous projection. The ability to perform this translation automatically
    is one of the key benefits of query expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The expression in the second generator is allowed to use the first range variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE600]'
  prefs: []
  type: TYPE_PRE
- en: This works because the expression `fullName.Split` emits a *sequence* (an array
    of strings).
  prefs: []
  type: TYPE_NORMAL
- en: Multiple generators are used extensively in database queries to flatten parent–child
    relationships and to perform manual joins.
  prefs: []
  type: TYPE_NORMAL
- en: Joining
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LINQ provides three *joining* operators, the main ones being `Join` and `GroupJoin`,
    which perform keyed lookup-based joins. `Join` and `GroupJoin` support only a
    subset of the functionality you get with multiple generators/`SelectMany`, but
    are more performant with local queries because they use a hashtable-based lookup
    strategy rather than performing nested loops. (With Entity Framework queries,
    the joining operators have no advantage over multiple generators.)
  prefs: []
  type: TYPE_NORMAL
- en: '`Join` and `GroupJoin` support only *equi-joins* (i.e., the joining condition
    must use the equality operator). There are two methods: `Join` and `GroupJoin`.
    `Join` emits a flat result set, whereas `GroupJoin` emits a hierarchical result
    set.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the query expression syntax for a flat join:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE601]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, consider the following collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE602]'
  prefs: []
  type: TYPE_PRE
- en: 'We could perform a join as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE603]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler translates this to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE604]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE605]'
  prefs: []
  type: TYPE_PRE
- en: 'With local sequences, `Join` and `GroupJoin` are more efficient at processing
    large collections than `SelectMany` because they first preload the inner sequence
    into a keyed hashtable-based lookup. With a database query, however, you could
    achieve the same result equally efficiently as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE606]'
  prefs: []
  type: TYPE_PRE
- en: GroupJoin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`GroupJoin` does the same work as `Join`, but instead of yielding a flat result,
    it yields a hierarchical result, grouped by each outer element.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The query expression syntax for `GroupJoin` is the same as for `Join`, but
    is followed by the `into` keyword. Here’s a basic example, using the `customers`
    and `purchases` collections we set up in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE607]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'An `into` clause translates to `GroupJoin` only when it appears directly after
    a `join` clause. After a `select` or `group` clause, it means *query continuation*.
    The two uses of the `into` keyword are quite different, although they have one
    feature in common: they both introduce a new query variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is a sequence of sequences—`IEnumerable<IEnumerable<T>>`—which you
    could enumerate as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE608]'
  prefs: []
  type: TYPE_PRE
- en: 'This isn’t very useful, however, because `outerSeq` has no reference to the
    outer customer. More commonly, you’d reference the outer range variable in the
    projection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE609]'
  prefs: []
  type: TYPE_PRE
- en: 'You could obtain the same result (but less efficiently, for local queries)
    by projecting into an anonymous type that included a subquery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE610]'
  prefs: []
  type: TYPE_PRE
- en: Zip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Zip` is the simplest joining operator. It enumerates two sequences in step
    (like a zipper), returning a sequence based on applying a function over each element
    pair; thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE611]'
  prefs: []
  type: TYPE_PRE
- en: 'produces a sequence with the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE612]'
  prefs: []
  type: TYPE_PRE
- en: Extra elements in either input sequence are ignored. `Zip` is not supported
    when you are querying a database.
  prefs: []
  type: TYPE_NORMAL
- en: Ordering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `orderby` keyword sorts a sequence. You can specify any number of expressions
    upon which to sort:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE613]'
  prefs: []
  type: TYPE_PRE
- en: 'This sorts first by length and then by name, yielding this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE614]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler translates the first `orderby` expression to a call to `OrderBy`,
    and subsequent expressions to a call to `ThenBy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE615]'
  prefs: []
  type: TYPE_PRE
- en: The `ThenBy` operator *refines* rather than *replaces* the previous sorting.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can include the `descending` keyword after any of the `orderby` expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE616]'
  prefs: []
  type: TYPE_PRE
- en: 'This translates to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE617]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The ordering operators return an extended type of `IEnumerable<T>` called `IOrderedEnumerable<T>`.
    This interface defines the extra functionality required by the `ThenBy` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`GroupBy` organizes a flat input sequence into sequences of *groups*. For example,
    the following groups a sequence of names by their length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE618]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler translates this query into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE619]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how to enumerate the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE620]'
  prefs: []
  type: TYPE_PRE
- en: '`Enumerable.GroupBy` works by reading the input elements into a temporary dictionary
    of lists so that all elements with the same key end up in the same sublist. It
    then emits a sequence of *groupings*. A grouping is a sequence with a `Key` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE621]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the elements in each grouping are untransformed input elements,
    unless you specify an `elementSelector` argument. The following projects each
    input element to uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE622]'
  prefs: []
  type: TYPE_PRE
- en: 'which translates to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE623]'
  prefs: []
  type: TYPE_PRE
- en: 'The subcollections are not emitted in order of key. `GroupBy` does no *sorting*
    (in fact, it preserves the original ordering). To sort, you must add an `OrderBy`
    operator (which means first adding an `into` clause, because `group by` ordinarily
    ends a query):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE624]'
  prefs: []
  type: TYPE_PRE
- en: 'Query continuations are often used in a `group by` query. The next query filters
    out groups that have exactly two matches in them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE625]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A `where` after a `group by` is equivalent to `HAVING` in SQL. It applies to
    each subsequence or grouping as a whole rather than the individual elements.
  prefs: []
  type: TYPE_NORMAL
- en: OfType and Cast
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`OfType` and `Cast` accept a nongeneric `IEnumerable` collection and emit a
    generic `IEnumerable<T>` sequence that you can subsequently query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE626]'
  prefs: []
  type: TYPE_PRE
- en: This is useful because it allows you to query collections written prior to C#
    2.0 (when `IEnumerable<T>` was introduced), such as `ControlCollection` in `System.Windows.Forms`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Cast` and `OfType` differ in their behavior when encountering an input element
    that’s of an incompatible type: `Cast` throws an exception, whereas `OfType` ignores
    the incompatible element.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules for element compatibility follow those of C#’s `is` operator. Here’s
    the internal implementation of `Cast`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE627]'
  prefs: []
  type: TYPE_PRE
- en: 'C# supports the `Cast` operator in query expressions—simply insert the element
    type immediately after the `from` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE628]'
  prefs: []
  type: TYPE_PRE
- en: 'This translates to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE629]'
  prefs: []
  type: TYPE_PRE
- en: Dynamic Binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Dynamic binding* defers *binding*—the process of resolving types, members,
    and operators—from compile time to runtime. Dynamic binding is useful when at
    compile time *you* know that a certain function, member, or operator exists, but
    the *compiler* does not. This commonly occurs when you are interoperating with
    dynamic languages (such as IronPython) and COM and in scenarios when you might
    otherwise use reflection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A dynamic type is declared by using the contextual keyword `dynamic`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE630]'
  prefs: []
  type: TYPE_PRE
- en: A dynamic type instructs the compiler to relax. We expect the runtime type of
    `d` to have a `Quack` method. We just can’t prove it statically. Because `d` is
    dynamic, the compiler defers binding `Quack` to `d` until runtime. Understanding
    what this means requires distinguishing between *static binding* and *dynamic
    binding*.
  prefs: []
  type: TYPE_NORMAL
- en: Static Binding Versus Dynamic Binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The canonical binding example is mapping a name to a specific function when
    compiling an expression. To compile the following expression, the compiler needs
    to find the implementation of the method named `Quack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE631]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s suppose the static type of `d` is `Duck`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE632]'
  prefs: []
  type: TYPE_PRE
- en: In the simplest case, the compiler does the binding by looking for a parameterless
    method named `Quack` on `Duck`. Failing that, the compiler extends its search
    to methods taking optional parameters, methods on base classes of `Duck`, and
    extension methods that take `Duck` as its first parameter. If no match is found,
    you’ll get a compilation error. Regardless of what method is bound, the bottom
    line is that the binding is done by the compiler, and the binding utterly depends
    on statically knowing the types of the operands (in this case, `d`). This makes
    it *static binding*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s change the static type of `d` to `object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE633]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `Quack` gives us a compilation error because although the value stored
    in `d` can contain a method called `Quack`, the compiler cannot know it given
    that the only information it has is the type of the variable, which in this case
    is `object`. But let’s now change the static type of `d` to `dynamic`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE634]'
  prefs: []
  type: TYPE_PRE
- en: A `dynamic` type is like `object`—it’s equally nondescriptive about a type.
    The difference is that it lets you use it in ways that aren’t known at compile
    time. A dynamic object binds at runtime based on its runtime type, not its compile-time
    type. When the compiler sees a dynamically bound expression (which in general
    is an expression that contains any value of type `dynamic`), it merely packages
    up the expression such that the binding can be done later at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: At runtime, if a dynamic object implements `IDynamicMeta​Ob⁠jectProvider`, that
    interface is used to perform the binding. If not, binding occurs in almost the
    same way as it would have had the compiler known the dynamic object’s runtime
    type. These two alternatives are called *custom binding* and *language binding*.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Custom binding occurs when a dynamic object implements `IDynamicMetaObjectProvider`
    (IDMOP). Although you can implement IDMOP on types that you write in C#, and this
    is useful to do, the more common case is that you have acquired an IDMOP object
    from a dynamic language that is implemented in .NET on the Dynamic Language Runtime
    (DLR), such as IronPython or IronRuby. Objects from those languages implicitly
    implement IDMOP as a means to directly control the meanings of operations performed
    on them. Here’s a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE635]'
  prefs: []
  type: TYPE_PRE
- en: The `Duck` class doesn’t actually have a `Quack` method. Instead, it uses custom
    binding to intercept and interpret all method calls. We discuss custom binders
    in detail in *C# 12 in a Nutshell*.
  prefs: []
  type: TYPE_NORMAL
- en: Language Binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Language binding occurs when a dynamic object does not implement `IDynamicMetaObjectProvider`.
    Language binding is useful when you are working around imperfectly designed types
    or inherent limitations in the .NET type system. For example, the built-in numeric
    types are imperfect in that they have no common interface. We have seen that methods
    can be bound dynamically; the same is true for operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE636]'
  prefs: []
  type: TYPE_PRE
- en: The benefit is obvious—you don’t need to duplicate code for each numeric type.
    However, you lose static type safety, risking runtime exceptions rather than compile-time
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Dynamic binding circumvents static type safety but not runtime type safety.
    Unlike with reflection, you cannot circumvent member accessibility rules with
    dynamic binding.
  prefs: []
  type: TYPE_NORMAL
- en: By design, language runtime binding behaves as similarly as possible to static
    binding, had the runtime types of the dynamic objects been known at compile time.
    In the previous example, the behavior of our program would be identical if we
    hardcoded `Mean` to work with the `int` type. The most notable exception in parity
    between static and dynamic binding is for extension methods, which we discuss
    in [“Uncallable Functions”](#uncallable_functions).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Dynamic binding also incurs a performance hit. Because of the DLR’s caching
    mechanisms, however, repeated calls to the same dynamic expression are optimized,
    allowing you to efficiently call dynamic expressions in a loop. This optimization
    brings the typical overhead for a simple dynamic expression on today’s hardware
    down to less than 100 ns.
  prefs: []
  type: TYPE_NORMAL
- en: RuntimeBinderException
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If a member fails to bind, a `RuntimeBinderException` is thrown. You can think
    of this as a compile-time error at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE637]'
  prefs: []
  type: TYPE_PRE
- en: The exception is thrown because the `int` type has no `Hello` method.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime Representation of dynamic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a deep equivalence between the `dynamic` and `object` types. The runtime
    treats the following expression as `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE638]'
  prefs: []
  type: TYPE_PRE
- en: 'This principle extends to constructed types and array types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE639]'
  prefs: []
  type: TYPE_PRE
- en: 'Like an object reference, a dynamic reference can point to an object of any
    type (except pointer types):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE640]'
  prefs: []
  type: TYPE_PRE
- en: 'Structurally, there is no difference between an object reference and a dynamic
    reference. A dynamic reference simply enables dynamic operations on the object
    it points to. You can convert from `object` to `dynamic` to perform any dynamic
    operation you want on an `object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE641]'
  prefs: []
  type: TYPE_PRE
- en: Dynamic Conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `dynamic` type has implicit conversions to and from all other types. For
    a conversion to succeed, the runtime type of the dynamic object must be implicitly
    convertible to the target static type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example throws a `RuntimeBinderException` because an `int` is
    not implicitly convertible to a `short`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE642]'
  prefs: []
  type: TYPE_PRE
- en: var Versus dynamic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `var` and `dynamic` types bear a superficial resemblance, but the difference
    is deep:'
  prefs: []
  type: TYPE_NORMAL
- en: '`var` says, “Let the *compiler* figure out the type.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dynamic` says, “Let the *runtime* figure out the type.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To illustrate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE643]'
  prefs: []
  type: TYPE_PRE
- en: Dynamic Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fields, properties, methods, events, constructors, indexers, operators, and
    conversions can all be called dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Trying to consume the result of a dynamic expression with a `void` return type
    is prohibited—just as with a statically typed expression. The difference is that
    the error occurs at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expressions involving dynamic operands are typically themselves dynamic, since
    the effect of absent type information is cascading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE644]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple of obvious exceptions to this rule. First, casting a dynamic
    expression to a static type yields a static expression. Second, constructor invocations
    always yield static expressions—even when called with dynamic arguments.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, there are a few edge cases for which an expression containing a
    dynamic argument is static, including passing an index to an array and delegate
    creation expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Member Overload Resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The canonical use case for `dynamic` involves a dynamic *receiver*. This means
    that a dynamic object is the receiver of a dynamic function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE645]'
  prefs: []
  type: TYPE_PRE
- en: 'However, dynamic binding is not limited to receivers: the method arguments
    are also eligible for dynamic binding. The effect of calling a function with dynamic
    arguments is to defer overload resolution from compile time to runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE646]'
  prefs: []
  type: TYPE_PRE
- en: Runtime overload resolution is also called *multiple dispatch* and is useful
    in implementing design patterns such as *visitor*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a dynamic receiver is not involved, the compiler can statically perform
    a basic check to see whether the dynamic call will succeed: it checks that a function
    with the right name and number of parameters exists. If no candidate is found,
    you get a compile-time error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If a function is called with a mixture of dynamic and static arguments, the
    final choice of method will reflect a mixture of dynamic and static binding decisions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE647]'
  prefs: []
  type: TYPE_PRE
- en: The call to `X(o,d)` is dynamically bound because one of its arguments, `d`,
    is `dynamic`. But because `o` is statically known, the binding—even though it
    occurs dynamically—will make use of that. In this case, overload resolution will
    pick the second implementation of `X` due to the static type of `o` and the runtime
    type of `d`. In other words, the compiler is “as static as it can possibly be.”
  prefs: []
  type: TYPE_NORMAL
- en: Uncallable Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some functions cannot be called dynamically. You cannot call the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Extension methods (via extension method syntax)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any member of an interface (via the interface)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Base members hidden by a subclass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is because dynamic binding requires two pieces of information: the name
    of the function to call, and the object upon which to call the function. However,
    in each of the three uncallable scenarios, an *additional type* is involved, which
    is known only at compile time. And there is no way to specify these additional
    types dynamically.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are calling extension methods, that additional type is an extension
    class, chosen implicitly by virtue of `using` directives in your source code (which
    disappear after compilation). When calling members via an interface, you communicate
    the additional type via an implicit or explicit cast. (With explicit implementation,
    it’s in fact impossible to call a member without casting to the interface.) A
    similar situation arises when you are calling a hidden base member: you must specify
    an additional type via either a cast or the `base` keyword—and that additional
    type is lost at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: Operator Overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can overload operators to provide more natural syntax for custom types.
    Operator overloading is most appropriately used for implementing custom structs
    that represent fairly primitive data types. For example, a custom numeric type
    is an excellent candidate for operator overloading.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can overload the following symbolic operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE648]'
  prefs: []
  type: TYPE_PRE
- en: You can override implicit and explicit conversions (with the `implicit` and
    `explicit` keywords), as you can the `true` and `false` operators.
  prefs: []
  type: TYPE_NORMAL
- en: The compound assignment operators (e.g., `+=`, `/=`) are automatically overridden
    when you override the noncompound operators (e.g., `+`, `/`).
  prefs: []
  type: TYPE_NORMAL
- en: Operator Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To overload an operator, you declare an *operator function*. An operator function
    must be static, and at least one of the operands must be the type in which the
    operator function is declared.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we define a struct called `Note`, representing a
    musical note, and then overload the `+` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE649]'
  prefs: []
  type: TYPE_PRE
- en: 'This overload allows us to add an `int` to a `Note`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE650]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we overrode `+`, we can use `+=` too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE651]'
  prefs: []
  type: TYPE_PRE
- en: 'From C# 11, you can also declare a `checked` version that will be called inside
    checked expressions or blocks. These are called *checked operators*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE652]'
  prefs: []
  type: TYPE_PRE
- en: Overloading Equality and Comparison Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Equality and comparison operators are often overridden when writing structs,
    and in rare cases with classes. Special rules and obligations apply when overloading
    these operators:'
  prefs: []
  type: TYPE_NORMAL
- en: Pairing
  prefs: []
  type: TYPE_NORMAL
- en: The C# compiler enforces that operators that are logical pairs are both defined.
    These operators are (`== !=`), (`< >`), and (`<= >=`).
  prefs: []
  type: TYPE_NORMAL
- en: '`Equals` and `GetHashCode`'
  prefs: []
  type: TYPE_NORMAL
- en: If you overload `==` and `!=`, you will usually need to override `object`’s
    `Equals` and `GetHashCode` methods so that collections and hashtables will work
    reliably with the type.
  prefs: []
  type: TYPE_NORMAL
- en: '`IComparable` and `IComparable<T>`'
  prefs: []
  type: TYPE_NORMAL
- en: If you overload `<` and `>`, you would also typically implement `IComparable`
    and `IComparable<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extending the previous example, here’s how you could overload `Note`’s equality
    operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE653]'
  prefs: []
  type: TYPE_PRE
- en: Custom Implicit and Explicit Conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implicit and explicit conversions are overloadable operators. These conversions
    are typically overloaded to make converting between strongly related types (such
    as numeric types) concise and natural.
  prefs: []
  type: TYPE_NORMAL
- en: As explained in the discussion on types, the rationale behind implicit conversions
    is that they should always succeed and not lose information during conversion.
    Otherwise, explicit conversions should be defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we define conversions between our musical `Note`
    type and a `double` (which represents the frequency in hertz of that note):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE654]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This example is somewhat contrived: in real life, these conversions might be
    better implemented with a `ToFrequency` method and a (static) `FromFrequency`
    method.'
  prefs: []
  type: TYPE_NORMAL
- en: Custom conversions are ignored by the `as` and `is` operators.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’re already familiar with the notion of attributing code elements of a program
    with modifiers, such as `virtual` or `ref`. These constructs are built into the
    language. *Attributes* are an extensible mechanism for adding custom information
    to code elements (assemblies, types, members, return values, and parameters).
    This extensibility is useful for services that integrate deeply into the type
    system, without requiring special keywords or constructs in the C# language.
  prefs: []
  type: TYPE_NORMAL
- en: Attribute Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An attribute is defined by a class that inherits (directly or indirectly) from
    the abstract class `System.Attribute`. To attach an attribute to a code element,
    specify the attribute’s type name in square brackets, before the code element.
    For example, the following attaches `ObsoleteAttribute` to the `Foo` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE655]'
  prefs: []
  type: TYPE_PRE
- en: 'This particular attribute is recognized by the compiler and will cause compiler
    warnings if a type or member marked obsolete is referenced. By convention, all
    attribute types end with the word *Attribute*. C# recognizes this and allows you
    to omit the suffix when attaching an attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE656]'
  prefs: []
  type: TYPE_PRE
- en: '`ObsoleteAttribute` is a type declared in the `System` namespace as follows
    (simplified for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE657]'
  prefs: []
  type: TYPE_PRE
- en: Named and Positional Attribute Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Attributes can have parameters. In the following example, we apply `XmlElementAttribute`
    to a class. This attribute instructs `XmlSerializer` (in `System.Xml.Serialization`)
    how an object is represented in XML and accepts several *attribute parameters*.
    The following attribute maps the `CustomerEntity` class to an XML element named
    `Customer`, belonging to the `http://oreilly.com` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE658]'
  prefs: []
  type: TYPE_PRE
- en: 'Attribute parameters fall into one of two categories: positional or named.
    In the preceding example, the first argument is a *positional parameter*; the
    second is a *named parameter*. Positional parameters correspond to parameters
    of the attribute type’s public constructors. Named parameters correspond to public
    fields or public properties on the attribute type.'
  prefs: []
  type: TYPE_NORMAL
- en: When specifying an attribute, you must include positional parameters that correspond
    to one of the attribute’s constructors. Named parameters are optional.
  prefs: []
  type: TYPE_NORMAL
- en: Attribute Targets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implicitly, the target of an attribute is the code element it immediately precedes,
    which is typically a type or type member. You can also attach attributes, however,
    to an assembly. This requires that you explicitly specify the attribute’s target.
    Here’s an example of using the `CLSCompliant` attribute to specify Common Language
    Specification (CLS) compliance for an entire assembly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE659]'
  prefs: []
  type: TYPE_PRE
- en: 'From C# 10, you can apply attributes to the method, parameters, and return
    value of a lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE660]'
  prefs: []
  type: TYPE_PRE
- en: Specifying Multiple Attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can specify multiple attributes for a single code element. You can list
    each attribute either within the same pair of square brackets (separated by a
    comma) or in separate pairs of square brackets (or a combination of the two).
    The following two examples are semantically identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE661]'
  prefs: []
  type: TYPE_PRE
- en: Writing Custom Attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can define your own attributes by subclassing `Sys⁠tem​.Attribute`. For
    example, you could use the following custom attribute for flagging a method for
    unit testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE662]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how you could apply the attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE663]'
  prefs: []
  type: TYPE_PRE
- en: '`AttributeUsage` is itself an attribute that indicates the construct (or combination
    of constructs) to which the custom attribute can be applied. The `AttributeTargets`
    enum includes such members as `Class`, `Method`, `Parameter`, and `Constructor`
    (as well as `All`, which combines all targets).'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving Attributes at Runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two standard ways to retrieve attributes at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: Call `GetCustomAttributes` on any `Type` or `MemberInfo` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call `Attribute.GetCustomAttribute` or `Attribute.Get​Cus⁠tomAttributes`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These latter two methods are overloaded to accept any reflection object that
    corresponds to a valid attribute target (`Type`, `Assembly`, `Module`, `MemberInfo`,
    or `ParameterInfo`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we can enumerate each method in the preceding `Foo` class that has
    a `TestAttribute`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE664]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE665]'
  prefs: []
  type: TYPE_PRE
- en: Caller Info Attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can tag optional parameters with one of three *caller info attributes*,
    which instruct the compiler to feed information obtained from the caller’s source
    code into the parameter’s default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[CallerMemberName]` applies the caller’s member name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[CallerFilePath]` applies the path to the caller’s source code file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[CallerLineNumber]` applies the line number in the caller’s source code file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Foo` method in the following program demonstrates all three:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE666]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming that our program resides in *c:\source\test\Program.cs*, the output
    would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE667]'
  prefs: []
  type: TYPE_PRE
- en: 'As with standard optional parameters, the substitution is done at the *calling
    site*. Hence, our `Main` method is syntactic sugar for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE668]'
  prefs: []
  type: TYPE_PRE
- en: 'Caller info attributes are useful for writing logging functions and for implementing
    change notification patterns. For instance, we can call a method such as the following
    from within a property’s `set` accessor—without having to specify the property’s
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE669]'
  prefs: []
  type: TYPE_PRE
- en: CallerArgumentExpression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A method parameter to which you apply the `[CallerArgumentExpression]` attribute
    captures an argument expression from the call site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE670]'
  prefs: []
  type: TYPE_PRE
- en: 'The main application for this feature is when writing validation and assertion
    libraries. In the following example, an exception is thrown, whose message includes
    the text “2 + 2 == 5.” This aids in debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE671]'
  prefs: []
  type: TYPE_PRE
- en: You can use `[CallerArgumentExpression]` multiple times in order to capture
    multiple argument expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `await` and `async` keywords support *asynchronous programming*, a style
    of programming in which long-running functions do most or all of their work *after*
    returning to the caller. This is in contrast to normal *synchronous* programming,
    in which long-running functions *block* the caller until the operation is complete.
    Asynchronous programming implies *concurrency* because the long-running operation
    continues *in parallel* to the caller. The implementer of an asynchronous function
    initiates this concurrency either through multithreading (for compute-bound operations)
    or via a callback mechanism (for I/O-bound operations).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Multithreading, concurrency, and asynchronous programming are large topics.
    We dedicate two chapters to them in *C# 12 in a Nutshell* and discuss them online
    at [*http://albahari.com/threading*](http://albahari.com/threading).
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, consider the following *synchronous* method, which is long-running
    and compute-bound:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE672]'
  prefs: []
  type: TYPE_PRE
- en: 'This method blocks the caller for a few seconds while it runs, before returning
    the result of the calculation to the caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE673]'
  prefs: []
  type: TYPE_PRE
- en: 'The CLR defines a class called `Task<TResult>` (in `System.Threading.Tasks`)
    to encapsulate the concept of an operation that completes in the future. You can
    generate a `Task<TResult>` for a compute-bound operation by calling `Task.Run`,
    which instructs the CLR to run the specified delegate on a separate thread that
    executes in parallel to the caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE674]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is *asynchronous* because it returns immediately to the caller
    while it executes concurrently. However, we need some mechanism to allow the caller
    to specify what should happen when the operation finishes and the result becomes
    available. `Task<TResult>` solves this by exposing a `GetAwaiter` method that
    lets the caller attach a *continuation*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE675]'
  prefs: []
  type: TYPE_PRE
- en: This says to the operation, “When you finish, execute the specified delegate.”
    Our continuation first calls `GetResult`, which returns the result of the calculation.
    (Or, if the task *faulted*—threw an exception—calling `GetResult` rethrows that
    exception.) Our continuation then writes out the result via `Console.WriteLine`.
  prefs: []
  type: TYPE_NORMAL
- en: The await and async Keywords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `await` keyword simplifies the attaching of continuations. Starting with
    a basic scenario, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE676]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler expands this into something functionally similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE677]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The compiler also emits code to optimize the scenario of the operation completing
    synchronously (immediately). A common reason for an asynchronous operation completing
    immediately is if it implements an internal caching mechanism and the result is
    already cached.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, we can call the `ComplexCalculationAsync` method we defined previously,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE678]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile, we need to add the `async` modifier to the containing method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE679]'
  prefs: []
  type: TYPE_PRE
- en: The `async` modifier instructs the compiler to treat `await` as a keyword rather
    than an identifier should an ambiguity arise within that method (this ensures
    that code written prior to C# 5.0 that might use `await` as an identifier will
    still compile without error). The `async` modifier can be applied only to methods
    (and lambda expressions) that return `void` or (as you’ll see later) a `Task`
    or `Task<TResult>`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `async` modifier is similar to the `unsafe` modifier in that it has no effect
    on a method’s signature or public metadata; it affects only what happens *within*
    the method.
  prefs: []
  type: TYPE_NORMAL
- en: Methods with the `async` modifier are called *asynchronous functions* because
    they themselves are typically asynchronous. To see why, let’s look at how execution
    proceeds through an asynchronous function.
  prefs: []
  type: TYPE_NORMAL
- en: Upon encountering an `await` expression, execution (normally) returns to the
    caller—rather like with `yield return` in an iterator. But before returning, the
    runtime attaches a continuation to the awaited task, ensuring that when the task
    completes, execution jumps back into the method and continues where it left off.
    If the task faults, its exception is rethrown (by virtue of calling `GetResult`);
    otherwise, its return value is assigned to the `await` expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The CLR’s implementation of a task awaiter’s `OnCompleted` method ensures that
    by default, continuations are posted through the current *synchronization context*,
    if one is present. In practice, this means that in rich-client UI scenarios (WPF,
    WinUI, and Windows Forms), if you `await` on a UI thread, your code will continue
    on that same thread. This simplifies thread safety.
  prefs: []
  type: TYPE_NORMAL
- en: The expression upon which you `await` is typically a task; however, any object
    with a `GetAwaiter` method that returns an *awaitable object*—implementing `INotifyCompletion.On​Com⁠pleted`
    and with an appropriately typed `GetResult` method (and a `bool IsCompleted` property
    that tests for synchronous completion)—will satisfy the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that our `await` expression evaluates to an `int` type; this is because
    the expression that we awaited was a `Task<int>` (whose `GetAwaiter().GetResult()`
    method returns an `int`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Awaiting a nongeneric task is legal and generates a void expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE680]'
  prefs: []
  type: TYPE_PRE
- en: '`Task.Delay` is a static method that returns a `Task` that completes in the
    specified number of milliseconds. The *synchronous* equivalent of `Task.Delay`
    is `Thread.Sleep`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Task` is the nongeneric base class of `Task<TResult>` and is functionally
    equivalent to `Task<TResult>` except that it has no result.'
  prefs: []
  type: TYPE_NORMAL
- en: Capturing Local State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The real power of `await` expressions is that they can appear almost anywhere
    in code. Specifically, an `await` expression can appear in place of any expression
    (within an asynchronous function) except for within a `lock` statement or `unsafe`
    context.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we `await` within a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE681]'
  prefs: []
  type: TYPE_PRE
- en: Upon first executing `ComplexCalculationAsync`, execution returns to the caller
    by virtue of the `await` expression. When the method completes (or faults), execution
    resumes where it left off, with the values of local variables and loop counters
    preserved. The compiler achieves this by translating such code into a state machine,
    like it does with iterators.
  prefs: []
  type: TYPE_NORMAL
- en: Without the `await` keyword, the manual use of continuations means that you
    must write something equivalent to a state machine. This is traditionally what
    makes asynchronous programming difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Asynchronous Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With any asynchronous function, you can replace the `void` return type with
    a `Task` to make the method itself *usefully* asynchronous (and `await`able).
    No further changes are required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE682]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we don’t explicitly return a task in the method body. The compiler
    manufactures the task, which it signals upon completion of the method (or upon
    an unhandled exception). This makes it easy to create asynchronous call chains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE683]'
  prefs: []
  type: TYPE_PRE
- en: (And because `Go` returns a `Task`, `Go` itself is `await`able.) The compiler
    expands asynchronous functions that return tasks into code that (indirectly) uses
    `TaskCompletionSource` to create a task that it then signals or faults.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`TaskCompletionSource` is a CLR type that lets you create tasks that you manually
    control, signaling them as complete with a result (or as faulted with an exception).
    Unlike `Task.Run`, `TaskCompletionSource` doesn’t tie up a thread for the duration
    of the operation. It’s also used for writing I/O-bound task-returning methods
    (such as `Task.Delay`).'
  prefs: []
  type: TYPE_NORMAL
- en: The aim is to ensure that when a task-returning asynchronous method finishes,
    execution can jump back to whoever awaited it, via a continuation.
  prefs: []
  type: TYPE_NORMAL
- en: Returning Task<TResult>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can return a `Task<TResult>` if the method body returns `TResult`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE684]'
  prefs: []
  type: TYPE_PRE
- en: 'We can demonstrate `GetAnswerToLife` by calling it from `Prin⁠t​AnswerToLife`
    (which is, in turn, called from `Go`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE685]'
  prefs: []
  type: TYPE_PRE
- en: 'Asynchronous functions make asynchronous programming similar to synchronous
    programming. Here’s the synchronous equivalent of our call graph, for which calling
    `Go()` gives the same result after blocking for five seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE686]'
  prefs: []
  type: TYPE_PRE
- en: This also illustrates the basic principle of how to design with asynchronous
    functions in C#, which is to write your methods synchronously and then replace
    *synchronous* method calls with *asynchronous* method calls that you `await`.
  prefs: []
  type: TYPE_NORMAL
- en: Parallelism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve just demonstrated the most common pattern, which is to `await` task-returning
    functions immediately after calling them. This results in sequential program flow
    that’s logically similar to the synchronous equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling an asynchronous method without awaiting it allows the code that follows
    to execute in parallel. For example, the following executes `PrintAnswerToLife`
    twice, concurrently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE687]'
  prefs: []
  type: TYPE_PRE
- en: 'By awaiting both operations afterward, we “end” the parallelism at that point
    (and rethrow any exceptions from those tasks). The `Task` class provides a static
    method called `WhenAll` to achieve the same result slightly more efficiently.
    `WhenAll` returns a task that completes when all of the tasks that you pass to
    it complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE688]'
  prefs: []
  type: TYPE_PRE
- en: '`WhenAll` is called a *task combinator*. (The `Task` class also provides a
    task combinator called `WhenAny`, which completes when *any* of the tasks provided
    to it complete.) We cover the task combinators in detail in *C# 12 in a Nutshell*.'
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous Lambda Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We know that ordinary *named* methods can be asynchronous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE689]'
  prefs: []
  type: TYPE_PRE
- en: 'So, too, can *unnamed* methods (lambda expressions and anonymous methods),
    if preceded by the `async` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE690]'
  prefs: []
  type: TYPE_PRE
- en: 'You can call and await these in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE691]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use asynchronous lambda expressions when attaching event handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE692]'
  prefs: []
  type: TYPE_PRE
- en: 'This is more succinct than the following, which has the same effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE693]'
  prefs: []
  type: TYPE_PRE
- en: 'Asynchronous lambda expressions can also return `Task​<TRe⁠sult>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE694]'
  prefs: []
  type: TYPE_PRE
- en: Asynchronous Streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With `yield return`, you can write an iterator; with `await`, you can write
    an asynchronous function. *Asynchronous streams* (from C# 8) combine these concepts
    and let you write an iterator that awaits, yielding elements asynchronously. This
    support builds on the following pair of interfaces, which are asynchronous counterparts
    to the enumeration interfaces we described in [“Enumeration and Iterators”](#enumeration_and_iterators):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE695]'
  prefs: []
  type: TYPE_PRE
- en: '`ValueTask<T>` is a struct that wraps `Task<T>` and is behaviorally equivalent
    to `Task<T>`, except that it enables more efficient execution when the task completes
    synchronously (which can happen often when enumerating a sequence). `IAsyncDisposable`
    is an asynchronous version of `IDisposable` and provides an opportunity to perform
    cleanup should you choose to manually implement the interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE696]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The act of fetching each element from the sequence (`MoveNextAsync`) is an
    asynchronous operation, so asynchronous streams are suitable when elements arrive
    in a piecemeal fashion (such as when processing data from a video stream). In
    contrast, the following type is more suitable when the sequence *as a whole* is
    delayed, but the elements, when they arrive, arrive all together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE697]'
  prefs: []
  type: TYPE_PRE
- en: 'To generate an asynchronous stream, you write a method that combines the principles
    of iterators and asynchronous methods. In other words, your method should include
    both `yield return` and `await`, and it should return `IAsyncEnumerable<T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE698]'
  prefs: []
  type: TYPE_PRE
- en: 'To consume an asynchronous stream, use the `await foreach` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE699]'
  prefs: []
  type: TYPE_PRE
- en: Static Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [“Static virtual/abstract interface members”](#static_virtualsolidusabstract_interface),
    we introduced an advanced feature whereby an interface can define `static virtual`
    or `static abstract` members, which are then implemented as static members by
    classes and structs. Later, in [“Generic Constraints”](#generic_constraints),
    we showed that applying an interface constraint to a type parameter gives a method
    access to that interface’s members. In this section, we’ll demonstrate how this
    enables *static polymorphism*, allowing for features such as generic math.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, consider the following interface, which defines a static method
    to create a random instance of some type `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE700]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose now that we wish to implement this interface in the following record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE701]'
  prefs: []
  type: TYPE_PRE
- en: 'With the help of the `System.Random` class (whose `Next` method generates a
    random integer), we can implement the static `Crea⁠te​Random` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE702]'
  prefs: []
  type: TYPE_PRE
- en: 'To call this method via the interface, we use a *constrained type parameter*.
    The following method creates an array of test data using this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE703]'
  prefs: []
  type: TYPE_PRE
- en: 'This line of code demonstrates its use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE704]'
  prefs: []
  type: TYPE_PRE
- en: Our call to the static `CreateRandom` method in `CreateTestData` is *polymorphic*
    because it works not just with `Point` but with any type that implements `ICreateRandom<T>`.
    This is different from *instance* polymorphism, because we don’t need an *instance*
    of `ICreateRandom<T>` on which to call `CreateRandom`; we call `CreateRandom`
    on the type itself.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphic Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because operators are essentially static functions (see [“Operator Overloading”](#operator_overloading)),
    operators can also be declared as static virtual interface members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE705]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The *self-referencing* type constraint in this interface definition is necessary
    to satisfy the compiler’s rules for operator overloading. Recall that when defining
    an operator function, at least one of the operands must be the type in which the
    operator function is declared. In this example, our operands are of type `T`,
    whereas the containing type is `IAddable<T>`, so we require a self-referencing
    type constraint to allow `T` to be treated as `IAddable<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we can implement the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE706]'
  prefs: []
  type: TYPE_PRE
- en: 'With a constrained type parameter, we can then write a method that calls our
    addition operator polymorphically (with edge-case handling omitted for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE707]'
  prefs: []
  type: TYPE_PRE
- en: Our call to the `+` operator (via the `+=` operator) is polymorphic because
    it binds to `IAddable<T>`, not `Point`. Hence, our `Sum` method works with all
    types that implement `IAddable<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, an interface such as `IAddable<T>` would be much more useful if
    it were defined in the .NET runtime, and if all .NET numeric types implemented
    it. Fortunately, this is indeed the case from .NET 7: the `System.Numerics` namespace
    includes (a more sophisticated version of) `IAddable`, along with many other arithmetic
    interfaces—most of which are encompassed by `INumber<TSelf>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Generic Math
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before .NET 7, code that performed arithmetic had to be hardcoded to a particular
    numeric type such as `int` or `double`. From .NET 7, the `INumber<TSelf>` interface
    was added to unify arithmetic operations across numeric types, allowing generic
    methods such as the following to be written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE708]'
  prefs: []
  type: TYPE_PRE
- en: '`INumber<TSelf>` is implemented by all real and integral numeric types in .NET
    (as well as `char`). It can be thought of as an umbrella interface, comprising
    other more granular interfaces for each kind of arithmetic operation (addition,
    subtraction, multiplication, division, modulus calculation, comparison, and so
    on), as well as interfaces for parsing and formatting. These interfaces define
    static abstract operators and methods—which allow the `+=` operator (and the call
    to `T.Zero`) to work inside our `Sum` method.'
  prefs: []
  type: TYPE_NORMAL
- en: Unsafe Code and Pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# supports direct memory manipulation via pointers within blocks of code marked
    as `unsafe`. Pointer types are useful for interoperating with native APIs, for
    accessing memory outside the managed heap, and in implementing micro-optimizations
    in performance-critical hotspots.
  prefs: []
  type: TYPE_NORMAL
- en: Projects that include unsafe code must specify `<AllowUnsafeBlocks>true</AllowUnsafeBlocks>`
    in the project file.
  prefs: []
  type: TYPE_NORMAL
- en: Pointer Basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For every value type or reference type *V*, there is a corresponding pointer
    type *V**. A pointer instance holds the address of a variable. Pointer types can
    be (unsafely) cast to any other pointer type. Following are the main pointer operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `&` | The *address-of* operator returns a pointer to the address of a variable.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | The *dereference* operator returns the variable at the address of a
    pointer. |'
  prefs: []
  type: TYPE_TB
- en: '| `->` | The *pointer-to-member* operator is a syntactic shortcut, in which
    `x->y` is equivalent to `(*x).y`. |'
  prefs: []
  type: TYPE_TB
- en: Unsafe Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By marking a type, type member, or statement block with the `unsafe` keyword,
    you’re permitted to use pointer types and perform C++-style pointer operations
    on memory within that scope. Here is an example of using pointers to quickly process
    a bitmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE709]'
  prefs: []
  type: TYPE_PRE
- en: Unsafe code can run faster than a corresponding safe implementation. In this
    case, the code would have required a nested loop with array indexing and bounds
    checking. An unsafe C# method can also be faster than calling an external C function
    because there is no overhead associated with leaving the managed execution environment.
  prefs: []
  type: TYPE_NORMAL
- en: The fixed Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `fixed` statement is required to pin a managed object such as the bitmap
    in the previous example. During the execution of a program, many objects are allocated
    and deallocated from the heap. To avoid unnecessary waste or fragmentation of
    memory, the garbage collector moves objects around. Pointing to an object is futile
    if its address could change while referencing it, so the `fixed` statement instructs
    the garbage collector to “pin” the object and not move it around. This can have
    an impact on the efficiency of the runtime, so you should use fixed blocks only
    briefly, and you should avoid heap allocation within the fixed block.
  prefs: []
  type: TYPE_NORMAL
- en: Within a `fixed` statement, you can get a pointer to a value type, an array
    of value types, or a string. In the case of arrays and strings, the pointer will
    actually point to the first element, which is a value type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Value types declared inline within reference types require the reference type
    to be pinned, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE710]'
  prefs: []
  type: TYPE_PRE
- en: The Pointer-to-Member Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the `&` and `*` operators, C# also provides the C++-style `->`
    operator, which you can use on structs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE711]'
  prefs: []
  type: TYPE_PRE
- en: The stackalloc Keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can allocate memory in a block on the stack explicitly with the `stackalloc`
    keyword. Because it is allocated on the stack, its lifetime is limited to the
    execution of the method, just as with any other local variable. The block can
    use the `[]` operator to index into memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE712]'
  prefs: []
  type: TYPE_PRE
- en: Fixed-Size Buffers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To allocate a block of memory within a struct, use the `fixed` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE713]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixed-size buffers are not arrays: if `Buffer` were an array, it would consist
    of a reference to an object stored on the (managed) heap, rather than 30 bytes
    within the struct itself.'
  prefs: []
  type: TYPE_NORMAL
- en: The `fixed` keyword is also used in this example to pin the object on the heap
    that contains the buffer (which will be the instance of `UnsafeClass`).
  prefs: []
  type: TYPE_NORMAL
- en: void*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *void pointer* (`void*`) makes no assumptions about the type of the underlying
    data and is useful for functions that deal with raw memory. An implicit conversion
    exists from any pointer type to `void*`. A `void*` cannot be dereferenced, and
    arithmetic operations cannot be performed on void pointers. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE714]'
  prefs: []
  type: TYPE_PRE
- en: Function Pointers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *function pointer* (from C# 9) is like a delegate but without the indirection
    of a delegate instance; instead, it points directly to a method. A function pointer
    points only to static methods, lacks multicast capability, and requires an `unsafe`
    context (because it bypasses runtime type safety). Its main purpose is to simplify
    and optimize interop with unmanaged APIs (we cover interop in *C# 12 in a Nutshell*).
  prefs: []
  type: TYPE_NORMAL
- en: 'A function pointer type is declared as follows (with the return type appearing
    last):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE715]'
  prefs: []
  type: TYPE_PRE
- en: 'This matches a function with this signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE716]'
  prefs: []
  type: TYPE_PRE
- en: 'The `&` operator creates a function pointer from a method group. Here’s a complete
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE717]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `functionPointer` is not an *object* upon which you can call
    a method such as `Invoke` (or with a reference to a `Target` object). Instead,
    it’s a variable that points directly to the target method’s address in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE718]'
  prefs: []
  type: TYPE_PRE
- en: Preprocessor Directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Preprocessor directives supply the compiler with additional information about
    regions of code. The most common preprocessor directives are the conditional directives,
    which provide a way to include or exclude regions of code from compilation. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE719]'
  prefs: []
  type: TYPE_PRE
- en: In this class, the statement in `Foo` is compiled as conditionally dependent
    upon the presence of the `DEBUG` symbol. If we remove the `DEBUG` symbol, the
    statement is not compiled. Preprocessor symbols can be defined within a source
    file (as we have done), or within the `<DefineConstants>` element in a project
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `#if` and `#elif` directives, you can use the `||`, `&&`, and `!`
    operators to perform *or*, *and*, and *not* operations on multiple symbols. The
    following directive instructs the compiler to include the code that follows if
    the `TESTMODE` symbol is defined and the `DEBUG` symbol is not defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE720]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind, however, that you’re not building an ordinary C# expression, and
    the symbols upon which you operate have absolutely no connection to *variables*—static
    or otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: The `#error` and `#warning` symbols prevent accidental misuse of conditional
    directives by making the compiler generate a warning or error given an undesirable
    set of compilation symbols.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 14](#preprocessor_directives) describes the complete list of preprocessor
    directives.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 14\. Preprocessor directives
  prefs: []
  type: TYPE_NORMAL
- en: '| Preprocessor directive | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `` #define `*symbol*` `` | Defines `*symbol*`. |'
  prefs: []
  type: TYPE_TB
- en: '| `` #undef `*symbol*` `` | Undefines `*symbol*`. |'
  prefs: []
  type: TYPE_TB
- en: '| `#if` `*symbol*` `[*operator symbol2*]...` | Conditional compilation (`*operator*`s
    are `==`, `!=`, `&&`, and `&#124;&#124;`). |'
  prefs: []
  type: TYPE_TB
- en: '| `#else` | Executes code to subsequent `#endif`. |'
  prefs: []
  type: TYPE_TB
- en: '| `#elif` `*symbol*` `[*operator symbol2*]` | Combines `#else` branch and `#if`
    test. |'
  prefs: []
  type: TYPE_TB
- en: '| `#endif` | Ends conditional directives. |'
  prefs: []
  type: TYPE_TB
- en: '| `` #warning `*text*` `` | `*text*` of the warning to appear in compiler output.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `` #error `*text*` `` | `*text*` of the error to appear in compiler output.
    |'
  prefs: []
  type: TYPE_TB
- en: '| ``#line [`*number*` ["`*file*`"] &#124; hidden]`` | `*number*` specifies
    the line in source code; `*file*` is the filename to appear in computer output;
    `hidden` instructs debuggers to skip over code from this point until the next
    `#line` directive. |'
  prefs: []
  type: TYPE_TB
- en: '| `` #region `*name*` `` | Marks the beginning of an outline. |'
  prefs: []
  type: TYPE_TB
- en: '| `#endregion` | Ends an outline region. |'
  prefs: []
  type: TYPE_TB
- en: '| `#pragma warning` | See the next section. |'
  prefs: []
  type: TYPE_TB
- en: '| `` #nullable `*option*` `` | See [“Nullable Reference Types”](#nullable_reference_types).
    |'
  prefs: []
  type: TYPE_TB
- en: Pragma Warning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The compiler generates a warning when it spots something in your code that seems
    unintentional. Unlike errors, warnings don’t ordinarily prevent your application
    from compiling.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler warnings can be extremely valuable in spotting bugs. Their usefulness,
    however, is undermined when you get *false* warnings. In a large application,
    maintaining a good signal-to-noise ratio is essential if the “real” warnings are
    to be noticed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To this effect, the compiler allows you to selectively suppress warnings with
    the `#pragma warning` directive. In this example, we instruct the compiler not
    to warn us about the field `Message` not being used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE721]'
  prefs: []
  type: TYPE_PRE
- en: Omitting the number in the `#pragma warning` directive disables or restores
    all warning codes.
  prefs: []
  type: TYPE_NORMAL
- en: If you are thorough in applying this directive, you can compile with the `/warnaserror`
    switch—this instructs the compiler to treat any residual warnings as errors.
  prefs: []
  type: TYPE_NORMAL
- en: XML Documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A *documentation comment* is a piece of embedded XML that documents a type
    or member. A documentation comment comes immediately before a type or member declaration
    and starts with three slashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE722]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiline comments can be done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE723]'
  prefs: []
  type: TYPE_PRE
- en: 'Or like this (notice the extra star at the start):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE724]'
  prefs: []
  type: TYPE_PRE
- en: 'If you compile with the `/doc` directive (or enable XML documentation in the
    project file), the compiler extracts and collates documentation comments into
    a single XML file. This has two main uses:'
  prefs: []
  type: TYPE_NORMAL
- en: If placed in the same folder as the compiled assembly, Visual Studio automatically
    reads the XML file and uses the information to provide IntelliSense member listings
    to consumers of the assembly of the same name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party tools (such as Sandcastle and NDoc) can transform the XML file into
    an HTML help file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard XML Documentation Tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the standard XML tags that Visual Studio and documentation generators
    recognize:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<summary>`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE725]'
  prefs: []
  type: TYPE_PRE
- en: Indicates the tool tip that IntelliSense should display for the type or member.
    Typically, a single phrase or sentence.
  prefs: []
  type: TYPE_NORMAL
- en: '`<remarks>`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE726]'
  prefs: []
  type: TYPE_PRE
- en: Additional text that describes the type or member. Documentation generators
    pick this up and merge it into the bulk of a type or member’s description.
  prefs: []
  type: TYPE_NORMAL
- en: '`<param>`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE727]'
  prefs: []
  type: TYPE_PRE
- en: Explains a parameter on a method.
  prefs: []
  type: TYPE_NORMAL
- en: '`<returns>`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE728]'
  prefs: []
  type: TYPE_PRE
- en: Explains the return value for a method.
  prefs: []
  type: TYPE_NORMAL
- en: '`<exception>`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE729]'
  prefs: []
  type: TYPE_PRE
- en: Lists an exception that a method might throw (`cref` refers to the exception
    type).
  prefs: []
  type: TYPE_NORMAL
- en: '`<permission>`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE730]'
  prefs: []
  type: TYPE_PRE
- en: Indicates an `IPermission` type required by the documented type or member.
  prefs: []
  type: TYPE_NORMAL
- en: '`<example>`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE731]'
  prefs: []
  type: TYPE_PRE
- en: Denotes an example (used by documentation generators). This usually contains
    both description text and source code (source code is typically within a `<c>`
    or `<code>` tag).
  prefs: []
  type: TYPE_NORMAL
- en: '`<c>`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE732]'
  prefs: []
  type: TYPE_PRE
- en: Indicates an inline code snippet. This tag is usually used within an `<example>`
    block.
  prefs: []
  type: TYPE_NORMAL
- en: '`<code>`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE733]'
  prefs: []
  type: TYPE_PRE
- en: Indicates a multiline code sample. This tag is usually used within an `<example>`
    block.
  prefs: []
  type: TYPE_NORMAL
- en: '`<see>`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE734]'
  prefs: []
  type: TYPE_PRE
- en: Inserts an inline cross-reference to another type or member. HTML documentation
    generators typically convert this to a hyperlink. The compiler emits a warning
    if the type or member name is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: '`<seealso>`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE735]'
  prefs: []
  type: TYPE_PRE
- en: Cross-references another type or member. Documentation generators typically
    write this into a separate “See Also” section at the bottom of the page.
  prefs: []
  type: TYPE_NORMAL
- en: '`<paramref>`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE736]'
  prefs: []
  type: TYPE_PRE
- en: References a parameter from within a `<summary>` or `<remarks>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: '`<list>`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE737]'
  prefs: []
  type: TYPE_PRE
- en: Instructs documentation generators to emit a bulleted, numbered, or table-style
    list.
  prefs: []
  type: TYPE_NORMAL
- en: '`<para>`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE738]'
  prefs: []
  type: TYPE_PRE
- en: Instructs documentation generators to format the contents into a separate paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: '`<include>`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE739]'
  prefs: []
  type: TYPE_PRE
- en: Merges an external XML file that contains documentation. The path attribute
    denotes an XPath query to a specific element in that file.
  prefs: []
  type: TYPE_NORMAL
