<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 6. Programming Asynchronously"><div class="chapter" id="programming_asynchronously">
<h1><span class="label">Chapter 6. </span>Programming Asynchronously</h1>


<p><a data-type="indexterm" data-primary="asynchronous programming" id="ix_ch06-asciidoc0"/>It used to be that most of the code anyone wrote was synchronous. Things like concurrency, thread pools, and parallel programming were the domain of specialized experts who sometimes still got it wrong. Historical internet forums, UseNet, and even books were full of warnings to not try multithreading unless you know what you’re doing and have a strong requirement for it. However, that’s changed.</p>

<p><a data-type="indexterm" data-primary="Task Parallel Library (TPL)" id="idm45678776218432"/><a data-type="indexterm" data-primary="TPL (Task Parallel Library)" id="idm45678776217712"/>In 2010, Microsoft introduced the Task Parallel Library (TPL), which made it a lot easier to write multithreaded code. This coincided with the common availability of multithread/multicore CPU architectures. One of the TPL primitives was the <code>Task</code> class, which represented a promise to perform some work, on a separate thread, and return the results. Interestingly, PLINQ, which is covered in <a data-type="xref" href="ch04.xhtml#querying_in_parallel">Recipe 4.10</a>, shipped in the same time frame. TPL is still an important part of the developer’s toolkit for in-process CPU-intensive multithreading.</p>

<p><a data-type="indexterm" data-primary="async language syntax" data-secondary="introduction in C# 4" id="idm45678776214848"/><a data-type="indexterm" data-primary="async language syntax" data-seealso="asynchronous programming" id="idm45678776213872"/>Building on the concepts of <code>Task</code>, from TPL, Microsoft introduced async via specialized language syntax in C# 4. While we had asynchronous programming since C# 1, through delegates, it was more complex and less efficient. In C# 5, async simplified this by introducing the <code>async/await</code> keywords and making the code and its order of execution very similar to synchronous code. In addition to simplification, a <a data-type="indexterm" data-primary="out-of-process communication" data-seealso="asynchronous programming" id="idm45678776211584"/>primary use case for C# async is out-of-process communication, as opposed to where TPL shines for in-process CPU intensive work. When going out-of-process, think about accessing the file system, making a database query, or calling a REST API. Behind the scenes, async manages the threads for these operations so they don’t block and improves application performance and scalability. With async, we could reason about our logic in a simple way and still have the benefits and sophistication of asynchronous operation.</p>

<p>Since its introduction, Microsoft has continued to improve async, both via language features and .NET Framework libraries. This chapter covers these new features, such as async <code>Main</code> methods, the new <code>ValueTask</code> type, async iterators, and async disposal. There are also original capabilities of async that deserve special attention, such as writing safe async libraries, managing concurrent async tasks, cancellation, and progress reporting.</p>

<p>The theme of this chapter is  checkout, where a customer has products in their shopping cart, they’ve started the checkout process, and the code needs to process each checkout request. We’ll start with the proper way to use async with console <span class="keep-together">applications</span>.</p>






<section data-type="sect1" data-pdf-bookmark="6.1 Creating Async Console Applications"><div class="sect1" id="creating_async_console_applications">
<h1>6.1 Creating Async Console Applications</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45678776205200">
<h2>Problem</h2>

<p><a data-type="indexterm" data-primary="asynchronous programming" data-secondary="creating async console applications" id="ix_ch06-asciidoc1"/><a data-type="indexterm" data-primary="console applications, async" id="ix_ch06-asciidoc2"/>You need to use a library in a console application, but it only has an async API.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45678776201328">
<h2>Solution</h2>

<p>This class has async methods:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">class</code> <code class="nc">CheckoutService</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">StartAsync</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="k">await</code> <code class="nf">ValidateAddressAsync</code><code class="p">();</code>
        <code class="k">await</code> <code class="nf">ValidateCreditAsync</code><code class="p">();</code>
        <code class="k">await</code> <code class="nf">GetShoppingCartAsync</code><code class="p">();</code>
        <code class="k">await</code> <code class="nf">FinalizeCheckoutAsync</code><code class="p">();</code>

        <code class="k">return</code> <code class="s">"Checkout Complete"</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">async</code> <code class="n">Task</code> <code class="nf">ValidateAddressAsync</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="c1">// perform address validation</code>
    <code class="p">}</code>

    <code class="k">async</code> <code class="n">Task</code> <code class="nf">ValidateCreditAsync</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="c1">// ensure credit is good</code>
    <code class="p">}</code>

    <code class="k">async</code> <code class="n">Task</code> <code class="nf">GetShoppingCartAsync</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="c1">// get contents of shopping cart</code>
    <code class="p">}</code>

    <code class="k">async</code> <code class="n">Task</code> <code class="nf">FinalizeCheckoutAsync</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="c1">// complete checkout transaction</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>Here’s the old way to write an async console app:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">class</code> <code class="nc">Program</code>
<code class="p">{</code>
    <code class="k">static</code> <code class="k">void</code> <code class="nf">Main</code><code class="p">(</code><code class="kt">string</code><code class="p">[]</code> <code class="n">args</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="kt">var</code> <code class="n">checkoutSvc</code> <code class="p">=</code> <code class="k">new</code> <code class="n">CheckoutService</code><code class="p">();</code>
        <code class="kt">string</code> <code class="n">result</code> <code class="p">=</code> <code class="kt">string</code><code class="p">.</code><code class="n">Empty</code><code class="p">;</code>

        <code class="n">Task</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">startedTask</code> <code class="p">=</code> <code class="n">checkoutSvc</code><code class="p">.</code><code class="n">StartAsync</code><code class="p">();</code>
        <code class="n">startedTask</code><code class="p">.</code><code class="n">Wait</code><code class="p">();</code>
        <code class="n">result</code> <code class="p">=</code> <code class="n">startedTask</code><code class="p">.</code><code class="n">Result</code><code class="p">;</code>

        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"Result: {result}"</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>Here’s the new recommended way to write an async console app:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="k">async</code> <code class="n">Task</code> <code class="nf">Main</code><code class="p">()</code>
<code class="p">{</code>
    <code class="kt">var</code> <code class="n">checkoutSvc</code> <code class="p">=</code> <code class="k">new</code> <code class="n">CheckoutService</code><code class="p">();</code>

    <code class="kt">string</code> <code class="n">result</code> <code class="p">=</code> <code class="k">await</code> <code class="n">checkoutSvc</code><code class="p">.</code><code class="n">StartAsync</code><code class="p">();</code>

    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"Result: {result}"</code><code class="p">);</code>
<code class="p">}</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45678776007696">
<h2>Discussion</h2>

<p>When first introduced, async was nearly everywhere and immediately useful. Still, there were edge cases, such as <code>Main</code> methods and <code>catch</code> and <code>finally</code> blocks, where async couldn’t be used. Fortunately, Microsoft fixed this in C# 7.1 and added more support in other parts of the .NET Framework that were lacking, for instance, async <code>ActionResult</code> in ASP.NET MVC. <a data-type="xref" href="#creating_async_iterators">Recipe 6.3</a> shows how async iterators solve another async problem.</p>

<p><a data-type="indexterm" data-primary="async Main" id="idm45678775982528"/>A prominent async addition, described in this section, is async <code>Main</code>. The problem was that, just like the <code>CheckoutService</code> class in the solution, many .NET Framework types and third-party libraries were written for async. However, without async <code>Main</code>, developers had to write problematic code. To demonstrate the problem, the solution includes two versions of a <code>Main</code> method: the old synchronous way and the new async approach.</p>

<p>With the old synchronous technique, developers were forced to use <code>Wait()</code> and <code>Result</code>, which are typical async antipatterns because of thread blocking and <span class="keep-together">potential</span> thread deadlocks and race conditions. <a data-type="xref" href="#writing_safe_async_libraries">Recipe 6.4</a> explains a scenario where writing code like this can cause a deadlock (and how to avoid it). These are members of the <code>Task</code> type, which async methods return. Unfortunately, this was the only choice in the first iteration of async if you wanted to write a command-line utility, text-based app, or demo app.</p>

<p>The second <code>Main</code> in the solution shows the new syntax, with the <code>async</code> modifier and the <code>Task</code> return type. All we have to do is <code>await</code> the call to <code>checkoutSvc.Start​A⁠sync()</code> and the code works fine.</p>
<div data-type="tip"><h6>Tip</h6>
<p>As you know, <code>Main</code> can return <code>void</code> or <code>int</code>. The solution example with <code>Task</code> is for a <code>void</code> return. You can change that to <code>Task&lt;int&gt;</code> for an <code>int</code> return.</p>
</div>

<p>Essentially, Microsoft hasn’t recommended a safe way to call from synchronous code into asynchronous code. So this was a welcome addition that makes it much easier to write console apps that call async code. Also, notice that the entire call chain, from <code>Main</code> to <code>CheckoutService.StartAsync</code> and to other <code>CheckoutService</code> methods, is all async. Ideally, the entire call chain is async, but occasionally you will have an async method that only calls synchronous methods; you can learn more about that in <a data-type="xref" href="#calling_synchronous_code_from_async_code">Recipe 6.6</a>.<a data-type="indexterm" data-startref="ix_ch06-asciidoc2" id="idm45678775933264"/><a data-type="indexterm" data-startref="ix_ch06-asciidoc1" id="idm45678775932560"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm45678775931888">
<h2>See Also</h2>

<p><a data-type="xref" data-xrefstyle="rec-num-title" href="#creating_async_iterators">Recipe 6.3, “Creating Async Iterators”</a></p>

<p><a data-type="xref" data-xrefstyle="rec-num-title" href="#writing_safe_async_libraries">Recipe 6.4, “Writing Safe Async Libraries”</a></p>

<p><a data-type="xref" data-xrefstyle="rec-num-title" href="#calling_synchronous_code_from_async_code">Recipe 6.6, “Calling Synchronous Code from Async Code”</a></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="6.2 Reducing Memory Allocations for Async Return Values"><div class="sect1" id="idm45678775926592">
<h1>6.2 Reducing Memory Allocations for Async Return Values</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45678775925408">
<h2>Problem</h2>

<p><a data-type="indexterm" data-primary="asynchronous programming" data-secondary="reducing memory allocations for async return values" id="ix_ch06-asciidoc3"/><a data-type="indexterm" data-primary="memory, reducing allocations for async return values" id="ix_ch06-asciidoc4"/>You want to reduce memory consumption for your async code.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45678775921440">
<h2>Solution</h2>

<p><a data-type="indexterm" data-primary="ValueTask" id="idm45678775920096"/>Here’s how to use <code>ValueTask</code> instead of <code>Task</code> in async methods:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">class</code> <code class="nc">CheckoutService</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">async</code> <code class="n">ValueTask</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">StartAsync</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="k">await</code> <code class="nf">ValidateAddressAsync</code><code class="p">();</code>
        <code class="k">await</code> <code class="nf">ValidateCreditAsync</code><code class="p">();</code>
        <code class="k">await</code> <code class="nf">GetShoppingCartAsync</code><code class="p">();</code>
        <code class="k">await</code> <code class="nf">FinalizeCheckoutAsync</code><code class="p">();</code>

        <code class="k">return</code> <code class="s">"Checkout Complete"</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">async</code> <code class="n">ValueTask</code> <code class="nf">ValidateAddressAsync</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="c1">// perform address validation</code>
    <code class="p">}</code>

    <code class="k">async</code> <code class="n">ValueTask</code> <code class="nf">ValidateCreditAsync</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="c1">// ensure credit is good</code>
    <code class="p">}</code>

    <code class="k">async</code> <code class="n">ValueTask</code> <code class="nf">GetShoppingCartAsync</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="c1">// get contents of shopping cart</code>
    <code class="p">}</code>

    <code class="k">async</code> <code class="n">ValueTask</code> <code class="nf">FinalizeCheckoutAsync</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="c1">// complete checkout transaction</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>And here’s the app that consumes that class:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">class</code> <code class="nc">Program</code>
<code class="p">{</code>
    <code class="k">static</code> <code class="k">async</code> <code class="n">Task</code> <code class="nf">Main</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="kt">var</code> <code class="n">checkoutSvc</code> <code class="p">=</code> <code class="k">new</code> <code class="n">CheckoutService</code><code class="p">();</code>

        <code class="kt">string</code> <code class="n">result</code> <code class="p">=</code> <code class="k">await</code> <code class="n">checkoutSvc</code><code class="p">.</code><code class="n">StartAsync</code><code class="p">();</code>

        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"Result: {result}"</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45678775813248">
<h2>Discussion</h2>

<p><a data-type="indexterm" data-primary="Task class" id="idm45678775790752"/>Since the beginning of async, we’ve returned types by either <code>Task</code> or <code>Task&lt;T&gt;</code>. That has always worked and will continue to work fine for any async code. Over time, though, people identified specific circumstances that open new performance opportunities concerning the fact that <code>Task</code> is a reference type and the runtime caches <code>Tasks</code>.</p>

<p>The <code>Task</code> class, by definition, is a reference type. That means the runtime allocates heap memory every time an async method returns a <code>Task</code>. As you know, value types allocate memory where they are defined, but they don’t cause garbage collector <span class="keep-together">overhead</span>.</p>

<p>Perhaps not as obvious, another feature of <code>Tasks</code> is that the runtime caches them. Rather than <code>await</code> a method, it’s possible to reference the returned <code>Task</code> from an <code>async</code> method. With that <code>Task</code> reference, you can perform concurrent invocations on multiple tasks. You could also invoke that task more than once. The important point here is that the runtime has cached the task, resulting in more memory usage.</p>

<p>As mentioned, in normal coding a <code>Task</code> works fine and you might not care. However, think about high-performance scenarios where a lot of <code>Task</code> objects get allocated and you are interested in finding ways to improve performance and scalability. The solution simulates a concept where this might matter. Imagine a business that needs to process a high volume of shopping cart checkouts each day. In that case, eliminating any overhead for object allocation, garbage collection, and memory pressure could be beneficial.</p>

<p><a data-type="indexterm" data-primary="ValueTask" id="idm45678775745104"/>To address these concerns, Microsoft added support for <code>ValueTask</code> (and <code>ValueTask&lt;T&gt;</code>) as async return types. As its name suggests, <code>ValueTask</code> is a value type. Because it’s a value type, the only memory allocation it incurs is wherever the value resides, on the stack in this case. By definition of a value type, there isn’t any unique heap allocation or garbage collection just for that value.</p>

<p>Further, the runtime does not cache <code>ValueType</code>, resulting in less memory allocation and cache management. This works great in high-performance/scalability scenarios. The <code>CheckoutService</code> in the solution demonstrates how to use <code>ValueTask</code>: just use it in place of <code>Task</code>. The assumption here is that the code will always <code>await</code> the method and never try to reuse the <code>ValueTask</code>. In the solution, that’s exactly what happens.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you’re writing a reusable library for other developers, consider whether <code>ValueTask</code> is appropriate. By using <code>ValueTask</code>, you eliminate the ability of consuming code to perform concurrent task operations or any other advanced scenarios for where a <code>Task</code> is more appropriate. <code>Task</code> gives the most flexibility in this case.</p>
</div>

<p>As is with most things, there’s a trade-off. All of the scenarios for which the runtime <code>Task</code> cache were useful are no longer options for <code>ValueTask</code>. With <code>ValueTask</code>, you can’t combine operations or reuse a <code>ValueTask</code> after the first time. Recipes <a data-type="xref" data-xrefstyle="select:labelnumber" href="#waiting_for_parallel_tasks_to_complete">6.7</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#handling_parallel_tasks_as_they_complete">6.8</a> show a couple of scenarios where <code>ValueTask</code> doesn’t work.</p>

<p>To recap, use <code>ValueTask</code> when performance and scalability are a concern, and you’re free to use <code>Task</code> any other time.<a data-type="indexterm" data-startref="ix_ch06-asciidoc4" id="idm45678775729504"/><a data-type="indexterm" data-startref="ix_ch06-asciidoc3" id="idm45678775728768"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm45678775791344">
<h2>See Also</h2>

<p><a data-type="xref" data-xrefstyle="rec-num-title" href="#waiting_for_parallel_tasks_to_complete">Recipe 6.7, “Waiting for Parallel Tasks to Complete”</a></p>

<p><a data-type="xref" data-xrefstyle="rec-num-title" href="#handling_parallel_tasks_as_they_complete">Recipe 6.8, “Handling Parallel Tasks as They Complete”</a></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="6.3 Creating Async Iterators"><div class="sect1" id="creating_async_iterators">
<h1>6.3 Creating Async Iterators</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45678775723040">
<h2>Problem</h2>

<p><a data-type="indexterm" data-primary="asynchronous programming" data-secondary="creating async iterators" id="ix_ch06-asciidoc5"/><a data-type="indexterm" data-primary="iterators" data-secondary="creating async iterators" id="ix_ch06-asciidoc6"/>You’re working with async code and a classical synchronous iterator won’t work.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45678775718896">
<h2>Solution</h2>

<p>Here’s the data for the checkout process:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">class</code> <code class="nc">CheckoutRequest</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="n">Guid</code> <code class="n">ShoppingCartID</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>

    <code class="k">public</code> <code class="kt">string</code> <code class="n">Name</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>

    <code class="k">public</code> <code class="kt">string</code> <code class="n">Card</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>

    <code class="k">public</code> <code class="kt">string</code> <code class="n">Address</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code></pre>

<p>This is the checkout process for each request:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">class</code> <code class="nc">CheckoutService</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">async</code> <code class="n">ValueTask</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">StartAsync</code><code class="p">(</code><code class="n">CheckoutRequest</code> <code class="n">request</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="k">return</code>
            <code class="err">$</code><code class="s">"Checkout Complete for Shopping "</code> <code class="p">+</code>
            <code class="err">$</code><code class="s">"Basket: {request.ShoppingCartID}"</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>The async iterator processes each request:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">class</code> <code class="nc">CheckoutStream</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">async</code> <code class="n">IAsyncEnumerable</code><code class="p">&lt;</code><code class="n">CheckoutRequest</code><code class="p">&gt;</code> <code class="n">GetRequestsAsync</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="k">while</code> <code class="p">(</code><code class="k">true</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">CheckoutRequest</code><code class="p">&gt;</code> <code class="n">requests</code> <code class="p">=</code>
                <code class="k">await</code> <code class="nf">GetNextBatchAsync</code><code class="p">();</code>

            <code class="k">foreach</code> <code class="p">(</code><code class="kt">var</code> <code class="n">request</code> <code class="k">in</code> <code class="n">requests</code><code class="p">)</code>
                <code class="k">yield</code> <code class="k">return</code> <code class="n">request</code><code class="p">;</code>

            <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="m">1000</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">}</code>

    <code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">CheckoutRequest</code><code class="p">&gt;&gt;</code> <code class="n">GetNextBatchAsync</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="k">return</code> <code class="k">new</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">CheckoutRequest</code><code class="p">&gt;</code>
        <code class="p">{</code>
            <code class="k">new</code> <code class="n">CheckoutRequest</code>
            <code class="p">{</code>
                <code class="n">ShoppingCartID</code> <code class="p">=</code> <code class="n">Guid</code><code class="p">.</code><code class="n">NewGuid</code><code class="p">(),</code>
                <code class="n">Address</code> <code class="p">=</code> <code class="s">"123 4th St"</code><code class="p">,</code>
                <code class="n">Card</code> <code class="p">=</code> <code class="s">"1234 5678 9012 3456"</code><code class="p">,</code>
                <code class="n">Name</code> <code class="p">=</code> <code class="s">"First Card Name"</code>
            <code class="p">},</code>
            <code class="k">new</code> <code class="n">CheckoutRequest</code>
            <code class="p">{</code>
                <code class="n">ShoppingCartID</code> <code class="p">=</code> <code class="n">Guid</code><code class="p">.</code><code class="n">NewGuid</code><code class="p">(),</code>
                <code class="n">Address</code> <code class="p">=</code> <code class="s">"789 1st Ave"</code><code class="p">,</code>
                <code class="n">Card</code> <code class="p">=</code> <code class="s">"2345 6789 0123 4567"</code><code class="p">,</code>
                <code class="n">Name</code> <code class="p">=</code> <code class="s">"Second Card Name"</code>
            <code class="p">},</code>
            <code class="k">new</code> <code class="n">CheckoutRequest</code>
            <code class="p">{</code>
                <code class="n">ShoppingCartID</code> <code class="p">=</code> <code class="n">Guid</code><code class="p">.</code><code class="n">NewGuid</code><code class="p">(),</code>
                <code class="n">Address</code> <code class="p">=</code> <code class="s">"123 4th St"</code><code class="p">,</code>
                <code class="n">Card</code> <code class="p">=</code> <code class="s">"1234 5678 9012 3456"</code><code class="p">,</code>
                <code class="n">Name</code> <code class="p">=</code> <code class="s">"First Card Name"</code>
            <code class="p">},</code>
        <code class="p">};</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>Finally, the application consumes the iterator to process each request:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="k">async</code> <code class="n">Task</code> <code class="nf">Main</code><code class="p">()</code>
<code class="p">{</code>
    <code class="kt">var</code> <code class="n">checkoutSvc</code> <code class="p">=</code> <code class="k">new</code> <code class="n">CheckoutService</code><code class="p">();</code>
    <code class="kt">var</code> <code class="n">checkoutStrm</code> <code class="p">=</code> <code class="k">new</code> <code class="n">CheckoutStream</code><code class="p">();</code>

    <code class="k">await</code> <code class="nf">foreach</code> <code class="p">(</code><code class="kt">var</code> <code class="n">request</code> <code class="k">in</code> <code class="n">checkoutStrm</code><code class="p">.</code><code class="n">GetRequestsAsync</code><code class="p">())</code>
    <code class="p">{</code>
        <code class="kt">string</code> <code class="n">result</code> <code class="p">=</code> <code class="k">await</code> <code class="n">checkoutSvc</code><code class="p">.</code><code class="n">StartAsync</code><code class="p">(</code><code class="n">request</code><code class="p">);</code>

        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"Result: {result}"</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45678775386592">
<h2>Discussion</h2>

<p>While iterators are essential for .NET Framework collections like <code>List&lt;T&gt;</code> or a custom collection you’ve written, they can also be useful abstractions that hide complex data acquisition logic. The solution demonstrates a related scenario where an iterator might be useful—processing a stream of <code>CheckoutRequests</code> as if it were a collection.</p>

<p>An important aspect of the solution is that it’s impractical to hold too many <code>Check​ou⁠t​Request</code> instances in memory. If a system continuously receives orders, it needs to scale. In the solution, we imagine a polling implementation that continuously gets the next batch of <code>CheckoutRequests</code>. This reduces memory pressure and the iterator provides an abstraction that hides the complex details of how the program receives orders.</p>

<p>In the early days of async, it would have been more complex to perform a task like this because the polling is asynchronous, making an out-of-process request. It’s clearly possible to find a library that lets this happen synchronously, but that ignores the benefit of async. The solution solves this problem with a newer interface for async streams, <code>IAsyncEnumerable</code>.</p>

<p>The <code>CheckoutStream</code> class has an iterator named <code>GetRequestsAsync</code>, returning <span class="keep-together"><code>IAsyncEnumerable&lt;CheckoutRequest&gt;</code></span>. This is the async equivalent of the <span class="keep-together"><code>IEnumerable&lt;T&gt;</code></span> for synchronous iterators. Although the <code>while</code> loop continues forever in this demo and you’ll need to manually stop the app, <a data-type="xref" href="#cancelling_async_operations">Recipe 6.9</a> shows how to cancel the process gracefully. This iterator gets a new batch of <code>CheckoutRequests</code>, yields each item in the batch, and sleeps for a second before getting the next batch. The sleep, <code>Task.Delay</code>, is for demo purposes so you can see the output.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>yield</code> keyword is syntactic sugar to help turn type members into iterators. <code>IEnumerable&lt;T&gt;</code> types, including <code>IAsync​Enumer⁠able​&lt;T&gt;</code>, have <code>MoveNext</code> and <code>Current</code> members, where <code>MoveNext</code> loads <code>Current</code> with the next value it reads. Behind the scenes, when the C# compiler sees an iterator, it generates a new class with the <code>MoveNext</code> and <code>Current</code> members. When invoking <code>yield</code>, such as in <code>yield return request</code> in <code>GetRequestsAsync</code>, the C# compiler instantiates that new class, calls <code>MoveNext</code>, and returns <code>Current</code>.</p>
</div>

<p>The <code>GetNextBatchAsync</code> method only returns a list of <code>CheckoutRequests</code>. However, imagine that this is really an async call to a network endpoint, queue, or service bus that has the next set of <code>CheckoutRequest</code> instances ready. Recipes <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch01.xhtml#designing_a_custom_exception">1.9</a>, <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch03.xhtml#rethrowing_exceptions">3.7</a>, and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch03.xhtml#building_resilient_network_connections">3.9</a> demonstrate some of the issues you’ll care about when doing this. By moving all this complexity into the iterator, application code can consume data in a much simpler manner.</p>

<p>The <code>Main</code> method shows how to consume an async iterator. The first thing to notice is the <code>async</code> modifier on the <code>foreach</code> loop. This was a new addition to C# for async streams. As you can see, it allows <code>foreach</code> to work with an <code>IAsyncEnumerable&lt;T&gt;</code> iterator.<a data-type="indexterm" data-startref="ix_ch06-asciidoc6" id="idm45678775282256"/><a data-type="indexterm" data-startref="ix_ch06-asciidoc5" id="idm45678775281520"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm45678775280848">
<h2>See Also</h2>

<p><a data-type="xref" data-xrefstyle="rec-num-title" href="ch01.xhtml#designing_a_custom_exception">Recipe 1.9, “Designing a Custom Exception”</a></p>

<p><a data-type="xref" data-xrefstyle="rec-num-title" href="ch03.xhtml#rethrowing_exceptions">Recipe 3.7, “Rethrowing Exceptions”</a></p>

<p><a data-type="xref" data-xrefstyle="rec-num-title" href="ch03.xhtml#building_resilient_network_connections">Recipe 3.9, “Building Resilient Network Connections”</a></p>

<p><a data-type="xref" data-xrefstyle="rec-num-title" href="#cancelling_async_operations">Recipe 6.9, “Cancelling Async Operations”</a></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="6.4 Writing Safe Async Libraries"><div class="sect1" id="writing_safe_async_libraries">
<h1>6.4 Writing Safe Async Libraries</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45678775272624">
<h2>Problem</h2>

<p><a data-type="indexterm" data-primary="asynchronous programming" data-secondary="writing safe async libraries" id="ix_ch06-asciidoc7"/><a data-type="indexterm" data-primary="libraries" data-secondary="writing safe async libraries" id="ix_ch06-asciidoc8"/><a data-type="indexterm" data-primary="UI thread, writing safe async libraries for" id="ix_ch06-asciidoc9"/>Your async code is causing a deadlock with the UI thread.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45678775267440">
<h2>Solution</h2>

<p>This class marshals the code off of the UI thread:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">class</code> <code class="nc">CheckoutService</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">StartAsync</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="k">await</code> <code class="nf">ValidateAddressAsync</code><code class="p">().</code><code class="n">ConfigureAwait</code><code class="p">(</code><code class="k">false</code><code class="p">);</code>
        <code class="k">await</code> <code class="nf">ValidateCreditAsync</code><code class="p">().</code><code class="n">ConfigureAwait</code><code class="p">(</code><code class="k">false</code><code class="p">);</code>
        <code class="k">await</code> <code class="nf">GetShoppingCartAsync</code><code class="p">().</code><code class="n">ConfigureAwait</code><code class="p">(</code><code class="k">false</code><code class="p">);</code>
        <code class="k">await</code> <code class="nf">FinalizeCheckoutAsync</code><code class="p">().</code><code class="n">ConfigureAwait</code><code class="p">(</code><code class="k">false</code><code class="p">);</code>

        <code class="k">return</code> <code class="s">"Checkout Complete"</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">async</code> <code class="n">Task</code> <code class="nf">ValidateAddressAsync</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="c1">// perform address validation</code>
    <code class="p">}</code>

    <code class="k">async</code> <code class="n">Task</code> <code class="nf">ValidateCreditAsync</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="c1">// ensure credit is good</code>
    <code class="p">}</code>

    <code class="k">async</code> <code class="n">Task</code> <code class="nf">GetShoppingCartAsync</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="c1">// get contents of shopping cart</code>
    <code class="p">}</code>

    <code class="k">async</code> <code class="n">Task</code> <code class="nf">FinalizeCheckoutAsync</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="c1">// complete checkout transaction</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>Here’s the program that calls it:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="k">async</code> <code class="n">Task</code> <code class="nf">Main</code><code class="p">()</code>
<code class="p">{</code>
    <code class="kt">var</code> <code class="n">checkoutSvc</code> <code class="p">=</code> <code class="k">new</code> <code class="n">CheckoutService</code><code class="p">();</code>

    <code class="kt">string</code> <code class="n">result</code> <code class="p">=</code> <code class="k">await</code> <code class="n">checkoutSvc</code><code class="p">.</code><code class="n">StartAsync</code><code class="p">();</code>

    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"Result: {result}"</code><code class="p">);</code>
<code class="p">}</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45678775144480">
<h2>Discussion</h2>

<p>UI technology such as Windows Forms, Windows Presentation Foundation (WPF), and WinUI run on a single thread—the UI thread. This simplifies the work a developer needs to do when working with UI code. However, if you’re using async or writing multithreaded logic, it’s easy for things to go wrong. In particular, if another thread attempts to do anything with the UI or run in the same logic of the UI thread, you run the risk of race conditions and deadlocks. To understand how bad the problem can be, consider that your application often runs perfectly in the development, QA, and production environments. Then, without notice, the UI locks up, customers begin to complain, and you can’t reproduce the problem.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In some cases, depending on the UI you’re using and the .NET version, you might get an exception like the following when accessing the UI from a non-UI thread:</p>

<pre data-type="programlisting" data-code-language="text">System.InvalidOperationException:
     'The calling thread cannot access this object
     because a different thread owns it.'</pre>

<p>This is good because at least you know there’s a problem.</p>
</div>

<p><a data-type="xref" href="#creating_async_console_applications">Recipe 6.1</a> explained how calling <code>Wait</code> or assigning <code>Result</code> on a <code>Task</code> could cause a deadlock. The problem here occurs because <code>Wait</code> and <code>Result</code> block the UI thread, waiting on a response. The called async code executes, returns, and tries to run on <span class="keep-together">the same</span> thread. However, as just mentioned, the UI thread is blocked, causing a <span class="keep-together">deadlock</span>.</p>

<p>The solution fixes this problem in the <code>CheckoutService.StartAsync</code> method. Notice how it calls <code>ConfigureAwait(false)</code>—the only difference between this code and the solution in <a data-type="xref" href="#creating_async_console_applications">Recipe 6.1</a>. What this does is marshal execution off of the calling thread (the UI thread) and onto a new thread. Now, when the thread returns from the async call, it won’t cause a deadlock.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>ConfigureAwait(true)</code> is the default condition when awaiting a <code>Task</code>. Changing this default is only needed in advanced scenarios that are out of the scope of practical everyday engineering. If you ever see it in code, it might be good to question why someone needed it.</p>
</div>

<p>A significant point to be made here is that the problem statement clearly says <em>libraries</em>. When writing a library, you want the code to work regardless of what code called it. Therefore, the library code must be independent and unaware of who the caller is. This is an example, as stated in <a data-type="xref" href="ch01.xhtml#designing_application_layers">Recipe 1.5</a>, where separation of concerns is important. If the library code doesn’t manipulate the UI, which it never should, you’ll avoid threading problems like race conditions and deadlocks.</p>

<p>It’s important to note that if one <code>await</code> is on <code>ConfigureAwait(false)</code>, all <code>awaits</code> in a method should be also. The reason is that some methods execute so quickly that they execute synchronously, and <code>ConfigureAwait(false)</code> doesn’t marshal the thread. If another <code>await</code> then runs asynchronously, without <code>ConfigureAwait(false)</code>, you’ll have the same threading problems as if <code>ConfigureAwait(false)</code> was never called.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Visual Studio analyzers set warnings on all non-UI code with async calls missing <code>ConfigureAwait(false)</code>. It might be tedious to add these, but you still should. Even if you think the first <code>await</code> of a method is guaranteed to run asynchronously, logic changes over time with maintenance, and you might inadvertently cause threading problems. It’s safer to leave this analyzer enabled and follow the recommendations.</p>
</div>

<p>Another benefit of <code>ConfigureAwait(false)</code> is that it slightly improves efficiency. The default, <code>ConfigureAwait(true)</code>, incurs overhead for setting up a callback that marshals the completed thread onto the UI thread. <code>ConfigureAwait(false)</code> avoids this.</p>

<p>Going back to the point about <code>ConfigureAwait(false)</code> being appropriate for library code, there are times when you don’t want to use it. More specifically, you don’t want to call <code>ConfigureAwait(false)</code> in UI code, in particular event handlers. Think about an event handler and what it does. It gets called in response to some user action, like a button click, and it sets status, updates waiting indicators, disables controls that the user shouldn’t interact with, makes the call, and afterward resets the UI. All of this work is happening on the UI thread, as it should. In this case, you don’t want to <span class="keep-together">marshal</span> off the UI thread with <code>ConfigureAwait(false)</code> because that will cause multithreaded UI problems.</p>

<p>Although library code should never know about a UI, there are times when the code should communicate progress or status. Rather than accessing UI code directly, there’s another way to communicate status, as discussed in the next section.<a data-type="indexterm" data-startref="ix_ch06-asciidoc9" id="idm45678775045280"/><a data-type="indexterm" data-startref="ix_ch06-asciidoc8" id="idm45678775044576"/><a data-type="indexterm" data-startref="ix_ch06-asciidoc7" id="idm45678775043904"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm45678775123168">
<h2>See Also</h2>

<p><a data-type="xref" data-xrefstyle="rec-num-title" href="ch01.xhtml#designing_application_layers">Recipe 1.5, “Designing Application Layers”</a></p>

<p><a data-type="xref" data-xrefstyle="rec-num-title" href="#updating_progress_asynchronously">Recipe 6.5, “Updating Progress Asynchronously”</a></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="6.5 Updating Progress Asynchronously"><div class="sect1" id="updating_progress_asynchronously">
<h1>6.5 Updating Progress Asynchronously</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45678775037824">
<h2>Problem</h2>

<p><a data-type="indexterm" data-primary="asynchronous programming" data-secondary="updating progress asynchronously" id="ix_ch06-asciidoc10"/><a data-type="indexterm" data-primary="status updates" id="ix_ch06-asciidoc11"/>You need to display the status from an async task without blocking the UI thread.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45678775033968">
<h2>Solution</h2>

<p>This class holds progress status info:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">class</code> <code class="nc">CheckoutRequestProgress</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="kt">int</code> <code class="n">Total</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>

    <code class="k">public</code> <code class="kt">string</code> <code class="n">Message</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code></pre>

<p>This method reports progress:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">async</code> <code class="n">IAsyncEnumerable</code><code class="p">&lt;</code><code class="n">CheckoutRequest</code><code class="p">&gt;</code>
    <code class="n">GetRequestsAsync</code><code class="p">(</code><code class="n">IProgress</code><code class="p">&lt;</code><code class="n">CheckoutRequestProgress</code><code class="p">&gt;</code> <code class="n">progress</code><code class="p">)</code>
<code class="p">{</code>
    <code class="kt">int</code> <code class="n">total</code> <code class="p">=</code> <code class="m">0</code><code class="p">;</code>

    <code class="k">while</code> <code class="p">(</code><code class="k">true</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">List</code><code class="p">&lt;</code><code class="n">CheckoutRequest</code><code class="p">&gt;</code> <code class="n">requests</code> <code class="p">=</code>
            <code class="k">await</code> <code class="nf">GetNextBatchAsync</code><code class="p">().</code><code class="n">ConfigureAwait</code><code class="p">(</code><code class="k">false</code><code class="p">);</code>

        <code class="n">total</code> <code class="p">+=</code> <code class="n">requests</code><code class="p">.</code><code class="n">Count</code><code class="p">;</code>

        <code class="k">foreach</code> <code class="p">(</code><code class="kt">var</code> <code class="n">request</code> <code class="k">in</code> <code class="n">requests</code><code class="p">)</code>
            <code class="k">yield</code> <code class="k">return</code> <code class="n">request</code><code class="p">;</code>

        <code class="n">progress</code><code class="p">.</code><code class="n">Report</code><code class="p">(</code>
            <code class="k">new</code> <code class="n">CheckoutRequestProgress</code>
            <code class="p">{</code>
                <code class="n">Total</code> <code class="p">=</code> <code class="n">total</code><code class="p">,</code>
                <code class="n">Message</code> <code class="p">=</code> <code class="s">"New Batch of Checkout Requests"</code>
            <code class="p">});</code>

        <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="m">1000</code><code class="p">).</code><code class="n">ConfigureAwait</code><code class="p">(</code><code class="k">false</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>Here’s the program that initializes and consumes progress updates:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="k">async</code> <code class="n">Task</code> <code class="nf">Main</code><code class="p">()</code>
<code class="p">{</code>
    <code class="kt">var</code> <code class="n">checkoutSvc</code> <code class="p">=</code> <code class="k">new</code> <code class="n">CheckoutService</code><code class="p">();</code>
    <code class="kt">var</code> <code class="n">checkoutStrm</code> <code class="p">=</code> <code class="k">new</code> <code class="n">CheckoutStream</code><code class="p">();</code>

    <code class="n">IProgress</code><code class="p">&lt;</code><code class="n">CheckoutRequestProgress</code><code class="p">&gt;</code> <code class="n">progress</code> <code class="p">=</code>
        <code class="k">new</code> <code class="n">Progress</code><code class="p">&lt;</code><code class="n">CheckoutRequestProgress</code><code class="p">&gt;(</code><code class="n">p</code> <code class="p">=&gt;</code>
        <code class="p">{</code>
            <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code>
                <code class="err">$</code><code class="s">"\n"</code> <code class="p">+</code>
                <code class="err">$</code><code class="s">"Total: {p.Total}, "</code> <code class="p">+</code>
                <code class="err">$</code><code class="s">"{p.Message}"</code> <code class="p">+</code>
                <code class="err">$</code><code class="s">"\n"</code><code class="p">);</code>
        <code class="p">});</code>

    <code class="k">await</code> <code class="nf">foreach</code> <code class="p">(</code><code class="kt">var</code> <code class="n">request</code> <code class="k">in</code>
        <code class="n">checkoutStrm</code><code class="p">.</code><code class="n">GetRequestsAsync</code><code class="p">(</code><code class="n">progress</code><code class="p">))</code>
    <code class="p">{</code>
        <code class="kt">string</code> <code class="n">result</code> <code class="p">=</code> <code class="k">await</code> <code class="n">checkoutSvc</code><code class="p">.</code><code class="n">StartAsync</code><code class="p">(</code><code class="n">request</code><code class="p">);</code>

        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"Result: {result}"</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45678774851488">
<h2>Discussion</h2>

<p>As explained in <a data-type="xref" href="#writing_safe_async_libraries">Recipe 6.4</a>, library code should never update the UI directly. If properly written, it will be running on a separate thread and be oblivious to who its caller is. That said, there are times when the business layer or library code might want to inform a caller of progress or status. The solution shows a situation where an iterator updates the UI with progress, defined in the <code>CheckoutRequestProgress</code> class. Essentially, the library code defines what type of progress information it offers and the calling code works with that. In this case, it’s the total number of orders processed and some message indicating status.</p>

<p>The <code>GetRequestAsync</code> method accepts a parameter of <code>IProgress&lt;CheckoutRequestProgress&gt;</code>, <code>progress</code>. The <code>IProgress&lt;T&gt;</code> is part of the .NET Framework, as is the <code>Progress&lt;T&gt;</code> class, which implements <code>IProgress&lt;T&gt;</code>. With the progress instance, <code>GetRequestsAsync</code> calls <code>Report</code>, passing an instance of <code>CheckoutRequestProgress</code> with populated properties. This sends the progress to a handler in the UI.</p>

<p>The <code>Main</code> method sets up reporting by instantiating a <code>Progress&lt;CheckoutRequest​Pro⁠gress&gt;</code> and assigning it to <code>progress</code>, an <code>IProgress&lt;CheckoutRequestProgress&gt;</code>. The <code>Progress&lt;T&gt;</code> constructor accepts an <code>Action</code> delegate, and <code>Main</code> assigns a lambda that writes progress to the console. Every time <code>GetRequestsAsync</code> calls <code>Report</code>, this lambda executes. Going full circle, <code>Main</code> passes <code>progress</code> as an argument to the <code>Get​Re⁠questsAsync</code> call, so it can reference the same object to report on.</p>

<p>You might have noticed that <code>GetRequestAsync</code> is running asynchronously, and the <code>await</code> on <code>GetNextBatchAsync</code> and <code>Task.Delay</code> also call <code>ConfigureAwait(false)</code>. If that code runs on another thread, other than the UI thread, what’s the possibility of a deadlock? None, because <code>Progress&lt;T&gt;</code> marshals the call back onto the UI thread so the code can safely interact with the UI. Remember, the library code, <code>GetRequests​A⁠sync</code>, has no knowledge of the lambda argument for the <code>Process&lt;T&gt;</code> constructor’s <code>Action</code> parameter. That means the lambda can safely access any UI code as necessary for displaying progress.<a data-type="indexterm" data-startref="ix_ch06-asciidoc11" id="idm45678774707856"/><a data-type="indexterm" data-startref="ix_ch06-asciidoc10" id="idm45678774707152"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm45678774712208">
<h2>See Also</h2>

<p><a data-type="xref" data-xrefstyle="rec-num-title" href="#writing_safe_async_libraries">Recipe 6.4, “Writing Safe Async Libraries”</a></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="6.6 Calling Synchronous Code from Async Code"><div class="sect1" id="calling_synchronous_code_from_async_code">
<h1>6.6 Calling Synchronous Code from Async Code</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45678774702640">
<h2>Problem</h2>

<p><a data-type="indexterm" data-primary="async language syntax" data-secondary="calling synchronous code from async code" id="ix_ch06-asciidoc12"/><a data-type="indexterm" data-primary="asynchronous programming" data-secondary="calling synchronous code from async code" id="ix_ch06-asciidoc13"/><a data-type="indexterm" data-primary="synchronous code, calling from async code" id="ix_ch06-asciidoc14"/>The only code inside your async method is synchronous and you want to <code>await</code> it asynchronously.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45678774697040">
<h2>Solution</h2>

<p>This class demonstrates how to return asynchronous results from synchronous logic:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">class</code> <code class="nc">CheckoutService</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">StartAsync</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="k">await</code> <code class="nf">ValidateAddressAsync</code><code class="p">().</code><code class="n">ConfigureAwait</code><code class="p">(</code><code class="k">false</code><code class="p">);</code>
        <code class="k">await</code> <code class="nf">ValidateCreditAsync</code><code class="p">().</code><code class="n">ConfigureAwait</code><code class="p">(</code><code class="k">false</code><code class="p">);</code>
        <code class="k">await</code> <code class="nf">GetShoppingCartAsync</code><code class="p">().</code><code class="n">ConfigureAwait</code><code class="p">(</code><code class="k">false</code><code class="p">);</code>
        <code class="k">await</code> <code class="nf">FinalizeCheckoutAsync</code><code class="p">().</code><code class="n">ConfigureAwait</code><code class="p">(</code><code class="k">false</code><code class="p">);</code>

        <code class="k">return</code> <code class="s">"Checkout Complete"</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">bool</code><code class="p">&gt;</code> <code class="n">ValidateAddressAsync</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="kt">bool</code> <code class="n">result</code> <code class="p">=</code> <code class="k">true</code><code class="p">;</code>
        <code class="k">return</code> <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">FromResult</code><code class="p">(</code><code class="n">result</code><code class="p">);</code>
    <code class="p">}</code>

    <code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">bool</code><code class="p">&gt;</code> <code class="n">ValidateCreditAsync</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="kt">bool</code> <code class="n">result</code> <code class="p">=</code> <code class="k">true</code><code class="p">;</code>
        <code class="k">return</code> <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">FromResult</code><code class="p">(</code><code class="n">result</code><code class="p">);</code>
    <code class="p">}</code>

    <code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">bool</code><code class="p">&gt;</code> <code class="n">GetShoppingCartAsync</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="kt">bool</code> <code class="n">result</code> <code class="p">=</code> <code class="k">true</code><code class="p">;</code>
        <code class="k">return</code> <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">FromResult</code><code class="p">(</code><code class="n">result</code><code class="p">);</code>
    <code class="p">}</code>

    <code class="k">async</code> <code class="n">Task</code> <code class="nf">FinalizeCheckoutAsync</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">CompletedTask</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>This is the code that runs the app:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="k">async</code> <code class="n">Task</code> <code class="nf">Main</code><code class="p">()</code>
<code class="p">{</code>
    <code class="kt">var</code> <code class="n">checkoutSvc</code> <code class="p">=</code> <code class="k">new</code> <code class="n">CheckoutService</code><code class="p">();</code>

    <code class="kt">string</code> <code class="n">result</code> <code class="p">=</code> <code class="k">await</code> <code class="n">checkoutSvc</code><code class="p">.</code><code class="n">StartAsync</code><code class="p">();</code>

    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"Result: {result}"</code><code class="p">);</code>
<code class="p">}</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45678774510992">
<h2>Discussion</h2>

<p>For simplicity, previous sections of this chapter call synchronous code from asynchronous code. One of the things you might have noticed is that Visual Studio (same as other IDEs) shows green squiggly underlines when an async method doesn’t <code>await</code> anything. You’ll also receive the following warning:</p>

<pre data-type="programlisting" data-code-language="text">CS1998: This async method lacks 'await' operators
and will run synchronously.
Consider using the 'await' operator to await non-blocking API calls,
or 'await Task.Run(...)' to do CPU-bound work on a background thread.</pre>

<p>It’s good the compiler emits this warning because it could be an error. It’s possible you forgot to add the <code>await</code> modifier to an async method call. In that case, program execution doesn’t stop at the awaited method. Both the async method and the code that calls it run. The async method that wasn’t awaited might not complete if the program exits.</p>

<p class="pagebreak-before less_space">Another problem is that if the async method that wasn’t awaited throws an exception, it won’t be caught because the calling code continued to run. A similar problem happens with <code>async</code> <code>void</code> methods where you can’t <code>await</code> them and there’s no way to catch exceptions.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>A couple of places in this chapter describe compiler warnings associated with async code. In a lot of circumstances, these warnings represent error conditions. Too often, I’ve encountered applications with unmanageable warning walls. It’s as if the developers somehow don’t believe warnings are a problem or aren’t paying attention. Understanding the implications of how a warning could be serious, especially accidentally forgetting to <code>await</code> an async method or failing to add <code>ConfigureAwait(false)</code>, as described in <a data-type="xref" href="#writing_safe_async_libraries">Recipe 6.4</a>, might provide the motivation to prioritize cleaning up and maintaining warnings.</p>
</div>

<p>Sometimes the code inside of an async method is genuinely synchronous. It might have originally been async but changed in maintenance, or you have to implement an interface. In this case, you have a couple of approaches. One is to remove the <code>async/await</code> keywords in the call chain until you reach a higher-level method that requires async. If there are multiple callers awaiting that method or it’s part of a public interface for multiple applications, you might not want to do that refactoring right away. The other approach, demonstrated in the solution, is to <code>await</code> <code>Task.FromResult&lt;T&gt;</code>.</p>

<p>You can see how this works in the <code>CheckoutService</code>, for <code>StartAsync</code>, where each method returns the result of awaiting <code>Task.FromResult&lt;T&gt;</code>. The <code>Task.From​Re⁠sult​&lt;T&gt;</code> method is generic, so you can use it on any type.</p>

<p>Awaiting <code>Task.FromResult&lt;T&gt;</code> works when the method needs to return a value. However, the <code>FinalizeTaskAsync</code> method only returns <code>Task</code>. Notice how that method simply awaits <code>Task.CompletedTask</code>.</p>

<p>One of the things you might be thinking is that this is extra work just to get rid of a warning. While that’s true, consider the benefits. You do clear the warning and enjoy the productivity boost in keeping the warning wall trimmed. More importantly, the code explicitly states its intention, and developers doing maintenance will clearly see there isn’t an error from a missing <code>await</code>—the code is correct.<a data-type="indexterm" data-startref="ix_ch06-asciidoc14" id="idm45678774441552"/><a data-type="indexterm" data-startref="ix_ch06-asciidoc13" id="idm45678774440816"/><a data-type="indexterm" data-startref="ix_ch06-asciidoc12" id="idm45678774440144"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm45678774491632">
<h2>See Also</h2>

<p><a data-type="xref" data-xrefstyle="rec-num-title" href="#writing_safe_async_libraries">Recipe 6.4, “Writing Safe Async Libraries”</a></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="6.7 Waiting for Parallel Tasks to Complete"><div class="sect1" id="waiting_for_parallel_tasks_to_complete">
<h1>6.7 Waiting for Parallel Tasks to Complete</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45678774416368">
<h2>Problem</h2>

<p><a data-type="indexterm" data-primary="asynchronous programming" data-secondary="waiting for parallel tasks to complete" id="ix_ch06-asciidoc15"/><a data-type="indexterm" data-primary="parallel tasks" data-secondary="waiting for parallel tasks to complete" id="ix_ch06-asciidoc16"/>You have multiple tasks, running in parallel, and need to wait for all of them to complete before continuing.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45678774412144">
<h2>Solution</h2>

<p>This code runs parallel tasks:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">class</code> <code class="nc">CheckoutService</code>
<code class="p">{</code>
    <code class="k">class</code> <code class="nc">WhenAllResult</code>
    <code class="p">{</code>
        <code class="k">public</code> <code class="kt">bool</code> <code class="n">IsValidAddress</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
        <code class="k">public</code> <code class="kt">bool</code> <code class="n">IsValidCredit</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
        <code class="k">public</code> <code class="kt">bool</code> <code class="n">HasShoppingCart</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
    <code class="p">}</code>

    <code class="k">public</code> <code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">StartAsync</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="kt">var</code> <code class="n">checkoutTasks</code> <code class="p">=</code>
            <code class="k">new</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Task</code><code class="p">&lt;(</code><code class="kt">string</code><code class="p">,</code> <code class="kt">bool</code><code class="p">)&gt;&gt;</code>
            <code class="p">{</code>
                <code class="n">ValidateAddressAsync</code><code class="p">(),</code>
                <code class="n">ValidateCreditAsync</code><code class="p">(),</code>
                <code class="n">GetShoppingCartAsync</code><code class="p">()</code>
            <code class="p">};</code>

        <code class="n">Task</code><code class="p">&lt;(</code><code class="kt">string</code> <code class="n">method</code><code class="p">,</code> <code class="kt">bool</code> <code class="n">result</code><code class="p">)[]&gt;</code> <code class="n">allTasks</code> <code class="p">=</code>
            <code class="n">Task</code><code class="p">.</code><code class="n">WhenAll</code><code class="p">(</code><code class="n">checkoutTasks</code><code class="p">);</code>

        <code class="k">if</code> <code class="p">(</code><code class="n">allTasks</code><code class="p">.</code><code class="n">IsCompletedSuccessfully</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="n">WhenAllResult</code> <code class="n">whenAllResult</code> <code class="p">=</code> <code class="n">GetResultsAsync</code><code class="p">(</code><code class="n">allTasks</code><code class="p">);</code>

            <code class="k">await</code> <code class="nf">FinalizeCheckoutAsync</code><code class="p">(</code><code class="n">whenAllResult</code><code class="p">);</code>

            <code class="k">return</code> <code class="s">"Checkout Complete"</code><code class="p">;</code>
        <code class="p">}</code>
        <code class="k">else</code>
        <code class="p">{</code>
            <code class="k">throw</code> <code class="n">allTasks</code><code class="p">.</code><code class="n">Exception</code><code class="p">;</code>
        <code class="p">}</code>
    <code class="p">}</code>

    <code class="n">WhenAllResult</code> <code class="nf">GetResultsAsync</code><code class="p">(</code>
        <code class="n">Task</code><code class="p">&lt;(</code><code class="kt">string</code> <code class="n">method</code><code class="p">,</code> <code class="kt">bool</code> <code class="n">result</code><code class="p">)[]&gt;</code> <code class="n">allTasks</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="kt">var</code> <code class="n">whenAllResult</code> <code class="p">=</code> <code class="k">new</code> <code class="n">WhenAllResult</code><code class="p">();</code>

        <code class="k">foreach</code> <code class="p">(</code><code class="kt">var</code> <code class="p">(</code><code class="n">method</code><code class="p">,</code> <code class="n">result</code><code class="p">)</code> <code class="k">in</code> <code class="n">allTasks</code><code class="p">.</code><code class="n">Result</code><code class="p">)</code>
            <code class="k">switch</code> <code class="p">(</code><code class="n">method</code><code class="p">)</code>
            <code class="p">{</code>
                <code class="k">case</code> <code class="nf">nameof</code><code class="p">(</code><code class="n">ValidateAddressAsync</code><code class="p">):</code>
                    <code class="n">whenAllResult</code><code class="p">.</code><code class="n">IsValidAddress</code> <code class="p">=</code> <code class="n">result</code><code class="p">;</code>
                    <code class="k">break</code><code class="p">;</code>
                <code class="k">case</code> <code class="nf">nameof</code><code class="p">(</code><code class="n">ValidateCreditAsync</code><code class="p">):</code>
                    <code class="n">whenAllResult</code><code class="p">.</code><code class="n">IsValidCredit</code> <code class="p">=</code> <code class="n">result</code><code class="p">;</code>
                    <code class="k">break</code><code class="p">;</code>
                <code class="k">case</code> <code class="nf">nameof</code><code class="p">(</code><code class="n">GetShoppingCartAsync</code><code class="p">):</code>
                    <code class="n">whenAllResult</code><code class="p">.</code><code class="n">HasShoppingCart</code> <code class="p">=</code> <code class="n">result</code><code class="p">;</code>
                    <code class="k">break</code><code class="p">;</code>
            <code class="p">}</code>

        <code class="k">return</code> <code class="n">whenAllResult</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">async</code> <code class="n">Task</code><code class="p">&lt;(</code><code class="kt">string</code><code class="p">,</code> <code class="kt">bool</code><code class="p">)&gt;</code> <code class="n">ValidateAddressAsync</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="c1">//throw new ArgumentException("Testing!");</code>

        <code class="k">return</code> <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">FromResult</code><code class="p">(</code>
            <code class="p">(</code><code class="n">nameof</code><code class="p">(</code><code class="n">ValidateAddressAsync</code><code class="p">),</code> <code class="k">true</code><code class="p">));</code>
    <code class="p">}</code>

    <code class="k">async</code> <code class="n">Task</code><code class="p">&lt;(</code><code class="kt">string</code><code class="p">,</code> <code class="kt">bool</code><code class="p">)&gt;</code> <code class="n">ValidateCreditAsync</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="k">return</code> <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">FromResult</code><code class="p">(</code>
            <code class="p">(</code><code class="n">nameof</code><code class="p">(</code><code class="n">ValidateCreditAsync</code><code class="p">),</code> <code class="k">true</code><code class="p">));</code>
    <code class="p">}</code>

    <code class="k">async</code> <code class="n">Task</code><code class="p">&lt;(</code><code class="kt">string</code><code class="p">,</code> <code class="kt">bool</code><code class="p">)&gt;</code> <code class="n">GetShoppingCartAsync</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="k">return</code> <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">FromResult</code><code class="p">(</code>
            <code class="p">(</code><code class="n">nameof</code><code class="p">(</code><code class="n">GetShoppingCartAsync</code><code class="p">),</code> <code class="k">true</code><code class="p">));</code>
    <code class="p">}</code>

    <code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">bool</code><code class="p">&gt;</code> <code class="n">FinalizeCheckoutAsync</code><code class="p">(</code><code class="n">WhenAllResult</code> <code class="n">result</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code>
            <code class="err">$</code><code class="s">"{nameof(WhenAllResult.IsValidAddress)}: "</code> <code class="p">+</code>
            <code class="err">$</code><code class="s">"{result.IsValidAddress}"</code><code class="p">);</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code>
            <code class="err">$</code><code class="s">"{nameof(WhenAllResult.IsValidCredit)}: "</code> <code class="p">+</code>
            <code class="err">$</code><code class="s">"{result.IsValidCredit}"</code><code class="p">);</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code>
            <code class="err">$</code><code class="s">"{nameof(WhenAllResult.HasShoppingCart)}: "</code> <code class="p">+</code>
            <code class="err">$</code><code class="s">"{result.HasShoppingCart}"</code><code class="p">);</code>

        <code class="kt">bool</code> <code class="n">success</code> <code class="p">=</code> <code class="k">true</code><code class="p">;</code>
        <code class="k">return</code> <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">FromResult</code><code class="p">(</code><code class="n">success</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>Here’s the app that requests and handles parallel task results:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="k">async</code> <code class="n">Task</code> <code class="nf">Main</code><code class="p">()</code>
<code class="p">{</code>
    <code class="k">try</code>
    <code class="p">{</code>
        <code class="kt">var</code> <code class="n">checkoutSvc</code> <code class="p">=</code> <code class="k">new</code> <code class="n">CheckoutService</code><code class="p">();</code>

        <code class="kt">string</code> <code class="n">result</code> <code class="p">=</code> <code class="k">await</code> <code class="n">checkoutSvc</code><code class="p">.</code><code class="n">StartAsync</code><code class="p">();</code>

        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"Result: {result}"</code><code class="p">);</code>
    <code class="p">}</code>
    <code class="k">catch</code> <code class="p">(</code><code class="n">AggregateException</code> <code class="n">aEx</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="k">foreach</code> <code class="p">(</code><code class="kt">var</code> <code class="n">ex</code> <code class="k">in</code> <code class="n">aEx</code><code class="p">.</code><code class="n">InnerExceptions</code><code class="p">)</code>
            <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"Unable to complete: {ex}"</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45678773958320">
<h2>Discussion</h2>

<p>When performing an action, such as shopping cart checkout, you don’t want the user to wait too long for the app to return. Running too many operations sequentially can make the wait longer. One of the ways to improve that user experience is to run independent operations concurrently.</p>

<p>In the solution, the <code>CheckoutService</code> has four different async services. Here we assume that three of those operations, <code>ValidateAddress​A⁠sync</code>, <code>ValidateCredit​A⁠sync</code>, and <code>GetShoppingCart​A⁠sync</code>, don’t have any dependencies on each other. This makes them good candidates for running at the same time.</p>

<p>The <code>StartAsync</code> method does this by creating a <code>List&lt;Task&gt;</code>. If you recall, awaiting a method is really an <code>await</code> on the returned <code>Task</code>. Without the <code>await</code>, each method returns a <code>Task</code>, but its logic doesn’t run until that task is awaited.</p>

<p>The <code>Task</code> class has a <code>WhenAll</code> method, whose purpose is to run all of the tasks, specified by the <code>checkoutTasks</code> argument, concurrently. <code>WhenAll</code> waits until all of the <code>Tasks</code> complete before returning.</p>

<p>Awaiting a single method with a return type is straightforward from the perspective that you assign the return value to a single variable. However, when running tasks concurrently, you need to correlate responses because <code>WhenAll</code> returns all tasks at the same time. Making an assumption about which tasks occur in which position of the collection could be error prone and cumbersome in maintenance. The code needs to know which response goes with which <code>Task</code>.</p>

<p>The solution does this via a tuple, where the <code>string</code> is the name of the method and <code>bool</code> is the response. The tuple and choice of contents was specific for this demo, and you would shape the task type in whatever way that makes sense for your app. This lets us know which task goes with which result. The <code>GetResultsAsync</code> method does this by iterating through the task array, and building the <code>WhenAllResult</code>, based on the method parameter of each response.</p>

<p>Notice that the first line of <code>ValidateAddressAsync</code> is a commented statement that throws an <code>ArgumentException</code>. Uncommenting and running the app again results in an exception during the call to <code>WhenAll</code>. The <code>Main</code> method handles that exception with a <code>catch</code> on <code>AggregateException</code>. Since all tasks are running concurrently, one or more of them could throw an exception. The <code>AggregateException</code> collects those exceptions. Normally, you would look in the <code>InnerException</code> property for exception details. However, <code>AggregateException</code> has another property, <code>InnerExceptions</code>. The difference is that the <code>AggregateException</code> property is plural, which is intentional. For proper debugging, you can find all exceptions in the <code>InnerExceptions</code> property.<a data-type="indexterm" data-startref="ix_ch06-asciidoc16" id="idm45678773852448"/><a data-type="indexterm" data-startref="ix_ch06-asciidoc15" id="idm45678773851712"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm45678773858032">
<h2>See Also</h2>

<p><a data-type="xref" data-xrefstyle="rec-num-title" href="#handling_parallel_tasks_as_they_complete">Recipe 6.8, “Handling Parallel Tasks as They Complete”</a></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="6.8 Handling Parallel Tasks as They Complete"><div class="sect1" id="handling_parallel_tasks_as_they_complete">
<h1>6.8 Handling Parallel Tasks as They Complete</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45678773847024">
<h2>Problem</h2>

<p><a data-type="indexterm" data-primary="asynchronous programming" data-secondary="handling parallel tasks as they complete" id="ix_ch06-asciidoc17"/><a data-type="indexterm" data-primary="parallel tasks" data-secondary="handling parallel tasks as they complete" id="ix_ch06-asciidoc18"/><a data-type="indexterm" data-primary="Task.WhenAny" id="ix_ch06-asciidoc19"/>You thought calling <code>Task.WhenAny</code> would be an efficient use of resources for processing results as they complete, but cost and performance are terrible.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45678773841344">
<h2>Solution</h2>

<p>This is a sequential implementation for calling multiple tasks:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">StartBigONAsync</code><code class="p">()</code>
<code class="p">{</code>
    <code class="p">(</code><code class="n">_</code><code class="p">,</code> <code class="kt">bool</code> <code class="n">addressResult</code><code class="p">)</code> <code class="p">=</code> <code class="k">await</code> <code class="n">ValidateAddressAsync</code><code class="p">();</code>
    <code class="p">(</code><code class="n">_</code><code class="p">,</code> <code class="kt">bool</code> <code class="n">creditResult</code><code class="p">)</code> <code class="p">=</code> <code class="k">await</code> <code class="n">ValidateCreditAsync</code><code class="p">();</code>
    <code class="p">(</code><code class="n">_</code><code class="p">,</code> <code class="kt">bool</code> <code class="n">cartResult</code><code class="p">)</code> <code class="p">=</code> <code class="k">await</code> <code class="n">GetShoppingCartAsync</code><code class="p">();</code>

    <code class="k">await</code> <code class="nf">FinalizeCheckoutAsync</code><code class="p">(</code>
        <code class="k">new</code> <code class="n">AllTasksResult</code>
        <code class="p">{</code>
            <code class="n">IsValidAddress</code> <code class="p">=</code> <code class="n">addressResult</code><code class="p">,</code>
            <code class="n">IsValidCredit</code> <code class="p">=</code> <code class="n">creditResult</code><code class="p">,</code>
            <code class="n">HasShoppingCart</code> <code class="p">=</code> <code class="n">cartResult</code>
        <code class="p">});</code>

    <code class="k">return</code> <code class="s">"Checkout Complete"</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>Here’s a parallel implementation for calling multiple tasks:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">StartBigO1Async</code><code class="p">()</code>
<code class="p">{</code>
    <code class="kt">var</code> <code class="n">checkoutTasks</code> <code class="p">=</code>
        <code class="k">new</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Task</code><code class="p">&lt;(</code><code class="kt">string</code><code class="p">,</code> <code class="kt">bool</code><code class="p">)&gt;&gt;</code>
        <code class="p">{</code>
            <code class="n">ValidateAddressAsync</code><code class="p">(),</code>
            <code class="n">ValidateCreditAsync</code><code class="p">(),</code>
            <code class="n">GetShoppingCartAsync</code><code class="p">()</code>
        <code class="p">};</code>

    <code class="n">Task</code><code class="p">&lt;(</code><code class="kt">string</code> <code class="n">method</code><code class="p">,</code> <code class="kt">bool</code> <code class="n">result</code><code class="p">)[]&gt;</code> <code class="n">allTasks</code> <code class="p">=</code>
        <code class="n">Task</code><code class="p">.</code><code class="n">WhenAll</code><code class="p">(</code><code class="n">checkoutTasks</code><code class="p">);</code>

    <code class="k">if</code> <code class="p">(</code><code class="n">allTasks</code><code class="p">.</code><code class="n">IsCompletedSuccessfully</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">AllTasksResult</code> <code class="n">allResult</code> <code class="p">=</code> <code class="n">GetResults</code><code class="p">(</code><code class="n">allTasks</code><code class="p">);</code>

        <code class="k">await</code> <code class="nf">FinalizeCheckoutAsync</code><code class="p">(</code><code class="n">allResult</code><code class="p">);</code>

        <code class="k">return</code> <code class="s">"Checkout Complete"</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">else</code>
    <code class="p">{</code>
        <code class="k">throw</code> <code class="n">allTasks</code><code class="p">.</code><code class="n">Exception</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>The next implementation processes tasks in parallel but handles each one as it returns:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">StartBigONSquaredAsync</code><code class="p">()</code>
<code class="p">{</code>
    <code class="kt">var</code> <code class="n">checkoutTasks</code> <code class="p">=</code>
        <code class="k">new</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Task</code><code class="p">&lt;(</code><code class="kt">string</code><code class="p">,</code> <code class="kt">bool</code><code class="p">)&gt;&gt;</code>
        <code class="p">{</code>
            <code class="n">ValidateAddressAsync</code><code class="p">(),</code>
            <code class="n">ValidateCreditAsync</code><code class="p">(),</code>
            <code class="n">GetShoppingCartAsync</code><code class="p">()</code>
        <code class="p">};</code>

    <code class="kt">var</code> <code class="n">allResult</code> <code class="p">=</code> <code class="k">new</code> <code class="n">AllTasksResult</code><code class="p">();</code>

    <code class="k">while</code> <code class="p">(</code><code class="n">checkoutTasks</code><code class="p">.</code><code class="n">Any</code><code class="p">())</code>
    <code class="p">{</code>
        <code class="n">Task</code><code class="p">&lt;(</code><code class="kt">string</code><code class="p">,</code> <code class="kt">bool</code><code class="p">)&gt;</code> <code class="n">task</code> <code class="p">=</code> <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">WhenAny</code><code class="p">(</code><code class="n">checkoutTasks</code><code class="p">);</code>
        <code class="n">checkoutTasks</code><code class="p">.</code><code class="n">Remove</code><code class="p">(</code><code class="n">task</code><code class="p">);</code>

        <code class="n">GetResult</code><code class="p">(</code><code class="n">task</code><code class="p">,</code> <code class="n">allResult</code><code class="p">);</code>
    <code class="p">}</code>

    <code class="k">await</code> <code class="nf">FinalizeCheckoutAsync</code><code class="p">(</code><code class="n">allResult</code><code class="p">);</code>

    <code class="k">return</code> <code class="s">"Checkout Complete"</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>This method shows how to get the first task that completes:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">async</code> <code class="n">Task</code><code class="p">&lt;(</code><code class="kt">string</code> <code class="n">method</code><code class="p">,</code> <code class="kt">bool</code> <code class="n">result</code><code class="p">)&gt;</code> <code class="n">ValidateCreditAsync</code><code class="p">()</code>
<code class="p">{</code>
    <code class="kt">var</code> <code class="n">checkoutTasks</code> <code class="p">=</code>
        <code class="k">new</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Task</code><code class="p">&lt;(</code><code class="kt">string</code><code class="p">,</code> <code class="kt">bool</code><code class="p">)&gt;&gt;</code>
        <code class="p">{</code>
            <code class="n">CheckInternalCreditAsync</code><code class="p">(),</code>
            <code class="n">CheckAgency1CreditAsync</code><code class="p">(),</code>
            <code class="n">CheckAgency2CreditAsync</code><code class="p">()</code>
        <code class="p">};</code>

    <code class="n">Task</code><code class="p">&lt;(</code><code class="kt">string</code><code class="p">,</code> <code class="kt">bool</code><code class="p">)&gt;</code> <code class="n">task</code> <code class="p">=</code> <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">WhenAny</code><code class="p">(</code><code class="n">checkoutTasks</code><code class="p">);</code>

    <code class="p">(</code><code class="n">_</code><code class="p">,</code> <code class="kt">bool</code> <code class="n">result</code><code class="p">)</code> <code class="p">=</code> <code class="n">task</code><code class="p">.</code><code class="n">Result</code><code class="p">;</code>

    <code class="k">return</code> <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">FromResult</code><code class="p">(</code>
        <code class="p">(</code><code class="n">nameof</code><code class="p">(</code><code class="n">ValidateCreditAsync</code><code class="p">),</code> <code class="n">result</code><code class="p">));</code>
<code class="p">}</code></pre>

<p>The <code>Main</code> method offers a choice of which method to start with:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="k">async</code> <code class="n">Task</code> <code class="nf">Main</code><code class="p">()</code>
<code class="p">{</code>
    <code class="k">try</code>
    <code class="p">{</code>
        <code class="kt">var</code> <code class="n">checkoutSvc</code> <code class="p">=</code> <code class="k">new</code> <code class="n">CheckoutService</code><code class="p">();</code>

        <code class="kt">string</code> <code class="n">result</code> <code class="p">=</code> <code class="k">await</code> <code class="n">checkoutSvc</code><code class="p">.</code><code class="n">StartBigO1Async</code><code class="p">();</code>
        <code class="c1">//string result = await checkoutSvc.StartBigONAsync();</code>
        <code class="c1">//string result = await checkoutSvc.StartBigONSquaredAsync();</code>

        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"Result: {result}"</code><code class="p">);</code>
    <code class="p">}</code>
    <code class="k">catch</code> <code class="p">(</code><code class="n">AggregateException</code> <code class="n">aEx</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="k">foreach</code> <code class="p">(</code><code class="kt">var</code> <code class="n">ex</code> <code class="k">in</code> <code class="n">aEx</code><code class="p">.</code><code class="n">InnerExceptions</code><code class="p">)</code>
            <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"Unable to complete: {ex}"</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45678773840720">
<h2>Discussion</h2>

<p>The problem in this section explores the role of <code>Task.WhenAny</code>. If you try to use <code>Task.WhenAny</code> for processing tasks as they return, you might be surprised because it doesn’t work the way you expect.</p>

<p>For the most part, the concept and organization of this solution operates similar to <a data-type="xref" href="#waiting_for_parallel_tasks_to_complete">Recipe 6.7</a>—the difference being that this solution shows different ways to run tasks and explains what you need to know to make the proper design decisions.</p>

<p>The <code>StartBigONAsync</code> method operates like previous sections of this chapter that ran sequentially. Its performance is O(N) because it processes N tasks, one after the other.</p>

<p><a data-type="xref" href="#waiting_for_parallel_tasks_to_complete">Recipe 6.7</a> showed how to speed up program execution when tasks don’t depend on each other. It uses <code>Task.WhenAll</code>, shown in <code>StartBigO1Async</code>. The performance boost comes from its approximately O(1) performance—instead of performing N operations, it does 1. To be more accurate, this is O(2) because <code>FinalizeCheckout​A⁠sync</code> runs after the other three complete.</p>

<p>In addition to <code>Task.WhenAll</code>, you can use <code>Task.WhenAny</code>. It might be natural to think that <code>Task.WhenAny</code> is a good way to run multiple tasks in parallel and then be able to process each task while the others are running. However, <code>Task.WhenAny</code> doesn’t work the way you think it does. Look at <code>StartBigONSquaredAsync</code> and follow the following logic:</p>
<ol>
<li>
<p>The <code>while</code> loop iterates as long as <code>checkoutTasks</code> still has contents.</p>
</li>
<li>
<p><code>Task.WhenAny</code> starts all of the tasks in parallel.</p>
</li>
<li>
<p>The fastest task returns.</p>
</li>
<li>
<p>Since that task returned, remove it from <code>checkoutTasks</code> so we don’t run it again.</p>
</li>
<li>
<p>Collect the results from that task.</p>
</li>
<li>
<p>Do the loop again on the remaining tasks or stop when <code>checkoutTasks</code> is empty.</p>
</li>

</ol>

<p>The first surprising mental hurdle in this algorithm is incorrectly thinking that subsequent loops operate on the same tasks, each returning as they complete. The reality is that each subsequent loop starts a brand-new set of tasks. This is how async works—you can <code>await</code> a task multiple times, but each <code>await</code> starts a new task. That means the code continuously starts new instances of remaining tasks on every loop. This looping pattern, with <code>Task.WhenAny</code>, doesn’t result in the O(1) performance you might have expected, like with <code>Task.WhenAll</code>, but rather O(N<sup>2</sup>). This solution only has three tasks, but imagine how performance would increasingly suffer as the task list grows.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>This chapter discusses performance with Big O notation. Especially when looking at algorithms that are O(N<sup>2</sup>), there’s a threshold of when too many operations ruin performance. <a data-type="xref" href="ch03.xhtml#measuring_performance">Recipe 3.10</a> shows how to measure application performance and find what that threshold is, based on your performance requirements.</p>
</div>

<p>To pile on, take that number of tasks and multiply it by the number of checkout operations that occur over a period of time. Not only would your application performance be bad, you might slow down servers with excessive network traffic and endpoint server processing. This might affect not only your own system, but other systems running concurrently too. Also, think about times when those network requests might be to cloud services on a consumption plan and how expensive that would get. This particular use case might be considered an antipattern, unless it’s used with a small number of tasks where the impact is minimal.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>On the internet, you’ll find articles explaining <code>Task.WhenAny</code> as a technique for running tasks in parallel and  processing each as they complete. While that might work for a few tasks, this section explains the hazards of using <code>Task.WhenAny</code> for that use case.</p>
</div>

<p>That said, there is a use case where <code>Task.WhenAny</code> is effective—first task wins. In the solution, there’s a <code>ValidateCreditAsync</code> method showing this strategy. The scenario is that you have multiple sources to learn if a customer has good credit and a response from any one of those sources is reliable. Each service has different performance characteristics and you’re only interested in the one that returns first. You can discard the rest. This keeps performance at O(1).</p>

<p><code>ValidateCreditAsync</code> has a list of tasks to run. <code>Task.WhenAny</code> runs those tasks in parallel and the first task to complete comes back. The code processes that task and returns.</p>

<p>The side effect in this solution is that tasks other than the first that returned continue running. However, you don’t have access to them because only one task is returned. For this scenario, you don’t care about those tasks but should stop them to avoid using more resources than necessary. You can learn how to do that in the next section on cancelling tasks.<a data-type="indexterm" data-startref="ix_ch06-asciidoc19" id="idm45678773257184"/><a data-type="indexterm" data-startref="ix_ch06-asciidoc18" id="idm45678773256480"/><a data-type="indexterm" data-startref="ix_ch06-asciidoc17" id="idm45678773255808"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm45678773380480">
<h2>See Also</h2>

<p><a data-type="xref" data-xrefstyle="rec-num-title" href="ch03.xhtml#measuring_performance">Recipe 3.10, “Measuring Performance”</a></p>

<p><a data-type="xref" data-xrefstyle="rec-num-title" href="#waiting_for_parallel_tasks_to_complete">Recipe 6.7, “Waiting for Parallel Tasks to Complete”</a></p>

<p><a data-type="xref" data-xrefstyle="rec-num-title" href="#cancelling_async_operations">Recipe 6.9, “Cancelling Async Operations”</a></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="6.9 Cancelling Async Operations"><div class="sect1" id="cancelling_async_operations">
<h1>6.9 Cancelling Async Operations</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45678773248288">
<h2>Problem</h2>

<p><a data-type="indexterm" data-primary="asynchronous programming" data-secondary="canceling async operations" id="ix_ch06-asciidoc20"/><a data-type="indexterm" data-primary="task cancellation" id="ix_ch06-asciidoc21"/>You have an async process in progress and need to stop it.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45678773244432">
<h2>Solution</h2>

<p>This class demonstrates multiple ways to cancel tasks:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">class</code> <code class="nc">CheckoutStream</code>
<code class="p">{</code>
    <code class="n">CancellationToken</code> <code class="n">cancelToken</code><code class="p">;</code>

    <code class="k">public</code> <code class="nf">CheckoutStream</code><code class="p">(</code><code class="n">CancellationToken</code> <code class="n">cancelToken</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="n">cancelToken</code> <code class="p">=</code> <code class="n">cancelToken</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">public</code> <code class="k">async</code> <code class="n">IAsyncEnumerable</code><code class="p">&lt;</code><code class="n">CheckoutRequest</code><code class="p">&gt;</code> <code class="n">GetRequestsAsync</code><code class="p">(</code>
        <code class="n">IProgress</code><code class="p">&lt;</code><code class="n">CheckoutRequestProgress</code><code class="p">&gt;</code> <code class="n">progress</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="kt">int</code> <code class="n">total</code> <code class="p">=</code> <code class="m">0</code><code class="p">;</code>

        <code class="k">while</code> <code class="p">(</code><code class="k">true</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="kt">var</code> <code class="n">requests</code> <code class="p">=</code> <code class="k">new</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">CheckoutRequest</code><code class="p">&gt;();</code>

            <code class="k">try</code>
            <code class="p">{</code>
                <code class="n">requests</code> <code class="p">=</code> <code class="k">await</code> <code class="n">GetNextBatchAsync</code><code class="p">();</code>
            <code class="p">}</code>
            <code class="k">catch</code> <code class="p">(</code><code class="n">OperationCanceledException</code><code class="p">)</code>
            <code class="p">{</code>
                <code class="k">break</code><code class="p">;</code>
            <code class="p">}</code>

            <code class="n">total</code> <code class="p">+=</code> <code class="n">requests</code><code class="p">.</code><code class="n">Count</code><code class="p">;</code>

            <code class="k">foreach</code> <code class="p">(</code><code class="kt">var</code> <code class="n">request</code> <code class="k">in</code> <code class="n">requests</code><code class="p">)</code>
            <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="n">cancelToken</code><code class="p">.</code><code class="n">IsCancellationRequested</code><code class="p">)</code>
                    <code class="k">break</code><code class="p">;</code>

                <code class="k">yield</code> <code class="k">return</code> <code class="n">request</code><code class="p">;</code>
            <code class="p">}</code>

            <code class="n">progress</code><code class="p">.</code><code class="n">Report</code><code class="p">(</code>
                <code class="k">new</code> <code class="n">CheckoutRequestProgress</code>
                <code class="p">{</code>
                    <code class="n">Total</code> <code class="p">=</code> <code class="n">total</code><code class="p">,</code>
                    <code class="n">Message</code> <code class="p">=</code> <code class="s">"New Batch of Checkout Requests"</code>
                <code class="p">});</code>


            <code class="k">if</code> <code class="p">(</code><code class="n">cancelToken</code><code class="p">.</code><code class="n">IsCancellationRequested</code><code class="p">)</code>
                <code class="k">break</code><code class="p">;</code>

            <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="m">1000</code><code class="p">);</code>
        <code class="p">}</code>

        <code class="k">if</code> <code class="p">(</code><code class="n">cancelToken</code><code class="p">.</code><code class="n">IsCancellationRequested</code><code class="p">)</code>
            <code class="n">progress</code><code class="p">.</code><code class="n">Report</code><code class="p">(</code>
                <code class="k">new</code> <code class="n">CheckoutRequestProgress</code>
                <code class="p">{</code>
                    <code class="n">Total</code> <code class="p">=</code> <code class="n">total</code><code class="p">,</code>
                    <code class="n">Message</code> <code class="p">=</code> <code class="s">"Process Cancelled!"</code>
                <code class="p">});</code>
    <code class="p">}</code>

    <code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="n">List</code><code class="p">&lt;</code><code class="n">CheckoutRequest</code><code class="p">&gt;&gt;</code> <code class="n">GetNextBatchAsync</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="n">cancelToken</code><code class="p">.</code><code class="n">IsCancellationRequested</code><code class="p">)</code>
            <code class="k">throw</code> <code class="k">new</code> <code class="nf">OperationCanceledException</code><code class="p">();</code>

        <code class="kt">var</code> <code class="n">requests</code> <code class="p">=</code> <code class="k">new</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">CheckoutRequest</code><code class="p">&gt;</code>
        <code class="p">{</code>
            <code class="k">new</code> <code class="n">CheckoutRequest</code>
            <code class="p">{</code>
                <code class="n">ShoppingCartID</code> <code class="p">=</code> <code class="n">Guid</code><code class="p">.</code><code class="n">NewGuid</code><code class="p">(),</code>
                <code class="n">Address</code> <code class="p">=</code> <code class="s">"123 4th St"</code><code class="p">,</code>
                <code class="n">Card</code> <code class="p">=</code> <code class="s">"1234 5678 9012 3456"</code><code class="p">,</code>
                <code class="n">Name</code> <code class="p">=</code> <code class="s">"First Card Name"</code>
            <code class="p">},</code>
            <code class="k">new</code> <code class="n">CheckoutRequest</code>
            <code class="p">{</code>
                <code class="n">ShoppingCartID</code> <code class="p">=</code> <code class="n">Guid</code><code class="p">.</code><code class="n">NewGuid</code><code class="p">(),</code>
                <code class="n">Address</code> <code class="p">=</code> <code class="s">"789 1st Ave"</code><code class="p">,</code>
                <code class="n">Card</code> <code class="p">=</code> <code class="s">"2345 6789 0123 4567"</code><code class="p">,</code>
                <code class="n">Name</code> <code class="p">=</code> <code class="s">"Second Card Name"</code>
            <code class="p">},</code>
            <code class="k">new</code> <code class="n">CheckoutRequest</code>
            <code class="p">{</code>
                <code class="n">ShoppingCartID</code> <code class="p">=</code> <code class="n">Guid</code><code class="p">.</code><code class="n">NewGuid</code><code class="p">(),</code>
                <code class="n">Address</code> <code class="p">=</code> <code class="s">"123 4th St"</code><code class="p">,</code>
                <code class="n">Card</code> <code class="p">=</code> <code class="s">"1234 5678 9012 3456"</code><code class="p">,</code>
                <code class="n">Name</code> <code class="p">=</code> <code class="s">"First Card Name"</code>
            <code class="p">},</code>
        <code class="p">};</code>

        <code class="k">return</code> <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">FromResult</code><code class="p">(</code><code class="n">requests</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>Here’s the app that initializes cancellation and shows how to cancel:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="k">async</code> <code class="n">Task</code> <code class="nf">Main</code><code class="p">()</code>
<code class="p">{</code>
    <code class="kt">var</code> <code class="n">cancelSource</code> <code class="p">=</code> <code class="k">new</code> <code class="n">CancellationTokenSource</code><code class="p">();</code>
    <code class="kt">var</code> <code class="n">checkoutStrm</code> <code class="p">=</code> <code class="k">new</code> <code class="n">CheckoutStream</code><code class="p">(</code><code class="n">cancelSource</code><code class="p">.</code><code class="n">Token</code><code class="p">);</code>
    <code class="kt">var</code> <code class="n">checkoutSvc</code> <code class="p">=</code> <code class="k">new</code> <code class="n">CheckoutService</code><code class="p">();</code>

    <code class="n">IProgress</code><code class="p">&lt;</code><code class="n">CheckoutRequestProgress</code><code class="p">&gt;</code> <code class="n">progress</code> <code class="p">=</code>
        <code class="k">new</code> <code class="n">Progress</code><code class="p">&lt;</code><code class="n">CheckoutRequestProgress</code><code class="p">&gt;(</code><code class="n">p</code> <code class="p">=&gt;</code>
        <code class="p">{</code>
            <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code>
                <code class="err">$</code><code class="s">"\n"</code> <code class="p">+</code>
                <code class="err">$</code><code class="s">"Total: {p.Total}, "</code> <code class="p">+</code>
                <code class="err">$</code><code class="s">"{p.Message}"</code> <code class="p">+</code>
                <code class="err">$</code><code class="s">"\n"</code><code class="p">);</code>
        <code class="p">});</code>

    <code class="kt">int</code> <code class="n">count</code> <code class="p">=</code> <code class="m">1</code><code class="p">;</code>

    <code class="k">await</code> <code class="nf">foreach</code> <code class="p">(</code><code class="kt">var</code> <code class="n">request</code> <code class="k">in</code>
        <code class="n">checkoutStrm</code><code class="p">.</code><code class="n">GetRequestsAsync</code><code class="p">(</code><code class="n">progress</code><code class="p">))</code>
    <code class="p">{</code>
        <code class="kt">string</code> <code class="n">result</code> <code class="p">=</code> <code class="k">await</code> <code class="n">checkoutSvc</code><code class="p">.</code><code class="n">StartAsync</code><code class="p">(</code><code class="n">request</code><code class="p">);</code>

        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"Result: {result}"</code><code class="p">);</code>

        <code class="k">if</code> <code class="p">(</code><code class="n">count</code><code class="p">++</code> <code class="p">&gt;=</code> <code class="m">10</code><code class="p">)</code>
            <code class="k">break</code><code class="p">;</code>

        <code class="k">if</code> <code class="p">(</code><code class="n">count</code> <code class="p">&gt;=</code> <code class="m">5</code><code class="p">)</code>
            <code class="n">cancelSource</code><code class="p">.</code><code class="n">Cancel</code><code class="p">();</code>
    <code class="p">}</code>
<code class="p">}</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45678773227744">
<h2>Discussion</h2>

<p><a data-type="xref" href="#creating_async_iterators">Recipe 6.3</a> has an async iterator with a <code>while</code> loop that never ends. That worked for a demo, but real applications often need a way to stop long-running processes. Think about a dialog that pops up with ongoing process status and offers a Cancel button, allowing you to stop the operation. Task cancellation has been around since the introduction of TPL and is instrumental in cancelling async operations too.</p>

<p>In the solution, the <code>Main</code> method shows how to initialize cancellation. The <code>Cancel​la⁠tionTokenSource</code>, <code>cancelSource</code>, provides both tokens and control over cancellation. See how the parameter to the <code>CheckoutStream</code> constructor is a <code>Cancellation​To⁠ken</code>, set via the <code>Token</code> property from <code>cancelSource</code>.</p>

<p>Because <code>cancelSource</code> can manage cancellation for all the code in its scope, you can pass a <code>CancellationToken</code> as a parameter to any constructors or methods with a <span class="keep-together"><code>Cancel​la⁠tionToken</code></span> parameter, allowing you to cancel any operations from a single place, <code>cancelSource</code>. The solution doesn’t have a button and cancels after processing 10 <code>CheckoutRequests</code>. You can see how that works with the <code>count</code> variable that’s incremented in each loop, checks the number of requests, and breaks out of the loop after <code>10</code>. This program never gets to <code>10</code> because of the check on <code>count &gt;= 5</code>, calling <code>cancelSource.Cancel()</code>.</p>

<p>The call to <code>cancelSource.Cancel</code> sends the message that the process should be cancelled, but you still have to write code that recognizes the need to cancel. It’s proper to cancel as soon as possible, and <code>GetRequestsAsync</code> has several checks on <code>cancelToken.IsCancellationRequested</code>. The <code>IsCancellationRequested</code> property is <code>true</code> when <code>Cancel</code> is called on the <code>CancellationTokenSource</code> instance that passed the <span class="keep-together"><code>CancelToken</code></span>.</p>

<p>Inside the loop, <code>IsCancellationRequested</code> breaks. Outside the loop, <code>IsCancellationRequested</code> sends an <code>IProgress&lt;T&gt;</code> status message to let the caller know that the operation was properly cancelled.</p>

<p>The <code>GetNextBatchAsync</code> method shows another way to handle cancellation, by throwing an <code>OperationCancelledException</code>. If you recall, the reason a method throws is because it is unable to complete the operation it was designed to do. In this case, <code>GetNextBatchAsync</code> did not retrieve records, so this could be a semantically correct way to respond. Even if this wasn’t a design decision that you would make, consider that <code>GetNextBatchAsync</code> might <code>await</code> another method, passing its <code>cancelToken</code>. When cancelled, that awaited async method could throw <code>OperationCancelled​Excep⁠tion</code>. Therefore, when handling cancellation, it’s safe to anticipate and handle <code>OperationCancelledException</code>. The solution does this by wrapping the call to <code>GetNextBatchAsync</code> in a <code>try/catch</code>, breaking the loop, and letting existing code report the cancelled status to the caller.</p>

<p>Whenever cancelling an operation, you might also need to clean up resources. The next section, <a data-type="xref" href="#disposing_async_resources">Recipe 6.10</a>, discusses how to do that.<a data-type="indexterm" data-startref="ix_ch06-asciidoc21" id="idm45678772684096"/><a data-type="indexterm" data-startref="ix_ch06-asciidoc20" id="idm45678772683424"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm45678772682624">
<h2>See Also</h2>

<p><a data-type="xref" data-xrefstyle="rec-num-title" href="#creating_async_iterators">Recipe 6.3, “Creating Async Iterators”</a></p>

<p><a data-type="xref" data-xrefstyle="rec-num-title" href="#disposing_async_resources">Recipe 6.10, “Disposing of Async Resources”</a></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="6.10 Disposing of Async Resources"><div class="sect1" id="disposing_async_resources">
<h1>6.10 Disposing of Async Resources</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45678772677120">
<h2>Problem</h2>

<p><a data-type="indexterm" data-primary="asynchronous programming" data-secondary="disposing async resources" id="ix_ch06-asciidoc22"/><a data-type="indexterm" data-primary="dispose pattern" data-secondary="disposing async resources" id="ix_ch06-asciidoc23"/>You have an async process with resources that must be disposed.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45678772672976">
<h2>Solution</h2>

<p>This class shows how to properly implement the async dispose pattern:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">class</code> <code class="nc">CheckoutStream</code> <code class="p">:</code> <code class="n">IAsyncDisposable</code><code class="p">,</code> <code class="n">IDisposable</code>
<code class="p">{</code>
    <code class="n">CancellationTokenSource</code> <code class="n">cancelSource</code> <code class="p">=</code> <code class="k">new</code> <code class="n">CancellationTokenSource</code><code class="p">();</code>
    <code class="n">CancellationToken</code> <code class="n">cancelToken</code><code class="p">;</code>
    <code class="n">ILogger</code> <code class="n">log</code> <code class="p">=</code> <code class="k">new</code> <code class="n">ConsoleLogger</code><code class="p">();</code>

    <code class="n">FileStream</code> <code class="n">asyncDisposeObj</code> <code class="p">=</code> <code class="k">new</code> <code class="n">FileStream</code><code class="p">(</code>
        <code class="s">"MyFile.txt"</code><code class="p">,</code> <code class="n">FileMode</code><code class="p">.</code><code class="n">OpenOrCreate</code><code class="p">,</code> <code class="n">FileAccess</code><code class="p">.</code><code class="n">Write</code><code class="p">);</code>
    <code class="n">HttpClient</code> <code class="n">syncDisposeObj</code> <code class="p">=</code> <code class="k">new</code> <code class="n">HttpClient</code><code class="p">();</code>

    <code class="k">public</code> <code class="nf">CheckoutStream</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="n">cancelToken</code> <code class="p">=</code> <code class="n">cancelSource</code><code class="p">.</code><code class="n">Token</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">public</code> <code class="k">async</code> <code class="n">IAsyncEnumerable</code><code class="p">&lt;</code><code class="n">CheckoutRequest</code><code class="p">&gt;</code> <code class="n">GetRequestsAsync</code><code class="p">(</code>
        <code class="n">IProgress</code><code class="p">&lt;</code><code class="n">CheckoutRequestProgress</code><code class="p">&gt;</code> <code class="n">progress</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="kt">int</code> <code class="n">total</code> <code class="p">=</code> <code class="m">0</code><code class="p">;</code>

        <code class="k">while</code> <code class="p">(</code><code class="k">true</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="kt">var</code> <code class="n">requests</code> <code class="p">=</code> <code class="k">new</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">CheckoutRequest</code><code class="p">&gt;();</code>

            <code class="k">try</code>
            <code class="p">{</code>
                <code class="n">requests</code> <code class="p">=</code> <code class="k">await</code> <code class="n">GetNextBatchAsync</code><code class="p">();</code>
            <code class="p">}</code>
            <code class="k">catch</code> <code class="p">(</code><code class="n">OperationCanceledException</code><code class="p">)</code>
            <code class="p">{</code>
                <code class="k">break</code><code class="p">;</code>
            <code class="p">}</code>

            <code class="n">total</code> <code class="p">+=</code> <code class="n">requests</code><code class="p">.</code><code class="n">Count</code><code class="p">;</code>

            <code class="k">foreach</code> <code class="p">(</code><code class="kt">var</code> <code class="n">request</code> <code class="k">in</code> <code class="n">requests</code><code class="p">)</code>
            <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="n">cancelToken</code><code class="p">.</code><code class="n">IsCancellationRequested</code><code class="p">)</code>
                    <code class="k">break</code><code class="p">;</code>

                <code class="k">yield</code> <code class="k">return</code> <code class="n">request</code><code class="p">;</code>
            <code class="p">}</code>

            <code class="n">progress</code><code class="p">.</code><code class="n">Report</code><code class="p">(</code>
                <code class="k">new</code> <code class="n">CheckoutRequestProgress</code>
                <code class="p">{</code>
                    <code class="n">Total</code> <code class="p">=</code> <code class="n">total</code><code class="p">,</code>
                    <code class="n">Message</code> <code class="p">=</code> <code class="s">"New Batch of Checkout Requests"</code>
                <code class="p">});</code>


            <code class="k">if</code> <code class="p">(</code><code class="n">cancelToken</code><code class="p">.</code><code class="n">IsCancellationRequested</code><code class="p">)</code>
                <code class="k">break</code><code class="p">;</code>

            <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="m">1000</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">}</code>

    <code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="n">List</code><code class="p">&lt;</code><code class="n">CheckoutRequest</code><code class="p">&gt;&gt;</code> <code class="n">GetNextBatchAsync</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="n">cancelToken</code><code class="p">.</code><code class="n">IsCancellationRequested</code><code class="p">)</code>
            <code class="k">throw</code> <code class="k">new</code> <code class="nf">OperationCanceledException</code><code class="p">();</code>

        <code class="kt">var</code> <code class="n">requests</code> <code class="p">=</code> <code class="k">new</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">CheckoutRequest</code><code class="p">&gt;</code>
        <code class="p">{</code>
            <code class="k">new</code> <code class="n">CheckoutRequest</code>
            <code class="p">{</code>
                <code class="n">ShoppingCartID</code> <code class="p">=</code> <code class="n">Guid</code><code class="p">.</code><code class="n">NewGuid</code><code class="p">(),</code>
                <code class="n">Address</code> <code class="p">=</code> <code class="s">"123 4th St"</code><code class="p">,</code>
                <code class="n">Card</code> <code class="p">=</code> <code class="s">"1234 5678 9012 3456"</code><code class="p">,</code>
                <code class="n">Name</code> <code class="p">=</code> <code class="s">"First Card Name"</code>
            <code class="p">},</code>
            <code class="k">new</code> <code class="n">CheckoutRequest</code>
            <code class="p">{</code>
                <code class="n">ShoppingCartID</code> <code class="p">=</code> <code class="n">Guid</code><code class="p">.</code><code class="n">NewGuid</code><code class="p">(),</code>
                <code class="n">Address</code> <code class="p">=</code> <code class="s">"789 1st Ave"</code><code class="p">,</code>
                <code class="n">Card</code> <code class="p">=</code> <code class="s">"2345 6789 0123 4567"</code><code class="p">,</code>
                <code class="n">Name</code> <code class="p">=</code> <code class="s">"Second Card Name"</code>
            <code class="p">},</code>
            <code class="k">new</code> <code class="n">CheckoutRequest</code>
            <code class="p">{</code>
                <code class="n">ShoppingCartID</code> <code class="p">=</code> <code class="n">Guid</code><code class="p">.</code><code class="n">NewGuid</code><code class="p">(),</code>
                <code class="n">Address</code> <code class="p">=</code> <code class="s">"123 4th St"</code><code class="p">,</code>
                <code class="n">Card</code> <code class="p">=</code> <code class="s">"1234 5678 9012 3456"</code><code class="p">,</code>
                <code class="n">Name</code> <code class="p">=</code> <code class="s">"First Card Name"</code>
            <code class="p">},</code>
        <code class="p">};</code>

        <code class="k">return</code> <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">FromResult</code><code class="p">(</code><code class="n">requests</code><code class="p">);</code>
    <code class="p">}</code>

    <code class="k">public</code> <code class="k">async</code> <code class="n">ValueTask</code> <code class="nf">DisposeAsync</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="k">await</code> <code class="nf">DisposeAsyncCore</code><code class="p">();</code>

        <code class="n">Dispose</code><code class="p">(</code><code class="n">disposing</code><code class="p">:</code> <code class="k">false</code><code class="p">);</code>
        <code class="n">GC</code><code class="p">.</code><code class="n">SuppressFinalize</code><code class="p">(</code><code class="k">this</code><code class="p">);</code>
    <code class="p">}</code>

    <code class="k">public</code> <code class="k">void</code> <code class="nf">Dispose</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="n">Dispose</code><code class="p">(</code><code class="n">disposing</code><code class="p">:</code> <code class="k">true</code><code class="p">);</code>
        <code class="n">GC</code><code class="p">.</code><code class="n">SuppressFinalize</code><code class="p">(</code><code class="k">this</code><code class="p">);</code>
    <code class="p">}</code>

    <code class="k">protected</code> <code class="k">virtual</code> <code class="k">void</code> <code class="nf">Dispose</code><code class="p">(</code><code class="kt">bool</code> <code class="n">disposing</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="n">disposing</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="n">syncDisposeObj</code><code class="p">?.</code><code class="n">Dispose</code><code class="p">();</code>
            <code class="p">(</code><code class="n">asyncDisposeObj</code> <code class="k">as</code> <code class="n">IDisposable</code><code class="p">)?.</code><code class="n">Dispose</code><code class="p">();</code>
        <code class="p">}</code>

        <code class="n">DisposeThisObject</code><code class="p">();</code>
    <code class="p">}</code>

    <code class="k">protected</code> <code class="k">virtual</code> <code class="k">async</code> <code class="n">ValueTask</code> <code class="nf">DisposeAsyncCore</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="n">asyncDisposeObj</code> <code class="k">is</code> <code class="n">not</code> <code class="k">null</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="k">await</code> <code class="n">asyncDisposeObj</code><code class="p">.</code><code class="n">DisposeAsync</code><code class="p">().</code><code class="n">ConfigureAwait</code><code class="p">(</code><code class="k">false</code><code class="p">);</code>
        <code class="p">}</code>

        <code class="k">if</code> <code class="p">(</code><code class="n">syncDisposeObj</code> <code class="k">is</code> <code class="n">IAsyncDisposable</code> <code class="n">disposable</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="k">await</code> <code class="n">disposable</code><code class="p">.</code><code class="n">DisposeAsync</code><code class="p">().</code><code class="n">ConfigureAwait</code><code class="p">(</code><code class="k">false</code><code class="p">);</code>
        <code class="p">}</code>
        <code class="k">else</code>
        <code class="p">{</code>
            <code class="n">syncDisposeObj</code><code class="p">.</code><code class="n">Dispose</code><code class="p">();</code>
        <code class="p">}</code>

        <code class="n">DisposeThisObject</code><code class="p">();</code>

        <code class="k">await</code> <code class="n">log</code><code class="p">.</code><code class="n">WriteAsync</code><code class="p">(</code><code class="s">"\n\nDisposed!"</code><code class="p">);</code>
    <code class="p">}</code>

    <code class="k">void</code> <code class="nf">DisposeThisObject</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="n">cancelSource</code><code class="p">.</code><code class="n">Cancel</code><code class="p">();</code>

        <code class="n">asyncDisposeObj</code> <code class="p">=</code> <code class="k">null</code><code class="p">;</code>
        <code class="n">syncDisposeObj</code> <code class="p">=</code> <code class="k">null</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>Here’s the app that demonstrates how to use an async disposable object:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">static</code> <code class="k">async</code> <code class="n">Task</code> <code class="nf">Main</code><code class="p">()</code>
<code class="p">{</code>
    <code class="k">await</code> <code class="k">using</code> <code class="nn">var</code> <code class="n">checkoutStrm</code> <code class="p">=</code> <code class="k">new</code> <code class="n">CheckoutStream</code><code class="p">();</code>

    <code class="kt">var</code> <code class="n">checkoutSvc</code> <code class="p">=</code> <code class="k">new</code> <code class="n">CheckoutService</code><code class="p">();</code>

    <code class="n">IProgress</code><code class="p">&lt;</code><code class="n">CheckoutRequestProgress</code><code class="p">&gt;</code> <code class="n">progress</code> <code class="p">=</code>
        <code class="k">new</code> <code class="n">Progress</code><code class="p">&lt;</code><code class="n">CheckoutRequestProgress</code><code class="p">&gt;(</code><code class="n">p</code> <code class="p">=&gt;</code>
        <code class="p">{</code>
            <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code>
                <code class="err">$</code><code class="s">"\n"</code> <code class="p">+</code>
                <code class="err">$</code><code class="s">"Total: {p.Total}, "</code> <code class="p">+</code>
                <code class="err">$</code><code class="s">"{p.Message}"</code> <code class="p">+</code>
                <code class="err">$</code><code class="s">"\n"</code><code class="p">);</code>
        <code class="p">});</code>

    <code class="kt">int</code> <code class="n">count</code> <code class="p">=</code> <code class="m">1</code><code class="p">;</code>

    <code class="k">await</code> <code class="nf">foreach</code> <code class="p">(</code><code class="kt">var</code> <code class="n">request</code> <code class="k">in</code>
        <code class="n">checkoutStrm</code><code class="p">.</code><code class="n">GetRequestsAsync</code><code class="p">(</code><code class="n">progress</code><code class="p">))</code>
    <code class="p">{</code>
        <code class="kt">string</code> <code class="n">result</code> <code class="p">=</code> <code class="k">await</code> <code class="n">checkoutSvc</code><code class="p">.</code><code class="n">StartAsync</code><code class="p">(</code><code class="n">request</code><code class="p">);</code>

        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"Result: {result}"</code><code class="p">);</code>

        <code class="k">if</code> <code class="p">(</code><code class="n">count</code><code class="p">++</code> <code class="p">&gt;=</code> <code class="m">10</code><code class="p">)</code>
            <code class="k">break</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45678772647232">
<h2>Discussion</h2>

<p><a data-type="xref" href="ch01.xhtml#managing_object_lifetime">Recipe 1.1</a> describes the dispose pattern and how it solves the problem of releasing resources when an object lifetime ends. That works well for synchronous code but not for asynchronous code. This section shows how to dispose of async resources with the async dispose pattern.</p>

<p>In the solution, <code>CheckoutStream</code> has two fields: a <code>FileStream</code>, <code>asyncDisposeObj</code>, and an <code>HttpClient</code>, <code>syncDisposeObj</code>. Normally these would have names representing their purpose in the application, but in this instance, their names represent how they’re used in the solution to help follow a complex set of logic. As their names <span class="keep-together">suggest</span>, <code>asyncDisposeObj</code> references a resource that must be disposed of asynchronously; <code>syncDisposeObj</code> references a resource that must be disposed of synchronously. It’s important to think about both asynchronous and synchronous disposal at the same time, because it explains why their disposal processes are now intertwined.</p>

<p>For asynchronous and synchronous disposal, <code>CheckoutService</code> implements <code>IAsyncDisposable</code> and <code>IDisposable</code>, respectively. As discussed in <a data-type="xref" href="ch01.xhtml#managing_object_lifetime">Recipe 1.1</a>, <code>IDisposable</code> specifies that classes must implement <code>Dispose</code>, with no parameters, and we add a virtual <code>Dispose(bool)</code>, with a <code>bool</code> parameter, and an optional destructor to implement the pattern. The solution doesn’t implement the optional destructor. For <code>IAsyncDisposable</code>, <code>CheckoutService</code> implements the required <code>DisposeAsync</code> method and a virtual <code>DisposeAsyncCore</code> method, neither of which have parameters.</p>

<p>Both disposal paths, asynchronous and synchronous, could run, so they both must be prepared to release resources. On the synchronous path, <code>Dispose(bool)</code> not only calls <code>Dispose</code> on <code>syncDisposeObj</code>, but also attempts to call <code>Dispose</code> on <code>asyncDisposeObj</code>. Notice that <code>Dispose(bool)</code> also calls <code>DisposeThisObject</code>, which holds the same code that the asynchronous path needs to call too—it reduces duplication.</p>

<p>While <code>Dispose</code> and <code>DisposeAsync</code> are interface members, <code>Dispose(bool)</code> and <code>DisposeAsyncCore</code> are conventions. Also notice that they’re both <code>virtual</code>. This is part of the pattern, where derived classes can implement disposal by overriding these methods and calling them, via <code>base.Dispose(bool)</code> and <code>base.DisposeAsyncCore</code>, to ensure release of resources up the entire inheritance hierarchy.</p>

<p>Both <code>Dispose</code> and <code>DisposeAsync</code> call <code>Dispose(bool)</code>, but <code>DisposeAsync</code> sets the <code>disposing</code> argument to <code>false</code>. If you recall, <code>disposing</code> is a flag for <code>Dispose(bool)</code> to release managed resources when set to <code>true</code>. Remember that <code>Dispose(bool)</code> is the synchronous path. Instead, <code>DisposeAsync</code> calls <code>DisposeAsyncCore</code> to release asynchronous resources.</p>

<p>As with <code>Dispose(true)</code>, <code>DisposeAsyncCore</code> attempts to release all managed resources. The async case is obvious. However, synchronous objects have a couple of possibilities. What if the synchronous object, now or in the future, implements <code>IAsyncDisposable</code>? Then, attempting to call <code>DisposeAsync</code> is the better choice when the code is on the asynchronous path. Otherwise, call the synchronous path, with <code>Dispose</code>.</p>

<p>As mentioned, both <code>Dispose(bool)</code> and <code>DisposeAsyncCore</code> call <code>DisposeThisObject</code>. In the solution scenario, the <code>GetRequestsAsync</code> iterator implements cancellation, as explained in <a data-type="xref" href="#cancelling_async_operations">Recipe 6.9</a>. Depending on the situation, it might be good to cancel during the dispose process. For instance, what if the code needs to persist its latest good state or has a closure protocol with a network endpoint? It’s good to think through your situation, and the dispose and async dispose patterns can help.</p>

<p>Finally, notice how the <code>Main</code> method awaits a using statement on the <code>CheckoutStream</code> instance. This is the same <code>using</code> statement discussed in <a data-type="xref" href="ch02.xhtml#simplifying_instance_cleanup">Recipe 2.2</a>, except that now it has an <code>await</code>. This ensures the code calls <code>DisposeAsync</code> at the end of the <code>Main</code> method<a data-type="indexterm" data-startref="ix_ch06-asciidoc23" id="idm45678771908048"/><a data-type="indexterm" data-startref="ix_ch06-asciidoc22" id="idm45678771907312"/>.<a data-type="indexterm" data-startref="ix_ch06-asciidoc0" id="idm45678771906512"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm45678772646640">
<h2>See Also</h2>

<p><a data-type="xref" data-xrefstyle="rec-num-title" href="ch01.xhtml#managing_object_lifetime">Recipe 1.1, “Managing Object End-of-Lifetime”</a></p>

<p><a data-type="xref" data-xrefstyle="rec-num-title" href="ch02.xhtml#simplifying_instance_cleanup">Recipe 2.2, “Simplifying Instance Cleanup”</a></p>

<p><a data-type="xref" data-xrefstyle="rec-num-title" href="#cancelling_async_operations">Recipe 6.9, “Cancelling Async Operations”</a></p>
</div></section>





</div></section>







</div></section></div></body></html>