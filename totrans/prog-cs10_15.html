<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 15. Files and Streams" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_files_and_streams">
<h1><span class="label">Chapter 15. </span>Files and Streams</h1>
<p><a data-primary="streams" data-type="indexterm" id="idm45884792221808"/>Most of the techniques I’ve shown so far in this book revolve around the information that lives in objects and variables. This kind of state is stored in a particular process’s memory, but to be useful, a program must interact with a broader world. This might happen through UI frameworks, but there’s one particular abstraction that can be used for many kinds of interactions with the outside world: a <em>stream</em>.</p>
<p>Streams are so widely used in computing that you will no doubt already be familiar with them, and a .NET stream is much the same as in most other programming systems: it is simply a sequence of bytes. That makes a stream a useful abstraction for many commonly encountered features such as a file on disk or the body of an HTTP response. A console application uses streams to represent its input and output. If you run such a program interactively, the text that the user types at the keyboard becomes the program’s input stream, and anything the program writes to its output stream appears on screen. A program doesn’t necessarily know what kind of input or output it has, though—you can redirect these streams with console programs. For example, the input stream might actually provide the contents of a file on disk, or it could even be the output from some other program.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Not all I/O APIs are stream-based. For example, in addition to the input stream, the <code>Console</code> class provides a <code>ReadKey</code> method that gives information about exactly which key was pressed, which works only if the input comes from the keyboard. So, although you can write programs that do not care whether their input comes interactively or from a file, some programs are pickier.</p>
</div>
<p>The stream APIs present you with raw byte data. However, it is possible to work at a different level. For example, there are text-oriented APIs that can wrap underlying streams, so you can work with characters or strings instead of raw bytes. There are also various <em>serialization</em> mechanisms that enable you to convert .NET objects into a stream representation, which you can turn back into objects later, making it possible to save an object’s state persistently or to send that state over the network. I’ll show these higher-level APIs later, but first, let’s look at the stream abstraction itself.</p>
<section data-pdf-bookmark="The Stream Class" data-type="sect1"><div class="sect1" id="the_stream_class">
<h1>The Stream Class</h1>
<p><a data-primary="Stream class" data-type="indexterm" id="ix_ch15-asciidoc0"/>The <code>Stream</code> class is defined in the <code>System.IO</code> namespace. It is an abstract base class, with concrete derived types such as <code>FileStream</code> or <code>GZipStream</code> representing particular kinds of streams. <a data-type="xref" href="#the_most_important_members_of_stream">Example 15-1</a> shows the <code>Stream</code> class’s three most important members. It has several other members, but these are at the heart of the abstraction. (As you’ll see later, there are also asynchronous versions of <code>Read</code> and <code>Write</code>. .NET Core 3.1 and .NET also provide overloads that take one of the <em>span</em> types described in <a data-type="xref" href="ch18.xhtml#ch_memory_efficiency">Chapter 18</a> in place of an array.  Everything I say in this section about these methods also applies to the asynchronous and span-based forms.)</p>
<div data-type="example" id="the_most_important_members_of_stream">
<h5><span class="label">Example 15-1. </span>The most important members of <code>Stream</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">abstract</code> <code class="kt">int</code> <code class="nf">Read</code><code class="p">(</code><code class="kt">byte</code><code class="p">[]</code> <code class="n">buffer</code><code class="p">,</code> <code class="kt">int</code> <code class="n">offset</code><code class="p">,</code> <code class="kt">int</code> <code class="n">count</code><code class="p">);</code>
<code class="k">public</code> <code class="k">abstract</code> <code class="k">void</code> <code class="nf">Write</code><code class="p">(</code><code class="kt">byte</code><code class="p">[]</code> <code class="n">buffer</code><code class="p">,</code> <code class="kt">int</code> <code class="n">offset</code><code class="p">,</code> <code class="kt">int</code> <code class="n">count</code><code class="p">);</code>
<code class="k">public</code> <code class="k">abstract</code> <code class="kt">long</code> <code class="n">Position</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code></pre></div>
<p>Some streams are read-only. For example, when the input stream for a console application represents the keyboard or the output of some other program, there’s no meaningful way for the program to write to that stream. (And for consistency, even if you use input redirection to run a console application with a file as its input, the input stream will be read-only.) Some streams are write-only, such as the output stream of a console application. <a data-primary="Read method" data-type="indexterm" id="ix_ch15-asciidoc1"/>If you call <code>Read</code> on a write-only stream or <code>Write</code> on a read-only one, these methods throw a <code>NotSupportedException</code>.</p>
<div data-type="tip"><h6>Tip</h6>
<p>The <code>Stream</code> class defines various <code>bool</code> properties that describe a stream’s capabilities, so you don’t have to wait until you get an exception to find out what sort of stream you’ve got. You can check the <code>CanRead</code> or <code>CanWrite</code> properties.</p>
</div>
<p>Both <code>Read</code> and <code>Write</code> take a <code>byte[]</code> array as their first argument, and these methods copy data into or out of that array, respectively. The <code>offset</code> and <code>count</code> arguments that follow indicate the array element at which to start and the number of bytes to read or write; you do not have to use the whole array. Notice that there are no arguments to specify the offset within the stream at which to read or write. This is managed by the <code>Position</code> property—this starts at zero, but each time you read or write, the position advances by the number of bytes processed.</p>
<p>Notice that the <code>Read</code> method returns an <code>int</code>. This tells you how many bytes were read from the stream—the method does not guarantee to provide the amount of data you requested. One obvious reason for this is that you could reach the end of the stream, so even though you may have asked to read 100 bytes into your array, there may have been only 30 bytes of data left between the current <code>Position</code> and the end of the stream. However, that’s not the only reason you might get less than you asked for, and this often catches people out, so for the benefit of people skim-reading this chapter, I’ll put this in a scary warning.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>If you ask for more than one byte at a time, a <code>Stream</code> is always free to return less data than you requested from <code>Read</code> for any reason. You should never presume that a call to <code>Read</code> returned as much data as it could, even if you have good reason to know that the amount you asked for will be available.</p>
</div>
<p>The reason <code>Read</code> is slightly tricky is that some streams are live, representing a source of information that produces data gradually as the program runs. For example, if a console application is running interactively, its input stream can provide data only as fast as the user types; a stream representing data being received over a network connection can provide data only as fast as it arrives. If you call <code>Read</code> and you ask for more data than is currently available, a stream might wait until it has as much as you’ve asked for, but it doesn’t have to—it may return whatever data it has immediately. (The only situation in which it is obliged to wait before returning is if it currently has no data at all but is not yet at the end of the stream. It has to return at least one byte, because a <code>0</code> return value indicates the end of the stream.) If you want to ensure that you read a specific number of bytes, you’ll have to check whether <code>Read</code> returned fewer bytes than you wanted, and if necessary, keep calling it until you have what you need. <a data-type="xref" href="#reading_a_specific_number_of_bytes">Example 15-2</a> shows how to do this.</p>
<div data-type="example" id="reading_a_specific_number_of_bytes">
<h5><span class="label">Example 15-2. </span>Reading a specific number of bytes</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">static</code> <code class="kt">int</code> <code class="nf">ReadAll</code><code class="p">(</code><code class="n">Stream</code> <code class="n">s</code><code class="p">,</code> <code class="kt">byte</code><code class="p">[]</code> <code class="n">buffer</code><code class="p">,</code> <code class="kt">int</code> <code class="n">offset</code><code class="p">,</code> <code class="kt">int</code> <code class="n">length</code><code class="p">)</code>
<code class="p">{</code>
    <code class="k">if</code> <code class="p">((</code><code class="n">offset</code> <code class="p">+</code> <code class="n">length</code><code class="p">)</code> <code class="p">&gt;</code> <code class="n">buffer</code><code class="p">.</code><code class="n">Length</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="k">throw</code> <code class="k">new</code> <code class="nf">ArgumentException</code><code class="p">(</code><code class="s">"Buffer too small to hold requested data"</code><code class="p">);</code>
    <code class="p">}</code>

    <code class="kt">int</code> <code class="n">bytesReadSoFar</code> <code class="p">=</code> <code class="m">0</code><code class="p">;</code>
    <code class="k">while</code> <code class="p">(</code><code class="n">bytesReadSoFar</code> <code class="p">&lt;</code> <code class="n">length</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="kt">int</code> <code class="n">bytes</code> <code class="p">=</code> <code class="n">s</code><code class="p">.</code><code class="n">Read</code><code class="p">(</code>
            <code class="n">buffer</code><code class="p">,</code> <code class="n">offset</code> <code class="p">+</code> <code class="n">bytesReadSoFar</code><code class="p">,</code> <code class="n">length</code> <code class="p">-</code> <code class="n">bytesReadSoFar</code><code class="p">);</code>
        <code class="k">if</code> <code class="p">(</code><code class="n">bytes</code> <code class="p">==</code> <code class="m">0</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="k">break</code><code class="p">;</code>
        <code class="p">}</code>
        <code class="n">bytesReadSoFar</code> <code class="p">+=</code> <code class="n">bytes</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">return</code> <code class="n">bytesReadSoFar</code><code class="p">;</code>
<code class="p">}</code></pre></div>
<p>Notice that this code checks for a <code>0</code> return value from <code>Read</code> to detect the end of the stream. Without that, it would loop forever if it reached the end of the stream before reading as much data as has been asked for. That means that if we do reach the end of the stream, this method will have to provide less data than the caller requested, so this may seem like it hasn’t really solved the problem. However, it does rule out the situation where you get less than you asked for despite not reaching the end 
<span class="keep-together">of the stream.</span> (You could change the method so that it throws an exception if it reaches 
<span class="keep-together">the end of</span> the stream before providing the specified number of bytes. That way, 
<span class="keep-together">if the method returns</span> at all, it is guaranteed to return exactly as many bytes as have been requested.)<a data-startref="ix_ch15-asciidoc1" data-type="indexterm" id="idm45884791671312"/></p>
<p><code>Stream</code> offers a simpler way to read. <a data-primary="ReadByte method" data-type="indexterm" id="idm45884791669872"/>The <code>ReadByte</code> method returns a single byte, unless you hit the end of the stream, at which point it returns a value of <code>−1</code>. (Its return type is <code>int</code>, enabling it to return any possible value for <code>byte</code> as well as negative values.) This avoids the problem of being handed back only some of the data you requested, because if you get anything back at all, you always get exactly one byte. However, it’s not especially convenient or efficient if you want to read larger chunks of data.</p>
<p><a data-primary="Write method" data-type="indexterm" id="idm45884791667088"/>The <code>Write</code> method doesn’t have any of these issues. If it succeeds, it always accepts all of the data you provide. Of course, it might fail—it could throw an exception before it manages to write all of the data because of an error (e.g., running out of space on disk or losing a network connection).</p>
<section data-pdf-bookmark="Position and Seeking" data-type="sect2"><div class="sect2" id="position_and_seeking">
<h2>Position and Seeking</h2>
<p><a data-primary="Position property (Stream)" data-type="indexterm" id="idm45884791663728"/><a data-primary="Seek method" data-type="indexterm" id="idm45884791662832"/><a data-primary="Stream class" data-secondary="position and seeking" data-type="indexterm" id="idm45884791662160"/>Streams automatically update their current position each time you read or write. As you can see in <a data-type="xref" href="#the_most_important_members_of_stream">Example 15-1</a>, the <code>Position</code> property can be set, so you can attempt to move directly to a particular position. This is not guaranteed to work because it’s not always possible to support it. For example, a <code>Stream</code> that represents data being received over a TCP network connection could produce data indefinitely—as long as the connection remains open and the other end keeps sending data, the stream will continue to honor calls to <code>Read</code>. A connection could remain open for many days and might receive terabytes of data in that time. If such a stream let you set its <code>Position</code> property, enabling your code to go back and reread data received earlier, the stream would have to find somewhere to store every single byte it received just in case the code using the stream wants to see it again. Since that might involve storing more data than you have space for on disk, this is clearly not practical, so some streams will throw <code>NotSupportedException</code> when you try to set the <code>Position</code> property. (There’s a <code>CanSeek</code> property you can use to discover whether a particular stream supports changing the position, so just like with read-only and write-only streams, you don’t have to wait until you get an exception to find out whether it will work.)</p>
<p>As well as the <code>Position</code> property, <code>Stream</code> also defines a <code>Seek</code> method, whose signature is shown in <a data-type="xref" href="#the_seek_method">Example 15-3</a>. This lets you specify the position you require relative to the stream’s current position. (This also throws <code>NotSupportedException</code> on streams that don’t support seeking.)</p>
<div data-type="example" id="the_seek_method">
<h5><span class="label">Example 15-3. </span>The <code>Seek</code> method</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">abstract</code> <code class="kt">long</code> <code class="nf">Seek</code><code class="p">(</code><code class="kt">long</code> <code class="n">offset</code><code class="p">,</code> <code class="n">SeekOrigin</code> <code class="n">origin</code><code class="p">);</code></pre></div>
<p>If you pass <code>SeekOrigin.Current</code> as the second argument, it will set the position by adding the first argument to the current position. You can pass a negative <code>offset</code> if you want to move backward. You can also pass <code>SeekOrigin.End</code> to set the position to be some specified number of bytes from the end of the stream. Passing <code>Seek​Ori⁠gin.Begin</code> has the same logical effect as just setting <code>Position</code>—it sets the position relative to the start of the stream.</p>
</div></section>
<section data-pdf-bookmark="Flushing" data-type="sect2"><div class="sect2" id="flushing">
<h2>Flushing</h2>
<p><a data-primary="Flush method" data-type="indexterm" id="idm45884791631344"/><a data-primary="Stream class" data-secondary="flushing" data-type="indexterm" id="idm45884791630640"/>As with many stream APIs on other programming systems, writing data to a <code>Stream</code> does not necessarily cause the data to reach its destination immediately. When a call to <code>Write</code> returns, all you know is that it has copied your data somewhere; but that might be a buffer in memory, not the final target. For example, if you write a single byte to a stream representing a file on a storage device, the stream object will typically defer writing that to the drive until it has enough bytes to make it worth the effort. Storage devices are block-based, meaning that writes happen in fixed-size chunks, typically several kilobytes in size, so it generally makes sense to wait until there’s enough data to fill a block before writing anything out.</p>
<p>This buffering is usually a good thing—it improves write performance while enabling you to ignore the details of how the disk works. However, a downside is that if you write data only occasionally (e.g., when writing error messages to a logfile), you could easily end up with long delays between the program writing data to a stream and that data reaching the disk. This could be perplexing for someone trying to diagnose a problem by looking at the logfiles of a program that’s currently running. And more insidiously, if your program crashes, anything in a stream’s buffers that has not yet made it to the storage device will probably be lost.</p>
<p>The <code>Stream</code> class therefore offers a <code>Flush</code> method. This lets you tell the stream that you want it to do whatever work is required to ensure that any buffered data is written to its target, even if that means making suboptimal use of the buffer.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>When using a <code>FileStream</code>, the <code>Flush</code> method does not necessarily guarantee that the data being flushed has made it to disk yet. It merely makes the stream pass the data to the OS. Before you call <code>Flush</code>, the OS hasn’t even seen the data, so if you were to terminate the process suddenly, the data would be lost. After <code>Flush</code> has returned, the OS has everything your code has written, so the process could be terminated without loss of data. However, the OS may perform additional buffering of its own, so if the power fails before the OS gets around to writing everything to disk, the data will still be lost. If you need to guarantee that data has been written persistently (rather than merely ensuring that you’ve handed it to the OS), you will also need to either use the <code>WriteThrough</code> flag, described in <a data-type="xref" href="#filestream_class">“FileStream Class”</a>, or call the <code>Flush</code> overload that takes a <code>bool</code>, passing <code>true</code> to force flushing to the storage device.</p>
</div>
<p>A stream automatically flushes its contents when you call <code>Dispose</code>. You need to use <code>Flush</code> only when you want to keep a stream open after writing out buffered data. It is particularly important if there will be extended periods during which the stream is open but inactive. (If the stream represents a network connection, and if your application depends on prompt data delivery—this would be the case in an online chat application or game, for example—you would call <code>Flush</code> even if you expect only fairly brief periods of inactivity.)</p>
</div></section>
<section data-pdf-bookmark="Copying" data-type="sect2"><div class="sect2" id="copying">
<h2>Copying</h2>
<p><a data-primary="CopyTo method" data-type="indexterm" id="idm45884791617344"/><a data-primary="Stream class" data-secondary="copying" data-type="indexterm" id="idm45884791616416"/>Copying all of the data from one stream to another is occasionally useful. It wouldn’t be hard to write a loop to do this, but you don’t have to, because the <code>Stream</code> class’s <code>CopyTo</code> method (or the equivalent <code>CopyToAsync</code>) does it for you. There’s not much to say about it. The main reason I’m mentioning it is that it’s not uncommon for developers to write their own version of this method because they didn’t know the functionality was built into <code>Stream</code>.</p>
</div></section>
<section data-pdf-bookmark="Length" data-type="sect2"><div class="sect2" id="length">
<h2>Length</h2>
<p><a data-primary="length operations" data-type="indexterm" id="idm45884791594192"/><a data-primary="Length property" data-type="indexterm" id="idm45884791593328"/><a data-primary="Stream class" data-secondary="length" data-type="indexterm" id="idm45884791592656"/>Some streams are able to report their length through the predictably named <code>Length</code> property. As with <code>Position</code>, this property’s type is <code>long</code>—<code>Stream</code> uses 64-bit numbers because streams often need to be larger than 2 GB, which would be the upper limit if sizes and positions were represented with <code>int</code>.</p>
<p><code>Stream</code> also defines a <code>SetLength</code> method that lets you define the length of a stream (where supported). You might think about using this when writing a large quantity of data to a file, to ensure that there is enough space to contain all the data you wish to write—better to get an <code>IOException</code> before you start than wasting time on a doomed operation and potentially causing system-wide problems by using up all of the free space. However, many filesystems support sparse files, letting you create files far larger than the available free space, so in practice you might not see any error until you start writing nonzero data. Even so, if you specify a length that is longer than the filesystem supports, <code>SetLength</code> will throw an <code>ArgumentException</code>.</p>
<p>Not all streams support length operations. The <code>Stream</code> class documentation says that the <code>Length</code> property is available only on streams that support <code>CanSeek</code>. This is because streams that support seeking are typically ones where the whole content of the stream is known and accessible up front. Seeking is unavailable on streams where the content is produced at runtime (e.g., input streams representing user input or streams representing data received over the network), and in those cases the length is also very often not known in advance. As for <code>SetLength</code>, the documentation states that this is supported only on streams that support both writing and seeking. (As with all members representing optional features, <code>Length</code> and <code>SetLength</code> will throw a <code>NotSupportedException</code> if you try to use these members on streams that do not support them.)</p>
</div></section>
<section data-pdf-bookmark="Disposal" data-type="sect2"><div class="sect2" id="disposal">
<h2>Disposal</h2>
<p><a data-primary="Dispose method" data-secondary="stream class" data-type="indexterm" id="idm45884791581552"/><a data-primary="Stream class" data-secondary="disposal" data-type="indexterm" id="idm45884791580352"/>Some streams represent resources external to the .NET runtime. For example, 
<span class="keep-together"><code>FileStream</code></span> provides stream access to the contents of a file, so it needs to obtain a file handle from the OS. It’s important to close handles when you’re done with them; otherwise you might prevent other applications from being able to use the file. Consequently, the <code>Stream</code> class implements the <code>IDisposable</code> interface (described in <a data-type="xref" href="ch07.xhtml#ch_object_lifetime">Chapter 7</a>) so that it can know when to do that. And, as I mentioned earlier, buffering streams such as <code>FileStream</code> flush their buffers when you call <code>Dispose</code>, before closing handles.</p>
<p>Not all stream types depend on <code>Dispose</code> being called: <code>MemoryStream</code> works entirely in memory, so the GC would be able to take care of it. But in general, if you caused a stream to be created, you should call <code>Dispose</code> when you no longer need it.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>There are some situations in which you will be provided with a stream, but it is not your job to dispose it. For example, ASP.NET Core can provide streams to represent data in HTTP requests and responses. It creates these for you and then disposes them after you’ve used them, so you should not call <code>Dispose</code> on them.</p>
</div>
<p><a data-primary="Close method" data-type="indexterm" id="idm45884791571696"/>Confusingly, the <code>Stream</code> class also has a <code>Close</code> method. This is an accident of history. The first public beta release of .NET 1.0 did not define <code>IDisposable</code>, and C# did not have <code>using</code> statements—the keyword was only for <code>using</code> directives, which bring namespaces into scope. The <code>Stream</code> class needed some way of knowing when to clean up its resources, and since there was not yet a standard way to do this, it invented its own idiom. It defined a <code>Close</code> method, which was consistent with the terminology used in many stream-based APIs in other programming systems. <code>IDisposable</code> was added before the final release of .NET 1.0, and the <code>Stream</code> class added support for this, but it left the <code>Close</code> method in place; removing it would have disrupted a lot of early adopters who had been using the betas. But <code>Close</code> is redundant, and the documentation actively advises against using it. It says you should call <code>Dispose</code> instead (through a <code>using</code> statement if that is convenient). There’s no harm in calling <code>Close</code>—there’s no practical difference between that and <code>Dispose</code>—but <code>Dispose</code> is the more common idiom and is therefore preferred.</p>
</div></section>
<section data-pdf-bookmark="Asynchronous Operation" data-type="sect2"><div class="sect2" id="asynchronous_operation">
<h2>Asynchronous Operation</h2>
<p><a data-primary="asynchronous operations" data-type="indexterm" id="idm45884791561488"/><a data-primary="Stream class" data-secondary="asynchronous operation" data-type="indexterm" id="idm45884791560448"/>The <code>Stream</code> class offers asynchronous versions of <code>Read</code> and <code>Write</code>. Be aware that there are two forms. <code>Stream</code> first appeared in .NET 1.0, so it supported what was then the standard asynchronous mechanism, the Asynchronous Programming Model (APM, described in <a data-type="xref" href="ch16.xhtml#ch_multithreading">Chapter 16</a>) through the <code>BeginRead</code>, <code>EndRead</code>, <code>BeginWrite</code>, and <code>EndWrite</code> methods. This model is now deprecated, having been superseded by the newer Task-based Asynchronous Pattern (or TAP, also described in <a data-type="xref" href="ch16.xhtml#ch_multithreading">Chapter 16</a>). <code>Stream</code> supports this through its <code>ReadAsync</code> and <code>WriteAsync</code> methods. <a data-primary="CopyToAsync method" data-type="indexterm" id="idm45884791552816"/><a data-primary="FlushAsync method" data-type="indexterm" id="idm45884791552080"/>There are two more operations that did not originally have any kind of asynchronous form that now have TAP versions: <code>FlushAsync</code> and <code>CopyToAsync</code>. (These support only TAP, because APM was already deprecated by the time Microsoft added these methods.)</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Avoid the old APM-based <code>Begin</code>/<code>End</code> forms of <code>Read</code> and <code>Write</code>. They weren’t present at all in early versions of .NET Core, nor in .NET Standard prior to 2.0. They reappeared to make it easier to migrate existing code from .NET Framework to .NET Core, so they are supported only for legacy scenarios.</p>
</div>
<p>Some stream types implement asynchronous operations using very efficient techniques that correspond directly to the asynchronous capabilities of the underlying OS. (<code>FileStream</code> does this, as do the various streams .NET can provide to represent content from network connections.) You may come across libraries with custom stream types that do not do this, but even then, the asynchronous methods will be available, because the base <code>Stream</code> class can fall back to using multithreaded techniques instead.</p>
<p><a data-primary="Position property (Stream)" data-type="indexterm" id="idm45884791545120"/>One thing you need to be careful of when using asynchronous reads and writes is that a stream only has a single <code>Position</code> property. Reads and writes depend on the current <code>Position</code> and also update it when they are done, so in general you must avoid starting a new operation before one already in progress is complete. However, if you wish to perform multiple concurrent read or write operations from a particular file, <code>FileStream</code> has special handling for this. If you tell it that you will be using the file in asynchronous mode, operations use the value <code>Position</code> has at the start of the operation, and once an asynchronous read or write has started, you are allowed to change <code>Position</code> and start another operation without waiting for all the previous ones to complete. But this only applies to <code>FileStream</code>, and only when the file was opened in asynchronous mode. Alternatively, instead of using <code>FileStream</code>, you could use the new <code>RandomAccess</code> class described later in this chapter.</p>
<p>.NET Core 3.1 and .NET 5.0 and later <a data-primary="disposal" data-secondary="IAsyncDisposable interface" data-type="indexterm" id="idm45884791539904"/>offer <code>IAsyncDisposable</code>, an asynchronous form of <code>Dispose</code>. The <code>Stream</code> class implements this, because disposal often involves flushing, which is a potentially slow operation.</p>
</div></section>
<section data-pdf-bookmark="Concrete Stream Types" data-type="sect2"><div class="sect2" id="concrete_stream_types">
<h2>Concrete Stream Types</h2>
<p><a data-primary="Stream class" data-secondary="concrete types" data-type="indexterm" id="idm45884791535520"/><a data-primary="HttpClient class" data-type="indexterm" id="idm45884791534544"/>The <code>Stream</code> class is abstract, so to use a stream, you’ll need a concrete derived type. In some situations, this will be provided for you—the ASP.NET Core web framework supplies stream objects representing HTTP request and response bodies, for example, and the client-side <code>HttpClient</code> class will do something similar. But sometimes you’ll need to create a stream object yourself. This section describes a few of the more commonly used types that derive from <code>Stream</code>.</p>
<p>The <code>FileStream</code> class represents a file on the filesystem. I will describe this in <a data-type="xref" href="#files_and_directories">“Files and Directories”</a>.</p>
<p><a data-primary="MemoryStream class" data-type="indexterm" id="idm45884791530112"/><code>MemoryStream</code> lets you create a stream on top of a <code>byte[]</code> array. You can either take an existing <code>byte[]</code> and wrap it in a <code>MemoryStream</code>, or you can create a <code>MemoryStream</code> and then populate it with data by calling <code>Write</code> (or the asynchronous equivalent). You can retrieve the populated <code>byte[]</code> once you’re done by calling either <code>ToArray</code> or <code>GetBuffer</code>. (<code>ToArray</code> allocates a new array, with the size based on the number of bytes actually written. <code>GetBuffer</code> is more efficient because it returns the underlying array <code>MemoryStream</code> is using, but unless the writes happened to fill it completely, the array returned will typically be oversized, with some unused space at the end.) This class is useful when you are working with APIs that require a stream and you don’t have one for some reason. For example, most of the serialization APIs described later in this chapter work with streams, but you might end up wanting to use that in conjunction with some other API that works in terms of <code>byte[]</code>. <code>MemoryStream</code> lets you bridge between those two representations.</p>
<p>Both Windows and Unix define an interprocess communication (IPC) mechanism enabling you to connect two processes through a stream. <a data-primary="named pipes" data-type="indexterm" id="idm45884791522368"/>Windows calls these <em>named pipes</em>. <a data-primary="domain sockets" data-type="indexterm" id="idm45884791521120"/>Unix also has a mechanism with that name, but it is completely different; it does, however, offer a mechanism similar to Windows named pipes: <em>domain sockets</em>. Although the precise details of Windows named pipes and Unix domain sockets differ, the various classes derived from <code>PipeStream</code> provide a common abstraction for both in .NET.</p>
<p><code>BufferedStream</code> derives from <code>Stream</code> but also takes a <code>Stream</code> in its constructor. It adds a layer of buffering, which is useful if you want to perform small reads or writes on a stream that is designed to work best with larger operations. (You don’t need to use this with <code>FileStream</code> because that has its own built-in buffering mechanism.)</p>
<p>There are various stream types that transform the contents of other streams in some way. For example, <code>DeflateStream</code>, <code>GZipStream</code>, and <code>BrotliStream</code> implement three widely used compression algorithms. You can wrap these around other streams to compress the data written to the underlying stream or to decompress the data read from it. (These just provide the lowest-level compression service. If you want to work with the popular ZIP format for packages of compressed files, use the <code>ZipArchive</code> class.) There’s also a class called <code>CryptoStream</code>, which can encrypt or decrypt the contents of other streams using any of the wide variety of encryption mechanisms supported in .NET.</p>
</div></section>
<section data-pdf-bookmark="One Type, Many Behaviors" data-type="sect2"><div class="sect2" id="stream_one_type_many_behaviors">
<h2>One Type, Many Behaviors</h2>
<p>As you’ve now seen, the abstract base class <code>Stream</code> gets used in a wide range of scenarios. It is arguably an abstraction that has been stretched a little too thin. The presence of properties such as <code>CanSeek</code> that tell you whether the particular <code>Stream</code> you have can be used in a certain way is arguably a symptom of an underlying problem, an example of something known as a <a data-primary="code smell" data-type="indexterm" id="idm45884791510464"/><em>code smell</em>. .NET streams did not invent this particular one-size-fits-all approach—it was popularized by Unix and the C programming language’s standard library a long time ago. The problem is that when writing code that deals with a <code>Stream</code>, you might not know what sort of thing you are dealing with.</p>
<p><a data-primary="Stream class" data-secondary="usage styles" data-type="indexterm" id="idm45884791508512"/>There are many different ways to use a <code>Stream</code>, but three usage styles come up a lot:</p>
<ul>
<li>
<p>Sequential access of a sequence of bytes</p>
</li>
<li>
<p>Random access, with a presumption of efficient caching</p>
</li>
<li>
<p>Access to some underlying capability of a device or system</p>
</li>
</ul>
<p>As you know, not all <code>Stream</code> implementations support all three models—if <code>CanSeek</code> returns <code>false</code>, that rules out the middle option. But what is less obvious is that even when these properties indicate that a capability is available, not all streams support all usage models equally efficiently.</p>
<p>For example, I worked on a project that used a library for accessing files in a cloud-hosted storage service that was able to represent those files with <code>Stream</code> objects. This looks convenient because you can pass those to any API that works with a <code>Stream</code>. However, it was designed very much for the third style of use in the preceding list: every single call to <code>Read</code> (or <code>ReadAsync</code>) would cause the library to make an HTTP request to the storage service. We had initially hoped to use this with another library that knew how to parse Parquet files (a binary tabular data storage format widely used in high-volume data processing). However, it turned out that the library was expecting a stream that supported the second type of access: it jumped back and forth through the file, making large numbers of fairly small reads. It worked perfectly well with the <code>FileStream</code> type I’ll be describing later, because that supports the first two modes of use well. (For the second style, it relies on the OS to do the caching.) But it would have been a performance disaster to plug a <code>Stream</code> from the storage service library directly into the Parquet parsing library.</p>
<p>It’s not always obvious when you have a mismatch of this kind. In this example, the properties reporting capabilities such as <code>CanSeek</code> gave no clue that there would be a problem. And applications that use Parquet files often use some sort of remote storage service, rather than the local filesystem, so there was no obvious reason to think that this library would presume that any <code>Stream</code> would offer local filesystem-like caching. It did technically work when we tried it: the storage library <code>Stream</code> worked hard to do everything asked of it, and the code worked correctly…eventually. So whenever you use a <code>Stream</code>, it’s important to make sure you have fully understood what access patterns it will be subjected to and how efficiently it supports those <span class="keep-together">patterns.</span></p>
<p><a data-primary="BufferedStream class" data-type="indexterm" id="idm45884791494576"/>In some cases you might be able to bridge the gap. The <code>BufferedStream</code> class can often take a <code>Stream</code> designed only for the third usage style mentioned previously and adapt it for the first style of usage. However, there’s nothing in the runtime libraries that can add support for the second style of usage to a <code>Stream</code> that doesn’t already innately support it. (This is typically only available either with streams that represent something already fully in memory or that wrap some local API that does the caching for you, such as the OS filesystem APIs.) In these cases you will either need to rethink your design (e.g., make a local copy of the <code>Stream</code> contents), change the way that the <code>Stream</code> is consumed, or write some sort of custom caching adapter. (In the end, we wrote an adapter that augmented the capabilities of <code>BufferedStream</code> with just enough random access caching to solve the performance problems.)<a data-startref="ix_ch15-asciidoc0" data-type="indexterm" id="idm45884791490720"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Random Access and Scatter/Gather I/O Without Stream" data-type="sect1"><div class="sect1" id="idm45884792209648">
<h1>Random Access and Scatter/Gather I/O Without Stream</h1>
<p>.NET 6.0 <a data-primary=".NET 6.0" data-primary-sortas="NET 6.0" data-secondary="RandomAccess class" data-type="indexterm" id="idm45884791488800"/><a data-primary="files and directories" data-secondary="random access and scatter/gather I/O without Stream" data-type="indexterm" id="idm45884791487552"/><a data-primary="RandomAccess class" data-type="indexterm" id="idm45884791486480"/><a data-primary="scatter/gather I/O without Stream" data-type="indexterm" id="idm45884791485808"/><a data-primary="System.IO RandomAccess class" data-type="indexterm" id="idm45884791485168"/>adds a new class to the <code>System.IO</code> namespace: <code>RandomAccess</code>. It enables file read and write operations without using <code>Stream</code>. It can simplify scenarios in which you want to perform multiple concurrent reads from a single file. It can also perform single read or write operations that operate across data that is not in a single contiguous block of memory, taking advantage of the underlying OS’s ability to handle such reads and writes efficiently.</p>
<p>To use <code>RandomAccess</code>, you must open a file with the <code>File</code> class’s <code>OpenHandle</code> method (also new in .NET 6.0), which returns a <code>SafeFileHandle</code>, a disposable wrapper around an OS file handle. You can pass this to the various <code>Read</code>, <code>ReadAsync</code>, <code>Write</code>, and <code>WriteAsync</code> static methods offered by <code>RandomAccess</code>. All of the read and write methods require you to pass the offset within the file, unlike <code>Stream</code>, which remembers the current <code>Position</code> for you. The advantage of passing the offset with each method is that it avoids the problems described earlier with performing multiple concurrent operations. <a data-type="xref" href="#randomaccess_read">Example 15-4</a> uses this to read data directly from a Windows <em>.exe</em> file. Notice that as with the <code>Stream</code> class, reads may fetch less data than you ask for, so in cases where you need to read a particular number of bytes, you will need to write a loop that can keep reading until the required amount of data has been fetched.</p>
<div data-type="example" id="randomaccess_read">
<h5><span class="label">Example 15-4. </span>Reading data from a file with <code>RandomAccess</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">static</code> <code class="k">void</code> <code class="nf">ReadAll</code><code class="p">(</code><code class="n">SafeFileHandle</code> <code class="n">fh</code><code class="p">,</code> <code class="n">Span</code><code class="p">&lt;</code><code class="kt">byte</code><code class="p">&gt;</code> <code class="n">buffer</code><code class="p">,</code> <code class="kt">long</code> <code class="n">offset</code><code class="p">)</code>
<code class="p">{</code>
    <code class="kt">int</code> <code class="n">soFar</code> <code class="p">=</code> <code class="m">0</code><code class="p">;</code>
    <code class="k">do</code>
    <code class="p">{</code>
        <code class="kt">int</code> <code class="n">read</code> <code class="p">=</code> <code class="n">RandomAccess</code><code class="p">.</code><code class="n">Read</code><code class="p">(</code><code class="n">fh</code><code class="p">,</code> <code class="n">buffer</code><code class="p">[</code><code class="n">soFar</code><code class="p">..],</code> <code class="n">offset</code> <code class="p">+</code> <code class="n">soFar</code><code class="p">);</code>
        <code class="k">if</code> <code class="p">(</code><code class="n">read</code> <code class="p">==</code> <code class="m">0</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="k">throw</code> <code class="k">new</code> <code class="nf">InvalidOperationException</code><code class="p">(</code>
                <code class="s">"Reached end of file before filling buffer"</code><code class="p">);</code>
        <code class="p">}</code>
        <code class="n">soFar</code> <code class="p">+=</code> <code class="n">read</code><code class="p">;</code>
    <code class="p">}</code> <code class="k">while</code> <code class="p">(</code><code class="n">soFar</code> <code class="p">&lt;</code> <code class="n">buffer</code><code class="p">.</code><code class="n">Length</code><code class="p">);</code>
<code class="p">}</code>

<code class="kt">var</code> <code class="n">stubSignature</code> <code class="p">=</code> <code class="k">new</code> <code class="kt">byte</code><code class="p">[</code><code class="m">2</code><code class="p">];</code>
<code class="n">ReadAll</code><code class="p">(</code><code class="n">fh</code><code class="p">,</code> <code class="n">stubSignature</code><code class="p">,</code> <code class="m">0</code><code class="p">);</code>
<code class="k">if</code> <code class="p">(</code><code class="n">stubSignature</code><code class="p">[</code><code class="m">0</code><code class="p">]</code> <code class="p">!=</code> <code class="p">(</code><code class="kt">byte</code><code class="p">)</code><code class="sc">'M'</code> <code class="p">||</code> <code class="n">stubSignature</code><code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="p">!=</code> <code class="p">(</code><code class="kt">byte</code><code class="p">)</code><code class="sc">'Z'</code><code class="p">)</code>
<code class="p">{</code>
    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"No 'MZ' at start of file - not an EXE file"</code><code class="p">);</code>
<code class="p">}</code></pre></div>
<p>This particular example just performs a single read to illustrate the usage, but a more complex example would be free to execute multiple concurrent reads, either on multiple threads or by using the <code>ReadAsync</code> method.</p>
<p>The buffer here is passed as a <code>Span&lt;byte&gt;</code>; <code>Write</code> takes a <code>ReadOnlySpan&lt;byte&gt;</code>. The asynchronous forms take <code>Memory&lt;byte&gt;</code> and <code>ReadOnlyMemory&lt;byte&gt;</code>, respectively. These types represent regions of memory—often but not necessarily arrays. They are all described in <a data-type="xref" href="ch18.xhtml#ch_memory_efficiency">Chapter 18</a>.</p>
<p>Each method also offers an overload that accepts a list of the relevant type (e.g., <code>IReadOnlyList&lt;Memory&lt;byte&gt;&gt;</code>, <code>IReadOnlyList&lt;ReadOnlyMemory&lt;byte&gt;&gt;</code>, etc.) to support <em>scatter/gather</em> reads or writes. These are operations in which a single read or write spans multiple blocks of memory. If the data you want to write out to a file is spread across multiple areas of memory (e.g., because the data in question was obtained by making multiple requests to external services), you can perform a single write operation, passing in a list of all the blocks of memory to write. This can be considerably more efficient than performing multiple separate writes—the operating system is able to handle this sort of I/O directly, and in many cases the underlying disk controller hardware is able to do the work of aggregating the blocks of data back into a single disk operation—it gathers together the data that was scattered in memory, hence the name. And the mirror image of this is available for reads: you can read a block of data from a file and have that distributed across multiple destination buffers.</p>
</div></section>
<section data-pdf-bookmark="Text-Oriented Types" data-type="sect1"><div class="sect1" id="text-oriented_types">
<h1>Text-Oriented Types</h1>
<p><a data-primary="text-oriented types" data-type="indexterm" id="ix_ch15-asciidoc2"/>The <code>Stream</code> and <code>RandomAccess</code> classes are byte oriented, but it’s common to work with files that contain text. If you want to process text stored in a file (or received over the network), it is cumbersome to use a byte-based API, because this forces you to deal explicitly with all of the variations that can occur. For example, there are multiple conventions for how to represent the end of a line—Windows typically uses two bytes with values of <code>13</code> and <code>10</code>, as do many internet standards such as HTTP, but Unix-like systems often use just a single byte with the value <code>10</code>.</p>
<p>There are also multiple character encodings in popular use. Some files use one byte per character, some use two, and some use a variable-length encoding. There are many different single-byte encodings too, so if you encounter a byte value of, say, <code>163</code> in a text file, you cannot know what that means unless you know which encoding is in use.</p>
<p>In a file using the single-byte Windows-1252 encoding, the value <code>163</code> represents a pound sign: £.<sup><a data-type="noteref" href="ch15.xhtml#CHP-16-FN-2" id="CHP-16-FN-2-marker">1</a></sup> But if the file is encoded with ISO/IEC 8859-5 (designed for regions that use Cyrillic alphabets), the exact same code represents the Cyrillic capital letter DJE: Ђ. And if the file uses the UTF-8 encoding, the value <code>163</code> would only be allowed as part of a multibyte sequence representing a single character.</p>
<p>Awareness of these issues is, of course, an essential part of any developer’s skill set, but that doesn’t mean you should have to handle every little detail any time you encounter text. So .NET defines specialized abstractions for working with text.</p>
<section data-pdf-bookmark="TextReader and TextWriter" data-type="sect2"><div class="sect2" id="textreader_and_textwriter">
<h2>TextReader and TextWriter</h2>
<p><a data-primary="text-oriented types" data-secondary="TextReader and TextWriter" data-type="indexterm" id="ix_ch15-asciidoc3"/><a data-primary="TextReader class" data-type="indexterm" id="ix_ch15-asciidoc4"/><a data-primary="TextWriter class" data-type="indexterm" id="ix_ch15-asciidoc5"/>The abstract <code>TextReader</code> and <code>TextWriter</code> classes present data as a sequence of <code>char</code> values. Logically speaking, these classes are similar to a stream, but each element in the sequence is a <code>char</code> instead of a <code>byte</code>. However, there are some differences in the details. For one thing, there are separate abstractions for reading and writing. <code>Stream</code> combines these, because it’s common to want read/write access to a single entity, particularly if the stream represents a file on disk. For byte-oriented random access, this makes sense, but it’s a problematic abstraction for text.</p>
<p>Variable-length encodings make it tricky to support random write access (i.e., the ability to change values at any point in the sequence). Consider what it would mean to take a 1 GB UTF-8 text file whose first character is a $ and replace that first character with a £. In UTF-8, the $ character takes only one byte, but £ requires two, so changing that first character would require an extra byte to be inserted at the start of the file. This would mean moving the remaining file contents—almost 1 GB of data—along by one byte.</p>
<p>Even read-only random access is relatively expensive. Finding the millionth character in a UTF-8 file requires you to read the first 999,999 characters, because without doing that, you have no way of knowing what mix of single-byte and multibyte characters there is. The millionth character might start at the millionth byte, but it could also start some 4 million bytes in, or anywhere in between. Since supporting random access with variable-length text encodings is expensive, particularly for writable data, these text-based types don’t offer it. Without random access, there’s no real benefit in merging readers and writers into one type. Also, separating reader and writer types removes the need to check the <code>CanWrite</code> property—you know that you can write because you’ve got a <code>TextWriter</code>.</p>
<p><code>TextReader</code> offers several ways to read data. The simplest is the zero-argument overload of <code>Read</code>, which returns an <code>int</code>. This will return <code>−1</code> if you’ve reached the end of the input and will otherwise return a character value. (You’ll need to cast it to a <code>char</code> once you’ve verified that it’s nonnegative.) Alternatively, there are two methods that look similar to the <code>Stream</code> class’s <code>Read</code> method, as <a data-type="xref" href="#textreader_chunk_reading_methods">Example 15-5</a> shows.</p>
<div data-type="example" id="textreader_chunk_reading_methods">
<h5><span class="label">Example 15-5. </span><code>TextReader</code> chunk reading methods</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">virtual</code> <code class="kt">int</code> <code class="nf">Read</code><code class="p">(</code><code class="kt">char</code><code class="p">[]</code> <code class="n">buffer</code><code class="p">,</code> <code class="kt">int</code> <code class="n">index</code><code class="p">,</code> <code class="kt">int</code> <code class="n">count</code><code class="p">)</code> <code class="p">{...}</code>
<code class="k">public</code> <code class="k">virtual</code> <code class="kt">int</code> <code class="nf">ReadBlock</code><code class="p">(</code><code class="kt">char</code><code class="p">[]</code> <code class="n">buffer</code><code class="p">,</code> <code class="kt">int</code> <code class="n">index</code><code class="p">,</code> <code class="kt">int</code> <code class="n">count</code><code class="p">)</code> <code class="p">{...}</code></pre></div>
<p>Just like <code>Stream.Read</code>, these take an array, as well as an index into that array and a count, and will attempt to read the number of values specified. The most obvious difference from <code>Stream</code> is that these use <code>char</code> instead of <code>byte</code>. But what’s the difference between <code>Read</code> and <code>ReadBlock</code>? Well, <code>ReadBlock</code> solves the same problem that I had to solve manually for <code>Stream</code> in <a data-type="xref" href="#reading_a_specific_number_of_bytes">Example 15-2</a>: whereas <code>Read</code> may return fewer characters than you asked for, <code>ReadBlock</code> will not return until either as many characters as you asked for are available or it reaches the end of the content.</p>
<p>One of the challenges of handling text input is dealing with the various conventions for line endings, and <code>TextReader</code> can insulate you from that. Its <code>ReadLine</code> method reads an entire line of input and returns it as a <code>string</code>. This string will not include the end-of-line character or characters.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>TextReader</code> does not presume one particular end-of-line convention. It accepts either a carriage return (character value <code>13</code>, which we write as <code>\r</code> in string literals) or a line feed (<code>10</code>, or <code>\n</code>). And if both characters appear adjacently, the character pair is treated as being a single end of line, despite being two characters. This processing happens only when you use either <code>ReadLine</code> or <code>Read​Li⁠neAsync</code>. If you work directly at the character level by using <code>Read</code> or <code>ReadBlock</code>, you will see the end-of-line characters exactly as they are.</p>
</div>
<p><code>TextReader</code> also offers <code>ReadToEnd</code>, which reads the input in its entirety and returns it as a single <code>string</code>. And finally, there’s <code>Peek</code>, which does the same thing as the single-argument <code>Read</code> method, except it does not change the state of the reader. It lets you look at the next character without consuming it, so the next time you call either <code>Peek</code> or <code>Read</code>, it will return the same character again.</p>
<p><a data-primary="Write method" data-type="indexterm" id="idm45884791185152"/>As for <code>TextWriter</code>, it offers two overloaded methods for writing: <code>Write</code> and <code>WriteLine</code>. Each of these offers overloads for all of the built-in value types (<code>bool</code>, <code>int</code>, <code>float</code>, etc.). Functionally, the class could have gotten away with a single overload that takes an <code>object</code>, because that can just call <code>ToString</code> on its argument, but these specialized overloads make it possible to avoid boxing the argument. <code>TextWriter</code> also offers a <code>Flush</code> method for much the same reason that <code>Stream</code> does.</p>
<p>By default, a <code>TextWriter</code> will use the default end-of-line sequence for the OS you are running on. On Windows this is the <code>\r\n</code> sequence (<code>13</code>, then <code>10</code>). On Linux you will just get a single <code>\n</code> at each line end. You can change this by setting the writer’s <code>NewLine</code> property.</p>
<p>Both of these abstract classes implement <code>IDisposable</code> because some of the concrete derived text reader and writer types are wrappers around other disposable resources.</p>
<p>As with <code>Stream</code>, these classes offer asynchronous versions of their methods. Unlike with <code>Stream</code>, this was a fairly recent addition, so they support only the task-based pattern described in <a data-type="xref" href="ch16.xhtml#ch_multithreading">Chapter 16</a>, which can be consumed with the <code>await</code> keyword described in <a data-type="xref" href="ch17.xhtml#ch_asynchronous_language_features">Chapter 17</a>.<a data-startref="ix_ch15-asciidoc5" data-type="indexterm" id="idm45884791171440"/><a data-startref="ix_ch15-asciidoc4" data-type="indexterm" id="idm45884791170736"/><a data-startref="ix_ch15-asciidoc3" data-type="indexterm" id="idm45884791170064"/></p>
</div></section>
<section data-pdf-bookmark="Concrete Reader and Writer Types" data-type="sect2"><div class="sect2" id="concrete_reader_and_writer_types">
<h2>Concrete Reader and Writer Types</h2>
<p><a data-primary="text-oriented types" data-secondary="concrete reader and writer types" data-type="indexterm" id="ix_ch15-asciidoc6"/>As with <code>Stream</code>, various APIs in .NET will present you with <code>TextReader</code> and <code>TextWriter</code> objects. For example, the <code>Console</code> class defines <code>In</code> and <code>Out</code> properties that provide textual access to the process’s input and output streams. I’ve not described these before, but we have been using them implicitly—the <code>Console.WriteLine</code> method overloads are all just wrappers that call <code>Out.WriteLine</code> for you. Likewise, the <code>Console</code> class’s <code>Read</code> and <code>ReadLine</code> methods simply forward to <code>In.Read</code> and <code>In.ReadLine</code>. There’s also <code>Error</code>, another <code>TextWriter</code> for writing to the standard error output stream. However, there are some concrete classes that derive from <code>TextReader</code> or <code>TextWriter</code> that you might want to instantiate directly.</p>
<section data-pdf-bookmark="StreamReader and StreamWriter" data-type="sect3"><div class="sect3" id="streamreader_and_streamwriter">
<h3>StreamReader and StreamWriter</h3>
<p><a data-primary="StreamReader type" data-type="indexterm" id="idm45884791157008"/><a data-primary="StreamWriter type" data-type="indexterm" id="idm45884791156080"/>Perhaps the most useful concrete text reader and writer types are <code>StreamReader</code> and <code>StreamWriter</code>, which wrap a <code>Stream</code> object. You can pass a <code>Stream</code> as a constructor argument, or you can just pass a string containing the path of a file, in which case they will automatically construct a <code>FileStream</code> for you and then wrap that. <a data-type="xref" href="#writing_text_to_a_file_with_streamwriter">Example 15-6</a> uses this technique to write some text to a file.</p>
<div data-type="example" id="writing_text_to_a_file_with_streamwriter">
<h5><span class="label">Example 15-6. </span>Writing text to a file with <code>StreamWriter</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">using</code> <code class="p">(</code><code class="kt">var</code> <code class="n">fw</code> <code class="p">=</code> <code class="k">new</code> <code class="n">StreamWriter</code><code class="p">(</code><code class="s">@"c:\temp\out.txt"</code><code class="p">))</code>
<code class="p">{</code>
    <code class="n">fw</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"Writing to a file at {DateTime.Now}"</code><code class="p">);</code>
<code class="p">}</code></pre></div>
<p>There are various constructor overloads offering more fine-grained control. When passing a string in order to use a file with a <code>StreamWriter</code> (as opposed to some <code>Stream</code> you have already obtained), you can optionally pass a <code>bool</code> indicating whether to start from scratch or to append to an existing file if one exists. (A <code>true</code> value enables appending.) If you do not pass this argument, appending is not used, and writing will begin from the start. You can also specify an encoding. By default, <code>StreamWriter</code> will use UTF-8 with no byte order mark (BOM), but you can pass any type derived from the <code>Encoding</code> class, which is described in <a data-type="xref" href="#encoding">“Encoding”</a>.</p>
<p><code>StreamReader</code> is similar—you can construct it by passing either a <code>Stream</code> or a <code>string</code> containing the path of a file, and you can optionally specify an encoding. However, if you don’t specify an encoding, the behavior is subtly different from <code>StreamWriter</code>. Whereas <code>StreamWriter</code> just defaults to UTF-8, <code>StreamReader</code> will attempt to detect the encoding from the stream’s content. It looks at the first few bytes and will look for certain features that are typically a good sign that a particular encoding is in use. If the encoded text begins with a Unicode BOM, this makes it possible to determine with high confidence what the encoding is.</p>
</div></section>
<section data-pdf-bookmark="StringReader and StringWriter" data-type="sect3"><div class="sect3" id="stringreader_and_stringwriter">
<h3>StringReader and StringWriter</h3>
<p><a data-primary="StringReader type" data-type="indexterm" id="idm45884791123376"/><a data-primary="StringWriter type" data-type="indexterm" id="idm45884791122672"/><a data-primary="StringBuilder class" data-type="indexterm" id="idm45884791122000"/>The <code>StringReader</code> and <code>StringWriter</code> classes serve a similar purpose to <span class="keep-together"><code>MemoryStream</code></span>: they are useful when you are working with an API that requires either a <span class="keep-together"><code>TextReader</code></span> or <code>TextWriter</code>, but you want to work entirely in memory. Whereas <span class="keep-together"><code>MemoryStream</code></span> presents a <code>Stream</code> API on top of a <code>byte[]</code> array, <code>StringReader</code> wraps a <code>string</code> as a <code>TextReader</code>, while <code>StringWriter</code> presents a <code>TextWriter</code> API on top of a <span class="keep-together"><code>StringBuilder</code></span>.</p>
<p>One of the APIs .NET offers for working with XML, <code>XmlReader</code>, requires either a <code>Stream</code> or a <code>TextReader</code>. Suppose you have XML content in a <code>string</code>. If you pass a <code>string</code> when creating a new <code>XmlReader</code>, it will interpret that as a URI from which to fetch the content, rather than the content itself. The constructor for <code>StringReader</code> that takes a string just wraps that string as the content of the reader, and we can pass that to the <code>XmlReader.Create</code> overload that requires a <code>TextReader</code>, as <a data-type="xref" href="#wrapping_a_string_in_a_stringreader">Example 15-7</a> shows. (The line that does this is in bold—the code that follows just uses the <code>XmlReader</code> to read the content to show that it works as expected.)</p>
<div data-type="example" id="wrapping_a_string_in_a_stringreader">
<h5><span class="label">Example 15-7. </span>Wrapping a string in a <code>StringReader</code></h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="kt">string</code><code> </code><code class="n">xmlContent</code><code> </code><code class="p">=</code><code>
</code><code>    </code><code class="s">"&lt;message&gt;&lt;text&gt;Hello&lt;/text&gt;&lt;recipient&gt;world&lt;/recipient&gt;&lt;/message&gt;"</code><code class="p">;</code><code>
</code><strong><code class="kt">var</code><code> </code><code class="n">xmlReader</code><code> </code><code class="p">=</code><code> </code><code class="n">XmlReader</code><code class="p">.</code><code class="n">Create</code><code class="p">(</code><code class="k">new</code><code> </code><code class="n">StringReader</code><code class="p">(</code><code class="n">xmlContent</code><code class="p">)</code><code class="p">)</code><code class="p">;</code></strong><code>
</code><code class="k">while</code><code> </code><code class="p">(</code><code class="n">xmlReader</code><code class="p">.</code><code class="n">Read</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>
</code><code class="p">{</code><code>
</code><code>    </code><code class="k">if</code><code> </code><code class="p">(</code><code class="n">xmlReader</code><code class="p">.</code><code class="n">NodeType</code><code> </code><code class="p">=</code><code class="p">=</code><code> </code><code class="n">XmlNodeType</code><code class="p">.</code><code class="n">Text</code><code class="p">)</code><code>
</code><code>    </code><code class="p">{</code><code>
</code><code>        </code><code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">xmlReader</code><code class="p">.</code><code class="n">Value</code><code class="p">)</code><code class="p">;</code><code>
</code><code>    </code><code class="p">}</code><code>
</code><code class="p">}</code></pre></div>
<p><code>StringWriter</code> is even simpler: you can just construct it with no arguments. Once you’ve finished writing to it, you can call either <code>ToString</code> or <code>GetStringBuilder</code> to extract all of the text that has been written.<a data-startref="ix_ch15-asciidoc6" data-type="indexterm" id="idm45884791009168"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Encoding" data-type="sect2"><div class="sect2" id="encoding">
<h2>Encoding</h2>
<p><a data-primary="encoding" data-secondary="text-oriented types" data-type="indexterm" id="ix_ch15-asciidoc7"/><a data-primary="StreamReader type" data-secondary="character encoding" data-type="indexterm" id="ix_ch15-asciidoc8"/><a data-primary="StreamWriter type" data-type="indexterm" id="ix_ch15-asciidoc9"/><a data-primary="Unicode" data-secondary="encoding" data-type="indexterm" id="ix_ch15-asciidoc10a"/><a data-primary="text-oriented types" data-secondary="encoding" data-type="indexterm" id="ix_ch15-asciidoc10"/>As I mentioned earlier, if you’re using the <code>StreamReader</code> or <code>StreamWriter</code>, these need to know which character encoding the underlying stream uses to be able to convert correctly between the bytes in the stream and .NET’s <code>char</code> or <code>string</code> types. To manage this, the <code>System.Text</code> namespace defines an abstract <code>Encoding</code> class, with various encoding-specific public concrete derived types, including <code>ASCIIEncoding</code>, <code>UTF7Encoding</code>, <code>UTF8Encoding</code>, <code>UTF32Encoding</code>, and <code>UnicodeEncoding</code>.</p>
<p>Most of those type names are self-explanatory, because they are named after the standard character encodings they represent, such as ASCII or UTF-8. The one that requires a little more explanation is <code>UnicodeEncoding</code>—after all, UTF-7, UTF-8, and UTF-32 are all Unicode encodings, so what’s this other one for? When Windows introduced support for Unicode back in the first version of Windows NT, it adopted a slightly unfortunate convention: in documentation and various API names, the term <em>Unicode</em> was used to refer to a 2-byte little-endian<sup><a data-type="noteref" href="ch15.xhtml#CHP-16-FN-3" id="CHP-16-FN-3-marker">2</a></sup> character encoding, which is just one of many possible encoding schemes, all of which could correctly be described as being “Unicode” of one form or another.</p>
<p>The <code>UnicodeEncoding</code> class is named to be consistent with this historical convention, although even then it’s still a bit confusing. The encoding referred to as “Unicode” in Win32 APIs is effectively UTF-16LE, but the <code>UnicodeEncoding</code> class is also capable of supporting the big-endian UTF-16BE.</p>
<p>The base <code>Encoding</code> class defines static properties that return instances of all the encoding types I’ve mentioned, so if you need an object representing a particular encoding, you would normally just write <code>Encoding.ASCII</code> or <code>Encoding.UTF8</code>, etc., instead of constructing a new object. There are two properties of type 
<span class="keep-together"><code>UnicodeEncoding</code></span>: the <code>Unicode</code> property returns one configured for UTF-16LE, and 
<span class="keep-together"><code>BigEndianUnicode</code></span> returns one for UTF-16BE.</p>
<p>For the various Unicode encodings, these properties will return encoding objects that will tell <code>StreamWriter</code> to generate a BOM at the start of the output. The main purpose of the BOM is to enable software that reads encoded text to detect automatically whether the encoding is big- or little-endian. (You can also use it to recognize UTF-8, because that encodes the BOM differently than other encodings.) If you know that you will be using an endian-specific encoding (e.g., UTF-16LE), the BOM is unnecessary, because you already know the order, but the Unicode specification defines adaptable formats in which the encoded bytes can advertise the order in use by starting with a BOM, a character with Unicode code point <code>U+FEFF</code>. The 16-bit version of this encoding is just called UTF-16, and you can tell whether any particular set of UTF-16-encoded bytes is big- or little-endian by seeing whether it begins with 0xFE, 0xFF or 0xFF, 0xFE.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Although Unicode defines encoding schemes that allow the endianness to be detected, it is not possible to create an <code>Encoding</code> object that works that way—it will always have a specific endianness. So, although an <code>Encoding</code> specifies whether a BOM should be written when writing data, this does not influence the behavior when reading data—it will always presume the endianness specified when the <code>Encoding</code> was constructed. This means that the <code>Encoding.UTF32</code> property is arguably misnamed—it always interprets data as little-endian even though the Unicode specification allows UTF-32 to use either big- or little-endian. <code>Encoding.UTF32</code> is really UTF-32LE.</p>
</div>
<p>As mentioned earlier, if you do not specify an encoding when creating a <code>StreamWriter</code>, it defaults to UTF-8 with no BOM, which is different from <code>Encoding.UTF8</code>—that will generate a BOM. And recall that <code>StreamReader</code> is more interesting: if you do not specify an encoding, it will attempt to detect the encoding. So .NET is able to handle automatic detection of byte ordering as required by the Unicode specification for UTF-16 and UTF-32; it is just that the way to do it is <em>not</em> to specify any particular encoding when constructing a <code>StreamReader</code>. It will look for a BOM, and if it finds one present, it will use a suitable Unicode encoding; otherwise, it presumes UTF-8 encoding.</p>
<p>UTF-8 is a popular encoding. If your main language is English, it’s a particularly convenient representation, because if you happen to use only the characters available in ASCII, each character will occupy a single byte, and the encoded text will have the exact same byte values as it would with ASCII encoding. But unlike ASCII, you’re not limited to a 7-bit character set. All Unicode code points are available; you just have to use multibyte representations for anything outside of the ASCII range. However, although it’s very widely used, UTF-8 is not the only popular 8-bit encoding.</p>
<section data-pdf-bookmark="Code page encodings" data-type="sect3"><div class="sect3" id="code_page_encodings">
<h3>Code page encodings</h3>
<p><a data-primary="code page encodings" data-type="indexterm" id="idm45884790956400"/><a data-primary="encoding" data-secondary="code page encodings" data-type="indexterm" id="idm45884790955696"/>Windows, like DOS before it, has long supported 8-bit encodings that extend ASCII. ASCII is a 7-bit encoding, meaning that with 8-bit bytes you have 128 “spare” values to use for other characters. This is nowhere near enough to cover every character for every locale, but within a particular country, it’s often enough to get by (although not always—many Far Eastern countries need more than 8 bits per character). But each country tends to want a different set of non-ASCII characters, depending on which accented characters are popular in that locale and whether a non-Roman alphabet is required. So various <em>code pages</em> exist for different locales. For example, code page 1253 uses values in the range 193–254 to define characters from the Greek alphabet (filling the remaining non-ASCII values with useful characters such as non-US currency symbols). Code page 1255 defines Hebrew characters instead, while 1256 defines Arabic characters in the upper range (and there is some common ground for these particular code pages, such as using 128 for the euro symbol, €, and 163 for the pound sign, £).</p>
<p>One of the most commonly encountered code pages is 1252, because that’s the Windows default for English-speaking locales. This does not define a non-Roman alphabet; instead it uses the upper character range for useful symbols and for various accented versions of the Roman alphabet that enable a wide range of Western European languages to be adequately represented.</p>
<p>You can create an encoding for a code page by calling the <code>Encoding.GetEncoding</code> method, passing in the code page number. (The concrete type of the object you get back is often not one of those I listed earlier. This method may return nonpublic types that derive from <code>Encoding</code>.) <a data-type="xref" href="#writing_with_the_windows_1252_code_page">Example 15-8</a> uses this to write text containing a pound sign to a file using code page 1252.</p>
<div data-type="example" id="writing_with_the_windows_1252_code_page">
<h5><span class="label">Example 15-8. </span>Writing with the Windows 1252 code page</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">using</code> <code class="p">(</code><code class="kt">var</code> <code class="n">sw</code> <code class="p">=</code> <code class="k">new</code> <code class="n">StreamWriter</code><code class="p">(</code><code class="s">"Text.txt"</code><code class="p">,</code> <code class="k">false</code><code class="p">,</code>
                                 <code class="n">Encoding</code><code class="p">.</code><code class="n">GetEncoding</code><code class="p">(</code><code class="m">1252</code><code class="p">)))</code>
<code class="p">{</code>
    <code class="n">sw</code><code class="p">.</code><code class="n">Write</code><code class="p">(</code><code class="s">"£100"</code><code class="p">);</code>
<code class="p">}</code></pre></div>
<p>This will encode the £ symbol as a single byte with the value <code>163</code>. With the default UTF-8 encoding, it would have been encoded as two bytes, with values of <code>194</code> and <code>163</code>, respectively.</p>
</div></section>
<section data-pdf-bookmark="Using encodings directly" data-type="sect3"><div class="sect3" id="using_encodings_directly">
<h3>Using encodings directly</h3>
<p><a data-primary="encoding" data-secondary="using encodings directly" data-type="indexterm" id="idm45884790919856"/><code>TextReader</code> and <code>TextWriter</code> are not the only way to use encodings. Objects representing encodings (such as <code>Encoding.UTF8</code>) define various members. The <code>GetBytes</code> method converts a <code>string</code> directly to a <code>byte[]</code> array, for example, and the <code>GetString</code> method converts back again.</p>
<p>You can also discover how much data these conversions will produce. <code>GetByteCount</code> tells you how large an array <code>GetBytes</code> would produce for a given string, while <code>GetCharCount</code> tells you how many characters decoding a particular array would generate. You can also find an upper limit for how much space will be required without knowing the exact text with <code>GetMaxByteCount</code>. Instead of a <code>string</code>, this takes a number, which it interprets as a string length; since .NET strings use UTF-16, this means that this API answers the question “If I have this many UTF-16 code units, what’s the largest number of code units that might be required to represent the same text in the target encoding?” This can produce a significant overestimate for variable-length encodings. For example, with UTF-8, <code>GetMaxByteCount</code> multiplies the length of the input string by three<sup><a data-type="noteref" href="ch15.xhtml#idm45884790912256" id="idm45884790912256-marker">3</a></sup> and adds an extra 3 bytes to deal with an edge case that can occur with surrogate characters. It produces a correct description of the worst possible case, but text containing any characters that don’t require 3 bytes in UTF-8 (i.e., any text in English or any other languages that use the Latin alphabet, and also any text using Greek, Cyrillic, Hebrew, or Arabic writing systems, for example) will require significantly less space than <code>GetMaxByteCount</code> predicts.</p>
<p><a data-primary="preamble" data-type="indexterm" id="idm45884790910576"/>Some encodings can provide a <em>preamble</em>, a distinctive sequence of bytes that, if found at the start of some encoded text, indicate that you are likely to be looking at something using that encoding. This can be useful if you are trying to detect which encoding is in use when you don’t already know. The various Unicode encodings all return their encoding of the BOM as the preamble, which you can retrieve with the <code>GetPreamble</code> method.</p>
<p>The <code>Encoding</code> class defines instance properties offering information about the encoding. <code>EncodingName</code> returns a human-readable name for the encoding, but there are two more names available. The <code>WebName</code> property returns the standard name for the encoding registered with the Internet Assigned Numbers Authority (IANA), which manages standard names and numbers for things on the internet such as MIME types. Some protocols, such as HTTP, sometimes put encoding names into headers, and this is the text you should use in that situation. The other two names, <code>BodyName</code> and <code>HeaderName</code>, are somewhat more obscure and are used only for internet email—there are different conventions for how certain encodings are represented in the body and headers of email<a data-startref="ix_ch15-asciidoc10" data-type="indexterm" id="idm45884790879088"/><a data-startref="ix_ch15-asciidoc10a" data-type="indexterm" id="idm45884790878480"/><a data-startref="ix_ch15-asciidoc9" data-type="indexterm" id="idm45884790877872"/><a data-startref="ix_ch15-asciidoc8" data-type="indexterm" id="idm45884790877232"/><a data-startref="ix_ch15-asciidoc7" data-type="indexterm" id="idm45884790876560"/>.<a data-startref="ix_ch15-asciidoc2" data-type="indexterm" id="idm45884790875760"/></p>
</div></section>
</div></section>
</div></section>
<section data-pdf-bookmark="Files and Directories" data-type="sect1"><div class="sect1" id="files_and_directories">
<h1>Files and Directories</h1>
<p><a data-primary="files and directories" data-type="indexterm" id="ix_ch15-asciidoc11"/>The abstractions I’ve shown so far in this chapter are very general purpose in 
<span class="keep-together">nature—you</span> can write code that uses a <code>Stream</code> without needing to have any idea where the bytes it contains come from or are going to, and likewise, <code>TextReader</code> and <code>TextWriter</code> do not demand any particular origin or destination for their data. This is useful because it makes it possible to write code that can be applied in a variety of scenarios. For example, the stream-based <code>GZipStream</code> can compress or decompress data from a file, over a network connection, or from any other stream. However, there are occasions where you know you will be dealing with files and want access to file-specific features. This section describes the classes for working with files and the filesystem.</p>
<section data-pdf-bookmark="FileStream Class" data-type="sect2"><div class="sect2" id="filestream_class">
<h2>FileStream Class</h2>
<p><a data-primary="files and directories" data-secondary="FileStream class" data-type="indexterm" id="ix_ch15-asciidoc12"/><a data-primary="FileStream class" data-type="indexterm" id="ix_ch15-asciidoc13"/>The <code>FileStream</code> class derives from <code>Stream</code> and represents a file from the filesystem. I’ve used it a few times in passing already. It adds relatively few members to those provided by the base class. The <code>Lock</code> and <code>Unlock</code> methods provide a way of acquiring exclusive access to specific byte ranges when using a single file from multiple processes. The <code>Name</code> property tells you the filename.</p>
<p><code>FileStream</code> offers a great deal of control in its constructors—disregarding the ones marked with the <code>[Obsolete]</code> attribute,<sup><a data-type="noteref" href="ch15.xhtml#CHP-16-FN-4" id="CHP-16-FN-4-marker">4</a></sup> there are no fewer than 10 constructor overloads. The ways of creating a <code>FileStream</code> fall into two groups: ones where you already have an OS file handle and ones where you don’t. If you already have a handle from somewhere, you are required to tell the <code>FileStream</code> whether that handle offers read, write, or read/write access to the file, which you do by passing a value from the <code>FileAccess</code> enumeration. The other overloads optionally let you indicate the buffer size you’d like to use when reading or writing, and a flag indicating whether the handle was opened for overlapped I/O, a Win32 mechanism for supporting asynchronous operation. (The constructors that don’t take that flag assume that you did not request overlapped I/O when creating the file handle.)</p>
<p>It is more common to use the other constructors, in which the <code>FileStream</code> uses OS APIs to create the file handle on your behalf. You can provide varying levels of detail on how you’d like this done. At a minimum, you must specify the file’s path and a value from the <code>FileMode</code> enumeration. <a data-type="xref" href="#filemode_enumeration">Table 15-1</a> shows the values this enumeration defines and describes what the <code>FileStream</code> constructor will do for each value in situations where the named file already exists and where it does not.</p>
<table id="filemode_enumeration">
<caption><span class="label">Table 15-1. </span><code>FileMode</code> enumeration</caption>
<thead>
<tr>
<th>Value</th>
<th>Behavior if file exists</th>
<th>Behavior if file does not exist</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>CreateNew</code></p></td>
<td><p>Throws <code>IOException</code></p></td>
<td><p>Creates new file</p></td>
</tr>
<tr>
<td><p><code>Create</code></p></td>
<td><p>Replaces existing file</p></td>
<td><p>Creates new file</p></td>
</tr>
<tr>
<td><p><code>Open</code></p></td>
<td><p>Opens existing file</p></td>
<td><p>Throws <code>FileNotFoundException</code></p></td>
</tr>
<tr>
<td><p><code>OpenOrCreate</code></p></td>
<td><p>Opens existing file</p></td>
<td><p>Creates new file</p></td>
</tr>
<tr>
<td><p><code>Truncate</code></p></td>
<td><p>Replaces existing file</p></td>
<td><p>Throws <code>FileNotFoundException</code></p></td>
</tr>
<tr>
<td><p><code>Append</code></p></td>
<td><p>Opens existing file, setting <code>Position</code> to end of file</p></td>
<td><p>Creates new file</p></td>
</tr>
</tbody>
</table>
<p>You can optionally specify a <code>FileAccess</code> too. If you do not, the <code>FileStream</code> will use <code>FileAccess.ReadWrite</code> unless you’ve chosen a <code>FileMode</code> of <code>Append</code>. Files opened in append mode can only be written to, so <code>FileStream</code> chooses <code>Write</code> in that case. (If you pass an explicit <code>FileAccess</code> asking for anything other than <code>Write</code> when opening in <code>Append</code> mode, the constructor throws an <code>ArgumentException</code>.)</p>
<p>By the way, as I describe each additional constructor argument in this section, the relevant overload will take all of the previously described ones too (with the exception of the <code>useAsync</code> argument, which appears in just one constructor). As <a data-type="xref" href="#filestream_constructors_taking_a_path">Example 15-9</a> shows, most of these constructors look just like the one before it, with one additional argument.</p>
<div data-type="example" id="filestream_constructors_taking_a_path">
<h5><span class="label">Example 15-9. </span><code>FileStream</code> constructors taking a path</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="nf">FileStream</code><code class="p">(</code><code class="kt">string</code> <code class="n">path</code><code class="p">,</code> <code class="n">FileMode</code> <code class="n">mode</code><code class="p">)</code>
<code class="k">public</code> <code class="nf">FileStream</code><code class="p">(</code><code class="kt">string</code> <code class="n">path</code><code class="p">,</code> <code class="n">FileMode</code> <code class="n">mode</code><code class="p">,</code> <code class="n">FileAccess</code> <code class="n">access</code><code class="p">)</code>
<code class="k">public</code> <code class="nf">FileStream</code><code class="p">(</code><code class="kt">string</code> <code class="n">path</code><code class="p">,</code> <code class="n">FileMode</code> <code class="n">mode</code><code class="p">,</code> <code class="n">FileAccess</code> <code class="n">access</code><code class="p">,</code>
                  <code class="n">FileShare</code> <code class="n">share</code><code class="p">)</code>
<code class="k">public</code> <code class="nf">FileStream</code><code class="p">(</code><code class="kt">string</code> <code class="n">path</code><code class="p">,</code> <code class="n">FileMode</code> <code class="n">mode</code><code class="p">,</code> <code class="n">FileAccess</code> <code class="n">access</code><code class="p">,</code>
                  <code class="n">FileShare</code> <code class="n">share</code><code class="p">,</code> <code class="kt">int</code> <code class="n">bufferSize</code><code class="p">)</code>
<code class="k">public</code> <code class="nf">FileStream</code><code class="p">(</code><code class="kt">string</code> <code class="n">path</code><code class="p">,</code> <code class="n">FileMode</code> <code class="n">mode</code><code class="p">,</code> <code class="n">FileAccess</code> <code class="n">access</code><code class="p">,</code>
                  <code class="n">FileShare</code> <code class="n">share</code><code class="p">,</code> <code class="kt">int</code> <code class="n">bufferSize</code><code class="p">,</code> <code class="kt">bool</code> <code class="n">useAsync</code><code class="p">)</code>
<code class="k">public</code> <code class="nf">FileStream</code><code class="p">(</code><code class="kt">string</code> <code class="n">path</code><code class="p">,</code> <code class="n">FileMode</code> <code class="n">mode</code><code class="p">,</code> <code class="n">FileAccess</code> <code class="n">access</code><code class="p">,</code>
                  <code class="n">FileShare</code> <code class="n">share</code><code class="p">,</code> <code class="kt">int</code> <code class="n">bufferSize</code><code class="p">,</code> <code class="n">FileOptions</code> <code class="n">options</code><code class="p">)</code></pre></div>
<p><a data-primary="FileShare type" data-type="indexterm" id="idm45884790729952"/>The overloads that accept an argument of type <code>FileShare</code> let you indicate whether you want exclusive access to the file. If you pass <code>FileShare.None</code>, the constructor will throw an <code>IOException</code> if the file is already open elsewhere, and if it succeeds, no other code will be able to open this file until you are finished with it. If you are prepared to allow other processes (or other code in your process) to open the file simultaneously, you can indicate whether your code can tolerate other users of the file having read access, write access, or both. <code>FileShare</code> is a flags-style enumeration, so you can specify <code>FileShare.Read|FileShare.Write</code>, but since that’s a common combination, <code>FileShare</code> defines a precombined <code>ReadWrite</code> value.</p>
<p>The constructor overloads that don’t take an explicit <code>FileShare</code> both use 
<span class="keep-together"><code>FileShare.Read</code>,</span> which indicates that your code is happy for other code to have the same file open simultaneously for reading but not writing. This would make sense if you are writing entries to a logfile, for example: you would most likely use 
<span class="keep-together"><code>FileMode.Append</code></span> and <code>FileShare.Read</code>, meaning only your code will be able to append log entries, but others could still open the file with <code>FileAccess.Read</code> to be able to read the log. If two programs attempt to open the same log file simultaneously for write access, and both specify <code>FileShare.Read</code> (explicitly or as the implicit default), then whichever gets in there first will succeed, but when the second one tries, the constructor will throw an <code>IOException</code> because the attempt to open the file for writing conflicts with the fact that the file is already open without 
<span class="keep-together"><code>FileShare.Write</code>.</span> And in this case, that is what you’d want—if two programs attempted to append to the end of the same file simultaneously, the result would be a mess because each would have its own idea about where the end of the file is.</p>
<p>If you attempt to open a file that some other code (either another process or code elsewhere inside your application) already has open, it will succeed only if the <code>File​Ac⁠cess</code> and <code>FileShare</code> you specify are compatible with the <code>FileShare</code> that was used by the code that got there first. Likewise, if your code has already opened a file, the <code>FileShare</code> you chose at that point determines which <code>FileAccess</code> and <code>FileShare</code> combinations other code could successfully apply while you are using the file. For example, if you want to read a logfile that some other process is writing to, then if that other process specified <code>FileShare.Read</code>, you will need to use <code>FileAccess.Read</code>. (The constructors that don’t specify a <code>FileAccess</code> default to <code>FileAccess.ReadWrite</code>, which would fail in this case because you can’t get write access if something else already has the file open with <code>FileShare.Read</code>.) But you would also need to specify <code>FileShare.ReadWrite</code>. That may look surprising in code that only wants to read, but it makes sense: it states that we don’t mind if other code attempts to modify the file while we are reading from it. The default of <code>FileShare.Read</code> states that we need the file not to change while we’re using it, but that would be the wrong choice for <em>reading</em> from a logfile—if we managed to open a logfile with <code>FileShare.Read</code>, that would prevent the main application from opening the logfile for writing.</p>
<p>Specifying <code>FileShare.Write</code> on its own (not combined with <code>FileShare.Read</code>) is legal but slightly strange. It tolerates other handles with write access being active simultaneously, but no readers will be allowed. You can also pass <code>Delete</code> (on its own or in combination with <code>Read</code> and/or <code>Write</code>), indicating that you don’t mind if someone else tries to delete the file while you have it open. Obviously, you’ll get I/O exceptions if you try to use a file after it has been deleted, so you’d need to be prepared for that, but this can sometimes be worth the effort; otherwise, attempts to delete a file will be blocked while you have it open.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Unix has fewer file-locking mechanisms than Windows, so these locking semantics will often be mapped to something simpler in those environments. Also, file locks are advisory in Unix, meaning processes can simply ignore them if they want to.</p>
</div>
<p>The next piece of information we can pass is the buffer size. This controls the size of block that the <code>FileStream</code> will use when reading from and writing to the filesystem. It defaults to 4,096 bytes. In most scenarios, this value works just fine, but if you are processing very high volumes of data, a large buffer size might provide better throughput. However, as with all performance matters, you should measure the effect of such a change to see if it is worthwhile—in some cases, you will not see any difference in data throughput and will simply use a bit more memory than necessary.</p>
<p>The <code>useAsync</code> flag lets you determine whether the file handle is opened in a way that is optimized for large asynchronous reads and writes. (On Windows, this opens the file for <em>overlapped I/O</em>, a Win32 feature supporting asynchronous operations.) If you are reading data in relatively large chunks, and you use the stream’s asynchronous APIs, you will typically get better performance by setting this flag. However, if you read data a few bytes at a time, this mode actually increases overhead. If the code accessing the file is particularly performance sensitive, it will be worth trying both settings to see which works better for your workload. As mentioned earlier, this also makes it possible to perform multiple concurrent operations on a single <code>FileStream</code>.</p>
<p>The next argument you can add is of type <code>FileOptions</code>. If you’re paying close attention, you’ll notice in <a data-type="xref" href="#filestream_constructors_taking_a_path">Example 15-9</a> that each of the overloads we’ve looked at up to now adds one more argument, but with this one, the <code>FileOptions</code> argument <em>replaces</em> the <code>bool useAsync</code> argument. That’s because one of the options you can specify with <code>FileOptions</code> is asynchronous access. <code>FileOptions</code> is a flags enumeration, so you can specify a combination of any of the flags it offers, which are described in <a data-type="xref" href="#fileoptions_flags">Table 15-2</a>.</p>
<table id="fileoptions_flags">
<caption><span class="label">Table 15-2. </span><code>FileOptions</code> flags</caption>
<thead>
<tr>
<th>Flag</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>WriteThrough</code></p></td>
<td><p>Disables OS write buffering so data goes straight to the storage device when you flush the stream</p></td>
</tr>
<tr>
<td><p><code>Asynchronous</code></p></td>
<td><p>Specifies the use of asynchronous I/O</p></td>
</tr>
<tr>
<td><p><code>RandomAccess</code></p></td>
<td><p>Hints to filesystem cache that you will be seeking, not reading or writing data in order</p></td>
</tr>
<tr>
<td><p><code>SequentialScan</code></p></td>
<td><p>Hints to filesystem cache that you will be reading or writing data in order</p></td>
</tr>
<tr>
<td><p><code>DeleteOnClose</code></p></td>
<td><p>Tells <code>FileStream</code> to delete the file when you call <code>Dispose</code></p></td>
</tr>
<tr>
<td><p><code>Encrypted</code></p></td>
<td><p>Encrypts the file so that its contents cannot be read by other users</p></td>
</tr>
</tbody>
</table>
<p>Be wary of the <code>WriteThrough</code> flag. Although it works as advertised, it might not have the desired effect, because some hard drives defer writes to improve performance. (Many hard drives have their own RAM, enabling them to receive data from the computer very quickly and to report write operations as having completed before really storing the data.) The <code>WriteThrough</code> flag will ensure that when you dispose or flush the stream, all the data you’ve written will have been delivered to the drive, but the drive will not necessarily have written that data persistently, so you could still lose the data if the power fails. The exact behavior will depend on how you have told the OS to configure the drive.</p>
<p>.NET 6.0 <a data-primary=".NET 6.0" data-primary-sortas="NET 6.0" data-secondary="FileStreamOptions overload" data-type="indexterm" id="idm45884790628256"/><a data-primary="FileStreamOptions overload" data-type="indexterm" id="idm45884790627008"/>adds a new overload that accepts two arguments: a <code>string</code> (the file’s path) and a <code>FileStreamOptions</code>. <code>FileStreamOptions</code> defines a property for each of the settings we’ve just discussed. So it has <code>Mode</code>, <code>Access</code>, <code>Share</code>, <code>Options</code>, and <code>BufferSize</code>. It also adds an additional setting, new to .NET 6.0, <code>PreallocationSize</code>, enabling applications to indicate how much space they expect the file to take up. This enables the OS to detect when insufficient space is available and also to reserve the space, reducing the chances of starting an operation that eventually fails due to lack of disk space. The <code>FileStreamOptions</code> overload makes it easier to set only those aspects for which you don’t want the defaults—you can just set the relevant properties. This means it’s no longer inconvenient if there isn’t a <code>FileStream</code> constructor overload with the exact combination of parameters you need.</p>
<p>While <code>FileStream</code> gives you control over the contents of the file, some operations you might wish to perform on files are either cumbersome or not supported at all with <code>FileStream</code>. For example, you can copy a file with this class, but it’s not as straightforward as it could be, and <code>FileStream</code> does not offer any way to delete a file. So the runtime libraries include a separate class for these kinds of operations.<a data-startref="ix_ch15-asciidoc13" data-type="indexterm" id="idm45884790619568"/><a data-startref="ix_ch15-asciidoc12" data-type="indexterm" id="idm45884790618864"/></p>
</div></section>
<section data-pdf-bookmark="File Class" data-type="sect2"><div class="sect2" id="file_class">
<h2>File Class</h2>
<p><a data-primary="File class" data-type="indexterm" id="ix_ch15-asciidoc14"/><a data-primary="files and directories" data-secondary="File class" data-type="indexterm" id="ix_ch15-asciidoc15"/>The static <code>File</code> class provides methods for performing various operations on files. The <code>Delete</code> method removes the named file from the filesystem. The <code>Move</code> method can either move or just rename a file. There are methods for retrieving information and attributes that the filesystem stores about each file, such as <code>GetCreationTime</code>, <span class="keep-together"><code>GetLast</code></span><code class="keep-together">AccessTime</code>, <code>GetLastWriteTime</code>,<sup><a data-type="noteref" href="ch15.xhtml#CHP-16-FN-5" id="CHP-16-FN-5-marker">5</a></sup> and <code>GetAttributes</code>. (The last of those returns a <code>FileAttributes</code> value, which is a flags enumeration type telling you whether the file is read only, a hidden file, a system file, and so on.)</p>
<p><a data-primary="Encrypt method" data-type="indexterm" id="idm45884790607040"/>The <code>Encrypt</code> method overlaps with <code>FileStream</code> to some extent—as you saw earlier, you can request that a file be stored with encryption when you create it. However, <code>Encrypt</code> is able to work with a file that has already been created without encryption—it effectively encrypts it in situ. (This is only supported on Windows, and only on drives where the filesystem supports it. It will throw <code>PlatformNotSupported​Ex⁠ception</code> on other operating systems, and <code>NotSupportedException</code> on Windows if encryption is not available for the specified file. This has the same effect as enabling encryption through a file’s Properties window in Windows File Explorer.) You can also turn an encrypted file back into an unencrypted one by calling <code>Decrypt</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a data-primary="Decrypt method" data-type="indexterm" id="idm45884790602144"/>It is not necessary to call <code>Decrypt</code> before reading an encrypted file. When logged in under the same user account that encrypted a file, you can read its contents in the usual way—encrypted files look just like normal ones because Windows automatically decrypts the contents as you read from them. The purpose of this particular encryption mechanism is that if some other user manages to obtain access to the file (e.g., if it’s on an external drive that gets stolen), the content will appear to be random junk. <code>Decrypt</code> removes this encryption, meaning that anyone who can access the file will be able to look at its contents.</p>
</div>
<p>The other methods provided by <code>File</code> all just offer slightly more convenient ways of doing things you could have done by hand with <code>FileStream</code>. <a data-primary="CopyTo method" data-type="indexterm" id="idm45884790598448"/>The <code>Copy</code> method makes a copy of a file, and while you could do that with the <code>CopyTo</code> method on <code>FileStream</code>, <code>Copy</code> takes care of some awkward details. For example, it ensures that the target file carries over attributes such as whether it’s read-only and whether encryption is enabled.</p>
<p><a data-primary="Exists method" data-type="indexterm" id="idm45884790595536"/>The <code>Exists</code> method lets you discover whether a file exists before you attempt to open it. You don’t strictly need this, because <code>FileStream</code> will throw a <code>FileNotFound</code> exception if you attempt to open a nonexistent file, but <code>Exists</code> is useful if you don’t need to do anything with the file other than determining whether it is there. If you are planning to open the file anyway, and are just trying to avoid an exception, you should be wary of this method; just because <code>Exists</code> returns <code>true</code>, that’s no guarantee that you won’t get a <code>FileNotFound</code> exception. It’s always possible that in between your checking for a file’s existence and attempting to open it, another process might delete the file. Alternatively, the file might be on a network share, and you might lose network connectivity. So you should always be prepared for exceptions with file access, even if you’ve attempted to avoid provoking them.</p>
<p><code>File</code> offers many helper methods to simplify opening or creating files. The <code>Create</code> method simply constructs a <code>FileStream</code> for you, passing in suitable <code>FileMode</code>, 
<span class="keep-together"><code>FileAccess</code></span>, and <code>FileShare</code> values. <a data-type="xref" href="#file.create_versus_new_filestream">Example 15-10</a> shows how to use it and also shows what the equivalent code would look like without using the <code>Create</code> helper. The <code>Create</code> method provides overloads letting you specify the buffer size, 
<span class="keep-together"><code>FileOptions</code>,</span> and <code>FileSecurity</code>, but these still provide the other arguments for you.</p>
<div data-type="example" id="file.create_versus_new_filestream">
<h5><span class="label">Example 15-10. </span><code>File.Create</code> versus new <code>FileStream</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">using</code> <code class="p">(</code><code class="n">FileStream</code> <code class="n">fs</code> <code class="p">=</code> <code class="n">File</code><code class="p">.</code><code class="n">Create</code><code class="p">(</code><code class="s">"foo.bar"</code><code class="p">))</code>
<code class="p">{</code>
   <code class="p">...</code>
<code class="p">}</code>

<code class="c1">// Equivalent code without using File class</code>
<code class="k">using</code> <code class="p">(</code><code class="kt">var</code> <code class="n">fs</code> <code class="p">=</code> <code class="k">new</code> <code class="n">FileStream</code><code class="p">(</code><code class="s">"foo.bar"</code><code class="p">,</code> <code class="n">FileMode</code><code class="p">.</code><code class="n">Create</code><code class="p">,</code>
                               <code class="n">FileAccess</code><code class="p">.</code><code class="n">ReadWrite</code><code class="p">,</code> <code class="n">FileShare</code><code class="p">.</code><code class="n">None</code><code class="p">))</code>
<code class="p">{</code>
    <code class="p">...</code>
<code class="p">}</code></pre></div>
<p>The <code>File</code> class’s <code>OpenRead</code> and <code>OpenWrite</code> methods provide similar decluttering for when you want to open an existing file for reading or open or create a file for writing. There’s also an <code>Open</code> method that requires you to pass a <code>FileMode</code>. This is of more marginal utility—it’s very similar to the <code>FileStream</code> constructor overload that also takes just a path and a mode, automatically supplying suitable other settings. The somewhat arbitrary difference is that while the <code>FileStream</code> constructor defaults to <code>FileShare.Read</code>, the <code>File.Open</code> method defaults to <code>FileShare.None</code>.</p>
<p><code>File</code> also offers several text-oriented helpers. The simplest method, <code>OpenText</code>, opens a file for text reading and is of limited value because it does exactly the same thing as the <code>StreamReader</code> constructor that takes a single string argument. The only reason to use this is if you happen to prefer how it makes your code look—if your code makes heavy use of the <code>File</code> helpers, you might choose to use this for idiomatic consistency.</p>
<p>Several of the methods exposed by <code>File</code> are text oriented. These enable us to improve on code of the kind shown in <a data-type="xref" href="#appending_to_a_file_with_streamwriter">Example 15-11</a>. This appends a line of text to a logfile.</p>
<div data-type="example" id="appending_to_a_file_with_streamwriter">
<h5><span class="label">Example 15-11. </span>Appending to a file with <code>StreamWriter</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">static</code> <code class="k">void</code> <code class="nf">Log</code><code class="p">(</code><code class="kt">string</code> <code class="n">message</code><code class="p">)</code>
<code class="p">{</code>
    <code class="k">using</code> <code class="p">(</code><code class="kt">var</code> <code class="n">sw</code> <code class="p">=</code> <code class="k">new</code> <code class="n">StreamWriter</code><code class="p">(</code><code class="s">@"c:\temp\log.txt"</code><code class="p">,</code> <code class="k">true</code><code class="p">))</code>
    <code class="p">{</code>
        <code class="n">sw</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">message</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>One issue with this is that it’s not all that easy to see at a glance how the <code>StreamWriter</code> is being opened—what does that <code>true</code> argument mean? As it happens, that tells the <code>StreamWriter</code> that we want it to create the underlying <code>FileStream</code> in append mode. <a data-type="xref" href="#creating_an_appending_streamwriter_with">Example 15-12</a> has the same effect—it uses <code>File.AppendText</code>, which just 
<span class="keep-together">calls the exact</span> same <code>FileStream</code> constructor for us. While I was somewhat 
<span class="keep-together">dismissive of <code>File.OpenText</code></span> earlier for offering similarly marginal value, I think 
<span class="keep-together"><code>File.AppendText</code></span> did once provide a genuinely useful improvement in readability in a way that <code>File.OpenText</code> does not. It’s much easier to see that <a data-type="xref" href="#creating_an_appending_streamwriter_with">Example 15-12</a> will append text to a file than it is with <a data-type="xref" href="#appending_to_a_file_with_streamwriter">Example 15-11</a>. However, since support for named arguments was added to C#, <code>AppendText</code> now looks less useful—we could just name the <code>append</code> argument in <a data-type="xref" href="#appending_to_a_file_with_streamwriter">Example 15-11</a> for a similar improvement in readability.</p>
<div data-type="example" id="creating_an_appending_streamwriter_with">
<h5><span class="label">Example 15-12. </span>Creating an appending <code>StreamWriter</code> with <code>File.AppendText</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">static</code> <code class="k">void</code> <code class="nf">Log</code><code class="p">(</code><code class="kt">string</code> <code class="n">message</code><code class="p">)</code>
<code class="p">{</code>
    <code class="k">using</code> <code class="p">(</code><code class="n">StreamWriter</code> <code class="n">sw</code> <code class="p">=</code> <code class="n">File</code><code class="p">.</code><code class="n">AppendText</code><code class="p">(</code><code class="s">@"c:\temp\log.txt"</code><code class="p">))</code>
    <code class="p">{</code>
        <code class="n">sw</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">message</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>If you’re only going to append some text to a file and immediately close it, there’s an even easier way. As <a data-type="xref" href="#appending_a_single_string_to_a_file">Example 15-13</a> shows, we can simplify things further with the <code>AppendAllText</code> helper.</p>
<div data-type="example" id="appending_a_single_string_to_a_file">
<h5><span class="label">Example 15-13. </span>Appending a single string to a file</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">static</code> <code class="k">void</code> <code class="nf">Log</code><code class="p">(</code><code class="kt">string</code> <code class="n">message</code><code class="p">)</code>
<code class="p">{</code>
    <code class="n">File</code><code class="p">.</code><code class="n">AppendAllText</code><code class="p">(</code><code class="s">@"c:\temp\log.txt"</code><code class="p">,</code> <code class="n">message</code><code class="p">);</code>
<code class="p">}</code></pre></div>
<p>Be careful, though. This does not do quite the same thing as <a data-type="xref" href="#creating_an_appending_streamwriter_with">Example 15-12</a>. That example used <code>WriteLine</code> to append the text, but <a data-type="xref" href="#appending_a_single_string_to_a_file">Example 15-13</a> is equivalent to using just <code>Write</code>. So, if you were to call the <code>Log</code> method in <a data-type="xref" href="#appending_a_single_string_to_a_file">Example 15-13</a> multiple times, you’d end up with one long line in your output file, unless the strings you were using happened to contain end-of-line characters. If you want to work with lines, there’s an <code>AppendAllLines</code> method that takes a collection of strings and appends each as a new line to the end of a file. <a data-type="xref" href="#appending_a_single_line_to_a_file">Example 15-14</a> uses this to append a full line with each call.</p>
<div data-type="example" id="appending_a_single_line_to_a_file">
<h5><span class="label">Example 15-14. </span>Appending a single line to a file</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">static</code> <code class="k">void</code> <code class="nf">Log</code><code class="p">(</code><code class="kt">string</code> <code class="n">message</code><code class="p">)</code>
<code class="p">{</code>
    <code class="n">File</code><code class="p">.</code><code class="n">AppendAllLines</code><code class="p">(</code><code class="s">@"c:\temp\log.txt"</code><code class="p">,</code> <code class="k">new</code><code class="p">[]</code> <code class="p">{</code> <code class="n">message</code> <code class="p">});</code>
<code class="p">}</code></pre></div>
<p>Since <code>AppendAllLines</code> accepts an <code>IEnumerable&lt;string&gt;</code>, you can use it to append any number of lines. But it’s perfectly happy to append just one if that’s what you want. <code>File</code> also defines <code>WriteAllText</code> and <code>WriteAllLines</code> methods, which work in a very similar way, but if there is already a file at the specified path, these will replace it instead of appending to it.</p>
<p>There are also some related text-oriented methods for reading the contents of files. <code>ReadAllText</code> performs the equivalent of constructing a <code>StreamReader</code> and then calling its <code>ReadToEnd</code> method—it returns the entire content of the file as a single <code>string</code>. <code>ReadAllBytes</code> fetches the whole file into a <code>byte[]</code> array. <code>ReadAllLines</code> reads the whole file as a <code>string[]</code> array, with one element for each line in the file. <code>ReadLines</code> is superficially very similar. It provides access to the whole file as an <code>IEnumerable&lt;string&gt;</code> with one item for each line, but the difference is that it works lazily—unlike all the other methods I’ve described in this paragraph, it does not read the entire file into memory up front, so <code>ReadLines</code> would be a better choice for very large files. It not only consumes less memory, but it also enables your code to get started more quickly—you can begin to process data as soon as the first line can be read from disk, whereas none of the other methods return until they have read the whole file.<a data-startref="ix_ch15-asciidoc15" data-type="indexterm" id="idm45884790300816"/><a data-startref="ix_ch15-asciidoc14" data-type="indexterm" id="idm45884790263872"/></p>
</div></section>
<section data-pdf-bookmark="Directory Class" data-type="sect2"><div class="sect2" id="directory_class">
<h2>Directory Class</h2>
<p><a data-primary="Directory class" data-type="indexterm" id="idm45884790262256"/><a data-primary="files and directories" data-secondary="Directory class" data-type="indexterm" id="idm45884790261216"/>Just as <code>File</code> is a static class offering methods for performing operations with files, <code>Directory</code> is a static class offering methods for performing operations with directories. Some of the methods are very similar to those offered by <code>File</code>—there are methods to get and set the creation time, last access time, and last write time, for example, and we also get <code>Move</code>, <code>Exists</code>, and <code>Delete</code> methods. Unlike <code>File</code>, <code>Directory.Delete</code> has two overloads. One takes just a path and works only if the directory is empty. The other also takes a <code>bool</code> that, if <code>true</code>, will delete everything in the folder, recursively deleting any nested folders and the files they contain. Use that one carefully.</p>
<p>Of course, there are also directory-specific methods. <code>GetFiles</code> takes a directory path and returns a <code>string[]</code> array containing the full path of each file in that directory. There’s an overload that lets you specify a pattern by which to filter the results, and a third overload that takes a pattern and also a flag that lets you request recursive searching of all subfolders. <a data-type="xref" href="#recursively_searching_for_files_of_a_par">Example 15-15</a> uses that to find all files with a <em>.jpg</em> extension in my <em>Pictures</em> folder. (Unless you’re also called Ian, you’d need to change that path to match your account name for this to work on your computer.) In a real application, you should get this path using the technique shown in <a data-type="xref" href="#known_folders">“Known Folders”</a>.</p>
<div data-type="example" id="recursively_searching_for_files_of_a_par">
<h5><span class="label">Example 15-15. </span>Recursively searching for files of a particular type</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">foreach</code> <code class="p">(</code><code class="kt">string</code> <code class="n">file</code> <code class="k">in</code> <code class="n">Directory</code><code class="p">.</code><code class="n">GetFiles</code><code class="p">(</code><code class="s">@"c:\users\ian\Pictures"</code><code class="p">,</code>
                                           <code class="s">"*.jpg"</code><code class="p">,</code>
                                           <code class="n">SearchOption</code><code class="p">.</code><code class="n">AllDirectories</code><code class="p">))</code>
<code class="p">{</code>
    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">file</code><code class="p">);</code>
<code class="p">}</code></pre></div>
<p>There is a similar <code>GetDirectories</code> method, offering the same three overloads, which returns the directories inside the specified directory instead of returning files. And there’s a <code>GetFileSystemEntries</code> method, again with the same three overloads, which returns both files and folders.</p>
<p>There are also methods called <code>EnumerateFiles</code>, <code>EnumerateDirectories</code>, and <span class="keep-together"><code>EnumerateFileSystemEntries</code></span>, which do exactly the same thing as the three <code>GetXxx</code> methods, but they return <code>IEnumerable&lt;string&gt;</code>. This is a lazy enumeration, so you can start processing results immediately instead of waiting for all the results as one big array.</p>
<p>The <code>Directory</code> class offers methods relating to the process’s current directory (the one used any time you call a file-based API without specifying the full path). 
<span class="keep-together"><code>GetCurrentDirectory</code></span> returns the path, and <code>SetCurrentDirectory</code> sets it.</p>
<p>You can create new directories too. The <code>CreateDirectory</code> method takes a path and will attempt to create as many directories as are necessary to ensure that the path exists. So, if you pass <em>C:\new\dir\here</em>, and there is no <em>C:\new</em> directory, it will create three new directories: first it will create <em>C:\new</em>, then <em>C:\new\dir</em>, and then <em>C:\new\dir\here</em>. If the folder you ask for already exists, it doesn’t treat that as an error; it just returns without doing anything.</p>
<p>The <code>GetDirectoryRoot</code> strips a directory path down to the drive name or other root, such as a network share name. For example, on Windows if you pass this <em>C:\temp\logs</em>, it will return <em>C:\</em>; and if you pass <em>\\someserver\myshare\dir\test</em>, it will return <span class="keep-together"><em>\\someserver\myshare</em></span>. This sort of string slicing, in which you split a path into its component parts, is a sufficiently common requirement that there’s a class dedicated to various operations of this kind.</p>
</div></section>
<section data-pdf-bookmark="Path Class" data-type="sect2"><div class="sect2" id="path_class">
<h2>Path Class</h2>
<p><a data-primary="files and directories" data-secondary="Path class" data-type="indexterm" id="ix_ch15-asciidoc16"/><a data-primary="Path class" data-type="indexterm" id="ix_ch15-asciidoc17"/>The static <code>Path</code> class provides useful utilities for strings containing filenames. Some extract pieces from a file path, such as the containing folder name or the file extension. Some combine strings to produce new file paths. Most of these methods just perform specialized string processing and do not require the files or directories to which the paths refer to exist. However, there are a few that go beyond string manipulation. For example, <code>Path.GetFullPath</code> will take the current directory into account if you do not pass an absolute path as the argument. But only the methods that need to make use of real locations will do so.</p>
<p>The <code>Path.Combine</code> method deals with the fiddly issues around combining folder and filenames. If you have a folder name, <em>C:\temp</em>, and a filename, <em>log.txt</em>, passing both to <code>Path.Combine</code> returns <em>C:\temp\log.txt</em>. And it will also work if you pass <em>C:\temp\</em> as the first argument, so one of the issues it deals with is working out whether it needs to supply an extra <code>\</code> character. If the second path is absolute, it detects this and simply ignores the first path, so if you pass <em>C:\temp</em> and <em>C:\logs\log.txt</em>, the result will be <em>C:\logs\log.txt</em>. Although these may seem like trivial matters, it’s surprisingly easy to get the file path combination wrong if you try to do it yourself by concatenating strings, so you should always avoid the temptation to do that and just use <code>Path.Combine</code>.</p>
<p>.NET Core and .NET have platform-specific behavior when it comes to paths. On Unix-like systems, only the <code>/</code> character is used as a directory separator, so the various methods in <code>Path</code> that expect paths to contain directories will treat only <code>/</code> as a separator on these systems. Windows uses a <code>\</code> as a separator, although it is common for <code>/</code> to be tolerated as a substitute, and <code>Path</code> follows suit. So <code>Path​.Com⁠bine("/x/y", "/z.txt")</code> will produce the same results on Windows and Linux, but <code>Path.Combine(@"\x\y", @"\z.txt")</code> will not. Also, on Windows, if a path begins with a drive letter, it is an absolute path, but Unix does not recognize drive letters. The examples in the preceding paragraph will produce strange-looking results on Linux or macOS because on those systems, all the paths will be treated as relative paths. If you remove the drive letters and replace <code>\</code> with <code>/</code>, the results will be as you’d expect.</p>
<p><a data-primary="GetDirectoryName method" data-type="indexterm" id="idm45884790168544"/>Given a file path, the <code>GetDirectoryName</code> method removes the filename part and just returns the directory. This method provides a good illustration of why you need to remember that most of the <code>Path</code> class’s members do not look at the filesystem. If you didn’t take that into account, you might expect that if you pass <code>GetDirectoryName</code> just the name of a directory such as <em>C:\Program Files</em>, it would detect that this is a directory and return the same string, but in fact it will return just <em>C:\</em>. The name <em>Program Files</em> is a perfectly good name for either a file or a directory, and since <code>GetDirectoryName</code> does not inspect the disk, and it expects to be passed a path that includes a filename, it will conclude in this case that it is a file. (Arguably, even if it were aware that <em>C:\Program Files</em> is a directory, <em>C:\</em> would be the correct result because that is the directory that contains the <em>Program Files</em> directory.) This method effectively looks for the final <code>/</code> or <code>\</code> character and returns everything before that. (So, if you pass a directory name with a trailing <code>\</code>, such as <em>C:\Program Files\</em>, it will return <em>C:\Program Files</em>. Then again, the whole point of this API is to remove the filename from a file’s full path. If you already have a string with just a directory name, you should not call this API.)</p>
<p><a data-primary="GetFileName method" data-type="indexterm" id="idm45884790159904"/>The <code>GetFileName</code> method returns just the filename (including the extension, if any). Like <code>GetDirectoryName</code>, it also looks for the last directory separator character, but it returns the text that comes after it rather than before it. Again, it does not look at the filesystem—this works purely through string manipulation (although as with all of these operations, it takes into account the local system’s rules for what counts as a directory separator or an absolute path). <code>GetFileNameWithoutExtension</code> is similar, but if an extension is present (e.g., <em>.txt</em> or <em>.jpg</em>), it removes that from the end of the name. Conversely, <code>GetExtension</code> returns the extension and nothing else.</p>
<p><a data-primary="GetRandomFileName method" data-type="indexterm" id="idm45884790156320"/>If you need to create temporary files to perform some work, <code>Path</code> provides three useful methods. <code>GetRandomFileName</code> uses a random-number generator to create a name you can use for either a random file or folder. The random number is cryptographically strong, which provides two useful properties: the name will be unique and hard to guess. (Certain kinds of attacks on a system’s security can become possible if an attacker can predict the name or location of temporary files.) This method does not actually create anything on the filesystem—it just hands back a suitable name. <code>GetTempFileName</code>, on the other hand, will create a file in the location the OS provides for temporary files. This file will be empty, and the method returns you its path as a string. You can then open the file and modify it. (This does not guarantee that cryptography will be used to pick a truly random name, so you should not depend on this sort of file’s location being unguessable. It will be unique, but that is all.) You should delete any file created by <code>GetTempFileName</code> once you have finished with it. Finally, <code>GetTempPath</code> returns the path of the folder that <code>GetTempFileName</code> would use; this doesn’t create anything, but you could use this in conjunction with a name returned by <code>GetRandomFileName</code> (combined with <code>Path.Combine</code>) to pick a location in which to create your own temporary file.<a data-startref="ix_ch15-asciidoc17" data-type="indexterm" id="idm45884790151744"/><a data-startref="ix_ch15-asciidoc16" data-type="indexterm" id="idm45884790150960"/></p>
</div></section>
<section data-pdf-bookmark="FileInfo, DirectoryInfo, and FileSystemInfo" data-type="sect2"><div class="sect2" id="fileinfo_directoryinfo_comma_and_fsi">
<h2>FileInfo, DirectoryInfo, and FileSystemInfo</h2>
<p><a data-primary="DirectoryInfo class" data-type="indexterm" id="idm45884790148704"/><a data-primary="FileInfo class" data-type="indexterm" id="idm45884790147776"/><a data-primary="files and directories" data-secondary="FileInfo, DirectoryInfo, FileSystemInfo" data-type="indexterm" id="idm45884790147104"/><a data-primary="FileSystemInfo class" data-type="indexterm" id="idm45884790146192"/>Although the <code>File</code> and <code>Folder</code> classes provide you with access to information—such as a file’s creation time and whether it is a system file or a read-only file—those classes have an issue if you need access to multiple pieces of information. It’s not very efficient to collect each bit of data with a separate call, because the information can be fetched from the underlying OS with fewer steps. Also, it can sometimes be easier to pass around a single object containing all the data you need instead of finding somewhere to put lots of separate items. So the <code>System.IO</code> namespace defines <code>FileInfo</code> and <code>DirectoryInfo</code> classes that contain the information about a file or directory. Since there’s a certain amount of common ground, these types both derive from a base class, <code>FileSystemInfo</code>.</p>
<p>To construct instances of these classes, you pass the path of the file or folder you want, as <a data-type="xref" href="#displaying_information_about_a_file_with">Example 15-16</a> shows. By the way, if sometime later you think the file may have been changed by some other program, and you want to update the information a <code>FileInfo</code> or <code>DirectoryInfo</code> returns, you can call <code>Refresh</code>, and it will reload information from the filesystem.</p>
<div data-type="example" id="displaying_information_about_a_file_with">
<h5><span class="label">Example 15-16. </span>Displaying information about a file with <code>FileInfo</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">fi</code> <code class="p">=</code> <code class="k">new</code> <code class="n">FileInfo</code><code class="p">(</code><code class="s">@"c:\temp\log.txt"</code><code class="p">);</code>
<code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code>
    <code class="err">$</code><code class="s">"{fi.FullName} ({fi.Length} bytes) last modified on {fi.LastWriteTime}"</code><code class="p">);</code></pre></div>
<p>As well as providing properties corresponding to the various <code>File</code> and <code>Directory</code> methods that fetch information (<code>CreationTime</code>, <code>Attributes,</code> etc.), these information classes provide instance methods that correspond to many of the static methods of <code>File</code> and <code>Directory</code>. For example, if you have a <code>FileInfo</code>, it provides <code>Delete</code>, <code>Encrypt</code>, and <code>Decrypt</code>—methods that work just like their <code>File</code> namesakes, except you don’t need to pass a path argument. There is also a counterpart of <code>Move</code>, although with a different name, <code>MoveTo</code>.</p>
<p><code>FileInfo</code> also provides equivalents to the various helper methods for opening the file with a <code>Stream</code> or a <code>FileStream</code>, such as <code>AppendText</code>, <code>OpenRead</code>, and <code>OpenText</code>. Perhaps more surprisingly, <code>Create</code> and <code>CreateText</code> are also available. It turns out that you can construct a <code>FileInfo</code> for a file that does not exist yet and then create it with these helpers. It doesn’t attempt to populate any of the properties that describe the file until the first time you try to read them, so it will defer throwing a <code>FileNotFound​Ex⁠ception</code> until that point, in case you were creating the <code>FileInfo</code> in order to create a new file.</p>
<p>As you’d expect, <code>DirectoryInfo</code> also offers instance methods that correspond to the various static helper methods defined by <code>Directory</code>.</p>
</div></section>
<section data-pdf-bookmark="Known Folders" data-type="sect2"><div class="sect2" id="known_folders">
<h2>Known Folders</h2>
<p><a data-primary="files and directories" data-secondary="known folders" data-type="indexterm" id="idm45884790107216"/><a data-primary="folders" data-type="indexterm" id="idm45884790106240"/>Desktop applications sometimes need to use specific folders. For example, an application’s settings will typically be stored in a certain folder under the user’s profile. There’s a separate folder for system-wide application settings. On Windows these are typically in the user’s <em>AppData</em> folder and <em>C:\ProgramData</em>, respectively. Windows also defines standard places for pictures, videos, music, and documents, and there are also folders representing special shell features, such as the desktop and the user’s “favorites.”</p>
<p>Although these folders are often in much the same place from one system to another, you should never presume that they will be where you expect. (So you should never do what <a data-type="xref" href="#recursively_searching_for_files_of_a_par">Example 15-15</a> does in real code.) Many of these folders have different names in localized versions of Windows. And even within a particular language, there’s no guarantee that these folders will be in the usual place—it’s possible to move some of them, and the locations have not remained fixed across different versions 
<span class="keep-together">of Windows.</span></p>
<p>So, if you need access to a particular standard folder, you should use the <code>Environment</code> class’s <code>GetFolderPath</code> method, as shown in <a data-type="xref" href="#discovering_where_to_store_settings">Example 15-17</a>. This takes a member from the nested <code>Environment.SpecialFolder</code> enum type, which defines values for all of the well-known folder types available in Windows.</p>
<div data-type="example" id="discovering_where_to_store_settings">
<h5><span class="label">Example 15-17. </span>Discovering where to store settings</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">string</code> <code class="n">appSettingsRoot</code> <code class="p">=</code>
    <code class="n">Environment</code><code class="p">.</code><code class="n">GetFolderPath</code><code class="p">(</code><code class="n">Environment</code><code class="p">.</code><code class="n">SpecialFolder</code><code class="p">.</code><code class="n">ApplicationData</code><code class="p">);</code>
<code class="kt">string</code> <code class="n">myAppSettingsFolder</code> <code class="p">=</code>
    <code class="n">Path</code><code class="p">.</code><code class="n">Combine</code><code class="p">(</code><code class="n">appSettingsRoot</code><code class="p">,</code> <code class="s">@"Endjin\FrobnicatorPro"</code><code class="p">);</code></pre></div>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>On non-Windows systems, <code>GetFolderPath</code> returns an empty string for most of this enumeration’s entries, because there is no local equivalent. However, a few work, such as <code>MyDocuments</code>, <code>Common​Ap⁠plicationData</code>, and <code>UserProfile</code>.</p>
</div>
<p>The <code>ApplicationData</code> folder is in the roaming section of the user’s profile. Information that does not need to be copied across all the machines a person uses (e.g., a cache that could be reconstructed if necessary) should go in the local section, which you can get with the <code>LocalApplicationData</code> enum entry.<a data-startref="ix_ch15-asciidoc11" data-type="indexterm" id="idm45884790050624"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Serialization" data-type="sect1"><div class="sect1" id="serialization-id1">
<h1>Serialization</h1>
<p><a data-primary="serialization" data-type="indexterm" id="ix_ch15-asciidoc18"/>The <code>Stream</code>, <code>TextReader</code>, and <code>TextWriter</code> types provide the ability to read and write data in files, networks, or anything else stream-like that provides a suitable concrete class. But these abstractions support only byte or text data. Suppose you have an object with several properties of various types, including some numeric types and perhaps also references to other objects, some of which might be collections. What if you wanted to write all the information in that object out to a file or over a network connection so that an object of the same type and with the same property values could be reconstituted at a later date, or on another computer at the other end of a connection?</p>
<p>You could do this with the abstractions shown in this chapter, but it would require a fair amount of work. You’d have to write code to read each property and write its value out to a <code>Stream</code> or <code>TextWriter</code>, and you’d need to convert the value to either binary or text. You’d also need to decide on your representation—would you just write values out in a fixed order, or would you come up with a scheme for writing name/value pairs so that you’re not stuck with an inflexible format if you need to add more properties later on? You’d also need to come up with ways to handle collections and references to other objects, and you’d need to decide what to do in the face of circular references—if two objects each refer to one another, naive code could end up getting stuck in an infinite loop.</p>
<p>.NET offers several solutions to this problem, each making varying trade-offs between the complexity of the scenarios they are able to support, how well they deal with versioning, and how suitable they are for interoperating with other platforms. These techniques all fall under the broad name of <em>serialization</em> (because they involve writing an object’s state into some form that stores data sequentially—serially—such as a <code>Stream</code>). Many different mechanisms have been introduced over the years in .NET, so I won’t cover all of them. I’ll just present the ones that best represent particular approaches to the problem.</p>
<section data-pdf-bookmark="BinaryReader, BinaryWriter, and BinaryPrimitives" data-type="sect2"><div class="sect2" id="binaryreader_and_binarywriter">
<h2>BinaryReader, BinaryWriter, and BinaryPrimitives</h2>
<p><a data-primary="BinaryReader class" data-type="indexterm" id="idm45884790040912"/><a data-primary="BinaryWriter class" data-type="indexterm" id="idm45884790039984"/><a data-primary="serialization" data-secondary="BinaryReader, BinaryWriter, BinaryPrimitives" data-type="indexterm" id="idm45884790039312"/>Although they are not strictly forms of serialization, no discussion of this area is complete without covering the <code>BinaryReader</code> and <code>BinaryWriter</code> classes, because they solve a fundamental problem that any attempt to serialize and deserialize objects must deal with: they can convert the CLR’s intrinsic types to and from streams of bytes. <code>BinaryPrimitives</code> does the same thing, but it is able to work with <code>Span&lt;byte&gt;</code> and related types, which are discussed in <a data-type="xref" href="ch18.xhtml#ch_memory_efficiency">Chapter 18</a>.</p>
<p><code>BinaryWriter</code> is a wrapper around a writable <code>Stream</code>. It provides a <code>Write</code> method that has overloads for all of the intrinsic types except for <code>object</code>. So it can take a value of any of the numeric types, or the <code>string</code>, <code>char</code>, or <code>bool</code> types, and it writes a binary representation of that value into a <code>Stream</code>. It can also write arrays of type <code>byte</code> or <code>char</code>.</p>
<p><code>BinaryReader</code> is a wrapper around a readable <code>Stream</code>, and it provides various methods for reading data, each corresponding to the overloads of <code>Write</code> provided by <code>BinaryWriter</code>. For example, you have <code>ReadDouble</code>, <code>ReadInt32</code>, and <code>ReadString</code>.</p>
<p>To use these types, you would create a <code>BinaryWriter</code> when you want to serialize some data, and write out each value you wish to store. When you later want to deserialize that data, you’d wrap a <code>BinaryReader</code> around a stream containing the data written with the writer, and call the relevant read methods in the exact same order that you wrote the data out in the first place.</p>
<p><a data-primary="BinaryPrimitives class" data-type="indexterm" id="idm45884789995024"/><code>BinaryPrimitives</code> works slightly differently. It is designed for code that needs to minimize the number of heap allocations, so it’s not a wrapper type—it is a static class offering a wide range of methods, such as <code>ReadInt32LittleEndian</code> and <code>WriteUInt16BigEndian</code>. These take <code>ReadOnlySpan&lt;byte&gt;</code> and <code>Span&lt;byte&gt;</code> arguments, respectively, because it is designed to work directly with data wherever it may lie in memory (not necessarily wrapped in a <code>Stream</code>). However, the basic principle is the same: it converts between byte sequences and primitive .NET types. (Also, string handling is rather more complex: there’s no <code>ReadString</code> method because anything that returns a <code>string</code> will create a new string object on the heap, unless there’s a fixed set of possible strings that you can preallocate and hand out again and again. See <a data-type="xref" href="ch18.xhtml#ch_memory_efficiency">Chapter 18</a> for details.)</p>
<p>These classes only solve the problem of how to represent various built-in types in binary. You are still left with the task of working out how to represent whole objects and what to do about more complex kinds of structures such as references between objects.</p>
</div></section>
<section data-pdf-bookmark="CLR Serialization" data-type="sect2"><div class="sect2" id="clr_serialization">
<h2>CLR Serialization</h2>
<p><a data-primary="CLR (Common Language Runtime)" data-secondary="serialization" data-type="indexterm" id="ix_ch15-asciidoc19"/><a data-primary="serialization" data-secondary="CLR serialization" data-type="indexterm" id="ix_ch15-asciidoc20"/>CLR serialization is, as the name suggests, a feature built into the runtime itself—it is not simply a library feature. Although it has been in .NET Framework since v1.0, it was not supported in .NET Core for the first few versions, but Microsoft eventually added it back in a somewhat reduced form to make it easier to migrate applications from .NET Framework. Microsoft discourages its use, but it continues to be popular in certain scenarios. It is fairly widely used in microservice environments for sending exceptions and relatively straightforward data structures across service boundaries. The limited support that .NET Core and .NET provide is aimed at these scenarios, so you cannot serialize just any old .NET object.</p>
<p>The most interesting aspect of CLR serialization is that it deals directly with object references. If you serialize, say, a <code>List&lt;SomeType&gt;</code> where multiple entries in the list refer to the same object, CLR serialization will detect this, storing just one copy of that object, and when deserializing, it will re-create that one-object-many-references structure. (Serialization systems based on the very widely used JSON format normally don’t do this.)</p>
<p>Types are required to opt into CLR serialization. .NET defines a <code>[Serializable]</code> attribute that must be present, and once you’ve added this, the CLR can take care of all of the details for you. Serialization works directly with an object’s fields. It uses reflection, which enables it to access all of them, whether public or private. <a data-primary="BinaryFormatter type" data-type="indexterm" id="idm45884789982640"/>The <code>BinaryFormatter</code> type (which is in the <code>System.Runtime.Serialization.Format⁠ters​.Binary</code> namespace) provides a <code>Serialize</code> method that will write an instance of any serializable type to a stream.  It correctly detects circular references, storing just one copy of each object in the stream, and when we pass the resulting stream back into the <code>Deserialize</code> method, it will restore any such structure correctly.</p>
<p>So this is pretty powerful—by adding a single attribute, I can write out a complete graph of objects. There is a downside: if I change the implementation of any of the types being serialized, I will be in trouble if a new version of my code attempts to deserialize a stream produced by an old version. So this is not a good choice for writing out an application’s settings to disk, because those are likely to evolve with each new version. As it happens, you can customize the way serialization works, which does make it possible to support versioning, but at that point, you’re back to doing a lot of the work by hand. (It may actually be easier to use <code>BinaryReader</code> and <code>BinaryWriter</code>.) Also, it’s easy to introduce security problems with this style of serialization: someone who controls a stream that you deserialize essentially has complete control over all the fields of your objects. The documentation states that <code>BinaryFormatter</code> “is insecure and can’t be made secure,” and you will see deprecation warnings when you attempt to use it. So I’m only describing CLR serialization here because it still gets used despite Microsoft’s attempts to end it, and also because its existence means that an assumption you might otherwise have made about object creation—specifically that a reference type can only be created through one of its constructors or via <code>MemberwiseClone</code>—turns out not be true.</p>
<p>Another issue with CLR serialization is that it produces binary streams in a .NET-specific format. If the only code that needs to deal with the stream is running .NET, then that’s not a problem, but you might want to produce streams for a broader audience. There are other serialization mechanisms than CLR serialization, and these can produce streams that may be easier for other systems to consume.<a data-startref="ix_ch15-asciidoc20" data-type="indexterm" id="idm45884789976928"/><a data-startref="ix_ch15-asciidoc19" data-type="indexterm" id="idm45884789976224"/></p>
</div></section>
<section data-pdf-bookmark="JSON" data-type="sect2"><div class="sect2" id="json_serialization">
<h2>JSON</h2>
<p><a data-primary="JSON" data-type="indexterm" id="ix_ch15-asciidoc21"/><a data-primary="serialization" data-secondary="JSON" data-type="indexterm" id="ix_ch15-asciidoc22"/>The JavaScript Object Notation, JSON, is a very widely used serialization format, and the .NET runtime libraries provide support for working with it in the 
<span class="keep-together"><code>System.Text.Json</code></span> namespace.<sup><a data-type="noteref" href="ch15.xhtml#idm45884789970704" id="idm45884789970704-marker">6</a></sup> It provides three ways of working with JSON data.</p>
<p>The <code>Utf8JsonReader</code> and <code>Utf8JsonWriter</code> types are stream-like abstractions that represent the contents of JSON data as a sequence of elements. These can be useful if you need to process JSON documents that are too large to load into memory as a single object. They are built on the memory-efficient mechanisms described in <a data-type="xref" href="ch18.xhtml#ch_memory_efficiency">Chapter 18</a>, which includes a full example showing how to process JSON with these types. This is a very high-performance option, but it is not the easiest to use.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>As the names suggest, these types read and write JSON using UTF-8 encoding. This is by far the most widely used encoding for sending and storing JSON, so all of <code>System.Text.Json</code> is optimized for it. Because of this, performance-sensitive code should typically avoid ever obtaining a JSON document as a .NET <code>string</code>, because that uses UTF-16 encoding and will require conversion to UTF-8 before you can work with these APIs.</p>
</div>
<p>There’s also the <code>JsonSerializer</code> class, which converts between entire .NET objects and JSON. It requires you to define classes with a structure corresponding to the JSON.</p>
<p>Finally, <code>System.Text.Json</code> offers types that can provide a description of a JSON document’s structure. These are useful when you do not know at development time exactly what the structure of your JSON data will be, because they provide a flexible object model that can adapt to any shape of JSON data. In fact, there are two variations on this approach. We have <code>JsonDocument</code>, <code>JsonElement</code>, and related types, which provide a highly efficient read-only mechanism for inspecting a JSON document, and the more flexible but slightly less efficient <code>JsonNode</code>, which is writable, enabling you either to build up a description of JSON from scratch or to read in some JSON and then modify it.</p>
<section data-pdf-bookmark="JsonSerializer" data-type="sect3"><div class="sect3" id="jsonserializer">
<h3>JsonSerializer</h3>
<p><a data-primary="System.Text.Json" data-secondary="JsonSerializer" data-type="indexterm" id="ix_ch15-asciidoc25"/><a data-primary="JsonSerializer" data-type="indexterm" id="ix_ch15-asciidoc26"/><code>JsonSerializer</code> offers an attribute-driven serialization model in which you define one or more classes mirroring the structure of the JSON data you need to deal with, and can then convert JSON data to and from that model.</p>
<p><a data-type="xref" href="#json_model">Example 15-18</a> shows a simple model suitable for use with <code>JsonSerializer</code>. As you can see, I’m not required to use any particular base class, and there are no mandatory attributes.</p>
<div data-type="example" id="json_model">
<h5><span class="label">Example 15-18. </span>Simple JSON serialization model</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">SimpleData</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="kt">int</code> <code class="n">Id</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
    <code class="k">public</code> <code class="n">IList</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;?</code> <code class="n">Names</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
    <code class="k">public</code> <code class="n">NestedData</code><code class="p">?</code> <code class="n">Location</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
    <code class="k">public</code> <code class="n">IDictionary</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="kt">int</code><code class="p">&gt;?</code> <code class="n">Map</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">NestedData</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="kt">string?</code> <code class="n">LocationName</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
    <code class="k">public</code> <code class="kt">double</code> <code class="n">Latitude</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
    <code class="k">public</code> <code class="kt">double</code> <code class="n">Longitude</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code></pre></div>
<p><a data-type="xref" href="#jsonserializer_serialize">Example 15-19</a> creates an instance of this model and then uses the <code>JsonConvert</code> class’s <code>Serialize</code> method to serialize it to a string.</p>
<div data-type="example" id="jsonserializer_serialize">
<h5><span class="label">Example 15-19. </span>Serializing data with <code>JsonSerializer</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">model</code> <code class="p">=</code> <code class="k">new</code> <code class="n">SimpleData</code>
<code class="p">{</code>
    <code class="n">Id</code> <code class="p">=</code> <code class="m">42</code><code class="p">,</code>
    <code class="n">Names</code> <code class="p">=</code> <code class="k">new</code><code class="p">[]</code> <code class="p">{</code> <code class="s">"Bell"</code><code class="p">,</code> <code class="s">"Stacey"</code><code class="p">,</code> <code class="s">"her"</code><code class="p">,</code> <code class="s">"Jane"</code> <code class="p">},</code>
    <code class="n">Location</code> <code class="p">=</code> <code class="k">new</code> <code class="n">NestedData</code>
    <code class="p">{</code>
        <code class="n">LocationName</code> <code class="p">=</code> <code class="s">"London"</code><code class="p">,</code>
        <code class="n">Latitude</code> <code class="p">=</code> <code class="m">51.503209</code><code class="p">,</code>
        <code class="n">Longitude</code> <code class="p">=</code> <code class="p">-</code><code class="m">0.119145</code>
    <code class="p">},</code>
    <code class="n">Map</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Dictionary</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="kt">int</code><code class="p">&gt;</code>
    <code class="p">{</code>
        <code class="p">{</code> <code class="s">"Answer"</code><code class="p">,</code> <code class="m">42</code> <code class="p">},</code>
        <code class="p">{</code> <code class="s">"FirstPrime"</code><code class="p">,</code> <code class="m">2</code> <code class="p">}</code>
    <code class="p">}</code>
<code class="p">};</code>

<code class="kt">string</code> <code class="n">json</code> <code class="p">=</code> <code class="n">JsonSerializer</code><code class="p">.</code><code class="n">Serialize</code><code class="p">(</code>
    <code class="n">model</code><code class="p">,</code>
    <code class="k">new</code> <code class="n">JsonSerializerOptions</code> <code class="p">{</code> <code class="n">WriteIndented</code> <code class="p">=</code> <code class="k">true</code> <code class="p">});</code>
<code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">json</code><code class="p">);</code></pre></div>
<p>The second argument to <code>Serialize</code> is optional. I’ve used it here to indent the JSON to make it easier to read. (By default, <code>JsonSerializer</code> will use a more efficient layout with no unnecessary whitespace, but that is much harder to read.) The results look like this:</p>
<pre data-type="programlisting">{
  "Id": 42,
  "Names": [
    "Bell",
    "Stacey",
    "her",
    "Jane"
  ],
  "Location": {
    "LocationName": "London",
    "Latitude": 51.503209,
    "Longitude": -0.119145
  },
  "Map": {
    "Answer": 42,
    "FirstPrime": 2
  }
}</pre>
<p>As you can see, each .NET object has become a JSON object, where the name/value pairs correspond to properties in my model. Numbers and strings are represented exactly as you would expect. The <code>IList&lt;string&gt;</code> has become a JSON array, and the <code>IDictionary&lt;string, int&gt;</code> has become another JSON dictionary. I’ve used interfaces for these collections, but you can also use the concrete <code>List&lt;T&gt;</code> and <code>Dictio⁠nary​&lt;TKey,TValue&gt;</code> types. You can use ordinary arrays to represent lists if you prefer. I tend to prefer the interfaces because it leaves you free to use whatever collection types you want. (E.g., <a data-type="xref" href="#jsonserializer_serialize">Example 15-19</a> initialized the <code>Names</code> property with a string array, but it could also have used <code>List&lt;string&gt;</code> without changing the model type.)</p>
<p>Converting serialized JSON back into the model is equally straightforward, as <a data-type="xref" href="#json_convert_deserialize">Example 15-20</a> shows.</p>
<div data-type="example" id="json_convert_deserialize">
<h5><span class="label">Example 15-20. </span>Deserializing data with <code>JsonSerializer</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">deserialized</code> <code class="p">=</code> <code class="n">JsonSerializer</code><code class="p">.</code><code class="n">Deserialize</code><code class="p">&lt;</code><code class="n">SimpleData</code><code class="p">&gt;(</code><code class="n">json</code><code class="p">);</code></pre></div>
<p>Although a plain and simple model such as this will often suffice, sometimes you may need to take control over some aspects of serialization, particularly if you are working with an externally defined JSON format. For example, you might need to work with a JSON API that uses naming conventions that are different from .NET’s—camelCasing is popular but conflicts with the PascalCasing convention for .NET properties. One way to resolve this to use the <code>JsonPropertyName</code> attribute to specify the name to use in the JSON, as <a data-type="xref" href="#json_property_attribute">Example 15-21</a> shows.</p>
<div data-type="example" id="json_property_attribute">
<h5><span class="label">Example 15-21. </span>Controlling the JSON with <code>JsonPropertyName</code> attributes</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">NestedData</code>
<code class="p">{</code>
<code class="na">    [JsonPropertyName("locationName")]</code>
    <code class="k">public</code> <code class="kt">string?</code> <code class="n">LocationName</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>

<code class="na">    [JsonPropertyName("latitude")]</code>
    <code class="k">public</code> <code class="kt">double</code> <code class="n">Latitude</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>

<code class="na">    [JsonPropertyName("longitude")]</code>
    <code class="k">public</code> <code class="kt">double</code> <code class="n">Longitude</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code></pre></div>
<p><code>JsonSerializer</code> will use the names specified in <code>JsonPropertyName</code> when serializing and will look for those names when deserializing. This approach gives us complete control over the .NET and JSON property names, but there is a simpler solution for this particular scenario. This kind of renaming that just changes the case of the first letter is so common that you can get <code>JsonSerializer</code> to do it for you. The <code>JsonSerializationOptions</code> passed to <code>JsonSerializer.Serialize</code> takes an optional constructor argument of type <code>JsonSerializerDefaults</code>, and if you pass <code>Json​Seri⁠ali⁠zerDefaults.Web</code>, as <a data-type="xref" href="#jsonserializer_with_web_defaults">Example 15-22</a> does, you will get the camelCasing style without needing to use any attributes.</p>
<div data-type="example" id="jsonserializer_with_web_defaults">
<h5><span class="label">Example 15-22. </span>Using <code>JsonSerializerDefaults</code> to get camelCased property names</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">options</code> <code class="p">=</code> <code class="k">new</code> <code class="n">JsonSerializerOptions</code><code class="p">(</code><code class="n">JsonSerializerDefaults</code><code class="p">.</code><code class="n">Web</code><code class="p">)</code>
<code class="p">{</code>
    <code class="n">WriteIndented</code> <code class="p">=</code> <code class="k">true</code>
<code class="p">};</code>
<code class="kt">string</code> <code class="n">json</code> <code class="p">=</code> <code class="n">JsonSerializer</code><code class="p">.</code><code class="n">Serialize</code><code class="p">(</code>
    <code class="n">model</code><code class="p">,</code>
    <code class="n">options</code><code class="p">);</code></pre></div>
<p>The <code>JsonSerializerOptions</code> also provide a way to handle circular references. Suppose you want to serialize objects of type <code>SelfRef</code>, as shown in <a data-type="xref" href="#self_referential_type">Example 15-23</a>.</p>
<div data-type="example" id="self_referential_type">
<h5><span class="label">Example 15-23. </span>A type supporting circular references</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">SelfRef</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="kt">string?</code> <code class="n">Name</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
    <code class="k">public</code> <code class="n">SelfRef</code><code class="p">?</code> <code class="n">Next</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>By default, if you attempt to serialize objects that refer to one another either directly or indirectly, you’ll get a <code>JsonException</code> reporting a possible cycle. It says “possible” because it doesn’t directly detect cycles by default—instead, <code>JsonSerializer</code> has a limit on the depth of any object graph that it will serialize. This is configurable through the <code>JsonSerializerOptions.MaxDepth</code> property, but by default the serializer will report an error if it has to go more than 64 objects deep. However, you can set the <code>ReferenceHandler</code> to change the behavior. <a data-type="xref" href="#serializing_circular_references">Example 15-24</a> sets this to <code>ReferenceHandler.Preserve</code>, enabling it to serialize a pair of <code>SelfRef</code> instances that refer to each other.</p>
<div data-type="example" id="serializing_circular_references">
<h5><span class="label">Example 15-24. </span>Serializing a type supporting circular references</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">options</code> <code class="p">=</code> <code class="k">new</code> <code class="n">JsonSerializerOptions</code><code class="p">(</code><code class="n">JsonSerializerDefaults</code><code class="p">.</code><code class="n">Web</code><code class="p">)</code>
<code class="p">{</code>
    <code class="n">WriteIndented</code> <code class="p">=</code> <code class="k">true</code><code class="p">,</code>
    <code class="n">ReferenceHandler</code> <code class="p">=</code> <code class="n">ReferenceHandler</code><code class="p">.</code><code class="n">Preserve</code>
<code class="p">};</code>
<code class="kt">var</code> <code class="n">circle</code> <code class="p">=</code> <code class="k">new</code> <code class="n">SelfRef</code>
<code class="p">{</code>
    <code class="n">Name</code> <code class="p">=</code> <code class="s">"Top"</code><code class="p">,</code>
    <code class="n">Next</code> <code class="p">=</code> <code class="k">new</code> <code class="n">SelfRef</code>
    <code class="p">{</code>
        <code class="n">Name</code> <code class="p">=</code> <code class="s">"Bottom"</code><code class="p">,</code>
    <code class="p">}</code>
<code class="p">};</code>
<code class="n">circle</code><code class="p">.</code><code class="n">Next</code><code class="p">.</code><code class="n">Next</code> <code class="p">=</code> <code class="n">circle</code><code class="p">;</code>
<code class="kt">string</code> <code class="n">json</code> <code class="p">=</code> <code class="n">JsonSerializer</code><code class="p">.</code><code class="n">Serialize</code><code class="p">(</code><code class="n">circle</code><code class="p">,</code> <code class="n">options</code><code class="p">);</code></pre></div>
<p>To enable this, the <code>JsonSerializer</code> gives objects identifiers by adding an <code>$id</code>
<span class="keep-together">property:</span></p>
<pre data-type="programlisting">{
  "$id": "1",
  "name": "Top",
  "next": {
    "$id": "2",
    "name": "Bottom",
    "next": {
      "$ref": "1"
    }
  }
}</pre>
<p>This enables the serializer to avoid problems when it encounters a circular reference. Whenever it has to serialize a property, it checks to see whether that refers to some object that has already been written out (or is in the process of being written out). If it does, then instead of attempting to write out the object again (which would cause an infinite loop, since it’ll just encounter the circular reference again and again), the serializer emits a JSON object containing a property with the special name <code>$ref</code> referring back to the relevant <code>$id</code>. This is not a universally supported form of JSON, which is why ID generation is not enabled by default.</p>
<p>You can control many other aspects of serialization with <code>JsonSerializerOptions</code>—you can define custom serialization mechanisms for data types, for example. (E.g., you might want to represent something as a <code>DateTimeOffset</code> in your C# code but have that become a string with a particular date-time format in the JSON.) The full details can be found in the <code>System.Text.Json</code> documentation.<a data-startref="ix_ch15-asciidoc26" data-type="indexterm" id="idm45884789331488"/><a data-startref="ix_ch15-asciidoc25" data-type="indexterm" id="idm45884789330752"/></p>
</div></section>
<section data-pdf-bookmark="JSON DOM" data-type="sect3"><div class="sect3" id="json_dom">
<h3>JSON DOM</h3>
<p><a data-primary="System.Text.Json" data-secondary="JSON DOM" data-type="indexterm" id="ix_ch15-asciidoc23"/><a data-primary="JSON DOM" data-type="indexterm" id="ix_ch15-asciidoc24"/>Whereas <code>JsonSerializer</code> requires you to define one or more types representing the structure of the JSON you want to work with, <code>System.Text.Json</code> provides a fixed set of types that enable a more dynamic approach. You can build a Document Object Model (DOM) in which instances of types such as <code>JsonElement</code> or <code>JsonNode</code> represent the structure of the JSON.</p>
<p><code>System.Text.Json</code> provides two ways to build a DOM. If you have data already in JSON form, you can use the <code>JsonDocument</code> class to obtain a read-only model of the JSON, in which each object, value, and array is represented as a <code>JsonElement</code>, and each property in an object is represented as a <code>JsonProperty</code>. <a data-type="xref" href="#dynamic_json_inspection">Example 15-25</a> uses <code>JsonDocument</code> to discover all of the properties in the object at the root of the JSON by calling <code>RootElement.EnumerateObject()</code> on the <code>JsonDocument</code>. This returns a collection of <code>JsonProperty</code> structs.</p>
<div data-type="example" id="dynamic_json_inspection">
<h5><span class="label">Example 15-25. </span>Dynamic JSON inspection with <code>JsonDocument</code> and <code>JsonElement</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">using</code> <code class="p">(</code><code class="n">JsonDocument</code> <code class="n">document</code> <code class="p">=</code> <code class="n">JsonDocument</code><code class="p">.</code><code class="n">Parse</code><code class="p">(</code><code class="n">json</code><code class="p">))</code>
<code class="p">{</code>
    <code class="k">foreach</code> <code class="p">(</code><code class="n">JsonProperty</code> <code class="n">property</code> <code class="k">in</code> <code class="n">document</code><code class="p">.</code><code class="n">RootElement</code><code class="p">.</code><code class="n">EnumerateObject</code><code class="p">())</code>
    <code class="p">{</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"Property: {property.Name} ({property.Value.ValueKind})"</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>Running this on the serialized document produced by earlier examples produces this output:</p>
<pre data-type="programlisting">Property: id (Number)
Property: names (Array)
Property: location (Object)
Property: map (Object)</pre>
<p>As this shows, we are able to discover at runtime what properties exist. The <code>JsonProperty.Value</code> returns a <code>JsonElement</code> struct, and we can inspect its <code>ValueKind</code> to discover which sort of JSON value it is. If it’s an array, we can enumerate its contents by calling <code>EnumerateArray</code>, and if it’s a string value, we can read its value by calling <code>GetString</code>. <a data-type="xref" href="#dynamic_json_array_inspection">Example 15-26</a> uses these methods to show all the strings in the <code>names</code> property.</p>
<div data-type="example" id="dynamic_json_array_inspection">
<h5><span class="label">Example 15-26. </span>Dynamic JSON array enumeration with <code>JsonDocument</code> and 
<span class="keep-together"><code>JsonElement</code></span></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">JsonElement</code> <code class="n">namesElement</code> <code class="p">=</code> <code class="n">document</code><code class="p">.</code><code class="n">RootElement</code><code class="p">.</code><code class="n">GetProperty</code><code class="p">(</code><code class="s">"names"</code><code class="p">);</code>
<code class="k">foreach</code> <code class="p">(</code><code class="n">JsonElement</code> <code class="n">name</code> <code class="k">in</code> <code class="n">namesElement</code><code class="p">.</code><code class="n">EnumerateArray</code><code class="p">())</code>
<code class="p">{</code>
    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"Name: {name.GetString()}"</code><code class="p">);</code>
<code class="p">}</code></pre></div>
<p>As this example also shows, if you know in advance that a particular property will be present, you don’t need to use <code>EnumerateObject</code> to find it: you can call <code>GetProperty</code>. There’s also a <code>TryGetProperty</code> for when the property is optional. <a data-type="xref" href="#dynamic_json_read_properties">Example 15-27</a> uses both: this treats the root object’s <code>location</code> property as optional, but if it is present, it then requires the <code>locationName</code>, <code>latitude</code>, and <code>longitude</code> properties to be present.</p>
<div data-type="example" id="dynamic_json_read_properties">
<h5><span class="label">Example 15-27. </span>Reading JSON properties with <code>JsonElement</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">if</code> <code class="p">(</code><code class="n">root</code><code class="p">.</code><code class="n">TryGetProperty</code><code class="p">(</code><code class="s">"location"</code><code class="p">,</code> <code class="k">out</code> <code class="n">JsonElement</code> <code class="n">locationElement</code><code class="p">))</code>
<code class="p">{</code>
    <code class="n">JsonElement</code> <code class="n">nameElement</code> <code class="p">=</code> <code class="n">locationElement</code><code class="p">.</code><code class="n">GetProperty</code><code class="p">(</code><code class="s">"locationName"</code><code class="p">);</code>
    <code class="n">JsonElement</code> <code class="n">latitudeElement</code> <code class="p">=</code> <code class="n">locationElement</code><code class="p">.</code><code class="n">GetProperty</code><code class="p">(</code><code class="s">"latitude"</code><code class="p">);</code>
    <code class="n">JsonElement</code> <code class="n">longitudeElement</code> <code class="p">=</code> <code class="n">locationElement</code><code class="p">.</code><code class="n">GetProperty</code><code class="p">(</code><code class="s">"longitude"</code><code class="p">);</code>
    <code class="kt">string</code> <code class="n">locationName</code> <code class="p">=</code> <code class="n">nameElement</code><code class="p">.</code><code class="n">GetString</code><code class="p">()!;</code>
    <code class="kt">double</code> <code class="n">latitude</code> <code class="p">=</code> <code class="n">latitudeElement</code><code class="p">.</code><code class="n">GetDouble</code><code class="p">();</code>
    <code class="kt">double</code> <code class="n">longitude</code> <code class="p">=</code> <code class="n">longitudeElement</code><code class="p">.</code><code class="n">GetDouble</code><code class="p">();</code>
    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"Location: {locationName}: {latitude},{longitude}"</code><code class="p">);</code>
<code class="p">}</code></pre></div>
<p>In addition to structural elements, objects and arrays, the data model in the <a href="https://oreil.ly/T1Qoe">JSON specification</a> recognizes four basic data types: strings, numbers, Booleans, and null. As you’ve seen, you can discover which of these any particular <code>JsonElement</code> represents with its <code>Kind</code> property. If it’s one of the basic data types, you can use a suitable <code>Get</code> method. The last two examples both used <code>GetString</code>, and the second also used <code>GetDouble</code>. There are multiple methods you can use to retrieve a number: if you are expecting an integer, you can call <code>GetSByte</code>, <code>GetInt16</code>, <code>GetInt32</code>, or <code>GetInt64</code> (and unsigned versions are also available) depending on what range of values you are expecting. There’s also <code>GetDecimal</code>.</p>
<p><code>JsonElement</code> also offers methods for reading string properties in particular formats: <code>GetGuid</code>, <code>GetDateTime</code>, <code>GetDateTimeOffset</code>, and <code>GetBytesFromBase64</code>.</p>
<p>All of the <code>Get</code> methods will throw an <code>InvalidOperationException</code> if the value is not in the required format. Each of them is also available in a <code>TryGet</code> form, enabling you to detect when the data cannot be parsed in the expected way without having to trigger an exception.</p>
<p>These types attempt to minimize the amount of memory allocated. <code>JsonElement</code> and <code>JsonProperty</code> are both structs, so you can obtain these without causing additional heap allocations. The underlying data is held in UTF-8 format by the <code>JsonDocument</code>, and the <code>JsonElement</code> and <code>JsonProperty</code> instances just refer back to that, avoiding the need to allocate copies of the relevant data. Obviously, the underlying data does need to live somewhere, and depending on exactly how you loaded the JSON into a <code>JsonDocument</code>, it may have to allocate some memory to hold it. (E.g., you can pass it a <code>Stream</code>, and since not all streams are rewindable, <code>JsonDocument</code> would need to make a copy of the stream’s contents.) <code>JsonDocument</code> uses the buffer pooling features available in the .NET runtime libraries to manage this data, meaning that if an application parses many JSON documents, it may be able to reuse memory, reducing pressure on the garbage collector (GC). But this means the <code>JsonDocument</code> needs to know when you’ve finished with the JSON so that it can return buffers to the pool. That’s why we use a <code>using</code> statement when working with a <code>JsonDocument</code>.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Be aware that <code>JsonElement.GetString</code> is more expensive than all the other <code>Get</code> methods, because it has to create a new .NET string on the heap. The other <code>Get</code> methods all return value types, so they do not cause heap allocations.</p>
</div>
<p>I mentioned earlier that there are two ways of working with a JSON DOM. 
<span class="keep-together"><code>JsonDocument</code></span> provides a read-only model that lets you inspect existing JSON. But there is also <code>JsonNode</code>, which is read/write. You can use this in a couple of ways that <code>JsonDocument</code> does not support. You can build up an object model from scratch to create a new JSON document. Alternatively, you can parse existing JSON into an object model just like with <code>JsonDocument</code>, but when you use <code>JsonNode</code>, the resulting model is modifiable. So you could use it to load some JSON and modify it, as <a data-type="xref" href="#dynamic_json_modification">Example 15-28</a> illustrates.</p>
<div data-type="example" id="dynamic_json_modification">
<h5><span class="label">Example 15-28. </span>Modifying JSON with <code>JsonNode</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">JsonNode</code> <code class="n">rootNode</code> <code class="p">=</code> <code class="n">JsonNode</code><code class="p">.</code><code class="n">Parse</code><code class="p">(</code><code class="n">json</code><code class="p">)!;</code>
<code class="n">JsonNode</code> <code class="n">mapNode</code> <code class="p">=</code> <code class="n">rootNode</code><code class="p">[</code><code class="s">"map"</code><code class="p">]!;</code>
<code class="n">mapNode</code><code class="p">[</code><code class="s">"iceCream"</code><code class="p">]</code> <code class="p">=</code> <code class="m">99</code><code class="p">;</code></pre></div>
<p>This loads the JSON text in <code>json</code> into a <code>JsonNode</code> and then retrieves the <code>map</code> property. (This example expects to work with JSON in the same form as I’ve used in the preceding examples, with camelCased property names.) So far this doesn’t do anything we couldn’t do with <code>JsonDocument</code>. But the final line adds a new entry to the object in <code>map</code>. It’s this ability to modify the document that makes <code>JsonNode</code> more powerful. So why do we need <code>JsonDocument</code> if <code>JsonNode</code> is more powerful? The power comes at a price: <code>JsonNode</code> is less efficient, so if you don’t need the extra flexibility, you shouldn’t use it.</p>
<p>The main advantage of using either the read-only <code>JsonDocument</code> and <code>JsonElement</code> or the writable <code>JsonNode</code> is that you don’t need to define any types to model the data. They also make it easier to write code whose behavior is driven by the structure of the data, because these APIs are able to describe what they find. The read-only form is typically more efficient than <code>JsonSerializer</code>, because it may enable you to cause fewer object allocations when reading data from a JSON document<a data-startref="ix_ch15-asciidoc24" data-type="indexterm" id="idm45884789017488"/><a data-startref="ix_ch15-asciidoc23" data-type="indexterm" id="idm45884789016784"/><a data-startref="ix_ch15-asciidoc22" data-type="indexterm" id="idm45884789016112"/><a data-startref="ix_ch15-asciidoc21" data-type="indexterm" id="idm45884789015440"/>.<a data-startref="ix_ch15-asciidoc18" data-type="indexterm" id="idm45884789014640"/></p>
</div></section>
</div></section>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="summary-files-and-streams">
<h1>Summary</h1>
<p>The <code>Stream</code> class is an abstraction representing data as a sequence of bytes. A stream can support reading, writing, or both, and may support seeking to arbitrary offsets as well as straightforward sequential access. <code>TextReader</code> and <code>TextWriter</code> provide strictly sequential reading and writing of character data, abstracting away the character encoding. These types may sit on top of a file, a network connection, or memory, or you could implement your own versions of these abstract classes. The <code>FileStream</code> class also provides some other filesystem access features, but for full control, we also have the <code>File</code> and <code>Directory</code> classes. When bytes and strings aren’t enough, .NET offers various serialization mechanisms that can automate the mapping between an object’s state in memory and a representation that can be written out to disk or sent over the network or any other stream-like target; this representation can later be turned back into an object of the same type and with equivalent state.</p>
<p>As you’ve seen, a few of the file and stream APIs offer asynchronous forms that can help improve performance, particularly in highly concurrent systems. The next chapter tackles concurrency, parallelism, and the task-based pattern that the asynchronous forms of these APIs use.</p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="CHP-16-FN-2"><sup><a href="ch15.xhtml#CHP-16-FN-2-marker">1</a></sup> You might have thought that the pound sign was #, but if, like me, you’re British, that’s just not on. It would be like someone insisting on referring to @ as a dollar sign. Unicode’s canonical name for # is <em>number sign</em>, and it also allows my preferred option, <em>hash</em>, as well as <em>octothorpe</em>, <em>crosshatch</em>, and, regrettably, <em>pound sign</em>.</p><p data-type="footnote" id="CHP-16-FN-3"><sup><a href="ch15.xhtml#CHP-16-FN-3-marker">2</a></sup> Just in case you’ve not come across the term, in <em>little-endian</em> representations, multibyte values start with the lower-order bytes, so the value 0x1234 in 16-bit little-endian would be 0x34, 0x12, whereas the big-endian version would be 0x12, 0x34. Little-endian looks reversed, but it’s the native format for Intel’s processors.</p><p data-type="footnote" id="idm45884790912256"><sup><a href="ch15.xhtml#idm45884790912256-marker">3</a></sup> Some Unicode characters can take up to 4 bytes in UTF-8, so multiplying by three might seem like it could underestimate. However, all such characters require two code units in UTF-16. Any single <code>char</code> in .NET will never require more than 3 bytes in UTF-8.</p><p data-type="footnote" id="CHP-16-FN-4"><sup><a href="ch15.xhtml#CHP-16-FN-4-marker">4</a></sup> Four overloads became obsolete when .NET 2.0 introduced a new way of representing OS handles. The overloads that accept an <code>IntPtr</code> were deprecated at that point, replaced by new ones taking a <code>SafeFileHandle</code>.</p><p data-type="footnote" id="CHP-16-FN-5"><sup><a href="ch15.xhtml#CHP-16-FN-5-marker">5</a></sup> These all return a <code>DateTime</code> that is relative to the computer’s current time zone. Each of these methods has an equivalent that returns the time relative to time zone zero (e.g., <code>GetCreationTimeUtc</code>).</p><p data-type="footnote" id="idm45884789970704"><sup><a href="ch15.xhtml#idm45884789970704-marker">6</a></sup> This is not available on .NET Framework. There, the open source JSON.NET project, available on the <a href="https://oreil.ly/LpJfk">Newtonsoft website</a> or via NuGet as <code>Newtonsoft.Json</code>, is a popular choice.</p></div></div></section></div></body></html>