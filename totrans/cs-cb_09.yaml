- en: Chapter 9\. Examining Recent C# Language Highlights
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 检视最近的C#语言亮点
- en: The C# programming language is continually evolving. Earlier chapters discussed
    subjects from C# 1 through C# 8\. The exception is pattern matching in [Chapter 8](ch08.xhtml#matching_with_patterns),
    where some of the patterns were introduced in C# 9\. This chapter focuses primarily
    on C# 9, the exception being the subject of [Recipe 9.9](#slicing_arrays), which
    is a C# 8 feature.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C#编程语言不断发展。前几章讨论了从C# 1到C# 8的主题。例外是在[第8章](ch08.xhtml#matching_with_patterns)中的模式匹配，其中一些模式是在C#
    9中引入的。本章主要关注C# 9，例外是[Recipe 9.9](#slicing_arrays)的主题，这是一个C# 8的功能。
- en: A central concept in this chapter is immutability—the ability to create and
    operate on types that don’t change. Immutability is important for safe multithreading
    as well as for the cognitive relief of knowing that code you’ve passed a type
    to won’t change (mutate) the contents of the object.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的一个核心概念是不可变性——能够创建和操作不会改变的类型。不可变性对于安全的多线程操作非常重要，也有助于减轻认知负担，因为你知道，你将一个类型传递给的代码不会改变（突变）对象的内容。
- en: The example scenario is working with addresses, such as a mailing address or
    a shipping address. In many contexts, an address is a value, meaning that it doesn’t
    have an identity. The address exists as a set of data (value) associated with
    an entity such as a customer or company. On the other hand, an entity does have
    an identity, normally modeled as an ID field in a database. Because we’re treating
    it as a value, address becomes a useful candidate for immutability because we
    don’t want the value to change once it’s set.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 示例场景是处理地址，如邮寄地址或送货地址。在许多情况下，地址是一个值，意味着它没有身份。地址作为与客户或公司等实体关联的一组数据（值）存在。另一方面，实体确实有一个身份，通常在数据库中建模为ID字段。因为我们将其视为一个值，所以地址成为不可变性的一个有用候选，因为我们不希望该值在设置后发生变化。
- en: One interesting feature of C# 9 is called *module initialization*. Think about
    how we use constructors to initialize types or `Main` to initialize an application.
    Module initialization lets you write initialization code at the scope of an assembly,
    and you’ll see how that works.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: C# 9的一个有趣特性称为*模块初始化*。想想我们如何使用构造函数初始化类型或`Main`初始化应用程序。模块初始化允许你在程序集范围内编写初始化代码，你将看到它是如何工作的。
- en: Another C# 9 theme is code simplification. You’ll see a section on how to write
    code without namespaces or classes, eliminating the ceremony around starting an
    application in a `Main` method. Another simplification is in instantiating objects,
    with a new feature to infer type contextually. Let’s start with simplifying application
    startup.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个C# 9的主题是简化代码。你将看到如何写出不带命名空间或类的代码，消除在`Main`方法中启动应用程序时的繁文缛节。另一个简化是在实例化对象时，使用新的特性来推断类型上下文。让我们从简化应用程序启动开始。
- en: 9.1 Simplifying Application Startup
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.1 简化应用程序启动
- en: Problem
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to eliminate as much code as possible for your application entry point.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要尽可能地消除应用程序入口的代码。
- en: Solution
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This is a top-level program:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个顶层程序：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here’s the code that the C# compiler generates:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是C#编译器生成的代码：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Discussion
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: A lot of the code we write is boilerplate—standard syntax that we copy over
    and over again. In the case of a console app with a `Main` method, you have a
    namespace that generally matches the project name, a class named `Program`, and
    a `Main` method. While you’re free to remove the namespace and rename the class,
    people rarely do. Developers have recognized this for years, and in C# 9, we no
    longer need the boilerplate code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们写的大部分代码都是样板代码——我们一遍又一遍地复制的标准语法。在具有`Main`方法的控制台应用程序中，你会有一个命名空间，通常与项目名称匹配，一个名为`Program`的类和一个`Main`方法。虽然你可以自由删除命名空间并重命名类，但人们很少这样做。开发人员多年来一直意识到这一点，在C#
    9中，我们不再需要这些样板代码。
- en: The solution shows the new top-level statements feature, where the code doesn’t
    have a namespace, class, or `Main` method. It’s the minimal amount of code required
    to start the app. The example code requests address details and prints out the
    results and works exactly as written.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案展示了新的顶级语句功能，代码中不需要命名空间、类或`Main`方法。这是启动应用程序所需的最少代码。示例代码请求地址详细信息并打印结果，其功能与所写的代码完全相同。
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you’re teaching someone how to program in C#, top-level statements can make
    the task easier. You don’t need to explain methods, because you’re not writing
    a `Main` method. You don’t need to explain a class, which is an object with members
    and more. You can leave out the namespace discussion and all the nuance about
    naming and organization. Rather than waxing lightly across (or ignoring) all of
    these complex details, you can discuss them later, when the student is ready.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在教授某人如何在 C# 中编程，顶级语句可以使任务更加简单。你不需要解释方法，因为你不写`Main`方法。你不需要解释一个类，它是一个具有成员和更多的对象。你可以省略命名空间的讨论以及所有关于命名和组织的微妙之处。与其浅显地横跨（或忽略）所有这些复杂细节，你可以在学生准备好时稍后讨论它们。
- en: Top-level statements serve in place of the `Main` method. The solution shows
    the code that the compiler generates. It has the `CompilerGenerated` attribute,
    class, and `Main` method. The naming conventions match the typical boilerplate
    code that Visual Studio, the .NET CLI, and other IDEs produce for console apps.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级语句可以替代`Main`方法。解决方案显示了编译器生成的代码。它具有`CompilerGenerated`属性、类和`Main`方法。命名约定与 Visual
    Studio、.NET CLI 和其他 IDE 为控制台应用程序生成的典型样板代码匹配。
- en: 'Interestingly, you can only put top-level statements in a single file. If you
    try putting them in multiple files, you’ll encounter the following compiler error:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，你只能将顶级语句放在单个文件中。如果尝试将它们放在多个文件中，你将遇到以下编译器错误：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 9.2 Reducing Instantiation Syntax
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.2 减少实例化语法
- en: Problem
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Object instantiation is too redundant and verbose.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对象实例化过于冗长和啰嗦。
- en: Solution
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'We’re going to instantiate this class:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要实例化这个类：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here are different ways to instantiate that class:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实例化该类的不同方式：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Discussion
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Originally, C# had a single way to instantiate a variable: declaring the type,
    variable name, new operator, type, and parenthesized constructor parameter list.
    You can see this in the solution via the `addressOld` field and `addressLocalOld`
    variable.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，C# 有一种实例化变量的方法：声明类型、变量名、new 操作符、类型和带括号的构造函数参数列表。你可以在解决方案中看到这一点，通过`addressOld`字段和`addressLocalOld`变量。
- en: Under the C# 3 paradigm, we needed a strongly typed variable (the `var` keyword)
    to hold anonymous types, especially for LINQ queries. A `var` variable required
    assignment and became a strongly typed assigned type. Some people saw that `var`
    looked similar to the JavaScript `var` and were uncomfortable using it. However,
    as stated earlier, the C# `var` variable is strongly typed, meaning that you can’t
    declare the variable to be of a different type.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 3 的范例下，我们需要一个强类型变量（`var`关键字）来保存匿名类型，特别是用于 LINQ 查询。`var`变量需要赋值，并成为一个强类型的分配类型。有些人看到`var`看起来像
    JavaScript 的`var`，并不习惯使用它。然而，正如前面所述，C# 的`var`变量是强类型的，这意味着你不能将变量声明为不同的类型。
- en: Besides LINQ, a convenient use case for `var` emerged in type instantiation.
    Developers recognized the ability to eliminate redundancy in defining variables
    by using `var`. You can see how this works in the solution for the `addressLocalVar`
    variable.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 LINQ，`var`的一个方便用法是在类型实例化中出现。开发人员认识到通过使用`var`消除定义变量时的冗余是可行的。你可以在解决方案中看到这是如何工作的，例如`addressLocalVar`变量。
- en: Because of the popularity of `var` to reduce code in object instantiation, developers
    looked toward fields for the same experience. However, you can’t use `var` with
    fields, as demonstrated in the `address` field in the solution, which is commented
    out.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用`var`在对象实例化中减少代码的流行，开发人员开始寻求在字段中使用相同的体验。然而，你不能在字段中使用`var`，这在解决方案中的`address`字段中有所示。
- en: C# 9 fixes the redundancy concerns with a feature called *target-typed new*.
    Instead of using `var`, target-typed new declares the type, identifier, and `new`
    keyword with a parameter list. The `addressNew` field and `addressLocalNew` variable
    show how this works. Now you can instantiate fields without the redundancy of
    specifying the same type twice in the same statement.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: C# 9 通过称为*目标类型的新*特性解决了冗余问题。而不是使用`var`，目标类型的新声明了类型、标识符和带参数的`new`关键字。`addressNew`字段和`addressLocalNew`变量展示了这是如何工作的。现在，你可以实例化字段，而无需在同一语句中指定相同类型两次的冗余。
- en: Target-typed new is shortcut syntax for the same type instantiation we’ve done
    forever. That means you can still use object initializers and constructor overloads,
    shown in `addressObjectInit` and `addressCtorInit`, respectively.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 目标类型的新实例化是永远做的相同类型实例化的快捷语法。这意味着你仍然可以使用对象初始化程序和构造函数重载，分别显示在`addressObjectInit`和`addressCtorInit`中。
- en: Now that we have target-typed new, there’s an argument to be made for preferring
    that over `var`. The first reason is the cognitive hesitation of developers who
    eschew `var` because it’s spelled the same way as the JavaScript `var`—even though
    we know the C# `var` is strongly typed. The other is that since we can use target-typed
    new for both variables and fields, we have syntactic consistency in how we instantiate
    types. Some developers will view mixing `var` and target-typed new in the same
    code as distracting or messy.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了目标类型的新特性，有理由更喜欢使用它而不是`var`。第一个原因是开发者在避免使用`var`时存在认知犹豫，因为它与JavaScript的`var`同名
    —— 尽管我们知道C#的`var`是强类型的。另一个原因是，由于我们可以在变量和字段中都使用目标类型的新特性，我们在实例化类型时有了语法上的一致性。一些开发者认为在同一代码中混合使用`var`和目标类型的新特性会让人分心或感觉凌乱。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Even if you don’t use `var` for type instantiation, it’s still useful. When
    doing LINQ queries, you can reshape data with anonymous type projections in the
    same method, and that requires a `var` for the results.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不在类型实例化时使用`var`，它仍然很有用。在进行LINQ查询时，你可以在同一方法中用匿名类型投影重新塑造数据，这就需要用到`var`来存储结果。
- en: Finally, introducing target-typed new into the language doesn’t necessarily
    imply a preference for direct object instantiation. As explained in [Recipe 1.2](ch01.xhtml#removing_explicit_dependencies),
    IoC is a powerful mechanism for decoupling code, promoting separation of concerns,
    and making code more testable.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将目标类型的新特性引入语言中并不一定意味着偏好直接对象实例化。正如[配方 1.2](ch01.xhtml#removing_explicit_dependencies)中解释的那样，IoC是一种强大的机制，用于解耦代码，促进关注点分离，并使代码更易于测试。
- en: See Also
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Recipe 1.2, “Removing Explicit Dependencies”](ch01.xhtml#removing_explicit_dependencies)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[配方 1.2, “移除显式依赖”](ch01.xhtml#removing_explicit_dependencies)'
- en: 9.3 Initializing Immutable State
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.3 初始化不可变状态
- en: Problem
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need immutable properties that are populated only during instantiation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在实例化期间仅填充不可变的属性。
- en: Solution
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s a class with immutable state:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个具有不可变状态的类：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here are a couple of ways to instantiate the immutable class:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实例化不可变类的几种方式：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Discussion
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Immutability, the ability to create and operate on types that don’t change,
    is increasingly an important feature for the quality and correctness of code.
    Imagine the scenario where you pass an object to a method and get the same type
    of object back. Assuming you don’t own the code for that method, how do you know
    what that method did to the object you gave it? Short of decompilation or trusting
    documentation, you don’t know. However, if the object is immutable, it can’t change,
    and you know that the method didn’t change anything.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性，即创建和操作不会改变的类型的能力，对代码的质量和正确性越来越重要。想象一下这样的情况：你将一个对象传递给一个方法，并得到相同类型的对象作为返回值。假设你不拥有该方法的代码，那么你如何知道该方法对你给定的对象做了什么？除了反编译或信任文档，你不知道。然而，如果对象是不可变的，它就不会改变，你就知道该方法没有做任何改变。
- en: Another use case for immutability is in multithreading. The reality of deadlocks
    and race conditions have plagued developers for a long time. In the deadlock scenario,
    separate threads wait on each other to release a resource that the other needs
    for changing. In the race condition scenario, you don’t know which thread will
    modify an object first, resulting in inconsistent object state. In each case,
    immutability simplifies the scenario because neither thread can change an existing
    object—they must rely on their own copy. Multithreading is such a complex topic
    that it couldn’t be fairly discussed here in depth, but the point is that immutability
    is part of the solution.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不可变性的用例是多线程。死锁和竞争条件的现实长期困扰着开发者。在死锁场景中，不同线程等待对方释放另一个线程需要的资源以进行更改。在竞争条件场景中，你无法知道哪个线程会首先修改对象，导致对象状态不一致。在每种情况下，不可变性简化了情景，因为任何线程都无法更改现有对象
    —— 它们必须依赖自己的副本。多线程是如此复杂的话题，无法在此深入讨论，但关键是不可变性是解决方案的一部分。
- en: In the solution, the `Address` class is immutable. You can instantiate it with
    the data you need, but its contents can’t change after that. Notice that the properties
    have a getter but not a setter. Instead, they have initters. The initters let
    you instantiate the object but not change it thereafter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中，`Address`类是不可变的。你可以用需要的数据实例化它，但其内容在那之后不能改变。请注意，属性有getter但没有setter。相反，它们有initters。initters允许你实例化对象，但随后不能更改它。
- en: The `Main` method shows how this works. The `addressObjectInit` variable instantiates
    normally, but setting any of its properties, including `City`, won’t compile.
    The `addressCtorInit` variable shows a similar situation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法展示了这是如何工作的。 `addressObjectInit` 变量可以正常实例化，但是设置其任何属性，包括 `City`，都将无法通过编译。
    `addressCtorInit` 变量展示了类似的情况。'
- en: If you have an existing class, making properties init-only can be useful. However,
    if you’re building new types with C# 9, you can also define records, as discussed
    in the next recipe.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有现有类，使属性成为只读可以很有用。但是，如果您正在使用 C# 9 构建新类型，您也可以定义记录类型，正如下一篇配方所讨论的那样。
- en: See Also
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 9.4, “Creating Immutable Types”](#creating_immutable_types)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[配方 9.4，“创建不可变类型”](#creating_immutable_types)'
- en: 9.4 Creating Immutable Types
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.4 创建不可变类型
- en: Problem
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need an immutable reference type but don’t want to write all the plumbing
    code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个不可变的引用类型，但不想编写所有的管道代码。
- en: Solution
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here is a C# record:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 C# 记录：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This code shows how to use that record:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码显示了如何使用该记录：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And this is the output:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here’s the synthesized code that the C# compiler generates:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 C# 编译器生成的合成代码：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Discussion
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '[Recipe 9.3](#initializing_immutable_state) discusses immutability and its
    benefits and how to create an immutable class. This works great if you have existing
    types and want to migrate them to being immutable. However, for new code and types
    that you want to make immutable, consider using a record.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[配方 9.3](#initializing_immutable_state)讨论了不可变性及其好处，以及如何创建不可变类。如果您有现有类型并希望将它们迁移到不可变状态，则这种方法非常有效。然而，对于想要使新代码和类型变为不可变的情况，建议考虑使用记录。'
- en: Records were introduced in C# 9 as a way to create simple immutable types. The
    solution shows how to do this with the `Address` record. Declare the type as record,
    give it a type name, list the properties, and terminate with a semicolon. Although
    this might look similar to defining a constructor or method, the parameters define
    the properties of this new type, and they follow the common convention of Pascal
    case naming.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 记录在 C# 9 中被引入为创建简单不可变类型的一种方式。解决方案展示了如何在 `Address` 记录中实现这一点。声明类型为记录，为其命名，列出属性，并以分号终止。尽管这看起来可能类似于定义构造函数或方法，但参数定义了这种新类型的属性，并遵循了常见的帕斯卡命名约定。
- en: The solution shows how to instantiate the `Address` record. Notice how the `address​C⁠torInit`
    variable doesn’t allow changing its state, including the `Street` property.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案展示了如何实例化 `Address` 记录。请注意，`addressCtorInit` 变量不允许更改其状态，包括 `Street` 属性。
- en: An interesting fact about records is that they are reference types with value
    semantics. The solution shows that comparing `addressClassic` and `addressCtorInit`
    with `==` results in `true`. This demonstrates value equality because the properties
    of both records are identical. However, notice the `ReferenceEquals` comparison.
    It’s `false` because records are reference types and each refers to separate objects
    in memory.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有关记录的一个有趣事实是它们是具有值语义的引用类型。解决方案显示，使用 `==` 比较 `addressClassic` 和 `addressCtorInit`
    结果为 `true`。这表明了值相等性，因为两个记录的属性是相同的。但请注意 `ReferenceEquals` 的比较结果。它是 `false`，因为记录是引用类型，每个都指向内存中的不同对象。
- en: Although declaring the `Address` record was short and quick, this is a huge
    simplification of the real code that the C# compiler generates. The solution shows
    the synthesized code with many members. The type is a class and it has a constructor
    overload with parameters for populating each property.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然声明 `Address` 记录是简短快捷的，但这是 C# 编译器生成的实际代码的大幅简化。解决方案展示了带有许多成员的合成代码。该类型是一个类，并且具有一个构造函数重载，用于填充每个属性的参数。
- en: The key to value equality is the implementation of `IEquatable<Address>`. The
    class has both a weakly typed and strongly typed `Equals` method. [Recipe 2.5](ch02.xhtml#checking_for_type_equality)
    showed how to implement `IEquatable<T>`, which shares some similarity to this
    implementation. One difference is the type being stored in the `EqualityContract`
    property. Since the C# generated class uses `EqualityContract` in both `Equals`
    and `GetHashCode`, it makes sense to eliminate the redundancy.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 值相等性的关键在于 `IEquatable<Address>` 的实现。该类具有弱类型和强类型 `Equals` 方法。[配方 2.5](ch02.xhtml#checking_for_type_equality)
    展示了如何实现 `IEquatable<T>`，这与此实现有些相似之处。一个区别是存储在 `EqualityContract` 属性中的类型。由于 C# 生成的类在
    `Equals` 和 `GetHashCode` 中使用 `EqualityContract`，因此消除冗余是有道理的。
- en: The `ToString` and `PrintMembers` implementations might be familiar if you’ve
    read [Recipe 3.6](ch03.xhtml#customizing_class_string_representation). The implementations
    are nearly identical. Notice that the `PrintMembers` is `virtual`, and that allows
    derived types to add their values to the output.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你读过[Recipe 3.6](ch03.xhtml#customizing_class_string_representation)，你可能会觉得`ToString`和`PrintMembers`的实现很熟悉。这两个实现几乎完全相同。请注意，`PrintMembers`是`virtual`的，这允许派生类型将它们的值添加到输出中。
- en: Finally, the synthesized class includes a `Clone` method to get a shallow copy,
    a deconstructor for representing values as a tuple, and a copy constructor for
    making a copy of another record. What would also be convenient is a way to get
    a copy of the current object but with modifications, which is discussed next.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，生成的类包括一个`Clone`方法用于获取浅复制，一个用于将值表示为元组的解构方法，以及一个复制构造函数用于复制另一个记录。还有一个方便的方法可以获得当前对象的副本，但带有修改，下面将讨论这一点。
- en: See Also
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Recipe 2.5, “Checking for Type Equality”](ch02.xhtml#checking_for_type_equality)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 2.5, “检查类型相等性”](ch02.xhtml#checking_for_type_equality)'
- en: '[Recipe 3.6, “Customizing Class String Representation”](ch03.xhtml#customizing_class_string_representation)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 3.6, “自定义类字符串表示”](ch03.xhtml#customizing_class_string_representation)'
- en: '[Recipe 9.3, “Initializing Immutable State”](#initializing_immutable_state)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 9.3, “初始化不可变状态”](#initializing_immutable_state)'
- en: 9.5 Simplifying Immutable Type Assignments
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.5 简化不可变类型赋值
- en: Problem
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to change a property of an object but don’t want to mutate the original
    object.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要更改对象的一个属性，但不想改变原始对象。
- en: Solution
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'We’ll use this record:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个记录：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And this code shows how to make a copy of that record:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何复制该记录：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Discussion
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'As discussed in [Recipe 9.4](#creating_immutable_types), records have a normal
    constructor, a copy constructor, and a clone method to create new records of the
    same type. There’s one scenario that these options don’t easily cover: getting
    a type with modifications. That is, what if you wanted everything on the object
    to be the same, except for one or two properties? This section shows a simple
    way to do that.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在[Recipe 9.4](#creating_immutable_types)中讨论的那样，记录类型具有普通构造函数、复制构造函数和克隆方法，用于创建相同类型的新记录。这些选项很容易涵盖一个场景：获取一个具有修改的类型。也就是说，如果你希望对象上的所有内容都保持不变，只改变一个或两个属性，本节展示了一种简单的方法来实现这一点。
- en: Since records are immutable, you can’t modify any of their properties. You could
    always instantiate a new record and supply all of the properties, but that is
    wasteful when only a single property changes, especially if it’s an object with
    a lot of properties.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于记录是不可变的，您不能修改它们的任何属性。您可以始终实例化一个新的记录并提供所有属性，但是如果只有一个属性发生变化，尤其是如果它是一个具有许多属性的对象，这种做法是很浪费的。
- en: The solution in C# 9 uses a `with` expression. You have an existing record,
    add a `with` expression, and only change the properties that need to change. This
    gives you a new instance of the record type with the changes you want.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: C# 9中的解决方案使用了`with`表达式。您有一个现有记录，添加一个`with`表达式，仅更改需要更改的属性。这样可以获得一个带有所需更改的新记录类型的实例。
- en: The solution does this on the `addressPre` variable. The `with` expression uses
    a block of property assignments to specify the properties that need to change.
    This example changes a single property. You can also set multiple properties in
    the same way you do with object initializers, via a comma-separated list.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案在`addressPre`变量上执行此操作。`with`表达式使用一个属性赋值块来指定需要更改的属性。此示例更改了一个属性。您也可以像使用对象初始化程序一样设置多个属性，通过逗号分隔的列表。
- en: See Also
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Recipe 9.4, “Creating Immutable Types”](#creating_immutable_types)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 9.4, “创建不可变类型”](#creating_immutable_types)'
- en: 9.6 Designing for Record Reuse
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.6 为记录重用设计
- en: Problem
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to avoid duplicating functionality.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要避免重复功能。
- en: Solution
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s an abstract base record:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个抽象基本记录：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'These two records derive from that abstract base record:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个记录派生自该抽象基本记录：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here’s how you can work with those records:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何使用这些记录的方法：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Discussion
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: One of the ways to achieve reuse in C# is via inheritance. Records support inheritance
    in the same manner as classes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中实现重用的一种方式是通过继承。记录支持与类相同的继承方式。
- en: The solution has a record named `AddressBase`. As its name suggests, `AddressBase`
    is intended to be a base record. `AddressBase` is also abstract, preventing direct
    instantiation. It has properties common to all derived types.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案有一个名为 `AddressBase` 的记录。顾名思义，`AddressBase` 旨在作为基础记录。`AddressBase` 还是抽象的，阻止直接实例化。它具有所有派生类型通用的属性。
- en: '`MailingAddress` and `ShippingAddress` derive from `AddressBase`, using the
    inheritance syntax similar to classes. The difference is that the inherited record
    declaration includes a parameter list, indicating which parameters from the derived
    record match the base record.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`MailingAddress` 和 `ShippingAddress` 派生自 `AddressBase`，使用类似类的继承语法。不同之处在于继承的记录声明包括参数列表，指示从派生记录中匹配基础记录的哪些参数。'
- en: '`MailingAddress` specializes `AddressBase` with two new properties: `Email`
    and `PreferEmail`. `ShippingAddress` specializes `AddressBase` with an extra `Delivery​In⁠structions`
    property.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`MailingAddress` 是基于 `AddressBase` 特化的，具有两个新属性：`Email` 和 `PreferEmail`。`ShippingAddress`
    也是基于 `AddressBase` 特化的，额外增加了一个 `DeliveryInstructions` 属性。'
- en: The definition of `ShippingAddress` is different because it explicitly defines
    members, rather than using default record syntax. It has a constructor, just like
    a C# class, passing parameters to the base, `AddressBase`. The `ShippingAddress`
    constructor implementation has validation code that throws an exception to protect
    against invalid initialization. In this case, it enforces the logic that a P.O.
    box is not a place you can deliver merchandise to. The constructor also initializes
    the `DeliveryInstructions` property. This demonstrates that while default record
    syntax simplifies the code, you still have the ability to customize records all
    you need.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShippingAddress` 的定义不同，因为它显式定义了成员，而不是使用默认的记录语法。它有一个构造函数，类似于 C# 类，将参数传递给基类
    `AddressBase`。`ShippingAddress` 构造函数中包含验证代码，用于防止无效初始化而抛出异常。在这种情况下，它强制执行逻辑，即邮政信箱不是交付商品的地方。构造函数还初始化了
    `DeliveryInstructions` 属性。这表明，虽然默认记录语法简化了代码，但你仍然可以根据需要定制记录。'
- en: When customizing records, you can add any member that a class could have. Additionally,
    you can override default implementations such as equality, `ToString` output,
    or constructors. Also, customizing as done with `ShippingAddress` doesn’t prevent
    the C# compiler from generating the default record implementation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在定制记录时，可以添加任何类可能具有的成员。此外，还可以重写等式、`ToString` 输出或构造函数的默认实现。此外，像 `ShippingAddress`
    一样的定制并不会阻止 C# 编译器生成默认记录实现。
- en: 9.7 Returning Different Method Override Types
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.7 返回不同的方法覆盖类型
- en: Problem
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You’re overriding a base class method but need to return a more specific type.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要覆盖基类方法，但需要返回更具体的类型。
- en: Solution
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here are the records we want to work with:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们想要处理的记录：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This base class has a method, returning a base record:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基类有一个方法，返回一个基础记录：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'These classes have methods returning derived records:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类具有返回派生记录的方法：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This code shows how to use those derived classes that return derived records:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码展示了如何使用那些返回派生记录的派生类。
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Discussion
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'It used to be that method overrides were required to return the same type as
    the base class virtual method return type. The problem was that derived classes
    often needed to return specialized information from their overrides. The alternatives
    were ugly:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以前方法覆盖要求返回与基类虚方法返回类型相同。问题在于，派生类经常需要从其覆盖中返回特定信息。替代方案很丑陋：
- en: Create a new nonpolymorphic method.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的非多态方法。
- en: Return the base type.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回基础类型。
- en: Return a type derived from the base return type and expect the caller to convert.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回一个从基础返回类型派生的类型，并期望调用者进行转换。
- en: None of these choices are optimal, and fortunately, C# 9 offers a solution through
    covariant return types.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选择都不是最佳的，幸运的是，C# 9 通过协变返回类型提供了解决方案。
- en: 'The solution has two sets of type hierarchies: one for return types and one
    for method polymorphism. `AddressBase` and its two derived records, `MailingAddress`
    and `ShippingAddress`, represent the return types. The `DeliveryBase` class, with
    its derived classes, `Communications` and `Shipping`, have a `GetAddress` method
    that operates polymorphically.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案有两组类型层次结构：一组用于返回类型，另一组用于方法多态性。`AddressBase` 及其两个派生记录 `MailingAddress` 和
    `ShippingAddress` 代表返回类型。`DeliveryBase` 类及其派生类 `Communications` 和 `Shipping` 具有多态操作的
    `GetAddress` 方法。
- en: Note
  id: totrans-135
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Notice how the implementation of `GetAddress` returns target-typed new instances.
    The compiler infers type by context, which is the return type in these examples.
    You can learn more about target-typed new in [Recipe 9.2](#reducing_instantiation_syntax).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`GetAddress`的实现如何返回目标类型的新实例。编译器通过上下文推断类型，这些示例中的返回类型是它。您可以在[食谱 9.2](#reducing_instantiation_syntax)中了解更多关于目标类型新实例的信息。
- en: Prior to C# 9, the `GetAddress` in `Communications` and `Shipping` would be
    forced to return `AddressBase`. However, looking at the solution implementation,
    the `Get​Ad⁠d​ress` in `Communications` and `Shipping` return `MailingAddress`
    and `Shipping​A⁠dd​ress`, respectively.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 9 之前，在 `Communications` 和 `Shipping` 中的 `GetAddress` 将被迫返回 `AddressBase`。然而，通过查看解决方案实现，在
    `Communications` 和 `Shipping` 中的 `GetAddress` 分别返回 `MailingAddress` 和 `ShippingAddress`。
- en: See Also
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 9.2, “Reducing Instantiation Syntax”](#reducing_instantiation_syntax)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[食谱 9.2，“减少实例化语法”](#reducing_instantiation_syntax)'
- en: 9.8 Implementing Iterators as Extension Methods
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.8 实现迭代器作为扩展方法
- en: Problem
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need an iterator on a third-party type for which you don’t have the code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在一个您无法访问代码的第三方类型上添加一个迭代器。
- en: Solution
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s a definition to a type in a third-party library that we don’t have access
    to:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个我们无法访问第三方库的类型的定义：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This class has an enumerator extension method for that type:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有一个针对该类型的枚举器扩展方法：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here’s how to use that enumerator:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何使用该枚举器的方法：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Discussion
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Sometimes, it’s convenient to add an iterator to an object. Doing so lets you
    separate the concerns of dissecting, transforming, and returning object data from
    the consuming code that wants to concentrate on solving the business problem.
    If you own the code of an object and want to loop over its contents, add an iterator.
    However, if the object is from a third party and you don’t have access to the
    code, you used to be forced to add extraneous logic to business code. In C# 9,
    you now have the ability to add a `GetEnumerator` method as an extension method.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，将迭代器添加到对象中会很方便。这样做可以将解剖、转换和返回对象数据的关注点与希望集中在解决业务问题的消费代码分离开来。如果您拥有对象的代码并希望循环访问其内容，则添加迭代器。然而，如果对象来自第三方且您无法访问其代码，则通常被迫在业务代码中添加冗余逻辑。在
    C# 9 中，您现在可以作为扩展方法添加 `GetEnumerator` 方法。
- en: In the solution, the `Address` record is the object we want to iterate over.
    More specifically, we want to iterate on the members of the `Address` record,
    similar to the way you can iterate over properties of a JavaScript object.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中，`Address` 记录是我们想要迭代的对象。更具体地说，我们想要遍历 `Address` 记录的成员，类似于您可以遍历 JavaScript
    对象的属性的方式。
- en: The `AddressExtensions` method has an extension method named `GetEnumerator`
    that takes an `Address` parameter and returns an `IEnumerable<T>`. The `this`
    parameter works just like for any other extension method, specifying the type
    and instance to operate on. The pattern for the iterator is that the method must
    be named `GetEnumerator`, and it must return an `IEnumerator<T>`. The type, `T`,
    can be any type of your choosing—whatever you need. In this example, `T` is `string`.
    This means that you need to convert each property to a string, which isn’t a problem
    in `Address` because all properties are already a string. Consistent with C# iterator
    implementation, the `AddressExtensions` `GetEnumerator` method uses `yield return`
    for each value and `yield break` to indicate the end of iteration.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddressExtensions` 方法有一个名为 `GetEnumerator` 的扩展方法，接受一个 `Address` 参数并返回一个 `IEnumerable<T>`。`this`
    参数的使用方式与任何其他扩展方法相同，指定要操作的类型和实例。迭代器的模式是该方法必须命名为 `GetEnumerator`，并且必须返回一个 `IEnumerator<T>`。类型
    `T` 可以是您选择的任何类型——您所需要的类型。在这个例子中，`T` 是 `string`。这意味着您需要将每个属性转换为一个字符串，在 `Address`
    中这并不是问题，因为所有属性都已经是字符串。与 C# 迭代器实现一致，`AddressExtensions` 的 `GetEnumerator` 方法使用
    `yield return` 返回每个值，并使用 `yield break` 表示迭代结束。'
- en: After getting a list of `Address`, the `Main` method has a nested `foreach`
    loop where the inner `foreach` iterates on an instance of `Address`. Because of
    the extension method, the `foreach` works on `address` the same as it does with
    arrays and collections—no extra syntax.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取 `Address` 列表之后，`Main` 方法有一个嵌套的 `foreach` 循环，其中内部的 `foreach` 在 `Address`
    的一个实例上进行迭代。由于扩展方法的存在，`foreach` 在处理 `address` 时与数组和集合的操作方式相同——不需要额外的语法。
- en: 9.9 Slicing Arrays
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.9 切片数组
- en: Problem
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use ranges to page through data.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您想使用范围来浏览数据。
- en: Solution
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'We’re going to use this record:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个记录：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This method populates an array of records:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法填充了一个记录数组：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This method does paging by slicing an array of records:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法通过切片数组记录进行分页：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This code iterates through pages of the record:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码迭代记录的各个页面：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Discussion
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Since C# 8, it has been much easier to slice arrays. Specify the beginning index,
    concatenate two dots, and specify the last index.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 自从C# 8以来，对数组进行切片变得更加容易。指定开始索引，连接两个点，并指定最后索引。
- en: This solution looks at slicing from the perspective of paging. Some of the applications
    we use page by number of rows or number of columns in a row. This solution pages
    `Address` instances by three per page.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案从分页的角度看待切片问题。我们使用的一些应用程序按行数或行中的列数分页。这个解决方案每页显示三个`Address`实例。
- en: There are two overloads of the `GetAddresses` method. The first, parameterless
    version, generates unique addresses.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetAddresses`方法有两个重载版本。第一个无参数版本生成唯一的地址。'
- en: The second `GetAddresses` overload is an iterator that takes an `int` parameter,
    `perPage`, instructing the method to return that many instances of `Address` at
    one time. After getting a list of `Address` instances, the `for` loop controls
    iterating through the list. The `for` initializer sets `i` to the first `Address`
    and `j` to one more than the last `Address`. Since `i` is the start of the range,
    the `for` condition ensures that `i` doesn’t exceed the size of the array. The
    `for` incrementer adjusts `i` and `j` to the next set of `Address` instances (that
    is, the next page).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`GetAddresses`重载是一个接受`int`参数`perPage`的迭代器，指示方法一次返回多少个`Address`实例。获取`Address`实例列表后，`for`循环控制对列表的迭代。`for`初始化器将`i`设置为第一个`Address`，`j`设置为最后一个`Address`加一。由于`i`是范围的开始，`for`条件确保`i`不超过数组的大小。`for`增量器调整`i`和`j`到下一组`Address`实例（即下一页）。
- en: '`GetAddresses(int` `perPage)` is an iterator, as indicated by the `IEnumerable<Address[]>`
    return type and the fact that it uses `yield return` on results. While [Recipe
    9.8](#implementing_iterators_as_extension_methods) showed how to add an iterator
    as an extension method, this example assumes you have access to the code and adding
    an iterator directly to the code is preferable.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetAddresses(int` `perPage)`是一个迭代器，表明它返回类型为`IEnumerable<Address[]>`并使用`yield
    return`来返回结果。而[9.8节](#implementing_iterators_as_extension_methods)展示了如何将迭代器作为扩展方法添加，本例假设你可以访问代码并直接将迭代器添加到代码中更为合适。'
- en: The `Main` method shows how to use the `GetAddresses(int perPage)` iterator,
    returning the page that was sliced out of the original `Address[]`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`方法展示了如何使用`GetAddresses(int perPage)`迭代器，返回从原始`Address[]`中切片的页面。'
- en: See Also
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 9.8, “Implementing Iterators as Extension Methods”](#implementing_iterators_as_extension_methods)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[9.8节，“将迭代器实现为扩展方法”](#implementing_iterators_as_extension_methods)'
- en: 9.10 Initializing Entire Modules
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.10 初始化整个模块
- en: Problem
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need IoC to work on a class library without relying on the caller to do
    it right.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要IoC来在类库上工作，而不依赖于调用者正确实现。
- en: Solution
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s a repository that returns records:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个返回记录的存储库：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This module initializer configures an IoC container:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块初始化器配置了一个IoC容器：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This service relies on the IoC container:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个服务依赖于IoC容器：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This `Main` method is a client that consumes the service:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Main`方法是一个使用该服务的客户端：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Discussion
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: C# 9 added a feature called module initialization. Essentially, this allows
    you to add any kind of initialization code for an assembly. This initialization
    code runs before any other code in the assembly.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: C# 9添加了一个称为模块初始化的功能。基本上，这允许您为一个程序集添加任何类型的初始化代码。此初始化代码在程序集中的任何其他代码之前运行。
- en: At first glance, this might sound strange because console, Windows Forms, and
    WPF apps have `Main` methods. Even all versions of ASP.NET and Web API have startup
    code. I’m not saying that there isn’t a use case for those technologies, though
    it seems like a rare event for the average professional developer.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这听起来可能有些奇怪，因为控制台、Windows窗体和WPF应用程序都有`Main`方法。即使所有版本的ASP.NET和Web API也有启动代码。我并不是说这些技术没有用武之地，但对于普通的专业开发人员来说，这似乎是一个罕见的事件。
- en: Note
  id: totrans-191
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Another initialization technique that has existed since C# 1 is the use of static
    constructors. A static constructor only runs whenever code accesses class members,
    either via type or instance. So, a static constructor isn’t a valid substitute
    for module initialization because it’s possible that calling code will never access
    a member of that class, and the static constructor will never run.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 自 C# 1 以来存在的另一种初始化技术是使用静态构造函数。静态构造函数只有在代码通过类型或实例访问类成员时才运行。因此，静态构造函数不能有效替代模块初始化，因为可能永远不会访问该类的成员，静态构造函数也永远不会运行。
- en: That said, there is a set of use cases that involve class libraries. The problem
    has always been that you don’t know how consuming code will use your library.
    You can document and set a contract that says the user must call some method or
    start the library a certain way, and that’s as close as you get to guaranteeing
    any type of control over initialization.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，有一组涉及类库的用例。问题始终是您不知道消费代码将如何使用您的库。您可以记录并设置一个合同，该合同表示用户必须以某种方式调用某些方法或启动库，这是您能够保证对初始化进行任何类型控制的最接近方法。
- en: Module initialization changes that because now you have more control over how
    to initialize library code, regardless of what the user does. The solution solves
    the problem of ensuring that IoC gets initialized before any code runs.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 模块初始化的变化使得您可以更好地控制如何初始化库代码，而不管用户做了什么。该解决方案解决了确保 IoC 在任何代码运行之前得到初始化的问题。
- en: The `AddressService` class offers two ways to instantiate an instance of itself,
    via IoC or with the `Create` method. The user has a choice of whether to use IoC
    or not. The benefit is that IoC becomes an option for the library developer too
    for making it easy to write unit tests and write maintainable code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddressService` 类提供了两种实例化自身的方式，可以通过 IoC 或使用 `Create` 方法。用户可以选择是否使用 IoC。好处在于
    IoC 对于库开发者来说也成为一个选项，便于编写单元测试和编写可维护的代码。'
- en: '[Recipe 1.2](ch01.xhtml#removing_explicit_dependencies) explains how IoC works,
    using `Microsoft.Extensions.Dependency​Injec⁠tion`, and this solution uses the
    same library and technique. The main difference is where the IoC container gets
    configured.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 1.2](ch01.xhtml#removing_explicit_dependencies) 解释了 IoC 的工作原理，使用 `Microsoft.Extensions.DependencyInjection`，而此解决方案使用相同的库和技术。主要区别在于
    IoC 容器的配置位置。'
- en: The `Initializer` class has a method named `InitAddressUtilities`. The `Module​Ini⁠tializer`
    attribute indicates that `InitAddressUtilities` is the module initialization code
    for this class library. The `InitAddressUtilities` method will run before any
    other code in the class library.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`Initializer` 类有一个名为 `InitAddressUtilities` 的方法。`ModuleInitializer` 属性表明 `InitAddressUtilities`
    是此类库的模块初始化代码。`InitAddressUtilities` 方法将在类库中的任何其他代码之前运行。'
- en: Note
  id: totrans-198
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In the early days of .NET, a module was a way to group code into a single file,
    for modularization. You could combine modules into an assembly, where the assembly
    was defined as being one or more modules with an additional manifest. The manifest
    contains meta-data for the CLR, the details of which are voluminous and unimportant
    for the current focus.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 早期，模块是将代码组合到单个文件中的一种方式，用于模块化。您可以将模块组合成一个装配体，其中装配体定义为一个或多个模块及一个额外的清单。清单包含
    CLR 的元数据，其详细信息繁多且对当前重点不重要。
- en: Using modules was largely a theoretical capability, as most code is compiled
    as a single module in an assembly. This is the default behavior for the C# compiler
    and Visual Studio. In fact, you had to go out of your way to create a module that
    was potentially useful. While it’s interesting that the `ModuleInitializer` has
    the word “module” in it, the practical reality is that it applies toward initialization
    at the level of the assembly.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块在很大程度上是一种理论能力，因为大多数代码都编译为一个装配体的单一模块。这是 C# 编译器和 Visual Studio 的默认行为。事实上，你必须费劲去创建一个潜在有用的模块。虽然
    `ModuleInitializer` 中有“module”一词，但实际情况是它适用于装配体级别的初始化。
- en: Because the `InitAddressUtilities` method has already run, the `Create` method
    in `AddressService` can rely on `Initializer.Container` having a valid container
    reference for resolving an `AddressService` instance.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `InitAddressUtilities` 方法已经运行，所以 `AddressService` 中的 `Create` 方法可以依赖于 `Initializer.Container`
    具有有效的容器引用来解析 `AddressService` 实例。
- en: See Also
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 1.2, “Removing Explicit Dependencies”](ch01.xhtml#removing_explicit_dependencies)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 1.2，“Removing Explicit Dependencies”](ch01.xhtml#removing_explicit_dependencies)'
