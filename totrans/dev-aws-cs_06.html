<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 6. DevOps" data-type="chapter" epub:type="chapter"><div class="chapter" id="Chapter6">
<h1><span class="label">Chapter 6. </span>DevOps</h1>
<p><a data-primary="DevOps" data-type="indexterm" id="ix_ch06-asciidoc0"/>There is a collective realization amongst industry professionals that cloud computing enables new workflows.  For example, cloud-native solutions like serverless computing open new ways to architect solutions in an event-driven manner.  Likewise, the underlying elastic capabilities of cloud computing enable virtualized storage, networking, and computing.   DevOps, a blend of practices combining software development and operations best practices, is one ideal methodology to harness these new workflows.</p>
<p>This chapter’s central focus is identifying the importance of DevOps to utilize cloud computing fully.  It covers getting started on DevOps for AWS and principles supporting DevOps rooted in Japanese culture.</p>
<section data-pdf-bookmark="Getting Started with DevOps on AWS" data-type="sect1"><div class="sect1" id="idm45599651834656">
<h1>Getting Started with DevOps on AWS</h1>
<p><a data-primary="DevOps" data-secondary="basics" data-type="indexterm" id="ix_ch06-asciidoc1"/>An ideal way to get started with DevOps on AWS is with a definition of how <a href="https://oreil.ly/UAhEl">AWS sees DevOps</a>: “the combination of cultural philosophies, practices, and tools that increases an organization’s ability to deliver applications and services at high velocity.” In practice, this means that AWS provides managed services that support a high-velocity workflow enabled by DevOps.</p>
<p>Underneath the surface of DevOps is a definite historical trend of organizational best practices supporting the rise of DevOps. Let’s discuss these concepts next.</p>
<section class="pagebreak-before less_space" data-pdf-bookmark="What Are the Principles Behind DevOps?" data-type="sect2"><div class="sect2" id="idm45599651830432">
<h2>What Are the Principles Behind DevOps?</h2>
<p><a data-primary="DevOps" data-secondary="principles" data-type="indexterm" id="ix_ch06-asciidoc2"/>At the heart of DevOps is the Japanese word <em>Kaizen</em>, meaning “improvement” or “change for the better.” In <a class="orm:hideurl" href="https://learning.oreilly.com/library/view/the-toyota-way/9781260468526"><em>The Toyota Way</em></a>, Second Edition (O’Reilly), Jeffrey K. Liker mentions that post-World War II Toyota developed a lean manufacturing system that incorporated this Kaizen philosophy. Ultimately, this philosophy led to Toyota being one of the leaders in automobile manufacturing quality.</p>
<p>One of the core principles of the Toyota Production System is that assembly line workers will stop the moving production line to fix abnormalities.  <a data-primary="DevOps" data-secondary="PDCA cycle" data-type="indexterm" id="idm45599651824976"/><a data-primary="PDCA (Plan-Do-Check-Act) cycle" data-type="indexterm" id="idm45599651824000"/>Another way to describe this process is Plan-Do-Check-Act, or PDCA cycle, which is shown in <a data-type="xref" href="#Figure-6-0-13-plan-do-check">Figure 6-1</a>. First, a problem needs identification; next, you try out a solution, analyze the results, implement the fix if it solves the problem, or repeat the entire PDCA process.</p>
<figure><div class="figure" id="Figure-6-0-13-plan-do-check">
<img alt="doac 0601" height="452" src="assets/doac_0601.png" width="947"/>
<h6><span class="label">Figure 6-1. </span>Plan-Do-Check-Act lifecycle</h6>
</div></figure>
<p>Essentially, PDCA is the scientific method implemented as a manufacturing business practice.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>According to <em>Encylopedia Britannica</em>, the
<a href="https://oreil.ly/MP7G4">scientific method</a> is a “mathematical and experimental technique employed in the sciences. More specifically, it is the technique used in the construction and testing of a scientific hypothesis.”</p>
</div>
<p class="pagebreak-before"><a data-primary="5 Whys" data-primary-sortas="five whys" data-type="indexterm" id="idm45599651817056"/>Related to both Kaizen and the scientific method is the 5 Whys technique in debugging the root cause of a problem.  This technique works in the following manner.  First, you identify a problem. Next, you ask “why” when you receive an answer, you ask why again, until ultimately, by the fifth time, you get to the root cause of the issue and have a solution to fix it.  The origin of 5 Whys has a historical lineage to the Toyota Production System, and it works well with the concept of continuously improving a system.  In <a data-type="xref" href="#Figure-6-0-7-five-whys">Figure 6-2</a>, a real scenario on AWS goes through the five stages of debugging.</p>
<figure><div class="figure" id="Figure-6-0-7-five-whys">
<img alt="doac 0602" height="818" src="assets/doac_0602.png" width="1440"/>
<h6><span class="label">Figure 6-2. </span>Using 5 Whys to debug a production system</h6>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Children are intuitively very good at the 5 Whys technique, which is why they ask simple, practical questions such as, “Why is the sky blue?” followed by the next question.  An incredible way to get in the right mindframe for using the 5 Whys technique is to ask questions the way a child would ask them.</p>
</div>
<p>Notice that the series of questions eventually leads to a reasonably straightforward fix, i.e., configure machines differently, i.e., use EBS storage, enable a swap partition, and configure the memory constraints of the Java process to match the resources on the server.</p>
<p class="pagebreak-before">As you can see, DevOps isn’t something invented overnight.  DevOps derives from centuries of improvements in critical thinking, from the scientific method centuries ago to, more recently, Kaizen and the Japanese automobile industry.  At the heart of DevOps is the ancient concept of the scientific method, i.e., asking why. The Japanese automobile industry refined this into the methodology of asking why coupled with continuous improvement in manufacturing.  DevOps is the further refinement of this continuous improvement manufacturing methodology in the software engineering domain, which is now ideally suited to cloud-native development.<a data-startref="ix_ch06-asciidoc2" data-type="indexterm" id="idm45599651810544"/>  Now that we know where DevOps came from, let’s discuss the best practices on the AWS platform.</p>
</div></section>
<section data-pdf-bookmark="AWS DevOps Best Practices" data-type="sect2"><div class="sect2" id="idm45599651829808">
<h2>AWS DevOps Best Practices</h2>
<p><a data-primary="DevOps" data-secondary="best practices" data-type="indexterm" id="ix_ch06-asciidoc3"/>An ideal place to start with AWS best practices is the <a href="https://oreil.ly/dfLzx">“Introduction to DevOps on AWS”</a> AWS whitepaper. Inside there are six best practices listed:</p>
<dl>
<dt>Continuous integration (CI)</dt>
<dd>
<p><a data-primary="continuous integration/continuous delivery (CI/CD)" data-secondary="continuous integration defined" data-type="indexterm" id="idm45599651804576"/>The heart and soul of DevOps is a continuous integration system.  Developers periodically merge changes into a central source control repository where automated tests run on the code. You can see the workflow around CI in <a data-type="xref" href="#Figure-6-0-1-ci">Figure 6-3</a>.  A developer in one environment, perhaps a laptop or Cloud9 workspace, pushes changes to the source code repository, triggers the build, tests the code, and allows it to merge.  Later, a second developer pulls these improvements into their checkout in a new local environment.  Note the tie-in to the concept of Kaizen here, or continuous improvement, since each time the build server tests changes, the system can improve the quality of the source code.</p>
</dd>
</dl>
<figure><div class="figure" id="Figure-6-0-1-ci">
<img alt="doac 0603" height="530" src="assets/doac_0603.png" width="1358"/>
<h6><span class="label">Figure 6-3. </span>Continuous integration workflow</h6>
</div></figure>
<dl class="pagebreak-before">
<dt>Continuous delivery (CD)</dt>
<dd>
<p><a data-primary="continuous integration/continuous delivery (CI/CD)" data-secondary="continuous delivery defined" data-type="indexterm" id="idm45599651798656"/>Continuous delivery builds on the concepts of continuous integration by automatically testing software pushed into the repository and preparing the software for release to any number of environments. In <a data-type="xref" href="#Figure-6-0-2-cd">Figure 6-4</a>, you’ll see the foundation established by CI. Now, with the addition of IaC, which automatically deploys the infrastructure alongside the existing software,  the entire system can seamlessly deploy to a new environment because the whole process is automated.  In a CD workflow, containers are a complementary aspect of the deployment since they work side by side with the deployment of the code and infrastructure.  Kaizen again plays a role in deploying improvements automatically.  Each commit to the source code repository adds improvements to the system, and since changes are easy to make, it encourages frequent minor enhancements.</p>
</dd>
</dl>
<figure><div class="figure" id="Figure-6-0-2-cd">
<img alt="doac 0604" height="781" src="assets/doac_0604.png" width="1358"/>
<h6><span class="label">Figure 6-4. </span>Continuous delivery workflow</h6>
</div></figure>
<dl class="pagebreak-before">
<dt>Infrastructure as Code (IaC)</dt>
<dd>
<p><a data-primary="Infrastructure as Code (IaC)" data-secondary="DevOps best practices" data-type="indexterm" id="idm45599651792800"/>IaC is a software development best practice that describes treating the provisioning and management of Infrastructure as Code checked into a repository.  Looking at <a data-type="xref" href="#Figure-6-0-3-iac">Figure 6-5</a>, the IaC workflow can do many valuable actions beyond initially creating the infrastructure. Some of the use cases of IaC include making idempotent changes and cleaning up experiments efficiently by deleting the entire stack.</p>
</dd>
</dl>
<figure><div class="figure" id="Figure-6-0-3-iac">
<img alt="doac 0605" height="937" src="assets/doac_0605.png" width="1359"/>
<h6><span class="label">Figure 6-5. </span>Infrastructure as Code workflow</h6>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a data-primary="idempotent (term)" data-type="indexterm" id="idm45599651787760"/><em>Idempotent</em> is a word frequently used with DevOps because it is essential to be able to do the same action repeatedly and always have the same state. An outstanding example of an idempotent deployment process is IaC that creates an S3 bucket with read-only permissions.  No matter how often this code runs, the result will be the same: an S3 bucket with read-only permissions.</p>
<p>The concept of idempotent actions is essential in DevOps because an automated agile workflow depends on automation actions that have the same effect no matter how often they run. A fantastic example of the mathematical foundations of idempotency is multiplying a series of numbers by zero.  The result is always zero, no matter what number you multiply by zero.</p>
</div>
<dl class="pagebreak-before">
<dt>Monitoring and logging</dt>
<dd>
<p><a data-primary="logging, monitoring, and instrumentation" data-secondary="DevOps best practices" data-type="indexterm" id="idm45599651784480"/><a data-primary="monitoring" data-secondary="DevOps best practices and" data-type="indexterm" id="idm45599651783472"/><a data-primary="monitoring" data-seealso="logging, monitoring, and instrumentation" data-type="indexterm" id="idm45599651782464"/>Data science for software systems is a unique way to think about monitoring and logging.  It is essential to use data about the infrastructure and deployed application to determine what actions are necessary to maintain a deployed application. In <a data-type="xref" href="#Figure-6-0-4-monitoring-logging">Figure 6-6</a>, servers send system- and application-level logging, metrics, and data from monitoring agents to AWS CloudWatch, where the data is centralized and distributed to dashboards, alerts, search, and automated insights.</p>
</dd>
</dl>
<figure><div class="figure" id="Figure-6-0-4-monitoring-logging">
<img alt="doac 0606" height="957" src="assets/doac_0606.png" width="1357"/>
<h6><span class="label">Figure 6-6. </span>Monitoring and logging is data science for software systems</h6>
</div></figure>
<dl class="pagebreak-before">
<dt>Communication and collaboration</dt>
<dd>
<p><a data-primary="collaboration, DevOps and" data-type="indexterm" id="idm45599651776640"/><a data-primary="communication, DevOps and" data-type="indexterm" id="idm45599651775872"/>DevOps is a behavior, not a specific task to check off a list.  As a result, when teams work together to implement DevOps practices through communication and collaboration, an optimal outcome results. In <a data-type="xref" href="#Figure-6-0-5-communication-collaboration">Figure 6-7</a>, we see that communication embeds in every step of the DevOps lifecycle, from code itself and the conversation around it, to the alerts from production systems that emit into a chat channel.  Note also the possible human interactions on pull requests, pushing to production, and monitoring the application in production.</p>
</dd>
</dl>
<figure><div class="figure" id="Figure-6-0-5-communication-collaboration">
<img alt="doac 0607" height="835" src="assets/doac_0607.png" width="1441"/>
<h6><span class="label">Figure 6-7. </span>DevOps communication and collaboration</h6>
</div></figure>
<dl class="pagebreak-before">
<dt>Security</dt>
<dd>
<p><a data-primary="security" data-secondary="DevOps best practices" data-type="indexterm" id="idm45599651770352"/>Security needs integration at every level of building a software system.  Additionally, the continuous integration and delivery systems need strict access control governance as they deliver software to production.  In <a data-type="xref" href="#Figure-6-0-6-security">Figure 6-8</a>, notice multiple layers of security in an adequately architected system on the AWS cloud.  This system includes firewall rules layered into a VPC to prevent unauthorized network access and policy control that leverages the principle of least privilege to secure the system.  Encryption for data in transit and rest hardens the environment against leaked data.  Finally, auditing all security events via AWS CloudTrail and two-factor authentication for access to the AWS console adds even more protection.</p>
</dd>
</dl>
<figure><div class="figure" id="Figure-6-0-6-security">
<img alt="doac 0608" height="1043" src="assets/doac_0608.png" width="1411"/>
<h6><span class="label">Figure 6-8. </span>DevOps security integration</h6>
</div></figure>
<p>These core DevOps principles are essential to consider when architecting a modern solution on the AWS Cloud. Let’s dive deeper into specific CI/CD (continuous integration and continuous delivery) services on the AWS platform<a data-startref="ix_ch06-asciidoc3" data-type="indexterm" id="idm45599651765792"/>.<a data-startref="ix_ch06-asciidoc1" data-type="indexterm" id="idm45599651764960"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Developing with CI/CD on AWS" data-type="sect1"><div class="sect1" id="idm45599651763872">
<h1>Developing with CI/CD on AWS</h1>
<p><a data-primary="continuous integration/continuous delivery (CI/CD)" data-secondary="developing on AWS" data-type="indexterm" id="ix_ch06-asciidoc4"/><a data-primary="DevOps" data-secondary="developing with CI/CD on AWS" data-type="indexterm" id="ix_ch06-asciidoc5"/>Several AWS-managed services deal with CI/CD, but two critical services are <a href="https://aws.amazon.com/codebuild">AWS CodeBuild</a> and <a href="https://aws.amazon.com/codepipeline">CodePipeline</a>. Let’s dive into how they both work.</p>
<section data-pdf-bookmark="AWS Code Deploy Services" data-type="sect2"><div class="sect2" id="idm45599651758368">
<h2>AWS Code Deploy Services</h2>
<p><a data-primary="continuous integration/continuous delivery (CI/CD)" data-secondary="AWS code deploy services" data-type="indexterm" id="ix_ch06-asciidoc6"/>AWS CodePipeline, AWS CodeBuild, AWS CodeCommit, and AWS CodeDeploy are deeply integrated services on AWS and include complementary workflows.  AWS CodePipeline is a continuous integration and continuous delivery (CI/CD) managed service that fully automates software releases.    <a data-primary="CodeBuild" data-type="indexterm" id="idm45599651755040"/>AWS CodeBuild is a fully managed build service that handles the components of a build process, including testing, building, and releasing packages.  <a data-primary="CodeDeploy" data-type="indexterm" id="idm45599651754080"/>AWS CodeDeploy is a managed service that automates the code deployment to any instance, including EC2 instances or on-premise servers.  <a data-primary="CodeCommit" data-type="indexterm" id="idm45599651753120"/>Finally, AWS CodeCommit is a fully managed code hosting service similar to GitHub or GitLab.</p>
<p><a data-primary="CodePipeline" data-type="indexterm" id="idm45599651751952"/>Let’s take a look at the AWS CodePipeline in <a data-type="xref" href="#Figure-6-0-CodePipeLine">Figure 6-9</a> and notice how it flows from left to right:  source, then build, then test, then staging, then production.  This workflow encapsulates the lifecycle of a project in the real world running on AWS.</p>
<figure><div class="figure" id="Figure-6-0-CodePipeLine">
<img alt="doac 0609" height="254" src="assets/doac_0609.png" width="1445"/>
<h6><span class="label">Figure 6-9. </span>CodePipeline workflow</h6>
</div></figure>
<p>Next, if you open the AWS Console and type in <strong><code>CodePipeline</code></strong>, the interface that pops up is, as shown in <a data-type="xref" href="#Figure-6-0-8-codepipeline">Figure 6-10</a>, mapping these same real-world steps to distinct stages in the process of deploying software on the AWS platform.</p>
<figure class="width-40"><div class="figure" id="Figure-6-0-8-codepipeline">
<img alt="doac 0610" height="684" src="assets/doac_0610.png" width="335"/>
<h6><span class="label">Figure 6-10. </span>CodePipeline interface</h6>
</div></figure>
<p>Since we already briefly covered continuous delivery of a .NET 6 application using AWS <a data-primary="CodeBuild" data-type="indexterm" id="ix_ch06-asciidoc7"/><a data-primary="Hugo" data-type="indexterm" id="ix_ch06-asciidoc8"/>CodeBuild in <a data-type="xref" href="ch05.xhtml#Chapter5">Chapter 5</a>, let’s take a different look at how we could be continuously deploying a <a href="https://gohugo.io">Hugo website</a> using AWS CodeBuild. AWS is a common deployment target for hosting a static website via Amazon S3, Amazon Route 53, and Amazon CloudFront, as shown in <a data-type="xref" href="#Figure-6-0-8-hugo-deploy">Figure 6-11</a>. AWS CodeBuild works very well as the deployment mechanism for these sites. You can log into AWS CodeBuild, set up a new build project, and tell it to use a <a href="https://oreil.ly/KNRop"><em>buildspec.yml</em></a>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Hugo is a unique static website hosting technology written in the <a href="https://go.dev">Go programming language</a> that builds pages at &lt;1ms per page.  You don’t need to use Go to use Hugo; you can write websites in the <a href="https://oreil.ly/uF0Tk">Markdown language</a>.  The speed to build websites and the ease of writing pages in Markdown make Hugo a superior technology for S3 static websites.</p>
</div>
<p class="pagebreak-before">Once GitHub gets a change event, CodeBuild runs the install in a container:</p>
<ol>
<li>
<p>It grabs the specific version of Hugo noted in the <em>buildspec.yml</em>.</p>
</li>
<li>
<p>It builds the Hugo pages. Thousands of Hugo pages can be rendered in subseconds because of the speed of Go.</p>
</li>
<li>
<p>The HTML pages sync to Amazon S3.</p>
</li>
</ol>
<p>Because this sync process runs inside of AWS, it is also speedy.</p>
<figure><div class="figure" id="Figure-6-0-8-hugo-deploy">
<img alt="doac 0611" height="852" src="assets/doac_0611.png" width="1442"/>
<h6><span class="label">Figure 6-11. </span>Hugo continuous deploy on AWS</h6>
</div></figure>
<p>Following is a more templated version of an AWS <em>buildspec.yml</em>, and you can swap out templated values with ones that work for your project:</p>
<pre data-code-language="bash" data-type="programlisting">version: <code class="m">0</code>.1

environment_variables:
  plaintext:
    HUGO_VERSION: <code class="s2">"0.42"</code>

phases:
  install:
    commands:
      - <code class="nb">cd</code> /tmp
      - wget https://github.com/gohugoio/hugo/releases/<code class="se">\</code>
      download/v<code class="si">${</code><code class="nv">HUGO_VERSION</code><code class="si">}</code>/hugo_<code class="si">${</code><code class="nv">HUGO_VERSION</code><code class="si">}</code>_Linux-64bit.tar.gz
      - tar -xzf hugo_<code class="si">${</code><code class="nv">HUGO_VERSION</code><code class="si">}</code>_Linux-64bit.tar.gz
      - mv hugo /usr/bin/hugo
      - <code class="nb">cd</code> -
      - rm -rf /tmp/*
  build:
    commands:
      - rm -rf public
      - hugo
  post_build:
    commands:
      - aws s3 sync public/ s3://&lt;yourwebsite&gt;.com/ --region us-west-2 --delete
      - aws s3 cp s3://&lt;yourwebsite&gt;.com/<code class="se">\</code>
      s3://&lt;yourwebsite&gt;.com/ --metadata-directive REPLACE <code class="se">\</code>
        --cache-control <code class="s1">'max-age=604800'</code> --recursive
      - aws cloudfront create-invalidation --distribution-id<code class="o">=</code>&lt;YOURID&gt; --paths <code class="s1">'/*'</code>
      - <code class="nb">echo</code> Build completed on <code class="sb">`</code>date<code class="sb">`</code></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can watch a complete walk-through of Hugo continuous delivery on YouTube <a href="https://oreil.ly/UjqS0">here</a>, and also follow along with notes on Hugo on the Pragmatic AI Labs <a href="https://oreil.ly/saRAN">website</a><a data-startref="ix_ch06-asciidoc8" data-type="indexterm" id="idm45599651697696"/><a data-startref="ix_ch06-asciidoc7" data-type="indexterm" id="idm45599651723872"/>.<a data-startref="ix_ch06-asciidoc6" data-type="indexterm" id="idm45599651723072"/></p>
</div>
<p>Now that we have more insight into the pure AWS build solution, let’s discuss how third-party build servers work with .NET on AWS.</p>
</div></section>
<section data-pdf-bookmark="Integrating Third-Party Build Servers" data-type="sect2"><div class="sect2" id="idm45599651757744">
<h2>Integrating Third-Party Build Servers</h2>
<p><a data-primary="continuous integration/continuous delivery (CI/CD)" data-secondary="integrating third-party build servers" data-type="indexterm" id="ix_ch06-asciidoc9"/>Not only can you use AWS build servers to build and deploy .NET to AWS, but there is beautiful support for third-party build servers, including <a href="https://www.jenkins.io">Jenkins</a>, <a href="https://oreil.ly/wwt7c">Azure DevOps</a>, and <a href="https://docs.github.com/en/actions">GitHub Actions</a>. <a data-primary="continuous integration/continuous delivery (CI/CD)" data-secondary="GitHub Actions" data-type="indexterm" id="ix_ch06-asciidoc10"/><a data-primary="GitHub Actions" data-type="indexterm" id="ix_ch06-asciidoc11"/>Let’s mainly focus on GitHub Actions since it is the most widely used managed build service.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can watch a walk-through of setting up a C# xUnit project with GitHub Actions on <a href="https://youtu.be/6OkcNWGA6FY">YouTube</a>.</p>
</div>
<p class="pagebreak-before"><a data-primary="GitHub CodeSpaces" data-type="indexterm" id="idm45599651688128"/>In building solutions with GitHub Actions, an ideal place to make code solutions is with <a href="https://oreil.ly/YH0i2">GitHub CodeSpaces</a>, as shown launching in <a data-type="xref" href="#Figure-6-0-9-github-codespaces">Figure 6-12</a>.  The code for the repository lives <a href="https://oreil.ly/BlklG">here</a>, and by selecting the green Code button, we can launch a 16-core workspace that has a clean Visual Studio interface.</p>
<figure><div class="figure" id="Figure-6-0-9-github-codespaces">
<img alt="doac 0612" height="720" src="assets/doac_0612.png" width="730"/>
<h6><span class="label">Figure 6-12. </span>GitHub CodeSpaces</h6>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>GitHub CodeSpaces is a paid service that allows development in a web-based development environment.  If your organization does not have access to this service, an alternative is AWS Cloud9, which has many similar features, but with the advantage of deep AWS integration.</p>
</div>
<p class="pagebreak-before">Notice that we created a file inside the path <em>.github/workflows</em> called <em>dotnet.yml</em>, which contains the entire workflow to build and test our project as shown in <a data-type="xref" href="#Figure-6-0-11-vscode">Figure 6-13</a>.</p>
<figure><div class="figure" id="Figure-6-0-11-vscode">
<img alt="doac 0613" height="1209" src="assets/doac_0613.png" width="1891"/>
<h6><span class="label">Figure 6-13. </span>GitHub CodeSpaces workflow</h6>
</div></figure>
<p>The <em>dotnet.yml</em> shows that the key steps are to restore the dependency, build the project, and then test the project:</p>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">.NET</code>
<code class="nt">on</code><code class="p">:</code>
  <code class="nt">push</code><code class="p">:</code>
    <code class="nt">branches</code><code class="p">:</code> <code class="p-Indicator">[</code> <code class="s">"</code><code class="s">main</code><code class="s">"</code> <code class="p-Indicator">]</code>
<code class="nt">jobs</code><code class="p">:</code>
  <code class="nt">build</code><code class="p">:</code>
    <code class="nt">runs-on</code><code class="p">:</code> <code class="l-Scalar-Plain">ubuntu-latest</code>
    <code class="nt">steps</code><code class="p">:</code>
    <code class="p-Indicator">-</code> <code class="nt">uses</code><code class="p">:</code> <code class="l-Scalar-Plain">actions/checkout@v3</code>
    <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">Setup</code> <code class="l-Scalar-Plain">.NET</code>
      <code class="nt">uses</code><code class="p">:</code> <code class="l-Scalar-Plain">actions/setup-dotnet@v2</code>
      <code class="nt">with</code><code class="p">:</code>
        <code class="nt">dotnet-version</code><code class="p">:</code> <code class="l-Scalar-Plain">5.0.x</code>
    <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">Restore</code> <code class="l-Scalar-Plain">dependencies</code> <a class="co" href="#callout_devops_1" id="co_devops_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
      <code class="nt">run</code><code class="p">:</code> <code class="l-Scalar-Plain">dotnet</code> <code class="l-Scalar-Plain">restore</code>
    <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">Build</code> <a class="co" href="#callout_devops_2" id="co_devops_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
      <code class="nt">run</code><code class="p">:</code> <code class="l-Scalar-Plain">dotnet</code> <code class="l-Scalar-Plain">build</code> <code class="l-Scalar-Plain">--no-restore</code>
    <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">Test</code> <a class="co" href="#callout_devops_3" id="co_devops_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
      <code class="nt">run</code><code class="p">:</code> <code class="l-Scalar-Plain">dotnet</code> <code class="l-Scalar-Plain">test</code> <code class="l-Scalar-Plain">--no-build</code> <code class="l-Scalar-Plain">--verbosity</code> <code class="l-Scalar-Plain">normal</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_devops_1" id="callout_devops_1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Restore dependencies.</p></dd>
<dt><a class="co" href="#co_devops_2" id="callout_devops_2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Build the project.</p></dd>
<dt><a class="co" href="#co_devops_3" id="callout_devops_3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>Test the project.</p></dd>
</dl>
<p>To create the structure for the project, first, create a directory and <code>cd</code> into it:</p>
<pre data-type="programlisting">mkdir HelloTests &amp;&amp; cd HelloTests</pre>
<p>Next, use <code>dotnet new xunit</code> to create the project.
Finally, paste the following code block inside your source code file. Let’s walk through what the code does:</p>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">using</code> <code class="nn">Xunit</code><code class="p">;</code>

<code class="k">namespace</code> <code class="nn">MyFirstUnitTests</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">class</code> <code class="nc">UnitTest1</code>
    <code class="p">{</code>
<code class="na">        [Fact]</code> <a class="co" href="#callout_devops_2-1" id="co_devops_2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
        <code class="k">public</code> <code class="k">void</code> <code class="nf">PassingTest</code><code class="p">(</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="n">Assert</code><code class="p">.</code><code class="n">Equal</code><code class="p">(</code><code class="m">4</code><code class="p">,</code> <code class="n">Add</code><code class="p">(</code><code class="m">2</code><code class="p">,</code> <code class="m">2</code><code class="p">)</code><code class="p">)</code><code class="p">;</code>
        <code class="p">}</code>
        <code class="kt">int</code> <code class="nf">Add</code><code class="p">(</code><code class="kt">int</code> <code class="n">x</code><code class="p">,</code> <code class="kt">int</code> <code class="n">y</code><code class="p">)</code> <a class="co" href="#callout_devops_2-2" id="co_devops_2-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
        <code class="p">{</code>
            <code class="k">return</code> <code class="n">x</code> <code class="p">+</code> <code class="n">y</code><code class="p">;</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_devops_2-1" id="callout_devops_2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The <code>[Fact]</code> block is the unit test that tests the `add` function</p></dd>
<dt><a class="co" href="#co_devops_2-2" id="callout_devops_2-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>There is an “inline” method, <code>Add</code>, which we run tests on.</p></dd>
</dl>
<p>To run this project, you perform the following actions:</p>
<ol>
<li>
<p>Install the dependencies: <code>dotnet restore</code>.</p>
</li>
<li>
<p>Build the project: <code>dotnet build --no-restore</code>.</p>
</li>
<li>
<p>Test the project: <code>dotnet test --no-build --verbosity normal</code>.</p>
</li>
</ol>
<p>You can see the final output in <a data-type="xref" href="#Figure-6-0-10-github-actions">Figure 6-14</a> showing a successful run of GitHub Actions.  What is extremely useful about this entire workflow is how easy it is to add steps for a project, like deploying to AWS.  A helpful blog post on AWS shows a detailed example of how to <a href="https://oreil.ly/jNRng">deploy code to AWS from GitHub Actions</a>.<a data-startref="ix_ch06-asciidoc11" data-type="indexterm" id="idm45599651344256"/><a data-startref="ix_ch06-asciidoc10" data-type="indexterm" id="idm45599651343552"/></p>
<figure><div class="figure" id="Figure-6-0-10-github-actions">
<img alt="doac 0614" height="839" src="assets/doac_0614.png" width="1322"/>
<h6><span class="label">Figure 6-14. </span>GitHub Actions build process</h6>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>It is also worth noting that many AWS services or tools have automatic pipelines built in:</p>
<dl>
<dt>AWS App Runner</dt>
<dd>
<p><a data-primary="App Runner" data-secondary="automatic pipelines" data-type="indexterm" id="idm45599651338480"/><a href="https://oreil.ly/mIA74">AWS App Runner</a> has a feature for automatic deployments from GitHub. When you connect App Runner to your code repository or container image registry, App Runner can automatically build and deploy your application when you update your source code or container image.</p>
</dd>
<dt>AWS Copilot</dt>
<dd>
<p><a data-primary="Copilot" data-type="indexterm" id="idm45599651335296"/><a href="https://oreil.ly/YQVjZ">AWS Copilot</a> can provision multiple deployment environments for you, such as testing and production environments. Additionally, Copilot can set up a CI/CD pipeline to automatically deploy<a data-startref="ix_ch06-asciidoc9" data-type="indexterm" id="idm45599651333936"/>.<a data-startref="ix_ch06-asciidoc5" data-type="indexterm" id="idm45599651333104"/><a data-startref="ix_ch06-asciidoc4" data-type="indexterm" id="idm45599651332400"/></p>
</dd>
</dl>
</div>
</div></section>
</div></section>
<section class="pagebreak-before less_space" data-pdf-bookmark="Integration with Partner Products" data-type="sect1"><div class="sect1" id="idm45599651330960">
<h1>Integration with Partner Products</h1>
<p><a data-primary="DevOps" data-secondary="integration with partner products" data-type="indexterm" id="idm45599651329360"/>It is worth noting that there are many great options for third-party partner products, including Jenkins, TeamCity, Azure DevOps, and Terraform.  A great place to highlight integrations with AWS CodeDeploy is the <a href="https://oreil.ly/cof1J">“Integration with partner products and services” section of the AWS documentation</a>. Here are standout highlighted resources:</p>
<dl>
<dt>Jenkins</dt>
<dd>
<p><a data-primary="Jenkins" data-type="indexterm" id="idm45599651325968"/>Jenkins is an open source Swiss Army knife of build systems, and AWS provides outstanding support.  One key advantage of Jenkins is the ability to mount a network filesystem on AWS and integrate that with your build and deploy process. You can read about how to <a href="https://oreil.ly/es2pf">set up CI/CD pipelines with Jenkins</a> with AWS App2Container as well as use <a href="https://oreil.ly/MEAe7">AWS CodeBuild with Jenkins</a>.</p>
</dd>
<dt>TeamCity</dt>
<dd>
<p><a data-primary="TeamCity" data-type="indexterm" id="idm45599651322320"/>TeamCity is a classic build system that many experienced and new .NET developers love.  A team using TeamCity can use the <a href="https://oreil.ly/RisFO">AWS CodeDeploy Runner plugin</a> to deploy directly to AWS.</p>
</dd>
<dt>Azure DevOps</dt>
<dd>
<p><a data-primary="Azure DevOps" data-type="indexterm" id="idm45599651319584"/>AWS App2Container has integration with <a href="https://oreil.ly/sKTWK">Microsoft Azure DevOps</a>.  The <a href="https://aws.amazon.com/vsts">AWS Toolkit for Azure DevOps</a> allows you to deploy .NET code to AWS without leaving the existing build/release pipeline.</p>
</dd>
<dt>Terraform</dt>
<dd>
<p><a data-primary="Terraform" data-type="indexterm" id="idm45599651316000"/>HashiCorp has integration with <a href="https://oreil.ly/NhcdI">AWS CodeDeploy</a>, allowing developers to not only use <a href="https://www.terraform.io/cdktf">Terraform CDK in C#</a>, but also products like <a href="https://oreil.ly/MoiAW">Consul</a>.</p>
</dd>
</dl>
<p>Now that you understand how to integrate tests with third-party partner integrations, including GitHub Actions, let’s discuss IaC.</p>
</div></section>
<section data-pdf-bookmark="Developing with IaC on AWS" data-type="sect1"><div class="sect1" id="idm45599651312304">
<h1>Developing with IaC on AWS</h1>
<p><a data-primary="DevOps" data-secondary="developing with IaC on AWS" data-type="indexterm" id="idm45599651311136"/><a data-primary="Infrastructure as Code (IaC)" data-secondary="containerized DevOps" data-type="indexterm" id="idm45599651310096"/>IaC is code that defines the infrastructure and maintains it.  Ultimately, containers and IaC are complementary technologies on the AWS platform.  Notice in <a data-type="xref" href="#Figure-6-1-aws-flavored-devops">Figure 6-15</a> that GitHub contains the essential elements of a project, including the build system file, the IaC file, the source code, and the Dockerfile.</p>
<figure><div class="figure" id="Figure-6-1-aws-flavored-devops">
<img alt="doac 0615" height="1105" src="assets/doac_0615.png" width="1446"/>
<h6><span class="label">Figure 6-15. </span>AWS-flavored containerized DevOps</h6>
</div></figure>
<p>In many scenarios, you could have all elements of a containerized microservice defined in a single repository, making it easy to debug and build locally or in a new environment.  IaC enables part of this workflow. Let’s talk about how an AWS IaC solution called Cloud Development Kit (CDK)) helps with this.</p>
</div></section>
<section data-pdf-bookmark="Working with AWS CDK in C#" data-type="sect1"><div class="sect1" id="idm45599651305408">
<h1>Working with AWS CDK in C#</h1>
<p><a data-primary="CDK (Cloud Development Kit)" data-type="indexterm" id="ix_ch06-asciidoc12"/><a data-primary="Cloud Development Kit (CDK)" data-type="indexterm" id="ix_ch06-asciidoc13"/><a data-primary="DevOps" data-secondary="working with AWS CDK in C#" data-type="indexterm" id="ix_ch06-asciidoc14"/><a href="https://aws.amazon.com/cdk">AWS CDK</a> is open source and supported by AWS.  It provides many benefits, including faster development and <a href="https://oreil.ly/xrLwb">rich examples</a>.  The <a href="https://oreil.ly/mG6iD">unit of deployment</a> in the AWS CDK is called a <em>stack</em>.  For example, to create two stacks representing a “development” and “production” environment, use the following C# code:</p>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">app</code> <code class="p">=</code> <code class="k">new</code> <code class="n">App</code><code class="p">();</code>

<code class="k">new</code> <code class="nf">MyFirstStack</code><code class="p">(</code><code class="n">app</code><code class="p">,</code> <code class="s">"dev"</code><code class="p">);</code>
<code class="k">new</code> <code class="nf">MySecondStack</code><code class="p">(</code><code class="n">app</code><code class="p">,</code> <code class="s">"prod"</code><code class="p">);</code>

<code class="n">app</code><code class="p">.</code><code class="n">Synth</code><code class="p">();</code></pre>
<p>To synthesize one stack, you run <code>cdk synth dev</code>.  Behind the scenes, this then <a href="https://oreil.ly/UtxOT">creates the CloudFormation template</a>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>It is worth noting that <a href="https://oreil.ly/l2j1s">constructs</a> are fundamental building blocks of AWS CDK apps and contain everything necessary to build a resource, say an S3 bucket. The <a href="https://constructs.dev">Construct Hub</a> includes over 600 .NET CDK constructs and is a recommended resource for building solutions efficiently and with AWS’s best practices behind you.</p>
</div>
<p>You can see the concepts defined in <a data-type="xref" href="#Figure-6-11-AppStacks">Figure 6-16</a>.  At the core of CDK is the idea of writing code that then turns into infrastructure since the infrastructure is a virtual resource.  <a data-primary="CloudFormation" data-type="indexterm" id="idm45599651269616"/>Notice that the C# language compiles down to <a href="https://oreil.ly/pBAiY">CloudFormation</a>, which then provisions resources.</p>
<figure><div class="figure" id="Figure-6-11-AppStacks">
<img alt="doac 0616" height="1090" src="assets/doac_0616.png" width="1333"/>
<h6><span class="label">Figure 6-16. </span>CDK architecture</h6>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a href="https://oreil.ly/lfNIR">AWS CloudFormation</a> is a form of IaC that lets you manage AWS resources by treating infrastructure as code written in JSON or YAML.  Some developers prefer CDK over regular CloudFormation because it takes less code to build the same solution.  Further, you can create solutions in your favorite language, such as C#.  This <a href="https://oreil.ly/CMBVE">blog post</a> is a perfect example of what you can do with CloudFormation and .NET.</p>
</div>
<p>In practice, a developer can use one of two approaches with CDK.  The first approach is to write CDK in C#, and there is a rich toolchain of examples, including many exciting examples on the <a href="https://oreil.ly/acwT1">.NET Workshop page</a>.  A second approach is to use a high-level abstraction that generates the CDK code for you, like <code>dotnet aws deploy</code>.</p>
<p>One example of this approach comes from the AWS Deploy Tool to deploy a <a href="https://oreil.ly/O9AfD">Blazor WebAssembly application</a>.  The key idea is that you must run <code>dotnet aws deploy</code>.</p>
<p>For example, in your development environment, you can do the following:</p>
<ol>
<li>
<p>Install or update the <code>dotnet</code> AWS deploy tool: <code>dotnet tool install -g aws.deploy.tools</code>.</p>
</li>
<li>
<p>Create a new Blazor WebAssembly application:  <code>dotnet new blazorserver -o BlazorApp --no-https &amp;&amp; BlazorApp</code>.</p>
</li>
<li>
<p>Finally, deploy by running the command <code>dotnet aws deploy</code>.</p>
</li>
</ol>
<p>You can refer to the latest documentation on <a href="https://oreil.ly/RUgOb">GitHub</a> to check out the latest options for using this deployment process.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>There are IaC solutions beyond just CDK.  One of the more popular is  <a href="https://www.terraform.io/cdktf">Terraform</a>, which has a CDKTF or Cloud Development Kit for Terraform with C# support. Another solution provider is Pulumi, and you can find a great example of how to publish a <a href="https://oreil.ly/3y4NQ">C# Lambda, here</a>.</p>
</div>
<p>As a final point, it is essential to point out that some AWS tools automatically create and deploy CDK projects.  Examples include the <a href="https://oreil.ly/ZmsmQ"> AWS deployment tool for .NET CLI</a> and AWS Toolkit for Visual Studio—<a href="https://oreil.ly/jXtPb">Publish to AWS feature</a>.  Additionally, with <a href="https://oreil.ly/WHjKB">CDK deployment projects</a>, you can add additional AWS resources like Amazon SQS queues, Amazon DynamoDB tables, and more.<a data-startref="ix_ch06-asciidoc14" data-type="indexterm" id="idm45599651221152"/><a data-startref="ix_ch06-asciidoc13" data-type="indexterm" id="idm45599651220448"/><a data-startref="ix_ch06-asciidoc12" data-type="indexterm" id="idm45599651219776"/></p>
<p>Now that we have an overview of Infrastructure as Code, let’s wrap up everything we covered in this chapter.</p>
</div></section>
<section data-pdf-bookmark="Conclusion" data-type="sect1"><div class="sect1" id="idm45599651304752">
<h1>Conclusion</h1>
<p>This chapter covered the historical origin of DevOps, including this history of continuous improvement in the Japanese automobile industry. At the heart of modern DevOps is an embrace of the cloud.  Cloud computing enables even deeper coupling of automation, testing, and speed of deployment.  One example of this integration is IaC, which is the perfect vehicle for DevOps workflows.  DevOps also enables optimal human interaction at key points of the lifecycle of software engineering, from code reviews via pull requests to working with a release manager on a production software release to finally monitoring the production system.</p>
<p>Another topic we covered is how AWS thinks of DevOps and the best practices of DevOps on AWS.  We then used build systems like AWS CodeBuild and third-party systems like GitHub Actions.  AWS has tight integration of each component and can replace any third-party tool if your organization chooses or integrates with them.</p>
<p>Finally, we ended the chapter with IaC, an essential tool for DevOps automation of infrastructure. We showed how you could do a one-line command to deploy static websites to AWS S3 using the AWS .NET deployment tool.  This tool’s ability to wrap up CDK and make it part of the automation lifecycle is extremely powerful.</p>
<p>This chapter’s big takeaway is that AWS takes DevOps seriously and provides a whole set of managed services and best practices to enable you to build maintainable and agile solutions.  Next up in <a data-type="xref" href="ch07.xhtml#Chapter7">Chapter 7</a>, we cover logging, monitoring, and instrumentation for .NET, which builds upon the foundational knowledge we covered on DevOps.  Before heading to that chapter, try some critical thinking questions and examples to cement your DevOps understanding further.<a data-startref="ix_ch06-asciidoc0" data-type="indexterm" id="idm45599651214624"/></p>
</div></section>
<section data-pdf-bookmark="Critical Thinking Discussion Questions" data-type="sect1"><div class="sect1" id="idm45599651213824">
<h1>Critical Thinking Discussion Questions</h1>
<ul>
<li>
<p>What is your definition of DevOps, and how can you use it to enhance organizational outcomes?</p>
</li>
<li>
<p>What is the advantage of using the <a href="https://oreil.ly/6xBjV">.NET AWS CDK  framework</a> to define cloud application resources on AWS?</p>
</li>
<li>
<p>Which <a href="https://oreil.ly/MRqXj">AWS deployment strategy</a> most closely aligns with where your organization works best?</p>
</li>
<li>
<p>Why is it essential to use <a href="https://oreil.ly/aa2ID">AWS CloudTrail</a> for any AWS deployment?</p>
</li>
<li>
<p>What could be an advantage of using AWS CodeCommit versus a third-party source code hosting service?</p>
</li>
</ul>
</div></section>
<section data-pdf-bookmark="Exercises" data-type="sect1"><div class="sect1" id="idm45599651205424">
<h1>Exercises</h1>
<ul>
<li>
<p>Use AWS CodeBuild to deploy a static S3 site using <a href="https://oreil.ly/TK8X2">AWS CDK in C#</a>.</p>
</li>
<li>
<p>Set up a continuous integration workflow for a .NET 6 project using GitHub Actions that tests code automatically upon check-in.</p>
</li>
<li>
<p>Set up a continuous integration workflow for a .NET 6 project using AWS Code Build.</p>
</li>
<li>
<p>Find an example CDK application in the <a href="https://oreil.ly/JIHP3">csharp</a> repo and deploy it to your AWS environment.</p>
</li>
<li>
<p>Continuously deploy your own Hugo website and blog about .NET on AWS using your own homegrown CMS.</p>
</li>
</ul>
</div></section>
</div></section></div></body></html>