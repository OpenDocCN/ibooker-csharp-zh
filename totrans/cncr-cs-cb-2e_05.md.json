["```cs\nvar multiplyBlock = new TransformBlock<int, int>(item => item * 2);\nvar subtractBlock = new TransformBlock<int, int>(item => item - 2);\n\n// After linking, values that exit multiplyBlock will enter subtractBlock.\nmultiplyBlock.LinkTo(subtractBlock);\n```", "```cs\nvar multiplyBlock = new TransformBlock<int, int>(item => item * 2);\nvar subtractBlock = new TransformBlock<int, int>(item => item - 2);\n\nvar options = new DataflowLinkOptions { PropagateCompletion = true };\nmultiplyBlock.LinkTo(subtractBlock, options);\n\n...\n\n// The first block's completion is automatically propagated to the second block.\nmultiplyBlock.Complete();\nawait subtractBlock.Completion;\n```", "```cs\nvar block = new TransformBlock<int, int>(item =>\n{\n  if (item == 1)\n    throw new InvalidOperationException(\"Blech.\");\n  return item * 2;\n});\nblock.Post(1);\nblock.Post(2);\n```", "```cs\ntry\n{\n  var block = new TransformBlock<int, int>(item =>\n  {\n    if (item == 1)\n      throw new InvalidOperationException(\"Blech.\");\n    return item * 2;\n  });\n  block.Post(1);\n  await block.Completion;\n}\ncatch (InvalidOperationException)\n{\n  // The exception is caught here.\n}\n```", "```cs\ntry\n{\n  var multiplyBlock = new TransformBlock<int, int>(item =>\n  {\n    if (item == 1)\n      throw new InvalidOperationException(\"Blech.\");\n    return item * 2;\n  });\n  var subtractBlock = new TransformBlock<int, int>(item => item - 2);\n  multiplyBlock.LinkTo(subtractBlock,\n      new DataflowLinkOptions { PropagateCompletion = true });\n  multiplyBlock.Post(1);\n  await subtractBlock.Completion;\n}\ncatch (AggregateException)\n{\n  // The exception is caught here.\n}\n```", "```cs\nvar multiplyBlock = new TransformBlock<int, int>(item => item * 2);\nvar subtractBlock = new TransformBlock<int, int>(item => item - 2);\n\nIDisposable link = multiplyBlock.LinkTo(subtractBlock);\nmultiplyBlock.Post(1);\nmultiplyBlock.Post(2);\n\n// Unlink the blocks.\n// The data posted above may or may not have already gone through the link.\n// In real-world code, consider a using block rather than calling Dispose.\nlink.Dispose();\n```", "```cs\nvar sourceBlock = new BufferBlock<int>();\nvar options = new DataflowBlockOptions { BoundedCapacity = 1 };\nvar targetBlockA = new BufferBlock<int>(options);\nvar targetBlockB = new BufferBlock<int>(options);\n\nsourceBlock.LinkTo(targetBlockA);\nsourceBlock.LinkTo(targetBlockB);\n```", "```cs\nvar multiplyBlock = new TransformBlock<int, int>(\n    item => item * 2,\n    new ExecutionDataflowBlockOptions\n    {\n      MaxDegreeOfParallelism = DataflowBlockOptions.Unbounded\n    });\nvar subtractBlock = new TransformBlock<int, int>(item => item - 2);\nmultiplyBlock.LinkTo(subtractBlock);\n```", "```cs\nIPropagatorBlock<int, int> CreateMyCustomBlock()\n{\n  var multiplyBlock = new TransformBlock<int, int>(item => item * 2);\n  var addBlock = new TransformBlock<int, int>(item => item + 2);\n  var divideBlock = new TransformBlock<int, int>(item => item / 2);\n\n  var flowCompletion = new DataflowLinkOptions { PropagateCompletion = true };\n  multiplyBlock.LinkTo(addBlock, flowCompletion);\n  addBlock.LinkTo(divideBlock, flowCompletion);\n\n  return DataflowBlock.Encapsulate(multiplyBlock, divideBlock);\n}\n```"]