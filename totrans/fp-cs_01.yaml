- en: Chapter 1\. Introduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章\. 介绍
- en: If you’ve learned much programming before now - whether that be in C#, Visual
    BASIC, Python or whatever - then chances are what you learned was based around
    the programming paradigm that is currently the most dominent - Object Oriented.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前学过很多编程 - 无论是C#、Visual BASIC、Python还是其他任何语言 - 那么您学到的很可能都是围绕着目前最主流的编程范式 -
    面向对象编程。
- en: Object-Oriented programming has been around for quite a long time. The precise
    date is a matter for debate, but it was likely invented somewhere around the late
    50s and early 60s.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程已经存在了相当长的时间。确切的日期存在争议，但很可能是在50年代末60年代初某个时候发明的。
- en: 'Object-Oriented coding is based around the idea of wrapping pieces of data
    - known as properties - and functionality into logical blocks of code called *Classes*,
    which are used as a sort of template from which we instantiate *Objects*. There’s
    a lot more to it: inheritance, polymorphism, Virtual and Abstract methods. All
    sorts of stuff like that.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编码是围绕着将数据片段 - 称为属性 - 和功能包装成称为*类*的逻辑代码块的想法，这些类被用作从中实例化*对象*的模板。它涉及更多内容：继承，多态性，虚拟和抽象方法。诸如此类的各种东西。
- en: This is however, not an Object-Oriented programming book. In fact, if you are
    already experienced with OO, you’ll probably get more from this book if you leave
    what you know already to one side.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是一本面向对象编程的书。事实上，如果您已经对面向对象有所了解，那么放下您已经掌握的知识，您可能会从本书中获得更多收获。
- en: What I’m going to be describing in this book is a style of programming that
    serves as an alternative to OO - functional programming. Functional Programming,
    despite gaining some mainstream recognition in the last few years, is actually
    as old - if not older - than OO. It’s based on mathematic principles that were
    developed by various people between the late 1800s and 1950s, and has been a feature
    of some programming languages since the 1960s.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本书中要描述的是一种作为面向对象的替代的编程风格 - 函数式编程。尽管最近几年函数式编程开始得到一些主流认可，但它实际上和面向对象一样古老 - 甚至可能更古老。它基于数学原理，这些原理在19世纪末至20世纪50年代间由各种人开发，并自1960年代以来一直是一些编程语言的特征。
- en: In this book, I’ll be showing you how to implement it in C# without the necessity
    of learning a whole new programming language.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我将向您展示如何在C#中实现它，而无需学习全新的编程语言。
- en: Before we get cracking with some code, I’d like to talk first about Functional
    Programming itself. What is it? Why should we be interested? When is it best used.
    All very important questions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，我想先讨论一下函数式编程本身。它是什么？我们为什么要感兴趣？最佳使用时机是什么？所有这些都是非常重要的问题。
- en: What is Functional Programming?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是函数式编程？
- en: There are a few basic concepts in Functional Programming, many of which have
    fairly obscure names for what are otherwise not terribly difficult concepts to
    understand. I’ll try to lay them out here as simply as I can.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程中有一些基本概念，其中许多概念名称相对晦涩，但实际上并不难理解。我会尽量在这里简单地阐述它们。
- en: Is it a Language, an API, or what?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是一种语言，一个API，还是什么？
- en: No, Functional Programming isn’t a language or a 3rd party plug-in library in
    Nuget, it’s a *paradigm*. What do I mean by that? There are more formal definitions
    of paradigms, but I think of it as being a *style* of programming. Like a guitar
    might be used as the exact same instrument, but to play many, often wildly different,
    styles of music, so also some programming languages offer support for different
    styles of working.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 不，函数式编程不是Nuget中的语言或第三方插件库，它是一种*范式*。我指的是什么？虽然有更正式的范式定义，但我认为它是一种*编程风格*。就像吉他可以作为同样的乐器，但可以演奏许多，甚至是完全不同的音乐风格一样，一些编程语言也支持不同的工作风格。
- en: Functional programming is also as old as Object-Oriented coding - if not older.
    I’ll talk more about its origins later, but for now just be aware that it is nothing
    new, and the theory behind it not only predates OO, but largely also the computing
    industry itself.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程与面向对象编码一样古老，甚至可能更古老。我稍后会详细讨论其起源，但现在只需知道它并不新鲜，其理论不仅先于面向对象，而且大部分也先于计算机行业本身。
- en: It’s also worth noting that you can combine paradigms, like mixing rock and
    jazz. Not only can they combine, but there are times when you can use the best
    features of each to produce a better end result.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得注意的是，您可以像混合摇滚和爵士乐一样结合编程范式。它们不仅可以结合，而且有时候您可以利用每种范式的最佳特性来产生更好的最终结果。
- en: 'Programming paradigms come in many, many flavors^([1](ch01.html#idm45400886960080))
    but for the sake of simplicity I’m only going to talk about the two most common
    in modern programming:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 编程范式有多种多样^([1](ch01.html#idm45400886960080))，但为简单起见，我只讨论现代编程中最常见的两种：
- en: Imperative
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式
- en: This was the only type of programming paradigm for quite a long time. Procedural
    and Object-Oriented (OO) belong to this category. These styles of programming
    involve more directly instructing the executing environment with the steps that
    need to be executed in detail, i.e. Which variable contains which intermediate
    steps and how the process is carried out step-by-step in minute detail. This is
    programming as it usually gets taught in school/college/university/at work [delete
    where appropriate].
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这在相当长的一段时间内是唯一的编程范式。过程化和面向对象（OO）属于此类。这些编程风格更直接地指导执行环境执行详细的步骤，即哪个变量包含哪些中间步骤，以及如何逐步详细执行过程。这通常是学校/大学/工作中教授的编程方式。
- en: Declarative
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式
- en: In this programming paradigm we’re less concerned with the precise details of
    how we accomplish our goal, the code more closely resembles a description of what
    is desired at the end of the process, and the details (including things such as
    order of execution of the steps) are left more in the hands of the execution environment.
    This is the category Functional Programming belongs to. SQL also belongs here,
    so in some ways Functional Programming more closely resembles SQL than OO. When
    writing SQL statements you aren’t concerned with what the order of operations
    are (it’s not really SELECT then WHERE then ORDER BY), you aren’t concerned with
    how exactly the data transformations are carried out in detail, you just write
    a script that effectively describes the desired output. These are some of the
    goals of Functional C# as well, so those of you with a background working with
    SQL Server or other relational databases might find some of the ideas coming up
    easier to grasp than those that haven’t.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种编程范式中，我们不太关心如何精确实现目标，代码更接近描述最终过程中所需的内容，而细节（包括执行步骤的顺序等）更多地留在执行环境的控制中。这是函数式编程所属的类别。SQL也属于此类，因此在某些方面，函数式编程更接近SQL而不是OO。在编写SQL语句时，你不关心操作的顺序（实际上并不是SELECT然后WHERE然后ORDER
    BY），也不关心数据转换的具体细节，你只需编写一个有效描述所需输出的脚本。这些也是函数式C#的一些目标，因此那些具有与SQL Server或其他关系数据库的背景的人可能会发现一些相关的想法更容易理解。
- en: There are many, many more paradigms besides these, but they’re well beyond the
    scope of this book. In fairness, most of them are pretty obscure besides these
    two, so you’re unlikely to run into them any time soon.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些之外，还有许多其他编程范式，但它们远超出本书的范围。公平地说，除了这两种以外，大多数都相当隐晦，因此你不太可能在短时间内遇到它们。
- en: The Properties of Functional Programming
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式编程的特性
- en: For the next few sections, I’m going to talk about each of the properties of
    Functional Programming, and what they really mean to a developer.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我将讨论函数式编程的每一个特性，以及它们对开发者的实际意义。
- en: Immutability
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可变性
- en: If something can *change* then it can also said that it can *mutate*, like a
    Teenage Mutant Ninja^([2](ch01.html#idm45400887889424)) Turtle. The other way
    of saying something can mutate is that it is *mutable*. If, on the other hand,
    something cannot change at all, then it is *immutable*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某物体能够*改变*，那么它也可以说是*变异*，就像一个少年变异忍者^([2](ch01.html#idm45400887889424))。另一种说法是，某物体可以变异，这意味着它是*可变的*。另一方面，如果某物体根本不能改变，那么它是*不可变的*。
- en: In programming, this refers to Variables that have their value set upon being
    defined, and after that point they may never be changed again. If a new value
    is required, then a new variable should be created, based on the old one. This
    is how all variables are treated in Functional code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，这指的是变量在定义时设置其值，并且在此后永远不可更改。如果需要新值，则应基于旧值创建一个新变量。这是函数式代码中所有变量的处理方式。
- en: It’s a slightly different way of working compared to Imperative code, but it
    ends up producing programs that more closely resemble mathematical working, and
    encourages good structure, and more predictable - and hence *more robust* - code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这与命令式代码略有不同，但最终会产生更接近数学运算的程序，鼓励良好的结构和更可预测的、因此*更健壮*的代码。
- en: '`DateTime` and `String` are both immutable data structures in .NET. You may
    *think* you’ve altered them, but behind the scenes every alteration creates a
    new item on the stack. This is why most new developers get the talk about concatenating
    strings in `For` loops and why you should never, *ever* do it.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`.NET`中`DateTime`和`String`都是不可变数据结构。你可能*认为*你已经改变了它们，但在幕后，每个改变都在堆栈上创建了一个新项。这就是为什么大多数新开发者在`For`循环中连接字符串时会被提醒，以及为什么你绝对不应该这样做的原因。'
- en: Higher-order Functions
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高阶函数
- en: These are functions that are passed around as variables. This may be either
    as local variables, parameters to a function or return values from a function.
    The `Func<T,TResult>` or `Action<T>` delegate types are perfect examples of this.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是作为变量传递的函数。这可以是作为局部变量、函数的参数或函数的返回值。`Func<T,TResult>`或`Action<T>`委托类型就是这种情况的完美示例。
- en: In case you aren’t familiar with these delegates, this is how they work in brief.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉这些委托，这是它们的简要工作原理。
- en: They’re both forms of function stored in the form of variables. They both take
    sets of generic types, which represent their parameters and return types - if
    any. The difference between `Func` and `Action` is that `Action` doesn’t return
    any value - i.e. it’s a `void` function that won’t contain a `return` keyword.
    The last generic type listed in a `Func` is its return type.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都是以变量形式存储的函数。它们都接受一组泛型类型，这些类型表示它们的参数和返回类型（如果有的话）。`Func`和`Action`之间的区别在于`Action`不返回任何值
    - 即它是一个不包含`return`关键字的`void`函数。在`Func`中列出的最后一个泛型类型是它的返回类型。
- en: 'These functions:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Could be re-written as delegate types like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 可以像这样重写为委托类型：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'These delegate types can be called exactly as if they were normal functions:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些委托类型可以像普通函数一样被调用：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The big advantage of using these Delegates types is they’re stored in variables
    that can be passed around the codebase. They can be included as parameters to
    other functions, or as return types. Used properly, they’re among the more powerful
    features of C#.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些委托类型的一个重大优势是它们存储在可以在代码库中传递的变量中。它们可以作为其他函数的参数或返回类型包含在内。正确使用时，它们是C#中更强大的特性之一。
- en: Using Functional Programming techniques, Delegate types can be composed together
    to create larger, more complex functions from smaller, functional building blocks.
    Like lego bricks being placed together to make a model *Millennium Falcon*, or
    whatever you prefer. This is the real reason this paradigm is called **Functional**
    Programming, because we build our applications up with *functions*, not, as the
    name suggests, that the code written in other paradigms don’t function. Why would
    anyone ever use them if they didn’t?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数式编程技术，委托类型可以组合在一起，从较小的功能构建块中创建更大、更复杂的函数。就像乐高积木一样，将它们放在一起来组成一个*千年隼号*模型，或者你喜欢的其他任何东西。这就是为什么这种编程范式被称为**函数式**编程的真正原因，因为我们用*函数*来构建我们的应用程序，而不是像名字所暗示的那样，其他范式中的代码不起作用。如果它们没有作用，为什么会有人使用它们呢？
- en: In fact - a rule of thumb for you. If there’s a question, Functional Programming’s
    answer will amost certainly be “Functions, Functions and more Functions”.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上 - 对你来说的一个经验法则。如果有疑问，函数式编程的答案几乎肯定是“函数、函数和更多函数”。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There are two kinds of callable code modules. Functions and Methods. The difference
    is that functions always return a value, but methods don’t. In C#, functions return
    data of some kind, whereas methods have a return type of `void`. Methods almost
    inevitable involve side-effects, and as such we should avoid any use of them in
    our code - except where unavoidable. Logging might be an example of usage of methods
    that is not only unavoidable, but also essential to good production code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种可调用的代码模块。函数和方法。区别在于函数总是返回一个值，但方法不返回。在C#中，函数返回某种数据，而方法的返回类型是`void`。方法几乎不可避免地涉及副作用，因此在我们的代码中应尽量避免使用它们
    - 除非无法避免。日志记录可能是方法的一个使用示例，这不仅是无法避免的，而且对于良好的生产代码也是必不可少的。
- en: Expressions Rather than Statements
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表达式而非语句
- en: A couple of definitions are required here.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要一些定义。
- en: '*Expressions* are discrete units of code that evaluate to a value. What do
    I mean by that?'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*表达式*是评估为值的离散代码单元。我是什么意思？'
- en: 'In its simplest form, these are expressions:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式中，这些是表达式：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can feed values in too, to form our expressions, so this is one as well:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以传递值来形成我们的表达式，所以这也是其中之一：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This too. It does carry out an operation - i.e. evaluate a boolean, but it’s
    used ultimately to return a `bool`, so it’s an expression:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是。它执行一个操作 - 即评估一个布尔值，但最终用于返回一个 `bool`，所以它是一个表达式：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'you can also consider ternary `if` statements to be expressions, if they’re
    used purely for determinging a value to return:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果纯粹用于确定要返回的值，你还可以将三元 `if` 语句视为表达式：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Another quick rule of thumb - if a line of code has a single equals sign, it’s
    likely to be an expression, because it’s assigning a value to something. There’s
    some gray area in that rule. Calls to other functions could have all sorts of
    unforseen consequences. It’s not a bad rule to keep in mind, though.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个快速的经验法则 - 如果一行代码有一个等号，那么它很可能是一个表达式，因为它正在为某个东西赋值。在这条规则中存在一些灰色地带。对其他函数的调用可能会有各种意想不到的后果。但把它记在心里还是个不错的主意。
- en: '*Statements* on the other hand are pieces of code that *don’t* evaluate to
    data. These take the form more of an instruction to do something. Either an instruction
    to the executing environment to change the order of execution via keywords like
    `if`, `where`, `for`, `foreach`, etc. or calls to functions that don’t return
    anything - and by implication instead carry out some sort of operation. Something
    like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*语句* 另一方面是一些不评估数据的代码片段。这些更像是一个指令，告诉执行环境通过关键字如 `if`、`where`、`for`、`foreach`
    等改变执行顺序，或者调用不返回任何东西的函数 - 由此暗示进行某种操作。像这样：'
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A final rule of thumb^([3](ch01.html#idm45400887043248)) if there is *no* equals
    sign, it is *definitely* a statement.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个经验法则^([3](ch01.html#idm45400887043248))，如果没有等号，那肯定是一个语句。
- en: Expression-based Programming
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于表达式的编程
- en: If it helps, think back to mathematics lessons from your school days. Remember
    those lines of working you used to have to write out when you were producing your
    final answer? Expression-based programming is like that.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有帮助的话，回想一下你在学校时的数学课。还记得在得出最终答案时你必须写出的那些计算过程吗？基于表达式的编程就像那样。
- en: Each line is a complete calculation, and builds on one or more previous lines.
    By writing expression-based code, you’re leaving your working behind, set in stone
    while the function runs. Amongst other benefits, it’s easier to debug, because
    you can look back at all of the previous values and know they’ve not been changed
    by a previous iteration of a loop, or anything like that.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行都是一个完整的计算，建立在一个或多个前面的行基础之上。通过编写基于表达式的代码，你在函数运行时留下了你的工作成果，一劳永逸。除了其他好处外，这样做更容易调试，因为你可以回顾所有先前的值，并且知道它们没有被循环的先前迭代或其他任何因素更改。
- en: This might seem like an impossibility, almost like being asked to program with
    your arms tied behind your back. It’s entirely possible though, and not even necessarily
    difficult. The tools have mostly been there for about a decade in C#, and there
    are plenty of more effective structures.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是一个不可能完成的任务，几乎就像是让你绑起手臂来编程一样。但完全有可能，而且并不一定困难。在 C# 中，大多数工具已经有了大约十年的历史，而且还有许多更有效的结构。
- en: 'Here’s an example of what I mean:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个我所说的例子：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now strictly speaking, you could write that out as one long line, but it wouldn’t
    look so nice & easy to read and understand, would it? I could also write it something
    like this to save all the intermediate variables:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在严格来说，你可以将它写成一行，但看起来可能不那么美观和易读易懂，对吧？为了保存所有中间变量，我也可以像这样写：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The issue here is that it’s a little harder to read without variable names,
    and also all of the intermediate values are lost - if there was a bug we’d have
    to step through and examine `returnValue` at each stage. In the expression-based
    solution all of the working is kept where it is.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题在于没有变量名会使得阅读起来有点困难，并且所有的中间值都会丢失 - 如果存在 bug，我们必须逐步检查每个阶段的 `returnValue`。而在基于表达式的解决方案中，所有的工作都保留在原地。
- en: After a little experience working in this manner, it will actually seem odd
    and even a little awkward and clunky to go back to the old way.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方式下工作一段时间后，回到旧方式实际上会显得有些奇怪，甚至有些笨拙和累赘。
- en: Referential Transparency
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用透明性
- en: 'This is a scary-sounding name for a simple concept. There is a concept in functional
    programming called “pure functions”. These are functions with the following properties:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来像是一个简单概念的可怕名称。在函数式编程中有一个叫做“纯函数”的概念。这些函数具有以下属性：
- en: They make no changes to anything outside of the function. No state can be updated,
    no files stored, etc.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不会对函数外的任何东西进行更改。不会更新状态，不会存储文件，等等。
- en: Given the same set of parameter values, they will always return the exact same
    result. No. Matter. What. Regardless of what state the system is in.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定相同的参数值集合，无论系统处于什么状态，它们始终返回完全相同的结果。无论如何，没有例外。
- en: They don’t have any unexpected side effects. Exceptions being thrown is included
    in that.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不会有任何意外的副作用。抛出异常也包括在内。
- en: 'The terms comes from the idea that given the same input, the same output always
    results, so in a calculation you can essentially swap the function call with the
    final value, given those inputs. In this example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些术语源自这样一个观念：给定相同的输入，总是得到相同的输出，因此在计算中，您基本上可以用函数调用交换最终值，只要这些输入存在。例如：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The call to addTen with a parameter of 10 will *always* evaluate to 20, with
    no exceptions. There are no possible side effects in a function this simple, either.
    Consequently, the reference to addTen(10) could in principle be exchanged for
    a constant value of 20 with no side effects. This is Referential Transparency.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数为 10 调用 addTen 将始终计算为 20，没有任何异常。在这么简单的函数中也不可能存在任何副作用。因此，可以在原则上将对 addTen(10)
    的引用替换为常量值 20 而没有副作用。这就是引用透明度。
- en: 'Here are some pure functions:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些纯函数：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note no side effect can occur (I made sure a null check was included with the
    string) and nothing outside the function is altered, only a new value generated
    and returned.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意不能发生任何副作用（我确保字符串包含了空检查），函数外部没有任何改变，只生成并返回了一个新值。
- en: 'Here are impure versions of those same functions:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这些相同函数的不纯版本：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In both of these cases there are reference to properties of the current class
    that are beyond the scope of the function itself. The Add function even modifies
    that state property. No null check on the SayHello function either. All of these
    factors mean we cannot consider these functions to be “pure”.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，都引用了当前类的属性，这超出了函数本身的范围。Add 函数甚至修改了该状态属性。SayHello 函数也没有空检查。所有这些因素意味着我们不能将这些函数视为“纯”的。
- en: How about these?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些如何？
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: None of these are likely to be pure.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都不太可能是纯的。
- en: SayHello relies on a function outside itself. I don’t actually know what `GetName()`
    does^([4](ch01.html#idm45400886017232)). If it’s simply returning a constant,
    then we *can* consider `SayHello()` to be pure. If on the other hand, it’s doing
    a lookup in a database table, then the possibility exists for missing data or
    lost network packets resulting in errors being thrown, all examples of unexpected
    side effects. If a function *had* to be used for retrieving the name, I’d consider
    re-writing this with a `Func<T,TResult>` delegate to inject the functionality
    safely into our SayHello function.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: SayHello 依赖于函数本身之外的功能。我并不确切知道 `GetName()` 做了什么^([4](ch01.html#idm45400886017232))。如果它只是返回一个常量，那么我们*可以*认为
    `SayHello()` 是纯的。另一方面，如果它在数据库表中进行查找，那么可能会出现缺少数据或丢失网络数据包导致抛出错误，这些都是意外副作用的例子。如果必须使用函数来检索名称，我会考虑使用
    `Func<T, TResult>` 委托来安全地将功能注入到我们的 SayHello 函数中。
- en: SayHello2 modifies the object being passed in - a clear side effect from use
    of this function. Passing objects by reference and modifying them like this isn’t
    all that unusual a practice in Object-Oriented code, but it’s absolutely not a
    thing done in functional programming. I’d perhaps make this pure by separating
    out the update to the object properties and the processing of saying hello into
    separate funtions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: SayHello2 修改了传入的对象 - 这是使用该函数的一个明显副作用。通过引用传递对象并像这样修改它们在面向对象编程中并不罕见，但在函数式编程中绝对不会这样做。我可能会通过将对象属性的更新和打招呼的处理分离为不同的函数来使其成为纯函数。
- en: SayHello3 uses `DateTime.Now`, which returns a different value each and every
    time it’s ever used. The absolute oposite of a pure function. One easy way to
    fix this is by adding a `DateTime` parameter to the function and passing the value
    in.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: SayHello3 使用了 `DateTime.Now`，每次使用时返回不同的值。这与纯函数的完全相反。修复的一种简单方法是在函数中添加一个 `DateTime`
    参数，并将该值传递进去。
- en: referential transparency is one of the features that massively increases the
    testability of functional code. It does mean that other techniques have to be
    used to track state, I’ll get into that later.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 引用透明度是显著增加功能代码可测试性的特征之一。这意味着必须使用其他技术来跟踪状态，稍后我会详细说明。
- en: There is also a limit to how much “purity” we can have in our application, especially
    once we have to interact with the outside world, the user, or some 3rd party libraries
    that don’t follow the functional paradigm. In C#, we’re always going to have to
    make compromises here or there.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，尤其是一旦我们不得不与外界，用户或一些不遵循函数范式的第三方库进行交互时，我们的“纯度”存在一定的限制。在这里或那里，我们总是不得不做出妥协。
- en: 'There’s a metaphor I usually like to wheel out at this point. A Shadow has
    two parts: the Umbra and Penumbra^([5](ch01.html#idm45400886012000)). The Umbra
    is the solid dark part of a shadow, most of the shadow in fact. The Penumbra is
    the grey fuzzy circle around the outside, the part where Shadow and Not-Shadow
    meet and one fades into the other. In C# applications, I imagine that the pure
    area of the code base is the Umbra, and the areas of compromise are the Penumbra.
    My task is to maximize the Pure area, and minimize as much as humanly possible
    the non-Pure area.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我通常喜欢引用一个比喻。影子有两部分：本影和半影^([5](ch01.html#idm45400886012000))。本影是影子的实心黑暗部分，事实上大部分影子都是本影。半影是围绕外部的灰色模糊圆圈，是影子和非影子相遇的部分，一个渐变为另一个的部分。在C#应用程序中，我想象纯粹代码区域是本影，而妥协区域是半影。我的任务是最大化纯粹区域，并尽可能减少非纯粹区域。
- en: '![The Umbra and Penumbra of a shadow](assets/umbra-penumbra.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![影子的本影和半影](assets/umbra-penumbra.jpg)'
- en: If you want a more formal definition of this architectural pattern, Gary Bernhardt
    has given talks calling it Functional Core, Imperative Shell^([6](ch01.html#idm45400886009296)).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要这种架构模式的更正式定义，Gary Bernhardt曾在演讲中称其为功能核心，命令式外壳^([6](ch01.html#idm45400886009296))。
- en: Recursion
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归
- en: 'If you don’t understand this, see: Recursion Otherwise, see: Seriously, Recursion'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不理解这个，请参见：递归，否则请参见：说真的，递归
- en: Seriously, Recursion
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 说真的，递归
- en: Recursion has been around for as long as programming, pretty much. It’s a function
    that calls itself in order to effect an indefinite (but hopefully not infinite)
    loop. This should be familiar to anyone that’s ever written code to traverse a
    folder structure, or perhaps written an efficient sorting algorithm.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 递归几乎存在于编程的整个历史中。它是一个调用自身以实现无限（但希望不是无限的）循环的函数。这对于曾经编写过用于遍历文件夹结构或编写高效排序算法的人来说应该是熟悉的。
- en: 'A recursive function typically comes in 2 parts:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数通常分为两部分：
- en: A condition, used to determine whether the function should be called again,
    or whether an end-state has been reached (e.g. the value we’re trying to calculate
    has been found, there are no sub-folders to explore, etc.)
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件，用于确定是否应再次调用函数，或者是否已达到最终状态（例如已找到我们正在计算的值，没有子文件夹可探索等）。
- en: A return statement, which either returns a final value, or references the same
    function again, depending on the outcome of the end-state condition.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回语句，它要么返回最终值，要么引用同一个函数，具体取决于最终状态条件的结果。
- en: 'Here is a very simple recursive Add^([7](ch01.html#idm45400886001568)):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个非常简单的递归加法^([7](ch01.html#idm45400886001568))：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Silly though the example above is, note that I never change the value of either
    parameter integers. Each call to the recursive function used parameter values
    based on the ones it itself received. This is another example of *Immutability*
    - I’m not changing values in a variable, I’m making a call to a function using
    using an expression based on the values received.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管上述例子很愚蠢，但请注意，我从未更改任何参数整数的值。递归函数的每次调用都使用基于其自身接收的值的参数值。这是*不可变性*的另一个例子 - 我没有改变变量中的值，而是使用基于接收到的值的表达式调用函数。
- en: Recursion is one of the methods Functional Programming uses as an alternative
    to statements like While and ForEach. There are some performance issues in C#,
    however. There is a whole chapter coming up at a later point to discuss Recursion
    in more detail, but for now just use it cautiously, and stick with me. All will
    become clear…​
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是函数式编程用作替代While和ForEach语句的方法之一。然而，在C#中存在一些性能问题。稍后将会有一个章节来更详细地讨论递归，但现在请谨慎使用，并跟随我的步伐。一切将会变得清晰...​
- en: Pattern Matching
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模式匹配
- en: In C# this is basically `Switch` statements with “go-faster” stripes. F# takes
    the concept further, though. We’ve pretty much had this in C# for a few versions
    now. The `Switch` expressions introduced in C# 8 introduced our own native implementation
    of this concept, and the Microsoft team has been enhancing it regularly.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，这基本上就是带有“加速”条纹的 `Switch` 语句。不过，F# 将这个概念推向了更深的层次。在几个版本后，我们已经在 C# 中实现了这一概念，C#
    8 中引入的 `Switch` 表达式就是我们自己的本地实现，而 Microsoft 团队一直在不断增强它。
- en: 'It’s switching where you can change the path of execution on the type of the
    object under examination, as well as its properties. It can be used to reduce
    a large, set of nested if-statements like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以根据对象的类型和属性改变执行路径，可以用来减少一组大量嵌套的 if 语句，例如这样：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'into a few fairly concise lines, like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 简化为几行，像这样：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It’s an incredible, powerful feature, and one of my favourite things^([8](ch01.html#idm45400886708432)).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个令人难以置信且强大的特性，也是我最喜欢的事情之一^([8](ch01.html#idm45400886708432))。
- en: There are many examples of this coming up in the next couple of chapters, so
    skip ahead if you’re interested in seeing more about what this is all about.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中会有许多这样的例子，如果你对看到更多关于这一切的内容感兴趣的话，可以跳过。
- en: Also, for those stuck using older versions of C#, there are ways of implementing
    this, and I’ll show a few tips on it later.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于那些仍在使用旧版本的 C# 的人来说，有实现这一方法的方式，稍后我将展示一些技巧。
- en: Stateless
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无状态的
- en: 'Object-Oriented code typically has a set of state objects, which represent
    a process - either real, or virtual. These state objects are updated periodically,
    to keep in sync with whatever it is they represent. Something like this, for example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的代码通常有一组状态对象，它们表示一个过程 - 真实的或虚拟的。这些状态对象定期更新，以保持与它们所代表的内容同步。例如像这样的东西：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Well, forget ever doing that again if you want to do Functional Programming.
    There is no concept of a central state object, or of modifying its properties,
    like in the code sample, above.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，如果你想要进行函数式编程，就永远不要再做那种事了。没有一个中心状态对象的概念，也没有修改其属性的概念，就像上面的代码示例中一样。
- en: Seriously? Feels like purest craziness, doesn’t it? Strictly, there **is** a
    state, but it’s more of an emergent property of the system.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 真的吗？感觉像是最纯粹的疯狂，不是吗？严格来说，确实有一个状态，但更多地是系统的 emergent property。
- en: 'Anyone that’s ever worked with React-Redux has already been exposed to the
    Functional approach to state (which was, in turn, inspired by the Functional Programming
    language, *Elm*). In Redux, the application state is an immutable object, which
    isn’t updated, but instead a function is defined by the developer that takes the
    old state, a command, and any required parameters, then returns a new state object
    based on the old one. This process became infinitely easier in C# with the introduction
    of Record types in C# 9\. I’ll talk more on that later. For now though, a simple
    version of how one of the repository functions might be refactored to work functionally
    might be something like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 任何曾经使用 React-Redux 的人已经接触过状态的函数式方法（这反过来又受到函数式编程语言 *Elm* 的启发）。在 Redux 中，应用程序状态是一个不可变对象，不进行更新，而是由开发者定义一个函数，该函数接受旧状态、一个命令和任何必要的参数，然后基于旧状态返回一个新的状态对象。在
    C# 9 中引入 Record 类型后，这个过程变得非常容易。稍后我会详细讨论这个问题。但现在，关于如何重构其中一个存储库函数以函数方式运行的简单版本，可能会是这样：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There would obviously be a difference in how this was used, outside the repository
    as well. In fact, calling it a repository is probably a bit of a mistake now.
    I’ll talk more about the strategies required for writing code without state objects
    later. Hopefully this is enough to get an idea of how Functional code might work.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在外部使用时，它的使用方式会有所不同。事实上，现在称其为存储库可能有点错误。稍后我将更多地讨论编写无状态对象代码所需的策略。希望这足以让你了解函数式代码的工作方式。
- en: Baking Cakes
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 烘焙蛋糕
- en: 'If you want a slightly higher level of description of the difference between
    those paradigms. Here’s how they’d both make cupcakes^([9](ch01.html#idm45400888316656)):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想对这些范式之间的差异稍微高级一点的描述。这是它们如何都能制作蛋糕^([9](ch01.html#idm45400888316656))：
- en: An Imperative Cake
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个命令式的蛋糕
- en: This isn’t real C# code, just a sort of .NET themed pseudo-code to give an impression
    of the imperative solution to this imaginary problem.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是真正的 C# 代码，只是一种 .NET 主题的伪代码，用来给这个虚构的问题提供命令式解决方案的印象。
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For me, this represents typical convoluted imperative code. Plenty of little
    short-lived variables cooked up to track state. It’s also very concerned with
    the very precise order of things. It’s more like instructions given to a robot
    with no intelligence at all, needing everything spelled out for them.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，这代表了典型的复杂的命令式代码。有很多小的短暂变量用来跟踪状态。它也非常关注事情的精确顺序。更像是给一个完全没有智能的机器人的指令，需要一切都明确指出。
- en: A Declarative Cake
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个声明式的蛋糕
- en: 'Here’s what an entirely imaginary bit of Declaritive code might look like to
    solve the same problem:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个完全虚构的声明式代码可能如何解决同样问题的例子：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That might look odd and unusual for now, if you’re unfamililar with Functional
    Programming, but over the course of this book, I’m going to explain how this all
    works, what the benefits are, and how you can implement all of this yourself in
    C#.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对函数式编程不熟悉，现在看起来可能有些奇怪和不寻常，但在这本书的过程中，我将解释这一切是如何工作的，其好处是什么，以及如何在C#中自己实现这一切。
- en: What’s worth noting though, is that there are no state tracking variables, no
    `If` or `While` statements. I’m not even sure what the order of operations would
    necessarily be, and it doesn’t matter, because the system will work so that any
    necessary steps are completed at the point of need.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，值得注意的是，这里没有状态跟踪变量，也没有`If`或`While`语句。我甚至不确定操作的顺序一定是什么，但这并不重要，因为系统会按需完成任何必要的步骤。
- en: This is more like instructions for a slightly more intelligent robot. One that
    can think a little for itself, at least as far as instructions that might sound
    something like “do this until such-and-such a state exists” which in procedural
    code would exist by combining a While loop and some state tracking code lines.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这更像是给一个稍微聪明一点的机器人的指令。至少可以自己思考一下，至少在过程式代码中可以通过组合一个While循环和一些状态跟踪代码行来存在“直到某种状态存在”的指令。
- en: Where does Functional Programming Come From?
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程从何而来？
- en: The first thing I want to get out of the way is that despite what some people
    might think, Functional Programming is old. *Really* old - by computing standards
    at least. My point being - it isn’t like the latest trendy JavaScript framework,
    here this year, so much old news next year. It predates all modern programming
    languages, and even computing itself to some extent. Functional has been around
    for longer than any of us, and it’s likely to be around long after we’re all happily
    retired. My slightly belabored point is that it’s worth investing your time and
    energy to learn and understand it. Even if one day you find yourself no longer
    working in C#, most other languages support Functional concepts to a greater or
    lesser degree (JavaScript does to an extent that most languages can only dream
    of), so these skills will remain relevant throughout the rest of your career.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我想先澄清一件事，尽管有些人可能会这么认为，函数式编程已经存在很久了。*真的* 很久了 - 至少从计算的角度来看是这样。我的观点是 - 它不像是最新潮的JavaScript框架，今年很火，明年就可能过时了。它比所有现代编程语言甚至计算本身都要古老。函数式编程比我们任何人都要早，而且很可能在我们都退休之后仍然存在。我稍微有些强调的观点是，投资时间和精力来学习和理解它是值得的。即使有一天你发现自己不再在C#中工作，大多数其他编程语言都在不同程度上支持函数式概念（JavaScript在某种程度上甚至超越了大多数语言的梦想），因此这些技能在你职业生涯的其余部分仍然很重要。
- en: A quick caveat before I continue with this section - I’m not a mathematician.
    I love mathematics, it was one of my favourite subjects at school, college & university,
    but there eventually comes a level of higher, theoretical mathematics that leaves
    even me with glazed-over eyes and a mild headache. That said, I’ll do my best
    to talk briefly about where exactly Functional Programming came from. Which was,
    indeed, that very world of theoretical mathematics.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我继续本节之前，有一个小提示 - 我不是数学家。我喜欢数学，它是我在学校、大学和大学里最喜欢的科目之一，但最终会有一个更高层次的理论数学，即使是我自己也会眼花缭乱，头疼。话虽如此，我会尽力简要地谈谈函数式编程究竟来自哪里。实际上，它来自于那个理论数学的世界。
- en: 'The first figure in the history of Functional Programming most people can name
    is usually Haskell Brooks Curry (1900-1982), an American mathematician that now
    has no fewer than three programming languages named after him, as well as the
    Functional concept of “Currying” (of which, more later). His work was on something
    called “Combinatory Logic” - a mathematical concept that involves writing out
    functions in the form of lambda (or arrow) expressions, and then combining them
    to create more complex logic. This is the fundamental basis of Functional Programming.
    Curry wasn’t the first to work on this though, he was following on from papers
    and books written by his mathematical predecessors, people like:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人能够提及的函数式编程历史上的第一位人物通常是哈斯克尔·布鲁克斯·柯里（1900-1982年），一位美国数学家，他现在有至少三种以他命名的编程语言，以及函数式概念“柯里化”（稍后详述）。他的工作是在称为“组合逻辑”的东西上进行的
    - 一种涉及以lambda（或箭头）表达式形式编写函数，然后组合它们以创建更复杂逻辑的数学概念。这是函数式编程的基础。尽管柯里并不是第一个研究这个问题的人，但他是在他的数学前辈撰写的论文和书籍之后。
- en: Alonzo Church (1903-1955, American) - It’s Church that coined the term “Lambda
    Expression” that we use in C#, and other languages, to this day.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阿隆佐·丘奇（1903-1955年，美国人） - 正是丘奇创造了我们今天在C#等语言中使用的“Lambda表达式”这一术语。
- en: Moses Schönfinkel (1888-1942, Russian) - Schönfinkel wrote papers on Combinatory
    logic that were one of the bases for Haskell Curry’s work
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摩西·绍恩菲克尔（1888-1942年，俄罗斯人） - 绍恩菲克尔撰写了有关组合逻辑的论文，这是哈斯克尔·柯里工作的基础之一。
- en: Friedrich Frege (1848-1925, German) - Arguably the first person to describe
    the concept we now know as Currying. As important as it is to credit the correct
    people with discoveries, Freging doesn’t quite have the same ring^([10](ch01.html#idm45400887929376)).
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弗里德里希·弗雷格（1848-1925年，德国人） - 可以说是首个描述我们现在称之为柯里化的概念的人。尽管很重要要正确地归功于发现者，但弗雷格并不完全拥有同样的影响力。
- en: 'The first Functional programming languages were:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第一批函数式编程语言是：
- en: IPL (Information Processing Language), developed in 1956 by Allen Newell (1927-1992,
    American), Cliff Shaw (1922-1991, American) and Herbert Simon (1916-2001, American)
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPL（信息处理语言），由艾伦·纽厄尔（1927-1992年，美国人）、克利夫·肖（1922-1991年，美国人）和赫伯特·西蒙（1916-2001年，美国人）于1956年开发。
- en: LISP (LISt Processor), developed in 1958 by John McCarthy (1927-2011, American).
    I hear tell that LISP still has its fans to this day, and is still in production
    use in some businesses. I’ve never seen any direct evidence of this myself, however.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LISP（LISt Processor），由约翰·麦卡锡（1927-2011年，美国人）于1958年开发。据说，LISP至今仍有一些忠实的粉丝，并且在一些企业中仍在生产使用。不过我个人从未见过直接的证据。
- en: Interestingly, neither of these languages are what you would call “pure” functional.
    Like C#, Java, and numerous other languages, they adopted something of a hybrid
    approach, unlike the modern “pure” functional languages, like Haskell and Elm.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，这两种语言都不被称为“纯”函数式语言。像C#、Java和许多其他语言一样，它们采用了一种混合的方法，不像现代的“纯”函数式语言，如Haskell和Elm。
- en: I don’t want to dwell too long on the (admittedly, fascinating) history of Functional
    Programming, but it’s hopefully obvious from what I have shown, that it has a
    long and illustrious pedigree.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我不想过多地谈论（尽管有趣的）函数式编程的历史，但希望从我展示的内容中很明显，它有着悠久而辉煌的传统。
- en: Who Else Does Functional Programming?
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有谁在进行函数式编程？
- en: As I’ve already said, Functional Programming has been around for a while, and
    it’s not just .NET developers that are showing an interest. Quite the opposite,
    many other languages have been offering Functional Paradigm support for a lot
    longer than .NET.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所说，函数式编程已经存在了一段时间，不只是.NET开发人员对其表现出兴趣。相反，许多其他语言比.NET提供了更长时间的函数式范式支持。
- en: 'What do I mean by support? I mean that it offers the ability to implement code
    in the Functional Paradigm. This comes in roughly two flavours:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我说支持是指它提供了在函数式范式中实现代码的能力。这大致有两种风味：
- en: Pure Functional Languages
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数式语言
- en: Intended for the developer to write exclusively Functional code. All variables
    are immutable, offers Currying, Higher-order Functions, etc. out-of-the-box. Some
    features of Object-Orientation might be possible in these languages, but it’s
    very much a secondary concern to the team behind them.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 旨在让开发人员专门编写函数式代码。所有变量都是不可变的，提供了柯里化、高阶函数等功能。这些语言可能也能实现一些面向对象的特性，但这显然不是开发团队的首要关注点。
- en: Hybrid or Multi-Paradigm Languages
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 混合或多范式语言
- en: These two terms can be used entirely interchangably. They describe programming
    languages that offer the features to allow code to be written in two or more paradigms.
    Often two or more at the same time. Supported paradigms are typically Functional
    and Object-Oriented. There may not be a perfect implementation available of any
    supported paradigms. It’s not unusual for Object Orientation to be fully supported,
    but not all of the features of Functional to be available to use.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个术语可以完全互换使用。它们描述了能够在两种或更多范式中编写代码的编程语言。通常同时支持的范式是功能性和面向对象的。可能不存在任何支持范式的完美实现。通常情况下，面向对象可能完全支持，但并非所有功能性的特性都可用。
- en: Pure Functional Languages
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯功能性编程语言
- en: 'There are also well over a dozen pure functional languages around, here is
    a brief look at the most popular three in use today:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有超过十几种纯功能语言，这里简要介绍今天使用最广泛的三种：
- en: Haskell
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell
- en: Haskell is used extensively in the banking industry. It’s often recommended
    as a great starting place for anyone wanting to really, really get to grips with
    Functional Programming. This may well be the case, but honestly, I don’t have
    the time or headspace free to learn an entire programming language I never intend
    to use in my day job.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell在银行业被广泛使用。对于任何真正想深入掌握功能性编程的人来说，它经常被推荐作为一个很好的起点。这可能确实如此，但老实说，我没有时间和精力去学习一门我在日常工作中根本不打算使用的完整编程语言。
- en: If you’re really interested in becoming an expert in the Functional Paradigm
    before working with it in C#, then by all means go ahead and seek out Haskell
    content. A frequent recommendation for that is “Learn You a Haskell For Great
    Good” by Miran Lipovača^([11](ch01.html#idm45400887916080)). I have never read
    this book myself, but friends of mine have and say it’s great.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的有兴趣在在工作前先成为一个功能范式的专家，那么请务必去寻找Haskell的内容。一个经常推荐的资源是Miran Lipovača的《Learn
    You a Haskell For Great Good》^([11](ch01.html#idm45400887916080))。我自己从未读过这本书，但我的朋友们读过并称赞它很棒。
- en: Elm
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Elm
- en: Elm seems to be gaining some traction these days, if for no other reason that
    the Elm system for performing updates in the UI has been picked up and implemented
    in quite a few other projects, including ReactJS. This “Elm Architecture” is something
    I want to save for a later chapter.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Elm似乎最近有些流行起来，即使只是因为Elm在UI中执行更新的系统已被许多其他项目采纳和实施，包括ReactJS。这种“Elm架构”是我想留到后面章节讨论的内容。
- en: Elixir
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Elixir
- en: A general-purpose programming language based on the same Virtual Machine that
    Erlang runs on. It’s very popular in industry and even has its own conferences
    annually.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 基于与Erlang相同的虚拟机的通用编程语言。它在工业界非常流行，甚至每年都有自己的会议。
- en: PureScript
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: PureScript
- en: PureScript compiles to JavaScript, so it can be used to create functional front-end
    code, as well as server-side code and desktop applications in isometric programming
    environments - i.e. those like Node.JS that allow the same language to be used
    client and server side.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: PureScript编译成JavaScript，因此可以用于创建功能性的前端代码，以及服务器端代码和在等距编程环境中创建桌面应用程序——例如Node.JS，它允许在客户端和服务器端使用同一种语言。
- en: Is It Worth Learning a Pure Functional Language First?
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习一门纯功能语言是否值得？
- en: For the time being at least, OO is the dominent paradigm for the vast majority
    of the software development world, and the Functional Paradigm something that
    has to be learned afterwards. I don’t rule out that changing in future, but for
    now at least, this is the situation we’re in.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 至少在目前，面向对象在绝大多数软件开发世界中占主导地位，功能性范式则是后来才需要学习的。我不排除将来可能会有所改变，但目前至少我们处于这种情况中。
- en: I have heard people argue the point that, coming from OO, it would be best to
    learn Functional Programming in its pure form *first* then come back to apply
    that learning in C#.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我听到有人争论说，从面向对象来看，最好先学习其纯形式的功能性编程，然后再回来将这些学习应用在C#中。
- en: If that’s what you *want* to do, go for it. Have fun. I have no doubt that it’s
    a worthwhile endeavor.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是你想做的事情，那就去做吧。愉快地享受吧。我毫不怀疑这是一个值得的努力。
- en: To me, this perspective puts me in mind of those teachers we used to have here,
    in the UK that insisted that children should learn Latin, because as the root
    of many European languages, knowledge of Latin can easily be transferred to French,
    Italian, Spanish, etc.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，这个观点让我想起了我们这里曾经有的那些老师，他们坚持认为孩子们应该学习拉丁语，因为作为许多欧洲语言的根源，拉丁语的知识可以很容易地转移到法语、意大利语、西班牙语等。
- en: I disagree with this somewhat ^([12](ch01.html#idm45400887905136)). Unlike Latin,
    Pure Functional languages aren’t necessarily *difficult*, though they are very
    unlike Object-Oriented development. In fact, there are fewer concepts to learn
    witih FP compared to OO. This said - those that have spent their careers heavily
    involved in OO development will likely find it harder to adjust.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我在某种程度上不同意这一点^([12](ch01.html#idm45400887905136))。与拉丁语不同，纯函数式语言不一定是*困难*的，尽管它们与面向对象开发非常不同。事实上，与面向对象相比，FP
    的概念要少得多。话虽如此，那些在整个职业生涯中深度参与面向对象开发的人可能会发现调整更为困难。
- en: Where Latin and pure functional languages are similar though is that they represent
    a purer, ancestral form. They are both of only limited value outside of a small
    number of specialist interests.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，拉丁语和纯函数式语言的相似之处在于它们代表了更纯粹、祖先的形式。它们在少数专业兴趣领域之外的价值都很有限。
- en: Learning Latin is also almost entirely *useless* unless you’re interested in
    Law, classical literature, Ancient History, etc. It’s far more useful to learn
    modern French or Italian. They’re easier languages to learn by far, and you can
    use them *now* to visit lovely places and talk to the nice people that live there.
    There are some great French-language comics from Belgium too. Check ‘em out. I’ll
    wait.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 学习拉丁语几乎完全是*无用*的，除非你对法律、古典文学、古代历史等感兴趣。学习现代法语或意大利语更有用得多。它们远比拉丁语易学，而且你可以*现在*用它们去访问美丽的地方并与那里的友好人士交流。比利时也有一些很棒的法语漫画。去看看吧，我会等你的。
- en: In the same way, very few places will ever actually use Pure Functional languages
    in production. You’d be spending a lot of time having to make a complete shift
    in the way you work, and end up learning a language you’ll probably never use
    outside of your own hobby code. I’ve been doing this job for a long time, and
    I’ve never yet encountered a company using anything more progressive in actual
    production than C#.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，很少有地方会真正将纯函数式语言用于生产。你将会花费大量时间完全改变你的工作方式，并最终学习一门你可能永远不会在自己的业余代码之外使用的语言。我已经做这个工作很长时间了，到目前为止，我从未遇到过一家公司在实际生产中使用比
    C# 更先进的东西。
- en: The lovely thing about C# is that is supports both OO *and* Functional style
    code, so you can shift between them as you please. Use as many features from one
    paradigm or the other as you like without any penalty. The paradigms can sit fairly
    comfortably alongside each other in the same codebase, so it’s an easy environment
    to transition from pure OO to Functional at a pace that suits you, or vice-versa.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: C# 的美妙之处在于它支持面向对象*和*函数式风格的代码，因此您可以根据需要在它们之间切换。您可以在同一个代码库中舒适地使用其中一个范式或另一个范式的许多特性，而无需任何惩罚。这两种范式可以在同一代码库中相对轻松地并存，因此您可以以适合自己的节奏从纯面向对象转向函数式，反之亦然。
- en: That isn’t possible in a pure Functional language, even if there are a lot of
    Functional features that aren’t possible in C#.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数式语言中是不可能的，即使 C# 中有很多函数式特性是不可能的。
- en: What about F#? Should I be learning F#?
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么 F# 呢？我应该学习 F# 吗？
- en: This is probably the most common question I get asked. What about F#? It’s not
    a pure Functional language, but the needle is far closer to being a proper implementation
    of the paradigm than C#. It has a wide variety of functional features straight
    out-of-the-box, as well as being easy to code in and highly performant - why not
    use that?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是我经常被问到的最常见的问题。那么 F# 呢？它并不是一种纯函数式语言，但是它更接近于正确实现这种范式而不是 C#。它拥有各种各样的函数式特性，可以直接使用，并且编码简单且性能出色
    - 为什么不使用呢？
- en: I always like to check the available exits in the room before I answer this
    question. F# has a passionate userbase, and they are probably all much smarter
    folks than me^([13](ch01.html#idm45400887897808)). But…​
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在回答这个问题之前，我总是喜欢检查房间里的出口情况。F# 有一群热情的用户，他们可能都比我聪明^([13](ch01.html#idm45400887897808))。但是……
- en: It’s not because F# isn’t easy to learn. It is, from what I’ve seen, and most
    likely it’s easier to learn than C# if you’re entirely new to programming.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是因为 F# 难学。从我看来，它确实容易学习，如果你完全是编程新手，那它很可能比 C# 更容易学习。
- en: It’s not that F# won’t bring business benefits, because I honestly believe it
    will.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是说 F# 不会带来商业利益，因为我真诚地相信它会。
- en: It’s not that F# can’t do absolutely everything any other language can do. It
    most certainly can. I’ve seen some impressive talks on how to make full-stack
    F# web applications.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是说 F# 不能做任何其他语言能做的事情。它肯定可以。我见过一些关于如何制作全栈 F# Web 应用程序的令人印象深刻的演讲。
- en: It’s a professional decision. It isn’t hard to find C# developers, at least
    in any country I’ve ever visited. If I were to put the names of every attendee
    of a big developers’ conference in a hat and draw one at random, there’s a better
    than even chance it would be someone that can write C# professionally. If a team
    decides to invest in a C# codebase, it’s not going to be much of a struggle to
    keep the team populated with engineers that will be able to keep the code well
    maintained, and the business relatively content.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个专业决定。在我去过的每个国家，至少找到C#开发者并不困难。如果我要把大型开发者大会的每个与会者的名字都放在帽子里，随机抽取一个，那么这个人很可能能够专业地编写C#代码。如果团队决定投资于C#代码库，那么保持团队中有足够工程师来保持代码的良好维护，让业务相对满意，将不会是一件艰难的事情。
- en: Developers that know F# on the other hand are relatively rare. I don’t know
    many. By adding F# into your codebase you may be putting a dependency on the team
    to ensure you always have enough people available that know it, or else take a
    risk that some areas of the code will be hard to maintain, because few people
    know how.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，了解F#的开发人员相对较少。我认识的不多。通过在代码库中加入F#，你可能会依赖团队确保始终有足够的了解F#的人可用，否则可能会冒一些代码难以维护的风险，因为了解该语言的人数不多。
- en: I should note that the risk isn’t as high as introducing an entirely new technology,
    like, say, Node.JS. F# is still a .NET language and compiles to the same Intermediate
    Language. You can even easily reference F# projects from C# projects in the same
    solution. It would still be an entirely unfamiliar syntax to the majority of .NET
    developers, however.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该指出，风险并不像引入全新技术那样高，比如说Node.JS。F#仍然是一种.NET语言，编译成相同的中间语言。你甚至可以在同一个解决方案中轻松引用F#项目和C#项目。然而，对于大多数.NET开发者来说，这仍然是一种完全陌生的语法。
- en: It’s my firm wish that this changes as time goes on. I’ve liked very much what
    I’ve seen of F#, and I’d love to do more of it. If my boss told me that a business
    decision had been made to adopt F#, I’d be the first to cheer!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，我坚定地希望这种情况会有所改变。我非常喜欢我所看到的F#，并且我很愿意做更多相关工作。如果我的老板告诉我，已经做出了采纳F#的业务决定，我会第一个欢呼！
- en: Fact is though, it’s not really a very likely scenario at present. Who knows
    what the future will bring. Maybe a future edition of this book will have to be
    heavily re-written to accomodate all the love for F# that’s suddenly sprung up,
    but for now I can’t see that on the near horizon.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 事实是，目前这种情况并不是真正的可能性。谁知道未来会带来什么变化。也许这本书的将来版本将不得不进行大幅修改，以适应突然兴起的对F#的热爱，但就目前而言，我看不到这种情况在近期会发生。
- en: My recommendation would be to try this book first. If you like what you see,
    maybe F# might be the next place you go on your Functional journey.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议先试读这本书。如果你喜欢所见的内容，也许F#可能会是你下一个函数式编程之旅的目的地。
- en: Multi-Paradigm Languages
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多范式语言
- en: It can probably be argued that all languages besides the Pure Functional languages
    are some form of hybrid. In other words, that at least *some* aspects of the functional
    paradigm can be implemented. That’s likely true, but I’m just going to look briefly
    at a few where it can be implemented entirely, or mostly, and as a feature provided
    explicitly by the team behind it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 可能可以认为除了纯函数式语言之外的所有语言都是某种形式的混合语言。换句话说，至少可以实现一些函数式编程范式的一些方面。这可能是真的，但我只是简要地看一下一些完全或大部分可以实现这一特性的语言，并且这些语言团队明确提供了这一功能。
- en: JavaScript
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript
- en: 'JavaScript is of course almost the wild-west of programming languages in the
    way that nearly anything can be done with it, and it does Functional very, very
    well. Arguably better than it does Object Orientation. Have a look for *Javascript:
    The Good Parts* by Douglas Crockford and some of his online lectures (for example
    [*https://www.youtube.com/watch?v=_DKkVvOt6dk*](https://www.youtube.com/watch?v=_DKkVvOt6dk))
    if you want an insight into how to do JS Functionally and properly.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 'JavaScript当然几乎就像编程语言的狂野西部，几乎任何事情都可以用它来实现，并且它在函数式编程方面表现得非常出色。可以说它在函数式编程方面表现得比面向对象编程还要好。如果你想了解如何正确地使用JS进行函数式编程，请查看Douglas
    Crockford的《JavaScript: The Good Parts》以及他的一些在线讲座（例如[https://www.youtube.com/watch?v=_DKkVvOt6dk](https://www.youtube.com/watch?v=_DKkVvOt6dk)）。'
- en: Python
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: 'Python has rapidly become a favourite programming language for the open source
    community, just over the last few years. It surprised me to find out it’s been
    around since the late 80s! Python supports higher-order functions and has a few
    libraries available: *itertools* and *functools* to allow further functional features
    to be implemented.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Python 迅速成为了开源社区的最爱编程语言，就在过去的几年里。让我惊讶的是它竟然存在于80年代末期！Python支持高阶函数，并提供了一些库：*itertools*
    和 *functools*，以允许进一步实现函数式特性。
- en: Java
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Java
- en: The Java platform has the same level of support for Functional features as .NET.
    Further to that, there are spin-off projects such as Scala, Clojure and Kotlin
    that offer far more Functional features than the Java language itself does.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Java 平台对函数式特性的支持与.NET相同。此外，还有一些分支项目，如Scala、Clojure和Kotlin，提供的函数式特性远远超过了Java语言本身。
- en: F#
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: F#
- en: I’ve already discussed this at length in a previous section, so I won’t go into
    it much more now. This is .NET’s more purely Functional style language. It’s also
    possible to have interoperability between C# and F# libraries, so you can have
    projects that utilize all the best features of both.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在前一节中详细讨论过这个问题，所以现在我不会再多说了。这是.NET更纯粹的函数式风格语言。C#和F#库之间也可以进行互操作性，因此您可以使用两者的最佳功能来构建项目。
- en: C#
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: C#
- en: Microsoft has slowly been adding in support for Functional Programming ever
    since somewhere near the beginning. Arguably the introduction of Delegate Covariance
    and Anonymous Methods in C# 2.0 all the way back in 2005 could be considered the
    very first item to support the Functional paradigm. Things didn’t really get going
    properly until the following year when C# 3.0 introduced what I consider one of
    the most transformative features ever added to C#- LINQ.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 微软自从早期就慢慢地添加了对函数式编程的支持。可以说，委托协变性和C# 2.0中的匿名方法的引入可能被认为是支持函数式范式的第一个项目。事情真正开始启动是在接下来的一年，当C#
    3.0引入我认为是迄今为止添加到C#中的最具变革性的功能之一时- LINQ。
- en: I’ll talk more about it later, but LINQ is deeply rooted in the Functional paradigm,
    and one of our best tools for getting started writing Functional-style code in
    C#. In fact, it’s a stated goal of the C# team that each version of C# that is
    released should contain further support for Functional Programming than the one
    before it. There are a number of factors driving this decision, but amongst them
    is F#, which often requests new functional features from the .NET runtime folks
    that C# ends up benefiting from too.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我稍后会详细讨论它，但LINQ深深植根于函数式范式，并且是我们开始编写C#函数式代码的最佳工具之一。事实上，C#团队明确规定，每个发布的C#版本都应比之前的版本更加支持函数式编程。驱使这一决定的因素有很多，其中之一就是F#，它经常向.NET运行时团队请求C#最终也会从中受益的新的函数式特性。
- en: The Benefits of Functional Programming
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程的好处
- en: I hope that you picked this book up because you’re already sold on Functional
    Programming and want to get started right away. This section might be useful for
    team discussions about whether or not to use it at work.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你拿起这本书是因为你已经对函数式编程心生兴趣，并且想要立即开始。对于团队讨论是否在工作中使用它，本节可能会有所帮助。
- en: Concise
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简洁
- en: While not a feature of Functional Programming, my favourite of the many benefits
    is just how concise and elegant it looks, compared to Object-Oriented or Imperative
    code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不是函数式编程的特性，但我最喜欢的许多好处之一就是它看起来多么简洁和优雅，与面向对象或命令式代码相比。
- en: Other styles of code are much more concerned with the low-level details of *how*
    to do something, to the point that sometimes it can take an awful lot of code-staring
    just to work out what that something even *is*. Functional programming is orientated
    more towards describing *what* is needed. The details of precisely which variables
    are updated how and when to achieve that goal are less of our concern.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 其他代码风格更关注于*如何*做某事的低级细节，以至于有时候甚至需要大量的代码来弄清楚这个*某事*到底是什么。函数式编程更注重描述*需要什么*。为了实现这个目标，精确地更新哪些变量以及何时更新这些变量的细节不是我们关心的重点。
- en: Some developers I’ve spoken to about this have disliked the idea of being less
    involved with the lower levels of data processing, but I’m personally happier
    to let the execution environment take care of that, then it’s one thing fewer
    that I need to be concerned with.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经与一些开发者讨论过这个问题，他们不喜欢减少与数据处理底层的参与度的想法，但我个人更愿意让执行环境来处理这个问题，这样我就少了一件需要关心的事情。
- en: It feels like a minor thing, but I honestly love how concise Functional code
    is compared to the Imperative alternatives. The job of a developer is a difficult
    one^([14](ch01.html#idm45400888623008)), and we often inherit complex codebases
    that we need to get to grips with quickly. The longer and harder it is for you
    to work out what a function actually does, the more money the business is losing
    by paying you to do that, rather than writing new code. Functional code often
    reads in a way that describes - in something approaching natural language - what
    it is that’s being accomplished. It also makes it easier to find bugs, which again
    saves time and money for the business.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是一个小事情，但我真的很喜欢函数式代码相对于命令式替代方法的简洁性。开发者的工作是一项困难的工作^([14](ch01.html#idm45400888623008))，我们经常要处理需要快速掌握的复杂代码库。如果你很难理解一个函数到底做了什么，那么企业为支付你的这个费用，而不是编写新代码而损失的钱会越多。函数式代码通常以接近自然语言的方式描述正在完成的工作。这也使得查找错误变得更容易，进而节省了企业的时间和金钱。
- en: Testable
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可测试
- en: One thing a lot of people describe as their favorite feature of functional programming
    is how incredibly testable it is. It really is, as well. If your codebase isn’t
    testable to something close to 100%, then there’s a chance you didn’t follow the
    paradigm correctly.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 很多人称函数式编程的一个最喜欢的特性是它的测试性。事实上，它确实如此。如果你的代码库不能接近100%地进行测试，那么有可能你没有正确地遵循这种编程范式。
- en: Test-Driven Development (TDD) and Behavior-Driven Development (BDD) are important
    professional practices now. These are programming techniques that involve writing
    automated unit tests for the production code *first*, then writing the real code
    required to allow the test to pass. It tends to result in better-designed, more
    robust code. Functional Programming enables these practices neatly. This in turn
    results in better codebase and fewer bugs in production.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发（TDD）和行为驱动开发（BDD）现在是重要的专业实践。这些是编程技术，首先为生产代码编写自动化单元测试，然后编写确保测试通过的实际代码。它倾向于产生设计更好、更健壮的代码。函数式编程能够很好地支持这些实践。这反过来导致了更好的代码库和生产中更少的错误。
- en: Robust
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 健壮
- en: It’s also not just the testability that results in a more robust codebase. Functional
    Programming has structures within it that actively prevent errors either from
    occurring in the first place.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 功能性编程不仅仅是为了更健壮的代码库而设计的。它内部有结构，可以有效地防止错误发生。
- en: That, or they prevent any unexpected behaviour further on, making it easier
    to report the issue accurately. There is no concept of NULL in Functional Programming.
    That alone saves an incredible number of possible errors, as well as reducing
    the number of automated tests that need to be written.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它们会阻止任何进一步的意外行为，从而更容易准确报告问题。在函数式编程中不存在NULL的概念。这单独就可以避免大量可能的错误，同时减少需要编写的自动化测试数量。
- en: Predictable
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可预测
- en: Functional code starts at the beginning of the code block and works its way
    to the end. Exclusively in order. That’s something you can’t say of Procedural
    Code, with its Loops and branching If statements. There is only a single, easy
    to follow flow of code.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式代码从代码块的开头开始，按照顺序逐步执行。完全按照一种易于遵循的代码流程。这是过程式代码无法做到的。它有循环和分支语句。函数式代码只有单一且易于跟随的代码流。
- en: When done properly there aren’t even any Try/Catch blocks, which I’ve often
    found to be some of the worst offenders when it comes to code with an unpredictable
    order of operations. If the Try isn’t small in scope and tightly coupled to the
    Catch, then sometimes it can be the code equivalent of throwing a rock blindly
    up into the air. Who knows where it’ll land and who or what might catch it. Who
    can say what unexpected behavior might arise from such a break in the flow of
    the program.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正确执行，甚至不会有任何的Try/Catch块。我经常发现，这些块在处理操作顺序不可预测的代码时，是最严重的问题之一。如果Try块的范围不小并且与Catch紧密耦合，有时候它会像是盲目地把一块石头扔到空中一样。谁知道它会落在哪里，谁或者什么会接住它。谁能说这样的程序流中可能会出现什么意外行为呢。
- en: Improperly designed Try/Catch blocks have been at the back of many instances
    of unexpected behavior in production that I’ve observed over my career, and it’s
    a problem that simply doesn’t exist in the Functional paradigm.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的职业生涯中，不正确设计的Try/Catch块是我观察到的许多生产中意外行为的根源，这是一个在函数式范式中根本不存在的问题。
- en: Improper error handling is still possible in Functional code, but the very nature
    of Functional Programming discourages it.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式代码仍然可能存在不正确的错误处理，但函数式编程的本质会阻止它。
- en: Better Support for Concurrency
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更好地支持并发
- en: 'There are two recent developments in the world of software devleopment that
    have become very important in the last few years:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发领域有两个近年来变得非常重要的新发展：
- en: Containerization
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化
- en: This is provided by products such as Docker and Kubernetes, amongst others.
    This is the idea that instead of running on a traditional server^([15](ch01.html#idm45400888611360))
    the application runs on something sort of like a mini-Virtual Machine (VM) which
    is generated by a script at deploy time. It isn’t quite the same, there’s no hardware
    emulation, but from a user perspective the result is roughly the same. It solves
    the “it worked on my machine” problem that is sadly all-too familiar to many developers.
    Many companies have software infrastructure that involves stacking up many instances
    of the same application in an array of containers, all processing the same source
    of input. Whether that be a queue, user requests, or whatever. The environment
    that hosts them can even be configured to scale up or down the number of active
    containers depending on demand.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由Docker和Kubernetes等产品提供的。这个概念是，应用程序不再在传统服务器上运行^([15](ch01.html#idm45400888611360))，而是在部署时由脚本生成的一种类似迷你虚拟机（VM）的东西。虽然不完全相同，没有硬件仿真，但从用户角度来看，结果大致相同。它解决了“在我的机器上可以工作”的问题，这对许多开发人员来说非常熟悉。许多公司的软件基础设施包括将许多相同应用程序的实例堆叠在一组容器中，所有这些容器都在处理相同的输入源。无论是队列、用户请求还是其他内容。托管它们的环境甚至可以根据需求调整活动容器的数量。
- en: Serverless
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器
- en: This might be familiar to .NET developers as Azure Functions or AWS Lambdas.
    This is code that isn’t deployed to a traditional web server, such as IIS, but
    rather as a single function that exists in isolation out on a cloud hosting environment.
    This allows both the same sorts of automatic scaling as is possible with containers,
    but also micro-level optimizations, where more money can be spent on more critical
    functions and less money on functions where the output can take longer to complete.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这对.NET开发人员可能很熟悉，例如Azure Functions或AWS Lambdas。这不是部署到传统的Web服务器（如IIS）的代码，而是作为一个单独的函数存在于云托管环境中。这允许与容器相同类型的自动扩展，同时还可以进行微级优化，这样可以在更关键的功能上花费更多资金，在输出较长的功能上花费较少资金。
- en: In both of these technologies, there is a great deal of utilization of concurrent
    processing; i.e. multiple instances of the same functionality working at the same
    time on the same input source. It’s like .NET’s Async features, but applied to
    a much larger scope.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种技术中，都大量利用并发处理；即多个相同功能的实例同时在相同的输入源上工作。就像.NET的异步功能，但应用范围更广。
- en: The problem with any sort of asyncronous operations tends to occur with shared
    resources, whether that’s in-memory state or a literal shared physical or software-based
    external resource.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 任何异步操作的问题往往发生在共享资源上，无论是内存状态还是字面上的共享物理或基于软件的外部资源。
- en: Functional Programming operates without state, so there can be no shared state
    between threads, containers or serverless functions.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程不使用状态，因此线程、容器或无服务器函数之间不能共享状态。
- en: When implemented correctly, following the Functional paradigm makes it much
    easier to implement these much-in-demand technological features, but without giving
    rise to any unexpected behavior in production.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当正确实现时，遵循函数式范式可以更轻松地实现这些非常需求的技术特性，而不会在生产中产生任何意外行为。
- en: Reduce Code Noise
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少代码噪音
- en: In audio processing they have a concept called the *Signal-to-Noise* Ratio.
    This is a measure of how clear a recording is, based on the ratio of the volume
    level of the signal (the thing you want to listen to) to the noise (hiss, crackle,
    rumble or whatever in the background).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在音频处理中，有一个称为*信噪比*的概念。这是根据信号（您要听的东西）的音量级别与噪音（嘶嘶声、爆裂声、隆隆声或背景中的其他声音）之间的比率来衡量录音的清晰度。
- en: In coding, the *signal* is the business logic of a block of code - the thing
    it is actually trying to accomplish. The *what* of the code.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码中，*信号*是代码块的业务逻辑 - 它实际上试图完成的事情。代码的*做什么*。
- en: The *noise* is all of the boilerplate code that must be written in order to
    accomplish the goal. The For-loop definition, If statements, that sort of thing.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*噪音* 是为了完成目标而必须编写的所有样板代码。例如 For 循环定义，If 语句，这种东西。'
- en: Compared to Procedural code, neat, concise Functional programming has significantly
    less boilerplate, and so has a much better Signal-to-noise ratio.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 相比过程化代码，整洁、简明的函数式编程大大减少了样板代码，因此具有更好的信号噪音比。
- en: This isn’t just a benefit to developers. Robust, easier to maintain codebases
    means the business needs to spend less money on maintainance and enhancements.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是对开发者的好处。稳健、易于维护的代码库意味着企业在维护和增强方面需要花费更少的金钱。
- en: The Best Places to Use Functional Programming
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最适合使用函数式编程的地方
- en: FP can do absolutely anything that any other paradigm can, but there are areas
    where it’s strongest and most beneficial - and other areas where it might be necessary
    to compromise and incorporate some Object Orientation features, or slightly bend
    the rules of the Functional Paradigm. In .NET at least, compromises necessarily
    have to be made, because any base classes or add-on libraries all tend to be written
    following the Object-Oriented paradigm. This doesn’t apply to Pure Functional
    languages.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程可以做任何其他范式可以做的事情，但它在某些领域更为强大和有益，并且在其他领域中可能需要妥协并引入一些面向对象的特性，或者稍微放松函数式范式的规则。至少在
    .NET 中，必须进行妥协，因为任何基础类或附加库都倾向于按照面向对象的范式编写。这不适用于纯函数式语言。
- en: Functional Programming is good where there’s a high degree of predictability.
    For example, data processing modules - functions that convert data from one form
    to another. Business logic classes that handle data from the user or database,
    then pass it on to be rendered elsewhere. Stuff like that.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程在高度可预测的场景中表现良好。例如，数据处理模块 - 将数据从一种形式转换为另一种形式的函数。处理来自用户或数据库的数据的业务逻辑类，然后将其传递到其他地方进行渲染。类似这样的东西。
- en: The stateless nature of Functional Programming makes it a great enabler of concurrent
    systems - like heavily asynchronous codebases, or places where several processors
    are listening concurrently to the same input queue. When there is no shared state,
    it’s just about impossible to get resource contention issues.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的无状态性质使其成为并发系统的重要推动因素 - 如高度异步的代码库，或者多个处理器同时监听同一输入队列的地方。当没有共享状态时，几乎不可能出现资源争用问题。
- en: If your team is looking into using Serverless applications - such as Azure Functions,
    then Functional Programming enables that nicely for most of the same reasons.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的团队正在考虑使用无服务器应用程序 - 例如 Azure Functions，那么函数式编程出于同样的原因可以很好地实现这一点。
- en: It’s worth considering Functional Programming for highly business-critical systems
    because the paradigm works in a way that makes it easier to produce code that’s
    less error-prone and more robust than applications coded with the Object-Oriented
    paradigm. If it’s incredibly important that the system should stay up, and not
    have a crash and burn (i.e. terminate unexpectedly) in the event of an unhandled
    exception or invalid input, then Functional Programming might be the best choice.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高度商业关键的系统，考虑使用函数式编程是值得的，因为这种范式的工作方式使得生成的代码比采用面向对象范式编写的应用程序更少出错，更加健壮。如果系统在发生未处理的异常或无效输入时不能崩溃或失败（即意外终止），那么函数式编程可能是最佳选择。
- en: Where You Should Consider Using Other Paradigms?
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在哪些情况下应考虑使用其他编程范式？
- en: You don’t have to ever do any such thing, of course. Functional can do anything,
    but there are a few areas where it might be worth looking around for other paradigms
    - purely in a C# context. And it’s also worth mentioning again that C# is a hybrid
    language, so many paradigms can quite happily sit side by side, next to each other,
    depending on the needs of the developer. I know which I prefer, of course!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你并不一定需要这样做。函数式可以做任何事情，但有几个领域可能值得寻找其他范式 - 纯粹在 C# 上下文中。再次提到，C# 是一种混合语言，因此许多范式可以根据开发者的需求并存并行。我当然知道我更喜欢哪一个！
- en: Interactions with external entities is one area for consideration. I/O, user
    input, 3rd party applications, web APIs, that sort of thing. There’s no way to
    make those pure functions (i.e. without side effects), so compromise is necessary.
    The same goes for 3rd party modules imported from Nuget packages. There are even
    a few older Microsoft libraries that are simply impossible to work with Functionally.
    This is still true in .NET Core. Have a look at the `SmtpClient` or `MailMessage`
    classes in .NET if you want to see a concrete example.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 与外部实体的交互是需要考虑的一个领域。输入输出、用户输入、第三方应用程序、Web API等。这些都无法成为纯函数（即没有副作用的函数），因此必须进行妥协。从NuGet包导入的第三方模块也是如此。甚至有一些较旧的Microsoft库在功能上也无法与函数式编程兼容。这在.NET
    Core中仍然适用。如果你想看一个具体的例子，请看看.NET中的`SmtpClient`或`MailMessage`类。
- en: In the C# world, if performance is your projects only, overwhelming concern,
    trumping all others, even readability and modularity, then following the Functional
    paradigm might not be the best idea. There’s nothing necessarily inherently poor
    in the performance of Functional C# code, but it’s not necessarily going to be
    the most utterly performant solution either.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#世界中，如果性能是你项目唯一、最重要的关注点，甚至超越了可读性和模块化，那么遵循函数式范式可能并不是最好的选择。函数式C#代码的性能并不一定差，但也不一定是最优的解决方案。
- en: I would argue that the benefits of Functional Programming far outweigh any minor
    loss of performance, and these days, most of the time it’s very easy to chuck
    a bit more hardware (virtual or physical, as appropriate) at the app - and this
    is likely to be an order of magnitude cheaper than the cost of additional developer
    time that would otherwise be required to develop, test, debug and maintain the
    codebase that is written in imparative-style code. This changes if - for example
    - you’re working on code to be placed on a mobile device of some sort, where performance
    is critical, because memory is limited and can’t be updated.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我会认为函数式编程的好处远远超过了任何轻微的性能损失，在当今，大多数时候很容易通过投入更多硬件（适当的虚拟或物理硬件）来解决应用程序的问题，而这往往比开发、测试、调试和维护以命令式编码方式编写的代码所需的额外开发时间要便宜一个数量级。例如，在开发要部署到某种移动设备上的代码时，性能至关重要，因为内存有限且无法更新。
- en: How Far Can We Take This?
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们能走多远？
- en: Unfortunately it simply isn’t possible to implement the entirety of the Functional
    paradigm in C#. There are all sorts of reasons for that, including the need for
    backwards compatability in the language and limitations imposed on what remains
    a strongly-typed language.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在C#中完全实现函数式范式是不可能的。其中有各种原因，包括语言的向后兼容性需求以及对依然是强类型语言的限制。
- en: The intention of this book isn’t to show you how all of it can be done, but
    rather to show where the boundaries are between what is and isn’t possible. I’ll
    also be looking into what’s practical, especially with an eye to those of you
    maintaining a production codebase. This is ultimately a practical, pragmatic guide
    to Functional coding styles.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的目的不是向你展示如何做所有的事情，而是展示什么是可能和不可能的边界。我还会特别关注那些在维护生产代码库的人。这最终是一个关于函数式编码风格的实用、务实的指南。
- en: Monads – Actually don’t worry about this yet
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Monad – 现在不要担心这个
- en: Monads are often thought to be the Functional horror story. Look on Wikipedia
    for definitions, and you’ll be presented with a strange letter soup containing
    Fs, Gs, arrows and more brackets than you’ll find under the shelves of your local
    library. The formal definitions are something I find - even now - utterly illegible.
    At the end of the day, I’m an engineer, not a mathematician.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Monad通常被认为是函数式编程的恐怖故事。在维基百科上查看定义，你会看到一串奇怪的字母，包括Fs、Gs、箭头以及比你当地图书馆书架下找到的还要多的括号。这些正式的定义即使现在我也觉得完全看不懂。说到底，我是一个工程师，不是数学家。
- en: Douglas Crockford once said that the curse of the Monad is that the moment you
    gain the ability to understand it, you lose the ability to explain it. So I won’t.
    They might make their presence known somewhere in this book, however. Especially
    at unlikely times.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Douglas Crockford曾经说过，Monad的诅咒在于，一旦你掌握了理解它的能力，你就失去了解释它的能力。所以我不会详细解释。它们可能会在本书的某个地方显现出来，尤其是在不太可能的时间。
- en: Don’t worry, it’ll be fine. We’ll work though it all together. Trust me…​
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心，一切都会好起来的。我们会一起克服所有困难的。相信我...​
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: In this first exciting installment of *Functional Programming with C#*, our
    mighty, awe-inspiring hero - you - bravely learned just what exactly Functional
    Programming is, and why it’s worth learning.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个*使用C#进行函数式编程*的激动人心的第一部分中，我们的强大而令人敬畏的英雄 - 你 - 勇敢地学到了什么是函数式编程，以及为什么值得学习。
- en: 'There was an initial, brief introduction to the important features of the Functional
    paradigm:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 对函数式范式的重要特性进行了初步简短的介绍：
- en: Immutabilty
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性
- en: Higher-Order Functions
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数
- en: Prefer Expressions over Statements
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更倾向于表达式而不是语句
- en: Referential Transparency
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用透明度
- en: Recursion
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归
- en: Pattern Matching
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配
- en: Stateless
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态
- en: There was a discussion of the areas Functional Programming is best used in,
    and where perhaps a discussion needs to be had regarding whether to use it in
    its pure form or not.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 有关函数式编程最适用的领域以及是否需要讨论是否纯粹使用它的讨论。
- en: We also looked at the many, many benefits of writing applications using the
    Functional Paradigm.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了使用函数式范式编写应用程序的许多许多优点。
- en: In the next thrilling episode, we’ll start looking at what you can do in C#
    right here, right now. No new 3rd party libraries or Visual Studio extension required.
    Just some honest-to-goodness out-of-the-box C# and a little ingenuity.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一集的激动人心的情节中，我们将开始探讨你可以在这里、现在使用C#所能做的事情。不需要新的第三方库或Visual Studio扩展。只需一些纯正的C#和一点点智慧。
- en: Come back just over the page to hear all about it. Same .NET time. Same .NET
    channel^([16](ch01.html#idm45400885994528)).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 翻页后再回来听更多关于它的内容。同样的.NET时间，同样的.NET频道^([16](ch01.html#idm45400885994528-marker))。
- en: ^([1](ch01.html#idm45400886960080-marker)) including Vanilla, and my personal
    favorite - Banana
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch01.html#idm45400886960080-marker)) 包括香草，以及我个人最喜欢的 - 香蕉
- en: ^([2](ch01.html#idm45400887889424-marker)) They were Hero turtles when I was
    growing up in the UK in the 90s. I think the TV folks were trying to avoid the
    violent connertations of the word “ninja”. They nevertheless still let us *see*
    our heroes regularly use sharp, bladed implements on their villains
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch01.html#idm45400887889424-marker)) 当我在90年代在英国长大时，它们是英雄海龟。我想电视工作人员试图避免“忍者”一词的暴力联想。尽管如此，他们仍然让我们经常看到我们的英雄们在他们的反派身上使用锋利的刀具
- en: ^([3](ch01.html#idm45400887043248-marker)) Credit must be given to functional
    programming supremo Mark Seeman ([*https://blog.ploeh.dk/*](https://blog.ploeh.dk/))
    for giving me these handy rules.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch01.html#idm45400887043248-marker)) 必须感谢函数式编程大师马克·西曼([*https://blog.ploeh.dk/*](https://blog.ploeh.dk/))给了我这些方便的规则。
- en: ^([4](ch01.html#idm45400886017232-marker)) Because I made it up for the same
    of this example
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch01.html#idm45400886017232-marker)) 因为我为了这个例子而编造了这个
- en: ^([5](ch01.html#idm45400886012000-marker)) Ok, art bods, I know there are actually
    about 12, but that’s more than I need for this metaphor to work
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch01.html#idm45400886012000-marker)) 好吧，艺术家，我知道实际上有大约12个，但这对我的比喻已经足够了
- en: '^([6](ch01.html#idm45400886009296-marker)) A talk on that subject is avialable
    here: [*https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell*](https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch01.html#idm45400886009296-marker)) 有关这个主题的讨论在这里可以找到：[*https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell*](https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell)
- en: ^([7](ch01.html#idm45400886001568-marker)) Never do this particular example
    in production code. I’m keeping it simple for the purposes of explanation
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch01.html#idm45400886001568-marker)) 不要在生产代码中使用这个特定的例子。我为了解释的目的保持简单
- en: ^([8](ch01.html#idm45400886708432-marker)) For some reason Julie Andrews won’t
    return my calls to discuss an updated .NET version of one of her famous songs
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch01.html#idm45400886708432-marker)) 由于某种原因，茱莉·安德鲁斯不接我电话，讨论更新的.NET版本的她著名歌曲之一
- en: ^([9](ch01.html#idm45400888316656-marker)) with a little creative liberty taken
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch01.html#idm45400888316656-marker)) 有些创意上的自由
- en: ^([10](ch01.html#idm45400887929376-marker)) e.g. “I can’t get this Freging code
    to work!”
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch01.html#idm45400887929376-marker)) 比如“我搞不定这个该死的代码！”
- en: ^([11](ch01.html#idm45400887916080-marker)) available to read online for free
    at [*http://www.learnyouahaskell.com*](http://www.learnyouahaskell.com). Tell
    ‘em I sent you
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ^([11](ch01.html#idm45400887916080-marker)) 可以免费在线阅读[*http://www.learnyouahaskell.com*](http://www.learnyouahaskell.com)。告诉他们是我推荐的
- en: ^([12](ch01.html#idm45400887905136-marker)) Although I **am** learning Latin.
    Insipiens sum. Huiusmodi res est ioci facio.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ^([12](ch01.html#idm45400887905136-marker)) 虽然我**正在**学习拉丁语。 Insipiens sum. Huiusmodi
    res est ioci facio.
- en: ^([13](ch01.html#idm45400887897808-marker)) especially F# guru Ian Russell,
    who helped with the F# content in this book. Thanks, Ian!
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ^([13](ch01.html#idm45400887897808-marker)) 特别感谢 F# 高手 Ian Russell，在本书的 F# 内容中提供了帮助。谢谢你，Ian！
- en: ^([14](ch01.html#idm45400888623008-marker)) at least that’s what we tell our
    managers
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ^([14](ch01.html#idm45400888623008-marker)) 至少这是我们告诉我们的经理们的
- en: ^([15](ch01.html#idm45400888611360-marker)) virtual or otherwise
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ^([15](ch01.html#idm45400888611360-marker)) 虚拟或者其他方式
- en: ^([16](ch01.html#idm45400885994528-marker)) or book, if we’re being picky
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ^([16](ch01.html#idm45400885994528-marker)) 或者书籍，如果我们想挑剔的话
