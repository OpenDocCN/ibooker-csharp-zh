<html><head></head><body><section data-pdf-bookmark="Unity Lab #4: User Interfaces" data-type="afterword" epub:type="afterword"><div class="appendix" id="unity_lab_hash4_user_interfaces">
<h1>Unity Lab #4: User Interfaces</h1>
<p><a data-primary="Billiard Ball game" data-type="indexterm" id="idm46402341345384"/><a data-primary="UI (user interface)" data-secondary="Billard Ball game" data-type="indexterm" id="idm46402341344616"/><a data-primary="Unity" data-secondary="user interfaces" data-type="indexterm" id="idm46402341343576"/>In the last Unity Lab you started to build a game, using a prefab to crate GameObject instances that appear at random points in your game’s 3D space and fly in circles. This Unity Lab picks up where the last one left off, allowing you to apply what you’ve learned about interfaces in C# and more.</p>
<p>Your program so far is an interesting visual simulation. The goal of this Unity Lab is to <strong>finish building the game</strong>. It starts off with a score of zero. Billiard balls will start to appear and fly around the screen. When the player clicks on a ball, the score goes up by 1 and the ball disappears. More and more balls appear; once 15 balls are flying around the screen, the game ends. For your game to work, your players need a way to start it and to play again once the game is over, and they’ll want to see their score as they click on the balls. So you’ll add a <strong>user interface</strong> that displays the score in the corner of the screen, and shows a button to start a new game.</p>
<section data-pdf-bookmark="Add a score that goes up when the player clicks a ball" data-type="sect1"><div class="sect1" id="add_a_score_that_goes_up_when_the_player">
<h1>Add a score that goes up when the player clicks a ball</h1>
<p>You’ve got a really interesting simulation. Now it’s time to turn it into a game. <strong>Add a new field</strong> to the <u>GameController</u> class to keep track of the score—you can add it just below the OneBallPrefab field:</p>
<pre data-type="programlisting">    public int Score = 0;</pre>
<p>Next, <strong>add a method called ClickedOnBall to the GameController class</strong>. This method will get called every time the player clicks on a ball:</p>
<pre data-type="programlisting">    public void ClickedOnBall()
    {
        Score++;
    }</pre>
<p>Unity makes it really easy for your GameObjects to respond to mouse clicks and other input. If you add a method called OnMouseDown to a script, Unity will call that method any time the GameObject it’s attached to is clicked. <strong>Add this method to the</strong> <u><strong>OneBallBehaviour</strong></u> <strong>class</strong>:</p>
<pre data-type="programlisting">    void OnMouseDown()
    {
        GameController controller = Camera.main.GetComponent&lt;GameController&gt;();
        controller.ClickedOnBall();
        Destroy(gameObject);
    }</pre>
<p>The first line of the OnMouseDown method <u>gets the instance of the GameController class</u>, and the second line calls its ClickedOnBall method, which increments its Score field.</p>
<p>Now run your game. Click on Main Camera in the hierarchy and watch its Game Controller (Script) component in the Inspector. Click on some of the rotating balls—they’ll disappear and the Score will go up.</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/454fig01.png"/>
<h6/>
</div></figure>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="there_are_no_dumb_questions-idd0027">
<h5>there are no Dumb Questions</h5>
<p><strong>Q: Why do we use Instantiate instead of the <code><strong>new</strong></code> keyword?</strong></p>
<p><strong>A:</strong> Instantiate and Destroy are <strong><em>special methods that are unique to Unity</em></strong>—you won’t see them in your other C# projects. The Instantiate method isn’t quite the same thing as the C# <code>new</code> keyword, because it’s creating a new instance of a prefab, not a class. Unity does create new instances of objects, but it needs to do a lot of other things, like making sure that it’s included in the update loop. When a GameObject’s script calls Destroy(gameObject) it’s telling Unity to destroy itself. The Destroy method tells Unity to destroy a GameObject—but not until after the update loop is complete.</p>
<p><strong>Q: I’m not clear on how the first line of the OnMouseDown method works. What’s going on there?</strong></p>
<p><strong>A:</strong> Let’s break down that statement piece by piece. The first part should be pretty familiar: it declares a variable called <code>controller</code> of type GameController, the class that you defined in the script that you attached to the Main Camera. In the second half, we want to call a method on the GameController attached to the Main Camera. So we use  Camera.main to get the Main Camera, and GetComponent&lt;GameController&gt;() to get the instance of GameController that we attached to it.</p>
</div></aside>
</div></section>
<section data-pdf-bookmark="Add two different modes to your game" data-type="sect1"><div class="sect1" id="add_two_different_modes_to_your_game">
<h1>Add two different modes to your game</h1>
<p><a data-primary="game modes" data-type="indexterm" id="idm46402341318760"/>Start up your favorite game. Do you immediately get dropped into the action? Probably not—you’re probably looking at a start menu. Some games let you pause the action to look at a map. Many games let you switch between moving the player and working with an inventory, or show an animation while the player is dying that can’t be interrupted. These are all examples of <strong>game modes</strong>.</p>
<blockquote>
<p><strong>You’ll add two modes to your game. You already have the “running” mode, so now you just need to add a “game over” mode.</strong></p>
</blockquote>
<p>Let’s add two different modes to your billiard ball game:</p>
<ul>
<li><p><strong>Mode #1: The game is running.</strong> Balls are being added to the scene, and clicking on them makes them disappear and the score go up.</p></li>
<li><p><strong>Mode #2: The game is over.</strong> Balls are no longer getting added to the scene, clicking on them doesn’t do anything, and a “Game over” banner is displayed.</p></li>
</ul>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/455fig01.png"/>
<h6/>
</div></figure>
<p>Here’s how you’ll add the two game modes to your game:</p>
<ol>
<li><p><strong><em>Make GameController.AddABall pay attention to the game mode.</em></strong></p>
<p>Your new and improved AddABall method will check if the game is over, and will only instantiate a new OneBall prefab if the game is not over.</p></li>
<li><p><strong><em>Make OneBallBehaviour.OnMouseDown only work when the game is running.</em></strong></p>
<p>When the game is over, we want the game to stop responding to mouse clicks. The player should just see the balls that were already added continue to circle until the game restarts.</p></li>
<li><p><strong><em>Make GameController.AddABall end the game when there are too many balls.</em></strong></p>
<p>AddABall also increments its NumberOfBalls counter, so it goes up by 1 every time a ball is added. If the value reaches MaximumBalls, it sets GameOver to true to end the game.</p></li>
</ol>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><strong>In this lab, you’re building this game in parts, and making changes along the way. You can download the code for each part from the book’s GitHub repository: <a href="https://github.com/head-first-csharp/fourth-edition">https://github.com/head-first-csharp/fourth-edition</a>.</strong></p>
</div>
</div></section>
<section data-pdf-bookmark="Add game mode to your game" data-type="sect1"><div class="sect1" id="add_game_mode_to_your_game">
<h1>Add game mode to your game</h1>
<p>Modify your GameController and OneBallBehaviour classes to <strong>add modes to your game</strong> by using a Boolean field to keep track of whether or not the game is over.</p>
<ol>
<li><p><strong><em>Make GameController.AddABall pay attention to the game mode.</em></strong></p>
<p>We want the GameController to know what mode the game is in. When we need to keep track of what an object knows, we use fields. Since there are two modes—running and game over—we can use a Boolean field to keep track of the mode. <strong>Add the GameOver field</strong> to your GameController class:</p>
<pre data-type="programlisting">    public bool GameOver = false;</pre>
<p>The game should only add new balls to the scene if the game is running. Modify the AddABall method to add an <code>if</code> statement that only calls Instantiate if GameOver is not true:</p>
<pre data-type="programlisting"> <span style="color:#9D9EA0;">    public void AddABall()</span>
  <span style="color:#9D9EA0;">    {</span>
         <strong>if (!GameOver)</strong>
         <strong>{</strong>
  <span style="color:#9D9EA0;">           Instantiate(OneBallPrefab);</span>
         <strong>}</strong>
 <span style="color:#9D9EA0;">    }</span></pre>
<p>Now you can test it out. Start your game, then <strong>click on Main Camera</strong> in the Hierarchy window.</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/pg456-01.png"/>
<h6/>
</div></figure>
<p>Set the GameOver field by unchecking the box in the Script component. The game should stop adding balls until you check the box again.</p></li>
<li><p><strong><em>Make OneBallBehaviour.OnMouseDown only work when the game is running.</em></strong></p>
<p>Your OnMouseDown method already calls the GameController’s ClickedOnBall method. Now <strong>modify OnMouseDown in OneBallBehaviour</strong> to use the GameController’s GameOver field as well:</p>
<pre data-type="programlisting"> <span style="color:#9D9EA0;">    void OnMouseDown()</span>
 <span style="color:#9D9EA0;">    {</span>
 <span style="color:#9D9EA0;">        GameController controller = Camera.main.GetComponent&lt;GameController&gt;();</span>
        <strong>if (!controller.GameOver)</strong>
        <strong>{</strong>
 <span style="color:#9D9EA0;">           controller.ClickedOnBall();</span>
 <span style="color:#9D9EA0;">           Destroy(gameObject);</span>
        <strong>}</strong>
 <span style="color:#9D9EA0;">    }</span></pre>
<p>Run your game again and test that balls disappear and the score goes up only when the game is not over.</p></li>
<li><p><strong><em>Make GameController.AddABall end the game when there are too many balls.</em></strong></p>
<p>The game needs to keep track of the number of balls in the scene. We’ll do this by <strong>adding two fields</strong> to the <u>GameController</u> class to keep track of the current number of balls and the maximum number of balls:</p>
<pre data-type="programlisting">    public int NumberOfBalls = 0;
    public int MaximumBalls = 15;</pre>
<p>Every time the player clicks on a ball, the ball’s OneBallBehaviour script calls GameController.ClickedOnBall to increment (add 1 to) the score. Let’s also decrement (subtract 1 from) NumberOfBalls:</p>
<pre data-type="programlisting"> <span style="color:#9D9EA0;">    public void ClickedOnBall()</span>
 <span style="color:#9D9EA0;">    {</span>
 <span style="color:#9D9EA0;">        Score++;</span>
         <strong>NumberOfBalls--;</strong>
 <span style="color:#9D9EA0;">    }</span></pre>
<p>Now <strong>modify the AddABall</strong> method so that it only adds balls if the game is running, and ends the game if there are too many balls in the scene:</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/457fig024.png"/>
<h6/>
</div></figure>
<p>Now test your game one more time by running it and then clicking on Main Camera in the Hierarchy window. The game should run normally, but as soon as the NumberOfBalls field is equal to the MaximumBalls field, the AddABall method sets its GameOver field to true and ends the game.</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/pg457-01.png"/>
<h6/>
</div></figure>
<p>Once that happens, clicking on the balls doesn’t do anything because OneBallBehaviour.OnMouseDown checks the GameOver field and only increments the score and destroys the ball if GameOver is false.</p>
<blockquote>
<p><strong>Your game needs to keep track of its game mode. Fields are a great way to do that.</strong></p>
</blockquote></li>
</ol>
</div></section>
<section data-pdf-bookmark="Add a UI to your game" data-type="sect1"><div class="sect1" id="add_a_ui_to_your_game">
<h1>Add a UI to your game</h1>
<p><a data-primary="Canvas (Unity)" data-type="indexterm" id="idm46402341260760"/>Almost any game you can think of—from Pac Man to Super Mario Brothers to Grand Theft Auto 5 to Minecraft—features a <strong>user interface (or UI)</strong>. Some games, like Pac Man, have a very simple UI that just shows the score, high score, lives left, and current level. Many games feature an intricate UI incorporated into the game’s mechanics (like a weapon wheel that lets the player quickly switch between weapons). Let’s add a UI to your game.</p>
<p><strong>Choose <em>UI &gt;&gt; Text</em> from the GameObject menu</strong> to add a 2D Text GameObject to your game’s UI. This adds a Canvas to the Hierarchy, and a Text under that Canvas:</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/458fig01.png"/>
<h6/>
</div></figure>
<p>Double-click on Canvas in the Hierarchy window to focus on it. It’s a 2-D rectangle. Click on its Move Gizmo and drag it around the scene. It won’t move! The Canvas that was just added will always be displayed, scaled to the size of the screen and in front of everything else in the game.</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/458fig02.png"/>
<h6/>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Did you notice an <u><span style="color:#9D9EA0;">EventSystem</span></u> in the Hierarchy? Unity automatically added it when you created the UI. It manages mouse, keyboard, and other inputs and sends them back to GameObjects—and it does all of that automatically, so you won’t need to work directly with it.</p>
</div>
<p>Then double-click on Text to focus on it—the editor will zoom in, but the default text (“New Text”) will be backward because the Main Camera is pointing at the back of the Canvas.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>A <span style="color:#9D9EA0;"><u>Canvas</u></span> is a two-dimensional GameObject that lets you lay out your game’s UI. Your game’s Canvas will have two GameObjects nested under it: the <span style="color:#9D9EA0;"><u>Text</u></span> GameObject that you just added will be in the upper-right corner to display the score, and there’s a <span style="color:#9D9EA0;"><u>Button</u></span> GameObject to let the player start a new game.</p>
</div>
</div></section>
<section data-pdf-bookmark="Use the 2D view to work with the Canvas" data-type="sect1"><div class="sect1" id="use_the_2d_view_to_work_with_the_canvas">
<h1>Use the 2D view to work with the Canvas</h1>
<p>The <strong>2D button</strong> at the top of the Scene window toggles 2D view on and off:</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/458fig03.png"/>
<h6/>
</div></figure>
<p>Click the 2D view—the editor flips around its view to shows the canvas head-on. <strong>Double-click on Text</strong> in the Hierarchy window to zoom in on it.</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/458fig04.png"/>
<h6/>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Use the mouse wheel to zoom in and out in 2D view</p>
</div>
<p>You can <strong>click the 2D button to switch between 2D and 3D</strong>. Click it again to return to the 3D view.</p>
</div></section>
<section data-pdf-bookmark="Set up the Text that will display the score in the UI" data-type="sect1"><div class="sect1" id="set_up_the_text_that_will_display_the_sc">
<h1>Set up the Text that will display the score in the UI</h1>
<p><a data-primary="GameObjects" data-secondary="anchored" data-type="indexterm" id="idm46402341235864"/><a data-primary="Inspector window (Unity)" data-type="indexterm" id="idm46402341234376"/>Your game’s UI will feature one Text GameObject and one Button. Each of those GameObjects will be <strong>anchored</strong> to a different part of the UI. For example, the Text GameObject that displays the score will show up in the upper-right corner of the screen (no matter how big or small the screen is).</p>
<p>Click on Text in the Hierarchy window to select it, then look at the Rect Transform component. We want the Text in the upper-right corner, so <strong>click the Anchors box</strong> in the Rect Transform panel.</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/459fig001.png"/>
<h6/>
</div></figure>
<p>The Anchor Presets window lets you anchor your UI GameObjects to various parts of the Canvas. <strong>Hold down Alt and Shift</strong> (or Option+Shift on a Mac) and <strong>choose the top right anchor preset</strong>. Click the same button you used to bring up the Anchor Presets window. The Text is now in the upper-right corner of the Canvas—double-click on it again to zoom into it.</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/459fig01.png"/>
<h6/>
</div></figure>
<p>Let’s add a little space above and to the right of the Text. Go back to the Rect Transform panel and <strong>set both Pos X and Pos Y to –10</strong> to position the text 10 units to the left and 10 down from the top-right corner. Then <strong>set the Alignment on the Text component to right</strong>, and use the box at the top of the Inspector to <strong>change the GameObject’s name to</strong> <code><strong>Score</strong></code>.</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/459fig02.png"/>
<h6/>
</div></figure>
<p>Your new Text should now show up in the Hierarchy window with the name Score. It should now be right-aligned, with a small gap between the edge of the Text and the edge of the Canvas.</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/459fig03.png"/>
<h6/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Add a button that calls a method to start the game" data-type="sect1"><div class="sect1" id="add_a_button_that_calls_a_method_to_star">
<h1>Add a button that calls a method to start the game</h1>
<p>When the game is in its “game over” mode, it will display a button labeled Play Again that calls a method to restart the game. <strong>Add an empty StartGame method</strong> to your GameController class (we’ll add its code later):</p>
<pre data-type="programlisting">    public void StartGame()
    {
<span style="color:#9D9EA0;">        // We’ll add the code for this method later</span>
    }</pre>
<p><strong>Click on Canvas in the Hierarchy window</strong> to focus on it. Then <strong>choose UI &gt;&gt; Button</strong> from the GameObject menu to add a Button. Since you’re already focused on the Canvas, the Unity editor will add the new Button and anchor it to the center of the Canvas. Did you notice that Button has a triangle next to it in the Hierarchy? Expand it—there’s a TextGameObject nested under it. Click on it and set its text to <code>Play Again</code>.</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/460fig01.png"/>
<h6/>
</div></figure>
<p>Now that the Button is set up, we just need to make it call the StartGame method on the GameController object attached to the Main Camera. A UI button is <strong><em>just a GameObject with a Button component</em></strong>, and you can use its On Click () box in the Inspector to hook it up to an event handler method. Click the <span class="inlineimage"><img alt="Images" src="assets/460fig02.png"/></span> button at the bottom of the On Click () box to add an event handler, then <strong>drag Main Camera onto the None (Object) box</strong>.</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/460fig03.png"/>
<h6/>
</div></figure>
<p>Now the Button knows which GameObject to use for the event handler. Click the <span class="inlineimage"><img alt="Images" src="assets/460fig04.png"/></span> dropdown and choose <strong>GameController &gt;&gt; StartGame</strong>. Now when the player presses the button, it will call the StartGame method on the GameController object hooked up to the Main Camera.</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/460fig05.png"/>
<h6/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Make the Play Again button and Score Text work" data-type="sect1"><div class="sect1" id="make_the_play_again_button_and_score_tex">
<h1>Make the Play Again button and Score Text work</h1>
<p>Your game’s UI will work like this:</p>
<ul>
<li><p>The game starts in the game over mode.</p></li>
<li><p>Clicking the Play Again button starts the game.</p></li>
<li><p>Text in the upper-right corner of the screen displays the current score.</p></li>
</ul>
<p>You’ll be using the Text and Button classes in your code. They’re in the UnityEngine.UI namespace, so <strong>add this</strong> <code><strong>using statement</strong></code> to the top of your GameController class:</p>
<pre data-type="programlisting">using UnityEngine.UI;</pre>
<p>Now you can add Text and Button fields to your GameController (just above the OneBallPrefab field):</p>
<pre data-type="programlisting">    public Text ScoreText;
    public Button PlayAgainButton;</pre>
<p><strong>Click on Main Camera</strong> in the Hierarchy window. <strong>Drag the Text GameObject</strong> out of the Hierarchy and <strong><em>onto</em></strong> the Score Text field in the Script component, <strong>then drag the Button GameObject</strong> <em>onto</em> the Play Again Button field.</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/461fig01.png"/>
<h6/>
</div></figure>
<p>Go back to your GameController code and <strong>set the GameController field’s default value to true</strong>:</p>
<pre data-type="programlisting">    public bool GameOver = true;</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Change this from false to true.</p>
</div>
<p>Now go back to Unity and check the Script component in the Inspector.</p>
<p><strong><em>Hold on, something’s wrong!</em></strong></p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/461fig02.png"/>
<h6/>
</div></figure>
<p>The Unity editor still shows the Game Over checkbox as unchecked—it didn’t change the field value. Make sure to check the box so your game starts in the game over mode:</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/461fig03.png"/>
<h6/>
</div></figure>
<p>Now the game will start in the game over mode, and the player can click the Play Again button to start playing.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="watch_itexclamation_mark-idd0010">
<h5><span class="inlineimage"><img alt="Images" src="assets/watch.png"/></span> Watch it!</h5>
<p><strong>Unity remembers your scripts’ field values.</strong></p>
<p><em>When you wanted to change the GameController.GameOver  field from false to true, it wasn’t enough to change the code. When you add a Script component to Unity, it keeps track of the field values, and it won’t reload the default values unless you reset it from the context menu (<span class="inlineimage"><img alt="Images" src="assets/461fig04.png"/></span>).</em></p>
</div></aside>
</div></section>
<section data-pdf-bookmark="Finish the code for the game" data-type="sect1"><div class="sect1" id="finish_the_code_for_the_game">
<h1>Finish the code for the game</h1>
<p><a data-primary="tags (XAML)" data-type="indexterm" id="idm46402341173416"/>The GameController object attached to the Main Camera keeps track of the score in its Score field. <strong>Add an Update method to the GameController class</strong> to update the Score Text in the UI:</p>
<pre data-type="programlisting">    void Update()
    {
        ScoreText.text = Score.ToString();
    }</pre>
<p>Next, <strong>modify your GameController.AddABall method</strong> to enable the Play Again button when it ends the game:</p>
<pre data-type="programlisting">    <span style="color:#9D9EA0;">if (NumberOfBalls &gt;= MaximumBalls)</span>
    <span style="color:#9D9EA0;">{</span>
        <span style="color:#9D9EA0;">GameOver = true;</span>
        <strong>PlayAgainButton.gameObject.SetActive(true);</strong>
    <span style="color:#9D9EA0;">}</span></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><strong>Every GameObject has a property called gameObject that lets you manipulate it. You’ll use its SetActive method to make the Play Again button visible or invisible.</strong></p>
</div>
<p>There’s just one more thing to do: get your StartGame method working so that it starts the game. It needs to do a few things: destroy any balls that are currently flying around the scene, disable the Play Again button, reset the score and number of balls, and set the mode to “running.” You already know how to do most of those things! You just need to be able to find the balls in order to destroy them. <strong>Click on the OneBall prefab in the Project window and set its tag</strong>:</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/462fig01.png"/>
<h6/>
</div></figure>
<p>Now you have everything in place to fill in your StartGame method. It uses a <code>foreach</code> loop to find and destroy any balls left over from the previous game, hides the button, resets the score and number of balls, and changes the game mode:</p>
<pre data-type="programlisting"> <span style="color:#9D9EA0;">    public void StartGame()</span>
 <span style="color:#9D9EA0;">    {</span>
        <strong>foreach (GameObject ball in GameObject.FindGameObjectsWithTag("GameController"))</strong>
        <strong>{</strong>
            <strong>Destroy(ball);</strong>
        <strong>}</strong>
        <strong>PlayAgainButton.gameObject.SetActive(false);</strong>
        <strong>Score = 0;</strong>
        <strong>NumberOfBalls = 0;</strong>
        <strong>GameOver = false;</strong>
 <span style="color:#9D9EA0;">    }</span></pre>
<p>Now run your game. It starts in “game over” mode. Press the button to start the game. The score goes up each time you click on a ball. As soon as the 15th ball is instantiated, the game ends and the Play Again button appears again.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="exercise-idd0029">
<h5><span class="inlineimage"><img alt="Images" src="assets/exercise.png"/></span> Exercise</h5>
<p><a data-primary="exercises" data-secondary="transform" data-type="indexterm" id="idm46402341148520"/><a data-primary="Transform component (Unity)" data-type="indexterm" id="idm46402341146664"/><strong>Here’s a Unity <u>coding challenge</u> for you!</strong> Each of your GameObjects has a <strong>transform.Translate</strong> method that moves it a distance from its current position. The goal of this exercise is to modify your game so that instead of using transform.RotateAround to circle balls around the Y axis, your OneBallBehaviour script uses transform.Translate to make the balls fly randomly around the scene.</p>
<ul>
<li><p><strong>Remove</strong> the XRotation, YRotation, and ZRotation fields from OneBallBehaviour. <strong>Replace them with fields</strong> to hold the X, Y, and Z speed called XSpeed, YSpeed, and ZSpeed. They’re float fields—no need to set their values.</p></li>
<li><p><strong>Replace all of the code in the Update method</strong> with this line of code that calls the transform.Translate method:</p>
<pre data-type="programlisting">transform.Translate(Time.deltaTime * XSpeed,
                    Time.deltaTime * YSpeed, Time.deltaTime * ZSpeed);</pre>
<p>The parameters represent the speed that the ball is traveling along the X, Y, or Z axis. So if XSpeed is 1.75, multiplying it by Time.deltaTime causes ball move along the X axis at a rate of 1.75 units per second.</p></li>
<li><p><strong>Replace the DegreesPerSecond field</strong> with a field called Multiplier with a value of 0.75<u>F</u>—<u>the F is important!</u> Use it to update the XSpeed field in the Update method, and <strong>add two similar lines</strong> for the YSpeed and ZSpeed fields:</p>
<pre data-type="programlisting">XSpeed += Multiplier - Random.value * Multiplier * 2;</pre>
<p>Part of this exercise is to <strong>understand exactly how this line of code works</strong>. Random.value is a static method that returns a random floating-point number between 0 and 1. What is this line of code doing to the XSpeed field?</p>
<p>..................................................................................................</p>
<p>..................................................................................................</p>
<p>..................................................................................................</p></li>
<li><p>Then <strong>add a method called ResetBall</strong> and <u>call it from the Start method</u>. Add this line of code to ResetBall:</p>
<pre data-type="programlisting">XSpeed += Multiplier - Random.value * Multiplier * 2;</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Before you start working on the game, figure out what these lines of code do.</p>
</div>
<p>What does that line of code do?</p>
<p>..................................................................................................</p>
<p>..................................................................................................</p>
<p><strong>Add two more lines</strong> just like it to ResetBall that update YSpeed and ZSpeed. Then <strong>move the line of code</strong> that updates transform.position <u>out of the Start method</u> and into the ResetBall method.</p></li>
<li><p>Modify the OneBallBehaviour class to <strong>add a field called TooFar</strong> and set it to 5. Then modify the Update method to check whether the ball went too far. You can check if a ball went too far along the X axis like this:</p>
<pre data-type="programlisting">Mathf.Abs(transform.position.x) &gt; TooFar</pre>
<p>That checks the <em>absolute value</em> of the X position, which means that it will check if transform.position.x is greater than 5F or less than –5F. Here’s an <code>if</code> statement that checks if the ball went too far along the X, Y, or Z axis:</p>
<pre data-type="programlisting">if ((Mathf.Abs(transform.position.x) &gt; TooFar)
     || (Mathf.Abs(transform.position.y) &gt; TooFar)
     || (Mathf.Abs(transform.position.z) &gt; TooFar)) {</pre>
<p><strong>Modify your OneBallBehaviour.Update method</strong> to use that <code>if</code> statement to call ResetBall if the ball went too far.</p></li>
</ul>
</div></aside>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="exercise_solution-idd0020">
<h5><span class="inlineimage"><img alt="Images" src="assets/Common-1.png"/></span> Exercise Solution</h5>
<p>Here’s what the entire OneBallBehaviour class looks like after updating it following the instructions in the exercise. The key to how this game works is that each ball’s speed along the X, Y, and Z axes is determined by its current XSpeed, YSpeed, and ZSpeed values. By making small changes to those values, you’ve made your ball move randomly throughout the scene.</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/464fig01.png"/>
<h6/>
</div></figure>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/pg465-01.png"/>
<h6/>
</div></figure>
<p><strong>Here are our answers to the questions—did you come up with similar answers?</strong></p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/pg465-02.png"/>
<h6/>
</div></figure>
</div></aside>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><strong>Did you notice that you <em>didn’t have to make any changes to the GameController class?</em> That’s because you didn’t make changes to the things that GameController <u>does</u>, like managing the UI or the game mode. If you can make a change by modifying one class but not touching others, that can be a sign that you designed your classes well.</strong></p>
</div>
</div></section>
<section data-pdf-bookmark="Get creative!" data-type="sect1"><div class="sect1" id="get_creativeexclamation_mark-idd0003">
<h1>Get creative!</h1>
<p><a data-primary="Inspector window (Unity)" data-type="indexterm" id="idm46402341110184"/>Can you find ways to improve your game and get practice writing code? Here are some ideas:</p>
<ul>
<li><p>Is the game too easy? Too hard? Try changing the parameters that you pass to InvokeRepeating in your GameController.Start method. Try making them fields. Play around with the MaximumBalls value, too. Small changes in these values can make a big difference in gameplay.</p></li>
<li><p>We gave you texture maps for all of the billiard balls. Try adding different balls that have different behaviors. Use the scale to make some balls bigger or smaller, and change their parameters to make them go faster or slower, or move differently.</p></li>
<li><p>Can you figure out how to make a “shooting star” ball that flies off really quickly in one direction and is worth a lot if the player clicks on it? How about making a “sudden death” 8 ball that immediately ends the game?</p></li>
<li><p>Modify your GameController.ClickedOnBall method to take a score parameter instead of incrementing the Score field and add the value that you pass. Try giving different values to different balls.</p></li>
</ul>
<p><strong><em>If you change fields in the OneBallBehaviour script, don’t forget to reset the Script component of the OneBall prefab! Otherwise, it will remember the old values.</em></strong></p>
<blockquote>
<p><strong>The more practice you get writing C# code, the easier it will get. Getting creative with your game is a great opportunity to get some practice!</strong></p>
</blockquote>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="bullet_points-idd0019">
<h5>Bullet Points</h5>
<ul>
<li><p>Unity games display a <strong>user interface (UI)</strong> with controls and graphics on a flat, two-dimensional plane in front of the game’s 3D scene.</p></li>
<li><p>Unity provides a set of <strong>2D UI GameObjects</strong> specifically made for building user interfaces.</p></li>
<li><p>A <strong>Canvas</strong> is a 2D GameObject that lets you lay out your game’s UI. UI components like Text and Button are nested under a Canvas GameObject.</p></li>
<li><p>The <strong>2D button</strong> at the top of the Scene window toggles 2D view on and off, which makes it easier to lay out a UI.</p></li>
<li><p>When you add a <strong>Script component</strong> to Unity, it keeps track of the field values, and it won’t reload the default values unless 2D reset it from the context menu.</p></li>
<li><p>A <strong>Button</strong> can call any method in a script that’s attached to a GameObject.</p></li>
<li><p>You can use the Inspector to <strong>modify field values</strong> in your GameObjects’ scripts. If you modify them while the game is running, they’ll reset to saved values when it stops.</p></li>
<li><p>The <strong>transform.Translate</strong> method moves a GameObject a distance from its current position.</p></li>
<li><p>A <strong>tag</strong> is a keyword that you can attach to any of your GameObjects that you can use in your code when you need to identify them or find them.</p></li>
<li><p>The <strong>GameObject.FindGameObjectsWithTag method</strong> returns a collection of GameObjects that match a given tag.</p></li>
</ul>
</div></aside>
</div></section>
</div></section></body></html>