<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 4. Generics" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_generics">
<h1><span class="label">Chapter 4. </span>Generics</h1>
<p><a data-primary="generics" data-type="indexterm" id="ix_ch04-asciidoc0"/>In <a data-type="xref" href="ch03.xhtml#ch_types">Chapter 3</a>, I showed how to write types and described the various kinds of members they can contain. However, there’s an extra dimension to classes, structs, interfaces, and methods that I did not show. <a data-primary="type parameters" data-type="indexterm" id="idm45884826018608"/>They can define <em>type parameters</em>, placeholders that let you plug in different types at compile time. This allows you to write just one type and then produce multiple versions of it. A type that does this is called a <em>generic type</em>. For example, the runtime libraries define a generic class called <code>List&lt;T&gt;</code> that acts as a variable-length array. <code>T</code> is a type parameter here, and you can use almost any type as an argument, so <code>List&lt;int&gt;</code> is a list of integers, <code>List&lt;string&gt;</code> is a list of strings, and so on.<sup><a data-type="noteref" href="ch04.xhtml#idm45884826015216" id="idm45884826015216-marker">1</a></sup> You can also write a <em>generic method</em>, which is a method that has its own type arguments, independently of whether its containing type is generic.</p>
<p><a data-primary="&lt;&gt; (angle brackets)" data-type="indexterm" id="idm45884826013024"/><a data-primary="angle brackets (&lt;&gt;)" data-type="indexterm" id="idm45884826012320"/>Generic types and methods are visually distinctive because they always have angle brackets (<code>&lt;</code> and <code>&gt;</code>) after the name. These contain a comma-separated list of parameters or arguments. The same parameter/argument distinction applies here as with methods: the declaration specifies a list of parameters, and then when you come to use the method or type, you supply arguments for those parameters. <a data-primary="type arguments" data-type="indexterm" id="idm45884826010272"/>So <code>List&lt;T&gt;</code> defines a single type parameter, <code>T</code>, and <code>List&lt;int&gt;</code> supplies a <em>type argument</em>, <code>int</code>, for that parameter.</p>
<p>You can use any name you like for type parameters, within the usual constraints for identifiers in C#, but there are some popular conventions. It’s common (but not universal) to use <code>T</code> when there’s only one parameter. For multiparameter generics, you tend to see slightly more descriptive names. For example, the runtime libraries define the <span class="keep-together"><code>Dictionary&lt;TKey, TValue&gt;</code></span> collection class. Sometimes you will see a descriptive name like that even when there’s just one parameter, but in any case, you will tend to see a <code>T</code> prefix so that the type parameters stand out when you use them in your code.</p>
<section data-pdf-bookmark="Generic Types" data-type="sect1"><div class="sect1" id="generic_types">
<h1>Generic Types</h1>
<p><a data-primary="generics" data-secondary="types" data-type="indexterm" id="ix_ch04-asciidoc1"/><a data-primary="Type class" data-secondary="generics and" data-type="indexterm" id="ix_ch04-asciidoc2"/>Classes, structs, records, and interfaces can all be generic, as can delegates, which we’ll be looking at in <a data-type="xref" href="ch09.xhtml#ch_delegates_lambdas_events">Chapter 9</a>. <a data-type="xref" href="#defining_a_generic_class">Example 4-1</a> shows how to define a generic class.</p>
<div data-type="example" id="defining_a_generic_class">
<h5><span class="label">Example 4-1. </span>Defining a generic class</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">NamedContainer</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="nf">NamedContainer</code><code class="p">(</code><code class="n">T</code> <code class="n">item</code><code class="p">,</code> <code class="kt">string</code> <code class="n">name</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">Item</code> <code class="p">=</code> <code class="n">item</code><code class="p">;</code>
        <code class="n">Name</code> <code class="p">=</code> <code class="n">name</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">public</code> <code class="n">T</code> <code class="n">Item</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="p">}</code>
    <code class="k">public</code> <code class="kt">string</code> <code class="n">Name</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>The syntax for structs, records, and interfaces is much the same: the type name is followed immediately by a type parameter list. <a data-type="xref" href="#defining_a_generic_record">Example 4-2</a> shows how to write a generic record similar to the class in <a data-type="xref" href="#defining_a_generic_class">Example 4-1</a>.</p>
<div data-type="example" id="defining_a_generic_record">
<h5><span class="label">Example 4-2. </span>Defining a generic record</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="n">record</code> <code class="n">NamedContainer</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;(</code><code class="n">T</code> <code class="n">Item</code><code class="p">,</code> <code class="kt">string</code> <code class="n">Name</code><code class="p">);</code></pre></div>
<p>Inside the definition of a generic type, I can use the type parameter <code>T</code> anywhere you would normally see a type name. In the first example, I’ve used it as the type of a constructor argument, and in both examples as the <code>Item</code> property’s type. I could define fields of type <code>T</code> too. (In fact I have, albeit not explicitly. Automatic properties generate hidden fields, so my <code>Item</code> property will have an associated hidden field of type <code>T</code>.) You can also define local variables of type <code>T</code>. And you’re free to use type parameters as arguments for other generic types. My <span class="keep-together"><code>NamedContainer&lt;T&gt;</code></span> could declare members of type <code>List&lt;T&gt;</code>, for example.</p>
<p>The types that Examples <a data-type="xref" data-xrefstyle="select:labelnumber" href="#defining_a_generic_class">4-1</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#defining_a_generic_record">4-2</a> define are, like any generic type, not complete types. <a data-primary="unbound type declaration" data-type="indexterm" id="idm45884825873856"/>A generic type declaration is <em>unbound</em>, meaning that there are type parameters that must be filled in to produce a complete type. Basic questions, such as how much memory a <code>NamedContainer&lt;T&gt;</code> instance will require, cannot be answered without knowing what <code>T</code> is—the hidden field for the <code>Item</code> property would need 4 bytes if <code>T</code> were an <code>int</code> but 16 bytes if it were a <code>decimal</code>. The CLR cannot produce executable code for a type if it does not know how the contents will be arranged in memory. So to use this, or any other generic type, we must provide type arguments. <a data-type="xref" href="#using_a_generic_class">Example 4-3</a> shows how. <a data-primary="constructed type" data-type="indexterm" id="idm45884825869248"/>When type arguments are supplied, the result is sometimes called a <em>constructed type</em>. (This has nothing to do with constructors, the special kind of member we looked at in <a data-type="xref" href="ch03.xhtml#ch_types">Chapter 3</a>. In fact, <a data-type="xref" href="#using_a_generic_class">Example 4-3</a> uses those too—it invokes the constructors of a couple of constructed types.)</p>
<div data-type="example" id="using_a_generic_class">
<h5><span class="label">Example 4-3. </span>Using a generic class</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">a</code> <code class="p">=</code> <code class="k">new</code> <code class="n">NamedContainer</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;(</code><code class="m">42</code><code class="p">,</code> <code class="s">"The answer"</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">b</code> <code class="p">=</code> <code class="k">new</code> <code class="n">NamedContainer</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;(</code><code class="m">99</code><code class="p">,</code> <code class="s">"Number of red balloons"</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">c</code> <code class="p">=</code> <code class="k">new</code> <code class="n">NamedContainer</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;(</code><code class="s">"Programming C#"</code><code class="p">,</code> <code class="s">"Book title"</code><code class="p">);</code></pre></div>
<p>You can use a constructed generic type anywhere you would use a normal type. For example, you can use them as the types for method parameters and return values, properties, or fields. You can even use one as a type argument for another generic type, as <a data-type="xref" href="#constructed_generic_types_as_type_argume">Example 4-4</a> shows.</p>
<div data-type="example" id="constructed_generic_types_as_type_argume">
<h5><span class="label">Example 4-4. </span>Constructed generic types as type arguments</h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="c1">// ...where a, and b come from </code><a data-type="xref" href="#using_a_generic_class">Example 4-3</a><code class="c1">.
</code><code class="kt">var</code> <code class="n">namedInts</code> <code class="p">=</code> <code class="k">new</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">NamedContainer</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code><code class="p">&gt;</code><code class="p">(</code><code class="p">)</code> <code class="p">{</code> <code class="n">a</code><code class="p">,</code> <code class="n">b</code> <code class="p">}</code><code class="p">;</code>
<code class="kt">var</code> <code class="n">namedNamedItem</code> <code class="p">=</code> <code class="k">new</code> <code class="n">NamedContainer</code><code class="p">&lt;</code><code class="n">NamedContainer</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code><code class="p">&gt;</code><code class="p">(</code><code class="n">a</code><code class="p">,</code> <code class="s">"Wrapped"</code><code class="p">)</code><code class="p">;</code></pre></div>
<p>Each different type I supply as an argument to <code>NamedContainer&lt;T&gt;</code> constructs a distinct type. (And for generic types with multiple type arguments, each distinct combination of type arguments would construct a distinct type.) This means that <code>NamedContainer&lt;int&gt;</code> is a different type than <code>NamedContainer&lt;string&gt;</code>. That’s why there’s no conflict in using <span class="keep-together"><code>NamedContainer&lt;int&gt;</code></span> as the type argument for another <code>NamedContainer</code>, as the final line of <a data-type="xref" href="#constructed_generic_types_as_type_argume">Example 4-4</a> does—there’s no infinite recursion here.</p>
<p>Because each different set of type arguments produces a distinct type, in most cases there is no implied compatibility between different forms of the same generic type. You cannot assign a <code>NamedContainer&lt;int&gt;</code> into a variable of type <code>Nam⁠ed​Con⁠tai⁠ner⁠&lt;str⁠ing&gt;</code> or vice versa. It makes sense that those two types are incompatible, because <code>int</code> and <code>string</code> are quite different types. But what if we used <code>object</code> as a type argument? As <a data-type="xref" href="ch02.xhtml#ch_basic_coding">Chapter 2</a> described, you can put almost anything in an <code>object</code> variable. If you write a method with a parameter of type <code>object</code>, it’s OK to pass a <code>string</code>, so you might expect a method that takes a <code>NamedContainer&lt;object&gt;</code> to be happy with a <code>NamedContainer&lt;string&gt;</code>. That won’t work, but some generic types (specifically, interfaces and delegates) can declare that they want this kind of compatibility relationship. The mechanisms that support this (called <em>covariance</em> and <em>contravariance</em>) are closely related to the type system’s inheritance mechanisms. <a data-type="xref" href="ch06.xhtml#ch_inheritance">Chapter 6</a> is all about inheritance and type compatibility, so I will discuss this aspect of generic types there.</p>
<p>The number of type parameters forms part of an unbound generic type’s identity. This makes it possible to introduce multiple types with the same name as long as they have different numbers of type parameters. (The technical term for number of type parameters is <em>arity</em>.)</p>
<p>So you could define a generic class called, say, <code>Operation&lt;T&gt;</code>, and then another class, <code>Operation&lt;T1, T2&gt;</code>, and also <code>Operation&lt;T1, T2, T3&gt;</code>, and so on, all in the same namespace, without introducing any ambiguity. When you are using these types, it’s clear from the number of arguments which type was meant—<code>Operation&lt;int&gt;</code> clearly uses the first, while <code>Operation&lt;string, double&gt;</code> uses the second, for example. And for the same reason, a nongeneric <code>Operation</code> class would be distinct from generic types of the same name.</p>
<p>My <code>NamedContainer&lt;T&gt;</code> example doesn’t do anything to instances of its type argument, <code>T</code>—it never invokes any methods or uses any properties or other members of <code>T</code>. All it does is accept a <code>T</code> as a constructor argument, which it stores away for later retrieval. This is also true of many generic types in the runtime libraries—I’ve mentioned some collection classes, which are all variations on the same theme of containing data for later retrieval.</p>
<p>There is a reason for this: a generic class can find itself working with any type, so it can presume little about its type arguments. However, it doesn’t have to be this way. You can specify <em>constraints</em> for your type arguments.<a data-startref="ix_ch04-asciidoc2" data-type="indexterm" id="idm45884825705376"/><a data-startref="ix_ch04-asciidoc1" data-type="indexterm" id="idm45884825704672"/></p>
</div></section>
<section data-pdf-bookmark="Constraints" data-type="sect1"><div class="sect1" id="constraints">
<h1>Constraints</h1>
<p><a data-primary="constraints" data-type="indexterm" id="ix_ch04-asciidoc3"/><a data-primary="generics" data-secondary="constraints" data-type="indexterm" id="ix_ch04-asciidoc4"/>C# allows you to state that a type argument must fulfill certain requirements. For example, suppose you want to be able to create new instances of the type on demand. <a data-type="xref" href="#creating_a_new_instance_of_a_parameteriz">Example 4-5</a> shows a simple class that provides deferred construction—it makes an instance available through a static property but does not attempt to construct that instance until the first time you read the property.</p>
<div data-type="example" id="creating_a_new_instance_of_a_parameteriz">
<h5><span class="label">Example 4-5. </span>Creating a new instance of a parameterized type</h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="c1">// For illustration only. Consider using Lazy&lt;T&gt; in a real program.
</code><code class="k">public</code> <code class="k">static</code> <code class="k">class</code> <code class="nc">Deferred</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code>
    <strong><code class="k">where</code> <code class="n">T</code> <code class="p">:</code> <code class="k">new</code><code class="p">(</code><code class="p">)</code></strong>
<code class="p">{</code>
    <code class="k">private</code> <code class="k">static</code> <code class="n">T</code><code class="p">?</code> <code class="n">_instance</code><code class="p">;</code>

    <code class="k">public</code> <code class="k">static</code> <code class="n">T</code> <code class="n">Instance</code>
    <code class="p">{</code>
        <code class="k">get</code>
        <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="n">_instance</code> <code class="p">=</code><code class="p">=</code> <code class="k">null</code><code class="p">)</code>
            <code class="p">{</code>
                <strong><code class="n">_instance</code> <code class="p">=</code> <code class="k">new</code> <code class="n">T</code><code class="p">(</code><code class="p">)</code><code class="p">;</code></strong>
            <code class="p">}</code>
            <code class="k">return</code> <code class="n">_instance</code><code class="p">;</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>You wouldn’t write a class like this in practice, because the runtime libraries offer <code>Lazy&lt;T&gt;</code>, which does the same job but with more flexibility. <span class="keep-together"><code>Lazy&lt;T&gt;</code></span> can work correctly in multithreaded code, which <a data-type="xref" href="#creating_a_new_instance_of_a_parameteriz">Example 4-5</a> will not. <a data-type="xref" href="#creating_a_new_instance_of_a_parameteriz">Example 4-5</a> is just to illustrate how constraints work. Don’t use it!</p>
</div>
<p>For this class to do its job, it needs to be able to construct an instance of whatever type is supplied as the argument for <code>T</code>. The <code>get</code> accessor uses the <code>new</code> keyword, and since it passes no arguments, it clearly requires <code>T</code> to provide a parameterless constructor. But not all types do, so what happens if we try to use a type without a suitable constructor as the argument for <code>Deferred&lt;T&gt;</code>?</p>
<p>The compiler will reject it, because it violates a constraint that this generic type has declared for <code>T</code>. Constraints appear just before the class’s opening brace, and they begin with the <code>where</code> keyword. The <code>new()</code> constraint in <a data-type="xref" href="#creating_a_new_instance_of_a_parameteriz">Example 4-5</a> states that <code>T</code> is required to supply a zero-argument <span class="keep-together">constructor.</span></p>
<p>If that constraint had not been present, the class in <a data-type="xref" href="#creating_a_new_instance_of_a_parameteriz">Example 4-5</a> would not compile—you would get an error on the line that attempts to construct a new <code>T</code>. A generic type (or method) is allowed to use only features of its type parameters that it has specified through constraints, or that are defined by the base <code>object</code> type. (The <code>object</code> type defines a <code>ToString</code> method, for example, so you can invoke that on instances of any type without needing to specify a constraint.)</p>
<p>C# offers only a very limited suite of constraints. You cannot demand a constructor that takes arguments, for example. In fact, C# supports only six kinds of constraints on a type argument: a type constraint, a reference type constraint, a value type constraint, <code>notnull</code>, <code>unmanaged</code>, and the <code>new()</code> constraint. We just saw that last one, so let’s look at the rest.</p>
<section class="less_space pagebreak-before" data-pdf-bookmark="Type Constraints" data-type="sect2"><div class="sect2" id="type_constraints">
<h2>Type Constraints</h2>
<p><a data-primary="constraints" data-secondary="type constraints" data-type="indexterm" id="ix_ch04-asciidoc5"/><a data-primary="type constraints" data-type="indexterm" id="ix_ch04-asciidoc6"/>You can constrain the argument for a type parameter to be compatible with a particular type. For example, you could use this to demand that the argument type implements a certain interface. <a data-type="xref" href="#using_a_type_constraint">Example 4-6</a> shows the syntax.</p>
<div data-type="example" id="using_a_type_constraint">
<h5><span class="label">Example 4-6. </span>Using a type constraint</h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="k">public</code> <code class="k">class</code> <code class="nc">GenericComparer</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="p">:</code> <code class="n">IComparer</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code>
    <strong><code class="k">where</code> <code class="n">T</code> <code class="p">:</code> <code class="n">IComparable</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code></strong>
<code class="p">{</code>
    <code class="k">public</code> <code class="kt">int</code> <code class="nf">Compare</code><code class="p">(</code><code class="n">T</code><code class="p">?</code> <code class="n">x</code><code class="p">,</code> <code class="n">T</code><code class="p">?</code> <code class="n">y</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="n">x</code> <code class="p">=</code><code class="p">=</code> <code class="k">null</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="n">y</code> <code class="p">=</code><code class="p">=</code> <code class="k">null</code> <code class="p">?</code> <code class="m">0</code> <code class="p">:</code> <code class="p">-</code><code class="m">1</code><code class="p">;</code> <code class="p">}</code>
        <code class="k">return</code> <code class="n">x</code><code class="p">.</code><code class="n">CompareTo</code><code class="p">(</code><code class="n">y</code><code class="p">)</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p><a data-primary="comparison" data-type="indexterm" id="idm45884825487424"/>I’ll just explain the purpose of this example before describing how it takes advantage of a type constraint. This class provides a bridge between two styles of value comparison that you’ll find in .NET. Some data types provide their own comparison logic, but at times, it can be more useful for comparison to be a separate function implemented in its own class. <a data-primary="IComparable&lt;T&gt; interface" data-type="indexterm" id="idm45884825486384"/><a data-primary="IComparer&lt;T&gt; interface" data-type="indexterm" id="idm45884825501456"/>These two styles are represented by the <span class="keep-together"><code>IComparable&lt;T&gt;</code></span> and <span class="keep-together"><code>IComparer&lt;T&gt;</code></span> interfaces, which are both part of the runtime libraries. (They are in the <code>System</code> and <code>System.Collections.Generics</code> namespaces, respectively.) I showed <code>IComparer&lt;T&gt;</code> in <a data-type="xref" href="ch03.xhtml#ch_types">Chapter 3</a>—an implementation of this interface can compare two objects or values of type <code>T</code>. The interface defines a single <code>Compare</code> method that takes two arguments and returns either a negative number, 0, or a positive number if the first argument is, respectively, less than, equal to, or greater than the second. 
<span class="keep-together"><code>IComparable&lt;T&gt;</code></span> is very similar, but its <code>CompareTo</code> method takes just a single argument, because with this interface, you are asking an instance to compare <em>itself</em> to some other instance.</p>
<p>Some of the runtime libraries’ collection classes require you to provide an <span class="keep-together"><code>IComparer&lt;T&gt;</code></span> to support ordering operations such as sorting. They use the model in which a separate object performs the comparison, because this offers two advantages over the <code>IComparable&lt;T&gt;</code> model. First, it enables you to use data types that don’t implement <code>IComparable&lt;T&gt;</code>. Second, it allows you to plug in different sorting orders. (For example, suppose you want to sort some strings with a case-insensitive order. The <code>string</code> type implements <code>IComparable&lt;string&gt;</code>, but it provides a case-sensitive, locale-specific order.) So <code>IComparer&lt;T&gt;</code> is the more flexible model. However, what if you are using a data type that implements <code>IComparable&lt;T&gt;</code>, and you’re perfectly happy with the order that provides? What would you do if you’re working with an API that demands an <code>IComparer&lt;T&gt;</code>?</p>
<p>Actually, the answer is that you’d probably just use the .NET feature designed for this very scenario: <code>Comparer&lt;T&gt;.Default</code>. If <code>T</code> implements <code>IComparable&lt;T&gt;</code>, that property will return an <code>IComparer&lt;T&gt;</code> that does precisely what you want. So in practice you wouldn’t need to write the code in <a data-type="xref" href="#using_a_type_constraint">Example 4-6</a>, because Microsoft has already written it for you. However, it’s instructive to see how you’d write your own version, because it illustrates how to use a type constraint.</p>
<p>The line starting with the <code>where</code> keyword states that this generic class requires the argument for its type parameter <code>T</code> to implement <code>IComparable&lt;T&gt;</code>. Without this addition, the <code>Compare</code> method would not compile—it invokes the <code>CompareTo</code> method on an argument of type <code>T</code>. That method is not present on all objects, and the C# compiler allows this only because we’ve constrained <code>T</code> to be an implementation of an interface that does offer such a method.</p>
<p>Interface constraints are somewhat odd: at first glance, it may look like we really shouldn’t need them. If a method needs a particular argument to implement a particular interface, you would normally just use that interface as the argument’s type. However, <a data-type="xref" href="#using_a_type_constraint">Example 4-6</a> can’t do this. You can demonstrate this by trying <a data-type="xref" href="#will_not_compile_colon_interface_not_imp">Example 4-7</a>. It won’t compile.</p>
<div data-type="example" id="will_not_compile_colon_interface_not_imp">
<h5><span class="label">Example 4-7. </span>Will not compile: interface not implemented</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">GenericComparer</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="p">:</code> <code class="n">IComparer</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="kt">int</code> <code class="nf">Compare</code><code class="p">(</code><code class="n">IComparable</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;?</code> <code class="n">x</code><code class="p">,</code> <code class="n">T</code><code class="p">?</code> <code class="n">y</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="n">x</code> <code class="p">==</code> <code class="k">null</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="n">y</code> <code class="p">==</code> <code class="k">null</code> <code class="p">?</code> <code class="m">0</code> <code class="p">:</code> <code class="p">-</code><code class="m">1</code><code class="p">;</code> <code class="p">}</code>
        <code class="k">return</code> <code class="n">x</code><code class="p">.</code><code class="n">CompareTo</code><code class="p">(</code><code class="n">y</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>The compiler will complain that I’ve not implemented the <code>IComparer&lt;T&gt;</code> interface’s <code>Compare</code> method. <a data-type="xref" href="#will_not_compile_colon_interface_not_imp">Example 4-7</a> has a <code>Compare</code> method, but its signature is wrong—that first argument should be a <code>T</code>. I could also try the correct signature without specifying the constraint, as <a data-type="xref" href="#will_not_compile_colon_missing_constrain">Example 4-8</a> shows.</p>
<div data-type="example" id="will_not_compile_colon_missing_constrain">
<h5><span class="label">Example 4-8. </span>Will not compile: missing constraint</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">GenericComparer</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="p">:</code> <code class="n">IComparer</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="kt">int</code> <code class="nf">Compare</code><code class="p">(</code><code class="n">T</code><code class="p">?</code> <code class="n">x</code><code class="p">,</code> <code class="n">T</code><code class="p">?</code> <code class="n">y</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="n">x</code> <code class="p">==</code> <code class="k">null</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="n">y</code> <code class="p">==</code> <code class="k">null</code> <code class="p">?</code> <code class="m">0</code> <code class="p">:</code> <code class="p">-</code><code class="m">1</code><code class="p">;</code> <code class="p">}</code>
        <code class="k">return</code> <code class="n">x</code><code class="p">.</code><code class="n">CompareTo</code><code class="p">(</code><code class="n">y</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>That will also fail to compile, because the compiler can’t find that <code>CompareTo</code> method I’m trying to use. It’s the constraint for <code>T</code> in <a data-type="xref" href="#using_a_type_constraint">Example 4-6</a> that enables the compiler to know what that method really is.</p>
<p>Type constraints don’t have to be interfaces, by the way. You can use any type. For example, you can require a particular type argument to derive from a particular base class. More subtly, you can also define one parameter’s constraint in terms of another type parameter. <a data-type="xref" href="#constraining_one_argument_to_derive_from">Example 4-9</a> requires the first type argument to derive from the second, for example.</p>
<div data-type="example" id="constraining_one_argument_to_derive_from">
<h5><span class="label">Example 4-9. </span>Constraining one argument to derive from another</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">Foo</code><code class="p">&lt;</code><code class="n">T1</code><code class="p">,</code> <code class="n">T2</code><code class="p">&gt;</code>
    <code class="k">where</code> <code class="n">T1</code> <code class="p">:</code> <code class="n">T2</code>
<code class="p">...</code></pre></div>
<p>Type constraints are fairly specific—they require either a particular inheritance relationship, or the implementation of certain interfaces. However, you can define slightly less specific constraints.<a data-startref="ix_ch04-asciidoc6" data-type="indexterm" id="idm45884825228448"/><a data-startref="ix_ch04-asciidoc5" data-type="indexterm" id="idm45884825227840"/></p>
</div></section>
<section data-pdf-bookmark="Reference Type Constraints" data-type="sect2"><div class="sect2" id="reference_type_constraints">
<h2>Reference Type Constraints</h2>
<p><a data-primary="constraints" data-secondary="reference type constraints" data-type="indexterm" id="ix_ch04-asciidoc7"/><a data-primary="type constraints" data-secondary="reference type constraints" data-type="indexterm" id="ix_ch04-asciidoc8"/>You can constrain a type argument to be a reference type. As <a data-type="xref" href="#constraint_requiring_a_reference_type">Example 4-10</a> shows, this looks similar to a type constraint. <a data-primary="class keyword, reference types and" data-type="indexterm" id="idm45884825221936"/>You just put the keyword <code>class</code> instead of a type name. If you are in an enabled nullable annotation context, the meaning of this annotation changes: it requires the type argument to be a non-nullable reference type. If you specify <code>class?</code>, that allows the type argument to be either a nullable or a non-nullable reference type.</p>
<div data-type="example" id="constraint_requiring_a_reference_type">
<h5><span class="label">Example 4-10. </span>Constraint requiring a reference type</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">Bar</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code>
    <code class="k">where</code> <code class="n">T</code> <code class="p">:</code> <code class="k">class</code>
<code class="p">...</code></pre></div>
<p>This constraint prevents the use of value types such as <code>int</code>, <code>double</code>, or any <code>struct</code> as the type argument. Its presence enables your code to do three things that would not otherwise be possible. First, it means that you can write code that tests whether variables of the relevant type are <code>null</code>.<sup><a data-type="noteref" href="ch04.xhtml#idm45884825181168" id="idm45884825181168-marker">2</a></sup> If you’ve not constrained the type to be a reference type, there’s always a possibility that it’s a value type, and those can’t have <code>null</code> values. The second capability is that you can use it as the target type of the<a data-primary="as operator" data-type="indexterm" id="idm45884825179040"/> <code>as</code> operator, which we’ll look at in <a data-type="xref" href="ch06.xhtml#ch_inheritance">Chapter 6</a>. This is really just a variation on the first feature—the <code>as</code> keyword requires a reference type because it can produce a <code>null</code> result.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a data-primary="nullable types, class constraints and" data-type="indexterm" id="idm45884825175536"/>A <code>class</code> constraint prevents the use of nullable types such as <code>int?</code> (or <code>Nullable&lt;int&gt;</code>, as the CLR calls it). Although you can test an <code>int?</code> for <code>null</code> and use it with the <code>as</code> operator, the compiler generates quite different code for nullable types for both operations than it does for a reference type. It cannot compile a single method that can cope with both reference types and nullable types if you use these features.</p>
</div>
<p>The third feature that a reference type constraint enables is the ability to use certain other generic types. It’s often convenient for generic code to use one of its type arguments as an argument for another generic type, and if that other type specifies a constraint, you’ll need to put the same constraint on your own type parameter. So if some other type specifies a class constraint, this might require you to constrain one of your own arguments in the same way.</p>
<p>Of course, this does raise the question of why the type you’re using needs the constraint in the first place. It might be that it simply wants to test for <code>null</code> or use the <code>as</code> operator, but there’s another reason for applying this constraint. Sometimes, you just need a type argument to be a reference type—there are situations in which a generic method might be able to compile without a <code>class</code> constraint, but it will not work correctly if used with a value type. To illustrate this, I’ll describe a scenario in which I sometimes find myself needing to use this kind of constraint.</p>
<p>I regularly write tests that create an instance of the class I’m testing and that also need one or more fake objects to stand in for real objects with which the object under test wants to interact. Using these stand-ins reduces the amount of code any single test has to exercise and can make it easier to verify the behavior of the object being tested. For example, my test might need to verify that my code sends messages to a server at the right moment, but I don’t want to have to run a real server during a unit test, so I provide an object that implements the same interface as the class that would transmit the message but that won’t really send the message. This combination of an object under test plus a fake is such a common pattern that it might be useful to put the code into a reusable base class. Using generics means that the class can work for any combination of the type being tested and the type being faked. <a data-type="xref" href="#constrained_by_another_constraint">Example 4-11</a> shows a simplified version of a kind of helper class I sometimes write in these <span class="keep-together">situations.</span></p>
<div data-type="example" id="constrained_by_another_constraint">
<h5><span class="label">Example 4-11. </span>Constrained by another constraint</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">using</code> <code class="nn">Microsoft.VisualStudio.TestTools.UnitTesting</code><code class="p">;</code>
<code class="k">using</code> <code class="nn">Moq</code><code class="p">;</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">TestBase</code><code class="p">&lt;</code><code class="n">TSubject</code><code class="p">,</code> <code class="n">TFake</code><code class="p">&gt;</code>
    <code class="k">where</code> <code class="n">TSubject</code> <code class="p">:</code> <code class="k">new</code><code class="p">()</code>
    <code class="k">where</code> <code class="n">TFake</code> <code class="p">:</code> <code class="k">class</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="n">TSubject</code><code class="p">?</code> <code class="n">Subject</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">private</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
    <code class="k">public</code> <code class="n">Mock</code><code class="p">&lt;</code><code class="n">TFake</code><code class="p">&gt;?</code> <code class="n">Fake</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">private</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>

<code class="na">    [TestInitialize]</code>
    <code class="k">public</code> <code class="k">void</code> <code class="nf">Initialize</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="n">Subject</code> <code class="p">=</code> <code class="k">new</code> <code class="n">TSubject</code><code class="p">();</code>
        <code class="n">Fake</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Mock</code><code class="p">&lt;</code><code class="n">TFake</code><code class="p">&gt;();</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>There are various ways to build fake objects for test purposes. You could just write new classes that implement the same interface as your real objects, but there are also third-party libraries that can generate them. One such library is called Moq (an <a href="https://github.com/Moq">open source project available for free</a>), and that’s where the <code>Mock&lt;T&gt;</code> class in <a data-type="xref" href="#constrained_by_another_constraint">Example 4-11</a> comes from. It’s capable of generating a fake implementation of any interface or of any nonsealed class. (<a data-type="xref" href="ch06.xhtml#ch_inheritance">Chapter 6</a> describes the <code>sealed</code> keyword.) It will provide empty implementations of all members by default, and you can configure more interesting behaviors if necessary. You can also verify whether the code under test used the fake object in the way you expected.</p>
<p><a data-primary="Mock&lt;T&gt; class" data-type="indexterm" id="idm45884825066928"/>How is that relevant to constraints? The <code>Mock&lt;T&gt;</code> class specifies a reference type constraint on its own type argument, <code>T</code>. This is due to the way in which it creates dynamic implementations of types at runtime; it’s a technique that can work only for reference types. <a data-primary="Moq library" data-type="indexterm" id="idm45884825029472"/>Moq generates a type at runtime, and if <code>T</code> is an interface, that generated type will implement it, whereas if <code>T</code> is a class, the generated type will derive from it.<sup><a data-type="noteref" href="ch04.xhtml#CHP-4-FN-1" id="CHP-4-FN-1-marker">3</a></sup> There’s nothing useful it can do if <code>T</code> is a struct, because you cannot derive from a value type. That means that when I use <code>Mock&lt;T&gt;</code> in <a data-type="xref" href="#constrained_by_another_constraint">Example 4-11</a>, I need to make sure that whatever type argument I pass is not a struct (i.e., it must be a reference type). But the type argument I’m using is one of my class’s type parameters: <code>TFake</code>. So I don’t know what type that will be—that’ll be up to whoever is using 
<span class="keep-together">my class.</span></p>
<p>For my class to compile without error, I have to ensure that I have met the constraints of any generic types that I use. I have to guarantee that <code>Mock&lt;TFake&gt;</code> is valid, and the only way to do that is to add a constraint on my own type that requires <code>TFake</code> to be a reference type. And that’s what I’ve done on the third line of the class definition in <a data-type="xref" href="#constrained_by_another_constraint">Example 4-11</a>. Without that, the compiler would report errors on the two lines that refer to <code>Mock&lt;TFake&gt;</code>.</p>
<p>To put it more generally, if you want to use one of your own type parameters as the type argument for a generic that specifies a constraint, you’ll need to specify the same constraint on your own type parameter.<a data-startref="ix_ch04-asciidoc8" data-type="indexterm" id="idm45884825020704"/><a data-startref="ix_ch04-asciidoc7" data-type="indexterm" id="idm45884825020000"/></p>
</div></section>
<section data-pdf-bookmark="Value Type Constraints" data-type="sect2"><div class="sect2" id="value_type_constraints">
<h2>Value Type Constraints</h2>
<p><a data-primary="constraints" data-secondary="value type constraints" data-type="indexterm" id="idm45884825017744"/><a data-primary="type constraints" data-secondary="value type constraints" data-type="indexterm" id="idm45884825016768"/><a data-primary="value type" data-secondary="constraints" data-type="indexterm" id="idm45884825015824"/>Just as you can constrain a type argument to be a reference type, you can also constrain it to be a value type. As shown in <a data-type="xref" href="#constraint_requiring_a_value_type">Example 4-12</a>, the syntax is similar to that for a reference type constraint but with the <code>struct</code> keyword.</p>
<div data-type="example" id="constraint_requiring_a_value_type">
<h5><span class="label">Example 4-12. </span>Constraint requiring a value type</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">Quux</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code>
    <code class="k">where</code> <code class="n">T</code> <code class="p">:</code> <code class="k">struct</code>
<code class="p">...</code></pre></div>
<p>Before now, we’ve seen the <code>struct</code> keyword only in the context of custom value types, but despite how it looks, this constraint permits <code>bool</code>, <code>enum</code> types, and any of the built-in numeric types such as <code>int</code>, as well as custom structs.</p>
<p><a data-primary="Nullable&lt;T&gt; type" data-type="indexterm" id="idm45884824980144"/>.NET’s <code>Nullable&lt;T&gt;</code> type imposes this constraint. Recall from <a data-type="xref" href="ch03.xhtml#ch_types">Chapter 3</a> that 
<span class="keep-together"><code>Nullable&lt;T&gt;</code></span> provides a wrapper for value types that allows a variable to hold either a value or no value. (We normally use the special syntax C# provides, so we’d write, say, <code>int?</code> instead of <code>Nullable&lt;int&gt;</code>.) The only reason this type exists is to provide nullability for types that would not otherwise be able to hold a null value. So it only makes sense to use this with a value type—reference type variables can already be set to <code>null</code> without needing this wrapper. The value type constraint prevents you from using <code>Nullable&lt;T&gt;</code> with types for which it is unnecessary.</p>
</div></section>
<section data-pdf-bookmark="Value Types All the Way Down with Unmanaged Constraints" data-type="sect2"><div class="sect2" id="unmanaged_constraints">
<h2>Value Types All the Way Down with Unmanaged Constraints</h2>
<p><a data-primary="constraints" data-secondary="unmanaged constraints" data-type="indexterm" id="idm45884824969120"/><a data-primary="unmanaged constraints" data-type="indexterm" id="idm45884824967920"/><a data-primary="value type" data-secondary="unmanaged constraints" data-type="indexterm" id="idm45884824967248"/>You can specify <code>unmanaged</code> as a constraint, which requires that the type argument be a value type but also that it contains no references. All of the type’s fields must be value types, and if any of those fields is not a built-in primitive type, then its type must in turn contain only fields that are value types, and so on all the way down. In practice this means that all the actual data needs to be either one of a fixed set of built-in types (essentially, all the numeric types, <code>bool</code>, or a pointer) or an <code>enum</code> type. This is mainly of interest in interop scenarios, because types that match the <code>unmanaged</code> constraint can be passed safely and efficiently to unmanaged code.</p>
</div></section>
<section data-pdf-bookmark="Not Null Constraints" data-type="sect2"><div class="sect2" id="notnull_constraints">
<h2>Not Null Constraints</h2>
<p><a data-primary="constraints" data-secondary="not null constraints" data-type="indexterm" id="idm45884824962880"/><a data-primary="not null constraints" data-type="indexterm" id="idm45884824961904"/>If you use the nullable references feature described in <a data-type="xref" href="ch03.xhtml#ch_types">Chapter 3</a> (which is enabled by default when you create new projects), you can specify a <code>notnull</code> constraint. This allows either value types or non-nullable reference types but not nullable reference types.</p>
</div></section>
<section data-pdf-bookmark="Other Special Type Constraints" data-type="sect2"><div class="sect2" id="idm45884824959488">
<h2>Other Special Type Constraints</h2>
<p><a data-type="xref" href="ch03.xhtml#ch_types">Chapter 3</a> described various special kinds of types, including enumeration types (<code>enum</code>) and delegate types (covered in detail in <a data-type="xref" href="ch09.xhtml#ch_delegates_lambdas_events">Chapter 9</a>). It is sometimes useful to constrain type arguments to be one of these kinds of types. There’s no special trick to this, though: you can just use type constraints. All delegate types derive from <code>System.Delegate</code>, and all enumeration types derive from <code>System.Enum</code>. As <a data-type="xref" href="#constraint_requiring_delegate_or_enum">Example 4-13</a> shows, you can just write a type constraint requiring a type argument to derive from either of these.</p>
<div data-type="example" id="constraint_requiring_delegate_or_enum">
<h5><span class="label">Example 4-13. </span>Constraints requiring delegate and <code>enum</code> types</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">RequireDelegate</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code>
    <code class="k">where</code> <code class="n">T</code> <code class="p">:</code> <code class="n">Delegate</code>
<code class="p">{</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">RequireEnum</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code>
    <code class="k">where</code> <code class="n">T</code> <code class="p">:</code> <code class="n">Enum</code>
<code class="p">{</code>
<code class="p">}</code></pre></div>
</div></section>
<section data-pdf-bookmark="Multiple Constraints" data-type="sect2"><div class="sect2" id="multiple_constraints">
<h2>Multiple Constraints</h2>
<p><a data-primary="constraints" data-secondary="multiple constraints" data-type="indexterm" id="idm45884824934400"/>If you’d like to impose multiple constraints for a single type argument, you can just put them in a list, as <a data-type="xref" href="#multiple_constraints-id1">Example 4-14</a> shows. There are some restrictions. You cannot combine the <code>class</code>, <code>struct</code>, <code>notnull</code>, or <code>unmanaged</code> constraints—these are mutually exclusive. If you do use one of these keywords, it must come first in the list. If the <code>new()</code> constraint is present, it must be last.</p>
<div data-type="example" id="multiple_constraints-id1">
<h5><span class="label">Example 4-14. </span>Multiple constraints</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">Spong</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code>
    <code class="k">where</code> <code class="n">T</code> <code class="p">:</code> <code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;,</code> <code class="n">IDisposable</code><code class="p">,</code> <code class="k">new</code><code class="p">()</code>
<code class="p">...</code></pre></div>
<p>When your type has multiple type parameters, you write one <code>where</code> clause for each type parameter you wish to constrain. In fact, we saw this earlier—<a data-type="xref" href="#constrained_by_another_constraint">Example 4-11</a> defines constraints for both of its parameters.<a data-startref="ix_ch04-asciidoc4" data-type="indexterm" id="idm45884824873568"/><a data-startref="ix_ch04-asciidoc3" data-type="indexterm" id="idm45884824872960"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Zero-Like Values" data-type="sect1"><div class="sect1" id="zero-like_values">
<h1>Zero-Like Values</h1>
<p><a data-primary="generics" data-secondary="zero-like values" data-type="indexterm" id="ix_ch04-asciidoc9"/><a data-primary="zero-like values" data-type="indexterm" id="ix_ch04-asciidoc10"/>There are certain features that all types support and that therefore do not require a constraint. This includes the set of methods defined by the <code>object</code> base class, covered in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch03.xhtml#ch_types">3</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch06.xhtml#ch_inheritance">6</a>. But there’s a more basic feature that can sometimes be useful in generic code.</p>
<p>Variables of any type can be initialized to a default value. As you have seen in the preceding chapters, there are some situations in which the CLR does this for us. For example, all the fields in a newly constructed object will have a known value even if we don’t write field initializers and don’t supply values in the constructor. Likewise, a new array of any type will have all of its elements initialized to a known value. The CLR does this by filling the relevant memory with zeros. The exact meaning of this depends on the data type. For any of the built-in numeric types, the value will quite literally be the number <code>0</code>, but for nonnumeric types, it’s something else. For <code>bool</code>, the default is <code>false</code>, and for a reference type, it is <code>null</code>.</p>
<p>Sometimes, it can be useful for generic code to be able to set a variable to this initial default zero-like value. But you cannot use a literal expression to do this in most situations. You cannot assign <code>null</code> into a variable whose type is specified by a type parameter unless that parameter has been constrained to be a reference type. And you cannot assign the literal <code>0</code> into any such variable, because there is currently no way to constrain a type argument to be a numeric type.</p>
<p><a data-primary="default keyword" data-type="indexterm" id="idm45884824861136"/>Instead, you can request the zero-like value for any type using the <code>default</code> keyword. (This is the same keyword we saw inside a <code>switch</code> statement in <a data-type="xref" href="ch02.xhtml#ch_basic_coding">Chapter 2</a> but used in a completely different way. C# keeps up the C-family tradition of defining multiple, unrelated meanings for each keyword.) If you write <code>default(<em>SomeType</em>)</code>, where <code><em>SomeType</em></code> is either a specific type or a type parameter, you will get the default initial value for that type: <code>0</code> if it is a numeric type, and the equivalent for any other type. For example, the expression <code>default(int)</code> has the value <code>0</code>, <code>default(bool)</code> is <code>false</code>, and <code>default(string)</code> is <code>null</code>. You can use this with a generic type parameter to get the default value for the corresponding type argument, as <a data-type="xref" href="#getting_the_default_open_parenthesis_zer">Example 4-15</a> shows.</p>
<div data-type="example" id="getting_the_default_open_parenthesis_zer">
<h5><span class="label">Example 4-15. </span>Getting the default (zero-like) value of a type argument</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">static</code> <code class="k">void</code> <code class="n">ShowDefault</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;()</code>
<code class="p">{</code>
    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="k">default</code><code class="p">(</code><code class="n">T</code><code class="p">));</code>
<code class="p">}</code></pre></div>
<p>Inside a generic type or method that defines a type parameter <code>T</code>, the expression <code>default(T)</code> will produce the default, zero-like value for <code>T</code>—whatever <code>T</code> may be—without requiring constraints. So you could use the generic method in <a data-type="xref" href="#getting_the_default_open_parenthesis_zer">Example 4-15</a> to verify that the defaults for <code>int</code>, <code>bool</code>, and <code>string</code> are the values I stated.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>When the nullable references feature (described in <a data-type="xref" href="ch03.xhtml#ch_types">Chapter 3</a>) is enabled, the compiler will consider a <code>default(T)</code> to be a potentially null value, unless you’ve ruled out the use of reference types by applying the <code>struct</code> constraint.</p>
</div>
<p>In cases where the compiler is able to infer what type is required, you can use a simpler form. Instead of writing <code>default(T)</code>, you can just write <code>default</code>. That wouldn’t work in <a data-type="xref" href="#getting_the_default_open_parenthesis_zer">Example 4-15</a> because <code>Console.WriteLine</code> can accept pretty much anything, so the compiler can’t narrow it down to one option, but it will work in <a data-type="xref" href="#default_literal_inferred">Example 4-16</a> because the compiler can see that the generic method’s return type is <code>T</code>, so this must need a <code>default(T)</code>. Since it can infer that, it’s enough for us to write just <code>default</code>.</p>
<div data-type="example" id="default_literal_inferred">
<h5><span class="label">Example 4-16. </span>Getting the default (zero-like) value of an inferred type</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">static</code> <code class="n">T</code><code class="p">?</code> <code class="n">GetDefault</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;()</code> <code class="p">=&gt;</code> <code class="k">default</code><code class="p">;</code></pre></div>
<p>And since I’ve just shown you an example of one, this seems like a good time to talk about generic methods.<a data-startref="ix_ch04-asciidoc10" data-type="indexterm" id="idm45884824758848"/><a data-startref="ix_ch04-asciidoc9" data-type="indexterm" id="idm45884824758240"/></p>
</div></section>
<section data-pdf-bookmark="Generic Methods" data-type="sect1"><div class="sect1" id="generic_methods">
<h1>Generic Methods</h1>
<p><a data-primary="generics" data-secondary="generic methods" data-type="indexterm" id="idm45884824755792"/><a data-primary="methods" data-secondary="generic" data-type="indexterm" id="idm45884824754816"/>As well as generic types, C# also supports generic methods. In this case, the generic type parameter list follows the method name and precedes the method’s normal parameter list. <a data-type="xref" href="#a_generic_method">Example 4-17</a> shows a method with a single type parameter. It uses that parameter as its return type and also as the element type for an array to be passed in as the method’s argument. This method returns the final element in the array, and because it’s generic, it will work for any array element type.</p>
<div data-type="example" id="a_generic_method">
<h5><span class="label">Example 4-17. </span>A generic method</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">static</code> <code class="n">T</code> <code class="n">GetLast</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;(</code><code class="n">T</code><code class="p">[]</code> <code class="n">items</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">items</code><code class="p">[^</code><code class="m">1</code><code class="p">];</code></pre></div>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can define generic methods inside either generic types or nongeneric types. If a generic method is a member of a generic type, all of the type parameters from the containing type are in scope inside the method, as well as the type parameters specific to the method.</p>
</div>
<p>Just as with a generic type, you can use a generic method by specifying its name along with its type arguments, as <a data-type="xref" href="#invoking_a_generic_method">Example 4-18</a> shows.</p>
<div data-type="example" id="invoking_a_generic_method">
<h5><span class="label">Example 4-18. </span>Invoking a generic method</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">int</code><code class="p">[]</code> <code class="n">values</code> <code class="p">=</code> <code class="p">{</code> <code class="m">1</code><code class="p">,</code> <code class="m">2</code><code class="p">,</code> <code class="m">3</code> <code class="p">};</code>
<code class="kt">int</code> <code class="n">last</code> <code class="p">=</code> <code class="n">GetLast</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;(</code><code class="n">values</code><code class="p">);</code></pre></div>
<p>Generic methods work in a similar way to generic types but with type parameters that are only in scope within the method declaration and body. You can specify constraints in much the same way as with generic types. The constraints appear after the method’s parameter list and before its body, as <a data-type="xref" href="#a_generic_method_with_a_constraint">Example 4-19</a> shows.</p>
<div data-type="example" id="a_generic_method_with_a_constraint">
<h5><span class="label">Example 4-19. </span>A generic method with a constraint</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">static</code> <code class="n">T</code> <code class="n">MakeFake</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;()</code>
    <code class="k">where</code> <code class="n">T</code> <code class="p">:</code> <code class="k">class</code>
<code class="p">{</code>
    <code class="k">return</code> <code class="k">new</code> <code class="n">Mock</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;().</code><code class="n">Object</code><code class="p">;</code>
<code class="p">}</code></pre></div>
<p>There’s one significant way in which generic methods differ from generic types, though: you don’t always need to specify a generic method’s type arguments explicitly.</p>
<section data-pdf-bookmark="Type Inference" data-type="sect2"><div class="sect2" id="type_inference">
<h2>Type Inference</h2>
<p><a data-primary="generics" data-secondary="methods" data-type="indexterm" id="idm45884824613472"/><a data-primary="type inference" data-type="indexterm" id="idm45884824612496"/>The C# compiler is often able to infer the type arguments for a generic method. I can modify <a data-type="xref" href="#invoking_a_generic_method">Example 4-18</a> by removing the type argument list from the method invocation, as <a data-type="xref" href="#generic_method_type_argument_inference">Example 4-20</a> shows. This doesn’t change the meaning of the code in any way.</p>
<div data-type="example" id="generic_method_type_argument_inference">
<h5><span class="label">Example 4-20. </span>Generic method type argument inference</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">int</code><code class="p">[]</code> <code class="n">values</code> <code class="p">=</code> <code class="p">{</code> <code class="m">1</code><code class="p">,</code> <code class="m">2</code><code class="p">,</code> <code class="m">3</code> <code class="p">};</code>
<code class="kt">int</code> <code class="n">last</code> <code class="p">=</code> <code class="n">GetLast</code><code class="p">(</code><code class="n">values</code><code class="p">);</code></pre></div>
<p>When presented with this sort of ordinary-looking method call, if there’s no nongeneric method of that name available, the compiler starts looking for suitable generic methods. If the method in <a data-type="xref" href="#a_generic_method">Example 4-17</a> is in scope, it will be a candidate, and the compiler will attempt to deduce the type arguments. This is a pretty simple case. The method expects an array of some type <code>T</code>, and we’ve passed an array with elements of type <code>int</code>, so it’s not a massive stretch to work out that this code should be treated as a call to <code>GetLast&lt;int&gt;</code>.</p>
<p>It gets more complex with more intricate cases. The C# specification has about six pages dedicated to the type inference algorithm, but it’s all to support one goal: letting you leave out type arguments when they would be redundant. By the way, type inference is always performed at compile time, so it’s based on the static type of the method arguments.</p>
<p>With APIs that make extensive use of generics (such as LINQ, which is the topic of <a data-type="xref" href="ch10.xhtml#ch_linq">Chapter 10</a>), explicitly listing every type argument can make the code very hard to follow, so it is common to rely on type inference. And if you use anonymous types, then type argument inference becomes essential because it is not possible to supply the type arguments explicitly.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Generics and Tuples" data-type="sect1"><div class="sect1" id="idm45884824757040">
<h1>Generics and Tuples</h1>
<p><a data-primary="generics" data-secondary="tuples and" data-type="indexterm" id="idm45884824561184"/><a data-primary="tuples" data-secondary="generics and" data-type="indexterm" id="idm45884824560208"/>C#’s lightweight tuples have a distinctive syntax, but as far as the runtime is concerned, there is nothing special about them. They are all just instances of a set of generic types. Look at <a data-type="xref" href="#tuple_usual_declaration">Example 4-21</a>. This uses <code>(int, int)</code> as the type of a local variable to indicate that it is a tuple containing two <code>int</code> values.</p>
<div data-type="example" id="tuple_usual_declaration">
<h5><span class="label">Example 4-21. </span>Declaring a tuple variable in the normal way</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="p">(</code><code class="kt">int</code><code class="p">,</code> <code class="kt">int</code><code class="p">)</code> <code class="n">p</code> <code class="p">=</code> <code class="p">(</code><code class="m">42</code><code class="p">,</code> <code class="m">99</code><code class="p">);</code></pre></div>
<p><a data-primary="ValueTuple&lt;T&gt; type" data-type="indexterm" id="idm45884824549456"/>Now look at <a data-type="xref" href="#tuple_underlying_type">Example 4-22</a>. This uses the <code>ValueTuple&lt;int, int&gt;</code> type in the <code>System</code> namespace. But this is exactly equivalent to the declaration in <a data-type="xref" href="#tuple_usual_declaration">Example 4-21</a>. In Visual Studio or VS Code, if you hover the mouse over the <code>p2</code> variable, it will report its type as <code>(int, int)</code>.</p>
<div data-type="example" id="tuple_underlying_type">
<h5><span class="label">Example 4-22. </span>Declaring a tuple variable with its underlying type</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">ValueTuple</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">,</code> <code class="kt">int</code><code class="p">&gt;</code> <code class="n">p2</code> <code class="p">=</code> <code class="p">(</code><code class="m">42</code><code class="p">,</code> <code class="m">99</code><code class="p">);</code></pre></div>
<p>One thing that C#’s special syntax for tuples adds is the ability to name the tuple elements. The <code>ValueTuple</code> family names its elements <code>Item1</code>, <code>Item2</code>, <code>Item3</code>, etc., but in C# we can pick other names. When you declare a local variable with named tuple elements, those names are  a fiction maintained by C#—they have no runtime representation at all. However, when a method returns a tuple, as in <a data-type="xref" href="#tuple_return">Example 4-23</a>, it’s different: the names need to be visible so that code consuming this method can use the same names. Even if this method is in some library component that my code has referenced, I want to be able to write <code>Pos().X</code>, instead of having to use <code>Pos().Item1</code>.</p>
<div data-type="example" id="tuple_return">
<h5><span class="label">Example 4-23. </span>Returning a tuple</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="nf">static</code> <code class="p">(</code><code class="kt">int</code> <code class="n">X</code><code class="p">,</code> <code class="kt">int</code> <code class="n">Y</code><code class="p">)</code> <code class="n">Pos</code><code class="p">()</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="m">10</code><code class="p">,</code> <code class="m">20</code><code class="p">);</code></pre></div>
<p>To make this work, the compiler applies an attribute named <code>TupleElementNames</code> to the method’s return value, and this contains an array listing the property names to use. (<a data-type="xref" href="ch14.xhtml#ch_attributes">Chapter 14</a> describes attributes.) You can’t actually write code that does this yourself: if you write a method that returns a <code>ValueTuple&lt;int, int&gt;</code> and you try to apply the <code>TupleElementNamesAttribute</code> as a <code>return</code> attribute, the compiler will produce an error telling you not to use this attribute directly and to use the tuple syntax instead. But that attribute is how the compiler reports the tuple element names.</p>
<p>Be aware that there’s another family of tuple types in the runtime libraries, <code>Tuple&lt;T&gt;</code>, <code>Tuple&lt;T1, T2&gt;</code>, and so on. These look almost identical to the <code>ValueTuple</code> family. The difference is that the <code>Tuple</code> family of generic types are all classes, whereas all the <code>ValueTuple</code> types are structs. The C# lightweight tuple syntax only uses the <code>ValueTuple</code> family. The <code>Tuple</code> family has been around in the runtime libraries for much longer, though, so you often see them used in older code that needed to bundle a set of values together without defining a new type just for that job.</p>
</div></section>
<section data-pdf-bookmark="Inside Generics" data-type="sect1"><div class="sect1" id="inside_generics">
<h1>Inside Generics</h1>
<p><a data-primary="generics" data-secondary="inside" data-type="indexterm" id="ix_ch04-asciidoc11"/><a data-primary="generics" data-secondary="templates versus" data-type="indexterm" id="ix_ch04-asciidoc12"/><a data-primary="templates, generics versus" data-type="indexterm" id="ix_ch04-asciidoc13"/>If you are familiar with C++ templates, you will by now have noticed that C# generics are quite different than templates. Superficially, they have some similarities and can be used in similar ways—both are suitable for implementing collection classes, for example. However, there are some template-based techniques that simply won’t work in C#, such as the code in <a data-type="xref" href="#template_technique_wont_work_in_cs">Example 4-24</a>.</p>
<div data-type="example" id="template_technique_wont_work_in_cs">
<h5><span class="label">Example 4-24. </span>A template technique that doesn’t work in C# generics</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">static</code> <code class="n">T</code> <code class="n">Add</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;(</code><code class="n">T</code> <code class="n">x</code><code class="p">,</code> <code class="n">T</code> <code class="n">y</code><code class="p">)</code>
<code class="p">{</code>
    <code class="k">return</code> <code class="n">x</code> <code class="p">+</code> <code class="n">y</code><code class="p">;</code>  <code class="c1">// Will not compile</code>
<code class="p">}</code></pre></div>
<p>You can do this sort of thing in a C++ template but not in C#, and you cannot fix it completely with a constraint. You could add a type constraint requiring <code>T</code> to derive from some type or implement some interface that defines a custom <code>+</code> operator, which would get this to compile, but it would be pretty limited—it would work only for types derived from that base type. In <span class="keep-together">C++</span>, you can write a template that will add together two items of any type that supports addition, whether that is a built-in type or a custom one. Moreover, <span class="keep-together">C++</span> templates don’t need constraints; the compiler is able to work out for itself whether a particular type will work as a template argument.</p>
<p>This issue is not specific to arithmetic. The fundamental problem is that because generic code relies on constraints to know what operations are available on its type parameters, it can use only features represented as members of interfaces or shared base classes. If arithmetic in .NET were interface-based, it would be possible to define a constraint that requires it. But operators are all static methods, and although interfaces can contain static members,<sup><a data-type="noteref" href="ch04.xhtml#idm45884824373280" id="idm45884824373280-marker">4</a></sup> there’s no supported way for individual types to supply their own implementation—the dynamic dispatch mechanism that enables each type to supply its own interface implementation only works for instance members.<sup><a data-type="noteref" href="ch04.xhtml#idm45884824371344" id="idm45884824371344-marker">5</a></sup></p>
<p>The limitations of C# generics are an upshot of how they are designed to work, so it’s useful to understand the mechanism. (These limitations are not specific to any particular CLR implementation, by the way. They are an inevitable result of how generics fit into the design of the .NET runtime.)</p>
<p>Generic methods and types are compiled without knowing which types will be used as arguments. This is the fundamental difference between C# generics and C++ templates—in C++, the compiler gets to see every instantiation of a template. But with C#, you can instantiate generic types without access to any of the relevant source code, long after the code has been compiled. After all, Microsoft wrote the generic <code>List&lt;T&gt;</code> class years ago, but you could write a brand-new class today and plug that in as the type argument just fine. (You might point out that the C++ standard library’s <code>std::vector</code> has been around even longer. However, the C++ compiler has access to the source file that defines the class, which is not true of C# and <code>List&lt;T&gt;</code>. C# sees only the compiled library.)</p>
<p>The upshot of this is that the C# compiler needs to have enough information to be able to generate type-safe code at the point at which it compiles generic code. Take <a data-type="xref" href="#template_technique_wont_work_in_cs">Example 4-24</a>. It cannot know what the + operator means here, because it would be different for different types. With the built-in numeric types, that code would need to compile to the specialized intermediate language (IL) instructions for performing addition. If that code were in a checked context (i.e., using the <code>checked</code> keyword shown in <a data-type="xref" href="ch02.xhtml#ch_basic_coding">Chapter 2</a>), we’d already have a problem, because the code for adding integers with overflow checking uses different IL opcodes for signed and unsigned integers. Furthermore, since this is a generic method, we may not be dealing with the built-in numeric types at all—perhaps we are dealing with a type that defines a custom <code>+</code> operator, in which case the compiler would need to generate a method call. (Custom operators are just methods under the covers.) Or if the type in question turns out not to support addition, the compiler should generate an error.</p>
<p>There are several possible outcomes for compiling a simple addition expression, depending on the actual types involved. That is fine when the types are known to the compiler, but it has to compile the code for generic types and methods without knowing which types will be used as arguments.</p>
<p>You might argue that perhaps Microsoft could have supported some sort of tentative semicompiled format for generic code, and in a sense, it did. When introducing generics, Microsoft modified the type system, file format, and IL instructions to allow generic code to use placeholders representing type parameters to be filled in when the type is fully constructed. So why not extend it to handle operators? Why not let the compiler generate errors at the point at which you compile code that attempts to use a generic type instead of insisting on generating errors when the generic code itself is compiled? Well, it turns out that you can plug in new sets of type arguments at runtime—the reflection API that we’ll look at in <a data-type="xref" href="ch13.xhtml#ch_reflection">Chapter 13</a> lets you construct generic types. There isn’t necessarily a compiler available at the point at which an error would become apparent, since not all versions of .NET ship with a copy of the C# compiler. In any case, what should happen if a generic class was written in C# but consumed by a completely different language, perhaps one that didn’t support operator overloading? Which language’s rules should apply when it comes to working out what to do with that <code>+</code> operator? Should it be the language in which the generic code was written or the language in which the type argument was written? (What if there are multiple type parameters, and for each argument, you use a type written in a different language?) Or perhaps the rules should come from the language that decided to plug the type arguments into the generic type or method, but what about cases where one piece of generic code passes its arguments through to some other generic entity? Even if you could decide which of these approaches would be best, it supposes that the rules used to determine what a line of code actually means are available at runtime, a presumption that once again founders on the fact that the relevant compilers will not necessarily be installed on the machine running the code.</p>
<p>.NET generics solve this problem by requiring the meaning of generic code to be fully defined when the generic code is compiled, using the rules of the language in which the generic code was written. If the generic code involves using methods or other members, they must be resolved statically (i.e., the identity of those members must be determined precisely at compile time). Critically, that means compile time for the generic code itself, not for the code consuming the generic code. These requirements explain why C# generics are not as flexible as the consumer-compile-time substitution model that <span class="keep-together">C++</span> uses. The payoff is that you can compile generics into libraries in binary form, and they can be used by any .NET language that supports generics, with completely predictable behavior.<a data-startref="ix_ch04-asciidoc13" data-type="indexterm" id="idm45884824360896"/><a data-startref="ix_ch04-asciidoc12" data-type="indexterm" id="idm45884824360192"/><a data-startref="ix_ch04-asciidoc11" data-type="indexterm" id="idm45884824359520"/></p>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="summary-id3">
<h1>Summary</h1>
<p>Generics enable us to write types and methods with type arguments, which can be filled in at compile time to produce different versions of the types or methods that work with particular types. One of the most important use cases for generics back when they were first introduced was to make it possible to write type-safe collection classes such as <code>List&lt;T&gt;</code>.<a data-startref="ix_ch04-asciidoc0" data-type="indexterm" id="idm45884824356608"/> We’ll look at some of these collection types in the 
<span class="keep-together">next chapter.</span></p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45884826015216"><sup><a href="ch04.xhtml#idm45884826015216-marker">1</a></sup> When saying the names of generic types, the convention is to use the word <em>of</em> as in “List of T” or “List of int.”</p><p data-type="footnote" id="idm45884825181168"><sup><a href="ch04.xhtml#idm45884825181168-marker">2</a></sup> This is permitted even if you used the plain <code>class</code> constraint in an enabled nullable annotation context. The nullable references feature does not provide watertight guarantees of non-null-ness, so it permits comparison with <code>null</code>.</p><p data-type="footnote" id="CHP-4-FN-1"><sup><a href="ch04.xhtml#CHP-4-FN-1-marker">3</a></sup> Moq relies on the <em>dynamic proxy</em> feature from the Castle Project to generate this type. If you would like to use something similar in your code, you can find this at <a href="http://castleproject.org">the Castle Project</a>.</p><p data-type="footnote" id="idm45884824373280"><sup><a href="ch04.xhtml#idm45884824373280-marker">4</a></sup> Static interface members are not available in .NET Framework.</p><p data-type="footnote" id="idm45884824371344"><sup><a href="ch04.xhtml#idm45884824371344-marker">5</a></sup> A proposal exists for adding dynamic dispatch for static interface members. Although it is not officially part of C# 10.0, the .NET 6.0 SDK includes a preview implementation. You can try it out by setting the <code>EnablePreviewFeatures</code> project property to true. If this becomes supported in a future version, perhaps we will see an <code>IAddable&lt;T&gt;</code>.</p></div></div></section></div></body></html>