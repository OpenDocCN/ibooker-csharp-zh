- en: Chapter 3\. Creating Types in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we delve into types and type members.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A class is the most common kind of reference type. The simplest possible class
    declaration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A more complex class optionally has the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Preceding the keyword `class` | *Attributes* and *class modifiers*. The non-nested
    class modifiers are `public`, `internal`, `abstract`, `sealed`, `static`, `unsafe`,
    and `partial`. |'
  prefs: []
  type: TYPE_TB
- en: '| Following `YourClassName` | *Generic type parameters* and *constraints*,
    a *base class*, and *interfaces*. |'
  prefs: []
  type: TYPE_TB
- en: '| Within the braces | *Class members* (these are *methods*, *properties*, *indexers*,
    *events*, *fields*, *constructors*, *overloaded operators*, *nested types*, and
    a *finalizer*). |'
  prefs: []
  type: TYPE_TB
- en: This chapter covers all of these constructs except attributes, operator functions,
    and the `unsafe` keyword, which are covered in [Chapter 4](ch04.html#advanced_chash).
    The following sections enumerate each of the class members.
  prefs: []
  type: TYPE_NORMAL
- en: Fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *field* is a variable that is a member of a class or struct; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Fields allow the following modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Static modifier | `static` |'
  prefs: []
  type: TYPE_TB
- en: '| Access modifiers | `public internal private protected` |'
  prefs: []
  type: TYPE_TB
- en: '| Inheritance modifier | `new` |'
  prefs: []
  type: TYPE_TB
- en: '| Unsafe code modifier | `unsafe` |'
  prefs: []
  type: TYPE_TB
- en: '| Read-only modifier | `readonly` |'
  prefs: []
  type: TYPE_TB
- en: '| Threading modifier | `volatile` |'
  prefs: []
  type: TYPE_TB
- en: 'There are two popular naming conventions for private fields: camel-cased (e.g.,
    `firstName`), and camel-cased with an underscore (`_firstName`). The latter convention
    lets you instantly distinguish private fields from parameters and local variables.'
  prefs: []
  type: TYPE_NORMAL
- en: The readonly modifier
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `readonly` modifier prevents a field from being modified after construction.
    A read-only field can be assigned only in its declaration or within the enclosing
    type’s constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Field initialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Field initialization is optional. An uninitialized field has a default value
    (`0`, `''\0''`, `null`, `false`). Field initializers run before constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A field initializer can contain expressions and call methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Declaring multiple fields together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For convenience, you can declare multiple fields of the same type in a comma-separated
    list. This is a convenient way for all the fields to share the same attributes
    and field modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *constant* is evaluated statically at compile time, and the compiler literally
    substitutes its value whenever used (rather like a macro in C++). A constant can
    be `bool`, `char`, `string`, any of the built-in numeric types, or an enum type.
  prefs: []
  type: TYPE_NORMAL
- en: 'A constant is declared with the `const` keyword and must be initialized with
    a value. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: A constant can serve a similar role to a `static readonly` field, but it is
    much more restrictive—both in the types you can use and in field initialization
    semantics. A constant also differs from a `static readonly` field in that the
    evaluation of the constant occurs at compile time; thus
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: is compiled to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'It makes sense for `PI` to be a constant because its value is predetermined
    at compile time. In contrast, a `static readonly` field’s value can potentially
    differ each time the program is run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'A `static readonly` field is also advantageous when exposing to other assemblies
    a value that might change in a later version. For instance, suppose that assembly
    `X` exposes a constant as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If assembly `Y` references `X` and uses this constant, the value `2.3` will
    be baked into assembly `Y` when compiled. This means that if `X` is later recompiled
    with the constant set to 2.4, `Y` will still use the old value of 2.3 *until*
    `Y` *is recompiled*. A `static readonly` field avoids this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Another way of looking at this is that any value that might change in the future
    is not constant by definition; thus, it should not be represented as one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Constants can also be declared local to a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Nonlocal constants allow the following modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Access modifiers | `public internal private protected` |'
  prefs: []
  type: TYPE_TB
- en: '| Inheritance modifier | `new` |'
  prefs: []
  type: TYPE_TB
- en: Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A method performs an action in a series of statements. A method can receive
    *input* data from the caller by specifying *parameters* and *output* data back
    to the caller by specifying a *return type*. A method can specify a `void` return
    type, indicating that it doesn’t return any value to its caller. A method can
    also output data back to the caller via `ref`/`out` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: A method’s *signature* must be unique within the type. A method’s signature
    comprises its name and parameter types in order (but not the parameter *names*,
    nor the return type).
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods allow the following modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Static modifier | `static` |'
  prefs: []
  type: TYPE_TB
- en: '| Access modifiers | `public internal private protected` |'
  prefs: []
  type: TYPE_TB
- en: '| Inheritance modifiers | `new virtual abstract override sealed` |'
  prefs: []
  type: TYPE_TB
- en: '| Partial method modifier | `partial` |'
  prefs: []
  type: TYPE_TB
- en: '| Unmanaged code modifiers | `unsafe extern` |'
  prefs: []
  type: TYPE_TB
- en: '| Asynchronous code modifier | `async` |'
  prefs: []
  type: TYPE_TB
- en: Expression-bodied methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A method that comprises a single expression, such as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'can be written more tersely as an *expression-bodied method*. A fat arrow replaces
    the braces and `return` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Expression-bodied functions can also have a void return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Local methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can define a method within another method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The local method (`Cube`, in this case) is visible only to the enclosing method
    (`WriteCubes`). This simplifies the containing type and instantly signals to anyone
    looking at the code that `Cube` is used nowhere else. Another benefit of local
    methods is that they can access the local variables and parameters of the enclosing
    method. This has a number of consequences, which we describe in detail in [“Capturing
    Outer Variables”](ch04.html#capturing_outer_variables).
  prefs: []
  type: TYPE_NORMAL
- en: Local methods can appear within other function kinds, such as property accessors,
    constructors, and so on. You can even put local methods inside other local methods,
    and inside lambda expressions that use a statement block ([Chapter 4](ch04.html#advanced_chash)).
    Local methods can be iterators ([Chapter 4](ch04.html#advanced_chash)) or asynchronous
    ([Chapter 14](ch14.html#concurrency_and_asynchron)).
  prefs: []
  type: TYPE_NORMAL
- en: Static local methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding the `static` modifier to a local method (from C# 8) prevents it from
    seeing the local variables and parameters of the enclosing method. This helps
    to reduce coupling and prevents the local method from accidentally referring to
    variables in the containing method.
  prefs: []
  type: TYPE_NORMAL
- en: Local methods and top-level statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Any methods that you declare in top-level statements are treated as local methods.
    This means that (unless marked as `static`) they can access the variables in the
    top-level statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Overloading methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Local methods cannot be overloaded. This means that methods declared in top-level
    statements (which are treated as local methods) cannot be overloaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'A type can *overload* methods (define multiple methods with the same name)
    as long as the signatures are different. For example, the following methods can
    all coexist in the same type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the following pairs of methods cannot coexist in the same type, because
    the return type and the `params` modifier are not part of a method’s signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Whether a parameter is pass-by-value or pass-by-reference is also part of the
    signature. For example, `Foo(int)` can coexist with either `Foo(ref int)` or `Foo(out
    int)`. However, `Foo(ref int)` and `Foo(out int)` cannot coexist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Instance Constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Constructors run initialization code on a class or struct. A constructor is
    defined like a method, except that the method name and return type are reduced
    to the name of the enclosing type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Instance constructors allow the following modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Access modifiers | `public internal private protected` |'
  prefs: []
  type: TYPE_TB
- en: '| Unmanaged code modifiers | `unsafe extern` |'
  prefs: []
  type: TYPE_TB
- en: 'Single-statement constructors can also be written as expression-bodied members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If a parameter name (or any variable name, for that matter) conflicts with
    a field name, you can disambiguate by prefixing the field with a `this` reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Overloading constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A class or struct may overload constructors. To avoid code duplication, one
    constructor can call another, using the `this` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When one constructor calls another, the *called constructor* executes first.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can pass an *expression* into another constructor, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The expression can access static members of the class but not instance members.
    (This is enforced because the object has not been initialized by the constructor
    at this stage, so any methods that you call on it are likely to fail.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This particular example could be better implemented with a single constructor
    that has `year` as an optional parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We will offer yet another solution shortly, in [“Object Initializers”](#object_initializers).
  prefs: []
  type: TYPE_NORMAL
- en: Implicit parameterless constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For classes, the C# compiler automatically generates a parameterless public
    constructor if and only if you do not define any constructors. However, as soon
    as you define at least one constructor, the parameterless constructor is no longer
    automatically generated.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor and field initialization order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We previously saw that fields can be initialized with default values in their
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Field initializations occur *before* the constructor is executed, and in the
    declaration order of the fields.
  prefs: []
  type: TYPE_NORMAL
- en: Nonpublic constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Constructors need not be public. A common reason to have a nonpublic constructor
    is to control instance creation via a static method call. The static method could
    be used to return an object from a pool rather than creating a new object, or
    to return various subclasses based on input arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Deconstructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A deconstructor (also called a *deconstructing method*) acts as an approximate
    opposite to a constructor: whereas a constructor typically takes a set of values
    (as parameters) and assigns them to fields, a deconstructor does the reverse and
    assigns fields back to a set of variables.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A deconstruction method must be called `Deconstruct` and must have one or more
    `out` parameters, such as in the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following special syntax calls the deconstructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The second line is the deconstructing call. It creates two local variables
    and then calls the `Deconstruct` method. Our deconstructing call is equivalent
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Deconstructing calls allow implicit typing, so we could shorten our call to
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Or simply this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can use C#’s discard symbol (`_`) if you’re uninterested in one or more
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This better indicates your intention than declaring a variable that you never
    use.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the variables into which you’re deconstructing are already defined, omit
    the types altogether:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This is called a *deconstructing assignment*. You can use a deconstructing
    assignment to simplify your class’s constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You can offer the caller a range of deconstruction options by overloading the
    `Deconstruct` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `Deconstruct` method can be an extension method (see [“Extension Methods”](ch04.html#extension_methods)).
    This is a useful trick if you want to deconstruct types that you did not author.
  prefs: []
  type: TYPE_NORMAL
- en: 'From C# 10, you can mix and match existing and new variables when deconstructing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Object Initializers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To simplify object initialization, any accessible fields or properties of an
    object can be set via an *object initializer* directly after construction. For
    example, consider the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Using object initializers, you can instantiate `Bunny` objects as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The code to construct `b1` and `b2` is precisely equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The temporary variables are to ensure that if an exception is thrown during
    initialization, you can’t end up with a half-initialized object.
  prefs: []
  type: TYPE_NORMAL
- en: The this Reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `this` reference refers to the instance itself. In the following example,
    the `Marry` method uses `this` to set the `partner`’s `mate` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `this` reference also disambiguates a local variable or parameter from
    a field; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `this` reference is valid only within nonstatic members of a class or struct.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Properties look like fields from the outside, but internally they contain logic,
    like methods do. For example, you can’t tell by looking at the following code
    whether `CurrentPrice` is a field or a property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'A property is declared like a field but with a `get`/`set` block added. Here’s
    how to implement `CurrentPrice` as a property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`get` and `set` denote property *accessors*. The `get` accessor runs when the
    property is read. It must return a value of the property’s type. The `set` accessor
    runs when the property is assigned. It has an implicit parameter named `value`
    of the property’s type that you typically assign to a private field (in this case,
    `currentPrice`).'
  prefs: []
  type: TYPE_NORMAL
- en: Although properties are accessed in the same way as fields, they differ in that
    they give the implementer complete control over getting and setting its value.
    This control enables the implementer to choose whatever internal representation
    is needed without exposing the internal details to the user of the property. In
    this example, the `set` method could throw an exception if `value` was outside
    a valid range of values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Throughout this book, we use public fields extensively to keep the examples
    free of distraction. In a real application, you would typically favor public properties
    over public fields in order to promote encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Properties allow the following modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Static modifier | `static` |'
  prefs: []
  type: TYPE_TB
- en: '| Access modifiers | `public internal private protected` |'
  prefs: []
  type: TYPE_TB
- en: '| Inheritance modifiers | `new virtual abstract override sealed` |'
  prefs: []
  type: TYPE_TB
- en: '| Unmanaged code modifiers | `unsafe extern` |'
  prefs: []
  type: TYPE_TB
- en: Read-only and calculated properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A property is read-only if it specifies only a `get` accessor, and it is write-only
    if it specifies only a `set` accessor. Write-only properties are rarely used.
  prefs: []
  type: TYPE_NORMAL
- en: 'A property typically has a dedicated backing field to store the underlying
    data. However, a property can also be computed from other data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Expression-bodied properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can declare a read-only property, such as the one in the preceding example,
    more tersely as an *expression-bodied property*. A fat arrow replaces all the
    braces and the `get` and `return` keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'With a little extra syntax, `set` accessors can also be expression-bodied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Automatic properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most common implementation for a property is a getter and/or setter that
    simply reads and writes to a private field of the same type as the property. An
    *automatic property* declaration instructs the compiler to provide this implementation.
    We can improve the first example in this section by declaring `CurrentPrice` as
    an automatic property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The compiler automatically generates a private backing field of a compiler-generated
    name that cannot be referred to. The `set` accessor can be marked `private` or
    `protected` if you want to expose the property as read-only to other types. Automatic
    properties were introduced in C# 3.0.
  prefs: []
  type: TYPE_NORMAL
- en: Property initializers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can add a *property initializer* to automatic properties, just as with
    fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives `CurrentPrice` an initial value of `123`. Properties with an initializer
    can be read-only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Just as with read-only fields, read-only automatic properties can also be assigned
    in the type’s constructor. This is useful in creating *immutable* (read-only)
    types.
  prefs: []
  type: TYPE_NORMAL
- en: get and set accessibility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `get` and `set` accessors can have different access levels. The typical
    use case for this is to have a `public` property with an `internal` or `private`
    access modifier on the setter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Notice that you declare the property itself with the more permissive access
    level (`public`, in this case) and add the modifier to the accessor you want to
    be *less* accessible.
  prefs: []
  type: TYPE_NORMAL
- en: Init-only setters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From C# 9, you can declare a property accessor with `init` instead of `set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'These *init-only* properties act like read-only properties, except that they
    can also be set via an object initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, the property cannot be altered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Init-only properties cannot even be set from inside their class, except via
    their property initializer, the constructor, or another init-only accessor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The alternative to init-only properties is to have read-only properties that
    you populate via a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Should the class be part of a public library, this approach makes versioning
    difficult, in that adding an optional parameter to the constructor at a later
    date breaks binary compatibility with consumers (whereas adding a new init-only
    property breaks nothing).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Init-only properties have another significant advantage, which is that they
    allow for nondestructive mutation when used in conjunction with records (see [“Records”](ch04.html#records-id00087)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as with ordinary `set` accessors, init-only accessors can provide an implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the `_pitch` field is read-only: init-only setters are permitted
    to modify `readonly` fields in their own class. (Without this feature, `_pitch`
    would need to be writable, and the class would fail at being internally immutable.)'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Changing a property’s accessor from `init` to `set` (or vice versa) is a *binary
    breaking change*: anyone that references your assembly will need to recompile
    their assembly.'
  prefs: []
  type: TYPE_NORMAL
- en: This should not be an issue when creating wholly immutable types, in that your
    type will never require properties with a (writable) `set` accessor.
  prefs: []
  type: TYPE_NORMAL
- en: CLR property implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C# property accessors internally compile to methods called `get_*XXX*` and
    `set_*XXX*`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: An `init` accessor is processed like a `set` accessor, but with an extra flag
    encoded into the `set` accessor’s “modreq” metadata (see [“Init-only properties”](ch18.html#init_only_properties)).
  prefs: []
  type: TYPE_NORMAL
- en: Simple nonvirtual property accessors are *inlined* by the Just-In-Time (JIT)
    compiler, eliminating any performance difference between accessing a property
    and a field. Inlining is an optimization in which a method call is replaced with
    the body of that method.
  prefs: []
  type: TYPE_NORMAL
- en: Indexers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Indexers provide a natural syntax for accessing elements in a class or struct
    that encapsulate a list or dictionary of values. Indexers are similar to properties
    but are accessed via an index argument rather than a property name. The `string`
    class has an indexer that lets you access each of its `char` values via an `int`
    index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The syntax for using indexers is like that for using arrays, except that the
    index argument(s) can be of any type(s).
  prefs: []
  type: TYPE_NORMAL
- en: 'Indexers have the same modifiers as properties (see [“Properties”](#properties))
    and can be called null-conditionally by inserting a question mark before the square
    bracket (see [“Null Operators”](ch02.html#null_operators)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Implementing an indexer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To write an indexer, define a property called `this`, specifying the arguments
    in square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how we could use this indexer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'A type can declare multiple indexers, each with parameters of different types.
    An indexer can also take more than one parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'If you omit the `set` accessor, an indexer becomes read-only, and you can use
    expression-bodied syntax to shorten its definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: CLR indexer implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Indexers internally compile to methods called `get_Item` and `set_Item`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Using indices and ranges with indexers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can support indices and ranges (see [“Indices and Ranges”](ch02.html#indices_and_ranges-id00073))
    in your own classes by defining an indexer with a parameter type of `Index` or
    `Range`. We could extend our previous example, by adding the following indexers
    to the `Sentence` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This then enables the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Primary Constructors (C# 12)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From C# 12, you can include a parameter list directly after a class (or struct)
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This instructs the compiler to automatically build a *primary constructor*
    using the *primary constructor parameters* (`firstName` and `lastName`), so that
    we can instantiate our class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Primary constructors are useful for prototyping and other simple scenarios.
    The alternative would be to define fields and write a constructor explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor that C# builds is called primary because any additional constructors
    that you choose to (explicitly) write must invoke it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that primary constructor parameters are *always populated*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: C# also provides *records*, which we cover in [“Records”](ch04.html#records-id00087).
    Records also support primary constructors; however, the compiler takes an extra
    step with records and generates (by default) a public init-only property for each
    primary constructor parameter. Should this behavior be desirable, consider using
    records instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Primary constructors are best suited to simple scenarios due to the following
    limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: You cannot add extra initialization code to a primary constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although it’s easy to expose a primary constructor parameter as a public property,
    you cannot easily incorporate validation logic unless the property is read-only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Primary constructors displace the default parameterless constructor that C#
    would otherwise generate.
  prefs: []
  type: TYPE_NORMAL
- en: Primary constructor semantics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To understand how primary constructors work, consider how an ordinary constructor
    behaves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: When the code inside this constructor finishes executing, parameters `firstName`
    and `lastName` disappear out of scope and cannot be subsequently accessed. In
    contrast, a primary constructor’s parameters do *not* disappear out of scope and
    can be subsequently accessed from anywhere within the class, for the life of the
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Primary constructor parameters are special C# constructs, not *fields*, although
    the compiler does end up generating hidden fields behind the scenes to store their
    values if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Primary constructors and field/property initializers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The accessibility of primary constructor parameters extends to field and property
    initializers. In the following example, we use field and property initializers
    to assign `firstName` to a public field, and `lastName` to a public property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Masking primary constructor parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Fields (or properties) can reuse primary constructor parameter names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: In this scenario, the field or property takes precedence, thereby masking the
    primary constructor parameter, *except* on the righthand side of field and property
    initializers (shown in boldface).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Just like ordinary parameters, primary constructor parameters are writable.
    Masking them with a same-named `readonly` field (as in our example) effectively
    protects them from subsequent modification.
  prefs: []
  type: TYPE_NORMAL
- en: Validating primary constructor parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes it’s useful to perform computation in field initializers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next example, we save an uppercase version of `lastName` to a field
    of the same name (masking the original value):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'In [“throw expressions”](ch04.html#throw_expressions-id00096), we describe
    how to throw exceptions when encountering scenarios such as invalid data. Here’s
    a preview to illustrate how this can be used with primary constructors to validate
    `lastName` upon construction, ensuring that it cannot be null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '(Remember that code within a field or property initializer executes when the
    object is constructed—not when the field or property is accessed.) In the next
    example, we expose a primary constructor parameter as a read/write property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding validation to this example is not straightforward in that you must validate
    in two places: in a (manually implemented) property `set` accessor and in the
    property initializer. (The same problem exists if the property is defined as init-only.)
    At this point, it’s easier to abandon the shortcut of primary constructors and
    define a constructor and backing fields explicitly.'
  prefs: []
  type: TYPE_NORMAL
- en: Static Constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A static constructor executes once per *type* rather than once per *instance*.
    A type can define only one static constructor, and it must be parameterless and
    have the same name as the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The runtime automatically invokes a static constructor just prior to the type
    being used. Two things trigger this:'
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating the type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing a static member in the type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only modifiers allowed by static constructors are `unsafe` and `extern`.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If a static constructor throws an unhandled exception ([Chapter 4](ch04.html#advanced_chash)),
    that type becomes *unusable* for the life of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'From C# 9, you can also define *module initializers*, which execute once per
    assembly (when the assembly is first loaded). To define a module initializer,
    write a static void method and then apply the `[ModuleInitializer]` attribute
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Static constructors and field initialization order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Static field initializers run just *before* the static constructor is called.
    If a type has no static constructor, static field initializers will execute just
    prior to the type being used—or *anytime earlier* at the whim of the runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Static field initializers run in the order in which the fields are declared.
    The following example illustrates this. `X` is initialized to `0`, and `Y` is
    initialized to `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'If we swap the two field initializers around, both fields are initialized to
    3\. The next example prints 0 followed by 3 because the field initializer that
    instantiates a `Foo` executes before `X` is initialized to `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: If we swap the two lines in boldface, the example prints 3 followed by 3.
  prefs: []
  type: TYPE_NORMAL
- en: Static Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A class marked `static` cannot be instantiated or subclassed, and must be composed
    solely of static members. The `System.Console` and `System.Math` classes are good
    examples of static classes.
  prefs: []
  type: TYPE_NORMAL
- en: Finalizers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finalizers are class-only methods that execute before the garbage collector
    reclaims the memory for an unreferenced object. The syntax for a finalizer is
    the name of the class prefixed with the `~` symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'This is actually C# syntax for overriding `Object`’s `Finalize` method, and
    the compiler expands it into the following method declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: We discuss garbage collection and finalizers fully in [Chapter 12](ch12.html#disposal_and_garbage_collection).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can write single-statement finalizers using expression-bodied syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Partial Types and Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Partial types allow a type definition to be split—typically across multiple
    files. A common scenario is for a partial class to be autogenerated from some
    other source (such as a Visual Studio template or designer), and for that class
    to be augmented with additional hand-authored methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Each participant must have the `partial` declaration; the following is illegal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Participants cannot have conflicting members. A constructor with the same parameters,
    for instance, cannot be repeated. Partial types are resolved entirely by the compiler,
    which means that each participant must be available at compile time and must reside
    in the same assembly.
  prefs: []
  type: TYPE_NORMAL
- en: You can specify a base class on one or more partial class declarations, as long
    as the base class, if specified, is the same. In addition, each participant can
    independently specify interfaces to implement. We cover base classes and interfaces
    in [“Inheritance”](#inheritance) and [“Interfaces”](#interfaces).
  prefs: []
  type: TYPE_NORMAL
- en: The compiler makes no guarantees with regard to field initialization order between
    partial type declarations.
  prefs: []
  type: TYPE_NORMAL
- en: Partial methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A partial type can contain *partial methods*. These let an autogenerated partial
    type provide customizable hooks for manual authoring; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'A partial method consists of two parts: a *definition* and an *implementation*.
    The definition is typically written by a code generator, and the implementation
    is typically manually authored. If an implementation is not provided, the definition
    of the partial method is compiled away (as is the code that calls it). This allows
    autogenerated code to be liberal in providing hooks without having to worry about
    bloat. Partial methods must be `void` and are implicitly `private`. They cannot
    include `out` parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: Extended partial methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Extended partial methods* (from C# 9) are designed for the reverse code generation
    scenario, where a programmer defines hooks that a code generator implements. An
    example of where this might occur is with *source generators*, a Roslyn feature
    that lets you feed the compiler an assembly that automatically generates portions
    of your code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A partial method declaration is *extended* if it begins with an accessibility
    modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The presence of the accessibility modifier doesn’t just affect accessibility:
    it tells the compiler to treat the declaration differently.'
  prefs: []
  type: TYPE_NORMAL
- en: Extended partial methods *must* have implementations; they do not melt away
    if unimplemented. In this example, both `M1` and `M2` must have implementations
    because they each specify accessibility modifiers (`public` and `private`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Because they cannot melt away, extended partial methods can return any type
    and can include `out` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The nameof operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `nameof` operator returns the name of any symbol (type, member, variable,
    and so on) as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Its advantage over simply specifying a string is that of static type checking.
    Tools such as Visual Studio can understand the symbol reference, so if you rename
    the symbol in question, all of its references will be renamed, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify the name of a type member such as a field or property, include the
    type as well. This works with both static and instance members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'This evaluates to `Length`. To return `StringBuilder.Length`, you would do
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A class can *inherit* from another class to extend or customize the original
    class. Inheriting from a class lets you reuse the functionality in that class
    instead of building it from scratch. A class can inherit from only a single class
    but can itself be inherited by many classes, thus forming a class hierarchy. In
    this example, we begin by defining a class called `Asset`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define classes called `Stock` and `House`, which will inherit from
    `Asset`. `Stock` and `House` get everything an `Asset` has, plus any additional
    members that they define:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how we can use these classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The *derived classes*, `Stock` and `House`, inherit the `Name` field from the
    *base class*, `Asset`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A derived class is also called a *subclass*.
  prefs: []
  type: TYPE_NORMAL
- en: A base class is also called a *superclass*.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'References are *polymorphic*. This means a variable of type *x* can refer to
    an object that subclasses *x*. For instance, consider the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'This method can display both a `Stock` and a `House` because they are both
    `Asset`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Polymorphism works on the basis that subclasses (`Stock` and `House`) have
    all the features of their base class (`Asset`). The converse, however, is not
    true. If `Display` was modified to accept a `House`, you could not pass in an
    `Asset`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Casting and Reference Conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An object reference can be:'
  prefs: []
  type: TYPE_NORMAL
- en: Implicitly *upcast* to a base class reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicitly *downcast* to a subclass reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Upcasting and downcasting between compatible reference types performs *reference
    conversions*: a new reference is (logically) created that points to the *same*
    object. An upcast always succeeds; a downcast succeeds only if the object is suitably
    typed.'
  prefs: []
  type: TYPE_NORMAL
- en: Upcasting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An upcast operation creates a base class reference from a subclass reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'After the upcast, variable `a` still references the same `Stock` object as
    variable `msft`. The object being referenced is not itself altered or converted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Although `a` and `msft` refer to the identical object, `a` has a more restrictive
    view on that object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: The last line generates a compile-time error because the variable `a` is of
    type `Asset`, even though it refers to an object of type `Stock`. To get to its
    `SharesOwned` field, you must *downcast* the `Asset` to a `Stock`.
  prefs: []
  type: TYPE_NORMAL
- en: Downcasting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A downcast operation creates a subclass reference from a base class reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'As with an upcast, only references are affected—not the underlying object.
    A downcast requires an explicit cast because it can potentially fail at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: If a downcast fails, an `InvalidCastException` is thrown. This is an example
    of *runtime type checking* (we elaborate on this concept in [“Static and Runtime
    Type Checking”](#static_and_runtime_type_checking)).
  prefs: []
  type: TYPE_NORMAL
- en: The as operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `as` operator performs a downcast that evaluates to `null` (rather than
    throwing an exception) if the downcast fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'This is useful when you’re going to subsequently test whether the result is
    `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Without such a test, a cast is advantageous, because if it fails, a more helpful
    exception is thrown. We can illustrate by comparing the following two lines of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: If `a` is not a `Stock`, the first line throws an `InvalidCastException`, which
    is an accurate description of what went wrong. The second line throws a `NullReferenceException`,
    which is ambiguous. Was `a` not a `Stock`, or was `a` null?
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of looking at it is that with the cast operator, you’re saying
    to the compiler: “I’m *certain* of a value’s type; if I’m wrong, there’s a bug
    in my code, so throw an exception!” Whereas with the `as` operator, you’re uncertain
    of its type and want to branch according to the outcome at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `as` operator cannot perform *custom conversions* (see [“Operator Overloading”](ch04.html#operator_overloading)),
    and it cannot do numeric conversions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `as` and cast operators will also perform upcasts, although this is not
    terribly useful because an implicit conversion will do the job.
  prefs: []
  type: TYPE_NORMAL
- en: The is operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `is` operator tests whether a variable matches a *pattern*. C# supports
    several kinds of patterns, the most important being a *type pattern*, where a
    type name follows the `is` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this context, the `is` operator tests whether a reference conversion would
    succeed—in other words, whether an object derives from a specified class (or implements
    an interface). It is often used to test before downcasting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: The `is` operator also evaluates to true if an *unboxing conversion* would succeed
    (see [“The object Type”](#the_object_type)). However, it does not consider custom
    or numeric conversions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `is` operator works with many other patterns introduced in recent versions
    of C#. For a full discussion, see [“Patterns”](ch04.html#patterns).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing a pattern variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can introduce a variable while using the `is` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'The variable that you introduce is available for “immediate” consumption, so
    the following is legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'And it remains in scope outside the `is` expression, allowing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Virtual Function Members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A function marked as `virtual` can be *overridden* by subclasses wanting to
    provide a specialized implementation. Methods, properties, indexers, and events
    can all be declared `virtual`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: (`Liability => 0` is a shortcut for `{ get { return 0; } }`. For more details
    on this syntax, see [“Expression-bodied properties”](#expression_bodied_properties).)
  prefs: []
  type: TYPE_NORMAL
- en: 'A subclass overrides a virtual method by applying the `override` modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the `Liability` of an `Asset` is `0`. A `Stock` does not need to
    specialize this behavior. However, the `House` specializes the `Liability` property
    to return the value of the `Mortgage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: The signatures, return types, and accessibility of the virtual and overridden
    methods must be identical. An overridden method can call its base class implementation
    via the `base` keyword (we cover this in [“The base Keyword”](#the_base_keyword)).
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Calling virtual methods from a constructor is potentially dangerous because
    authors of subclasses are unlikely to know, when overriding the method, that they
    are working with a partially initialized object. In other words, the overriding
    method might end up accessing methods or properties that rely on fields not yet
    initialized by the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Covariant return types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From C# 9, you can override a method (or property `get` accessor) such that
    it returns a *more derived* (subclassed) type. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'This is permitted because it does not break the contract that `Clone` must
    return an `Asset`: it returns a `House`, which *is* an `Asset` (and more).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prior to C# 9, you had to override methods with the identical return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'This still does the job, because the overridden `Clone` method instantiates
    a `House` rather than an `Asset`. However, to treat the returned object as a `House`,
    you must then perform a downcast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Abstract Classes and Abstract Members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A class declared as *abstract* can never be instantiated. Instead, only its
    concrete *subclasses* can be instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Abstract classes are able to define *abstract members*. Abstract members are
    like virtual members except that they don’t provide a default implementation.
    That implementation must be provided by the subclass unless that subclass is also
    declared abstract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Hiding Inherited Members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A base class and a subclass can define identical members. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Counter` field in class `B` is said to *hide* the `Counter` field in class
    `A`. Usually, this happens by accident, when a member is added to the base type
    *after* an identical member was added to the subtype. For this reason, the compiler
    generates a warning and then resolves the ambiguity as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: References to `A` (at compile time) bind to `A.Counter`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: References to `B` (at compile time) bind to `B.Counter`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Occasionally, you want to hide a member deliberately, in which case you can
    apply the `new` modifier to the member in the subclass. The `new` modifier *does
    nothing more than suppress the compiler warning that would otherwise result*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: The `new` modifier communicates your intent to the compiler—and other programmers—that
    the duplicate member is not an accident.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: C# overloads the `new` keyword to have independent meanings in different contexts.
    Specifically, the `new` *operator* is different from the `new` *member modifier*.
  prefs: []
  type: TYPE_NORMAL
- en: new versus override
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following class hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'The differences in behavior between `Overrider` and `Hider` are demonstrated
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Sealing Functions and Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An overridden function member can *seal* its implementation with the `sealed`
    keyword to prevent it from being overridden by further subclasses. In our earlier
    virtual function member example, we could have sealed `House`’s implementation
    of `Liability`, preventing a class that derives from `House` from overriding `Liability`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: You can also apply the `sealed` modifier to the class itself, to prevent subclassing.
    Sealing a class is more common than sealing a function member.
  prefs: []
  type: TYPE_NORMAL
- en: Although you can seal a function member against overriding, you can’t seal a
    member against being *hidden*.
  prefs: []
  type: TYPE_NORMAL
- en: The base Keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `base` keyword is similar to the `this` keyword. It serves two essential
    purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing an overridden function member from the subclass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling a base-class constructor (see the next section)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this example, `House` uses the `base` keyword to access `Asset`’s implementation
    of `Liability`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: With the `base` keyword, we access `Asset`’s `Liability` property *nonvirtually*.
    This means that we will always access `Asset`’s version of this property—regardless
    of the instance’s actual runtime type.
  prefs: []
  type: TYPE_NORMAL
- en: The same approach works if `Liability` is *hidden* rather than *overridden*.
    (You can also access hidden members by casting to the base class before invoking
    the function.)
  prefs: []
  type: TYPE_NORMAL
- en: Constructors and Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A subclass must declare its own constructors. The base class’s constructors
    are *accessible* to the derived class but are never automatically *inherited*.
    For example, if we define `Baseclass` and `Subclass` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'the following is illegal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '`Subclass` must hence “redefine” any constructors it wants to expose. In doing
    so, however, it can call any of the base class’s constructors via the `base` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: The `base` keyword works rather like the `this` keyword except that it calls
    a constructor in the base class.
  prefs: []
  type: TYPE_NORMAL
- en: Base-class constructors always execute first; this ensures that *base* initialization
    occurs before *specialized* initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit calling of the parameterless base-class constructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If a constructor in a subclass omits the `base` keyword, the base type’s *parameterless*
    constructor is implicitly called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'If the base class has no accessible parameterless constructor, subclasses are
    forced to use the `base` keyword in their constructors. This means that a base
    class with (only) a multiparameter constructor burdens subclasses with the obligation
    to call it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Required members (C# 11)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The requirement for subclasses to invoke a constructor in the base class can
    become burdensome in large class hierarchies if there are many constructors with
    many parameters. Sometimes, the best solution is to avoid constructors altogether
    and rely solely on object initializers to set fields or properties during construction.
    To help with this, you can mark a field or property as `required` (from C# 11):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'A required member *must* be populated via an object initializer when constructed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Should you wish to also write a constructor, you can apply the `[SetsRequired​Mem⁠bers]`
    attribute to bypass the required member restriction for that constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Consumers can now benefit from the convenience of that constructor without
    any trade-off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we also defined a parameterless constructor (for use with the object
    initializer). Its presence also ensures that subclasses remain under no burden
    to reproduce any constructor. In the following example, the `House` class chooses
    not to implement a convenience constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Constructor and field initialization order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When an object is instantiated, initialization takes place in the following
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From subclass to base class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fields are initialized.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Arguments to base-class constructor calls are evaluated.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From base class to subclass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Constructor bodies execute.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Inheritance with primary constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Classes with primary constructors can subclass with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to `Baseclass(x)` is equivalent to calling `base(x)` in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Overloading and Resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inheritance has an interesting impact on method overloading. Consider the following
    two overloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'When an overload is called, the most specific type has precedence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'The particular overload to call is determined statically (at compile time)
    rather than at runtime. The following code calls `Foo(Asset)`, even though the
    runtime type of `a` is `House`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you cast `Asset` to `dynamic` ([Chapter 4](ch04.html#advanced_chash)), the
    decision as to which overload to call is deferred until runtime and is then based
    on the object’s actual type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: The object Type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`object` (`System.Object`) is the ultimate base class for all types. Any type
    can be upcast to `object`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate how this is useful, consider a general-purpose *stack*. A stack
    is a data structure based on the principle of *LIFO*—“last in, first out.” A stack
    has two operations: *push* an object on the stack and *pop* an object off the
    stack. Here is a simple implementation that can hold up to 10 objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `Stack` works with the object type, we can `Push` and `Pop` instances
    of *any type* to and from the `Stack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '`object` is a reference type, by virtue of being a class. Despite this, value
    types, such as `int`, can also be cast to and from `object`, and so be added to
    our stack. This feature of C# is called *type unification* and is demonstrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: When you cast between a value type and `object`, the CLR must perform some special
    work to bridge the difference in semantics between value and reference types.
    This process is called *boxing* and *unboxing*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In [“Generics”](#generics), we describe how to improve our `Stack` class to
    better handle stacks with same-typed elements.
  prefs: []
  type: TYPE_NORMAL
- en: Boxing and Unboxing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Boxing is the act of converting a value-type instance to a reference-type instance.
    The reference type can be either the `object` class or an interface (which we
    visit later in the chapter).^([1](ch03.html#ch01fn5)) In this example, we box
    an `int` into an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Unboxing reverses the operation by casting the object back to the original
    value type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Unboxing requires an explicit cast. The runtime checks that the stated value
    type matches the actual object type, and throws an `InvalidCastException` if the
    check fails. For instance, the following throws an exception because `long` does
    not exactly match `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'The following succeeds, however:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'As does this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: In the last example, `(double)` performs an *unboxing* and then `(int)` performs
    a *numeric conversion*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Boxing conversions are crucial in providing a unified type system. The system
    is not perfect, however: we’ll see in [“Generics”](#generics) that variance with
    arrays and generics supports only *reference conversions* and not *boxing conversions*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Copying semantics of boxing and unboxing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Boxing *copies* the value-type instance into the new object, and unboxing *copies*
    the contents of the object back into a value-type instance. In the following example,
    changing the value of `i` doesn’t change its previously boxed copy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Static and Runtime Type Checking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C# programs are type-checked both statically (at compile time) and at runtime
    (by the CLR).
  prefs: []
  type: TYPE_NORMAL
- en: 'Static type checking enables the compiler to verify the correctness of your
    program without running it. The following code will fail because the compiler
    enforces static typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'Runtime type checking is performed by the CLR when you downcast via a reference
    conversion or unboxing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Runtime type checking is possible because each object on the heap internally
    stores a little type token. You can retrieve this token by calling the `GetType`
    method of `object`.
  prefs: []
  type: TYPE_NORMAL
- en: The GetType Method and typeof Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All types in C# are represented at runtime with an instance of `System.Type`.
    There are two basic ways to get a `System.Type` object:'
  prefs: []
  type: TYPE_NORMAL
- en: Call `GetType` on the instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `typeof` operator on a type name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetType` is evaluated at runtime; `typeof` is evaluated statically at compile
    time (when generic type parameters are involved, it’s resolved by the JIT compiler).'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.Type` has properties for such things as the type’s name, assembly,
    base type, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '`System.Type` also has methods that act as a gateway to the runtime’s reflection
    model, described in [Chapter 18](ch18.html#reflection_and_metadata).'
  prefs: []
  type: TYPE_NORMAL
- en: The ToString Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ToString` method returns the default textual representation of a type
    instance. This method is overridden by all built-in types. Here is an example
    of using the `int` type’s `ToString` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'You can override the `ToString` method on custom types as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t override `ToString`, the method returns the type name.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'When you call an *overridden* `object` member such as `ToString` directly on
    a value type, boxing doesn’t occur. Boxing then occurs only if you cast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: Object Member Listing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are all the members of `object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: We describe the `Equals`, `ReferenceEquals`, and `GetHashCode` methods in [“Equality
    Comparison”](ch06.html#equality_comparison-id00067).
  prefs: []
  type: TYPE_NORMAL
- en: Structs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A *struct* is similar to a class, with the following key differences:'
  prefs: []
  type: TYPE_NORMAL
- en: A struct is a value type, whereas a class is a reference type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A struct does not support inheritance (other than implicitly deriving from `object`,
    or more precisely, `System.ValueType`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A struct can have all of the members that a class can, except for a finalizer.
    And because it cannot be subclassed, members cannot be marked as virtual, abstract,
    or protected.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Prior to C# 10, structs were further prohibited from defining fields initializers
    and parameterless constructors. Although this prohibition has now been relaxed—primarily
    for the benefit of record structs (see [“Records”](ch04.html#records-id00087))—it’s
    worth thinking carefully before defining these constructs, as they can result
    in confusing behavior that we’ll describe in [“Struct Construction Semantics”](#struct_construction_semantics).
  prefs: []
  type: TYPE_NORMAL
- en: A struct is appropriate when value-type semantics are desirable. Good examples
    of structs are numeric types, where it is more natural for assignment to copy
    a value rather than a reference. Because a struct is a value type, each instance
    does not require instantiation of an object on the heap; this results in useful
    savings when creating many instances of a type. For instance, creating an array
    of value type elements requires only a single heap allocation.
  prefs: []
  type: TYPE_NORMAL
- en: Because structs are value types, an instance cannot be null. The default value
    for a struct is an empty instance, with all fields empty (set to their default
    values).
  prefs: []
  type: TYPE_NORMAL
- en: Struct Construction Semantics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Prior to C# 11, every field in a struct had to be explicitly assigned in the
    constructor (or field initializer). This restriction has now been relaxed.
  prefs: []
  type: TYPE_NORMAL
- en: The default constructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In addition to any constructors that you define, a struct always has an implicit
    parameterless constructor that performs a bitwise-zeroing of its fields (setting
    them to their default values):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'Even when you define a parameterless constructor of your own, the implicit
    parameterless constructor still exists and can be accessed via the `default` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we initialized `x` to 1 via a field initializer, and we initialized
    `y` to 1 via the parameterless constructor. And yet with the `default` keyword,
    we were still able to create a `Point` that bypassed both initializations. The
    default constructor can be accessed other ways, too, as the following example
    illustrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Having what amounts to two parameterless constructors can be a source of confusion,
    and is arguably a good reason to avoid defining field initializers and explicit
    parameterless constructors in structs.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good strategy with structs is to design them such that their `default` value
    is a valid state, thereby making initialization redundant. For example, rather
    than initializing a property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: Read-Only Structs and Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can apply the `readonly` modifier to a struct to enforce that all fields
    are `readonly`; this aids in declaring intent as well as affording the compiler
    more optimization freedom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to apply `readonly` at a more granular level, you can apply the
    `readonly` modifier (from C# 8) to a struct’s *functions*. This ensures that if
    the function attempts to modify any field, a compile-time error is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: If a `readonly` function calls a non-`readonly` function, the compiler generates
    a warning (and defensively copies the struct to avoid the possibility of a mutation).
  prefs: []
  type: TYPE_NORMAL
- en: Ref Structs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Ref structs were introduced in C# 7.2 as a niche feature primarily for the benefit
    of the `Span<T>` and `ReadOnlySpan<T>` structs that we describe in [Chapter 23](ch23.html#spanless_thantgreater_than_and-id00089)
    (and the highly optimized `Utf8JsonReader` that we describe in [Chapter 11](ch11.html#other_xml_and_json_technologies)).
    These structs help with a micro-optimization technique that aims to reduce memory
    allocations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike reference types, whose instances always live on the heap, value types
    live *in-place* (wherever the variable was declared). If a value type appears
    as a parameter or local variable, it will reside on the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'But if a value type appears as a field in a class, it will reside on the heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, arrays of structs live on the heap, and boxing a struct sends it
    to the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding the `ref` modifier to a struct’s declaration ensures that it can only
    ever reside on the stack. Attempting to use a *ref struct* in such a way that
    it could reside on the heap generates a compile-time error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: Ref structs were introduced mainly for the benefit of the `Span<T>` and `ReadOnlySpan<T>`
    structs. Because `Span<T>` and `ReadOnlySpan<T>` instances can exist only on the
    stack, it’s possible for them to safely wrap stack-allocated memory.
  prefs: []
  type: TYPE_NORMAL
- en: Ref structs cannot partake in any C# feature that directly or indirectly introduces
    the possibility of existing on the heap. This includes a number of advanced C#
    features that we describe in [Chapter 4](ch04.html#advanced_chash), namely, lambda
    expressions, iterators, and asynchronous functions (because, behind the scenes,
    these features all create hidden classes with fields). Also, ref structs cannot
    appear inside non-ref structs, and they cannot implement interfaces (because this
    could result in boxing).
  prefs: []
  type: TYPE_NORMAL
- en: Access Modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To promote encapsulation, a type or type member can limit its *accessibility*
    to other types and other assemblies by adding an *access modifier* to the declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public`'
  prefs: []
  type: TYPE_NORMAL
- en: Fully accessible. This is the implicit accessibility for members of an enum
    or interface.
  prefs: []
  type: TYPE_NORMAL
- en: '`internal`'
  prefs: []
  type: TYPE_NORMAL
- en: Accessible only within the containing assembly or friend assemblies. This is
    the default accessibility for non-nested types.
  prefs: []
  type: TYPE_NORMAL
- en: '`private`'
  prefs: []
  type: TYPE_NORMAL
- en: Accessible only within the containing type. This is the default accessibility
    for members of a class or struct.
  prefs: []
  type: TYPE_NORMAL
- en: '`protected`'
  prefs: []
  type: TYPE_NORMAL
- en: Accessible only within the containing type or subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: '`protected internal`'
  prefs: []
  type: TYPE_NORMAL
- en: The *union* of `protected` and `internal` accessibility. A member that is `protected
    internal` is accessible in two ways.
  prefs: []
  type: TYPE_NORMAL
- en: '`private protected`'
  prefs: []
  type: TYPE_NORMAL
- en: The *intersection* of `protected` and `internal` accessibility. A member that
    is `private protected` is accessible only within the containing type, or from
    subclasses *that reside in the same assembly* (making it *less* accessible than
    `protected` or `internal` alone).
  prefs: []
  type: TYPE_NORMAL
- en: '`file` (from C# 11)'
  prefs: []
  type: TYPE_NORMAL
- en: Accessible only from within the same file. Intended for use by *source generators*
    (see [“Extended partial methods”](#extended_partial_methods)). This modifier can
    be applied only to type declarations.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Class2` is accessible from outside its assembly; `Class1` is not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '`ClassB` exposes field `x` to other types in the same assembly; `ClassA` does
    not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions within `Subclass` can call `Bar` but not `Foo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Friend Assemblies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can expose `internal` members to other *friend* assemblies by adding the
    `System.Runtime.CompilerServices.InternalsVisibleTo` assembly attribute, specifying
    the name of the friend assembly as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'If the friend assembly has a strong name (see [Chapter 17](ch17.html#assemblies)),
    you must specify its *full* 160-byte public key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'You can extract the full public key from a strongly named assembly with a LINQ
    query (we explain LINQ in detail in [Chapter 8](ch08.html#linq_queries)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The companion sample in LINQPad invites you to browse to an assembly and then
    copies the assembly’s full public key to the clipboard.
  prefs: []
  type: TYPE_NORMAL
- en: Accessibility Capping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A type caps the accessibility of its declared members. The most common example
    of capping is when you have an `internal` type with `public` members. For example,
    consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '`C`’s (default) `internal` accessibility caps `Foo`’s accessibility, effectively
    making `Foo internal`. A common reason `Foo` would be marked `public` is to make
    for easier refactoring should `C` later be changed to `public`.'
  prefs: []
  type: TYPE_NORMAL
- en: Restrictions on Access Modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When overriding a base class function, accessibility must be identical on the
    overridden function; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: (An exception is when overriding a `protected internal` method in another assembly,
    in which case the override must simply be `protected`.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler prevents any inconsistent use of access modifiers. For example,
    a subclass itself can be less accessible than a base class but not more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An interface is similar to a class, but only *specifies behavior* and does
    not hold state (data). Consequently:'
  prefs: []
  type: TYPE_NORMAL
- en: An interface can define only functions and not fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface members are *implicitly abstract*. (There are exceptions to this rule
    that we will describe in [“Default Interface Members”](#default_interface_members-id00061)
    and [“Static Interface Members”](#static_interface_members).)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class (or struct) can implement multiple interfaces. In contrast, a class
    can inherit from only a single class, and a struct cannot inherit at all (aside
    from deriving from `System.ValueType`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interface declaration is like a class declaration, but it (normally) provides
    no implementation for its members because its members are implicitly abstract.
    These members will be implemented by the classes and structs that implement the
    interface. An interface can contain only functions, that is, methods, properties,
    events, and indexers (which noncoincidentally are precisely the members of a class
    that can be abstract).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the definition of the `IEnumerator` interface, defined in `System.Collections`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'Interface members are always implicitly public and cannot declare an access
    modifier. Implementing an interface means providing a `public` implementation
    for all of its members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'You can implicitly cast an object to any interface that it implements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Even though `Countdown` is an internal class, its members that implement `IEnumerator`
    can be called publicly by casting an instance of `Countdown` to `IEnumerator`.
    For instance, if a public type in the same assembly defined a method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'a caller from another assembly could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: If `IEnumerator` were itself defined as `internal`, this wouldn’t be possible.
  prefs: []
  type: TYPE_NORMAL
- en: Extending an Interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Interfaces can derive from other interfaces; for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '`IRedoable` “inherits” all the members of `IUndoable`. In other words, types
    that implement `IRedoable` must also implement the members of `IUndoable`.'
  prefs: []
  type: TYPE_NORMAL
- en: Explicit Interface Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implementing multiple interfaces can sometimes result in a collision between
    member signatures. You can resolve such collisions by *explicitly implementing*
    an interface member. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `I1` and `I2` have conflicting `Foo` signatures, `Widget` explicitly
    implements `I2`’s `Foo` method. This lets the two methods coexist in one class.
    The only way to call an explicitly implemented member is to cast to its interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: Another reason to explicitly implement interface members is to hide members
    that are highly specialized and distracting to a type’s normal use case. For example,
    a type that implements `ISerializable` would typically want to avoid flaunting
    its `ISerializable` members unless explicitly cast to that interface.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Interface Members Virtually
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An implicitly implemented interface member is, by default, sealed. It must
    be marked `virtual` or `abstract` in the base class in order to be overridden:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling the interface member through either the base class or the interface
    calls the subclass’s implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: An explicitly implemented interface member cannot be marked `virtual`, nor can
    it be overridden in the usual manner. It can, however, be *reimplemented*.
  prefs: []
  type: TYPE_NORMAL
- en: Reimplementing an Interface in a Subclass
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A subclass can reimplement any interface member already implemented by a base
    class. Reimplementation hijacks a member implementation (when called through the
    interface) and works whether or not the member is `virtual` in the base class.
    It also works whether a member is implemented implicitly or explicitly—although
    it works best in the latter case, as we will demonstrate.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, `TextBox` implements `IUndoable.Undo` explicitly,
    and so it cannot be marked as `virtual`. To “override” it, `RichTextBox` must
    reimplement `IUndoable`’s `Undo` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling the reimplemented member through the interface calls the subclass’s
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming the same `RichTextBox` definition, suppose that `TextBox` implemented
    `Undo` *implicitly*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'This would give us another way to call `Undo`, which would “break” the system,
    as shown in Case 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: Case 3 demonstrates that reimplementation hijacking is effective only when a
    member is called through the interface and not through the base class. This is
    usually undesirable in that it can create inconsistent semantics. This makes reimplementation
    most appropriate as a strategy for overriding *explicitly* implemented interface
    members.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives to interface reimplementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Even with explicit member implementation, interface reimplementation is problematic
    for a couple of reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The subclass has no way to call the base class method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The base class author might not anticipate that a method will be reimplemented
    and might not allow for the potential consequences.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reimplementation can be a good last resort when subclassing hasn’t been anticipated.
    A better option, however, is to design a base class such that reimplementation
    will never be required. There are two ways to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: When implicitly implementing a member, mark it `virtual` if appropriate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When explicitly implementing a member, use the following pattern if you anticipate
    that subclasses might need to override any logic:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t anticipate any subclassing, you can mark the class as `sealed`
    to preempt interface reimplementation.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces and Boxing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Converting a struct to an interface causes boxing. Calling an implicitly implemented
    member on a struct does not cause boxing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: Default Interface Members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From C# 8, you can add a default implementation to an interface member, making
    it optional to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: This is advantageous if you want to add a member to an interface defined in
    a popular library without breaking (potentially thousands of) implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Default implementations are always explicit, so if a class implementing `ILogger`
    fails to define a `Log` method, the only way to call it is through the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'This prevents a problem of multiple implementation inheritance: if the same
    default member is added to two interfaces that a class implements, there is never
    an ambiguity as to which member is called.'
  prefs: []
  type: TYPE_NORMAL
- en: Static Interface Members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An interface can also declare static members. There are two kinds of static
    interface members:'
  prefs: []
  type: TYPE_NORMAL
- en: Static nonvirtual interface members
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static virtual/abstract interface members
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In contrast to *instance* members, static members on interfaces are nonvirtual
    by default. To make a static interface member virtual, you must mark it with `static
    abstract` or `static virtual`.
  prefs: []
  type: TYPE_NORMAL
- en: Static nonvirtual interface members
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Static nonvirtual interface members exist mainly to help with writing default
    interface members. They are not implemented by classes or structs; instead, they
    are consumed directly. Along with methods, properties, events, and indexers, static
    nonvirtual members permit fields, which are typically accessed from code inside
    default member implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: 'Static nonvirtual interface members are public by default, so they can be accessed
    from the outside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: You can restrict this by adding an accessibility modifier (such as `private`,
    `protected`, or `internal`).
  prefs: []
  type: TYPE_NORMAL
- en: Instance fields are (still) prohibited. This is in line with the principle of
    interfaces, which is to define *behavior*, not *state*.
  prefs: []
  type: TYPE_NORMAL
- en: Static virtual/abstract interface members
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Static virtual/abstract interface members (from C# 11) enable *static polymorphism*,
    an advanced feature that we will discuss in [Chapter 4](ch04.html#advanced_chash).
    Static virtual interface members are marked with `static abstract` or `static
    virtual`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'An implementing class or struct must implement static abstract members, and
    can optionally implement static virtual members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: In addition to methods, properties, and events, operators and conversions are
    also legal targets for static virtual interface members (see [“Operator Overloading”](ch04.html#operator_overloading)).
    Static virtual interface members are called through a constrained type parameter;
    we will demonstrate this in [“Static Polymorphism”](ch04.html#static_polymorphism)
    and [“Generic Math”](ch04.html#generic_math-id00069), after covering generics
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An enum is a special value type that lets you specify a group of named numeric
    constants. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this enum type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: 'Each enum member has an underlying integral value. These are by default:'
  prefs: []
  type: TYPE_NORMAL
- en: Underlying values are of type `int`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constants `0`, `1`, `2`... are automatically assigned, in the declaration
    order of the enum members.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can specify an alternative integral type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specify an explicit underlying value for each enum member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The compiler also lets you explicitly assign *some* of the enum members. The
    unassigned enum members keep incrementing from the last explicit value. The preceding
    example is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: Enum Conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can convert an `enum` instance to and from its underlying integral value
    with an explicit cast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also explicitly cast one enum type to another. Suppose that `Horizontal​A⁠lignment`
    is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: 'A translation between the enum types uses the underlying integral values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'The numeric literal `0` is treated specially by the compiler in an `enum` expression
    and does not require an explicit cast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two reasons for the special treatment of `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: The first member of an enum is often used as the “default” value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For *combined enum* types, `0` means “no flags.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flags Enums
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can combine enum members. To prevent ambiguities, members of a combinable
    enum require explicitly assigned values, typically in powers of two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: 'or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: 'To work with combined enum values, you use bitwise operators such as `|` and
    `&`. These operate on the underlying integral values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: By convention, the `Flags` attribute should always be applied to an enum type
    when its members are combinable. If you declare such an `enum` without the `Flags`
    attribute, you can still combine members, but calling `ToString` on an `enum`
    instance will emit a number rather than a series of names.
  prefs: []
  type: TYPE_NORMAL
- en: By convention, a combinable enum type is given a plural rather than singular
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'For convenience, you can include combination members within an enum declaration
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: Enum Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The operators that work with enums are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: The bitwise, arithmetic, and comparison operators return the result of processing
    the underlying integral values. Addition is permitted between an enum and an integral
    type, but not between two enums.
  prefs: []
  type: TYPE_NORMAL
- en: Type-Safety Issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: 'Because an enum can be cast to and from its underlying integral type, the actual
    value it can have might fall outside the bounds of a legal enum member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: 'The bitwise and arithmetic operators can produce similarly invalid values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'An invalid `BorderSide` would break the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: 'One solution is to add another `else` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: 'Another workaround is to explicitly check an enum value for validity. The static
    `Enum.IsDefined` method does this job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, `Enum.IsDefined` does not work for flagged enums. However, the
    following helper method (a trick dependent on the behavior of `Enum.ToString()`)
    returns `true` if a given flagged enum is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: Nested Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A *nested type* is declared within the scope of another type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'A nested type has the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: It can access the enclosing type’s private members and everything else the enclosing
    type can access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can declare it with the full range of access modifiers rather than just
    `public` and `internal`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default accessibility for a nested type is `private` rather than `internal`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing a nested type from outside the enclosing type requires qualification
    with the enclosing type’s name (like when accessing static members).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, to access `Color.Red` from outside our `TopLevel` class, we’d
    need to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: All types (classes, structs, interfaces, delegates, and enums) can be nested
    within either a class or a struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of accessing a private member of a type from a nested type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of applying the `protected` access modifier to a nested
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of referring to a nested type from outside the enclosing
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: Nested types are used heavily by the compiler itself when it generates private
    classes that capture state for constructs such as iterators and anonymous methods.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If the sole reason for using a nested type is to avoid cluttering a namespace
    with too many types, consider using a nested namespace, instead. A nested type
    should be used because of its stronger access control restrictions, or when the
    nested class must access private members of the containing class.
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C# has two separate mechanisms for writing code that is reusable across different
    types: *inheritance* and *generics*. Whereas inheritance expresses reusability
    with a base type, generics express reusability with a “template” that contains
    “placeholder” types. Generics, when compared to inheritance, can *increase type
    safety* and *reduce casting and boxing*.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: C# generics and C++ templates are similar concepts, but they work differently.
    We explain this difference in [“C# Generics Versus C++ Templates”](#chash_generics_versus_cplusplus_templat).
  prefs: []
  type: TYPE_NORMAL
- en: Generic Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A generic type declares *type parameters*—placeholder types to be filled in
    by the consumer of the generic type, which supplies the *type arguments*. Here
    is a generic type `Stack<T>`, designed to stack instances of type `T`. `Stack<T>`
    declares a single type parameter `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use `Stack<T>` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '`Stack<int>` fills in the type parameter `T` with the type argument `int`,
    implicitly creating a type on the fly (the synthesis occurs at runtime). Attempting
    to push a string onto our `Stack<int>` would, however, produce a compile-time
    error. `Stack<int>` effectively has the following definition (substitutions appear
    in bold, with the class name hashed out to avoid confusion):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: 'Technically, we say that `Stack<T>` is an *open type*, whereas `Stack<int>`
    is a *closed type*. At runtime, all generic type instances are closed—with the
    placeholder types filled in. This means that the following statement is illegal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it’s legal if it’s within a class or method that itself defines `T`
    as a type parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: Why Generics Exist
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Generics exist to write code that is reusable across different types. Suppose
    that we need a stack of integers but we don’t have generic types. One solution
    would be to hardcode a separate version of the class for every required element
    type (e.g., `IntStack`, `StringStack`, etc.). Clearly, this would cause considerable
    code duplication. Another solution would be to write a stack that is generalized
    by using `object` as the element type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: 'An `ObjectStack`, however, wouldn’t work as well as a hardcoded `IntStack`
    for specifically stacking integers. An `ObjectStack` would require boxing and
    downcasting that could not be checked at compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: What we need is both a general implementation of a stack that works for all
    element types as well as a way to easily specialize that stack to a specific element
    type for increased type safety and reduced casting and boxing. Generics give us
    precisely this by allowing us to parameterize the element type. `Stack<T>` has
    the benefits of both `ObjectStack` and `IntStack`. Like `ObjectStack`, `Stack<T>`
    is written once to work *generally* across all types. Like `IntStack`, `Stack<T>`
    is *specialized* for a particular type—the beauty is that this type is `T`, which
    we substitute on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`ObjectStack` is functionally equivalent to `Stack<object>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Generic Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A generic method declares type parameters within the signature of a method.
  prefs: []
  type: TYPE_NORMAL
- en: 'With generic methods, many fundamental algorithms can be implemented in a general-purpose
    way. Here is a generic method that swaps the contents of two variables of any
    type `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '`Swap<T>` is called as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: 'Generally, there is no need to supply type arguments to a generic method, because
    the compiler can implicitly infer the type. If there is ambiguity, generic methods
    can be called with type arguments as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: Within a generic *type*, a method is not classed as generic unless it *introduces*
    type parameters (with the angle bracket syntax). The `Pop` method in our generic
    stack merely uses the type’s existing type parameter, `T`, and is not classed
    as a generic method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods and types are the only constructs that can introduce type parameters.
    Properties, indexers, events, fields, constructors, operators, and so on cannot
    declare type parameters, although they can partake in any type parameters already
    declared by their enclosing type. In our generic stack example, for instance,
    we could write an indexer that returns a generic item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, constructors can partake in existing type parameters but not *introduce*
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: Declaring Type Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Type parameters can be introduced in the declaration of classes, structs, interfaces,
    delegates (covered in [Chapter 4](ch04.html#advanced_chash)), and methods. Other
    constructs, such as properties, cannot *introduce* a type parameter, but they
    can *use* one. For example, the property `Value` uses `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: 'A generic type or method can have multiple parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: 'To instantiate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: 'Generic type names and method names can be overloaded as long as the number
    of type parameters is different. For example, the following three type names do
    not conflict:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: By convention, generic types and methods with a *single* type parameter typically
    name their parameter `T`, as long as the intent of the parameter is clear. When
    using *multiple* type parameters, each parameter is prefixed with `T` but has
    a more descriptive name.
  prefs: []
  type: TYPE_NORMAL
- en: typeof and Unbound Generic Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open generic types do not exist at runtime: they are closed as part of compilation.
    However, it is possible for an *unbound* generic type to exist at runtime—purely
    as a `Type` object. The only way to specify an unbound generic type in C# is via
    the `typeof` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: Open generic types are used in conjunction with the Reflection API ([Chapter 18](ch18.html#reflection_and_metadata)).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the `typeof` operator to specify a closed type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you can specify an open type (which is closed at runtime):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: The default Generic Value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use the `default` keyword to get the default value for a generic type
    parameter. The default value for a reference type is `null`, and the default value
    for a value type is the result of bitwise-zeroing the value type’s fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: 'From C# 7.1, you can omit the type argument for cases in which the compiler
    is able to infer it. We could replace the last line of code with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: Generic Constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, you can substitute a type parameter with any type whatsoever. *Constraints*
    can be applied to a type parameter to require more specific type arguments. These
    are the possible constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, `GenericClass<T,U>` requires `T` to derive from (or
    be identical to) `SomeClass` and implement `Interface1`, and requires `U` to provide
    a parameterless constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: You can apply constraints wherever type parameters are defined, in both methods
    and type definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A *constraint* is a *restriction*; however, the main purpose of type parameter
    constraints is to enable things that would otherwise be prohibited.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, the constraint `T:Foo` lets you treat instances of `T` as `Foo`,
    and the constraint `T:new()` lets you construct new instances of `T`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *base-class constraint* specifies that the type parameter must subclass (or
    match) a particular class; an *interface constraint* specifies that the type parameter
    must implement that interface. These constraints allow instances of the type parameter
    to be implicitly converted to that class or interface. For example, suppose that
    we want to write a generic `Max` method, which returns the maximum of two values.
    We can take advantage of the generic interface defined in the `System` namespace
    called `IComparable<T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '`CompareTo` returns a positive number if `this` is greater than `other`. Using
    this interface as a constraint, we can write a `Max` method as follows (to avoid
    distraction, null checking is omitted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Max` method can accept arguments of any type implementing `IComparable<T>`
    (which includes most built-in types such as `int` and `string`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: From C# 11, an interface constraint also lets you call static virtual/abstract
    members on that interface (see [“Static virtual/abstract interface members”](ch01.html#static_virtualsolidusabstract-id00040)).
    For example, if interface `IFoo` defines a static abstract method called `Bar`,
    the `T:IFoo` constraint makes it legal to call `T.Bar()`. We pick up this topic
    again in [“Static Polymorphism”](ch04.html#static_polymorphism).
  prefs: []
  type: TYPE_NORMAL
- en: 'The *class constraint* and *struct constraint* specify that `T` must be a reference
    type or (non-nullable) value type. A great example of the struct constraint is
    the `System.Nullable<T>` struct (we discuss this class in depth in [“Nullable
    Value Types”](ch04.html#nullable_value_types)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: 'The *unmanaged constraint* (introduced in C# 7.3) is a stronger version of
    a struct constraint: `T` must be a simple value type or a struct that is (recursively)
    free of any reference types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *parameterless constructor constraint* requires `T` to have a public parameterless
    constructor. If this constraint is defined, you can call `new()` on `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: 'The *naked type constraint* requires one type parameter to derive from (or
    match) another type parameter. In this example, the method `FilteredStack` returns
    another `Stack`, containing only the subset of elements where the type parameter
    `U` is of the type parameter `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: Subclassing Generic Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A generic class can be subclassed just like a nongeneric class. The subclass
    can leave the base class’s type parameters open, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, the subclass can close the generic type parameters with a concrete type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: 'A subtype can also introduce fresh type arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Technically, *all* type arguments on a subtype are fresh: you could say that
    a subtype closes and then reopens the base type arguments. This means that a subclass
    can give new (and potentially more meaningful) names to the type arguments that
    it reopens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: Self-Referencing Generic Declarations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A type can name *itself* as the concrete type when closing a type argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are also legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: Static Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Static data is unique for each closed type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: Type Parameters and Conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C#’s cast operator can perform several kinds of conversion, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Numeric conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boxing/unboxing conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom conversion (via operator overloading; see [Chapter 4](ch04.html#advanced_chash))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The decision as to which kind of conversion will take place happens at *compile
    time*, based on the known types of the operands. This creates an interesting scenario
    with generic type parameters, because the precise operand types are unknown at
    compile time. If this leads to ambiguity, the compiler generates an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common scenario is when you want to perform a reference conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: 'Without knowledge of `T`’s actual type, the compiler is concerned that you
    might have intended this to be a *custom conversion*. The simplest solution is
    to instead use the `as` operator, which is unambiguous because it cannot perform
    custom conversions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: 'A more general solution is to first cast to `object`. This works because conversions
    to/from `object` are assumed not to be custom conversions, but reference or boxing/unboxing
    conversions. In this case, `StringBuilder` is a reference type, so it must be
    a reference conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: 'Unboxing conversions can also introduce ambiguities. The following could be
    an unboxing, numeric, or custom conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution, again, is to first cast to `object` and then to `int` (which
    then unambiguously signals an unboxing conversion in this case):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: Covariance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assuming `A` is convertible to `B`, `X` has a covariant type parameter if `X<A>`
    is convertible to `X<B>`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: With C#’s notion of covariance (and contravariance), “convertible” means convertible
    via an *implicit reference conversion*—such as `A` *subclassing* `B`, or `A` *implementing*
    `B`. Numeric conversions, boxing conversions, and custom conversions are not included.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, type `IFoo<T>` has a covariant `T` if the following is legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: Interfaces permit covariant type parameters (as do delegates; see [Chapter 4](ch04.html#advanced_chash)),
    but classes do not. Arrays also allow covariance (`A[]` can be converted to `B[]`
    if `A` has an implicit reference conversion to `B`) and are discussed here for
    comparison.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Covariance and contravariance (or simply “variance”) are advanced concepts.
    The motivation behind introducing and enhancing variance in C# was to allow generic
    interface and generic types (in particular, those defined in .NET, such as `IEnumerable<T>`)
    to work more as you’d expect. You can benefit from this without understanding
    the details behind covariance and contravariance.
  prefs: []
  type: TYPE_NORMAL
- en: Variance is not automatic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To ensure static type safety, type parameters are not automatically variant.
    Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: 'The following fails to compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: 'That restriction prevents the possibility of runtime failure with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: 'Lack of covariance, however, can hinder reusability. Suppose, for instance,
    that we wanted to write a method to `Wash` a stack of animals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `Wash` with a stack of bears would generate a compile-time error. One
    workaround is to redefine the `Wash` method with a constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now call `Wash` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: Another solution is to have `Stack<T>` implement an interface with a covariant
    type parameter, as you’ll see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For historical reasons, array types support covariance. This means that `B[]`
    can be cast to `A[]` if `B` subclasses `A` (and both are reference types):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: 'The downside of this reusability is that element assignments can fail at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: Declaring a covariant type parameter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Type parameters on interfaces and delegates can be declared covariant by marking
    them with the `out` modifier. This modifier ensures that, unlike with arrays,
    covariant type parameters are fully type-safe.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can illustrate this with our `Stack<T>` class by having it implement the
    following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: 'The `out` modifier on `T` indicates that `T` is used only in *output positions*
    (e.g., return types for methods). The `out` modifier flags the type parameter
    as *covariant* and allows us to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: The conversion from `bears` to `animals` is permitted by the compiler—by virtue
    of the type parameter being covariant. This is type-safe because the case the
    compiler is trying to avoid—pushing a `Camel` onto the stack—can’t occur, because
    there’s no way to feed a `Camel` *in*to an interface where `T` can appear only
    in *out*put positions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Covariance (and contravariance) in interfaces is something that you typically
    *consume*: it’s less common that you need to *write* variant interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Curiously, method parameters marked as `out` are not eligible for covariance,
    due to a limitation in the CLR.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can leverage the ability to cast covariantly to solve the reusability problem
    described earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `IEnumerator<T>` and `IEnumerable<T>` interfaces described in [Chapter 7](ch07.html#collections-id00055)
    have a covariant `T`. This allows you to cast `IEnumerable<string>` to `IEnumerable<object>`,
    for instance.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler will generate an error if you use a covariant type parameter in
    an *input* position (e.g., a parameter to a method or a writable property).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Covariance (and contravariance) works only for elements with *reference conversions*—not
    *boxing conversions*. (This applies both to type parameter variance and array
    variance.) So, if you wrote a method that accepted a parameter of type `IPoppable<object>`,
    you could call it with `IPoppable<string>` but not `IPoppable<int>`.
  prefs: []
  type: TYPE_NORMAL
- en: Contravariance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We previously saw that, assuming that `A` allows an implicit reference conversion
    to `B`, a type `X` has a covariant type parameter if `X<A>` allows a reference
    conversion to `X<B>`. *Contravariance* is when you can convert in the reverse
    direction—from `X<B>` to `X<A>`. This is supported if the type parameter appears
    only in *input* positions and is designated with the `in` modifier. Extending
    our previous example, suppose the `Stack<T>` class implements the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now legally do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: No member in `IPushable` *outputs* a `T`, so we can’t get into trouble by casting
    `animals` to `bears` (there’s no way to `Pop`, for instance, through that interface).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Our `Stack<T>` class can implement both `IPushable<T>` and `IPoppable<T>`—despite
    `T` having opposing variance annotations in the two interfaces! This works because
    you must exercise variance through the interface and not the class; therefore,
    you must commit to the lens of either `IPoppable` or `IPushable` before performing
    a variant conversion. This lens then restricts you to the operations that are
    legal under the appropriate variance rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'This also illustrates why *classes* do not allow variant type parameters: concrete
    implementations typically require data to flow in both directions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To give another example, consider the following interface, defined in the `System`
    namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the interface has a contravariant `T`, we can use an `IComparer<**object**>`
    to compare two *strings*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: Mirroring covariance, the compiler will report an error if you try to use a
    contravariant type parameter in an output position (e.g., as a return value or
    in a readable property).
  prefs: []
  type: TYPE_NORMAL
- en: C# Generics Versus C++ Templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C# generics are similar in application to C++ templates, but they work very
    differently. In both cases, a synthesis between the producer and consumer must
    take place in which the placeholder types of the producer are filled in by the
    consumer. However, with C# generics, producer types (i.e., open types such as
    `List<T>`) can be compiled into a library (such as *mscorlib.dll*). This works
    because the synthesis between the producer and the consumer that produces closed
    types doesn’t actually happen until runtime. With C++ templates, this synthesis
    is performed at compile time. This means that in C++ you don’t deploy template
    libraries as *.dll*s—they exist only as source code. It also makes it difficult
    to dynamically inspect, let alone create, parameterized types on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To dig deeper into why this is the case, consider again the `Max` method in
    C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: Why couldn’t we have implemented it like this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason is that `Max` needs to be compiled once and work for all possible
    values of `T`. Compilation cannot succeed because there is no single meaning for
    `>` across all values of `T`—in fact, not every `T` even has a `>` operator. In
    contrast, the following code shows the same `Max` method written with C++ templates.
    This code will be compiled separately for each value of `T`, taking on whatever
    semantics `>` has for a particular `T`, and failing to compile if a particular
    `T` does not support the `>` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: ^([1](ch03.html#ch01fn5-marker)) The reference type can also be `System.ValueType`
    or `System.Enum` ([Chapter 6](ch06.html#dotnet_fundamentals)).
  prefs: []
  type: TYPE_NORMAL
