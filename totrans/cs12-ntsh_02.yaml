- en: Chapter 2\. C# Language Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduce the basics of the C# language.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Almost all of the code listings in this book are available as interactive samples
    in LINQPad. Working through these samples in conjunction with the book accelerates
    learning in that you can edit the samples and instantly see the results without
    needing to set up projects and solutions in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: To download the samples, in LINQPad, click the Samples tab, and then click “Download
    more samples.” LINQPad is free—go to [http://*www.linqpad.net*](http://www.linqpad.net).
  prefs: []
  type: TYPE_NORMAL
- en: A First C# Program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following is a program that multiplies 12 by 30 and prints the result, 360,
    to the screen. The double forward slash indicates that the remainder of a line
    is a *comment*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Our program consists of two *statements*. Statements in C# execute sequentially
    and are terminated by a semicolon. The first statement computes the *expression*
    `12 * 30` and stores the result in a *variable*, named `x`, whose type is a 32-bit
    integer (`int`). The second statement calls the `WriteLine` *method* on a *class*
    called `Console`, which is defined in a *namespace* called `System`. This prints
    the variable `x` to a text window on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: A method performs a function; a class groups function members and data members
    to form an object-oriented building block. The `Console` class groups members
    that handle command-line input/output (I/O) functionality, such as the `WriteLine`
    method. A class is a kind of *type*, which we examine in [“Type Basics”](#type_basics).
  prefs: []
  type: TYPE_NORMAL
- en: At the outermost level, types are organized into *namespaces*. Many commonly
    used types—including the `Console` class—reside in the `System` namespace. The
    .NET libraries are organized into nested namespaces. For example, the `System.Text`
    namespace contains types for handling text, and `System.IO` contain types for
    input/output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qualifying the `Console` class with the `System` namespace on every use adds
    clutter. The `using` directive lets you avoid this clutter by *importing* a namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A basic form of code reuse is to write higher-level functions that call lower-level
    functions. We can *refactor* our program with a reusable *method* called `FeetToInches`
    that multiplies an integer by 12, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Our method contains a series of statements surrounded by a pair of braces. This
    is called a *statement block*.
  prefs: []
  type: TYPE_NORMAL
- en: 'A method can receive *input* data from the caller by specifying *parameters*
    and *output* data back to the caller by specifying a *return type*. Our `FeetToInches`
    method has a parameter for inputting feet, and a return type for outputting inches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The *literals* `30` and `100` are the *arguments* passed to the `FeetToInches`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a method doesn’t receive input, use empty parentheses. If it doesn’t return
    anything, use the `void` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Methods are one of several kinds of functions in C#. Another kind of function
    we used in our example program was the `*` *operator*, which performs multiplication.
    There are also *constructors*, *properties*, *events*, *indexers*, and *finalizers*.
  prefs: []
  type: TYPE_NORMAL
- en: Compilation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The C# compiler compiles source code (a set of files with the *.cs* extension)
    into an *assembly*. An assembly is the unit of packaging and deployment in .NET.
    An assembly can be either an *application* or a *library*. A normal console or
    Windows application has an *entry point*, whereas a library does not. The purpose
    of a library is to be called upon (*referenced*) by an application or by other
    libraries. .NET itself is a set of libraries (as well as a runtime environment).
  prefs: []
  type: TYPE_NORMAL
- en: Each of the programs in the preceding section began directly with a series of
    statements (called *top-level statements*). The presence of top-level statements
    implicitly creates an entry point for a console or Windows application. (Without
    top-level statements, a *Main method* denotes an application’s entry point—see
    [“Custom Types”](#custom_types).)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Unlike .NET Framework, .NET 8 assemblies never have a *.exe* extension. The
    *.exe* that you see after building a .NET 8 application is a platform-specific
    native loader responsible for starting your application’s *.dll* assembly.
  prefs: []
  type: TYPE_NORMAL
- en: .NET 8 also allows you to create a self-contained deployment that includes the
    loader, your assemblies, and the required portions of the .NET runtime—all in
    a single *.exe* file. .NET 8 also allows ahead-of-time (AOT) compilation, where
    the executable contains precompiled native code for faster startup and reduced
    memory consumption.
  prefs: []
  type: TYPE_NORMAL
- en: The `dotnet` tool (*dotnet.exe* on Windows) helps you to manage .NET source
    code and binaries from the command line. You can use it to both build and run
    your program, as an alternative to using an integrated development environment
    (IDE) such as Visual Studio or Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: You can obtain the `dotnet` tool either by installing the .NET 8 SDK or by installing
    Visual Studio. Its default location is *%ProgramFiles%\dotnet* on Windows or */usr/bin/dotnet*
    on Ubuntu Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile an application, the `dotnet` tool requires a *project file* as well
    as one or more C# files. The following command *scaffolds* a new console project
    (creates its basic structure):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This creates a subfolder called *MyFirstProgram* containing a project file called
    *MyFirstProgram.csproj* and a C# file called *Program.cs* that prints “Hello world.”
  prefs: []
  type: TYPE_NORMAL
- en: 'To build and run your program, run the following command from the *MyFirstProgram*
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if you just want to build without running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The output assembly will be written to a subdirectory under *bin\debug*.
  prefs: []
  type: TYPE_NORMAL
- en: We explain assemblies in detail in [Chapter 17](ch17.html#assemblies).
  prefs: []
  type: TYPE_NORMAL
- en: Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C# syntax is inspired by C and C++ syntax. In this section, we describe C#’s
    elements of syntax, using the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Identifiers and Keywords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Identifiers* are names that programmers choose for their classes, methods,
    variables, and so on. Here are the identifiers in our example program, in the
    order in which they appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: An identifier must be a whole word, essentially made up of Unicode characters
    starting with a letter or underscore. C# identifiers are case sensitive. By convention,
    parameters, local variables, and private fields should be in *camel case* (e.g.,
    `myVariable`), and all other identifiers should be in *Pascal case* (e.g., `MyMethod`).
  prefs: []
  type: TYPE_NORMAL
- en: '*Keywords* are names that mean something special to the compiler. There are
    two keywords in our example program: `using` and `int`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most keywords are *reserved*, which means that you can’t use them as identifiers.
    Here is the full list of C# reserved keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `abstract` `as`'
  prefs: []
  type: TYPE_NORMAL
- en: '`base`'
  prefs: []
  type: TYPE_NORMAL
- en: '`bool`'
  prefs: []
  type: TYPE_NORMAL
- en: '`break`'
  prefs: []
  type: TYPE_NORMAL
- en: '`byte`'
  prefs: []
  type: TYPE_NORMAL
- en: '`case`'
  prefs: []
  type: TYPE_NORMAL
- en: '`catch`'
  prefs: []
  type: TYPE_NORMAL
- en: '`char`'
  prefs: []
  type: TYPE_NORMAL
- en: '`checked`'
  prefs: []
  type: TYPE_NORMAL
- en: '`class`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const`'
  prefs: []
  type: TYPE_NORMAL
- en: '`continue`'
  prefs: []
  type: TYPE_NORMAL
- en: '`decimal`'
  prefs: []
  type: TYPE_NORMAL
- en: '`default`'
  prefs: []
  type: TYPE_NORMAL
- en: '`delegate` | `do` `double`'
  prefs: []
  type: TYPE_NORMAL
- en: '`else`'
  prefs: []
  type: TYPE_NORMAL
- en: '`enum`'
  prefs: []
  type: TYPE_NORMAL
- en: '`event`'
  prefs: []
  type: TYPE_NORMAL
- en: '`explicit`'
  prefs: []
  type: TYPE_NORMAL
- en: '`extern`'
  prefs: []
  type: TYPE_NORMAL
- en: '`false`'
  prefs: []
  type: TYPE_NORMAL
- en: '`finally`'
  prefs: []
  type: TYPE_NORMAL
- en: '`fixed`'
  prefs: []
  type: TYPE_NORMAL
- en: '`float`'
  prefs: []
  type: TYPE_NORMAL
- en: '`for`'
  prefs: []
  type: TYPE_NORMAL
- en: '`foreach`'
  prefs: []
  type: TYPE_NORMAL
- en: '`goto`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if`'
  prefs: []
  type: TYPE_NORMAL
- en: '`implicit` | `in` `int`'
  prefs: []
  type: TYPE_NORMAL
- en: '`interface`'
  prefs: []
  type: TYPE_NORMAL
- en: '`internal`'
  prefs: []
  type: TYPE_NORMAL
- en: '`is`'
  prefs: []
  type: TYPE_NORMAL
- en: '`lock`'
  prefs: []
  type: TYPE_NORMAL
- en: '`long`'
  prefs: []
  type: TYPE_NORMAL
- en: '`namespace`'
  prefs: []
  type: TYPE_NORMAL
- en: '`new`'
  prefs: []
  type: TYPE_NORMAL
- en: '`null`'
  prefs: []
  type: TYPE_NORMAL
- en: '`object`'
  prefs: []
  type: TYPE_NORMAL
- en: '`operator`'
  prefs: []
  type: TYPE_NORMAL
- en: '`out`'
  prefs: []
  type: TYPE_NORMAL
- en: '`override`'
  prefs: []
  type: TYPE_NORMAL
- en: '`params`'
  prefs: []
  type: TYPE_NORMAL
- en: '`private` | `protected` `public`'
  prefs: []
  type: TYPE_NORMAL
- en: '`readonly`'
  prefs: []
  type: TYPE_NORMAL
- en: '`record`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ref`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sbyte`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sealed`'
  prefs: []
  type: TYPE_NORMAL
- en: '`short`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sizeof`'
  prefs: []
  type: TYPE_NORMAL
- en: '`stackalloc`'
  prefs: []
  type: TYPE_NORMAL
- en: '`static`'
  prefs: []
  type: TYPE_NORMAL
- en: '`string`'
  prefs: []
  type: TYPE_NORMAL
- en: '`struct`'
  prefs: []
  type: TYPE_NORMAL
- en: '`switch`'
  prefs: []
  type: TYPE_NORMAL
- en: '`this` | `throw` `true`'
  prefs: []
  type: TYPE_NORMAL
- en: '`try`'
  prefs: []
  type: TYPE_NORMAL
- en: '`typeof`'
  prefs: []
  type: TYPE_NORMAL
- en: '`uint`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ulong`'
  prefs: []
  type: TYPE_NORMAL
- en: '`unchecked`'
  prefs: []
  type: TYPE_NORMAL
- en: '`unsafe`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ushort`'
  prefs: []
  type: TYPE_NORMAL
- en: '`using`'
  prefs: []
  type: TYPE_NORMAL
- en: '`virtual`'
  prefs: []
  type: TYPE_NORMAL
- en: '`void`'
  prefs: []
  type: TYPE_NORMAL
- en: '`volatile`'
  prefs: []
  type: TYPE_NORMAL
- en: '`while` |'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you really want to use an identifier that clashes with a reserved keyword,
    you can do so by qualifying it with the `@` prefix. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `@` symbol doesn’t form part of the identifier itself. So, `@myVariable`
    is the same as `myVariable`.
  prefs: []
  type: TYPE_NORMAL
- en: Contextual keywords
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some keywords are *contextual*, meaning that you also can use them as identifiers—without
    an `@` symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `add` `alias`'
  prefs: []
  type: TYPE_NORMAL
- en: '`and`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ascending`'
  prefs: []
  type: TYPE_NORMAL
- en: '`async`'
  prefs: []
  type: TYPE_NORMAL
- en: '`await`'
  prefs: []
  type: TYPE_NORMAL
- en: '`by`'
  prefs: []
  type: TYPE_NORMAL
- en: '`descending` | `dynamic` `equals`'
  prefs: []
  type: TYPE_NORMAL
- en: '`file`'
  prefs: []
  type: TYPE_NORMAL
- en: '`from`'
  prefs: []
  type: TYPE_NORMAL
- en: '`get`'
  prefs: []
  type: TYPE_NORMAL
- en: '`global`'
  prefs: []
  type: TYPE_NORMAL
- en: '`group`'
  prefs: []
  type: TYPE_NORMAL
- en: '`init` | `into` `join`'
  prefs: []
  type: TYPE_NORMAL
- en: '`let`'
  prefs: []
  type: TYPE_NORMAL
- en: '`managed`'
  prefs: []
  type: TYPE_NORMAL
- en: '`nameof`'
  prefs: []
  type: TYPE_NORMAL
- en: '`nint`'
  prefs: []
  type: TYPE_NORMAL
- en: '`not`'
  prefs: []
  type: TYPE_NORMAL
- en: '`notnull` | `nuint` `on`'
  prefs: []
  type: TYPE_NORMAL
- en: '`or`'
  prefs: []
  type: TYPE_NORMAL
- en: '`orderby`'
  prefs: []
  type: TYPE_NORMAL
- en: '`partial`'
  prefs: []
  type: TYPE_NORMAL
- en: '`remove`'
  prefs: []
  type: TYPE_NORMAL
- en: '`required`'
  prefs: []
  type: TYPE_NORMAL
- en: '`select` | `set` `unmanaged`'
  prefs: []
  type: TYPE_NORMAL
- en: '`value`'
  prefs: []
  type: TYPE_NORMAL
- en: '`var`'
  prefs: []
  type: TYPE_NORMAL
- en: '`with`'
  prefs: []
  type: TYPE_NORMAL
- en: '`when`'
  prefs: []
  type: TYPE_NORMAL
- en: '`where`'
  prefs: []
  type: TYPE_NORMAL
- en: '`yield` |'
  prefs: []
  type: TYPE_NORMAL
- en: With contextual keywords, ambiguity cannot arise within the context in which
    they are used.
  prefs: []
  type: TYPE_NORMAL
- en: Literals, Punctuators, and Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Literals* are primitive pieces of data lexically embedded into the program.
    The literals we used in our example program are `12` and `30`.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Punctuators* help demarcate the structure of the program. An example is the
    semicolon, which terminates a statement. Statements can wrap multiple lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'An *operator* transforms and combines expressions. Most operators in C# are
    denoted with a symbol, such as the multiplication operator, `*`. We discuss operators
    in more detail later in this chapter. These are the operators we used in our example
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A period denotes a member of something (or a decimal point with numeric literals).
    Parentheses are used when declaring or calling a method; empty parentheses are
    used when the method accepts no arguments. (Parentheses also have other purposes
    that you’ll see later in this chapter.) An equals sign performs *assignment*.
    (The double equals sign, `==`, performs equality comparison, as you’ll see later.)
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C# offers two different styles of source-code documentation: *single-line comments*
    and *multiline comments*. A single-line comment begins with a double forward slash
    and continues until the end of the line; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'A multiline comment begins with `/*` and ends with `*/`; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Comments can embed XML documentation tags, which we explain in [“XML Documentation”](ch04.html#xml_documentation).
  prefs: []
  type: TYPE_NORMAL
- en: Type Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A *type* defines the blueprint for a value. In this example, we use two literals
    of type `int` with values `12` and `30`. We also declare a *variable* of type
    `int` whose name is `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Because most of the code listings in this book require types from the `System`
    namespace, we will omit “`using System`” from now on, unless we’re illustrating
    a concept relating to namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *variable* denotes a storage location that can contain different values over
    time. In contrast, a *constant* always represents the same value (more on this
    later):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: All values in C# are *instances* of a type. The meaning of a value and the set
    of possible values a variable can have are determined by its type.
  prefs: []
  type: TYPE_NORMAL
- en: Predefined Type Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Predefined types are types that are specially supported by the compiler. The
    `int` type is a predefined type for representing the set of integers that fit
    into 32 bits of memory, from −2^(31) to 2^(31)−1, and is the default type for
    numeric literals within this range. You can perform functions such as arithmetic
    with instances of the `int` type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Another predefined C# type is `string`. The `string` type represents a sequence
    of characters, such as “.NET” or [*http://oreilly.com*](http://oreilly.com). You
    can work with strings by calling functions on them, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we called `x.ToString()` to obtain a string representation
    of the integer `x`. You can call `ToString()` on a variable of almost any type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The predefined `bool` type has exactly two possible values: `true` and `false`.
    The `bool` type is commonly used with an `if` statement to conditionally branch
    execution flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In C#, predefined types (also referred to as built-in types) are recognized
    with a C# keyword. The `System` namespace in .NET contains many important types
    that are not predefined by C# (e.g., `DateTime`).
  prefs: []
  type: TYPE_NORMAL
- en: Custom Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as we can write our own methods, we can write our own types. In this next
    example, we define a custom type named `UnitConverter`—a class that serves as
    a blueprint for unit conversions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this example, our class definition appears in the same file as our top-level
    statements. This is legal—as long as the top-level statements appear first—and
    is acceptable when writing small test programs. With larger programs, the standard
    approach is to put the class definition in a separate file such as *UnitConverter.cs*.
  prefs: []
  type: TYPE_NORMAL
- en: Members of a type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A type contains *data members* and *function members*. The data member of `UnitConverter`
    is the *field* called `ratio`. The function members of `UnitConverter` are the
    `Convert` method and the `UnitConverter`’s *constructor*.
  prefs: []
  type: TYPE_NORMAL
- en: Symmetry of predefined types and custom types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A beautiful aspect of C# is that predefined types and custom types have few
    differences. The predefined `int` type serves as a blueprint for integers. It
    holds data—32 bits—and provides function members that use that data, such as `ToString`.
    Similarly, our custom `UnitConverter` type acts as a blueprint for unit conversions.
    It holds data—the ratio—and provides function members to use that data.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors and instantiation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Data is created by *instantiating* a type. Predefined types can be instantiated
    simply by using a literal such as `12` or `"Hello world"`. The `new` operator
    creates instances of a custom type. We created and declared an instance of the
    `UnitConverter` type with this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Immediately after the `new` operator instantiates an object, the object’s *constructor*
    is called to perform initialization. A constructor is defined like a method, except
    that the method name and return type are reduced to the name of the enclosing
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Instance versus static members
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The data members and function members that operate on the *instance* of the
    type are called *instance members*. The `UnitConverter`’s `Convert` method and
    the `int`’s `ToString` method are examples of instance members. By default, members
    are instance members.
  prefs: []
  type: TYPE_NORMAL
- en: Data members and function members that don’t operate on the instance of the
    type can be marked as `static`. To refer to a static member from outside its type,
    you specify its *type* name rather than an *instance*. An example is the `WriteLine`
    method of the `Console` class. Because this is static, we call `Console.WriteLine()`
    and not `new Console().WriteLine()`.
  prefs: []
  type: TYPE_NORMAL
- en: (The `Console` class is actually declared as a *static class*, which means that
    *all* of its members are static and you can never create instances of a `Console`.)
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, the instance field `Name` pertains to an instance of
    a particular `Panda`, whereas `Population` pertains to the set of all `Panda`
    instances. We create two instances of the `Panda`, print their names, and then
    print the total population:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Attempting to evaluate `p1.Population` or `Panda.Name` will generate a compile-time
    error.
  prefs: []
  type: TYPE_NORMAL
- en: The public keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `public` keyword exposes members to other classes. In this example, if
    the `Name` field in `Panda` was not marked as public, it would be private and
    could not be accessed from outside the class. Marking a member `public` is how
    a type communicates: “Here is what I want other types to see—everything else is
    my own private implementation details.” In object-oriented terms, we say that
    the public members *encapsulate* the private members of the class.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining namespaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Particularly with larger programs, it makes sense to organize types into namespaces.
    Here’s how to define the `Panda` class inside a namespace called `Animals`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we also *imported* the `Animals` namespace so that our top-level
    statements could access its types without qualification. Without that import,
    we’d need to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We cover namespaces in detail at the end of this chapter (see [“Namespaces”](#namespaces-id00029)).
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Main method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All of our examples, so far, have used top-level statements (a feature introduced
    in C# 9).
  prefs: []
  type: TYPE_NORMAL
- en: 'Without top-level statements, a simple console or Windows application looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the absence of top-level statements, C# looks for a static method called
    `Main`, which becomes the entry point. The `Main` method can be defined inside
    any class (and only one `Main` method can exist).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Main` method can optionally return an integer (rather than `void`) in
    order to return a value to the execution environment (where a nonzero value typically
    indicates an error). The `Main` method can also optionally accept an array of
    strings as a parameter (that will be populated with any arguments passed to the
    executable). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: An array (such as `string[]`) represents a fixed number of elements of a particular
    type. Arrays are specified by placing square brackets after the element type.
    We describe them in [“Arrays”](#arrays-id00001).
  prefs: []
  type: TYPE_NORMAL
- en: (The `Main` method can also be declared `async` and return a `Task` or `Task<int>`
    in support of asynchronous programming, which we cover in [Chapter 14](ch14.html#concurrency_and_asynchron).)
  prefs: []
  type: TYPE_NORMAL
- en: Types and Conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C# can convert between instances of compatible types. A conversion always creates
    a new value from an existing one. Conversions can be either *implicit* or *explicit*:
    implicit conversions happen automatically, and explicit conversions require a
    *cast*. In the following example, we *implicitly* convert an `int` to a `long`
    type (which has twice the bit capacity of an `int`) and *explicitly* cast an `int`
    to a `short` type (which has half the bit capacity of an `int`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Implicit conversions are allowed when both of the following are true:'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler can guarantee that they will always succeed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No information is lost in conversion.^([1](ch02.html#ch01fn1))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Conversely, *explicit* conversions are required when one of the following is
    true:'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler cannot guarantee that they will always succeed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information might be lost during conversion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (If the compiler can determine that a conversion will *always* fail, both kinds
    of conversion are prohibited. Conversions that involve generics can also fail
    in certain conditions—see [“Type Parameters and Conversions”](ch03.html#type_parameters_and_conversions).)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The *numeric conversions* that we just saw are built into the language. C# also
    supports *reference conversions* and *boxing conversions* (see [Chapter 3](ch03.html#creating_types_in_chash))
    as well as *custom conversions* (see [“Operator Overloading”](ch04.html#operator_overloading)).
    The compiler doesn’t enforce the aforementioned rules with custom conversions,
    so it’s possible for badly designed types to behave otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Value Types Versus Reference Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All C# types fall into the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Value types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic type parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pointer types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this section, we describe value types and reference types. We cover generic
    type parameters in [“Generics”](ch03.html#generics) and pointer types in [“Unsafe
    Code and Pointers”](ch04.html#unsafe_code_and_pointers).
  prefs: []
  type: TYPE_NORMAL
- en: '*Value types* comprise most built-in types (specifically, all numeric types,
    the `char` type, and the `bool` type) as well as custom `struct` and `enum` types.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Reference types* comprise all class, array, delegate, and interface types.
    (This includes the predefined `string` type.)'
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental difference between value types and reference types is how they
    are handled in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Value types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The content of a *value type* variable or constant is simply a value. For example,
    the content of the built-in value type, `int`, is 32 bits of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define a custom value type with the `struct` keyword (see [Figure 2-1](#a_value_type_instance_in_memory)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Or more tersely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![A value-type instance in memory](assets/cn10_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. A value-type instance in memory
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The assignment of a value-type instance always *copies* the instance; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 2-2](#assignment_copies_a_value_type_instance) shows that `p1` and
    `p2` have independent storage.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assignment copies a value-type instance](assets/cn10_0202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2\. Assignment copies a value-type instance
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Reference types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A reference type is more complex than a value type, having two parts: an *object*
    and the *reference* to that object. The content of a reference-type variable or
    constant is a reference to an object that contains the value. Here is the `Point`
    type from our previous example rewritten as a class rather than a `struct` (shown
    in [Figure 2-3](#a_reference_type_instance_in_memory)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![A reference-type instance in memory](assets/cn10_0203.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-3\. A reference-type instance in memory
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Assigning a reference-type variable copies the reference, not the object instance.
    This allows multiple variables to refer to the same object—something not ordinarily
    possible with value types. If we repeat the previous example, but with `Point`
    now a class, an operation to `p1` affects `p2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 2-4](#assignment_copies_a_reference) shows that `p1` and `p2` are two
    references that point to the same object.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assignment copies a reference](assets/cn10_0204.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-4\. Assignment copies a reference
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Null'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A reference can be assigned the literal `null`, indicating that the reference
    points to no object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In [“Nullable Reference Types”](ch04.html#nullable_reference_types-id00081),
    we describe a feature of C# that helps to reduce accidental `NullReference​Ex⁠ception`
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, a value type cannot ordinarily have a null value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: C# also has a construct called *nullable value types* for representing value-type
    nulls. For more information, see [“Nullable Value Types”](ch04.html#nullable_value_types).
  prefs: []
  type: TYPE_NORMAL
- en: Storage overhead
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Value-type instances occupy precisely the memory required to store their fields.
    In this example, `Point` takes 8 bytes of memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Technically, the CLR positions fields within the type at an address that’s
    a multiple of the fields’ size (up to a maximum of 8 bytes). Thus, the following
    actually consumes 16 bytes of memory (with the 7 bytes following the first field
    “wasted”):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You can override this behavior by applying the `StructLayout` attribute (see
    [“Mapping a Struct to Unmanaged Memory”](ch24.html#mapping_a_struct_to_unmanaged_memory)).
  prefs: []
  type: TYPE_NORMAL
- en: Reference types require separate allocations of memory for the reference and
    object. The object consumes as many bytes as its fields, plus additional administrative
    overhead. The precise overhead is intrinsically private to the implementation
    of the .NET runtime, but at minimum, the overhead is 8 bytes, used to store a
    key to the object’s type as well as temporary information such as its lock state
    for multithreading and a flag to indicate whether it has been fixed from movement
    by the garbage collector. Each reference to an object requires an extra 4 or 8
    bytes, depending on whether the .NET runtime is running on a 32- or 64-bit platform.
  prefs: []
  type: TYPE_NORMAL
- en: Predefined Type Taxonomy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The predefined types in C# are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Value types*'
  prefs: []
  type: TYPE_NORMAL
- en: Numeric
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signed integer (`sbyte`, `short`, `int`, `long`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Unsigned integer (`byte`, `ushort`, `uint`, `ulong`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Real number (`float`, `double`, `decimal`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical (`bool`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character (`char`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Reference types*'
  prefs: []
  type: TYPE_NORMAL
- en: String (`string`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object (`object`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Predefined types in C# alias .NET types in the `System` namespace. There is
    only a syntactic difference between these two statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The set of predefined *value* types excluding `decimal` are known as *primitive
    types* in the CLR. Primitive types are so called because they are supported directly
    via instructions in compiled code, and this usually translates to direct support
    on the underlying processor; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `System.IntPtr` and `System.UIntPtr` types are also primitive (see [Chapter 24](ch24.html#native_and_com_interoperabilit)).
  prefs: []
  type: TYPE_NORMAL
- en: Numeric Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# has the predefined numeric types shown in [Table 2-1](#predefined_numeric_types_in_chash).
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-1\. Predefined numeric types in C#
  prefs: []
  type: TYPE_NORMAL
- en: '| C# type | System type | Suffix | Size | Range |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Integral—signed** |'
  prefs: []
  type: TYPE_TB
- en: '| `sbyte` | `SByte` |  | 8 bits | –2⁷ to 2⁷–1 |'
  prefs: []
  type: TYPE_TB
- en: '| `short` | `Int16` |  | 16 bits | –2^(15) to 2^(15)–1 |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | `Int32` |  | 32 bits | –2^(31) to 2^(31)–1 |'
  prefs: []
  type: TYPE_TB
- en: '| `long` | `Int64` | `L` | 64 bits | –2^(63) to 2^(63)–1 |'
  prefs: []
  type: TYPE_TB
- en: '| `nint` | `IntPtr` |  | 32/64 bits |  |'
  prefs: []
  type: TYPE_TB
- en: '| **Integral—unsigned** |'
  prefs: []
  type: TYPE_TB
- en: '| `byte` | `Byte` |  | 8 bits | 0 to 2⁸–1 |'
  prefs: []
  type: TYPE_TB
- en: '| `ushort` | `UInt16` |  | 16 bits | 0 to 2^(16)–1 |'
  prefs: []
  type: TYPE_TB
- en: '| `uint` | `UInt32` | `U` | 32 bits | 0 to 2^(32)–1 |'
  prefs: []
  type: TYPE_TB
- en: '| `ulong` | `UInt64` | `UL` | 64 bits | 0 to 2^(64)–1 |'
  prefs: []
  type: TYPE_TB
- en: '| `nuint` | `UIntPtr` |  | 32/64 bits |  |'
  prefs: []
  type: TYPE_TB
- en: '| **Real** |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | `Single` | `F` | 32 bits | ± (~10^(–45) to 10^(38)) |'
  prefs: []
  type: TYPE_TB
- en: '| `double` | `Double` | `D` | 64 bits | ± (~10^(–324) to 10^(308)) |'
  prefs: []
  type: TYPE_TB
- en: '| `decimal` | `Decimal` | `M` | 128 bits | ± (~10^(–28) to 10^(28)) |'
  prefs: []
  type: TYPE_TB
- en: Of the *integral* types, `int` and `long` are first-class citizens and are favored
    by both C# and the runtime. The other integral types are typically used for interoperability
    or when space efficiency is paramount. The `nint` and `nuint` native-sized integer
    types are most useful when working with pointers, so we will describe these in
    a later chapter (see [“Native-Sized Integers”](ch04.html#native_sized_integers)).
  prefs: []
  type: TYPE_NORMAL
- en: Of the *real* number types, `float` and `double` are called *floating-point
    types*^([2](ch02.html#ch01fn2)) and are typically used for scientific and graphical
    calculations. The `decimal` type is typically used for financial calculations,
    for which base-10-accurate arithmetic and high precision are required.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: .NET supplements this list with several specialized numeric types, including
    `Int128` and `UInt128` for signed and unsigned 128-bit integers, `BigInteger`
    for arbitrarily large integers, and `Half` for 16-bit floating point numbers.
    `Half` is intended mainly for interoperating with graphics card processors and
    does not have native support in most CPUs, making `float` and `double` better
    choices for general use.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric Literals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Integral-type literals* can use decimal or hexadecimal notation; hexadecimal
    is denoted with the `0x` prefix. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You can insert an underscore anywhere within a numeric literal to make it more
    readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You can specify numbers in binary with the `0b` prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '*Real literals* can use decimal and/or exponential notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Numeric literal type inference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, the compiler *infers* a numeric literal to be either `double` or
    an integral type:'
  prefs: []
  type: TYPE_NORMAL
- en: If the literal contains a decimal point or the exponential symbol (`E`), it
    is a `double`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Otherwise, the literal’s type is the first type in this list that can fit the
    literal’s value: `int`, `uint`, `long`, and `ulong`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Numeric suffixes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Numeric suffixes* explicitly define the type of a literal. Suffixes can be
    either lowercase or uppercase, and are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Category | C# type | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `F` | `float` | `float f = 1.0F;` |'
  prefs: []
  type: TYPE_TB
- en: '| `D` | `double` | `double d = 1D;` |'
  prefs: []
  type: TYPE_TB
- en: '| `M` | `decimal` | `decimal d = 1.0M;` |'
  prefs: []
  type: TYPE_TB
- en: '| `U` | `uint` | `uint i = 1U;` |'
  prefs: []
  type: TYPE_TB
- en: '| `L` | `long` | `long i = 1L;` |'
  prefs: []
  type: TYPE_TB
- en: '| `UL` | `ulong` | `ulong i = 1UL;` |'
  prefs: []
  type: TYPE_TB
- en: 'The suffixes `U` and `L` are rarely necessary because the `uint`, `long`, and
    `ulong` types can nearly always be either *inferred* or *implicitly converted*
    from `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `D` suffix is technically redundant in that all literals with a decimal
    point are inferred to be `double`. And you can always add a decimal point to a
    numeric literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `F` and `M` suffixes are the most useful and should always be applied when
    specifying `float` or `decimal` literals. Without the `F` suffix, the following
    line would not compile, because 4.5 would be inferred to be of type `double`,
    which has no implicit conversion to `float`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The same principle is true for a decimal literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We describe the semantics of numeric conversions in detail in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric Conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Converting between integral types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Integral type conversions are *implicit* when the destination type can represent
    every possible value of the source type. Otherwise, an *explicit* conversion is
    required; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Converting between floating-point types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `float` can be implicitly converted to a `double` given that a `double` can
    represent every possible value of a `float`. The reverse conversion must be explicit.
  prefs: []
  type: TYPE_NORMAL
- en: Converting between floating-point and integral types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All integral types can be implicitly converted to all floating-point types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The reverse conversion must be explicit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you cast from a floating-point number to an integral type, any fractional
    portion is truncated; no rounding is performed. The static class `System.Convert`
    provides methods that round while converting between various numeric types (see
    [Chapter 6](ch06.html#dotnet_fundamentals)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Implicitly converting a large integral type to a floating-point type preserves
    *magnitude* but can occasionally lose *precision*. This is because floating-point
    types always have more magnitude than integral types but can have less precision.
    Rewriting our example with a larger number demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Decimal conversions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All integral types can be implicitly converted to the decimal type given that
    a decimal can represent every possible C# integral-type value. All other numeric
    conversions to and from a decimal type must be explicit because they introduce
    the possibility of either a value being out of range or precision being lost.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The arithmetic operators (`+`, `-`, `*`, `/`, `%`) are defined for all numeric
    types except the 8- and 16-bit integral types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Increment and Decrement Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The increment and decrement operators (`++`, `--`, respectively) increment
    and decrement numeric types by 1\. The operator can either follow or precede the
    variable, depending on whether you want its value *before* or *after* the increment/decrement;
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Specialized Operations on Integral Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *integral types* are `int`, `uint`, `long`, `ulong`, `short`, `ushort`,
    `byte`, and `sbyte`.
  prefs: []
  type: TYPE_NORMAL
- en: Division
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Division operations on integral types always eliminate the remainder (round
    toward zero). Dividing by a variable whose value is zero generates a runtime error
    (a `DivideByZeroException`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Dividing by the *literal* or *constant* 0 generates a compile-time error.
  prefs: []
  type: TYPE_NORMAL
- en: Overflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At runtime, arithmetic operations on integral types can overflow. By default,
    this happens silently—no exception is thrown, and the result exhibits “wraparound”
    behavior, as though the computation were done on a larger integer type and the
    extra significant bits discarded. For example, decrementing the minimum possible
    `int` value results in the maximum possible `int` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Overflow check operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `checked` operator instructs the runtime to generate an `OverflowException`
    rather than overflowing silently when an integral-type expression or statement
    exceeds the arithmetic limits of that type. The `checked` operator affects expressions
    with the `++`, `−−`, `+`, `−` (binary and unary), `*`, `/`, and explicit conversion
    operators between integral types. Overflow checking incurs a small performance
    cost.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `checked` operator has no effect on the `double` and `float` types (which
    overflow to special “infinite” values, as you’ll see soon) and no effect on the
    `decimal` type (which is always checked).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use `checked` around either an expression or a statement block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You can make arithmetic overflow checking the default for all expressions in
    a program by selecting the “checked” option at the project level (in Visual Studio,
    go to Advanced Build Settings). If you then need to disable overflow checking
    just for specific expressions or statements, you can do so with the `unchecked`
    operator. For example, the following code will not throw exceptions—even if the
    project’s “checked” option is selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Overflow checking for constant expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Regardless of the “checked” project setting, expressions evaluated at compile
    time are always overflow-checked—unless you apply the `unchecked` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Bitwise operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C# supports the following bitwise operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Meaning | Sample expression | Result |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `~` | Complement | `~0xfU` | `0xfffffff0U` |'
  prefs: []
  type: TYPE_TB
- en: '| `&` | And | `0xf0 & 0x33` | `0x30` |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;` | Or | `0xf0 &#124; 0x33` | `0xf3` |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | Exclusive Or | `0xff00 ^ 0x0ff0` | `0xf0f0` |'
  prefs: []
  type: TYPE_TB
- en: '| `<<` | Shift left | `0x20 << 2` | `0x80` |'
  prefs: []
  type: TYPE_TB
- en: '| `>>` | Shift right | `0x20 >> 1` | `0x10` |'
  prefs: []
  type: TYPE_TB
- en: '| `>>>` | Unsigned shift right | `int.MinValue >>> 1` | `0x40000000` |'
  prefs: []
  type: TYPE_TB
- en: The shift-right operator `(>>`) replicates the high-order bit when operating
    on signed integers, whereas the unsigned shift-right operator (`>>>`) does not.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Additional bitwise operations are exposed via a class called `BitOperations`
    in the `System.Numerics` namespace (see [“BitOperations”](ch06.html#bitoperations)).
  prefs: []
  type: TYPE_NORMAL
- en: 8- and 16-Bit Integral Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The 8- and 16-bit integral types are `byte`, `sbyte`, `short`, and `ushort`.
    These types lack their own arithmetic operators, so C# implicitly converts them
    to larger types as required. This can cause a compile-time error when trying to
    assign the result back to a small integral type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, `x` and `y` are implicitly converted to `int` so that the addition
    can be performed. This means that the result is also an `int`, which cannot be
    implicitly cast back to a `short` (because it could cause loss of data). To make
    this compile, you must add an explicit cast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Special Float and Double Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike integral types, floating-point types have values that certain operations
    treat specially. These special values are NaN (Not a Number), +∞, −∞, and −0\.
    The `float` and `double` classes have constants for `NaN`, +∞, and −∞, as well
    as other values (`MaxValue`, `MinValue`, and `Epsilon`); for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The constants that represent special values for `double` and `float` are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Special value | Double constant | Float constant |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NaN | `double.NaN` | `float.NaN` |'
  prefs: []
  type: TYPE_TB
- en: '| +∞ | `double.PositiveInfinity` | `float.PositiveInfinity` |'
  prefs: []
  type: TYPE_TB
- en: '| −∞ | `double.NegativeInfinity` | `float.NegativeInfinity` |'
  prefs: []
  type: TYPE_TB
- en: '| −0 | `−0.0` | `−0.0f` |'
  prefs: []
  type: TYPE_TB
- en: 'Dividing a nonzero number by zero results in an infinite value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Dividing zero by zero, or subtracting infinity from infinity, results in a
    NaN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'When using `==`, a NaN value is never equal to another value, even another
    NaN value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'To test whether a value is NaN, you must use the `float.IsNaN` or `double.IsNaN`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'When using `object.Equals`, however, two NaN values are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: NaNs are sometimes useful in representing special values. In Windows Presentation
    Foundation (WPF), `double.NaN` represents a measurement whose value is “Automatic.”
    Another way to represent such a value is with a nullable type ([Chapter 4](ch04.html#advanced_chash));
    another is with a custom struct that wraps a numeric type and adds an additional
    field ([Chapter 3](ch03.html#creating_types_in_chash)).
  prefs: []
  type: TYPE_NORMAL
- en: '`float` and `double` follow the specification of the IEEE 754 format types,
    supported natively by almost all processors. You can find detailed information
    on the behavior of these types at [*http://www.ieee.org*](http://www.ieee.org).'
  prefs: []
  type: TYPE_NORMAL
- en: double Versus decimal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`double` is useful for scientific computations (such as computing spatial coordinates).
    `decimal` is useful for financial computations and values that are manufactured
    rather than the result of real-world measurements. Here’s a summary of the differences.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Category | double | decimal |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Internal representation | Base 2 | Base 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Decimal precision | 15–16 significant figures | 28–29 significant figures
    |'
  prefs: []
  type: TYPE_TB
- en: '| Range | ±(~10^(−324) to ~10^(308)) | ±(~10^(−28) to ~10^(28)) |'
  prefs: []
  type: TYPE_TB
- en: '| Special values | +0, −0, +∞, −∞, and NaN | None |'
  prefs: []
  type: TYPE_TB
- en: '| Speed | Native to processor | Non-native to processor (about 10 times slower
    than `double`) |'
  prefs: []
  type: TYPE_TB
- en: Real Number Rounding Errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`float` and `double` internally represent numbers in base 2\. For this reason,
    only numbers expressible in base 2 are represented precisely. Practically, this
    means most literals with a fractional component (which are in base 10) will not
    be represented precisely; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This is why `float` and `double` are bad for financial calculations. In contrast,
    `decimal` works in base 10 and so can precisely represent numbers expressible
    in base 10 (as well as its factors, base 2 and base 5). Because real literals
    are in base 10, `decimal` can precisely represent numbers such as 0.1\. However,
    neither `double` nor `decimal` can precisely represent a fractional number whose
    base 10 representation is recurring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'This leads to accumulated rounding errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'which break equality and comparison operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Boolean Type and Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C#’s `bool` type (aliasing the `System.Boolean` type) is a logical value that
    can be assigned the literal `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Although a Boolean value requires only one bit of storage, the runtime will
    use one byte of memory because this is the minimum chunk that the runtime and
    processor can efficiently work with. To avoid space inefficiency in the case of
    arrays, .NET provides a `BitArray` class in the `System.Collections` namespace
    that is designed to use just one bit per Boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: bool Conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No casting conversions can be made from the `bool` type to numeric types, or
    vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Equality and Comparison Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`==` and `!=` test for equality and inequality of any type but always return
    a `bool` value.^([3](ch02.html#ch01fn3)) Value types typically have a very simple
    notion of equality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'For reference types, equality, by default, is based on *reference*, as opposed
    to the actual *value* of the underlying object (more on this in [Chapter 6](ch06.html#dotnet_fundamentals)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The equality and comparison operators, `==`, `!=`, `<`, `>`, `>=`, and `<=`,
    work for all numeric types, but you should use them with caution with real numbers
    (as we saw in [“Real Number Rounding Errors”](#real_number_rounding_errors)).
    The comparison operators also work on `enum` type members by comparing their underlying
    integral-type values. We describe this in [“Enums”](ch03.html#enums-id00013).
  prefs: []
  type: TYPE_NORMAL
- en: We explain the equality and comparison operators in greater detail in [“Operator
    Overloading”](ch04.html#operator_overloading), and in [“Equality Comparison”](ch06.html#equality_comparison-id00067)
    and [“Order Comparison”](ch06.html#order_comparison).
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `&&` and `||` operators test for *and* and *or* conditions. They are frequently
    used in conjunction with the `!` operator, which expresses *not*. In the following
    example, the `UseUmbrella` method returns `true` if it’s rainy or sunny (to protect
    us from the rain or the sun), as long as it’s not also windy (umbrellas are useless
    in the wind):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The `&&` and `||` operators *short-circuit* evaluation when possible. In the
    preceding example, if it is windy, the expression `(rainy || sunny)` is not even
    evaluated. Short-circuiting is essential in allowing expressions such as the following
    to run without throwing a `NullReferenceException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The `&` and `|` operators also test for *and* and *or* conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The difference is that they *do not short-circuit*. For this reason, they are
    rarely used in place of conditional operators.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Unlike in C and C++, the `&` and `|` operators perform (non-short-circuiting)
    Boolean comparisons when applied to `bool` expressions. The `&` and `|` operators
    perform *bitwise* operations only when applied to numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional operator (ternary operator)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *conditional operator* (more commonly called the *ternary operator* because
    it’s the only operator that takes three operands) has the form `q ? a : b`; thus,
    if condition `q` is true, `a` is evaluated; otherwise `b` is evaluated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The conditional operator is particularly useful in Language-Integrated Query
    (LINQ) expressions ([Chapter 8](ch08.html#linq_queries)).
  prefs: []
  type: TYPE_NORMAL
- en: Strings and Characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C#’s `char` type (aliasing the `System.Char` type) represents a Unicode character
    and occupies 2 bytes (UTF-16). A `char` literal is specified within single quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '*Escape sequences* express characters that cannot be expressed or interpreted
    literally. An escape sequence is a backslash followed by a character with a special
    meaning; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 2-2](#escape_sequence_characters) shows the escape sequence characters.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-2\. Escape sequence characters
  prefs: []
  type: TYPE_NORMAL
- en: '| Char | Meaning | Value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `\''` | Single quote | `0x0027` |'
  prefs: []
  type: TYPE_TB
- en: '| `\"` | Double quote | `0x0022` |'
  prefs: []
  type: TYPE_TB
- en: '| `\\` | Backslash | `0x005C` |'
  prefs: []
  type: TYPE_TB
- en: '| `\0` | Null | `0x0000` |'
  prefs: []
  type: TYPE_TB
- en: '| `\a` | Alert | `0x0007` |'
  prefs: []
  type: TYPE_TB
- en: '| `\b` | Backspace | `0x0008` |'
  prefs: []
  type: TYPE_TB
- en: '| `\f` | Form feed | `0x000C` |'
  prefs: []
  type: TYPE_TB
- en: '| `\n` | New line | `0x000A` |'
  prefs: []
  type: TYPE_TB
- en: '| `\r` | Carriage return | `0x000D` |'
  prefs: []
  type: TYPE_TB
- en: '| `\t` | Horizontal tab | `0x0009` |'
  prefs: []
  type: TYPE_TB
- en: '| `\v` | Vertical tab | `0x000B` |'
  prefs: []
  type: TYPE_TB
- en: 'The `\u` (or `\x`) escape sequence lets you specify any Unicode character via
    its four-digit hexadecimal code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Char Conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An implicit conversion from a `char` to a numeric type works for the numeric
    types that can accommodate an unsigned `short`. For other numeric types, an explicit
    conversion is required.
  prefs: []
  type: TYPE_NORMAL
- en: String Type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C#’s string type (aliasing the `System.String` type, covered in depth in [Chapter 6](ch06.html#dotnet_fundamentals))
    represents an immutable (unmodifiable) sequence of Unicode characters. A string
    literal is specified within double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`string` is a reference type rather than a value type. Its equality operators,
    however, follow value-type semantics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The escape sequences that are valid for `char` literals also work inside strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The cost of this is that whenever you need a literal backslash, you must write
    it twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid this problem, C# allows *verbatim* string literals. A verbatim string
    literal is prefixed with `@` and does not support escape sequences. The following
    verbatim string is identical to the preceding one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'A verbatim string literal can also span multiple lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'You can include the double-quote character in a verbatim literal by writing
    it twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Raw string literals (C# 11)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Wrapping a string in three or more quote characters (`"""`) creates a *raw
    string literal*. Raw string literals can contain almost any character sequence,
    without escaping or doubling up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Raw string literals make it easy to represent JSON, XML, and HTML literals,
    as well as regular expressions and source code. Should you need to include three
    (or more) quote characters in the string itself, you can do so by wrapping the
    string in four (or more) quote characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiline raw string literals are subject to special rules. We can represent
    the string `"Line 1\r\nLine 2"` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the opening and closing quotes must be on separate lines to the
    string content. Additionally:'
  prefs: []
  type: TYPE_NORMAL
- en: Whitespace following the *opening* `"""` (on the same line) is ignored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whitespace preceding the *closing* `"""` (on the same line) is treated as *common
    indentation* and is removed from every line in the string. This lets you include
    indentation for source-code readability without that indentation becoming part
    of the string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s another example to illustrate the multiline raw string literal rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The compiler will generate an error if each line in a multiline raw string literal
    is not prefixed with the common indentation specified by the closing quotes.
  prefs: []
  type: TYPE_NORMAL
- en: Raw string literals can be interpolated, subject to special rules described
    in [“String interpolation”](#string_interpolation).
  prefs: []
  type: TYPE_NORMAL
- en: String concatenation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `+` operator concatenates two strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the operands might be a nonstring value, in which case `ToString` is
    called on that value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `+` operator repeatedly to build up a string is inefficient: a better
    solution is to use the `System.Text.StringBuilder` type (described in [Chapter 6](ch06.html#dotnet_fundamentals)).'
  prefs: []
  type: TYPE_NORMAL
- en: String interpolation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A string preceded with the `$` character is called an *interpolated string*.
    Interpolated strings can include expressions enclosed in braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Any valid C# expression of any type can appear within the braces, and C# will
    convert the expression to a string by calling its `ToString` method or equivalent.
    You can change the formatting by appending the expression with a colon and a *format
    string* (format strings are described in [“String.Format and composite format
    strings”](ch06.html#stringdotformat_and_composite_format_st)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Should you need to use a colon for another purpose (such as a ternary conditional
    operator, which we’ll cover later), you must wrap the entire expression in parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'From C# 10, interpolated strings can be constants, as long as the interpolated
    values are constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'From C# 11, interpolated strings are permitted to span multiple lines (whether
    standard or verbatim):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Raw string literals (from C# 11) can also be interpolated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'To include a brace literal in an interpolated string:'
  prefs: []
  type: TYPE_NORMAL
- en: With standard and verbatim string literals, repeat the desired brace character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With raw string literals, change the interpolation sequence by repeating the
    `$` prefix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using two (or more) `$` characters in a raw string literal prefix changes the
    interpolation sequence from one brace to two (or more) braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: This preserves the ability to copy-and-paste text into a raw string literal
    without needing to modify the string.
  prefs: []
  type: TYPE_NORMAL
- en: String comparisons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To perform *equality* comparisons with strings, you can use the `==` operator
    (or one of `string`’s `Equals` methods). For *order* comparison, you must use
    the string’s `CompareTo` method; the `<` and `>` operators are unsupported. We
    describe equality and order comparison in detail in [“Comparing Strings”](ch06.html#comparing_strings).
  prefs: []
  type: TYPE_NORMAL
- en: UTF-8 Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From C# 11, you can use the `u8` suffix to create string literals encoded in
    UTF-8 rather than UTF-16\. This feature is intended for advanced scenarios such
    as the low-level handling of JSON text in performance hotspots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: The underlying type is `ReadOnlySpan<byte>`, which we cover in [Chapter 23](ch23.html#spanless_thantgreater_than_and-id00089).
    You can convert this to an array by calling the `ToArray()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An array represents a fixed number of variables (called *elements*) of a particular
    type. The elements in an array are always stored in a contiguous block of memory,
    providing highly efficient access.
  prefs: []
  type: TYPE_NORMAL
- en: 'An array is denoted with square brackets after the element type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Square brackets also *index* the array, accessing a particular element by position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints “e” because array indexes start at 0\. You can use a `for` loop
    statement to iterate through each element in the array. The `for` loop in this
    example cycles the integer `i` from `0` to `4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The `Length` property of an array returns the number of elements in the array.
    After an array has been created, you cannot change its length. The `System.Collection`
    namespace and subnamespaces provide higher-level data structures, such as dynamically
    sized arrays and dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'An *array initialization expression* lets you declare and populate an array
    in a single step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Or simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'From C# 12, you can use square brackets instead of curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'This is called a *collection expression* and has the advantage of also working
    when calling methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Collection expressions also work with other collection types such as lists and
    sets—see [“Collection Initializers and Collection Expressions”](ch04.html#collection_initializers_and_collection).
  prefs: []
  type: TYPE_NORMAL
- en: All arrays inherit from the `System.Array` class, providing common services
    for all arrays. These members include methods to get and set elements regardless
    of the array type. We describe them in [“The Array Class”](ch07.html#the_array_class).
  prefs: []
  type: TYPE_NORMAL
- en: Default Element Initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating an array always preinitializes the elements with default values. The
    default value for a type is the result of a bitwise zeroing of memory. For example,
    consider creating an array of integers. Because `int` is a value type, this allocates
    1,000 integers in one contiguous block of memory. The default value for each element
    will be 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Value types versus reference types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Whether an array element type is a value type or a reference type has important
    performance implications. When the element type is a value type, each element
    value is allocated as part of the array, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Had `Point` been a class, creating the array would have merely allocated 1,000
    null references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid this error, we must explicitly instantiate 1,000 `Point`s after instantiating
    the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'An array *itself* is always a reference type object, regardless of the element
    type. For instance, the following is legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Indices and Ranges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Indices and ranges* (introduced in C# 8) simplify working with elements or
    portions of an array.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Indices and ranges also work with the CLR types `Span<T>` and `ReadOnlySpan<T>`
    (see [Chapter 23](ch23.html#spanless_thantgreater_than_and-id00089)).
  prefs: []
  type: TYPE_NORMAL
- en: You can also make your own types work with indices and ranges, by defining an
    indexer of type `Index` or `Range` (see [“Indexers”](ch03.html#indexers)).
  prefs: []
  type: TYPE_NORMAL
- en: Indices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Indices let you refer to elements relative to the *end* of an array, with the
    `^` operator. `^1` refers to the last element, `^2` refers to the second-to-last
    element, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: (`^0` equals the length of the array, so `vowels[^0]` generates an error.)
  prefs: []
  type: TYPE_NORMAL
- en: 'C# implements indices with the help of the `Index` type, so you can also do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Ranges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Ranges let you “slice” an array by using the `..` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: The second number in the range is *exclusive*, so `..2` returns the elements
    *before* `vowels[2]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the `^` symbol in ranges. The following returns the last two
    characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'C# implements ranges with the help of the `Range` type, so you can also do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Multidimensional Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Multidimensional arrays come in two varieties: *rectangular* and *jagged*.
    Rectangular arrays represent an *n*-dimensional block of memory, and jagged arrays
    are arrays of arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: Rectangular arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Rectangular arrays are declared using commas to separate each dimension. The
    following declares a rectangular two-dimensional array for which the dimensions
    are 3 by 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetLength` method of an array returns the length for a given dimension
    (starting at 0):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'You can initialize a rectangular array with explicit values. The following
    code creates an array identical to the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Jagged arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Jagged arrays are declared using successive square brackets to represent each
    dimension. Here is an example of declaring a jagged two-dimensional array for
    which the outermost dimension is 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Interestingly, this is `new int[3][]` and not `new int[][3]`. Eric Lippert has
    written [an excellent article](http://albahari.com/jagged) on why this is so.
  prefs: []
  type: TYPE_NORMAL
- en: 'The inner dimensions aren’t specified in the declaration because, unlike a
    rectangular array, each inner array can be an arbitrary length. Each inner array
    is implicitly initialized to null rather than an empty array. You must manually
    create each inner array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'You can initialize a jagged array with explicit values. The following code
    creates an array identical to the previous example with an additional element
    at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Simplified Array Initialization Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways to shorten array initialization expressions. The first is
    to omit the `new` operator and type qualifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: (From C# 12, you can use square brackets instead of braces with single-dimensional
    arrays.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The second approach is to use the `var` keyword, which instructs the compiler
    to implicitly type a local variable. Here are simple examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'The same principle can be applied to arrays, except that it can be taken one
    stage further. By omitting the type qualifier after the `new` keyword, the compiler
    infers the array type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how we can apply this to multidimensional arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'For this to work, the elements must all be implicitly convertible to a single
    type (and at least one of the elements must be of that type, and there must be
    exactly one best type), as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Bounds Checking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All array indexing is bounds checked by the runtime. An `IndexOutOfRange​Excep⁠tion`
    is thrown if you use an invalid index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Array bounds checking is necessary for type safety and simplifies debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Generally, the performance hit from bounds checking is minor, and the Just-In-Time
    (JIT) compiler can perform optimizations, such as determining in advance whether
    all indexes will be safe before entering a loop, thus avoiding a check on each
    iteration. In addition, C# provides “unsafe” code that can explicitly bypass bounds
    checking (see [“Unsafe Code and Pointers”](ch04.html#unsafe_code_and_pointers)).
  prefs: []
  type: TYPE_NORMAL
- en: Variables and Parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A variable represents a storage location that has a modifiable value. A variable
    can be a *local variable*, *parameter* (*value*, *ref*, or *out*, or *in*), *field*
    (*instance* or *static*), or *array element*.
  prefs: []
  type: TYPE_NORMAL
- en: The Stack and the Heap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The stack and the heap are the places where variables reside. Each has very
    different lifetime semantics.
  prefs: []
  type: TYPE_NORMAL
- en: Stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The stack is a block of memory for storing local variables and parameters.
    The stack logically grows and shrinks as a method or function is entered and exited.
    Consider the following method (to avoid distraction, input argument checking is
    ignored):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: This method is recursive, meaning that it calls itself. Each time the method
    is entered, a new `int` is allocated on the stack, and each time the method exits,
    the `int` is deallocated.
  prefs: []
  type: TYPE_NORMAL
- en: Heap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The heap is the memory in which *objects* (i.e., reference-type instances) reside.
    Whenever a new object is created, it is allocated on the heap, and a reference
    to that object is returned. During a program’s execution, the heap begins filling
    up as new objects are created. The runtime has a garbage collector that periodically
    deallocates objects from the heap, so your program does not run out of memory.
    An object is eligible for deallocation as soon as it’s not referenced by anything
    that’s itself “alive.”
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we begin by creating a `StringBuilder` object referenced
    by the variable `ref1` and then write out its content. That `StringBuilder` object
    is then immediately eligible for garbage collection because nothing subsequently
    uses it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we create another `StringBuilder` referenced by variable `ref2` and copy
    that reference to `ref3`. Even though `ref2` is not used after that point, `ref3`
    keeps the same `StringBuilder` object alive—ensuring that it doesn’t become eligible
    for collection until we’ve finished using `ref3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Value-type instances (and object references) live wherever the variable was
    declared. If the instance was declared as a field within a class type, or as an
    array element, that instance lives on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can’t explicitly delete objects in C#, as you can in C++. An unreferenced
    object is eventually collected by the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: The heap also stores static fields. Unlike objects allocated on the heap (which
    can be garbage-collected), these live until the process ends.
  prefs: []
  type: TYPE_NORMAL
- en: Definite Assignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C# enforces a definite assignment policy. In practice, this means that outside
    of an `unsafe` or interop context, you can’t accidentally access uninitialized
    memory. Definite assignment has three implications:'
  prefs: []
  type: TYPE_NORMAL
- en: Local variables must be assigned a value before they can be read.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function arguments must be supplied when a method is called (unless marked as
    optional; see [“Optional parameters”](#optional_parameters)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All other variables (such as fields and array elements) are automatically initialized
    by the runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the following code results in a compile-time error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Fields and array elements are automatically initialized with the default values
    for their type. The following code outputs `0` because array elements are implicitly
    assigned to their default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code outputs `0`, because fields are implicitly assigned a default
    value (whether instance or static):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Default Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All type instances have a default value. The default value for the predefined
    types is the result of a bitwise zeroing of memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Default value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Reference types (and nullable value types) | `null` |'
  prefs: []
  type: TYPE_TB
- en: '| Numeric and enum types | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `char` type | `''\0''` |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` type | `false` |'
  prefs: []
  type: TYPE_TB
- en: 'You can obtain the default value for any type via the `default` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'You can optionally omit the type when it can be inferred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: The default value in a custom value type (i.e., `struct`) is the same as the
    default value for each field defined by the custom type.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A method may have a sequence of parameters. Parameters define the set of arguments
    that must be provided for that method. In the following example, the method `Foo`
    has a single parameter named `p`, of type `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'You can control how parameters are passed with the `ref`, `in`, and `out` modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter modifier | Passed by | Variable must be definitely assigned |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| (None) | Value | Going in |'
  prefs: []
  type: TYPE_TB
- en: '| `ref` | Reference | Going in |'
  prefs: []
  type: TYPE_TB
- en: '| `in` | Reference (read-only) | Going in |'
  prefs: []
  type: TYPE_TB
- en: '| `out` | Reference | Going out |'
  prefs: []
  type: TYPE_TB
- en: Passing arguments by value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, arguments in C# are *passed by value*, which is by far the most
    common case. This means that a copy of the value is created when passed to the
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Assigning `p` a new value does not change the contents of `x`, because `p` and
    `x` reside in different memory locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Passing a reference-type argument by value copies the *reference* but not the
    object. In the following example, `Foo` sees the same `StringBuilder` object we
    instantiated (`sb`) but has an independent *reference* to it. In other words,
    `sb` and `fooSB` are separate variables that reference the same `StringBuilder`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Because `fooSB` is a *copy* of a reference, setting it to `null` doesn’t make
    `sb` null. (If, however, `fooSB` was declared and called with the `ref` modifier,
    `sb` *would* become null.)
  prefs: []
  type: TYPE_NORMAL
- en: The ref modifier
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To *pass by reference*, C# provides the `ref` parameter modifier. In the following
    example, `p` and `x` refer to the same memory locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Now assigning `p` a new value changes the contents of `x`. Notice how the `ref`
    modifier is required both when writing and when calling the method.^([4](ch02.html#ch01fn4))
    This makes it very clear what’s going on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ref` modifier is essential in implementing a swap method (in [“Generics”](ch03.html#generics),
    we show how to write a swap method that works with any type):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A parameter can be passed by reference or by value, regardless of whether the
    parameter type is a reference type or a value type.
  prefs: []
  type: TYPE_NORMAL
- en: The out modifier
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An `out` argument is like a `ref` argument except for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It need not be assigned before going into the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must be assigned before it comes *out* of the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `out` modifier is most commonly used to get multiple return values back
    from a method; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Like a `ref` parameter, an `out` parameter is passed by reference.
  prefs: []
  type: TYPE_NORMAL
- en: Out variables and discards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can declare variables on the fly when calling methods with `out` parameters.
    We can replace the first two lines in our preceding example with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'When calling methods with multiple `out` parameters, sometimes you’re not interested
    in receiving values from all the parameters. In such cases, you can “discard”
    the ones in which you’re uninterested by using an underscore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the compiler treats the underscore as a special symbol, called
    a *discard*. You can include multiple discards in a single call. Assuming `SomeBigMethod`
    has been defined with seven `**out**` parameters, we can ignore all but the fourth,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'For backward compatibility, this language feature will not take effect if a
    real underscore variable is in scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Implications of passing by reference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you pass an argument by reference, you alias the storage location of an
    existing variable rather than create a new storage location. In the following
    example, the variables `x` and `y` represent the same instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: The in modifier
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An `in` parameter is similar to a `ref` parameter except that the argument’s
    value cannot be modified by the method (doing so generates a compile-time error).
    This modifier is most useful when passing a large value type to the method because
    it allows the compiler to avoid the overhead of copying the argument prior to
    passing it in while still protecting the original value from modification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overloading solely on the presence of `in` is permitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'To call the second overload, the caller must use the `in` modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: When there’s no ambiguity
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'use of the `in` modifier is optional for the caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: To make this example meaningful, `SomeBigStruct` would be defined as a struct
    (see [“Structs”](ch03.html#structs)).
  prefs: []
  type: TYPE_NORMAL
- en: The params modifier
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `params` modifier, if applied to the last parameter of a method, allows
    the method to accept any number of arguments of a particular type. The parameter
    type must be declared as a (single-dimensional) array, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: If there are zero arguments in the `params` position, a zero-length array is
    created.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also supply a `params` argument as an ordinary array. The first line
    in our example is semantically equivalent to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Optional parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Methods, constructors, and indexers ([Chapter 3](ch03.html#creating_types_in_chash))
    can declare *optional parameters*. A parameter is optional if it specifies a *default
    value* in its declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'You can omit optional parameters when calling the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'The *default argument* of `23` is actually *passed* to the optional parameter
    `x`—the compiler bakes the value 23 into the compiled code at the *calling* side.
    The preceding call to `Foo` is semantically identical to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: because the compiler simply substitutes the default value of an optional parameter
    wherever it is used.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Adding an optional parameter to a public method that’s called from another assembly
    requires recompilation of both assemblies—just as though the parameter were mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: The default value of an optional parameter must be specified by a constant expression,
    a parameterless constructor of a value type, or a `default` expression. Optional
    parameters cannot be marked with `ref` or `out`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mandatory parameters must occur *before* optional parameters in both the method
    declaration and the method call (the exception is with `params` arguments, which
    still always come last). In the following example, the explicit value of `1` is
    passed to `x`, and the default value of `0` is passed to `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: You can do the converse (pass a default value to `x` and an explicit value to
    `y`) by combining optional parameters with *named arguments*.
  prefs: []
  type: TYPE_NORMAL
- en: Named arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Rather than identifying an argument by position, you can identify an argument
    by name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'Named arguments can occur in any order. The following calls to `Foo` are semantically
    identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'A subtle difference is that argument expressions are evaluated in the order
    in which they appear at the *calling* site. In general, this makes a difference
    only with interdependent side-effecting expressions such as the following, which
    writes `0, 1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you would almost certainly avoid writing such code in practice!
  prefs: []
  type: TYPE_NORMAL
- en: 'You can mix named and positional arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there is a restriction: positional arguments must come before named
    arguments unless they are used in the correct position. So, you could call `Foo`
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'But not like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'Named arguments are particularly useful in conjunction with optional parameters.
    For instance, consider the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'You can call this supplying only a value for `d`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: This is particularly useful when calling COM APIs, which we discuss in detail
    in [Chapter 24](ch24.html#native_and_com_interoperabilit).
  prefs: []
  type: TYPE_NORMAL
- en: Ref Locals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A somewhat esoteric feature of C# is that you can define a local variable that
    *references* an element in an array or field in an object (from C# 7):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `numRef` is a *reference* to `numbers[2]`. When we modify
    `numRef`, we modify the array element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: The target for a ref local must be an array element, field, or local variable;
    it cannot be a *property* ([Chapter 3](ch03.html#creating_types_in_chash)). *Ref
    locals* are intended for specialized micro-optimization scenarios and are typically
    used in conjunction with *ref returns*.
  prefs: []
  type: TYPE_NORMAL
- en: Ref Returns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `Span<T>` and `ReadOnlySpan<T>` types that we describe in [Chapter 23](ch23.html#spanless_thantgreater_than_and-id00089)
    use ref returns to implement a highly efficient indexer. Outside such scenarios,
    ref returns are not commonly used, and you can consider them a micro-optimization
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can return a *ref local* from a method. This is called a *ref return*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'If you omit the `ref` modifier on the calling side, it reverts to returning
    an ordinary value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'You also can use ref returns when defining a property or indexer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'Such a property is implicitly writable, despite there being no `set` accessor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'You can prevent such modification by using `ref readonly`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ref readonly` modifier prevents modification while still enabling the
    performance gain of returning by reference. The gain would be very small in this
    case, because `x` is of type `string` (a reference type): no matter how long the
    `string`, the only inefficiency that you can hope to avoid is the copying of a
    single 32- or 64-bit *reference*. Real gains can occur with custom value types
    (see [“Structs”](ch03.html#structs)), but only if the struct is marked as `readonly`
    (otherwise, the compiler will perform a defensive copy).'
  prefs: []
  type: TYPE_NORMAL
- en: Attempting to define an explicit `set` accessor on a *ref return* property or
    indexer is illegal.
  prefs: []
  type: TYPE_NORMAL
- en: var—Implicitly Typed Local Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is often the case that you declare and initialize a variable in one step.
    If the compiler is able to infer the type from the initialization expression,
    you can use the keyword `var` in place of the type declaration; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'This is precisely equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'Because of this direct equivalence, implicitly typed variables are statically
    typed. For example, the following generates a compile-time error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`var` can decrease code readability when you can’t deduce the type purely by
    looking at the variable declaration. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: What type is `x`?
  prefs: []
  type: TYPE_NORMAL
- en: In [“Anonymous Types”](ch04.html#anonymous_types), we will describe a scenario
    in which the use of `var` is mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: Target-Typed new Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way to reduce lexical repetition is with *target-typed* `new` *expressions*
    (from C# 9):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'This is precisely equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'The principle is that you can call `new` without specifying a type name if
    the compiler is able to unambiguously infer it. Target-typed `new` expressions
    are particularly useful when the variable declaration and initialization are in
    different parts of your code. A common example is when you want to initialize
    a field in a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'Target-typed `new` expressions are also helpful in the following scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: Expressions and Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An *expression* essentially denotes a value. The simplest kinds of expressions
    are constants and variables. Expressions can be transformed and combined using
    operators. An *operator* takes one or more input *operands* to output a new expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a *constant expression*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `*` operator to combine two operands (the literal expressions
    `12` and `30`), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'We can build complex expressions because an operand can itself be an expression,
    such as the operand `(12 * 30)` in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: Operators in C# can be classed as *unary*, *binary*, or *ternary*, depending
    on the number of operands they work on (one, two, or three). The binary operators
    always use *infix* notation in which the operator is placed *between* the two
    operands.
  prefs: []
  type: TYPE_NORMAL
- en: Primary Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Primary expressions include expressions composed of operators that are intrinsic
    to the basic plumbing of the language. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: This expression is composed of two primary expressions. The first expression
    performs a member lookup (with the `.` operator), and the second expression performs
    a method call (with the `()` operator).
  prefs: []
  type: TYPE_NORMAL
- en: Void Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A void expression is an expression that has no value, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'Because it has no value, you cannot use a void expression as an operand to
    build more complex expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: Assignment Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An assignment expression uses the `=` operator to assign the result of another
    expression to a variable; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'An assignment expression is not a void expression—it has a value of whatever
    was assigned, and so can be incorporated into another expression. In the following
    example, the expression assigns `2` to `x` and `10` to `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use this style of expression to initialize multiple values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'The *compound assignment operators* are syntactic shortcuts that combine assignment
    with another operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '(A subtle exception to this rule is with *events*, which we describe in [Chapter 4](ch04.html#advanced_chash):
    the `+=` and `-=` operators here are treated specially and map to the event’s
    `add` and `remove` accessors.)'
  prefs: []
  type: TYPE_NORMAL
- en: Operator Precedence and Associativity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an expression contains multiple operators, *precedence* and *associativity*
    determine the order of their evaluation. Operators with higher precedence execute
    before operators of lower precedence. If the operators have the same precedence,
    the operator’s associativity determines the order of evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: Precedence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'is evaluated as follows because `*` has a higher precedence than `+`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: Left-associative operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Binary operators (except for assignment, lambda, and null-coalescing operators)
    are *left-associative*; in other words, they are evaluated from left to right.
    For example, the following expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'is evaluated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: 'You can insert parentheses to change the actual order of evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: Right-associative operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *assignment operators* as well as the lambda, null-coalescing, and conditional
    operators are *right-associative*; in other words, they are evaluated from right
    to left.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right associativity allows multiple assignments such as the following to compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: This first assigns `3` to `y` and then assigns the result of that expression
    (`3`) to `x`.
  prefs: []
  type: TYPE_NORMAL
- en: Operator Table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 2-3](#chash_operators_left_parenthesiscategor) lists C#’s operators
    in order of precedence. Operators in the same category have the same precedence.'
  prefs: []
  type: TYPE_NORMAL
- en: We explain user-overloadable operators in [“Operator Overloading”](ch04.html#operator_overloading).
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-3\. C# operators (categories in order of precedence)
  prefs: []
  type: TYPE_NORMAL
- en: '| Category | Operator symbol | Operator name | Example | User-overloadable
    |  |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Primary | `.` | Member access | `x.y` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `?.` and `?[]` | Null-conditional | `x?.y` or `x?[0]` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `!` (postfix) | Null-forgiving | `x!.y` or `x![0]` | No |'
  prefs: []
  type: TYPE_TB
- en: '|  | `->` (unsafe) | Pointer to struct | `x->y` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `()` | Function call | `x()` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `[]` | Array/index | `a[x]` | Via indexer |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `++` | Post-increment | `x++` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `−−` | Post-decrement | `x−−` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `new` | Create instance | `new Foo()` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `stackalloc` | Stack allocation | `stackalloc(10)` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `typeof` | Get type from identifier | `typeof(int)` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `nameof` | Get name of identifier | `nameof(x)` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `checked` | Integral overflow check on | `checked(x)` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `unchecked` | Integral overflow check off | `unchecked(x)` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `default` | Default value | `default(char)` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '| Unary | `await` | Await | `await myTask` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `sizeof` | Get size of struct | `sizeof(int)` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `+` | Positive value of | `+x` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `−` | Negative value of | `−x` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `!` | Not | `!x` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `~` | Bitwise complement | `~x` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `++` | Pre-increment | `++x` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `−−` | Pre-decrement | `−−x` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `()` | Cast | `(int)x` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `^` | Index from end | `array[^1]` | No |'
  prefs: []
  type: TYPE_TB
- en: '|  | `*` (unsafe) | Value at address | `*x` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `&` (unsafe) | Address of value | `&x` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '| Range | `..` `..^` | Range of indices | `x..y` `x..^y` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '| Switch & with | `switch` | Switch expression | `num switch {` `1 => true,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`_ => false`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}` | No |'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | `with` | With expression | `rec with` `{ X = 123 }` | No |'
  prefs: []
  type: TYPE_TB
- en: '| Multiplicative | `*` | Multiply | `x * y` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `/` | Divide | `x / y` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `%` | Remainder | `x % y` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| Additive | `+` | Add | `x + y` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `−` | Subtract | `x − y` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| Shift | `<<` | Shift left | `x << 1` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `>>` | Shift right | `x >> 1` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `>>>` | Unsigned shift right | `x >>> 1` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| Relational | `<` | Less than | `x < y` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `>` | Greater than | `x > y` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `<=` | Less than or equal to | `x <= y` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `>=` | Greater than or equal to | `x >= y` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `is` | Type is or is subclass of | `x is y` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `as` | Type conversion | `x as y` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '| Equality | `==` | Equals | `x == y` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `!=` | Not equals | `x != y` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| Bitwise And | `&` | And | `x & y` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| Bitwise Xor | `^` | Exclusive Or | `x ^ y` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| Bitwise Or | `&#124;` | Or | `x &#124; y` | Yes |  |'
  prefs: []
  type: TYPE_TB
- en: '| Conditional And | `&&` | Conditional And | `x && y` | Via `&` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Conditional Or | `&#124;&#124;` | Conditional Or | `x &#124;&#124; y` | Via
    `&#124;` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Null coalescing | `??` | Null coalescing | `x ?? y` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '| Conditional | `?:` | Conditional | `isTrue ? thenThis : elseThis` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '| Assignment and lambda | `=` | Assign | `x = y` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `*=` | Multiply self by | `x *= 2` | Via `*` |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `/=` | Divide self by | `x /= 2` | Via `/` |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `%=` | Remainder & assign to self | `x %= 2` |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `+=` | Add to self | `x += 2` | Via `+` |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `−=` | Subtract from self | `x −= 2` | Via `−` |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `<<=` | Shift self left by | `x <<= 2` | Via `<<` |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `>>=` | Shift self right by | `x >>= 2` | Via `>>` |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `>>>=` | Unsigned shift self right by | `x >>>= 2` | Via `>>>` |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `&=` | And self by | `x &= 2` | Via `&` |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `^=` | Exclusive-Or self by | `x ^= 2` | Via `^` |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `&#124;=` | Or self by | `x &#124;= 2` | Via `&#124;` |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `??=` | Null-coalescing assignment | `x ??= 0` | No |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `=>` | Lambda | `x => x + 1` | No |  |'
  prefs: []
  type: TYPE_TB
- en: Null Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C# provides three operators to make it easier to work with nulls: the *null-coalescing
    operator*, the *null-coalescing assignment operator*, and the *null-conditional
    operator*.'
  prefs: []
  type: TYPE_NORMAL
- en: Null-Coalescing Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `??` operator is the *null-coalescing operator*. It says, “If the operand
    to the left is non-null, give it to me; otherwise, give me another value.” For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: If the lefthand expression is non-null, the righthand expression is never evaluated.
    The null-coalescing operator also works with nullable value types (see [“Nullable
    Value Types”](ch04.html#nullable_value_types)).
  prefs: []
  type: TYPE_NORMAL
- en: Null-Coalescing Assignment Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `??=` operator (introduced in C# 8) is the *null-coalescing assignment
    operator*. It says, “If the operand to the left is null, assign the right operand
    to the left operand.” Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: The `??=` operator is particularly useful in implementing lazily calculated
    properties. We’ll cover this topic later, in [“Calculated Fields and Lazy Evaluation”](ch04.html#calculated_fields_and_lazy_evaluation).
  prefs: []
  type: TYPE_NORMAL
- en: Null-Conditional Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `?.` operator is the *null-conditional* or “Elvis” operator (after the
    Elvis emoticon). It allows you to call methods and access members just like the
    standard dot operator except that if the operand on the left is null, the expression
    evaluates to null instead of throwing a `NullReferenceException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'The last line is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: 'Null-conditional expressions also work with indexers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon encountering a null, the Elvis operator short-circuits the remainder of
    the expression. In the following example, `s` evaluates to null, even with a standard
    dot operator between `ToString()` and `ToUpper()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'Repeated use of Elvis is necessary only if the operand immediately to its left
    might be null. The following expression is robust to both `x` being null and `x.y`
    being null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: 'It is equivalent to the following (except that `x.y` is evaluated only once):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'The final expression must be capable of accepting a null. The following is
    illegal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'We can fix this with the use of nullable value types (see [“Nullable Value
    Types”](ch04.html#nullable_value_types)). If you’re already familiar with nullable
    value types, here’s a preview:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the null-conditional operator to call a void method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: If `someObject` is null, this becomes a “no-operation” rather than throwing
    a `NullReferenceException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the null-conditional operator with the commonly used type members
    that we describe in [Chapter 3](ch03.html#creating_types_in_chash), including
    *methods*, *fields*, *properties*, and *indexers*. It also combines well with
    the *null-coalescing operator*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: Statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions comprise statements that execute sequentially in the textual order
    in which they appear. A *statement block* is a series of statements appearing
    between braces (the `{}` tokens).
  prefs: []
  type: TYPE_NORMAL
- en: Declaration Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A variable declaration introduces a new variable, optionally initializing it
    with an expression. You may declare multiple variables of the same type in a comma-separated
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: 'A constant declaration is like a variable declaration except that it cannot
    be changed after it has been declared, and the initialization must occur with
    the declaration (see [“Constants”](ch03.html#constants)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: Local variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The scope of a local variable or local constant extends throughout the current
    block. You cannot declare another local variable with the same name in the current
    block or in any nested blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A variable’s scope extends in *both directions* throughout its code block. This
    means that if we moved the initial declaration of `x` in this example to the bottom
    of the method, we’d get the same error. This is in contrast to C++ and is somewhat
    peculiar, given that it’s not legal to refer to a variable or constant before
    it’s declared.
  prefs: []
  type: TYPE_NORMAL
- en: Expression Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Expression statements are expressions that are also valid statements. An expression
    statement must either change state or call something that might change state.
    Changing state essentially means changing a variable. Following are the possible
    expression statements:'
  prefs: []
  type: TYPE_NORMAL
- en: Assignment expressions (including increment and decrement expressions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method call expressions (both void and nonvoid)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object instantiation expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: 'When you call a constructor or a method that returns a value, you’re not obliged
    to use the result. However, unless the constructor or method changes state, the
    statement is completely useless:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: Selection Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C# has the following mechanisms to conditionally control the flow of program
    execution:'
  prefs: []
  type: TYPE_NORMAL
- en: Selection statements (`if`, `switch`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional operator (`?:`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loop statements (`while`, `do`-`while`, `for`, `foreach`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This section covers the simplest two constructs: the `if` statement and the
    `switch` statement.'
  prefs: []
  type: TYPE_NORMAL
- en: The if statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An `if` statement executes a statement if a `bool` expression is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: 'The statement can be a code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: The else clause
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An `if` statement can optionally feature an `else` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'Within an `else` clause, you can nest another `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: Changing the flow of execution with braces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An `else` clause always applies to the immediately preceding `if` statement
    in the statement block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'This is semantically identical to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: 'We can change the execution flow by moving the braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: 'With braces, you explicitly state your intention. This can improve the readability
    of nested `if` statements—even when not required by the compiler. A notable exception
    is with the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’ve arranged the `if` and `else` statements to mimic the “elseif” construct
    of other languages (and C#’s `#elif` preprocessor directive). Visual Studio’s
    auto-formatting recognizes this pattern and preserves the indentation. Semantically,
    though, each `if` statement following an `else` statement is functionally nested
    within the `else` clause.
  prefs: []
  type: TYPE_NORMAL
- en: The switch statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`switch` statements let you branch program execution based on a selection of
    possible values that a variable might have. `switch` statements can result in
    cleaner code than multiple `if` statements because `switch` statements require
    an expression to be evaluated only once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: This example demonstrates the most common scenario, which is switching on *constants*.
    When you specify a constant, you’re restricted to the built-in numeric types and
    the `bool`, `char`, `string`, and `enum` types.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of each `case` clause, you must specify explicitly where execution
    is to go next, with some kind of jump statement (unless your code ends in an infinite
    loop). Here are the options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`break` (jumps to the end of the `switch` statement)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`goto case *x*` (jumps to another `case` clause)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`goto default` (jumps to the `default` clause)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any other jump statement—namely, `return`, `throw`, `continue`, or `goto *label*`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When more than one value should execute the same code, you can list the common
    `case`s sequentially:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: This feature of a `switch` statement can be pivotal in terms of producing cleaner
    code than multiple `if`-`else` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Switching on types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Switching on a type is a special case of switching on a *pattern.* A number
    of other patterns have been introduced in recent versions of C#; see [“Patterns”](ch04.html#patterns)
    for a full discussion.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also switch on *types* (from C# 7):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: (The `object` type allows for a variable of any type; we discuss this fully
    in [“Inheritance”](ch03.html#inheritance) and [“The object Type”](ch03.html#the_object_type).)
  prefs: []
  type: TYPE_NORMAL
- en: Each *case* clause specifies a type upon which to match, and a variable upon
    which to assign the typed value if the match succeeds (the “pattern” variable).
    Unlike with constants, there’s no restriction on what types you can use.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can predicate a `case` with the `when` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: The order of the case clauses can matter when switching on type (unlike when
    switching on constants). This example would give a different result if we reversed
    the two cases (in fact, it would not even compile, because the compiler would
    determine that the second case is unreachable). An exception to this rule is the
    `default` clause, which is always executed last, regardless of where it appears.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can stack multiple case clauses. The `Console.WriteLine` in the following
    code will execute for any floating-point type greater than 1,000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the compiler lets us consume the pattern variables `f`, `d`,
    and `m`, *only* in the `when` clauses. When we call `Console.WriteLine`, it’s
    unknown which one of those three variables will be assigned, so the compiler puts
    all of them out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can mix and match constants and patterns in the same switch statement.
    And you can also switch on the null value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: Switch expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From C# 8, you can use `switch` in the context of an *expression*. Assuming
    that `cardNumber` is of type `int`, the following illustrates its use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `switch` keyword appears *after* the variable name, and that
    the case clauses are expressions (terminated by commas) rather than statements.
    Switch expressions are more compact than their switch statement counterparts,
    and you can use them in LINQ queries ([Chapter 8](ch08.html#linq_queries)).
  prefs: []
  type: TYPE_NORMAL
- en: If you omit the default expression (`_`) and the switch fails to match, an exception
    is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also switch on multiple values (the *tuple* pattern):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: Many more options are possible through the use of *patterns* (see [“Patterns”](ch04.html#patterns)).
  prefs: []
  type: TYPE_NORMAL
- en: Iteration Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C# enables a sequence of statements to execute repeatedly with the `while`,
    `do-while`, `for`, and `foreach` statements.
  prefs: []
  type: TYPE_NORMAL
- en: while and do-while loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`while` loops repeatedly execute a body of code while a `bool` expression is
    true. The expression is tested *before* the body of the loop is executed. For
    example, the following writes `012`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '`do-while` loops differ in functionality from `while` loops only in that they
    test the expression *after* the statement block has executed (ensuring that the
    block is always executed at least once). Here’s the preceding example rewritten
    with a `do-while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: for loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`for` loops are like `while` loops with special clauses for *initialization*
    and *iteration* of a loop variable. A `for` loop contains three clauses as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s what each clause does:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialization clause
  prefs: []
  type: TYPE_NORMAL
- en: Executed before the loop begins; used to initialize one or more *iteration*
    variables
  prefs: []
  type: TYPE_NORMAL
- en: Condition clause
  prefs: []
  type: TYPE_NORMAL
- en: The `bool` expression that, while true, will execute the body
  prefs: []
  type: TYPE_NORMAL
- en: Iteration clause
  prefs: []
  type: TYPE_NORMAL
- en: Executed *after* each iteration of the statement block; used typically to update
    the iteration variable
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following prints the numbers 0 through 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: 'The following prints the first 10 Fibonacci numbers (in which each number is
    the sum of the previous two):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: 'Any of the three parts of the `for` statement can be omitted. You can implement
    an infinite loop such as the following (though `while(true)` can be used, instead):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: foreach loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `foreach` statement iterates over each element in an enumerable object.
    Most of the .NET types that represent a set or list of elements are enumerable.
    For example, both an array and a string are enumerable. Here is an example of
    enumerating over the characters in a string, from the first character through
    to the last:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: We define enumerable objects in [“Enumeration and Iterators”](ch04.html#enumeration_and_iterators).
  prefs: []
  type: TYPE_NORMAL
- en: Jump Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The C# jump statements are `break`, `continue`, `goto`, `return`, and `throw`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Jump statements obey the reliability rules of `try` statements (see [“try Statements
    and Exceptions”](ch04.html#try_statements_and_exceptions)). This means that:'
  prefs: []
  type: TYPE_NORMAL
- en: A jump out of a `try` block always executes the `try`’s `finally` block before
    reaching the target of the jump.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A jump cannot be made from the inside to the outside of a `finally` block (except
    via `throw`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The break statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `break` statement ends the execution of the body of an iteration or `switch`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: The continue statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `continue` statement forgoes the remaining statements in a loop and makes
    an early start on the next iteration. The following loop skips even numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: The goto statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `goto` statement transfers execution to another label within a statement
    block. The form is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, when used within a `switch` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: 'A label is a placeholder in a code block that precedes a statement, denoted
    with a colon suffix. The following iterates the numbers 1 through 5, mimicking
    a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: The `goto case *case-constant*` transfers execution to another case in a `switch`
    block (see [“The switch statement”](#the_switch_statement)).
  prefs: []
  type: TYPE_NORMAL
- en: The return statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `return` statement exits the method and must return an expression of the
    method’s return type if the method is nonvoid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: A `return` statement can appear anywhere in a method (except in a `finally`
    block), and can be used more than once.
  prefs: []
  type: TYPE_NORMAL
- en: The throw statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `throw` statement throws an exception to indicate an error has occurred
    (see [“try Statements and Exceptions”](ch04.html#try_statements_and_exceptions)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: Miscellaneous Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `using` statement provides an elegant syntax for calling `Dispose` on objects
    that implement `IDisposable`, within a `finally` block (see [“try Statements and
    Exceptions”](ch04.html#try_statements_and_exceptions) and [“IDisposable, Dispose,
    and Close”](ch12.html#idisposablecomma_disposecomma_and_close)).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: C# overloads the `using` keyword to have independent meanings in different contexts.
    Specifically, the `using` *directive* is different from the `using` *statement*.
  prefs: []
  type: TYPE_NORMAL
- en: The `lock` statement is a shortcut for calling the `Enter` and `Exit` methods
    of the `Monitor` class (see Chapters [14](ch14.html#concurrency_and_asynchron)
    and [23](ch23.html#spanless_thantgreater_than_and-id00089)).
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A namespace is a domain for type names. Types are typically organized into
    hierarchical namespaces, making them easier to find and avoiding conflicts. For
    example, the `RSA` type that handles public key encryption is defined within the
    following namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: 'A namespace forms an integral part of a type’s name. The following code calls
    `RSA`’s `Create` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Namespaces are independent of assemblies, which are *.dll* files that serve
    as units of deployment (described in [Chapter 17](ch17.html#assemblies)).
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces also have no impact on member visibility—`public`, `internal`, `private`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `namespace` keyword defines a namespace for types within that block; for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: 'The dots in the namespace indicate a hierarchy of nested namespaces. The code
    that follows is semantically identical to the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: You can refer to a type with its *fully qualified name*, which includes all
    namespaces from the outermost to the innermost. For example, we could refer to
    `Class1` in the preceding example as `Outer.Middle.Inner.Class1`.
  prefs: []
  type: TYPE_NORMAL
- en: Types not defined in any namespace are said to reside in the *global namespace*.
    The global namespace also includes top-level namespaces, such as `Outer` in our
    example.
  prefs: []
  type: TYPE_NORMAL
- en: File-Scoped Namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often, you will want all the types in a file to be defined in one namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: 'From C# 10, you can accomplish this with a *file-scoped namespace*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: File-scoped namespaces reduce clutter and eliminate an unnecessary level of
    indentation.
  prefs: []
  type: TYPE_NORMAL
- en: The using Directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `using` directive *imports* a namespace, allowing you to refer to types
    without their fully qualified names. The following imports the previous example’s
    `Outer​.Mid⁠dle.Inner` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It’s legal (and often desirable) to define the same type name in different namespaces.
    However, you’d typically do so only if it was unlikely for a consumer to want
    to import both namespaces at once. A good example is the `TextBox` class, which
    is defined both in `System.Windows.Controls` (WPF) and `System.Windows.Forms`
    (Windows Forms).
  prefs: []
  type: TYPE_NORMAL
- en: A `using` directive can be nested within a namespace itself to limit the scope
    of the directive.
  prefs: []
  type: TYPE_NORMAL
- en: The global using Directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From C# 10, if you prefix a `using` directive with the `global` keyword, the
    directive will apply to all files in the project or compilation unit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: This lets you centralize common imports and avoid repeating the same directives
    in every file.
  prefs: []
  type: TYPE_NORMAL
- en: '`global using` directives must precede nonglobal directives and cannot appear
    inside namespace declarations. The global directive can be used with `using static`.'
  prefs: []
  type: TYPE_NORMAL
- en: Implicit global usings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From .NET 6, project files allow for implicit `global using` directives. If
    the `Implici⁠t​Usings` element is set to true in the project file (the default
    for new projects), the following namespaces are automatically imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: Additional namespaces are imported, based on the project SDK (Web, Windows Forms,
    WPF, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: using static
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `using static` directive imports a *type* rather than a namespace. All
    static members of the imported type can then be used without qualification. In
    the following example, we call the `Console` class’s static `WriteLine` method
    without needing to refer to the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: 'The `using static` directive imports all accessible static members of the type,
    including fields, properties, and nested types ([Chapter 3](ch03.html#creating_types_in_chash)).
    You can also apply this directive to enum types ([Chapter 3](ch03.html#creating_types_in_chash)),
    in which case their members are imported. So, if we import the following enum
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: 'we can specify `Hidden` instead of `Visibility.Hidden`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: Should an ambiguity arise between multiple static imports, the C# compiler is
    not smart enough to infer the correct type from the context and will generate
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: Rules Within a Namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Name scoping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Names declared in outer namespaces can be used unqualified within inner namespaces.
    In this example, `Class1` does not need qualification within `Inner`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to refer to a type in a different branch of your namespace hierarchy,
    you can use a partially qualified name. In the following example, we base `SalesReport`
    on `Common.ReportBase`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: Name hiding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the same type name appears in both an inner and an outer namespace, the
    inner name wins. To refer to the type in the outer namespace, you must qualify
    its name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: All type names are converted to fully qualified names at compile time. Intermediate
    Language (IL) code contains no unqualified or partially qualified names.
  prefs: []
  type: TYPE_NORMAL
- en: Repeated namespaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can repeat a namespace declaration, as long as the type names within the
    namespaces don’t conflict:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: We can even break the example into two source files such that we could compile
    each class into a different assembly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Source file 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: 'Source file 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: Nested using directives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can nest a `using` directive within a namespace. This allows you to scope
    the `using` directive within a namespace declaration. In the following example,
    `Class1` is visible in one scope but not in another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: Aliasing Types and Namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Importing a namespace can result in type-name collision. Rather than importing
    the entire namespace, you can import just the specific types that you need, giving
    each type an alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: 'An entire namespace can be aliased, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: Alias any type (C# 12)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From C# 12, the `using` directive can alias any kind of type, including, for
    instance, arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: You can also alias tuples—we cover this in [“Aliasing Tuples (C# 12)”](ch04.html#aliasing_tuples_left_parenthesischash_o).
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Namespace Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Extern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Extern aliases allow your program to reference two types with the same fully
    qualified name (i.e., the namespace and type name are identical). This is an unusual
    scenario and can occur only when the two types come from different assemblies.
    Consider the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Library 1, compiled to *Widgets1.dll*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: 'Library 2, compiled to *Widgets2.dll*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: 'Application, which references *Widgets1.dll* and *Widgets2.dll*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: 'The application cannot compile, because `Widget` is ambiguous. Extern aliases
    can resolve the ambiguity. The first step is to modify the application’s *.csproj*
    file, assigning a unique alias to each reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: 'The second step is to use the `extern alias` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: Namespace alias qualifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, names in inner namespaces hide names in outer namespaces.
    However, sometimes even the use of a fully qualified type name does not resolve
    the conflict. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: The `Main` method could be instantiating either the nested class `B`, or the
    class `B` within the namespace `A`. The compiler always gives higher precedence
    to identifiers in the current namespace (in this case, the nested `B` class).
  prefs: []
  type: TYPE_NORMAL
- en: 'To resolve such conflicts, a namespace name can be qualified, relative to one
    of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The global namespace—the root of all namespaces (identified with the contextual
    keyword `global`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The set of extern aliases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `::` token performs namespace alias qualification. In this example, we
    qualify using the global namespace (this is most commonly seen in autogenerated
    code to avoid name conflicts):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of qualifying with an alias (adapted from the example in
    [“Extern”](#extern)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: ^([1](ch02.html#ch01fn1-marker)) A minor caveat is that very large `long` values
    lose some precision when converted to `double`.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch02.html#ch01fn2-marker)) Technically, `decimal` is a floating-point
    type, too, although it’s not referred to as such in the C# language specification.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch02.html#ch01fn3-marker)) It’s possible to *overload* these operators
    ([Chapter 4](ch04.html#advanced_chash)) such that they return a non-`bool` type,
    but this is almost never done in practice.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch02.html#ch01fn4-marker)) An exception to this rule is when calling Component
    Object Model (COM) methods. We discuss this in [Chapter 25](ch25.html#regular_expressions-id00102).
  prefs: []
  type: TYPE_NORMAL
