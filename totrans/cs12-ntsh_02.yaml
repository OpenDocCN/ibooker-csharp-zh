- en: Chapter 2\. C# Language Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 C#语言基础
- en: In this chapter, we introduce the basics of the C# language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了C#语言的基础知识。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Almost all of the code listings in this book are available as interactive samples
    in LINQPad. Working through these samples in conjunction with the book accelerates
    learning in that you can edit the samples and instantly see the results without
    needing to set up projects and solutions in Visual Studio.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的几乎所有代码清单都可以在LINQPad中作为交互式示例使用。通过与书籍一起使用这些示例，可以加速学习，因为您可以编辑示例并立即查看结果，而不需要在Visual
    Studio中设置项目和解决方案。
- en: To download the samples, in LINQPad, click the Samples tab, and then click “Download
    more samples.” LINQPad is free—go to [http://*www.linqpad.net*](http://www.linqpad.net).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载示例，请在 LINQPad 中点击“示例”选项卡，然后点击“下载更多示例”。LINQPad 是免费的—请访问 [http://*www.linqpad.net*](http://www.linqpad.net)。
- en: A First C# Program
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个C#程序
- en: 'Following is a program that multiplies 12 by 30 and prints the result, 360,
    to the screen. The double forward slash indicates that the remainder of a line
    is a *comment*:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个程序，它将12乘以30并将结果360打印到屏幕上。双斜杠表示行的余下部分是一个 *注释*：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Our program consists of two *statements*. Statements in C# execute sequentially
    and are terminated by a semicolon. The first statement computes the *expression*
    `12 * 30` and stores the result in a *variable*, named `x`, whose type is a 32-bit
    integer (`int`). The second statement calls the `WriteLine` *method* on a *class*
    called `Console`, which is defined in a *namespace* called `System`. This prints
    the variable `x` to a text window on the screen.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序由两个 *语句* 组成。C# 中的语句按顺序执行，并以分号结束。第一个语句计算 *表达式* `12 * 30` 并将结果存储在一个名为 `x`
    的 *变量* 中，其类型为32位整数（`int`）。第二个语句调用名为 `WriteLine` 的 *方法*，在名为 `Console` 的 *类* 上调用，该类在名为
    `System` 的 *命名空间* 中定义。这将把变量 `x` 打印到屏幕上的文本窗口中。
- en: A method performs a function; a class groups function members and data members
    to form an object-oriented building block. The `Console` class groups members
    that handle command-line input/output (I/O) functionality, such as the `WriteLine`
    method. A class is a kind of *type*, which we examine in [“Type Basics”](#type_basics).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方法执行一个功能；一个类将功能成员和数据成员组合起来形成一个面向对象的构建块。`Console`类组合了处理命令行输入/输出（I/O）功能的成员，比如`WriteLine`方法。类是一种
    *类型*，我们在 [“类型基础”](#type_basics) 中进行讨论。
- en: At the outermost level, types are organized into *namespaces*. Many commonly
    used types—including the `Console` class—reside in the `System` namespace. The
    .NET libraries are organized into nested namespaces. For example, the `System.Text`
    namespace contains types for handling text, and `System.IO` contain types for
    input/output.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在最外层级别，类型被组织成 *命名空间*。许多常用的类型—包括 `Console` 类—位于 `System` 命名空间中。.NET库被组织成嵌套的命名空间。例如，`System.Text`
    命名空间包含用于处理文本的类型，而 `System.IO` 包含用于输入/输出的类型。
- en: 'Qualifying the `Console` class with the `System` namespace on every use adds
    clutter. The `using` directive lets you avoid this clutter by *importing* a namespace:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次使用时用 `System` 命名空间限定 `Console` 类会增加混乱。`using` 指令允许您通过 *导入* 命名空间来避免此混乱：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A basic form of code reuse is to write higher-level functions that call lower-level
    functions. We can *refactor* our program with a reusable *method* called `FeetToInches`
    that multiplies an integer by 12, as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 代码重用的一种基本形式是编写调用低级函数的高级函数。我们可以使用可重用的 *方法* `FeetToInches` 重构我们的程序，该方法将整数乘以12，如下所示：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our method contains a series of statements surrounded by a pair of braces. This
    is called a *statement block*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法包含一系列语句，这些语句被一对大括号包围。这被称为 *语句块*。
- en: 'A method can receive *input* data from the caller by specifying *parameters*
    and *output* data back to the caller by specifying a *return type*. Our `FeetToInches`
    method has a parameter for inputting feet, and a return type for outputting inches:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 方法可以通过指定 *参数* 从调用者那里接收 *输入* 数据，并通过指定 *返回类型* 将 *输出* 数据返回给调用者。我们的 `FeetToInches`
    方法有一个用于输入英尺的参数，以及一个用于输出英寸的返回类型：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The *literals* `30` and `100` are the *arguments* passed to the `FeetToInches`
    method.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*字面量* `30` 和 `100` 是传递给`FeetToInches`方法的 *参数*。'
- en: 'If a method doesn’t receive input, use empty parentheses. If it doesn’t return
    anything, use the `void` keyword:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个方法不接收输入，使用空括号。如果它不返回任何内容，使用`void`关键字：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Methods are one of several kinds of functions in C#. Another kind of function
    we used in our example program was the `*` *operator*, which performs multiplication.
    There are also *constructors*, *properties*, *events*, *indexers*, and *finalizers*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是 C# 中几种函数的一种。我们在示例程序中使用的另一种函数是执行乘法的 `*` *运算符*。还有 *构造函数*、*属性*、*事件*、*索引器* 和
    *终结器*。
- en: Compilation
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译
- en: The C# compiler compiles source code (a set of files with the *.cs* extension)
    into an *assembly*. An assembly is the unit of packaging and deployment in .NET.
    An assembly can be either an *application* or a *library*. A normal console or
    Windows application has an *entry point*, whereas a library does not. The purpose
    of a library is to be called upon (*referenced*) by an application or by other
    libraries. .NET itself is a set of libraries (as well as a runtime environment).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: C# 编译器将源代码（具有 *.cs* 扩展名的一组文件）编译成一个 *程序集*。程序集是 .NET 中的打包和部署单元。程序集可以是 *应用程序* 或
    *库*。普通的控制台或 Windows 应用程序有一个 *入口点*，而库则没有。库的目的是被应用程序或其他库调用（*引用*）。.NET 本身是一组库（以及运行时环境）。
- en: Each of the programs in the preceding section began directly with a series of
    statements (called *top-level statements*). The presence of top-level statements
    implicitly creates an entry point for a console or Windows application. (Without
    top-level statements, a *Main method* denotes an application’s entry point—see
    [“Custom Types”](#custom_types).)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 前面部分的每个程序直接以一系列语句（称为 *顶级语句*）开始。顶级语句的存在隐含地创建了一个控制台或 Windows 应用程序的入口点。（没有顶级语句时，*Main
    方法* 表示应用程序的入口点，请参阅 [“自定义类型”](#custom_types)。）
- en: Note
  id: totrans-25
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike .NET Framework, .NET 8 assemblies never have a *.exe* extension. The
    *.exe* that you see after building a .NET 8 application is a platform-specific
    native loader responsible for starting your application’s *.dll* assembly.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 不同于 .NET Framework，.NET 8 程序集从不使用 *.exe* 扩展名。在构建 .NET 8 应用程序后看到的 *.exe* 是一个特定于平台的本机加载器，负责启动您的应用程序的
    *.dll* 程序集。
- en: .NET 8 also allows you to create a self-contained deployment that includes the
    loader, your assemblies, and the required portions of the .NET runtime—all in
    a single *.exe* file. .NET 8 also allows ahead-of-time (AOT) compilation, where
    the executable contains precompiled native code for faster startup and reduced
    memory consumption.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 8 还允许您创建自包含部署，其中包括加载器、您的程序集以及所需的 .NET 运行时部分，全部打包在单个 *.exe* 文件中。.NET 8 还支持提前（AOT）编译，可使可执行文件包含预编译的本机代码，从而加快启动速度并减少内存消耗。
- en: The `dotnet` tool (*dotnet.exe* on Windows) helps you to manage .NET source
    code and binaries from the command line. You can use it to both build and run
    your program, as an alternative to using an integrated development environment
    (IDE) such as Visual Studio or Visual Studio Code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`dotnet` 工具（在 Windows 上为 *dotnet.exe*）可帮助您从命令行管理 .NET 源代码和二进制文件。您可以使用它来构建和运行程序，作为使用集成开发环境（如
    Visual Studio 或 Visual Studio Code）的替代方案。'
- en: You can obtain the `dotnet` tool either by installing the .NET 8 SDK or by installing
    Visual Studio. Its default location is *%ProgramFiles%\dotnet* on Windows or */usr/bin/dotnet*
    on Ubuntu Linux.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过安装 .NET 8 SDK 或安装 Visual Studio 来获取 `dotnet` 工具。它在 Windows 上的默认位置为 *%ProgramFiles%\dotnet*，在
    Ubuntu Linux 上为 */usr/bin/dotnet*。
- en: 'To compile an application, the `dotnet` tool requires a *project file* as well
    as one or more C# files. The following command *scaffolds* a new console project
    (creates its basic structure):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译一个应用程序，`dotnet` 工具需要一个 *项目文件* 以及一个或多个 C# 文件。以下命令创建一个新的控制台项目（创建其基本结构）：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This creates a subfolder called *MyFirstProgram* containing a project file called
    *MyFirstProgram.csproj* and a C# file called *Program.cs* that prints “Hello world.”
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为 *MyFirstProgram* 的子文件夹，其中包含一个名为 *MyFirstProgram.csproj* 的项目文件和一个名为
    *Program.cs* 的 C# 文件，该文件打印出“Hello world”。
- en: 'To build and run your program, run the following command from the *MyFirstProgram*
    folder:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 *MyFirstProgram* 文件夹构建和运行程序，请运行以下命令：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Or, if you just want to build without running:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您只想构建而不运行：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The output assembly will be written to a subdirectory under *bin\debug*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的程序集将被写入到 *bin\debug* 子目录下。
- en: We explain assemblies in detail in [Chapter 17](ch17.html#assemblies).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 17 章](ch17.html#assemblies) 中详细解释了程序集。
- en: Syntax
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法
- en: 'C# syntax is inspired by C and C++ syntax. In this section, we describe C#’s
    elements of syntax, using the following program:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: C# 语法受到 C 和 C++ 语法的启发。在本节中，我们使用以下程序描述了 C# 的语法元素：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Identifiers and Keywords
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标识符和关键字
- en: '*Identifiers* are names that programmers choose for their classes, methods,
    variables, and so on. Here are the identifiers in our example program, in the
    order in which they appear:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*标识符*是程序员为类、方法、变量等选择的名称。以下是我们示例程序中的标识符，按照它们出现的顺序列出：'
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: An identifier must be a whole word, essentially made up of Unicode characters
    starting with a letter or underscore. C# identifiers are case sensitive. By convention,
    parameters, local variables, and private fields should be in *camel case* (e.g.,
    `myVariable`), and all other identifiers should be in *Pascal case* (e.g., `MyMethod`).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符必须是一个完整的词，基本上由以字母或下划线开头的Unicode字符组成。C#标识符区分大小写。按照惯例，参数、局部变量和私有字段应该使用*驼峰命名法*（例如，`myVariable`），而其他所有标识符应该使用*帕斯卡命名法*（例如，`MyMethod`）。
- en: '*Keywords* are names that mean something special to the compiler. There are
    two keywords in our example program: `using` and `int`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*关键字*是编译器特殊意义的名称。在我们的示例程序中有两个关键字：`using`和`int`。'
- en: 'Most keywords are *reserved*, which means that you can’t use them as identifiers.
    Here is the full list of C# reserved keywords:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数关键字是*保留字*，这意味着你不能将它们用作标识符。以下是C#保留关键字的完整列表：
- en: '| `abstract` `as`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '| `abstract` `as`'
- en: '`base`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`base`'
- en: '`bool`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`bool`'
- en: '`break`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`'
- en: '`byte`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`byte`'
- en: '`case`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`case`'
- en: '`catch`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch`'
- en: '`char`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`char`'
- en: '`checked`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`checked`'
- en: '`class`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`class`'
- en: '`const`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`'
- en: '`continue`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`'
- en: '`decimal`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`decimal`'
- en: '`default`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`default`'
- en: '`delegate` | `do` `double`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`delegate` | `do` `double`'
- en: '`else`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`else`'
- en: '`enum`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`'
- en: '`event`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`event`'
- en: '`explicit`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`explicit`'
- en: '`extern`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`extern`'
- en: '`false`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`false`'
- en: '`finally`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally`'
- en: '`fixed`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`fixed`'
- en: '`float`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`float`'
- en: '`for`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`'
- en: '`foreach`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach`'
- en: '`goto`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`goto`'
- en: '`if`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`'
- en: '`implicit` | `in` `int`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`implicit` | `in` `int`'
- en: '`interface`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`interface`'
- en: '`internal`'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`internal`'
- en: '`is`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`is`'
- en: '`lock`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`lock`'
- en: '`long`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`long`'
- en: '`namespace`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`namespace`'
- en: '`new`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`'
- en: '`null`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`null`'
- en: '`object`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`object`'
- en: '`operator`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`operator`'
- en: '`out`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`out`'
- en: '`override`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`override`'
- en: '`params`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`params`'
- en: '`private` | `protected` `public`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`private` | `protected` `public`'
- en: '`readonly`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`readonly`'
- en: '`record`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`record`'
- en: '`ref`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`ref`'
- en: '`return`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`'
- en: '`sbyte`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`sbyte`'
- en: '`sealed`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`sealed`'
- en: '`short`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`short`'
- en: '`sizeof`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`sizeof`'
- en: '`stackalloc`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`stackalloc`'
- en: '`static`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`static`'
- en: '`string`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`string`'
- en: '`struct`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct`'
- en: '`switch`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`'
- en: '`this` | `throw` `true`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`this` | `throw` `true`'
- en: '`try`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`'
- en: '`typeof`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeof`'
- en: '`uint`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`uint`'
- en: '`ulong`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`ulong`'
- en: '`unchecked`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`unchecked`'
- en: '`unsafe`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`unsafe`'
- en: '`ushort`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`ushort`'
- en: '`using`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`using`'
- en: '`virtual`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`virtual`'
- en: '`void`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`void`'
- en: '`volatile`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`volatile`'
- en: '`while` |'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` |'
- en: 'If you really want to use an identifier that clashes with a reserved keyword,
    you can do so by qualifying it with the `@` prefix. For instance:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实想要使用与保留关键字冲突的标识符，可以通过使用`@`前缀来完成。例如：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `@` symbol doesn’t form part of the identifier itself. So, `@myVariable`
    is the same as `myVariable`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`@`符号本身不属于标识符的一部分。因此，`@myVariable`与`myVariable`是相同的。'
- en: Contextual keywords
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上下文关键字
- en: 'Some keywords are *contextual*, meaning that you also can use them as identifiers—without
    an `@` symbol:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一些关键字是*上下文相关*的，这意味着你也可以将它们作为标识符使用，无需使用`@`符号：
- en: '| `add` `alias`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '| `add` `alias`'
- en: '`and`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`and`'
- en: '`ascending`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`ascending`'
- en: '`async`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`'
- en: '`await`'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`await`'
- en: '`by`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`by`'
- en: '`descending` | `dynamic` `equals`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`descending` | `dynamic` `equals`'
- en: '`file`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`file`'
- en: '`from`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`from`'
- en: '`get`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`'
- en: '`global`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`global`'
- en: '`group`'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`group`'
- en: '`init` | `into` `join`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` | `into` `join`'
- en: '`let`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`'
- en: '`managed`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`managed`'
- en: '`nameof`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`nameof`'
- en: '`nint`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`nint`'
- en: '`not`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`not`'
- en: '`notnull` | `nuint` `on`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`notnull` | `nuint` `on`'
- en: '`or`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`or`'
- en: '`orderby`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`orderby`'
- en: '`partial`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`partial`'
- en: '`remove`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove`'
- en: '`required`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`required`'
- en: '`select` | `set` `unmanaged`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`select` | `set` `unmanaged`'
- en: '`value`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`value`'
- en: '`var`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`var`'
- en: '`with`'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`with`'
- en: '`when`'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`when`'
- en: '`where`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`where`'
- en: '`yield` |'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield` |'
- en: With contextual keywords, ambiguity cannot arise within the context in which
    they are used.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用上下文关键字的上下文中，不会产生歧义。
- en: Literals, Punctuators, and Operators
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字面量、标点符号和运算符
- en: '*Literals* are primitive pieces of data lexically embedded into the program.
    The literals we used in our example program are `12` and `30`.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*字面量*是程序中词法嵌入的原始数据片段。在我们的示例程序中使用的字面量包括`12`和`30`。'
- en: '*Punctuators* help demarcate the structure of the program. An example is the
    semicolon, which terminates a statement. Statements can wrap multiple lines:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*标点符号*有助于标明程序的结构。例如，分号用于结束语句。语句可以跨多行：'
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'An *operator* transforms and combines expressions. Most operators in C# are
    denoted with a symbol, such as the multiplication operator, `*`. We discuss operators
    in more detail later in this chapter. These are the operators we used in our example
    program:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*运算符*可以转换和组合表达式。C#中大多数运算符用符号表示，比如乘法运算符`*`。我们在示例程序中使用的运算符如下：'
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A period denotes a member of something (or a decimal point with numeric literals).
    Parentheses are used when declaring or calling a method; empty parentheses are
    used when the method accepts no arguments. (Parentheses also have other purposes
    that you’ll see later in this chapter.) An equals sign performs *assignment*.
    (The double equals sign, `==`, performs equality comparison, as you’ll see later.)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 句点表示某物的成员（或数字文字中的小数点）。在声明或调用方法时使用括号；当方法不接受参数时使用空括号。（括号还有其他目的，稍后在本章中你会看到。）等号执行*赋值*。（双等号
    `==` 执行相等比较，稍后会看到。）
- en: Comments
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: 'C# offers two different styles of source-code documentation: *single-line comments*
    and *multiline comments*. A single-line comment begins with a double forward slash
    and continues until the end of the line; for example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: C# 提供两种不同风格的源代码文档：*单行注释*和*多行注释*。单行注释以双斜杠开头，并持续到行尾；例如：
- en: '[PRE13]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A multiline comment begins with `/*` and ends with `*/`; for example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释以 `/*` 开始，以 `*/` 结束；例如：
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Comments can embed XML documentation tags, which we explain in [“XML Documentation”](ch04.html#xml_documentation).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注释可以嵌入 XML 文档标签，我们在 [“XML 文档”](ch04.html#xml_documentation) 中详细解释。
- en: Type Basics
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型基础
- en: 'A *type* defines the blueprint for a value. In this example, we use two literals
    of type `int` with values `12` and `30`. We also declare a *variable* of type
    `int` whose name is `x`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型*定义了一个值的蓝图。在这个例子中，我们使用了两个类型为 `int`、值为 `12` 和 `30` 的字面量。我们还声明了一个名为 `x` 的类型为
    `int` 的*变量*：'
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-170
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Because most of the code listings in this book require types from the `System`
    namespace, we will omit “`using System`” from now on, unless we’re illustrating
    a concept relating to namespaces.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因为本书中大部分代码清单需要 `System` 命名空间中的类型，所以我们将从现在开始省略“`using System`”，除非我们在说明与命名空间相关的概念。
- en: 'A *variable* denotes a storage location that can contain different values over
    time. In contrast, a *constant* always represents the same value (more on this
    later):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*变量*表示随时间可以包含不同值的存储位置。相比之下，*常量*始终表示相同的值（稍后详细说明）：'
- en: '[PRE16]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: All values in C# are *instances* of a type. The meaning of a value and the set
    of possible values a variable can have are determined by its type.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，所有的值都是*类型的实例*。一个值的含义以及变量可能具有的可能值集由其类型确定。
- en: Predefined Type Examples
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预定义类型示例
- en: 'Predefined types are types that are specially supported by the compiler. The
    `int` type is a predefined type for representing the set of integers that fit
    into 32 bits of memory, from −2^(31) to 2^(31)−1, and is the default type for
    numeric literals within this range. You can perform functions such as arithmetic
    with instances of the `int` type, as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 预定义类型是编译器特别支持的类型。`int` 类型是表示适合于 32 位内存的整数集的预定义类型，范围从 −2^(31) 到 2^(31)−1，并且是此范围内数字文字的默认类型。您可以对
    `int` 类型的实例执行算术操作，如下所示：
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Another predefined C# type is `string`. The `string` type represents a sequence
    of characters, such as “.NET” or [*http://oreilly.com*](http://oreilly.com). You
    can work with strings by calling functions on them, as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个预定义的 C# 类型是 `string`。`string` 类型表示字符序列，例如 “.NET” 或 [*http://oreilly.com*](http://oreilly.com)。您可以通过调用它们上面的函数来处理字符串，如下所示：
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, we called `x.ToString()` to obtain a string representation
    of the integer `x`. You can call `ToString()` on a variable of almost any type.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们调用 `x.ToString()` 来获取整数 `x` 的字符串表示。你几乎可以在任何类型的变量上调用 `ToString()`。
- en: 'The predefined `bool` type has exactly two possible values: `true` and `false`.
    The `bool` type is commonly used with an `if` statement to conditionally branch
    execution flow:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 预定义的 `bool` 类型只有两个可能的值：`true` 和 `false`。`bool` 类型通常与 `if` 语句一起用于有条件地分支执行流程：
- en: '[PRE19]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-183
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In C#, predefined types (also referred to as built-in types) are recognized
    with a C# keyword. The `System` namespace in .NET contains many important types
    that are not predefined by C# (e.g., `DateTime`).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，预定义类型（也称为内置类型）由 C# 关键字识别。在 .NET 中，`System` 命名空间包含许多重要的类型，这些类型不是由 C# 预定义的（例如
    `DateTime`）。
- en: Custom Types
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义类型
- en: 'Just as we can write our own methods, we can write our own types. In this next
    example, we define a custom type named `UnitConverter`—a class that serves as
    a blueprint for unit conversions:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们可以编写自己的方法一样，我们也可以编写自己的类型。在下一个示例中，我们定义了一个名为 `UnitConverter` 的自定义类型——一个作为单位转换蓝图的类：
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-188
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In this example, our class definition appears in the same file as our top-level
    statements. This is legal—as long as the top-level statements appear first—and
    is acceptable when writing small test programs. With larger programs, the standard
    approach is to put the class definition in a separate file such as *UnitConverter.cs*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的类定义出现在与顶层语句相同的文件中。这是合法的——只要顶层语句出现在前面——在编写小型测试程序时也是可以接受的。对于较大的程序，标准做法是将类定义放在单独的文件中，如*UnitConverter.cs*。
- en: Members of a type
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类的成员
- en: A type contains *data members* and *function members*. The data member of `UnitConverter`
    is the *field* called `ratio`. The function members of `UnitConverter` are the
    `Convert` method and the `UnitConverter`’s *constructor*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 类包含*数据成员*和*函数成员*。`UnitConverter`的数据成员是称为*比率*的*字段*。`UnitConverter`的函数成员包括`Convert`方法和`UnitConverter`的*构造函数*。
- en: Symmetry of predefined types and custom types
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预定义类型和自定义类型的对称性
- en: A beautiful aspect of C# is that predefined types and custom types have few
    differences. The predefined `int` type serves as a blueprint for integers. It
    holds data—32 bits—and provides function members that use that data, such as `ToString`.
    Similarly, our custom `UnitConverter` type acts as a blueprint for unit conversions.
    It holds data—the ratio—and provides function members to use that data.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: C#的一个美妙之处在于预定义类型和自定义类型几乎没有差别。预定义的`int`类型用作整数的蓝图。它保存数据——32位——并提供使用该数据的函数成员，如`ToString`。同样，我们的自定义`UnitConverter`类型作为单位转换的蓝图。它保存数据——比率——并提供使用该数据的函数成员。
- en: Constructors and instantiation
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数和实例化
- en: 'Data is created by *instantiating* a type. Predefined types can be instantiated
    simply by using a literal such as `12` or `"Hello world"`. The `new` operator
    creates instances of a custom type. We created and declared an instance of the
    `UnitConverter` type with this statement:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 数据是通过*实例化*类型来创建的。预定义类型可以通过字面量（如`12`或`"Hello world"`）简单实例化。`new`运算符创建自定义类型的实例。我们使用以下语句创建和声明了`UnitConverter`类型的一个实例：
- en: '[PRE21]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Immediately after the `new` operator instantiates an object, the object’s *constructor*
    is called to perform initialization. A constructor is defined like a method, except
    that the method name and return type are reduced to the name of the enclosing
    type:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`运算符实例化对象后，会调用对象的*构造函数*进行初始化。构造函数定义类似于方法，但方法名称和返回类型缩减为封闭类型的名称：'
- en: '[PRE22]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Instance versus static members
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实例成员与静态成员的区别
- en: The data members and function members that operate on the *instance* of the
    type are called *instance members*. The `UnitConverter`’s `Convert` method and
    the `int`’s `ToString` method are examples of instance members. By default, members
    are instance members.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*实例*类型的数据成员和函数成员称为*实例成员*。`UnitConverter`的`Convert`方法和`int`的`ToString`方法就是实例成员的例子。默认情况下，成员都是实例成员。'
- en: Data members and function members that don’t operate on the instance of the
    type can be marked as `static`. To refer to a static member from outside its type,
    you specify its *type* name rather than an *instance*. An example is the `WriteLine`
    method of the `Console` class. Because this is static, we call `Console.WriteLine()`
    and not `new Console().WriteLine()`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 不操作类型实例的数据成员和函数成员可以标记为`static`。要从其类型外部引用静态成员，需指定其*类型*名称而不是*实例*。例如，`Console`类的`WriteLine`方法。因为这是静态的，我们调用`Console.WriteLine()`而不是`new
    Console().WriteLine()`。
- en: (The `Console` class is actually declared as a *static class*, which means that
    *all* of its members are static and you can never create instances of a `Console`.)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: （`Console`类实际上声明为*静态类*，这意味着*所有*它的成员都是静态的，你永远无法创建`Console`的实例。）
- en: 'In the following code, the instance field `Name` pertains to an instance of
    a particular `Panda`, whereas `Population` pertains to the set of all `Panda`
    instances. We create two instances of the `Panda`, print their names, and then
    print the total population:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，`Name`实例字段属于特定`Panda`的实例，而`Population`则属于所有`Panda`实例的集合。我们创建了两个`Panda`的实例，打印它们的名称，然后打印总人口数量：
- en: '[PRE23]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Attempting to evaluate `p1.Population` or `Panda.Name` will generate a compile-time
    error.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试评估`p1.Population`或`Panda.Name`将生成编译时错误。
- en: The public keyword
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 公共关键字
- en: 'The `public` keyword exposes members to other classes. In this example, if
    the `Name` field in `Panda` was not marked as public, it would be private and
    could not be accessed from outside the class. Marking a member `public` is how
    a type communicates: “Here is what I want other types to see—everything else is
    my own private implementation details.” In object-oriented terms, we say that
    the public members *encapsulate* the private members of the class.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`public`关键字将成员暴露给其他类。在本例中，如果`Panda`中的`Name`字段未标记为`public`，则将是私有的，无法从类外部访问。将成员标记为`public`是类型通信的方式：“这是我希望其他类型看到的东西——其他都是我自己的私有实现细节。”从面向对象的角度来看，我们说公共成员*封装*了类的私有成员。'
- en: Defining namespaces
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义命名空间
- en: 'Particularly with larger programs, it makes sense to organize types into namespaces.
    Here’s how to define the `Panda` class inside a namespace called `Animals`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是在较大的程序中，将类型组织到命名空间中是有意义的。以下是如何在名为`Animals`的命名空间内定义`Panda`类：
- en: '[PRE24]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this example, we also *imported* the `Animals` namespace so that our top-level
    statements could access its types without qualification. Without that import,
    we’d need to do this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们还*导入*了`Animals`命名空间，以便我们的顶级语句可以无需限定地访问其类型。如果没有这个导入，我们需要这样做：
- en: '[PRE25]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We cover namespaces in detail at the end of this chapter (see [“Namespaces”](#namespaces-id00029)).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章末尾详细介绍命名空间（请参阅[“命名空间”](#namespaces-id00029)）。
- en: Defining a Main method
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义主方法
- en: All of our examples, so far, have used top-level statements (a feature introduced
    in C# 9).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的示例都使用了顶级语句（这是C# 9引入的一个功能）。
- en: 'Without top-level statements, a simple console or Windows application looks
    like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 没有顶级语句，简单的控制台或Windows应用程序如下所示：
- en: '[PRE26]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the absence of top-level statements, C# looks for a static method called
    `Main`, which becomes the entry point. The `Main` method can be defined inside
    any class (and only one `Main` method can exist).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有顶级语句的情况下，C#会寻找名为`Main`的静态方法，这成为入口点。`Main`方法可以定义在任何类内部（只能存在一个`Main`方法）。
- en: 'The `Main` method can optionally return an integer (rather than `void`) in
    order to return a value to the execution environment (where a nonzero value typically
    indicates an error). The `Main` method can also optionally accept an array of
    strings as a parameter (that will be populated with any arguments passed to the
    executable). For example:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`方法可以选择性地返回整数（而不是`void`），以向执行环境返回一个值（其中非零值通常表示错误）。`Main`方法还可以选择性地接受字符串数组作为参数（该参数将填充为传递给可执行文件的任何参数）。例如：'
- en: '[PRE27]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-221
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: An array (such as `string[]`) represents a fixed number of elements of a particular
    type. Arrays are specified by placing square brackets after the element type.
    We describe them in [“Arrays”](#arrays-id00001).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 数组（如`string[]`）表示特定类型的固定数量的元素。数组通过在元素类型后面放置方括号来指定。我们在[“数组”](#arrays-id00001)中描述它们。
- en: (The `Main` method can also be declared `async` and return a `Task` or `Task<int>`
    in support of asynchronous programming, which we cover in [Chapter 14](ch14.html#concurrency_and_asynchron).)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: （`Main`方法还可以声明为`async`并返回`Task`或`Task<int>`，以支持异步编程，我们在[第14章](ch14.html#concurrency_and_asynchron)中介绍。）
- en: Types and Conversions
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型和转换
- en: 'C# can convert between instances of compatible types. A conversion always creates
    a new value from an existing one. Conversions can be either *implicit* or *explicit*:
    implicit conversions happen automatically, and explicit conversions require a
    *cast*. In the following example, we *implicitly* convert an `int` to a `long`
    type (which has twice the bit capacity of an `int`) and *explicitly* cast an `int`
    to a `short` type (which has half the bit capacity of an `int`):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: C#可以在兼容类型的实例之间进行转换。转换总是从现有值创建新值。转换可以是*隐式*或*显式*：隐式转换会自动发生，显式转换需要*强制转换*。在以下示例中，我们*隐式*将`int`转换为具有两倍`int`位容量的`long`类型，并*显式*将`int`转换为具有`int`位容量一半的`short`类型：
- en: '[PRE28]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Implicit conversions are allowed when both of the following are true:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当满足以下两个条件时，允许隐式转换：
- en: The compiler can guarantee that they will always succeed.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器可以保证它们将始终成功。
- en: No information is lost in conversion.^([1](ch02.html#ch01fn1))
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换过程中不会丢失信息。^([1](ch02.html#ch01fn1))
- en: 'Conversely, *explicit* conversions are required when one of the following is
    true:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，当满足以下条件之一时，需要*显式*转换：
- en: The compiler cannot guarantee that they will always succeed.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器无法保证它们将始终成功。
- en: Information might be lost during conversion.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换过程中可能会丢失信息。
- en: (If the compiler can determine that a conversion will *always* fail, both kinds
    of conversion are prohibited. Conversions that involve generics can also fail
    in certain conditions—see [“Type Parameters and Conversions”](ch03.html#type_parameters_and_conversions).)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: （如果编译器可以确定转换将*始终*失败，则两种类型的转换都被禁止。涉及泛型的转换在某些条件下也可能失败 —— 见[“类型参数和转换”](ch03.html#type_parameters_and_conversions)。）
- en: Note
  id: totrans-234
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The *numeric conversions* that we just saw are built into the language. C# also
    supports *reference conversions* and *boxing conversions* (see [Chapter 3](ch03.html#creating_types_in_chash))
    as well as *custom conversions* (see [“Operator Overloading”](ch04.html#operator_overloading)).
    The compiler doesn’t enforce the aforementioned rules with custom conversions,
    so it’s possible for badly designed types to behave otherwise.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到的*数值转换*是语言内置的。C#还支持*引用转换*和*装箱转换*（参见[第 3 章](ch03.html#creating_types_in_chash)），以及*自定义转换*（参见[“运算符重载”](ch04.html#operator_overloading)）。编译器不会对自定义转换强制执行上述规则，因此设计不良的类型可能会有不同的行为。
- en: Value Types Versus Reference Types
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值类型与引用类型对比
- en: 'All C# types fall into the following categories:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 所有C#类型都属于以下类别：
- en: Value types
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值类型
- en: Reference types
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用类型
- en: Generic type parameters
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型类型参数
- en: Pointer types
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针类型
- en: Note
  id: totrans-242
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In this section, we describe value types and reference types. We cover generic
    type parameters in [“Generics”](ch03.html#generics) and pointer types in [“Unsafe
    Code and Pointers”](ch04.html#unsafe_code_and_pointers).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们描述了值类型和引用类型。我们在[“泛型”](ch03.html#generics)中介绍了泛型类型参数，以及在[“不安全代码和指针”](ch04.html#unsafe_code_and_pointers)中介绍了指针类型。
- en: '*Value types* comprise most built-in types (specifically, all numeric types,
    the `char` type, and the `bool` type) as well as custom `struct` and `enum` types.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*值类型* 包括大多数内置类型（具体来说是所有数值类型、`char`类型和`bool`类型），以及自定义的`struct`和`enum`类型。'
- en: '*Reference types* comprise all class, array, delegate, and interface types.
    (This includes the predefined `string` type.)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*引用类型* 包括所有类、数组、委托和接口类型。（这包括预定义的`string`类型。）'
- en: The fundamental difference between value types and reference types is how they
    are handled in memory.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型和引用类型的根本区别在于它们在内存中的处理方式。
- en: Value types
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 值类型
- en: The content of a *value type* variable or constant is simply a value. For example,
    the content of the built-in value type, `int`, is 32 bits of data.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型变量或常量的内容只是一个值。例如，内置的值类型`int`的内容是32位的数据。
- en: 'You can define a custom value type with the `struct` keyword (see [Figure 2-1](#a_value_type_instance_in_memory)):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`struct`关键字定义自定义值类型（见[图 2-1](#a_value_type_instance_in_memory)）：
- en: '[PRE29]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Or more tersely:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 或更简洁地说：
- en: '[PRE30]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![A value-type instance in memory](assets/cn10_0201.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![内存中的值类型实例](assets/cn10_0201.png)'
- en: Figure 2-1\. A value-type instance in memory
  id: totrans-254
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-1\. 内存中的值类型实例
- en: 'The assignment of a value-type instance always *copies* the instance; for example:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型实例的赋值总是会*复制*实例；例如：
- en: '[PRE31]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[Figure 2-2](#assignment_copies_a_value_type_instance) shows that `p1` and
    `p2` have independent storage.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-2](#assignment_copies_a_value_type_instance) 显示了`p1`和`p2`有独立的存储。'
- en: '![Assignment copies a value-type instance](assets/cn10_0202.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![分配复制值类型实例](assets/cn10_0202.png)'
- en: Figure 2-2\. Assignment copies a value-type instance
  id: totrans-259
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-2\. 分配复制值类型实例
- en: Reference types
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用类型
- en: 'A reference type is more complex than a value type, having two parts: an *object*
    and the *reference* to that object. The content of a reference-type variable or
    constant is a reference to an object that contains the value. Here is the `Point`
    type from our previous example rewritten as a class rather than a `struct` (shown
    in [Figure 2-3](#a_reference_type_instance_in_memory)):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型比值类型更复杂，包含两个部分：*对象*和指向该对象的*引用*。引用类型变量或常量的内容是指向包含值的对象的引用。这里是我们之前示例中的`Point`类型，它被重写为一个类而不是`struct`（如[图 2-3](#a_reference_type_instance_in_memory)所示）：
- en: '[PRE32]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![A reference-type instance in memory](assets/cn10_0203.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![内存中的引用类型实例](assets/cn10_0203.png)'
- en: Figure 2-3\. A reference-type instance in memory
  id: totrans-264
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-3\. 内存中的引用类型实例
- en: 'Assigning a reference-type variable copies the reference, not the object instance.
    This allows multiple variables to refer to the same object—something not ordinarily
    possible with value types. If we repeat the previous example, but with `Point`
    now a class, an operation to `p1` affects `p2`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 分配引用类型变量会复制引用而非对象实例。这允许多个变量引用同一个对象，这在值类型中通常是不可能的。如果我们重复之前的例子，但现在`Point`是一个类，对`p1`的操作会影响到`p2`：
- en: '[PRE33]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[Figure 2-4](#assignment_copies_a_reference) shows that `p1` and `p2` are two
    references that point to the same object.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-4](#assignment_copies_a_reference) 显示 `p1` 和 `p2` 是指向同一对象的两个引用。'
- en: '![Assignment copies a reference](assets/cn10_0204.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![分配复制一个引用](assets/cn10_0204.png)'
- en: Figure 2-4\. Assignment copies a reference
  id: totrans-269
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-4\. 分配复制一个引用
- en: 'Null'
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空值
- en: 'A reference can be assigned the literal `null`, indicating that the reference
    points to no object:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将引用分配为字面量 `null`，表示引用指向没有对象：
- en: '[PRE34]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-273
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In [“Nullable Reference Types”](ch04.html#nullable_reference_types-id00081),
    we describe a feature of C# that helps to reduce accidental `NullReference​Ex⁠ception`
    errors.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [“可空引用类型”](ch04.html#nullable_reference_types-id00081) 中，我们描述了C#的一个特性，有助于减少意外的
    `NullReference​Ex⁠ception` 错误。
- en: 'In contrast, a value type cannot ordinarily have a null value:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，值类型通常不能有空值：
- en: '[PRE35]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-277
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: C# also has a construct called *nullable value types* for representing value-type
    nulls. For more information, see [“Nullable Value Types”](ch04.html#nullable_value_types).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: C# 还有一种称为*可空值类型*的构造，用于表示值类型的空值。有关更多信息，请参见 [“可空值类型”](ch04.html#nullable_value_types)。
- en: Storage overhead
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储开销
- en: 'Value-type instances occupy precisely the memory required to store their fields.
    In this example, `Point` takes 8 bytes of memory:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型实例占用精确存储其字段所需的内存。在这个例子中，`Point` 占用8字节的内存：
- en: '[PRE36]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-282
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Technically, the CLR positions fields within the type at an address that’s
    a multiple of the fields’ size (up to a maximum of 8 bytes). Thus, the following
    actually consumes 16 bytes of memory (with the 7 bytes following the first field
    “wasted”):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，CLR 将类型内的字段定位到地址，该地址是字段大小的倍数（最多为8字节）。因此，以下实际上会消耗16字节的内存（第一个字段后面的7字节“浪费”）：
- en: '[PRE37]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can override this behavior by applying the `StructLayout` attribute (see
    [“Mapping a Struct to Unmanaged Memory”](ch24.html#mapping_a_struct_to_unmanaged_memory)).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过应用 `StructLayout` 属性来覆盖此行为（参见 [“将结构映射到非托管内存”](ch24.html#mapping_a_struct_to_unmanaged_memory)）。
- en: Reference types require separate allocations of memory for the reference and
    object. The object consumes as many bytes as its fields, plus additional administrative
    overhead. The precise overhead is intrinsically private to the implementation
    of the .NET runtime, but at minimum, the overhead is 8 bytes, used to store a
    key to the object’s type as well as temporary information such as its lock state
    for multithreading and a flag to indicate whether it has been fixed from movement
    by the garbage collector. Each reference to an object requires an extra 4 or 8
    bytes, depending on whether the .NET runtime is running on a 32- or 64-bit platform.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型需要单独分配内存来存储引用和对象。对象消耗的字节数与其字段一样多，再加上额外的管理开销。精确的开销是.NET运行时实现的私有信息，但至少为8字节，用于存储对象类型的键以及临时信息，例如其在多线程中的锁定状态和指示其是否已由垃圾收集器固定的标志。每个对象的引用需要额外的4或8字节，具体取决于.NET运行时是否运行在32位或64位平台上。
- en: Predefined Type Taxonomy
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预定义类型分类
- en: 'The predefined types in C# are as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中的预定义类型如下：
- en: '*Value types*'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '*值类型*'
- en: Numeric
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值
- en: Signed integer (`sbyte`, `short`, `int`, `long`)
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号整数 (`sbyte`, `short`, `int`, `long`)
- en: Unsigned integer (`byte`, `ushort`, `uint`, `ulong`)
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无符号整数 (`byte`, `ushort`, `uint`, `ulong`)
- en: Real number (`float`, `double`, `decimal`)
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实数 (`float`, `double`, `decimal`)
- en: Logical (`bool`)
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑 (`bool`)
- en: Character (`char`)
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符 (`char`)
- en: '*Reference types*'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '*引用类型*'
- en: String (`string`)
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串 (`string`)
- en: Object (`object`)
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象 (`object`)
- en: 'Predefined types in C# alias .NET types in the `System` namespace. There is
    only a syntactic difference between these two statements:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中的预定义类型别名 .NET 类型位于 `System` 命名空间中。这两个语句之间只有语法上的差异：
- en: '[PRE38]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The set of predefined *value* types excluding `decimal` are known as *primitive
    types* in the CLR. Primitive types are so called because they are supported directly
    via instructions in compiled code, and this usually translates to direct support
    on the underlying processor; for example:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: CLR 中，预定义的*值*类型不包括 `decimal`，它们被称为CLR中的*基元类型*。之所以称为基元类型，是因为它们直接通过编译后的指令支持，在底层处理器上通常会直接翻译为支持；例如：
- en: '[PRE39]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `System.IntPtr` and `System.UIntPtr` types are also primitive (see [Chapter 24](ch24.html#native_and_com_interoperabilit)).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.IntPtr` 和 `System.UIntPtr` 类型也是基元类型（参见 [第24章](ch24.html#native_and_com_interoperabilit)）。'
- en: Numeric Types
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数值类型
- en: C# has the predefined numeric types shown in [Table 2-1](#predefined_numeric_types_in_chash).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中有如下所示的预定义数值类型表 [表2-1](#predefined_numeric_types_in_chash)。
- en: Table 2-1\. Predefined numeric types in C#
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-1\. C#中的预定义数值类型
- en: '| C# type | System type | Suffix | Size | Range |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| C# 类型 | 系统类型 | 后缀 | 大小 | 范围 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **Integral—signed** |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| **整数—有符号** |'
- en: '| `sbyte` | `SByte` |  | 8 bits | –2⁷ to 2⁷–1 |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| `sbyte` | `SByte` |  | 8 位 | –2⁷ 到 2⁷–1 |'
- en: '| `short` | `Int16` |  | 16 bits | –2^(15) to 2^(15)–1 |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `short` | `Int16` |  | 16 位 | –2^(15) 到 2^(15)–1 |'
- en: '| `int` | `Int32` |  | 32 bits | –2^(31) to 2^(31)–1 |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `int` | `Int32` |  | 32 位 | –2^(31) 到 2^(31)–1 |'
- en: '| `long` | `Int64` | `L` | 64 bits | –2^(63) to 2^(63)–1 |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `long` | `Int64` | `L` | 64 位 | –2^(63) 到 2^(63)–1 |'
- en: '| `nint` | `IntPtr` |  | 32/64 bits |  |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `nint` | `IntPtr` |  | 32/64 位 |  |'
- en: '| **Integral—unsigned** |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| **整数—无符号** |'
- en: '| `byte` | `Byte` |  | 8 bits | 0 to 2⁸–1 |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | `Byte` |  | 8 位 | 0 到 2⁸–1 |'
- en: '| `ushort` | `UInt16` |  | 16 bits | 0 to 2^(16)–1 |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| `ushort` | `UInt16` |  | 16 位 | 0 到 2^(16)–1 |'
- en: '| `uint` | `UInt32` | `U` | 32 bits | 0 to 2^(32)–1 |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| `uint` | `UInt32` | `U` | 32 位 | 0 到 2^(32)–1 |'
- en: '| `ulong` | `UInt64` | `UL` | 64 bits | 0 to 2^(64)–1 |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| `ulong` | `UInt64` | `UL` | 64 位 | 0 到 2^(64)–1 |'
- en: '| `nuint` | `UIntPtr` |  | 32/64 bits |  |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `nuint` | `UIntPtr` |  | 32/64 位 |  |'
- en: '| **Real** |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| **实数** |'
- en: '| `float` | `Single` | `F` | 32 bits | ± (~10^(–45) to 10^(38)) |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| `float` | `Single` | `F` | 32 位 | ± (~10^(–45) 到 10^(38)) |'
- en: '| `double` | `Double` | `D` | 64 bits | ± (~10^(–324) to 10^(308)) |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `Double` | `D` | 64 位 | ± (~10^(–324) 到 10^(308)) |'
- en: '| `decimal` | `Decimal` | `M` | 128 bits | ± (~10^(–28) to 10^(28)) |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| `decimal` | `Decimal` | `M` | 128 位 | ± (~10^(–28) 到 10^(28)) |'
- en: Of the *integral* types, `int` and `long` are first-class citizens and are favored
    by both C# and the runtime. The other integral types are typically used for interoperability
    or when space efficiency is paramount. The `nint` and `nuint` native-sized integer
    types are most useful when working with pointers, so we will describe these in
    a later chapter (see [“Native-Sized Integers”](ch04.html#native_sized_integers)).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在*整数*类型中，`int` 和 `long` 是头等公民，并且被 C# 和运行时青睐。其他整数类型通常用于互操作性或空间效率至关重要时。`nint`
    和 `nuint` 本地大小的整数类型在处理指针时非常有用，因此我们将在后面的章节中描述它们（参见 [“本地大小整数”](ch04.html#native_sized_integers)）。
- en: Of the *real* number types, `float` and `double` are called *floating-point
    types*^([2](ch02.html#ch01fn2)) and are typically used for scientific and graphical
    calculations. The `decimal` type is typically used for financial calculations,
    for which base-10-accurate arithmetic and high precision are required.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在*实数*类型中，`float` 和 `double` 被称为 *浮点类型*^([2](ch02.html#ch01fn2))，通常用于科学和图形计算。`decimal`
    类型通常用于财务计算，其中需要基于十进制的精确算术和高精度。
- en: Note
  id: totrans-327
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: .NET supplements this list with several specialized numeric types, including
    `Int128` and `UInt128` for signed and unsigned 128-bit integers, `BigInteger`
    for arbitrarily large integers, and `Half` for 16-bit floating point numbers.
    `Half` is intended mainly for interoperating with graphics card processors and
    does not have native support in most CPUs, making `float` and `double` better
    choices for general use.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 还用几种特殊的数值类型补充了此列表，包括用于有符号和无符号 128 位整数的 `Int128` 和 `UInt128`，用于任意大整数的 `BigInteger`，以及用于
    16 位浮点数的 `Half`。`Half` 主要用于与图形处理器的互操作，并且在大多数 CPU 中没有本地支持，因此在一般用途中，`float` 和 `double`
    是更好的选择。
- en: Numeric Literals
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字文字
- en: '*Integral-type literals* can use decimal or hexadecimal notation; hexadecimal
    is denoted with the `0x` prefix. For example:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '*整数类型文字* 可以使用十进制或十六进制表示法；十六进制用 `0x` 前缀表示。例如：'
- en: '[PRE40]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can insert an underscore anywhere within a numeric literal to make it more
    readable:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在数字文字中的任何位置插入下划线，以提高其可读性：
- en: '[PRE41]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can specify numbers in binary with the `0b` prefix:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `0b` 前缀指定二进制数字：
- en: '[PRE42]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*Real literals* can use decimal and/or exponential notation:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '*实数文字* 可以使用十进制和/或指数表示法：'
- en: '[PRE43]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Numeric literal type inference
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数字文字类型推断
- en: 'By default, the compiler *infers* a numeric literal to be either `double` or
    an integral type:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，编译器会 *推断* 数字文字为 `double` 或整数类型之一：
- en: If the literal contains a decimal point or the exponential symbol (`E`), it
    is a `double`.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文字包含小数点或指数符号 (`E`)，则为 `double`。
- en: 'Otherwise, the literal’s type is the first type in this list that can fit the
    literal’s value: `int`, `uint`, `long`, and `ulong`.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，文字的类型是此列表中可以容纳文字值的第一个类型：`int`、`uint`、`long` 和 `ulong`。
- en: 'For example:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE44]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Numeric suffixes
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数字后缀
- en: '*Numeric suffixes* explicitly define the type of a literal. Suffixes can be
    either lowercase or uppercase, and are as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '*数字后缀* 明确定义了文字的类型。后缀可以是小写或大写，如下所示：'
- en: '| Category | C# type | Example |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | C# 类型 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `F` | `float` | `float f = 1.0F;` |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| `F` | `float` | `float f = 1.0F;` |'
- en: '| `D` | `double` | `double d = 1D;` |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| `D` | `double` | `double d = 1D;` |'
- en: '| `M` | `decimal` | `decimal d = 1.0M;` |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| `M` | `decimal` | `decimal d = 1.0M;` |'
- en: '| `U` | `uint` | `uint i = 1U;` |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| `U` | `uint` | `uint i = 1U;` |'
- en: '| `L` | `long` | `long i = 1L;` |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| `L` | `long` | `long i = 1L;` |'
- en: '| `UL` | `ulong` | `ulong i = 1UL;` |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| `UL` | `ulong` | `ulong i = 1UL;` |'
- en: 'The suffixes `U` and `L` are rarely necessary because the `uint`, `long`, and
    `ulong` types can nearly always be either *inferred* or *implicitly converted*
    from `int`:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 后缀 `U` 和 `L` 很少需要，因为 `uint`，`long` 和 `ulong` 类型几乎总是可以从 `int` *推断* 或*隐式转换*而来：
- en: '[PRE45]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `D` suffix is technically redundant in that all literals with a decimal
    point are inferred to be `double`. And you can always add a decimal point to a
    numeric literal:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`D` 后缀在技术上是多余的，因为所有带小数点的字面量都被推断为 `double`。而且你总是可以向数字字面量添加一个小数点：'
- en: '[PRE46]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `F` and `M` suffixes are the most useful and should always be applied when
    specifying `float` or `decimal` literals. Without the `F` suffix, the following
    line would not compile, because 4.5 would be inferred to be of type `double`,
    which has no implicit conversion to `float`:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`F` 和 `M` 后缀是最有用的，当指定 `float` 或 `decimal` 字面量时应始终添加。如果没有 `F` 后缀，下面的行将无法编译，因为
    4.5 将被推断为 `double` 类型，而 `double` 类型没有到 `float` 类型的隐式转换：'
- en: '[PRE47]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The same principle is true for a decimal literal:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制字面量也适用同样的原则：
- en: '[PRE48]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We describe the semantics of numeric conversions in detail in the following
    section.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节详细描述数值转换的语义。
- en: Numeric Conversions
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字转换
- en: Converting between integral types
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数类型之间的转换
- en: 'Integral type conversions are *implicit* when the destination type can represent
    every possible value of the source type. Otherwise, an *explicit* conversion is
    required; for example:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 当目标类型能够表示源类型的每一个可能值时，整数类型转换是*隐式*的。否则，需要进行*显式*转换；例如：
- en: '[PRE49]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Converting between floating-point types
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮点类型之间的转换
- en: A `float` can be implicitly converted to a `double` given that a `double` can
    represent every possible value of a `float`. The reverse conversion must be explicit.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 `double` 可以表示 `float` 的每一个可能值，`float` 可以隐式转换为 `double`。反向转换必须是显式的。
- en: Converting between floating-point and integral types
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮点类型和整数类型之间的转换
- en: 'All integral types can be implicitly converted to all floating-point types:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 所有整数类型可以隐式转换为所有浮点类型：
- en: '[PRE50]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The reverse conversion must be explicit:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 反向转换必须是显式的：
- en: '[PRE51]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note
  id: totrans-374
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When you cast from a floating-point number to an integral type, any fractional
    portion is truncated; no rounding is performed. The static class `System.Convert`
    provides methods that round while converting between various numeric types (see
    [Chapter 6](ch06.html#dotnet_fundamentals)).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从浮点数转换为整数类型时，任何小数部分都会被截断；不进行四舍五入。静态类`System.Convert`提供了在各种数值类型之间进行转换时进行四舍五入的方法（见[第6章](ch06.html#dotnet_fundamentals)）。
- en: 'Implicitly converting a large integral type to a floating-point type preserves
    *magnitude* but can occasionally lose *precision*. This is because floating-point
    types always have more magnitude than integral types but can have less precision.
    Rewriting our example with a larger number demonstrates this:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 将大整数类型隐式转换为浮点类型会保留*幅度*，但有时可能会丢失*精度*。这是因为浮点类型始终具有比整数类型更大的幅度，但可能具有较少的精度。通过使用一个较大的数字来重新编写我们的示例来演示这一点：
- en: '[PRE52]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Decimal conversions
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 十进制转换
- en: All integral types can be implicitly converted to the decimal type given that
    a decimal can represent every possible C# integral-type value. All other numeric
    conversions to and from a decimal type must be explicit because they introduce
    the possibility of either a value being out of range or precision being lost.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 所有整数类型可以隐式转换为十进制类型，前提是十进制可以表示所有可能的 C# 整数类型值。对于十进制类型的所有其他数值转换必须是显式的，因为它们可能导致值超出范围或精度丢失的可能性。
- en: Arithmetic Operators
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术运算符
- en: 'The arithmetic operators (`+`, `-`, `*`, `/`, `%`) are defined for all numeric
    types except the 8- and 16-bit integral types:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算符（`+`，`-`，`*`，`/`，`%`）适用于所有数值类型，但不适用于8位和16位整数类型：
- en: '[PRE53]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Increment and Decrement Operators
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自增和自减运算符
- en: 'The increment and decrement operators (`++`, `--`, respectively) increment
    and decrement numeric types by 1\. The operator can either follow or precede the
    variable, depending on whether you want its value *before* or *after* the increment/decrement;
    for example:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 自增和自减运算符（`++`，`--`，分别）通过 1 增加和减少数值类型。运算符可以跟随或在变量之前，具体取决于您希望其值在增加/减少之前还是之后；例如：
- en: '[PRE54]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Specialized Operations on Integral Types
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数类型的专用操作
- en: The *integral types* are `int`, `uint`, `long`, `ulong`, `short`, `ushort`,
    `byte`, and `sbyte`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '*整数类型*包括`int`、`uint`、`long`、`ulong`、`short`、`ushort`、`byte`和`sbyte`。'
- en: Division
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 除法
- en: 'Division operations on integral types always eliminate the remainder (round
    toward zero). Dividing by a variable whose value is zero generates a runtime error
    (a `DivideByZeroException`):'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 对整数类型的除法操作总是消除余数（向零舍入）。除以值为零的变量会生成运行时错误（`DivideByZeroException`）：
- en: '[PRE55]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Dividing by the *literal* or *constant* 0 generates a compile-time error.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 除以*文字*或*常量* 0会生成编译时错误。
- en: Overflow
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 溢出
- en: 'At runtime, arithmetic operations on integral types can overflow. By default,
    this happens silently—no exception is thrown, and the result exhibits “wraparound”
    behavior, as though the computation were done on a larger integer type and the
    extra significant bits discarded. For example, decrementing the minimum possible
    `int` value results in the maximum possible `int` value:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，整数类型的算术操作可能会溢出。默认情况下，这种情况发生时是静默的——不会抛出异常，并且结果表现为“环绕”行为，就像在更大的整数类型上进行计算并丢弃额外的有效位一样。例如，将最小可能的`int`值递减结果为最大可能的`int`值：
- en: '[PRE56]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Overflow check operators
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 溢出检查运算符
- en: The `checked` operator instructs the runtime to generate an `OverflowException`
    rather than overflowing silently when an integral-type expression or statement
    exceeds the arithmetic limits of that type. The `checked` operator affects expressions
    with the `++`, `−−`, `+`, `−` (binary and unary), `*`, `/`, and explicit conversion
    operators between integral types. Overflow checking incurs a small performance
    cost.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`checked`运算符指示运行时在整数类型表达式或语句超出算术限制时生成`OverflowException`，而不是静默溢出。`checked`运算符影响具有`++`、`−−`、`+`、`−`（二元和一元）、`*`、`/`和整数类型之间的显式转换运算符的表达式。溢出检查会带来小的性能成本。'
- en: Note
  id: totrans-397
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `checked` operator has no effect on the `double` and `float` types (which
    overflow to special “infinite” values, as you’ll see soon) and no effect on the
    `decimal` type (which is always checked).
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`checked`运算符对`double`和`float`类型无效（它们溢出到特殊的“无穷”值，稍后您将看到），并且对`decimal`类型无效（它总是检查的）。'
- en: 'You can use `checked` around either an expression or a statement block:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在表达式或语句块周围使用`checked`：
- en: '[PRE57]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You can make arithmetic overflow checking the default for all expressions in
    a program by selecting the “checked” option at the project level (in Visual Studio,
    go to Advanced Build Settings). If you then need to disable overflow checking
    just for specific expressions or statements, you can do so with the `unchecked`
    operator. For example, the following code will not throw exceptions—even if the
    project’s “checked” option is selected:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过选择项目级别的“checked”选项（在Visual Studio中，转到高级构建设置）使算术溢出检查成为程序中所有表达式的默认值。然后，如果需要仅为特定表达式或语句禁用溢出检查，可以使用`unchecked`运算符。例如，以下代码不会抛出异常——即使选择了项目的“checked”选项：
- en: '[PRE58]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Overflow checking for constant expressions
  id: totrans-403
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常量表达式的溢出检查
- en: 'Regardless of the “checked” project setting, expressions evaluated at compile
    time are always overflow-checked—unless you apply the `unchecked` operator:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 无论“checked”项目设置如何，在编译时评估的表达式总是进行溢出检查——除非您应用`unchecked`运算符：
- en: '[PRE59]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Bitwise operators
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位操作符
- en: 'C# supports the following bitwise operators:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: C#支持以下位操作符：
- en: '| Operator | Meaning | Sample expression | Result |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| 操作符 | 含义 | 示例表达式 | 结果 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `~` | Complement | `~0xfU` | `0xfffffff0U` |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| `~` | 补码 | `~0xfU` | `0xfffffff0U` |'
- en: '| `&` | And | `0xf0 & 0x33` | `0x30` |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| `&` | 与 | `0xf0 & 0x33` | `0x30` |'
- en: '| `&#124;` | Or | `0xf0 &#124; 0x33` | `0xf3` |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | 或 | `0xf0 &#124; 0x33` | `0xf3` |'
- en: '| `^` | Exclusive Or | `0xff00 ^ 0x0ff0` | `0xf0f0` |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 异或 | `0xff00 ^ 0x0ff0` | `0xf0f0` |'
- en: '| `<<` | Shift left | `0x20 << 2` | `0x80` |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| `<<` | 左移 | `0x20 << 2` | `0x80` |'
- en: '| `>>` | Shift right | `0x20 >> 1` | `0x10` |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| `>>` | 右移 | `0x20 >> 1` | `0x10` |'
- en: '| `>>>` | Unsigned shift right | `int.MinValue >>> 1` | `0x40000000` |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| `>>>` | 无符号右移 | `int.MinValue >>> 1` | `0x40000000` |'
- en: The shift-right operator `(>>`) replicates the high-order bit when operating
    on signed integers, whereas the unsigned shift-right operator (`>>>`) does not.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 右移操作符`>>`在对有符号整数进行操作时复制高阶位，而无符号右移操作符(`>>>`)则不会。
- en: Note
  id: totrans-418
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Additional bitwise operations are exposed via a class called `BitOperations`
    in the `System.Numerics` namespace (see [“BitOperations”](ch06.html#bitoperations)).
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 附加的位操作通过名为`BitOperations`的类在`System.Numerics`命名空间中公开（参见[“位操作”](ch06.html#bitoperations)）。
- en: 8- and 16-Bit Integral Types
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8位和16位整数类型
- en: 'The 8- and 16-bit integral types are `byte`, `sbyte`, `short`, and `ushort`.
    These types lack their own arithmetic operators, so C# implicitly converts them
    to larger types as required. This can cause a compile-time error when trying to
    assign the result back to a small integral type:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 8 位和 16 位整数类型是 `byte`、`sbyte`、`short` 和 `ushort`。这些类型缺少自己的算术运算符，因此 C# 根据需要隐式将它们转换为较大的类型。当尝试将结果分配回小整数类型时，这可能会导致编译时错误：
- en: '[PRE60]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In this case, `x` and `y` are implicitly converted to `int` so that the addition
    can be performed. This means that the result is also an `int`, which cannot be
    implicitly cast back to a `short` (because it could cause loss of data). To make
    this compile, you must add an explicit cast:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`x` 和 `y` 被隐式转换为 `int` 以执行加法。这意味着结果也是一个 `int`，不能隐式地转回 `short`（因为可能导致数据丢失）。为了使其编译通过，必须添加显式转换：
- en: '[PRE61]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Special Float and Double Values
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊浮点和双精度值
- en: 'Unlike integral types, floating-point types have values that certain operations
    treat specially. These special values are NaN (Not a Number), +∞, −∞, and −0\.
    The `float` and `double` classes have constants for `NaN`, +∞, and −∞, as well
    as other values (`MaxValue`, `MinValue`, and `Epsilon`); for example:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 不像整数类型，浮点类型具有某些操作对待特殊的值。这些特殊值包括 NaN（不是一个数字）、+∞、−∞ 和 −0\. 类 `float` 和 `double`
    有 `NaN`、+∞ 和 −∞ 的常量，以及其他值（`MaxValue`、`MinValue` 和 `Epsilon`）；例如：
- en: '[PRE62]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The constants that represent special values for `double` and `float` are as
    follows:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 表示 `double` 和 `float` 特殊值的常量如下：
- en: '| Special value | Double constant | Float constant |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| 特殊值 | Double 常量 | Float 常量 |'
- en: '| --- | --- | --- |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| NaN | `double.NaN` | `float.NaN` |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| NaN | `double.NaN` | `float.NaN` |'
- en: '| +∞ | `double.PositiveInfinity` | `float.PositiveInfinity` |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| +∞ | `double.PositiveInfinity` | `float.PositiveInfinity` |'
- en: '| −∞ | `double.NegativeInfinity` | `float.NegativeInfinity` |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '| −∞ | `double.NegativeInfinity` | `float.NegativeInfinity` |'
- en: '| −0 | `−0.0` | `−0.0f` |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '| −0 | `−0.0` | `−0.0f` |'
- en: 'Dividing a nonzero number by zero results in an infinite value:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 将非零数除以零会得到无限值：
- en: '[PRE63]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Dividing zero by zero, or subtracting infinity from infinity, results in a
    NaN:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 将零除以零或从无穷大中减去无穷大会得到 NaN：
- en: '[PRE64]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'When using `==`, a NaN value is never equal to another value, even another
    NaN value:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `==` 时，NaN 值永远不等于另一个值，即使是另一个 NaN 值：
- en: '[PRE65]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'To test whether a value is NaN, you must use the `float.IsNaN` or `double.IsNaN`
    method:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试一个值是否为 NaN，必须使用 `float.IsNaN` 或 `double.IsNaN` 方法：
- en: '[PRE66]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'When using `object.Equals`, however, two NaN values are equal:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `object.Equals` 时，两个 NaN 值是相等的：
- en: '[PRE67]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note
  id: totrans-445
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注：
- en: NaNs are sometimes useful in representing special values. In Windows Presentation
    Foundation (WPF), `double.NaN` represents a measurement whose value is “Automatic.”
    Another way to represent such a value is with a nullable type ([Chapter 4](ch04.html#advanced_chash));
    another is with a custom struct that wraps a numeric type and adds an additional
    field ([Chapter 3](ch03.html#creating_types_in_chash)).
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: NaNs 有时用于表示特殊值。在 Windows Presentation Foundation (WPF) 中，`double.NaN` 表示值为“自动”的测量。表示这种值的另一种方式是使用可空类型（[第
    4 章](ch04.html#advanced_chash)）；另一种方式是使用包装数值类型并添加附加字段的自定义结构体（[第 3 章](ch03.html#creating_types_in_chash)）。
- en: '`float` and `double` follow the specification of the IEEE 754 format types,
    supported natively by almost all processors. You can find detailed information
    on the behavior of these types at [*http://www.ieee.org*](http://www.ieee.org).'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '`float` 和 `double` 遵循 IEEE 754 格式类型的规范，几乎所有处理器都原生支持。您可以在 [*http://www.ieee.org*](http://www.ieee.org)
    上找到有关这些类型行为的详细信息。'
- en: double Versus decimal
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: double 与 decimal
- en: '`double` is useful for scientific computations (such as computing spatial coordinates).
    `decimal` is useful for financial computations and values that are manufactured
    rather than the result of real-world measurements. Here’s a summary of the differences.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '`double` 对于科学计算（如计算空间坐标）很有用。`decimal` 对于金融计算和制造而非实际测量结果的值很有用。以下是两者差异的摘要。'
- en: '| Category | double | decimal |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | double | decimal |'
- en: '| --- | --- | --- |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Internal representation | Base 2 | Base 10 |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '| 内部表示 | Base 2 | Base 10 |'
- en: '| Decimal precision | 15–16 significant figures | 28–29 significant figures
    |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '| 十进制精度 | 15–16 有效数字 | 28–29 有效数字 |'
- en: '| Range | ±(~10^(−324) to ~10^(308)) | ±(~10^(−28) to ~10^(28)) |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '| 范围 | ±(~10^(−324) 到 ~10^308) | ±(~10^(−28) 到 ~10^28) |'
- en: '| Special values | +0, −0, +∞, −∞, and NaN | None |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '| 特殊值 | +0、−0、+∞、−∞ 和 NaN | 无 |'
- en: '| Speed | Native to processor | Non-native to processor (about 10 times slower
    than `double`) |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '| 速度 | 本地处理器原生 | 非本地处理器（大约比 `double` 慢 10 倍） |'
- en: Real Number Rounding Errors
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实数舍入误差
- en: '`float` and `double` internally represent numbers in base 2\. For this reason,
    only numbers expressible in base 2 are represented precisely. Practically, this
    means most literals with a fractional component (which are in base 10) will not
    be represented precisely; for example:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '`float`和`double`在内部以2进制表示数字。因此，只有能够用2进制表示的数字才能被精确表示。实际上，这意味着大多数带有小数部分的字面量（以10进制表示）将不能被精确表示；例如：'
- en: '[PRE68]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This is why `float` and `double` are bad for financial calculations. In contrast,
    `decimal` works in base 10 and so can precisely represent numbers expressible
    in base 10 (as well as its factors, base 2 and base 5). Because real literals
    are in base 10, `decimal` can precisely represent numbers such as 0.1\. However,
    neither `double` nor `decimal` can precisely represent a fractional number whose
    base 10 representation is recurring:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么`float`和`double`在财务计算中表现不佳。相比之下，`decimal`以10进制工作，因此可以精确表示以10进制表示的数字（以及它的因子，即2进制和5进制）。由于实数字面量是以10进制表示的，`decimal`可以精确表示诸如0.1这样的数字。然而，无论是`double`还是`decimal`都无法精确表示其10进制表示为循环的分数：
- en: '[PRE69]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This leads to accumulated rounding errors:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了累积的舍入误差：
- en: '[PRE70]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'which break equality and comparison operations:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 打破等式和比较运算的操作：
- en: '[PRE71]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Boolean Type and Operators
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔类型和运算符
- en: C#’s `bool` type (aliasing the `System.Boolean` type) is a logical value that
    can be assigned the literal `true` or `false`.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: C#的`bool`类型（别名`System.Boolean`类型）是一个逻辑值，可以赋值为字面量`true`或`false`。
- en: Although a Boolean value requires only one bit of storage, the runtime will
    use one byte of memory because this is the minimum chunk that the runtime and
    processor can efficiently work with. To avoid space inefficiency in the case of
    arrays, .NET provides a `BitArray` class in the `System.Collections` namespace
    that is designed to use just one bit per Boolean value.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管布尔值只需要存储一个比特，但运行时会使用一个字节的内存，因为这是运行时和处理器能有效处理的最小块。为了避免在数组情况下的空间效率低下，.NET在`System.Collections`命名空间中提供了一个`BitArray`类，设计用于每个布尔值只使用一个比特。
- en: bool Conversions
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔类型转换
- en: No casting conversions can be made from the `bool` type to numeric types, or
    vice versa.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 不能从`bool`类型进行数值类型或反之的强制转换。
- en: Equality and Comparison Operators
  id: totrans-471
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等式和比较运算符
- en: '`==` and `!=` test for equality and inequality of any type but always return
    a `bool` value.^([3](ch02.html#ch01fn3)) Value types typically have a very simple
    notion of equality:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '`==`和`!=`测试任何类型的相等和不等，但始终返回一个`bool`值。^([3](ch02.html#ch01fn3)) 值类型通常具有非常简单的相等概念：'
- en: '[PRE72]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'For reference types, equality, by default, is based on *reference*, as opposed
    to the actual *value* of the underlying object (more on this in [Chapter 6](ch06.html#dotnet_fundamentals)):'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 对于引用类型，默认情况下，等式是基于*引用*而不是底层对象的*值*（在[第6章](ch06.html#dotnet_fundamentals)中详细介绍）：
- en: '[PRE73]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The equality and comparison operators, `==`, `!=`, `<`, `>`, `>=`, and `<=`,
    work for all numeric types, but you should use them with caution with real numbers
    (as we saw in [“Real Number Rounding Errors”](#real_number_rounding_errors)).
    The comparison operators also work on `enum` type members by comparing their underlying
    integral-type values. We describe this in [“Enums”](ch03.html#enums-id00013).
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 等式和比较运算符`==`、`!=`、`<`、`>`、`>=`和`<=`适用于所有数值类型，但在使用实数时应谨慎（如我们在[“实数舍入误差”](#real_number_rounding_errors)中看到的）。比较运算符也适用于`enum`类型成员，通过比较它们的底层整数类型值进行比较。我们在[“枚举”](ch03.html#enums-id00013)中描述了这一点。
- en: We explain the equality and comparison operators in greater detail in [“Operator
    Overloading”](ch04.html#operator_overloading), and in [“Equality Comparison”](ch06.html#equality_comparison-id00067)
    and [“Order Comparison”](ch06.html#order_comparison).
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[“运算符重载”](ch04.html#operator_overloading)，[“等式比较”](ch06.html#equality_comparison-id00067)和[“顺序比较”](ch06.html#order_comparison)中更详细地解释了等式和比较运算符。
- en: Conditional Operators
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件运算符
- en: 'The `&&` and `||` operators test for *and* and *or* conditions. They are frequently
    used in conjunction with the `!` operator, which expresses *not*. In the following
    example, the `UseUmbrella` method returns `true` if it’s rainy or sunny (to protect
    us from the rain or the sun), as long as it’s not also windy (umbrellas are useless
    in the wind):'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '`&&`和`||`运算符测试*与*和*或*条件。它们经常与`!`运算符一起使用，表示*非*。在以下示例中，如果天气雨天或晴天（用来遮挡雨水或阳光），`UseUmbrella`方法将返回`true`，只要不是多风的情况（风中使用伞是无效的）：'
- en: '[PRE74]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The `&&` and `||` operators *short-circuit* evaluation when possible. In the
    preceding example, if it is windy, the expression `(rainy || sunny)` is not even
    evaluated. Short-circuiting is essential in allowing expressions such as the following
    to run without throwing a `NullReferenceException`:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '`&&`和`||`运算符在可能时*短路*评估。在上述示例中，如果有风，表达式`(rainy || sunny)`甚至不会被评估。短路在允许如下表达式运行而不抛出`NullReferenceException`时是至关重要的：'
- en: '[PRE75]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The `&` and `|` operators also test for *and* and *or* conditions:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '`&`和`|`运算符还测试*and*和*or*条件：'
- en: '[PRE76]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The difference is that they *do not short-circuit*. For this reason, they are
    rarely used in place of conditional operators.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于它们*不进行短路*。因此，它们很少用于替代条件运算符。
- en: Note
  id: totrans-486
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike in C and C++, the `&` and `|` operators perform (non-short-circuiting)
    Boolean comparisons when applied to `bool` expressions. The `&` and `|` operators
    perform *bitwise* operations only when applied to numbers.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 与C和C++不同，当应用于`bool`表达式时，`&`和`|`运算符执行（非短路）布尔比较。当应用于数字时，`&`和`|`运算符只执行*位*操作。
- en: Conditional operator (ternary operator)
  id: totrans-488
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件运算符（三元运算符）
- en: 'The *conditional operator* (more commonly called the *ternary operator* because
    it’s the only operator that takes three operands) has the form `q ? a : b`; thus,
    if condition `q` is true, `a` is evaluated; otherwise `b` is evaluated:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '*条件运算符*（更常称为*三元运算符*，因为它是唯一接受三个操作数的运算符）的形式为`q ? a : b`；因此，如果条件`q`为真，则评估`a`；否则评估`b`：'
- en: '[PRE77]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The conditional operator is particularly useful in Language-Integrated Query
    (LINQ) expressions ([Chapter 8](ch08.html#linq_queries)).
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 条件运算符在语言集成查询（LINQ）表达式中特别有用（[第 8 章](ch08.html#linq_queries)）。
- en: Strings and Characters
  id: totrans-492
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串和字符
- en: 'C#’s `char` type (aliasing the `System.Char` type) represents a Unicode character
    and occupies 2 bytes (UTF-16). A `char` literal is specified within single quotes:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: C#的`char`类型（别名`System.Char`类型）表示一个 Unicode 字符，占据 2 个字节（UTF-16）。`char`字面量在单引号内指定：
- en: '[PRE78]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '*Escape sequences* express characters that cannot be expressed or interpreted
    literally. An escape sequence is a backslash followed by a character with a special
    meaning; for example:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '*转义序列*表示不能以字面或直接方式表示或解释的字符。转义序列是一个反斜杠后跟具有特殊含义的字符；例如：'
- en: '[PRE79]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[Table 2-2](#escape_sequence_characters) shows the escape sequence characters.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2-2](#escape_sequence_characters)显示了转义序列字符。'
- en: Table 2-2\. Escape sequence characters
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-2\. 转义序列字符
- en: '| Char | Meaning | Value |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
  zh: '| Char | 含义 | 值 |'
- en: '| --- | --- | --- |'
  id: totrans-500
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `\''` | Single quote | `0x0027` |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '| `\''` | 单引号 | `0x0027` |'
- en: '| `\"` | Double quote | `0x0022` |'
  id: totrans-502
  prefs: []
  type: TYPE_TB
  zh: '| `\"` | 双引号 | `0x0022` |'
- en: '| `\\` | Backslash | `0x005C` |'
  id: totrans-503
  prefs: []
  type: TYPE_TB
  zh: '| `\\` | 反斜杠 | `0x005C` |'
- en: '| `\0` | Null | `0x0000` |'
  id: totrans-504
  prefs: []
  type: TYPE_TB
  zh: '| `\0` | 空字符 | `0x0000` |'
- en: '| `\a` | Alert | `0x0007` |'
  id: totrans-505
  prefs: []
  type: TYPE_TB
  zh: '| `\a` | 警报 | `0x0007` |'
- en: '| `\b` | Backspace | `0x0008` |'
  id: totrans-506
  prefs: []
  type: TYPE_TB
  zh: '| `\b` | 退格 | `0x0008` |'
- en: '| `\f` | Form feed | `0x000C` |'
  id: totrans-507
  prefs: []
  type: TYPE_TB
  zh: '| `\f` | 换页符 | `0x000C` |'
- en: '| `\n` | New line | `0x000A` |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
  zh: '| `\n` | 换行符 | `0x000A` |'
- en: '| `\r` | Carriage return | `0x000D` |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
  zh: '| `\r` | 回车符 | `0x000D` |'
- en: '| `\t` | Horizontal tab | `0x0009` |'
  id: totrans-510
  prefs: []
  type: TYPE_TB
  zh: '| `\t` | 水平制表符 | `0x0009` |'
- en: '| `\v` | Vertical tab | `0x000B` |'
  id: totrans-511
  prefs: []
  type: TYPE_TB
  zh: '| `\v` | 垂直制表符 | `0x000B` |'
- en: 'The `\u` (or `\x`) escape sequence lets you specify any Unicode character via
    its four-digit hexadecimal code:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '`\u`（或`\x`）转义序列允许您通过其四位十六进制代码指定任何 Unicode 字符：'
- en: '[PRE80]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Char Conversions
  id: totrans-514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符转换
- en: An implicit conversion from a `char` to a numeric type works for the numeric
    types that can accommodate an unsigned `short`. For other numeric types, an explicit
    conversion is required.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 从`char`到数值类型的隐式转换适用于可以容纳无符号`short`的数值类型。对于其他数值类型，需要显式转换。
- en: String Type
  id: totrans-516
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串类型
- en: 'C#’s string type (aliasing the `System.String` type, covered in depth in [Chapter 6](ch06.html#dotnet_fundamentals))
    represents an immutable (unmodifiable) sequence of Unicode characters. A string
    literal is specified within double quotes:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: C#的字符串类型（别名`System.String`类型，在[第 6 章](ch06.html#dotnet_fundamentals)深入讨论）表示一种不可变（不可修改）的
    Unicode 字符序列。字符串字面量在双引号内指定：
- en: '[PRE81]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Note
  id: totrans-519
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`string` is a reference type rather than a value type. Its equality operators,
    however, follow value-type semantics:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '`string`是引用类型而不是值类型。然而，其相等运算符遵循值类型语义：'
- en: '[PRE82]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The escape sequences that are valid for `char` literals also work inside strings:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`char`字面量有效的转义序列也适用于字符串内部：
- en: '[PRE83]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The cost of this is that whenever you need a literal backslash, you must write
    it twice:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 代价是每当需要字面反斜杠时，必须写两次：
- en: '[PRE84]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'To avoid this problem, C# allows *verbatim* string literals. A verbatim string
    literal is prefixed with `@` and does not support escape sequences. The following
    verbatim string is identical to the preceding one:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 为避免此问题，C#允许*verbatim*字符串直接文字。verbatim字符串直接文字以`@`为前缀，不支持转义序列。以下verbatim字符串与前述字符串相同：
- en: '[PRE85]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'A verbatim string literal can also span multiple lines:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: verbatim字符串直接文字也可以跨多行：
- en: '[PRE86]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'You can include the double-quote character in a verbatim literal by writing
    it twice:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将其写两次来在直接文字文本中包含双引号字符：
- en: '[PRE87]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Raw string literals (C# 11)
  id: totrans-532
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始字符串直接文字（C# 11）
- en: 'Wrapping a string in three or more quote characters (`"""`) creates a *raw
    string literal*. Raw string literals can contain almost any character sequence,
    without escaping or doubling up:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 用三个或更多引号字符（`"""`）包裹字符串会创建一个*原始字符串直接文字*。原始字符串直接文字可以包含几乎任何字符序列，无需转义或重复：
- en: '[PRE88]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Raw string literals make it easy to represent JSON, XML, and HTML literals,
    as well as regular expressions and source code. Should you need to include three
    (or more) quote characters in the string itself, you can do so by wrapping the
    string in four (or more) quote characters:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 原始字符串直接文字使得表示JSON、XML和HTML直接文字、正则表达式和源代码变得容易。如果需要在字符串本身中包含三个（或更多）引号字符，可以通过将字符串包装在四个（或更多）引号字符中来实现：
- en: '[PRE89]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Multiline raw string literals are subject to special rules. We can represent
    the string `"Line 1\r\nLine 2"` as follows:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 多行原始字符串直接文字受特殊规则约束。我们可以将字符串`"Line 1\r\nLine 2"`表示如下：
- en: '[PRE90]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Notice that the opening and closing quotes must be on separate lines to the
    string content. Additionally:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，开头和结尾的引号必须在不同的行上。另外：
- en: Whitespace following the *opening* `"""` (on the same line) is ignored.
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略*opening* `"""`（在同一行上）之后的空白。
- en: Whitespace preceding the *closing* `"""` (on the same line) is treated as *common
    indentation* and is removed from every line in the string. This lets you include
    indentation for source-code readability without that indentation becoming part
    of the string.
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同一行上，*closing* `"""` 之前的空白被视为*common indentation*并从字符串的每一行中移除。这使您可以包含用于源代码可读性的缩进，而不将该缩进作为字符串的一部分。
- en: 'Here’s another example to illustrate the multiline raw string literal rules:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是另一个示例，以说明多行原始字符串直接文字的规则：
- en: '[PRE91]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The output is as follows:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE92]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The compiler will generate an error if each line in a multiline raw string literal
    is not prefixed with the common indentation specified by the closing quotes.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多行原始字符串直接文字中的每一行未以关闭引号指定的公共缩进为前缀，则编译器将生成错误。
- en: Raw string literals can be interpolated, subject to special rules described
    in [“String interpolation”](#string_interpolation).
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 原始字符串直接文字可以被插值，受[“字符串插值”](#string_interpolation)描述的特殊规则约束。
- en: String concatenation
  id: totrans-548
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串连接
- en: 'The `+` operator concatenates two strings:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '`+`运算符连接两个字符串：'
- en: '[PRE93]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'One of the operands might be a nonstring value, in which case `ToString` is
    called on that value:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符的一个操作数可能是非字符串值，在这种情况下，将对该值调用`ToString`：
- en: '[PRE94]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Using the `+` operator repeatedly to build up a string is inefficient: a better
    solution is to use the `System.Text.StringBuilder` type (described in [Chapter 6](ch06.html#dotnet_fundamentals)).'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 反复使用`+`运算符来构建字符串是低效的：更好的解决方案是使用`System.Text.StringBuilder`类型（在[第6章](ch06.html#dotnet_fundamentals)中描述）。
- en: String interpolation
  id: totrans-554
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串插值
- en: 'A string preceded with the `$` character is called an *interpolated string*.
    Interpolated strings can include expressions enclosed in braces:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 以`$`字符为前缀的字符串称为*插值字符串*。插值字符串可以包含用大括号括起来的表达式：
- en: '[PRE95]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Any valid C# expression of any type can appear within the braces, and C# will
    convert the expression to a string by calling its `ToString` method or equivalent.
    You can change the formatting by appending the expression with a colon and a *format
    string* (format strings are described in [“String.Format and composite format
    strings”](ch06.html#stringdotformat_and_composite_format_st)):'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类型的有效C#表达式都可以出现在大括号内，并且C#将通过调用其`ToString`方法或等效方法将表达式转换为字符串。您可以通过追加表达式和冒号以及*格式字符串*来更改格式（格式字符串在[“String.Format和组合格式字符串”](ch06.html#stringdotformat_and_composite_format_str)中描述）：
- en: '[PRE96]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Should you need to use a colon for another purpose (such as a ternary conditional
    operator, which we’ll cover later), you must wrap the entire expression in parentheses:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要为其他目的使用冒号（例如三元条件运算符，我们稍后会讨论），必须将整个表达式包装在括号中：
- en: '[PRE97]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'From C# 10, interpolated strings can be constants, as long as the interpolated
    values are constants:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 10开始，插值字符串可以是常量，只要插值的值是常量：
- en: '[PRE98]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'From C# 11, interpolated strings are permitted to span multiple lines (whether
    standard or verbatim):'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 11 开始，允许插值字符串跨多行（无论是标准还是文本）：
- en: '[PRE99]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Raw string literals (from C# 11) can also be interpolated:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 原始字符串字面量（从 C# 11 开始）也可以插值：
- en: '[PRE100]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'To include a brace literal in an interpolated string:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 要在插值字符串中包含大括号字面量：
- en: With standard and verbatim string literals, repeat the desired brace character.
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准和文本字符串字面量时，重复所需的大括号字符。
- en: With raw string literals, change the interpolation sequence by repeating the
    `$` prefix.
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原始字符串字面量时，通过重复`$`前缀改变插值序列。
- en: 'Using two (or more) `$` characters in a raw string literal prefix changes the
    interpolation sequence from one brace to two (or more) braces:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始字符串字面量前使用两个（或更多）`$`字符会改变插值序列，从一个大括号变为两个（或更多）大括号：
- en: '[PRE101]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: This preserves the ability to copy-and-paste text into a raw string literal
    without needing to modify the string.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 这保留了将文本复制粘贴到原始字符串字面量中而无需修改字符串的能力。
- en: String comparisons
  id: totrans-573
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串比较
- en: To perform *equality* comparisons with strings, you can use the `==` operator
    (or one of `string`’s `Equals` methods). For *order* comparison, you must use
    the string’s `CompareTo` method; the `<` and `>` operators are unsupported. We
    describe equality and order comparison in detail in [“Comparing Strings”](ch06.html#comparing_strings).
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`==`运算符（或`string`的`Equals`方法之一）执行*相等*比较，必须使用字符串的`CompareTo`方法进行*顺序*比较；不支持`<`和`>`运算符。我们在[“比较字符串”](ch06.html#comparing_strings)中详细描述了相等性和顺序比较。
- en: UTF-8 Strings
  id: totrans-575
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UTF-8 字符串
- en: 'From C# 11, you can use the `u8` suffix to create string literals encoded in
    UTF-8 rather than UTF-16\. This feature is intended for advanced scenarios such
    as the low-level handling of JSON text in performance hotspots:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 11 开始，可以使用`u8`后缀创建以 UTF-8 编码而不是 UTF-16 编码的字符串字面量。此功能适用于高级场景，例如在性能热点处低级处理
    JSON 文本：
- en: '[PRE102]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The underlying type is `ReadOnlySpan<byte>`, which we cover in [Chapter 23](ch23.html#spanless_thantgreater_than_and-id00089).
    You can convert this to an array by calling the `ToArray()` method.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 底层类型是`ReadOnlySpan<byte>`，我们在[第 23 章](ch23.html#spanless_thantgreater_than_and-id00089)中介绍了它。您可以调用`ToArray()`方法将其转换为数组。
- en: Arrays
  id: totrans-579
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: An array represents a fixed number of variables (called *elements*) of a particular
    type. The elements in an array are always stored in a contiguous block of memory,
    providing highly efficient access.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 数组表示特定类型的固定数量变量（称为*元素*）。数组中的元素总是存储在连续的内存块中，提供高效的访问。
- en: 'An array is denoted with square brackets after the element type:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 数组在元素类型后用方括号表示：
- en: '[PRE103]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Square brackets also *index* the array, accessing a particular element by position:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号还用于*索引*数组，通过位置访问特定元素。
- en: '[PRE104]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'This prints “e” because array indexes start at 0\. You can use a `for` loop
    statement to iterate through each element in the array. The `for` loop in this
    example cycles the integer `i` from `0` to `4`:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印“e”，因为数组索引从0开始。您可以使用`for`循环语句迭代数组中的每个元素。在此示例中，`for`循环从整数`i`循环到`4`：
- en: '[PRE105]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The `Length` property of an array returns the number of elements in the array.
    After an array has been created, you cannot change its length. The `System.Collection`
    namespace and subnamespaces provide higher-level data structures, such as dynamically
    sized arrays and dictionaries.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的`Length`属性返回数组中的元素数量。创建数组后，无法更改其长度。`System.Collection`命名空间及其子命名空间提供了更高级的数据结构，例如动态大小的数组和字典。
- en: 'An *array initialization expression* lets you declare and populate an array
    in a single step:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组初始化表达式*允许您在单个步骤中声明和填充数组：'
- en: '[PRE106]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Or simply:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 或简单地说：
- en: '[PRE107]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Note
  id: totrans-592
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'From C# 12, you can use square brackets instead of curly braces:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 12 开始，可以使用方括号代替花括号：
- en: '[PRE108]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'This is called a *collection expression* and has the advantage of also working
    when calling methods:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为*集合表达式*，其优点在于在调用方法时也可以使用：
- en: '[PRE109]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Collection expressions also work with other collection types such as lists and
    sets—see [“Collection Initializers and Collection Expressions”](ch04.html#collection_initializers_and_collection).
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 集合表达式还适用于其他集合类型，如列表和集合——参见[“集合初始化器和集合表达式”](ch04.html#collection_initializers_and_collection)。
- en: All arrays inherit from the `System.Array` class, providing common services
    for all arrays. These members include methods to get and set elements regardless
    of the array type. We describe them in [“The Array Class”](ch07.html#the_array_class).
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 所有数组都继承自`System.Array`类，为所有数组提供共享服务。这些成员包括无论数组类型如何都能获取和设置元素的方法。我们在[“数组类”](ch07.html#the_array_class)中描述了它们。
- en: Default Element Initialization
  id: totrans-599
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认元素初始化
- en: 'Creating an array always preinitializes the elements with default values. The
    default value for a type is the result of a bitwise zeroing of memory. For example,
    consider creating an array of integers. Because `int` is a value type, this allocates
    1,000 integers in one contiguous block of memory. The default value for each element
    will be 0:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数组时，总是使用默认值预初始化元素。类型的默认值是内存的比特位清零结果。例如，考虑创建整数数组。因为`int`是值类型，这将在内存中分配1,000个整数，连续分配的内存块中每个元素的默认值为0：
- en: '[PRE110]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Value types versus reference types
  id: totrans-602
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 值类型与引用类型
- en: 'Whether an array element type is a value type or a reference type has important
    performance implications. When the element type is a value type, each element
    value is allocated as part of the array, as shown here:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 数组元素类型是值类型还是引用类型对性能有重要影响。当元素类型是值类型时，每个元素值作为数组的一部分分配，如下所示：
- en: '[PRE111]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Had `Point` been a class, creating the array would have merely allocated 1,000
    null references:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Point`是一个类，创建数组只会分配1,000个空引用：
- en: '[PRE112]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'To avoid this error, we must explicitly instantiate 1,000 `Point`s after instantiating
    the array:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 要避免此错误，我们必须在实例化数组后显式实例化1,000个`Point`：
- en: '[PRE113]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'An array *itself* is always a reference type object, regardless of the element
    type. For instance, the following is legal:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数组 *本身* 总是一个引用类型对象，无论元素类型如何。例如，以下操作是合法的：
- en: '[PRE114]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Indices and Ranges
  id: totrans-611
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引和范围
- en: '*Indices and ranges* (introduced in C# 8) simplify working with elements or
    portions of an array.'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '*索引和范围*（在C# 8中引入）简化了处理数组元素或部分的工作。'
- en: Note
  id: totrans-613
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Indices and ranges also work with the CLR types `Span<T>` and `ReadOnlySpan<T>`
    (see [Chapter 23](ch23.html#spanless_thantgreater_than_and-id00089)).
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 索引和范围也适用于CLR类型`Span<T>`和`ReadOnlySpan<T>`（参见[第23章](ch23.html#spanless_thantgreater_than_and-id00089)）。
- en: You can also make your own types work with indices and ranges, by defining an
    indexer of type `Index` or `Range` (see [“Indexers”](ch03.html#indexers)).
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过定义`Index`或`Range`类型的索引器，使自定义类型与索引和范围一起工作（参见[“索引器”](ch03.html#indexers)）。
- en: Indices
  id: totrans-616
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引
- en: 'Indices let you refer to elements relative to the *end* of an array, with the
    `^` operator. `^1` refers to the last element, `^2` refers to the second-to-last
    element, and so on:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 索引允许您使用`^`运算符相对于数组的*末尾*引用元素。`^1`引用最后一个元素，`^2`引用倒数第二个元素，依此类推：
- en: '[PRE115]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: (`^0` equals the length of the array, so `vowels[^0]` generates an error.)
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: （`^0`等于数组的长度，因此`vowels[^0]`将生成错误。）
- en: 'C# implements indices with the help of the `Index` type, so you can also do
    the following:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: C# 使用`Index`类型实现索引，因此您也可以执行以下操作：
- en: '[PRE116]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Ranges
  id: totrans-622
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 范围
- en: 'Ranges let you “slice” an array by using the `..` operator:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 范围允许您通过使用`..`运算符来“切片”数组：
- en: '[PRE117]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The second number in the range is *exclusive*, so `..2` returns the elements
    *before* `vowels[2]`.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 范围中的第二个数字是*排除的*，因此`..2`返回`vowels[2]`之前的元素。
- en: 'You can also use the `^` symbol in ranges. The following returns the last two
    characters:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在范围中使用`^`符号。以下返回最后两个字符：
- en: '[PRE118]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'C# implements ranges with the help of the `Range` type, so you can also do
    the following:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: C# 使用`Range`类型实现范围，因此您也可以执行以下操作：
- en: '[PRE119]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Multidimensional Arrays
  id: totrans-630
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多维数组
- en: 'Multidimensional arrays come in two varieties: *rectangular* and *jagged*.
    Rectangular arrays represent an *n*-dimensional block of memory, and jagged arrays
    are arrays of arrays.'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 多维数组有两种类型：*矩形*和*嵌套*。矩形数组表示一个*n*维内存块，而嵌套数组是数组的数组。
- en: Rectangular arrays
  id: totrans-632
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 矩形数组
- en: 'Rectangular arrays are declared using commas to separate each dimension. The
    following declares a rectangular two-dimensional array for which the dimensions
    are 3 by 3:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逗号分隔每个维度声明矩形数组。以下声明了维度为3乘3的矩形二维数组：
- en: '[PRE120]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The `GetLength` method of an array returns the length for a given dimension
    (starting at 0):'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的`GetLength`方法返回给定维度（从0开始）的长度：
- en: '[PRE121]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'You can initialize a rectangular array with explicit values. The following
    code creates an array identical to the previous example:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用显式值初始化矩形数组。以下代码创建与前面示例相同的数组：
- en: '[PRE122]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Jagged arrays
  id: totrans-639
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌套数组
- en: 'Jagged arrays are declared using successive square brackets to represent each
    dimension. Here is an example of declaring a jagged two-dimensional array for
    which the outermost dimension is 3:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 声明嵌套数组时，使用连续的方括号来表示每个维度。以下是声明外部维度为3的嵌套二维数组的示例：
- en: '[PRE123]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Note
  id: totrans-642
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Interestingly, this is `new int[3][]` and not `new int[][3]`. Eric Lippert has
    written [an excellent article](http://albahari.com/jagged) on why this is so.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，这是`new int[3][]`而不是`new int[][3]`。Eric Lippert在[这篇优秀的文章](http://albahari.com/jagged)中详细解释了为什么会这样。
- en: 'The inner dimensions aren’t specified in the declaration because, unlike a
    rectangular array, each inner array can be an arbitrary length. Each inner array
    is implicitly initialized to null rather than an empty array. You must manually
    create each inner array:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 声明中未指定内部维度，因为与矩形数组不同，每个内部数组可以是任意长度。每个内部数组隐式初始化为null，而不是空数组。您必须手动创建每个内部数组：
- en: '[PRE124]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'You can initialize a jagged array with explicit values. The following code
    creates an array identical to the previous example with an additional element
    at the end:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用显式值初始化锯齿数组。以下代码创建了一个与上一个示例相同的数组，并在末尾添加了一个额外的元素：
- en: '[PRE125]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Simplified Array Initialization Expressions
  id: totrans-648
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简化的数组初始化表达式
- en: 'There are two ways to shorten array initialization expressions. The first is
    to omit the `new` operator and type qualifications:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 缩短数组初始化表达式有两种方法。第一种是省略`new`运算符和类型限定符：
- en: '[PRE126]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: (From C# 12, you can use square brackets instead of braces with single-dimensional
    arrays.)
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: （从C# 12开始，您可以在单维数组中使用方括号而不是大括号。）
- en: 'The second approach is to use the `var` keyword, which instructs the compiler
    to implicitly type a local variable. Here are simple examples:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是使用`var`关键字，它指示编译器隐式地为局部变量赋予类型。以下是简单的示例：
- en: '[PRE127]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The same principle can be applied to arrays, except that it can be taken one
    stage further. By omitting the type qualifier after the `new` keyword, the compiler
    infers the array type:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的原则也适用于数组，只是可以进一步进行。通过在`new`关键字后省略类型限定符，编译器推断出数组类型：
- en: '[PRE128]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Here’s how we can apply this to multidimensional arrays:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何将其应用于多维数组的方法：
- en: '[PRE129]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'For this to work, the elements must all be implicitly convertible to a single
    type (and at least one of the elements must be of that type, and there must be
    exactly one best type), as in the following example:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其工作，所有元素都必须隐式转换为单一类型（至少一个元素必须是该类型，并且必须有一个最佳类型），如下例所示：
- en: '[PRE130]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Bounds Checking
  id: totrans-660
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边界检查
- en: 'All array indexing is bounds checked by the runtime. An `IndexOutOfRange​Excep⁠tion`
    is thrown if you use an invalid index:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时对所有数组索引进行边界检查。如果使用无效索引，则会抛出`IndexOutOfRange​Excep⁠tion`：
- en: '[PRE131]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Array bounds checking is necessary for type safety and simplifies debugging.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 数组边界检查对类型安全性和简化调试是必要的。
- en: Note
  id: totrans-664
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Generally, the performance hit from bounds checking is minor, and the Just-In-Time
    (JIT) compiler can perform optimizations, such as determining in advance whether
    all indexes will be safe before entering a loop, thus avoiding a check on each
    iteration. In addition, C# provides “unsafe” code that can explicitly bypass bounds
    checking (see [“Unsafe Code and Pointers”](ch04.html#unsafe_code_and_pointers)).
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，边界检查带来的性能损失很小，即时（JIT）编译器可以执行优化，例如在进入循环之前预先确定所有索引是否安全，从而避免每次迭代都进行检查。此外，C#提供了可以显式绕过边界检查的“不安全”代码（参见[“不安全代码和指针”](ch04.html#unsafe_code_and_pointers)）。
- en: Variables and Parameters
  id: totrans-666
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量和参数
- en: A variable represents a storage location that has a modifiable value. A variable
    can be a *local variable*, *parameter* (*value*, *ref*, or *out*, or *in*), *field*
    (*instance* or *static*), or *array element*.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 变量表示具有可修改值的存储位置。变量可以是*局部变量*、*参数*（*值*、*ref*、*out*或*in*）、*字段*（*实例*或*静态*）或*数组元素*。
- en: The Stack and the Heap
  id: totrans-668
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈和堆
- en: The stack and the heap are the places where variables reside. Each has very
    different lifetime semantics.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 栈和堆是变量驻留的地方。它们具有非常不同的生存周期语义。
- en: Stack
  id: totrans-670
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 栈
- en: 'The stack is a block of memory for storing local variables and parameters.
    The stack logically grows and shrinks as a method or function is entered and exited.
    Consider the following method (to avoid distraction, input argument checking is
    ignored):'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是用于存储局部变量和参数的内存块。栈在进入和退出方法或函数时逻辑增长和收缩。考虑以下方法（为了避免分散注意力，忽略了输入参数检查）：
- en: '[PRE132]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: This method is recursive, meaning that it calls itself. Each time the method
    is entered, a new `int` is allocated on the stack, and each time the method exits,
    the `int` is deallocated.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法是递归的，意味着它调用自身。每次进入方法时，在堆栈上分配一个新的`int`，每次退出方法时，`int`都会被释放。
- en: Heap
  id: totrans-674
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆
- en: The heap is the memory in which *objects* (i.e., reference-type instances) reside.
    Whenever a new object is created, it is allocated on the heap, and a reference
    to that object is returned. During a program’s execution, the heap begins filling
    up as new objects are created. The runtime has a garbage collector that periodically
    deallocates objects from the heap, so your program does not run out of memory.
    An object is eligible for deallocation as soon as it’s not referenced by anything
    that’s itself “alive.”
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是 *对象*（即引用类型实例）所驻留的内存。每当创建新对象时，它都会被分配到堆上，并返回对该对象的引用。程序执行期间，堆会随着新对象的创建而填充。运行时有一个垃圾收集器定期从堆中释放对象，以确保程序不会耗尽内存。一个对象在不再被任何“活动”的引用引用时，就有资格被回收。
- en: In the following example, we begin by creating a `StringBuilder` object referenced
    by the variable `ref1` and then write out its content. That `StringBuilder` object
    is then immediately eligible for garbage collection because nothing subsequently
    uses it.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们首先创建一个由变量 `ref1` 引用的 `StringBuilder` 对象，然后输出其内容。由于后续没有任何使用它的操作，这个
    `StringBuilder` 对象随即成为垃圾回收的对象。
- en: 'Then, we create another `StringBuilder` referenced by variable `ref2` and copy
    that reference to `ref3`. Even though `ref2` is not used after that point, `ref3`
    keeps the same `StringBuilder` object alive—ensuring that it doesn’t become eligible
    for collection until we’ve finished using `ref3`:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们创建另一个由变量 `ref2` 引用的 `StringBuilder`，并将该引用复制给 `ref3`。尽管此后未再使用 `ref2`，但 `ref3`
    保持对同一 `StringBuilder` 对象的引用，确保在我们完成对 `ref3` 的使用之前，它不会成为回收对象：
- en: '[PRE133]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Value-type instances (and object references) live wherever the variable was
    declared. If the instance was declared as a field within a class type, or as an
    array element, that instance lives on the heap.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型实例（以及对象引用）存在于变量声明的位置。如果实例被声明为类类型的字段或数组元素，则该实例存在于堆上。
- en: Note
  id: totrans-680
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can’t explicitly delete objects in C#, as you can in C++. An unreferenced
    object is eventually collected by the garbage collector.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，你无法像在 C++ 中那样显式地删除对象。一个未被引用的对象最终会被垃圾收集器收集。
- en: The heap also stores static fields. Unlike objects allocated on the heap (which
    can be garbage-collected), these live until the process ends.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 堆还存储静态字段。与分配在堆上的对象不同（可以进行垃圾回收），这些字段一直存在，直到进程结束。
- en: Definite Assignment
  id: totrans-683
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 明确赋值
- en: 'C# enforces a definite assignment policy. In practice, this means that outside
    of an `unsafe` or interop context, you can’t accidentally access uninitialized
    memory. Definite assignment has three implications:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: C# 强制执行明确赋值策略。在实践中，这意味着在 `unsafe` 或互操作上下文之外，你不能意外地访问未初始化的内存。明确赋值有三个影响：
- en: Local variables must be assigned a value before they can be read.
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部变量在使用之前必须被赋予一个值。
- en: Function arguments must be supplied when a method is called (unless marked as
    optional; see [“Optional parameters”](#optional_parameters)).
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用方法时，必须提供函数参数（除非标记为可选；参见 [“可选参数”](#optional_parameters)）。
- en: All other variables (such as fields and array elements) are automatically initialized
    by the runtime.
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他所有变量（如字段和数组元素）都会由运行时自动初始化。
- en: 'For example, the following code results in a compile-time error:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码会导致编译时错误：
- en: '[PRE134]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Fields and array elements are automatically initialized with the default values
    for their type. The following code outputs `0` because array elements are implicitly
    assigned to their default values:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 字段和数组元素会自动使用其类型的默认值进行初始化。以下代码输出 `0`，因为数组元素会隐式地赋值为它们的默认值：
- en: '[PRE135]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'The following code outputs `0`, because fields are implicitly assigned a default
    value (whether instance or static):'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码输出 `0`，因为字段会隐式地被赋予一个默认值（无论是实例字段还是静态字段）：
- en: '[PRE136]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Default Values
  id: totrans-694
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认值
- en: 'All type instances have a default value. The default value for the predefined
    types is the result of a bitwise zeroing of memory:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类型实例都有一个默认值。预定义类型的默认值是对内存的比特位清零的结果：
- en: '| Type | Default value |'
  id: totrans-696
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 默认值 |'
- en: '| --- | --- |'
  id: totrans-697
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Reference types (and nullable value types) | `null` |'
  id: totrans-698
  prefs: []
  type: TYPE_TB
  zh: '| 引用类型（以及可空值类型） | `null` |'
- en: '| Numeric and enum types | `0` |'
  id: totrans-699
  prefs: []
  type: TYPE_TB
  zh: '| 数值和枚举类型 | `0` |'
- en: '| `char` type | `''\0''` |'
  id: totrans-700
  prefs: []
  type: TYPE_TB
  zh: '| `char` 类型 | `''\0''` |'
- en: '| `bool` type | `false` |'
  id: totrans-701
  prefs: []
  type: TYPE_TB
  zh: '| `bool` 类型 | `false` |'
- en: 'You can obtain the default value for any type via the `default` keyword:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 `default` 关键字获取任何类型的默认值：
- en: '[PRE137]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'You can optionally omit the type when it can be inferred:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型可以被推断时，可以选择省略类型声明：
- en: '[PRE138]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: The default value in a custom value type (i.e., `struct`) is the same as the
    default value for each field defined by the custom type.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义值类型（即 `struct`）中的默认值与定义的每个字段的默认值相同。
- en: Parameters
  id: totrans-707
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数
- en: 'A method may have a sequence of parameters. Parameters define the set of arguments
    that must be provided for that method. In the following example, the method `Foo`
    has a single parameter named `p`, of type `int`:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方法可以有一系列参数。参数定义了必须为该方法提供的参数集。在以下示例中，方法 `Foo` 有一个名为 `p` 的参数，类型为 `int`：
- en: '[PRE139]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'You can control how parameters are passed with the `ref`, `in`, and `out` modifiers:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `ref`、`in` 和 `out` 修饰符来控制参数的传递方式：
- en: '| Parameter modifier | Passed by | Variable must be definitely assigned |'
  id: totrans-711
  prefs: []
  type: TYPE_TB
  zh: '| 参数修饰符 | 传递方式 | 变量必须有明确的赋值 |'
- en: '| --- | --- | --- |'
  id: totrans-712
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| (None) | Value | Going in |'
  id: totrans-713
  prefs: []
  type: TYPE_TB
  zh: '| (无) | 值 | 传递进去 |'
- en: '| `ref` | Reference | Going in |'
  id: totrans-714
  prefs: []
  type: TYPE_TB
  zh: '| `ref` | 引用 | 传递进去 |'
- en: '| `in` | Reference (read-only) | Going in |'
  id: totrans-715
  prefs: []
  type: TYPE_TB
  zh: '| `in` | 引用（只读） | 传递进去 |'
- en: '| `out` | Reference | Going out |'
  id: totrans-716
  prefs: []
  type: TYPE_TB
  zh: '| `out` | 引用 | 传递出去 |'
- en: Passing arguments by value
  id: totrans-717
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按值传递参数
- en: 'By default, arguments in C# are *passed by value*, which is by far the most
    common case. This means that a copy of the value is created when passed to the
    method:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，C# 中的参数是按值传递的，这是最常见的情况。这意味着传递到方法时会创建值的副本：
- en: '[PRE140]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Assigning `p` a new value does not change the contents of `x`, because `p` and
    `x` reside in different memory locations.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `p` 赋予一个新值不会改变 `x` 的内容，因为 `p` 和 `x` 存在于不同的内存位置。
- en: 'Passing a reference-type argument by value copies the *reference* but not the
    object. In the following example, `Foo` sees the same `StringBuilder` object we
    instantiated (`sb`) but has an independent *reference* to it. In other words,
    `sb` and `fooSB` are separate variables that reference the same `StringBuilder`
    object:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 按引用类型参数传递的参数按值复制*引用*但不复制对象。在以下示例中，`Foo` 看到我们实例化的同一个 `StringBuilder` 对象（`sb`），但是具有独立的*引用*。换句话说，`sb`
    和 `fooSB` 是引用同一个 `StringBuilder` 对象的不同变量：
- en: '[PRE141]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Because `fooSB` is a *copy* of a reference, setting it to `null` doesn’t make
    `sb` null. (If, however, `fooSB` was declared and called with the `ref` modifier,
    `sb` *would* become null.)
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `fooSB` 是引用的*副本*，将其设置为 `null` 不会使 `sb` 变为 null。（但是，如果 `fooSB` 声明并使用了 `ref`
    修饰符，`sb` *会* 变为 null。）
- en: The ref modifier
  id: totrans-724
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`ref` 修饰符'
- en: 'To *pass by reference*, C# provides the `ref` parameter modifier. In the following
    example, `p` and `x` refer to the same memory locations:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 要按引用传递，C# 提供了 `ref` 参数修饰符。在以下示例中，`p` 和 `x` 指向相同的内存位置：
- en: '[PRE142]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Now assigning `p` a new value changes the contents of `x`. Notice how the `ref`
    modifier is required both when writing and when calling the method.^([4](ch02.html#ch01fn4))
    This makes it very clear what’s going on.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将 `p` 赋予一个新值会改变 `x` 的内容。请注意，在编写和调用方法时都需要 `ref` 修饰符。^([4](ch02.html#ch01fn4))
    这使得发生的事情非常清楚。
- en: 'The `ref` modifier is essential in implementing a swap method (in [“Generics”](ch03.html#generics),
    we show how to write a swap method that works with any type):'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '`ref` 修饰符在实现交换方法（在[“泛型”](ch03.html#generics)中，我们展示了如何编写适用于任何类型的交换方法）中至关重要：'
- en: '[PRE143]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Note
  id: totrans-730
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A parameter can be passed by reference or by value, regardless of whether the
    parameter type is a reference type or a value type.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以按引用或按值传递，无论参数类型是引用类型还是值类型。
- en: The out modifier
  id: totrans-732
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: out 修饰符
- en: 'An `out` argument is like a `ref` argument except for the following:'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '`out` 参数与 `ref` 参数类似，除了以下情况：'
- en: It need not be assigned before going into the function.
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入函数之前不需要对其进行赋值。
- en: It must be assigned before it comes *out* of the function.
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在离开函数之前必须为其分配一个值。
- en: 'The `out` modifier is most commonly used to get multiple return values back
    from a method; for example:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '`out` 修饰符最常用于从方法中获取多个返回值；例如：'
- en: '[PRE144]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Like a `ref` parameter, an `out` parameter is passed by reference.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 像 `ref` 参数一样，`out` 参数也是按引用传递的。
- en: Out variables and discards
  id: totrans-739
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Out 变量和丢弃
- en: 'You can declare variables on the fly when calling methods with `out` parameters.
    We can replace the first two lines in our preceding example with this:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用具有 `out` 参数的方法时，您可以在调用时临时声明变量。我们可以用以下方式替换我们前面示例的前两行：
- en: '[PRE145]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'When calling methods with multiple `out` parameters, sometimes you’re not interested
    in receiving values from all the parameters. In such cases, you can “discard”
    the ones in which you’re uninterested by using an underscore:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用具有多个 `out` 参数的方法时，有时您对其中一些参数的值不感兴趣。在这种情况下，您可以使用下划线“丢弃”您不感兴趣的参数：
- en: '[PRE146]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'In this case, the compiler treats the underscore as a special symbol, called
    a *discard*. You can include multiple discards in a single call. Assuming `SomeBigMethod`
    has been defined with seven `**out**` parameters, we can ignore all but the fourth,
    as follows:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，编译器将下划线视为一个特殊符号，称为*丢弃*。你可以在单个调用中包含多个丢弃。假设`SomeBigMethod`已经定义了七个`**out**`参数，我们可以忽略除了第四个之外的所有参数，如下所示：
- en: '[PRE147]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'For backward compatibility, this language feature will not take effect if a
    real underscore variable is in scope:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向后兼容，如果实际下划线变量在作用域中，则不会生效：
- en: '[PRE148]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Implications of passing by reference
  id: totrans-748
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递引用的影响
- en: 'When you pass an argument by reference, you alias the storage location of an
    existing variable rather than create a new storage location. In the following
    example, the variables `x` and `y` represent the same instance:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 当您通过引用传递参数时，您将现有变量的存储位置别名化，而不是创建一个新的存储位置。在以下示例中，变量`x`和`y`表示同一个实例：
- en: '[PRE149]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: The in modifier
  id: totrans-751
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: in修饰符
- en: An `in` parameter is similar to a `ref` parameter except that the argument’s
    value cannot be modified by the method (doing so generates a compile-time error).
    This modifier is most useful when passing a large value type to the method because
    it allows the compiler to avoid the overhead of copying the argument prior to
    passing it in while still protecting the original value from modification.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`参数类似于`ref`参数，但是方法不能修改参数的值（这样做会生成编译时错误）。当将大的值类型传递给方法时，这个修饰符非常有用，因为它允许编译器在传递参数之前避免复制参数的开销，同时仍然保护原始值不被修改。'
- en: 'Overloading solely on the presence of `in` is permitted:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅基于`in`的存在进行重载是允许的：
- en: '[PRE150]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'To call the second overload, the caller must use the `in` modifier:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用第二个重载，调用者必须使用`in`修饰符：
- en: '[PRE151]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: When there’s no ambiguity
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有歧义时
- en: '[PRE152]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'use of the `in` modifier is optional for the caller:'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 对于调用者来说，使用`in`修饰符是可选的：
- en: '[PRE153]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: To make this example meaningful, `SomeBigStruct` would be defined as a struct
    (see [“Structs”](ch03.html#structs)).
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这个例子有意义，`SomeBigStruct`应该被定义为一个结构体（参见[“结构体”](ch03.html#structs)）。
- en: The params modifier
  id: totrans-762
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: params修饰符
- en: 'The `params` modifier, if applied to the last parameter of a method, allows
    the method to accept any number of arguments of a particular type. The parameter
    type must be declared as a (single-dimensional) array, as shown in the following
    example:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`params`修饰符应用于方法的最后一个参数，则该方法可以接受特定类型的任意数量的参数。参数类型必须声明为（单维）数组，如下例所示：
- en: '[PRE154]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: If there are zero arguments in the `params` position, a zero-length array is
    created.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`params`位置没有参数，则创建一个长度为零的数组。
- en: 'You can also supply a `params` argument as an ordinary array. The first line
    in our example is semantically equivalent to this:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将`params`参数作为普通数组提供。我们示例中的第一行在语义上等同于这个：
- en: '[PRE155]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Optional parameters
  id: totrans-768
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选参数
- en: 'Methods, constructors, and indexers ([Chapter 3](ch03.html#creating_types_in_chash))
    can declare *optional parameters*. A parameter is optional if it specifies a *default
    value* in its declaration:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 方法、构造函数和索引器（见[第3章](ch03.html#creating_types_in_chash)）可以声明*可选参数*。如果参数在声明中指定了*默认值*，则该参数是可选的：
- en: '[PRE156]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'You can omit optional parameters when calling the method:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 调用方法时可以省略可选参数：
- en: '[PRE157]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'The *default argument* of `23` is actually *passed* to the optional parameter
    `x`—the compiler bakes the value 23 into the compiled code at the *calling* side.
    The preceding call to `Foo` is semantically identical to:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: '*默认参数*的`23`实际上*传递*给了可选参数`x`——编译器将值`23`嵌入编译代码中的*调用*端。前面对`Foo`的调用在语义上等同于：'
- en: '[PRE158]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: because the compiler simply substitutes the default value of an optional parameter
    wherever it is used.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 因为编译器简单地在使用时替换可选参数的默认值。
- en: Warning
  id: totrans-776
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Adding an optional parameter to a public method that’s called from another assembly
    requires recompilation of both assemblies—just as though the parameter were mandatory.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个可选参数到一个从另一个程序集调用的公共方法需要重新编译两个程序集——就像这个参数是必须的一样。
- en: The default value of an optional parameter must be specified by a constant expression,
    a parameterless constructor of a value type, or a `default` expression. Optional
    parameters cannot be marked with `ref` or `out`.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 可选参数的默认值必须由常量表达式、值类型的无参数构造函数或`default`表达式指定。可选参数不能标记为`ref`或`out`。
- en: 'Mandatory parameters must occur *before* optional parameters in both the method
    declaration and the method call (the exception is with `params` arguments, which
    still always come last). In the following example, the explicit value of `1` is
    passed to `x`, and the default value of `0` is passed to `y`:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 强制参数必须在方法声明和方法调用中*之前*的可选参数（例外是 `params` 参数，它们始终位于最后）。在以下示例中，显式值 `1` 被传递给 `x`，默认值
    `0` 被传递给 `y`：
- en: '[PRE159]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: You can do the converse (pass a default value to `x` and an explicit value to
    `y`) by combining optional parameters with *named arguments*.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将可选参数与*命名参数*结合使用来做相反的操作（向 `x` 传递默认值，向 `y` 传递显式值）。
- en: Named arguments
  id: totrans-782
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名参数
- en: 'Rather than identifying an argument by position, you can identify an argument
    by name:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是按位置标识参数，你可以按名称标识参数：
- en: '[PRE160]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Named arguments can occur in any order. The following calls to `Foo` are semantically
    identical:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 命名参数可以按任何顺序出现。以下对 `Foo` 的调用在语义上是相同的：
- en: '[PRE161]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Note
  id: totrans-787
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'A subtle difference is that argument expressions are evaluated in the order
    in which they appear at the *calling* site. In general, this makes a difference
    only with interdependent side-effecting expressions such as the following, which
    writes `0, 1`:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 一个微妙的差异是参数表达式在*调用*现场按出现顺序进行评估。通常，这只在互相关联的具有副作用的表达式（例如下面写出 `0, 1`）中有所不同。
- en: '[PRE162]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Of course, you would almost certainly avoid writing such code in practice!
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在实践中几乎肯定会避免编写这样的代码！
- en: 'You can mix named and positional arguments:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以混合使用命名和位置参数：
- en: '[PRE163]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'However, there is a restriction: positional arguments must come before named
    arguments unless they are used in the correct position. So, you could call `Foo`
    like this:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有一个限制：位置参数必须在命名参数之前，除非它们在正确的位置使用。因此，你可以像这样调用 `Foo`：
- en: '[PRE164]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'But not like this:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 但不是这样：
- en: '[PRE165]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Named arguments are particularly useful in conjunction with optional parameters.
    For instance, consider the following method:'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 命名参数在与可选参数结合使用时特别有用。例如，考虑以下方法：
- en: '[PRE166]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'You can call this supplying only a value for `d`, as follows:'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以只为 `d` 提供一个值进行调用，如下所示：
- en: '[PRE167]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: This is particularly useful when calling COM APIs, which we discuss in detail
    in [Chapter 24](ch24.html#native_and_com_interoperabilit).
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 这在调用 COM API 时特别有用，我们在[第 24 章](ch24.html#native_and_com_interoperabilit)中详细讨论。
- en: Ref Locals
  id: totrans-802
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ref Locals
- en: 'A somewhat esoteric feature of C# is that you can define a local variable that
    *references* an element in an array or field in an object (from C# 7):'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: C# 的一个相对生僻的特性是，你可以定义一个局部变量，*引用*数组中的元素或对象中的字段（从 C# 7 开始）：
- en: '[PRE168]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'In this example, `numRef` is a *reference* to `numbers[2]`. When we modify
    `numRef`, we modify the array element:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`numRef` 是对 `numbers[2]` 的*引用*。当我们修改 `numRef` 时，我们修改了数组元素：
- en: '[PRE169]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: The target for a ref local must be an array element, field, or local variable;
    it cannot be a *property* ([Chapter 3](ch03.html#creating_types_in_chash)). *Ref
    locals* are intended for specialized micro-optimization scenarios and are typically
    used in conjunction with *ref returns*.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: ref local 的目标必须是数组元素、字段或局部变量；不能是*属性*（见[第 3 章](ch03.html#creating_types_in_chash)）。*Ref
    locals* 用于专门的微优化场景，通常与*ref returns*一起使用。
- en: Ref Returns
  id: totrans-808
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ref 返回
- en: Note
  id: totrans-809
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `Span<T>` and `ReadOnlySpan<T>` types that we describe in [Chapter 23](ch23.html#spanless_thantgreater_than_and-id00089)
    use ref returns to implement a highly efficient indexer. Outside such scenarios,
    ref returns are not commonly used, and you can consider them a micro-optimization
    feature.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第 23 章](ch23.html#spanless_thantgreater_than_and-id00089)中描述的 `Span<T>`
    和 `ReadOnlySpan<T>` 类型使用 ref 返回来实现高效的索引器。除此类场景外，ref 返回并不常用，你可以将其视为微优化特性。
- en: 'You can return a *ref local* from a method. This is called a *ref return*:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从方法中返回一个*ref local*。这称为*ref return*：
- en: '[PRE170]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'If you omit the `ref` modifier on the calling side, it reverts to returning
    an ordinary value:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在调用端省略了 `ref` 修饰符，则会回归到返回普通值：
- en: '[PRE171]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'You also can use ref returns when defining a property or indexer:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义属性或索引器时，也可以使用 ref 返回：
- en: '[PRE172]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Such a property is implicitly writable, despite there being no `set` accessor:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管没有 `set` 访问器，这样的属性在隐式上是可写的：
- en: '[PRE173]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'You can prevent such modification by using `ref readonly`:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `ref readonly` 来防止这种修改：
- en: '[PRE174]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'The `ref readonly` modifier prevents modification while still enabling the
    performance gain of returning by reference. The gain would be very small in this
    case, because `x` is of type `string` (a reference type): no matter how long the
    `string`, the only inefficiency that you can hope to avoid is the copying of a
    single 32- or 64-bit *reference*. Real gains can occur with custom value types
    (see [“Structs”](ch03.html#structs)), but only if the struct is marked as `readonly`
    (otherwise, the compiler will perform a defensive copy).'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: '`ref readonly`修饰符防止修改，同时仍然允许通过引用返回以获得性能提升。在这种情况下，性能提升非常小，因为`x`是`string`类型（引用类型）：无论字符串有多长，你希望避免的唯一低效性只是单个32位或64位*引用*的复制。'
- en: Attempting to define an explicit `set` accessor on a *ref return* property or
    indexer is illegal.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在*ref返回*属性或索引器上定义显式的`set`访问器是非法的。
- en: var—Implicitly Typed Local Variables
  id: totrans-823
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: var—隐式类型局部变量
- en: 'It is often the case that you declare and initialize a variable in one step.
    If the compiler is able to infer the type from the initialization expression,
    you can use the keyword `var` in place of the type declaration; for example:'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 经常情况下，你会在一步内声明并初始化一个变量。如果编译器能够从初始化表达式推断出类型，你可以使用关键字`var`替代类型声明；例如：
- en: '[PRE175]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'This is precisely equivalent to the following:'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 这等效于以下内容：
- en: '[PRE176]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Because of this direct equivalence, implicitly typed variables are statically
    typed. For example, the following generates a compile-time error:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这种直接等价性，隐式类型变量是静态类型的。例如，以下代码会生成编译时错误：
- en: '[PRE177]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: Note
  id: totrans-830
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`var` can decrease code readability when you can’t deduce the type purely by
    looking at the variable declaration. For example:'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 当你无法仅通过查看变量声明来推断类型时，`var`可能会降低代码的可读性。例如：
- en: '[PRE178]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: What type is `x`?
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '`x`的类型是什么？'
- en: In [“Anonymous Types”](ch04.html#anonymous_types), we will describe a scenario
    in which the use of `var` is mandatory.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“匿名类型”](ch04.html#anonymous_types)中，我们将描述一种必须使用`var`的场景。
- en: Target-Typed new Expressions
  id: totrans-835
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标类型化的新表达式
- en: 'Another way to reduce lexical repetition is with *target-typed* `new` *expressions*
    (from C# 9):'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种减少词汇重复的方式是使用*目标类型化*的`new` *表达式*（从C# 9开始）：
- en: '[PRE179]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'This is precisely equivalent to:'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 这等效于：
- en: '[PRE180]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'The principle is that you can call `new` without specifying a type name if
    the compiler is able to unambiguously infer it. Target-typed `new` expressions
    are particularly useful when the variable declaration and initialization are in
    different parts of your code. A common example is when you want to initialize
    a field in a constructor:'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 原则是，如果编译器能够明确推断，可以在不指定类型名称的情况下调用`new`。目标类型化的`new`表达式特别适用于变量声明和初始化位于代码不同部分的情况。一个常见的例子是在构造函数中初始化字段时：
- en: '[PRE181]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Target-typed `new` expressions are also helpful in the following scenario:'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 目标类型化的`new`表达式在以下场景中也非常有用：
- en: '[PRE182]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: Expressions and Operators
  id: totrans-844
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式和操作符
- en: An *expression* essentially denotes a value. The simplest kinds of expressions
    are constants and variables. Expressions can be transformed and combined using
    operators. An *operator* takes one or more input *operands* to output a new expression.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*表达式*本质上表示一个值。最简单的表达式类型是常量和变量。表达式可以通过操作符进行转换和组合。*操作符*接受一个或多个输入*操作数*以生成一个新的表达式。
- en: 'Here is an example of a *constant expression*:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个*常量表达式*的示例：
- en: '[PRE183]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'We can use the `*` operator to combine two operands (the literal expressions
    `12` and `30`), as follows:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`*`操作符结合两个操作数（字面表达式`12`和`30`），如下所示：
- en: '[PRE184]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'We can build complex expressions because an operand can itself be an expression,
    such as the operand `(12 * 30)` in the following example:'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以构建复杂的表达式，因为操作数本身可以是一个表达式，例如以下示例中的操作数`(12 * 30)`：
- en: '[PRE185]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Operators in C# can be classed as *unary*, *binary*, or *ternary*, depending
    on the number of operands they work on (one, two, or three). The binary operators
    always use *infix* notation in which the operator is placed *between* the two
    operands.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的操作符可以被分类为*一元*、*二元*或*三元*，取决于它们操作的操作数数量（一个、两个或三个）。二元操作符总是使用*中缀*表示法，其中操作符被放置*在*两个操作数之间。
- en: Primary Expressions
  id: totrans-853
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主表达式
- en: 'Primary expressions include expressions composed of operators that are intrinsic
    to the basic plumbing of the language. Here is an example:'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 主表达式包括由语言基本结构内在操作符组成的表达式。以下是一个示例：
- en: '[PRE186]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: This expression is composed of two primary expressions. The first expression
    performs a member lookup (with the `.` operator), and the second expression performs
    a method call (with the `()` operator).
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 该表达式由两个主表达式组成。第一个表达式执行成员查找（使用`.`运算符），第二个表达式执行方法调用（使用`()`运算符）。
- en: Void Expressions
  id: totrans-857
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无值表达式
- en: 'A void expression is an expression that has no value, such as this:'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 无值表达式是指没有值的表达式，比如这个：
- en: '[PRE187]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'Because it has no value, you cannot use a void expression as an operand to
    build more complex expressions:'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它没有值，您不能将无值表达式用作操作数来构建更复杂的表达式：
- en: '[PRE188]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: Assignment Expressions
  id: totrans-862
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值表达式
- en: 'An assignment expression uses the `=` operator to assign the result of another
    expression to a variable; for example:'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值表达式使用`=`运算符将另一个表达式的结果分配给变量；例如：
- en: '[PRE189]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'An assignment expression is not a void expression—it has a value of whatever
    was assigned, and so can be incorporated into another expression. In the following
    example, the expression assigns `2` to `x` and `10` to `y`:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值表达式不是无值表达式——它具有被分配的值，因此可以并入另一个表达式。在以下示例中，该表达式将`2`赋给`x`，将`10`赋给`y`：
- en: '[PRE190]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'You can use this style of expression to initialize multiple values:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这种表达式样式来初始化多个值：
- en: '[PRE191]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'The *compound assignment operators* are syntactic shortcuts that combine assignment
    with another operator:'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: '*复合赋值运算符*是将赋值与另一个运算符结合的语法快捷方式：'
- en: '[PRE192]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '(A subtle exception to this rule is with *events*, which we describe in [Chapter 4](ch04.html#advanced_chash):
    the `+=` and `-=` operators here are treated specially and map to the event’s
    `add` and `remove` accessors.)'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: (对这一规则的一个微妙例外是关于*事件*的描述，在[第四章](ch04.html#advanced_chash)中：这里的`+=`和`-=`运算符被特殊对待，并映射到事件的`add`和`remove`访问器。)
- en: Operator Precedence and Associativity
  id: totrans-872
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运算符优先级和结合性
- en: When an expression contains multiple operators, *precedence* and *associativity*
    determine the order of their evaluation. Operators with higher precedence execute
    before operators of lower precedence. If the operators have the same precedence,
    the operator’s associativity determines the order of evaluation.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个表达式包含多个运算符时，*优先级*和*结合性*决定它们评估的顺序。具有较高优先级的运算符在低优先级运算符之前执行。如果运算符具有相同的优先级，则运算符的结合性决定评估的顺序。
- en: Precedence
  id: totrans-874
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优先级
- en: The following expression
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表达式
- en: '[PRE193]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'is evaluated as follows because `*` has a higher precedence than `+`:'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`*`的优先级高于`+`，所以它被解释如下：
- en: '[PRE194]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: Left-associative operators
  id: totrans-879
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 左结合运算符
- en: Binary operators (except for assignment, lambda, and null-coalescing operators)
    are *left-associative*; in other words, they are evaluated from left to right.
    For example, the following expression
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 除了赋值、lambda和空合并运算符之外，二元运算符（除了赋值、lambda和空合并运算符）都是*左结合*的；换句话说，它们从左到右进行评估。例如，以下表达式
- en: '[PRE195]'
  id: totrans-881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'is evaluated as follows:'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 被解释如下：
- en: '[PRE196]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'You can insert parentheses to change the actual order of evaluation:'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以插入括号来改变实际的评估顺序：
- en: '[PRE197]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: Right-associative operators
  id: totrans-886
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 右结合运算符
- en: The *assignment operators* as well as the lambda, null-coalescing, and conditional
    operators are *right-associative*; in other words, they are evaluated from right
    to left.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: '*赋值运算符*以及lambda、空合并和条件运算符是*右结合*的；换句话说，它们从右到左进行评估。'
- en: 'Right associativity allows multiple assignments such as the following to compile:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 右结合性允许多次分配，例如以下的编译：
- en: '[PRE198]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: This first assigns `3` to `y` and then assigns the result of that expression
    (`3`) to `x`.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将`3`赋给`y`，然后将该表达式的结果（`3`）赋给`x`。
- en: Operator Table
  id: totrans-891
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运算符表
- en: '[Table 2-3](#chash_operators_left_parenthesiscategor) lists C#’s operators
    in order of precedence. Operators in the same category have the same precedence.'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格2-3](#chash_operators_left_parenthesiscategor)按优先级顺序列出了C#的运算符。同一类别中的运算符具有相同的优先级。'
- en: We explain user-overloadable operators in [“Operator Overloading”](ch04.html#operator_overloading).
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[“运算符重载”](ch04.html#operator_overloading)中解释了可用户重载的运算符。
- en: Table 2-3\. C# operators (categories in order of precedence)
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-3\. C#运算符（按优先级顺序的类别）
- en: '| Category | Operator symbol | Operator name | Example | User-overloadable
    |  |'
  id: totrans-895
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | 运算符符号 | 运算符名称 | 示例 | 可用户重载 |  |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-896
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| Primary | `.` | Member access | `x.y` | No |  |'
  id: totrans-897
  prefs: []
  type: TYPE_TB
  zh: '| 主要 | `.` | 成员访问 | `x.y` | 否 |  |'
- en: '|  | `?.` and `?[]` | Null-conditional | `x?.y` or `x?[0]` | No |  |'
  id: totrans-898
  prefs: []
  type: TYPE_TB
  zh: '|  | `?.` 和 `?[]` | 空条件 | `x?.y` 或 `x?[0]` | 否 |  |'
- en: '|  | `!` (postfix) | Null-forgiving | `x!.y` or `x![0]` | No |'
  id: totrans-899
  prefs: []
  type: TYPE_TB
  zh: '|  | `!`（后缀） | 空值前缀 | `x!.y` 或 `x![0]` | 否 |'
- en: '|  | `->` (unsafe) | Pointer to struct | `x->y` | No |  |'
  id: totrans-900
  prefs: []
  type: TYPE_TB
  zh: '|  | `->`（不安全） | 指向结构的指针 | `x->y` | 否 |  |'
- en: '|  | `()` | Function call | `x()` | No |  |'
  id: totrans-901
  prefs: []
  type: TYPE_TB
  zh: '|  | `()` | 函数调用 | `x()` | 否 |  |'
- en: '|  | `[]` | Array/index | `a[x]` | Via indexer |  |'
  id: totrans-902
  prefs: []
  type: TYPE_TB
  zh: '|  | `[]` | 数组/索引 | `a[x]` | 通过索引器 |  |'
- en: '|  | `++` | Post-increment | `x++` | Yes |  |'
  id: totrans-903
  prefs: []
  type: TYPE_TB
  zh: '|  | `++` | 后增 | `x++` | 是 |  |'
- en: '|  | `−−` | Post-decrement | `x−−` | Yes |  |'
  id: totrans-904
  prefs: []
  type: TYPE_TB
  zh: '|  | `−−` | 后减 | `x−−` | 是 |  |'
- en: '|  | `new` | Create instance | `new Foo()` | No |  |'
  id: totrans-905
  prefs: []
  type: TYPE_TB
  zh: '|  | `new` | 创建实例 | `new Foo()` | 否 |  |'
- en: '|  | `stackalloc` | Stack allocation | `stackalloc(10)` | No |  |'
  id: totrans-906
  prefs: []
  type: TYPE_TB
  zh: '|  | `stackalloc` | 栈分配 | `stackalloc(10)` | 否 |  |'
- en: '|  | `typeof` | Get type from identifier | `typeof(int)` | No |  |'
  id: totrans-907
  prefs: []
  type: TYPE_TB
  zh: '|  | `typeof` | 根据标识符获取类型 | `typeof(int)` | 否 |  |'
- en: '|  | `nameof` | Get name of identifier | `nameof(x)` | No |  |'
  id: totrans-908
  prefs: []
  type: TYPE_TB
  zh: '|  | `nameof` | 获取标识符的名称 | `nameof(x)` | 否 |  |'
- en: '|  | `checked` | Integral overflow check on | `checked(x)` | No |  |'
  id: totrans-909
  prefs: []
  type: TYPE_TB
  zh: '|  | `checked` | 整数溢出检查 | `checked(x)` | 否 |  |'
- en: '|  | `unchecked` | Integral overflow check off | `unchecked(x)` | No |  |'
  id: totrans-910
  prefs: []
  type: TYPE_TB
  zh: '|  | `unchecked` | 整数溢出检查关闭 | `unchecked(x)` | 否 |  |'
- en: '|  | `default` | Default value | `default(char)` | No |  |'
  id: totrans-911
  prefs: []
  type: TYPE_TB
  zh: '|  | `default` | 默认值 | `default(char)` | 否 |  |'
- en: '| Unary | `await` | Await | `await myTask` | No |  |'
  id: totrans-912
  prefs: []
  type: TYPE_TB
  zh: '| 一元 | `await` | 等待 | `await myTask` | 否 |  |'
- en: '|  | `sizeof` | Get size of struct | `sizeof(int)` | No |  |'
  id: totrans-913
  prefs: []
  type: TYPE_TB
  zh: '|  | `sizeof` | 获取结构体大小 | `sizeof(int)` | 否 |  |'
- en: '|  | `+` | Positive value of | `+x` | Yes |  |'
  id: totrans-914
  prefs: []
  type: TYPE_TB
  zh: '|  | `+` | 正值 | `+x` | 是 |  |'
- en: '|  | `−` | Negative value of | `−x` | Yes |  |'
  id: totrans-915
  prefs: []
  type: TYPE_TB
  zh: '|  | `−` | 负值 | `−x` | 是 |  |'
- en: '|  | `!` | Not | `!x` | Yes |  |'
  id: totrans-916
  prefs: []
  type: TYPE_TB
  zh: '|  | `!` | 非 | `!x` | 是 |  |'
- en: '|  | `~` | Bitwise complement | `~x` | Yes |  |'
  id: totrans-917
  prefs: []
  type: TYPE_TB
  zh: '|  | `~` | 按位补码 | `~x` | 是 |  |'
- en: '|  | `++` | Pre-increment | `++x` | Yes |  |'
  id: totrans-918
  prefs: []
  type: TYPE_TB
  zh: '|  | `++` | 前增 | `++x` | 是 |  |'
- en: '|  | `−−` | Pre-decrement | `−−x` | Yes |  |'
  id: totrans-919
  prefs: []
  type: TYPE_TB
  zh: '|  | `−−` | 前减 | `−−x` | 是 |  |'
- en: '|  | `()` | Cast | `(int)x` | No |  |'
  id: totrans-920
  prefs: []
  type: TYPE_TB
  zh: '|  | `()` | 强制转换 | `(int)x` | 否 |  |'
- en: '|  | `^` | Index from end | `array[^1]` | No |'
  id: totrans-921
  prefs: []
  type: TYPE_TB
  zh: '|  | `^` | 从末尾索引 | `array[^1]` | 否 |'
- en: '|  | `*` (unsafe) | Value at address | `*x` | No |  |'
  id: totrans-922
  prefs: []
  type: TYPE_TB
  zh: '|  | `*`（不安全） | 地址的值 | `*x` | 否 |  |'
- en: '|  | `&` (unsafe) | Address of value | `&x` | No |  |'
  id: totrans-923
  prefs: []
  type: TYPE_TB
  zh: '|  | `&`（不安全） | 值的地址 | `&x` | 否 |  |'
- en: '| Range | `..` `..^` | Range of indices | `x..y` `x..^y` | No |  |'
  id: totrans-924
  prefs: []
  type: TYPE_TB
  zh: '| 范围 | `..` `..^` | 索引范围 | `x..y` `x..^y` | 否 |  |'
- en: '| Switch & with | `switch` | Switch expression | `num switch {` `1 => true,`'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: '| Switch 和 with | `switch` | Switch 表达式 | `num switch {` `1 => true,`'
- en: '`_ => false`'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: '`_ => false`'
- en: '`}` | No |'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: '`}` | 否 |'
- en: '|  | `with` | With expression | `rec with` `{ X = 123 }` | No |'
  id: totrans-928
  prefs: []
  type: TYPE_TB
  zh: '|  | `with` | With 表达式 | `rec with` `{ X = 123 }` | 否 |'
- en: '| Multiplicative | `*` | Multiply | `x * y` | Yes |  |'
  id: totrans-929
  prefs: []
  type: TYPE_TB
  zh: '| 乘法 | `*` | 乘法 | `x * y` | 是 |  |'
- en: '|  | `/` | Divide | `x / y` | Yes |  |'
  id: totrans-930
  prefs: []
  type: TYPE_TB
  zh: '|  | `/` | 除 | `x / y` | 是 |  |'
- en: '|  | `%` | Remainder | `x % y` | Yes |  |'
  id: totrans-931
  prefs: []
  type: TYPE_TB
  zh: '|  | `%` | 余数 | `x % y` | 是 |  |'
- en: '| Additive | `+` | Add | `x + y` | Yes |  |'
  id: totrans-932
  prefs: []
  type: TYPE_TB
  zh: '| 加法 | `+` | 加 | `x + y` | 是 |  |'
- en: '|  | `−` | Subtract | `x − y` | Yes |  |'
  id: totrans-933
  prefs: []
  type: TYPE_TB
  zh: '|  | `−` | 减 | `x − y` | 是 |  |'
- en: '| Shift | `<<` | Shift left | `x << 1` | Yes |  |'
  id: totrans-934
  prefs: []
  type: TYPE_TB
  zh: '| 移位 | `<<` | 左移 | `x << 1` | 是 |  |'
- en: '|  | `>>` | Shift right | `x >> 1` | Yes |  |'
  id: totrans-935
  prefs: []
  type: TYPE_TB
  zh: '|  | `>>` | 右移 | `x >> 1` | 是 |  |'
- en: '|  | `>>>` | Unsigned shift right | `x >>> 1` | Yes |  |'
  id: totrans-936
  prefs: []
  type: TYPE_TB
  zh: '|  | `>>>` | 无符号右移 | `x >>> 1` | 是 |  |'
- en: '| Relational | `<` | Less than | `x < y` | Yes |  |'
  id: totrans-937
  prefs: []
  type: TYPE_TB
  zh: '| 关系 | `<` | 小于 | `x < y` | 是 |  |'
- en: '|  | `>` | Greater than | `x > y` | Yes |  |'
  id: totrans-938
  prefs: []
  type: TYPE_TB
  zh: '|  | `>` | 大于 | `x > y` | 是 |  |'
- en: '|  | `<=` | Less than or equal to | `x <= y` | Yes |  |'
  id: totrans-939
  prefs: []
  type: TYPE_TB
  zh: '|  | `<=` | 小于或等于 | `x <= y` | 是 |  |'
- en: '|  | `>=` | Greater than or equal to | `x >= y` | Yes |  |'
  id: totrans-940
  prefs: []
  type: TYPE_TB
  zh: '|  | `>=` | 大于或等于 | `x >= y` | 是 |  |'
- en: '|  | `is` | Type is or is subclass of | `x is y` | No |  |'
  id: totrans-941
  prefs: []
  type: TYPE_TB
  zh: '|  | `is` | 类型是或是子类 | `x is y` | 否 |  |'
- en: '|  | `as` | Type conversion | `x as y` | No |  |'
  id: totrans-942
  prefs: []
  type: TYPE_TB
  zh: '|  | `as` | 类型转换 | `x as y` | 否 |  |'
- en: '| Equality | `==` | Equals | `x == y` | Yes |  |'
  id: totrans-943
  prefs: []
  type: TYPE_TB
  zh: '| 相等性 | `==` | 等于 | `x == y` | 是 |  |'
- en: '|  | `!=` | Not equals | `x != y` | Yes |  |'
  id: totrans-944
  prefs: []
  type: TYPE_TB
  zh: '|  | `!=` | 不等于 | `x != y` | 是 |  |'
- en: '| Bitwise And | `&` | And | `x & y` | Yes |  |'
  id: totrans-945
  prefs: []
  type: TYPE_TB
  zh: '| 位与 | `&` | 与 | `x & y` | 是 |  |'
- en: '| Bitwise Xor | `^` | Exclusive Or | `x ^ y` | Yes |  |'
  id: totrans-946
  prefs: []
  type: TYPE_TB
  zh: '| 位异或 | `^` | 异或 | `x ^ y` | 是 |  |'
- en: '| Bitwise Or | `&#124;` | Or | `x &#124; y` | Yes |  |'
  id: totrans-947
  prefs: []
  type: TYPE_TB
  zh: '| 位或 | `&#124;` | 或 | `x &#124; y` | 是 |  |'
- en: '| Conditional And | `&&` | Conditional And | `x && y` | Via `&` |  |'
  id: totrans-948
  prefs: []
  type: TYPE_TB
  zh: '| 条件与 | `&&` | 条件与 | `x && y` | 通过 `&` |  |'
- en: '| Conditional Or | `&#124;&#124;` | Conditional Or | `x &#124;&#124; y` | Via
    `&#124;` |  |'
  id: totrans-949
  prefs: []
  type: TYPE_TB
  zh: '| 条件或 | `&#124;&#124;` | 条件或 | `x &#124;&#124; y` | 通过 `&#124;` |  |'
- en: '| Null coalescing | `??` | Null coalescing | `x ?? y` | No |  |'
  id: totrans-950
  prefs: []
  type: TYPE_TB
  zh: '| 空值合并 | `??` | 空值合并 | `x ?? y` | 否 |  |'
- en: '| Conditional | `?:` | Conditional | `isTrue ? thenThis : elseThis` | No |  |'
  id: totrans-951
  prefs: []
  type: TYPE_TB
  zh: '| 条件 | `?:` | 条件运算符 | `isTrue ? thenThis : elseThis` | 否 |  |'
- en: '| Assignment and lambda | `=` | Assign | `x = y` | No |  |'
  id: totrans-952
  prefs: []
  type: TYPE_TB
  zh: '| 赋值和 Lambda | `=` | 赋值 | `x = y` | 否 |  |'
- en: '|  | `*=` | Multiply self by | `x *= 2` | Via `*` |  |'
  id: totrans-953
  prefs: []
  type: TYPE_TB
  zh: '|  | `*=` | 自乘 | `x *= 2` | 通过 `*` |  |'
- en: '|  | `/=` | Divide self by | `x /= 2` | Via `/` |  |'
  id: totrans-954
  prefs: []
  type: TYPE_TB
  zh: '|  | `/=` | 自除 | `x /= 2` | 通过 `/` |  |'
- en: '|  | `%=` | Remainder & assign to self | `x %= 2` |  |'
  id: totrans-955
  prefs: []
  type: TYPE_TB
  zh: '|  | `%=` | 余数并赋值 | `x %= 2` |  |'
- en: '|  | `+=` | Add to self | `x += 2` | Via `+` |  |'
  id: totrans-956
  prefs: []
  type: TYPE_TB
  zh: '|  | `+=` | 自增 | `x += 2` | 通过 `+` |  |'
- en: '|  | `−=` | Subtract from self | `x −= 2` | Via `−` |  |'
  id: totrans-957
  prefs: []
  type: TYPE_TB
  zh: '|  | `−=` | 自减赋值 | `x −= 2` | 通过 `−` |  |'
- en: '|  | `<<=` | Shift self left by | `x <<= 2` | Via `<<` |  |'
  id: totrans-958
  prefs: []
  type: TYPE_TB
  zh: '|  | `<<=` | 左移赋值 | `x <<= 2` | 通过 `<<` |  |'
- en: '|  | `>>=` | Shift self right by | `x >>= 2` | Via `>>` |  |'
  id: totrans-959
  prefs: []
  type: TYPE_TB
  zh: '|  | `>>=` | 右移赋值 | `x >>= 2` | 通过 `>>` |  |'
- en: '|  | `>>>=` | Unsigned shift self right by | `x >>>= 2` | Via `>>>` |  |'
  id: totrans-960
  prefs: []
  type: TYPE_TB
  zh: '|  | `>>>=` | 无符号右移赋值 | `x >>>= 2` | 通过 `>>>` |  |'
- en: '|  | `&=` | And self by | `x &= 2` | Via `&` |  |'
  id: totrans-961
  prefs: []
  type: TYPE_TB
  zh: '|  | `&=` | 按位与赋值 | `x &= 2` | 通过 `&` |  |'
- en: '|  | `^=` | Exclusive-Or self by | `x ^= 2` | Via `^` |  |'
  id: totrans-962
  prefs: []
  type: TYPE_TB
  zh: '|  | `^=` | 按位异或赋值 | `x ^= 2` | 通过 `^` |  |'
- en: '|  | `&#124;=` | Or self by | `x &#124;= 2` | Via `&#124;` |  |'
  id: totrans-963
  prefs: []
  type: TYPE_TB
  zh: '|  | `&#124;=` | 按位或赋值 | `x &#124;= 2` | 通过 `&#124;` |  |'
- en: '|  | `??=` | Null-coalescing assignment | `x ??= 0` | No |  |'
  id: totrans-964
  prefs: []
  type: TYPE_TB
  zh: '|  | `??=` | 空值合并赋值 | `x ??= 0` | 否 |  |'
- en: '|  | `=>` | Lambda | `x => x + 1` | No |  |'
  id: totrans-965
  prefs: []
  type: TYPE_TB
  zh: '|  | `=>` | Lambda | `x => x + 1` | 否 |  |'
- en: Null Operators
  id: totrans-966
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空操作符
- en: 'C# provides three operators to make it easier to work with nulls: the *null-coalescing
    operator*, the *null-coalescing assignment operator*, and the *null-conditional
    operator*.'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: C# 提供了三个操作符来更轻松地处理 null：*空值合并运算符*、*空值合并赋值运算符*和*空值条件运算符*。
- en: Null-Coalescing Operator
  id: totrans-968
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空值合并运算符
- en: 'The `??` operator is the *null-coalescing operator*. It says, “If the operand
    to the left is non-null, give it to me; otherwise, give me another value.” For
    example:'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: '`??` 运算符是*空值合并运算符*。它表示，“如果左边的操作数非 null，则给我；否则，给我另一个值。”例如：'
- en: '[PRE199]'
  id: totrans-970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: If the lefthand expression is non-null, the righthand expression is never evaluated.
    The null-coalescing operator also works with nullable value types (see [“Nullable
    Value Types”](ch04.html#nullable_value_types)).
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 如果左侧表达式非 null，则不会评估右侧表达式。空值合并运算符也适用于可空值类型（参见[“可空值类型”](ch04.html#nullable_value_types)）。
- en: Null-Coalescing Assignment Operator
  id: totrans-972
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空值合并赋值运算符
- en: 'The `??=` operator (introduced in C# 8) is the *null-coalescing assignment
    operator*. It says, “If the operand to the left is null, assign the right operand
    to the left operand.” Consider the following:'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: '`??=` 运算符（在 C# 8 中引入）是*空值合并赋值运算符*。它表示，“如果左边的操作数为 null，则将右边的操作数赋给左操作数。”考虑以下情况：'
- en: '[PRE200]'
  id: totrans-974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'This is equivalent to:'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 这等同于：
- en: '[PRE201]'
  id: totrans-976
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: The `??=` operator is particularly useful in implementing lazily calculated
    properties. We’ll cover this topic later, in [“Calculated Fields and Lazy Evaluation”](ch04.html#calculated_fields_and_lazy_evaluation).
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: '`??=` 运算符在实现延迟计算属性时特别有用。我们稍后将在[“计算字段和延迟评估”](ch04.html#calculated_fields_and_lazy_evaluation)中介绍这个主题。'
- en: Null-Conditional Operator
  id: totrans-978
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空值条件运算符
- en: 'The `?.` operator is the *null-conditional* or “Elvis” operator (after the
    Elvis emoticon). It allows you to call methods and access members just like the
    standard dot operator except that if the operand on the left is null, the expression
    evaluates to null instead of throwing a `NullReferenceException`:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: '`?.` 运算符是*空值条件*或“Elvis”运算符（以 Elvis 表情命名）。它允许您调用方法和访问成员，就像标准点运算符一样，除非左边的操作数为
    null，否则表达式将计算为 null，而不是抛出 `NullReferenceException`：'
- en: '[PRE202]'
  id: totrans-980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'The last line is equivalent to the following:'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行等同于以下内容：
- en: '[PRE203]'
  id: totrans-982
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'Null-conditional expressions also work with indexers:'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 空值条件表达式也适用于索引器：
- en: '[PRE204]'
  id: totrans-984
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'Upon encountering a null, the Elvis operator short-circuits the remainder of
    the expression. In the following example, `s` evaluates to null, even with a standard
    dot operator between `ToString()` and `ToUpper()`:'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 遇到 null 时，Elvis 运算符将短路表达式的其余部分。在以下示例中，`s` 计算为 null，即使在 `ToString()` 和 `ToUpper()`
    之间使用标准点运算符：
- en: '[PRE205]'
  id: totrans-986
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'Repeated use of Elvis is necessary only if the operand immediately to its left
    might be null. The following expression is robust to both `x` being null and `x.y`
    being null:'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在左侧的操作数可能为 null 时才需要重复使用 Elvis。以下表达式对 `x` 为 null 和 `x.y` 为 null 都是健壮的：
- en: '[PRE206]'
  id: totrans-988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'It is equivalent to the following (except that `x.y` is evaluated only once):'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 它等同于以下内容（除了只计算 `x.y` 一次）：
- en: '[PRE207]'
  id: totrans-990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'The final expression must be capable of accepting a null. The following is
    illegal:'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 最终表达式必须能够接受 null。以下是非法的：
- en: '[PRE208]'
  id: totrans-992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'We can fix this with the use of nullable value types (see [“Nullable Value
    Types”](ch04.html#nullable_value_types)). If you’re already familiar with nullable
    value types, here’s a preview:'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用可空值类型来解决此问题（参见[“可空值类型”](ch04.html#nullable_value_types)）。如果您已经熟悉可空值类型，这里是一个预览：
- en: '[PRE209]'
  id: totrans-994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'You can also use the null-conditional operator to call a void method:'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用空值条件运算符调用空方法：
- en: '[PRE210]'
  id: totrans-996
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: If `someObject` is null, this becomes a “no-operation” rather than throwing
    a `NullReferenceException`.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `someObject` 是 null，这将成为“无操作”，而不是抛出 `NullReferenceException`。
- en: 'You can use the null-conditional operator with the commonly used type members
    that we describe in [Chapter 3](ch03.html#creating_types_in_chash), including
    *methods*, *fields*, *properties*, and *indexers*. It also combines well with
    the *null-coalescing operator*:'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用空值条件运算符与我们在[第3章](ch03.html#creating_types_in_chash)中描述的常用类型成员，包括*方法*、*字段*、*属性*和*索引器*。它还可以很好地与*空值合并运算符*结合使用：
- en: '[PRE211]'
  id: totrans-999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: Statements
  id: totrans-1000
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语句
- en: Functions comprise statements that execute sequentially in the textual order
    in which they appear. A *statement block* is a series of statements appearing
    between braces (the `{}` tokens).
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 函数由按照它们出现的文本顺序依次执行的语句组成。*语句块*是出现在大括号（`{}`）之间的一系列语句。
- en: Declaration Statements
  id: totrans-1002
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明语句
- en: 'A variable declaration introduces a new variable, optionally initializing it
    with an expression. You may declare multiple variables of the same type in a comma-separated
    list:'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 变量声明引入一个新变量，并可选择用表达式进行初始化。你可以在逗号分隔的列表中声明多个相同类型的变量：
- en: '[PRE212]'
  id: totrans-1004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'A constant declaration is like a variable declaration except that it cannot
    be changed after it has been declared, and the initialization must occur with
    the declaration (see [“Constants”](ch03.html#constants)):'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 常量声明类似于变量声明，但在声明后不能更改，并且必须在声明时进行初始化（参见[“常量”](ch03.html#constants)）：
- en: '[PRE213]'
  id: totrans-1006
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: Local variables
  id: totrans-1007
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 局部变量
- en: 'The scope of a local variable or local constant extends throughout the current
    block. You cannot declare another local variable with the same name in the current
    block or in any nested blocks:'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量或局部常量的作用域在整个当前块中延伸。你不能在当前块或任何嵌套块中声明另一个同名的局部变量：
- en: '[PRE214]'
  id: totrans-1009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: Note
  id: totrans-1010
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A variable’s scope extends in *both directions* throughout its code block. This
    means that if we moved the initial declaration of `x` in this example to the bottom
    of the method, we’d get the same error. This is in contrast to C++ and is somewhat
    peculiar, given that it’s not legal to refer to a variable or constant before
    it’s declared.
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的作用域在其代码块中向*两个方向*延伸。这意味着，如果我们将`x`的初始声明移动到方法底部，我们会得到相同的错误。这与C++不同，并且有些特别，因为在声明之前引用变量或常量是不合法的。
- en: Expression Statements
  id: totrans-1012
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式语句
- en: 'Expression statements are expressions that are also valid statements. An expression
    statement must either change state or call something that might change state.
    Changing state essentially means changing a variable. Following are the possible
    expression statements:'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式语句是有效的表达式，同时也是有效的语句。表达式语句必须改变状态或调用可能改变状态的内容。改变状态实质上意味着改变一个变量。以下是可能的表达式语句：
- en: Assignment expressions (including increment and decrement expressions)
  id: totrans-1014
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值表达式（包括增量和减量表达式）
- en: Method call expressions (both void and nonvoid)
  id: totrans-1015
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法调用表达式（无论是void还是非void）
- en: Object instantiation expressions
  id: totrans-1016
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象实例化表达式
- en: 'Here are some examples:'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些例子：
- en: '[PRE215]'
  id: totrans-1018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'When you call a constructor or a method that returns a value, you’re not obliged
    to use the result. However, unless the constructor or method changes state, the
    statement is completely useless:'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用一个构造函数或返回值的方法时，你不一定要使用这个结果。然而，除非构造函数或方法改变状态，否则这个语句完全没有用处：
- en: '[PRE216]'
  id: totrans-1020
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: Selection Statements
  id: totrans-1021
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择语句
- en: 'C# has the following mechanisms to conditionally control the flow of program
    execution:'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: C#有以下机制来有条件地控制程序执行流程：
- en: Selection statements (`if`, `switch`)
  id: totrans-1023
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择语句（`if`，`switch`）
- en: Conditional operator (`?:`)
  id: totrans-1024
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件运算符（`?:`）
- en: Loop statements (`while`, `do`-`while`, `for`, `foreach`)
  id: totrans-1025
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环语句（`while`，`do`-`while`，`for`，`foreach`）
- en: 'This section covers the simplest two constructs: the `if` statement and the
    `switch` statement.'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了最简单的两个结构：`if`语句和`switch`语句。
- en: The if statement
  id: totrans-1027
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if语句
- en: 'An `if` statement executes a statement if a `bool` expression is true:'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个`bool`表达式为真，则`if`语句执行一个语句：
- en: '[PRE217]'
  id: totrans-1029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'The statement can be a code block:'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 语句可以是一个代码块：
- en: '[PRE218]'
  id: totrans-1031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: The else clause
  id: totrans-1032
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: else子句
- en: 'An `if` statement can optionally feature an `else` clause:'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: if语句可以选择包含一个`else`子句：
- en: '[PRE219]'
  id: totrans-1034
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'Within an `else` clause, you can nest another `if` statement:'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 在`else`子句中，你可以嵌套另一个`if`语句：
- en: '[PRE220]'
  id: totrans-1036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: Changing the flow of execution with braces
  id: totrans-1037
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用括号改变执行流程
- en: 'An `else` clause always applies to the immediately preceding `if` statement
    in the statement block:'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: '`else`子句始终应用于语句块中的上一个`if`语句：'
- en: '[PRE221]'
  id: totrans-1039
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'This is semantically identical to the following:'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 这在语义上与以下内容相同：
- en: '[PRE222]'
  id: totrans-1041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'We can change the execution flow by moving the braces:'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过移动括号来改变执行流程：
- en: '[PRE223]'
  id: totrans-1043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'With braces, you explicitly state your intention. This can improve the readability
    of nested `if` statements—even when not required by the compiler. A notable exception
    is with the following pattern:'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 使用大括号，您明确说明了您的意图。这可以改善嵌套`if`语句的可读性，即使编译器不要求。一个显著的例外是以下模式：
- en: '[PRE224]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: Here, we’ve arranged the `if` and `else` statements to mimic the “elseif” construct
    of other languages (and C#’s `#elif` preprocessor directive). Visual Studio’s
    auto-formatting recognizes this pattern and preserves the indentation. Semantically,
    though, each `if` statement following an `else` statement is functionally nested
    within the `else` clause.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经安排了`if`和`else`语句，以模仿其他语言的“elseif”构造（以及C＃的`#elif`预处理器指令）。Visual Studio的自动格式化识别此模式并保留缩进。但从语义上讲，每个跟在`else`语句后的`if`语句在功能上都是嵌套在`else`子句中。
- en: The switch statement
  id: totrans-1047
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: switch语句
- en: '`switch` statements let you branch program execution based on a selection of
    possible values that a variable might have. `switch` statements can result in
    cleaner code than multiple `if` statements because `switch` statements require
    an expression to be evaluated only once:'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句允许您根据变量可能具有的一组可能值来分支程序执行。`switch`语句可能会比多个`if`语句生成更清晰的代码，因为`switch`语句只需要评估一次表达式：'
- en: '[PRE225]'
  id: totrans-1049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: This example demonstrates the most common scenario, which is switching on *constants*.
    When you specify a constant, you’re restricted to the built-in numeric types and
    the `bool`, `char`, `string`, and `enum` types.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例演示了最常见的情况，即切换到*常量*。当您指定常量时，您受限于内置数值类型和`bool`，`char`，`string`和`enum`类型。
- en: 'At the end of each `case` clause, you must specify explicitly where execution
    is to go next, with some kind of jump statement (unless your code ends in an infinite
    loop). Here are the options:'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个`case`子句的末尾，必须明确指定下一步执行的位置，使用某种跳转语句（除非您的代码以无限循环结束）。以下是选项：
- en: '`break` (jumps to the end of the `switch` statement)'
  id: totrans-1052
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`break`（跳转到`switch`语句的结尾）'
- en: '`goto case *x*` (jumps to another `case` clause)'
  id: totrans-1053
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`goto case *x*`（跳转到另一个`case`子句）'
- en: '`goto default` (jumps to the `default` clause)'
  id: totrans-1054
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`goto default`（跳转到`default`子句）'
- en: Any other jump statement—namely, `return`, `throw`, `continue`, or `goto *label*`
  id: totrans-1055
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何其他跳转语句——即`return`，`throw`，`continue`或`goto *label*`
- en: 'When more than one value should execute the same code, you can list the common
    `case`s sequentially:'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个值应执行相同的代码时，您可以按顺序列出通用`case`：
- en: '[PRE226]'
  id: totrans-1057
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: This feature of a `switch` statement can be pivotal in terms of producing cleaner
    code than multiple `if`-`else` statements.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句的这个特性在生成比多个`if`-`else`语句更干净的代码方面至关重要。'
- en: Switching on types
  id: totrans-1059
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 切换类型
- en: Note
  id: totrans-1060
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Switching on a type is a special case of switching on a *pattern.* A number
    of other patterns have been introduced in recent versions of C#; see [“Patterns”](ch04.html#patterns)
    for a full discussion.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 切换类型是切换到*模式*的特殊情况。最近版本的C＃中引入了许多其他模式，请参阅[“模式”](ch04.html#patterns)进行全面讨论。
- en: 'You can also switch on *types* (from C# 7):'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以从C＃ 7中*类型*（来自C# 7）切换：
- en: '[PRE227]'
  id: totrans-1063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: (The `object` type allows for a variable of any type; we discuss this fully
    in [“Inheritance”](ch03.html#inheritance) and [“The object Type”](ch03.html#the_object_type).)
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: （`object`类型允许任何类型的变量；我们在[“继承”](ch03.html#inheritance)和[“object类型”](ch03.html#the_object_type)中对此进行了全面讨论。）
- en: Each *case* clause specifies a type upon which to match, and a variable upon
    which to assign the typed value if the match succeeds (the “pattern” variable).
    Unlike with constants, there’s no restriction on what types you can use.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 每个*case*子句指定要匹配的类型，以及如果匹配成功则要分配的变量（“模式”变量）。与常量不同，您可以使用任何类型，没有限制。
- en: 'You can predicate a `case` with the `when` keyword:'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`when`关键字对`case`进行断言：
- en: '[PRE228]'
  id: totrans-1067
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: The order of the case clauses can matter when switching on type (unlike when
    switching on constants). This example would give a different result if we reversed
    the two cases (in fact, it would not even compile, because the compiler would
    determine that the second case is unreachable). An exception to this rule is the
    `default` clause, which is always executed last, regardless of where it appears.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 当切换到类型时，case子句的顺序可能很重要（与切换到常量不同）。如果我们反转两个case，此示例将产生不同的结果（事实上，它甚至无法编译，因为编译器将确定第二个case是不可达的）。这个规则的一个例外是`default`子句，它始终在最后执行，无论其出现在何处。
- en: 'You can stack multiple case clauses. The `Console.WriteLine` in the following
    code will execute for any floating-point type greater than 1,000:'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以堆叠多个case子句。下面代码中的`Console.WriteLine`将对任何大于1,000的浮点类型执行：
- en: '[PRE229]'
  id: totrans-1070
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: In this example, the compiler lets us consume the pattern variables `f`, `d`,
    and `m`, *only* in the `when` clauses. When we call `Console.WriteLine`, it’s
    unknown which one of those three variables will be assigned, so the compiler puts
    all of them out of scope.
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，编译器允许我们仅在 `when` 子句中使用模式变量 `f`、`d` 和 `m`。当调用 `Console.WriteLine` 时，未知哪一个变量将被赋值，因此编译器将它们全部超出范围。
- en: 'You can mix and match constants and patterns in the same switch statement.
    And you can also switch on the null value:'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在同一个开关语句中混合使用常量和模式。你也可以针对 null 值进行开关：
- en: '[PRE230]'
  id: totrans-1073
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: Switch expressions
  id: totrans-1074
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开关表达式
- en: 'From C# 8, you can use `switch` in the context of an *expression*. Assuming
    that `cardNumber` is of type `int`, the following illustrates its use:'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 自 C# 8 开始，你可以在 *表达式* 上下文中使用 `switch`。假设 `cardNumber` 是 `int` 类型，以下示例演示了其用法：
- en: '[PRE231]'
  id: totrans-1076
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: Notice that the `switch` keyword appears *after* the variable name, and that
    the case clauses are expressions (terminated by commas) rather than statements.
    Switch expressions are more compact than their switch statement counterparts,
    and you can use them in LINQ queries ([Chapter 8](ch08.html#linq_queries)).
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`switch` 关键字出现在变量名之后，并且 case 子句是表达式（以逗号终止），而不是语句。开关表达式比其开关语句对应物更紧凑，并且可以在
    LINQ 查询中使用（参见[第 8 章](ch08.html#linq_queries)）。
- en: If you omit the default expression (`_`) and the switch fails to match, an exception
    is thrown.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你省略了默认表达式（`_`）并且开关未匹配成功，将抛出异常。
- en: 'You can also switch on multiple values (the *tuple* pattern):'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以针对多个值进行开关（*元组* 模式）：
- en: '[PRE232]'
  id: totrans-1080
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: Many more options are possible through the use of *patterns* (see [“Patterns”](ch04.html#patterns)).
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 *模式* 可以实现更多选项（详见[“模式”](ch04.html#patterns)）。
- en: Iteration Statements
  id: totrans-1082
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代语句
- en: C# enables a sequence of statements to execute repeatedly with the `while`,
    `do-while`, `for`, and `foreach` statements.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: C# 允许一系列语句通过 `while`、`do-while`、`for` 和 `foreach` 语句重复执行。
- en: while and do-while loops
  id: totrans-1084
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: while 和 do-while 循环
- en: '`while` loops repeatedly execute a body of code while a `bool` expression is
    true. The expression is tested *before* the body of the loop is executed. For
    example, the following writes `012`:'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环在 `bool` 表达式为 true 时重复执行代码体。在执行循环体之前测试表达式。例如，以下代码将输出 `012`：'
- en: '[PRE233]'
  id: totrans-1086
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '`do-while` loops differ in functionality from `while` loops only in that they
    test the expression *after* the statement block has executed (ensuring that the
    block is always executed at least once). Here’s the preceding example rewritten
    with a `do-while` loop:'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: '`do-while` 循环在功能上与 `while` 循环只有一个不同点，即它在执行语句块之后测试表达式（确保语句块至少执行一次）。以下是使用 `do-while`
    循环重写的前面示例：'
- en: '[PRE234]'
  id: totrans-1088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: for loops
  id: totrans-1089
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: for 循环
- en: '`for` loops are like `while` loops with special clauses for *initialization*
    and *iteration* of a loop variable. A `for` loop contains three clauses as follows:'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环与 `while` 循环类似，具有用于 *初始化* 和 *迭代* 循环变量的特殊子句。`for` 循环包含如下三个子句：'
- en: '[PRE235]'
  id: totrans-1091
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'Here’s what each clause does:'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子句的作用如下：
- en: Initialization clause
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化子句
- en: Executed before the loop begins; used to initialize one or more *iteration*
    variables
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环开始之前执行；用于初始化一个或多个 *迭代* 变量
- en: Condition clause
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 条件子句
- en: The `bool` expression that, while true, will execute the body
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `bool` 表达式，在为 true 时执行循环体
- en: Iteration clause
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代子句
- en: Executed *after* each iteration of the statement block; used typically to update
    the iteration variable
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代语句块之后执行；通常用于更新迭代变量
- en: 'For example, the following prints the numbers 0 through 2:'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下打印出数字 0 到 2：
- en: '[PRE236]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'The following prints the first 10 Fibonacci numbers (in which each number is
    the sum of the previous two):'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下打印出前 10 个斐波那契数（其中每个数是前两个数的和）：
- en: '[PRE237]'
  id: totrans-1102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'Any of the three parts of the `for` statement can be omitted. You can implement
    an infinite loop such as the following (though `while(true)` can be used, instead):'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 语句的三个部分都可以省略。你可以实现类似以下的无限循环（尽管可以使用 `while(true)` 替代）：'
- en: '[PRE238]'
  id: totrans-1104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: foreach loops
  id: totrans-1105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: foreach 循环
- en: 'The `foreach` statement iterates over each element in an enumerable object.
    Most of the .NET types that represent a set or list of elements are enumerable.
    For example, both an array and a string are enumerable. Here is an example of
    enumerating over the characters in a string, from the first character through
    to the last:'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach` 语句在可枚举对象中迭代每个元素。大多数表示元素集合或列表的 .NET 类型都是可枚举的。例如，数组和字符串都是可枚举的。以下是枚举字符串中字符的示例，从第一个字符到最后一个字符：'
- en: '[PRE239]'
  id: totrans-1107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: 'Here’s the output:'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE240]'
  id: totrans-1109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: We define enumerable objects in [“Enumeration and Iterators”](ch04.html#enumeration_and_iterators).
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [“枚举和迭代器”](ch04.html#enumeration_and_iterators) 中定义可枚举对象。
- en: Jump Statements
  id: totrans-1111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跳转语句
- en: The C# jump statements are `break`, `continue`, `goto`, `return`, and `throw`.
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: C# 跳转语句包括 `break`、`continue`、`goto`、`return` 和 `throw`。
- en: Note
  id: totrans-1113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Jump statements obey the reliability rules of `try` statements (see [“try Statements
    and Exceptions”](ch04.html#try_statements_and_exceptions)). This means that:'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转语句遵守 `try` 语句的可靠性规则（参见 [“try 语句和异常”](ch04.html#try_statements_and_exceptions)）。这意味着：
- en: A jump out of a `try` block always executes the `try`’s `finally` block before
    reaching the target of the jump.
  id: totrans-1115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `try` 块跳出总是在达到跳转目标之前执行 `try` 的 `finally` 块。
- en: A jump cannot be made from the inside to the outside of a `finally` block (except
    via `throw`).
  id: totrans-1116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能从 `finally` 块的内部跳到外部（除非通过 `throw`）。
- en: The break statement
  id: totrans-1117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`break` 语句'
- en: 'The `break` statement ends the execution of the body of an iteration or `switch`
    statement:'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: '`break` 语句结束循环体或 `switch` 语句的执行：'
- en: '[PRE241]'
  id: totrans-1119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: The continue statement
  id: totrans-1120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继续语句
- en: 'The `continue` statement forgoes the remaining statements in a loop and makes
    an early start on the next iteration. The following loop skips even numbers:'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue` 语句放弃循环中的剩余语句，并提前开始下一次迭代。以下循环跳过偶数：'
- en: '[PRE242]'
  id: totrans-1122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: The goto statement
  id: totrans-1123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: goto 语句
- en: 'The `goto` statement transfers execution to another label within a statement
    block. The form is as follows:'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: '`goto` 语句将执行转移到语句块内的另一个标签。其形式如下：'
- en: '[PRE243]'
  id: totrans-1125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'Or, when used within a `switch` statement:'
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，当在 `switch` 语句中使用时：
- en: '[PRE244]'
  id: totrans-1127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: 'A label is a placeholder in a code block that precedes a statement, denoted
    with a colon suffix. The following iterates the numbers 1 through 5, mimicking
    a `for` loop:'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 标签是代码块中语句之前的占位符，用冒号后缀表示。以下迭代 1 到 5 的数字，模拟 `for` 循环：
- en: '[PRE245]'
  id: totrans-1129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: The `goto case *case-constant*` transfers execution to another case in a `switch`
    block (see [“The switch statement”](#the_switch_statement)).
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: '`goto case *case-constant*` 将执行转移到 `switch` 块中的另一个 case（参见 [“switch 语句”](#the_switch_statement)）。'
- en: The return statement
  id: totrans-1131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回语句
- en: 'The `return` statement exits the method and must return an expression of the
    method’s return type if the method is nonvoid:'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: '`return` 语句退出方法，如果方法是非 `void` 类型，则必须返回方法返回类型的表达式：'
- en: '[PRE246]'
  id: totrans-1133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: A `return` statement can appear anywhere in a method (except in a `finally`
    block), and can be used more than once.
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: '`return` 语句可以出现在方法的任何位置（除了 `finally` 块），并且可以多次使用。'
- en: The throw statement
  id: totrans-1135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抛出语句
- en: 'The `throw` statement throws an exception to indicate an error has occurred
    (see [“try Statements and Exceptions”](ch04.html#try_statements_and_exceptions)):'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: '`throw` 语句抛出异常，指示发生错误（参见 [“try 语句和异常”](ch04.html#try_statements_and_exceptions)）：'
- en: '[PRE247]'
  id: totrans-1137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: Miscellaneous Statements
  id: totrans-1138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 杂项语句
- en: The `using` statement provides an elegant syntax for calling `Dispose` on objects
    that implement `IDisposable`, within a `finally` block (see [“try Statements and
    Exceptions”](ch04.html#try_statements_and_exceptions) and [“IDisposable, Dispose,
    and Close”](ch12.html#idisposablecomma_disposecomma_and_close)).
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: '`using` 语句提供了一种优雅的语法，用于在对象实现 `IDisposable` 时调用 `Dispose`，在 `finally` 块中（参见
    [“try 语句和异常”](ch04.html#try_statements_and_exceptions) 和 [“IDisposable、Dispose
    和 Close”](ch12.html#idisposablecomma_disposecomma_and_close)）。'
- en: Note
  id: totrans-1140
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: C# overloads the `using` keyword to have independent meanings in different contexts.
    Specifically, the `using` *directive* is different from the `using` *statement*.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: C# 重载 `using` 关键字，以在不同的上下文中具有独立的含义。具体来说，`using` *指令* 与 `using` *语句* 不同。
- en: The `lock` statement is a shortcut for calling the `Enter` and `Exit` methods
    of the `Monitor` class (see Chapters [14](ch14.html#concurrency_and_asynchron)
    and [23](ch23.html#spanless_thantgreater_than_and-id00089)).
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: '`lock` 语句是调用 `Monitor` 类的 `Enter` 和 `Exit` 方法的快捷方式（参见第 [14](ch14.html#concurrency_and_asynchron)
    和 [23](ch23.html#spanless_thantgreater_than_and-id00089) 章节）。'
- en: Namespaces
  id: totrans-1143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间
- en: 'A namespace is a domain for type names. Types are typically organized into
    hierarchical namespaces, making them easier to find and avoiding conflicts. For
    example, the `RSA` type that handles public key encryption is defined within the
    following namespace:'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是类型名称的域。类型通常组织到分层命名空间中，使其更易于查找并避免冲突。例如，处理公钥加密的 `RSA` 类型定义在以下命名空间中：
- en: '[PRE248]'
  id: totrans-1145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: 'A namespace forms an integral part of a type’s name. The following code calls
    `RSA`’s `Create` method:'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是类型名称的一个组成部分。以下代码调用 `RSA` 的 `Create` 方法：
- en: '[PRE249]'
  id: totrans-1147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: Note
  id: totrans-1148
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Namespaces are independent of assemblies, which are *.dll* files that serve
    as units of deployment (described in [Chapter 17](ch17.html#assemblies)).
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间与程序集独立，程序集是作为部署单元的 *.dll* 文件（详见[第 17 章](ch17.html#assemblies)）。
- en: Namespaces also have no impact on member visibility—`public`, `internal`, `private`,
    and so on.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间对成员可见性没有影响——`public`、`internal`、`private` 等。
- en: 'The `namespace` keyword defines a namespace for types within that block; for
    example:'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: '`namespace` 关键字为该块内部的类型定义了一个命名空间；例如：'
- en: '[PRE250]'
  id: totrans-1152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: 'The dots in the namespace indicate a hierarchy of nested namespaces. The code
    that follows is semantically identical to the preceding example:'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间中的点表示嵌套命名空间的层次结构。接下来的代码在语义上与前面的示例相同：
- en: '[PRE251]'
  id: totrans-1154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: You can refer to a type with its *fully qualified name*, which includes all
    namespaces from the outermost to the innermost. For example, we could refer to
    `Class1` in the preceding example as `Outer.Middle.Inner.Class1`.
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用*完全限定名称*引用类型，该名称包括从最外层到最内层的所有命名空间。例如，我们可以在前面的示例中将 `Class1` 称为 `Outer.Middle.Inner.Class1`。
- en: Types not defined in any namespace are said to reside in the *global namespace*.
    The global namespace also includes top-level namespaces, such as `Outer` in our
    example.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 没有定义在任何命名空间中的类型称为*全局命名空间*。全局命名空间还包括顶层命名空间，例如我们示例中的 `Outer`。
- en: File-Scoped Namespaces
  id: totrans-1157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件范围命名空间
- en: 'Often, you will want all the types in a file to be defined in one namespace:'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你会希望文件中的所有类型都定义在同一个命名空间中：
- en: '[PRE252]'
  id: totrans-1159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: 'From C# 10, you can accomplish this with a *file-scoped namespace*:'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 10 开始，你可以通过*文件范围命名空间*来实现这一点：
- en: '[PRE253]'
  id: totrans-1161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: File-scoped namespaces reduce clutter and eliminate an unnecessary level of
    indentation.
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 文件范围的命名空间减少了混乱，并消除了不必要的缩进级别。
- en: The using Directive
  id: totrans-1163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`using` 指令'
- en: 'The `using` directive *imports* a namespace, allowing you to refer to types
    without their fully qualified names. The following imports the previous example’s
    `Outer​.Mid⁠dle.Inner` namespace:'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: '`using` 指令*导入*一个命名空间，允许你引用类型而无需完全限定其名称。以下导入了前面示例的 `Outer.Middle.Inner` 命名空间：'
- en: '[PRE254]'
  id: totrans-1165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: Note
  id: totrans-1166
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It’s legal (and often desirable) to define the same type name in different namespaces.
    However, you’d typically do so only if it was unlikely for a consumer to want
    to import both namespaces at once. A good example is the `TextBox` class, which
    is defined both in `System.Windows.Controls` (WPF) and `System.Windows.Forms`
    (Windows Forms).
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 定义相同类型名称在不同命名空间中是合法的（通常也是可取的）。但是，你通常只会在不太可能同时导入两个命名空间的情况下这样做。一个很好的例子是 `TextBox`
    类，它在 `System.Windows.Controls`（WPF）和 `System.Windows.Forms`（Windows Forms）中都有定义。
- en: A `using` directive can be nested within a namespace itself to limit the scope
    of the directive.
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: '`using` 指令可以嵌套在命名空间本身内部，以限制指令的范围。'
- en: The global using Directive
  id: totrans-1169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局 using 指令
- en: 'From C# 10, if you prefix a `using` directive with the `global` keyword, the
    directive will apply to all files in the project or compilation unit:'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 10 开始，如果使用 `global` 关键字前缀 `using` 指令，则该指令将应用于项目或编译单元中的所有文件：
- en: '[PRE255]'
  id: totrans-1171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: This lets you centralize common imports and avoid repeating the same directives
    in every file.
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得你可以集中常见导入并避免在每个文件中重复相同的指令。
- en: '`global using` directives must precede nonglobal directives and cannot appear
    inside namespace declarations. The global directive can be used with `using static`.'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: '`global using` 指令必须位于非全局指令之前，并且不能出现在命名空间声明内部。全局指令可以与 `using static` 一起使用。'
- en: Implicit global usings
  id: totrans-1174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐式全局导入
- en: 'From .NET 6, project files allow for implicit `global using` directives. If
    the `Implici⁠t​Usings` element is set to true in the project file (the default
    for new projects), the following namespaces are automatically imported:'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 从 .NET 6 开始，项目文件允许隐式 `global using` 指令。如果项目文件中的 `Implici⁠t​Usings` 元素设置为 true（新项目的默认设置），则会自动导入以下命名空间：
- en: '[PRE256]'
  id: totrans-1176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: Additional namespaces are imported, based on the project SDK (Web, Windows Forms,
    WPF, and so on).
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 根据项目 SDK（Web、Windows Forms、WPF 等），还会导入其他命名空间。
- en: using static
  id: totrans-1178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: using static
- en: 'The `using static` directive imports a *type* rather than a namespace. All
    static members of the imported type can then be used without qualification. In
    the following example, we call the `Console` class’s static `WriteLine` method
    without needing to refer to the type:'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: '`using static` 指令导入一个*类型*而不是命名空间。然后可以无需限定符使用导入类型的所有静态成员。在下面的示例中，我们调用 `Console`
    类的静态 `WriteLine` 方法，无需引用类型：'
- en: '[PRE257]'
  id: totrans-1180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: 'The `using static` directive imports all accessible static members of the type,
    including fields, properties, and nested types ([Chapter 3](ch03.html#creating_types_in_chash)).
    You can also apply this directive to enum types ([Chapter 3](ch03.html#creating_types_in_chash)),
    in which case their members are imported. So, if we import the following enum
    type:'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: '`using static`指令导入类型的所有可访问静态成员，包括字段、属性和嵌套类型（[第3章](ch03.html#creating_types_in_chash)）。也可以将此指令应用于枚举类型（[第3章](ch03.html#creating_types_in_chash)），在这种情况下将导入其成员。因此，如果我们导入以下枚举类型：'
- en: '[PRE258]'
  id: totrans-1182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: 'we can specify `Hidden` instead of `Visibility.Hidden`:'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定`Hidden`而不是`Visibility.Hidden`：
- en: '[PRE259]'
  id: totrans-1184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: Should an ambiguity arise between multiple static imports, the C# compiler is
    not smart enough to infer the correct type from the context and will generate
    an error.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个静态导入之间存在歧义，C#编译器无法从上下文中推断出正确的类型，并将生成错误。
- en: Rules Within a Namespace
  id: totrans-1186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间内的规则
- en: Name scoping
  id: totrans-1187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 名称作用域
- en: 'Names declared in outer namespaces can be used unqualified within inner namespaces.
    In this example, `Class1` does not need qualification within `Inner`:'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部命名空间中声明的名称可以在其中的内部命名空间中不带限定地使用。在此示例中，`Inner`内部不需要在`Class1`中进行限定：
- en: '[PRE260]'
  id: totrans-1189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: 'If you want to refer to a type in a different branch of your namespace hierarchy,
    you can use a partially qualified name. In the following example, we base `SalesReport`
    on `Common.ReportBase`:'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要引用命名空间层次结构中不同分支中的类型，可以使用部分限定名称。在以下示例中，我们将`SalesReport`基于`Common.ReportBase`：
- en: '[PRE261]'
  id: totrans-1191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: Name hiding
  id: totrans-1192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 名称隐藏
- en: 'If the same type name appears in both an inner and an outer namespace, the
    inner name wins. To refer to the type in the outer namespace, you must qualify
    its name:'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相同的类型名称同时出现在内部和外部命名空间中，则内部名称优先。要引用外部命名空间中的类型，必须限定其名称：
- en: '[PRE262]'
  id: totrans-1194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: Note
  id: totrans-1195
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: All type names are converted to fully qualified names at compile time. Intermediate
    Language (IL) code contains no unqualified or partially qualified names.
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类型名称在编译时转换为完全限定名称。中间语言（IL）代码不包含未限定或部分限定的名称。
- en: Repeated namespaces
  id: totrans-1197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重复的命名空间
- en: 'You can repeat a namespace declaration, as long as the type names within the
    namespaces don’t conflict:'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以重复命名空间声明，只要命名空间中的类型名称不冲突：
- en: '[PRE263]'
  id: totrans-1199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: We can even break the example into two source files such that we could compile
    each class into a different assembly.
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以将示例分解为两个源文件，以便将每个类编译到不同的程序集中。
- en: 'Source file 1:'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 源文件1：
- en: '[PRE264]'
  id: totrans-1202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: 'Source file 2:'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 源文件2：
- en: '[PRE265]'
  id: totrans-1204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: Nested using directives
  id: totrans-1205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌套的using指令
- en: 'You can nest a `using` directive within a namespace. This allows you to scope
    the `using` directive within a namespace declaration. In the following example,
    `Class1` is visible in one scope but not in another:'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名空间中可以嵌套`using`指令。这样可以在命名空间声明内部作用域限定`using`指令。在下面的示例中，`Class1`在一个作用域内可见，但在另一个作用域内不可见：
- en: '[PRE266]'
  id: totrans-1207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: Aliasing Types and Namespaces
  id: totrans-1208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 别名类型和命名空间
- en: 'Importing a namespace can result in type-name collision. Rather than importing
    the entire namespace, you can import just the specific types that you need, giving
    each type an alias:'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 导入命名空间可能导致类型名称冲突。与其导入整个命名空间，你可以只导入需要的特定类型，并为每个类型指定别名：
- en: '[PRE267]'
  id: totrans-1210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: 'An entire namespace can be aliased, as follows:'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 可以对整个命名空间进行别名，如下所示：
- en: '[PRE268]'
  id: totrans-1212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: Alias any type (C# 12)
  id: totrans-1213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 别名任何类型（C# 12）
- en: 'From C# 12, the `using` directive can alias any kind of type, including, for
    instance, arrays:'
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 12开始，`using`指令可以为任何类型（例如数组）设置别名：
- en: '[PRE269]'
  id: totrans-1215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: You can also alias tuples—we cover this in [“Aliasing Tuples (C# 12)”](ch04.html#aliasing_tuples_left_parenthesischash_o).
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以为元组设置别名-我们将在[“别名元组（C# 12）”](ch04.html#aliasing_tuples_left_parenthesischash_o)中讨论此问题。
- en: Advanced Namespace Features
  id: totrans-1217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级命名空间功能
- en: Extern
  id: totrans-1218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Extern
- en: Extern aliases allow your program to reference two types with the same fully
    qualified name (i.e., the namespace and type name are identical). This is an unusual
    scenario and can occur only when the two types come from different assemblies.
    Consider the following example.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 外部别名允许您的程序引用具有相同完全限定名称的两种类型（即命名空间和类型名称相同）。这是一个不寻常的情况，只有当这两种类型来自不同的程序集时才会发生。考虑以下示例。
- en: 'Library 1, compiled to *Widgets1.dll*:'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 库1，编译到*Widgets1.dll*：
- en: '[PRE270]'
  id: totrans-1221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: 'Library 2, compiled to *Widgets2.dll*:'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 库2，编译到*Widgets2.dll*：
- en: '[PRE271]'
  id: totrans-1223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: 'Application, which references *Widgets1.dll* and *Widgets2.dll*:'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序，引用*Widgets1.dll*和*Widgets2.dll*：
- en: '[PRE272]'
  id: totrans-1225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: 'The application cannot compile, because `Widget` is ambiguous. Extern aliases
    can resolve the ambiguity. The first step is to modify the application’s *.csproj*
    file, assigning a unique alias to each reference:'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序无法编译，因为`Widget`存在歧义。外部别名可以解决这种歧义。第一步是修改应用程序的*.csproj*文件，为每个引用分配唯一别名：
- en: '[PRE273]'
  id: totrans-1227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: 'The second step is to use the `extern alias` directive:'
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是使用 `extern alias` 指令：
- en: '[PRE274]'
  id: totrans-1229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: Namespace alias qualifiers
  id: totrans-1230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名空间别名限定符
- en: 'As we mentioned earlier, names in inner namespaces hide names in outer namespaces.
    However, sometimes even the use of a fully qualified type name does not resolve
    the conflict. Consider the following example:'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，内部命名空间中的名称会隐藏外部命名空间中的名称。然而，有时即使使用完全限定的类型名称也无法解决冲突。请考虑以下示例：
- en: '[PRE275]'
  id: totrans-1232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: The `Main` method could be instantiating either the nested class `B`, or the
    class `B` within the namespace `A`. The compiler always gives higher precedence
    to identifiers in the current namespace (in this case, the nested `B` class).
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法可以实例化嵌套类 `B`，或者命名空间 `A` 中的类 `B`。编译器总是优先考虑当前命名空间中的标识符（在本例中是嵌套类 `B`）。'
- en: 'To resolve such conflicts, a namespace name can be qualified, relative to one
    of the following:'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决此类冲突，可以对命名空间名称进行限定，相对于以下之一：
- en: The global namespace—the root of all namespaces (identified with the contextual
    keyword `global`)
  id: totrans-1235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局命名空间——所有命名空间的根（用上下文关键字 `global` 标识）
- en: The set of extern aliases
  id: totrans-1236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部别名集合
- en: 'The `::` token performs namespace alias qualification. In this example, we
    qualify using the global namespace (this is most commonly seen in autogenerated
    code to avoid name conflicts):'
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: '`::` 符号执行命名空间别名限定。在此示例中，我们使用全局命名空间进行限定（这在自动生成的代码中最常见，用于避免名称冲突）：'
- en: '[PRE276]'
  id: totrans-1238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: 'Here is an example of qualifying with an alias (adapted from the example in
    [“Extern”](#extern)):'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个使用别名进行限定的示例（改编自 [“Extern”](#extern) 中的例子）：
- en: '[PRE277]'
  id: totrans-1240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: ^([1](ch02.html#ch01fn1-marker)) A minor caveat is that very large `long` values
    lose some precision when converted to `double`.
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.html#ch01fn1-marker)) 一个小的注意事项是，非常大的 `long` 值在转换为 `double` 时会失去一些精度。
- en: ^([2](ch02.html#ch01fn2-marker)) Technically, `decimal` is a floating-point
    type, too, although it’s not referred to as such in the C# language specification.
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch02.html#ch01fn2-marker)) 从技术上讲，`decimal` 也是一种浮点类型，尽管在 C# 语言规范中没有这样称呼。
- en: ^([3](ch02.html#ch01fn3-marker)) It’s possible to *overload* these operators
    ([Chapter 4](ch04.html#advanced_chash)) such that they return a non-`bool` type,
    but this is almost never done in practice.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch02.html#ch01fn3-marker)) 可以*重载*这些运算符（参见[第4章](ch04.html#advanced_chash)），使其返回非`bool`类型，但实际上这几乎从不会这样做。
- en: ^([4](ch02.html#ch01fn4-marker)) An exception to this rule is when calling Component
    Object Model (COM) methods. We discuss this in [Chapter 25](ch25.html#regular_expressions-id00102).
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch02.html#ch01fn4-marker)) 这个规则的一个例外是调用组件对象模型 (COM) 方法时。我们在[第25章](ch25.html#regular_expressions-id00102)中讨论过这个问题。
