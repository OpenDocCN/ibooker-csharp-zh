["```cs\nvar inJail = true;\nvar inventory = getInventory();\nvar rnd = getRandomNumberGenerator();\n\nwhile(inJail)\n{\n  var playerAction = getAction();\n  if(playerAction == Actions.PayFine)\n  {\n   inventory.Money -= 50;\n   inJail = false;\n  }\n  else if(playerAction == Actions.GetOutOfJailFree)\n  {\n   inventory.GetOutOfJailFree -= 1;\n   inJail = false;\n  }\n  else if(playerAction == Actions.RollDice)\n  {\n   var dieOne = rnd.Random(1, 6);\n   var dieTwo = rnd.Random(1,6);\n   inJail = dieOne != dieTwo; // Stay in jail if the dice are different\n  }\n}\n```", "```cs\npublic record Inventory\n{\n public int Money { get; set; }\n public int GetOutOfJail { get; set; }\n}\n\n// I'm making the Inventory object a Record to make it\n// a bit easier to be functional\nvar inventory = getInventory();\nvar rnd = getRandomNumberGenerator();\n\nvar updatedInventory = GetOutOfJail(inventory);\n\nprivate Inventory GetOutOfJail(Inventory oldInv)\n{\n var playerAction = getAction();\n return playerAction switch\n {\n  Actions.PayFine => oldInv with\n  {\n   Money = oldInv.Money - 50\n  },\n  Actions.GetOutOfJailFree => oldInv with\n  {\n   GetOutOfJail = oldInv.GetOutOfJail - 1\n  },\n  Actions.RollDice =>\n  {\n   var dieOne = rnd.Random(1, 6);\n   var dieTwo = rnd.Random(1,6);\n   // return unmodified state, or else\n   // iterate again\n   return dieOne == dieTwo\n    ? oldInv\n    : GetOutOfJail(oldInv);\n  }\n };\n}\n```", "```cs\npublic static class FunctionalExtensions\n{\n\tpublic static T IterateUntil<T>(\n\t\tthis T @this,\n\t\tFunc<T, T> updateFunction,\n\t\tFunc<T, bool> endCondition)\n\t{\n\t\tvar currentThis = @this;\n\n\t\twhile (!endCondition(currentThis))\n\t\t{\n\t\t\tcurrentThis = updateFunction(currentThis);\n\t\t}\n\n\t\treturn currentThis;\n\t}\n}\n```", "```cs\n// we need everything required to both update and\n// assess whether we should continue or not in a\n// single object, so I'm considering it \"state\" rather than\n// simply inventory\nvar playerState = geState();\nvar rnd = getRandomNumberGenerator();\n\nvar playerState.IterateUntil(x => {\n var action = GetAction();\n  return action switch\n  {\n   Actions.PayFine => x with\n   {\n    Money = x.Money - 50,\n    LastAction = action\n   },\n   Actions.GetOutOfJailFree => x with\n   {\n    GetOutOfJail = x.GetOutOfJail - 1,\n    LastAction = action\n   },\n   _ => x with\n   {\n    DieOne = rnd.Random(1, 6),\n    DieTwo = rnd.Random(1, 6)\n   }\n  }\n},\n\nx => x.LastAction == Actions.PayFine ||\n x.LastAction == Actions.GetOutOfJailFree ||\n x.DieOne == x.DieTwo\n\n);\n```", "```cs\npublic static T IterateUntil<T>(\n this T @this,\n Func<T, T> updateFunction,\n Func<T, bool> endCondition)\n{\n\tvar currentThis = @this;\n\n\tLoopBeginning:\n\n\t\tcurrentThis = updateFunction(currentThis);\n\t\tif(endCondition(currentThis))\n\t\t\tgoto LoopEnding;\n\t\tgoto LoopBeginning;\n\n\tLoopEnding:\n\n\treturn currentThis;\n}\n```", "```cs\npublic interface IEnumerator<T>\n{\n object Current { get; }\n object IEnumerator.Current { get; }\n void Dispose();\n bool MoveNext();\n void Reset();\n}\n```", "```cs\npublic class ArrayEnumerable<T> : IEnumerator<T>\n{\n\tpublic readonly T[] _data;\n\tpublic int pos = -1;\n\tpublic ArrayEnumerable(T[] data)\n\t{\n\t\tthis._data = data;\n\t}\n\n\tprivate T GetCurrent() => this.pos > -1 ? _data[this.pos] : default;\n\n\tT IEnumerator<T>.Current => GetCurrent();\n\n\tobject IEnumerator.Current => GetCurrent();\n\n\tpublic void Dispose()\n\t{\n\t\t//  Run!  Run for your life!\n\t\t// Run before the GC gets us all!\n\t}\n\tpublic bool MoveNext()\n\t{\n\t\tthis.pos++;\n\t\treturn this.pos < this._data.Length;\n\t}\n\tpublic void Reset()\n\t{\n\t\tthis.pos = -1;\n\t}\n}\n```", "```cs\npublic bool MoveNext()\n{\n\tpos += 2;\n\treturn this.pos < this._data.Length;\n}\n\n// This turns { 1, 2, 3, 4 }\n// into { 2, 4 }\n```", "```cs\npublic bool IsCopy = false;\npublic bool MoveNext()\n{\n if(this.IsCopy)\n {\n  this.pos = this.pos + 1;\n }\n this.IsCopy = !this.IsCopy;\n\n return this.pos < this._data.Length\n}\n\n// This turns { 1, 2, 3 }\n// into { 1, 1, 2, 2, 3, 3 }\n```", "```cs\npublic class BackwardsEnumerator<T> : IEnumerable<T>\n{\n private readonly T[] data;\n\n public BackwardsEnumerator(IEnumerable<T> data)\n {\n  this.data = data.ToArray();\n }\n\n public IEnumerator<T> GetEnumerator()\n {\n  return new BackwardsArrayEnumerable<T>(this.data);\n }\n\n IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n}\n```", "```cs\npublic class BackwardsArrayEnumerable<T> : IEnumerator<T>\n{\n  public readonly T[] _data;\n\n public int pos;\n\n public BackwardsArrayEnumerable(T[] data)\n {\n  this._data = data ?? new T[0];\n  this.pos = this._data.Length;\n }\n\n T Current => (this._data != null && this._data.Length > 0 &&\n  this.pos >= 0 && this.pos < this._data.Length)\n   ? _data[pos] : default;\n\n object IEnumerator.Current => this.Current;\n\n T IEnumerator<T>.Current => this.Current;\n\n public void Dispose()\n {\n  // Nothing to dispose\n }\n\n public bool MoveNext()\n {\n\n  this.pos = this.pos - 1;\n  return this.pos >= 0;\n }\n\n public void Reset()\n {\n  this.pos = this._data.Length;\n }\n}\n```", "```cs\nvar data = new[] { 1, 2, 3, 4, 5, 6, 7, 8 };\nvar backwardsEnumerator = new BackwardsEnumerator<int>(data);\nvar list = new List<int>();\nforeach(var d in backwardsEnumerator)\n{\n list.Add(d);\n}\n\n// list = { 8, 7, 6, 5, 4, 3, 2, 1 }\n```", "```cs\npublic class GameEnumerator : IEnumerator<Game>\n{\n// I need this in case of a restart\n private Game StartState;\n private Game CurrentState;\n // old game state -> new game state\n private readonly Func<Game, Game> iterator;\n // Should the iteration stop?\n private Func<Game, bool> endCondition;\n // some tricky logic required to ensure the final\n // game state is iterated.  Normal logic is that if\n // the MoveNext function returns false, then there isn't\n // anything pulled from Current, the loop simply terminates\n private bool stopIterating = false;\n\n public GameEnumerator(Func<Game, Game> iterator,\n  Func<Game, bool> endCondition, Game state)\n {\n  this.StartState = state;\n  this.CurrentState = state;\n  this.iterator = iterator;\n  this.endCondition = endCondition;\n }\n\n public Game Current => this.CurrentState;\n\n object IEnumerator.Current => Current;\n\n public void Dispose()\n {\n  // Nothing to dispose\n }\n\n public bool MoveNext()\n {\n  var newState = this.iterator(this.CurrentState);\n  // Not strictly functional here, but as always with\n  // this topic, a compromise is needed\n  this.CurrentState = newState;\n\n // Have we completed the final iteration?  That's done after\n // reaching the end condition\n  if (stopIterating)\n      return false;\n\n  var endConditionMet = this.endCondition(this.CurrentState);\n  var lastIteration = !this.stopIterating && endConditionMet;\n  this.stopIterating = endConditionMet;\n  return !this.stopIterating || lastIteration;\n }\n\n public void Reset()\n {\n // restore the initial state\n  this.CurrentState = this.StartState;\n }\n}\n```", "```cs\npublic class GameIterator : IEnumerable<Game>\n{\n private readonly Game _startState;\n private readonly Func<Game,Game> _iterator;\n private readonly Func<Game,bool> _endCondition;\n\n public GameIterator(Game startState, Func<Game, Game> iterator,\n  Func<Game, bool> endCondition)\n {\n  this._startState = startState;\n  this._iterator = iterator;\n  this._endCondition = endCondition;\n }\n\n public IEnumerator<Game> GetEnumerator() =>\n  new GameEnumerator(this._startState, this._iterator, this._endCondition);\n }\n\n IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n}\n```", "```cs\nvar playerState = getState();\nvar rnd = getRandomNumberGenerator();\nvar endCondition = (Game x) => x.x.LastAction == Actions.PayFine ||\n  x.LastAction == Actions.GetOutOfJailFree ||\n  x.DieOne == x.DieTwo);\n\nvar update = (Game x) => {\n  var action = GetAction();\n    return action switch\n  {\n   Actions.PayFine => x with\n   {\n    Money = x.Money - 50,\n    LastAction = action\n   },\n   Actions.GetOutOfJailFree => x with\n   {\n    GetOutOfJail = x.GetOutOfJail - 1,\n    LastAction = action\n   },\n   _ => x with\n   {\n    DieOne = rnd.Random(1, 6),\n    DieTwo = rnd.Random(1, 6)\n   }\n  }\n}\n\nvar gameIterator = new GameIterator(playerState, update, endCondition);\n```", "```cs\nforeach(var g in gameIterator)\n{\n// store the updated state outside of the loop.\n playerState = g;\n\n // Here you can do whatever logic you'd like to do\n // to message back to the player.  Write a message onto screen\n // or whatever is useful for them to be prompted to do another action\n}\n\n// At the end of the loop here, the player is now out of jail, and\n// the game can continue with the updated version of playerState;\n```", "```cs\nvar gameStates = gameIterator.Select(x => x);\n```", "```cs\nvar endState = var gameStates = gameIterator.Last();\n```", "```cs\nvar messages = gameIterator.Select(x =>\n \"You chose to do \" + x.LastAction + \" and are \" +\n  (x.InJail ? \"In Jail\" : \"Free to go!\");\n);\n```", "```cs\nvar stateAndMessages = (\n Messages: Enumerable.Empty<string>(),\n State: playerState\n);\n\nvar updatedStateAndMessages =\n stateAndMessages.Aggregate(stateAndMessages, (acc, x) => (\n  acc.Messages.Append(\"You chose to do \" + x.LastAction + \" and are \" +\n   (x.InJail ? \"In Jail\" : \"Free to go!\")),\n   x\n ));\n```"]