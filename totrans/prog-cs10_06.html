<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 6. Inheritance" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_inheritance">
<h1><span class="label">Chapter 6. </span>Inheritance</h1>
<p><a data-primary="inheritance" data-type="indexterm" id="ix_ch06-asciidoc0"/>C# classes support <em>inheritance</em>, a popular object-oriented code reuse mechanism. When you write a class, you can optionally specify a base class. Your class will derive from this, meaning that everything in the base class will be present in your class, as well as any members you add.</p>
<p>Classes and class-based record types support only single inheritance (so you can only specify one base class). Interfaces offer a form of multiple inheritance. Value types, including <code>record struct</code> types, do not support inheritance at all. One reason for this is that value types are not normally used by reference, which removes one of the main benefits of inheritance: runtime polymorphism. Inheritance is not necessarily incompatible with value-like behavior—some languages manage it—but it often has problems. <a data-primary="slicing" data-type="indexterm" id="idm45884819738400"/>For example, assigning a value of some derived type into a variable of its base type ends up losing all of the fields that the derived type added, a problem known as <em>slicing</em>. C# sidesteps this by restricting inheritance to reference types. When you assign a variable of some derived type into a variable of a base type, you’re copying a reference, not the object itself, so the object remains intact. Slicing is an issue only if the base class offers a method that clones the object and doesn’t provide a way for derived classes to extend that (or it does, but some derived class fails to extend it).</p>
<p>Classes specify a base class using the syntax shown in <a data-type="xref" href="#specifying_a_base_class">Example 6-1</a>—the base type appears after a colon that follows the class name. This example assumes that a class called <code>SomeClass</code> has been defined elsewhere in the project, or one of the libraries 
<span class="keep-together">it uses.</span></p>
<div class="less_space pagebreak-before" data-type="example" id="specifying_a_base_class">
<h5><span class="label">Example 6-1. </span>Specifying a base class</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">Derived</code> <code class="p">:</code> <code class="n">SomeClass</code>
<code class="p">{</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">AlsoDerived</code> <code class="p">:</code> <code class="n">SomeClass</code><code class="p">,</code> <code class="n">IDisposable</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">void</code> <code class="nf">Dispose</code><code class="p">()</code> <code class="p">{</code> <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>As you saw in <a data-type="xref" href="ch03.xhtml#ch_types">Chapter 3</a>, if the class implements any interfaces, these are also listed after the colon. If you want to derive from a class, and you want to implement interfaces as well, the base class must appear first, as the second class in <a data-type="xref" href="#specifying_a_base_class">Example 6-1</a> illustrates.</p>
<p>You can derive from a class that in turn derives from another class. The <code>MoreDerived</code> class in <a data-type="xref" href="#inheritance_chain">Example 6-2</a> derives from <code>Derived</code>, which in turn derives from <code>Base</code>.</p>
<div data-type="example" id="inheritance_chain">
<h5><span class="label">Example 6-2. </span>Inheritance chain</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">Base</code>
<code class="p">{</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">Derived</code> <code class="p">:</code> <code class="n">Base</code>
<code class="p">{</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">MoreDerived</code> <code class="p">:</code> <code class="n">Derived</code>
<code class="p">{</code>
<code class="p">}</code></pre></div>
<p>This means that <code>MoreDerived</code> technically has multiple base classes: it derives from both <code>Derived</code> (directly) and <code>Base</code> (indirectly, via <code>Derived</code>). This is not multiple inheritance because there is only a single chain of inheritance—any single class derives directly from at most one base class. (All classes derive either directly or indirectly from <code>object</code>, which is the default base class if you do not specify one.)</p>
<p>Since a derived class inherits everything the base class has—all its fields, methods, and other members, both public and private—an instance of the derived class can do anything an instance of the base class could do. This is the classic <em>is a</em> relationship that inheritance implies in many languages. Any instance of <code>MoreDerived</code> is a <code>Derived</code> and also a <code>Base</code>. C#’s type system recognizes this relationship.</p>
<section data-pdf-bookmark="Inheritance and Conversions" data-type="sect1"><div class="sect1" id="inheritance_and_conversions">
<h1>Inheritance and Conversions</h1>
<p><a data-primary="conversions" data-secondary="implicit" data-type="indexterm" id="idm45884819623904"/><a data-primary="implicit conversions" data-type="indexterm" id="idm45884819622624"/><a data-primary="conversions" data-secondary="inheritance and" data-type="indexterm" id="ix_ch06-asciidoc1"/><a data-primary="inheritance" data-secondary="conversions and" data-type="indexterm" id="ix_ch06-asciidoc2"/>C# provides various built-in implicit conversions. In <a data-type="xref" href="ch02.xhtml#ch_basic_coding">Chapter 2</a>, we saw the conversions for numeric types, but there are also ones for reference types. If some type <code>D</code> derives from <code>B</code> (either directly or indirectly), then a reference of type <code>D</code> can be converted implicitly to a reference of type <code>B</code>. This follows from the <em>is a</em> relationship I described in the preceding section—any instance of <code>D</code> is a <code>B</code>. This implicit conversion enables polymorphism: code written to work in terms of <code>B</code> will be able to work with any type derived from <code>B</code>.</p>
<p><a data-primary="implicit conversions" data-secondary="implicit reference conversions" data-type="indexterm" id="idm45884819614672"/><a data-primary="conversions" data-secondary="implicit reference" data-type="indexterm" id="idm45884819613696"/>Implicit reference conversions are special. Unlike other conversions, they do not change the value in any way. (The built-in implicit numeric conversions all create a new value from their input, often involving a change of representation. The binary representation of the integer 1 looks different for the <code>float</code> and <code>int</code> types, for example.) In effect, they convert the interpretation of the reference, rather than converting the reference itself or the object it refers to. As you’ll see later in this chapter, there are various places where the CLR will take the availability of an implicit reference conversion into account but will not consider other forms of conversion.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>A custom implicit conversion between two reference types doesn’t count as an implicit reference conversion for these purposes, because a method needs to be invoked to effect such a conversion. The cases in which implicit reference conversions are special rely on the fact that the “conversion” requires no work at runtime.</p>
</div>
<p>There is no implicit conversion in the opposite direction—although a variable of type <code>B</code> could refer to an object of type <code>D</code>, there’s no guarantee that it will. There could be any number of types derived from <code>B</code>, and a <code>B</code> variable could refer to an instance of any of them. <a data-primary="downcast" data-type="indexterm" id="idm45884819608144"/>Nevertheless, you will sometimes want to attempt to convert a reference from a base type to a derived type, an operation sometimes referred to as a <em>downcast</em>. Perhaps you know for a fact that a particular variable holds a reference of a certain type. Or perhaps you’re not sure and would like your code to provide additional services for specific types. C# offers three ways to do this.</p>
<p>We can attempt a downcast using the cast syntax. This is the same syntax we use for performing nonimplicit numeric conversions, as <a data-type="xref" href="#feeling_downcast">Example 6-3</a> shows.</p>
<div data-type="example" id="feeling_downcast">
<h5><span class="label">Example 6-3. </span>Feeling downcast</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">static</code> <code class="k">void</code> <code class="nf">UseAsDerived</code><code class="p">(</code><code class="n">Base</code> <code class="n">baseArg</code><code class="p">)</code>
<code class="p">{</code>
    <code class="kt">var</code> <code class="n">d</code> <code class="p">=</code> <code class="p">(</code><code class="n">Derived</code><code class="p">)</code> <code class="n">baseArg</code><code class="p">;</code>

    <code class="c1">// ...go on to do something with d</code>
<code class="p">}</code></pre></div>
<p><a data-primary="InvalidCastException type" data-type="indexterm" id="idm45884819589568"/>This conversion is not guaranteed to succeed—that’s why we can’t use an implicit conversion. If you try this when the <code>baseArg</code> argument refers to something that’s neither an instance of <code>Derived</code> nor something derived from <code>Derived</code>, the conversion will fail, throwing an <code>InvalidCastException</code>. (Exceptions are described in <a data-type="xref" href="ch08.xhtml#ch_exceptions">Chapter 8</a>.)</p>
<p>A cast is therefore appropriate only if you’re confident that the object really is of the type you expect, and you would consider it to be an error if it turned out not to be. This is useful when an API accepts an object that it will later give back to you. Many asynchronous APIs do this, because in cases where you launch multiple operations concurrently, you need some way of working out which particular one finished when you get a completion notification (although, as we’ll see in later chapters, there are various ways to tackle that problem). Since these APIs don’t know what sort of data you’ll want to associate with an operation, they usually just take a reference of type <code>object</code>, and you would typically use a cast to turn it back into a reference of the required type when the reference is eventually handed back to you.</p>
<p>Sometimes, you will not know for certain whether an object has a particular type. In this case, you can use the<a data-primary="as operator" data-type="indexterm" id="idm45884819580864"/> <code>as</code> operator instead, as shown in <a data-type="xref" href="#the_as_operator">Example 6-4</a>. This allows you to attempt a conversion without risking an exception. If the conversion fails, this operator just returns <code>null</code>.</p>
<div data-type="example" id="the_as_operator">
<h5><span class="label">Example 6-4. </span>The <code>as</code> operator</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">static</code> <code class="k">void</code> <code class="nf">MightUseAsDerived</code><code class="p">(</code><code class="n">Base</code> <code class="n">b</code><code class="p">)</code>
<code class="p">{</code>
    <code class="kt">var</code> <code class="n">d</code> <code class="p">=</code> <code class="n">b</code> <code class="k">as</code> <code class="n">Derived</code><code class="p">;</code>

    <code class="k">if</code> <code class="p">(</code><code class="n">d</code> <code class="p">!=</code> <code class="k">null</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="c1">// ...go on to do something with d</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>Although this technique is quite common in existing code, the introduction of patterns back in C# 7.0 provided a more succinct alternative. <a data-type="xref" href="#is_operator_with_declaration_pattern">Example 6-5</a> has the same effect as <a data-type="xref" href="#the_as_operator">Example 6-4</a>: the body of the <code>if</code> runs only if <code>b</code> refers to an instance of <code>Derived</code>, in which case it can be accessed through the variable <code>d</code>. <a data-primary="is operator" data-type="indexterm" id="idm45884819492528"/>The <code>is</code> keyword here indicates that we want to test <code>b</code> against a pattern. In this case we’re using a declaration pattern, which  performs the same runtime type test as the <code>as</code> operator. An expression that applies a pattern with <code>is</code> produces a <code>bool</code> indicating whether the pattern matches. We can use this as the <code>if</code> statement’s condition expression, removing the need to compare with <code>null</code>. And since declaration patterns incorporate variable declaration and initialization, the work that needed two statements in <a data-type="xref" href="#the_as_operator">Example 6-4</a> can all be rolled into the <code>if</code> statement in <a data-type="xref" href="#is_operator_with_declaration_pattern">Example 6-5</a>.</p>
<div data-type="example" id="is_operator_with_declaration_pattern">
<h5><span class="label">Example 6-5. </span>The <code>is</code> operator with a declaration pattern</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">static</code> <code class="k">void</code> <code class="nf">MightUseAsDerived</code><code class="p">(</code><code class="n">Base</code> <code class="n">b</code><code class="p">)</code>
<code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="n">b</code> <code class="k">is</code> <code class="n">Derived</code> <code class="n">d</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="c1">// ...go on to do something with d</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>In addition to being more compact, the <code>is</code> operator also has the benefit of working in one scenario where <code>as</code> does not: you can test whether a reference of type <code>object</code> refers to an instance of a value type such as an <code>int</code>. (This may seem like a contradiction—how could you have a reference to something that is not a reference type? <a data-type="xref" href="ch07.xhtml#ch_object_lifetime">Chapter 7</a> will show how this is possible.) The <code>as</code> operator wouldn’t work because it returns <code>null</code> when the instance is not of the specified type, but of course it cannot do that for a value type—there’s no such thing as a <code>null</code> of type <code>int</code>. Since the declaration pattern eliminates the need to test for <code>null</code>—we just use the <code>bool</code> result that the <code>is</code> operator produces—we are free to use value types.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Occasionally you may want to detect when a particular type is present without needing to perform a conversion. Since <code>is</code> can be followed by any pattern, you can use a type pattern, e.g., <code>is Derived</code>. This performs the same test as a declaration pattern, without going on to introduce a new variable.</p>
</div>
<p>When converting with the techniques just described, you don’t necessarily need to specify the exact type. <a data-primary="conversions" data-secondary="implicit" data-type="indexterm" id="idm45884819455568"/><a data-primary="implicit conversions" data-type="indexterm" id="idm45884819454592"/>These operations will succeed as long as an implicit reference conversion exists from the object’s real type to the type you’re looking for. For example, given the <code>Base</code>, <code>Derived</code>, and <code>MoreDerived</code> types that <a data-type="xref" href="#inheritance_chain">Example 6-2</a> defines, suppose you have a variable of type <code>Base</code> that currently contains a reference to an instance of <code>MoreDerived</code>. Obviously, you could cast the reference to <code>MoreDerived</code> (and both <code>as</code> and <code>is</code> would also succeed for that type), but as you’d probably expect, converting to <code>Derived</code> would work too.</p>
<p>These four mechanisms also work for interfaces. When you try to convert a reference to an interface type reference (or test for an interface type with a type pattern), it will succeed if the object referred to implements the relevant interface.<a data-startref="ix_ch06-asciidoc2" data-type="indexterm" id="idm45884819448608"/><a data-startref="ix_ch06-asciidoc1" data-type="indexterm" id="idm45884819447904"/></p>
</div></section>
<section data-pdf-bookmark="Interface Inheritance" data-type="sect1"><div class="sect1" id="interface_inheritance">
<h1>Interface Inheritance</h1>
<p><a data-primary="inheritance" data-secondary="interface inheritance" data-type="indexterm" id="idm45884819445552"/><a data-primary="interface inheritance" data-type="indexterm" id="idm45884819444576"/>Interfaces support inheritance, but it’s not quite the same as class inheritance. The syntax is similar, but as <a data-type="xref" href="#interface_inheritance-id1">Example 6-6</a> shows, an interface can specify multiple base interfaces. While .NET offers only single implementation inheritance, this limitation does not apply to interfaces because most of the complications and potential ambiguities that can arise with multiple inheritance do not apply to purely abstract types. The most vexing problems are around handling of fields, which means that even interfaces with default implementations support multiple inheritance, because those don’t get to add either fields or public members to the implementing type. (When a class uses a default implementation for a member, that member is accessible only through references of the interface’s type.)</p>
<div data-type="example" id="interface_inheritance-id1">
<h5><span class="label">Example 6-6. </span>Interface inheritance</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">interface</code> <code class="n">IBase1</code>
<code class="p">{</code>
    <code class="k">void</code> <code class="nf">Base1Method</code><code class="p">();</code>
<code class="p">}</code>

<code class="k">interface</code> <code class="n">IBase2</code>
<code class="p">{</code>
    <code class="k">void</code> <code class="nf">Base2Method</code><code class="p">();</code>
<code class="p">}</code>

<code class="k">interface</code> <code class="n">IBoth</code> <code class="p">:</code> <code class="n">IBase1</code><code class="p">,</code> <code class="n">IBase2</code>
<code class="p">{</code>
    <code class="k">void</code> <code class="nf">Method3</code><code class="p">();</code>
<code class="p">}</code></pre></div>
<p>Although <em>interface inheritance</em> is the official name for this feature, it is a misnomer—whereas derived classes inherit all members from their base, derived interfaces do not. It may appear that they do—given a variable of type <code>IBoth</code>, you can invoke the <code>Base1Method</code> and <code>Base2Method</code> methods defined by its bases. However, the true meaning of interface inheritance is that any type that implements an interface is obliged to implement all inherited interfaces. So a class that implements <code>IBoth</code> must also implement <code>IBase1</code> and <code>IBase2</code>. It’s a subtle distinction, especially since C# does not require you to list the base interfaces explicitly. The class in <a data-type="xref" href="#implementing_a_derived_interface">Example 6-7</a> only declares that it implements <code>IBoth</code>. However, if you were to use .NET’s reflection API, to inspect the type definition, you would find that the compiler has added <code>IBase1</code> and <code>IBase2</code> to the list of interfaces the class implements as well as the explicitly declared <code>IBoth</code>.</p>
<div data-type="example" id="implementing_a_derived_interface">
<h5><span class="label">Example 6-7. </span>Implementing a derived interface</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">Impl</code> <code class="p">:</code> <code class="n">IBoth</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">void</code> <code class="nf">Base1Method</code><code class="p">()</code>
    <code class="p">{</code>
    <code class="p">}</code>

    <code class="k">public</code> <code class="k">void</code> <code class="nf">Base2Method</code><code class="p">()</code>
    <code class="p">{</code>
    <code class="p">}</code>

    <code class="k">public</code> <code class="k">void</code> <code class="nf">Method3</code><code class="p">()</code>
    <code class="p">{</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>Since implementations of a derived interface must implement all base interfaces, C# lets you access bases’ members directly through a reference of a derived type, so a variable of type <code>IBoth</code> provides access to <code>Base1Method</code> and <code>Base2Method</code>, as well as that interface’s own <code>Method3</code>. Implicit reference conversions exist from derived interface types to their bases. For example, a reference of type <code>IBoth</code> can be assigned to variables of type <code>IBase1</code> and <code>IBase2</code>.</p>
</div></section>
<section data-pdf-bookmark="Generics" data-type="sect1"><div class="sect1" id="generics-id1">
<h1>Generics</h1>
<p><a data-primary="generics" data-secondary="inheritance" data-type="indexterm" id="ix_ch06-asciidoc3"/><a data-primary="inheritance" data-secondary="generics" data-type="indexterm" id="ix_ch06-asciidoc4"/>If you derive from a generic class, you must supply the type arguments it requires. If your derived type is also generic, it can use its own type parameters as arguments if you wish, as long as they meet any constraints the base class defines. <a data-type="xref" href="#deriving_from_a_generic_base_class">Example 6-8</a> shows both techniques and also illustrates that when deriving from a class with multiple type parameters, you can use a mixture, specifying one type argument directly and punting on the other.</p>
<div data-type="example" id="deriving_from_a_generic_base_class">
<h5><span class="label">Example 6-8. </span>Deriving from a generic base class</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">GenericBase1</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="n">T</code><code class="p">?</code> <code class="n">Item</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">GenericBase2</code><code class="p">&lt;</code><code class="n">TKey</code><code class="p">,</code> <code class="n">TValue</code><code class="p">&gt;</code>
    <code class="k">where</code> <code class="n">TValue</code> <code class="p">:</code> <code class="k">class</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="n">TKey</code><code class="p">?</code> <code class="n">Key</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
    <code class="k">public</code> <code class="n">TValue</code><code class="p">?</code> <code class="n">Value</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">NonGenericDerived</code> <code class="p">:</code> <code class="n">GenericBase1</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code>
<code class="p">{</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">GenericDerived</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="p">:</code> <code class="n">GenericBase1</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code>
<code class="p">{</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">MixedDerived</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="p">:</code> <code class="n">GenericBase2</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="n">T</code><code class="p">&gt;</code>
    <code class="k">where</code> <code class="n">T</code> <code class="p">:</code> <code class="k">class</code>
<code class="p">{</code>
<code class="p">}</code></pre></div>
<p>Although you are free to use any of your type parameters as type arguments for a base class, you cannot derive from a type parameter. This is a little disappointing if you are used to languages that permit such things, but the C# language specification simply forbids it. However, you are allowed to use your own type as a type argument to your base class. And you can also specify a constraint on a type argument, requiring it to derive from your own type. <a data-type="xref" href="#curious_patterns">Example 6-9</a> shows each of these.</p>
<div data-type="example" id="curious_patterns">
<h5><span class="label">Example 6-9. </span>Self-referential type arguments</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">SelfAsTypeArgument</code> <code class="p">:</code> <code class="n">IComparable</code><code class="p">&lt;</code><code class="n">SelfAsTypeArgument</code><code class="p">&gt;</code>
<code class="p">{</code>
    <code class="c1">// ...implementation removed for clarity</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">Curious</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code>
    <code class="k">where</code> <code class="n">T</code> <code class="p">:</code> <code class="n">Curious</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code>
<code class="p">{</code>
<code class="p">}</code></pre></div>
<section data-pdf-bookmark="Covariance and Contravariance" data-type="sect2"><div class="sect2" id="covariance_and_contravariance">
<h2>Covariance and Contravariance</h2>
<p><a data-primary="covariance" data-type="indexterm" id="ix_ch06-asciidoc5"/><a data-primary="generics" data-secondary="covariance and contravariance" data-type="indexterm" id="ix_ch06-asciidoc6"/>In <a data-type="xref" href="ch04.xhtml#ch_generics">Chapter 4</a>, I mentioned that generic types have special rules for type compatibility, referred to as <em>covariance</em> and <em>contravariance</em>. <a data-primary="conversions" data-secondary="implicit" data-type="indexterm" id="idm45884819104416"/><a data-primary="implicit conversions" data-type="indexterm" id="idm45884819103408"/>These rules determine whether references of certain generic types are implicitly convertible to one another when implicit conversions exist between their type arguments.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Covariance and contravariance are applicable only to the generic type arguments of interfaces and delegates. (Delegates are described in <a data-type="xref" href="ch09.xhtml#ch_delegates_lambdas_events">Chapter 9</a>.) You cannot define a covariant or contravariant class, struct, or record.</p>
</div>
<p>Consider the simple <code>Base</code> and <code>Derived</code> classes shown earlier in <a data-type="xref" href="#inheritance_chain">Example 6-2</a>, and look at the method in <a data-type="xref" href="#a_method_accepting_any_base">Example 6-10</a>, which accepts any <code>Base</code>. (It does nothing with it, but that’s not relevant here—what matters is what its signature says it can use.)</p>
<div data-type="example" id="a_method_accepting_any_base">
<h5><span class="label">Example 6-10. </span>A method accepting any <code>Base</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">static</code> <code class="k">void</code> <code class="nf">UseBase</code><code class="p">(</code><code class="n">Base</code> <code class="n">b</code><code class="p">)</code>
<code class="p">{</code>
<code class="p">}</code></pre></div>
<p>We already know that as well as accepting a reference to any <code>Base</code>, this can also accept a reference to an instance of any type derived from <code>Base</code>, such as <code>Derived</code>. Bearing that in mind, consider the method in <a data-type="xref" href="#a_method_accepting_any_ienumerable_base">Example 6-11</a>.</p>
<div data-type="example" id="a_method_accepting_any_ienumerable_base">
<h5><span class="label">Example 6-11. </span>A method accepting any <code>IEnumerable&lt;Base&gt;</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">static</code> <code class="k">void</code> <code class="nf">AllYourBase</code><code class="p">(</code><code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">Base</code><code class="p">&gt;</code> <code class="n">bases</code><code class="p">)</code>
<code class="p">{</code>
<code class="p">}</code></pre></div>
<p>This requires an object that implements the <code>IEnumerable&lt;T&gt;</code> generic interface described in <a data-type="xref" href="ch05.xhtml#ch_collections">Chapter 5</a>, where <code>T</code> is <code>Base</code>. What would you expect to happen if we attempted to pass an object that did not implement <code>IEnumerable&lt;Base&gt;</code> but did implement <code>IEnumerable&lt;Derived&gt;</code>? <a data-type="xref" href="#passing_an_ienumerable_of_a_derived_t">Example 6-12</a> does this, and it compiles just fine.</p>
<div data-type="example" id="passing_an_ienumerable_of_a_derived_t">
<h5><span class="label">Example 6-12. </span>Passing an <code>IEnumerable&lt;T&gt;</code> of a derived type</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">Derived</code><code class="p">&gt;</code> <code class="n">derivedItems</code> <code class="p">=</code> <code class="k">new</code><code class="p">[]</code> <code class="p">{</code> <code class="k">new</code> <code class="n">Derived</code><code class="p">(),</code> <code class="k">new</code> <code class="n">Derived</code><code class="p">()</code> <code class="p">};</code>
<code class="n">AllYourBase</code><code class="p">(</code><code class="n">derivedItems</code><code class="p">);</code></pre></div>
<p>Intuitively, this makes sense. The <code>AllYourBase</code> method is expecting an object that can supply a sequence of objects that are all of type <code>Base</code>. An <code>IEnumerable&lt;Derived&gt;</code> fits the bill because it supplies a sequence of <code>Derived</code> objects, and any <code>Derived</code> object is also a <code>Base</code>. However, what about the code in <a data-type="xref" href="#method_accepting_any_icollectionofbase">Example 6-13</a>?</p>
<div data-type="example" id="method_accepting_any_icollectionofbase">
<h5><span class="label">Example 6-13. </span>A method accepting any <code>ICollection&lt;Base&gt;</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">static</code> <code class="k">void</code> <code class="nf">AddBase</code><code class="p">(</code><code class="n">ICollection</code><code class="p">&lt;</code><code class="n">Base</code><code class="p">&gt;</code> <code class="n">bases</code><code class="p">)</code>
<code class="p">{</code>
    <code class="n">bases</code><code class="p">.</code><code class="n">Add</code><code class="p">(</code><code class="k">new</code> <code class="n">Base</code><code class="p">());</code>
<code class="p">}</code></pre></div>
<p>Recall from <a data-type="xref" href="ch05.xhtml#ch_collections">Chapter 5</a> that <code>ICollection&lt;T&gt;</code> derives from <code>IEnumerable&lt;T&gt;</code>, and it adds the ability to modify the collection in certain ways. This particular method exploits that by adding a new <code>Base</code> object to the collection. That would mean trouble for the code in <a data-type="xref" href="#error_trying_to_pass_an_icollection">Example 6-14</a>.</p>
<div data-type="example" id="error_trying_to_pass_an_icollection">
<h5><span class="label">Example 6-14. </span>Error: trying to pass an <code>ICollection&lt;T&gt;</code> with a derived type</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">ICollection</code><code class="p">&lt;</code><code class="n">Derived</code><code class="p">&gt;</code> <code class="n">derivedList</code> <code class="p">=</code> <code class="k">new</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Derived</code><code class="p">&gt;();</code>
<code class="n">AddBase</code><code class="p">(</code><code class="n">derivedList</code><code class="p">);</code>  <code class="c1">// Will not compile</code></pre></div>
<p>Code that uses the <code>derivedList</code> variable will expect every object in that list to be of type <code>Derived</code> (or something derived from it, such as the <code>MoreDerived</code> class from <a data-type="xref" href="#inheritance_chain">Example 6-2</a>). But the <code>AddBase</code> method in <a data-type="xref" href="#method_accepting_any_icollectionofbase">Example 6-13</a> attempts to add a plain <code>Base</code> instance. That cannot be correct, and the compiler does not allow it. The call to <code>AddBase</code> will produce a compiler error complaining that references of type <code>ICollection&lt;Derived&gt;</code> cannot be converted implicitly to references of type <code>ICollection&lt;Base&gt;</code>.</p>
<p>How does the compiler know that it’s not OK to do this, while the very similar-looking conversion from <code>IEnumerable&lt;Derived&gt;</code> to <code>IEnumerable&lt;Base&gt;</code> is allowed? It’s not because <a data-type="xref" href="#method_accepting_any_icollectionofbase">Example 6-13</a> contains code that would cause a problem, by the way. You’d get the same compiler error even if the <code>AddBase</code> method were completely empty. The reason we don’t get an error in <a data-type="xref" href="#passing_an_ienumerable_of_a_derived_t">Example 6-12</a> is that the <code>IEnumerable&lt;T&gt;</code> interface declares its type argument <code>T</code> as covariant. You saw the syntax for this in <a data-type="xref" href="ch05.xhtml#ch_collections">Chapter 5</a>, but I didn’t draw attention to it, so <a data-type="xref" href="#covariant_type_parameter">Example 6-15</a> shows the relevant part from that interface’s definition again.</p>
<div data-type="example" id="covariant_type_parameter">
<h5><span class="label">Example 6-15. </span>Covariant type parameter</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">interface</code> <code class="n">IEnumerable</code><code class="p">&lt;</code><code class="k">out</code> <code class="n">T</code><code class="p">&gt;</code> <code class="p">:</code> <code class="n">IEnumerable</code></pre></div>
<p>That <code>out</code> keyword does the job. (Again, C# keeps up the C-family tradition of giving each keyword multiple jobs—we first saw this keyword in the context of method parameters that can return information to the caller.) Intuitively, describing the type argument <code>T</code> as “out” makes sense, in that the <code>IEnumerable&lt;T&gt;</code> interface only ever <em>provides</em> a <code>T</code>—it does not define any members that <em>accept</em> a <code>T</code>. (The interface uses this type parameter in just one place: its read-only <code>Current</code> property.)</p>
<p>Compare that with <code>ICollection&lt;T&gt;</code>. This derives from <code>IEnumerable&lt;T&gt;</code>, so clearly it’s possible to get a <code>T</code> out of it, but it’s also possible to pass a <code>T</code> into its <code>Add</code> method. So <code>ICollection&lt;T&gt;</code> cannot annotate its type argument with <code>out</code>. (If you were to try to write your own similar interface, the compiler would produce an error if you declared the type argument as being covariant. Rather than just taking your word for it, it checks to make sure you really can’t pass a <code>T</code> in anywhere.)</p>
<p>The compiler rejects the code in <a data-type="xref" href="#error_trying_to_pass_an_icollection">Example 6-14</a> because <code>T</code> is not covariant in 
<span class="keep-together"><code>ICollection&lt;T&gt;</code></span>. The terms <em>covariant</em> and <em>contravariant</em> come from a branch of mathematics called <em>category theory</em>. <a data-primary="conversions" data-secondary="implicit" data-type="indexterm" id="idm45884818807472"/><a data-primary="implicit conversions" data-type="indexterm" id="idm45884818806464"/>The parameters that behave like 
<span class="keep-together"><code>IEnumerable&lt;T&gt;</code></span>’s <code>T</code> are called covariant because implicit reference conversions for the generic type work in the same direction as conversions for the type argument: <code>Derived</code> is implicitly convertible to <code>Base</code>, and since <code>T</code> is covariant in <code>IEnumerable&lt;T&gt;</code>, <code>IEnumerable&lt;Derived&gt;</code> is implicitly convertible to <code>IEnumerable&lt;Base&gt;</code>.</p>
<p><a data-primary="contravariance" data-type="indexterm" id="ix_ch06-asciidoc7"/>Contravariance works the other way around, and as you might guess, we denote it with the <code>in</code> keyword. It’s easiest to see this in action with code that uses members of types, so <a data-type="xref" href="#class_hierarchy_with_actual_members">Example 6-16</a> shows a marginally more interesting pair of classes than the earlier examples.</p>
<div data-type="example" id="class_hierarchy_with_actual_members">
<h5><span class="label">Example 6-16. </span>Class hierarchy with actual members</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">Shape</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="n">Rect</code> <code class="n">BoundingBox</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">RoundedRectangle</code> <code class="p">:</code> <code class="n">Shape</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="kt">double</code> <code class="n">CornerRadius</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code></pre></div>
<p><a data-type="xref" href="#comparing_shapes">Example 6-17</a> defines two classes that use these shape types. Both implement 
<span class="keep-together"><code>IComparer&lt;T&gt;</code></span>, which I introduced in <a data-type="xref" href="ch04.xhtml#ch_generics">Chapter 4</a>. <a data-primary="comparison" data-type="indexterm" id="idm45884818775248"/>The <code>BoxAreaComparer</code> compares two shapes based on the area of their bounding box—the shape whose bounding box covers the greater area will be deemed the larger by this comparison. The <code>CornerSharpnessComparer</code>, on the other hand, compares rounded rectangles by looking at how pointy their corners are.</p>
<div data-type="example" id="comparing_shapes">
<h5><span class="label">Example 6-17. </span>Comparing shapes</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">BoxAreaComparer</code> <code class="p">:</code> <code class="n">IComparer</code><code class="p">&lt;</code><code class="n">Shape</code><code class="p">&gt;</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="kt">int</code> <code class="nf">Compare</code><code class="p">(</code><code class="n">Shape</code><code class="p">?</code> <code class="n">x</code><code class="p">,</code> <code class="n">Shape</code><code class="p">?</code> <code class="n">y</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="n">x</code> <code class="k">is</code> <code class="k">null</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="k">return</code> <code class="n">y</code> <code class="k">is</code> <code class="k">null</code> <code class="p">?</code> <code class="m">0</code> <code class="p">:</code> <code class="p">-</code><code class="m">1</code><code class="p">;</code>
        <code class="p">}</code>
        <code class="k">if</code> <code class="p">(</code><code class="n">y</code> <code class="k">is</code> <code class="k">null</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="k">return</code> <code class="m">1</code><code class="p">;</code>
        <code class="p">}</code>

        <code class="kt">double</code> <code class="n">xArea</code> <code class="p">=</code> <code class="n">x</code><code class="p">.</code><code class="n">BoundingBox</code><code class="p">.</code><code class="n">Width</code> <code class="p">*</code> <code class="n">x</code><code class="p">.</code><code class="n">BoundingBox</code><code class="p">.</code><code class="n">Height</code><code class="p">;</code>
        <code class="kt">double</code> <code class="n">yArea</code> <code class="p">=</code> <code class="n">y</code><code class="p">.</code><code class="n">BoundingBox</code><code class="p">.</code><code class="n">Width</code> <code class="p">*</code> <code class="n">y</code><code class="p">.</code><code class="n">BoundingBox</code><code class="p">.</code><code class="n">Height</code><code class="p">;</code>

        <code class="k">return</code> <code class="n">Math</code><code class="p">.</code><code class="n">Sign</code><code class="p">(</code><code class="n">xArea</code> <code class="p">-</code> <code class="n">yArea</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">CornerSharpnessComparer</code> <code class="p">:</code> <code class="n">IComparer</code><code class="p">&lt;</code><code class="n">RoundedRectangle</code><code class="p">&gt;</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="kt">int</code> <code class="nf">Compare</code><code class="p">(</code><code class="n">RoundedRectangle</code><code class="p">?</code> <code class="n">x</code><code class="p">,</code> <code class="n">RoundedRectangle</code><code class="p">?</code> <code class="n">y</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="n">x</code> <code class="k">is</code> <code class="k">null</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="k">return</code> <code class="n">y</code> <code class="k">is</code> <code class="k">null</code> <code class="p">?</code> <code class="m">0</code> <code class="p">:</code> <code class="p">-</code><code class="m">1</code><code class="p">;</code>
        <code class="p">}</code>
        <code class="k">if</code> <code class="p">(</code><code class="n">y</code> <code class="k">is</code> <code class="k">null</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="k">return</code> <code class="m">1</code><code class="p">;</code>
        <code class="p">}</code>

        <code class="c1">// Smaller corners are sharper, so smaller radius is "greater" for</code>
        <code class="c1">// the purpose of this comparison, hence the backward subtraction.</code>
        <code class="k">return</code> <code class="n">Math</code><code class="p">.</code><code class="n">Sign</code><code class="p">(</code><code class="n">y</code><code class="p">.</code><code class="n">CornerRadius</code> <code class="p">-</code> <code class="n">x</code><code class="p">.</code><code class="n">CornerRadius</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p><a data-primary="IComparer&lt;T&gt; interface" data-type="indexterm" id="idm45884818518672"/><a data-primary="conversions" data-secondary="implicit" data-type="indexterm" id="idm45884818517632"/><a data-primary="implicit conversions" data-type="indexterm" id="idm45884818516784"/>References of type <code>RoundedRectangle</code> are implicitly convertible to <code>Shape</code>, so what about <code>IComparer&lt;T&gt;</code>? Our <code>BoxAreaComparer</code> can compare any shapes and declares this by implementing <code>IComparer&lt;Shape&gt;</code>. The comparer’s type argument <code>T</code> is only ever used in the <code>Compare</code> method, and that is happy to be passed any <code>Shape</code>. It will not be fazed if we pass it a pair of <code>RoundedRectangle</code> references, so our class is a perfectly adequate <span class="keep-together"><code>IComparer&lt;RoundedRectangle&gt;</code></span>. An implicit conversion from <span class="keep-together"><code>IComparer&lt;Shape&gt;</code></span> to <span class="keep-together"><code>IComparer&lt;RoundedRectangle&gt;</code></span> therefore makes sense, and is in fact allowed. However, the <span class="keep-together"><code>CornerSharpnessComparer</code></span> is fussier. It uses the <code>CornerRadius</code> property, which is available only on rounded rectangles, not on any old <code>Shape</code>. Therefore, no implicit conversion exists from <code>IComparer&lt;RoundedRectangle&gt;</code> to <code>IComparer&lt;Shape&gt;</code>.</p>
<p>This is the reverse of what we saw with <code>IEnumerable&lt;T&gt;</code>. <a data-primary="conversions" data-secondary="reference" data-type="indexterm" id="idm45884818471168"/><a data-primary="reference conversions" data-type="indexterm" id="idm45884818470160"/><a data-primary="conversions" data-secondary="implicit reference" data-type="indexterm" id="idm45884818469488"/><a data-primary="implicit conversions" data-secondary="implicit reference conversions" data-type="indexterm" id="idm45884818468544"/>Implicit conversion is available between <code>IEnumerable&lt;T1&gt;</code> and <code>IEnumerable&lt;T2&gt;</code> when an implicit reference conversion from <code>T1</code> to <code>T2</code> exists. But implicit conversion between <code>IComparer&lt;T1&gt;</code> and <code>IComparer&lt;T2&gt;</code> is available when an implicit reference conversion exists in the other direction: from <code>T2</code> to <code>T1</code>. That reversed relationship is called contravariance. <a data-type="xref" href="#contravariant_type_parameter">Example 6-18</a> is an excerpt of the definition for <code>IComparer&lt;T&gt;</code> showing this contravariant type parameter.</p>
<div data-type="example" id="contravariant_type_parameter">
<h5><span class="label">Example 6-18. </span>Contravariant type parameter</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">interface</code> <code class="n">IComparer</code><code class="p">&lt;</code><code class="k">in</code> <code class="n">T</code><code class="p">&gt;</code></pre></div>
<p>Most generic type parameters are neither covariant nor contravariant. (They are <em>invariant</em>.) <span class="keep-together"><code>ICollection&lt;T&gt;</code></span> cannot be variant, because it contains some members that accept a <code>T</code> and some that return one. An <code>ICollection&lt;Shape&gt;</code> might contain shapes that are not <code>RoundedRectangles</code>, so you cannot pass it to a method expecting an <code>ICollection&lt;RoundedRectangle&gt;</code>, because such a method would expect every object it retrieves from the collection to be a rounded rectangle. Conversely, an <span class="keep-together"><code>ICollection&lt;RoundedRectangle&gt;</code></span> cannot be expected to allow shapes other than rounded rectangles to be added, and so you cannot pass an <code>ICo⁠lle⁠cti⁠on&lt;⁠Rou⁠nde⁠d​Rec⁠tan⁠gle&gt;</code> to a method that expects an <code>ICollection&lt;Shape&gt;</code> because that method may try to add other kinds of shapes.</p>
<p>Arrays are covariant, just like <code>IEnumerable&lt;T&gt;</code>. This is rather odd, because we can write methods like the one in <a data-type="xref" href="#changing_an_element_in_an_array">Example 6-19</a>.</p>
<div data-type="example" id="changing_an_element_in_an_array">
<h5><span class="label">Example 6-19. </span>Changing an element in an array</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">static</code> <code class="k">void</code> <code class="nf">UseBaseArray</code><code class="p">(</code><code class="n">Base</code><code class="p">[]</code> <code class="n">bases</code><code class="p">)</code>
<code class="p">{</code>
    <code class="n">bases</code><code class="p">[</code><code class="m">0</code><code class="p">]</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Base</code><code class="p">();</code>
<code class="p">}</code></pre></div>
<p>If I were to call this with the code in <a data-type="xref" href="#passing_an_array_with_derived_element_ty">Example 6-20</a>, I would be making the same mistake as I did in <a data-type="xref" href="#error_trying_to_pass_an_icollection">Example 6-14</a>, where I attempted to pass an <code>ICollection&lt;Derived&gt;</code> to a method that wanted to put something that was not <code>Derived</code> into the collection. But while <a data-type="xref" href="#error_trying_to_pass_an_icollection">Example 6-14</a> does not compile, <a data-type="xref" href="#passing_an_array_with_derived_element_ty">Example 6-20</a> does, due to the surprising covariance of arrays.</p>
<div data-type="example" id="passing_an_array_with_derived_element_ty">
<h5><span class="label">Example 6-20. </span>Passing an array with derived element type</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">Derived</code><code class="p">[]</code> <code class="n">derivedBases</code> <code class="p">=</code> <code class="p">{</code> <code class="k">new</code> <code class="n">Derived</code><code class="p">(),</code> <code class="k">new</code> <code class="n">Derived</code><code class="p">()</code> <code class="p">};</code>
<code class="n">UseBaseArray</code><code class="p">(</code><code class="n">derivedBases</code><code class="p">);</code></pre></div>
<p>This makes it look as though we could sneakily make this array accept a reference to an object that is not an instance of the array’s element type—in this case, putting a reference to a non-<code>Derived</code> object, <code>Base</code>, in <code>Derived[]</code>. But that would be a violation of the type system. Does this mean the sky is falling?</p>
<p>In fact, C# correctly forbids such a violation, but it relies on the CLR to enforce this at runtime. Although a reference to an array of type <code>Derived[]</code> can be implicitly converted to a reference of type <code>Base[]</code>, any attempt to set an array element in a way that is inconsistent with the type system will throw an <code>ArrayTypeMismatchException</code>. So <a data-type="xref" href="#changing_an_element_in_an_array">Example 6-19</a> would throw that exception when it tried to assign a reference to a <code>Base</code> into the <code>Derived[]</code> array.</p>
<p>The runtime check ensures that type safety is maintained, and this enables a convenient feature. If we write a method that takes an array and only reads from it, we can pass arrays of some derived element type. The downside is that the CLR has to do extra work at runtime when you modify array elements to ensure that there is no type mismatch. It may be able to optimize the code to avoid having to check every single assignment, but there is still some overhead, meaning that arrays are not quite as efficient as they might be.</p>
<p>This somewhat peculiar arrangement dates back to the time before .NET had formalized concepts of covariance and contravariance—these came in with generics, which were introduced in .NET 2.0. Perhaps if generics had been around from the start, arrays would be less odd, although having said that, even after .NET 2.0 their peculiar form of covariance was for many years the only mechanism built into the framework that provided a way to pass a collection covariantly to a method that wanted to read from it using indexing. Until .NET 4.5 introduced <code>IReadOnlyList&lt;T&gt;</code> (for which <code>T</code> is covariant), there was no read-only indexed collection interface in the framework, and therefore no standard indexed collection interface with a covariant type parameter. (<code>IList&lt;T&gt;</code> is read/write, so just like <code>ICollection&lt;T&gt;</code>, it cannot offer variance.)<a data-startref="ix_ch06-asciidoc7" data-type="indexterm" id="idm45884818347440"/></p>
<p>While we’re on the subject of type compatibility and the implicit reference conversions that inheritance makes available, there’s one more type we should look at: <code>object</code><a data-startref="ix_ch06-asciidoc6" data-type="indexterm" id="idm45884818325184"/><a data-startref="ix_ch06-asciidoc5" data-type="indexterm" id="idm45884818324576"/>.<a data-startref="ix_ch06-asciidoc4" data-type="indexterm" id="idm45884818323840"/><a data-startref="ix_ch06-asciidoc3" data-type="indexterm" id="idm45884818323232"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="System.Object" data-type="sect1"><div class="sect1" id="system.object">
<h1>System.Object</h1>
<p><a data-primary="inheritance" data-secondary="System.Object" data-type="indexterm" id="idm45884818321216"/><a data-primary="System.Object" data-type="indexterm" id="idm45884818320240"/>The <code>System.Object</code> type, or <code>object</code>, as we usually call it in C#, is useful because it can act as a sort of universal container: a variable of this type can hold a reference to almost anything. I’ve mentioned this before, but I haven’t yet explained why it’s true. The reason this works is that almost everything derives from <code>object</code>.</p>
<p>If you do not specify a base class when writing a class or record, the C# compiler automatically uses <code>object</code> as the base. As we’ll see shortly, it chooses different bases for certain kinds of types such as structs, but even those derive from <code>object</code> indirectly. (As ever, pointer types are an exception—these do not derive from <code>object</code>.)</p>
<p><a data-primary="interfaces" data-secondary="objects versus" data-type="indexterm" id="idm45884818315552"/><a data-primary="objects" data-secondary="interfaces versus" data-type="indexterm" id="idm45884818314240"/>The relationship between interfaces and objects is slightly more subtle. Interfaces do not derive from <code>object</code>, because an interface can specify only other interfaces as its bases. However, a reference of any interface type is implicitly convertible to a reference of type <code>object</code>. This conversion will always be valid, because all types that are capable of implementing interfaces ultimately derive from <code>object</code>. Moreover, C# chooses to make the <code>object</code> class’s members available through interface references even though they are not, strictly speaking, members of the interface. <a data-primary="ToString method" data-type="indexterm" id="idm45884818311424"/>This means that references of any kind always offer the following methods defined by <code>object</code>: <code>ToString</code>, <code>Equals</code>, <code>GetHashCode</code>, and <code>GetType</code>.</p>
<section data-pdf-bookmark="The Ubiquitous Methods of System.Object" data-type="sect2"><div class="sect2" id="the_ubiquitous_methods_of_object">
<h2>The Ubiquitous Methods of System.Object</h2>
<p>I’ve used <code>ToString</code> in a few examples already. The default implementation returns the object’s type name, but many types provide their own implementation of <code>ToString</code>, returning a more useful textual representation of the object’s current value. The numeric types return a decimal representation of their value, for example, while <code>bool</code> returns either <code>"True"</code> or <code>"False"</code>.</p>
<p><a data-primary="Equals method" data-type="indexterm" id="idm45884818303776"/>I discussed <code>Equals</code> and <code>GetHashCode</code> in <a data-type="xref" href="ch03.xhtml#ch_types">Chapter 3</a>, but I’ll provide a quick recap here. <code>Equals</code> allows an object to be compared with any other object. The default implementation just performs an identity comparison—that is, it returns <code>true</code> only when an object is compared with itself. Many types provide an <code>Equals</code> method that performs value-like comparison—for example, two distinct <code>string</code> objects may contain identical text, in which case they will report being equal to each other. <a data-primary="ReferenceEquals method" data-type="indexterm" id="idm45884818298608"/>(Should you need to perform an identity-based comparison of objects that provide value-based comparison, you can use the <code>object</code> class’s static <span class="keep-together"><code>ReferenceEquals</code></span> method.) Incidentally, <code>object</code> also defines a static version of <code>Equals</code> that takes two arguments. This checks whether the arguments are <code>null</code>, returning <code>true</code> if both are <code>null</code> and <code>false</code> if only one is <code>null</code>; otherwise, it defers to the first argument’s <code>Equals</code> method. <a data-primary="GetHashCode method" data-type="indexterm" id="idm45884818293088"/>And, as discussed in <a data-type="xref" href="ch03.xhtml#ch_types">Chapter 3</a>, <code>GetHashCode</code> returns an integer that is a reduced representation of the object’s value, which is used by hash-based mechanisms such as the <code>Dictionary&lt;TKey, TValue&gt;</code> collection class. Any pair of objects for which <code>Equals</code> returns <code>true</code> must return the same hash codes.</p>
<p>The <code>GetType</code> method provides a way to discover things about the object’s type. It returns a reference of type <code>Type</code>. That’s part of the reflection API, which is the subject of <a data-type="xref" href="ch13.xhtml#ch_reflection">Chapter 13</a>.</p>
<p>Besides these public members, available through any reference, <code>object</code> defines two more members that are not universally accessible. An object has access to these members only on itself. <a data-primary="Finalize method" data-type="indexterm" id="idm45884818286928"/><a data-primary="MemberwiseClone method" data-type="indexterm" id="idm45884818286224"/>They are <code>Finalize</code> and <code>MemberwiseClone</code>. The CLR calls the <code>Finalize</code> method to notify you that your object is no longer in use and the memory it occupies is about to be reclaimed. In C# we do not normally work directly with the <code>Finalize</code> method, because C# presents this mechanism through destructors, as I’ll show in <a data-type="xref" href="ch07.xhtml#ch_object_lifetime">Chapter 7</a>. <code>MemberwiseClone</code> creates a new instance of the same type as your object, initialized with copies of all of your object’s fields. If you need a way to create a clone of an object, this may be easier than writing code that copies all the contents across by hand, although it is not very fast.</p>
<p>The reason these last two methods are available only from inside the object is that you might not want other people cloning your object, and it would be unhelpful if external code could call the <code>Finalize</code> method, fooling your object into thinking that it was about to be freed if in fact it wasn’t. <a data-primary="private members" data-type="indexterm" id="ch06-priv8"/>The <code>object</code> class limits the accessibility of these members. But they’re not private—that would mean that only the <code>object</code> class itself could access them, because private members are not visible even to derived classes. Instead, <code>object</code> makes theses members <em>protected</em>, an accessibility specifier designed for inheritance scenarios.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Accessibility and Inheritance" data-type="sect1"><div class="sect1" id="accessibility_and_inheritance">
<h1>Accessibility and Inheritance</h1>
<p><a data-primary="accessibility" data-secondary="inheritance and" data-type="indexterm" id="idm45884818276224"/><a data-primary="inheritance" data-secondary="accessibility and" data-type="indexterm" id="idm45884818275024"/>By now, you will already be familiar with most of the accessibility levels available for types and their members. Elements marked as <code>public</code> are available to all, <code>private</code> members are accessible only from within the type that declared them, and <code>internal</code> members are available to code defined in the same component.<sup><a data-type="noteref" href="ch06.xhtml#CHP-6-FN-1" id="CHP-6-FN-1-marker">1</a></sup> But with inheritance, we get three other accessibility options.</p>
<p><a data-primary="protected members" data-type="indexterm" id="idm45884818270704"/>A member marked as <code>protected</code> is available inside the type that defined it and also inside any derived types. But for code using an instance of your type, <code>protected</code> members are not accessible, just like <code>private</code> members.</p>
<p><a data-primary="protected internal members" data-type="indexterm" id="idm45884818268064"/><a data-primary="internal members" data-type="indexterm" id="idm45884818267168"/><a data-primary="internal types" data-type="indexterm" id="idm45884818266496"/>The next protection level for type members is <code>protected internal</code>. (You can write <code>internal protected</code> if you prefer; the order makes no difference.) This makes the member more accessible than either <code>protected</code> or <code>internal</code> on its own: the member will be accessible to all derived types <em>and</em> to all code that shares an assembly.</p>
<p><a data-primary="protected private members" data-type="indexterm" id="idm45884818263264"/>The third protection level that inheritance adds is <code>protected private</code>. Members marked with this (or the equivalent <code>private protected</code>) are available only to types that are both derived from <em>and</em> defined in the same component as the defining type.</p>
<p>You can use <code>protected</code>, <code>protected internal</code>, or <code>protected private</code> for any member of a type, and not just methods. You can even define nested types with these accessibility specifiers.</p>
<p>While <code>protected</code> and <code>protected internal</code> (although not <code>protected private</code>) members are not available through an ordinary variable of the defining type, they are still part of the type’s public API, in the sense that anyone who has access to your classes will be able to use these members. As with most languages that support a similar mechanism, <code>protected</code> members in C# are typically used to provide services that derived classes might find useful. If you write a <code>public</code> class that supports inheritance, then anyone can derive from it and gain access to its <code>protected</code> members. Removing or changing <code>protected</code> members would therefore risk breaking code that depends on your class just as surely as removing or changing <code>public</code> members would.<a data-startref="ch06-priv8" data-type="indexterm" id="idm45884818254336"/></p>
<p>When you derive from a class, you cannot make your class more visible than its base. If you derive from an <code>internal</code> class, for example, you cannot declare your class to be <code>public</code>. Your base class forms part of your class’s API, so anyone wishing to use your class will also in effect be using its base class; this means that if the base is inaccessible, your class will also be inaccessible, which is why C# does not permit a class to be more visible than its base. If you derive from a <code>protected</code> nested class, your derived class could be <code>protected</code>, <code>private</code>, or <code>protected private</code> but not <code>public</code>, <code>internal</code>, or <code>protected internal</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>This restriction does not apply to the interfaces you implement. A <code>public</code> class is free to implement <code>internal</code> or <code>private</code> interfaces. However, it does apply to an interface’s bases: a <code>public</code> interface cannot derive from an <code>internal</code> interface.</p>
</div>
<p>When defining methods, there’s another keyword you can add for the benefit of derived types: <code>virtual</code>.</p>
</div></section>
<section data-pdf-bookmark="Virtual Methods" data-type="sect1"><div class="sect1" id="virtual_methods">
<h1>Virtual Methods</h1>
<p><a data-primary="inheritance" data-secondary="virtual methods" data-type="indexterm" id="ix_ch06-asciidoc8"/><a data-primary="methods" data-secondary="virtual" data-type="indexterm" id="ix_ch06-asciidoc9"/><a data-primary="virtual methods" data-type="indexterm" id="ix_ch06-asciidoc10"/>A <em>virtual method</em> is one that a derived type can replace. Several of the methods defined by <code>object</code> are virtual: the <code>ToString</code>, <code>Equals</code>, <code>GetHashCode</code>, and <code>Finalize</code> methods are all designed to be replaced. The code required to produce a useful textual representation of an object’s value will differ considerably from one type to another, as will the logic required to determine equality and produce a hash code. Types typically define a finalizer only if they need to do some specialized cleanup work when they go out of use.</p>
<p>Not all methods are virtual. In fact, C# makes methods nonvirtual by default. The <code>object</code> class’s <code>GetType</code> method is not virtual, so you can always trust the information it returns to you because you know that you’re calling the <code>GetType</code> method supplied by .NET, and not some type-specific substitute designed to fool you. To declare that a method should be virtual, use the <code>virtual</code> keyword, as <a data-type="xref" href="#a_class_with_a_virtual_method">Example 6-21</a> shows.</p>
<div data-type="example" id="a_class_with_a_virtual_method">
<h5><span class="label">Example 6-21. </span>A class with a virtual method</h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="k">public</code> <code class="k">class</code> <code class="nc">BaseWithVirtual</code>
<code class="p">{</code>
    <strong><code class="k">public</code> <code class="k">virtual</code> <code class="k">void</code> <code class="nf">ShowMessage</code><code class="p">(</code><code class="p">)</code></strong>
    <code class="p">{</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Hello from BaseWithVirtual"</code><code class="p">)</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can also apply the <code>virtual</code> keyword to properties. Properties are just methods under the covers, so this has the effect of making the accessor methods virtual. The same is true for events, which are discussed in <a data-type="xref" href="ch09.xhtml#ch_delegates_lambdas_events">Chapter 9</a>.</p>
</div>
<p>There’s nothing unusual about the syntax for invoking a virtual method. As <a data-type="xref" href="#using_a_virtual_method">Example 6-22</a> shows, it looks just like calling any other method.</p>
<div data-type="example" id="using_a_virtual_method">
<h5><span class="label">Example 6-22. </span>Using a virtual method</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">static</code> <code class="k">void</code> <code class="nf">CallVirtualMethod</code><code class="p">(</code><code class="n">BaseWithVirtual</code> <code class="n">o</code><code class="p">)</code>
<code class="p">{</code>
    <code class="n">o</code><code class="p">.</code><code class="n">ShowMessage</code><code class="p">();</code>
<code class="p">}</code></pre></div>
<p>The difference between virtual and nonvirtual method invocations is that a virtual method call decides at runtime which method to invoke. The code in <a data-type="xref" href="#using_a_virtual_method">Example 6-22</a> will, in effect, inspect the object passed in, and if the object’s type supplies its own implementation of <code>ShowMessage</code>, it will call that instead of the one defined in <span class="keep-together"><code>BaseWithVirtual</code></span>. The method is chosen based on the actual type the target object turns out to have at runtime, and not the static type (determined at compile time) of the expression that refers to the target object.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Since virtual method invocation selects the method based on the type of the object on which you invoke the method, static methods cannot be virtual.</p>
</div>
<p>Derived types are not obliged to replace virtual methods. <a data-type="xref" href="#overriding_virtual_methods">Example 6-23</a> shows two classes that derive from the one in <a data-type="xref" href="#a_class_with_a_virtual_method">Example 6-21</a>. The first leaves the base class’s implementation of <code>ShowMessage</code> in place. The second overrides it. Note the <code>override</code> keyword—C# requires us to state explicitly that we are intending to override a virtual method.</p>
<div data-type="example" id="overriding_virtual_methods">
<h5><span class="label">Example 6-23. </span>Overriding virtual methods</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">DeriveWithoutOverride</code> <code class="p">:</code> <code class="n">BaseWithVirtual</code>
<code class="p">{</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">DeriveAndOverride</code> <code class="p">:</code> <code class="n">BaseWithVirtual</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">override</code> <code class="k">void</code> <code class="nf">ShowMessage</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"This is an override"</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>We can use these types with the method in <a data-type="xref" href="#using_a_virtual_method">Example 6-22</a>. <a data-type="xref" href="#exploiting_virtual_methods">Example 6-24</a> calls it three times, passing in a different type of object each time.</p>
<div data-type="example" id="exploiting_virtual_methods">
<h5><span class="label">Example 6-24. </span>Exploiting virtual methods</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">CallVirtualMethod</code><code class="p">(</code><code class="k">new</code> <code class="n">BaseWithVirtual</code><code class="p">());</code>
<code class="n">CallVirtualMethod</code><code class="p">(</code><code class="k">new</code> <code class="n">DeriveWithoutOverride</code><code class="p">());</code>
<code class="n">CallVirtualMethod</code><code class="p">(</code><code class="k">new</code> <code class="n">DeriveAndOverride</code><code class="p">());</code></pre></div>
<p>This produces the following output:</p>
<pre data-type="programlisting">Hello from BaseWithVirtual
Hello from BaseWithVirtual
This is an override</pre>
<p>Obviously, when we pass an instance of the base class, we get the output from the base class’s <code>ShowMessage</code> method. We also get that with the derived class that has not supplied an override. It is only the final class, which overrides the method, that produces different output. This shows that virtual methods provide a way to write polymorphic code: <a data-type="xref" href="#using_a_virtual_method">Example 6-22</a> can use a variety of types.</p>
<p>When overriding a method, the method name and its parameter types must be an exact match. In most cases, the return type will also be identical, but it doesn’t always need to be. If the <code>virtual</code> method’s return type is not <code>void</code>, and is not a <code>ref</code> return, the overriding method may have a different type as long as an implicit reference conversion from that type to the <code>virtual</code> method’s return type exists. To put that more informally, an override is allowed to be more specific about its return type. This means that examples such as <a data-type="xref" href="#override_covariant_return_type">Example 6-25</a> are legal.</p>
<div data-type="example" id="override_covariant_return_type">
<h5><span class="label">Example 6-25. </span>An override that narrows the return type</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">Product</code> <code class="p">{</code> <code class="p">}</code>
<code class="k">public</code> <code class="k">class</code> <code class="nc">Book</code> <code class="p">:</code> <code class="n">Product</code> <code class="p">{</code> <code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">ProductSourceBase</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">virtual</code> <code class="n">Product</code> <code class="nf">Get</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">new</code> <code class="n">Product</code><code class="p">();</code> <code class="p">}</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">BookSource</code> <code class="p">:</code> <code class="n">ProductSourceBase</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">override</code> <code class="n">Book</code> <code class="nf">Get</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">new</code> <code class="n">Book</code><code class="p">();</code> <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>Note that the return type of the override of <code>Get</code> is <code>Book</code>, even though the <code>virtual</code> method it overrides returns a <code>Product</code>. This is fine because anything that invokes this method through a reference of type <code>ProductSourceBase</code> will expect to get back a reference of type <code>Product</code>, and thanks to inheritance, a <code>Book</code> is a <code>Product</code>. So users of the <code>ProductSourceBase</code> type will be unaware of and unaffected by the change. This feature can sometimes be useful in cases where code working directly with a derived type needs to know the specific type that will be returned.</p>
<p>You might be wondering why we need virtual methods, given that interfaces also enable polymorphic code. <a data-primary="interfaces" data-secondary="virtual methods versus" data-type="indexterm" id="idm45884817934672"/><a data-primary="virtual methods" data-secondary="interfaces versus" data-type="indexterm" id="idm45884817933664"/>Prior to C# 8.0 one major advantage of virtual methods over interfaces was that the base class could provide an implementation that derived classes would acquire by default, supplying their own implementation only if they really needed something different. The addition of default interface implementations to the language means that interfaces can now do the same thing, although a default interface member implementation cannot define or access nonstatic fields, so it is somewhat limited compared to a class that defines a virtual function. (And since default interface implementations require runtime support, they are unavailable to code that needs to be able to run on .NET Framework, which includes any library targeting .NET Standard 2.0 or older.) However, there is a more subtle advantage available to virtual methods, but before we can look at it, we need to explore a feature of virtual methods that at first glance even more closely resembles the way interfaces work.</p>
<section data-pdf-bookmark="Abstract Methods" data-type="sect2"><div class="sect2" id="abstract_methods">
<h2>Abstract Methods</h2>
<p><a data-primary="abstract methods" data-type="indexterm" id="idm45884817930688"/><a data-primary="virtual methods" data-secondary="abstract methods" data-type="indexterm" id="idm45884817929760"/>You can define a virtual method without providing a default implementation. C# calls this an <em>abstract method</em>. If a class contains one or more abstract methods, the class is incomplete, because it doesn’t provide all of the methods it defines. Classes of this kind are also described as being abstract, and it is not possible to construct instances of an abstract class; attempting to use the <code>new</code> operator with an abstract class will cause a compiler error. <a data-primary="concrete class" data-type="indexterm" id="idm45884817927776"/>Sometimes when discussing classes, it’s useful to make clear that some particular class is <em>not</em> abstract, for which we normally use the term <em>concrete class</em>.</p>
<p>If you derive from an abstract class, then unless you provide implementations for all the abstract methods, your derived class will also be abstract. You must state your intention to write an abstract class with the <code>abstract</code> keyword; if this is absent from a class that has unimplemented abstract methods (either ones it has defined itself or ones it has inherited from its base class), the C# compiler will report an error. <a data-type="xref" href="#an_abstract_class">Example 6-26</a> shows an abstract class that defines a single abstract method. Abstract methods are virtual by definition; there wouldn’t be much use in defining a method that has no body if there were no way for derived classes to supply a body.</p>
<div data-type="example" id="an_abstract_class">
<h5><span class="label">Example 6-26. </span>An abstract class</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">abstract</code> <code class="k">class</code> <code class="nc">AbstractBase</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">abstract</code> <code class="k">void</code> <code class="nf">ShowMessage</code><code class="p">();</code>
<code class="p">}</code></pre></div>
<p>Abstract method declarations just define the signature and do not contain a body. Unlike with interfaces, each abstract member has its own accessibility—you can declare abstract methods as <code>public</code>, <code>internal</code>, <code>protected internal</code>, <code>protected private</code>, or <code>protected</code>. (It makes no sense to make an abstract or virtual method <code>private</code>, because the method will be inaccessible to derived types and therefore impossible to override.)</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Although classes that contain abstract methods are required to be abstract, the converse is not true. It is legal, albeit unusual, to define a class as abstract even if it would be a viable concrete class. This prevents the class from being constructed. A class that derives from this will be concrete without needing to override any abstract methods.</p>
</div>
<p>Abstract classes have the option to declare that they implement an interface without needing to provide a full implementation. You can’t just omit the unimplemented members, though. You must explicitly declare all of its members, marking any that you want to leave unimplemented as being abstract, as <a data-type="xref" href="#abstract_interface_implementation">Example 6-27</a> shows. This forces concrete derived types to supply the implementation.</p>
<div data-type="example" id="abstract_interface_implementation">
<h5><span class="label">Example 6-27. </span>Abstract interface implementation</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">abstract</code> <code class="k">class</code> <code class="nc">MustBeComparable</code> <code class="p">:</code> <code class="n">IComparable</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">abstract</code> <code class="kt">int</code> <code class="nf">CompareTo</code><code class="p">(</code><code class="kt">string?</code> <code class="n">other</code><code class="p">);</code>
<code class="p">}</code></pre></div>
<p>There’s clearly some overlap between abstract classes and interfaces. Both provide a way to define an abstract type that code can use without needing to know the exact type that will be supplied at runtime. Each option has its pros and cons. Interfaces have the advantage that a single type can implement multiple interfaces, whereas a class gets to specify only a single base class. But abstract classes can define fields and can use these in any default member implementations they supply, and they also provide a way to supply default implementations that will work on .NET Framework. However, there’s a more subtle advantage available to virtual methods that comes into play when you release multiple versions of a library over time.</p>
</div></section>
<section data-pdf-bookmark="Inheritance and Library Versioning" data-type="sect2"><div class="sect2" id="idm45884817932032">
<h2>Inheritance and Library Versioning</h2>
<p><a data-primary="inheritance" data-secondary="library versioning and" data-type="indexterm" id="ix_ch06-asciidoc11"/><a data-primary="libraries" data-secondary="inheritance and library versioning" data-type="indexterm" id="ix_ch06-asciidoc12"/><a data-primary="versioning" data-secondary="inheritance and library versioning" data-type="indexterm" id="ix_ch06-asciidoc13"/><a data-primary="virtual methods" data-secondary="inheritance and library versioning" data-type="indexterm" id="ix_ch06-asciidoc14"/>Imagine what would happen if you had written and released a library that defined some public interfaces and abstract classes, and in the second release of the library, you decided that you wanted to add some new members to one of the interfaces. It’s conceivable that this might not cause a problem for customers using your code. <span class="keep-together">Certainly,</span> any place where they use a reference of that interface type will be unaffected by the addition of new features. However, what if some of your customers have written types that implement your interface? Suppose, for example, that in a future version of .NET, Microsoft decided to add a new member to the <code>IEnumerable&lt;T&gt;</code> interface.</p>
<p>If the interface were not to supply a default implementation for the new member, it would be a disaster. This interface is widely used but also widely implemented. Classes that already implement <code>IEnumerable&lt;T&gt;</code> would become invalid because they would not provide this new member, so old code would fail to compile, and code already compiled would throw <code>MissingMethodException</code> errors at runtime. C#’s support for default member implementations in interfaces mitigates this: in the unlikely event that Microsoft did add a new member to <code>IEnumerable&lt;T&gt;</code>, it could supply a default implementation preventing these errors. This doesn’t help anyone using .NET Framework, which does not support this feature, but for newer runtimes, it makes modification of existing interface definitions seem viable. However, there’s a more subtle problem. Some classes might by chance already have had a member with the same name and signature as the newly added method. If that code is recompiled against the new interface definition, the compiler would treat that existing member as part of the implementation of the interface, even though the developer who wrote the method did not write it with that intention. So unless the existing code coincidentally happens to do exactly what the new member requires, we’d have a problem, and we wouldn’t get compiler errors or warnings to alert us.</p>
<p>Consequently, the widely accepted rule is that you do not alter interfaces once they have been published. If you have complete control over all of the code that uses and implements an interface, you can get away with modifying the interface, because you can make any necessary modifications to the affected code. But once the interface has become available for use in codebases you do not control—that is, once it has been published—it’s no longer possible to change it without risking breaking someone else’s code. Default interface implementations mitigate this risk, but they cannot eliminate the problem of existing methods accidentally being misinterpreted when they get recompiled against the updated interface.</p>
<p>Abstract base classes do not have to suffer from this problem. Obviously, introducing new abstract members would cause exactly the same <code>MissingMethodException</code> failures, but introducing new virtual methods does not. (And since virtual methods have been in C# since v1, this enables you to target .NET Framework, where default interface implementation support is unavailable.)</p>
<p>But what if, after releasing version 1.0 of a component, you add a new virtual method in version 1.1 that turns out to have the same name and signature as a method that one of your customers happens to have added in a derived class? Perhaps in version 1.0, your component defines the rather uninteresting base class shown in <a data-type="xref" href="#base_type_version_1.0">Example 6-28</a>.</p>
<div data-type="example" id="base_type_version_1.0">
<h5><span class="label">Example 6-28. </span>Base type version 1.0</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">LibraryBase</code>
<code class="p">{</code>
<code class="p">}</code></pre></div>
<p>If you release this library, perhaps on the <a href="https://nuget.org">NuGet package management website</a>, or maybe as part of some Software Development Kit (SDK) for your application, a customer might write a derived type such as the one in <a data-type="xref" href="#class_derived_from_version_1.0_base">Example 6-29</a>. The <code>Start</code> method they have written is clearly not meant to override anything in the base class.</p>
<div data-type="example" id="class_derived_from_version_1.0_base">
<h5><span class="label">Example 6-29. </span>Class derived from version 1.0 base</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">CustomerDerived</code> <code class="p">:</code> <code class="n">LibraryBase</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">void</code> <code class="nf">Start</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Derived type's Start method"</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>Since you won’t necessarily get to see every line of code that your customers write, you might be unaware of this <code>Start</code> method. So in version 1.1 of your component, you might decide to add a new virtual method, also called <code>Start</code>, as <a data-type="xref" href="#base_type_version_1.1">Example 6-30</a> shows.</p>
<div data-type="example" id="base_type_version_1.1">
<h5><span class="label">Example 6-30. </span>Base type version 1.1</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">LibraryBase</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">virtual</code> <code class="k">void</code> <code class="nf">Start</code><code class="p">()</code> <code class="p">{</code> <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>Imagine that your system calls this method as part of an initialization procedure introduced in v1.1. You’ve defined a default empty implementation so that types derived from <code>LibraryBase</code> that don’t need to take part in that procedure don’t have to do anything. Types that wish to participate will override this method. But what happens with the class in <a data-type="xref" href="#class_derived_from_version_1.0_base">Example 6-29</a>? Clearly the developer who wrote that did not intend to participate in your new initialization mechanism, because that didn’t exist when the code was written. It could be bad if your code calls the <code>CustomerDerived</code> class’s <code>Start</code> method, because the developer presumably expects it to be called only when their code decides to call it. Fortunately, the compiler will detect this problem. If the customer attempts to compile <a data-type="xref" href="#class_derived_from_version_1.0_base">Example 6-29</a> against version 1.1 of your library (<a data-type="xref" href="#base_type_version_1.1">Example 6-30</a>), the compiler will warn them that something is not right:</p>
<pre data-type="programlisting">warning CS0114: 'CustomerDerived.Start()' hides inherited member
'LibraryBase.Start()'. To make the current member override that implementation,
add the override keyword. Otherwise add the new keyword.</pre>
<p><a data-primary="override keyword" data-type="indexterm" id="idm45884817727056"/>This is why the C# compiler requires the <code>override</code> keyword when we replace virtual methods. It wants to know whether we were intending to override an existing method, so that if we weren’t, it can warn us about naming collisions. (The absence of any equivalent keyword signifying the intention to implement an interface member is why the compiler cannot detect the same problem with default interface implementation. And the reason for this absence is that default interface implementation didn’t exist prior to C# 8.0.)</p>
<p>We get a warning rather than an error, because the compiler provides a behavior that is likely to be safe when this situation has arisen due to the release of a new version of a library. The compiler guesses—correctly, in this case—that the developer who wrote the <code>CustomerDerived</code> type didn’t mean to override the <code>LibraryBase</code> class’s <code>Start</code> method. So rather than having the <code>CustomerDerived</code> type’s <code>Start</code> method override the base class’s virtual method, it <em>hides</em> it. A derived type is said to hide a member of a base class when it introduces a new member with the same name.</p>
<p><a data-primary="hidden methods, virtual methods versus" data-type="indexterm" id="idm45884817699184"/><a data-primary="virtual methods" data-secondary="hidden methods versus" data-type="indexterm" id="idm45884817698352"/>Hiding methods is quite different than overriding them. When hiding occurs, the base method is not replaced. <a data-type="xref" href="#hidden_versus_virtual_method">Example 6-31</a> shows how the hidden <code>Start</code> method remains available. It creates a <code>CustomerDerived</code> object and places a reference to that object in two variables of different types: one of type <code>CustomerDerived</code> and one of type <span class="keep-together"><code>LibraryBase</code></span>. It then calls <code>Start</code> through each of these.</p>
<div data-type="example" id="hidden_versus_virtual_method">
<h5><span class="label">Example 6-31. </span>Hidden versus virtual method</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">d</code> <code class="p">=</code> <code class="k">new</code> <code class="n">CustomerDerived</code><code class="p">();</code>
<code class="n">LibraryBase</code> <code class="n">b</code> <code class="p">=</code> <code class="n">d</code><code class="p">;</code>

<code class="n">d</code><code class="p">.</code><code class="n">Start</code><code class="p">();</code>
<code class="n">b</code><code class="p">.</code><code class="n">Start</code><code class="p">();</code></pre></div>
<p>When we use the <code>d</code> variable, the call to <code>Start</code> ends up calling the derived type’s <code>Start</code> method, the one that has hidden the base member. But the <code>b</code> variable’s type is <code>LibraryBase</code>, so that invokes the base <code>Start</code> method. If <code>CustomerDerived</code> had overridden the base class’s <code>Start</code> method instead of hiding it, both of those method calls would have invoked the override.</p>
<p>When name collisions occur because of a new library version, this hiding behavior <span class="keep-together">is usually</span> the right thing to do. If the customer’s code has a variable of type <span class="keep-together"><code>CustomerDerived</code></span>, then that code will want to invoke the <code>Start</code> method specific to that derived type. However, the compiler produces a warning, because it doesn’t know for certain that this is the reason for the problem. It might be that you <em>did</em> mean to override the method, and you just forgot to write the <code>override</code> keyword.</p>
<p>Like many developers, I don’t like to see compiler warnings, and I try to avoid committing code that produces them. But what should you do if a new library version puts you in this situation? The best long-term solution is probably to change the name of the method in your derived class so that it doesn’t clash with the method in the new version of the library. However, if you’re up against a deadline, you may want a more expedient solution. So C# lets you declare that you know that there’s a name clash and that you definitely want to hide the base member, not override it. <a data-primary="new keyword" data-type="indexterm" id="ix_ch06-asciidoc15"/>As <a data-type="xref" href="#avoiding_warnings_when_hiding_members">Example 6-32</a> shows, you can use the <code>new</code> keyword to state that you’re aware of the issue and definitely want to hide the base class member. The code will still behave in the same way, but you’ll no longer get the warning, because you’ve assured the compiler that you know what’s going on. But this is an issue you should fix at some point, because sooner or later the existence of two methods with the same name on the same type that mean different things is likely to cause confusion.</p>
<div data-type="example" id="avoiding_warnings_when_hiding_members">
<h5><span class="label">Example 6-32. </span>Avoiding warnings when hiding members</h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="k">public</code> <code class="k">class</code> <code class="nc">CustomerDerived</code> <code class="p">:</code> <code class="n">LibraryBase</code>
<code class="p">{</code>
    <strong><code class="k">public</code> <code class="k">new</code> <code class="k">void</code> <code class="nf">Start</code><code class="p">(</code><code class="p">)</code></strong>
    <code class="p">{</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Derived type's Start method"</code><code class="p">)</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>C# does not let you use the <code>new</code> keyword to deal with the equivalent problem that arises with default interface implementations. There is no way to retain the default implementation supplied by an interface and also declare a public method with the same signature. This is slightly frustrating because it’s possible at the binary level: it’s the behavior you get if you do not recompile the code that implements an interface after adding a new member with a default implementation. You can still have separate implementations of, say, <code>ILibrary.Start</code> and <code>CustomerDerived.Start</code>, but you have to use explicit interface implementation.</p>
</div>
<p>Just occasionally, you may see the <code>new</code> keyword used in this way for reasons other than handling library versioning issues. For example, the <code>ISet&lt;T&gt;</code> interface that I showed in <a data-type="xref" href="ch05.xhtml#ch_collections">Chapter 5</a> uses it to introduce a new <code>Add</code> method. <code>ISet&lt;T&gt;</code> derives from <code>ICollection&lt;T&gt;</code>, an interface that already provides an <code>Add</code> method, which takes an instance of <code>T</code> and has a <code>void</code> return type. <code>ISet&lt;T&gt;</code> makes a subtle change to this, shown in <a data-type="xref" href="#hiding_to_change_the_signature">Example 6-33</a>.</p>
<div data-type="example" id="hiding_to_change_the_signature">
<h5><span class="label">Example 6-33. </span>Hiding to change the signature</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">interface</code> <code class="n">ISet</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="p">:</code> <code class="n">ICollection</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code>
<code class="p">{</code>
    <code class="k">new</code> <code class="kt">bool</code> <code class="nf">Add</code><code class="p">(</code><code class="n">T</code> <code class="n">item</code><code class="p">);</code>
    <code class="c1">// ...other members omitted for clarity</code>
<code class="p">}</code></pre></div>
<p>The <code>ISet&lt;T&gt;</code> interface’s <code>Add</code> method tells you whether the item you just added was already in the set, something the base <code>ICollection&lt;T&gt;</code> interface’s <code>Add</code> method doesn’t support. <code>ISet&lt;T&gt;</code> needs its <code>Add</code> to have a different return type—<code>bool</code> instead of <code>void</code>—so it defines <code>Add</code> with the <code>new</code> keyword to indicate that it should hide the <code>ICollection&lt;T&gt;</code> one. Both methods are still available—if you have two variables, one of type <code>ICollection&lt;T&gt;</code> and the other of type <code>ISet&lt;T&gt;</code>, both referring to the same object, you’ll be able to access the <code>void Add</code> through the former and the <code>bool Add</code> through the latter.</p>
<p>Microsoft didn’t have to do this. It could have called the new <code>Add</code> method something else—<code>AddIfNotPresent</code>, for example. But it’s arguably less confusing just to have the one method name for adding things to a collection, particularly since you’re free to ignore the return value, at which point the new <code>Add</code> looks indistinguishable from the old one. And most <code>ISet&lt;T&gt;</code> implementations will implement the <code>ICo⁠lle⁠cti⁠on&lt;⁠T&gt;.​Add</code> method by calling straight through to the <code>ISet&lt;T&gt;.Add</code> method, so it makes sense that they have the same name.</p>
<p>Aside from the preceding example, so far I’ve discussed method hiding only in the context of compiling old code against a new version of a library. What happens if you have old code <em>already compiled</em> against an old library but that ends up <em>running</em> against a new version? That’s a scenario you are highly likely to run into when the library in question is the .NET runtime libraries. Suppose you are using third-party components that you have only in binary form (e.g., ones you’ve licensed from a company that does not supply source code). The supplier will have built these to use some particular version of .NET. If you upgrade your application to run with a new version of .NET, you might not be able to get hold of newer versions of the third-party components—maybe the vendor hasn’t released them yet, or perhaps it has gone out of business.</p>
<p>If the components you’re using were compiled for, say, .NET Standard 1.2, and you use them in a project built for .NET 6.0, all of those older components will end up using the .NET 6.0 versions of the runtime libraries. .NET has a versioning policy that arranges for all the components that a particular program uses to get the same version of the runtime libraries, regardless of which version any individual component may have been built for. So it’s entirely possible that some component, <em>OldControls.dll</em>, contains classes that derive from classes in .NET Standard 1.2, and that define members that collide with the names of members newly added in 
<span class="keep-together">.NET 6.0.</span></p>
<p>This is more or less the same scenario as I described earlier, except that the code that was written for an older version of a library is not going to be recompiled. We’re not going to get a compiler warning about hiding a method, because that would involve running the compiler, and we have only the binary for the relevant component. What happens now?</p>
<p>Fortunately, we don’t need the old component to be recompiled. The C# compiler sets various flags in the compiled output for each method it compiles, indicating things like whether the method is virtual or not and whether the method was intended to override some method in the base class. When you put the <code>new</code> keyword on a method, the compiler sets a flag indicating that the method is not meant to override anything. The CLR calls this the <em>newslot</em> flag. When C# compiles a method such as the one in <a data-type="xref" href="#class_derived_from_version_1.0_base">Example 6-29</a>, which does not specify either <code>override</code> or <code>new</code>, it also sets this same newslot flag for that method, because at the time the method was compiled, there was no method of the same name on the base class. As far as both the developer and the compiler were concerned, the <code>CustomerDerived</code> class’s <code>Start</code> was written as a brand-new method that was not connected to anything on the base class.<a data-startref="ix_ch06-asciidoc15" data-type="indexterm" id="idm45884817541696"/></p>
<p>So when this old component gets loaded in conjunction with a new version of the library defining the base class, the CLR can see what was intended—it can see that, as far as the author of the <code>CustomerDerived</code> class was concerned, <code>Start</code> is not meant to override anything. It therefore treats <code>CustomerDerived.Start</code> as a distinct method from <code>LibraryBase.Start</code>—it hides the base method just like it did when we were able to recompile.</p>
<p>By the way, everything I’ve said about virtual methods can also apply to properties, because a property’s accessors are just methods. So you can define virtual properties, and derived classes can override or hide these in exactly the same way as with methods. I won’t be getting to events until <a data-type="xref" href="ch09.xhtml#ch_delegates_lambdas_events">Chapter 9</a>, but those are also methods in disguise, so they can also be virtual.</p>
<p>Just occasionally, you may want to write a class that overrides a virtual method and then prevents derived classes from overriding it again. For this, C# defines the <code>sealed</code> keyword, and in fact, it’s not just methods that can be sealed<a data-startref="ix_ch06-asciidoc14" data-type="indexterm" id="idm45884817503600"/><a data-startref="ix_ch06-asciidoc13" data-type="indexterm" id="idm45884817502992"/><a data-startref="ix_ch06-asciidoc12" data-type="indexterm" id="idm45884817502384"/><a data-startref="ix_ch06-asciidoc11" data-type="indexterm" id="idm45884817501776"/>.<a data-startref="ix_ch06-asciidoc10" data-type="indexterm" id="idm45884817501040"/><a data-startref="ix_ch06-asciidoc9" data-type="indexterm" id="idm45884817500432"/><a data-startref="ix_ch06-asciidoc8" data-type="indexterm" id="idm45884817499760"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Sealed Methods and Classes" data-type="sect1"><div class="sect1" id="sealed_methods_and_classes">
<h1>Sealed Methods and Classes</h1>
<p><a data-primary="classes" data-secondary="sealed" data-type="indexterm" id="ix_ch06-asciidoc16"/><a data-primary="inheritance" data-secondary="sealed methods and classes" data-type="indexterm" id="ix_ch06-asciidoc17"/><a data-primary="methods" data-secondary="sealed" data-type="indexterm" id="ix_ch06-asciidoc18"/><a data-primary="sealed classes" data-type="indexterm" id="ix_ch06-asciidoc19"/><a data-primary="sealed methods" data-type="indexterm" id="ix_ch06-asciidoc20"/>Virtual methods are deliberately open to modification through inheritance. A sealed method is the opposite—it is one that cannot be overridden. Methods are sealed by default in C#: methods cannot be overridden unless declared virtual. But when you override a virtual method, you can seal it, closing it off for further modification. <a data-type="xref" href="#a_sealed_method">Example 6-34</a> uses this technique to provide a custom <code>ToString</code> implementation that cannot be further overridden by derived classes.</p>
<div data-type="example" id="a_sealed_method">
<h5><span class="label">Example 6-34. </span>A sealed method</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">FixedToString</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">sealed</code> <code class="k">override</code> <code class="kt">string</code> <code class="nf">ToString</code><code class="p">()</code> <code class="p">=&gt;</code> <code class="s">"Arf arf!"</code><code class="p">;</code>
<code class="p">}</code></pre></div>
<p>You can also seal an entire class, preventing anyone from deriving from it. <a data-type="xref" href="#a_sealed_class">Example 6-35</a> shows a class that not only does nothing but also prevents anyone from extending it to do something useful. (You’d normally seal only a class that does something. This example is just to illustrate where the keyword goes.)</p>
<div data-type="example" id="a_sealed_class">
<h5><span class="label">Example 6-35. </span>A sealed class</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">sealed</code> <code class="k">class</code> <code class="nc">EndOfTheLine</code>
<code class="p">{</code>
<code class="p">}</code></pre></div>
<p>Some types are inherently sealed. Value types, for example, do not support inheritance, so structs, record structs, and enums are effectively sealed. The built-in <code>string</code> class is also sealed.</p>
<p>There are two normal reasons for sealing either classes or methods. One is that you want to guarantee some particular invariant, and if you leave your type open to modification, you will not be able to guarantee that invariant. For example, instances of the <code>string</code> type are immutable. The <code>string</code> type itself does not provide a way to modify an instance’s value, and because nobody can derive from <code>string</code>, you can guarantee that if you have a reference of type <code>string</code>, you have a reference to an immutable object. This makes it safe for you to use in scenarios where you do not want the value to change—for example, when you use an object as a key to a dictionary (or anything else that relies on a hash code), you need the value not to change, because if the hash code changes while the item is in use as a key, the container will malfunction.</p>
<p>The other usual reason for leaving things sealed is that designing types that can successfully be modified through inheritance is hard, particularly if your type will be used outside of your own organization. Simply opening things up for modification is not sufficient—if you decide to make all your methods virtual, it might make it easy for people using your type to modify its behavior, but you will have made a rod for your back when it comes to maintaining the base class. Unless you control all of the code that derives from your class, it will be almost impossible to change anything in the base, because you will never know which methods may have been overridden in derived classes, making it hard to ensure that your class’s internal state is consistent at all times. Developers writing derived types will doubtless do their best not to break things, but they will inevitably rely on aspects of your class’s behavior that are undocumented. So in opening up every aspect of your class for modification through inheritance, you rob yourself of the freedom to change your class.</p>
<p>You should be very selective about which methods, if any, you make virtual. And you should also document whether callers are allowed to replace the method completely or whether they are required to call the base implementation as part of their override. Speaking of which, how do you do that?<a data-startref="ix_ch06-asciidoc20" data-type="indexterm" id="idm45884817433248"/><a data-startref="ix_ch06-asciidoc19" data-type="indexterm" id="idm45884817432656"/><a data-startref="ix_ch06-asciidoc18" data-type="indexterm" id="idm45884817431984"/><a data-startref="ix_ch06-asciidoc17" data-type="indexterm" id="idm45884817431312"/><a data-startref="ix_ch06-asciidoc16" data-type="indexterm" id="idm45884817430640"/></p>
</div></section>
<section data-pdf-bookmark="Accessing Base Members" data-type="sect1"><div class="sect1" id="accessing_base_members">
<h1>Accessing Base Members</h1>
<p><a data-primary="base class members, accessing base" data-type="indexterm" id="idm45884817428176"/><a data-primary="inheritance" data-secondary="accessing base members" data-type="indexterm" id="idm45884817423392"/>Everything that is in scope in a base class and is not private will also be in scope and accessible in a derived type. If you want to access some member of the base class, you typically just access it as if it were a normal member of your class. <a data-primary="this reference" data-type="indexterm" id="idm45884817422064"/>You can either access members through the <code>this</code> reference or just refer to them by name without qualification.</p>
<p>However, there are some situations in which you need to state explicitly that you mean to refer to a base class member. In particular, if you have overridden a method, calling that method by name will invoke your override recursively. If you want to call back to the original method that you overrode, there’s a special keyword for that, shown in <a data-type="xref" href="#calling_the_base_method_after_overriding">Example 6-36</a>.</p>
<div data-type="example" id="calling_the_base_method_after_overriding">
<h5><span class="label">Example 6-36. </span>Calling the base method after overriding</h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="k">public</code> <code class="k">class</code> <code class="nc">CustomerDerived</code> <code class="p">:</code> <code class="n">LibraryBase</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">override</code> <code class="k">void</code> <code class="nf">Start</code><code class="p">(</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Derived type's Start method"</code><code class="p">)</code><code class="p">;</code>
        <strong><code class="k">base</code><code class="p">.</code><code class="n">Start</code><code class="p">(</code><code class="p">)</code><code class="p">;</code></strong>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>By using the <code>base</code> keyword, we are opting out of the normal virtual method dispatch mechanism. If we had written just <code>Start()</code>, that would have been a recursive call, which would be undesirable here. By writing <code>base.Start()</code>, we get the method that would have been available on an instance of the base class, the method we overrode.</p>
<p>What if the inheritance chain is deeper? Suppose <code>CustomerDerived</code> derives from <code>IntermediateBase</code> and that <code>IntermediateBase</code> derives from <code>LibraryBase</code> and also overrides the <code>Start</code> method. In that case, writing <code>base.Start()</code> in our <code>Cus⁠tom⁠er​Der⁠iv⁠ed</code> type will call the override defined by <code>IntermediateBase</code>. There’s no way to bypass that and call the original <code>LibraryBase.Start</code> directly.</p>
<p>In this example, I have called the base class’s implementation after completing my work. C# does not care when you call the base—you could call it as the first thing the method does, as the last, or halfway through the method. You could even call it several times, or not at all. It is up to the author of the base class to document whether and when the base class implementation of the method should be called by an override.</p>
<p>You can use the <code>base</code> keyword for other members too, such as properties and events. However, access to base constructors works a bit differently.</p>
</div></section>
<section data-pdf-bookmark="Inheritance and Construction" data-type="sect1"><div class="sect1" id="inheritance_and_construction">
<h1>Inheritance and Construction</h1>
<p><a data-primary="construction, inheritance and" data-type="indexterm" id="ix_ch06-asciidoc21"/><a data-primary="inheritance" data-secondary="construction and" data-type="indexterm" id="ix_ch06-asciidoc22"/><a data-primary="public members" data-type="indexterm" id="idm45884817331408"/>Although a derived class inherits all the members of its base class, this does not mean the same thing for constructors as it does for everything else. With other members, if they are public in the base class, they will be public members of the derived class too, accessible to anyone who uses your derived class. But constructors are special, because someone using your class cannot construct it by using one of the constructors defined by the base class.</p>
<p>There is a straightforward reason for this: if you want an instance of some type <code>D</code>, then you’ll want it to be a full-fledged <code>D</code> with everything in it properly initialized. Suppose that <code>D</code> derives from <code>B</code>. If you were able to use one of <code>B</code>’s constructors directly, it wouldn’t do anything to the parts specific to <code>D</code>. A base class’s constructor won’t know about any of the fields defined by a derived class, so it cannot initialize them. If you want a <code>D</code>, you’ll need a constructor that knows how to initialize a <code>D</code>. So with a derived class, you can use only the constructors offered by that derived class, regardless of what constructors the base class might provide.</p>
<p>In the examples I’ve shown so far in this chapter, I’ve been able to ignore this because of the default constructor that C# provides. As you saw in <a data-type="xref" href="ch03.xhtml#ch_types">Chapter 3</a>, if you don’t write a constructor, C# writes one for you that takes no arguments. It does this for derived classes too, and the generated constructor will invoke the no-arguments constructor of the base class. But this changes if I start writing my own constructors. <a data-type="xref" href="#no_default_constructor_in_derived_class">Example 6-37</a> defines a pair of classes, where the base defines an explicit no-arguments constructor, and the derived class defines one that requires an argument.</p>
<div data-type="example" id="no_default_constructor_in_derived_class">
<h5><span class="label">Example 6-37. </span>No default constructor in derived class</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">BaseWithZeroArgCtor</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="nf">BaseWithZeroArgCtor</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Base constructor"</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">DerivedNoDefaultCtor</code> <code class="p">:</code> <code class="n">BaseWithZeroArgCtor</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="nf">DerivedNoDefaultCtor</code><code class="p">(</code><code class="kt">int</code> <code class="n">i</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Derived constructor"</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>Because the base class has a zero-argument constructor, I can construct it with <code>new BaseWithZeroArgCtor()</code>. But I cannot do this with the derived type: I can construct that only by passing an argument—for example, <code>new DerivedNoDefaultCtor(123)</code>. So as far as the publicly visible API of <code>DerivedNoDefaultCtor</code> is concerned, the derived class appears not to have inherited its base class’s constructor.</p>
<p>However, it has in fact inherited it, as you can see by looking at the output you get if you construct an instance of the derived type:</p>
<pre data-type="programlisting">Base constructor
Derived constructor</pre>
<p>When constructing an instance of <code>DerivedNoDefaultCtor</code>, the base class’s constructor runs immediately before the derived class’s constructor. Since the base constructor ran, clearly it was present. All of the base class’s constructors are available to a derived type, but they can be invoked only by constructors in the derived class. <a data-type="xref" href="#no_default_constructor_in_derived_class">Example 6-37</a> invoked the base constructor implicitly: all constructors are required to invoke a constructor on their base class, and if you don’t specify which to invoke, the compiler invokes the base’s zero-argument constructor for you.</p>
<p>What if the base doesn’t define a parameterless constructor? In that case, you’ll get a compiler error if you derive a class that does not specify which constructor to call. <a data-type="xref" href="#invoking_a_base_constructor_explicitly">Example 6-38</a> shows a base class without a zero-argument constructor. (The presence of explicit constructors disables the compiler’s normal generation of a default constructor, and since this base class supplies only a constructor that takes arguments, this means there is no zero-argument constructor.) It also shows a derived class with two constructors, both of which call into the base constructor explicitly, using the <code>base</code> keyword.</p>
<div data-type="example" id="invoking_a_base_constructor_explicitly">
<h5><span class="label">Example 6-38. </span>Invoking a base constructor explicitly</h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="k">public</code> <code class="k">class</code> <code class="nc">BaseNoDefaultCtor</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="nf">BaseNoDefaultCtor</code><code class="p">(</code><code class="kt">int</code> <code class="n">i</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Base constructor: "</code> <code class="p">+</code> <code class="n">i</code><code class="p">)</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">DerivedCallingBaseCtor</code> <code class="p">:</code> <code class="n">BaseNoDefaultCtor</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="nf">DerivedCallingBaseCtor</code><code class="p">(</code><code class="p">)</code>
        <strong><code class="p">:</code> <code class="k">base</code><code class="p">(</code><code class="m">123</code><code class="p">)</code></strong>
    <code class="p">{</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Derived constructor (default)"</code><code class="p">)</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">public</code> <code class="nf">DerivedCallingBaseCtor</code><code class="p">(</code><code class="kt">int</code> <code class="n">i</code><code class="p">)</code>
        <strong><code class="p">:</code> <code class="k">base</code><code class="p">(</code><code class="n">i</code><code class="p">)</code></strong>
    <code class="p">{</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Derived constructor: "</code> <code class="p">+</code> <code class="n">i</code><code class="p">)</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>The derived class here decides to supply a parameterless constructor even though the base class doesn’t have one—it supplies a constant value for the argument the base requires. The second just passes its argument through to the base.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Here’s a frequently asked question: <em>How do I provide all the same constructors as my base class, just passing the arguments straight through?</em> The answer is: <em>write all the constructors by hand</em>. There is no way to get the C# compiler to generate a set of constructors in a derived class that look identical to the ones that the base class offers. You need to do it the long-winded way.</p>
<p><a data-primary="Visual Studio" data-secondary="constructor generation" data-type="indexterm" id="idm45884817140096"/><a data-primary="Visual Studio Code" data-secondary="constructor generation" data-type="indexterm" id="idm45884817157648"/><a data-primary="JetBrains Rider" data-type="indexterm" id="idm45884817156704"/>At least Visual Studio, VS Code, or JetBrains Rider can generate the code for you—if you click on a class declaration, and then click the Quick Actions icon that appears, it will offer to generate constructors with the same arguments as any nonprivate constructor in the base class, automatically passing all the arguments through for you.</p>
</div>
<p><a data-primary="initializers" data-secondary="field" data-type="indexterm" id="idm45884817155168"/>As <a data-type="xref" href="ch03.xhtml#ch_types">Chapter 3</a> showed, a class’s field initializers run before its constructor. The picture is more complicated once inheritance is involved, because there are multiple classes and multiple constructors. The easiest way to predict what will happen is to understand that although instance field initializers and constructors have separate syntax, C# ends up compiling all the initialization code for a particular class into the constructor. This code performs the following steps: first, it runs field initializers specific to this class (so this step does not include base field initializers—the base class will take care of itself); next, it calls the base class constructor; and finally, it runs the body of the constructor. The upshot of this is that in a derived class, your instance field initializers will run before base class construction has occurred—not just before the base constructor body but even before the base’s instance fields have been initialized. <a data-type="xref" href="#exploring_construction_order">Example 6-39</a> illustrates this.</p>
<div data-type="example" id="exploring_construction_order">
<h5><span class="label">Example 6-39. </span>Exploring construction order</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">BaseInit</code>
<code class="p">{</code>
    <code class="k">protected</code> <code class="k">static</code> <code class="kt">int</code> <code class="nf">Init</code><code class="p">(</code><code class="kt">string</code> <code class="n">message</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">message</code><code class="p">);</code>
        <code class="k">return</code> <code class="m">1</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">private</code> <code class="kt">int</code> <code class="n">b1</code> <code class="p">=</code> <code class="n">Init</code><code class="p">(</code><code class="s">"Base field b1"</code><code class="p">);</code>

    <code class="k">public</code> <code class="nf">BaseInit</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="n">Init</code><code class="p">(</code><code class="s">"Base constructor"</code><code class="p">);</code>
    <code class="p">}</code>

    <code class="k">private</code> <code class="kt">int</code> <code class="n">b2</code> <code class="p">=</code> <code class="n">Init</code><code class="p">(</code><code class="s">"Base field b2"</code><code class="p">);</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">DerivedInit</code> <code class="p">:</code> <code class="n">BaseInit</code>
<code class="p">{</code>
    <code class="k">private</code> <code class="kt">int</code> <code class="n">d1</code> <code class="p">=</code> <code class="n">Init</code><code class="p">(</code><code class="s">"Derived field d1"</code><code class="p">);</code>

    <code class="k">public</code> <code class="nf">DerivedInit</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="n">Init</code><code class="p">(</code><code class="s">"Derived constructor"</code><code class="p">);</code>
    <code class="p">}</code>

    <code class="k">private</code> <code class="kt">int</code> <code class="n">d2</code> <code class="p">=</code> <code class="n">Init</code><code class="p">(</code><code class="s">"Derived field d2"</code><code class="p">);</code>
<code class="p">}</code></pre></div>
<p>I’ve put the field initializers on either side of the constructor just to show that their position relative to nonfield members is irrelevant. The order of the fields matters, but only with respect to one another. Constructing an instance of the <code>DerivedInit</code> class produces this output:</p>
<pre data-type="programlisting">Derived field d1
Derived field d2
Base field b1
Base field b2
Base constructor
Derived constructor</pre>
<p>This verifies that the derived type’s field initializers run first, and then the base field initializers, followed by the base constructor, and then finally the derived constructor. In other words, although constructor bodies start with the base class, instance field initialization happens in reverse.</p>
<p>That’s why you don’t get to invoke instance methods in field initializers. Static methods are available, but instance methods are not, because the class is a long way from being ready. It could be problematic if one of the derived type’s field initializers were able to invoke a method on the base class, because the base class has performed no initialization at all at that point—not only has its constructor body not run, but its field initializers haven’t run either. If instance methods were available during this phase, we’d have to write all of our code to be very defensive, because we could not assume that our fields contain anything useful.</p>
<p>As you can see, the constructor bodies run relatively late in the process, which is why we are allowed to invoke methods from them. But there’s still potential danger here. What if the base class defines a virtual method and invokes that method on itself in its constructor? If the derived type overrides that, we’ll be invoking the method before the derived type’s constructor body has run. (Its field initializers will have run at that point, though. In fact, this is the main reason field initializers run in what seems to be reverse order—it means that derived classes have a way of performing some initialization before the base class’s constructor has a chance to invoke a virtual method.) If you’re familiar with C++, you might hazard a guess that when the base constructor invokes a virtual method, it’ll run the base implementation. But C# does it differently: a base class’s constructor will invoke the derived class’s override in that case. This is not necessarily a problem, and it can occasionally be useful, but it means you need to think carefully and document your assumptions clearly if you want your object to invoke virtual methods on itself during construction.<a data-startref="ix_ch06-asciidoc22" data-type="indexterm" id="idm45884816976992"/><a data-startref="ix_ch06-asciidoc21" data-type="indexterm" id="idm45884816976384"/></p>
</div></section>
<section data-pdf-bookmark="Record Types" data-type="sect1"><div class="sect1" id="idm45884817334128">
<h1>Record Types</h1>
<p><a data-primary="record types" data-secondary="inheritance and" data-type="indexterm" id="ix_ch06-asciidoc23"/>When you define a <code>record</code> type (or you use the more explicit but functionally identical <code>record class</code> syntax), the resulting record type is, from the runtime’s perspective, still a class. Record types can do most of the things that normal classes can—although they’re typically all about the properties, you can add other members such as methods and constructors. And it turns out that class-based records also support inheritance. (Naturally, since <code>record struct</code> types are value types, those do not support inheritance.)</p>
<p>There are some constraints on inheritance with record types. An ordinary class is not allowed to inherit from a record type—only record types can derive from record types. Similarly, a record type can inherit only from either another record type or the usual <code>object</code> base type. But within these constraints, inheritance with records works much as it does for classes. <a data-type="xref" href="#record_inheritance">Example 6-40</a> shows a base record and a couple of derived types.</p>
<div data-type="example" id="record_inheritance">
<h5><span class="label">Example 6-40. </span>Record inheritance</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">abstract</code> <code class="n">record</code> <code class="n">OptionallyLabeled</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="kt">string?</code> <code class="n">Label</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="n">init</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code>

<code class="k">public</code> <code class="n">record</code> <code class="n">OptionallyLabeledItem</code> <code class="p">:</code> <code class="n">OptionallyLabeled</code><code class="p">;</code>

<code class="k">public</code> <code class="n">record</code> <code class="nf">Product</code><code class="p">(</code><code class="kt">string</code> <code class="n">Name</code><code class="p">)</code> <code class="p">:</code> <code class="n">OptionallyLabeled</code><code class="p">;</code></pre></div>
<p>As this shows, we can define a record type as <code>abstract</code>. When a record is not using the positional syntax, the way we inherit from a base type (abstract or not) looks the same as for a class: as <code>OptionallyLabeledItem</code> shows, we put a colon after the type name, followed by the base type name. If our derived type wants to use the positional syntax, the colon and base type come after the parameter list, as the <code>Product</code> type shows. <a data-type="xref" href="#initializing_derived_records">Example 6-41</a> shows how to instantiate the two derived types defined in <a data-type="xref" href="#record_inheritance">Example 6-40</a>.</p>
<div data-type="example" id="initializing_derived_records">
<h5><span class="label">Example 6-41. </span>Instantiating derived record types</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">unlabeled</code> <code class="p">=</code> <code class="k">new</code> <code class="n">OptionallyLabeledItem</code><code class="p">();</code>
<code class="kt">var</code> <code class="n">labeled</code> <code class="p">=</code> <code class="k">new</code> <code class="n">OptionallyLabeledItem</code>
<code class="p">{</code>
    <code class="n">Label</code> <code class="p">=</code> <code class="s">"New, improved!"</code>
<code class="p">};</code>

<code class="kt">var</code> <code class="n">unlabeledProduct</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Product</code><code class="p">(</code><code class="s">"Book"</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">labeledProduct</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Product</code><code class="p">(</code><code class="s">"Shirt"</code><code class="p">)</code>
<code class="p">{</code>
    <code class="n">Label</code> <code class="p">=</code> <code class="s">"Half price"</code>
<code class="p">};</code></pre></div>
<p>Since the base class’s <code>Label</code> property does not need to be set, we’re free to construct either of the derived types without setting it. But if we do want to set it, we use exactly the same object initializer syntax as we would have done if that <code>Label</code> property were defined directly by <code>OptionallyLabeledItem</code> or <code>Product</code>. But what if the base type uses the positional syntax to define properties that are not optional? As <a data-type="xref" href="#record_inheritance_positional">Example 6-42</a> shows, the record inheritance syntax allows us to supply an argument list to the 
<span class="keep-together">base class.</span></p>
<div data-type="example" id="record_inheritance_positional">
<h5><span class="label">Example 6-42. </span>Deriving from a positional record</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">abstract</code> <code class="n">record</code> <code class="nf">Colorful</code><code class="p">(</code><code class="kt">string</code> <code class="n">Color</code><code class="p">);</code>

<code class="k">public</code> <code class="n">record</code> <code class="nf">LightBulb</code><code class="p">(</code><code class="kt">string</code> <code class="n">Color</code><code class="p">,</code> <code class="kt">int</code> <code class="n">Lumens</code><code class="p">)</code> <code class="p">:</code> <code class="n">Colorful</code><code class="p">(</code><code class="n">Color</code><code class="p">);</code></pre></div>
<p><code>LightBulb</code> uses the positional syntax itself and uses one of its two constructor arguments as the value for the <code>Color</code> property that the base class requires. But in some cases, you might not want to pass a value through like this: sometimes a derived type will know what value to pass to the base record type, as <a data-type="xref" href="#record_inheritance_base_ctor_constant">Example 6-43</a> shows.</p>
<div data-type="example" id="record_inheritance_base_ctor_constant">
<h5><span class="label">Example 6-43. </span>Passing a constant to a positional base record</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="n">record</code> <code class="nf">FordModelT</code><code class="p">()</code> <code class="p">:</code> <code class="n">Colorful</code><code class="p">(</code><code class="s">"Black"</code><code class="p">);</code></pre></div>
<p>So in this case, although the base <code>Colorful</code> record uses the positional syntax, requiring the <code>Color</code> property to be supplied, this derived type does not pass that requirement on. The popular story is that Ford’s early car, the Model T, was only available in one color, so this particular derived type can just set the <code>Color</code> itself. Users of the <code>FordModelT</code> record do not need to supply the <code>Color</code>, even though it’s a mandatory argument for the base <code>Colorful</code> type. Pedants will by now be itching to point out that this paint constraint applied only for 12 of the 19 years for which the Model T was produced. I would draw their attention to <a data-type="xref" href="#record_constructing_modelt">Example 6-44</a>, which shows that although the <code>FordModelT</code> type does not require the <code>Color</code> property to be passed during construction, it can still be set with an object initializer. So this record type enables the color to be specified just as it could with early and late Model Ts, but the default is aligned with the fact that the overwhelming majority of these cars were indeed black.</p>
<div data-type="example" id="record_constructing_modelt">
<h5><span class="label">Example 6-44. </span>Using a derived record that has made a mandatory base property optional</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">commonModelT</code> <code class="p">=</code> <code class="k">new</code> <code class="n">FordModelT</code><code class="p">();</code>
<code class="kt">var</code> <code class="n">lateModelT</code> <code class="p">=</code> <code class="k">new</code> <code class="n">FordModelT</code> <code class="p">{</code> <code class="n">Color</code> <code class="p">=</code> <code class="s">"Green"</code> <code class="p">};</code></pre></div>
<p>To be able to use the syntax shown in Examples <a data-type="xref" data-xrefstyle="select:labelnumber" href="#record_inheritance_positional">6-42</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#record_inheritance_base_ctor_constant">6-43</a>, where we put a positional argument list directly after the base class’s name, a record must itself use the positional syntax. If you look closely at <a data-type="xref" href="#record_inheritance_base_ctor_constant">Example 6-43</a>, you’ll see that after the <code>FordModelT</code> type name, there’s an empty argument list. Although this may seem redundant, in this case it needs to be here, because without it, we wouldn’t be allowed to write <code>Colorful("Black")</code> after the colon.</p>
<p>There are other ways to pass arguments to a positional base record. As <a data-type="xref" href="ch03.xhtml#ch_types">Chapter 3</a> described, when we use the positional syntax, we are just defining a constructor, so an alternative would be to use the normal syntax for invoking the base constructor, as <a data-type="xref" href="#invoke_base_record_ctor">Example 6-45</a> shows.</p>
<div data-type="example" id="invoke_base_record_ctor">
<h5><span class="label">Example 6-45. </span>Passing positional base record arguments with an ordinary constructor</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="n">record</code> <code class="n">RedDelicious</code> <code class="p">:</code> <code class="n">Colorful</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="nf">RedDelicious</code><code class="p">()</code> <code class="p">:</code> <code class="k">base</code><code class="p">(</code><code class="s">"Red"</code><code class="p">)</code>
    <code class="p">{</code> <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>The last few examples have dealt with cases where a base class uses the positional syntax but where its derived type does not. But what about the converse, where the base type is not positional but a derived type wants to be? If the derived type just wants to add one or more of its own properties, this is straightforward. In fact, we’ve already seen it—the product type in <a data-type="xref" href="#record_inheritance">Example 6-40</a> does exactly this. However, what if the base type defines an optional property (such as <code>OptionallyLabeled.Label</code>) but the derived type wants to make that mandatory? You can do it, but you can’t use the positional syntax. You have to write the constructor in full, as <a data-type="xref" href="#making_optional_base_prop_positional">Example 6-46</a> shows.</p>
<div data-type="example" id="making_optional_base_prop_positional">
<h5><span class="label">Example 6-46. </span>Making an optional base property class positional</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="n">record</code> <code class="n">LabeledDemographic</code> <code class="p">:</code> <code class="n">OptionallyLabeled</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="nf">LabeledDemographic</code><code class="p">(</code><code class="kt">string</code> <code class="n">label</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">Label</code> <code class="p">=</code> <code class="n">label</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">public</code> <code class="k">void</code> <code class="nf">Deconstruct</code><code class="p">(</code><code class="k">out</code> <code class="kt">string?</code> <code class="n">label</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">label</code> <code class="p">=</code> <code class="n">Label</code><code class="p">;</code>
<code class="p">}</code></pre></div>
<p>Although this doesn’t use the positional syntax, it has a similar effect, because the positional syntax works by defining a constructor. The presence of the constructor in <a data-type="xref" href="#making_optional_base_prop_positional">Example 6-46</a> will prevent the compiler from generating a default zero-argument constructor, meaning that code using <code>LabeledDemographic</code> will be obliged to provide the <code>Label</code> property during construction, just as if the positional syntax were in use. You automatically get a deconstructor when using the positional syntax, but I’ve had to write my own here. The compiler doesn’t generate one because deconstruction ends up being a little odd when attempting to impose positional behavior in a type deriving from a nonpositional record. The base class defines <code>Label</code> as optional, and even though we’ve defined a constructor that requires a non-null argument, it would be possible to follow the constructor with an object initializer that sets it back to <code>null</code>. (That would be weird but not illegal.) So our deconstructor ends up not quite matching our constructor.</p>
<section data-pdf-bookmark="Records, Inheritance, and the with Keyword" data-type="sect2"><div class="sect2" id="idm45884816573536">
<h2>Records, Inheritance, and the with Keyword</h2>
<p><a data-primary="record types" data-secondary="with keyword" data-type="indexterm" id="idm45884816572288"/><a data-primary="with keyword" data-type="indexterm" id="idm45884816571184"/><a data-type="xref" href="ch03.xhtml#ch_types">Chapter 3</a> showed how you can create modified copies of record types using a <code>with</code> expression. This builds a new instance that has all the same properties as the original except for any new property values you specify in the braces following the <code>with</code> keyword. This mechanism has been designed with inheritance in mind: the instance produced by the <code>with</code> keyword will always have the same type as its input, even in cases where the code is written in terms of the base type, like <a data-type="xref" href="#base_record_with_expression">Example 6-47</a>.</p>
<div data-type="example" id="base_record_with_expression">
<h5><span class="label">Example 6-47. </span>Using <code>with</code> on a base record type</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">OptionallyLabeled</code> <code class="nf">Discount</code><code class="p">(</code><code class="n">OptionallyLabeled</code> <code class="n">item</code><code class="p">)</code>
<code class="p">{</code>
    <code class="k">return</code> <code class="n">item</code> <code class="n">with</code>
    <code class="p">{</code>
        <code class="n">Label</code> <code class="p">=</code> <code class="s">"60% off!"</code>
    <code class="p">};</code>
<code class="p">}</code></pre></div>
<p>This uses the abstract <code>OptionallyLabeled</code> record type from <a data-type="xref" href="#record_inheritance">Example 6-40</a>. We can call this passing in any concrete type derived from that abstract base. <a data-type="xref" href="#with_inheritance_test">Example 6-48</a> calls it twice with two different types.</p>
<div data-type="example" id="with_inheritance_test">
<h5><span class="label">Example 6-48. </span>Testing how <code>with</code> interacts with inheritance</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">Discount</code><code class="p">(</code><code class="k">new</code> <code class="n">OptionallyLabeledItem</code><code class="p">()));</code>
<code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">Discount</code><code class="p">(</code><code class="k">new</code> <code class="n">Product</code><code class="p">(</code><code class="s">"Sweater"</code><code class="p">)));</code></pre></div>
<p>Running that code produces this output:</p>
<pre data-type="programlisting">OptionallyLabeledItem { Label = 60% off! }
Product { Label = 60% off!, Name = Sweater }</pre>
<p><code>Console.WriteLine</code> calls <code>ToString</code> on its input, and record types implement this by reporting their name and then their property values. So you can see from this that when the <code>Discount</code> method produced modified copies of its inputs, it successfully preserved the type. So even though <code>Discount</code> knows nothing about the <code>Product</code> record type or its <code>Name</code> property, when it created a copy with the new <code>Label</code> value, that <code>Name</code> property was correctly carried over.</p>
<p>This works because of code that the compiler generates for record types. I already described the copy constructor in <a data-type="xref" href="ch03.xhtml#ch_types">Chapter 3</a>, but that alone would not make this possible—the <code>Discount</code> method doesn’t know about the <code>OptionallyLabeledItem</code> or <code>Product</code> types, so it wouldn’t know to invoke their copy constructors. So records also get a hidden <code>virtual</code> method with an unspeakable name, <code>&lt;Clone&gt;$</code>. The <code>with</code> expression in <a data-type="xref" href="#base_record_with_expression">Example 6-47</a> invokes this (before going on to set the <code>Label</code> property). The compiler-generated <code>&lt;Clone&gt;$</code> method invokes its own copy constructor. Since derived record types override <code>&lt;Clone&gt;$</code>, a <code>with</code> expression will always get a full copy of the input record no matter what its type is, even when the code is written in terms of a base type.<a data-startref="ix_ch06-asciidoc23" data-type="indexterm" id="idm45884816479840"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Special Base Types" data-type="sect1"><div class="sect1" id="special_base_types">
<h1>Special Base Types</h1>
<p><a data-primary="base types, inheritance and" data-type="indexterm" id="idm45884816477760"/><a data-primary="inheritance" data-secondary="special base types" data-type="indexterm" id="idm45884816477040"/>The .NET runtime libraries define a few base types that have special significance in C#. The most obvious is <code>System.Object</code>, which I’ve already described in some detail.</p>
<p><a data-primary="System.ValueType" data-type="indexterm" id="idm45884816460128"/><a data-primary="ValueType" data-type="indexterm" id="idm45884816459088"/>There’s also <code>System.ValueType</code>. This is the abstract base type of all value types, so any <code>struct</code> or <code>record struct</code> you define—and also all of the built-in value types, such as <code>int</code> and <code>bool</code>—derive from <code>ValueType</code>. Ironically, <code>ValueType</code> itself is a reference type; only types that derive from <code>ValueType</code> are value types. Like most types, <code>ValueType</code> derives from <code>System.Object</code>. There is an obvious conceptual difficulty here: in general, derived classes are everything their base class is, plus whatever functionality they add. So, given that <code>object</code> and <code>ValueType</code> are both reference types, it may seem odd that types derived from <code>ValueType</code> are not. And for that matter, it’s not obvious how an <code>object</code> variable can hold a reference to an instance of something that’s not a reference type. I will resolve all of these issues in <a data-type="xref" href="ch07.xhtml#ch_object_lifetime">Chapter 7</a>.</p>
<p><a data-primary="public members" data-type="indexterm" id="idm45884816451600"/>C# does not permit you to write a type that derives explicitly from <code>ValueType</code>. If you want to write a type that derives from <code>ValueType</code>, that’s what the <code>struct</code> keyword is for. You can declare a variable of type <code>ValueType</code>, but since the type doesn’t define any public members, a <code>ValueType</code> reference doesn’t enable anything you can’t do with an <code>object</code> reference. The only observable difference is that with a variable of that type, you can assign instances of any value type into it but not instances of a reference type. Aside from that, it’s identical to <code>object</code>. Consequently, it’s fairly rare to see <code>ValueType</code> mentioned explicitly in C# code.</p>
<p>Enumeration types also all derive from a common abstract base type: <code>System.Enum</code>. Since enums are value types, you won’t be surprised to find out that <code>Enum</code> derives from <code>ValueType</code>. As with <code>ValueType</code>, you would never derive from <code>Enum</code> explicitly—you use the <code>enum</code> keyword for that. Unlike <code>ValueType</code>, <code>Enum</code> does add some useful members. For example, its static <code>GetValues</code> method returns an array of all the enumeration’s values, while <code>GetNames</code> returns an array with all those values converted to strings. It also offers <code>Parse</code>, which converts from the string representation back to the enumeration value.</p>
<p>As <a data-type="xref" href="ch05.xhtml#ch_collections">Chapter 5</a> described, arrays all derive from a common base class, <code>System.Array</code>, and you’ve already seen the features that offers.</p>
<p>The <code>System.Exception</code> base class is special: when you throw an exception, C# requires that the object you throw be of this type or a type that derives from it. (Exceptions are the topic of <a data-type="xref" href="ch08.xhtml#ch_exceptions">Chapter 8</a>.)</p>
<p>Delegate types all derive from a common base type, <code>System.MulticastDelegate</code>, which in turn derives from <code>System.Delegate</code>. I’ll discuss these in <a data-type="xref" href="ch09.xhtml#ch_delegates_lambdas_events">Chapter 9</a>.</p>
<p>Those are all the base types that the CTS treats as being special. There’s one more base type to which the C# compiler assigns particular significance, and that’s <code>Sys⁠tem.​Att⁠rib⁠ute</code>. In <a data-type="xref" href="ch01.xhtml#ch_introducing_csharp">Chapter 1</a>, I applied certain annotations to methods and classes to tell the unit test framework to treat them specially. These attributes all correspond to types, so when I applied the <code>[TestClass]</code> attribute to a class, I was using a type called <code>TestClassAttribute</code>. Types designed to be used as attributes are all required to derive from <code>System.Attribute</code>. Some of them are recognized by the compiler—for example, there are some that control the version numbers that the compiler puts into the file headers of the EXE and DLL files it produces. I’ll show all of this in <a data-type="xref" href="ch14.xhtml#ch_attributes">Chapter 14</a>.</p>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="summary-id5">
<h1>Summary</h1>
<p>C# supports single implementation inheritance, and only with classes or reference type records—you cannot derive from a struct at all. However, interfaces can declare multiple bases, and a class can implement multiple interfaces. Implicit reference conversions exist from derived types to base types, and generic interfaces and delegates can choose to offer additional implicit reference conversions using either covariance or contravariance. All types derive from <code>System.Object</code>, guaranteeing that certain standard members are available on all variables. We saw how virtual methods allow derived classes to modify selected members of their bases, and how sealing can disable that. We also looked at the relationship between a derived type and its base when it comes to accessing members, and constructors in particular.<a data-startref="ix_ch06-asciidoc0" data-type="indexterm" id="idm45884816429184"/></p>
<p>Our exploration of inheritance is complete, but it has raised some new issues, such as the relationship between value types and references and the role of finalizers. So, in the next chapter, I’ll talk about the connection between references and an object’s life cycle, along with the way the CLR bridges the gap between references and value types.</p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="CHP-6-FN-1"><sup><a href="ch06.xhtml#CHP-6-FN-1-marker">1</a></sup> More precisely, the same assembly, and also friend assemblies. <a data-type="xref" href="ch12.xhtml#ch_assemblies">Chapter 12</a> describes assemblies.</p></div></div></section></div></body></html>