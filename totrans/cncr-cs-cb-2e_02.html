<html><head></head><body><section data-pdf-bookmark="Chapter 2. Async Basics" data-type="chapter" epub:type="chapter"><div class="chapter" id="async-basics">
<h1><span class="label">Chapter 2. </span>Async Basics</h1>


<p>This <a data-primary="asynchronous programming" data-secondary="overview" data-type="indexterm" id="idm45458706961528"/>chapter introduces you to the basics of using <code>async</code> and <code>await</code> for asynchronous operations. Here, we’ll only deal with naturally asynchronous operations, which are operations such as HTTP requests, database commands, and web service calls.</p>

<p>If you have a CPU-intensive operation that you want to treat as though it were asynchronous (e.g., so that it doesn’t block the UI thread), then see <a data-type="xref" href="ch04.html#parallel-basics">Chapter 4</a> and <a data-type="xref" href="ch08.html#recipe-async-interop-parallel">Recipe 8.4</a>. Also, this chapter only deals with operations that are started once and complete once; if you need to handle streams of events, then see Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch03.html#async-streams">3</a> and
<a data-type="xref" data-xrefstyle="select:labelnumber" href="ch06.html#rx-basics">6</a>.</p>






<section class="recipe" data-pdf-bookmark="2.1 Pausing for a Period of Time" data-type="sect1"><div class="sect1" id="recipe-async-delay">
<h1>2.1 Pausing for a Period of Time</h1>








<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458706952568">
<h2>Problem</h2>

<p>You <a data-primary="asynchronous programming" data-secondary="pausing for specified time" data-type="indexterm" id="ch2r1a"/><a data-primary="tasks" data-secondary="pausing for specified time" data-type="indexterm" id="ch2r1b"/><a data-primary="timeouts" data-type="indexterm" id="ch2r1c"/><a data-primary="retry delays" data-type="indexterm" id="ch2r1d"/><a data-primary="pausing" data-seealso="timeouts" data-type="indexterm" id="ch2r1e"/><a data-primary="timeouts" data-type="indexterm" id="ch2r1f"/>need to (asynchronously) wait for a period of time. This is a common scenario when unit testing or implementing retry delays. It also comes up when coding simple timeouts.</p>
</div></section>













<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458706920712">
<h2>Solution</h2>

<p>The<a data-primary="Task.Delay method" data-type="indexterm" id="idm45458706919080"/> <code>Task</code> type has a static method <code>Delay</code> that returns a task that completes after the specified time.</p>

<p>The following example code defines a task that completes asynchronously. When faking an asynchronous operation, it’s important to test synchronous success and asynchronous success, as well as asynchronous failure. The following example returns a task used for the asynchronous success case:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="n">DelayResult</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;(</code><code class="n">T</code> <code class="n">result</code><code class="p">,</code> <code class="n">TimeSpan</code> <code class="n">delay</code><code class="p">)</code>
<code class="p">{</code>
  <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">delay</code><code class="p">);</code>
  <code class="k">return</code> <code class="n">result</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>Exponential <a data-primary="exponential backoff" data-type="indexterm" id="idm45458706889192"/>backoff is a strategy in which you increase the delays between retries. Use it when working with web services to ensure that the server doesn’t get flooded with retries. The next example is a simple implementation of exponential backoff:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">DownloadStringWithRetries</code><code class="p">(</code><code class="n">HttpClient</code> <code class="n">client</code><code class="p">,</code> <code class="kt">string</code> <code class="n">uri</code><code class="p">)</code>
<code class="p">{</code>
  <code class="c1">// Retry after 1 second, then after 2 seconds, then 4.</code>
  <code class="n">TimeSpan</code> <code class="n">nextDelay</code> <code class="p">=</code> <code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">1</code><code class="p">);</code>
  <code class="k">for</code> <code class="p">(</code><code class="kt">int</code> <code class="n">i</code> <code class="p">=</code> <code class="m">0</code><code class="p">;</code> <code class="n">i</code> <code class="p">!=</code> <code class="m">3</code><code class="p">;</code> <code class="p">++</code><code class="n">i</code><code class="p">)</code>
  <code class="p">{</code>
    <code class="k">try</code>
    <code class="p">{</code>
      <code class="k">return</code> <code class="k">await</code> <code class="n">client</code><code class="p">.</code><code class="n">GetStringAsync</code><code class="p">(</code><code class="n">uri</code><code class="p">);</code>
    <code class="p">}</code>
    <code class="k">catch</code>
    <code class="p">{</code>
    <code class="p">}</code>

    <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">nextDelay</code><code class="p">);</code>
    <code class="n">nextDelay</code> <code class="p">=</code> <code class="n">nextDelay</code> <code class="p">+</code> <code class="n">nextDelay</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="c1">// Try one last time, allowing the error to propagate.</code>
  <code class="k">return</code> <code class="k">await</code> <code class="n">client</code><code class="p">.</code><code class="n">GetStringAsync</code><code class="p">(</code><code class="n">uri</code><code class="p">);</code>
<code class="p">}</code></pre>
<div data-type="tip"><h6>Tip</h6>
<p>For <a data-primary="Polly NuGet library" data-type="indexterm" id="idm45458706886632"/>production code, I’d recommend a more thorough solution, such as the <a href="http://www.thepollyproject.org/"><code>Polly</code></a> NuGet library; this code is just a simple example of <code>Task.Delay</code> usage.</p>
</div>

<p>You <a data-primary="CancellationTokenSource type" data-type="indexterm" id="idm45458706764184"/><a data-primary="Task.WhenAny method" data-type="indexterm" id="idm45458706763480"/>can also use <code>Task.Delay</code> as a simple timeout. <code>CancellationTokenSource</code> is the normal type used to implement a timeout (<a data-type="xref" href="ch10.html#recipe-cancel-timeout">Recipe 10.3</a>). You can wrap a cancellation token in an infinite <code>Task.Delay</code> to provide a task that cancels after a specified time. Finally, use that timer task with <code>Task.WhenAny</code> (<a data-type="xref" href="#recipe-async-whenany">Recipe 2.5</a>) to implement a “soft timeout.” The following example code returns <code>null</code> if the service doesn’t respond within three seconds:</p>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">DownloadStringWithTimeout</code><code class="p">(</code><code class="n">HttpClient</code> <code class="n">client</code><code class="p">,</code> <code class="kt">string</code> <code class="n">uri</code><code class="p">)</code>
<code class="p">{</code>
  <code class="k">using</code> <code class="kt">var</code> <code class="n">cts</code> <code class="p">=</code> <code class="k">new</code> <code class="n">CancellationTokenSource</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">3</code><code class="p">));</code>
  <code class="n">Task</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">downloadTask</code> <code class="p">=</code> <code class="n">client</code><code class="p">.</code><code class="n">GetStringAsync</code><code class="p">(</code><code class="n">uri</code><code class="p">);</code>
  <code class="n">Task</code> <code class="n">timeoutTask</code> <code class="p">=</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">Timeout</code><code class="p">.</code><code class="n">InfiniteTimeSpan</code><code class="p">,</code> <code class="n">cts</code><code class="p">.</code><code class="n">Token</code><code class="p">);</code>

  <code class="n">Task</code> <code class="n">completedTask</code> <code class="p">=</code> <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">WhenAny</code><code class="p">(</code><code class="n">downloadTask</code><code class="p">,</code> <code class="n">timeoutTask</code><code class="p">);</code>
  <code class="k">if</code> <code class="p">(</code><code class="n">completedTask</code> <code class="p">==</code> <code class="n">timeoutTask</code><code class="p">)</code>
    <code class="k">return</code> <code class="k">null</code><code class="p">;</code>
  <code class="k">return</code> <code class="k">await</code> <code class="n">downloadTask</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>While it’s possible to use <code>Task.Delay</code> as a “soft timeout,” this approach has limitations. If the operation times out, it’s not canceled; in the previous example, the download task continues downloading and will download the full response before discarding it. The preferred approach is to use a cancellation token as the timeout and pass it directly to the operation (<code>GetStringAsync</code> in the last example). That said, sometimes the operation is not cancelable, and in that case <code>Task.Delay</code> may be used by other code to <em>act like</em> the operation timed out.</p>
</div></section>













<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458706920120">
<h2>Discussion</h2>

<p><code>Task.Delay</code> is a fine option for unit testing asynchronous code or for implementing retry logic. However, if you need to implement a timeout, a <code>CancellationToken</code> is usually a <a data-startref="ch2r1a" data-type="indexterm" id="idm45458706702264"/><a data-startref="ch2r1b" data-type="indexterm" id="idm45458706701528"/><a data-startref="ch2r1c" data-type="indexterm" id="idm45458706700856"/><a data-startref="ch2r1d" data-type="indexterm" id="idm45458706700184"/><a data-startref="ch2r1e" data-type="indexterm" id="idm45458706699512"/><a data-startref="ch2r1f" data-type="indexterm" id="idm45458706698840"/>better choice.</p>
</div></section>













<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458706697912">
<h2>See Also</h2>

<p><a data-type="xref" href="#recipe-async-whenany">Recipe 2.5</a> covers how <code>Task.WhenAny</code> is used to determine which task completes first.</p>

<p><a data-type="xref" href="ch10.html#recipe-cancel-timeout">Recipe 10.3</a> covers using <code>CancellationToken</code> as a timeout.</p>
</div></section>





</div></section>













<section class="recipe" data-pdf-bookmark="2.2 Returning Completed Tasks" data-type="sect1"><div class="sect1" id="recipe-async-fromresult">
<h1>2.2 Returning Completed Tasks</h1>








<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458706664760">
<h2>Problem</h2>

<p>You <a data-primary="asynchronous programming" data-secondary="completed tasks, returning" data-type="indexterm" id="ch2r2a"/><a data-primary="tasks" data-secondary="completed, returning" data-type="indexterm" id="ch2r2b"/>need to implement a synchronous method with an asynchronous signature. This situation can arise if you’re inheriting from an asynchronous interface or base class but want to implement it synchronously. This technique is particularly useful when unit testing asynchronous code, when you need a simple stub or mock for an asynchronous interface.</p>
</div></section>













<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458706660632">
<h2>Solution</h2>

<p>You <a data-primary="Task.FromResult method" data-type="indexterm" id="ch2r2c"/>can use <code>Task.FromResult</code> to create and return a new <code>Task&lt;T&gt;</code> that is already completed with the specified value:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="k">interface</code> <code class="n">IMyAsyncInterface</code>
<code class="p">{</code>
  <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">GetValueAsync</code><code class="p">();</code>
<code class="p">}</code>

<code class="k">class</code> <code class="nc">MySynchronousImplementation</code> <code class="p">:</code> <code class="n">IMyAsyncInterface</code>
<code class="p">{</code>
  <code class="k">public</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">GetValueAsync</code><code class="p">()</code>
  <code class="p">{</code>
    <code class="k">return</code> <code class="n">Task</code><code class="p">.</code><code class="n">FromResult</code><code class="p">(</code><code class="m">13</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p>For <a data-primary="Task.CompletedTask method" data-type="indexterm" id="idm45458706584664"/>methods that don’t have a return value, you can use <code>Task.CompletedTask</code>, which is a cached <code>Task</code> that is successfully completed:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="k">interface</code> <code class="n">IMyAsyncInterface</code>
<code class="p">{</code>
  <code class="n">Task</code> <code class="nf">DoSomethingAsync</code><code class="p">();</code>
<code class="p">}</code>

<code class="k">class</code> <code class="nc">MySynchronousImplementation</code> <code class="p">:</code> <code class="n">IMyAsyncInterface</code>
<code class="p">{</code>
  <code class="k">public</code> <code class="n">Task</code> <code class="nf">DoSomethingAsync</code><code class="p">()</code>
  <code class="p">{</code>
    <code class="k">return</code> <code class="n">Task</code><code class="p">.</code><code class="n">CompletedTask</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p><code>Task.FromResult</code> provides completed tasks only for successful results. If you need a task with a different kind of result (e.g., a task that is completed with a <code class="keep-together">NotImplementedException</code>), then you can use <code>Task.FromException</code>:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="n">Task</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="n">NotImplementedAsync</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;()</code>
<code class="p">{</code>
  <code class="k">return</code> <code class="n">Task</code><code class="p">.</code><code class="n">FromException</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;(</code><code class="k">new</code> <code class="n">NotImplementedException</code><code class="p">());</code>
<code class="p">}</code></pre>

<p>Similarly, <a data-primary="Task.FromCanceled method" data-type="indexterm" id="idm45458706551640"/>there’s a <code>Task.FromCanceled</code> for creating tasks that have already been canceled from a given <code>CancellationToken</code>:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">GetValueAsync</code><code class="p">(</code><code class="n">CancellationToken</code> <code class="n">cancellationToken</code><code class="p">)</code>
<code class="p">{</code>
  <code class="k">if</code> <code class="p">(</code><code class="n">cancellationToken</code><code class="p">.</code><code class="n">IsCancellationRequested</code><code class="p">)</code>
    <code class="k">return</code> <code class="n">Task</code><code class="p">.</code><code class="n">FromCanceled</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;(</code><code class="n">cancellationToken</code><code class="p">);</code>
  <code class="k">return</code> <code class="n">Task</code><code class="p">.</code><code class="n">FromResult</code><code class="p">(</code><code class="m">13</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>If <a data-primary="Task.FromException method" data-type="indexterm" id="idm45458706417656"/>it is possible for your synchronous implementation to fail, then you should capture exceptions and use <code>Task.FromException</code> to return them, as such:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="k">interface</code> <code class="n">IMyAsyncInterface</code>
<code class="p">{</code>
  <code class="n">Task</code> <code class="nf">DoSomethingAsync</code><code class="p">();</code>
<code class="p">}</code>

<code class="k">class</code> <code class="nc">MySynchronousImplementation</code> <code class="p">:</code> <code class="n">IMyAsyncInterface</code>
<code class="p">{</code>
  <code class="k">public</code> <code class="n">Task</code> <code class="nf">DoSomethingAsync</code><code class="p">()</code>
  <code class="p">{</code>
    <code class="k">try</code>
    <code class="p">{</code>
      <code class="n">DoSomethingSynchronously</code><code class="p">();</code>
      <code class="k">return</code> <code class="n">Task</code><code class="p">.</code><code class="n">CompletedTask</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">catch</code> <code class="p">(</code><code class="n">Exception</code> <code class="n">ex</code><code class="p">)</code>
    <code class="p">{</code>
      <code class="k">return</code> <code class="n">Task</code><code class="p">.</code><code class="n">FromException</code><code class="p">(</code><code class="n">ex</code><code class="p">);</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">}</code></pre>
</div></section>













<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458706660008">
<h2>Discussion</h2>

<p>If you’re implementing an asynchronous interface with synchronous code, avoid any form of blocking. It isn’t ideal for an asynchronous method to block and then return a completed task, when it is possible for the method to be implemented asynchronously. For a counterexample, consider the <code>Console</code> text readers in the .NET BCL. <code>Console.In.ReadLineAsync</code> will actually block the calling thread until a line is read, and then it will return a completed task. This behavior isn’t intuitive and has surprised many developers. If an asynchronous method blocks, it prevents the calling thread from starting other tasks, which interferes with concurrency and may even cause a deadlock.</p>

<p>If <a data-primary="tasks" data-secondary="caching" data-type="indexterm" id="idm45458706381880"/>you regularly use <code>Task.FromResult</code> with the same value, consider caching the actual task. For example, if you create a <code>Task&lt;int&gt;</code> with a zero result once, then you avoid creating extra instances that will have to be garbage-collected:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="k">private</code> <code class="k">static</code> <code class="k">readonly</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">zeroTask</code> <code class="p">=</code> <code class="n">Task</code><code class="p">.</code><code class="n">FromResult</code><code class="p">(</code><code class="m">0</code><code class="p">);</code>
<code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">GetValueAsync</code><code class="p">()</code>
<code class="p">{</code>
  <code class="k">return</code> <code class="n">zeroTask</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>Logically,<a data-primary="TaskCompletionSource type" data-type="indexterm" id="idm45458706350792"/> <code>Task.FromResult</code>, <code>Task.FromException</code>, and <code>Task.FromCanceled</code> are all helper methods and shortcuts for the general-purpose <code>TaskCompletionSource&lt;T&gt;</code>. <code>TaskCompletionSource&lt;T&gt;</code> is a lower-level type that is useful for interoperating with other forms of asynchronous code. Generally, you should use the shorthand <code>Task.FromResult</code> and friends if you want to return a task that’s already been completed. Use <code>TaskCompletionSource&lt;T&gt;</code> to return a task that is completed at some future <a data-startref="ch2r2a" data-type="indexterm" id="idm45458706346456"/><a data-startref="ch2r2b" data-type="indexterm" id="idm45458706345752"/><a data-startref="ch2r2c" data-type="indexterm" id="idm45458706345080"/>time.</p>
</div></section>













<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458706350424">
<h2>See Also</h2>

<p><a data-type="xref" href="ch07.html#recipe-async-test">Recipe 7.1</a> covers unit testing asynchronous methods.</p>

<p><a data-type="xref" href="ch11.html#recipe-oop-inheritance">Recipe 11.1</a> covers inheritance of <code>async</code> methods.</p>

<p><a data-type="xref" href="ch08.html#recipe-async-interop-any">Recipe 8.3</a> shows how <code>TaskCompletionSource&lt;T&gt;</code> can be used for general-purpose interop with other asynchronous code.</p>
</div></section>





</div></section>













<section class="recipe" data-pdf-bookmark="2.3 Reporting Progress" data-type="sect1"><div class="sect1" id="recipe-async-progress">
<h1>2.3 Reporting Progress</h1>








<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458706303480">
<h2>Problem</h2>

<p>You <a data-primary="asynchronous programming" data-secondary="progress, reporting" data-type="indexterm" id="idm45458706302120"/><a data-primary="progress reports" data-secondary="sending" data-type="indexterm" id="idm45458706301144"/>need to respond to progress while an operation is executing.</p>
</div></section>













<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458706299816">
<h2>Solution</h2>

<p>Use <a data-primary="IProgress type" data-type="indexterm" id="idm45458706298056"/><a data-primary="Progress type" data-type="indexterm" id="idm45458706297320"/>the provided <code>IProgress&lt;T&gt;</code> and <code>Progress&lt;T&gt;</code> types. Your <code>async</code> method should take an <code>IProgress&lt;T&gt;</code> argument; the <code>T</code> is whatever type of progress you need to report:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="k">async</code> <code class="n">Task</code> <code class="nf">MyMethodAsync</code><code class="p">(</code><code class="n">IProgress</code><code class="p">&lt;</code><code class="kt">double</code><code class="p">&gt;</code> <code class="n">progress</code> <code class="p">=</code> <code class="k">null</code><code class="p">)</code>
<code class="p">{</code>
  <code class="kt">bool</code> <code class="n">done</code> <code class="p">=</code> <code class="k">false</code><code class="p">;</code>
  <code class="kt">double</code> <code class="n">percentComplete</code> <code class="p">=</code> <code class="m">0</code><code class="p">;</code>
  <code class="k">while</code> <code class="p">(!</code><code class="n">done</code><code class="p">)</code>
  <code class="p">{</code>
    <code class="p">...</code>
    <code class="n">progress</code><code class="p">?.</code><code class="n">Report</code><code class="p">(</code><code class="n">percentComplete</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p>Calling code can use it as such:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="k">async</code> <code class="n">Task</code> <code class="nf">CallMyMethodAsync</code><code class="p">()</code>
<code class="p">{</code>
  <code class="kt">var</code> <code class="n">progress</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Progress</code><code class="p">&lt;</code><code class="kt">double</code><code class="p">&gt;();</code>
  <code class="n">progress</code><code class="p">.</code><code class="n">ProgressChanged</code> <code class="p">+=</code> <code class="p">(</code><code class="n">sender</code><code class="p">,</code> <code class="n">args</code><code class="p">)</code> <code class="p">=&gt;</code>
  <code class="p">{</code>
    <code class="p">...</code>
  <code class="p">};</code>
  <code class="k">await</code> <code class="nf">MyMethodAsync</code><code class="p">(</code><code class="n">progress</code><code class="p">);</code>
<code class="p">}</code></pre>
</div></section>













<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458706235048">
<h2>Discussion</h2>

<p>By convention, the <code>IProgress&lt;T&gt;</code> parameter may be <code>null</code> if the caller doesn’t need progress reports, so be sure to check for this in your <code>async</code> method.</p>

<p>Bear <a data-primary="IProgress.Report method" data-type="indexterm" id="idm45458706157848"/>in mind that the <code>IProgress&lt;T&gt;.Report</code> method is usually asynchronous. This means that <code>MyMethodAsync</code> may continue executing before the progress is reported. For this reason, it’s best to define <code>T</code> as an <em>immutable type</em> or at least a value type. If <code>T</code> is a mutable reference type, then you’ll have to create a separate copy yourself each time you call <code>IProgress&lt;T&gt;.Report</code>.</p>

<p><code>Progress&lt;T&gt;</code> will <a data-primary="callbacks" data-secondary="Progress type using" data-type="indexterm" id="idm45458706153624"/>capture the current context when it is constructed and will invoke its callback within that context. This means that if you construct the <code>Progress&lt;T&gt;</code> on the UI thread, then you can update the UI from its callback, even if the asynchronous method is invoking <code>Report</code> from a background thread.</p>

<p>When a method supports progress reporting, it should also make a best effort to support cancellation.</p>

<p><code>IProgress&lt;T&gt;</code> is not exclusively for asynchronous code; both progress and cancellation can (and should) be used in long-running synchronous code as well.</p>
</div></section>













<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458706149880">
<h2>See Also</h2>

<p><a data-type="xref" href="ch10.html#recipe-cancel-async">Recipe 10.4</a> covers how to support cancellation in an asynchronous method.</p>
</div></section>





</div></section>













<section class="recipe" data-pdf-bookmark="2.4 Waiting for a Set of Tasks to Complete" data-type="sect1"><div class="sect1" id="recipe-async-whenall">
<h1>2.4 Waiting for a Set of Tasks to Complete</h1>








<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458706145832">
<h2>Problem</h2>

<p>You <a data-primary="asynchronous programming" data-secondary="multiple tasks, waiting for all to complete" data-type="indexterm" id="ch2r4a"/><a data-primary="tasks" data-secondary="multiple, waiting for all to complete" data-type="indexterm" id="ch2r4b"/>have several tasks and need to wait for them all to complete.</p>
</div></section>













<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458706141656">
<h2>Solution</h2>

<p>The <a data-primary="Task.WhenAll method" data-type="indexterm" id="ch2r4c"/>framework provides a <code>Task.WhenAll</code> method for this purpose. This method takes several tasks and returns a task that completes when all of those tasks have completed:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="n">Task</code> <code class="n">task1</code> <code class="p">=</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">1</code><code class="p">));</code>
<code class="n">Task</code> <code class="n">task2</code> <code class="p">=</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">2</code><code class="p">));</code>
<code class="n">Task</code> <code class="n">task3</code> <code class="p">=</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">1</code><code class="p">));</code>

<code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">WhenAll</code><code class="p">(</code><code class="n">task1</code><code class="p">,</code> <code class="n">task2</code><code class="p">,</code> <code class="n">task3</code><code class="p">);</code></pre>

<p>If all the tasks have the same result type and they all complete successfully, then the <code>Task.WhenAll</code> task will return an array containing all the task results:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">task1</code> <code class="p">=</code> <code class="n">Task</code><code class="p">.</code><code class="n">FromResult</code><code class="p">(</code><code class="m">3</code><code class="p">);</code>
<code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">task2</code> <code class="p">=</code> <code class="n">Task</code><code class="p">.</code><code class="n">FromResult</code><code class="p">(</code><code class="m">5</code><code class="p">);</code>
<code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">task3</code> <code class="p">=</code> <code class="n">Task</code><code class="p">.</code><code class="n">FromResult</code><code class="p">(</code><code class="m">7</code><code class="p">);</code>

<code class="kt">int</code><code class="p">[]</code> <code class="n">results</code> <code class="p">=</code> <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">WhenAll</code><code class="p">(</code><code class="n">task1</code><code class="p">,</code> <code class="n">task2</code><code class="p">,</code> <code class="n">task3</code><code class="p">);</code>

<code class="c1">// "results" contains { 3, 5, 7 }</code></pre>

<p>There is an overload of <code>Task.WhenAll</code> that takes an <code>IEnumerable</code> of tasks; however, I don’t recommend that you use it. Whenever I mix asynchronous code with LINQ, I find the code is clearer when I explicitly “reify” the sequence (i.e., evaluate the sequence, creating a collection):</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">DownloadAllAsync</code><code class="p">(</code><code class="n">HttpClient</code> <code class="n">client</code><code class="p">,</code>
    <code class="n">IEnumerable</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">urls</code><code class="p">)</code>
<code class="p">{</code>
  <code class="c1">// Define the action to do for each URL.</code>
  <code class="kt">var</code> <code class="n">downloads</code> <code class="p">=</code> <code class="n">urls</code><code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">url</code> <code class="p">=&gt;</code> <code class="n">client</code><code class="p">.</code><code class="n">GetStringAsync</code><code class="p">(</code><code class="n">url</code><code class="p">));</code>
  <code class="c1">// Note that no tasks have actually started yet</code>
  <code class="c1">//  because the sequence is not evaluated.</code>

  <code class="c1">// Start all URLs downloading simultaneously.</code>
  <code class="n">Task</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;[]</code> <code class="n">downloadTasks</code> <code class="p">=</code> <code class="n">downloads</code><code class="p">.</code><code class="n">ToArray</code><code class="p">();</code>
  <code class="c1">// Now the tasks have all started.</code>

  <code class="c1">// Asynchronously wait for all downloads to complete.</code>
  <code class="kt">string</code><code class="p">[]</code> <code class="n">htmlPages</code> <code class="p">=</code> <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">WhenAll</code><code class="p">(</code><code class="n">downloadTasks</code><code class="p">);</code>

  <code class="k">return</code> <code class="kt">string</code><code class="p">.</code><code class="n">Concat</code><code class="p">(</code><code class="n">htmlPages</code><code class="p">);</code>
<code class="p">}</code></pre>
</div></section>













<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458705983224">
<h2>Discussion</h2>

<p>If <a data-primary="error handling" data-secondary="when waiting on multiple tasks" data-type="indexterm" id="idm45458705872216"/>any of the tasks throws an exception, then <code>Task.WhenAll</code> will fault its returned task with that exception. If multiple tasks throw an exception, then all of those exceptions are placed on the <code>Task</code> returned by <code>Task.WhenAll</code>. However, when that task is awaited, only one of them will be thrown. If you need each specific exception, you can examine the <code>Exception</code> property on the <code>Task</code> returned by <code>Task.WhenAll</code>:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="k">async</code> <code class="n">Task</code> <code class="nf">ThrowNotImplementedExceptionAsync</code><code class="p">()</code>
<code class="p">{</code>
  <code class="k">throw</code> <code class="k">new</code> <code class="nf">NotImplementedException</code><code class="p">();</code>
<code class="p">}</code>

<code class="k">async</code> <code class="n">Task</code> <code class="nf">ThrowInvalidOperationExceptionAsync</code><code class="p">()</code>
<code class="p">{</code>
  <code class="k">throw</code> <code class="k">new</code> <code class="nf">InvalidOperationException</code><code class="p">();</code>
<code class="p">}</code>

<code class="k">async</code> <code class="n">Task</code> <code class="nf">ObserveOneExceptionAsync</code><code class="p">()</code>
<code class="p">{</code>
  <code class="kt">var</code> <code class="n">task1</code> <code class="p">=</code> <code class="n">ThrowNotImplementedExceptionAsync</code><code class="p">();</code>
  <code class="kt">var</code> <code class="n">task2</code> <code class="p">=</code> <code class="n">ThrowInvalidOperationExceptionAsync</code><code class="p">();</code>

  <code class="k">try</code>
  <code class="p">{</code>
    <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">WhenAll</code><code class="p">(</code><code class="n">task1</code><code class="p">,</code> <code class="n">task2</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="k">catch</code> <code class="p">(</code><code class="n">Exception</code> <code class="n">ex</code><code class="p">)</code>
  <code class="p">{</code>
    <code class="c1">// "ex" is either NotImplementedException or InvalidOperationException.</code>
    <code class="p">...</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="k">async</code> <code class="n">Task</code> <code class="nf">ObserveAllExceptionsAsync</code><code class="p">()</code>
<code class="p">{</code>
  <code class="kt">var</code> <code class="n">task1</code> <code class="p">=</code> <code class="n">ThrowNotImplementedExceptionAsync</code><code class="p">();</code>
  <code class="kt">var</code> <code class="n">task2</code> <code class="p">=</code> <code class="n">ThrowInvalidOperationExceptionAsync</code><code class="p">();</code>

  <code class="n">Task</code> <code class="n">allTasks</code> <code class="p">=</code> <code class="n">Task</code><code class="p">.</code><code class="n">WhenAll</code><code class="p">(</code><code class="n">task1</code><code class="p">,</code> <code class="n">task2</code><code class="p">);</code>
  <code class="k">try</code>
  <code class="p">{</code>
    <code class="k">await</code> <code class="n">allTasks</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">catch</code>
  <code class="p">{</code>
    <code class="n">AggregateException</code> <code class="n">allExceptions</code> <code class="p">=</code> <code class="n">allTasks</code><code class="p">.</code><code class="n">Exception</code><code class="p">;</code>
    <code class="p">...</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p>Most of the time, I do <em>not</em> observe all the exceptions when using <code>Task.WhenAll</code>. It’s usually sufficient to respond to only the first error that was thrown, rather than all of them.</p>

<p>Note that in the preceding example, the <code>ThrowNotImplementedExceptionAsync</code> and <code>ThrowInvalidOperationExceptionAsync</code> methods don’t throw their exceptions directly; they use the <code>async</code> keyword, so their exceptions are captured and placed on a task that is returned normally. This is the normal and expected behavior of methods that return awaitable <a data-startref="ch2r4a" data-type="indexterm" id="idm45458705743112"/><a data-startref="ch2r4b" data-type="indexterm" id="idm45458705742408"/><a data-startref="ch2r4c" data-type="indexterm" id="idm45458705741736"/>types.</p>
</div></section>













<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458705740936">
<h2>See Also</h2>

<p><a data-type="xref" href="#recipe-async-whenany">Recipe 2.5</a> covers a way to wait for <em>any</em> of a collection of tasks to complete.</p>

<p><a data-type="xref" href="#recipe-async-orderbycompletion">Recipe 2.6</a> covers waiting for a collection of tasks to complete and performing actions as each one completes.</p>

<p><a data-type="xref" href="#recipe-async-catchtask">Recipe 2.8</a> covers exception handling for <code>async Task</code> methods.</p>
</div></section>





</div></section>













<section class="recipe" data-pdf-bookmark="2.5 Waiting for Any Task to Complete" data-type="sect1"><div class="sect1" id="recipe-async-whenany">
<h1>2.5 Waiting for Any Task to Complete</h1>








<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458705733672">
<h2>Problem</h2>

<p>You <a data-primary="asynchronous programming" data-secondary="multiple tasks, waiting for any to complete" data-type="indexterm" id="ch2r5a"/><a data-primary="tasks" data-secondary="multiple, waiting for any to complete" data-type="indexterm" id="ch2r5b"/>have several tasks and need to respond to just one of them that’s completing. You’ll encounter this problem most commonly when you have multiple independent attempts at an operation, with a first-one-takes-all kind of structure. For example, you could request stock quotes from multiple web services simultaneously, but you only care about the first one that responds.</p>
</div></section>













<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458705729032">
<h2>Solution</h2>

<p>Use <a data-primary="Task.WhenAny method" data-type="indexterm" id="ch2r5c"/>the <code>Task.WhenAny</code> method. The <code>Task.WhenAny</code> method takes a sequence of tasks and returns a task that completes when any of the tasks complete. The result of the returned task is the task that completed. Don’t worry if that sounds confusing; it’s one of those things that’s difficult to explain but is easier to understand with code:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="c1">// Returns the length of data at the first URL to respond.</code>
<code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">FirstRespondingUrlAsync</code><code class="p">(</code><code class="n">HttpClient</code> <code class="n">client</code><code class="p">,</code>
    <code class="kt">string</code> <code class="n">urlA</code><code class="p">,</code> <code class="kt">string</code> <code class="n">urlB</code><code class="p">)</code>
<code class="p">{</code>
  <code class="c1">// Start both downloads concurrently.</code>
  <code class="n">Task</code><code class="p">&lt;</code><code class="kt">byte</code><code class="p">[]&gt;</code> <code class="n">downloadTaskA</code> <code class="p">=</code> <code class="n">client</code><code class="p">.</code><code class="n">GetByteArrayAsync</code><code class="p">(</code><code class="n">urlA</code><code class="p">);</code>
  <code class="n">Task</code><code class="p">&lt;</code><code class="kt">byte</code><code class="p">[]&gt;</code> <code class="n">downloadTaskB</code> <code class="p">=</code> <code class="n">client</code><code class="p">.</code><code class="n">GetByteArrayAsync</code><code class="p">(</code><code class="n">urlB</code><code class="p">);</code>

  <code class="c1">// Wait for either of the tasks to complete.</code>
  <code class="n">Task</code><code class="p">&lt;</code><code class="kt">byte</code><code class="p">[]&gt;</code> <code class="n">completedTask</code> <code class="p">=</code>
      <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">WhenAny</code><code class="p">(</code><code class="n">downloadTaskA</code><code class="p">,</code> <code class="n">downloadTaskB</code><code class="p">);</code>

  <code class="c1">// Return the length of the data retrieved from that URL.</code>
  <code class="kt">byte</code><code class="p">[]</code> <code class="n">data</code> <code class="p">=</code> <code class="k">await</code> <code class="n">completedTask</code><code class="p">;</code>
  <code class="k">return</code> <code class="n">data</code><code class="p">.</code><code class="n">Length</code><code class="p">;</code>
<code class="p">}</code></pre>
</div></section>













<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458705723896">
<h2>Discussion</h2>

<p>The task returned by <code>Task.WhenAny</code> never completes in a faulted or canceled state. This “outer” task always completes successfully, and its result value is the first <code>Task</code> to complete (the “inner” task). If the inner task completed with an exception, then that exception is not propagated to the outer task (the one returned by <code>Task.WhenAny</code>). You should usually <code>await</code> the inner task after it has completed to ensure any exceptions are observed.</p>

<p>When the first task completes, consider whether to cancel the remaining tasks. If the other tasks aren’t canceled but are also never awaited, then they are abandoned. Abandoned tasks will run to completion, and their results will be ignored. Any exceptions from those abandoned tasks will also be ignored. If these tasks aren’t canceled, they do continue to run and can use resources unnecessarily, such as HTTP connections, DB connections, or timers.</p>

<p>It is possible to use <code>Task.WhenAny</code> to implement timeouts (e.g., using <code>Task.Delay</code> as one of the tasks), but it’s not recommended. It’s more natural to express timeouts with cancellation, and cancellation has the added benefit that it can actually <em>cancel</em> the operation(s) if they time out.</p>

<p>Another anti-pattern for <code>Task.WhenAny</code> is handling tasks as they complete. At first it seems reasonable to keep a list of tasks and remove each task from the list as it completes. The problem with this approach is that it executes in O(N²) time, when an O(N) algorithm exists. The proper O(N) algorithm is <a data-startref="ch2r5a" data-type="indexterm" id="idm45458705573816"/><a data-startref="ch2r5b" data-type="indexterm" id="idm45458705573112"/><a data-startref="ch2r5c" data-type="indexterm" id="idm45458705572440"/>discussed in <a data-type="xref" href="#recipe-async-orderbycompletion">Recipe 2.6</a>.</p>
</div></section>













<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458705570712">
<h2>See Also</h2>

<p><a data-type="xref" href="#recipe-async-whenall">Recipe 2.4</a> covers asynchronously waiting for <em>all</em> of a collection of tasks to complete.</p>

<p><a data-type="xref" href="#recipe-async-orderbycompletion">Recipe 2.6</a> covers waiting for a collection of tasks to complete and performing actions as each one completes.</p>

<p><a data-type="xref" href="ch10.html#recipe-cancel-timeout">Recipe 10.3</a> covers using a cancellation token to implement timeouts.</p>
</div></section>





</div></section>













<section class="recipe" data-pdf-bookmark="2.6 Processing Tasks as They Complete" data-type="sect1"><div class="sect1" id="recipe-async-orderbycompletion">
<h1>2.6 Processing Tasks as They Complete</h1>








<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458705564040">
<h2>Problem</h2>

<p>You <a data-primary="asynchronous programming" data-secondary="multiple tasks, processing as they complete" data-type="indexterm" id="ch2r6a"/><a data-primary="tasks" data-secondary="multiple, processing as they complete" data-type="indexterm" id="ch2r6b"/>have a collection of tasks to await, and you want to do some processing on each task after it completes. However, you want to do the processing for each one as soon as it completes, not waiting for any of the other tasks.</p>

<p>The following example code kicks off three delay tasks and then awaits each one:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">DelayAndReturnAsync</code><code class="p">(</code><code class="kt">int</code> <code class="k">value</code><code class="p">)</code>
<code class="p">{</code>
  <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="k">value</code><code class="p">));</code>
  <code class="k">return</code> <code class="k">value</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">// Currently, this method prints "2", "3", and "1".</code>
<code class="c1">// The desired behavior is for this method to print "1", "2", and "3".</code>
<code class="k">async</code> <code class="n">Task</code> <code class="nf">ProcessTasksAsync</code><code class="p">()</code>
<code class="p">{</code>
  <code class="c1">// Create a sequence of tasks.</code>
  <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">taskA</code> <code class="p">=</code> <code class="n">DelayAndReturnAsync</code><code class="p">(</code><code class="m">2</code><code class="p">);</code>
  <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">taskB</code> <code class="p">=</code> <code class="n">DelayAndReturnAsync</code><code class="p">(</code><code class="m">3</code><code class="p">);</code>
  <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">taskC</code> <code class="p">=</code> <code class="n">DelayAndReturnAsync</code><code class="p">(</code><code class="m">1</code><code class="p">);</code>
  <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;[]</code> <code class="n">tasks</code> <code class="p">=</code> <code class="k">new</code><code class="p">[]</code> <code class="p">{</code> <code class="n">taskA</code><code class="p">,</code> <code class="n">taskB</code><code class="p">,</code> <code class="n">taskC</code> <code class="p">};</code>

  <code class="c1">// Await each task in order.</code>
  <code class="k">foreach</code> <code class="p">(</code><code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">task</code> <code class="k">in</code> <code class="n">tasks</code><code class="p">)</code>
  <code class="p">{</code>
    <code class="kt">var</code> <code class="n">result</code> <code class="p">=</code> <code class="k">await</code> <code class="n">task</code><code class="p">;</code>
    <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">result</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p>The code currently awaits each task in sequence order, even though the third task in the sequence is the first one to complete. You want the code to do the processing (e.g., <code>Trace.WriteLine</code>) as each task completes without waiting for the others.</p>
</div></section>













<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458705556616">
<h2>Solution</h2>

<p>There <a data-primary="Task.Delay method" data-type="indexterm" id="ch2r6c"/><a data-primary="Task.WhenAll method" data-type="indexterm" id="ch2r6d"/>are a few different approaches you can take to solve this problem. The one described first in this recipe is the recommended approach; another is described in the “Discussion” section.</p>

<p>The easiest solution is to restructure the code by introducing a higher-level <code>async</code> method that handles awaiting the task and processing its result. Once the processing is factored out, the code is significantly simplified:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">DelayAndReturnAsync</code><code class="p">(</code><code class="kt">int</code> <code class="k">value</code><code class="p">)</code>
<code class="p">{</code>
  <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="k">value</code><code class="p">));</code>
  <code class="k">return</code> <code class="k">value</code><code class="p">;</code>
<code class="p">}</code>

<code class="k">async</code> <code class="n">Task</code> <code class="nf">AwaitAndProcessAsync</code><code class="p">(</code><code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">task</code><code class="p">)</code>
<code class="p">{</code>
  <code class="kt">int</code> <code class="n">result</code> <code class="p">=</code> <code class="k">await</code> <code class="n">task</code><code class="p">;</code>
  <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">result</code><code class="p">);</code>
<code class="p">}</code>

<code class="c1">// This method now prints "1", "2", and "3".</code>
<code class="k">async</code> <code class="n">Task</code> <code class="nf">ProcessTasksAsync</code><code class="p">()</code>
<code class="p">{</code>
  <code class="c1">// Create a sequence of tasks.</code>
  <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">taskA</code> <code class="p">=</code> <code class="n">DelayAndReturnAsync</code><code class="p">(</code><code class="m">2</code><code class="p">);</code>
  <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">taskB</code> <code class="p">=</code> <code class="n">DelayAndReturnAsync</code><code class="p">(</code><code class="m">3</code><code class="p">);</code>
  <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">taskC</code> <code class="p">=</code> <code class="n">DelayAndReturnAsync</code><code class="p">(</code><code class="m">1</code><code class="p">);</code>
  <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;[]</code> <code class="n">tasks</code> <code class="p">=</code> <code class="k">new</code><code class="p">[]</code> <code class="p">{</code> <code class="n">taskA</code><code class="p">,</code> <code class="n">taskB</code><code class="p">,</code> <code class="n">taskC</code> <code class="p">};</code>

  <code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">Task</code><code class="p">&gt;</code> <code class="n">taskQuery</code> <code class="p">=</code>
      <code class="k">from</code> <code class="n">t</code> <code class="k">in</code> <code class="n">tasks</code> <code class="k">select</code> <code class="nf">AwaitAndProcessAsync</code><code class="p">(</code><code class="n">t</code><code class="p">);</code>
  <code class="n">Task</code><code class="p">[]</code> <code class="n">processingTasks</code> <code class="p">=</code> <code class="n">taskQuery</code><code class="p">.</code><code class="n">ToArray</code><code class="p">();</code>

  <code class="c1">// Await all processing to complete</code>
  <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">WhenAll</code><code class="p">(</code><code class="n">processingTasks</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>Alternatively, this code can be written like this:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">DelayAndReturnAsync</code><code class="p">(</code><code class="kt">int</code> <code class="k">value</code><code class="p">)</code>
<code class="p">{</code>
  <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="k">value</code><code class="p">));</code>
  <code class="k">return</code> <code class="k">value</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">// This method now prints "1", "2", and "3".</code>
<code class="k">async</code> <code class="n">Task</code> <code class="nf">ProcessTasksAsync</code><code class="p">()</code>
<code class="p">{</code>
  <code class="c1">// Create a sequence of tasks.</code>
  <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">taskA</code> <code class="p">=</code> <code class="n">DelayAndReturnAsync</code><code class="p">(</code><code class="m">2</code><code class="p">);</code>
  <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">taskB</code> <code class="p">=</code> <code class="n">DelayAndReturnAsync</code><code class="p">(</code><code class="m">3</code><code class="p">);</code>
  <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">taskC</code> <code class="p">=</code> <code class="n">DelayAndReturnAsync</code><code class="p">(</code><code class="m">1</code><code class="p">);</code>
  <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;[]</code> <code class="n">tasks</code> <code class="p">=</code> <code class="k">new</code><code class="p">[]</code> <code class="p">{</code> <code class="n">taskA</code><code class="p">,</code> <code class="n">taskB</code><code class="p">,</code> <code class="n">taskC</code> <code class="p">};</code>

  <code class="n">Task</code><code class="p">[]</code> <code class="n">processingTasks</code> <code class="p">=</code> <code class="n">tasks</code><code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="k">async</code> <code class="n">t</code> <code class="p">=&gt;</code>
  <code class="p">{</code>
    <code class="kt">var</code> <code class="n">result</code> <code class="p">=</code> <code class="k">await</code> <code class="n">t</code><code class="p">;</code>
    <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">result</code><code class="p">);</code>
  <code class="p">}).</code><code class="n">ToArray</code><code class="p">();</code>

  <code class="c1">// Await all processing to complete</code>
  <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">WhenAll</code><code class="p">(</code><code class="n">processingTasks</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>The refactoring shown is the cleanest and most portable way to solve this problem. Note that it is subtly different than the original code. This solution will do the task processing concurrently, whereas the original code would do the task processing one at a time. Typically this isn’t a problem, but if it’s not acceptable for your situation, then consider using locks (<a data-type="xref" href="ch12.html#recipe-async-locks">Recipe 12.2</a>) or the following alternative solution.</p>
</div></section>













<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458705200536">
<h2>Discussion</h2>

<p>If refactoring isn’t a palatable solution, then there is an alternative. Stephen Toub and Jon Skeet have both developed an extension method that returns an array of tasks that will complete in order. Stephen Toub’s solution is available on the <a href="http://bit.ly/toub-task">Parallel Programming with .NET blog</a>, and Jon Skeet’s solution is available on <a href="http://bit.ly/skeet_blog">his coding blog</a>.</p>
<div data-type="tip"><h6>Tip</h6>
<p>The<a data-primary="Nito.AsyncEx library" data-type="indexterm" id="idm45458705000888"/><a data-primary="OrderByCompletion method" data-type="indexterm" id="idm45458705000152"/> <code>OrderByCompletion</code> extension method is also available in the open source <a href="https://github.com/StephenCleary/AsyncEx"><code>AsyncEx</code> library</a>, in the <a href="http://bit.ly/nito-async"><code>Nito.AsyncEx</code> NuGet package</a>.</p>
</div>

<p>Using an extension method like <code>OrderByCompletion</code> minimizes the changes to the original <a data-startref="ch2r6a" data-type="indexterm" id="idm45458704995720"/><a data-startref="ch2r6b" data-type="indexterm" id="idm45458704995016"/><a data-startref="ch2r6c" data-type="indexterm" id="idm45458704994344"/><a data-startref="ch2r6d" data-type="indexterm" id="idm45458704993672"/>code:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">DelayAndReturnAsync</code><code class="p">(</code><code class="kt">int</code> <code class="k">value</code><code class="p">)</code>
<code class="p">{</code>
  <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="k">value</code><code class="p">));</code>
  <code class="k">return</code> <code class="k">value</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">// This method now prints "1", "2", and "3".</code>
<code class="k">async</code> <code class="n">Task</code> <code class="nf">UseOrderByCompletionAsync</code><code class="p">()</code>
<code class="p">{</code>
  <code class="c1">// Create a sequence of tasks.</code>
  <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">taskA</code> <code class="p">=</code> <code class="n">DelayAndReturnAsync</code><code class="p">(</code><code class="m">2</code><code class="p">);</code>
  <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">taskB</code> <code class="p">=</code> <code class="n">DelayAndReturnAsync</code><code class="p">(</code><code class="m">3</code><code class="p">);</code>
  <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">taskC</code> <code class="p">=</code> <code class="n">DelayAndReturnAsync</code><code class="p">(</code><code class="m">1</code><code class="p">);</code>
  <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;[]</code> <code class="n">tasks</code> <code class="p">=</code> <code class="k">new</code><code class="p">[]</code> <code class="p">{</code> <code class="n">taskA</code><code class="p">,</code> <code class="n">taskB</code><code class="p">,</code> <code class="n">taskC</code> <code class="p">};</code>

  <code class="c1">// Await each one as they complete.</code>
  <code class="k">foreach</code> <code class="p">(</code><code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">task</code> <code class="k">in</code> <code class="n">tasks</code><code class="p">.</code><code class="n">OrderByCompletion</code><code class="p">())</code>
  <code class="p">{</code>
    <code class="kt">int</code> <code class="n">result</code> <code class="p">=</code> <code class="k">await</code> <code class="n">task</code><code class="p">;</code>
    <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">result</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code></pre>
</div></section>













<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458704990904">
<h2>See Also</h2>

<p><a data-type="xref" href="#recipe-async-whenall">Recipe 2.4</a> covers asynchronously waiting for a sequence of tasks to complete.</p>
</div></section>





</div></section>













<section class="recipe" data-pdf-bookmark="2.7 Avoiding Context for Continuations" data-type="sect1"><div class="sect1" id="recipe-async-configureawait">
<h1>2.7 Avoiding Context for Continuations</h1>








<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458704881192">
<h2>Problem</h2>

<p>When <a data-primary="context" data-secondary="avoiding on continuations" data-type="indexterm" id="idm45458704879640"/><a data-primary="schedulers" data-secondary="in asynchronous programming" data-secondary-sortas="asynchronous" data-type="indexterm" id="idm45458704878664"/><a data-primary="asynchronous programming" data-secondary="schedulers" data-type="indexterm" id="idm45458704877432"/>an <code>async</code> method resumes after an <code>await</code>, by default it will resume executing within the same context. This can cause performance problems if that context was a UI context and a large number of <code>async</code> methods are resuming on the UI context.</p>
</div></section>













<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458704874792">
<h2>Solution</h2>

<p>To <a data-primary="ConfigureAwait method" data-type="indexterm" id="idm45458704873240"/>avoid resuming on a context, <code>await</code> the result of <code>ConfigureAwait</code> and pass <code>false</code> for its <code>continueOnCapturedContext</code> parameter:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="k">async</code> <code class="n">Task</code> <code class="nf">ResumeOnContextAsync</code><code class="p">()</code>
<code class="p">{</code>
  <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">1</code><code class="p">));</code>

  <code class="c1">// This method resumes within the same context.</code>
<code class="p">}</code>

<code class="k">async</code> <code class="n">Task</code> <code class="nf">ResumeWithoutContextAsync</code><code class="p">()</code>
<code class="p">{</code>
  <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">1</code><code class="p">)).</code><code class="n">ConfigureAwait</code><code class="p">(</code><code class="k">false</code><code class="p">);</code>

  <code class="c1">// This method discards its context when it resumes.</code>
<code class="p">}</code></pre>
</div></section>













<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458704870136">
<h2>Discussion</h2>

<p>Having too many continuations run on the UI thread can cause a performance problem. This type of performance problem is difficult to diagnose, since it’s not a single method that is slowing down the system. Rather, the UI performance begins to suffer from “thousands of paper cuts” as the application grows more complex.</p>

<p>The real question is, <em>how many</em> continuations on the UI thread are <em>too many?</em> There’s no hard-and-fast answer, but Lucian Wischik of Microsoft has <a href="http://bit.ly/new-async">publicized the guideline</a> used by the Universal Windows team: a hundred or so per second is OK, but a thousand or so per second is too many.</p>

<p>It’s best to avoid this problem right at the beginning. For every <code>async</code> method you write, if it doesn’t <em>need</em> to resume to its original context, then use <code>ConfigureAwait</code>. There’s no disadvantage to doing so.</p>

<p>It’s also a good idea to be aware of context when writing <code>async</code> code. Normally, an <code>async</code> method should <em>either</em> require context (dealing with UI elements or ASP.NET requests/responses) or be free from context (doing background operations). If you have an <code>async</code> method that has parts requiring context and parts free from context, consider splitting it up into two (or more) <code>async</code> methods. This approach helps keep your code better organized into layers.</p>
</div></section>













<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458704869752">
<h2>See Also</h2>

<p><a data-type="xref" href="ch01.html#intro">Chapter 1</a> covers an introduction to asynchronous programming.</p>
</div></section>





</div></section>













<section class="recipe" data-pdf-bookmark="2.8 Handling Exceptions from async Task Methods" data-type="sect1"><div class="sect1" id="recipe-async-catchtask">
<h1>2.8 Handling Exceptions from async Task Methods</h1>








<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458704837688">
<h2>Problem</h2>

<p>Exception <a data-primary="asynchronous programming" data-secondary="error handling" data-type="indexterm" id="ch2r89a"/><a data-primary="error handling" data-secondary="in asynchronous programming" data-secondary-sortas="asynchronous" data-type="indexterm" id="ch2r89b"/><a data-primary="tasks" data-secondary="handling exceptions from" data-type="indexterm" id="ch2r8c"/>handling is a critical part of any design. It’s easy to design for the success case, but a design isn’t correct until it also handles the failure cases. Fortunately, handling exceptions from <code>async Task</code> methods is straightforward.</p>
</div></section>













<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458704831400">
<h2>Solution</h2>

<p>Exceptions can be caught by a simple <code>try/catch</code>, just like you would do for synchronous code:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="k">async</code> <code class="n">Task</code> <code class="nf">ThrowExceptionAsync</code><code class="p">()</code>
<code class="p">{</code>
  <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">1</code><code class="p">));</code>
  <code class="k">throw</code> <code class="k">new</code> <code class="nf">InvalidOperationException</code><code class="p">(</code><code class="s">"Test"</code><code class="p">);</code>
<code class="p">}</code>

<code class="k">async</code> <code class="n">Task</code> <code class="nf">TestAsync</code><code class="p">()</code>
<code class="p">{</code>
  <code class="k">try</code>
  <code class="p">{</code>
    <code class="k">await</code> <code class="nf">ThrowExceptionAsync</code><code class="p">();</code>
  <code class="p">}</code>
  <code class="k">catch</code> <code class="p">(</code><code class="n">InvalidOperationException</code><code class="p">)</code>
  <code class="p">{</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p>Exceptions raised from <code>async Task</code> methods are placed on the returned <code>Task</code>. They are only raised when the returned <code>Task</code> is awaited:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="k">async</code> <code class="n">Task</code> <code class="nf">ThrowExceptionAsync</code><code class="p">()</code>
<code class="p">{</code>
  <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">1</code><code class="p">));</code>
  <code class="k">throw</code> <code class="k">new</code> <code class="nf">InvalidOperationException</code><code class="p">(</code><code class="s">"Test"</code><code class="p">);</code>
<code class="p">}</code>

<code class="k">async</code> <code class="n">Task</code> <code class="nf">TestAsync</code><code class="p">()</code>
<code class="p">{</code>
  <code class="c1">// The exception is thrown by the method and placed on the task.</code>
  <code class="n">Task</code> <code class="n">task</code> <code class="p">=</code> <code class="n">ThrowExceptionAsync</code><code class="p">();</code>
  <code class="k">try</code>
  <code class="p">{</code>
    <code class="c1">// The exception is re-raised here, where the task is awaited.</code>
    <code class="k">await</code> <code class="n">task</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">catch</code> <code class="p">(</code><code class="n">InvalidOperationException</code><code class="p">)</code>
  <code class="p">{</code>
    <code class="c1">// The exception is correctly caught here.</code>
  <code class="p">}</code>
<code class="p">}</code></pre>
</div></section>













<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458704661672">
<h2>Discussion</h2>

<p>When an exception is thrown out of an <code>async Task</code> method, that exception is captured and put on the returned <code>Task</code>. Since <code>async void</code> methods don’t have a <code>Task</code> to put their exception on, their behavior is different; catching exceptions from <code>async void</code> methods is covered in <a data-type="xref" href="#recipe-async-catchvoid">Recipe 2.9</a>.</p>

<p>When you <code>await</code> a faulted <code>Task</code>, the first exception on that task is re-thrown. If you’re familiar with the problems of re-throwing exceptions, you may be wondering about stack traces. Rest assured: when the exception is re-thrown, the original stack trace is correctly preserved.</p>

<p>This setup sounds somewhat complicated, but all this complexity works together so that the simple scenario has simple code. Most of the time, your code should propagate exceptions from asynchronous methods that it calls; all it has to do is <code>await</code> the task returned from that asynchronous method, and the exception will be propagated naturally.</p>

<p>There are some situations (such as <code>Task.WhenAll</code>) where a <code>Task</code> may have multiple exceptions, and <code>await</code> will only rethrow the first one. See <a data-type="xref" href="#recipe-async-whenall">Recipe 2.4</a> for an example of handling all <a data-startref="ch2r8c" data-type="indexterm" id="idm45458704590888"/>exceptions.</p>
</div></section>













<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458704590088">
<h2>See Also</h2>

<p><a data-type="xref" href="#recipe-async-whenall">Recipe 2.4</a> covers waiting for multiple tasks.</p>

<p><a data-type="xref" href="#recipe-async-catchvoid">Recipe 2.9</a> covers techniques for catching exceptions from <code>async void</code> methods.</p>

<p><a data-type="xref" href="ch07.html#recipe-async-testfail">Recipe 7.2</a> covers unit testing exceptions thrown from <code>async Task</code> methods.</p>
</div></section>





</div></section>













<section class="recipe" data-pdf-bookmark="2.9 Handling Exceptions from async void Methods" data-type="sect1"><div class="sect1" id="recipe-async-catchvoid">
<h1>2.9 Handling Exceptions from async void Methods</h1>








<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458704582904">
<h2>Problem</h2>

<p>You <a data-primary="async keyword" data-secondary="async void" data-type="indexterm" id="ch2r9a"/><a data-primary="error handling" data-secondary="async void methods" data-type="indexterm" id="idm45458704580296"/>have an <code>async void</code> method and need to handle exceptions propagated out of that method.</p>
</div></section>













<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458704578552">
<h2>Solution</h2>

<p>There is no good solution. If at all possible, change the method to return <code>Task</code> instead of <code>void</code>. In some situations, doing that isn’t possible; for example, let’s say you need to unit test an <code>ICommand</code> implementation (which <em>must</em> return <code>void</code>). In this case, you can provide a <code>Task</code>-returning overload of your <code>Execute</code> method:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="k">sealed</code> <code class="k">class</code> <code class="nc">MyAsyncCommand</code> <code class="p">:</code> <code class="n">ICommand</code>
<code class="p">{</code>
  <code class="k">async</code> <code class="k">void</code> <code class="n">ICommand</code><code class="p">.</code><code class="n">Execute</code><code class="p">(</code><code class="kt">object</code> <code class="n">parameter</code><code class="p">)</code>
  <code class="p">{</code>
    <code class="k">await</code> <code class="nf">Execute</code><code class="p">(</code><code class="n">parameter</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="k">public</code> <code class="k">async</code> <code class="n">Task</code> <code class="nf">Execute</code><code class="p">(</code><code class="kt">object</code> <code class="n">parameter</code><code class="p">)</code>
  <code class="p">{</code>
    <code class="p">...</code> <code class="c1">// Asynchronous command implementation goes here.</code>
  <code class="p">}</code>

  <code class="p">...</code> <code class="c1">// Other members (CanExecute, etc.)</code>
<code class="p">}</code></pre>

<p>It’s best to avoid propagating exceptions out of <code>async void</code> methods. If you must use an <code>async void</code> method, consider wrapping all of its code in a <code>try</code> block and handling the exception directly.</p>

<p>There is <a data-primary="SynchronizationContext type" data-type="indexterm" id="ch2r9y"/><a data-primary="context" data-secondary="controlling, for handling exceptions" data-type="indexterm" id="ch2r9z"/>another solution for handling exceptions from <code>async void</code> methods. When an <code>async void</code> method propagates an exception, that exception is then raised on the <code>SynchronizationContext</code> that was active at the time the <code>async void</code> method started executing. If your execution environment provides a <code>SynchronizationContext</code>, then it usually has a way to handle these top-level exceptions at a global scope. For example, WPF has <code>Application.DispatcherUnhandledException</code>, Universal Windows has <code>Application.UnhandledException</code>, and ASP.NET<a data-primary="ASP.NET" data-secondary="UseExceptionHandler" data-type="indexterm" id="idm45458704476728"/> has the <code>UseExceptionHandler</code> middleware.</p>

<p>It <a data-primary="AsyncContext type" data-type="indexterm" id="idm45458704475048"/>is also possible to handle exceptions from <code>async void</code> methods by controlling the <code>SynchronizationContext</code>. Writing your own <code>SynchronizationContext</code> isn’t easy, but you can use the <code>AsyncContext</code> type from the free <code>Nito.AsyncEx</code> NuGet helper library. <code>AsyncContext</code> is particularly useful for applications that don’t have a built-in <code>SynchronizationContext</code>, such as Console applications and Win32 services. The next example uses <code>AsyncContext</code> to run and handle exceptions from an <code>async void</code> method:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="k">static</code> <code class="k">class</code> <code class="nc">Program</code>
<code class="p">{</code>
  <code class="k">static</code> <code class="k">void</code> <code class="nf">Main</code><code class="p">(</code><code class="kt">string</code><code class="p">[]</code> <code class="n">args</code><code class="p">)</code>
  <code class="p">{</code>
    <code class="k">try</code>
    <code class="p">{</code>
      <code class="n">AsyncContext</code><code class="p">.</code><code class="n">Run</code><code class="p">(()</code> <code class="p">=&gt;</code> <code class="n">MainAsync</code><code class="p">(</code><code class="n">args</code><code class="p">));</code>
    <code class="p">}</code>
    <code class="k">catch</code> <code class="p">(</code><code class="n">Exception</code> <code class="n">ex</code><code class="p">)</code>
    <code class="p">{</code>
      <code class="n">Console</code><code class="p">.</code><code class="n">Error</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">ex</code><code class="p">);</code>
    <code class="p">}</code>
  <code class="p">}</code>

  <code class="c1">// BAD CODE!!!</code>
  <code class="c1">// In the real world, do not use async void unless you have to.</code>
  <code class="k">static</code> <code class="k">async</code> <code class="k">void</code> <code class="nf">MainAsync</code><code class="p">(</code><code class="kt">string</code><code class="p">[]</code> <code class="n">args</code><code class="p">)</code>
  <code class="p">{</code>
    <code class="p">...</code>
  <code class="p">}</code>
<code class="p">}</code></pre>
</div></section>













<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458704468344">
<h2>Discussion</h2>

<p>One reason to prefer <code>async Task</code> over <code>async void</code> is that <code>Task</code>-returning methods are easier to test. At the very least, overloading <code>void</code>-returning methods with <code>Task</code>-returning methods will give you a testable API surface.</p>

<p>If you do need to provide your own <code>SynchronizationContext</code> type (for example, <code>AsyncContext</code>), be sure not to install that <code>SynchronizationContext</code> on any threads that don’t belong to you. As a general rule, you shouldn’t place this type on any thread that already has one (such as UI or ASP.NET classic request threads); nor should you place a <code>SynchronizationContext</code> on threadpool threads. The main thread of a Console application does belong to you, and so do any threads you manually create <a data-startref="ch2r89a" data-type="indexterm" id="idm45458704392936"/><a data-startref="ch2r89b" data-type="indexterm" id="idm45458704392232"/><a data-startref="ch2r9a" data-type="indexterm" id="idm45458704391560"/><a data-startref="ch2r9y" data-type="indexterm" id="idm45458704390888"/><a data-startref="ch2r9z" data-type="indexterm" id="idm45458704390216"/>yourself.</p>
<div data-type="tip"><h6>Tip</h6>
<p>The <code>AsyncContext</code> type is in the <a href="http://bit.ly/nito-async"><code>Nito.AsyncEx</code></a> NuGet package.</p>
</div>
</div></section>













<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458704386856">
<h2>See Also</h2>

<p><a data-type="xref" href="#recipe-async-catchtask">Recipe 2.8</a> covers exception handling with <code>async Task</code> methods.</p>

<p><a data-type="xref" href="ch07.html#recipe-async-testvoid">Recipe 7.3</a> covers unit testing <code>async void</code> methods.</p>
</div></section>





</div></section>













<section class="recipe" data-pdf-bookmark="2.10 Creating a ValueTask" data-type="sect1"><div class="sect1" id="recipe-async-implement-valuetask">
<h1>2.10 Creating a ValueTask</h1>








<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458704380776">
<h2>Problem</h2>

<p>You <a data-primary="asynchronous programming" data-secondary="synchronous results from" data-type="indexterm" id="ch2r1011a"/><a data-primary="tasks" data-secondary="synchronous results from" data-type="indexterm" id="ch2r1011b"/><a data-primary="ValueTask type" data-type="indexterm" id="ch2r1011c"/>need to implement a method that returns <code>ValueTask&lt;T&gt;</code>.</p>
</div></section>













<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458704375160">
<h2>Solution</h2>

<p><code>ValueTask&lt;T&gt;</code> is used as a return type in scenarios where there’s usually a synchronous result that can be returned and asynchronous behavior is more rare. As a general rule, for your own application code, you should use <code>Task&lt;T&gt;</code> as a return type and not <code>ValueTask&lt;T&gt;</code>. Only consider using <code>ValueTask&lt;T&gt;</code> as a return type in your own application after profiling shows that you’d see a performance increase. That said, there are situations where you need to implement a method that returns <code>ValueTask&lt;T&gt;</code>. One <a data-primary="IAsyncDisposable.DisposeAsync method" data-type="indexterm" id="idm45458704370920"/>such situation is <code>IAsyncDisposable</code>, whose <code>DisposeAsync</code> method returns <code>ValueTask</code>. See <a data-type="xref" href="ch11.html#recipe-oop-dispose">Recipe 11.6</a> for a more detailed discussion of asynchronous disposal.</p>

<p>The easiest way to implement a method that returns <code>ValueTask&lt;T&gt;</code> is to use <code>async</code> and <code>await</code> just like a normal <code>async</code> method:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">async</code> <code class="n">ValueTask</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">MethodAsync</code><code class="p">()</code>
<code class="p">{</code>
  <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="m">100</code><code class="p">);</code> <code class="c1">// asynchronous work.</code>
  <code class="k">return</code> <code class="m">13</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>Many times a method returning <code>ValueTask&lt;T&gt;</code> is capable of returning a value immediately; in that case, you can optimize for that scenario using the <code>ValueTask&lt;T&gt;</code> constructor, and then forward to the slow asynchronous method only if necessary:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="n">ValueTask</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">MethodAsync</code><code class="p">()</code>
<code class="p">{</code>
  <code class="k">if</code> <code class="p">(</code><code class="n">CanBehaveSynchronously</code><code class="p">)</code>
    <code class="k">return</code> <code class="k">new</code> <code class="n">ValueTask</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;(</code><code class="m">13</code><code class="p">);</code>
  <code class="k">return</code> <code class="k">new</code> <code class="n">ValueTask</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;(</code><code class="n">SlowMethodAsync</code><code class="p">());</code>
<code class="p">}</code>

<code class="k">private</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">SlowMethodAsync</code><code class="p">();</code></pre>

<p>A similar approach is possible for the nongeneric <code>ValueTask</code>. Here, the <code>ValueTask</code> default constructor is used to return a successfully completed <code>ValueTask</code>. The following example shows an <code>IAsyncDisposable</code> implementation that only runs its asynchronous disposal logic once; on future invocations, the <code>DisposeAsync</code> method completes successfully and synchronously:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="k">private</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">Task</code><code class="p">&gt;</code> <code class="n">_disposeLogic</code><code class="p">;</code>

<code class="k">public</code> <code class="n">ValueTask</code> <code class="nf">DisposeAsync</code><code class="p">()</code>
<code class="p">{</code>
  <code class="k">if</code> <code class="p">(</code><code class="n">_disposeLogic</code> <code class="p">==</code> <code class="k">null</code><code class="p">)</code>
    <code class="k">return</code> <code class="k">default</code><code class="p">;</code>

  <code class="c1">// Note: this simple example is not threadsafe;</code>
  <code class="c1">//  if multiple threads call DisposeAsync,</code>
  <code class="c1">//  the logic could run more than once.</code>
  <code class="n">Func</code><code class="p">&lt;</code><code class="n">Task</code><code class="p">&gt;</code> <code class="n">logic</code> <code class="p">=</code> <code class="n">_disposeLogic</code><code class="p">;</code>
  <code class="n">_disposeLogic</code> <code class="p">=</code> <code class="k">null</code><code class="p">;</code>
  <code class="k">return</code> <code class="k">new</code> <code class="nf">ValueTask</code><code class="p">(</code><code class="n">logic</code><code class="p">());</code>
<code class="p">}</code></pre>
</div></section>













<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458704215528">
<h2>Discussion</h2>

<p>Most of your methods should return <code>Task&lt;T&gt;</code>, since consuming <code>Task&lt;T&gt;</code> has fewer pitfalls than consuming <code>ValueTask&lt;T&gt;</code>. See <a data-type="xref" href="#recipe-async-consume-valuetask">Recipe 2.11</a> for details on these pitfalls.</p>

<p>Most often, if you’re just implementing interfaces that use <code>ValueTask</code> or <code>ValueTask&lt;T&gt;</code>, then you can simply use <code>async</code> and <code>await</code>. The more advanced implementations are for when you want to use <code>ValueTask&lt;T&gt;</code> yourself.</p>

<p>The approaches covered in this recipe are the simpler and more common approaches to creating <code>ValueTask&lt;T&gt;</code> and <code>ValueTask</code> instances. There is another approach more suitable to more advanced scenarios, when you need to absolutely minimize the allocations used. This <a data-primary="IValueTaskSource type" data-type="indexterm" id="idm45458704157800"/><a data-primary="ManualResetValueTaskSourceCore type" data-type="indexterm" id="idm45458704157096"/>more advanced approach enables you to cache or pool an <code>IValueTaskSource&lt;T&gt;</code> implementation and reuse it for multiple asynchronous method invocations. To get started with the advanced scenario, see the <a href="http://bit.ly/man-reset-type-doc">Microsoft docs for the <code>ManualResetValueTaskSourceCore&lt;T&gt;</code> type</a>.</p>
</div></section>













<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458704154472">
<h2>See Also</h2>

<p><a data-type="xref" href="#recipe-async-consume-valuetask">Recipe 2.11</a> covers limitations of consuming <code>ValueTask&lt;T&gt;</code> and <code>ValueTask</code> types.</p>

<p><a data-type="xref" href="ch11.html#recipe-oop-dispose">Recipe 11.6</a> covers asynchronous disposal.</p>
</div></section>





</div></section>













<section class="recipe" data-pdf-bookmark="2.11 Consuming a ValueTask" data-type="sect1"><div class="sect1" id="recipe-async-consume-valuetask">
<h1>2.11 Consuming a ValueTask</h1>








<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458704148360">
<h2>Problem</h2>

<p>You need to consume a <code>ValueTask&lt;T&gt;</code> value.</p>
</div></section>













<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458704146296">
<h2>Solution</h2>

<p>Using <code>await</code> is the most straightforward and common way to consume a <code>ValueTask&lt;T&gt;</code> or <code>ValueTask</code> value. The majority of the time, this is all you need to do:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="n">ValueTask</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">MethodAsync</code><code class="p">();</code>

<code class="k">async</code> <code class="n">Task</code> <code class="nf">ConsumingMethodAsync</code><code class="p">()</code>
<code class="p">{</code>
  <code class="kt">int</code> <code class="k">value</code> <code class="p">=</code> <code class="k">await</code> <code class="n">MethodAsync</code><code class="p">();</code>
<code class="p">}</code></pre>

<p>You can also do the <code>await</code> after doing a concurrent operation, as with <code>Task&lt;T&gt;</code>:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="n">ValueTask</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">MethodAsync</code><code class="p">();</code>

<code class="k">async</code> <code class="n">Task</code> <code class="nf">ConsumingMethodAsync</code><code class="p">()</code>
<code class="p">{</code>
  <code class="n">ValueTask</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">valueTask</code> <code class="p">=</code> <code class="n">MethodAsync</code><code class="p">();</code>
  <code class="p">...</code> <code class="c1">// other concurrent work</code>
  <code class="kt">int</code> <code class="k">value</code> <code class="p">=</code> <code class="k">await</code> <code class="n">valueTask</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>Both of these are appropriate because the <code>ValueTask</code> is only awaited a single time. This is one of the restrictions of <code>ValueTask</code>.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>A <code>ValueTask</code> or <code>ValueTask&lt;T&gt;</code> may only be awaited once.</p>
</div>

<p>To <a data-primary="AsTask method" data-type="indexterm" id="idm45458704040168"/>do anything more complex, convert the <code>ValueTask&lt;T&gt;</code> into a <code>Task&lt;T&gt;</code> by calling <code>AsTask</code>:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="n">ValueTask</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">MethodAsync</code><code class="p">();</code>

<code class="k">async</code> <code class="n">Task</code> <code class="nf">ConsumingMethodAsync</code><code class="p">()</code>
<code class="p">{</code>
  <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">task</code> <code class="p">=</code> <code class="n">MethodAsync</code><code class="p">().</code><code class="n">AsTask</code><code class="p">();</code>
  <code class="p">...</code> <code class="c1">// other concurrent work</code>
  <code class="kt">int</code> <code class="k">value</code> <code class="p">=</code> <code class="k">await</code> <code class="n">task</code><code class="p">;</code>
  <code class="kt">int</code> <code class="n">anotherValue</code> <code class="p">=</code> <code class="k">await</code> <code class="n">task</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>It’s perfectly safe to <code>await</code> a <code>Task&lt;T&gt;</code> multiple times. You can do other things with it, too, like asynchronously wait for multiple operations to complete (see <a data-type="xref" href="#recipe-async-whenall">Recipe 2.4</a>):</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="n">ValueTask</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">MethodAsync</code><code class="p">();</code>

<code class="k">async</code> <code class="n">Task</code> <code class="nf">ConsumingMethodAsync</code><code class="p">()</code>
<code class="p">{</code>
  <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">task1</code> <code class="p">=</code> <code class="n">MethodAsync</code><code class="p">().</code><code class="n">AsTask</code><code class="p">();</code>
  <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">task2</code> <code class="p">=</code> <code class="n">MethodAsync</code><code class="p">().</code><code class="n">AsTask</code><code class="p">();</code>
  <code class="kt">int</code><code class="p">[]</code> <code class="n">results</code> <code class="p">=</code> <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">WhenAll</code><code class="p">(</code><code class="n">task1</code><code class="p">,</code> <code class="n">task2</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>However, for each <code>ValueTask&lt;T&gt;</code>, you can only call <code>AsTask</code> once. The usual approach is to convert it to a <code>Task&lt;T&gt;</code> immediately and then ignore the <code>ValueTask&lt;T&gt;</code>. Also note that you cannot both <code>await</code> and call <code>AsTask</code> on the same <code>ValueTask&lt;T&gt;</code>.</p>

<p>Most code should either immediately <code>await</code> a <code>ValueTask&lt;T&gt;</code> or convert it to a <code>Task&lt;T&gt;</code>.</p>
</div></section>













<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458704145640">
<h2>Discussion</h2>

<p>Other properties on <code>ValueTask&lt;T&gt;</code> are for more advanced usage. They don’t tend to act like other properties you may be familiar with; in particular, <code>ValueTask&lt;T&gt;.Result</code> has more restrictions than <code>Task&lt;T&gt;.Result</code>. Code that synchronously retrieves a result from a <code>ValueTask&lt;T&gt;</code> may call <code>ValueTask&lt;T&gt;.Result</code> or <code>ValueTask&lt;T&gt;.GetAwaiter().GetResult()</code>, but these members must not be called until the <code>ValueTask&lt;T&gt;</code> is complete. Synchronously retrieving a result from <code>Task&lt;T&gt;</code> blocks the calling thread until the task completes; <code>ValueTask&lt;T&gt;</code> makes no such guarantees.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Synchronously getting results from a <code>ValueTask</code> or <code>ValueTask&lt;T&gt;</code> may only be done once, after the <code>ValueTask</code> has completed, and that same <code>ValueTask</code> cannot be awaited or converted to a task.</p>
</div>

<p>At the risk of being repetitive, when your code calls a method returning <code>ValueTask</code> or <code>ValueTask&lt;T&gt;</code>, it should either immediately <code>await</code> that <code>ValueTask</code> or immediately call <code>AsTask</code> to convert it to a <code>Task</code>. This simple guideline doesn’t cover all the advanced scenarios, but most applications will never need to do more than <a data-startref="ch2r1011a" data-type="indexterm" id="idm45458703874808"/><a data-startref="ch2r1011b" data-type="indexterm" id="idm45458703874104"/><a data-startref="ch2r1011c" data-type="indexterm" id="idm45458703873432"/>that.</p>
</div></section>













<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458703872504">
<h2>See Also</h2>

<p><a data-type="xref" href="#recipe-async-implement-valuetask">Recipe 2.10</a> covers how to return <code>ValueTask&lt;T&gt;</code> and <code>ValueTask</code> values from your methods.</p>

<p>Recipes <a data-type="xref" data-xrefstyle="select:labelnumber" href="#recipe-async-whenall">2.4</a> and
<a data-type="xref" data-xrefstyle="select:labelnumber" href="#recipe-async-whenany">2.5</a> cover waiting for multiple tasks simultaneously.</p>
</div></section>





</div></section>







</div></section></body></html>