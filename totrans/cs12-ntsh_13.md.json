["```cs\n#define TESTMODE            // #define directives must be at top of file\n                            // Symbol names are uppercase by convention.\nusing System;\n\nclass Program\n{\n  static void Main()\n  {\n#if TESTMODE\n    Console.WriteLine (\"in test mode!\");     // OUTPUT: in test mode!\n#endif\n  }\n}\n```", "```cs\n#if TESTMODE && !PLAYMODE      // if TESTMODE and not PLAYMODE\n  ...\n```", "```cs\n<PropertyGroup>\n  <DefineConstants>TESTMODE;PLAYMODE</DefineConstants>\n</PropertyGroup>\n```", "```cs\nstatic internal bool TestMode = true;\n\nstatic void Main()\n{\n  if (TestMode) Console.WriteLine (\"in test mode!\");\n}\n```", "```cs\n    using TestType =\n      #if V2\n         MyCompany.Widgets.GadgetV2;\n      #else\n         MyCompany.Widgets.Gadget;\n      #endif\n    ```", "```cs\nstatic void LogStatus (string msg)\n{\n  string logFilePath = ...\n  System.IO.File.AppendAllText (logFilePath, msg + \"\\r\\n\");\n}\n```", "```cs\n#if LOGGINGMODE\nLogStatus (\"Message Headers: \" + GetMsgHeaders());\n#endif\n```", "```cs\nLogStatus (\"Message Headers: \" + GetComplexMessageHeaders());\n```", "```cs\n[Conditional (\"LOGGINGMODE\")]\nstatic void LogStatus (string msg)\n{\n  ...\n}\n```", "```cs\nusing System;\nusing System.Linq;\n\nclass Program\n{\n  public static bool EnableLogging;\n\n  static void LogStatus (Func<string> message)\n  {\n    string logFilePath = ...\n    if (EnableLogging)\n      System.IO.File.AppendAllText (logFilePath, message() + \"\\r\\n\");\n  }\n}\n```", "```cs\nLogStatus ( () => \"Message Headers: \" + GetComplexMessageHeaders() );\n```", "```cs\nAll methods of the Debug class are defined with [Conditional(\"DEBUG\")].\nAll methods of the Trace class are defined with [Conditional(\"TRACE\")].\n```", "```cs\nDebug.Write     (\"Data\");\nDebug.WriteLine (23 * 34);\nint x = 5, y = 3;\nDebug.WriteIf   (x > y, \"x is greater than y\");\n```", "```cs\nDebug.Fail (\"File data.txt does not exist!\");\n```", "```cs\nDebug.Assert (File.Exists (\"data.txt\"), \"File data.txt does not exist!\");\nvar result = ...\nDebug.Assert (result != null);\n```", "```cs\npublic void ShowMessage (string message)\n{\n  if (message == null) throw new ArgumentNullException (\"message\");\n  ...\n}\n```", "```cs\n// Clear the default listener:\nTrace.Listeners.Clear();\n\n// Add a writer that appends to the trace.txt file:\nTrace.Listeners.Add (new TextWriterTraceListener (\"trace.txt\"));\n\n// Obtain the Console's output stream, then add that as a listener:\nSystem.IO.TextWriter tw = Console.Out;\nTrace.Listeners.Add (new TextWriterTraceListener (tw));\n\n// Set up a Windows Event log source and then create/add listener.\n// CreateEventSource requires administrative elevation, so this would\n// typically be done in application setup.\nif (!EventLog.SourceExists (\"DemoApp\"))\n  EventLog.CreateEventSource (\"DemoApp\", \"Application\");\n\nTrace.Listeners.Add (new EventLogTraceListener (\"DemoApp\"));\n```", "```cs\nTextWriterTraceListener tl = new TextWriterTraceListener (Console.Out);\ntl.TraceOutputOptions = TraceOptions.DateTime | TraceOptions.Callstack;\n```", "```cs\nTrace.TraceWarning (\"Orange alert\");\n\n*DiagTest.vshost.exe Warning: 0 : Orange alert*\n *DateTime=2007-03-08T05:57:13.6250000Z*\n *Callstack=   at System.Environment.GetStackTrace(Exception e, Boolean*\n*needFileInfo)*\n *at System.Environment.get_StackTrace()     at ...*\n```", "```cs\n[DebuggerStepThrough, DebuggerHidden]\nvoid DoWorkProxy()\n{\n  // setup...\n  DoWork();\n  // teardown...\n}\n\nvoid DoWork() {...}   // Real method...\n```", "```cs\nforeach (Process p in Process.GetProcesses())\nusing (p)\n{\n  Console.WriteLine (p.ProcessName);\n  Console.WriteLine (\"   PID:      \" + p.Id);\n  Console.WriteLine (\"   Memory:   \" + p.WorkingSet64);\n  Console.WriteLine (\"   Threads:  \" + p.Threads.Count);\n}\n```", "```cs\npublic void EnumerateThreads (Process p)\n{\n  foreach (ProcessThread pt in p.Threads)\n  {\n    Console.WriteLine (pt.Id);\n    Console.WriteLine (\"   State:    \" + pt.ThreadState);\n    Console.WriteLine (\"   Priority: \" + pt.PriorityLevel);\n    Console.WriteLine (\"   Started:  \" + pt.StartTime);\n    Console.WriteLine (\"   CPU time: \" + pt.TotalProcessorTime);\n  }\n}\n```", "```cs\nstatic void Main() { A (); }\nstatic void A()    { B (); }\nstatic void B()    { C (); }\nstatic void C()\n{\n  StackTrace s = new StackTrace (true);\n\n  Console.WriteLine (\"Total frames:   \" + s.FrameCount);\n  Console.WriteLine (\"Current method: \" + s.GetFrame(0).GetMethod().Name);\n  Console.WriteLine (\"Calling method: \" + s.GetFrame(1).GetMethod().Name);\n  Console.WriteLine (\"Entry method:   \" + s.GetFrame\n                                       (s.FrameCount-1).GetMethod().Name);\n  Console.WriteLine (\"Call Stack:\");\n  foreach (StackFrame f in s.GetFrames())\n    Console.WriteLine (\n      \"  File: \"   + f.GetFileName() +\n      \"  Line: \"   + f.GetFileLineNumber() +\n      \"  Col: \"    + f.GetFileColumnNumber() +\n      \"  Offset: \" + f.GetILOffset() +\n      \"  Method: \" + f.GetMethod().Name);\n}\n```", "```cs\nTotal frames:   4\nCurrent method: C\nCalling method: B\nEntry method: Main\nCall stack:\n  File: C:\\Test\\Program.cs  Line: 15  Col: 4  Offset: 7  Method: C\n  File: C:\\Test\\Program.cs  Line: 12  Col: 22  Offset: 6  Method: B\n  File: C:\\Test\\Program.cs  Line: 11  Col: 22  Offset: 6  Method: A\n  File: C:\\Test\\Program.cs  Line: 10  Col: 25  Offset: 6  Method: Main\n```", "```cs\n   at DebugTest.Program.C() in C:\\Test\\Program.cs:line 16\n   at DebugTest.Program.B() in C:\\Test\\Program.cs:line 12\n   at DebugTest.Program.A() in C:\\Test\\Program.cs:line 11\n   at DebugTest.Program.Main() in C:\\Test\\Program.cs:line 10\n```", "```cs\nconst string SourceName = \"MyCompany.WidgetServer\";\n\n// CreateEventSource requires administrative permissions, so this would\n// typically be done in application setup.\nif (!EventLog.SourceExists (SourceName))\n  EventLog.CreateEventSource (SourceName, \"Application\");\n\nEventLog.WriteEntry (SourceName,\n  \"Service started; using configuration file=...\",\n  EventLogEntryType.Information);\n```", "```cs\nEventLog log = new EventLog (\"Application\");\n\nConsole.WriteLine (\"Total entries: \" + log.Entries.Count);\n\nEventLogEntry last = log.Entries [log.Entries.Count - 1];\nConsole.WriteLine (\"Index:   \" + last.Index);\nConsole.WriteLine (\"Source:  \" + last.Source);\nConsole.WriteLine (\"Type:    \" + last.EntryType);\nConsole.WriteLine (\"Time:    \" + last.TimeWritten);\nConsole.WriteLine (\"Message: \" + last.Message);\n```", "```cs\nforeach (EventLog log in EventLog.GetEventLogs())\n  Console.WriteLine (log.LogDisplayName);\n```", "```cs\nusing (var log = new EventLog (\"Application\"))\n{\n  log.EnableRaisingEvents = true;\n  log.EntryWritten += DisplayEntry;\n  Console.ReadLine();\n}\n\nvoid DisplayEntry (object sender, EntryWrittenEventArgs e)\n{\n  EventLogEntry entry = e.Entry;\n  Console.WriteLine (entry.Message);\n}\n```", "```cs\nPerformanceCounterCategory[] cats =\n  PerformanceCounterCategory.GetCategories();\n\nforeach (PerformanceCounterCategory cat in cats)\n{\n  Console.WriteLine (\"Category: \" + cat.CategoryName);\n\n  string[] instances = cat.GetInstanceNames();\n  if (instances.Length == 0)\n  {\n    foreach (PerformanceCounter ctr in cat.GetCounters())\n      Console.WriteLine (\"  Counter: \" + ctr.CounterName);\n  }\n  else   // Dump counters with instances\n  {\n    foreach (string instance in instances)\n    {\n      Console.WriteLine (\"  Instance: \" + instance);\n      if (cat.InstanceExists (instance))\n        foreach (PerformanceCounter ctr in cat.GetCounters (instance))\n          Console.WriteLine (\"    Counter: \" + ctr.CounterName);\n    }\n  }\n}\n```", "```cs\nvar x =\n  new XElement (\"counters\",\n    from PerformanceCounterCategory cat in\n         PerformanceCounterCategory.GetCategories()\n    where cat.CategoryName.StartsWith (\".NET\")\n    let instances = cat.GetInstanceNames()\n    select new XElement (\"category\",\n      new XAttribute (\"name\", cat.CategoryName),\n      instances.Length == 0\n      ?\n        from c in cat.GetCounters()\n        select new XElement (\"counter\",\n          new XAttribute (\"name\", c.CounterName))\n      :\n        from i in instances\n        select new XElement (\"instance\", new XAttribute (\"name\", i),\n          !cat.InstanceExists (i)\n          ?\n            null\n          :\n            from c in cat.GetCounters (i)\n            select new XElement (\"counter\",\n              new XAttribute (\"name\", c.CounterName))\n        )\n    )\n  );\nx.Save (\"counters.xml\");\n```", "```cs\nusing PerformanceCounter pc = new PerformanceCounter (\"Processor\",\n                                                      \"% Processor Time\",\n                                                      \"_Total\");\nConsole.WriteLine (pc.NextValue());\n```", "```cs\nstring procName = Process.GetCurrentProcess().ProcessName;\nusing PerformanceCounter pc = new PerformanceCounter (\"Process\",\n                                                      \"Private Bytes\",\n                                                      procName);\nConsole.WriteLine (pc.NextValue());\n```", "```cs\n// need to import System.Threading as well as System.Diagnostics\n\nstatic void Monitor (string category, string counter, string instance,\n                     EventWaitHandle stopper)\n{\n  if (!PerformanceCounterCategory.Exists (category))\n    throw new InvalidOperationException (\"Category does not exist\");\n\n  if (!PerformanceCounterCategory.CounterExists (counter, category))\n    throw new InvalidOperationException (\"Counter does not exist\");\n\n  if (instance == null) instance = \"\";   // \"\" == no instance (not null!)\n  if (instance != \"\" &&\n      !PerformanceCounterCategory.InstanceExists (instance, category))\n    throw new InvalidOperationException (\"Instance does not exist\");\n\n  float lastValue = 0f;\n  using (PerformanceCounter pc = new PerformanceCounter (category,\n                                                      counter, instance))\n    while (!stopper.WaitOne (200, false))\n    {\n      float value = pc.NextValue();\n      if (value != lastValue)         // Only write out the value\n      {                               // if it has changed.\n        Console.WriteLine (value);\n        lastValue = value;\n      }\n    }\n}\n```", "```cs\nEventWaitHandle stopper = new ManualResetEvent (false);\n\nnew Thread (() =>\n  Monitor (\"Processor\", \"% Processor Time\", \"_Total\", stopper)\n).Start();\n\nnew Thread (() =>\n  Monitor (\"LogicalDisk\", \"% Idle Time\", \"C:\", stopper)\n).Start();\n\nConsole.WriteLine (\"Monitoring - press any key to quit\");\nConsole.ReadKey();\nstopper.Set();\n```", "```cs\nstring category = \"Nutshell Monitoring\";\n\n// We'll create two counters in this category:\nstring eatenPerMin = \"Macadamias eaten so far\";\nstring tooHard = \"Macadamias deemed too hard\";\n\nif (!PerformanceCounterCategory.Exists (category))\n{\n  CounterCreationDataCollection cd = new CounterCreationDataCollection();\n\n  cd.Add (new CounterCreationData (eatenPerMin,\n          \"Number of macadamias consumed, including shelling time\",\n          PerformanceCounterType.NumberOfItems32));\n\n  cd.Add (new CounterCreationData (tooHard,\n          \"Number of macadamias that will not crack, despite much effort\",\n          PerformanceCounterType.NumberOfItems32));\n\n  PerformanceCounterCategory.Create (category, \"Test Category\",\n    PerformanceCounterCategoryType.SingleInstance, cd);\n}\n```", "```cs\nstring category = \"Nutshell Monitoring\";\nstring eatenPerMin = \"Macadamias eaten so far\";\n\nusing (PerformanceCounter pc = new PerformanceCounter (category,\n                                                       eatenPerMin, \"\"))\n{\n  pc.ReadOnly = false;\n  pc.RawValue = 1000;\n  pc.Increment();\n  pc.IncrementBy (10);\n  Console.WriteLine (pc.NextValue());    // 1011\n}\n```", "```cs\nStopwatch s = Stopwatch.StartNew();\nSystem.IO.File.WriteAllText (\"test.txt\", new string ('*', 30000000));\nConsole.WriteLine (s.Elapsed);       // 00:00:01.4322661\n```", "```cs\ndotnet tool install --global dotnet-counters\n```", "```cs\ndotnet-counters monitor System.Runtime --process-id *<<ProcessID>>*\n```", "```cs\nPress p to pause, r to resume, q to quit.\n    Status: Running\n\n[System.Runtime]\n    # of Assemblies Loaded                            63\n    % Time in GC (since last GC)                       0\n    Allocation Rate (Bytes / sec)                244,864\n    CPU Usage (%)                                      6\n    Exceptions / sec                                   0\n    GC Heap Size (MB)                                  8\n    Gen 0 GC / sec                                     0\n    Gen 0 Size (B)                               265,176\n    Gen 1 GC / sec                                     0\n    Gen 1 Size (B)                               451,552\n    Gen 2 GC / sec                                     0\n    Gen 2 Size (B)                                    24\n    LOH Size (B)                               3,200,296\n    Monitor Lock Contention Count / sec                0\n    Number of Active Timers                            0\n    ThreadPool Completed Work Items / sec             15\n    ThreadPool Queue Length                            0\n    ThreadPool Threads Count                           9\n    Working Set (MB)                                  52\n```", "```cs\ndotnet tool install --global dotnet-trace\n```", "```cs\ndotnet-trace collect --process-id *<<ProcessId>>*\n```", "```cs\n[EventSource (Name = \"MyTestSource\")]\npublic sealed class MyEventSource : EventSource\n{\n  public static MyEventSource Instance = new MyEventSource ();\n\n  MyEventSource() : base (EventSourceSettings.EtwSelfDescribingEventFormat)\n  {\n  }\n\n  public void Log (string message, int someNumber)\n  {\n    WriteEvent (1, message, someNumber);\n  }\n}\n```", "```cs\nMyEventSource.Instance.Log (\"Something\", 123);\n```", "```cs\ndotnet-trace collect --process-id *<<ProcessId>>* --providers MyTestSource\n```", "```cs\nulimit -c unlimited\n```", "```cs\nSOFTWARE\\Microsoft\\Windows\\Windows Error Reporting\\LocalDumps\n```", "```cs\ndotnet tool install --global dotnet-dump\n```", "```cs\ndotnet-dump collect --process-id *<<YourProcessId>>*\n```", "```cs\ndotnet-dump analyze *<<dumpfile>>*\n```"]