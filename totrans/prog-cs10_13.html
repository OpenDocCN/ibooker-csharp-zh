<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 13. Reflection" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_reflection">
<h1><span class="label">Chapter 13. </span>Reflection</h1>
<p><a data-primary="reflection" data-type="indexterm" id="ix_ch13-asciidoc0"/>The CLR knows a great deal about the types our programs define and use. It requires all assemblies to provide detailed metadata, describing each member of every type, including private implementation details. It relies on this information to perform critical functions, such as JIT compilation and garbage collection. However, it does not keep this knowledge to itself. The <em>reflection</em> API grants access to this detailed type information, so your code can discover everything that the runtime can see. Moreover, you can use reflection to make things happen. For example, a reflection object representing a method not only describes the method’s name and signature, but it also lets you invoke the method. And  you can go further still and generate code at runtime.</p>
<p>Reflection is particularly useful in extensible frameworks, because they can use it to adapt their behavior at runtime based on the structure of your code. For example, Visual Studio’s Properties panel uses reflection to discover what public properties a component offers, so if you write a component that can appear on a design surface, such as a UI element, you do not need to do anything special to make its properties available for editing—Visual Studio will find them automatically.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Many reflection-based frameworks that can automatically discover what they need to know also allow components to enrich that information explicitly. For example, although you don’t need to do anything special to support editing in the Properties panel, you can customize the categorization, description, and editing mechanisms if you want to. This is normally achieved with <em>attributes</em>, which are the topic of <a data-type="xref" href="ch14.xhtml#ch_attributes">Chapter 14</a>.</p>
</div>
<section data-pdf-bookmark="Reflection Types" data-type="sect1"><div class="sect1" id="reflection_types">
<h1>Reflection Types</h1>
<p><a data-primary="reflection" data-secondary="types" data-type="indexterm" id="ix_ch13-asciidoc1"/><a data-primary="types" data-secondary="reflection" data-type="indexterm" id="ix_ch13-asciidoc2"/>The reflection API defines various classes in the <code>System.Reflection</code> namespace. These classes have a structural relationship that mirrors the way that assemblies and the type system work. For example, a type’s containing assembly is part of its identity, so the reflection class that represents a type (<code>Type</code><sup><a data-type="noteref" href="ch13.xhtml#idm45884795200512" id="idm45884795200512-marker">1</a></sup>) has an <code>Assembly</code> property that returns its containing <code>Assembly</code> object. And you can navigate this relationship in both directions—you can discover all of the types in an assembly from the <code>Assembly</code> class’s <code>DefinedTypes</code> property. An application that can be extended by loading plug-in DLLs would typically use this to find the types each plug-in provides. <a data-type="xref" href="#reflection_containment_hierarchy">Figure 13-1</a> shows the reflection types that correspond to .NET types, their members, and the components that contain them. The arrows represent containment relationships. (As with assemblies and types, these are all navigable in both directions.)</p>
<figure><div class="figure" id="reflection_containment_hierarchy">
<img alt="" height="321" src="assets/pc10_1301.png" width="600"/>
<h6><span class="label">Figure 13-1. </span>Reflection containment hierarchy</h6>
</div></figure>
<p><a data-type="xref" href="#reflection_inheritance_hierarchy">Figure 13-2</a> illustrates the inheritance hierarchy for these types. This shows a couple of extra abstract types, <code>MemberInfo</code> and <code>MethodBase</code>, which are shared by various reflection classes that have a certain amount in common. For example, constructors and methods both have parameter lists, and the mechanism for inspecting these is provided by their shared base class, <code>MethodBase</code>. All members of types have certain common features, such as accessibility, so anything that is (or can be) a member of a type is represented in reflection by an object that derives from <code>MemberInfo</code>.</p>
<figure><div class="figure" id="reflection_inheritance_hierarchy">
<img alt="" height="210" src="assets/pc10_1302.png" width="600"/>
<h6><span class="label">Figure 13-2. </span>Reflection inheritance hierarchy</h6>
</div></figure>
<section data-pdf-bookmark="Assembly" data-type="sect2"><div class="sect2" id="assembly">
<h2>Assembly</h2>
<p><a data-primary="Assembly class" data-type="indexterm" id="ix_ch13-asciidoc3"/><a data-primary="reflection" data-secondary="Assembly" data-type="indexterm" id="ix_ch13-asciidoc4"/>The <code>Assembly</code> class represents, predictably enough, a single assembly. If you’re writing a plug-in system, or some other sort of framework that needs to load user-supplied DLLs and use them (such as a unit test runner), the <code>Assembly</code> type will be your starting point. As <a data-type="xref" href="ch12.xhtml#ch_assemblies">Chapter 12</a> showed, the static <code>Assembly.Load</code> method takes an assembly name and returns the object for that assembly. (That method will load the assembly if necessary, but if it has already been loaded, it just returns a reference to the relevant <code>Assembly</code> object.) But there are some other ways to get hold of objects of this kind.</p>
<p>The <code>Assembly</code> class defines three context-sensitive static methods that each return an <code>Assembly</code>. The <code>GetEntryAssembly</code> method returns the object representing the EXE file containing your program’s <code>Main</code> method. The <code>GetExecutingAssembly</code> method returns the assembly that contains the method from which you called it. <code>GetCallin⁠g​Assembly</code> walks up the stack by one level and returns the assembly containing the code that called the method that called <code>GetCallingAssembly</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The JIT compiler’s optimizations can sometimes produce surprising results with <code>GetExecutingAssembly</code> and <code>GetCallingAssembly</code>. Method inlining and tail call optimizations can both cause these methods to return the assembly for methods that are one stack frame farther back than you would expect. You can prevent inlining optimizations by <span class="keep-together">annotating</span> a method with the <code>MethodImpl​At⁠tribute</code>, passing the <code>NoInlining</code> flag from the <code>MethodImpl​Options</code> enumeration. (Attributes are described in <a data-type="xref" href="ch14.xhtml#ch_attributes">Chapter 14</a>.) There’s no way to disable tail call optimizations explicitly, but those will be applied only when a particular method call is the last thing a method does before returning.</p>
</div>
<p><code>GetCallingAssembly</code> can be useful in diagnostic logging, because it provides information about the code that called your method. The 
<span class="keep-together"><code>GetExecutingAssembly</code></span> method is less useful: you presumably already know which assembly the code will be in because you’re the developer writing it. It may still be useful to get hold of the <code>Assembly</code> object for the component you’re writing, but there are other ways. The <code>Type</code> object described in the next section provides an <code>Assembly</code> property. <a data-type="xref" href="#obtaining_your_own_assembly_via_a_type">Example 13-1</a> uses that to get the <code>Assembly</code> via the containing class. Empirically, this seems to be faster, which is not entirely surprising because it’s doing less work—both techniques need to retrieve reflection objects, but one of them also has to inspect the stack.<a data-primary="typeof operator" data-secondary="assemblies" data-type="indexterm" id="idm45884795167776"/></p>
<div data-type="example" id="obtaining_your_own_assembly_via_a_type">
<h5><span class="label">Example 13-1. </span>Obtaining your own <code>Assembly</code> via a <code>Type</code></h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="k">class</code> <code class="nc">Program</code>
<code class="p">{</code>
    <code class="k">static</code> <code class="k">void</code> <code class="nf">Main</code><code class="p">(</code><code class="p">)</code>
    <code class="p">{</code>
        <strong><code class="n">Assembly</code> <code class="n">me</code> <code class="p">=</code> <code class="k">typeof</code><code class="p">(</code><code class="n">Program</code><code class="p">)</code><code class="p">.</code><code class="n">Assembly</code><code class="p">;</code></strong>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">me</code><code class="p">.</code><code class="n">FullName</code><code class="p">)</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p><a data-primary="MetadataLoadContext class" data-type="indexterm" id="idm45884795129200"/>If you want to use an assembly from a specific place on disk, you can use the 
<span class="keep-together"><code>LoadFrom</code> method</span> described in <a data-type="xref" href="ch12.xhtml#ch_assemblies">Chapter 12</a>. Alternatively, you can use the <code>System​.Reflec⁠tion.MetadataLoadContext</code> NuGet package’s <code>MetadataLoadContext</code> class. This loads the assembly in such a way that you can inspect its type information, but no code in the assembly will execute, nor will any assemblies it depends on be loaded automatically. This is an appropriate way to load an assembly if you’re writing a tool that displays or otherwise processes information about a component but does not want to run its code. There are a few reasons it can be important to avoid loading an assembly in the usual way with such a tool. Loading an assembly and inspecting its types can sometimes trigger the execution of code (such as static constructors) in that assembly. Also, if you load for reflection purposes only, the processor architecture is not significant, so you could load a 32-bit-only DLL into a 64-bit process, or you could inspect an ARM-only <span class="keep-together">assembly</span> in an x86 process.</p>
<p>Having obtained an <code>Assembly</code> from any of the aforementioned mechanisms, you can discover various things about it. The <code>FullName</code> property provides the display name, for example. Or you can call <code>GetName</code>, which returns an <code>AssemblyName</code> object, providing easy programmatic access to all of the components of the assembly’s name.</p>
<p>You can retrieve a list of all of the other assemblies on which a particular <code>Assembly</code> depends by calling <code>GetReferencedAssemblies</code>. If you call this on an assembly you’ve written, it will not necessarily return all of the assemblies you can see in the Dependencies node in Visual Studio’s Solution Explorer, because the C# compiler strips out unused references.</p>
<p>Assemblies contain types, so you can find <code>Type</code> objects representing those types by calling an <code>Assembly</code> object’s <code>GetType</code> method, passing in the name of the type you require, including its namespace. This will return <code>null</code> if the type is not found, unless you call one of the overloads that additionally accept a <code>bool</code>—with these, passing <code>true</code> produces an exception if the type is not found. There’s also an overload that takes two <code>bool</code> arguments, the second of which lets you pass <code>true</code> to request a case-insensitive search. All of these methods will return either <code>public</code> or <code>internal</code> types. You can also request a nested type, by specifying the name of the containing type, then a <code>+</code> symbol, then the nested type name. <a data-type="xref" href="#getting_a_nested_type_from_an_assembly">Example 13-2</a> gets the <code>Type</code> object for a type called <code>Inside</code> nested inside a type called <code>ContainingType</code> in the <code>MyLib</code> namespace. This works even if the nested type is private.</p>
<div data-type="example" id="getting_a_nested_type_from_an_assembly">
<h5><span class="label">Example 13-2. </span>Getting a nested type from an assembly</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">Type</code><code class="p">?</code> <code class="n">nt</code> <code class="p">=</code> <code class="n">someAssembly</code><code class="p">.</code><code class="n">GetType</code><code class="p">(</code><code class="s">"MyLib.ContainingType+Inside"</code><code class="p">);</code></pre></div>
<p><a data-primary="public types" data-type="indexterm" id="idm45884795081360"/>The <code>Assembly</code> class also provides a <code>DefinedTypes</code> property that returns a collection containing a <code>TypeInfo</code> object for every type (top-level or nested) the assembly defines, and also <code>ExportedTypes</code>, which returns only public types, and it returns <code>Type</code> objects and not full <code>TypeInfo</code> objects. (The distinction between <code>TypeInfo</code> and <code>Type</code> is described in <a data-type="xref" href="#type_and_typeinfo">“Type and TypeInfo”</a>.) That will also include any <code>public</code> nested types. It will not include <code>protected</code> types nested inside <code>public</code> types, which is perhaps a bit surprising because such types are accessible from outside the assembly (albeit only to classes that derive from the containing type).</p>
<p>Besides returning types, <code>Assembly</code> can also create new instances of them with the <code>CreateInstance</code> method. If you pass just the fully qualified name of the type as a string, this will create an instance if the type is public and has a no-arguments constructor. There’s an overload that lets you work with nonpublic types and types with constructors that require arguments; however, it is rather more complex to use, because it also takes arguments that specify whether you want a case-insensitive match for the type name, along with a <code>CultureInfo</code> object that defines the rules to use for case-insensitive comparisons—different countries have different ideas about how such comparisons work. It also has arguments for controlling more advanced scenarios. However, you can pass <code>null</code> for most of these, as <a data-type="xref" href="#dynamic_construction">Example 13-3</a> shows.</p>
<div data-type="example" id="dynamic_construction">
<h5><span class="label">Example 13-3. </span>Dynamic construction</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">object?</code> <code class="n">o</code> <code class="p">=</code> <code class="n">asm</code><code class="p">.</code><code class="n">CreateInstance</code><code class="p">(</code>
    <code class="s">"MyApp.WithConstructor"</code><code class="p">,</code>
    <code class="k">false</code><code class="p">,</code>
    <code class="n">BindingFlags</code><code class="p">.</code><code class="n">Public</code> <code class="p">|</code> <code class="n">BindingFlags</code><code class="p">.</code><code class="n">Instance</code><code class="p">,</code>
    <code class="k">null</code><code class="p">,</code>
    <code class="k">new</code> <code class="kt">object</code><code class="p">[]</code> <code class="p">{</code> <code class="s">"Constructor argument"</code> <code class="p">},</code>
    <code class="k">null</code><code class="p">,</code>
    <code class="k">null</code><code class="p">);</code></pre></div>
<p>This creates an instance of a type called <code>WithConstructor</code> in the <code>MyApp</code> namespace in the assembly to which <code>asm</code> refers. The <code>false</code> argument indicates that we want an exact match on the name, not a case-insensitive comparison. <a data-primary="BindingFlags enumeration type" data-type="indexterm" id="idm45884794983872"/>The <code>BindingFlags</code> indicate that we are looking for a public instance constructor. (See the sidebar <a href="#bindingflags">“Bind⁠ing​Flags”</a>.) The first <code>null</code> argument is where you could pass a <code>Binder</code> object, which allows you to customize the behavior when the arguments you have supplied do not exactly match the types of the required arguments. By leaving this out, I’m indicating that I expect the ones I’ve supplied to match exactly. (I’ll get an exception if they don’t.) The <code>object[]</code> argument contains the list of arguments I’d like to pass to the constructor—a single string, in this case. The penultimate <code>null</code> is where I’d pass a culture if I were using either case-insensitive comparisons or automatic conversions between numeric types and strings, but since I’m doing neither, I can leave it out. And the final argument once supported scenarios that have now been deprecated, so it should always be <code>null</code>.<a data-startref="ix_ch13-asciidoc4" data-type="indexterm" id="idm45884794971920"/><a data-startref="ix_ch13-asciidoc3" data-type="indexterm" id="idm45884794971312"/></p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="bindingflags">
<h5>BindingFlags</h5>
<p><a data-primary="public members" data-type="indexterm" id="idm45884794969216"/>Many of the reflection APIs take an argument of the <code>BindingFlags</code> enumeration type to determine which members to return. For example, you can specify <code>BindingFlags.Public</code> to indicate that you want only public members or types, or <code>BindingFlags.NonPublic</code> to indicate that you want only items that are not public, or you can combine both flags to indicate that you’d like either.</p>
<p>Be aware that it’s possible to specify combinations that will return nothing. When working with members, you must include either <code>BindingFlags.Instance</code>, <code>BindingFlags.Static</code>, or both, for example, because all type members are one or the other (likewise for <code>BindingFlags.Public</code> and <code>BindingFlags.NonPublic</code>).</p>
<p>Often, methods that can accept <code>BindingFlags</code> offer an overload that does not. This typically defaults to specifying public members, both instance and static (i.e., <code>BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance</code>).</p>
<p><code>BindingFlags</code> defines numerous options, but not all are applicable in every scenario. For example, it defines a <code>FlattenHierarchy</code> value, which is used for reflection APIs that return type members: if this flag is present, members defined by the base class will be considered, as well as those defined by the class specified. This option is not applicable to <code>Assembly.CreateInstance</code> because you cannot use a base class constructor directly to construct a derived type.</p>
</div></aside>
</div></section>
<section data-pdf-bookmark="Module" data-type="sect2"><div class="sect2" id="module">
<h2>Module</h2>
<p><a data-primary="Module class" data-type="indexterm" id="idm45884794960192"/><a data-primary="reflection" data-secondary="Module" data-type="indexterm" id="idm45884794959264"/><a data-type="xref" href="#reflection_containment_hierarchy">Figure 13-1</a> shows <code>Assembly</code> as a container of <code>Module</code> objects. .NET Framework supports splitting the contents of one assembly across multiple files (<em>modules</em>), but this rarely used feature is not supported in .NET Core or .NET. In most cases, you can ignore the <code>Module</code> type—you can normally do everything you need with the other types in the reflection API. One exception is that the APIs for generating code at runtime require you to identify which module should contain the generated code, even when you’re creating just one module. (.NET’s APIs for generating code at runtime are beyond the scope of this book.)</p>
<p>The <code>Module</code> class provides one other service: surprisingly, it defines <code>GetField</code>, 
<span class="keep-together"><code>GetFields</code>,</span> <code>GetMethod</code>, and <code>GetMethods</code> properties. These provide access to globally scoped methods and fields. You never see these in C#, because the language requires all fields and methods to be defined within a type, but the CLR allows globally scoped methods and fields, so the reflection API has to be able to present them. These are exposed through <code>Module</code>, and not <code>Assembly</code>, so even in modern .NET’s one-module-per-assembly world, you can only get to them through the <code>Module</code> type. You can retrieve that from an <code>Assembly</code> object’s <code>Modules</code> property, or you can use any of the API types described in the following sections that derive from <code>MemberInfo</code>. (<a data-type="xref" href="#reflection_inheritance_hierarchy">Figure 13-2</a> shows which types do so.) This defines a <code>Module</code> property that returns the <code>Module</code> in which the relevant member is defined.</p>
</div></section>
<section data-pdf-bookmark="MemberInfo" data-type="sect2"><div class="sect2" id="memberinfo">
<h2>MemberInfo</h2>
<p><a data-primary="MemberInfo class" data-type="indexterm" id="ix_ch13-asciidoc5"/><a data-primary="reflection" data-secondary="MemberInfo" data-type="indexterm" id="ix_ch13-asciidoc6"/>Like all the classes I’m describing in this section, <code>MemberInfo</code> is abstract. However, unlike the rest, it does not correspond to one particular feature of the type system. It is a shared base class providing common functionality for all of the types that represent items that can be members of other types. So this is the base class of <code>ConstructorInfo</code>, <code>MethodInfo</code>, <code>FieldInfo</code>, <code>PropertyInfo</code>, <code>EventInfo</code>, and <code>Type</code>, because all of those can be members of other types. In fact, in C#, all except <code>Type</code> are <em>required</em> to be members of some other type (although, as you just saw in the preceding section, some languages allow methods and fields to be scoped to a module instead of a type).</p>
<p><code>MemberInfo</code> defines common properties required by all type members. There’s a <code>Name</code> property, of course, and also a <code>DeclaringType</code>, which refers to the <code>Type</code> object for the item’s containing type; this returns <code>null</code> for nonnested types and module-scoped methods and fields. <code>MemberInfo</code> also defines a <code>Module</code> property that refers to the containing module, regardless of whether the item in question is module-scoped or a member of a type.</p>
<p>As well as <code>DeclaringType</code>, <code>MemberInfo</code> defines a <code>ReflectedType</code>, which indicates the type from which the <code>MemberInfo</code> was retrieved. These will often be the same but can be different when inheritance is involved. <a data-type="xref" href="#declaringtype_versus_reflectedtype">Example 13-4</a> shows the distinction.<a data-primary="typeof operator" data-secondary="examples of use" data-type="indexterm" id="idm45884794932320"/></p>
<div data-type="example" id="declaringtype_versus_reflectedtype">
<h5><span class="label">Example 13-4. </span><code>DeclaringType</code> versus <code>ReflectedType</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">class</code> <code class="nc">Base</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">void</code> <code class="nf">Foo</code><code class="p">()</code>
    <code class="p">{</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="k">class</code> <code class="nc">Derived</code> <code class="p">:</code> <code class="n">Base</code>
<code class="p">{</code>
<code class="p">}</code>

<code class="k">class</code> <code class="nc">Program</code>
<code class="p">{</code>
    <code class="k">static</code> <code class="k">void</code> <code class="nf">Main</code><code class="p">(</code><code class="kt">string</code><code class="p">[]</code> <code class="n">args</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">MemberInfo</code> <code class="n">bf</code> <code class="p">=</code> <code class="k">typeof</code><code class="p">(</code><code class="n">Base</code><code class="p">).</code><code class="n">GetMethod</code><code class="p">(</code><code class="s">"Foo"</code><code class="p">)!;</code>
        <code class="n">MemberInfo</code> <code class="n">df</code> <code class="p">=</code> <code class="k">typeof</code><code class="p">(</code><code class="n">Derived</code><code class="p">).</code><code class="n">GetMethod</code><code class="p">(</code><code class="s">"Foo"</code><code class="p">)!;</code>

        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Base    Declaring: {0}, Reflected: {1}"</code><code class="p">,</code>
                          <code class="n">bf</code><code class="p">.</code><code class="n">DeclaringType</code><code class="p">,</code> <code class="n">bf</code><code class="p">.</code><code class="n">ReflectedType</code><code class="p">);</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Derived Declaring: {0}, Reflected: {1}"</code><code class="p">,</code>
                          <code class="n">df</code><code class="p">.</code><code class="n">DeclaringType</code><code class="p">,</code> <code class="n">df</code><code class="p">.</code><code class="n">ReflectedType</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>This gets the <code>MethodInfo</code> for the <code>Base.Foo</code> and <code>Derived.Foo</code> methods. (<code>MethodInfo</code> derives from <code>MemberInfo</code>.) These are just different ways of describing the same method—<code>Derived</code> does not define its own <code>Foo</code>, so it inherits the one defined by <code>Base</code>. The program produces this output:</p>
<pre data-type="programlisting">Base    Declaring: Base, Reflected: Base
Derived Declaring: Base, Reflected: Derived</pre>
<p>When retrieving the information for <code>Foo</code> via the <code>Base</code> class’s <code>Type</code> object, the 
<span class="keep-together"><code>DeclaringType</code></span> and <code>ReflectedType</code> are, unsurprisingly, both <code>Base</code>. However, when we retrieve the <code>Foo</code> method’s information via the <code>Derived</code> type, the <code>DeclaringType</code> tells us that the method is defined by <code>Base</code>, while the <code>ReflectedType</code> tells us that we obtained this method via the <code>Derived</code> type.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Because a <code>MemberInfo</code> remembers which type you retrieved it from, comparing two <code>MemberInfo</code> objects is not a reliable way to detect whether they refer to the same thing. Comparing <code>bf</code> and <code>df</code> in <a data-type="xref" href="#declaringtype_versus_reflectedtype">Example 13-4</a> with either the <code>==</code> operator or their <code>Equals</code> method would return <code>false</code> despite the fact that they both refer to <code>Base.Foo</code>. If you had been unaware of the <code>ReflectedType</code> property, you might not have expected this behavior.</p>
</div>
<p>Slightly surprisingly, <code>MemberInfo</code> does not provide any information about the visibility of the member it describes. This may seem odd, because in C#, all of the constructs that correspond to the types that derive from <code>MemberInfo</code> (such as constructors, methods, or properties) can be prefixed with <code>public</code>, <code>private</code>, etc. The reflection API does make this information available but not through the <code>MemberInfo</code> base class. This is because the CLR handles visibility for certain member types a little differently from how C# presents it. From the CLR’s perspective, properties and events do not have an accessibility of their own. Instead, their accessibility is managed at the level of the individual methods. This enables a property’s <code>get</code> and <code>set</code> to have different accessibility levels, and likewise for an event’s accessors. Of course, we can control property accessor accessibility independently in C# if we want to. Where C# misleads us is that it lets us specify a single accessibility level for the entire property. But this is just shorthand for setting both accessors to the same level. The confusing part is that it lets us specify the accessibility for the property and then a different accessibility for one of the members, as <a data-type="xref" href="#property_accessor_accessibility">Example 13-5</a> does.</p>
<div data-type="example" id="property_accessor_accessibility">
<h5><span class="label">Example 13-5. </span>Property accessor accessibility</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="kt">int</code> <code class="n">Count</code>
<code class="p">{</code>
    <code class="k">get</code><code class="p">;</code>
    <code class="k">private</code> <code class="k">set</code><code class="p">;</code>
<code class="p">}</code></pre></div>
<p>This is a bit misleading because, despite how it looks, that <code>public</code> accessibility does not apply to the whole property. This property-level accessibility simply tells the compiler what to use for accessors that don’t specify their own accessibility level. The first version of C# required both property accessors to have the same accessibility, so it made sense to state it for the whole property. (It still has an equivalent restriction for events.) But this was an arbitrary restriction—the CLR has always allowed each accessor to have a different accessibility. C# now supports this, but because of the history, the syntax for exploiting this is misleadingly asymmetric. From the CLR’s point of view, <a data-type="xref" href="#property_accessor_accessibility">Example 13-5</a> just says to make the <code>get public</code> and the <code>set private</code>. <a data-type="xref" href="#how_the_clr_sees_property_accessibility">Example 13-6</a> would be a better representation of what’s really going on.</p>
<div data-type="example" id="how_the_clr_sees_property_accessibility">
<h5><span class="label">Example 13-6. </span>How the CLR sees property accessibility</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="c1">// Won't compile but arguably should</code>
<code class="kt">int</code> <code class="n">Count</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">get</code><code class="p">;</code>
    <code class="k">private</code> <code class="k">set</code><code class="p">;</code>
<code class="p">}</code></pre></div>
<p>But we can’t write it that way, because C# demands that the accessibility for the more visible of the two accessors be stated at the property level. This makes the syntax simpler when both properties have the same accessibility, but it makes things a bit weird when they’re different. Moreover, the syntax in <a data-type="xref" href="#property_accessor_accessibility">Example 13-5</a> (i.e., the syntax the compiler actually supports) makes it look like we should be able to specify accessibility in three places: the property and both of the accessors. The CLR does not support that, so the compiler will produce an error if you try to specify accessibility for both of the accessors. So there is no accessibility for the property or event itself. (Imagine if there were—what would it even mean if a property had <code>public</code> accessibility but its <code>get</code> were <code>internal</code> and its <code>set</code> were <code>private</code>?) Consequently, not everything that derives from <code>MemberInfo</code> has a particular accessibility, so the reflection API provides properties representing accessibility farther down in the class hierarchy.<a data-startref="ix_ch13-asciidoc6" data-type="indexterm" id="idm45884794717280"/><a data-startref="ix_ch13-asciidoc5" data-type="indexterm" id="idm45884794716576"/></p>
</div></section>
<section data-pdf-bookmark="Type and TypeInfo" data-type="sect2"><div class="sect2" id="type_and_typeinfo">
<h2>Type and TypeInfo</h2>
<p><a data-primary="reflection" data-secondary="Type and TypeInfo" data-type="indexterm" id="ix_ch13-asciidoc7"/><a data-primary="Type class" data-secondary="reflection and" data-type="indexterm" id="ix_ch13-asciidoc8"/><a data-primary="TypeInfo class" data-type="indexterm" id="ix_ch13-asciidoc9"/><a data-primary="typeof operator" data-type="indexterm" id="idm45884794709392"/>The <code>Type</code> class represents a particular type. It is more widely used than any of the other classes in this chapter, which is why it alone lives in the <code>System</code> namespace while the rest are defined in <code>System.Reflection</code>. It’s the easiest to get hold of because C# has an operator designed for just this job: <code>typeof</code>. I’ve shown this in a few examples already, but <a data-type="xref" href="#getting_a_type_with_typeof">Example 13-7</a> shows it in isolation. As you can see, you can use either a built-in name, such as <code>string</code>, or an ordinary type name, such as <code>IDisposable</code>. You could also include the namespace, but that’s not necessary when the type’s namespace is in scope.</p>
<div data-type="example" id="getting_a_type_with_typeof">
<h5><span class="label">Example 13-7. </span>Getting a <code>Type</code> with <code>typeof</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">Type</code> <code class="n">stringType</code> <code class="p">=</code> <code class="k">typeof</code><code class="p">(</code><code class="kt">string</code><code class="p">);</code>
<code class="n">Type</code> <code class="n">disposableType</code> <code class="p">=</code> <code class="k">typeof</code><code class="p">(</code><code class="n">IDisposable</code><code class="p">);</code></pre></div>
<p>Also, as I mentioned in <a data-type="xref" href="ch06.xhtml#ch_inheritance">Chapter 6</a>, the <code>System.Object</code> type (or <code>object</code>, as we usually write it in C#) provides a <code>GetType</code> instance method that takes no arguments. You can call this on any reference type variable to retrieve the type of the object that variable refers to. This will not necessarily be the same type as the variable itself, because the variable may refer to an instance of a derived type. You can also call this method on any value type variable, and because value types do not support inheritance, it will always return the <code>Type</code> object for the variable’s static type.</p>
<p>So all you need is an object, a value, or a type identifier (such as <code>string</code>), and it is trivial to get a <code>Type</code> object. And, there are many other places <code>Type</code> objects can come from.</p>
<p>In addition to <code>Type</code>, we also have <code>TypeInfo</code>. This was introduced in early versions of .NET Core with the intention of enabling <code>Type</code> to serve purely as a lightweight identifier, and for <code>TypeInfo</code> to be the mechanism by which you reflect against a type. This was a departure from how <code>Type</code> had always worked in .NET Framework, where it performs both roles. This dual role was arguably a mistake because if you only need an identifier, <code>Type</code> is unnecessarily heavyweight. .NET Core was originally envisaged as having a separate existence from .NET Framework with no need for strict compatibility, so it seemed to provide an opportunity to fix historical design problems. However, once Microsoft took the decision that .NET Core would be the basis of all future versions of .NET, it became necessary to bring it back into line with how .NET Framework had always worked. However, by this time, .NET Framework had also introduced <code>TypeInfo</code>, and for a while, new type-level reflection features were added to that instead of <code>Type</code> to minimize incompatibilities with .NET Core 1. .NET Core 2.0 realigned with .NET Framework, but this meant that the split of functionality between <code>Type</code> and <code>TypeInfo</code> is now just an upshot of what was added when. <code>TypeInfo</code> contains members added during the brief period between its introduction and the decision to revert to the old way. In cases where you have a <code>Type</code> but you need to use a feature specific to <code>TypeInfo</code>, you can get this from a <code>Type</code> by calling <code>GetTypeInfo</code>.</p>
<p>As you’ve already seen, you can retrieve <code>Type</code> objects from an <code>Assembly</code>, either by name or as a comprehensive list. The reflection types that derive from <code>MemberInfo</code> also provide a reference to their containing type through <code>DeclaringType</code>. (<code>Type</code> derives from <code>MemberInfo</code>, so it also offers this property, which is relevant when dealing with nested types.)</p>
<p><a data-primary="mscorlib assembly" data-type="indexterm" id="idm45884794637456"/>You can also call the <code>Type</code> class’s own static <code>GetType</code> method. If you pass just a namespace-qualified string, it will search for the named type in a system assembly called <code>mscorlib</code>, and also in the assembly from which you called the method. However, you can pass an <em>assembly-qualified name</em>, which combines an assembly name and a type name. A name of this form starts with the namespace-qualified type name, followed by a comma and the assembly name. For example, this is the assembly-qualified name of the <code>System.String</code> class in .NET Framework 4.8 (split across two lines to fit in this book):</p>
<pre data-type="programlisting">System.String, mscorlib, Version=4.0.0.0, Culture=neutral,
 PublicKeyToken=b77a5c561934e089</pre>
<p>You can discover a type’s assembly-qualified name through the <code>Type.Assembly​Quali⁠fiedName</code> property. Be aware that this won’t always match what you asked for. If you pass the preceding type name into <code>Type.GetType</code> on .NET 6.0, it will work, but if you then ask the returned <code>Type</code> for its <code>AssemblyQualifiedName</code>, it will return this instead:</p>
<pre data-type="programlisting">System.String, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral,
 PublicKeyToken=7cec85d7bea7798e</pre>
<p>The only reason it works when you pass either the first string or just <code>System.String</code> is because <code>mscorlib</code> still exists for backward compatibility purposes. I described this in the preceding chapter, but to summarize, in .NET Framework, the <code>mscorlib</code> assembly contains the core types of the runtime libraries, but in .NET Core and .NET 5.0 or later, the code has moved elsewhere. <code>mscorlib</code> still exists, but it contains only type forwarding entries indicating which assembly each class now lives in. For example, it forwards <code>System.String</code> to its new home, which, at the time of this writing, is the <code>System.Private.CoreLib</code> assembly.</p>
<p>As well as the standard <code>MemberInfo</code> properties, such as <code>Module</code> and <code>Name</code>, the <code>Type</code> and <code>TypeInfo</code> classes add various properties of their own. The inherited <code>Name</code> property contains the unqualified name, so <code>Type</code> adds a <code>Namespace</code> property. All types are scoped to an assembly, so <code>Type</code> defines an <code>Assembly</code> property. (You could, of course, get there via <code>Module.Assembly</code>, but it’s more convenient to use the <code>Assembly</code> property.) It also defines a <code>BaseType</code> property, although that will be <code>null</code> for some types (e.g., nonderived interfaces and the type object for the <code>System.Object</code> class).</p>
<p>Since <code>Type</code> can represent all sorts of types, there are properties you can use to determine exactly what you’ve got: <code>IsArray</code>, <code>IsClass</code>, <code>IsEnum</code>, <code>IsInterface</code>, <code>IsPointer</code>, and <code>IsValueType</code>. (You can also get <code>Type</code> objects for non-.NET types in interop scenarios, so there’s also an <code>IsCOMObject</code> property.) If it represents a class, there are some properties that tell you more about what kind of class you’ve got: <code>IsAbstract</code>, <code>IsSealed</code>, and <code>IsNested</code>. That last one is applicable to value types as well as classes.</p>
<p><code>Type</code> also defines numerous properties providing<a data-primary="internal types" data-type="indexterm" id="idm45884794612416"/> information about the type’s visibility. For nonnested types, <code>IsPublic</code> tells you whether it’s <code>public</code> or <code>internal</code>, but things are more complex for nested types. <code>IsNestedAssembly</code> indicates an <code>internal</code> nested type, while <code>IsNestedPublic</code> and <code>IsNestedPrivate</code> indicate <code>public</code> and 
<span class="keep-together"><code>private</code></span> nested types. Instead of the usual C-family “protected” terminology, the CLR uses the term <em>family</em>, so we have <code>IsNestedFamily</code> for <code>protected</code>, <code>IsNestedFamOR​As⁠sem</code> for <code>protected internal</code>, and <code>IsNestedFamANDAssem</code> for <code>protected private</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>There is no <code>IsRecord</code> property. As far as the runtime is concerned, record types are classes or structs. Records are a feature of the C# type system but not of the .NET runtime’s type system, the CTS. Reflection is a runtime feature, so it presents the CTS perspective.</p>
</div>
<p>The <code>TypeInfo</code> class also provides methods to discover related reflection objects. (The properties in this paragraph are all defined on <code>TypeInfo</code>, not <code>Type</code>. As previously discussed, this is just an accident of when they were defined.) Most of these come in two forms: one where you want a complete list of all the items of the specified kind and one where you know the name of the thing you’re 
<span class="keep-together">looking</span> for. For example, we have <code>DeclaredConstructors</code>, <code>DeclaredEvents</code>, <code>DeclaredFields</code>, <code>DeclaredMethods</code>, <code>DeclaredNestedTypes</code>, and <code>DeclaredProperties</code> along with their counterparts, 
<span class="keep-together"><code>GetDeclaredConstructor</code></span>, <code>GetDeclaredEvent</code>, <code>GetDeclaredField</code>, 
<span class="keep-together"><code>GetDeclaredMethod</code>,</span> <code>GetDeclaredNestedType</code>, and <code>GetDeclaredProperty</code>.</p>
<p>The <code>Type</code> class lets you discover type compatibility relationships. You can ask whether one type derives from another type by calling the type’s <code>IsSubclassOf</code> method. Inheritance is not the only reason one type may be compatible with a reference of a different type—a variable whose type is an interface can refer to an instance of any type that implements that interface, regardless of its base class. The <code>Type</code> class therefore offers a more general method called <code>IsAssignableFrom</code>, shown in <a data-type="xref" href="#testing_type_compatibility">Example 13-8</a>, which tells you whether an implicit reference conversion exists.</p>
<div data-type="example" id="testing_type_compatibility">
<h5><span class="label">Example 13-8. </span>Testing type compatibility</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">Type</code> <code class="n">stringType</code> <code class="p">=</code> <code class="k">typeof</code><code class="p">(</code><code class="kt">string</code><code class="p">);</code>
<code class="n">Type</code> <code class="n">objectType</code> <code class="p">=</code> <code class="k">typeof</code><code class="p">(</code><code class="kt">object</code><code class="p">);</code>
<code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">stringType</code><code class="p">.</code><code class="n">IsAssignableFrom</code><code class="p">(</code><code class="n">objectType</code><code class="p">));</code>
<code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">objectType</code><code class="p">.</code><code class="n">IsAssignableFrom</code><code class="p">(</code><code class="n">stringType</code><code class="p">));</code></pre></div>
<p>This shows <code>False</code> and then <code>True</code>, because you cannot take a reference to an instance of type <code>object</code> and assign it into a variable of type <code>string</code>, but you can take a reference to an instance of type <code>string</code> and assign it into a variable of type <code>object</code>.</p>
<p>As well as telling you things about a type and its relationships to other types, the <code>Type</code> class provides the ability to use a type’s members at runtime. It defines an <code>InvokeMember</code> method, the exact meaning of which depends on what kind of member you invoke—it could mean calling a method, or getting or setting a property or field, for example. Since some member types support multiple kinds of invocation (e.g., both get and set), you need to specify which particular operation you want. <a data-type="xref" href="#invoking_a_method_with_invokemember">Example 13-9</a> uses <code>InvokeMember</code> to invoke a method identified by its name (the <code>member</code> string argument) on an instance of a type, also identified by name, that it instantiates dynamically. This illustrates how reflection can be used to work with types and members whose identities are not known until runtime.</p>
<div data-type="example" id="invoking_a_method_with_invokemember">
<h5><span class="label">Example 13-9. </span>Invoking a method with <code>InvokeMember</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">static</code> <code class="kt">object?</code> <code class="n">CreateAndInvokeMethod</code><code class="p">(</code>
  <code class="kt">string</code> <code class="n">typeName</code><code class="p">,</code> <code class="kt">string</code> <code class="n">member</code><code class="p">,</code> <code class="k">params</code> <code class="kt">object</code><code class="p">[]</code> <code class="n">args</code><code class="p">)</code>
<code class="p">{</code>
    <code class="n">Type</code> <code class="n">t</code> <code class="p">=</code> <code class="n">Type</code><code class="p">.</code><code class="n">GetType</code><code class="p">(</code><code class="n">typeName</code><code class="p">)</code>
        <code class="p">??</code> <code class="k">throw</code> <code class="k">new</code> <code class="n">ArgumentException</code><code class="p">(</code>
            <code class="err">$</code><code class="s">"Type {typeName} not found"</code><code class="p">,</code> <code class="n">nameof</code><code class="p">(</code><code class="n">typeName</code><code class="p">));</code>
    <code class="kt">object</code> <code class="n">instance</code> <code class="p">=</code> <code class="n">Activator</code><code class="p">.</code><code class="n">CreateInstance</code><code class="p">(</code><code class="n">t</code><code class="p">)!;</code>
    <code class="k">return</code> <code class="n">t</code><code class="p">.</code><code class="n">InvokeMember</code><code class="p">(</code>
      <code class="n">member</code><code class="p">,</code>
      <code class="n">BindingFlags</code><code class="p">.</code><code class="n">Instance</code> <code class="p">|</code> <code class="n">BindingFlags</code><code class="p">.</code><code class="n">Public</code> <code class="p">|</code> <code class="n">BindingFlags</code><code class="p">.</code><code class="n">InvokeMethod</code><code class="p">,</code>
      <code class="k">null</code><code class="p">,</code>
      <code class="n">instance</code><code class="p">,</code>
      <code class="n">args</code><code class="p">);</code>
<code class="p">}</code></pre></div>
<p>This example first creates an instance of the specified type—this uses a slightly different approach to dynamic creation than the one I showed earlier with 
<span class="keep-together"><code>Assembly.CreateInstance</code>.</span> Here I’m using <code>Type.GetType</code> to look up the type, and then <a data-primary="Activator class" data-type="indexterm" id="idm45884794394080"/>I’m using a class I’ve not mentioned before, <code>Activator</code>. This class’s job is to create new instances of objects whose type you have determined at runtime. Its functionality overlaps somewhat with <code>Assembly.CreateInstance</code>, but in this case, it’s the most convenient way to get from a <code>Type</code> to a new instance of that type. Then I’ve used the <code>Type</code> object’s <code>InvokeMember</code> to invoke the specified method. As with <a data-type="xref" href="#dynamic_construction">Example 13-3</a>, I’ve had to specify binding flags to indicate what kind of member I’m looking for and also what to do with it—here I’m looking to call a method (as opposed to, say, setting a property value). The <code>null</code> argument is, as with <a data-type="xref" href="#dynamic_construction">Example 13-3</a>, a place where I would have specified a <code>Binder</code> if I had wanted to support automatic coercion of the method argument types.</p>
<section data-pdf-bookmark="Generic types" data-type="sect3"><div class="sect3" id="generic_types-id1">
<h3>Generic types</h3>
<p><a data-primary="generics" data-secondary="Type class and" data-type="indexterm" id="idm45884794387200"/><a data-primary="Type class" data-secondary="generics" data-type="indexterm" id="idm45884794386128"/>.NET’s support for generics complicates the role of the <code>Type</code> class. As well as representing an ordinary nongeneric type, a <code>Type</code> can represent a particular instance of a generic type (e.g., <code>List&lt;int&gt;</code>) but also an unbound generic type (e.g., <code>List&lt;&gt;</code>, although that’s an illegal type identifier in all but one very specific scenario). <a data-type="xref" href="#type_objects_for_generic_types">Example 13-10</a> shows how to obtain both kinds of <code>Type</code> objects.</p>
<div data-type="example" id="type_objects_for_generic_types">
<h5><span class="label">Example 13-10. </span><code>Type</code> objects for generic types</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">Type</code> <code class="n">bound</code> <code class="p">=</code> <code class="k">typeof</code><code class="p">(</code><code class="n">List</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;);</code>
<code class="n">Type</code> <code class="n">unbound</code> <code class="p">=</code> <code class="k">typeof</code><code class="p">(</code><code class="n">List</code><code class="p">&lt;&gt;);</code></pre></div>
<p>The <code>typeof</code> operator is the only place in which you can use an unbound generic type identifier in C#—in all other contexts, it would be an error not to supply type arguments. By the way, if the type takes multiple type arguments, you must provide commas—for example, <code>typeof(Dictionary&lt;,&gt;)</code>. This is necessary to avoid ambiguity when there are multiple generic types with the same names, distinguished only by the number of type parameters (also known as the <em>arity</em>)—for example, <code>typeof(Func&lt;,&gt;)</code> versus <code>typeof(Func&lt;,,,&gt;)</code>. You cannot specify a partially bound generic type. For example, <code>typeof(Dictionary&lt;string,&gt;)</code> would fail to compile.</p>
<p>You can tell when a <code>Type</code> object refers to a generic type—the <code>IsGenericType</code> property will return <code>true</code> for both <code>bound</code> and <code>unbound</code> from <a data-type="xref" href="#type_objects_for_generic_types">Example 13-10</a>. You can also determine whether or not the type arguments have been supplied by using the <code>IsGenericTypeDefinition</code> property, which would return <code>false</code> and <code>true</code> for <code>bound</code> and <code>unbound</code>, respectively. If you have a bound generic type and you’d like to get the unbound type from which it was constructed, you use the <code>GetGenericType​Defini⁠tion</code> method—calling that on <code>bound</code> would return the same type object that <code>unbound</code> refers to.</p>
<p>Given a <code>Type</code> object whose <code>IsGenericTypeDefinition</code> property returns <code>true</code>, you can construct a new bound version of that type by calling <code>MakeGenericType</code>, passing an array of <code>Type</code> objects, one for each type argument.</p>
<p>If you have a generic type, you can retrieve its type arguments from the <code>Generic​Ty⁠peArguments</code> property. Perhaps surprisingly, this even works for unbound types, although it behaves differently than with a bound type. If you get <code>GenericType​Argu⁠ments</code> from <code>bound</code> from <a data-type="xref" href="#type_objects_for_generic_types">Example 13-10</a>, it will return an array containing a single <code>Type</code> object, which will be the same one you would get from <code>typeof(int)</code>. If you get <code>unbound.GenericTypeArguments</code>, you will also get an array containing a single <code>Type</code>, but this time, it will be a <code>Type</code> object that does not represent a specific type—its <code>IsGenericParameter</code> property will be <code>true</code>, indicating that this represents a placeholder. Its name in this case will be <code>T</code>. In general, the name will correspond to whatever placeholder name the generic type chooses. For example, with <code>typeof​(Dic⁠tionary&lt;,&gt;)</code>, you’ll get two <code>Type</code> objects called <code>TKey</code> and <code>TValue</code>, respectively. You will encounter similar generic argument placeholder types if you use the reflection API to look up members of generic types. For example, if you retrieve the <code>MethodInfo</code> for the <code>Add</code> method of the unbound <code>List&lt;&gt;</code> type, you’ll find that it takes a single argument of a type named <code>T</code>, which returns <code>true</code> from its <code>IsGenericParameter</code> property.</p>
<p>When a <code>Type</code> object represents an unbound generic parameter, you can find out whether the parameter is covariant or contravariant (or neither) through its <code>Generi⁠c​ParameterAttributes</code> method.<a data-startref="ix_ch13-asciidoc9" data-type="indexterm" id="idm45884794314992"/><a data-startref="ix_ch13-asciidoc8" data-type="indexterm" id="idm45884794314320"/><a data-startref="ix_ch13-asciidoc7" data-type="indexterm" id="idm45884794313648"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="MethodBase, ConstructorInfo, and MethodInfo" data-type="sect2"><div class="sect2" id="methodbase_comma_constructorinfo_comma_a">
<h2>MethodBase, ConstructorInfo, and MethodInfo</h2>
<p><a data-primary="ConstructorInfo class" data-type="indexterm" id="ix_ch13-asciidoc10"/><a data-primary="MethodBase class" data-type="indexterm" id="ix_ch13-asciidoc11"/><a data-primary="MethodInfo class" data-type="indexterm" id="ix_ch13-asciidoc12"/><a data-primary="reflection" data-secondary="MethodBase, ConstructorInfo, and MethodInfo" data-type="indexterm" id="ix_ch13-asciidoc13"/>Constructors and methods have a great deal in common. The same accessibility options are available for both kinds of members, they both have argument lists, and they can both contain code. Consequently, the <code>MethodInfo</code> and <code>ConstructorInfo</code> reflection types share a base class, <code>MethodBase</code>, which defines properties and methods for handling these common aspects.</p>
<p>To obtain a <code>MethodInfo</code> or <code>ConstructorInfo</code>, besides using the <code>Type</code> class properties I mentioned earlier, you can also call the <code>MethodBase</code> class’s static <code>GetCurrentMethod</code> method. This inspects the calling code to see if it’s a constructor or a normal method and returns either a <code>MethodInfo</code> or <code class="keep-together">ConstructorInfo</code> accordingly.</p>
<p>As well as the members it inherits from <code>MemberInfo</code>, <code>MethodBase</code> defines properties specifying the member’s accessibility. These are similar in concept to those I described earlier for types, but the names are marginally different, because unlike <code>Type</code>, <code>MethodBase</code> does not define accessibility properties that make a distinction between nested and nonnested members. So with <code>MethodBase</code>, we find <code>IsPublic</code>, <code>IsPrivate</code>, <code>IsAssembly</code>, <code>IsFamily</code>, <code>IsFamilyOrAssembly</code>, and <code>IsFamilyAndAssembly</code> for <code>public</code>, <code>private</code>, <code>internal</code>, <code>protected</code>, <code>protected internal</code>, and <code>protected private</code>, respectively.</p>
<p>In addition to accessibility-related properties, <code>MethodBase</code> defines properties that tell you about aspects of the method, such as <code>IsStatic</code>, <code>IsAbstract</code>, <code>IsVirtual</code>, <code>IsFinal</code>, and <code>IsConstructor</code>.</p>
<p>There are also properties for dealing with generic methods. <code>IsGenericMethod</code> and <code>IsGenericMethodDefinition</code> are the method-level equivalents of the type-level <span class="keep-together"><code>IsGenericType</code></span> and <code>IsGenericTypeDefinition</code> properties. As with <code>Type</code>, there’s a <code>GetGenericMethodDefinition</code> method to get from a bound generic method to an unbound one, and a <code>MakeGenericMethod</code> to produce a bound generic method from an unbound one. You can retrieve type arguments by calling <code>GetGenericArguments</code>, and as with generic types, this will return specific types when called on a bound method and will return placeholder types when used with an unbound method.</p>
<p>You can inspect the implementation of the method by calling <code>GetMethodBody</code>. This returns a <code>MethodBody</code> object that provides access to the IL (as an array of bytes) and also to the local variable definitions used by the method.</p>
<p>The <code>MethodInfo</code> class derives from <code>MethodBase</code> and represents only methods (and not constructors). It adds a <code>ReturnType</code> property that provides a <code>Type</code> object indicating the method’s return type. (There’s a special system type, <code>System.Void</code>, whose <code>Type</code> object is used here when a method returns nothing.)</p>
<p>The <code>ConstructorInfo</code> class does not add any properties beyond those it inherits from <code>MethodBase</code>. It does define two read-only static fields, though: <code>ConstructorName</code> and <code>TypeConstructorName</code>. These contain the strings <code>".ctor"</code> and <code>".cctor"</code>, respectively, which are the values you will find in the <code>Name</code> property for <code>ConstructorInfo</code> objects for instance and static constructors. As far as the CLR is concerned, these are the real <span class="keep-together">names—</span>although in C# constructors appear to have the same name as their containing type, that’s true only in your C# source files, and not at runtime.</p>
<p>You can invoke the method or constructor represented by a <code>MethodInfo</code> or 
<span class="keep-together"><code>ConstructorInfo</code></span> by calling the <code>Invoke</code> method. This does the same thing as 
<span class="keep-together"><code>Type.InvokeMember</code></span>—<a data-type="xref" href="#invoking_a_method_with_invokemember">Example 13-9</a> used that to call a method. However, because <code>Invoke</code> is specialized for working with just methods and constructors, it’s rather simpler to use. With a <code>ConstructorInfo</code>, you need to pass only an array of arguments. With <code>MethodInfo</code>, you also pass the object on which you want to invoke the method, or <code>null</code> if you want to invoke a static method. <a data-type="xref" href="#invoking_a_method">Example 13-11</a> performs the same job as<a data-primary="Activator class" data-type="indexterm" id="idm45884794269232"/> <a data-type="xref" href="#invoking_a_method_with_invokemember">Example 13-9</a> but using <code>MethodInfo</code>.</p>
<div data-type="example" id="invoking_a_method">
<h5><span class="label">Example 13-11. </span>Invoking a method</h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="k">public</code> <code class="k">static</code> <code class="kt">object?</code> <code class="n">CreateAndInvokeMethod</code><code class="p">(</code>
  <code class="kt">string</code> <code class="n">typeName</code><code class="p">,</code> <code class="kt">string</code> <code class="n">member</code><code class="p">,</code> <code class="k">params</code> <code class="kt">object</code><code class="p">[</code><code class="p">]</code> <code class="n">args</code><code class="p">)</code>
<code class="p">{</code>
    <code class="n">Type</code> <code class="n">t</code> <code class="p">=</code> <code class="n">Type</code><code class="p">.</code><code class="n">GetType</code><code class="p">(</code><code class="n">typeName</code><code class="p">)</code>
        <code class="p">?</code><code class="p">?</code> <code class="k">throw</code> <code class="k">new</code> <code class="n">ArgumentException</code><code class="p">(</code>
            <code class="err">$</code><code class="s">"Type {typeName} not found"</code><code class="p">,</code> <code class="n">nameof</code><code class="p">(</code><code class="n">typeName</code><code class="p">)</code><code class="p">)</code><code class="p">;</code>
    <code class="kt">object</code> <code class="n">instance</code> <code class="p">=</code> <code class="n">Activator</code><code class="p">.</code><code class="n">CreateInstance</code><code class="p">(</code><code class="n">t</code><code class="p">)</code><code class="p">!</code><code class="p">;</code>
    <strong><code class="n">MethodInfo</code> <code class="n">m</code> <code class="p">=</code> <code class="n">t</code><code class="p">.</code><code class="n">GetMethod</code><code class="p">(</code><code class="n">member</code><code class="p">)</code></strong>
        <code class="p">?</code><code class="p">?</code> <code class="k">throw</code> <code class="k">new</code> <code class="n">ArgumentException</code><code class="p">(</code>
            <code class="err">$</code><code class="s">"Method {member} not found"</code><code class="p">,</code> <code class="n">nameof</code><code class="p">(</code><code class="n">member</code><code class="p">)</code><code class="p">)</code><code class="p">;</code>
    <strong><code class="k">return</code> <code class="n">m</code><code class="p">.</code><code class="n">Invoke</code><code class="p">(</code><code class="n">instance</code><code class="p">,</code> <code class="n">args</code><code class="p">)</code><code class="p">;</code></strong>
<code class="p">}</code></pre></div>
<p>For either methods or constructors, you can call <code>GetParameters</code>, which returns an array of <code>ParameterInfo</code> objects representing the method’s parameters.<a data-startref="ix_ch13-asciidoc13" data-type="indexterm" id="idm45884794144224"/><a data-startref="ix_ch13-asciidoc12" data-type="indexterm" id="idm45884794143696"/><a data-startref="ix_ch13-asciidoc11" data-type="indexterm" id="idm45884794143024"/><a data-startref="ix_ch13-asciidoc10" data-type="indexterm" id="idm45884794142352"/></p>
</div></section>
<section data-pdf-bookmark="ParameterInfo" data-type="sect2"><div class="sect2" id="parameterinfo">
<h2>ParameterInfo</h2>
<p><a data-primary="ParameterInfo class" data-type="indexterm" id="idm45884794160784"/><a data-primary="reflection" data-secondary="ParameterInfo" data-type="indexterm" id="idm45884794159856"/>The <code>ParameterInfo</code> class represents parameters for methods or constructors. Its <code>ParameterType</code> and <code>Name</code> properties provide the basic information you’d see from looking at the method signature. It also defines a <code>Member</code> property that refers back to the method or constructor to which the parameter belongs. The <code>HasDefaultValue</code> property will tell you whether the parameter is optional, and if it is, <code>DefaultValue</code> provides the value to be used when the argument is omitted.</p>
<p>If you are working with members defined by unbound generic types, or with an unbound generic method, be aware that the <code>ParameterType</code> of a <code>ParameterInfo</code> could refer to a generic type argument, and not a real type. This is also true of any <code>Type</code> objects returned by the reflection objects described in the next three sections.</p>
</div></section>
<section data-pdf-bookmark="FieldInfo" data-type="sect2"><div class="sect2" id="fieldinfo">
<h2>FieldInfo</h2>
<p><a data-primary="FieldInfo class" data-type="indexterm" id="idm45884794109312"/><a data-primary="reflection" data-secondary="FieldInfo" data-type="indexterm" id="idm45884794108384"/><code>FieldInfo</code> represents a field in a type. You typically obtain it from a <code>Type</code> object with <code>GetField</code> or <code>GetFields</code>, or if you’re using code written in a language that supports global fields, you can retrieve those from the containing <code>Module</code>.</p>
<p><code>FieldInfo</code> defines a set of properties representing accessibility. These look just like the ones defined by <code>MethodBase</code>. Additionally, there’s <code>FieldType</code>, representing the type a field can contain. (As always, if the member belongs to an unbound generic type, this might refer to a type argument rather than a specific type.) There are also some properties providing further information about the field, including <code>IsStatic</code>, <code>IsInitOnly</code>, and <code>IsLiteral</code>. These correspond to <code>static</code>, <code>readonly</code>, and <code>const</code> in C#, respectively. (Fields representing values in enumeration types will also return <code>true</code> from <code>IsLiteral</code>.)</p>
<p><code>FieldInfo</code> defines <code>GetValue</code> and <code>SetValue</code> methods that let you read and write the value of the field. These take an argument specifying the instance to use, or <code>null</code> if the field is static. As with the <code>MethodBase</code> class’s <code>Invoke</code>, these do not do anything you couldn’t do with the <code>Type</code> class’s <code>InvokeMember</code>, but these methods are typically more convenient.</p>
</div></section>
<section data-pdf-bookmark="PropertyInfo" data-type="sect2"><div class="sect2" id="propertyinfo">
<h2>PropertyInfo</h2>
<p><a data-primary="PropertyInfo type" data-type="indexterm" id="idm45884794094272"/><a data-primary="reflection" data-secondary="PropertyInfo" data-type="indexterm" id="idm45884794093344"/>The <code>PropertyInfo</code> type represents a property. You can obtain these from the containing <code>Type</code> object’s <code>GetProperty</code> or <code>GetProperties</code> methods. As I mentioned earlier, <code>PropertyInfo</code> does not define any properties for accessibility, because the accessibility is determined at the level of the individual get and set methods. You can retrieve those with the <code>GetGetMethod</code> and <code>GetSetMethod</code> methods, which both return <code>MethodInfo</code> objects.</p>
<p>Much like with <code>FieldInfo</code>, the <code>PropertyInfo</code> class defines <code>GetValue</code> and <code>SetValue</code> methods for reading and writing the value. Properties are allowed to take arguments—C# indexers are properties with arguments, for example. So there are overloads of <span class="keep-together"><code>GetValue</code></span> and <code>SetValue</code> that take arrays of arguments. Also, there is a <code>GetIndexParameters</code> method that returns an array of <code>ParameterInfo</code> objects, representing the <span class="keep-together">arguments</span> required to use the property. The property’s type is available through the <code>PropertyType</code> property.</p>
</div></section>
<section data-pdf-bookmark="EventInfo" data-type="sect2"><div class="sect2" id="eventinfo">
<h2>EventInfo</h2>
<p><a data-primary="EventInfo objects" data-type="indexterm" id="idm45884794081552"/><a data-primary="reflection" data-secondary="EventInfo" data-type="indexterm" id="idm45884794080512"/>Events are represented by <code>EventInfo</code> objects, which are returned by the <code>Type</code> class’s <code>GetEvent</code> and <code>GetEvents</code> methods. Like <code>PropertyInfo</code>, this does not have any accessibility properties, because the event’s add and remove methods each define their own accessibility. You can retrieve those methods with <code>GetAddMethod</code> and <code>GetRemoveMethod</code>, which both return a <code>MethodInfo</code>. <code>EventInfo</code> defines an <code>EventHandlerType</code>, which returns the type of delegate that event handlers are required to supply.</p>
<p>You can attach and remove handlers by calling the <code>AddEventHandler</code> and <code>Remove​EventHandler</code> methods. As with all other dynamic invocation, these just offer a more convenient alternative to the <code>Type</code> class’s <code>InvokeMember</code> method.<a data-startref="ix_ch13-asciidoc2" data-type="indexterm" id="idm45884794072768"/><a data-startref="ix_ch13-asciidoc1" data-type="indexterm" id="idm45884794072032"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Reflection Contexts" data-type="sect1"><div class="sect1" id="reflection_contexts">
<h1>Reflection Contexts</h1>
<p><a data-primary="reflection" data-secondary="reflection contexts" data-type="indexterm" id="ix_ch13-asciidoc14"/><a data-primary="reflection contexts" data-type="indexterm" id="ix_ch13-asciidoc15"/>.NET has a feature called <em>reflection contexts</em>. These enable reflection to provide a virtualized view of the type system. By writing a custom reflection context, you can modify how types appear—you can cause a type to look like it has extra properties, or you can add to the set of attributes that members and parameters appear to offer. (<a data-type="xref" href="ch14.xhtml#ch_attributes">Chapter 14</a> will describe attributes.)</p>
<p>Reflection contexts are useful because they make it possible to write reflection-driven frameworks that enable individual types to customize how they are handled but without forcing every type that participates into providing explicit support. Prior to the introduction of custom reflection contexts in .NET 4.5, this was handled with various ad hoc systems. Take the Properties panel in Visual Studio, for example. This can automatically display every public property defined by any .NET object that ends up on a design surface (e.g., any UI component you write). It’s great to have automatic editing support even for components that do not provide any explicit handling for that, but components should have the opportunity to customize how they behave at design time.</p>
<p>Because the Properties panel predates .NET 4.5, it uses one of the ad hoc solutions: the <code>TypeDescriptor</code> class. This is a wrapper on top of reflection, which allows any class to augment its design-time behavior by implementing <code>ICustomTypeDescriptor</code>, enabling a class to customize the set of properties it offers for editing and also to control how they are presented, even offering custom editing UIs. This is flexible, but has the downside of coupling the design-time code with the runtime code—components that use this model cannot easily be shipped without also supplying the design-time code. So Visual Studio introduced its own virtualization mechanisms for separating the two.</p>
<p>To avoid having each framework define its own virtualization system, custom reflection contexts add virtualization directly into the reflection API. If you want to write code that can consume type information provided by reflection but can also support design-time augmentation or modification of that information, it’s no longer necessary to use some sort of wrapper layer. You can use the usual reflection types described earlier in this chapter, but it’s now possible to ask reflection to give you different implementations of these types, providing different virtualized views.</p>
<p>You do this by writing a custom reflection context that describes how you want to modify the view that reflection provides. <a data-type="xref" href="#a_simple_type_comma_enhanced_by_a_reflec">Example 13-12</a> shows a particularly boring type followed by a custom reflection context that makes that type look like it has 
<span class="keep-together">a property.</span></p>
<div data-type="example" id="a_simple_type_comma_enhanced_by_a_reflec">
<h5><span class="label">Example 13-12. </span>A simple type, enhanced by a reflection context</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">class</code> <code class="nc">NotVeryInteresting</code>
<code class="p">{</code>
<code class="p">}</code>

<code class="k">class</code> <code class="nc">MyReflectionContext</code> <code class="p">:</code> <code class="n">CustomReflectionContext</code>
<code class="p">{</code>
    <code class="k">protected</code> <code class="k">override</code> <code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">PropertyInfo</code><code class="p">&gt;</code> <code class="n">AddProperties</code><code class="p">(</code><code class="n">Type</code> <code class="n">type</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="n">type</code> <code class="p">==</code> <code class="k">typeof</code><code class="p">(</code><code class="n">NotVeryInteresting</code><code class="p">))</code>
        <code class="p">{</code>
            <code class="kt">var</code> <code class="n">fakeProp</code> <code class="p">=</code> <code class="n">CreateProperty</code><code class="p">(</code>
                <code class="n">MapType</code><code class="p">(</code><code class="k">typeof</code><code class="p">(</code><code class="kt">string</code><code class="p">).</code><code class="n">GetTypeInfo</code><code class="p">()),</code>
                <code class="s">"FakeProperty"</code><code class="p">,</code>
                <code class="n">o</code> <code class="p">=&gt;</code> <code class="s">"FakeValue"</code><code class="p">,</code>
                <code class="p">(</code><code class="n">o</code><code class="p">,</code> <code class="n">v</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"Setting value: {v}"</code><code class="p">));</code>

            <code class="k">return</code> <code class="k">new</code><code class="p">[]</code> <code class="p">{</code> <code class="n">fakeProp</code> <code class="p">};</code>
        <code class="p">}</code>
        <code class="k">else</code>
        <code class="p">{</code>
            <code class="k">return</code> <code class="k">base</code><code class="p">.</code><code class="n">AddProperties</code><code class="p">(</code><code class="n">type</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>Code that uses the reflection API directly will see the <code>NotVeryInteresting</code>
<span class="keep-together">type directly</span> as it is, with no properties. However, we can map that type through 
<span class="keep-together"><code>MyReflectionContext</code>,</span> as <a data-type="xref" href="#using_a_custom_reflection_context">Example 13-13</a> shows.</p>
<div data-type="example" id="using_a_custom_reflection_context">
<h5><span class="label">Example 13-13. </span>Using a custom reflection context</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">ctx</code> <code class="p">=</code> <code class="k">new</code> <code class="n">MyReflectionContext</code><code class="p">();</code>
<code class="n">TypeInfo</code> <code class="n">mappedType</code> <code class="p">=</code> <code class="n">ctx</code><code class="p">.</code><code class="n">MapType</code><code class="p">(</code><code class="k">typeof</code><code class="p">(</code><code class="n">NotVeryInteresting</code><code class="p">).</code><code class="n">GetTypeInfo</code><code class="p">());</code>

<code class="k">foreach</code> <code class="p">(</code><code class="n">PropertyInfo</code> <code class="n">prop</code> <code class="k">in</code> <code class="n">mappedType</code><code class="p">.</code><code class="n">DeclaredProperties</code><code class="p">)</code>
<code class="p">{</code>
    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"{prop.Name} ({prop.PropertyType.Name})"</code><code class="p">);</code>
<code class="p">}</code></pre></div>
<p>The <code>mappedType</code> variable holds a reference to the resulting mapped type. It still looks like an ordinary reflection <code>TypeInfo</code> object, and we can iterate through its properties in the usual way with <code>DeclaredProperties</code>, but because we’ve mapped the type through my custom reflection context, we see the modified version of the type. This code’s output will show that the type appears to define one property called <code>FakeProperty</code>, of type <code>string</code>.<a data-startref="ix_ch13-asciidoc15" data-type="indexterm" id="idm45884793858288"/><a data-startref="ix_ch13-asciidoc14" data-type="indexterm" id="idm45884793857552"/></p>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="summary-id12">
<h1>Summary</h1>
<p>The reflection API makes it possible to write code whose behavior is based on the structure of the types it works with. This might involve deciding which values to present in a UI grid based on the properties an object offers, or it might mean modifying the behavior of a framework based on what members a particular type chooses to define. For example, parts of the ASP.NET Core web framework will detect whether your code is using synchronous or asynchronous programming techniques and adapt appropriately. These techniques require the ability to inspect code at runtime, which is what reflection enables. All of the information in an assembly required by the type system is available to our code. Furthermore, you can present this through a virtualized view by writing a custom reflection context, making it possible to customize the behavior of reflection-driven code.</p>
<p>Code that inspects the structure of types to drive its behavior often needs additional information. For example, the <code>System.Text.Json</code> namespace includes types described in <a data-type="xref" href="ch15.xhtml#ch_files_and_streams">Chapter 15</a> that can convert between .NET objects and JSON documents. These rely on reflection, but you can take more precise control over the purpose by supplying extra information in the form of <em>attributes</em>. These are the topic of the next chapter.<a data-startref="ix_ch13-asciidoc0" data-type="indexterm" id="idm45884793853264"/></p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45884795200512"><sup><a href="ch13.xhtml#idm45884795200512-marker">1</a></sup> For historical reasons discussed later, a subset of this functionality is in a derived type called <code>TypeInfo</code>. But the base <code>Type</code> class is the one you most often encounter.</p></div></div></section></div></body></html>