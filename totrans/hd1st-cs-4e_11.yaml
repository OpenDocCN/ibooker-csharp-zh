- en: 'Chapter 7\. Interfaces, Casting, and “is”: *Making Classes keep their Promises*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。接口、转换和“is”：*使类们信守它们的承诺*
- en: '![Images](assets/355fig01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/355fig01.png)'
- en: '**Need an object to do a specific job? Use an interface.** Sometimes you need
    to group your objects together based on the **things they can do** rather than
    the classes they inherit from—and that’s where **interfaces** come in. You can
    use an interface to define a **specific job**. Any instance of a class that **implements**
    the interface is *guaranteed to do that job*, no matter what other classes it’s
    related to. To make it all work, any class that implements an interface must promise
    to **fulfill all of its obligations**...or the compiler will break its kneecaps,
    see?'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**需要一个对象来做特定的工作吗？使用接口。** 有时，您需要根据它们**能够做什么**而不是它们从哪些类继承而来来对对象进行分组，这就是**接口**的用武之地。您可以使用接口来定义**特定的工作**。任何实现接口的类的实例都*保证能够执行该工作*，无论它们与其他类的关系如何。为了使一切正常运行，任何实现接口的类都必须承诺*履行其所有义务*...否则编译器将削减其膝盖，明白吗？'
- en: The beehive is under attack!
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蜂巢正在遭受攻击！
- en: An enemy hive is trying to take over the Queen’s territory, and keeps sending
    enemy bees to attack her workers. So she’s added a new elite Bee subclass called
    HiveDefender to defend the hive.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 敌方蜂巢正在试图占领女王的领土，并不断派遣敌蜜蜂来攻击她的工作人员。因此，她添加了一个名为HiveDefender的新的精英蜜蜂子类来保卫蜂巢。
- en: '![Images](assets/356fig01.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/356fig01.png)'
- en: So we need a DefendHive method, because enemies can attack at any time
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 因此，我们需要一个DefendHive方法，因为敌人随时可能发动攻击。
- en: We can add a HiveDefender subclass to the Bee class hierarchy by extending the
    Bee class, overriding its CostPerShift with the amount of honey each defender
    consumes every shift, and overriding the DoJob method to fly out to the enemy
    hive and attack the enemy bees.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过扩展Bee类将HiveDefender子类添加到Bee类层次结构中，重写其CostPerShift以表示每个防御者每个班次消耗的蜂蜜量，并重写DoJob方法以飞到敌方蜂巢并攻击敌蜜蜂。
- en: But enemy bees can attack at any time. We want defenders to be able to defend
    the hive ***whether or not they’re currently doing their normal jobs.***
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 但敌蜜蜂随时可能攻击。我们希望防御者能够在***无论他们当前是否在执行正常工作***的情况下保护蜂巢。
- en: So in addition to DoJob, we’ll add a DefendHive method to any Bee that can defend
    the hive—not just the elite HiveDefender workers, butany of their sisters who
    can take up arms and protect their Queen. The Queen will call her workers’ DefendHive
    methods any time she sees that her hive is under attack.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除了DoJob之外，我们还将向任何能够保卫蜂巢的蜜蜂添加DefendHive方法——不仅仅是精英的HiveDefender工作人员，而是她们的任何能够拿起武器保护她们女王的姐妹们。女王将在她发现自己的蜂巢受到攻击时调用她工作人员的DefendHive方法。
- en: '![Images](assets/356fig02.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/356fig02.png)'
- en: We can use casting to call the DefendHive method...
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们可以使用casting来调用DefendHive方法...
- en: When you coded the Queen.DoJob method, you used a foreach loop to get each Bee
    reference in the `workers` array, then you used that reference to call worker.DoJob.
    If the hive is under attack, the Queen will want to call her defenders’ DefendHive
    methods. So we’ll give her a HiveUnderAttack method that gets called any time
    the hive is being attacked by enemy bees, and she’ll use a foreach loop to order
    her workers to defend the hive until all of the attackers are gone.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当您编写Queen.DoJob方法时，使用foreach循环来获取`workers`数组中的每个蜜蜂引用，然后使用该引用调用worker.DoJob。如果蜂巢遭受攻击，女王将希望调用她的防御者们的DefendHive方法。因此，我们将为她提供一个HiveUnderAttack方法，每当蜂巢受到敌蜜蜂攻击时调用，她将使用foreach循环命令她的工作人员保卫蜂巢，直到所有攻击者都离开为止。
- en: But there’s a problem. The Queen can use the Bee references to call DoJob because
    each subclass overrides Bee.DoJob, but she can’t use a Bee reference to call the
    DefendHive method, because that method isn’t part of the Bee class. So how does
    she call DefendHive?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但出现了问题。女王可以使用蜜蜂引用来调用DoJob，因为每个子类都重写了Bee.DoJob，但她不能使用Bee引用来调用DefendHive方法，因为该方法不是Bee类的一部分。那么她如何调用DefendHive呢？
- en: Since DefendHive is only defined in each subclass, we’ll need to use `casting`
    to convert the Bee reference to the correct subclass in order to call its DefendHive
    method.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于DefendHive仅在每个子类中定义，我们需要使用`casting`将Bee引用转换为正确的子类，以便调用其DefendHive方法。
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '...but what if we add more Bee subclasses that can defend?'
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '...但如果我们添加更多可以防御的蜜蜂子类呢？'
- en: Some honey manufacturer and egg care bees want to step up and defend the hive,
    too. That means we’ll need to add more `else` blocks to her HiveUnderAttack method.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一些蜜制品制造商和鸡蛋护理蜜蜂也想站出来保护蜂巢。这意味着我们将需要向她的HiveUnderAttack方法添加更多的`else`块。
- en: '***This is getting complex.*** The Queen.DoJob method is nice and simple—a
    very short foreach loop that takes advantage of the Bee class model to call the
    specific version of the DoJob method that was implemented in the subclass. We
    can’t do that with DefendHive because it’s not part of the Bee class—and we don’t
    want to add it, because not all bees can defend the hive. ***Is there a better
    way to have unrelated classes do the same job?***'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '***这变得很复杂。*** Queen.DoJob 方法非常简单——一个非常短的 foreach 循环，利用 Bee 类模型调用了子类中实现的特定版本的
    DoJob 方法。我们不能对 DefendHive 这样做，因为它不是 Bee 类的一部分——而且我们也不想添加它，因为并非所有蜜蜂都能保卫蜂巢。***有没有更好的方法让无关的类执行相同的工作？***'
- en: '![Images](assets/357fig01.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/357fig01.png)'
- en: An interface defines methods and properties that a class must implement...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个接口定义了类必须实现的方法和属性...
- en: 'An **interface** works just like an abstract class: you use abstract methods,
    and then you use the colon (:) to make a class implement that interface.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口**的工作方式就像抽象类：你使用抽象方法，然后使用冒号（:）使类实现该接口。'
- en: So if we wanted to add defenders to the hive, we could have an interface called
    IDefend. Here’s what that looks like. It uses the `**interface**` **keyword**
    to define the interface, and it includes a single member, an abstract method called
    Defend. All members in an interface are public and abstract by default, so C#
    keeps things simple by having you ***leave off the `public` and `abstract` keywords:***
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想要将防御者添加到蜂巢中，我们可以有一个名为 IDefend 的接口。它看起来像这样。它使用`**interface**` **关键字**定义接口，并包含一个名为
    Defend 的抽象方法。接口中的所有成员默认都是公共和抽象的，因此C#简化了事务，让您***省略`public`和`abstract`关键字：***
- en: '![Images](assets/358fig01.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/358fig01.png)'
- en: Any class that implements the IDefend interface **must include a Defend method**
    whose declaration matches the one in the interface. If it doesn’t, the compiler
    will give an error.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 任何实现了IDefend接口的类**必须包含一个Defend方法**，其声明与接口中的声明相匹配。如果不匹配，编译器将报错。
- en: '...but there’s no limit to the number of interfaces a class can implement'
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '...但一个类可以实现的接口数量没有限制'
- en: We just said that you use a colon (:) to make a class implement an interface.
    What if that class is already using a colon to extend a base class? No problem!
    **A class can implement many different interfaces, even if it already extends
    a base class:**
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚说过，你使用冒号（:）使一个类实现一个接口。如果该类已经使用冒号扩展了一个基类怎么办？没问题！**一个类可以实现许多不同的接口，即使它已经扩展了一个基类：**
- en: '![Images](assets/358fig02.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/358fig02.png)'
- en: 'Now we have a class that can act like a NectarCollector, but can also defend
    the hive. NectarCollector extends Bee, so if you **use it from a Bee reference**
    it acts like a Bee:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个既可以像NectarCollector一样工作，又可以保卫蜂巢的类。NectarCollector扩展了Bee，所以如果你**使用一个Bee引用**，它就像一个Bee：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'But if you **use it from an IDefend reference**, it acts like a hive defender:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你**使用一个IDefend引用**，它就像一个蜂巢防御者：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**When a class implements an interface, it must include all of the methods
    and properties listed inside the interface or the code won’t build.**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**当一个类实现一个接口时，它必须包含接口内列出的所有方法和属性，否则代码将无法编译。**'
- en: Interfaces let unrelated classes do the same job
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口让无关的类执行相同的工作
- en: Interfaces can be a really powerful tool to help you design C# code that’s easy
    to understand and build. Start by thinking about **specific jobs that classes
    need to do**, because that’s what interfaces are all about.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接口可以是帮助你设计易于理解和构建的C#代码的强大工具。首先要考虑的是**类需要执行的具体任务**，因为这正是接口的目的所在。
- en: '![Images](assets/359fig01.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/359fig01.png)'
- en: 'So how does this help the Queen? The IDefender interface lives entirely outside
    the Bee class hierarchy. So we can add a NectarDefender class that knows how to
    defend the hive, and ***it can still extend NectarCollector***. The Queen can
    keep an array of all of her defenders:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这对女王有什么帮助呢？IDefender接口完全存在于Bee类层次结构之外。因此，我们可以添加一个知道如何保卫蜂巢的NectarDefender类，***它仍然可以扩展NectarCollector***。女王可以保留她所有防御者的数组：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'That makes it easy for her to rally her defenders:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这让她很容易召集她的防御者：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: And since it lives outside of the Bee class model, we can do this ***without
    modifying any existing code.***
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 而且由于它存在于Bee类模型之外，我们可以***不修改任何现有代码***来实现这一点。
- en: '![Images](assets/359fig02.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/359fig02.png)'
- en: Note
  id: totrans-43
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '![Images](assets/relax.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/relax.png)'
- en: '**We’re going to give you a lot of examples of interfaces.**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们将为您提供许多接口的示例。**'
- en: Still a little puzzled about how interfaces work and why you would use them?
    Don’t worry—that’s normal! The syntax is pretty straightforward, but there’s **a
    lot of subtlety**. So we’ll spend more time on interfaces...and we’ll give you
    plenty of examples, and lots of practice.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对接口的工作方式及其使用方式仍有些困惑？别担心——这很正常！语法非常简单直接，但其中还有很多微妙之处。所以我们会花更多时间来讲解接口...并且我们会给你很多例子和大量的练习。
- en: Get a little practice using interfaces
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习使用接口
- en: The best way to understand interfaces is to start using them. Go ahead and **create
    a new Console App** project.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 理解接口的最佳方法是开始使用它们。继续 **创建一个新的控制台应用** 项目。
- en: '***Do this!***'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '***这样做！***'
- en: '**Add the Main method.** Here’s the code for a class called TallGuy, along
    with code for the Main method that instantiates it using an object initializer
    and calls its TalkAboutYourself method. There’s nothing new here—we’ll use it
    in a minute:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加 Main 方法。** 这是一个名为 TallGuy 的类的代码，以及调用其 TalkAboutYourself 方法的 Main 方法的代码。这里没有新东西——我们马上会用到它：'
- en: '[PRE5]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Add an interface.** We’re going to make TallGuy implement an interface. Add
    a new IClown interface to your project: right-click on the project in the Solution
    Explorer, **select Add >> New Item...(Windows) or Add >> New File... (Mac), and
    choose Interface**. Make sure it’s called *IClown.cs*. The IDE will create an
    interface that includes the interface declaration. Add a Honk method:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加一个接口。** 我们将使 TallGuy 实现一个接口。向你的项目中添加一个新的 IClown 接口：在“解决方案资源管理器”中右键单击项目，选择“添加
    >> 新建项目...（Windows）或添加 >> 新建文件...（Mac）”，选择“接口”。确保它的名字是 *IClown.cs*。IDE 将创建一个包含接口声明的接口。添加一个
    Honk 方法：'
- en: '[PRE6]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You don’t need to add “public” or “abstract” inside the interface, because it
    automatically makes every property and method public and asbtract.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你不需要在接口内部添加 “public” 或 “abstract”，因为它自动将每个属性和方法设为公共和抽象。
- en: '**Try coding the rest of the IClown interface.** Before you go on to the next
    step, see if you can create the rest of the IClown interface, and modify the TallGuy
    class to implement this interface. In addition to the void method called Honk
    that doesn’t take any parameters, your IClown interface should also have a read-only
    string property called FunnyThingIHave that has a get accessor but no set accessor.'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**尝试编写其余的 IClown 接口部分。** 在进行下一步之前，看看是否能创建剩余的 IClown 接口部分，并修改 TallGuy 类以实现此接口。除了不带任何参数的
    void 方法 Honk 外，你的 IClown 接口还应该有一个只读的字符串属性 FunnyThingIHave，该属性有一个 get 访问器但没有 set
    访问器。'
- en: '**Here’s the IClown interface.** Did you get it right? It’s OK if you put the
    Honk method first—the order of the members doesn’t matter in an interface, just
    like it doesn’t matter in a class.'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**这是 IClown 接口的样子。** 你弄对了吗？如果你把 Honk 方法放在第一位也没关系——接口成员的顺序不重要，就像类中的顺序一样。'
- en: '[PRE7]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The IClown interface requires any class that implements it to have a void method
    called Honk and a string property called FunnyThingIHave that has a get accessor.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: IClown 接口要求任何实现它的类具有一个 void 方法 Honk 和一个名为 FunnyThingIHave 的字符串属性，该属性具有 get 访问器。
- en: '**Modify the TallGuy class so that it implements IClown.** Remember, the colon
    operator is always followed by the base class to inherit from (if any), and then
    a list of interfaces to implement, all separated by commas. Since there’s no base
    class and only one interface to implement, the declaration looks like this:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**修改 TallGuy 类，使其实现 IClown 接口。** 记住，冒号操作符后面总是跟着要继承的基类（如果有的话），然后是一系列以逗号分隔的要实现的接口。由于没有基类，只需实现一个接口，声明看起来像这样：'
- en: '[PRE8]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then make sure the rest of the class is the same, including the two fields
    and the method. Select Build Solution from the Build menu in the IDE to compile
    and build the program. You’ll see two errors:'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后确保类的其余部分保持不变，包括两个字段和方法。从 IDE 的“生成”菜单中选择“生成解决方案”来编译和构建程序。你会看到两个错误：
- en: '![Images](assets/361fig01.png)'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Images](assets/361fig01.png)'
- en: '**Fix the errors by adding the missing interface members.** The errors will
    go away as soon as you add all of the methods and properties defined in the interface.
    So go ahead and implement the interface. Add a read-only string property called
    FunnyThingIHave with a get accessor that always returns the string “big shoes”.
    Then add a Honk method that writes “Honk honk!” to the console.'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过添加缺失的接口成员来修复错误。** 一旦添加了接口中定义的所有方法和属性，错误就会消失。所以继续实现接口。添加一个只读的字符串属性 FunnyThingIHave，其
    get 访问器总是返回字符串 “big shoes”。然后添加一个 Honk 方法，将 “Honk honk!” 写入控制台。'
- en: 'Here’s what it’ll look like:'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是实现的样子：
- en: '![Images](assets/361fig02.png)'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Images](assets/361fig02.png)'
- en: '**Now your code will compile.** Update your Main method so that it prints the
    TallGuy object’s FunnyThingIHave property and then calls its Honk method:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**现在你的代码将会编译。** 更新你的Main方法，以便打印TallGuy对象的FunnyThingIHave属性，然后调用它的Honk方法：'
- en: '[PRE9]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![Images](assets/364fig01.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/364fig01.png)'
- en: 'Tonight’s talk: **An abstract class and an interface butt heads over the pressing
    question, “Who’s more important?**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 今晚的讨论：**抽象类和接口就“谁更重要”这个紧迫问题发生争执。**
- en: '| **Abstract Class:** | **Interface:** |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| **抽象类：** | **接口：** |'
- en: '| I think it’s obvious who’s more important between the two of us. Programmers
    need me to get their jobs done. Let’s face it. You don’t even come close. |  |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 我觉得很明显，在我们两个中间谁更重要。程序员需要我来完成他们的工作。面对现实吧，你远远不及我。 |  |'
- en: '|  | Nice. This oughta be good. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '|  | 不错，这肯定会很有意思。 |'
- en: '| You can’t really think you’re more important than me. You don’t even use
    real inheritance—you only get implemented. |  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 你真的以为你比我更重要吗？你甚至不使用真正的继承——你只被实现。 |  |'
- en: '|  | Great, here we go again. “Interfaces don’t use real inheritance.” “Interfaces
    only implement.” That’s just plain ignorant. Implementation is as good as inheritance.
    In fact, it’s better! |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '|  | 太好了，又来了。“接口不使用真正的继承。”“接口只实现。”这简直是无知。实现和继承一样好。事实上，它更好！ |'
- en: '| Better? You’re nuts. I’m much more flexible than you. Sure, I can’t be instantiated—but
    then, neither can you. Unlike you, I have the **awesome power** of inheritance.
    The poor saps that extend you can’t take advantage of `virtual` and `override`
    at all! |  |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 更好了吗？你疯了。我比你灵活得多。当然，我不能被实例化——但你也不行。不像你，我有继承的**强大力量**。那些扩展你的可怜家伙根本不能利用`virtual`和`override`！
    |  |'
- en: '|  | Yeah? What if you want a class that inherits from you ***and*** your buddy?
    **You can’t inherit from two classes.** You have to choose which class to inherit
    from. That’s just plain rude! There’s no limit to the number of interfaces a class
    can implement. Talk about flexible! With me, a programmer can make a class do
    anything. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '|  | 是吗？如果你想要一个类从你***和***你的朋友继承，**你不能从两个类继承**。你必须选择要从哪个类继承。这简直是无礼！一个类可以实现的接口数没有限制。说到灵活性！通过我，程序员可以让一个类做任何事情。
    |'
- en: '| **Abstract Class:** | **Interface:** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **抽象类：** | **接口：** |'
- en: '| You might be overstating your power a little bit. | Really, now? Well, let’s
    think about just how powerful I can be for developers that use me. I’m all about
    the job—when they get an interface reference, they don’t need to know anything
    about what’s going on inside that object at all. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 你可能夸大了自己的力量。 | 真的吗？那好，让我们考虑一下我对使用我的开发人员有多有力。我全靠工作——当他们得到一个接口的引用时，根本不需要知道对象内部正在发生什么。
    |'
- en: '| And you think that’s a good thing? Ha! When you use me and my subclasses,
    you know exactly what’s going on inside all of us. I can handle any behavior that
    all of my subclasses need, and they just need to inherit it. Transparency is a
    powerful thing, kiddo! | Nine times out of 10, a programmer wants to make sure
    an object has certain properties and methods, but doesn’t really care how they’re
    implemented. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 你认为那是好事吗？哈！当你使用我和我的子类时，你完全知道我们所有人内部都发生了什么。我可以处理所有子类需要的任何行为，他们只需继承它。透明性是一种强大的东西，小子！
    | 十有八九，程序员想要确保一个对象具有特定的属性和方法，但并不关心它们是如何实现的。 |'
- en: '| Really? I doubt that—programmers always care what’s in their properties and
    methods. | OK, sure. Eventually. But think about how many times you’ve seen a
    programmer write a method that takes an object that just needs to have a certain
    method, and it doesn’t really matter right at that very moment exactly how the
    method’s built—just that it’s there. So bang! The programmer just needs to use
    an interface. Problem solved! |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 真的吗？我怀疑，程序员总是关心他们的属性和方法。 | 好的，当然。最终。但是想想有多少次你看到程序员编写一个方法，只需一个具有某个方法的对象，此时方法的具体实现并不重要——只需它存在即可。所以轰！程序员只需使用一个接口。问题解决！
    |'
- en: '| Yeah, sure, tell a coder they can’t code. | Ugh, you’re ***so frustrating!***
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 是的，当然，告诉程序员他们不能编码。 | 哎呀，你真是让人***气愤至极！*** |'
- en: You can’t instantiate an interface, but you can reference an interface
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你不能实例化一个接口，但可以引用一个接口。
- en: Say you need an object that has a Defend method so you can use it in a loop
    to defend the hive. Any object that implemented the IDefender interface would
    do. It could be a HiveDefender object, a NectarDefender object, or even a HelpfulLadyBug
    object. As long as it implements the IDefender interface, that guarantees that
    it has a Defend method. You just need to call it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您需要一个具有Defend方法的对象，以便您可以在循环中使用它来保护蜂巢。任何实现IDefender接口的对象都可以。它可以是一个HiveDefender对象，一个NectarDefender对象，甚至是一个HelpfulLadyBug对象。只要它实现了IDefender接口，就保证它有一个Defend方法。您只需调用它。
- en: That’s where **interface references** come in. You can use one to refer to an
    object that implements the interface you need and you’ll always be sure that it
    has the right methods for your purpose—even if you don’t know much else about
    it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是**接口引用**的用处。您可以使用一个引用来引用实现您需要的接口的对象，您始终可以确保它具有适合您目的的正确方法——即使您对它了解不多。
- en: If you try to instantiate an interface, your code won’t build
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果您尝试实例化一个接口，您的代码将无法构建
- en: You can create an array of IWorker references, but you can’t instantiate an
    interface. What you *can* do is point those references at new instances of classes
    that implement IWorker. Now you can have an array that holds many different kinds
    of objects!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建一个IWorker引用数组，但是您不能实例化一个接口。您*可以*将这些引用指向实现IWorker的类的新实例。现在您可以拥有一个包含许多不同类型对象的数组！
- en: If you try to instantiate an interface, the compiler will complain.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试实例化一个接口，编译器会抱怨。
- en: '![Images](assets/366fig01.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/366fig01.png)'
- en: You can’t use the `new` keyword with an interface, which makes sense—the methods
    and properties don’t have any implementation. If you could create an object from
    an interface, how would it know how to behave?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能使用`new`关键字与接口一起使用，这是有道理的——方法和属性没有任何实现。如果您可以从接口创建对象，它怎么知道如何行为？
- en: Use the interface to reference an object you already have
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用界面引用您已经拥有的对象
- en: So you can’t instantiate an interface...but you ***can* use the interface to
    make a reference variable**, and use it to reference an object that ***implements***
    the interface.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你不能实例化一个接口...但是你可以使用接口来做一个引用变量，并用它来引用实现了接口的对象。
- en: Remember how you could pass a Tiger reference to any method that expects an
    Animal, because Tiger extends Animal? Well, this is the same thing—you can use
    an instance of a class that implements IDefender in any method or statement that
    expects an IDefender.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得如何将老虎引用传递给期望动物的任何方法吗？因为老虎扩展了动物？好吧，这也是一样的——您可以在期望IDefender的任何方法或语句中使用实现IDefender的类的实例。
- en: '![Images](assets/366fig002.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/366fig002.png)'
- en: These are ordinary `new` statements, just like you’ve been using for most of
    the book. The only difference is that you’re **using a variable of type IDefender**
    to reference them.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是普通的`new`语句，就像您在本书的大部分部分中一直使用的那样。唯一的区别是您使用IDefender类型的变量引用它们。
- en: '![Images](assets/366fig02.png)![Images](assets/367fig01.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/366fig02.png)![图片](assets/367fig01.png)'
- en: Note
  id: totrans-98
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Output**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '**5 Acts**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**5法案**'
- en: '**7 Clowns**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**7个小丑**'
- en: '**7 Of2016**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**2016年的7月**'
- en: '![Images](assets/368fig01.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/368fig01.png)'
- en: Interface references are ordinary object references
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口引用是普通的对象引用
- en: You already know all about how objects live in the heap. When you work with
    an interface reference, it’s just another way to refer to the same objects you’ve
    already been using. Let’s take a closer look at how interfaces would be used to
    reference objects in the heap.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经了解了对象如何存储在堆中。当您使用接口引用时，这只是引用您已经使用的相同对象的另一种方式。让我们更详细地看看如何使用接口来引用堆中的对象。
- en: '**We’ll start by creating objects as usual.**'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们将像往常一样创建对象。**'
- en: 'Here’s code to create some bees: it creates an instance of HiveDefender and
    an instance of NectarDefender—and both of those classes implement the IDefender
    interface.'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是一些创建蜜蜂的代码：它创建了HiveDefender的一个实例和NectarDefender的一个实例——这两个类都实现了IDefender接口。
- en: '[PRE10]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![Images](assets/369fig01.png)'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/369fig01.png)'
- en: '**Next we’ll add IDefender references.**'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**接下来我们将添加IDefender引用。**'
- en: You can use interface references just like you use any other reference type.
    These two statements use interfaces to create **new references to existing objects**.
    You can only point an interface reference at an instance of a class that implements
    it.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以像使用任何其他引用类型一样使用接口引用。这两个语句使用接口来创建对现有对象的**新引用**。您只能将接口引用指向实现它的类的实例。
- en: '[PRE11]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![Images](assets/369fig02.png)'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/369fig02.png)'
- en: '**An interface reference will keep an object alive.**'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**接口引用会使对象保持活动状态。**'
- en: When there aren’t any references pointing to an object, it disappears. There’s
    no rule that says those references all have to be the same type! An interface
    reference is just as good as any other object reference when it comes to keeping
    track of objects so they don’t get garbage-collected.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当没有引用指向一个对象时，它就消失了。并没有规定这些引用都必须是同一类型！接口引用在跟踪对象以避免被垃圾回收时和其他对象引用一样好用。
- en: '![Images](assets/369fig03.png)'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/369fig03.png)'
- en: '**Use an interface like any other type.**'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**像使用任何其他类型一样使用接口。**'
- en: You can create a new object with a `new` statement and assign it straight to
    an interface reference variable in a single line of code. You can **use interfaces
    to create arrays** that can reference any object that implements the interface.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以用`new`语句创建一个新对象，并将其直接分配给一个接口引用变量，一行代码搞定。你可以**使用接口创建数组**，这些数组可以引用任何实现了接口的对象。
- en: '[PRE12]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The RoboBee 4000 can do a worker bee’s job without using valuable honey
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RoboBee 4000可以完成工蜂的工作，而不使用宝贵的蜂蜜。
- en: 'Bee-siness was booming last quarter, and the Queen had enough spare budget
    to buy the latest in hive technology: the RoboBee 4000\. It can do the work of
    three different bees, and best of all it doesn’t consume any honey! It’s not exactly
    environmentally friendly, though—it runs on gas. So how can we use interfaces
    to integrate RoboBee into the hive’s day-to-day business?'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 上个季度的蜜蜂业务蓬勃发展，女王有足够的预算购买了最新的蜂箱技术：RoboBee 4000。它可以完成三只不同蜜蜂的工作，最重要的是它不消耗任何蜂蜜！虽然这不算是环保，因为它使用的是燃气。那么我们如何使用接口将RoboBee整合到蜂箱的日常业务中呢？
- en: '![Images](assets/370fig01.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/370fig01.png)'
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Let’s take a close look at the class diagram to see how we can use an interface
    to integrate a RoboBee class into the Beehive Management System. Remember, we’re
    using dotted lines to show that an object implements an interface.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看类图，看看我们如何使用接口将RoboBee类集成到蜂巢管理系统中。记住，我们用虚线表示对象实现了接口。
- en: '![Images](assets/370fig02.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/370fig02.png)'
- en: Now all we need to do is modify the Beehive Management System to use the IWorker
    interface instead of the abstract Bee class any time it needs to reference a worker.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要修改蜂巢管理系统，在需要引用工作者时都使用IWorker接口，而不是抽象的Bee类。
- en: '**Everything in a public interface is automatically public, because you’ll
    use it to define the public methods and properties of any class that implements
    it.**'
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**公共接口中的一切都自动是公共的，因为你会用它来定义任何实现它的类的公共方法和属性。**'
- en: The IWorker’s Job property is a hack
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IWorker的Job属性是一个hack。
- en: 'The Beehive Management System uses the Worker.Job property like this: `if (worker.Job
    == job)`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 蜂巢管理系统使用Worker.Job属性如下：`if (worker.Job == job)`
- en: 'Does something seem a bit odd about that? It does to us. We think it’s a **hack**,
    or a clumsy, inelegant solution. Why do we think the Jobproperty is a hack? Imagine
    what would happen if you had a typo like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有点奇怪吧？对我们来说确实如此。我们认为这是一个**hack**，或者说是一个笨拙、不优雅的解决方案。我们为什么认为Job属性是一个hack呢？想象一下，如果你出现了这样的拼写错误：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-133
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We misspelled “Egg Care”—that’s a mistake anyone could make! Can you imagine
    how hard it would be to track down the bugs that this simple typo would cause?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们把“Egg Care”拼错了——这是任何人都可能犯的错误！你能想象这个简单拼写错误会导致多难以追踪的bug吗？
- en: Now the code has no way to figure out if a Worker reference is pointing to an
    instance of EggCare. That would be a really nasty bug to try to fix. So we know
    this code is error-prone...but how is it a hack?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码没有办法判断Worker引用是否指向EggCare的实例。这将是一个非常难以修复的恶心bug。所以我们知道这段代码容易出错……但它为什么是一个hack呢？
- en: 'We’ve talked about **separation of concerns**: all of the code to address a
    specific problem should be kept together. The Job property ***violates the principle
    of separation of concerns***. If we have a Worker reference, we shouldn’t need
    to check a string to figure out whether it points to an EggCare object or a NectarCollector
    object. The Job property returns “Egg Care” for an EggCare object and “Nectar
    Collector” for a NectarCollector object and is only used to check the object’s
    type. But we’re already keeping track of that information: ***it’s the object’s
    type***.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们谈论了**关注点分离**：解决特定问题的所有代码应该放在一起。Job属性***违反了关注点分离原则***。如果我们有一个Worker引用，我们不应该需要检查一个字符串来确定它是否指向一个EggCare对象或一个NectarCollector对象。Job属性对于EggCare对象返回“Egg
    Care”，对于NectarCollector对象返回“Nectar Collector”，仅用于检查对象的类型。但我们已经跟踪了这个信息：***它就是对象的类型***。
- en: '![Images](assets/373fig01.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/373fig01.png)'
- en: '**That’s right! C# gives you tools to work with types.**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**没错！C#提供了处理类型的工具。**'
- en: You don’t ever need a property like Job to keep track of the type of a class
    with strings like “Egg Care” or “Nectar Collector”. C# gives you tools that let
    you check the type of an object.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你永远不需要像“Egg Care”或“Nectar Collector”这样的字符串来跟踪类的类型属性，C#提供了工具，让你可以检查对象的类型。
- en: Use “is” to check the type of an object
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用“is”来检查对象的类型
- en: 'What would it take to get rid of the Job property hack? Right now the Queen
    has her `workers` array, which means that all she can get is an IWorker reference.
    She uses the Job property to figure out which workers are EggCare workers and
    which ones are NectarCollectors:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如何消除Job属性的hack？目前女王有她的`workers`数组，这意味着她只能获取到IWorker引用。她使用Job属性来区分哪些工人是EggCare工人，哪些是NectarCollector工人：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We just saw how that code will fail miserably if we accidentally type “Egg Crae”
    instead of “Egg Care”. And if you set a HoneyManufacturer’s Job to “Egg Care”
    accidentally, you’ll get one of those InvalidCastException errors. It would be
    great if the compiler could detect problems like that as soon as we write them,
    just like we use private or abstract members to get it to detect other kinds of
    problems.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到，如果我们意外地输入“Egg Crae”而不是“Egg Care”，那段代码将会彻底失败。如果你意外地将HoneyManufacturer的Job设置为“Egg
    Care”，你将会得到一个InvalidCastException错误。如果编译器能在我们编写这些代码时就检测到这些问题，就像我们使用私有或抽象成员一样检测其他类型的问题一样，那将是非常好的。
- en: '![Images](assets/375fig01.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/375fig01.png)'
- en: 'C# gives us a tool to do exactly that: we can use the `**is**` **keyword**
    to check an object’s type. If you have an object reference, you can **use `is`
    to find out if it’s a specific type:**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: C#给了我们一个工具来做到这一点：我们可以使用`**is**` **关键字**来检查对象的类型。如果你有一个对象引用，你可以**使用`is`来找出它是否是特定类型的：**
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If the object that objectReference is pointing to has ObjectType as its type,
    then it returns true and creates a new reference called `newVariable` with that
    type.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果objectReference指向的对象的类型是ObjectType，那么它返回true，并创建一个名为`newVariable`的新引用，该引用具有该类型。
- en: 'So if the Queen wants to find all of her EggCare workers and have them work
    a night shift, she can use the `is` keyword:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果女王想找到所有的EggCare工人，并让他们进行夜班工作，她可以使用`is`关键字：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `if` statement in this loop uses `is` to check each IWorker reference.
    Look closely at the conditional test:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此循环中的if语句使用`is`来检查每个IWorker引用。仔细观察条件测试：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If the object referenced by the `worker` variable is an EggCare object, that
    test returns true, and the `is` statement assigns the reference to a new EggCare
    variable called `eggCareWorker`. This is just like casting, but the `is` statement
    is **doing the casting for you safely.**
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`worker`变量引用的对象是一个EggCare对象，那么该测试将返回true，并且`is`语句将该引用分配给一个新的名为`eggCareWorker`的EggCare变量。这与强制转换类似，但`is`语句**安全地执行强制转换**。
- en: '**The is keyword returns true if an object matches a type, and can declare
    a variable with a reference to that object.**'
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**is关键字在对象匹配类型时返回true，并且可以声明一个具有对该对象引用的变量。**'
- en: Use “is” to access methods in a subclass
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用“is”来访问子类中的方法
- en: Let’s pull together everything we’ve talked about so far into a new project
    by creating a simple class model with Animal at the top, Hippo and Canine classes
    that extend Animal, and a Wolf class that extends Canine.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把我们到目前为止讨论的一切汇总到一个新项目中，通过创建一个简单的类模型，Animal在顶部，Hippo和Canine类扩展Animal，以及一个扩展Canine的Wolf类。
- en: '***Do this!***'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '***做这个！***'
- en: 'Create a new console app and **add these Animal, Hippo, Canine, and Wolf classes**
    to it:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序，并**添加这些Animal、Hippo、Canine和Wolf类**到其中：
- en: '![Images](assets/376fig01.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/376fig01.png)'
- en: Note
  id: totrans-159
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注：
- en: '**In [#inheritance_your_objectapostrophes_famil](ch06.html#inheritance_your_objectapostrophes_famil)
    we learned that we could use different references to call different methods on
    the same object. When you didn’t use the override and virtual keywords, if your
    reference variable had the type Locksmith it called Locksmith.ReturnContents,
    but if it was a JewelThief type it called JewelThief.ReturnContents. We’re doing
    something similar here.**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**在[#inheritance_your_objectapostrophes_famil](ch06.html#inheritance_your_objectapostrophes_famil)我们学习到，我们可以使用不同的引用调用同一对象的不同方法。当你没有使用override和virtual关键字时，如果你的引用变量是Locksmith类型，它调用Locksmith.ReturnContents，但如果是JewelThief类型，它调用JewelThief.ReturnContents。我们在这里做了类似的事情。**'
- en: 'Next, fill in the Main method. Here’s what it does:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，填写Main方法。它的作用如下：
- en: It creates an array of Hippo and Wolf objects, then uses a foreach loop to go
    through each of them.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建了一个Hippo和Wolf对象的数组，然后使用foreach循环遍历每个对象。
- en: It uses the Animal reference to call the MakeNoise method.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用Animal引用调用MakeNoise方法。
- en: If it’s a Hippo, the Main method calls its Hippo.Swim method.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是Hippo，Main方法调用其Hippo.Swim方法。
- en: If it’s a Wolf, the Main method calls its Wolf.HuntInPack method.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是Wolf，Main方法调用其Wolf.HuntInPack方法。
- en: 'The problem is that if you have an Animal reference pointing to a Hippo object,
    you can’t use it to call Hippo.Swim:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，如果你有一个Animal引用指向一个Hippo对象，你不能使用它来调用Hippo.Swim：
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It doesn’t matter that your object is a Hippo. If you’re using an Animal variable,
    you can only access the fields, methods, and properties of Animal.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你的对象是Hippo并不重要。如果你使用Animal变量，你只能访问Animal的字段、方法和属性。
- en: 'Luckily, there’s a way around this. If you’re 100% sure that you have a Hippo
    object, then you can **cast your Animal reference to a Hippo**—and then you can
    access its Hippo.Swim method:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一种方法可以解决这个问题。 如果你完全确定你有一个Hippo对象，那么你可以将你的Animal引用转换为Hippo——然后你可以访问它的Hippo.Swim方法：
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here’s **the Main method that uses the** `**is**` **keyword** to call Hippo.Swim
    or Wolf.HuntInPack:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是**使用**`**is**` **keyword** **调用Hippo.Swim或Wolf.HuntInPack的Main方法**：
- en: '![Images](assets/377fig01.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/377fig01.png)'
- en: Note
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Take a few minutes and use the debugger to really understand what’s going
    on here. Put a breakpoint on the first line of the foreach loop; add watches for
    `animal, hippo`, and `wolf`; and step through it.**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**花几分钟时间，使用调试器真正理解这里发生了什么。在foreach循环的第一行设置断点；添加`animal, hippo`和`wolf`的监视器；并逐步执行。**'
- en: What if we want different animals to swim or hunt in packs?
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果我们希望不同的动物能够游泳或者群体狩猎怎么办？
- en: Did you know that lions are pack hunters? Or that tigers can swim? And what
    about dogs, which hunt in packs AND swim? If we want to add the Swim and HuntInPack
    methods to all of the animals in our zoo simulator model that need them, the foreach
    loop is just going to get longer and longer.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道狮子是群体猎手吗？还是老虎会游泳？那狗呢，它们既群体狩猎又游泳？如果我们想要将Swim和HuntInPack方法添加到我们动物园模拟器模型中所有需要它们的动物中，那么foreach循环将变得越来越长。
- en: 'The beauty of defining an abstract method or property in a base class and overriding
    it in a subclass is that **you don’t need to know anything about the subclass**
    to use it. You can add all of the Animal subclasses you want, and this loop will
    still work:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在基类中定义抽象方法或属性并在子类中重写它的美妙之处在于**你不需要知道任何关于子类的信息**就可以使用它。你可以添加所有想要的Animal子类，这个循环仍然有效：
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The MakeNoise method will **always be implemented by the object.**
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**MakeNoise方法将始终由对象实现。**'
- en: In fact, you can treat it like a **contract** that the compiler enforces.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以把它看作是一个**合同**，编译器强制执行。
- en: Note
  id: totrans-181
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**So is there a way to treat the HuntInPack and Swim methods like contracts
    too, so we can use more general variables with them­—just like we do with the
    Animal class?**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**那么是否有办法将HuntInPack和Swim方法也像契约一样对待，这样我们就可以用更一般的变量来使用它们——就像我们对Animal类所做的那样？**'
- en: '![Images](assets/378fig01.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/378fig01.png)'
- en: Use interfaces to work with classes that do the same job
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用接口来处理执行相同工作的类
- en: 'Classes that swim have a Swim method, and classes that hunt in packs have a
    HuntInPack method. OK, that’s a good start. Now we want to write code that works
    with objects that swim or hunt in packs­—and that’s where interfaces shine. Let’s
    use the `**interface**` **keyword** to define two interfaces and **add an abstract
    member** to each interface:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 有游泳的类有一个Swim方法，有群体狩猎的类有一个HuntInPack方法。好的，这是一个良好的开端。现在我们想写能够处理游泳或群体狩猎对象的代码——这就是接口发挥作用的地方。让我们使用`**interface**`
    **keyword**来定义两个接口，并**add an abstract member**到每个接口：
- en: '![Images](assets/379fig01.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/379fig01.png)'
- en: '***Add this!***'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '***Add this!***'
- en: Next, **make the Hippo and Wolf classes implement the interfaces** by adding
    an interface to the end of each class declaration. Use a **colon** (:) to implement
    an interface, just like you do when you’re extending a class. If it’s already
    extending a class, you just add a comma after the superclass and then the interface
    name. Then you just need to make sure the class **implements all the interface
    members**, or you’ll get a compiler error.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，**使Hippo和Wolf类实现这些接口**，只需在每个类声明的末尾添加一个接口。像扩展类时一样使用**冒号**（:)来实现一个接口。如果已经扩展了一个类，只需在超类之后添加一个逗号，然后是接口名。然后，你只需确保类**实现了所有接口成员**，否则会得到编译器错误。
- en: '[PRE22]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Use the “is” keyword to check if the Animal is a swimmer or pack hunter
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用“is”关键字来检查Animal是否是游泳者或群体猎手
- en: 'You can use the `**is**` **keyword** to check if a specific object implements
    an interface—and it works no matter what other classes that object implements.
    If the `animal` variable references an object that implements the ISwimmer interface,
    then `animal is ISwimmer` will return true and you can safely cast it to an ISwimmer
    reference to call its Swim method:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`**is**` **关键字**来检查特定对象是否实现了接口——无论该对象实现了哪些其他类。如果animal变量引用了一个实现了ISwimmer接口的对象，那么`animal
    is ISwimmer`将返回true，并且你可以安全地将其转换为ISwimmer引用以调用其Swim方法：
- en: '![Images](assets/379fig02.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/379fig02.png)'
- en: Safely navigate your class hierarchy with “is”
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用“is”安全地导航你的类层次结构
- en: When you did the exercise to replace Bee with IWorker in the Beehive Management
    System, were you able to get it to throw the InvalidCastException? ***Here’s why
    it threw the exception.***
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在替换蜜蜂管理系统中的Bee为IWorker时，你能否使其抛出InvalidCastException？***以下是它抛出异常的原因***。
- en: '![Images](assets/380fig01.png) **You can safely convert a NectarCollector reference
    to an IWorker reference.**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](assets/380fig01.png) **你可以安全地将NectarCollector引用转换为IWorker引用**。'
- en: All NectarCollectors are Bees (meaning they extend the Bee base class), so you
    can always use the = operator to take a reference to a NectarCollector and assign
    it to a Bee variable.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 所有NectarCollectors都是Bees（即它们扩展了Bee基类），所以你始终可以使用=运算符将NectarCollector的引用赋给Bee变量。
- en: '[PRE23]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: And since Bee implements the IWorker interface, you can safely convert it to
    an IWorker reference too.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 并且由于Bee实现了IWorker接口，所以你也可以安全地将其转换为IWorker引用。
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Those type conversions are safe: they’ll never throw an IllegalCastException
    because they only assign more specific objects to variables with more general
    types *in the same class hierarchy*.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型转换是安全的：它们永远不会抛出IllegalCastException，因为它们只能将更具体的对象分配给具有更一般类型的变量*在同一类层次结构中*。
- en: '![Images](assets/380fig02.png) **You can’t safely convert a Bee reference to
    a NectarCollector reference.**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](assets/380fig02.png) **你不能安全地将Bee引用转换为NectarCollector引用**。'
- en: 'You can’t safely go in the other direction—converting a Bee to a NectarCollector—because
    not all Bee objects are instances of NectarCollector. A HoneyManufacturer is *definitely
    not* a NectarCollector. So this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能安全地反向操作——将Bee转换为NectarCollector——因为并非所有Bee对象都是NectarCollector的实例。HoneyManufacturer*绝对不是*
    NectarCollector。所以这个：
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: is an **invalid cast** that tries to cast an object to a variable that doesn’t
    match its type.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 是一种试图将对象转换为不匹配其类型的变量的**无效转换**。
- en: '![Images](assets/380fig03.png) **The “is” keyword lets you convert types safely.**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](assets/380fig03.png) **“is”关键字让你可以安全地转换类型**。'
- en: Luckily, **the `is` keyword is safer than casting with parentheses**. It lets
    you check that the type matches, and only casts the reference to a new variable
    if the types match.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，**`is`关键字比用括号进行转换更安全**。它允许你检查类型是否匹配，并且只有在类型匹配时才将引用转换为新变量。
- en: '[PRE26]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code will never throw an InvalidCastException because it only executes
    the code that uses a NectarCollector object if `pearl` is a NectarCollector.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码永远不会抛出InvalidCastException，因为它只有在`pearl`是NectarCollector时才会执行使用NectarCollector对象的代码。
- en: 'C# has another tool for safe type conversion: the “as” keyword'
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#还有另一种安全类型转换的工具：**“as”关键字**
- en: 'C# gives you another tool for safe casting: the **`as` keyword**. It also does
    safe type conversion. Here’s how it works. Let’s say you have an IWorker reference
    called `pearl`, and you want to safely cast it to a NectarCollector variable `irene`.
    You can convert it safely to a NectarCollector like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: C#为安全转换提供了另一种工具：**`as`关键字**。它也执行安全类型转换。以下是其工作原理。假设你有一个名为`pearl`的IWorker引用，并且你想将其安全地转换为NectarCollector变量`irene`。你可以这样安全地将其转换为NectarCollector：
- en: '[PRE27]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If the types are compatible, this statement sets the `irene` variable to reference
    the same object as the `pearl` variable. If the type of the object doesn’t match
    the type of the variable, it doesn’t throw an exception. Instead, it just **sets
    the variable to `null`**, which you can check with an `if` statement:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型兼容，此语句将`irene`变量设置为引用与`pearl`变量相同的对象。如果对象的类型与变量的类型不匹配，它不会抛出异常。而是将变量设置为`null`，您可以使用`if`语句检查：
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Use upcasting and downcasting to move up and down a class hierarchy
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用向上转型和向下转型在类层次结构中向上和向下移动
- en: Class diagrams typically have the base class at the top, its subclasses below
    it, their subclasses below them, etc. The higher a class is in the diagram, the
    more abstract it is; the lower the class is in the diagram, the more concrete
    it is. “Abstract higher, concrete lower” isn’t a hard-and-fast rule—it’s a **convention**
    that makes it easier for us to see at a glance how our class models work.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 类图通常将基类放在顶部，其子类放在其下方，它们的子类依次排列。在图表中，类越高抽象性越强；类越低具体性越强。“抽象高，具体低”并非一成不变的规则，这是一个让我们一眼看清楚我们类模型工作原理的**约定**。
- en: 'In [#inheritance_your_objectapostrophes_famil](ch06.html#inheritance_your_objectapostrophes_famil)
    we talked about how you can always use a subclass in place of the base class it
    inherits from, but you can’t always use a base class in place of a subclass that
    extends it. You can also think about this another way: in a sense, you’re **moving
    up or down the class hierarchy**. For example, if you start with this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在[#inheritance_your_objectapostrophes_famil](ch06.html#inheritance_your_objectapostrophes_famil)中，我们讨论了如何始终可以使用子类替代它继承的基类，但不能总是可以使用基类替代扩展它的子类。您还可以以另一种方式考虑这个问题：从某种意义上讲，您正在**向上或向下移动**类层次结构。例如，如果您从这开始：
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can use the = operator to do normal assignment (for superclasses) or casting
    (for interfaces). That’s like ***moving up*** the class hierarchy. This is called
    **upcasting**:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用=运算符来执行普通赋值（用于超类）或转型（用于接口）。这就像***向上移动***类层次结构。这被称为**向上转型**：
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And you can navigate in the other direction by using the `is` operator to safely
    ***move down*** the class hierarchy. This is called **downcasting**:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`is`运算符可以安全地***向下移动***类层次结构。这被称为**向下转型**：
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![Images](assets/382fig01.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/382fig01.png)'
- en: A quick example of upcasting
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速的向上转型示例
- en: If you’re trying to figure out how to cut down your energy bill each month,
    you don’t really care what each of your appliances does—you only care that they
    consume power. So if you were writing a program to monitor your electricity consumption,
    you’d probably just write an Appliance class. But if you needed to distinguish
    a coffee maker from an oven, you’d have to build a class hierarchy and add the
    methods and properties that are specific to a coffee maker or oven to your CoffeeMaker
    and Oven classes, which would inherit from an Appliance class that has their common
    methods and properties.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在努力找出如何每个月削减能源账单，您并不真的关心每个家电做什么——您只关心它们消耗的电力。因此，如果您正在编写一个程序来监控您的电力消耗，您可能只会编写一个Appliance类。但是，如果您需要区分咖啡机和烤箱，您就必须构建一个类层次结构，并将特定于咖啡机或烤箱的方法和属性添加到您的CoffeeMaker和Oven类中，它们将继承自具有它们共同方法和属性的Appliance类。
- en: 'Then you could write a method to monitor the power consumption:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以编写一个方法来监控功耗：
- en: '![Images](assets/383fig02.png)![Images](assets/383fig01.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/383fig02.png)![图片](assets/383fig01.png)'
- en: 'If you wanted to use that method to monitor the power consumption for a coffee
    maker, you could create an instance of CoffeeMaker and pass its reference directly
    to the method:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要使用该方法监控咖啡机的功耗，您可以创建一个CoffeeMaker的实例并直接将其引用传递给该方法：
- en: '![Images](assets/383fig03.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/383fig03.png)'
- en: Upcasting turns your CoffeeMaker into an Appliance
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向上转型将您的CoffeeMaker转换为一个Appliance
- en: When you substitute a subclass for a base class—like substituting a CoffeeMaker
    for an Appliance, or a Hippo for an Animal—it’s called **upcasting**. It’s a really
    powerful tool to use when you build class hierarchies. The only drawback to upcasting
    is that you can only use the properties and methods of the base class. In other
    words, when you treat a CoffeeMaker like an Appliance, you can’t tell it to make
    coffee or fill it with water. You *can* tell whether or not it’s plugged in, since
    that’s something you can do with any Appliance (which is why the PluggedIn property
    is part of the Appliance class).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当你用子类替换基类——比如用咖啡机替换家电，或者用河马替换动物——这被称为**向上转型**。在构建类层次结构时，这是一个非常强大的工具。向上转型的唯一缺点是，你只能使用基类的属性和方法。换句话说，当你把咖啡机当作家电时，你不能让它制作咖啡或加水。你可以判断它是否插上电源，因为这是你可以对任何家电做的事情（这就是为什么PluggedIn属性属于家电类的原因）。
- en: '**Let’s create some objects.**'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**让我们创建一些对象。**'
- en: 'Let’s start by creating instances of the CoffeeMaker and Oven classes as usual:'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们像往常一样创建咖啡机和烤箱类的实例：
- en: '[PRE32]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**You don’t need to add this code to an app—just read through the code and
    start to get a sense of how upcasting and downcasting work. You’ll get lots of
    practice with them later in the book.**'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**你不需要将这段代码添加到应用中——只需阅读代码并开始了解向上转型和向下转型的工作原理。你将在本书的后续章节中获得大量实践。**'
- en: '**What if we want to create an array of Appliances?**'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果我们想要创建一个家电数组怎么办？**'
- en: 'You can’t put a CoffeeMaker in an Oven[] array, and you can’t put an Oven in
    a CoffeeMaker[] array. You ***can*** put both of them in an Appliance[] array:'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你不能把咖啡机放入一个Oven[]数组中，也不能把烤箱放入一个CoffeeMaker[]数组中。但是你***可以***把它们都放入一个Appliance[]数组中：
- en: '[PRE33]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can use upcasting to create an array of Appliances that can hold both CoffeeMakers
    and Ovens.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以使用向上转型创建一个可以容纳咖啡机和烤箱的家电数组。
- en: '**But you can’t treat just any Appliance like an Oven.**'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**但你不能把任何家电都当作烤箱来对待。**'
- en: 'When you’ve got an Appliance reference, you can **only** access the methods
    and properties that have to do with appliances. You **can’t** use the CoffeeMaker
    methods and properties through the Appliance reference ***even if you know it’s
    really a CoffeeMaker***. So these statements will work just fine, because they
    treat a CoffeeMaker object like an Appliance:'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你有一个家电的引用时，你只能访问与家电相关的方法和属性。通过家电引用，即使你知道它实际上是一个咖啡机，你也**不能**使用咖啡机的方法和属性。所以这些语句将正常工作，因为它们把一个咖啡机对象当作家电来对待：
- en: '![Images](assets/384fig001.png)'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图像](assets/384fig001.png)'
- en: 'your code won’t compile, and the IDE will display an error:'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的代码不会编译，并且IDE会显示错误：
- en: '![Images](assets/384fig01.png)'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图像](assets/384fig01.png)'
- en: Once you upcast from a subclass to a base class, you can only access the methods
    and properties that **match the reference** that you’re using to access the object.
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦你从子类向基类向上转型，你只能访问与你用来访问对象的引用匹配的方法和属性。
- en: '![Images](assets/384fig02.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/384fig02.png)'
- en: Downcasting turns your Appliance back into a CoffeeMaker
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向下转型将你的家电转换回咖啡机。
- en: 'Upcasting is a great tool, because it lets you use a CoffeeMaker or an Oven
    anywhere you just need an Appliance. But it’s got a big drawback—if you’re using
    an Appliance reference that points to a CoffeeMaker object, you can only use the
    methods and properties that belong to Appliance. That’s where **downcasting**
    comes in: that’s how you take your **previously upcast reference** and change
    it back. You can figure out if your Appliance is really a CoffeeMaker using the
    `**is**` keyword, and if it is you can convert it back to a CoffeeMaker.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 向上转型是一个很好的工具，因为它让你可以在任何需要家电的地方使用咖啡机或烤箱。但是它有一个很大的缺点——如果你使用一个指向咖啡机对象的家电引用，你只能使用属于家电的方法和属性。这就是**向下转型**的用武之地：这是如何将你的**之前向上转型的引用**重新改回的方法。你可以使用`**is**`关键字来判断你的家电是否真的是一个咖啡机，如果是，你可以将它转换回咖啡机。
- en: '**We’ll start with the CoffeeMaker we already upcast.**'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们将从已经向上转型的咖啡机开始。**'
- en: 'Here’s the code that we used:'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是我们使用的代码：
- en: '[PRE34]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**What if we want to turn the Appliance back into a CoffeeMaker?**'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果我们想把家电转换回咖啡机怎么办？**'
- en: 'Let’s say we’re building an app that looks in an array of Appliance references
    so it can make our CoffeeMaker start brewing. We can’t just use our Appliance
    reference to call the CoffeeMaker method:'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设我们正在构建一个应用程序，该应用程序查找一个家电引用数组，以便让我们的咖啡机开始冲泡。我们不能只使用我们的家电引用调用咖啡机方法：
- en: '[PRE35]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: That statement won’t compile—you’ll get that “‘Appliance’ does not contain a
    definition for ‘StartBrewing’” compiler error because StartBrewing is a member
    of CoffeeMaker but you’re using an Appliance reference.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 那个语句无法编译 —— 因为 StartBrewing 是 CoffeeMaker 的成员，但您正在使用 Appliance 引用。
- en: '![Images](assets/385fig001.png)'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Images](assets/385fig001.png)'
- en: '**But since we know it’s a CoffeeMaker, let’s use it like one.**'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**但既然我们知道它是咖啡机，让我们像使用咖啡机一样使用它。**'
- en: The `is` keyword is the first step. Once you know that you’ve got an Appliance
    reference that’s pointing to a CoffeeMaker object, you can use `**is**` to downcast
    it. That lets you use the CoffeeMaker class’s methods and properties. Since CoffeeMaker
    inherits from Appliance, it still has its Appliance methods and properties.
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`is` 关键字是第一步。一旦确定你有一个指向 CoffeeMaker 对象的 Appliance 引用，就可以使用 `**is**` 进行向下转型。这样可以使用
    CoffeeMaker 类的方法和属性。由于 CoffeeMaker 继承自 Appliance，它仍然具有其 Appliance 的方法和属性。'
- en: '[PRE36]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![Images](assets/385fig002.png)![Images](assets/385fig01.png)'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Images](assets/385fig002.png)![Images](assets/385fig01.png)'
- en: Upcasting and downcasting work with interfaces, too
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向上转型和向下转型也适用于接口
- en: 'Interfaces work really well with upcasting and downcasting. Let’s add an ICooksFood
    interface for any class that can heat up food. Next, we’ll add a Microwave class—both
    Microwave and Oven implement the ICooksFood interface. Now a reference to an Oven
    object can be an ICooksFood reference, a Microwave reference, or an Oven reference.
    That means we have three different types of references that could point to an
    Oven object—and each of them can access different members, depending on the reference’s
    type. Luckily, the IDE’s IntelliSense can help you figure out exactly what you
    can and can’t do with each of them:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 接口在向上转型和向下转型中表现非常出色。让我们为任何可以加热食物的类添加一个 ICooksFood 接口。接下来，我们将添加一个 Microwave 类——Microwave
    和 Oven 都实现了 ICooksFood 接口。现在，对 Oven 对象的引用可以是 ICooksFood 引用、Microwave 引用或 Oven
    引用。这意味着我们有三种不同类型的引用可以指向一个 Oven 对象，每种引用根据其类型可以访问不同的成员。幸运的是，IDE 的 IntelliSense 可以帮助您确切地了解每种引用可以做什么和不能做什么：
- en: '[PRE37]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![Images](assets/386fig01.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/386fig01.png)'
- en: Note
  id: totrans-266
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As soon as you type the dot, the IntelliSense window will pop up with a list
    of all of the members you can use. `misterToasty` is an Oven reference pointing
    to an Oven object, so it can access all of the methods and properties. It’s the
    most specific type, so you can only point it at Oven objects.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦输入点，IntelliSense 窗口将弹出一个列表，列出您可以使用的所有成员。`misterToasty` 是指向 Oven 对象的 Oven 引用，因此它可以访问所有方法和属性。这是最具体的类型，因此您只能将其指向
    Oven 对象。
- en: '![Images](assets/386fig04.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/386fig04.png)'
- en: 'To access ICooksFood interface members, convert it to an ICooksFood reference:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问 ICooksFood 接口成员，请将其转换为 ICooksFood 引用：
- en: '[PRE38]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '![Images](assets/386fig02.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/386fig02.png)'
- en: Note
  id: totrans-272
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`cooker` is an ICooksFood reference pointing to that same Oven object. It can
    only access ICooksFood members, but it can also point to a Microwave object.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`cooker` 是指向同一 Oven 对象的 ICooksFood 引用。它只能访问 ICooksFood 成员，但也可以指向 Microwave
    对象。'
- en: 'This is the same Oven class that we used earlier, so it also extends the Appliance
    base class. If you use an Appliance reference to access the object, you’ll only
    see members of the Appliance class:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前使用过的同一个 Oven 类，因此它也扩展了 Appliance 基类。如果使用 Appliance 引用访问对象，您只能看到 Appliance
    类的成员：
- en: '[PRE39]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '![Images](assets/386fig03.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/386fig03.png)'
- en: Note
  id: totrans-277
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`powerConsumer` is an Appliance reference. It only lets you get to the public
    fields, methods, and properties in Appliance. It’s more general than an Oven reference
    (so you could point it at a CoffeeMaker object if you wanted to).'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`powerConsumer` 是一个 Appliance 引用。它只允许您访问 Appliance 的公共字段、方法和属性。它比 Oven 引用更一般（所以如果需要，您可以将其指向
    CoffeeMaker 对象）。'
- en: Note
  id: totrans-279
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Three different references that point to the same object can access different
    methods and properties, depending on the reference’s type.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 指向同一对象的三个不同引用可以根据引用的类型访问不同的方法和属性。
- en: Interfaces can inherit from other interfaces
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口可以继承其他接口
- en: As we’ve mentioned, when one class inherits from another, it gets all of the
    methods and properties from the base class. **Interface inheritance** is simpler.
    Since there’s no actual method body in any interface, you don’t have to worry
    about calling base class constructors or methods. The inherited interfaces **accumulate
    all of the members** of the interfaces that they extend.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们提到的，当一个类从另一个类继承时，它会获取基类中的所有方法和属性。**接口继承**更简单。由于任何接口中都没有实际的方法体，因此您无需担心调用基类的构造函数或方法。继承的接口**累积了它们扩展的所有成员**。
- en: 'So what does this look like in code? Let’s add an IDefender interface that
    inherits from IWorker:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 那么代码是什么样子的呢？让我们添加一个从 IWorker 继承的 IDefender 接口：
- en: '![Images](assets/388fig001.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/388fig001.png)'
- en: When a class implements an interface, it must implement every property and method
    in that interface. If that interface inherits from another one, then all of *those*
    properties and methods need to be implemented, too. So any class that implements
    IDefender not only must implement all of the IDefender members, but also all of
    the IWorker members. Here’s a class model that includes IWorker and IDefender,
    and **two separate hierarchies** that implement them.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类实现一个接口时，它必须实现该接口中的每个属性和方法。如果该接口又继承自另一个接口，则还需要实现*那些*属性和方法。因此，任何实现 IDefender
    的类不仅必须实现所有 IDefender 成员，还必须实现所有 IWorker 成员。以下是包含 IWorker 和 IDefender 的类模型，以及**两个单独的层次结构**来实现它们。
- en: '![Images](assets/388fig01.png)![Images](assets/391fig01.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/388fig01.png)![图片](assets/391fig01.png)'
- en: '**Absolutely! Making fields read-only helps prevent bugs.**'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**绝对！将字段设置为只读有助于防止错误。**'
- en: 'Go back to the ScaryScary.scaryThingCount field—the IDE put dots underneath
    the first two letters of the field name. Hover over the dots to get the IDE to
    pop up a window:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 ScaryScary.scaryThingCount 字段——IDE 在字段名的前两个字母下面放置了点。将鼠标悬停在点上即可弹出窗口：
- en: '![Images](assets/391fig02.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/391fig02.png)'
- en: 'Press Ctrl+. to pop up a list of actions, and choose “**Add readonly modifier**”
    to add the `readonly` **keyword** to the declaration:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 按 Ctrl+. 弹出操作列表，并选择“**添加 readonly 修饰符**”将 `readonly` **关键字**添加到声明中：
- en: '![Images](assets/391fig03.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/391fig03.png)'
- en: 'Now the field can only be set when it’s declared or in the constructor. If
    you try to change its value anywhere else in the method, you’ll get a compiler
    error:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在该字段只能在声明时或在构造函数中设置。如果您尝试在方法的任何其他位置更改其值，将收到编译器错误：
- en: '![Images](assets/391fig04.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/391fig04.png)'
- en: The `readonly` keyword...just another way C# helps you keep your data safe.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`readonly` 关键字……这只是 C# 帮助您保持数据安全的另一种方式。'
- en: '**Interface references only know about the methods and properties that are
    defined in the interface.**'
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**接口引用只知道在接口中定义的方法和属性。**'
- en: Note
  id: totrans-296
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注释
- en: Look up “implement” in the dictionary—one definition is “to put a decision,
    plan, or agreement into effect.”
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 查看字典中的“implement”一词——其中一个定义是“将决定、计划或协议付诸实施”。
- en: '**Actually, you can add code to your interfaces by including static members
    and default implementations.**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**实际上，您可以通过包含静态成员和默认实现来向接口添加代码。**'
- en: '![Images](assets/394fig01.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/394fig01.png)'
- en: Interfaces aren’t just about making sure classes that implement them include
    certain members. Sure, that’s their main job. But interfaces can also contain
    code, just like the other tools you use to create your class model.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 接口不仅仅是确保实现它们的类包含某些成员。当然，这是它们的主要任务。但接口也可以包含代码，就像您用来创建类模型的其他工具一样。
- en: 'The easiest way to add code to an interface is to add **static methods, properties,
    and fields**. These work exactly like static members in classes: they can store
    data of any type—including references to objects—and you can call them just like
    any other static method: `Interface.MethodName();`'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 向接口添加代码的最简单方法是添加**静态方法、属性和字段**。它们的工作方式与类中的静态成员完全相同：可以存储任何类型的数据，包括对对象的引用，并且可以像调用任何其他静态方法一样调用它们：`Interface.MethodName();`
- en: You can also include code in your interfaces by adding **default implementations**
    for methods. To add a default implementation, you just add a method body to the
    method in your interface. This method is not part of the object—this is not the
    same as inheritance—and you can only access it using an interface reference. It
    can call methods implemented by the object, as long as they’re part of the interface.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过为方法添加**默认实现**在你的接口中包含代码。要添加默认实现，只需在接口的方法中添加一个方法体。这个方法不是对象的一部分——这不同于继承——你只能使用接口引用来访问它。它可以调用对象实现的方法，只要它们是接口的一部分。
- en: Interfaces can have static members
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口可以拥有静态成员
- en: 'Everybody loves it when way too many clowns pack themselves into a tiny clown
    car! So let’s update the IClown interface to add static methods that generate
    a clown car description. Here’s what we’ll add:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都喜欢看到过多的小丑挤进一个小小的小丑车里！因此让我们更新IClown接口，添加生成小丑车描述的静态方法。这是我们将要添加的内容：
- en: We’ll be using random numbers, so we’ll add a static reference to an instance
    of Random. It only needs to be used in IClown for now, but we’ll also use it in
    IScaryClown soon, so go ahead and mark it `protected`.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用随机数，因此我们将添加一个对Random实例的静态引用。目前它只需要在IClown中使用，但我们很快也会在IScaryClown中使用它，所以去标记它为`protected`。
- en: A clown car is only funny if it’s packed with clowns, so we’ll add a static
    int property with a private static backing field and a setter that only accepts
    values over 10.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有挤满小丑的小丑车才有趣，所以我们将添加一个带有私有静态后备字段的静态int属性，并且只接受大于10的值。
- en: A method called ClownCarDescription returns a string that describes the clown
    car.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为ClownCarDescription的方法返回描述小丑车的字符串。
- en: '![Images](assets/395fig001a.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/395fig001a.png)'
- en: 'Here’s the code—it uses a static field, property, and method just like you’d
    see in a class:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码——它使用了一个静态字段、属性和方法，就像你在类中看到的那样：
- en: '![Images](assets/395fig001.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/395fig001.png)'
- en: 'Now you can update the Main method to access the static IClown members:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以更新Main方法来访问静态IClown成员：
- en: '[PRE40]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-313
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Try adding a private field to your interface. You can add one—but only if
    it’s static! If you remove the static keyword, the compiler will tell you that
    interfaces can’t contain instance fields.**'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试向你的接口添加一个私有字段。你可以添加一个——但只能是静态的！如果去掉静态关键字，编译器会告诉你接口不能包含实例字段。**'
- en: These static interface members behave exactly like the static class members
    that you’ve used in previous chapters. Public members can be used from any class,
    private members can only be used from inside IClown, and protected members can
    be used from IClown or any interface that extends it.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这些静态接口成员的行为与你在前几章中使用的静态类成员完全相同。公共成员可以从任何类中使用，私有成员只能从IClown内部使用，而受保护的成员可以从IClown或任何扩展它的接口中使用。
- en: Default implementations give bodies to interface methods
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认实现为接口方法提供了方法体
- en: 'All of the methods that you’ve seen in interfaces so far—except for the static
    methods—have been abstract: they don’t have bodies, so any class that implements
    the interface must provide an implementation for the method.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止你在接口中看到的所有方法——除了静态方法——都是抽象的：它们没有方法体，因此任何实现该接口的类必须为该方法提供实现。
- en: 'But you can also provide a **default implementation** for any of your interface
    methods. Here’s an example:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 但你也可以为你的接口方法提供一个**默认实现**。这里是一个例子：
- en: '![Images](assets/396fig01.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/396fig01.png)'
- en: 'You can call the default implementation—but you **must use an interface reference**
    to make the call:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以调用默认实现——但你**必须使用接口引用**来进行调用：
- en: '[PRE41]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'But this code will not compile—it will give you the error *“NectarCollector’
    does not contain a definition for ‘Buzz’”*:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 但这段代码不会编译——它会给你一个错误*“‘NectarCollector’ does not contain a definition for ‘Buzz’”*：
- en: '[PRE42]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The reason is that when an interface method has a default implementation, that
    makes it a virtual method, just like the ones you used in classes. Any class that
    implements the interface has the option to implement the method. The virtual method
    is ***attached to the interface***. Like any other interface implementation, it’s
    not inherited. That’s a good thing—if a class inherited default implementations
    from every interface that it implemented, then if two of those interfaces had
    methods with the same name the class would run into the Deadly Diamond of Death.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是当接口方法具有默认实现时，这使其成为一个虚方法，就像您在类中使用的方法一样。任何实现接口的类都可以选择实现该方法。虚方法与接口一样***附属***。像任何其他接口实现一样，它不会被继承。这是一件好事——如果一个类从它实现的每个接口中继承了默认实现，那么如果其中两个接口具有相同名称的方法，该类将遇到死亡之钻石的问题。
- en: Note
  id: totrans-325
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can use verbatim string literals to create multiline strings that include
    line breaks. They work great with string interpolation—just add a $ to the beginning.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用逐字字符串文字创建包含换行符的多行字符串。它们与字符串插值非常搭配——只需在开头添加 $。
- en: Add a ScareAdults method with a default implementation
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个带有默认实现的 ScareAdults 方法
- en: 'Our IScaryClown interface is state-of-the-art when it comes to simulating scary
    clowns. But there’s a problem: it only has a method to scare little children.
    What if we want our clowns to terrify the living $#!* out of adults too?'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到模拟可怕小丑时，我们的 IScaryClown 接口是最先进的。但是有一个问题：它只有一个用于惊吓小孩的方法。如果我们希望我们的小丑也能吓到成年人，怎么办？
- en: 'We ***could*** add an abstract ScareAdults method to the IScaryClown interface.
    But what if we already had dozens of classes that implemented IScaryClown? And
    what if most of them would be perfectly fine with the same implementation of the
    ScareAdults method? That’s where default implementations are really useful. A
    default implementation lets you add a method to an interface that’s already in
    use **without having to update any of the classes that implement it**. Add a ScareAdults
    method with a default implementation to IScaryClown:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们***可以***向 IScaryClown 接口添加一个抽象的 ScareAdults 方法。但是，如果我们已经有数十个实现了 IScaryClown
    接口的类呢？如果其中大多数类都对 ScareAdults 方法的同一实现非常满意呢？这就是默认实现真正有用的地方。默认实现允许您向已经在使用中的接口添加一个方法，而**无需更新任何实现它的类**。向
    IScaryClown 添加一个带有默认实现的 ScareAdults 方法：
- en: '![Images](assets/397fig01.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/397fig01.png)'
- en: '***Add this!***'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '***添加这个！***'
- en: 'Take a close look at how the ScareAdults method works. That method only has
    two statements, but there’s a lot packed into them. Let’s break down exactly what’s
    going on:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察 ScareAdults 方法的工作方式。该方法只有两个语句，但它们包含了很多内容。让我们逐步分解正在发生的事情：
- en: 'The Console.WriteLine statement uses a verbatim literal with string interpolation.
    The literal starts with `$@` to tell the C# compiler two things: the `$` tells
    it to use string interpolation, and the `@` tells it to use a verbatim literal.
    That means the string will include three line breaks.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Console.WriteLine 语句使用了带有字符串插值的逐字文字。文本以 `$@` 开头，告诉 C# 编译器两件事：`$` 告诉它使用字符串插值，`@`
    告诉它使用逐字文字。这意味着字符串将包括三个换行符。
- en: The literal uses string interpolation to call `r`andom.Next(4, 10), which uses
    the private static random field that IScaryClown inherited from IClown.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该文字使用字符串插值调用 `r`andom.Next(4, 10)，它使用 IScaryClown 从 IClown 继承的私有静态 random 字段。
- en: We’ve seen throughout the book that when there’s a static field, that means
    there’s only one copy of that field. So there’s just one instance of Random that
    both IClown and IScaryClown share.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书贯穿始终的是，当存在静态字段时，意味着该字段只有一个副本。因此，IClown 和 IScaryClown 共享一个 Random 的实例。
- en: The last line of the ScareAdults method calls ScareLittleChildren. That method
    is abstract in the IScaryClown interface, so it will call the version of ScareLittleChildren
    in the class that implements IScaryClown.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ScareAdults 方法的最后一行调用 ScareLittleChildren。该方法在 IScaryClown 接口中是抽象的，因此它将调用实现
    IScaryClown 接口的类中 ScareLittleChildren 的版本。
- en: That means ScareAdults will call the version of ScareLittleChildren that’s defined
    in whatever class implements IScaryClown.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这意味着 ScareAdults 将调用在实现 IScaryClown 接口的任何类中定义的 ScareLittleChildren 版本。
- en: 'Call your new default implementation by modifying the block after the `if`
    statement in your Main method to call ScareAdults instead of ScareLittleChildren:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 通过修改 Main 方法中 `if` 语句后的代码块调用 ScareAdults 而不是 ScareLittleChildren 来调用您的新默认实现：
- en: '[PRE43]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '![Images](assets/398fig01.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/398fig01.png)'
- en: '**C# developers use interfaces *all the time*, especially when we use libraries,
    frameworks, and APIs.**'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '**C# 开发人员 *经常* 使用接口，特别是在使用库、框架和 API 时。**'
- en: 'Developers always stand on the shoulders of giants. You’re about halfway through
    this book, and in the first half you’ve written code that prints text to the console,
    draws windows with buttons, and renders 3D objects. You didn’t need to write code
    to specifically output individual bytes to the console, or draw the lines and
    text to display buttons in a window, or do the math needed to display a sphere—you
    took advantage of code that other people wrote:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员总是站在巨人的肩膀上。你已经读了这本书的一半，在前半部分，你编写了打印文本到控制台的代码，绘制带有按钮的窗口，并渲染了3D对象。你不需要编写代码来逐个输出字节到控制台，或者绘制线条和文本以显示窗口中的按钮，也不需要执行显示球体所需的数学计算
    —— 你利用了其他人编写的代码：
- en: You’ve used **frameworks** like .NET Core and WPF.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已经使用过像 .NET Core 和 WPF 这样的**框架**。
- en: You’ve used **APIs** like the Unity scripting API.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已经使用过像 Unity 脚本 API 这样的**API**。
- en: The frameworks and APIs contain **class libraries** that you access with `using`
    directives at the top of your code.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些框架和 API 包含**类库**，你可以在代码顶部使用 `using` 指令访问它们。
- en: 'And when you’re using libraries, frameworks, and APIs, you use interfaces a
    lot. See for yourself: open up a .NET Core or WPF application, click inside of
    any method, and type `**I**` to pop up an IntelliSense window. Any potential match
    that has the ![Images](assets/398fig02a.png) symbol next to it is an interface.
    These are all interfaces that you can use to work with the framework.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用库、框架和 API 时，经常会使用接口。自己看看：打开一个 .NET Core 或 WPF 应用程序，在任何方法中点击，然后键入 `**I**`
    弹出 IntelliSense 窗口。任何旁边有 ![Images](assets/398fig02a.png) 符号的潜在匹配项都是接口。这些都是你可以用来与框架一起工作的接口。
- en: '![Images](assets/398fig02.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/398fig02.png)'
- en: Note
  id: totrans-348
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**There’s no Mac equivalent to the WPF feature discussed next, so the Visual
    Studio for Mac Learner’s Guide skips this section.**'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**没有 Mac 上等效的功能可以替代下一个讨论的 WPF 特性，因此 Visual Studio for Mac 学习指南跳过了这部分。**'
- en: Data binding updates WPF controls automatically
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据绑定会自动更新 WPF 控件。
- en: 'Here’s a great example of a real-world use case for an interface: **data binding**.
    Data binding is a really useful feature in WPF that lets you set up your controls
    so their properties are automatically set based on a property in an object, and
    when that property changes your controls’ properties are automatically kept up
    to date.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个真实世界使用接口的绝佳例子：**数据绑定**。数据绑定是 WPF 中非常有用的功能，它允许你设置控件，使它们的属性根据对象中的属性自动设置，并且当该属性更改时，你的控件属性也会自动保持更新。
- en: '![Images](assets/399fig01.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/399fig01.png)'
- en: 'Here’s an overview of the steps to modify your Beehive Management System—we’ll
    dig into them next:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是修改蜂箱管理系统的步骤概述 —— 我们将在接下来详细介绍它们：
- en: '**Modify the Queen class to implement the INotifyPropertyChanged interface.**'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**修改 Queen 类以实现 INotifyPropertyChanged 接口。**'
- en: This interface lets the Queen announce that the status report has been updated.
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个接口让 Queen 可以宣布状态报告已更新。
- en: '**Modify the XAML to create an instance of Queen.**'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**修改 XAML 以创建 Queen 的实例。**'
- en: We’ll bind the TextBox.Text property to the Queen’s StatusReport property.
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将把 TextBox.Text 属性绑定到 Queen 的 StatusReport 属性。
- en: '**Modify the code-behind so the “queen” field uses the instance of Queen we
    just created.**'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**修改代码后端，使“queen”字段使用我们刚刚创建的 Queen 实例。**'
- en: Right now the queen field in *MainWindow.xaml.cs* has a field initializer with
    a `new` statement to create an instance of Queen. We’ll modify it to use the instance
    we created with XAML instead.
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，MainWindow.xaml.cs 中的 queen 字段有一个字段初始化器，其中包含一个 `new` 语句以创建 Queen 的实例。我们将修改它以使用我们用
    XAML 创建的实例。
- en: '![Images](assets/399fig02.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/399fig02.png)'
- en: Modify the Beehive Management System to use data binding
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改蜂箱管理系统以使用数据绑定
- en: You only need to make a few changes to add data binding to your WPF app.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要做一些修改，就可以在你的 WPF 应用程序中添加数据绑定。
- en: '***Do this!***'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '***做这个！***'
- en: '**Modify the Queen class to implement the INotifyPropertyChanged interface.**'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**修改 Queen 类以实现 INotifyPropertyChanged 接口。**'
- en: 'Update the Queen class declaration to make it implement INotifyPropertyChanged.
    That interface is in the System.ComponentModel namespace, so you’ll need to add
    a `using` directive to the top of the class:'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更新 Queen 类声明以使其实现 INotifyPropertyChanged。该接口位于 System.ComponentModel 命名空间中，因此你需要在类顶部添加一个
    `using` 指令：
- en: '[PRE44]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now you can add `INotifyPropertyChanged` to the end of the class declaration.
    The IDE will draw a red squiggly underline beneath it—which is what you’d expect,
    since you haven’t implemented the interface by adding its members yet.
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在可以在类声明的末尾添加 `INotifyPropertyChanged`。IDE 会在其下面绘制一个红色的波浪线——这是你预期的，因为你还没有通过添加其成员来实现接口。
- en: '![Images](assets/400fig01.png)'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/400fig01.png)'
- en: 'Press Alt+Enter or Ctrl+. to show potential fixes **and choose “Implement interface”**
    from the context menu. The IDE will add a line of code to your class with the
    `**event keyword**`, which you haven’t seen yet:'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按 Alt+Enter 或 Ctrl+. 显示潜在的修复选项，并从上下文菜单中选择“实现接口”。IDE 将向你的类中添加一行代码，其中包含了 `**event
    keyword**`，这是你尚未见过的：
- en: '[PRE45]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: But guess what? You’ve used events before! The DispatchTimer you used in [#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin)
    has a Tick event, and WPF Button controls have a Click event. ***Now your Queen
    class has a PropertyChanged event.*** Any class that you use for data binding
    fires—or **invokes**—its PropertyChanged event to let WPF know a property has
    changed.
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但猜猜？你以前使用过事件！你在 [#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin)
    中使用的 DispatchTimer 有一个 Tick 事件，而 WPF Button 控件有一个 Click 事件。***现在你的 Queen 类有一个
    PropertyChanged 事件。*** 任何用于数据绑定的类都会触发——或**调用**——其 PropertyChanged 事件，以通知 WPF 属性已更改。
- en: 'Your Queen class needs to fire its event, just like the DispatchTimer fires
    its Tick event on an interval and the Button fires its Click event when the user
    clicks on it. So **add this OnPropertyChanged method**:'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的 Queen 类需要像 DispatchTimer 在间隔上触发其 Tick 事件和 Button 在用户单击时触发其 Click 事件一样触发其事件。因此，**添加此
    OnPropertyChanged 方法**：
- en: '[PRE46]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now you just need to **modify the UpdateStatusReport method** to call OnPropertyChanged:'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在只需**修改 UpdateStatusReport 方法**以调用 OnPropertyChanged：
- en: '[PRE47]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You added an event to your Queen class, and added a method that uses the ?.
    operator to invoke the event. That’s all you need to know about events for now—at
    the end of the book we’ll point you to a downloadable chapter that teaches you
    more about events.
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你向 Queen 类添加了一个事件，并添加了一个使用 ?. 运算符来调用该事件的方法。目前你需要知道关于事件的就这些——在本书的结尾，我们将为你提供一个可下载的章节，进一步教授你有关事件的知识。
- en: '**Modify the XAML to create an instance of Queen.**'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**修改 XAML 以创建 Queen 的一个实例。**'
- en: 'You’ve created objects with the `new` keyword, and you’ve used Unity’s Instantiate
    method. XAML gives you another way to create new instances of your classes. **Add
    this to your XAML** just above the `<Grid>` tag:'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你使用了 `new` 关键字创建对象，并使用了 Unity 的 Instantiate 方法。XAML 为你提供了另一种创建类的新实例的方式。**将这段代码添加到你的
    XAML**，就在 `<Grid>` 标签的上面：
- en: '![Images](assets/401fig01.png)'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/401fig01.png)'
- en: 'Next, **modify the** `<Grid>` **tag** to add a DataContext attribute:'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，**修改** `<Grid>` **标签**以添加 DataContext 属性：
- en: '[PRE48]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, **add a Text attribute to the `<TextBox>` tag** to bind it to the
    Queen’s StatusReport property:'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，**向** `<TextBox>` **标签添加一个 Text 属性**，将其绑定到 Queen 的 StatusReport 属性：
- en: '[PRE49]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now the TextBox will update automatically any time the Queen object invokes
    its PropertyChanged event.
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在每当 Queen 对象调用其 PropertyChanged 事件时，TextBox 将自动更新。
- en: '**Modify the code-behind to use the instance of Queen in the window’s resources.**'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**修改代码后台以使用窗口资源中的 Queen 实例。**'
- en: Right now the queen field in *MainWindow.xaml.cs* has a field initializer with
    a `new` statement to create an instance of Queen. We’ll modify it to use the instance
    we created with XAML instead.
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在 *MainWindow.xaml.cs* 中的 queen 字段具有一个字段初始化程序，其中包含一个 `new` 语句以创建 Queen 的一个实例。我们将修改它，以使用我们在
    XAML 中创建的实例。
- en: 'First, comment out (or delete) the three occurrences of the line that sets
    statusReport.Text. There’s one in the MainWindow constructor and two in the Click
    event handlers:'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，注释掉（或删除）设置 statusReport.Text 的三个行的出现。一个在 MainWindow 构造函数中，另外两个在 Click 事件处理程序中：
- en: '[PRE50]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, modify the Queen field declaration to remove the field initializer (`new
    Queen();`) from the end:'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，修改 Queen 字段声明，从末尾移除字段初始化程序（`new Queen();`）：
- en: '[PRE51]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finally, modify the constructor to set the queen field like this:'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，修改构造函数以如下方式设置 queen 字段：
- en: '![Images](assets/401fig02.png)'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/401fig02.png)'
- en: This code uses a **dictionary** called Resources. *(This is a sneak peek at
    dictionaries! You’ll learn about them in the next chapter.)* Now run your game.
    It works exactly like before, but now the TextBox updates automatically any time
    the Queen updates the status report.
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码使用了一个名为 Resources 的**字典**。（这是对字典的一个预览！你将在下一章学习到它们。）现在运行你的游戏。它的工作方式与之前完全相同，但现在
    TextBox 在 Queen 更新状态报告时会自动更新。
- en: Note
  id: totrans-395
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Congratulations! You just used an interface to add data binding to your WPF
    app.**'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**恭喜！你刚刚使用接口为你的WPF应用添加了数据绑定。**'
- en: Polymorphism means that one object can take many different forms
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态性意味着一个对象可以具有多种形式
- en: Any time you use a RoboBee in place of an IWorker, or a Wolf in place of an
    Animal, or even an aged Vermont cheddar in a recipe that just calls for cheese,
    you’re using **polymorphism**. That’s what you’re doing any time you upcast or
    downcast. It’s taking an object and using it in a method or a statement that expects
    something else.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你用RoboBee替代IWorker，或用Wolf替代Animal，甚至在配方中用老佛蒙特切达干酪代替仅仅要求奶酪的情况下，你正在使用**多态性**。这就是你进行向上转型或向下转型的情况。它将一个对象用在期望其他东西的方法或语句中。
- en: Keep your eyes open for polymorphism!
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持对多态性的关注！
- en: You’ve been using polymorphism throughout—we just didn’t use that word to describe
    it. While you’re writing code over the next few chapters, be on the lookout for
    the many different ways you use it.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个过程中，你一直在使用多态性——我们只是没有用这个词来描述它。在接下来的几章中编写代码时，请留意你使用它的许多不同方式。
- en: 'Here’s a list of four typical ways that you’ll use polymorphism. We’re providing
    an example of each of them, though you won’t see these particular lines in the
    exercises. As soon as you write similar code in an exercise in later chapters
    in the book, come back to this page and **check it off the following list**:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了你将使用多态性的四种典型方式。我们提供了每种方式的示例，尽管你不会在练习中看到这些特定的行。一旦你在本书后面章节的练习中编写了类似的代码，请回到这一页并**在下面的列表中打勾确认**：
- en: '![Images](assets/403fig01.png)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/403fig01.png)'
- en: '**You’re using polymorphism when you take an instance of one class and use
    it in a statement or a method that expects a different type, like a parent class
    or an interface that the class implements.**'
  id: totrans-403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**当你拿一个类的实例并将其用在期望不同类型的语句或方法中，比如父类或实现类的接口时，你就在使用多态性。**'
- en: Note
  id: totrans-404
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The idea that you could combine your data and your code into classes and objects
    was a revolutionary one when it was first introduced—but that’s how you’ve been
    building all your C# programs so far, so you can think of it as just plain programming.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将数据和代码合并到类和对象中时，这个想法在最初提出时是革命性的——但这就是你迄今为止一直在构建所有C#程序的方式，所以你可以将其视为普通的编程。
- en: '![Images](assets/404fig01.png)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/404fig01.png)'
- en: '**You’re an object-oriented programmer.**'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '**你是一个面向对象的程序员。**'
- en: There’s a name for what you’ve been doing. It’s called **object-oriented programming**,
    or OOP. Before languages like C# came along, people didn’t use objects and methods
    when writing their code. They just used functions (which is what they call methods
    in a non-OO program) that were all in one place—as if each program were just one
    big static class that only had static methods. It made it a lot harder to create
    programs that modeled the problems they were solving. Luckily, you’ll never have
    to write programs without OOP, because it’s a core part of C#.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 你所做的事有一个名字。它被称为**面向对象编程**，或者OOP。在像C#这样的语言出现之前，人们在编写他们的代码时不使用对象和方法。他们只使用函数（在非面向对象程序中称为方法），这些函数都在一个地方——就像每个程序只是一个有静态方法的大静态类一样。这使得创建能够模拟它们解决的问题的程序变得更加困难。幸运的是，你永远不必在没有OOP的情况下编写程序，因为它是C#的核心部分。
- en: The four core principles of object-oriented programming
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象编程的四个核心原则
- en: 'When programmers talk about OOP, they’re referring to four important principles.
    They should seem very familiar to you by now because you’ve been working with
    every one of them. We just told you about polymorphism, and you’ll recognize the
    first three principles from [#encapsulation_keep_your_privateshellippr](ch05.html#encapsulation_keep_your_privateshellippr)
    and [#inheritance_your_objectapostrophes_famil](ch06.html#inheritance_your_objectapostrophes_famil):
    **inheritance, abstraction**, and **encapsulation.**'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序员谈论面向对象编程时，他们指的是四个重要原则。现在它们应该对你来说非常熟悉了，因为你已经在使用每一个。我们刚刚告诉过你多态性，你将在[#encapsulation_keep_your_privateshellippr](ch05.html#encapsulation_keep_your_privateshellippr)和[#inheritance_your_objectapostrophes_famil](ch06.html#inheritance_your_objectapostrophes_famil)中认识到前三个原则：**继承，抽象**和**封装**。
- en: '![Images](assets/404fig02.png)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/404fig02.png)'
