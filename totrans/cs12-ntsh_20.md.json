["```cs\nSystem.Security;\nSystem.Security.Cryptography;\n```", "```cs\nFile.WriteAllText (\"myfile.txt\", \"\");\nFile.Encrypt (\"myfile.txt\");\nFile.AppendAllText (\"myfile.txt\", \"sensitive data\");\n```", "```cs\npublic static byte[] Protect\n  (byte[] userData, byte[] optionalEntropy, DataProtectionScope scope);\n\npublic static byte[] Unprotect\n  (byte[] encryptedData, byte[] optionalEntropy, DataProtectionScope scope);\n```", "```cs\nbyte[] original = {1, 2, 3, 4, 5};\nDataProtectionScope scope = DataProtectionScope.CurrentUser;\n\nbyte[] encrypted = ProtectedData.Protect (original, null, scope);\nbyte[] decrypted = ProtectedData.Unprotect (encrypted, null, scope);\n// decrypted is now {1, 2, 3, 4, 5}\n```", "```cs\nbyte[] hash;\nusing (Stream fs = File.OpenRead (\"checkme.doc\"))\n  hash = SHA1.Create().ComputeHash (fs);   // SHA1 hash is 20 bytes long\n```", "```cs\nbyte[] data = System.Text.Encoding.UTF8.GetBytes (\"stRhong%pword\");\nbyte[] hash = SHA256.Create().ComputeHash (data);\n```", "```cs\nbyte[] encrypted = KeyDerivation.Pbkdf2 (\n    password: \"stRhong%pword\",\n    salt: Encoding.UTF8.GetBytes (\"j78Y#p)/saREN!y3@\"),\n    prf: KeyDerivationPrf.HMACSHA512,\n    iterationCount: 100,\n    numBytesRequested: 64);\n```", "```cs\nbyte[] key = {145,12,32,245,98,132,98,214,6,77,131,44,221,3,9,50};\nbyte[] iv  = {15,122,132,5,93,198,44,31,9,39,241,49,250,188,80,7};\n\nbyte[] data = { 1, 2, 3, 4, 5 };   // This is what we're encrypting.\n\nusing (SymmetricAlgorithm algorithm = Aes.Create())\nusing (ICryptoTransform encryptor = algorithm.CreateEncryptor (key, iv))\nusing (Stream f = File.Create (\"encrypted.bin\"))\nusing (Stream c = new CryptoStream (f, encryptor, CryptoStreamMode.Write))\n  c.Write (data, 0, data.Length);\n```", "```cs\nbyte[] key = {145,12,32,245,98,132,98,214,6,77,131,44,221,3,9,50};\nbyte[] iv  = {15,122,132,5,93,198,44,31,9,39,241,49,250,188,80,7};\n\nbyte[] decrypted = new byte[5];\n\nusing (SymmetricAlgorithm algorithm = Aes.Create())\nusing (ICryptoTransform decryptor = algorithm.CreateDecryptor (key, iv))\nusing (Stream f = File.OpenRead (\"encrypted.bin\"))\nusing (Stream c = new CryptoStream (f, decryptor, CryptoStreamMode.Read))\n  for (int b; (b = c.ReadByte()) > -1;)\n    Console.Write (b + \" \");                            // 1 2 3 4 5\n```", "```cs\nbyte[] key = new byte [16];\nbyte[] iv  = new byte [16];\nRandomNumberGenerator rand = RandomNumberGenerator.Create();\nrand.GetBytes (key);\nrand.GetBytes (iv);\n```", "```cs\nbyte[] key = RandomNumberGenerator.GetBytes (16);\nbyte[] iv = RandomNumberGenerator.GetBytes (16);\n```", "```cs\npublic static byte[] Encrypt (byte[] data, byte[] key, byte[] iv)\n{\n  using Aes algorithm = Aes.Create();\n  algorithm.Key = key;\n  return algorithm.EncryptCbc (data, iv);\n}\n\npublic static byte[] Decrypt (byte[] data, byte[] key, byte[] iv)\n{\n  using Aes algorithm = Aes.Create();\n  algorithm.Key = key;\n  return algorithm.DecryptCbc (data, iv);\n}\n```", "```cs\npublic static byte[] Encrypt (byte[] data, byte[] key, byte[] iv)\n{\n  using (Aes algorithm = Aes.Create())\n  using (ICryptoTransform encryptor = algorithm.CreateEncryptor (key, iv))\n    return Crypt (data, encryptor);\n}\n\npublic static byte[] Decrypt (byte[] data, byte[] key, byte[] iv)\n{\n  using (Aes algorithm = Aes.Create())\n  using (ICryptoTransform decryptor = algorithm.CreateDecryptor (key, iv))\n    return Crypt (data, decryptor);\n}\n\nstatic byte[] Crypt (byte[] data, ICryptoTransform cryptor)\n{\n  MemoryStream m = new MemoryStream();\n  using (Stream c = new CryptoStream (m, cryptor, CryptoStreamMode.Write))\n    c.Write (data, 0, data.Length);\n  return m.ToArray();\n}\n```", "```cs\npublic static string Encrypt (string data, byte[] key, byte[] iv)\n{\n  return Convert.ToBase64String (\n    Encrypt (Encoding.UTF8.GetBytes (data), key, iv));\n}\n\npublic static string Decrypt (string data, byte[] key, byte[] iv)\n{\n  return Encoding.UTF8.GetString (\n    Decrypt (Convert.FromBase64String (data), key, iv));\n}\n```", "```cs\nbyte[] key = new byte[16];\nbyte[] iv = new byte[16];\n\nvar cryptoRng = RandomNumberGenerator.Create();\ncryptoRng.GetBytes (key);\ncryptoRng.GetBytes (iv);\n\nstring encrypted = Encrypt (\"Yeah!\", key, iv);\nConsole.WriteLine (encrypted);                 // R1/5gYvcxyR2vzPjnT7yaQ==\n\nstring decrypted = Decrypt (encrypted, key, iv);\nConsole.WriteLine (decrypted);                 // Yeah!\n```", "```cs\nbyte[] key = new byte [16];\nbyte[] iv = new byte [16];\n\nvar cryptoRng = RandomNumberGenerator.Create();\ncryptoRng.GetBytes (key);\ncryptoRng.GetBytes (iv);\n\nusing (Aes algorithm = Aes.Create())\n{\n  using (ICryptoTransform encryptor = algorithm.CreateEncryptor(key, iv))\n  using (Stream f = File.Create (\"serious.bin\"))\n  using (Stream c = new CryptoStream (f, encryptor, CryptoStreamMode.Write))\n  using (Stream d = new DeflateStream (c, CompressionMode.Compress))\n  using (StreamWriter w = new StreamWriter (d))\n    await w.WriteLineAsync (\"Small and secure!\");\n\n  using (ICryptoTransform decryptor = algorithm.CreateDecryptor(key, iv))\n  using (Stream f = File.OpenRead (\"serious.bin\"))\n  using (Stream c = new CryptoStream (f, decryptor, CryptoStreamMode.Read))\n  using (Stream d = new DeflateStream (c, CompressionMode.Decompress))\n  using (StreamReader r = new StreamReader (d))\n    Console.WriteLine (await r.ReadLineAsync());     // Small and secure!\n}\n```", "```cs\nbyte[] data = { 1, 2, 3, 4, 5 };   // This is what we're encrypting.\n\nusing (var rsa = new RSACryptoServiceProvider())\n{\n  byte[] encrypted = rsa.Encrypt (data, true);\n  byte[] decrypted = rsa.Decrypt (encrypted, true);\n}\n```", "```cs\nvar rsa = new RSACryptoServiceProvider (2048);\n```", "```cs\nusing (var rsa = new RSACryptoServiceProvider())\n{\n  File.WriteAllText (\"PublicKeyOnly.xml\", rsa.ToXmlString (false));\n  File.WriteAllText (\"PublicPrivate.xml\", rsa.ToXmlString (true));\n}\n```", "```cs\nbyte[] data = Encoding.UTF8.GetBytes (\"Message to encrypt\");\n\nstring publicKeyOnly = File.ReadAllText (\"PublicKeyOnly.xml\");\nstring publicPrivate = File.ReadAllText (\"PublicPrivate.xml\");\n\nbyte[] encrypted, decrypted;\n\nusing (var rsaPublicOnly = new RSACryptoServiceProvider())\n{\n  rsaPublicOnly.FromXmlString (publicKeyOnly);\n  encrypted = rsaPublicOnly.Encrypt (data, true);\n\n  // The next line would throw an exception because you need the private\n  // key in order to decrypt:\n  // decrypted = rsaPublicOnly.Decrypt (encrypted, true);\n}\n\nusing (var rsaPublicPrivate = new RSACryptoServiceProvider())\n{\n  // With the private key we can successfully decrypt:\n  rsaPublicPrivate.FromXmlString (publicPrivate);\n  decrypted = rsaPublicPrivate.Decrypt (encrypted, true);\n}\n```", "```cs\nbyte[] data = Encoding.UTF8.GetBytes (\"Message to sign\");\nbyte[] publicKey;\nbyte[] signature;\nobject hasher = SHA1.Create();         // Our chosen hashing algorithm.\n\n// Generate a new key pair, then sign the data with it:\nusing (var publicPrivate = new RSACryptoServiceProvider())\n{\n  signature = publicPrivate.SignData (data, hasher);\n  publicKey = publicPrivate.ExportCspBlob (false);    // get public key\n}\n\n// Create a fresh RSA using just the public key, then test the signature.\nusing (var publicOnly = new RSACryptoServiceProvider())\n{\n  publicOnly.ImportCspBlob (publicKey);\n  Console.Write (publicOnly.VerifyData (data, hasher, signature)); // True\n\n  // Let's now tamper with the data and recheck the signature:\n  data[0] = 0;\n  Console.Write (publicOnly.VerifyData (data, hasher, signature)); // False\n\n  // The following throws an exception as we're lacking a private key:\n  signature = publicOnly.SignData (data, hasher);\n}\n```", "```cs\nusing (var rsa = new RSACryptoServiceProvider())\n{\n  byte[] hash = SHA1.Create().ComputeHash (data);\n  signature = rsa.SignHash (hash, CryptoConfig.MapNameToOID (\"SHA1\"));\n  ...\n}\n```"]