<html><head></head><body><section data-pdf-bookmark="Chapter 10. Reading and writing files: Save the last byte for me!" data-type="chapter" epub:type="chapter"><div class="chapter" id="reading_and_writing_files_save_the_last">&#13;
<h1><span class="label">Chapter 10. </span>Reading and writing files: <em>Save the last byte for me!</em></h1>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg529.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p><strong>Sometimes it pays to be a little persistent.</strong></p>&#13;
<p>So far, all of your programs have been pretty short-lived. They fire up, run for a while, and shut down. But that’s not always enough, especially when you’re dealing with important information. You need to be able to <strong>save your work</strong>. In this chapter, we’ll look at how to <strong>write data to a file</strong>, and then how to <strong>read that information back in</strong> from a file. You’ll learn about <strong>streams</strong>, and how to store your objects in files with <strong>serialization</strong>, and get down to the actual bits and bytes of <strong>hexadecimal</strong>, <strong>Unicode</strong>, and <strong>binary data</strong></p>&#13;
<section data-pdf-bookmark=".NET uses streams to read and write data" data-type="sect1"><div class="sect1" id="dotnet_uses_streams_to_read_and_write_da">&#13;
<h1>.NET uses <u>streams</u> to read and write data</h1>&#13;
<p><a data-primary=".NET Framework" data-secondary="streams, readinga and writing data" data-type="indexterm" id="idm46402339886392"/><a data-primary="Stream object" data-type="indexterm" id="idm46402339885128"/><a data-primary="streams" data-secondary="about" data-type="indexterm" id="idm46402339884280"/>A <strong>stream</strong> is the .NET Framework’s way of getting data into and out of your program. Any time your program reads or writes a file, connects to another computer over a network, or generally does anything where it <strong>sends or receives bytes</strong>, you’re using streams. Sometimes you’re using streams directly , other times indirectly. Even when you’re using classes that don’t directly expose streams, under the hood they’re almost always using streams.</p>&#13;
<blockquote>&#13;
<p><strong>Whenever you want to read data from a file or write data to a file, you’ll use a <u>Stream</u> object.</strong></p>&#13;
</blockquote>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><strong>Let’s say you have a simple app that needs to read data from a file. A really basic way to do that is to use a <code>Stream</code> object.</strong></p>&#13;
</div>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg530-1.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><strong>And if your app needs to write data out to the file, it can use <span style="color:#9D9EA0;">another <code>Stream</code> object.</span></strong></p>&#13;
</div>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg530-2.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Different streams read and write different things" data-type="sect1"><div class="sect1" id="different_streams_read_and_write_differe">&#13;
<h1>Different streams read and write different things</h1>&#13;
<p><a data-primary="FileStreams" data-secondary="about" data-type="indexterm" id="idm46402339870936"/><a data-primary="GZipStream object" data-type="indexterm" id="idm46402339869208"/><a data-primary="MemoryStream" data-type="indexterm" id="idm46402339868328"/><a data-primary="NetworkStreams" data-type="indexterm" id="idm46402339867528"/><a data-primary="streams" data-secondary="different types" data-type="indexterm" id="idm46402339866728"/><a data-primary="streams" data-secondary="things you can do with" data-type="indexterm" id="idm46402339865608"/>Every stream is a subclass of the <strong>abstract Stream class</strong>, and there are many subclasses of Stream that do different things. We’ll be concentrating on reading and writing regular files, but everything you learn about streams in this chapter can apply to compressed or encrypted files, or network streams that don’t use files at all.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg531.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<section data-pdf-bookmark="Things you can do with a stream:" data-type="sect2"><div class="sect2" id="things_you_can_do_with_a_stream">&#13;
<h2>Things you can do with a stream:</h2>&#13;
<ol>&#13;
<li><p><strong>Write to the stream.</strong></p>&#13;
<p>You can write your data to a stream through a stream’s <strong>Write method.</strong></p></li>&#13;
<li><p><strong>Read from the stream.</strong></p>&#13;
<p>You can use the <strong>Read method</strong> to get data from a file, or a network, or memory, or just about anything else using a stream. You can even read data from <strong><em>really big</em></strong> files, even if they’re too big to fit into memory.</p></li>&#13;
<li><p><strong>Change your position within the stream.</strong></p>&#13;
<p>Most streams support a <code><strong>Seek method</strong></code> that lets you find a position within the stream so you can read or insert data at a specific place. However, not every Stream class supports Seek—which makes sense, because you can’t always backtrack in some sources of streaming data.</p></li>&#13;
</ol>&#13;
<blockquote>&#13;
<p><strong>Streams let you read and write data. Use the right kind of stream for the data you’re working with.</strong></p>&#13;
</blockquote>&#13;
</div></section>&#13;
</div></section>&#13;
<section data-pdf-bookmark="A FileStream reads and writes bytes in a file" data-type="sect1"><div class="sect1" id="a_filestream_reads_and_writes_bytes_in_a">&#13;
<h1>A FileStream reads and writes bytes in a file</h1>&#13;
<p><a data-primary="encodings" data-type="indexterm" id="idm46402339851160"/><a data-primary="FileStreams" data-secondary="reading and writing bytes to file" data-type="indexterm" id="idm46402339850312"/><a data-primary="streams" data-secondary="forgetting to close" data-type="indexterm" id="idm46402339849000"/>When your program needs to write a few lines of text to a file, there are a lot of things that have to happen:</p>&#13;
<ol>&#13;
<li><p>Create a new FileStream object and tell it to write to the file.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg532-1.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</li>&#13;
<li><p>The FileStream attaches itself to a file.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg532-2.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</li>&#13;
<li><p>Streams write bytes to files, so you’ll need to convert the string that you want to write to an array of bytes.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg532-3.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</li>&#13;
<li><p>Call the stream’s Write method and pass it the byte array.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg532-4.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</li>&#13;
<li><p>Close the stream so other programs can access the file.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg532-5.png"/>&#13;
<h6/>&#13;
</div></figure></li>&#13;
</ol>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Write text to a file in three simple steps" data-type="sect1"><div class="sect1" id="write_text_to_a_file_in_three_simple_ste">&#13;
<h1>Write text to a file in three simple steps</h1>&#13;
<p><a data-primary="FileStreams" data-secondary="created and managed by StreamWriter" data-type="indexterm" id="idm46402339832424"/><a data-primary="streams" data-secondary="writing text to files" data-type="indexterm" id="idm46402339830728"/><a data-primary="StreamWriter" data-secondary="about" data-type="indexterm" id="idm46402339829688"/><a data-primary="StreamWriter" data-secondary="Close( ) method" data-type="indexterm" id="idm46402339828568"/><a data-primary="StreamWriter" data-secondary="Write( ) and WriteLine( ) methods" data-type="indexterm" id="idm46402339827448"/><a data-primary="\t (tab character)" data-type="indexterm" id="idm46402339826296"/>C# comes with a convenient class called <strong>StreamWriter</strong> that simplifies those things for you. All you have to do is create a new StreamWriter object and give it a filename. It <strong><em>automatically</em></strong> creates a FileStream and opens the file. Then you can use the StreamWriter’s Write and WriteLine methods to write everything to the file you want.</p>&#13;
<blockquote>&#13;
<p><strong>StreamWriter creates and manages a FileStream object for you automatically.</strong></p>&#13;
</blockquote>&#13;
<ol>&#13;
<li><p><strong>Use the StreamWriter’s constructor to open or create a file.</strong></p>&#13;
<p>You can pass a filename to the StreamWriter’s constructor. When you do, the writer automatically opens the file. StreamWriter also has an overloaded constructor that lets you specify its <em>append</em> mode: passing it <code>true</code> tells it to add data to the end of an existing file (or append), while <code>false</code> tells the stream to delete the existing file and create a new file with the same name.</p>&#13;
<pre data-type="programlisting">var writer = new StreamWriter("toaster oven.txt", true);</pre>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg533-1.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</li>&#13;
<li><p><strong>Use the Write and WriteLine methods to write to the file.</strong></p>&#13;
<p>These methods work just like the ones in the Console class: Write writes text, and WriteLine writes text and adds a line break to the end.</p>&#13;
<pre data-type="programlisting">writer.WriteLine($"The {appliance} is set to {temp} degrees.");</pre>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg533-2.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</li>&#13;
<li><p><strong>Call the Close method to release the file.</strong></p>&#13;
<p>If you leave the stream open and attached to a file, then it’ll keep the file locked and no other program will be able to use it. So make sure you always close your files!</p>&#13;
<pre data-type="programlisting">writer.Close();</pre></li>&#13;
</ol>&#13;
</div></section>&#13;
<section data-pdf-bookmark="The Swindler launches another diabolical plan" data-type="sect1"><div class="sect1" id="the_swindler_launches_another_diabolical">&#13;
<h1>The Swindler launches another diabolical plan</h1>&#13;
<p><a data-primary="binary (executable)" data-type="indexterm" id="idm46402339808984"/><a data-primary="Captain Amazing" data-type="indexterm" id="idm46402339807736"/><a data-primary="StreamWriter" data-secondary="Write( ) and WriteLine( ) methods" data-type="indexterm" id="idm46402339806872"/>The citizens of Objectville have long lived in fear of the Swindler, Captain Amazing’s archnemesis. Now he’s using a StreamWriter to implement another evil plan. Let’s take a look at what’s going on. Create a new Console App project and <strong>add this Main code</strong>, starting with a <code>using</code> declaration because StreamWriter is in the <strong>System.IO namespace</strong>:</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><strong>StreamWriter’s Write and WriteLine methods work just like Console’s: Write writes text, and WriteLine writes text with a line break. Both classes support {curly brackets} like this:</strong></p>&#13;
<pre data-type="programlisting"><strong>sw.WriteLine("Clone #{0} attacks {1}",</strong>&#13;
          <strong>number, location);</strong></pre>&#13;
<p><strong>When you include {0} in the text, it’s replaced by the first parameter after the string; {1} is replaced by the second, {2} by the third, etc.</strong></p>&#13;
</div>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg534-1.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg534-2.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><span style="color:#9D9EA0;">The Swindler is Captain Amazing’s arch-nemesis, a shadowy supervillain bent on the domination of Objectville.</span></p>&#13;
</div>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg534-3.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>Here’s the output that it writes to <em>secret_plan.txt</em>:</p>&#13;
<p><strong>Output</strong></p>&#13;
<pre data-type="programlisting">How I'll defeat Captain Amazing&#13;
Another genius secret plan by The Swindler&#13;
I'll unleash my army of clones upon the citizens of&#13;
Objectville.&#13;
Clone #1 attacks the mall&#13;
Clone #2 attacks downtown&#13;
Clone #3 attacks the mall&#13;
Clone #4 attacks downtown&#13;
Clone #5 attacks the mall</pre>&#13;
</div></section>&#13;
<section data-pdf-bookmark="StreamWriter Magnets" data-type="sect1"><div class="sect1" id="streamwriter_magnets">&#13;
<h1>StreamWriter Magnets</h1>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg535a.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>Oops! These magnets were nicely arranged on the fridge with the code for the Flobbo class, but someone slammed the door and they all fell off. Can you rearrange them so the Main method produces the output below?</p>&#13;
<pre data-type="programlisting"><strong>static void Main(string[] args) {&#13;
    Flobbo f = new Flobbo("blue yellow");&#13;
    StreamWriter sw = f.Snobbo();&#13;
    f.Blobbo(f.Blobbo(f.Blobbo(sw), sw), sw);&#13;
}</strong></pre>&#13;
<p><strong>We added an extra challenge.</strong></p>&#13;
<p>Something weird is going on with the Blobbo method. See how it has two different declarations in the first two magnets? We defined Blobbo as an <strong>overloaded method</strong>—there are two different versions, each with its own parameters, just like the <strong>overloaded methods</strong> you’ve used in previous chapters.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg535.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</div></section>&#13;
<section data-pdf-bookmark="StreamWriter Magnets Solution" data-type="sect1"><div class="sect1" id="streamwriter_magnets_solution">&#13;
<h1>StreamWriter Magnets Solution</h1>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg535a.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p><a data-primary="methods" data-secondary="overloaded" data-type="indexterm" id="idm46402339778552"/><a data-primary="overloaded methods" data-type="indexterm" id="idm46402339777192"/>Your job was to construct the Flobbo class from the magnets to create the desired output.</p>&#13;
<pre data-type="programlisting"><strong>static void Main(string[] args) {&#13;
    Flobbo f = new Flobbo("blue yellow");&#13;
    StreamWriter sw = f.Snobbo();&#13;
    f.Blobbo(f.Blobbo(f.Blobbo(sw), sw), sw);&#13;
}</strong></pre>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg536.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><strong>Just a reminder: we picked intentionally weird variable names and methods in these puzzles because if we used really good names, the puzzles would be too easy! Don’t use names like this in your code, OK?</strong></p>&#13;
</div>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Use a StreamReader to read a file" data-type="sect1"><div class="sect1" id="use_a_streamreader_to_read_a_file">&#13;
<h1>Use a StreamReader to read a file</h1>&#13;
<p><a data-primary="characters" data-type="indexterm" id="idm46402339770696"/><a data-primary="overloaded constructors" data-type="indexterm" id="idm46402339769496"/><a data-primary="StreamReader" data-secondary="about" data-type="indexterm" id="idm46402339768696"/><a data-primary="StreamWriter" data-secondary="using with StreamReader" data-type="indexterm" id="idm46402339767144"/>Let’s read the Swindler’s secret plans with <strong>StreamReader</strong>, a class that’s a lot like StreamWriter—except instead of writing a file, you create a StreamReader and pass it the name of the file to read in its constructor. Its ReadLine method returns a string that contains the next line from the file. You can write a loop that reads lines from it until its EndOfStream field is true—that’s when it runs out of lines to read. Add this console app that uses a StreamReader to read one file, and a StreamWriter to write another file:</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><strong>StreamReader is a class that reads characters from streams, <span style="color:#9D9EA0;"><u>but it’s not a stream itself.</u></span> When you pass a filename to its constructor, it creates a stream for you, and closes it when you call its Close method. It also has an overloaded constructor that takes a reference to a Stream.</strong></p>&#13;
</div>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg537.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><strong>Output</strong></p>&#13;
<pre data-type="programlisting">To: CaptainAmazing@objectville.net&#13;
From: Commissioner@objectville.net&#13;
Subject: Can you save the day... again?&#13;
&#13;
We've discovered the Swindler's terrible plan:&#13;
The plan -&gt; How I'll defeat Captain Amazing&#13;
The plan -&gt; Another genius secret plan by The Swindler&#13;
The plan -&gt; I'll unleash my army of clones upon the citizens of Objectville.&#13;
The plan -&gt; Clone #1 attacks the mall&#13;
The plan -&gt; Clone #2 attacks downtown&#13;
The plan -&gt; Clone #3 attacks the mall&#13;
The plan -&gt; Clone #4 attacks downtown&#13;
The plan -&gt; Clone #5 attacks the mall&#13;
&#13;
Can you help us?</pre>&#13;
</div>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Data can go through more than one stream" data-type="sect1"><div class="sect1" id="data_can_go_through_more_than_one_stream">&#13;
<h1>Data can go through <u>more</u> <u>than</u> <u>one</u> stream</h1>&#13;
<p><a data-primary="CryptoStream" data-type="indexterm" id="idm46402339755240"/><a data-primary="streams" data-secondary="chaining" data-type="indexterm" id="idm46402339754056"/>One big advantage to working with streams in .NET is that you can have your data go through more than one stream on its way to its final destination. One of the many types of streams in .NET Core is the CryptoStream class. This lets you encrypt your data before you do anything else with it. So instead of writing plain text to a regular old text file:</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg538-1.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg538-2.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>the Swindler can <strong>chain streams together</strong> and send the text through a CryptoStream object before writing its output to a FileStream:</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg538-3.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<blockquote>&#13;
<p><strong>You can <u>CHAIN</u> streams. One stream can write to another stream, which writes to another stream...often ending with a network or file stream.</strong></p>&#13;
</blockquote>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Pool Puzzle" data-type="sect1"><div class="sect1" id="pool_puzzle-idd0002">&#13;
<h1>Pool Puzzle</h1>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg539-1.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>Your <strong><em>job</em></strong> is to take code snippets from the pool and place them into the blank lines in the Pineapple, Pizza, and Party classes. You can use the same snippet more than once, and you won’t need to use all the snippets. Your <strong><em>goal</em></strong> is to make the program write a file called <em>order.txt</em> with the five lines listed in the output box below.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg539-2.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Pool Puzzle Solution" data-type="sect1"><div class="sect1" id="pool_puzzle_solution-idd0002">&#13;
<h1>Pool Puzzle Solution</h1>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg540.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="there_are_no_dumb_questions-idd0034">&#13;
<h5>there are no Dumb Questions</h5>&#13;
<p><a data-primary="byte arrays" data-type="indexterm" id="idm46402339730952"/><a data-primary="characters" data-type="indexterm" id="idm46402339729896"/><a data-primary="encodings" data-type="indexterm" id="idm46402339729128"/><a data-primary="FileStreams" data-secondary="created and managed by StreamWriter" data-type="indexterm" id="idm46402339728328"/><a data-primary="format strings" data-type="indexterm" id="idm46402339727176"/><a data-primary="format strings" data-secondary="{0} and {1}" data-type="indexterm" id="idm46402339726328"/><a data-primary="StreamReader" data-secondary="about" data-type="indexterm" id="idm46402339725352"/><a data-primary="streams" data-secondary="closing" data-type="indexterm" id="idm46402339724200"/><a data-primary="StreamWriter" data-secondary="{0} and {1}" data-see="format strings" data-type="indexterm" id="idm46402339723016"/><a data-primary="StreamWriter" data-secondary="about" data-type="indexterm" id="idm46402339721640"/><a data-primary="strings" data-secondary="converting to byte array" data-type="indexterm" id="idm46402339720568"/><strong>Q: Can you explain what you were doing with {0} and {1} when you called the StreamWriter Write and WriteLine methods?</strong></p>&#13;
<p><strong>A:</strong> When you’re printing strings to a file, you’ll often find yourself in the position of having to print the contents of a bunch of variables. For example, you might have to write something like this:</p>&#13;
<pre data-type="programlisting">writer.WriteLine("My name is " + name +&#13;
    "and my age is " + age);</pre>&#13;
<p>It gets really tedious and somewhat error-prone to have to keep using + to combine strings. It’s easier to use <strong>composite formatting</strong>, where you use a <strong>format string with placeholders</strong> like {0}, {1}, {2}, etc., and follow it with variables to replace the placeholders:</p>&#13;
<pre data-type="programlisting">writer.WriteLine(&#13;
 "My name is {0} and my age is {1}", name, age);</pre>&#13;
<p>You’re probably thinking, isn’t that really similar to string interpolation? And you’re right—it is! In some cases string interpolation may be easier to read, and in other cases using a format string is cleaner. Just like string interpolation, <strong>format strings support formatting</strong>. For example, <strong><code>{1:0.00}</code></strong> means format the second argument as a number with two decimal places, while <strong><code>{3:c}</code></strong> says to format the fourth argument in the local currency.</p>&#13;
<p>Oh, and one more thing—format strings work with Console.Write and Console.WriteLine too!</p>&#13;
<p><strong>Q: What was that Path.DirectorySeparatorChar field that you used in the console app that used StringReader?</strong></p>&#13;
<p><strong>A:</strong> We wrote that code to work on both Window and macOS, so we took advantage of some of .NET Core’s tools to help with that. Windows uses backslash characters as a path separator (C:\Windows), while macOS uses a forward slash (/Users).</p>&#13;
<p>Path.DirectorySeparatorChar is a read-only field that’s set to the correct path separator character for the operating system:  a \ on Windows and / on macOS and Linux.</p>&#13;
<p>We also used the Environment.GetFolderPath method, which returns the path of one of the special folders for the current user—in that case, the user’s Documents folder on Windows or home directory on macOS.</p>&#13;
<p><strong>Q: Near the beginning of the chapter you talked about converting a string to a byte array. How would that even work?</strong></p>&#13;
<p><strong>A:</strong> You’ve probably heard many times that files on disk are represented as bits and bytes. What that means is that when you write a file to a disk, the operating system treats it as one long sequence of bytes. The StreamReader and StreamWriter are converting from <em>bytes</em> to <em>characters</em> for you—that’s called <em>encoding</em> and <em>decoding</em>. Remember from <a href="ch04.html#types_and_references_getting_the_referen">#types_and_references_getting_the_referen</a> how a byte variable can store any number between 0 and 255? Every file on your hard drive is one long sequence of numbers between 0 and 255. It’s up to the programs that read and write those files to interpret those bytes as meaningful data. When you open a file in Notepad, it converts each individual byte to a character—for example, <code><strong>E</strong></code> is 69 and <code><strong>a</strong></code> is 97 (but this depends on the encoding...you’ll learn more about encodings in just a minute). When you type text into Notepad and save it, Notepad converts each character back into a byte and saves it to disk. If you want to write a string to a stream, you’ll need to do the same.</p>&#13;
<p><strong>Q: If I’m just using a StreamWriter to write to a file, why do I really care if it’s creating a FileStream for me?</strong></p>&#13;
<p><strong>A:</strong> If you’re only reading or writing lines to or from a text file in order, then all you need are StreamReader and StreamWriter. As soon as you need to do anything more complex than that, you’ll need to start working with other streams. If you ever need to write data like numbers, arrays, collections, or objects to a file, a StreamWriter just won’t do. We’ll go into a lot more detail about how that will work in just a minute.</p>&#13;
<p><strong>Q: Why do I need to worry about closing streams after I’m done with them?</strong></p>&#13;
<p><strong>A:</strong> Have you ever had a word processor tell you it couldn’t open a file because it was “busy”? When one program uses a file, Windows locks it and prevents other programs from using it. Your programs are no exception—Windows will do that for your apps when they open files, too. If you don’t call the Close method, then it’s possible for your program to keep a file locked until it ends.</p>&#13;
<blockquote>&#13;
<p><strong>Both Console and StreamWriter can use composite formatting, which replaces placeholders with values of parameters passed to Write or WriteLine.</strong></p>&#13;
</blockquote>&#13;
</div></aside>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Use the static File and Directory classes to work with files and directories" data-type="sect1"><div class="sect1" id="use_the_static_file_and_directory_classe">&#13;
<h1>Use the static File and Directory classes to work with files and directories</h1>&#13;
<p><a data-primary="directories" data-secondary="creating new" data-type="indexterm" id="idm46402339701368"/><a data-primary="directories" data-secondary="getting list of files" data-type="indexterm" id="idm46402339693992"/><a data-primary="File class" data-secondary="about" data-type="indexterm" id="idm46402339697464"/><a data-primary="File class" data-secondary="AppendAllText() method" data-type="indexterm" id="idm46402339696488"/><a data-primary="File class" data-secondary="CreateDirectory() method" data-type="indexterm" id="idm46402339695416"/><a data-primary="File class" data-secondary="Create() method" data-type="indexterm" id="idm46402339691512"/><a data-primary="File class" data-secondary="Delete() method" data-type="indexterm" id="idm46402339690440"/><a data-primary="File class" data-secondary="Exists() method" data-type="indexterm" id="idm46402339689320"/><a data-primary="File class" data-secondary="GetLastAccessTime() method" data-type="indexterm" id="idm46402339688216"/><a data-primary="File class" data-secondary="Get LastWriteTime() method" data-type="indexterm" id="idm46402339687128"/><a data-primary="File class" data-secondary="OpenRead() method" data-type="indexterm" id="idm46402339686008"/><a data-primary="File class" data-secondary="OpenWrite() method" data-type="indexterm" id="idm46402339684856"/><a data-primary="FileInfo class" data-type="indexterm" id="idm46402339683720"/><a data-primary="files" data-secondary="appending text to" data-type="indexterm" id="idm46402339682856"/><a data-primary="files" data-secondary="finding out if exists" data-type="indexterm" id="idm46402339681720"/><a data-primary="files" data-secondary="getting information about" data-type="indexterm" id="idm46402339680648"/><a data-primary="files" data-secondary="reading from or writing to" data-type="indexterm" id="idm46402339679576"/>Like StreamWriter, the File class creates streams that let you work with files behind the scenes. You can use its methods to do most common actions without having to create the FileStreams first. The Directory class lets you work with whole directories full of files.</p>&#13;
<section data-pdf-bookmark="Things you can do with the static File class:" data-type="sect2"><div class="sect2" id="things_you_can_do_with_the_static_file_c">&#13;
<h2>Things you can do with the static File class:</h2>&#13;
<ol>&#13;
<li><p><strong>Find out if the file exists.</strong></p>&#13;
<p>You can check to see if a file exists using the File.Exists method. It’ll return true if it does, and false if it doesn’t.</p></li>&#13;
<li><p><strong>Read from and write to the file.</strong></p>&#13;
<p>You can use the File.OpenRead method to get data from a file, or the File.Create or  File.OpenWrite method to write to the file.</p></li>&#13;
<li><p><strong>Append text to the file.</strong></p>&#13;
<p>The File.AppendAllText method lets you append text to an already created file. It even creates the file if it’s not there when the method runs.</p></li>&#13;
<li><p><strong>Get information about the file.</strong></p>&#13;
<p>The File.GetLastAccessTime and File.GetLastWriteTime methods return the date and time when the file was last accessed and modified.</p></li>&#13;
</ol>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg542.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Things you can do with the static Directory class:" data-type="sect2"><div class="sect2" id="things_you_can_do_with_the_static_direct">&#13;
<h2>Things you can do with the static Directory class:</h2>&#13;
<ol>&#13;
<li><p><strong>Create a new directory.</strong></p>&#13;
<p>Create a directory using the Directory.CreateDirectory method. All you have to do is supply the path; this method does the rest.</p></li>&#13;
<li><p><strong>Get a list of the files in a directory.</strong></p>&#13;
<p>You can create an array of files in a directory using the Directory.GetFiles method; just tell the method which directory you want to know about, and it will do the rest.</p></li>&#13;
<li><p><strong>Delete a directory.</strong></p>&#13;
<p>Need to delete a directory? Call the Directory.Delete method.</p></li>&#13;
</ol>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sharpen_your_pencil-idd0038">&#13;
<h5><span class="inlineimage"><img alt="Images" src="assets/pencil.png"/></span> Sharpen your pencil</h5>&#13;
<p><a data-primary="exercises" data-secondary="Sharpen your pencil" data-tertiary="File and Directory classes" data-type="indexterm" id="idm46402339660600"/><a data-primary="Sharpen Your Pencil exercises" data-secondary="File and Directory classes" data-type="indexterm" id="idm46402339659160"/>.NET has classes with a bunch of static methods for working with files and folders, and their method names are intuitive. The File class gives you methods to work with files, and the Directory class lets you work with directories. Write down what you think each of these lines of code does, then answer the two additional questions at the end.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg543.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</div></aside>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sharpen_your_pencil_solution-idd021">&#13;
<h5><span class="inlineimage"><img alt="Images" src="assets/pencil.png"/></span> Sharpen your pencil Solution</h5>&#13;
<p><a data-primary="escape sequences" data-type="indexterm" id="idm46402339653368"/>.NET has classes with a bunch of static methods for working with files and folders, and their method names are intuitive. The File class gives you methods to work with files, and the Directory class lets you work with directories. Your job was to write down what each bit of code did.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg544.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</div></aside>&#13;
</div></section>&#13;
</div></section>&#13;
<section data-pdf-bookmark="IDisposable makes sure objects are closed properly" data-type="sect1"><div class="sect1" id="idisposable_makes_sure_objects_are_close">&#13;
<h1>IDisposable makes sure objects are closed properly</h1>&#13;
<p><a data-primary="allocate, defined" data-type="indexterm" id="idm46402339648952"/><a data-primary="allocated resources" data-type="indexterm" id="idm46402339647368"/><a data-primary="Dispose() method" data-secondary="about" data-type="indexterm" id="idm46402339646264"/><a data-primary="IDisposable interface" data-secondary="about" data-type="indexterm" id="idm46402339645208"/>A lot of .NET classes implement a particularly useful interface called IDisposable. It <strong>has only one member</strong>: a method called Dispose. Whenever a class implements IDisposable, it’s telling you that there are important things that it needs to do in order to shut itself down, usually because it’s <strong>allocated resources</strong> that it won’t give back until you tell it to. The Dispose method is how you tell the object to release those resources.</p>&#13;
<section data-pdf-bookmark="Use the IDE to explore IDisposable" data-type="sect2"><div class="sect2" id="use_the_ide_to_explore_idisposable">&#13;
<h2>Use the IDE to explore IDisposable</h2>&#13;
<p>You can use the Go To Definition feature in the IDE (or “Go to Declaration” on a Mac) to see the definition of IDisposable. Go to your project and type <code>IDisposable</code> anywhere inside a class. Then right-click on it and select Go To Definition from the menu. It’ll open a new tab with code in it. Expand all of the code and this is what you’ll see:</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg545.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</div></section>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Avoid filesystem errors with using statements" data-type="sect1"><div class="sect1" id="avoid_filesystem_errors_with_using_state">&#13;
<h1>Avoid filesystem errors with <u>using</u> statements</h1>&#13;
<p><a data-primary="Captain Amazing" data-type="indexterm" id="idm46402339635512"/><a data-primary="errors" data-secondary="avoiding file system errors with using statements" data-type="indexterm" id="idm46402339634712"/><a data-primary="streams" data-secondary="using statements" data-type="indexterm" id="idm46402339633576"/><a data-primary="using statements" data-type="indexterm" id="idm46402339632488"/>Throughout the chapter we’ve been stressing that you need to <strong>close your streams</strong>. That’s because some of the most common bugs that programmers run across when they deal with files are caused when streams aren’t closed properly. Luckily, C# gives you a great tool to make sure that never happens to you: IDisposable and the Dispose method. When you <strong>wrap your stream code in a <code>using</code> statement</strong>, it automatically closes your streams for you. All you need to do is <strong>declare your stream reference</strong> with a <code>using</code> statement, followed by a block of code (inside curly brackets) that uses that reference. When you do that, C# <strong>automatically calls the Dispose method</strong> as soon as it finishes running the block of code.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><span style="color:#9D9EA0;">These “using” statements are different from the ones at the top of your code.</span></p>&#13;
</div>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg546.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><strong>This <code>using</code> statement declares a variable <code>sw</code> that references a new StreamWriter and is followed by a block of code. After all of the statements in the block are executed, the using block will <span style="color:#9D9EA0;"><u>automatically call sw.Dispose</u></span>.</strong></p>&#13;
</div>&#13;
<section data-pdf-bookmark="Use multiple using statements for multiple objects" data-type="sect2"><div class="sect2" id="use_multiple_using_statements_for_multip">&#13;
<h2>Use multiple using statements for multiple objects</h2>&#13;
<p>You can pile <code>using</code> statements on top of each other—you don’t need extra sets of curly brackets or indents:</p>&#13;
<pre data-type="programlisting">using (var reader = new StreamReader("secret_plan.txt"))&#13;
using (var writer = new StreamWriter("email.txt"))&#13;
{&#13;
     <span style="color:#9D9EA0;">// statements that use reader and writer</span>&#13;
}</pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><strong>Every stream has a Dispose method that closes the stream. When you declare your stream in a <code>using</code> statement, it will <span style="color:#9D9EA0;">always get closed!</span> And that’s important, because some streams <span style="color:#9D9EA0;"><em>don’t write</em></span> all of their data <em><u>until they’re closed.</u></em></strong></p>&#13;
</div>&#13;
<blockquote>&#13;
<p><strong>When you declare an object in a <span style="color:#9D9EA0;">using</span> block, that object’s Dispose method is called <u>automatically.</u></strong></p>&#13;
</blockquote>&#13;
</div></section>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Use a MemoryStream to stream data to memory" data-type="sect1"><div class="sect1" id="use_a_memorystream_to_stream_data_to_mem">&#13;
<h1>Use a MemoryStream to stream data to memory</h1>&#13;
<p><a data-primary="\\ (double backslash), escaping backslash in strings" data-type="indexterm" id="idm46402339610552"/><a data-primary="characters" data-type="indexterm" id="idm46402339609208"/><a data-primary="Encoding.UTF8.GetString" data-type="indexterm" id="idm46402339608328"/><a data-primary="escape sequences" data-type="indexterm" id="idm46402339607496"/><a data-primary="MemoryStream" data-type="indexterm" id="idm46402339606696"/>We’ve been using streams to read and write files. What if you want to read data from a file and then, well, do something with it? You can use a <strong>MemoryStream</strong>, which keeps track of all data streamed to it by storing it in memory. For example, you can create a new MemoryStream and pass it as an argument to a StreamWriter constructor, and then any data you write with the StreamWriter will be sent to that MemoryStream. You can retrieve that data using the <strong>MemoryStream.ToArray method</strong>, which returns all of the data that’s been streamed to it in a byte array.</p>&#13;
<section data-pdf-bookmark="Use Encoding.UTF8.GetString to convert byte arrays to strings" data-type="sect2"><div class="sect2" id="use_encodingdotutf8dotgetstring_to_conve">&#13;
<h2>Use Encoding.UTF8.GetString to convert byte arrays to strings</h2>&#13;
<p>One of the most common things that you’ll do with byte arrays is convert them to strings. For example, if you have a byte array called bytes, here’s one way to convert it to a string:</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg547-1.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>Here’s a small console app that uses composite formatting to write a number to a MemoryStream, and then convert it to a byte array and then to a string. Just one problem... <strong><em>it doesn’t work!</em></strong></p>&#13;
<p><strong>Create a new console app</strong> and add this code to it. Can you sleuth out the problem and fix it?</p>&#13;
<p><strong><em>Do this!</em></strong></p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg547-2.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><strong>This app doesn’t work! When you run it, it ’s supposed to write a line of text to the console, but it doesn’t write anything at all. We’ll explain what’s wrong, but before we do first see if you can <span style="color:#9D9EA0;"><u>sleuth it out</u> on your own.</span></strong></p>&#13;
<p><strong><em>Here’s a hint: can you figure out when the streams are closed?</em></strong></p>&#13;
</div>&#13;
<p><strong>Q: Remind me why you put an @ in front of the strings that contained filenames in that “Sharpen your pencil” exercise?</strong></p>&#13;
<p><strong>A:</strong> Because if we didn’t, the \S in “C:\SYP” would be interpreted as an invalid escape sequence and throw an exception. When you add a string literal to your program, the compiler converts escape sequences like <code>\n</code> and <code>\r</code> to special characters. Windows filenames have backslash characters in them, but C# strings normally use backslashes to start escape sequences. If you put @ in front of a string, it tells C# not to interpret escape sequences. It also tells C# to include line breaks in your string, so you can hit Enter halfway through the string and it’ll include that as a line break in the output.</p>&#13;
<p><strong>Q: And what exactly are escape sequences?</strong></p>&#13;
<p><strong>A:</strong> An escape sequence is a way to include special characters in your strings. For example, <code>\n</code> is a line feed, <code>\t</code> is a tab, and <code>\r</code> is a return character, or half of a Windows return (in Windows text files, lines have to end with <code>\r\n</code>; for macOS and Linux, lines just end in <code>\n</code>). If you need to include a quotation mark inside a string, you can use <code>\"</code> and it won’t end the string. If you want to use an actual backslash in your string and not have C# interpret it as the beginning of an escape sequence, just do a double backslash: <code>\\</code>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><span style="color:#9D9EA0;">We gave you a chance to sleuth this problem out on your own. Here’s how we fixed it.</span></p>&#13;
</div>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sleuth_it_out-idd0004">&#13;
<h5><span class="inlineimage"><img alt="Images" src="assets/cap.png"/></span> Sleuth it out</h5>&#13;
<p>Sherlock Holmes once said, “Data! Data! Data! I can’t make bricks without clay.” Let’s start at the scene of the crime: our code that’s not working. We’ll scour it for all of the data that we can find by digging up clues.</p>&#13;
<p>How many of these clues did you spot?</p>&#13;
<ul>&#13;
<li><p>We instantiate a StreamWriter that feeds data into a new MemoryStream.</p></li>&#13;
<li><p>The StreamWriter writes a line of text to the MemoryStream.</p></li>&#13;
<li><p>The contents of the MemoryStream are copied to an array and converted to a string.</p></li>&#13;
<li><p>This all happens inside a <code>using</code> block, so the streams are definitely closed.</p></li>&#13;
</ul>&#13;
<p>If you spotted all of those clues, then congratulations—you’ve been sharpening your code detective skills! But like in every great mystery, there’s always one last clue, some fact we learned earlier that proves to be the key to unraveling the whole crime and finding the culprit.</p>&#13;
<p>We used a <code>using</code> block, so we know that the streams definitely get closed. <strong><em>But <u>when</u> are they closed?</em></strong> Which leads us to the keystone to this mystery, the all-important clue that we learned just moments before the crime: <strong><em>some streams don’t write all of their data <u>until they’re closed.</u></em></strong></p>&#13;
<p>The StreamWriter and MemoryStream are declared in the same <code>using</code> block, so both Dispose methods are called <em>after the last line in the block is executed</em>. What does that mean? It means the MemoryStream.ToArray method is called <strong><em>before</em></strong> <em>the StreamWriter is closed.</em></p>&#13;
<p>So we can fix the problem by adding a <strong><em>nested</em></strong> <code>using</code> block to <em>first</em> close the StreamWriter and <em>then</em> call ToArray:</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg548.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><strong>Stream objects often have data in memory that’s <span style="color:#9D9EA0;"><u>buffered</u></span>, or waiting to be written. When the stream empties all of that data, it’s called <span style="color:#9D9EA0;"><u>flushing</u></span>. If you need to flush the buffered data without closing the stream, you can also <span style="color:#9D9EA0;"><u>call its Flush method.</u></span></strong></p>&#13;
</div>&#13;
</div></aside>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="exercise-idd0033">&#13;
<h5><span class="inlineimage"><img alt="Images" src="assets/exercise.png"/></span> Exercise</h5>&#13;
<p><a data-primary="exercises" data-secondary="for cards" data-type="indexterm" id="idm46402339558392"/>In <a href="ch08.html#enums_and_collections_organizing_your_da">#enums_and_collections_organizing_your_da</a> you created a Deck class that kept track of a sequence of Card objects, with methods to reset it to a 52-card deck in order, shuffle the cards to randomize their order, and sort the cards to put them back in order. Now you’ll add a method to write the cards to a file, and a constructor that lets you initialize a new deck by reading cards from a file.</p>&#13;
<p><strong>Start by reviewing the Deck and Card classes that you wrote in <a href="ch08.html#enums_and_collections_organizing_your_da">#enums_and_collections_organizing_your_da</a></strong></p>&#13;
<p>You created your Deck class by extending a generic collection of Card objects. This allowed you to use some useful members that Deck inherited from Collection&lt;Card&gt;:</p>&#13;
<ul>&#13;
<li><p>The Count property returns the number of cards in the deck.</p></li>&#13;
<li><p>The Add method adds a card to the top of the deck.</p></li>&#13;
<li><p>The RemoveAt method removes a card at a specific index from the deck.</p></li>&#13;
<li><p>The Clear method removes all cards from the deck.</p></li>&#13;
</ul>&#13;
<p>That gave you a solid starting point to add a Reset method that clears the deck and then adds 52 cards in order (Ace through King in each suit), a Deal method to remove the card from the top of the deck and return it, a Shuffle method to randomize the order of the cards, and a Sort method to put them back in order.</p>&#13;
<p><strong>Add a method to write all of the cards in the deck to a file</strong></p>&#13;
<p>Your Card class has a Name property that returns a string like “Three of Clubs” or “Ace of Hearts”. Add a method called WriteCards that takes a string with a filename as a parameter and writes the name of each card to a line in that file—so if you reset the deck and then call WriteCards, it will write 52 lines to the file, one for each card.</p>&#13;
<p><strong>Add an overloaded Deck constructor that reads a deck of cards in from a file</strong></p>&#13;
<p>Add a second constructor to the Deck class. Here’s what it should do:</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg549-1.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg549-2.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>In <a href="ch09.html#linq_and_lambdas_get_control_of_your_dat">#linq_and_lambdas_get_control_of_your_dat</a> you learned that switch expressions must be exhaustive, so add a default case that <strong>throws a new InvalidDataException</strong> if it encounters a suit or value that it doesn’t recognize—this will make sure each card is valid.</p>&#13;
<p>Here’s a Main method that you can use to test your app. It creates a deck with 10 random cards, writes it to a file, and then reads that file into a second deck and writes each of its cards to the console.</p>&#13;
</div></aside>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="exercise_solution-idd0024">&#13;
<h5><span class="inlineimage"><img alt="Images" src="assets/exercise.png"/></span> <strong>Exercise Solution</strong></h5>&#13;
<p>Here are the two methods that you added to the Deck class. The WriteCards method uses a StreamWriter to write each card to a file, and the overloaded Deck constructor uses a StreamReader to read each card from a file. Since you’re using a StreamWriter and StreamReader, make sure you add <code>using System.IO;</code> to the top of the file.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg550.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</div></aside>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="bullet_points-idd0023">&#13;
<h5>Bullet Points</h5>&#13;
<ul>&#13;
<li><p><a data-primary="macOS line endings" data-type="indexterm" id="idm46402339534824"/><a data-primary="Windows" data-secondary="line endings" data-type="indexterm" id="idm46402339532200"/>Whenever you want to read data from a file or write data to a file, you’ll use a <strong>Stream</strong> object. Stream is an abstract class, with subclasses that do different things.</p></li>&#13;
<li><p>A <strong>FileStream</strong> lets you read from and write to files. A <strong>MemoryStream</strong> reads or writes data in memory.</p></li>&#13;
<li><p>You can write your data to a stream through a stream’s <strong>Write method</strong>, and read data using its <strong>Read method</strong>.</p></li>&#13;
<li><p>A <strong>StreamWriter</strong> is a quick way to write data to a file. StreamWriter creates and manages a FileStream object for you automatically.</p></li>&#13;
<li><p>A <strong>StreamReader</strong> reads characters from streams, but it’s not a stream itself. It creates a stream for you, reads from it, and closes it when you call its Close method.</p></li>&#13;
<li><p>The Write and WriteLine methods of StreamWriter and Console use <strong>composite formatting</strong>, which takes a format string with placeholders like {0}, {1}, {2} that support formatting like {1:0.00} and {3:c}.</p></li>&#13;
<li><p><strong>Path.DirectorySeparatorChar</strong> is a read-only field that’s set to the path separator character for the operating system:  a “\” on Windows and “/” on macOS and Linux.</p></li>&#13;
<li><p>The <strong>Environment.GetFolderPath method</strong> returns the path of one of the special folders for the current user, such as the user’s Documents folder on Windows or home directory on macOS.</p></li>&#13;
<li><p>The <strong>File class</strong> has static methods including Exists (which checks if a file exists), OpenRead and OpenWrite (to get streams to read from or write to the file), and AppendAllText (to write text to a file in one statement).</p></li>&#13;
<li><p>The <strong>Directory class</strong> has static methods including CreateDirectory (to create folders), GetFiles (to get the list of files), and Delete (to remove a folder).</p></li>&#13;
<li><p>The <strong>FileInfo class</strong> is similar to the File class, except instead of using static methods it’s instantiated.</p></li>&#13;
<li><p>Remember to <strong>always close a stream</strong> after you’re done with it. Some streams don’t write all of their data until they’re closed or their <strong>Flush</strong> methods are called.</p></li>&#13;
<li><p>The <strong>IDisposable interface</strong> makes sure objects are closed properly. It includes one member, the Dispose method, which provides a mechanism for releasing unmanaged resources.</p></li>&#13;
<li><p>Use a <strong><code>using</code> statement</strong> to instantiate a class that implements IDisposable. The <code>using</code> statement is followed by a block of code; the object instantiated in the <code>using</code> statement is disposed of at the end of the block.</p></li>&#13;
<li><p>Use <strong>multiple <code>using</code> statements</strong> in a row to declare objects that are disposed of at the end of the same block.</p></li>&#13;
</ul>&#13;
</div></aside>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="windows_and_macos_have_different_line_en">&#13;
<h5>Windows and macOS have different line endings</h5>&#13;
<p>If you’re running Windows, open Notepad. If you’re running macOS, open TextEdit. Create a file with two lines—the first line has the characters L1 and the second has the characters L2.</p>&#13;
<p>If you used Windows, it will contain these six bytes: 76 49 13 10 76 50</p>&#13;
<p>If you used macOS, it will contain these five bytes: 76 49 10 76 50</p>&#13;
<p>Can you spot the difference? You can see that the first and second lines are encoded with the same bytes: L is 76, 1 is 49, and 2 is 50. The line break is encoded differently: on Windows it’s encoded with two bytes, 13 and 10, while on macOS it’s encoded with one byte, 10. This is the difference between Windows-style and Unix-style line endings (macOS is a flavor of Unix). If you need to write code that runs on different operating systems and writes files with line endings, you can use the static <strong>Environment.NewLine</strong> property, which returns “\r\n” on Windows and “\r” on macOS or Linux.</p>&#13;
</div></aside>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg552.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p><a data-primary="deserializing" data-type="indexterm" id="idm46402339499096"/><a data-primary="serialization" data-secondary="about" data-type="indexterm" id="idm46402339505976"/><strong>There’s an easier way to store your objects in files. It’s called <span style="color:#9D9EA0;">serialization.</span></strong></p>&#13;
<p><strong>Serialization</strong> means writing an object’s entire state to a file or string. <strong>Deserialization</strong> means reading the object’s state back from that file or string. So instead of painstakingly writing out each field and value to a file line by line, you can save your object the easy way by serializing it out to a stream. <strong><em>Serializing</em></strong> an object is like <strong>flattening it out</strong> so you can slip it into a file. On the other end, <strong><em>deserializing</em></strong> an object is like taking it out of the file and <strong>inflating</strong> it again.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><span style="color:#9D9EA0;">OK, just to come clean here: there’s also a method called Enum.Parse that will convert the string “Spades” to the enum value Suits.Spades. It even has a companion, Enum.TryParse, that works just like the int. TryParse method you’ve used throughout this book. But serialization still makes a lot more sense here. You’ll find out more about that shortly...</span></p>&#13;
</div>&#13;
</div></section>&#13;
</div></section>&#13;
<section data-pdf-bookmark="What happens to an object when it’s serialized?" data-type="sect1"><div class="sect1" id="what_happens_to_an_object_when_itapostro">&#13;
<h1>What happens to an object when it’s serialized?</h1>&#13;
<p><a data-primary="serialization" data-secondary="what happens to objects" data-type="indexterm" id="idm46402339495752"/>It seems like something mysterious has to happen to an object in order to copy it off of the heap and put it into a file, but it’s actually pretty straightforward.</p>&#13;
<ol>&#13;
<li><p><strong>Object on the heap</strong></p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg553-1.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>When you create an instance of an object, it has a <strong>state</strong>. Everything that an object “knows” is what makes one instance of a class different from another instance of the same class.</p></li>&#13;
<li><p><strong>Object serialized</strong></p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg553-2.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>When C# serializes an object, it <strong>saves the complete state of the object</strong>, so that an identical instance (object) can be brought back to life on the heap later.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg553-3.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</li>&#13;
<li><p><strong>And later on...</strong></p>&#13;
<p>Later—maybe days later, and in a different program—you can go back to the file and <strong>deserialize</strong> it. That pulls the original class back out of the file and restores it <strong>exactly as it was</strong>, with all of its fields and values intact.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg553-4.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</li>&#13;
</ol>&#13;
</div></section>&#13;
<section data-pdf-bookmark="But what exactly IS an object’s state? What needs to be saved?" data-type="sect1"><div class="sect1" id="but_what_exactly_is_an_objectapostrophes">&#13;
<h1>But what exactly <u>IS</u> an object’s state? What needs to be saved?</h1>&#13;
<p>We already know that <strong>an object stores its state in its fields and properties</strong>. So when an object is serialized, each of those values needs to be saved to the file.</p>&#13;
<p>Serialization starts to get interesting when you have more complicated objects. Chars, ints, doubles, and other value types have bytes that can just be written out to a file as is. What if an object has an instance variable that’s an object <em>reference</em>? What about an object that has five instance variables that are object references? What if those object instance variables themselves have instance variables?</p>&#13;
<p>Think about it for a minute. What part of an object is potentially unique? Think about what needs to be restored in order to get an object that’s identical to the one that was saved. Somehow everything on the heap has to be written to the file.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><span style="color:#9D9EA0;">Brain Barbell is like a “juiced up” Brain Power. Take a few minutes and really think about this one.</span></p>&#13;
</div>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="brain_barbell">&#13;
<h5><span class="inlineimage"><img alt="Images" src="assets/Common-3.png"/></span> Brain Barbell</h5>&#13;
<p>What has to happen for this Car object to be saved so that it can be restored to its original state? Let’s say the car has three passengers and a three-liter engine and all-weather radial tires...aren’t those things all part of the Car object’s state? What should happen to them?</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg554.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</div></aside>&#13;
</div></section>&#13;
<section data-pdf-bookmark="When an object is serialized, all of the objects it refers to get serialized, too..." data-type="sect1"><div class="sect1" id="when_an_object_is_serializedcomma_all_of">&#13;
<h1>When an object is serialized, all of the objects it refers to get serialized, too...</h1>&#13;
<p><a data-primary="serialization" data-secondary="what happens to objects" data-type="indexterm" id="idm46402339465800"/>...and all of the objects <em>they</em> refer to, and all of the objects <em>those other objects</em> refer to, and so on and so on. Don’t worry—it may sound complicated, but it all happens automatically. C# starts with the object you want to serialize and looks through its fields for other objects. Then it does the same for each of them. Every single object gets written out to the file, along with all the information C# needs to reconstitute it all when the object gets deserialized.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><strong>A group of objects connected to each other by references is sometimes referred to as a <u>graph.</u></strong></p>&#13;
</div>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg555.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Use JsonSerialization to serialize your objects" data-type="sect1"><div class="sect1" id="use_jsonserialization_to_serialize_your">&#13;
<h1>Use JsonSerialization to serialize your objects</h1>&#13;
<p><a data-primary="JSON serialization" data-type="indexterm" id="idm46402339460696"/><a data-primary="objects" data-secondary="reading entire with serialization" data-type="indexterm" id="idm46402339459288"/><a data-primary="serialization" data-secondary="reading entire object" data-type="indexterm" id="idm46402339456632"/>You’re not just limited to reading and writing lines of text to your files. You can use <strong>JSON serialization</strong> to let your programs <strong><em>copy entire objects</em></strong> to strings (which you can write to files!) and read them back in...all in just a few lines of code! Let’s take a look at how this works. Start by <strong>creating a new console app.</strong></p>&#13;
<p><strong><em>Do this!</em></strong></p>&#13;
<ol>&#13;
<li><p><strong>Design some classes for your object graph.</strong></p>&#13;
<p>Add this <code>HairColor</code> enum and these Guy, Outfit, and HairStyle classes to your new console app:</p>&#13;
<pre data-type="programlisting">class Guy {&#13;
    public string Name { get; set; }&#13;
    public HairStyle Hair { get; set; }&#13;
    public Outfit Clothes { get; set; }&#13;
    public override string ToString() =&gt; $"{Name} with {Hair} wearing {Clothes}";&#13;
}&#13;
&#13;
class Outfit {&#13;
    public string Top { get; set; }&#13;
    public string Bottom { get; set; }&#13;
    public override string ToString() =&gt; $"{Top} and {Bottom}";&#13;
}&#13;
&#13;
enum HairColor { &#13;
   Auburn, Black, Blonde, Blue, Brown, Gray, Platinum, Purple, Red, White &#13;
}&#13;
&#13;
class HairStyle {&#13;
    public HairColor Color { get; set; }&#13;
    public float Length { get; set; }&#13;
    public override string ToString() =&gt; $"{Length:0.0} inch {Color} hair";&#13;
}</pre></li>&#13;
<li><p><strong>Create a graph of objects to serialize.</strong></p>&#13;
<p>Now create a small graph of objects to serialize: a new List&lt;Guy&gt; pointing to a couple of Guy objects. Add this code to your Main method. It uses a collection initializer and object initializers to build the object graph:</p>&#13;
<pre data-type="programlisting">static void Main(string[] args) {&#13;
    var guys = new List&lt;Guy&gt;() {&#13;
       new Guy() { Name = "Bob", Clothes = new Outfit() { Top = "t-shirt", Bottom = "jeans" },&#13;
          Hair = new HairStyle() { Color = HairColor.Red, Length = 3.5f }&#13;
       },&#13;
       new Guy() { Name = "Joe", Clothes = new Outfit() { Top = "polo", Bottom = "slacks" },&#13;
          Hair = new HairStyle() { Color = HairColor.Gray, Length = 2.7f }&#13;
       },&#13;
    };&#13;
}</pre>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg556.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</li>&#13;
<li><p><a data-primary="exercises" data-secondary="JsonSerializer" data-type="indexterm" id="idm46402339444888"/><strong>Use JsonSerializer to serialize the objects to a string.</strong></p>&#13;
<p>First add a <code>using</code> directive to the top of your code file:</p>&#13;
<pre data-type="programlisting">using System.Text.Json;</pre>&#13;
<p>Now you can <strong>serialize the entire graph</strong> with a single line of code:</p>&#13;
<pre data-type="programlisting">    var jsonString = <strong>JsonSerializer.Serialize(guys);</strong>&#13;
    Console.WriteLine(jsonString);</pre>&#13;
<p>Run your app and look closely at what it prints to the console:</p>&#13;
<pre data-type="programlisting">[{"Name":"Bob","Hair":{"Color":8,"Length":3.5},"Clothes":{"Top":"t-shirt","Bot&#13;
tom":"jeans"}},{"Name":"Joe","Hair":{"Color":5,"Length":2.7},"Clothes":{"Top":&#13;
"polo","Bottom":"slacks"}}]</pre>&#13;
<p>That’s your object graph <strong>serialized to JSON</strong> (which some people pronounce “Jason” and others pronounce  “JAY-sahn”). It’s <em>a human-readable data interchange format</em>, which means that it’s a way to store complex objects using strings that a person can make sense of. Because it’s human readable, you can see that it has all of the parts of the graph: names and clothes are encoded as strings (“Bob”, “t-shirt”) and enums are encoded as their integer values.</p></li>&#13;
<li><p><strong>Use JsonSerializer to deserialize the JSON to a new object graph.</strong></p>&#13;
<p>Now that we have a string that contains the object graph serialized to JSON, we can <strong>deserialize</strong> it. That just means using it to create new objects. JsonSerializer lets us do that in one line of code, too. Add this to the Main method:</p>&#13;
<pre data-type="programlisting">var copyOfGuys = JsonSerializer.Deserialize&lt;List&lt;Guy&gt;&gt;(jsonString);&#13;
foreach (var guy in copyOfGuys)&#13;
    Console.WriteLine("I deserialized this guy: {0}", guy);</pre>&#13;
<p>Run your app again. It deserializes the guys from the JSON string and writes them to the console:</p>&#13;
<pre data-type="programlisting">I deserialized this guy: Bob with 3.5 inch Red hair wearing t-shirt and jeans&#13;
I deserialized this guy: Joe with 2.7 inch Gray hair wearing polo and slacks</pre></li>&#13;
</ol>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="json_up_close">&#13;
<h5><span class="inlineimage"><img alt="Images" src="assets/zoom.png"/></span> JSON Up Close</h5>&#13;
<p><a data-primary="{ } (curly brackets)" data-type="indexterm" id="idm46402339429000"/><a data-primary="JSON serialization" data-type="indexterm" id="idm46402339427944"/>Let’s take a closer look at how JSON actually works. Go back to your app with the Guy object graph and replace the line that serializes the graph to a string with this:</p>&#13;
<pre data-type="programlisting">var options = new JsonSerializerOptions() { WriteIndented = true };&#13;
var jsonString = JsonSerializer.Serialize(guys, options);</pre>&#13;
<p>That code calls an overloaded JsonSerializer.Serialize method that takes a JsonSerializerOptions object that lets you set options for the serializer. In this case, you’re telling it to write the JSON as indented text—in other words, it adds line breaks and spaces to make the JSON easier for people to read.</p>&#13;
<p>Now run the program again. The output should look like this:</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg558.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>Let’s break down exactly what we’re seeing:</p>&#13;
<ul>&#13;
<li><p>The JSON starts and ends with square brackets [ ]. This is how a list is serialized in JSON. A list of numbers would look like this: [1, 2, 3, 4].</p></li>&#13;
<li><p>This particular JSON represents a list with two objects. Each object starts and ends with curly braces { }—and if you look at the JSON, you can see that the second line is an opening curly brace <code>{</code>, the second-to-last line is a closing curly brace <code>}</code>, and in the middle there’s a line with <code>},</code> followed by a line with <code>{</code>. That’s how JSON represents two objects—in this case, the two Guy objects.</p></li>&#13;
<li><p>Each object contains a set of keys and values that correspond to the serialized object’s properties, separated by commas. For example, <code>"Name": "Joe",</code> represents the first Guy object’s Name property.</p></li>&#13;
<li><p>The Guy.Clothes property is an object reference that points to an Outfit object. It’s represented by a nested object with values for Top and Bottom.</p></li>&#13;
</ul>&#13;
</div></aside>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><strong>When you use JsonSerializer to serialize an object graph to JSON, it generates a (somewhat) readable text representation of the data in each object.</strong></p>&#13;
</div>&#13;
</div></section>&#13;
<section data-pdf-bookmark="JSON only includes data, not specific C# types" data-type="sect1"><div class="sect1" id="json_only_includes_datacomma_not_specifi">&#13;
<h1>JSON only includes data, not specific C# types</h1>&#13;
<p><a data-primary="emoji" data-type="indexterm" id="idm46402339413784"/><a data-primary="JSON serialization" data-type="indexterm" id="idm46402339412600"/>When you were looking through the JSON data, you saw human-readable versions of the data in your objects: strings like “Bob” and “slacks”, numbers like 8 and 3.5, and even lists and nested objects. What <em>didn’t</em> you see when you looked at the JSON data? JSON <strong>does not include the names of types</strong>. Look inside a JSON file and you won’t see class names like Guy, Outfit, HairColor, or HairStyle, or even the names of basic types like int, string, or double. That’s because JSON just contains the data, and JsonSerializer will do its best to deserialize the data into whatever properties it finds.</p>&#13;
<p>Let’s put this to the test. Add a new class to your project:</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg559.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>And run your code again. Since the JSON just has a list of objects, JsonSerializer.Deserialize will happily stick them into a Stack (or a Queue, or an array, or another collection type). Since Dude has public Name and Hair properties that match the data, it will fill in any data that it can. Here’s what it prints to the output:</p>&#13;
<pre data-type="programlisting">Next dude: Joe with 2.7 inch Gray hair hair&#13;
Next dude: Bob with 3.5 inch Red hair hair</pre>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sharpen_your_pencil-idd0039">&#13;
<h5><span class="inlineimage"><img alt="Images" src="assets/pencil.png"/></span> Sharpen your pencil</h5>&#13;
<p>Let’s use JsonSerializer to explore how strings are translated into JSON. Add the following code to a console app, then write down what each line of code writes to the console. The last line serializes the elephant animal emoji.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg559-1.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</div></aside>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><a data-primary="JsonSerializer" data-type="indexterm" id="idm46402339402696"/><span style="color:#9D9EA0;">One more thing! We showed you basic serialization with JsonSerializer. There are just a couple more things you need to know about it.</span></p>&#13;
</div>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="watch_itexclamation_mark-idd0012">&#13;
<h5><span class="inlineimage"><img alt="Images" src="assets/watchit.png"/></span> Watch it!</h5>&#13;
<p><strong>JsonSerializer only serializes public properties (<u>not</u> fields), and requires a parameterless constructor.</strong></p>&#13;
<p><em>Remember the SwordDamage class from <a href="ch05.html#encapsulation_keep_your_privateshellippr">#encapsulation_keep_your_privateshellippr</a>? Its Damage property has a private set accessor:</em></p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg560.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p><em>It also has a constructor that takes an int parameter:</em></p>&#13;
<pre data-type="programlisting">    <em>public SwordDamage(int startingRoll)</em></pre>&#13;
<p><em>You’ll be able to use JsonSerializer to serialize a SwordDamage object without any problems. If you try to deserialize one, JsonSerializer will throw an exception—at least, it will if you use the code we’ve shown you. If you want to serialize objects that save their state in fields, or private properties, or use constructors with parameters, you’ll need to create a converter. You can read more about that in the .NET Core serialization documentation: <a href="https://docs.microsoft.com/en-us/dotnet/standard/serialization">https://docs.microsoft.com/en-us/dotnet/standard/serialization</a>.</em></p>&#13;
</div></aside>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="bullet_points-idd0024">&#13;
<h5>Bullet Points</h5>&#13;
<ul>&#13;
<li><p><strong>Serialization</strong> means writing an object’s entire state to a file or string. <strong>Deserialization</strong> means reading the object’s state back from that file or string.</p></li>&#13;
<li><p>A group of objects connected to each other by references is sometimes referred to as a <strong>graph</strong>.</p></li>&#13;
<li><p>When an object is serialized, the <strong>entire graph</strong> of objects it refers to is serialized along with it so they can all be deserialized together.</p></li>&#13;
<li><p>The <strong>JsonSerializer class</strong> has a static Serialize method that serializes an object graph to JSON, and a static Deserialize method that instantiates an object graph using serialized JSON data.</p></li>&#13;
<li><p>JSON data is <strong>human</strong> <strong>readable</strong> (for the most part). Values are serialized as plain text: strings are written in “quotes” and other literals (like numbers and Boolean values) are encoded without quotes.</p></li>&#13;
<li><p>JSON represents <strong>arrays</strong> of values using square brackets [ ].</p></li>&#13;
<li><p>JSON represents <strong>objects</strong> inside curly brackets { }, with members and their values represented as key/value pairs separated by a colon.</p></li>&#13;
<li><p>JSON <strong>does not store specific types</strong> like string or int, or specific class names. Instead, it relies on “smart” classes like JsonSerializer to do their best to match the data to the type that the data is being deserialized into.</p></li>&#13;
</ul>&#13;
</div></aside>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Next up: we’ll take a deep dive into our data" data-type="sect1"><div class="sect1" id="next_up_weapostrophell_take_a_deep_dive">&#13;
<h1>Next up: we’ll take a deep dive into our data</h1>&#13;
<p><a data-primary="binary data" data-type="indexterm" id="idm46402339374648"/><a data-primary="characters" data-secondary="Unicode" data-type="indexterm" id="idm46402339373816"/><a data-primary="Unicode" data-type="indexterm" id="idm46402339372568"/>You’ve been writing lots of code using value types like int, bool, and double, and creating objects that store data in fields. Now it’s time to take a lower-level view of things. The rest of this chapter is all about getting to know your data better by understanding the actual bytes that C# and .NET use to represent it.</p>&#13;
<p>Here’s what we’ll do.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg561-1.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<blockquote>&#13;
<p><strong>We’ll explore how C# strings are encoded with Unicod—.NET uses Unicode to store characters and text.</strong></p>&#13;
</blockquote>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg561-2.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<blockquote>&#13;
<p><strong>We’ll write values as binary data, then we’ll read them back in and see what bytes were written.</strong></p>&#13;
</blockquote>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg561-3.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<blockquote>&#13;
<p><strong>We’ll build a hex dumper that lets us take a closer look at the bits and bytes in files.</strong></p>&#13;
</blockquote>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="game_designhellip_and_beyond">&#13;
<h5><span class="inlineimage"><img alt="Images" src="assets/game.png"/></span> <strong>Accessibility</strong></h5>&#13;
<p><a data-primary="Accessibility Game design... and beyond element" data-type="indexterm" id="idm46402339358664"/><a data-primary="Game design... and beyond elements" data-secondary="Accessibility" data-type="indexterm" id="idm46402339357608"/><strong>Game design... and beyond</strong></p>&#13;
<p>How would you play your favorite game if you were visually impaired? What if you had a motor or dexterity impairment that made it difficult for you to hold a controller? The goal of <strong>accessibility</strong> is to make sure that the programs that we build are designed so they can be used by people with disabilities or impairments. Game accessibility is all about making our games accessible to everyone, regardless of any impairments.</p>&#13;
<p>There are a few approaches to game testing you’ll want to think about as you start designing and building games:</p>&#13;
<ul>&#13;
<li><p><strong>“Wait, what? There are blind gamers?”</strong> Yes! Did you think that the “video” part of video games means they’re inaccessible to people with visual impairments? Take a few minutes to search YouTube for “blind gamer” and watch videos of people with visual impairments, including folks who are totally blind, showcase serious gaming skills.</p></li>&#13;
<li><p>One really important thing you can do as a developer to make your game accessible is to take time to <strong>understand players with impairments</strong>. So what did you learn from watching those videos?</p></li>&#13;
<li><p>One thing we learned from watching blind gamers play is that they use <strong>sounds from the games</strong> to understand what’s going on. In a fighting game, different moves may make different sounds. In a platformer, enemies coming towards the player might make telltale chirps or clicks. We also learned that while some games provide adequate <strong>audio cues</strong>, others don’t—and few (if any) games are <em>designed</em> to give totally blind players adequate audio cues to play the game.</p></li>&#13;
<li><p>On the other hand, many gamers have <strong>hearing impairments</strong>, so it’s important that you don’t rely only on audio cues. Try playing your game with the sound on mute. Does that keep important information from being conveyed to the player? Are there visual cues that go along with the audio? Are there subtitles for all of the dialog? Make sure your game is playable without sound.</p></li>&#13;
<li><p>1 in 12 men and 1 in 200 women have some form of <strong>color blindness</strong> (including one of the authors of this book!). Many high-budget games include a <em>color blind mode</em> that does sophisticated color adjustments. You can make your game more accessible to color-blind people by using colors that have a <strong>high contrast</strong> with each other.</p></li>&#13;
<li><p>Many gamers have a wide range of <strong>motor impairments</strong>, from repetitive strain injuries to paralysis. Players who are unable to use conventional input devices like a mouse and keyboard or a controller may use <strong>assistive hardware</strong> like an eye tracker or modified controller. One way you can accommodate these players is to make it easy for your games to accept keyboard mappings by letting players set up a profile where different keys map to the various game controls.</p></li>&#13;
<li><p>You may have noticed that many games start with a warning screen about seizures. That’s because many gamers with <strong>epilepsy</strong> are photosensitive, which means that certain flashing or flickering patterns can cause them to have seizures. While seizure warnings are important, we can do better. As developers, it’s important for us to put effort into understanding and avoiding the kinds of strobe lights, flashing, and other visual patterns most likely to trigger seizures. Take the time to read this editorial by video game reviewer Cathy Vice <strong>about her experience as a gamer with epilepsy</strong>: <a href="https://indiegamerchick.com/2013/08/06/the-epilepsy-thing/">https://indiegamerchick.com/2013/08/06/the-epilepsy-thing</a>.</p></li>&#13;
</ul>&#13;
<p><strong>Accessibility is often abbreviated as <em>#a11y</em>—that’s a “numeronym,” or a kind of shorthand that says <em>a</em> followed by 11 letters (“ccessibilit”) followed by <em>y</em>. It’s a great way to remind us that <em><u>we can all be responsible allies.</u></em></strong></p>&#13;
</div></aside>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><span style="color:#9D9EA0;">Accessibility features are often included as an afterthought, but your games—and any other kind of program!—come out better if you think about these things from the very beginning.</span></p>&#13;
</div>&#13;
</div></section>&#13;
<section data-pdf-bookmark="C# strings are encoded with Unicode" data-type="sect1"><div class="sect1" id="chash_strings_are_encoded_with_unicode">&#13;
<h1>C# strings are <u>encoded</u> with Unicode</h1>&#13;
<p><a data-primary="assistive technology" data-type="indexterm" id="idm46402339337640"/><a data-primary="characters" data-secondary="Unicode" data-type="indexterm" id="idm46402339336904"/><a data-primary="emoji" data-type="indexterm" id="idm46402339333112"/><a data-primary="Unicode" data-type="indexterm" id="idm46402339332280"/>You’ve been using strings since you typed <code>"Hello, world!"</code> into the IDE at the start of <a href="ch01.html#start_building_with_chash_build_somethin">#start_building_with_chash_build_somethin</a>. Because strings are so intuitive, we haven’t really needed to dissect them and figure out what makes them tick. But ask yourself...<strong><em>what exactly <u>is</u> a string?</em></strong></p>&#13;
<p>A C# string is a <strong>read-only collection of chars</strong>. So if you actually look at how a string is stored in memory, you’ll see the string “Elephant” stored as the chars ‘E’, ‘l’, ‘e’, ‘p’, ‘h’, ‘a’, ‘n’, and ‘t’. Now ask yourself...<strong><em>what exactly <u>is</u> a char?</em></strong></p>&#13;
<p>A char is a character represented with <strong>Unicode</strong>. Unicode is an industry standard for <strong>encoding</strong> characters, or converting them into bytes so they can be stored in memory, transmitted across networks, included in documents, or pretty much anything else you want to do with them—and you’re guaranteed that you’ll always get the correct characters.</p>&#13;
<p>This is especially important when you consider just how many characters there are. The Unicode standard supports over 150 <strong>scripts</strong> (sets of characters for specific languages), including not just Latin (which has the 26 English letters and variants like é and ç but scripts for many languages used around the world. The list of supported scripts is constantly growing, as the Unicode Consortium adds new ones every year (here’s the current list: <a href="http://www.unicode.org/standard/supported.html">http://www.unicode.org/standard/supported.html</a>).</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg563-1.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>Unicode supports another really important set of characters: <strong>emoji</strong>. All of the emoji, from the winking smiley face (<span class="inlineimage"><img alt="Images" src="assets/pg563-2.png"/></span> ) to the ever-popular pile of poo (<span class="inlineimage"><img alt="Images" src="assets/pg563-3.png"/></span> ), are Unicode characters.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="watch_itexclamation_mark-idd0013">&#13;
<h5><span class="inlineimage"><img alt="Images" src="assets/watch.png"/></span> Watch it!</h5>&#13;
<p><strong>Assistive technology can be thrown off by Unicode characters.</strong></p>&#13;
<p><em>Accessibility is <u>extremely</u> important. We felt that it’s especially valuable to bring up accessibility here because—like many of our “Game design... and beyond” topics—we can use it to teach a lesson that applies to all software development. You’ve probably seen posts on social media that use emoji or other “funny-looking” characters, and many that use boldfaced, cursive, or upside-down characters. On some platforms, these are done with Unicode characters, and when done like that they can be very problematic for assistive technology.</em></p>&#13;
<p><em>Take a social media post like this: <img alt="Images" src="assets/pg563-4.png"/></em></p>&#13;
<p><em>On screen, those hand claps look fine. But a screen reader like Windows Narrator or macOS VoiceOver might read that message aloud like this: “I’m clapping hands using clapping hands hand clapping hands claps clapping hands to clapping hands emphasize clapping hands points.”</em></p>&#13;
<p><em>You might see “fonts” that look like this: <img alt="Images" src="assets/pg563-5.png"/></em></p>&#13;
<p><em>A screen reader will read  <span class="inlineimage"><img alt="Images" src="assets/pg563-6.png"/></span> as “mathematical bold Fraktur small m” and other characters as “script letter n” or “mathematical double stroke small a,” or just leave them out entirely. The experience could be just as bad for someone using a braille reader. Are those assistive technologies somehow broken? Not at all—they’re doing their job. Those are the real names for those Unicode characters, and the assistive technologies are accurately describing the text. As you go through the next part of this chapter, keep these examples in mind—they’ll help you better understand how Unicode works.</em></p>&#13;
</div></aside>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg564.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p><a data-primary="binary data" data-type="indexterm" id="idm46402339309976"/><a data-primary="code points" data-type="indexterm" id="idm46402339309064"/><a data-primary="emoji" data-type="indexterm" id="idm46402339308424"/><a data-primary="UTF-8" data-type="indexterm" id="idm46402339302552"/><a data-primary="UTF-16" data-type="indexterm" id="idm46402339301640"/><strong>Every Unicode character—including emoji—has a unique number called a <span style="color:#9D9EA0;">code point.</span></strong></p>&#13;
<p>The number for a Unicode character is called a <strong>code point</strong>. You can download a list of all of the Unicode characters here: <a href="https://www.unicode.org/Public/UNIDATA/UnicodeData.txt">https://www.unicode.org/Public/UNIDATA/UnicodeData.txt</a>.</p>&#13;
<p>That’s a large text file with a line for every Unicode character. Download it and search for “ELEPHANT” and you’ll find a line that starts like this: <code>1F418;ELEPHANT</code>. The numbers 1F418 represent a <strong>hexadecimal</strong> (or <strong>hex</strong>) value. Hex values are written with the numbers 0 to 9 and letters A to F, and it’s often easier to work with Unicode values (and binary values in general) in hex than in decimal. You can create a hex literal in C# by adding 0x to the beginning, like this: 0x1F418.</p>&#13;
<p>1F418 is the Elephant emoji’s <strong><em>UTF-8</em></strong> <strong>code point</strong>. UTF-8 is the most common way to <strong>encode</strong> a character as Unicode (or represent it as a number). It’s a variable-length encoding, using between 1 and 4 bytes. In this case, it uses 3 bytes: 0x01 (or 1), 0xF4 (or 244), and 0x18 (or 24).</p>&#13;
<p>But that’s not what the JSON serializer printed. It printed a longer hex number: D83DDC18. That’s because <strong>the C# char type uses <em>UTF-16</em></strong>, which uses code points that consist of either one or two 2-byte numbers. The UTF-16 code point of the elephant emoji is 0xD83D 0xDC18. UTF-8 is much more popular than UTF-16, especially on the Web, so when you look up code points you’re much more likely to find UTF-8 than UTF-16.</p>&#13;
<blockquote>&#13;
<p><strong>UTF-8 is a variable-length encoding used by most web pages and many systems. It can store characters using one, two, three, or more bytes. UTF-16 is a fixed-length encoding that always uses either one or two 2-byte numbers. .NET stores char values in memory as UTF-16 values.</strong></p>&#13;
</blockquote>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Visual Studio works really well with Unicode" data-type="sect1"><div class="sect1" id="visual_studio_works_really_well_with_uni">&#13;
<h1>Visual Studio works really well with Unicode</h1>&#13;
<p><a data-primary="Visual Studio" data-secondary="Unicode and" data-type="indexterm" id="idm46402339289688"/>Let’s use Visual Studio to see how the IDE works with Unicode characters. You saw back in <a href="ch01.html#start_building_with_chash_build_somethin">#start_building_with_chash_build_somethin</a> that you can use emoji in code. Let’s see what else the IDE can handle. Go to the code editor and enter this code:</p>&#13;
<pre data-type="programlisting">    Console.WriteLine("Hello ");</pre>&#13;
<p>If you’re using Windows, open up the Character Map app. If you’re using a Mac, press Ctrl-<img alt="Images" src="assets/pg565a.png"/>-space to pop up the Character Viewer. Then search for the Hebrew letter shin (<img alt="Images" src="assets/pg565b.png"/>) and copy it to the clipboard.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg565.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>Place your cursor at the end of the string between the space and the quotation mark, and paste in the shin character that you copied to the clipboard. Hmm, something looks weird:</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg565-1.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>Did you notice that the cursor is positioned to the <em>left</em> of the pasted letter? Well, let’s continue. Don’t click anywhere in the IDE—keep the cursor where it is, then switch over to Character Map or Character Viewer to search for the Hebrew letter lamed (<img alt="Images" src="assets/pg565-2.png"/>). Switch back to the IDE—make sure the cursor is still positioned just left of the shin—and paste in the lamed:</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg565-3.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>When you pasted the lamed, the IDE added it to the left of the shin. Now search for the Hebrew letters vav (<code>I</code>) and final mem (<img alt="Images" src="assets/pg565-4.png"/>). Paste each of them into the IDE—it will insert them to the left of the cursor:</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg565-5.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>The IDE knows that <strong><em>Hebrew is read right to left</em></strong>, so it’s behaving accordingly. Click to select the text near the beginning of the statement, and slowly drag your cursor right to select <code>Hello</code> and then <img alt="Images" src="assets/pg565-6.png"/>. Watch carefully what happens when the selection reaches the Hebrew letters. It skips to the shin (<img alt="Images" src="assets/pg565-7.png"/>) and then selects from right to left—and that’s exactly what a Hebrew reader would expect it to do.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark=".NET uses Unicode to store characters and text" data-type="sect1"><div class="sect1" id="dotnet_uses_unicode_to_store_characters">&#13;
<h1>.NET uses Unicode to store characters and text</h1>&#13;
<p><a data-primary="char type" data-type="indexterm" id="idm46402339268584"/><a data-primary="encodings" data-type="indexterm" id="idm46402339265176"/><a data-primary="File class" data-secondary="ReadAllBytes( ) method" data-type="indexterm" id="idm46402339264408"/><a data-primary="File class" data-secondary="WriteAllBytes( ) method" data-type="indexterm" id="idm46402339263432"/><a data-primary="strings" data-secondary="storage of data in memory as Unicode" data-type="indexterm" id="idm46402339262344"/><a data-primary="UTF-8" data-type="indexterm" id="idm46402339261336"/><a data-primary="UTF-16" data-type="indexterm" id="idm46402339260536"/>The two C# types for storing text and characters—string and char—keep their data in memory as Unicode. When that data’s written out as bytes to a file, each of those Unicode numbers is written out to the file. Let’s get a sense of exactly how Unicode data is written out to a file. <strong>Create a new console app.</strong> We’ll use the File.WriteAllBytes and File.ReadAllBytes methods to start exploring Unicode.</p>&#13;
<p><strong><em>Do this!</em></strong></p>&#13;
<ol>&#13;
<li><p><strong>Write a normal string out to a file and read it back.</strong></p>&#13;
<p>Add the following code to the Main method—it uses File.WriteAllText to write the string “Eureka!” out to a file called <em>eureka.txt</em> (so you’ll need <code>using System.IO;</code>). Then it creates a new byte array called <code>eurekaBytes</code>, reads the file into it, and prints out all of the bytes it read:</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg566.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>You’ll see these bytes written to the output: <code>69 117 114 101 107 97 33</code>. The last line calls the method Encoding.UTF8.GetString, which converts a byte array with UTF-8-encoded characters to a string. Now <strong>open the file in Notepad</strong> (Windows) <strong>or TextEdit</strong> (Mac). It says “Eureka!”</p></li>&#13;
<li><p><strong>Then add code to write the bytes as hex numbers.</strong></p>&#13;
<p>When you’re encoding data you’lloften use hex, so let’s do that now. Add this code to the end of the Main method that writes the same bytes out, using <code>{0:x2}</code> to <strong>format each byte as a hex number</strong>:</p>&#13;
<pre data-type="programlisting">foreach (byte b in eurekaBytes)&#13;
    Console.Write("{0:x2} ", b);&#13;
Console.WriteLine();</pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><span style="color:#9D9EA0;">Hex uses the numbers 0 through 9 and letters A through F to represent numbers in base 16, so 6B is equal to 107.</span></p>&#13;
</div>&#13;
<p>That tells Write to print parameter 0 (the first one after the string to print) as a two-character hex code. So it writes the same seven bytes in hex instead of decimal: <code>45 75 72 65 6b-61 21</code>.</p>&#13;
</li>&#13;
<li><p><strong>Modify the first line to write the Hebrew letters “<img alt="Images" src="assets/pg566-2.png"/>” instead of “Eureka!”</strong></p>&#13;
<p>You just added the Hebrew text <span class="inlineimage"><img alt="Images" src="assets/pg566-2.png"/></span> to another program using either Character Map (Windows) or Character Viewer (Mac). <strong>Comment out the first line of the Main method and replace it with the following code</strong> that writes <span class="inlineimage"><img alt="Images" src="assets/pg566-2.png"/></span> to the file instead of “Eureka!” We’ve added an extra Encoding.Unicode parameter so it writes UTF-16 (the Encoding class is in the System.Text namespace, so also add <code>using System.Text;</code> to the top):</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg566-1.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>Now run the code again, and look closely at the output: <code>ff fe e9 05 dc 05 d5 05 dd 05</code>. The first two characters are “FF FE”, which is the Unicode way of saying that we’re going to have a string of 2-byte characters. The rest of the bytes are the Hebrew letters—but they’re reversed, so U+05E9 appears as <code><strong>e9 05</strong></code>. Now open the file up in Notepad or TextEdit to make sure it looks right.</p></li>&#13;
<li><p><a data-primary="escape sequences" data-type="indexterm" id="idm46402339236504"/><a data-primary="\u escape sequences" data-type="indexterm" id="idm46402339234360"/><a data-primary="UTF-32" data-type="indexterm" id="idm46402339233480"/><strong>Use JsonSerializer to explore UTF-8 and UTF-16 code points.</strong></p>&#13;
<p>When you serialized the elephant emoji, JsonSerializer generated <code>\uD83D\uDC18</code> – which we now know is the 4-byte UTF-16 code point in hex. Now let’s try that with the Hebrew letter shin. Add <code>using System.Text.Json;</code> to the top of your app and then add this line:</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg567-1a.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>Run your app again. This time it printed a value with two hex bytes, “\u05E9”—that’s the UTF-16 code point for the Hebrew letter shin. It’s also the UTF-8 code point for the same letter.</p>&#13;
<p>But wait a minute—we learned that the UTF-8 code point for the elephant emoji is <code>0x1F418</code>, which is <strong><em>different</em></strong> than the UTF-16 code point (0xD83D 0xDC18). What’s going on?</p>&#13;
<p>It turns out that most of the characters with 2-byte UTF-8 code points have the same code points in UTF-16. Once you reach the UTF-8 values that require three or more bytes—which includes the familiar emoji that we’ve used in this book—they differ. So while the Hebrew letter shin is 0x05E9 in both UTF-8 and UTF-16, the elephant emoji is 0x1F418 in UTF-8 and 0xD8ED 0xDC18 in UTF-16.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg567-1.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</li>&#13;
<li><p><strong>Use Unicode escape sequences to encode</strong> <img alt="Images" src="assets/pg567-2.png"/>.</p>&#13;
<p>Add these lines to your Main method to write the elephant emoji to two files using both the UTF-16 and UTF-32 escape sequences:</p>&#13;
<pre data-type="programlisting">File.WriteAllText("elephant1.txt", "\uD83D\uDC18");&#13;
File.WriteAllText("elephant2.txt", "\U0001F418");</pre>&#13;
<p>Run your app again, then open both of those files in Notepad or TextEdit. You should see the correct character written to the file.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><strong>You used UTF-16 and UTF-32 escape sequences to create your emoji, but the WriteAllText method <span style="color:#9D9EA0;"><u>writes a UTF-8 file</u></span>. The Encoding.UTF8.GetString method you used in step 1 converts a byte array with UTF-8-encoded data back to a string.</strong></p>&#13;
</div></li>&#13;
</ol>&#13;
</div></section>&#13;
<section data-pdf-bookmark="C# can use byte arrays to move data around" data-type="sect1"><div class="sect1" id="chash_can_use_byte_arrays_to_move_data_a">&#13;
<h1>C# can use byte arrays to move data around</h1>&#13;
<p><a data-primary="byte arrays" data-type="indexterm" id="idm46402339220328"/><a data-primary="File class" data-secondary="ReadAllBytes( ) method" data-type="indexterm" id="idm46402339214808"/><a data-primary="File class" data-secondary="WriteAllBytes( ) method" data-type="indexterm" id="idm46402339213832"/>Since all your data ends up encoded as <strong>bytes</strong>, it makes sense to think of a file as one <strong>big byte array</strong>...and you already know how to read and write byte arrays.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg568.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Use a BinaryWriter to write binary data" data-type="sect1"><div class="sect1" id="use_a_binarywriter_to_write_binary_data">&#13;
<h1>Use a BinaryWriter to write binary data</h1>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><a data-primary="binary data" data-type="indexterm" id="idm46402339207640"/><a data-primary="binary data" data-secondary="writing" data-type="indexterm" id="idm46402339206440"/><a data-primary="BinaryWriter" data-type="indexterm" id="idm46402339205288"/><a data-primary="exercises" data-secondary="Sharpen your pencil" data-tertiary="Unicode" data-type="indexterm" id="idm46402339204456"/><a data-primary="Sharpen Your Pencil exercises" data-secondary="Unicode" data-type="indexterm" id="idm46402339203032"/><a data-primary="UTF-8" data-type="indexterm" id="idm46402339201992"/><span style="color:#9D9EA0;">StreamWriter also encodes your data. It just specializes in text and text encoding—it defaults to UTF-8.</span></p>&#13;
</div>&#13;
<p>You <strong><em>could</em></strong> encode all of your strings, chars, ints, and floats into byte arrays before writing them out to files, but that would get pretty tedious. That’s why .NET gives you a very useful class called <strong>BinaryWriter</strong> that <strong>automatically encodes your data</strong> and writes it to a file. All you need to do is create a FileStream and pass it into the BinaryWriter’s constructor (they’re in the System.IO namespace, so you’ll need <code>using System.IO;</code>). Then you can call its methods to write out your data. Let’s practice using BinaryWriter to write binary data to a file.</p>&#13;
<p><strong><em>Do this!</em></strong></p>&#13;
<ol>&#13;
<li><p>Start by creating a console app and setting up some data to write to a file:</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg569-1a.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</li>&#13;
<li><p>To use a BinaryWriter, first you need to open a new stream with File.Create:</p>&#13;
<pre data-type="programlisting">  using (var output = File.Create("binarydata.dat"))&#13;
  using (var writer = new BinaryWriter(output))&#13;
  {</pre></li>&#13;
<li><p>Now just call its Write method. Each time you do this, it adds new bytes onto the end of the file that contain an encoded version of whatever data you passed it as a parameter:</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg569-1.png"/>&#13;
<h6/>&#13;
</div></figure></li>&#13;
<li><p>Now use the same code you used before to read in the file you just wrote:</p>&#13;
<pre data-type="programlisting">  byte[] dataWritten = File.ReadAllBytes("binarydata.dat");&#13;
  foreach (byte b in dataWritten)&#13;
      Console.Write("{0:x2} ", b);&#13;
  Console.WriteLine(" - {0} bytes", dataWritten.Length);</pre>&#13;
<p>Write down the output in the blanks below. Can you <strong>figure out</strong> <strong>what bytes correspond</strong> to each of the five <code>writer.Write(...)</code> statements? We put a bracket under the groups of bytes that correspond with each statement to help you figure out which bytes in the file correspond with data written by the app.</p>&#13;
</li>&#13;
</ol>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sharpen_your_pencil_">&#13;
<h5><span class="inlineimage"><img alt="Images" src="assets/pencil.png"/></span> Sharpen your pencil</h5>&#13;
<p>Here’s a hint: <span style="color:#9D9EA0;">strings can be different lengths, so the string has to start with a number to tell .NET how long it is. BinaryWriter uses UTF-8 to encode strings, and in UTF-8 all of the characters in “Hello!” have UTF code points that consist of a single byte. Download UnicodeData.txt from unicode.org (we gave you the URL earlier) and use it to look up the code points for each character.</span></p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg569-2.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</div></aside>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Use BinaryReader to read the data back in" data-type="sect1"><div class="sect1" id="use_binaryreader_to_read_the_data_back_i">&#13;
<h1>Use BinaryReader to read the data back in</h1>&#13;
<p><a data-primary="binary data" data-secondary="reading" data-type="indexterm" id="idm46402339180120"/><a data-primary="BinaryReader" data-type="indexterm" id="idm46402339178440"/>The BinaryReader class works just like BinaryWriter. You create a stream, attach the BinaryReader object to it, and then call its methods...but the reader <strong>doesn’t know what data’s in the file</strong>! It has no way of knowing. Your float value of 491.695F was encoded as d8 f5 43 45. Those same bytes are a perfectly valid <code>int</code>—1,140,185,334—so you’ll need to tell the BinaryReader exactly what types to read from the file. Add the following code to your program, and have it read the data you just wrote.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><span style="color:#9D9EA0;">Don’t take our word for it. Replace the line that reads the float with a call to ReadInt32. (You’ll need to change the type of floatRead to int.) Then you can see for yourself what it reads from the file.</span></p>&#13;
</div>&#13;
<ol>&#13;
<li><p>Start out by setting up the FileStream and BinaryReader objects:</p>&#13;
<pre data-type="programlisting">using (var input = File.OpenRead("binarydata.dat"))&#13;
using (var reader = new BinaryReader(input))&#13;
{</pre></li>&#13;
<li><p>You tell BinaryReader what type of data to read by calling its different methods:</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg570-1.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</li>&#13;
<li><p>Now write the data that you read from the file to the console:</p>&#13;
<pre data-type="programlisting">     Console.Write("int: {0}  string: {1}  bytes: ", intRead, stringRead);&#13;
     foreach (byte b in byteArrayRead)&#13;
         Console.Write("{0} ", b);&#13;
     Console.Write(" float: {0}  char: {1} ", floatRead, charRead);&#13;
  }</pre>&#13;
<p>Here’s the output that gets printed to the console:</p>&#13;
<pre data-type="programlisting">  int: 48769414  string: Hello!  bytes: 47 129 0 116  float: 491.695  char: E</pre>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sharpen_your_pencil_solution-idd022">&#13;
<h5><span class="inlineimage"><img alt="Images" src="assets/pencil.png"/></span> Sharpen your pencil Solution</h5>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg570-2.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</div></aside></li>&#13;
</ol>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="there_are_no_dumb_questions-idd0035">&#13;
<h5>there are no Dumb Questions</h5>&#13;
<p><a data-primary="File class" data-secondary="Close( ) method" data-type="indexterm" id="idm46402339159096"/><a data-primary="File class" data-secondary="ReadAllBytes( ) method" data-type="indexterm" id="idm46402339157864"/><a data-primary="File class" data-secondary="ReadAllLines( ) method" data-type="indexterm" id="idm46402339156712"/><a data-primary="File class" data-secondary="ReadAllText( ) method" data-type="indexterm" id="idm46402339155656"/><a data-primary="File class" data-secondary="static methods" data-type="indexterm" id="idm46402339154648"/><a data-primary="File class" data-secondary="WriteAllBytes( ) method" data-type="indexterm" id="idm46402339153496"/><a data-primary="File class" data-secondary="WriteAllLines( ) method" data-type="indexterm" id="idm46402339152376"/><a data-primary="File class" data-secondary="WriteAllText( ) method" data-type="indexterm" id="idm46402339151224"/><a data-primary="FileStreams" data-secondary="versus StreamReader and StreamWriter" data-type="indexterm" id="idm46402339150088"/><a data-primary="StreamReader" data-secondary="versus FileStreams" data-type="indexterm" id="idm46402339148984"/><a data-primary="StreamWriter" data-secondary="versus FileStreams" data-type="indexterm" id="idm46402339147848"/><a data-primary="UTF-8" data-type="indexterm" id="idm46402339146776"/><strong>Q: Earlier in the chapter when I wrote “Eureka!” to a file and then read the bytes back, it took one byte per character. So why did each of the Hebrew letters in <span class="inlineimage"><img alt="Images" src="assets/571fig01.png"/></span> take two bytes? And why did it write the bytes “FF FE” at the beginning of the file?</strong></p>&#13;
<p><strong>A:</strong> What you’re seeing is the difference between two closely related Unicode encodings. Latin characters (including plain English letters), numbers, normal punctuation marks, and some standard characters (like curly brackets, ampersands, and other things you see on your keyboard) all have very low Unicode numbers—between 0 and 127. They correspond to a very old encoding called ASCII that dates back to the 1960s, and UTF-8 was designed to be backward compatible with ASCII. A file with only those Unicode characters contains just their bytes and nothing else.</p>&#13;
<p>Things get a little more complicated when you add Unicode characters with higher-numbered code points into the mix. One byte can only hold a number between 0 and 255. Two bytes in a row can store numbers between 0 and 65,536—which, in hex, is FFFF. The file needs to be able to tell whatever program opens it up that it’s going to contain these higher-numbered characters, so it puts a special reserved byte sequence at the beginning of the file: FF FE. That’s called the <em>byte order mark</em>. As soon as a program sees that, it knows that all of the characters are encoded with two bytes each (so an E is encoded as 00 45, with a leading zero).</p>&#13;
<p><strong>Q: Why is it called a byte order mark?</strong></p>&#13;
<p><strong>A:</strong> Go back to the code that wrote <span class="inlineimage"><img alt="Images" src="assets/571fig02.png"/></span> to a file, then printed the bytes it wrote. You’ll see that the bytes in the file were reversed. For example, the <span class="inlineimage"><img alt="Images" src="assets/571fig03.png"/></span> code point U+05E9 was written to the file as E9 05. That’s called <em>little-endian</em>—it means the least significant byte is written first. Go back to the code that calls WriteAllText and modify it to <strong>change the third argument from Encoding.Unicode to Encoding.BigEndianUnicode</strong>. That tells it to write the data out in <em>big-endian</em>, which doesn’t flip the bytes around—when you run it again, you’ll see the bytes come out as 05 E9 instead. You’ll also see a different byte order mark: FE FF. This tells Notepad or TextEdit how to interpret the bytes in the file.</p>&#13;
<p><strong>Q: Why didn’t I use a <code>using</code> block or call Close after I used File.ReadAllText and File.WriteAllText?</strong></p>&#13;
<p><strong>A:</strong> The File class has several very useful static methods that automatically open up a file, read or write data, and then <strong>close it automatically</strong>. In addition to the ReadAllText and WriteAllText methods, there are ReadAllBytes and WriteAllBytes, which work with byte arrays, and ReadAllLines and WriteAllLines, which read and write string arrays, where each string in the array is a separate line in the file. All of these methods automatically open and close the streams, so you can do your whole file operation in a single statement.</p>&#13;
<p><strong>Q: If FileStream has methods for reading and writing, why do I ever need to use StreamReader and StreamWriter?</strong></p>&#13;
<p><strong>A:</strong> The FileStream class is really useful for reading and writing bytes in binary files. Its methods for reading and writing operate with bytes and byte arrays. A lot of programs work exclusively with text files, and that’s where StreamReader and StreamWriter come in really handy. They have methods that are built specifically for reading and writing lines of text. Without them, if you wanted to read a line of text in from a file, you’d have to first read a byte array and then write a loop to search through that array for a linebreak—so it’s not hard to see how they make your life easier.</p>&#13;
</div></aside>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><strong>If you’re writing a string that only has Unicode characters with low numbers (such as Latin letters), it writes one byte per character. If it’s got high-numbered characters (like emoji characters), they’ll be written using two or more bytes each.</strong></p>&#13;
</div>&#13;
</div></section>&#13;
<section data-pdf-bookmark="A hex dump lets you see the bytes in your files" data-type="sect1"><div class="sect1" id="a_hex_dump_lets_you_see_the_bytes_in_you">&#13;
<h1>A hex dump lets you see the bytes in your files</h1>&#13;
<p><a data-primary="characters" data-type="indexterm" id="idm46402339128600"/><a data-primary="hex dump" data-type="indexterm" id="idm46402339127752"/><a data-primary="streams" data-secondary="using file streams to build hex dumper" data-type="indexterm" id="idm46402339126984"/><a data-primary="UTF-8" data-type="indexterm" id="idm46402339125288"/>A <strong>hex dump</strong> is a <em>hexadecimal</em> view of the contents of a file, and it’s a really common way for programmers to take a deep look at a file’s internal structure.</p>&#13;
<p>It turns out that hex is a convenient way to display bytes in a file. A byte takes two characters to display in hex: bytes range from 0 to 255, or 00 to ff in hex. That lets you see a lot of data in a really small space, and in a format that makes it easier to spot patterns. It’s useful to display binary data in rows that are 8, 16, or 32 bytes long because most binary data tends to break down in chunks of 4, 8, 16, or 32...like all the types in C#. (For example, an int takes up 4 bytes.) A hex dump lets you see exactly what those values are made of.</p>&#13;
<section data-pdf-bookmark="How to make a hex dump of some plain text" data-type="sect2"><div class="sect2" id="how_to_make_a_hex_dump_of_some_plain_tex">&#13;
<h2>How to make a hex dump of some plain text</h2>&#13;
<p>Start with some familiar text using Latin characters:</p>&#13;
<pre data-type="programlisting">When you have eliminated the impossible, whatever remains, however&#13;
improbable, must be the truth. - Sherlock Holmes</pre>&#13;
<p>First, break up the text into 16-character segments, starting with the first 16: <code>When you have el</code></p>&#13;
<p>Next, convert each character in the text to its UTF-8 code point. Since the Latin characters all have <strong><em>1-byte</em></strong> UTF-8 code points, each will be represented by a two-digit hex number from 00 to 7F. Here’s what each line of our dump will look like:</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg572.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>Repeat until you’ve dumped every 16-character segment in the file:</p>&#13;
<pre data-type="programlisting">     0000: 57 68 65 6e 20 79 6f 75 -- 20 68 61 76 65 20 65 6c    When you have el&#13;
     0010: 69 6d 69 6e 61 74 65 64 -- 20 74 68 65 20 69 6d 70    iminated the imp&#13;
     0020: 6f 73 73 69 62 6c 65 2c -- 20 77 68 61 74 65 76 65    ossible, whateve&#13;
     0030: 72 20 72 65 6d 61 69 6e -- 73 2c 20 68 6f 77 65 76    r remains, howev&#13;
     0040: 65 72 20 69 6d 70 72 6f -- 62 61 62 6c 65 2c 20 6d    er improbable, m&#13;
     0050: 75 73 74 20 62 65 20 74 -- 68 65 20 74 72 75 74 68    ust be the truth&#13;
     0060: 2e 20 2d 20 53 68 65 72 -- 6c 6f 63 6b 20 48 6f 6c    . - Sherlock Hol&#13;
     0070: 6d 65 73 0a             --                            mes.</pre>&#13;
<p>And that’s our dump. There are many hex dump programs for various operating systems, and each of them has a slightly different output. Each line in our particular hex dump format represents 16 characters in the input that was used to generate it, with the offset at the start of each line and the text for each character at the end. Other hex dump apps might display things differently (for example, rendering escape sequences or showing values in decimal).</p>&#13;
<blockquote>&#13;
<p><strong>A hex dump is a hexadecimal view of data in a file or memory, and can be a really useful tool to help you debug binary data.</strong></p>&#13;
</blockquote>&#13;
</div></section>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Use StreamReader to build a hex dumper" data-type="sect1"><div class="sect1" id="use_streamreader_to_build_a_hex_dumper">&#13;
<h1>Use StreamReader to build a hex dumper</h1>&#13;
<p><a data-primary="StreamReader" data-secondary="building hex dumper using" data-type="indexterm" id="idm46402339105480"/><a data-primary="StreamReader" data-secondary="ReadBlock method" data-type="indexterm" id="idm46402339110712"/><a data-primary="String.Substring method" data-type="indexterm" id="idm46402339109672"/>Let’s build a hex dump app that reads data from a file with StreamReader and writes its dump to the console. We’ll take advantage of the <strong>ReadBlock method</strong> in StreamReader, which reads a block of characters into a char array: you specify the number of characters you want to read, and it’ll either read that many characters or, if there are fewer than that many left in the file, it’ll read the rest of the file. Since we’re displaying 16 characters per line, we’ll read blocks of 16 characters.</p>&#13;
<p><strong>Create a new console app called HexDump</strong>. Before you add code, <strong>run the app</strong> to create the folder with the binary. Use Notepad or TextEdit to <strong>create a text file called</strong> <em>textdata.txt</em>, add some text to it, and put it in the same folder as the binary.</p>&#13;
<p>Here’s the code from inside the Main method—it reads the <em>textdata.txt</em> file and writes a hex dump to the console. Make sure you add <code>using System.IO;</code> to the top.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><strong>The <span style="color:#9D9EA0;"><u>ReadBlock method</u></span> reads the next characters from its input into a byte array (sometimes referred to as a buffer). It <span style="color:#9D9EA0;"><u>blocks</u></span>, which means it keeps executing and doesn’t return until it’s either read all of the characters you asked for or run out of data to read.</strong></p>&#13;
</div>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg573.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Use Stream.Read to read bytes from a stream" data-type="sect1"><div class="sect1" id="use_streamdotread_to_read_bytes_from_a_s">&#13;
<h1>Use Stream.Read to read <u>bytes</u> from a stream</h1>&#13;
<p><a data-primary="Stream object" data-type="indexterm" id="idm46402339094568"/><a data-primary="streams" data-secondary="reading bytes from, using Stream.Read( )" data-type="indexterm" id="idm46402339093416"/>The hex dumper works just fine for text files—but there’s a problem. <strong>Copy the <em>binarydata.dat</em> file</strong> you wrote with BinaryWriter into the same folder as your app, then change the app to read it:</p>&#13;
<pre data-type="programlisting">    using (var reader = new StreamReader("binarydata.dat"))</pre>&#13;
<p>Now run your app. This time it prints something else—but it’s not quite right:</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg574-1.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>The text characters (“Hello<code>!</code>”) seem OK. But compare the output with the “Sharpen your pencil” solution—the bytes aren’t quite right. It looks like it replaced some bytes (86, e8, 81, f6, d8, and f5) with a different byte, fd. That’s because <strong>StreamReader is built to read text files</strong>, so it only reads <strong>7-bit values</strong>, or byte values up to 127 (7F in hex, or 1111111 in binary—which are 7 bits).</p>&#13;
<p>So let’s do this right—by <strong><em>reading the bytes directly from the stream</em></strong>. Modify the <code>using</code>  block so it uses <strong>File.OpenRead</strong>, which opens the file and <strong>returns a FileStream</strong>. You’ll use the Stream’s Length property to keep reading until you’ve read all of the bytes in the file, and its Read method to read the next 16 bytes into the byte array buffer:</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg574-2.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>The rest of the code is the same, except for the line that sets <code>bufferContents:</code></p>&#13;
<pre data-type="programlisting">    <span style="color:#9D9EA0;">// Write the actual characters in the byte array</span>&#13;
    var bufferContents = Encoding.UTF8.GetString(buffer);</pre>&#13;
<p>You used the Encoding class earlier in the chapter to convert a byte array to a string. This byte array contains a single byte per character—that means it’s a valid UTF-8 string. That means you can use Encoding.UTF8.GetString to convert it. Since the Encoding class is in the System.Text namespace, you’ll need to add <code>using System.Text;</code> to the top of the file.</p>&#13;
<p>Now run your app again. This time it prints the correct bytes instead of changing them to fd:</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg574-3.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>There’s just one more thing we can do to clean up the output. Many hex dump programs replace nontext characters with dots in the output. <strong>Add this line to the end of the <code>for</code> loop:</strong></p>&#13;
<pre data-type="programlisting">   if (buffer[i] &lt; 0x20 || buffer[i] &gt; 0x7F) buffer[i] = (byte)’.’;</pre>&#13;
<p>Now run your app again—this time the question marks are replaced with dots:</p>&#13;
<pre data-type="programlisting">    0000: 86 29 e8 02 06 48 65 6c -- 6c 6f 21 2f 81 00 74 f6    .)...Hello!/..t.&#13;
    0010: d8 f5 43 45             --                            ..CE</pre>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Modify your hex dumper to use command-line arguments" data-type="sect1"><div class="sect1" id="modify_your_hex_dumper_to_use_command_li">&#13;
<h1>Modify your hex dumper to use <u>command-line arguments</u></h1>&#13;
<p><a data-primary="command line" data-type="indexterm" id="idm46402339070200"/><a data-primary="command-line arguments" data-type="indexterm" id="idm46402339068936"/><a data-primary="Main method" data-type="indexterm" id="idm46402339068072"/>Most hex dump programs are utilities that you run from the command line. You can dump a file by passing its name to the hex dumper as a <strong>command-line argument</strong>, like this: <code>C:\&gt; HexDump myfile.txt</code></p>&#13;
<p>Let’s modify the hex dumper to use command-line arguments. When you create a console app, C# makes the command-line arguments available as the <strong><code>args</code> string array</strong> that gets passed to the Main method:</p>&#13;
<pre data-type="programlisting">   static void Main<strong>(string[] args)</strong></pre>&#13;
<p>We’ll modify the Main method to open a file and read its contents from a stream. The <strong>File.OpenRead method</strong> takes a filename as a parameter, opens it for reading, and returns a stream with the file contents.</p>&#13;
<p>Change these lines in your Main method:</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg575.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>Now let’s use the command-line argument in the IDE by <strong>changing the debug properties</strong> to pass a command line to the program. <strong>Right-click on the <u>project</u></strong> in the solution, then:</p>&#13;
<ul>&#13;
<li><p><strong><em>On Windows,</em></strong> choose Properties, then click Debug, and enter the filename to dump in the Application arguments box (either the full path or the name of a file in the binary folder).</p></li>&#13;
<li><p><strong><em>On macOS,</em></strong> choose Options, expand Run &gt;&gt; Configurations, click Default, and enter the filename in the Arguments box.</p></li>&#13;
</ul>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><span style="color:#9D9EA0;">Make sure you right-click on the <u>project</u>, not the solution.</span></p>&#13;
</div>&#13;
<p>Now when you debug your app, its <code>args</code> array will contain the arguments you set in the project settings. <strong><em>Make sure you <u>specify a valid filename</u> when you set up the command-line arguments.</em></strong></p>&#13;
<section data-pdf-bookmark="Run your app from the command line" data-type="sect2"><div class="sect2" id="run_your_app_from_the_command_line">&#13;
<h2>Run your app from the command line</h2>&#13;
<p>You can also run the app from the command line, replacing <code>[filename]</code> with the name of a file (either the full path or the name of a file in the current directory):</p>&#13;
<ul>&#13;
<li><p><strong><em>On Windows,</em></strong> Visual Studio builds an executable under the bin\Debug folder (in the same place you put your files to read), so you can run the executable directly from that folder. Open a command window, <strong><code>cd</code></strong> to the bin\Debug folder, and run <code>HexDump [filename].</code></p></li>&#13;
<li><p><strong><em>On a Mac,</em></strong> you’ll need to <strong>build a self-contained application</strong>. Open a Terminal window, go to the project folder, and run this command: <code>dotnet publish -r osx-x64.</code></p>&#13;
<p>The output will include a line like this: <code>HexDump -&gt; /path-to-binary/osx-x64/publish/</code></p>&#13;
<p>Open a Terminal window, <code>cd</code> to the full path that it printed, and run <code>./HexDump [filename].</code></p></li>&#13;
</ul>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="downloadable_exercise_hide_and_seek">&#13;
<h5><span class="inlineimage"><img alt="Images" src="assets/com25.png"/></span> Downloadable exercise: Hide and Seek</h5>&#13;
<p><a data-primary="characters" data-secondary="Unicode" data-type="indexterm" id="idm46402339039560"/><a data-primary="escape sequences" data-type="indexterm" id="idm46402339038360"/><a data-primary="Unicode" data-type="indexterm" id="idm46402339037560"/><a data-primary="UTF-8" data-type="indexterm" id="idm46402339036648"/><a data-primary="UTF-16" data-type="indexterm" id="idm46402339035768"/><a data-primary="UTF-32" data-type="indexterm" id="idm46402339034968"/>In this next exercise you’ll build an app where you explore a house and play a game of Hide and Seek against a computer player. You’ll put your collection and interface skills to the test when you lay out the locations. Then you’ll turn it into a game, serializing the state of the game to a file so you can save and load it.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg576.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p><strong>Go to the GitHub page for the book and download the project PDF:</strong></p>&#13;
<p><strong><a href="https://github.com/head-first-csharp/fourth-edition">https://github.com/head-first-csharp/fourth-edition</a></strong></p>&#13;
</div></aside>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="bullet_points-idd0025">&#13;
<h5>Bullet Points</h5>&#13;
<ul>&#13;
<li><p><strong>Unicode</strong> is an industry standard for <em>encoding</em> characters, or converting them into bytes. Every one of the over one million Unicode characters has a <em>code point</em>, or a unique number assigned to it.</p></li>&#13;
<li><p>Most files and web pages are encoded using <strong>UTF-8</strong>, a variable-length Unicode encoding that encodes some characters with either one, two, three, or four bytes.</p></li>&#13;
<li><p>C# and .NET use <strong>UTF-16</strong> when storing characters and text in memory, treating a string as a <strong>read-only collection of chars</strong>.</p></li>&#13;
<li><p>The <strong>Encoding.UTF8.GetString method</strong> converts a UTF-8 byte array to a string. <strong>Encoding.Unicode</strong> converts a byte array encoded with UTF-16 to a string, and Encoding.UTF32 converts a UTF-32 byte array.</p></li>&#13;
<li><p>Use <strong><code>\u</code> escape sequences</strong> to include Unicode in C# strings. The <code>\u</code> escape sequence encodes UTF-16, while <strong><code>\U</code></strong> encodes <strong>UTF-32</strong>, a 4-byte fixed-length encoding.</p></li>&#13;
<li><p>StreamWriter and StreamReader work will with text, but will not handle many characters outside of the Latin character sets. Use <strong>BinaryWriter and BinaryReader</strong> to read and write binary data.</p></li>&#13;
<li><p>The <strong>StreamReader.ReadBlock</strong> method reads characters into a byte array buffer. It <strong>blocks</strong>, or keeps executing and doesn’t return, until it’s either read all of the characters you asked for or run out of data to read.</p></li>&#13;
<li><p>File.OpenRead returns a FileStream, and the <strong>FileStream.Read method</strong> reads bytes from a stream.</p></li>&#13;
<li><p>The <strong>String.Substring method</strong> returns a part of a string. The String class has an <strong>overloaded constructor</strong> that takes a char array as a parameter and converts it to a string.</p></li>&#13;
<li><p>C# makes the command-line arguments for a console app available as the <code>args</code> string array that gets passed to the Main method.</p></li>&#13;
</ul>&#13;
</div></aside>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section></body></html>