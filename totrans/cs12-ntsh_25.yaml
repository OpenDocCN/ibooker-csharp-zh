- en: Chapter 25\. Regular Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The regular expressions language identifies character patterns. The .NET types
    supporting regular expressions are based on Perl 5 regular expressions and support
    both search and search/replace functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regular expressions are used for tasks such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Validating text input such as passwords and phone numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing textual data into more structured forms (e.g., a NuGet version string)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing patterns of text in a document (e.g., whole words only)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter is split into both conceptual sections teaching the basics of regular
    expressions in .NET, and reference sections describing the regular expressions
    language.
  prefs: []
  type: TYPE_NORMAL
- en: All regular expression types are defined in `System.Text.RegularExpressions`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The samples in this chapter are all preloaded into LINQPad, which also includes
    an interactive RegEx tool (press Ctrl+Shift+F1). An online tool is available at
    [*http://regexstorm.net/tester*](http://regexstorm.net/tester).
  prefs: []
  type: TYPE_NORMAL
- en: Regular Expression Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most common regular expression operators is a *quantifier*. `?`
    is a quantifier that matches the preceding item 0 or 1 time. In other words, `?`
    means *optional*. An item is either a single character or a complex structure
    of characters in square brackets. For example, the regular expression `"colou?r"`
    matches `color` and `colour`, but not `colouur`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`Regex.Match` searches within a larger string. The object that it returns has
    properties for the `Index` and `Length` of the match as well as the actual `Value`
    matched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can think of `Regex.Match` as a more powerful version of the `string`’s
    `IndexOf` method. The difference is that it searches for a *pattern* rather than
    a literal string.
  prefs: []
  type: TYPE_NORMAL
- en: The `IsMatch` method is a shortcut for calling `Match` and then testing the
    `Success` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The regular expressions engine works from left to right by default, so only
    the leftmost match is returned. You can use the `NextMatch` method to return more
    matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Matches` method returns all matches in an array. We can rewrite the preceding
    example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Another common regular expressions operator is the *alternator*, expressed
    with a vertical bar, `|`. An alternator expresses alternatives. The following
    matches “Jen”, “Jenny”, and “Jennifer”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The brackets around an alternator separate the alternatives from the rest of
    the expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can specify a timeout when matching regular expressions. If a match operation
    takes longer than the specified `TimeSpan`, a `RegexMatchTimeoutException` is
    thrown. This can be useful if your program processes user-supplied regular expressions
    because it prevents malformed regular expressions from infinitely spinning.
  prefs: []
  type: TYPE_NORMAL
- en: Compiled Regular Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some of the preceding examples, we called a static `RegEx` method repeatedly
    with the same pattern. An alternative approach in these cases is to instantiate
    a `Regex` object with the pattern and `RegexOptions.Compiled` and then call instance
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`RegexOptions.Compiled` instructs the `RegEx` instance to use lightweight code
    generation (`DynamicMethod` in `Reflection.Emit`) to dynamically build and compile
    code tailored to that particular regular expression. This results in faster matching,
    at the expense of an initial compilation cost.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also instantiate a `Regex` object without using `RegexOptions.Compiled`.
    A `Regex` instance is immutable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The regular expressions engine is fast. Even without compilation, a simple match
    typically takes less than a microsecond.
  prefs: []
  type: TYPE_NORMAL
- en: RegexOptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `RegexOptions` flags enum lets you tweak matching behavior. A common use
    for `RegexOptions` is to perform a case-insensitive search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This applies the current culture’s rules for case equivalence. The `CultureInvariant`
    flag lets you request the invariant culture instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can activate most of the `RegexOptions` flags within a regular expression
    itself, using a single-letter code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can turn options on and off throughout an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Another useful option is `IgnorePatternWhitespace` or `(?x)`. This allows you
    to insert whitespace to make a regular expression more readable—without the whitespace
    being taken literally.
  prefs: []
  type: TYPE_NORMAL
- en: The `NonBacktracking` option (from .NET 7) instructs the regex engine to use
    a forwards-only matching algorithm. This usually results in slower performance
    and disables some advanced features such as lookahead or lookbehind. However,
    it also prevents malformed or maliciously constructed expressions from taking
    near-infinite time, mitigating a potential denial-of-service attack when processing
    user-supplied regular expressions (a *ReDOS* attack). Specifying a timeout is
    also useful in this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 25-1](#regular_expression_options-id00102) lists all `RegExOptions`
    values along with their single-letter codes.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 25-1\. Regular expression options
  prefs: []
  type: TYPE_NORMAL
- en: '| Enum value | Regular expressions code | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `None` |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| `IgnoreCase` | `i` | Ignores case (by default, regular expressions are case
    sensitive) |'
  prefs: []
  type: TYPE_TB
- en: '| `Multiline` | `m` | Changes `^` and `$` so that they match the start/end
    of a line instead of start/end of the string |'
  prefs: []
  type: TYPE_TB
- en: '| `ExplicitCapture` | `n` | Captures only explicitly named or explicitly numbered
    groups (see [“Groups”](#groups)) |'
  prefs: []
  type: TYPE_TB
- en: '| `Compiled` |   | Forces compilation to IL (see [“Compiled Regular Expressions”](#compiled_regular_expressions))
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Singleline` | `s` | Makes `.` match every character (instead of matching
    every character except `\n`) |'
  prefs: []
  type: TYPE_TB
- en: '| `IgnorePatternWhitespace` | `x` | Eliminates unescaped whitespace from the
    pattern |'
  prefs: []
  type: TYPE_TB
- en: '| `RightToLeft` | `r` | Searches from right to left; can’t be specified midstream
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ECMAScript` |   | Forces ECMA compliance (by default, the implementation
    is not ECMA compliant) |'
  prefs: []
  type: TYPE_TB
- en: '| `CultureInvariant` |   | Turns off culture-specific behavior for string comparisons
    |'
  prefs: []
  type: TYPE_TB
- en: '| `NonBacktracking` |   | Disables backtracking to ensure predictable (albeit
    slower) performance |'
  prefs: []
  type: TYPE_TB
- en: Character Escapes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Regular expressions have the following metacharacters, which have a special
    rather than literal meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: \ * + ? | { [ () ^ $ . #
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To use a metacharacter literally, you must prefix, or *escape*, the character
    with a backslash. In the following example, we escape the `?` character to match
    the string `"what?"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If the character is inside a *set* (square brackets), this rule does not apply,
    and the metacharacters are interpreted literally. We discuss sets in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Regex`’s `Escape` and `Unescape` methods convert a string containing regular
    expression metacharacters by replacing them with escaped equivalents, and vice
    versa:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'All the regular expression strings in this chapter are expressed with the C#
    `@` literal. This is to bypass C#’s escape mechanism, which also uses the backslash.
    Without the `@`, a literal backslash would require four backslashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Unless you include the `(?x)` option, spaces are treated literally in regular
    expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Character Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Character sets act as wildcards for a particular set of characters.
  prefs: []
  type: TYPE_NORMAL
- en: '| Expression | Meaning | Inverse (“not”) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `[abcdef]` | Matches a single character in the list. | `[^abcdef]` |'
  prefs: []
  type: TYPE_TB
- en: '| `[a-f]` | Matches a single character in a *range.* | `[^a-f]` |'
  prefs: []
  type: TYPE_TB
- en: '| `\d` | Matches anything in the Unicode *digits* category. In ECMAScript mode,
    `[0-9]`. | `\D` |'
  prefs: []
  type: TYPE_TB
- en: '| `\w` | Matches a *word* character (by default, varies according to `CultureInfo.CurrentCulture`;
    for example, in English, same as `[a-zA-Z_0-9]`). | `\W` |'
  prefs: []
  type: TYPE_TB
- en: '| `\s` | Matches a whitespace character; that is, anything for which `char.IsWhiteSpace`
    returns true (including Unicode spaces). In ECMAScript mode, `[\n\r\t\f\v ]`.
    | `\S` |'
  prefs: []
  type: TYPE_TB
- en: '| `\p{`*category*`}` | Matches a character in a specified *category*. | `\P`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `.` | (Default mode) Matches any character except `\n`. | `\n` |'
  prefs: []
  type: TYPE_TB
- en: '| `.` | (`SingleLine` mode) Matches any character. | `\n` |'
  prefs: []
  type: TYPE_TB
- en: 'To match exactly one of a set of characters, put the character set in square
    brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To match any character *except* those in a set, put the set in square brackets
    with a `^` symbol before the first character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can specify a range of characters by using a hyphen. The following regular
    expression matches a chess move:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`\d` indicates a digit character, so `\d` will match any digit. `\D` matches
    any nondigit character.'
  prefs: []
  type: TYPE_NORMAL
- en: '`\w` indicates a word character, which includes letters, numbers, and the underscore.
    `\W` matches any nonword character. These work as expected for non-English letters,
    too, such as Cyrillic.'
  prefs: []
  type: TYPE_NORMAL
- en: '`.` matches any character except `\n` (but allows `\r`).'
  prefs: []
  type: TYPE_NORMAL
- en: '`\p` matches a character in a specified category, such as `{Lu}` for uppercase
    letter or `{P}` for punctuation (we list the categories in the reference section
    later in the chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We will find more uses for `\d`, `\w`, and `.` when we combine them with *quantifiers*.
  prefs: []
  type: TYPE_NORMAL
- en: Quantifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quantifiers match an item a specified number of times.
  prefs: []
  type: TYPE_NORMAL
- en: '| Quantifier | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | Zero or more matches |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | One or more matches |'
  prefs: []
  type: TYPE_TB
- en: '| `?` | Zero or one match |'
  prefs: []
  type: TYPE_TB
- en: '| `{*n*}` | Exactly `*n*` matches |'
  prefs: []
  type: TYPE_TB
- en: '| `{*n*,}` | At least `*n*` matches |'
  prefs: []
  type: TYPE_TB
- en: '| `{*n*,*m*}` | Between `*n*` and `*m*` matches |'
  prefs: []
  type: TYPE_TB
- en: 'The `*` quantifier matches the preceding character or group zero or more times.
    The following matches *cv.docx*, along with any numbered versions of the same
    file (e.g., *cv2.docx*, *cv15.docx*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we must escape the period in the file extension using a backslash.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following allows anything between *cv* and *.docx* and is equivalent to
    `dir cv*.docx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `+` quantifier matches the preceding character or group one or more times.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `{}` quantifier matches a specified number (or range) of repetitions. The
    following matches a blood pressure reading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Greedy Versus Lazy Quantifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, quantifiers are *greedy*, as opposed to *lazy*. A greedy quantifier
    repeats as *many* times as it can before advancing. A lazy quantifier repeats
    as *few* times as it can before advancing. You can make any quantifier lazy by
    suffixing it with the `?` symbol. To illustrate the difference, consider the following
    HTML fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Suppose that we want to extract the two phrases in italics. If we execute the
    following
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'the result is not two matches, but a *single* match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that our `*` quantifier greedily repeats as many times as it
    can before matching `</i>`. So, it passes right by the first `</i>`, stopping
    only at the final `</i>` (the *last point* at which the rest of the expression
    can still match).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we make the quantifier lazy, the `*` bails out at the *first* point at which
    the rest of the expression can match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Zero-Width Assertions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The regular expressions language lets you place conditions on what should occur
    *before* or *after* a match, through *lookbehind*, *lookahead*, *anchors*, and
    *word boundaries*. These are called *zero-width* assertions because they don’t
    increase the width (or length) of the match itself.
  prefs: []
  type: TYPE_NORMAL
- en: Lookahead and Lookbehind
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `(?=*expr*)` construct checks whether the text that follows matches `*expr*`,
    without including `expr` in the result. This is called *positive lookahead*. In
    the following example, we look for a number followed by the word “miles”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the word “miles” was not returned in the result, even though it
    was required to *satisfy* the match.
  prefs: []
  type: TYPE_NORMAL
- en: 'After a successful *lookahead*, matching continues as though the sneak preview
    never took place. So, if we append `.*` to our expression like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: the result is `25 miles more`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lookahead can be useful in enforcing rules for a strong password. Suppose that
    a password must be at least six characters and contain at least one digit. With
    a lookup, we could achieve this, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This first performs a *lookahead* to ensure that a digit occurs somewhere in
    the string. If satisfied, it returns to its position before the sneak preview
    began and matches six or more characters. (In [“Cookbook Regular Expressions”](#cookbook_regular_expressions),
    we include a more substantial password validation example.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The opposite is the *negative lookahead* construct, `(?!*expr*)`. This requires
    that the match *not* be followed by `*expr*`. The following expression matches
    “good”—unless “however” or “but” appears later in the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `(?<=*expr*)` construct denotes *positive lookbehind* and requires that
    a match be *preceded* by a specified expression. The opposite construct, `(?<!*expr*)`,
    denotes *negative lookbehind* and requires that a match *not be preceded* by a
    specified expression. For example, the following matches “good”—unless “however”
    appears *earlier* in the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We could improve these examples by adding *word boundary assertions*, which
    we introduce shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Anchors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The anchors `^` and `$` match a particular *position*. By default:'
  prefs: []
  type: TYPE_NORMAL
- en: '`^`'
  prefs: []
  type: TYPE_NORMAL
- en: Matches the *start* of the string
  prefs: []
  type: TYPE_NORMAL
- en: '`$`'
  prefs: []
  type: TYPE_NORMAL
- en: Matches the *end* of the string
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`^` has two context-dependent meanings: an *anchor* and a *character class
    negator*.'
  prefs: []
  type: TYPE_NORMAL
- en: '`$` has two context-dependent meanings: an *anchor* and a *replacement group
    denoter*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When you specify `RegexOptions.Multiline` or include `(?m)` in the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '`^` matches the start of the string or *line* (directly after a `\n`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$` matches the end of the string or *line* (directly before a `\n`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There’s a catch to using `$` in multiline mode: a new line in Windows is nearly
    always denoted with `\r\n` rather than just `\n`. This means that for `$` to be
    useful for Windows files, you must usually match the `\r`, as well, with a *positive
    lookahead*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The *positive lookahead* ensures that `\r` doesn’t become part of the result.
    The following matches lines that end in `".txt"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following matches all empty lines in string `s`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following matches all lines that are either empty or contain only whitespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Because an anchor matches a position rather than a character, specifying an
    anchor on its own matches an empty string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Word Boundaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The word boundary assertion `\b` matches where word characters (`\w`) adjoin
    either:'
  prefs: []
  type: TYPE_NORMAL
- en: Nonword characters (`\W`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The beginning/end of the string (`^` and `$`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\b` is often used to match whole words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The following statements highlight the effect of a word boundary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The next query uses *positive lookahead* to return words followed by “(sic)”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, it’s useful to separate a regular expression into a series of subexpressions,
    or *groups*. For instance, consider the following regular expression that represents
    a US phone number such as 206-465-1918:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose that we want to separate this into two groups: area code and local
    number. We can achieve this by using parentheses to *capture* each group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We then retrieve the groups programmatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The zeroth group represents the entire match. In other words, it has the same
    value as the match’s `Value`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Groups are part of the regular expressions language itself. This means that
    you can refer to a group within a regular expression. The `\n` syntax lets you
    index the group by group number `n` within the expression. For example, the expression
    `(\w)ee\1` matches `deed` and `peep`. In the following example, we find all words
    in a string starting and ending in the same letter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The brackets around the `\w` instruct the regular expressions engine to store
    the submatch in a group (in this case, a single letter) so that it can be used
    later. We refer to that group later using `\1`, meaning the first group in the
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: Named Groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a long or complex expression, it can be easier to work with groups by *name*
    rather than index. Here’s a rewrite of the previous example, using a group that
    we name `''letter''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how to name a captured group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s how to refer to a group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example matches a simple (non-nested) XML/HTML element by looking
    for start and end nodes with a matching name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Allowing for all possible variations in XML structure, such as nested elements,
    is more complex. The .NET regular expressions engine has a sophisticated extension
    called “matched balanced constructs” that can assist with nested tags—information
    on this is available on the internet and in [*Mastering Regular Expressions*](https://learning.oreilly.com/library/view/mastering-regular-expressions/0596528124/)
    (O’Reilly) by Jeffrey E. F. Friedl.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing and Splitting Text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `RegEx.Replace` method works like `string.Replace` except that it uses a
    regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following replaces “cat” with “dog”. Unlike with `string.Replace`, “catapult”
    won’t change into “dogapult”, because we match on word boundaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The replacement string can reference the original match with the `$0` substitution
    construct. The following example wraps numbers within a string in angle brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You can access any captured groups with `$1`, `$2`, `$3`, and so on, or `${*name*}`
    for a named group. To illustrate how this can be useful, consider the regular
    expression in the previous section that matched a simple XML element. By rearranging
    the groups, we can form a replacement expression that moves the element’s content
    into an XML attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: MatchEvaluator Delegate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Replace` has an overload that takes a `MatchEvaluator` delegate, which is
    invoked per match. This allows you to delegate the content of the replacement
    string to C# code when the regular expressions language isn’t expressive enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In [“Cookbook Regular Expressions”](#cookbook_regular_expressions), we show
    how to use a `Match​Eva⁠luator` to escape Unicode characters appropriately for
    HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting Text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The static `Regex.Split` method is a more powerful version of the `string.Split`
    method, with a regular expression denoting the separator pattern. In this example,
    we split a string, where any digit counts as a separator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The result, here, doesn’t include the separators themselves. You can include
    the separators, however, by wrapping the expression in a *positive lookahead*.
    The following splits a camel-case string into separate words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Cookbook Regular Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recipes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Matching US Social Security number/phone number
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Extracting “name = value” pairs (one per line)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that this starts with the *multiline* directive `(?m)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Strong password validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following checks whether a password has at least six characters and whether
    it contains a digit, symbol, or punctuation mark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Lines of at least 80 characters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Parsing dates/times (N/N/N H:M:S AM/PM)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This expression handles a variety of numeric date formats—and works whether
    the year comes first or last. The `(?x)` directive improves readability by allowing
    whitespace; the `(?i)` switches off case sensitivity (for the optional AM/PM designator).
    You can then access each component of the match through the `Groups` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: (Of course, this doesn’t verify that the date/time is correct.)
  prefs: []
  type: TYPE_NORMAL
- en: Matching Roman numerals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Removing repeated words
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here, we capture a named group called `dupe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Word count
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Matching a GUID
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Parsing an XML/HTML tag
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Regex is useful for parsing HTML fragments—particularly when the document might
    be imperfectly formed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Splitting a camel-cased word
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This requires a *positive lookahead* to include the uppercase separators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Obtaining a legal filename
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Escaping Unicode characters for HTML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Unescaping characters in an HTTP query string
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Parsing Google search terms from a web stats log
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You should use this in conjunction with the previous example to unescape characters
    in the query string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Regular Expressions Language Reference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tables [25-2](#character_escapes) through [25-12](#regular_expression_option)
    summarize the regular expressions grammar and syntax supported in the .NET implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Table 25-2\. Character escapes
  prefs: []
  type: TYPE_NORMAL
- en: '| Escape code sequence | Meaning | Hexadecimal equivalent |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `\a` | Bell | `\u0007` |'
  prefs: []
  type: TYPE_TB
- en: '| `\b` | Backspace | `\u0008` |'
  prefs: []
  type: TYPE_TB
- en: '| `\t` | Tab | `\u0009` |'
  prefs: []
  type: TYPE_TB
- en: '| `\r` | Carriage return | `\u000A` |'
  prefs: []
  type: TYPE_TB
- en: '| `\v` | Vertical tab | `\u000B` |'
  prefs: []
  type: TYPE_TB
- en: '| `\f` | Form feed | `\u000C` |'
  prefs: []
  type: TYPE_TB
- en: '| `\n` | Newline | `\u000D` |'
  prefs: []
  type: TYPE_TB
- en: '| `\e` | Escape | `\u001B` |'
  prefs: []
  type: TYPE_TB
- en: '| `\*nnn*` | ASCII character *nnn* as octal (e.g., `\n052`) |   |'
  prefs: []
  type: TYPE_TB
- en: '| `\x*nn*` | ASCII character *nn* as hex (e.g., `\x3F`) |   |'
  prefs: []
  type: TYPE_TB
- en: '| `\c*l*` | ASCII control character *l* (e.g., `\cG` for Ctrl-G) |   |'
  prefs: []
  type: TYPE_TB
- en: '| `\u*nnnn*` | Unicode character *nnnn* as hex (e.g., `\u07DE`) |   |'
  prefs: []
  type: TYPE_TB
- en: '| `\*symbol*` | A nonescaped symbol |   |'
  prefs: []
  type: TYPE_TB
- en: 'Special case: within a regular expression, `\b` means word boundary, except
    in a `[ ]` set, in which `\b` means the backspace character.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 25-3\. Character sets
  prefs: []
  type: TYPE_NORMAL
- en: '| Expression | Meaning | Inverse (“not”) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `[abcdef]` | Matches a single character in the list | `[^abcdef]` |'
  prefs: []
  type: TYPE_TB
- en: '| `[a-f]` | Matches a single character in a *range* | `[^a-f]` |'
  prefs: []
  type: TYPE_TB
- en: '| `\d` | Matches a decimal digit Same as `[0-9]` | `\D` |'
  prefs: []
  type: TYPE_TB
- en: '| `\w` | Matches a *word* character (by default, varies according to `CultureInfo.CurrentCulture`;
    for example, in English, same as `[a-zA-Z_0-9]`) | `\W` |'
  prefs: []
  type: TYPE_TB
- en: '| `\s` | Matches a whitespace character Same as `[\n\r\t\f\v ]` | `\S` |'
  prefs: []
  type: TYPE_TB
- en: '| `\p{*category*}` | Matches a character in a specified *category* (see [Table 25-4](#character_categories))
    | `\P` |'
  prefs: []
  type: TYPE_TB
- en: '| `.` | (Default mode) Matches any character except `\n` | `\n` |'
  prefs: []
  type: TYPE_TB
- en: '| `.` | (`SingleLine` mode) Matches any character | `\n` |'
  prefs: []
  type: TYPE_TB
- en: Table 25-4\. Character categories
  prefs: []
  type: TYPE_NORMAL
- en: '| Quantifier | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `\p{L}` | Letters |'
  prefs: []
  type: TYPE_TB
- en: '| `\p{Lu}` | Uppercase letters |'
  prefs: []
  type: TYPE_TB
- en: '| `\p{Ll}` | Lowercase letters |'
  prefs: []
  type: TYPE_TB
- en: '| `\p{N}` | Numbers |'
  prefs: []
  type: TYPE_TB
- en: '| `\p{P}` | Punctuation |'
  prefs: []
  type: TYPE_TB
- en: '| `\p{M}` | Diacritic marks |'
  prefs: []
  type: TYPE_TB
- en: '| `\p{S}` | Symbols |'
  prefs: []
  type: TYPE_TB
- en: '| `\p{Z}` | Separators |'
  prefs: []
  type: TYPE_TB
- en: '| `\p{C}` | Control characters |'
  prefs: []
  type: TYPE_TB
- en: Table 25-5\. Quantifiers
  prefs: []
  type: TYPE_NORMAL
- en: '| Quantifier | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | Zero or more matches |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | One or more matches |'
  prefs: []
  type: TYPE_TB
- en: '| `?` | Zero or one match |'
  prefs: []
  type: TYPE_TB
- en: '| `{*n*}` | Exactly `*n*` matches |'
  prefs: []
  type: TYPE_TB
- en: '| `{*n*,}` | At least `*n*` matches |'
  prefs: []
  type: TYPE_TB
- en: '| `{*n,m*}` | Between `*n*` and `*m*` matches |'
  prefs: []
  type: TYPE_TB
- en: The `?` suffix can be applied to any of the quantifiers to make them *lazy*
    rather than *greedy*.
  prefs: []
  type: TYPE_NORMAL
- en: Table 25-6\. Substitutions
  prefs: []
  type: TYPE_NORMAL
- en: '| Expression | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `$0` | Substitutes the matched text |'
  prefs: []
  type: TYPE_TB
- en: '| `$*group-number*` | Substitutes an indexed `*group-number*` within the matched
    text |'
  prefs: []
  type: TYPE_TB
- en: '| `${*group-name*}` | Substitutes a text `*group-name*` within the matched
    text |'
  prefs: []
  type: TYPE_TB
- en: Substitutions are specified only within a replacement pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Table 25-7\. Zero-width assertions
  prefs: []
  type: TYPE_NORMAL
- en: '| Expression | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | Start of string (or line in *multiline* mode) |'
  prefs: []
  type: TYPE_TB
- en: '| `$` | End of string (or line in *multiline* mode) |'
  prefs: []
  type: TYPE_TB
- en: '| `\A` | Start of string (ignores *multiline* mode) |'
  prefs: []
  type: TYPE_TB
- en: '| `\z` | End of string (ignores *multiline* mode) |'
  prefs: []
  type: TYPE_TB
- en: '| `\Z` | End of line or string |'
  prefs: []
  type: TYPE_TB
- en: '| `\G` | Where search started |'
  prefs: []
  type: TYPE_TB
- en: '| `\b` | On a word boundary |'
  prefs: []
  type: TYPE_TB
- en: '| `\B` | Not on a word boundary |'
  prefs: []
  type: TYPE_TB
- en: '| `(?=*expr*)` | Continue matching only if expression `*expr*` matches on right
    (*positive lookahead*) |'
  prefs: []
  type: TYPE_TB
- en: '| `(?!*expr*)` | Continue matching only if expression `*expr*` doesn’t match
    on right (*negative lookahead*) |'
  prefs: []
  type: TYPE_TB
- en: '| `(?<=*expr*)` | Continue matching only if expression `*expr*` matches on
    left (*positive lookbehind*) |'
  prefs: []
  type: TYPE_TB
- en: '| `(?<!*expr*)` | Continue matching only if expression `*expr*` doesn’t match
    on left (*negative lookbehind*) |'
  prefs: []
  type: TYPE_TB
- en: '| `(?>*expr*)` | Subexpression `*expr*` is matched once and not backtracked
    |'
  prefs: []
  type: TYPE_TB
- en: Table 25-8\. Grouping constructs
  prefs: []
  type: TYPE_NORMAL
- en: '| Syntax | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `(*expr*)` | Capture matched expression `*expr*` into indexed group |'
  prefs: []
  type: TYPE_TB
- en: '| `(?*number*)` | Capture matched substring into a specified group `*number*`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `(?''*name*'')` | Capture matched substring into group `*name*` |'
  prefs: []
  type: TYPE_TB
- en: '| `(?''*name1-name2*'')` | Undefine `*name2*` and store interval and current
    group into `*name1*`; if `*name2*` is undefined, matching backtracks |'
  prefs: []
  type: TYPE_TB
- en: '| `(?:*expr*)` | Noncapturing group |'
  prefs: []
  type: TYPE_TB
- en: Table 25-9\. Back references
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter syntax | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `\*index*` | Reference a previously captured group by `*index*` |'
  prefs: []
  type: TYPE_TB
- en: '| `\k<*name*>` | Reference a previously captured group by `*name*` |'
  prefs: []
  type: TYPE_TB
- en: Table 25-10\. Alternation
  prefs: []
  type: TYPE_NORMAL
- en: '| Expression syntax | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;` | Logical *or* |'
  prefs: []
  type: TYPE_TB
- en: '| `(?(*expr*)*yes*&#124;*no*)` | Matches `*yes*` if expression matches; otherwise,
    matches `*no*` (`*no*` is optional) |'
  prefs: []
  type: TYPE_TB
- en: '| `(?(*name*)*yes*&#124;*no*)` | Matches `*yes*` if named group has a match;
    otherwise, matches `*no*` (`*no*` is optional) |'
  prefs: []
  type: TYPE_TB
- en: Table 25-11\. Miscellaneous constructs
  prefs: []
  type: TYPE_NORMAL
- en: '| Expression syntax | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `(?#*comment*)` | Inline comment |'
  prefs: []
  type: TYPE_TB
- en: '| `#*comment*` | Comment to end of line (works only in `IgnorePatternWhitespace`
    mode) |'
  prefs: []
  type: TYPE_TB
- en: Table 25-12\. Regular expression options
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `(?i)` | Case-insensitive match (“ignore” case) |'
  prefs: []
  type: TYPE_TB
- en: '| `(?m)` | Multiline mode; changes `^` and `$` so that they match beginning
    and end of any line |'
  prefs: []
  type: TYPE_TB
- en: '| `(?n)` | Captures only explicitly named or numbered groups |'
  prefs: []
  type: TYPE_TB
- en: '| `(?c)` | Compiles to Intermediate Language |'
  prefs: []
  type: TYPE_TB
- en: '| `(?s)` | Single-line mode; changes meaning of “.” so that it matches every
    character |'
  prefs: []
  type: TYPE_TB
- en: '| `(?x)` | Eliminates unescaped whitespace from the pattern |'
  prefs: []
  type: TYPE_TB
- en: '| `(?r)` | Searches from right to left; can’t be specified midstream |'
  prefs: []
  type: TYPE_TB
