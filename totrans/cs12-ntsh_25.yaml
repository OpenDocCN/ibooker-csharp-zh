- en: Chapter 25\. Regular Expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第25章 正则表达式
- en: The regular expressions language identifies character patterns. The .NET types
    supporting regular expressions are based on Perl 5 regular expressions and support
    both search and search/replace functionality.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式语言识别字符模式。支持正则表达式的.NET类型基于Perl 5正则表达式，支持搜索和搜索/替换功能。
- en: 'Regular expressions are used for tasks such as:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式用于诸如以下任务：
- en: Validating text input such as passwords and phone numbers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证文本输入，如密码和电话号码。
- en: Parsing textual data into more structured forms (e.g., a NuGet version string)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文本数据解析为更结构化的形式（例如，NuGet版本字符串）
- en: Replacing patterns of text in a document (e.g., whole words only)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换文档中的文本模式（例如，仅整个单词）
- en: This chapter is split into both conceptual sections teaching the basics of regular
    expressions in .NET, and reference sections describing the regular expressions
    language.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为概念部分和参考部分，分别介绍.NET中正则表达式的基础知识和正则表达式语言。
- en: All regular expression types are defined in `System.Text.RegularExpressions`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 所有正则表达式类型都定义在`System.Text.RegularExpressions`中。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The samples in this chapter are all preloaded into LINQPad, which also includes
    an interactive RegEx tool (press Ctrl+Shift+F1). An online tool is available at
    [*http://regexstorm.net/tester*](http://regexstorm.net/tester).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例都预装在LINQPad中，该工具还包括一个交互式的RegEx工具（按Ctrl+Shift+F1）。在线工具可访问[*http://regexstorm.net/tester*](http://regexstorm.net/tester)。
- en: Regular Expression Basics
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式基础知识
- en: 'One of the most common regular expression operators is a *quantifier*. `?`
    is a quantifier that matches the preceding item 0 or 1 time. In other words, `?`
    means *optional*. An item is either a single character or a complex structure
    of characters in square brackets. For example, the regular expression `"colou?r"`
    matches `color` and `colour`, but not `colouur`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的正则表达式运算符之一是*量词*。`?`是一个量词，匹配前面的项目0或1次。换句话说，`?`表示*可选*。项目可以是单个字符或方括号中复杂的字符结构。例如，正则表达式`"colou?r"`匹配`color`和`colour`，但不匹配`colouur`：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`Regex.Match` searches within a larger string. The object that it returns has
    properties for the `Index` and `Length` of the match as well as the actual `Value`
    matched:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`Regex.Match`在较大字符串内搜索。返回的对象具有匹配的`Index`和`Length`属性以及实际匹配的`Value`：'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can think of `Regex.Match` as a more powerful version of the `string`’s
    `IndexOf` method. The difference is that it searches for a *pattern* rather than
    a literal string.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`Regex.Match`视为`string`的`IndexOf`方法的更强大版本。不同之处在于它搜索*模式*而不是字面字符串。
- en: The `IsMatch` method is a shortcut for calling `Match` and then testing the
    `Success` property.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsMatch`方法是调用`Match`并测试`Success`属性的快捷方式。'
- en: 'The regular expressions engine works from left to right by default, so only
    the leftmost match is returned. You can use the `NextMatch` method to return more
    matches:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，正则表达式引擎从左到右工作，因此仅返回最左边的匹配项。您可以使用`NextMatch`方法返回更多匹配项：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `Matches` method returns all matches in an array. We can rewrite the preceding
    example, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Matches`方法返回数组中的所有匹配项。我们可以按照前面的示例重写如下：'
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Another common regular expressions operator is the *alternator*, expressed
    with a vertical bar, `|`. An alternator expresses alternatives. The following
    matches “Jen”, “Jenny”, and “Jennifer”:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的正则表达式运算符是*交替符*，用竖线`|`表示。交替符表示备选项。以下匹配“Jen”，“Jenny”和“Jennifer”：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The brackets around an alternator separate the alternatives from the rest of
    the expression.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 交替符周围的括号将备选项与表达式的其余部分分开。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can specify a timeout when matching regular expressions. If a match operation
    takes longer than the specified `TimeSpan`, a `RegexMatchTimeoutException` is
    thrown. This can be useful if your program processes user-supplied regular expressions
    because it prevents malformed regular expressions from infinitely spinning.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当匹配正则表达式时，你可以指定超时时间。如果匹配操作超过指定的`TimeSpan`，将抛出`RegexMatchTimeoutException`异常。如果你的程序处理用户提供的正则表达式，这非常有用，因为它可以防止格式错误的正则表达式无限循环。
- en: Compiled Regular Expressions
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译正则表达式
- en: 'In some of the preceding examples, we called a static `RegEx` method repeatedly
    with the same pattern. An alternative approach in these cases is to instantiate
    a `Regex` object with the pattern and `RegexOptions.Compiled` and then call instance
    methods:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的一些示例中，我们反复调用了静态的`Regex`方法，使用相同的模式。在这些情况下的另一种方法是使用模式和`RegexOptions.Compiled`实例化一个`Regex`对象，然后调用实例方法：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`RegexOptions.Compiled` instructs the `RegEx` instance to use lightweight code
    generation (`DynamicMethod` in `Reflection.Emit`) to dynamically build and compile
    code tailored to that particular regular expression. This results in faster matching,
    at the expense of an initial compilation cost.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegexOptions.Compiled` 指示 `RegEx` 实例使用轻量级代码生成（`Reflection.Emit` 中的 `DynamicMethod`）动态构建和编译特定于该正则表达式的代码。这样做可以实现更快的匹配速度，但需要付出初始编译成本。'
- en: You can also instantiate a `Regex` object without using `RegexOptions.Compiled`.
    A `Regex` instance is immutable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以实例化 `Regex` 对象而不使用 `RegexOptions.Compiled`。`Regex` 实例是不可变的。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The regular expressions engine is fast. Even without compilation, a simple match
    typically takes less than a microsecond.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式引擎非常快速。即使不进行编译，简单匹配通常少于一微秒。
- en: RegexOptions
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RegexOptions
- en: 'The `RegexOptions` flags enum lets you tweak matching behavior. A common use
    for `RegexOptions` is to perform a case-insensitive search:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegexOptions` 标志枚举允许您调整匹配行为。`RegexOptions` 的常见用法是执行不区分大小写的搜索：'
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This applies the current culture’s rules for case equivalence. The `CultureInvariant`
    flag lets you request the invariant culture instead:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于当前文化规则的大小写等价性。`CultureInvariant` 标志允许您请求不变的文化：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can activate most of the `RegexOptions` flags within a regular expression
    itself, using a single-letter code, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在正则表达式中通过单字母代码激活大多数 `RegexOptions` 标志，如下所示：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can turn options on and off throughout an expression:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在表达式中随时打开和关闭选项：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Another useful option is `IgnorePatternWhitespace` or `(?x)`. This allows you
    to insert whitespace to make a regular expression more readable—without the whitespace
    being taken literally.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的选项是 `IgnorePatternWhitespace` 或 `(?x)`。这允许您插入空格以使正则表达式更易读，而不会将空格视为字面字符。
- en: The `NonBacktracking` option (from .NET 7) instructs the regex engine to use
    a forwards-only matching algorithm. This usually results in slower performance
    and disables some advanced features such as lookahead or lookbehind. However,
    it also prevents malformed or maliciously constructed expressions from taking
    near-infinite time, mitigating a potential denial-of-service attack when processing
    user-supplied regular expressions (a *ReDOS* attack). Specifying a timeout is
    also useful in this scenario.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`NonBacktracking` 选项（从 .NET 7 开始）指示正则表达式引擎使用前向匹配算法。这通常导致性能较慢，并禁用某些高级特性，如前瞻或后顾。但是，它还可以防止形式不正确或恶意构造的表达式花费近乎无限的时间，从而减轻处理用户提供的正则表达式时可能发生的拒绝服务攻击（*ReDOS*
    攻击）。在这种情况下，指定超时也很有用。'
- en: '[Table 25-1](#regular_expression_options-id00102) lists all `RegExOptions`
    values along with their single-letter codes.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 25-1](#regular_expression_options-id00102) 列出所有 `RegExOptions` 值及其单字母代码。'
- en: Table 25-1\. Regular expression options
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 25-1\. 正则表达式选项
- en: '| Enum value | Regular expressions code | Description |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 枚举值 | 正则表达式代码 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `None` |   |   |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `None` |   |   |'
- en: '| `IgnoreCase` | `i` | Ignores case (by default, regular expressions are case
    sensitive) |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `IgnoreCase` | `i` | 忽略大小写（默认情况下，正则表达式区分大小写） |'
- en: '| `Multiline` | `m` | Changes `^` and `$` so that they match the start/end
    of a line instead of start/end of the string |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `Multiline` | `m` | 更改 `^` 和 `$`，使其匹配行的开头/结尾而不是字符串的开头/结尾 |'
- en: '| `ExplicitCapture` | `n` | Captures only explicitly named or explicitly numbered
    groups (see [“Groups”](#groups)) |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `ExplicitCapture` | `n` | 仅捕获显式命名或显式编号的组（见 [“Groups”](#groups)） |'
- en: '| `Compiled` |   | Forces compilation to IL (see [“Compiled Regular Expressions”](#compiled_regular_expressions))
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `Compiled` |   | 强制编译为 IL（见 [“Compiled Regular Expressions”](#compiled_regular_expressions)）
    |'
- en: '| `Singleline` | `s` | Makes `.` match every character (instead of matching
    every character except `\n`) |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `Singleline` | `s` | 使 `.` 匹配每个字符（而不是匹配除 `\n` 外的每个字符） |'
- en: '| `IgnorePatternWhitespace` | `x` | Eliminates unescaped whitespace from the
    pattern |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `IgnorePatternWhitespace` | `x` | 从模式中消除未转义的空格 |'
- en: '| `RightToLeft` | `r` | Searches from right to left; can’t be specified midstream
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `RightToLeft` | `r` | 从右向左搜索；不能在中间指定 |'
- en: '| `ECMAScript` |   | Forces ECMA compliance (by default, the implementation
    is not ECMA compliant) |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `ECMAScript` |   | 强制执行 ECMAScript 兼容性（默认情况下，实现不符合 ECMAScript） |'
- en: '| `CultureInvariant` |   | Turns off culture-specific behavior for string comparisons
    |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `CultureInvariant` |   | 关闭字符串比较的特定于文化的行为 |'
- en: '| `NonBacktracking` |   | Disables backtracking to ensure predictable (albeit
    slower) performance |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `NonBacktracking` |   | 禁用回溯以确保可预测（尽管较慢）的性能 |'
- en: Character Escapes
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符转义
- en: 'Regular expressions have the following metacharacters, which have a special
    rather than literal meaning:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式具有以下元字符，它们具有特殊的而不是字面意义：
- en: \ * + ? | { [ () ^ $ . #
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '\ * + ? | { [ () ^ $ . # '
- en: 'To use a metacharacter literally, you must prefix, or *escape*, the character
    with a backslash. In the following example, we escape the `?` character to match
    the string `"what?"`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要字面使用元字符，必须使用反斜杠进行前缀，即*转义*字符。在下面的例子中，我们转义 `?` 字符来匹配字符串 `"what?"`：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If the character is inside a *set* (square brackets), this rule does not apply,
    and the metacharacters are interpreted literally. We discuss sets in the following
    section.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符位于*集合*（方括号）内，则此规则不适用，并且元字符被逐字解释。我们在下一节讨论集合。
- en: 'The `Regex`’s `Escape` and `Unescape` methods convert a string containing regular
    expression metacharacters by replacing them with escaped equivalents, and vice
    versa:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Regex` 的 `Escape` 和 `Unescape` 方法通过将包含正则表达式元字符的字符串替换为转义等效项（反之亦然）来转换字符串：'
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'All the regular expression strings in this chapter are expressed with the C#
    `@` literal. This is to bypass C#’s escape mechanism, which also uses the backslash.
    Without the `@`, a literal backslash would require four backslashes:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有的正则表达式字符串都用 C# 的 `@` 文字表达。这是为了绕过 C# 的转义机制，该机制也使用反斜杠。没有 `@`，字面上的反斜杠将需要四个反斜杠：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Unless you include the `(?x)` option, spaces are treated literally in regular
    expressions:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 除非包括 `(?x)` 选项，否则空格在正则表达式中被视为字面量：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Character Sets
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符集
- en: Character sets act as wildcards for a particular set of characters.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 字符集充当特定字符集的通配符。
- en: '| Expression | Meaning | Inverse (“not”) |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 表达式 | 含义 | 反义（“非”） |'
- en: '| --- | --- | --- |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `[abcdef]` | Matches a single character in the list. | `[^abcdef]` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `[abcdef]` | 匹配列表中的单个字符。 | `[^abcdef]` |'
- en: '| `[a-f]` | Matches a single character in a *range.* | `[^a-f]` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `[a-f]` | 匹配范围内的单个字符。 | `[^a-f]` |'
- en: '| `\d` | Matches anything in the Unicode *digits* category. In ECMAScript mode,
    `[0-9]`. | `\D` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `\d` | 匹配 Unicode *数字* 类别中的任何内容。在 ECMAScript 模式下，`[0-9]`。 | `\D` |'
- en: '| `\w` | Matches a *word* character (by default, varies according to `CultureInfo.CurrentCulture`;
    for example, in English, same as `[a-zA-Z_0-9]`). | `\W` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `\w` | 匹配一个*单词*字符（默认情况下，根据 `CultureInfo.CurrentCulture` 变化；例如，在英语中，与 `[a-zA-Z_0-9]`
    相同）。 | `\W` |'
- en: '| `\s` | Matches a whitespace character; that is, anything for which `char.IsWhiteSpace`
    returns true (including Unicode spaces). In ECMAScript mode, `[\n\r\t\f\v ]`.
    | `\S` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `\s` | 匹配空白字符；即，`char.IsWhiteSpace` 返回 true 的任何内容（包括 Unicode 空格）。在 ECMAScript
    模式下，`[\n\r\t\f\v ]`。 | `\S` |'
- en: '| `\p{`*category*`}` | Matches a character in a specified *category*. | `\P`
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `\p{`*category*`}` | 匹配指定*类别*中的字符。 | `\P` |'
- en: '| `.` | (Default mode) Matches any character except `\n`. | `\n` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `.` | （默认模式）匹配除 `\n` 之外的任何字符。 | `\n` |'
- en: '| `.` | (`SingleLine` mode) Matches any character. | `\n` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `.` | （`SingleLine` 模式）匹配任何字符。 | `\n` |'
- en: 'To match exactly one of a set of characters, put the character set in square
    brackets:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要匹配一组字符中的一个，请将字符集放在方括号内：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To match any character *except* those in a set, put the set in square brackets
    with a `^` symbol before the first character:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要匹配除了集合中字符以外的任何字符，请在方括号中使用 `^` 符号放置集合：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can specify a range of characters by using a hyphen. The following regular
    expression matches a chess move:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用连字符指定一系列字符。以下正则表达式匹配象棋走法：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`\d` indicates a digit character, so `\d` will match any digit. `\D` matches
    any nondigit character.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`\d` 表示数字字符，因此 `\d` 将匹配任何数字。 `\D` 匹配任何非数字字符。'
- en: '`\w` indicates a word character, which includes letters, numbers, and the underscore.
    `\W` matches any nonword character. These work as expected for non-English letters,
    too, such as Cyrillic.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`\w` 表示一个单词字符，包括字母、数字和下划线。`\W` 匹配任何非单词字符。对于非英语字母，如西里尔字母，这些也能正常工作。'
- en: '`.` matches any character except `\n` (but allows `\r`).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`.` 匹配除了 `\n` 之外的任何字符（但允许 `\r`）。'
- en: '`\p` matches a character in a specified category, such as `{Lu}` for uppercase
    letter or `{P}` for punctuation (we list the categories in the reference section
    later in the chapter):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`\p` 匹配指定类别中的字符，例如 `{Lu}` 表示大写字母或 `{P}` 表示标点符号（我们稍后在参考部分列出类别）：'
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We will find more uses for `\d`, `\w`, and `.` when we combine them with *quantifiers*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将它们与*量词*结合使用时，我们将发现更多关于 `\d`、`\w` 和 `.` 的用法。
- en: Quantifiers
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 量词
- en: Quantifiers match an item a specified number of times.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 量词匹配指定次数的项。
- en: '| Quantifier | Meaning |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 量词 | 含义 |'
- en: '| --- | --- |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `*` | Zero or more matches |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 零个或多个匹配 |'
- en: '| `+` | One or more matches |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 一次或多次匹配 |'
- en: '| `?` | Zero or one match |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `?` | 零或一个匹配 |'
- en: '| `{*n*}` | Exactly `*n*` matches |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `{*n*}` | 正好 `*n*` 次匹配 |'
- en: '| `{*n*,}` | At least `*n*` matches |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `{*n*,}` | 至少 `*n*` 次匹配 |'
- en: '| `{*n*,*m*}` | Between `*n*` and `*m*` matches |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `{*n*,*m*}` | 匹配 `*n*` 到 `*m*` 次 |'
- en: 'The `*` quantifier matches the preceding character or group zero or more times.
    The following matches *cv.docx*, along with any numbered versions of the same
    file (e.g., *cv2.docx*, *cv15.docx*):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`*` 量词匹配前面的字符或组零次或更多次。下面的示例匹配 *cv.docx*，以及同一文件的任何编号版本（例如 *cv2.docx*，*cv15.docx*）：'
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice that we must escape the period in the file extension using a backslash.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须使用反斜杠转义文件扩展名中的句点。
- en: 'The following allows anything between *cv* and *.docx* and is equivalent to
    `dir cv*.docx`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下面允许在 *cv* 和 *.docx* 之间的任何内容，并且等效于 `dir cv*.docx`：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `+` quantifier matches the preceding character or group one or more times.
    For example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`+` 量词匹配前面的字符或组一次或更多次。例如：'
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `{}` quantifier matches a specified number (or range) of repetitions. The
    following matches a blood pressure reading:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`{}` 量词匹配指定数量（或范围）的重复。以下匹配一个血压读数：'
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Greedy Versus Lazy Quantifiers
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 贪婪量词与懒惰量词的比较
- en: 'By default, quantifiers are *greedy*, as opposed to *lazy*. A greedy quantifier
    repeats as *many* times as it can before advancing. A lazy quantifier repeats
    as *few* times as it can before advancing. You can make any quantifier lazy by
    suffixing it with the `?` symbol. To illustrate the difference, consider the following
    HTML fragment:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，量词是 *贪婪* 的，与 *懒惰* 相对。贪婪量词重复尽可能多次，然后再继续。懒惰量词重复尽可能少次，然后再继续。通过在其后缀加上 `?`
    符号，你可以使任何量词变成懒惰的。为了说明差异，请考虑以下 HTML 片段：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Suppose that we want to extract the two phrases in italics. If we execute the
    following
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们要提取两个斜体短语。如果我们执行以下操作：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'the result is not two matches, but a *single* match:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 结果不是两个匹配，而是*单个*匹配：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The problem is that our `*` quantifier greedily repeats as many times as it
    can before matching `</i>`. So, it passes right by the first `</i>`, stopping
    only at the final `</i>` (the *last point* at which the rest of the expression
    can still match).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于我们的 `*` 量词贪婪地重复尽可能多次，直到匹配 `</i>`。因此，它会跳过第一个 `</i>`，仅在最后一个 `</i>`（*表达式其余部分仍可匹配的最后点*）处停止。
- en: 'If we make the quantifier lazy, the `*` bails out at the *first* point at which
    the rest of the expression can match:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使量词懒惰，`*` 将在*表达式其余部分仍可匹配的第一个*点处退出：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here’s the result:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Zero-Width Assertions
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 零宽断言
- en: The regular expressions language lets you place conditions on what should occur
    *before* or *after* a match, through *lookbehind*, *lookahead*, *anchors*, and
    *word boundaries*. These are called *zero-width* assertions because they don’t
    increase the width (or length) of the match itself.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式语言允许您在匹配之前或之后对应该发生的条件进行设置，通过*回顾*、*预查*、*锚点*和*词边界*。这些称为*零宽*断言，因为它们不增加匹配本身的宽度（或长度）。
- en: Lookahead and Lookbehind
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预查和回顾
- en: 'The `(?=*expr*)` construct checks whether the text that follows matches `*expr*`,
    without including `expr` in the result. This is called *positive lookahead*. In
    the following example, we look for a number followed by the word “miles”:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`(?=*expr*)` 构造检查紧随的文本是否与 `*expr*` 匹配，但不包括 `expr` 在结果中。这被称为 *正向预查*。在下面的例子中，我们寻找一个数字后面跟着单词“miles”：'
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice that the word “miles” was not returned in the result, even though it
    was required to *satisfy* the match.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，单词“miles”未在结果中返回，尽管它是必须*满足*的匹配。
- en: 'After a successful *lookahead*, matching continues as though the sneak preview
    never took place. So, if we append `.*` to our expression like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功的 *预查* 之后，匹配继续进行，就好像预览从未发生过一样。因此，如果我们像这样追加 `.*` 到我们的表达式中：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: the result is `25 miles more`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是 `25 miles more`。
- en: 'Lookahead can be useful in enforcing rules for a strong password. Suppose that
    a password must be at least six characters and contain at least one digit. With
    a lookup, we could achieve this, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 预查可以在强密码规则强制执行中非常有用。假设密码必须至少包含六个字符并至少包含一个数字。通过预查，我们可以实现如下：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This first performs a *lookahead* to ensure that a digit occurs somewhere in
    the string. If satisfied, it returns to its position before the sneak preview
    began and matches six or more characters. (In [“Cookbook Regular Expressions”](#cookbook_regular_expressions),
    we include a more substantial password validation example.)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先执行*预查*以确保数字在字符串的某处出现。如果满足条件，则返回预览开始之前的位置，并匹配六个或更多字符。（在[“正则表达式手册”](#cookbook_regular_expressions)中，我们包括一个更实质的密码验证示例。）
- en: 'The opposite is the *negative lookahead* construct, `(?!*expr*)`. This requires
    that the match *not* be followed by `*expr*`. The following expression matches
    “good”—unless “however” or “but” appears later in the string:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 相反的是*负向预查*结构`(?!*expr*)`。这要求匹配*不*后跟`*expr*`。以下表达式匹配“good”—除非后续字符串中出现“however”或“but”：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `(?<=*expr*)` construct denotes *positive lookbehind* and requires that
    a match be *preceded* by a specified expression. The opposite construct, `(?<!*expr*)`,
    denotes *negative lookbehind* and requires that a match *not be preceded* by a
    specified expression. For example, the following matches “good”—unless “however”
    appears *earlier* in the string:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`(?<=*expr*)`结构表示*正向回顾*，要求匹配*之前*由指定表达式。相反的结构`(?<!*expr*)`表示*负向回顾*，要求匹配*不*之前有指定的表达式。例如，以下匹配“good”—除非前面字符串中出现“however”：'
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We could improve these examples by adding *word boundary assertions*, which
    we introduce shortly.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加*单词边界断言*来改进这些示例，稍后我们将介绍这一点。
- en: Anchors
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锚点
- en: 'The anchors `^` and `$` match a particular *position*. By default:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 锚点`^`和`$`匹配特定的*位置*。默认情况下：
- en: '`^`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`^`'
- en: Matches the *start* of the string
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配字符串的*开始*
- en: '`$`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`$`'
- en: Matches the *end* of the string
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配字符串的*结尾*
- en: Note
  id: totrans-150
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`^` has two context-dependent meanings: an *anchor* and a *character class
    negator*.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`^`有两个上下文相关的含义：*锚点*和*字符类否定器*。'
- en: '`$` has two context-dependent meanings: an *anchor* and a *replacement group
    denoter*.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`$`有两个上下文相关的含义：*锚点*和*替换组指示符*。'
- en: 'For example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When you specify `RegexOptions.Multiline` or include `(?m)` in the expression:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当您指定`RegexOptions.Multiline`或在表达式中包含`(?m)`时：
- en: '`^` matches the start of the string or *line* (directly after a `\n`).'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^`匹配字符串或*行*的开始（直接在`\n`之后）。'
- en: '`$` matches the end of the string or *line* (directly before a `\n`).'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$`匹配字符串或*行*的结尾（直接在`\n`之前）。'
- en: 'There’s a catch to using `$` in multiline mode: a new line in Windows is nearly
    always denoted with `\r\n` rather than just `\n`. This means that for `$` to be
    useful for Windows files, you must usually match the `\r`, as well, with a *positive
    lookahead*:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在多行模式下使用`$`有一个注意事项：Windows中的换行符几乎总是用`\r\n`表示，而不仅仅是`\n`。这意味着对于Windows文件，要使`$`有用，通常必须同时匹配`\r`，使用*正向预查*：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The *positive lookahead* ensures that `\r` doesn’t become part of the result.
    The following matches lines that end in `".txt"`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*正向预查*确保`\r`不成为结果的一部分。以下匹配以`".txt"`结尾的行：'
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following matches all empty lines in string `s`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配字符串`s`中所有空行：
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following matches all lines that are either empty or contain only whitespace:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下匹配所有空行或仅包含空白的行：
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-166
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Because an anchor matches a position rather than a character, specifying an
    anchor on its own matches an empty string:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因为锚点匹配的是位置而不是字符，所以在其自身上指定锚点会匹配一个空字符串：
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Word Boundaries
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单词边界
- en: 'The word boundary assertion `\b` matches where word characters (`\w`) adjoin
    either:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 单词边界断言`\b`匹配单词字符(`\w`)与以下之一相邻：
- en: Nonword characters (`\W`)
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非单词字符（`\W`）
- en: The beginning/end of the string (`^` and `$`)
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串的开始/结束（`^`和`$`）
- en: '`\b` is often used to match whole words:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`\b`通常用于匹配整个单词：'
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following statements highlight the effect of a word boundary:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语句突出显示单词边界的效果：
- en: '[PRE39]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The next query uses *positive lookahead* to return words followed by “(sic)”:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个查询使用*正向预查*来返回后面跟有“(sic)”的单词：
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Groups
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组
- en: 'Sometimes, it’s useful to separate a regular expression into a series of subexpressions,
    or *groups*. For instance, consider the following regular expression that represents
    a US phone number such as 206-465-1918:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有时将正则表达式分解为一系列子表达式或*组*是有用的。例如，考虑以下表示美国电话号码（如206-465-1918）的正则表达式：
- en: '[PRE41]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Suppose that we want to separate this into two groups: area code and local
    number. We can achieve this by using parentheses to *capture* each group:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想将其分成两组：区号和本地号码。我们可以通过使用括号来*捕获*每个组来实现此目的：
- en: '[PRE42]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We then retrieve the groups programmatically:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 程序化地检索组：
- en: '[PRE43]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The zeroth group represents the entire match. In other words, it has the same
    value as the match’s `Value`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 第零组表示整个匹配。换句话说，它的值与匹配的`Value`相同：
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Groups are part of the regular expressions language itself. This means that
    you can refer to a group within a regular expression. The `\n` syntax lets you
    index the group by group number `n` within the expression. For example, the expression
    `(\w)ee\1` matches `deed` and `peep`. In the following example, we find all words
    in a string starting and ending in the same letter:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 组是正则表达式语言的一部分。这意味着您可以在正则表达式内部引用一个组。`\n`语法允许您在表达式内通过组号`n`索引组。例如，表达式`(\w)ee\1`匹配`deed`和`peep`。在以下示例中，我们找到字符串中所有以相同字母开头和结尾的单词：
- en: '[PRE45]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The brackets around the `\w` instruct the regular expressions engine to store
    the submatch in a group (in this case, a single letter) so that it can be used
    later. We refer to that group later using `\1`, meaning the first group in the
    expression.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`\w`周围的括号指示正则表达式引擎将子匹配存储在一个组中（在本例中是单个字母），以便稍后使用。我们稍后使用`\1`引用该组，表示表达式中的第一个组。'
- en: Named Groups
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名组
- en: 'In a long or complex expression, it can be easier to work with groups by *name*
    rather than index. Here’s a rewrite of the previous example, using a group that
    we name `''letter''`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在长或复杂的表达式中，通过*名称*而不是索引来处理组可能更容易。以下是先前示例的重写，使用了我们命名为`'letter'`的组：
- en: '[PRE46]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here’s how to name a captured group:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何命名捕获组的：
- en: '[PRE47]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And here’s how to refer to a group:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何引用一个组：
- en: '[PRE48]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following example matches a simple (non-nested) XML/HTML element by looking
    for start and end nodes with a matching name:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例通过查找具有匹配名称的起始和结束节点来匹配简单（非嵌套）XML/HTML元素：
- en: '[PRE49]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Allowing for all possible variations in XML structure, such as nested elements,
    is more complex. The .NET regular expressions engine has a sophisticated extension
    called “matched balanced constructs” that can assist with nested tags—information
    on this is available on the internet and in [*Mastering Regular Expressions*](https://learning.oreilly.com/library/view/mastering-regular-expressions/0596528124/)
    (O’Reilly) by Jeffrey E. F. Friedl.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 允许XML结构的所有可能变化，如嵌套元素，这更加复杂。.NET正则表达式引擎具有称为“匹配平衡构造”的复杂扩展，可用于嵌套标签 - 有关此信息，请查看互联网和Jeffrey
    E. F. Friedl的[*Mastering Regular Expressions*](https://learning.oreilly.com/library/view/mastering-regular-expressions/0596528124/)（O’Reilly）。
- en: Replacing and Splitting Text
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换和拆分文本
- en: The `RegEx.Replace` method works like `string.Replace` except that it uses a
    regular expression.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegEx.Replace`方法的工作方式类似于`string.Replace`，但它使用正则表达式。'
- en: 'The following replaces “cat” with “dog”. Unlike with `string.Replace`, “catapult”
    won’t change into “dogapult”, because we match on word boundaries:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将“cat”替换为“dog”。与`string.Replace`不同，"catapult"不会变成"dogapult"，因为我们匹配了单词边界：
- en: '[PRE50]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The replacement string can reference the original match with the `$0` substitution
    construct. The following example wraps numbers within a string in angle brackets:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字符串可以使用`$0`替换构造引用原始匹配项。以下示例在字符串中的数字周围加上尖括号：
- en: '[PRE51]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You can access any captured groups with `$1`, `$2`, `$3`, and so on, or `${*name*}`
    for a named group. To illustrate how this can be useful, consider the regular
    expression in the previous section that matched a simple XML element. By rearranging
    the groups, we can form a replacement expression that moves the element’s content
    into an XML attribute:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`$1`，`$2`，`$3`等访问任何捕获的组，或`${*name*}`用于命名组。为了说明这可以有多有用，考虑前一节中匹配简单XML元素的正则表达式。通过重新排列这些组，我们可以形成一个替换表达式，将元素的内容移到XML属性中：
- en: '[PRE52]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here’s the result:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果：
- en: '[PRE53]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: MatchEvaluator Delegate
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MatchEvaluator委托
- en: '`Replace` has an overload that takes a `MatchEvaluator` delegate, which is
    invoked per match. This allows you to delegate the content of the replacement
    string to C# code when the regular expressions language isn’t expressive enough:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`Replace`有一个重载，接受一个`MatchEvaluator`委托，每次匹配时调用。当正则表达式语言表达能力不足时，这允许您将替换字符串的内容委托给C#代码：'
- en: '[PRE54]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In [“Cookbook Regular Expressions”](#cookbook_regular_expressions), we show
    how to use a `Match​Eva⁠luator` to escape Unicode characters appropriately for
    HTML.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“Cookbook Regular Expressions”](#cookbook_regular_expressions)中，我们展示如何使用`Match​Eva⁠luator`适当地转义Unicode字符以用于HTML。
- en: Splitting Text
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拆分文本
- en: 'The static `Regex.Split` method is a more powerful version of the `string.Split`
    method, with a regular expression denoting the separator pattern. In this example,
    we split a string, where any digit counts as a separator:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 静态 `Regex.Split` 方法是 `string.Split` 方法的更强大版本，其中正则表达式表示分隔符模式。在此示例中，我们将字符串分割，其中任何数字都作为分隔符：
- en: '[PRE55]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The result, here, doesn’t include the separators themselves. You can include
    the separators, however, by wrapping the expression in a *positive lookahead*.
    The following splits a camel-case string into separate words:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此结果不包括分隔符本身。但是，可以通过使用 *正向预查* 将表达式包裹起来来包含分隔符。以下内容将驼峰格式的字符串拆分为单独的单词：
- en: '[PRE56]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Cookbook Regular Expressions
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 食谱正则表达式
- en: Recipes
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配方
- en: Matching US Social Security number/phone number
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 匹配美国社会安全号码/电话号码
- en: '[PRE57]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Extracting “name = value” pairs (one per line)
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取“名称 = 值”对（每行一个）
- en: 'Note that this starts with the *multiline* directive `(?m)`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此处使用了 *多行* 指令 `(?m)`：
- en: '[PRE58]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Strong password validation
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强密码验证
- en: 'The following checks whether a password has at least six characters and whether
    it contains a digit, symbol, or punctuation mark:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的内容检查密码是否至少包含六个字符，并且是否包含数字、符号或标点符号：
- en: '[PRE59]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Lines of at least 80 characters
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 至少包含 80 个字符的行
- en: '[PRE60]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Parsing dates/times (N/N/N H:M:S AM/PM)
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析日期/时间（N/N/N H:M:S AM/PM）
- en: 'This expression handles a variety of numeric date formats—and works whether
    the year comes first or last. The `(?x)` directive improves readability by allowing
    whitespace; the `(?i)` switches off case sensitivity (for the optional AM/PM designator).
    You can then access each component of the match through the `Groups` collection:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 此表达式处理多种数字日期格式，并且无论年份先出现还是后出现都能正常工作。`(?x)` 指令通过允许空白符提高了可读性；`(?i)` 关闭了大小写敏感性（用于可选的
    AM/PM 指示符）。然后，可以通过 `Groups` 集合访问每个匹配的组件：
- en: '[PRE61]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: (Of course, this doesn’t verify that the date/time is correct.)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: （当然，这并不验证日期/时间是否正确。）
- en: Matching Roman numerals
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 匹配罗马数字
- en: '[PRE62]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Removing repeated words
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除重复的单词
- en: 'Here, we capture a named group called `dupe`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，我们捕获了一个名为 `dupe` 的命名组：
- en: '[PRE63]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Word count
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单词计数
- en: '[PRE64]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Matching a GUID
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 匹配 GUID
- en: '[PRE65]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Parsing an XML/HTML tag
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析 XML/HTML 标签
- en: 'Regex is useful for parsing HTML fragments—particularly when the document might
    be imperfectly formed:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式对解析 HTML 片段非常有用——特别是当文档可能不完整时：
- en: '[PRE66]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Splitting a camel-cased word
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拆分驼峰命名的单词
- en: 'This requires a *positive lookahead* to include the uppercase separators:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要使用 *正向预查* 来包括大写分隔符：
- en: '[PRE67]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Obtaining a legal filename
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获得合法文件名
- en: '[PRE68]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Escaping Unicode characters for HTML
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于 HTML 的转义 Unicode 字符
- en: '[PRE69]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Unescaping characters in an HTTP query string
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 HTTP 查询字符串中取消转义字符
- en: '[PRE70]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Parsing Google search terms from a web stats log
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 web 统计日志中解析 Google 搜索术语
- en: 'You should use this in conjunction with the previous example to unescape characters
    in the query string:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该与前面的示例结合使用来在查询字符串中取消转义字符：
- en: '[PRE71]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Regular Expressions Language Reference
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式语言参考
- en: Tables [25-2](#character_escapes) through [25-12](#regular_expression_option)
    summarize the regular expressions grammar and syntax supported in the .NET implementation.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 [25-2](#character_escapes) 至 [25-12](#regular_expression_option) 总结了在 .NET
    实现中支持的正则表达式语法和语法。
- en: Table 25-2\. Character escapes
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 表 25-2\. 字符转义
- en: '| Escape code sequence | Meaning | Hexadecimal equivalent |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| 转义代码序列 | 含义 | 十六进制等效 |'
- en: '| --- | --- | --- |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `\a` | Bell | `\u0007` |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `\a` | 响铃符 | `\u0007` |'
- en: '| `\b` | Backspace | `\u0008` |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `\b` | 退格符 | `\u0008` |'
- en: '| `\t` | Tab | `\u0009` |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `\t` | 制表符 | `\u0009` |'
- en: '| `\r` | Carriage return | `\u000A` |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `\r` | 回车符 | `\u000A` |'
- en: '| `\v` | Vertical tab | `\u000B` |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `\v` | 垂直制表符 | `\u000B` |'
- en: '| `\f` | Form feed | `\u000C` |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `\f` | 换页符 | `\u000C` |'
- en: '| `\n` | Newline | `\u000D` |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `\n` | 换行符 | `\u000D` |'
- en: '| `\e` | Escape | `\u001B` |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `\e` | Escape | `\u001B` |'
- en: '| `\*nnn*` | ASCII character *nnn* as octal (e.g., `\n052`) |   |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `\*nnn*` | ASCII 字符 *nnn*（如 `\n052`） |   |'
- en: '| `\x*nn*` | ASCII character *nn* as hex (e.g., `\x3F`) |   |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `\x*nn*` | ASCII 字符 *nn*（如 `\x3F`） |   |'
- en: '| `\c*l*` | ASCII control character *l* (e.g., `\cG` for Ctrl-G) |   |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `\c*l*` | ASCII 控制字符 *l*（例如，`\cG` 表示 Ctrl-G） |   |'
- en: '| `\u*nnnn*` | Unicode character *nnnn* as hex (e.g., `\u07DE`) |   |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `\u*nnnn*` | Unicode 字符 *nnnn*（如 `\u07DE`） |   |'
- en: '| `\*symbol*` | A nonescaped symbol |   |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `\*symbol*` | 一个非转义的符号 |   |'
- en: 'Special case: within a regular expression, `\b` means word boundary, except
    in a `[ ]` set, in which `\b` means the backspace character.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊情况：在正则表达式中，`\b` 表示单词边界，但在 `[ ]` 集合中，`\b` 表示退格字符。
- en: Table 25-3\. Character sets
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 表 25-3\. 字符集
- en: '| Expression | Meaning | Inverse (“not”) |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 表达式 | 含义 | 反义（“非”） |'
- en: '| --- | --- | --- |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `[abcdef]` | Matches a single character in the list | `[^abcdef]` |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `[abcdef]` | 匹配列表中的单个字符 | `[^abcdef]` |'
- en: '| `[a-f]` | Matches a single character in a *range* | `[^a-f]` |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `[a-f]` | 匹配范围内的单个字符 | `[^a-f]` |'
- en: '| `\d` | Matches a decimal digit Same as `[0-9]` | `\D` |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `\d` | 匹配一个十进制数字，等同于 `[0-9]` | `\D` |'
- en: '| `\w` | Matches a *word* character (by default, varies according to `CultureInfo.CurrentCulture`;
    for example, in English, same as `[a-zA-Z_0-9]`) | `\W` |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| `\w` | 匹配一个*单词*字符（默认情况下，根据 `CultureInfo.CurrentCulture` 变化；例如，在英语中，与 `[a-zA-Z_0-9]`
    相同） | `\W` |'
- en: '| `\s` | Matches a whitespace character Same as `[\n\r\t\f\v ]` | `\S` |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| `\s` | 匹配空白字符，等同于 `[\n\r\t\f\v ]` | `\S` |'
- en: '| `\p{*category*}` | Matches a character in a specified *category* (see [Table 25-4](#character_categories))
    | `\P` |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| `\p{*category*}` | 匹配指定*category*中的字符（参见[表 25-4](#character_categories)）
    | `\P` |'
- en: '| `.` | (Default mode) Matches any character except `\n` | `\n` |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| `.` | （默认模式）匹配除 `\n` 外的任意字符 | `\n` |'
- en: '| `.` | (`SingleLine` mode) Matches any character | `\n` |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| `.` | （*单行*模式）匹配任意字符，不包括 `\n` | `\n` |'
- en: Table 25-4\. Character categories
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 表 25-4\. 字符类别
- en: '| Quantifier | Meaning |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| 量词 | 意义 |'
- en: '| --- | --- |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `\p{L}` | Letters |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `\p{L}` | 字母 |'
- en: '| `\p{Lu}` | Uppercase letters |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| `\p{Lu}` | 大写字母 |'
- en: '| `\p{Ll}` | Lowercase letters |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `\p{Ll}` | 小写字母 |'
- en: '| `\p{N}` | Numbers |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| `\p{N}` | 数字 |'
- en: '| `\p{P}` | Punctuation |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| `\p{P}` | 标点符号 |'
- en: '| `\p{M}` | Diacritic marks |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| `\p{M}` | 重音符号 |'
- en: '| `\p{S}` | Symbols |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| `\p{S}` | 符号 |'
- en: '| `\p{Z}` | Separators |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| `\p{Z}` | 分隔符 |'
- en: '| `\p{C}` | Control characters |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| `\p{C}` | 控制字符 |'
- en: Table 25-5\. Quantifiers
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 表 25-5\. 量词
- en: '| Quantifier | Meaning |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| 量词 | 意义 |'
- en: '| --- | --- |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `*` | Zero or more matches |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 零次或多次匹配 |'
- en: '| `+` | One or more matches |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 一次或多次匹配 |'
- en: '| `?` | Zero or one match |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| `?` | 零或一次匹配 |'
- en: '| `{*n*}` | Exactly `*n*` matches |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| `{*n*}` | 恰好 `*n*` 次匹配 |'
- en: '| `{*n*,}` | At least `*n*` matches |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| `{*n*,}` | 至少 `*n*` 次匹配 |'
- en: '| `{*n,m*}` | Between `*n*` and `*m*` matches |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| `{*n,m*}` | 匹配 `*n*` 到 `*m*` 次 |'
- en: The `?` suffix can be applied to any of the quantifiers to make them *lazy*
    rather than *greedy*.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将 `?` 后缀应用于任何量词，使其变为*懒惰*而不是*贪婪*。
- en: Table 25-6\. Substitutions
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 表 25-6\. 替换
- en: '| Expression | Meaning |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| 表达式 | 意义 |'
- en: '| --- | --- |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `$0` | Substitutes the matched text |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| `$0` | 替换匹配的文本 |'
- en: '| `$*group-number*` | Substitutes an indexed `*group-number*` within the matched
    text |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| `$*group-number*` | 在匹配的文本中替换索引为 `*group-number*` 的文本 |'
- en: '| `${*group-name*}` | Substitutes a text `*group-name*` within the matched
    text |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| `${*group-name*}` | 在匹配的文本中替换文本 `*group-name*` |'
- en: Substitutions are specified only within a replacement pattern.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 替换只在替换模式中指定。
- en: Table 25-7\. Zero-width assertions
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 表 25-7\. 零宽断言
- en: '| Expression | Meaning |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| 表达式 | 意义 |'
- en: '| --- | --- |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `^` | Start of string (or line in *multiline* mode) |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 字符串开头（或在*多行*模式下是行首） |'
- en: '| `$` | End of string (or line in *multiline* mode) |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| `$` | 字符串结尾（或在*多行*模式下是行尾） |'
- en: '| `\A` | Start of string (ignores *multiline* mode) |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| `\A` | 字符串开头（忽略*多行*模式） |'
- en: '| `\z` | End of string (ignores *multiline* mode) |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| `\z` | 字符串结尾（忽略*多行*模式） |'
- en: '| `\Z` | End of line or string |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| `\Z` | 行尾或字符串结尾 |'
- en: '| `\G` | Where search started |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| `\G` | 开始搜索的位置 |'
- en: '| `\b` | On a word boundary |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| `\b` | 在单词边界上 |'
- en: '| `\B` | Not on a word boundary |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| `\B` | 不在单词边界上 |'
- en: '| `(?=*expr*)` | Continue matching only if expression `*expr*` matches on right
    (*positive lookahead*) |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| `(?=*expr*)` | 只有右边的表达式 `*expr*` 匹配时继续匹配（*正向先行断言*） |'
- en: '| `(?!*expr*)` | Continue matching only if expression `*expr*` doesn’t match
    on right (*negative lookahead*) |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| `(?!*expr*)` | 只有右边的表达式 `*expr*` 不匹配时继续匹配（*负向先行断言*） |'
- en: '| `(?<=*expr*)` | Continue matching only if expression `*expr*` matches on
    left (*positive lookbehind*) |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| `(?<=*expr*)` | 只有左边的表达式 `*expr*` 匹配时继续匹配（*正向后行断言*） |'
- en: '| `(?<!*expr*)` | Continue matching only if expression `*expr*` doesn’t match
    on left (*negative lookbehind*) |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| `(?<!*expr*)` | 只有左边的表达式 `*expr*` 不匹配时继续匹配（*负向后行断言*） |'
- en: '| `(?>*expr*)` | Subexpression `*expr*` is matched once and not backtracked
    |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| `(?>*expr*)` | 子表达式 `*expr*` 仅匹配一次，不回溯 |'
- en: Table 25-8\. Grouping constructs
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 表 25-8\. 分组结构
- en: '| Syntax | Meaning |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| 语法 | 意义 |'
- en: '| --- | --- |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `(*expr*)` | Capture matched expression `*expr*` into indexed group |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| `(*expr*)` | 将匹配的表达式 `*expr*` 捕获到索引组中 |'
- en: '| `(?*number*)` | Capture matched substring into a specified group `*number*`
    |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| `(?*number*)` | 将匹配的子字符串捕获到指定的组 `*number*` |'
- en: '| `(?''*name*'')` | Capture matched substring into group `*name*` |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| `(?''*name*'')` | 将匹配的子字符串捕获到组 `*name*` 中 |'
- en: '| `(?''*name1-name2*'')` | Undefine `*name2*` and store interval and current
    group into `*name1*`; if `*name2*` is undefined, matching backtracks |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| `(?''*name1-name2*'')` | 取消定义`*name2*`并将区间和当前组存储到`*name1*`；如果`*name2*`未定义，则匹配回溯
    |'
- en: '| `(?:*expr*)` | Noncapturing group |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| `(?:*expr*)` | 非捕获组 |'
- en: Table 25-9\. Back references
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 表 25-9\. 后向引用
- en: '| Parameter syntax | Meaning |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| 参数语法 | 含义 |'
- en: '| --- | --- |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `\*index*` | Reference a previously captured group by `*index*` |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| `\*index*` | 根据`*index*`引用先前捕获的组 |'
- en: '| `\k<*name*>` | Reference a previously captured group by `*name*` |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| `\k<*name*>` | 根据`*name*`引用先前捕获的组 |'
- en: Table 25-10\. Alternation
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 表 25-10\. 选择
- en: '| Expression syntax | Meaning |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| 表达式语法 | 含义 |'
- en: '| --- | --- |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `&#124;` | Logical *or* |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | 逻辑*或* |'
- en: '| `(?(*expr*)*yes*&#124;*no*)` | Matches `*yes*` if expression matches; otherwise,
    matches `*no*` (`*no*` is optional) |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| `(?(*expr*)*yes*&#124;*no*)` | 如果表达式匹配，则匹配`*yes*`；否则，匹配`*no*`（`*no*`为可选项）
    |'
- en: '| `(?(*name*)*yes*&#124;*no*)` | Matches `*yes*` if named group has a match;
    otherwise, matches `*no*` (`*no*` is optional) |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| `(?(*name*)*yes*&#124;*no*)` | 如果命名组有匹配，则匹配`*yes*`；否则，匹配`*no*`（`*no*`为可选项）
    |'
- en: Table 25-11\. Miscellaneous constructs
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 表 25-11\. 杂项构造
- en: '| Expression syntax | Meaning |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| 表达式语法 | 含义 |'
- en: '| --- | --- |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `(?#*comment*)` | Inline comment |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| `(?#*comment*)` | 行内注释 |'
- en: '| `#*comment*` | Comment to end of line (works only in `IgnorePatternWhitespace`
    mode) |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| `#*comment*` | 行尾注释（仅在`IgnorePatternWhitespace`模式下有效） |'
- en: Table 25-12\. Regular expression options
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 表 25-12\. 正则表达式选项
- en: '| Option | Meaning |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 含义 |'
- en: '| --- | --- |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `(?i)` | Case-insensitive match (“ignore” case) |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| `(?i)` | 大小写不敏感匹配（忽略大小写） |'
- en: '| `(?m)` | Multiline mode; changes `^` and `$` so that they match beginning
    and end of any line |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| `(?m)` | 多行模式；改变`^`和`$`以匹配任何行的开头和结尾 |'
- en: '| `(?n)` | Captures only explicitly named or numbered groups |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| `(?n)` | 仅捕获显式命名或编号的组 |'
- en: '| `(?c)` | Compiles to Intermediate Language |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| `(?c)` | 编译为中间语言 |'
- en: '| `(?s)` | Single-line mode; changes meaning of “.” so that it matches every
    character |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| `(?s)` | 单行模式；改变“.”的含义以匹配每个字符 |'
- en: '| `(?x)` | Eliminates unescaped whitespace from the pattern |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| `(?x)` | 从模式中消除未转义的空白 |'
- en: '| `(?r)` | Searches from right to left; can’t be specified midstream |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| `(?r)` | 从右到左搜索；不能在中间指定 |'
