["```cs\nclass YourClassName\n{\n}\n```", "```cs\nclass Octopus\n{\n  string name;\n  public int Age = 10;\n}\n```", "```cs\npublic int Age = 10;\n```", "```cs\nstatic readonly string TempFolder = System.IO.Path.GetTempPath();\n```", "```cs\nstatic readonly int legs = 8,\n                    eyes = 2;\n```", "```cs\npublic class Test\n{\n  public const string Message = \"Hello World\";\n}\n```", "```cs\npublic static double Circumference (double radius)\n{\n  return 2 * System.Math.PI * radius;\n}\n```", "```cs\npublic static double Circumference (double radius)\n{\n  return 6.2831853071795862 * radius;\n}\n```", "```cs\nstatic readonly DateTime StartupTime = DateTime.Now;\n```", "```cs\npublic const decimal ProgramVersion = 2.3;\n```", "```cs\nvoid Test()\n{\n  const double twoPI = 2 * System.Math.PI;\n  ...\n}\n```", "```cs\nint Foo (int x) { return x * 2; }\n```", "```cs\nint Foo (int x) => x * 2;\n```", "```cs\nvoid Foo (int x) => Console.WriteLine (x);\n```", "```cs\nvoid WriteCubes()\n{\n  Console.WriteLine (Cube (3));\n  Console.WriteLine (Cube (4));\n  Console.WriteLine (Cube (5));\n\n  int Cube (int value) => value * value * value;\n}\n```", "```cs\nint x = 3;\nFoo();\n\nvoid Foo() => Console.WriteLine (x);\n```", "```cs\nvoid Foo (int x) {...}\nvoid Foo (double x) {...}\nvoid Foo (int x, float y) {...}\nvoid Foo (float x, int y) {...}\n```", "```cs\nvoid  Foo (int x) {...}\nfloat Foo (int x) {...}           // Compile-time error\n\nvoid  Goo (int[] x) {...}\nvoid  Goo (params int[] x) {...}  // Compile-time error\n```", "```cs\nvoid Foo (int x) {...}\nvoid Foo (ref int x) {...}     // OK so far\nvoid Foo (out int x) {...}     // Compile-time error\n```", "```cs\nPanda p = new Panda (\"Petey\");   // Call constructor\n\npublic class Panda\n{\n  string name;                   // Define field\n  public Panda (string n)        // Define constructor\n  {\n    name = n;                    // Initialization code (set up field)\n  }\n}\n```", "```cs\npublic Panda (string n) => name = n;\n```", "```cs\npublic Panda (string name) => this.name = name;\n```", "```cs\npublic class Wine\n{\n  public decimal Price;\n  public int Year;\n  public Wine (decimal price) => Price = price;\n  public Wine (decimal price, int year) : this (price) => Year = year;\n}\n```", "```cs\npublic Wine (decimal price, DateTime year) : this (price, year.Year) { }\n```", "```cs\npublic Wine (decimal price, int year = 0)\n{\n  Price = price; Year = year;\n}\n```", "```cs\nclass Player\n{\n  int shields = 50;   // Initialized first\n  int health = 100;   // Initialized second\n}\n```", "```cs\npublic class Class1\n{\n  Class1() {}                             // Private constructor\n  public static Class1 Create (...)\n  {\n    // Perform custom logic here to return an instance of Class1\n    ...\n  }\n}\n```", "```cs\nclass Rectangle\n{\n  public readonly float Width, Height;\n\n  public Rectangle (float width, float height)\n  {\n    Width = width;\n    Height = height;\n  }\n\n  public void Deconstruct (out float width, out float height)\n  {\n    width = Width;\n    height = Height;\n  }\n}\n```", "```cs\nvar rect = new Rectangle (3, 4);\n(float width, float height) = rect;          // Deconstruction\nConsole.WriteLine (width + \" \" + height);    // 3 4\n```", "```cs\nfloat width, height;\nrect.Deconstruct (out width, out height);\n```", "```cs\nrect.Deconstruct (out var width, out var height);\n```", "```cs\n(var width, var height) = rect;\n```", "```cs\nvar (width, height) = rect;\n```", "```cs\nvar (_, height) = rect;\n```", "```cs\nfloat width, height;\n(width, height) = rect;\n```", "```cs\npublic Rectangle (float width, float height) =>\n  (Width, Height) = (width, height);\n```", "```cs\ndouble x1 = 0;\n(x1, double y2) = rect;\n```", "```cs\npublic class Bunny\n{\n  public string Name;\n  public bool LikesCarrots, LikesHumans;\n\n  public Bunny () {}\n  public Bunny (string n) => Name = n;\n}\n```", "```cs\n// Note parameterless constructors can omit empty parentheses\nBunny b1 = new Bunny { Name=\"Bo\", LikesCarrots=true, LikesHumans=false };\nBunny b2 = new Bunny (\"Bo\")     { LikesCarrots=true, LikesHumans=false };\n```", "```cs\nBunny *temp1* = new Bunny();    // *temp1* is a compiler-generated name\n*temp1*.Name = \"Bo\";\n*temp1*.LikesCarrots = true;\n*temp1*.LikesHumans = false;\nBunny b1 = *temp1*;\n\nBunny *temp2* = new Bunny (\"Bo\");\n*temp2*.LikesCarrots = true;\n*temp2*.LikesHumans = false;\nBunny b2 = *temp2*;\n```", "```cs\npublic class Panda\n{\n  public Panda Mate;\n\n  public void Marry (Panda partner)\n  {\n    Mate = partner;\n    partner.Mate = this;\n  }\n}\n```", "```cs\npublic class Test\n{\n  string name;\n  public Test (string name) => this.name = name;\n}\n```", "```cs\nStock msft = new Stock();\nmsft.CurrentPrice = 30;\nmsft.CurrentPrice -= 3;\nConsole.WriteLine (msft.CurrentPrice);\n```", "```cs\npublic class Stock\n{\n  decimal currentPrice;           // The private \"backing\" field\n\n  public decimal CurrentPrice     // The public property\n  {\n    get { return currentPrice; }\n    set { currentPrice = value; }\n  }\n}\n```", "```cs\ndecimal currentPrice, sharesOwned;\n\npublic decimal Worth\n{\n  get { return currentPrice * sharesOwned; }\n}\n```", "```cs\npublic decimal Worth => currentPrice * sharesOwned;\n```", "```cs\npublic decimal Worth\n{\n  get => currentPrice * sharesOwned;\n  set => sharesOwned = value / currentPrice;\n}\n```", "```cs\npublic class Stock\n{\n  ...\n  public decimal CurrentPrice { get; set; }\n}\n```", "```cs\npublic decimal CurrentPrice { get; set; } = 123;\n```", "```cs\npublic int Maximum { get; } = 999;\n```", "```cs\npublic class Foo\n{\n  private decimal x;\n  public decimal X\n  {\n    get         { return x;  }\n    private set { x = Math.Round (value, 2); }\n  }\n}\n```", "```cs\npublic class Note\n{\n  public int Pitch    { get; init; } = 20;   // “Init-only” property\n  public int Duration { get; init; } = 100;  // “Init-only” property\n}\n```", "```cs\nvar note = new Note { Pitch = 50 };\n```", "```cs\nnote.Pitch = 200;  // Error – init-only setter!\n```", "```cs\npublic class Note\n{\n  public int Pitch    { get; }\n  public int Duration { get; }\n\n  public Note (int pitch = 20, int duration = 100)\n  {\n    Pitch = pitch; Duration = duration;\n  }\n}\n```", "```cs\npublic class Note\n{\n  readonly int _pitch;\n  public int Pitch { get => _pitch; init => _pitch = value; }\n  ...\n```", "```cs\npublic decimal get_CurrentPrice {...}\npublic void set_CurrentPrice (decimal value) {...}\n```", "```cs\nstring s = \"hello\";\nConsole.WriteLine (s[0]); // 'h'\nConsole.WriteLine (s[3]); // 'l'\n```", "```cs\nstring s = null;\nConsole.WriteLine (s?[0]);  // Writes nothing; no error.\n```", "```cs\nclass Sentence\n{\n  string[] words = \"The quick brown fox\".Split();\n\n  public string this [int wordNum]      // indexer\n  {\n    get { return words [wordNum];  }\n    set { words [wordNum] = value; }\n  }\n}\n```", "```cs\nSentence s = new Sentence();\nConsole.WriteLine (s[3]);       // fox\ns[3] = \"kangaroo\";\nConsole.WriteLine (s[3]);       // kangaroo\n```", "```cs\npublic string this [int arg1, string arg2]\n{\n  get { ... }  set { ... }\n}\n```", "```cs\npublic string this [int wordNum] => words [wordNum];\n```", "```cs\npublic string get_Item (int wordNum) {...}\npublic void set_Item (int wordNum, string value) {...}\n```", "```cs\n  public string this [Index index] => words [index];\n  public string[] this [Range range] => words [range];\n```", "```cs\nSentence s = new Sentence();\nConsole.WriteLine (s [^1]);         // fox  \nstring[] firstTwoWords = s [..2];   // (The, quick)\n```", "```cs\nclass Person (string firstName, string lastName)\n{\n  public void Print() => Console.WriteLine (firstName + \" \" + lastName);\n}\n```", "```cs\nPerson p = new Person (\"Alice\", \"Jones\");\np.Print();    // Alice Jones\n```", "```cs\nclass Person    // (without primary constructors)\n{\n  string firstName, lastName;       // Field declarations\n\n  public Person (string firstName, string lastName)   // Constructor\n  {\n    this.firstName = firstName;     // Assign field\n    this.lastName = lastName;       // Assign field\n  }\n\n  public void Print() => Console.WriteLine (firstName + \" \" + lastName);\n}\n```", "```cs\nclass Person (string firstName, string lastName)\n{\n  public Person (string firstName, string lastName, int age)\n    : this (firstName, lastName)   // Must call the primary constructor\n  {\n    ...\n  }\n}\n```", "```cs\nclass Person\n{\n  public Person (string firstName, string lastName)\n  {\n *   ... do something with firstName, lastName*\n  }\n}\n```", "```cs\nclass Person (string firstName, string lastName)\n{\n  public readonly string FirstName = firstName;  // Field\n  public string LastName { get; } = lastName;    // Property\n}\n```", "```cs\nclass Person (string firstName, string lastName)\n{\n  readonly string firstName = firstName;\n  readonly string lastName = lastName;\n\n  public void Print() => Console.WriteLine (firstName + \" \" + lastName);\n}\n```", "```cs\nnew Person (\"Alice\", \"Jones\").Print();   // Alice Jones\n\nclass Person (string firstName, string lastName)\n{\n  public readonly string FullName = firstName + \" \" + lastName;\n  public void Print() => Console.WriteLine (FullName);\n}\n```", "```cs\nnew Person (\"Alice\", \"Jones\").Print();   // Alice JONES\n\nclass Person (string firstName, string lastName)\n{\n  readonly string lastName = lastName.ToUpper();\n  public void Print() => Console.WriteLine (firstName + \" \" + lastName);\n}\n```", "```cs\nnew Person (\"Alice\", null);   // throws ArgumentNullException\n\nclass Person (string firstName, string lastName)\n{\n  readonly string lastName = (lastName == null)\n     ? throw new ArgumentNullException (\"lastName\")\n     : lastName;\n}\n```", "```cs\nclass Person (string firstName, string lastName)\n{\n  public string LastName { get; set; } = lastName;\n}\n```", "```cs\nclass Test\n{\n  static Test() { Console.WriteLine (\"Type Initialized\"); }\n}\n```", "```cs\n[System.Runtime.CompilerServices.ModuleInitializer]\ninternal static void InitAssembly()\n{\n  ...\n}\n```", "```cs\nclass Foo\n{\n  public static int X = Y;    // 0\n  public static int Y = 3;    // 3\n}\n```", "```cs\nConsole.WriteLine (Foo.X);    // 3\n\nclass Foo\n{\n  public static Foo Instance = new Foo();\n  public static int X = 3;\n\n  Foo() => Console.WriteLine (X);    // 0\n}\n```", "```cs\nclass Class1\n{\n  ~Class1()\n  {\n    ...\n  }\n}\n```", "```cs\nprotected override void Finalize()\n{\n  ...\n  base.Finalize();\n}\n```", "```cs\n~Class1() => Console.WriteLine (\"Finalizing\");\n```", "```cs\n// PaymentFormGen.cs - auto-generated\npartial class PaymentForm { ... }\n\n// PaymentForm.cs - hand-authored\npartial class PaymentForm { ... }\n```", "```cs\npartial class PaymentForm {}\nclass PaymentForm {}\n```", "```cs\npartial class PaymentForm    // In auto-generated file\n{\n  ...\n  partial void ValidatePayment (decimal amount);\n}\n\npartial class PaymentForm    // In hand-authored file\n{\n  ...\n  partial void ValidatePayment (decimal amount)\n  {\n    if (amount > 100)\n      ...\n  }\n}\n```", "```cs\npublic partial class Test\n{\n  public partial void M1();    // Extended partial method\n  private partial void M2();   // Extended partial method\n}\n```", "```cs\npublic partial class Test\n{\n  public partial bool IsValid (string identifier);\n  internal partial bool TryParse (string number, out int result);\n}\n```", "```cs\nint count = 123;\nstring name = nameof (count);       // name is \"count\"\n```", "```cs\nstring name = nameof (StringBuilder.Length);\n```", "```cs\nnameof (StringBuilder) + \".\" + nameof (StringBuilder.Length);\n```", "```cs\npublic class Asset\n{\n  public string Name;\n}\n```", "```cs\npublic class Stock : Asset   // inherits from Asset\n{\n  public long SharesOwned;\n}\n\npublic class House : Asset   // inherits from Asset\n{\n  public decimal Mortgage;\n}\n```", "```cs\nStock msft = new Stock { Name=\"MSFT\",\n                         SharesOwned=1000 };\n\nConsole.WriteLine (msft.Name);         // MSFT\nConsole.WriteLine (msft.SharesOwned);  // 1000\n\nHouse mansion = new House { Name=\"Mansion\",\n                            Mortgage=250000 };\n\nConsole.WriteLine (mansion.Name);      // Mansion\nConsole.WriteLine (mansion.Mortgage);  // 250000\n```", "```cs\npublic static void Display (Asset asset)\n{\n  System.Console.WriteLine (asset.Name);\n}\n```", "```cs\nStock msft    = new Stock ... ;\nHouse mansion = new House ... ;\n\nDisplay (msft);\nDisplay (mansion);\n```", "```cs\nDisplay (new Asset());     // Compile-time error\n\npublic static void Display (House house)         // Will not accept Asset\n{\n  System.Console.WriteLine (house.Mortgage);\n}\n```", "```cs\nStock msft = new Stock();\nAsset a = msft;              // Upcast\n```", "```cs\nConsole.WriteLine (a == msft);        // True\n```", "```cs\nConsole.WriteLine (a.Name);           // OK\nConsole.WriteLine (a.SharesOwned);    // Compile-time error\n```", "```cs\nStock msft = new Stock();\nAsset a = msft;                      // Upcast\nStock s = (Stock)a;                  // Downcast\nConsole.WriteLine (s.SharesOwned);   // <No error>\nConsole.WriteLine (s == a);          // True\nConsole.WriteLine (s == msft);       // True\n```", "```cs\nHouse h = new House();\nAsset a = h;               // Upcast always succeeds\nStock s = (Stock)a;        // Downcast fails: a is not a Stock\n```", "```cs\nAsset a = new Asset();\nStock s = a as Stock;       // s is null; no exception thrown\n```", "```cs\nif (s != null) Console.WriteLine (s.SharesOwned);\n```", "```cs\nlong shares = ((Stock)a).SharesOwned;    // Approach #1\nlong shares = (a as Stock).SharesOwned;  // Approach #2\n```", "```cs\nlong x = 3 as long;    // Compile-time error\n```", "```cs\nif (a is Stock)\n  Console.WriteLine (((Stock)a).SharesOwned);\n```", "```cs\nif (a is Stock s)\n  Console.WriteLine (s.SharesOwned);\n```", "```cs\nStock s;\nif (a is Stock)\n{\n  s = (Stock) a;\n  Console.WriteLine (s.SharesOwned);\n}\n```", "```cs\nif (a is Stock s && s.SharesOwned > 100000)\n  Console.WriteLine (\"Wealthy\");\n```", "```cs\nif (a is Stock s && s.SharesOwned > 100000)\n  Console.WriteLine (\"Wealthy\");\nelse\n  s = new Stock();   // s is in scope\n\nConsole.WriteLine (s.SharesOwned);  // Still in scope\n```", "```cs\npublic class Asset\n{\n  public string Name;\n  public virtual decimal Liability => 0;   // Expression-bodied property\n}\n```", "```cs\npublic class Stock : Asset\n{\n  public long SharesOwned;\n}\n\npublic class House : Asset\n{\n  public decimal Mortgage;\n  public override decimal Liability => Mortgage;\n}\n```", "```cs\nHouse mansion = new House { Name=\"McMansion\", Mortgage=250000 };\nAsset a = mansion;\nConsole.WriteLine (mansion.Liability);  // 250000\nConsole.WriteLine (a.Liability);        // 250000\n```", "```cs\npublic class Asset\n{\n  public string Name;\n  public virtual Asset Clone() => new Asset { Name = Name };\n}\n\npublic class House : Asset\n{\n  public decimal Mortgage;\n  public override House Clone() => new House\n                                   { Name = Name, Mortgage = Mortgage };\n}\n```", "```cs\npublic override Asset Clone() => new House { ... }\n```", "```cs\nHouse mansion1 = new House { Name=\"McMansion\", Mortgage=250000 };\nHouse mansion2 = (House) mansion1.Clone();\n```", "```cs\npublic abstract class Asset\n{\n  // Note empty implementation\n  public abstract decimal NetValue { get; }\n}\n\npublic class Stock : Asset\n{\n  public long SharesOwned;\n  public decimal CurrentPrice;\n\n  // Override like a virtual method.\n  public override decimal NetValue => CurrentPrice * SharesOwned;\n}\n```", "```cs\npublic class A      { public int Counter = 1; }\npublic class B : A  { public int Counter = 2; }\n```", "```cs\npublic class A     { public     int Counter = 1; }\npublic class B : A { public new int Counter = 2; }\n```", "```cs\npublic class BaseClass\n{\n  public virtual void Foo()  { Console.WriteLine (\"BaseClass.Foo\"); }\n}\n\npublic class Overrider : BaseClass\n{\n  public override void Foo() { Console.WriteLine (\"Overrider.Foo\"); }\n}\n\npublic class Hider : BaseClass\n{\n  public new void Foo()      { Console.WriteLine (\"Hider.Foo\"); }\n}\n```", "```cs\nOverrider over = new Overrider();\nBaseClass b1 = over;\nover.Foo();                         // Overrider.Foo\nb1.Foo();                           // Overrider.Foo\n\nHider h = new Hider();\nBaseClass b2 = h;\nh.Foo();                           // Hider.Foo\nb2.Foo();                          // BaseClass.Foo\n```", "```cs\npublic sealed override decimal Liability { get { return Mortgage; } }\n```", "```cs\npublic class House : Asset\n{\n  ...\n  public override decimal Liability => base.Liability + Mortgage;\n}\n```", "```cs\npublic class Baseclass\n{\n  public int X;\n  public Baseclass () { }\n  public Baseclass (int x) => X = x;\n}\n\npublic class Subclass : Baseclass { }\n```", "```cs\nSubclass s = new Subclass (123);\n```", "```cs\npublic class Subclass : Baseclass\n{\n  public Subclass (int x) : base (x) { }\n}\n```", "```cs\npublic class Baseclass\n{\n  public int X;\n  public Baseclass() { X = 1; }\n}\n\npublic class Subclass : Baseclass\n{\n  public Subclass() { Console.WriteLine (X); }  // 1\n}\n```", "```cs\nclass Baseclass\n{\n   public Baseclass (int x, int y, int z, string s, DateTime d) { ... }\n}\n\npublic class Subclass : Baseclass\n{\n  public Subclass (int x, int y, int z, string s, DateTime d)\n    : base (x, y, z, s, d) { ... }\n}\n```", "```cs\npublic class Asset\n{\n  public required string Name;\n}\n```", "```cs\nAsset a1 = new Asset { Name=\"House\" };  // OK\nAsset a2 = new Asset();                 // Error: will not compile!\n```", "```cs\npublic class Asset\n{\n  public required string Name;\n\n  public Asset() { }\n\n  [System.Diagnostics.CodeAnalysis.SetsRequiredMembers]\n  public Asset (string n) => Name = n;\n}\n```", "```cs\nAsset a1 = new Asset { Name = \"House\" };  // OK\nAsset a2 = new Asset (\"House\");           // OK\nAsset a3 = new Asset();                   // Error!\n```", "```cs\npublic class House : Asset { }            // No constructor, no worries!\n\nHouse h1 = new House { Name = \"House\" };  // OK\nHouse h2 = new House();                   // Error!\n```", "```cs\npublic class B\n{\n  int x = 1;         // Executes 3rd\n  public B (int x)\n  {\n    ...              // Executes 4th\n  }\n}\npublic class D : B\n{\n  int y = 1;         // Executes 1st\n  public D (int x)\n    : base (x + 1)   // Executes 2nd\n  {\n     ...             // Executes 5th\n  }\n}\n```", "```cs\npublic class Baseclass (int x) { ... }\n\npublic class Subclass (int x, int y) : Baseclass (x) { ... }\n```", "```cs\npublic class Subclass : Baseclass\n{\n  public Subclass (int x, int y) : base (x) { ... }\n}\n```", "```cs\nstatic void Foo (Asset a) { }\nstatic void Foo (House h) { }\n```", "```cs\nHouse h = new House (...);\nFoo(h);                      // Calls Foo(House)\n```", "```cs\nAsset a = new House (...);\nFoo(a);                      // Calls Foo(Asset)\n```", "```cs\nAsset a = new House (...);\nFoo ((dynamic)a);   // Calls Foo(House)\n```", "```cs\npublic class Stack\n{\n  int position;\n  object[] data = new object[10];\n  public void Push (object obj)   { data[position++] = obj;  }\n  public object Pop()             { return data[--position]; }\n}\n```", "```cs\nStack stack = new Stack();\nstack.Push (\"sausage\");\nstring s = (string) stack.Pop();   // Downcast, so explicit cast is needed\n\nConsole.WriteLine (s);             // sausage\n```", "```cs\nstack.Push (3);\nint three = (int) stack.Pop();\n```", "```cs\nint x = 9;\nobject obj = x;           // Box the int\n```", "```cs\nint y = (int)obj;         // Unbox the int\n```", "```cs\nobject obj = 9;           // 9 is inferred to be of type int\nlong x = (long) obj;      // InvalidCastException\n```", "```cs\nobject obj = 9;\nlong x = (int) obj;\n```", "```cs\nobject obj = 3.5;              // 3.5 is inferred to be of type double\nint x = (int) (double) obj;    // x is now 3\n```", "```cs\nobject[] a1 = new string[3];   // Legal\nobject[] a2 = new int[3];      // Error\n```", "```cs\nint i = 3;\nobject boxed = i;\ni = 5;\nConsole.WriteLine (boxed);    // 3\n```", "```cs\nint x = \"5\";\n```", "```cs\nobject y = \"5\";\nint z = (int) y;          // Runtime error, downcast failed\n```", "```cs\nPoint p = new Point();\nConsole.WriteLine (p.GetType().Name);             // Point\nConsole.WriteLine (typeof (Point).Name);          // Point\nConsole.WriteLine (p.GetType() == typeof(Point)); // True\nConsole.WriteLine (p.X.GetType().Name);           // Int32\nConsole.WriteLine (p.Y.GetType().FullName);       // System.Int32\n\npublic class Point { public int X, Y; }\n```", "```cs\nint x = 1;\nstring s = x.ToString();     // s is \"1\"\n```", "```cs\nPanda p = new Panda { Name = \"Petey\" };\nConsole.WriteLine (p);   // Petey\n\npublic class Panda\n{\n  public string Name;\n  public override string ToString() => Name;\n}\n```", "```cs\nint x = 1;\nstring s1 = x.ToString();    // Calling on nonboxed value\nobject box = x;\nstring s2 = box.ToString();  // Calling on boxed value\n```", "```cs\npublic class Object\n{\n  public Object();\n\n  public extern Type GetType();\n\n  public virtual bool Equals (object obj);\n  public static bool Equals  (object objA, object objB);\n  public static bool ReferenceEquals (object objA, object objB);\n\n  public virtual int GetHashCode();\n\n  public virtual string ToString();\n\n  protected virtual void Finalize();\n  protected extern object MemberwiseClone();\n}\n```", "```cs\nPoint p = new Point();        // p.x and p.y will be 0\nstruct Point { int x, y; }\n```", "```cs\nPoint p1 = new Point();       // p1.x and p1.y will be 1\nPoint p2 = default;           // p2.x and p2.y will be 0\n\nstruct Point\n{\n  int x = 1;\n  int y;\n  public Point() => y = 1;\n}\n```", "```cs\nvar points = new Point[10];   // Each point in the array will be (0,0)\nvar test = new Test();        // test.p will be (0,0)\n\nclass Test { Point p; }\n```", "```cs\npublic string Protocol { get; set; } = \"https\";\n```", "```cs\nstruct WebOptions\n{\n  string protocol;\n  public string Protocol { get => protocol ?? \"https\";\n                           set => protocol = value;    }\n}\n```", "```cs\nreadonly struct Point\n{\n  public readonly int X, Y;   // X and Y must be readonly\n}\n```", "```cs\nstruct Point\n{\n  public int X, Y;\n  public readonly void ResetX() => X = 0;  // Error!\n}\n```", "```cs\nvoid SomeMethod()\n{\n  Point p;   // p will reside on the stack\n}\nstruct Point { public int X, Y; }\n```", "```cs\nclass MyClass\n{\n  Point p;   // Lives on heap, because MyClass instances live on the heap\n}\n```", "```cs\nvar points = new Point [100];           // Error: will not compile!\n\nref struct Point { public int X, Y; }\nclass MyClass    { Point P;         }   // Error: will not compile!\n```", "```cs\nclass Class1 {}                  // Class1 is internal (default)\npublic class Class2 {}\n```", "```cs\nclass ClassA { int x;          } // x is private (default)\nclass ClassB { internal int x; }\n```", "```cs\nclass BaseClass\n{\n  void Foo()           {}        // Foo is private (default)\n  protected void Bar() {}\n}\n\nclass Subclass : BaseClass\n{\n  void Test1() { Foo(); }       // Error - cannot access Foo\n  void Test2() { Bar(); }       // OK\n}\n```", "```cs\n[assembly: InternalsVisibleTo (\"Friend\")]\n```", "```cs\n[assembly: InternalsVisibleTo (\"StrongFriend, PublicKey=0024f000048c...\")]\n```", "```cs\nstring key = string.Join (\"\",\n  Assembly.GetExecutingAssembly().GetName().GetPublicKey()\n    .Select (b => b.ToString (\"x2\")));\n```", "```cs\nclass C { public void Foo() {} }\n```", "```cs\nclass BaseClass             { protected virtual  void Foo() {} }\nclass Subclass1 : BaseClass { protected override void Foo() {} }  // OK\nclass Subclass2 : BaseClass { public    override void Foo() {} }  // Error\n```", "```cs\ninternal class A {}\npublic class B : A {}          // Error\n```", "```cs\npublic interface IEnumerator\n{\n  bool MoveNext();\n  object Current { get; }\n  void Reset();\n}\n```", "```cs\ninternal class Countdown : IEnumerator\n{\n  int count = 11;\n  public bool MoveNext() => count-- > 0;\n  public object Current => count;\n  public void Reset() { throw new NotSupportedException(); }\n}\n```", "```cs\nIEnumerator e = new Countdown();\nwhile (e.MoveNext())\n  Console.Write (e.Current);      // 109876543210\n```", "```cs\npublic static class Util\n{\n  public static object GetCountDown() => new CountDown();\n}\n```", "```cs\nIEnumerator e = (IEnumerator) Util.GetCountDown();\ne.MoveNext();\n```", "```cs\npublic interface IUndoable             { void Undo(); }\npublic interface IRedoable : IUndoable { void Redo(); }\n```", "```cs\ninterface I1 { void Foo(); }\ninterface I2 { int Foo(); }\n\npublic class Widget : I1, I2\n{\n  public void Foo()\n  {\n    Console.WriteLine (\"Widget's implementation of I1.Foo\");\n  }\n\n  int I2.Foo()\n  {\n    Console.WriteLine (\"Widget's implementation of I2.Foo\");\n    return 42;\n  }\n}\n```", "```cs\nWidget w = new Widget();\nw.Foo();                      // Widget's implementation of I1.Foo\n((I1)w).Foo();                // Widget's implementation of I1.Foo\n((I2)w).Foo();                // Widget's implementation of I2.Foo\n```", "```cs\npublic interface IUndoable { void Undo(); }\n\npublic class TextBox : IUndoable\n{\n  public virtual void Undo() => Console.WriteLine (\"TextBox.Undo\");\n}\n\npublic class RichTextBox : TextBox\n{\n  public override void Undo() => Console.WriteLine (\"RichTextBox.Undo\");\n}\n```", "```cs\nRichTextBox r = new RichTextBox();\nr.Undo();                          // RichTextBox.Undo\n((IUndoable)r).Undo();             // RichTextBox.Undo\n((TextBox)r).Undo();               // RichTextBox.Undo\n```", "```cs\npublic interface IUndoable { void Undo(); }\n\npublic class TextBox : IUndoable\n{\n  void IUndoable.Undo() => Console.WriteLine (\"TextBox.Undo\");\n}\n\npublic class RichTextBox : TextBox, IUndoable\n{\n  public void Undo() => Console.WriteLine (\"RichTextBox.Undo\");\n}\n```", "```cs\nRichTextBox r = new RichTextBox();\nr.Undo();                 // RichTextBox.Undo      Case 1\n((IUndoable)r).Undo();    // RichTextBox.Undo      Case 2\n```", "```cs\npublic class TextBox : IUndoable\n{\n  public void Undo() => Console.WriteLine (\"TextBox.Undo\");\n}\n```", "```cs\nRichTextBox r = new RichTextBox();\nr.Undo();                 // RichTextBox.Undo      Case 1\n((IUndoable)r).Undo();    // RichTextBox.Undo      Case 2\n((TextBox)r).Undo();      // TextBox.Undo          Case 3\n```", "```cs\npublic class TextBox : IUndoable\n{\n  void IUndoable.Undo()         => Undo();    // Calls method below\n  protected virtual void Undo() => Console.WriteLine (\"TextBox.Undo\");\n}\n\npublic class RichTextBox : TextBox\n{\n  protected override void Undo() => Console.WriteLine(\"RichTextBox.Undo\");\n}\n```", "```cs\ninterface  I { void Foo();          }\nstruct S : I { public void Foo() {} }\n\n...\nS s = new S();\ns.Foo();         // No boxing.\n\nI i = s;         // Box occurs when casting to interface.\ni.Foo();\n```", "```cs\ninterface ILogger\n{\n  void Log (string text) => Console.WriteLine (text);\n}\n```", "```cs\nclass Logger : ILogger { }\n...\n((ILogger)new Logger()).Log (\"message\");\n```", "```cs\ninterface ILogger\n{\n  void Log (string text) => \n    Console.WriteLine (Prefix + text);\n\n  static string Prefix = \"\"; \n}\n```", "```cs\nILogger.Prefix = \"File log: \";\n```", "```cs\ninterface ITypeDescribable\n{\n  static abstract string Description { get; }\n  static virtual string Category => null;\n}\n```", "```cs\nclass CustomerTest : ITypeDescribable\n{\n  public static string Description => \"Customer tests\";  // Mandatory\n  public static string Category    => \"Unit testing\";    // Optional\n}\n```", "```cs\npublic enum BorderSide { Left, Right, Top, Bottom }\n```", "```cs\nBorderSide topSide = BorderSide.Top;\nbool isTop = (topSide == BorderSide.Top);   // true\n```", "```cs\npublic enum BorderSide : byte { Left, Right, Top, Bottom }\n```", "```cs\npublic enum BorderSide : byte { Left=1, Right=2, Top=10, Bottom=11 }\n```", "```cs\npublic enum BorderSide : byte\n { Left=1, Right, Top=10, Bottom }\n```", "```cs\nint i = (int) BorderSide.Left;\nBorderSide side = (BorderSide) i;\nbool leftOrRight = (int) side <= 2;\n```", "```cs\npublic enum HorizontalAlignment\n{\n  Left = BorderSide.Left,\n  Right = BorderSide.Right,\n  Center\n}\n```", "```cs\nHorizontalAlignment h = (HorizontalAlignment) BorderSide.Right;\n// same as:\nHorizontalAlignment h = (HorizontalAlignment) (int) BorderSide.Right;\n```", "```cs\nBorderSide b = 0;    // No cast required\nif (b == 0) ...\n```", "```cs\n[Flags]\nenum BorderSides { None=0, Left=1, Right=2, Top=4, Bottom=8 }\n```", "```cs\nenum BorderSides { None=0, Left=1, Right=1<<1, Top=1<<2, Bottom=1<<3 }\n```", "```cs\nBorderSides leftRight = BorderSides.Left | BorderSides.Right;\n\nif ((leftRight & BorderSides.Left) != 0)\n  Console.WriteLine (\"Includes Left\");     // Includes Left\n\nstring formatted = leftRight.ToString();   // \"Left, Right\"\n\nBorderSides s = BorderSides.Left;\ns |= BorderSides.Right;\nConsole.WriteLine (s == leftRight);   // True\n\ns ^= BorderSides.Right;               // Toggles BorderSides.Right\nConsole.WriteLine (s);                // Left\n```", "```cs\n[Flags]\nenum BorderSides\n{\n  None=0,\n  Left=1, Right=1<<1, Top=1<<2, Bottom=1<<3,\n  LeftRight = Left | Right, \n  TopBottom = Top  | Bottom,\n  All       = LeftRight | TopBottom\n}\n```", "```cs\n=   ==   !=   <   >   <=   >=   +   -   ^  &  |   ˜\n+=   -=   ++  --   sizeof\n```", "```cs\npublic enum BorderSide { Left, Right, Top, Bottom }\n```", "```cs\nBorderSide b = (BorderSide) 12345;\nConsole.WriteLine (b);                // 12345\n```", "```cs\nBorderSide b = BorderSide.Bottom;\nb++;                                  // No errors\n```", "```cs\nvoid Draw (BorderSide side)\n{\n  if      (side == BorderSide.Left)  {...}\n  else if (side == BorderSide.Right) {...}\n  else if (side == BorderSide.Top)   {...}\n  else                               {...} // Assume BorderSide.Bottom\n}\n```", "```cs\n  ...\n  else if (side == BorderSide.Bottom) ...\n  else throw new ArgumentException (\"Invalid BorderSide: \" + side, \"side\");\n```", "```cs\nBorderSide side = (BorderSide) 12345;\nConsole.WriteLine (Enum.IsDefined (typeof (BorderSide), side));   // False\n```", "```cs\nfor (int i = 0; i <= 16; i++)\n{\n  BorderSides side = (BorderSides)i;\n  Console.WriteLine (IsFlagDefined (side) + \" \" + side);\n}\n\nbool IsFlagDefined (Enum e)\n{\n  decimal d;\n  return !decimal.TryParse(e.ToString(), out d);\n}\n\n[Flags]\npublic enum BorderSides { Left=1, Right=2, Top=4, Bottom=8 }\n```", "```cs\npublic class TopLevel\n{\n  public class Nested { }               // Nested class\n  public enum Color { Red, Blue, Tan }  // Nested enum\n}\n```", "```cs\nTopLevel.Color color = TopLevel.Color.Red;\n```", "```cs\npublic class TopLevel\n{\n  static int x;\n  class Nested\n  {\n    static void Foo() { Console.WriteLine (TopLevel.x); }\n  }\n}\n```", "```cs\npublic class TopLevel\n{\n  protected class Nested { }\n}\n\npublic class SubTopLevel : TopLevel\n{\n  static void Foo() { new TopLevel.Nested(); }\n}\n```", "```cs\npublic class TopLevel\n{\n  public class Nested { }\n}\n\nclass Test\n{\n  TopLevel.Nested n;\n}\n```", "```cs\npublic class Stack<T>\n{\n  int position;\n  T[] data = new T[100];\n  public void Push (T obj)  => data[position++] = obj;\n  public T Pop()            => data[--position];\n}\n```", "```cs\nvar stack = new Stack<int>();\nstack.Push (5);\nstack.Push (10);\nint x = stack.Pop();        // x is 10\nint y = stack.Pop();        // y is 5\n```", "```cs\npublic class ###\n{\n  int position;\n  int[] data = new int[100];\n  public void Push (int obj)  => data[position++] = obj;\n  public int Pop()            => data[--position];\n}\n```", "```cs\nvar stack = new Stack<T>();   // Illegal: What is T?\n```", "```cs\npublic class Stack<T>\n{\n  ...\n  public Stack<T> Clone()\n  {\n    Stack<T> clone = new Stack<T>();   // Legal\n    ...\n  } \n}\n```", "```cs\npublic class ObjectStack\n{\n  int position;\n  object[] data = new object[10];\n  public void Push (object obj) => data[position++] = obj;\n  public object Pop()           => data[--position];\n}\n```", "```cs\n// Suppose we just want to store integers here:\nObjectStack stack = new ObjectStack();\n\nstack.Push (\"s\");          // Wrong type, but no error!\nint i = (int)stack.Pop();  // Downcast - runtime error\n```", "```cs\nstatic void Swap<T> (ref T a, ref T b)\n{\n  T temp = a;\n  a = b;\n  b = temp;\n}\n```", "```cs\nint x = 5;\nint y = 10;\nSwap (ref x, ref y);\n```", "```cs\nSwap<int> (ref x, ref y);\n```", "```cs\npublic T this [int index] => data [index];\n```", "```cs\npublic Stack<T>() { }   // Illegal\n```", "```cs\npublic struct Nullable<T>\n{\n  public T Value { get; }\n}\n```", "```cs\nclass Dictionary<TKey, TValue> {...}\n```", "```cs\nDictionary<int,string> myDict = new Dictionary<int,string>();\n```", "```cs\nvar myDict = new Dictionary<int,string>();\n```", "```cs\nclass A        {}\nclass A<T>     {}\nclass A<T1,T2> {}\n```", "```cs\nclass A<T> {}\nclass A<T1,T2> {}\n...\n\nType a1 = typeof (A<>);   // *Unbound* type (notice no type arguments).\nType a2 = typeof (A<,>);  // Use commas to indicate multiple type args.\n```", "```cs\nType a3 = typeof (A<int,int>);\n```", "```cs\nclass B<T> { void X() { Type t = typeof (T); } }\n```", "```cs\nstatic void Zap<T> (T[] array)\n{\n  for (int i = 0; i < array.Length; i++)\n    array[i] = default(T);\n}\n```", "```cs\n    array[i] = default;\n```", "```cs\nwhere *T* : *base-class*   // Base-class constraint\nwhere *T* : *interface*    // Interface constraint\nwhere *T* : class        // Reference-type constraint\nwhere *T* : class?       // (See \"Nullable Reference Types\" in Chapter 4)\nwhere *T* : struct       // Value-type constraint (excludes Nullable types)\nwhere *T* : unmanaged    // Unmanaged constraint\nwhere *T* : new()        // Parameterless constructor constraint\nwhere *U* : *T*            // Naked type constraint\nwhere *T* : notnull      // Non-nullable value type, or (from C# 8)\n                       // a non-nullable reference type\n```", "```cs\nclass     SomeClass {}\ninterface Interface1 {}\n\nclass GenericClass<T,U> where T : SomeClass, Interface1\n                        where U : new()\n{...}\n```", "```cs\npublic interface IComparable<T>   // Simplified version of interface\n{\n  int CompareTo (T other);\n}\n```", "```cs\nstatic T Max <T> (T a, T b) where T : IComparable<T>\n{\n  return a.CompareTo (b) > 0 ? a : b;\n}\n```", "```cs\nint z = Max (5, 10);               // 10\nstring last = Max (\"ant\", \"zoo\");  // zoo\n```", "```cs\nstruct Nullable<T> where T : struct {...}\n```", "```cs\nstatic void Initialize<T> (T[] array) where T : new()\n{\n  for (int i = 0; i < array.Length; i++)\n    array[i] = new T();\n}\n```", "```cs\nclass Stack<T>\n{\n  Stack<U> FilteredStack<U>() where U : T {...}\n}\n```", "```cs\nclass Stack<T>                   {...}\nclass SpecialStack<T> : Stack<T> {...}\n```", "```cs\nclass IntStack : Stack<int>  {...}\n```", "```cs\nclass List<T>                     {...}\nclass KeyedList<T,TKey> : List<T> {...}\n```", "```cs\nclass List<T> {...}\nclass KeyedList<TElement,TKey> : List<TElement> {...}\n```", "```cs\npublic interface IEquatable<T> { bool Equals (T obj); }\n\npublic class Balloon : IEquatable<Balloon>\n{\n  public string Color { get; set; }\n  public int CC { get; set; }\n\n  public bool Equals (Balloon b)\n  {\n    if (b == null) return false;\n    return b.Color == Color && b.CC == CC;\n  }\n}\n```", "```cs\nclass Foo<T> where T : IComparable<T> { ... }\nclass Bar<T> where T : Bar<T> { ... }\n```", "```cs\nConsole.WriteLine (++Bob<int>.Count);     // 1\nConsole.WriteLine (++Bob<int>.Count);     // 2\nConsole.WriteLine (++Bob<string>.Count);  // 1\nConsole.WriteLine (++Bob<object>.Count);  // 1\n\nclass Bob<T> { public static int Count; }\n```", "```cs\nStringBuilder Foo<T> (T arg)\n{\n  if (arg is StringBuilder)\n    return (StringBuilder) arg;   // Will not compile\n  ...\n}\n```", "```cs\nStringBuilder Foo<T> (T arg)\n{\n  StringBuilder sb = arg as StringBuilder;\n  if (sb != null) return sb;\n  ...\n}\n```", "```cs\n  return (StringBuilder) (object) arg;\n```", "```cs\nint Foo<T> (T x) => (int) x;     // Compile-time error\n```", "```cs\nint Foo<T> (T x) => (int) (object) x;\n```", "```cs\nIFoo<string> s = ...;\nIFoo<object> b = s;\n```", "```cs\nclass Animal {}\nclass Bear : Animal {}\nclass Camel : Animal {}\n\npublic class Stack<T>   // A simple Stack implementation\n{\n  int position;\n  T[] data = new T[100];\n  public void Push (T obj)  => data[position++] = obj;\n  public T Pop()            => data[--position]; \n}\n```", "```cs\nStack<Bear> bears = new Stack<Bear>();\nStack<Animal> animals = bears;            // Compile-time error\n```", "```cs\nanimals.Push (new Camel());      // Trying to add Camel to bears\n```", "```cs\npublic class ZooCleaner\n{\n  public static void Wash (Stack<Animal> animals) {...}\n}\n```", "```cs\nclass ZooCleaner\n{\n  public static void Wash<T> (Stack<T> animals) where T : Animal { ... }\n}\n```", "```cs\nStack<Bear> bears = new Stack<Bear>();\nZooCleaner.Wash (bears);\n```", "```cs\nBear[] bears = new Bear[3];\nAnimal[] animals = bears;     // OK\n```", "```cs\nanimals[0] = new Camel();     // Runtime error\n```", "```cs\npublic interface IPoppable<out T> { T Pop(); }\n```", "```cs\nvar bears = new Stack<Bear>();\nbears.Push (new Bear());\n// Bears implements IPoppable<Bear>. We can convert to IPoppable<Animal>:\nIPoppable<Animal> animals = bears;   // Legal\nAnimal a = animals.Pop();\n```", "```cs\npublic class ZooCleaner\n{\n  public static void Wash (IPoppable<Animal> animals) { ... }\n}\n```", "```cs\npublic interface IPushable<in T> { void Push (T obj); }\n```", "```cs\nIPushable<Animal> animals = new Stack<Animal>();\nIPushable<Bear> bears = animals;    // Legal\nbears.Push (new Bear());\n```", "```cs\npublic interface IComparer<in T>\n{\n  // Returns a value indicating the relative ordering of a and b\n  int Compare (T a, T b);\n}\n```", "```cs\nvar objectComparer = Comparer<object>.Default;\n// objectComparer implements IComparer<object>\nIComparer<string> stringComparer = objectComparer;\nint result = stringComparer.Compare (\"Brett\", \"Jemaine\");\n```", "```cs\nstatic T Max <T> (T a, T b) where T : IComparable<T>\n  => a.CompareTo (b) > 0 ? a : b;\n```", "```cs\nstatic T Max <T> (T a, T b)\n  => (a > b ? a : b);             // Compile error\n```", "```cs\ntemplate <class T> T Max (T a, T b)\n{\n  return a > b ? a : b;\n}\n```"]