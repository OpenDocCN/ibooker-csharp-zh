<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 11. Reactive Extensions" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_reactive_extensions">
<h1><span class="label">Chapter 11. </span>Reactive Extensions</h1>
<p><a data-primary="reactive extensions (Rx)" data-type="indexterm" id="ix_ch11-asciidoc0"/>The <a data-primary="reactive extensions (Rx)" data-secondary="basics" data-type="indexterm" id="idm45884802053920"/>Reactive Extensions for .NET (usually shortened to <em>Rx</em>) are designed for working with asynchronous and event-based sources of information. Rx provides services that help you orchestrate and synchronize the way your code reacts to data from these kinds of sources. We already saw how to define and subscribe to events in <a data-type="xref" href="ch09.xhtml#ch_delegates_lambdas_events">Chapter 9</a>, but Rx offers much more than these basic features. It provides an abstraction for event sources that has a steeper learning curve than events, but it comes with a powerful set of operators that makes it far easier to combine and manage multiple streams of events than is possible with the free-for-all that delegates and .NET events provide. Microsoft has also made an associated set of libraries called Reaqtor available that builds on the foundation of Rx to provide a framework for reliable, stateful, distributed, scalable, high-performance event processing in services.</p>
<p><a data-primary="IObservable&lt;T&gt; interface" data-type="indexterm" id="idm45884802051296"/>Rx’s fundamental abstraction, <code>IObservable&lt;T&gt;</code>, represents a sequence of items, and its operators are defined as extension methods for this interface. This might sound a lot like LINQ to Objects, and there are similarities—not only does <a data-primary="IEnumerable&lt;T&gt; interface" data-secondary="IObservable&lt;T&gt; and" data-type="indexterm" id="idm45884802049888"/><code>IObservable&lt;T&gt;</code> have a lot in common with <code>IEnumerable&lt;T&gt;</code>, but Rx also supports almost all of the standard LINQ operators. If you are familiar with LINQ to Objects, you will also feel at home with Rx. The difference is that in Rx, sequences are less passive. Unlike <code>IEnumerable&lt;T&gt;</code>, Rx sources do not wait to be asked for their items, nor can the consumer of an Rx source demand to be given the next item. Instead, Rx uses a <em>push</em> model in which the source notifies its recipients when items are available.</p>
<p>For example, if you’re writing an application that deals with live financial information, such as stock market price data, <code>IObservable&lt;T&gt;</code> is a much more natural model than <code>IEnumerable&lt;T&gt;</code>. Because Rx implements standard LINQ operators, you can write queries against a live source—you could narrow down the stream of events with a <code>where</code> clause or group them by stock symbol. Rx goes beyond standard LINQ, adding its own operators that take into account the temporal nature of a live event source. For example, you could write a query that provides data only for stocks that are changing price more frequently than some minimum rate.</p>
<p>Rx’s push-oriented approach makes it a better match than <code>IEnumerable&lt;T&gt;</code> for event-like sources. But why not just use events, or even plain delegates? Rx addresses four shortcomings of those alternatives. First, it defines a standard way for sources to report errors. Second, it is able to deliver items in a well-defined order, even in multithreaded scenarios involving numerous sources. Third, Rx provides a clear way to signal when there are no more items. Fourth, because a traditional event is represented by a special kind of member, not a normal object, there are significant limits on what you can do with an event—you can’t pass a .NET event as an argument to a method, store it in a field, or offer it in a property. You can do these things with a delegate, but that’s not the same thing—delegates can handle events but cannot represent a source of them. There’s no way to write a method that subscribes to some .NET event that you pass as an argument, because you can’t pass the actual event itself. Rx fixes this by representing event sources as objects, instead of a special distinctive element of the type system that doesn’t work like anything else.</p>
<p>We get all four of these features for free back in the world of <code>IEnumerable&lt;T&gt;</code>, of course. A collection can throw an exception when its contents are being enumerated, but with callbacks, it’s less obvious when and where to deliver exceptions. <code>IEnumerable&lt;T&gt;</code> makes consumers retrieve items one at a time, so the ordering is unambiguous, but with plain events and delegates, nothing enforces that. And <code>IEnumerable&lt;T&gt;</code> tells consumers when the end of the collection has been reached, but with a simple callback, it’s not necessarily clear when you’ve had the last call. <code>IObservable&lt;T&gt;</code> handles all of these eventualities, bringing the things we can take for granted with <code>IEnumerable&lt;T&gt;</code> into the world of events.</p>
<p>By providing a coherent abstraction that addresses these problems, Rx is able to bring all of the benefits of LINQ to event-driven scenarios. Rx does not replace events; I wouldn’t have dedicated one-fifth of <a data-type="xref" href="ch09.xhtml#ch_delegates_lambdas_events">Chapter 9</a> to them if it did. In fact, Rx can integrate with events. It can bridge between its own abstractions and several others, not just ordinary events but also <code>IEnumerable&lt;T&gt;</code> and various asynchronous programming models. Far from deprecating events, Rx raises their capabilities to a new level. It’s considerably harder to get your head around Rx than events, but it offers much more power once you do.</p>
<p>Two interfaces form the heart of Rx. Sources that present items through this model implement <code>IObservable&lt;T&gt;</code>. Subscribers are required to supply an object that implements <code>IObserver&lt;T&gt;</code>. These two interfaces are built into .NET. The other parts of Rx are in the <code>System.Reactive</code> NuGet package.</p>
<section data-pdf-bookmark="Fundamental Interfaces" data-type="sect1"><div class="sect1" id="fundamental_interfaces">
<h1>Fundamental Interfaces</h1>
<p><a data-primary="reactive extensions (Rx)" data-secondary="fundamental interfaces" data-type="indexterm" id="ix_ch11-asciidoc1"/>The two most important types in Rx are the <a data-primary="IObservable&lt;T&gt; interface" data-type="indexterm" id="idm45884802032032"/><code>IObservable&lt;T&gt;</code> and <a data-primary="IObserver&lt;T&gt; interface" data-type="indexterm" id="ix_ch11-asciidoc2"/><a data-primary="reactive extensions (Rx)" data-secondary="IObserver&lt;T&gt;" data-type="indexterm" id="ix_ch11-asciidoc3"/><code>IObserver&lt;T&gt;</code> interfaces. They are <span class="keep-together">important</span> enough to be in the <code>System</code> namespace. <a data-type="xref" href="#iobservableoft_and_iobserveroft">Example 11-1</a> shows their definitions.</p>
<div data-type="example" id="iobservableoft_and_iobserveroft">
<h5><span class="label">Example 11-1. </span><code>IObservable&lt;T&gt;</code> and <code>IObserver&lt;T&gt;</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">interface</code> <code class="n">IObservable</code><code class="p">&lt;</code><code class="k">out</code> <code class="n">T</code><code class="p">&gt;</code>
<code class="p">{</code>
    <code class="n">IDisposable</code> <code class="nf">Subscribe</code><code class="p">(</code><code class="n">IObserver</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="n">observer</code><code class="p">);</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">interface</code> <code class="n">IObserver</code><code class="p">&lt;</code><code class="k">in</code> <code class="n">T</code><code class="p">&gt;</code>
<code class="p">{</code>
    <code class="k">void</code> <code class="nf">OnCompleted</code><code class="p">();</code>
    <code class="k">void</code> <code class="nf">OnError</code><code class="p">(</code><code class="n">Exception</code> <code class="n">error</code><code class="p">);</code>
    <code class="k">void</code> <code class="nf">OnNext</code><code class="p">(</code><code class="n">T</code> <code class="k">value</code><code class="p">);</code>
<code class="p">}</code></pre></div>
<p>The fundamental abstraction in Rx, <code>IObservable&lt;T&gt;</code>, is implemented by event sources. Instead of using the <code>event</code> keyword, it models events as a sequence of items. An <code>IObservable&lt;T&gt;</code> provides items to subscribers as and when it’s ready to.</p>
<p>As you can see, the type argument for <code>IObservable&lt;T&gt;</code> is covariant, meaning if you have a type <code>Base</code> that is the base type of another type <code>Derived</code>, then just as you can pass a <code>Derived</code> to any method expecting a <code>Base</code>, you can pass an 
<span class="keep-together"><code>IObservable&lt;Derived&gt;</code></span> to anything expecting an <code>IObservable&lt;Base&gt;</code>. It makes sense intuitively to see the <code>out</code> keyword here, because like <code>IEnumerable&lt;T&gt;</code>, this is a source of information—items come out of it. Conversely, items go into a subscriber’s <code>IObserver&lt;T&gt;</code> implementation, so that has the <code>in</code> keyword, which denotes contravariance—you can pass an <code>IObserver&lt;Base&gt;</code> to anything expecting an 
<span class="keep-together"><code>IObserver&lt;Derived&gt;</code>.</span> (I described variance in <a data-type="xref" href="ch06.xhtml#ch_inheritance">Chapter 6</a>.)</p>
<p>We can subscribe to a source by passing an implementation of <code>IObserver&lt;T&gt;</code> to the <code>Subscribe</code> method. The source will invoke <code>OnNext</code> when it wants to report events, and it can call <code>OnCompleted</code> to indicate that there will be no further activity. If the source wants to report an error, it can call <code>OnError</code>. Both <code>OnCompleted</code> and <code>OnError</code> indicate the end of the stream—an observable should not call any further methods on the observer after that.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>You will not necessarily get an exception immediately if you break this rule. In some cases you will—if you use the NuGet <code>System.Reactive</code> library to help implement and consume these interfaces, there are certain circumstances in which it can detect this kind of mistake. But in general it is the responsibility of code calling these methods to stick to the rule.</p>
</div>
<p><a data-primary="marble diagram" data-type="indexterm" id="idm45884801932688"/>There’s a visual convention for representing Rx activity. It’s sometimes called a <em>marble diagram</em>, because it consists mainly of small circles that look a bit like marbles. <a data-type="xref" href="#simple_marble_diagram">Figure 11-1</a> uses this convention to represent two sequences of events. The horizontal lines represent subscriptions to sources, with the vertical bar on the left indicating the start of the subscription, and the horizontal position indicating when something <span class="keep-together">occurred</span> (with elapsed time increasing from left to right). The circles indicate calls to <code>OnNext</code> (i.e., events being reported by the source). An arrow on the righthand end indicates that the subscription was still active by the end of the time the diagram represents. A vertical bar on the right indicates the end of the subscription—either due to a call to <code>OnError</code> or <code>OnCompleted</code> or because the subscriber unsubscribed.</p>
<figure><div class="figure" id="simple_marble_diagram">
<img alt="" height="89" src="assets/pc10_1101.png" width="600"/>
<h6><span class="label">Figure 11-1. </span>Simple marble diagram</h6>
</div></figure>
<p>When you call <code>Subscribe</code> on an observable, it returns an object that implements 
<span class="keep-together"><code>IDisposable</code>,</span> which provides a way to unsubscribe. If you call <code>Dispose</code>, the observable will not deliver any more notifications to your observer. This can be more convenient than the mechanism for unsubscribing from an event; to unsubscribe from an event, you must pass in an equivalent delegate to the one you used for subscription. If you’re using anonymous methods, that can be surprisingly awkward, because often the only way to do that is to keep hold of a reference to the original delegate. With Rx, any subscription to a source is represented as an <code>IDisposable</code>, making it easier to handle in a uniform way. In fact, you often do not need to unsubscribe anyway—this is necessary only if you want to stop receiving notifications before the source completes (making this an example of something that is relatively unusual in .NET: optional disposability).</p>
<section data-pdf-bookmark="IObserver&lt;T&gt;" data-type="sect2"><div class="sect2" id="iobserver_of_t">
<h2>IObserver&lt;T&gt;</h2>
<p><a data-primary="IObservable&lt;T&gt; interface" data-secondary="Rx implementation" data-type="indexterm" id="idm45884801921440"/>As you’ll see, in practice we often don’t call a source’s <code>Subscribe</code> method directly, nor do we usually need to implement <code>IObserver&lt;T&gt;</code> ourselves. Instead, it’s common to use one of the delegate-based extension methods that Rx provides and that attaches an Rx-supplied implementation. However, those extension methods are not part of Rx’s fundamental types, so for now I’ll show what you’d need to write if these interfaces are all you’ve got. <a data-type="xref" href="#simple_iobserver_implementation">Example 11-2</a> shows a simple but complete observer.</p>
<div data-type="example" id="simple_iobserver_implementation">
<h5><span class="label">Example 11-2. </span>Simple <code>IObserver&lt;T&gt;</code> implementation</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">class</code> <code class="nc">MySubscriber</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="p">:</code> <code class="n">IObserver</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">void</code> <code class="nf">OnNext</code><code class="p">(</code><code class="n">T</code> <code class="k">value</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Received: "</code> <code class="p">+</code> <code class="k">value</code><code class="p">);</code>
    <code class="k">public</code> <code class="k">void</code> <code class="nf">OnCompleted</code><code class="p">()</code> <code class="p">=&gt;</code> <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Complete"</code><code class="p">);</code>
    <code class="k">public</code> <code class="k">void</code> <code class="nf">OnError</code><code class="p">(</code><code class="n">Exception</code> <code class="n">ex</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Error: "</code> <code class="p">+</code> <code class="n">ex</code><code class="p">);</code>
<code class="p">}</code></pre></div>
<p>Rx sources (i.e., implementations of <code>IObservable&lt;T&gt;</code>) are required to make certain guarantees about how they call an observer’s methods. The calls happen in a certain order: <code>OnNext</code> is called for each item that the source provides, and I already mentioned that once either <code>OnCompleted</code> or <code>OnError</code> is called, the observer knows that there will be no further calls to any of the three methods. Either of those methods signals the end of the sequence.</p>
<p>Also, calls are not allowed to overlap—when an observable source calls one of our observer’s methods, it must wait for that method to return before calling again. A multithreaded observable must take care to coordinate its calls, and even in a single-threaded world, the possibility of recursion can make it necessary for sources to detect and prevent re-entrant calls.</p>
<p>This makes life simple for the observer. Because Rx provides events as a sequence, my code doesn’t need to deal with the possibility of concurrent calls. It’s up to the source to call methods in the correct order. So, although <code>IObservable&lt;T&gt;</code> may look like the simpler interface, having just one method, it’s the more demanding one to implement. As you’ll see later, it’s usually easiest to let the Rx libraries implement this for you, but it’s still important to know how observable sources work, so I’ll implement it by hand to begin with.<a data-startref="ix_ch11-asciidoc3" data-type="indexterm" id="idm45884801849728"/><a data-startref="ix_ch11-asciidoc2" data-type="indexterm" id="idm45884801849024"/></p>
</div></section>
<section data-pdf-bookmark="IObservable&lt;T&gt;" data-type="sect2"><div class="sect2" id="iobservable_of_t">
<h2>IObservable&lt;T&gt;</h2>
<p><a data-primary="IObservable&lt;T&gt; interface" data-type="indexterm" id="ix_ch11-asciidoc4"/><a data-primary="reactive extensions (Rx)" data-secondary="IObservable&lt;T&gt;" data-type="indexterm" id="ix_ch11-asciidoc5"/>Rx makes a distinction between <em>hot</em> and <em>cold</em> observable sources. <a data-primary="hot observables" data-secondary="defined" data-type="indexterm" id="idm45884801812832"/>A hot observable produces each value as and when something of interest happens, and if no subscribers are attached at that moment, that value will be lost. A hot observable typically represents something live, such as mouse input, keypresses, or data reported by a sensor, which is why the values it produces are independent of how many subscribers, if any, are attached. Hot sources typically have broadcast-like behavior—they send each item to all of their subscribers. These can be the more complex kind of source to implement, so I’ll discuss cold sources first.</p>
<section data-pdf-bookmark="Implementing cold sources" data-type="sect3"><div class="sect3" id="implementing_cold_sources">
<h3>Implementing cold sources</h3>
<p><a data-primary="cold observables" data-type="indexterm" id="ix_ch11-asciidoc6"/><a data-primary="IObservable&lt;T&gt; interface" data-secondary="implementing cold sources" data-type="indexterm" id="ix_ch11-asciidoc7"/>Whereas hot sources report items as and when they want to, cold observables work differently. They start pushing values when an observer subscribes, and they provide values to each subscriber separately, rather than broadcasting. This means that a subscriber won’t miss anything by being too late, because the source starts providing items when you subscribe. <a data-type="xref" href="#a_simple_cold_observable_source">Example 11-3</a> shows a very simple cold source.</p>
<div data-type="example" id="a_simple_cold_observable_source">
<h5><span class="label">Example 11-3. </span>A simple cold observable source</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">SimpleColdSource</code> <code class="p">:</code> <code class="n">IObservable</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="n">IDisposable</code> <code class="nf">Subscribe</code><code class="p">(</code><code class="n">IObserver</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">observer</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">observer</code><code class="p">.</code><code class="n">OnNext</code><code class="p">(</code><code class="s">"Hello,"</code><code class="p">);</code>
        <code class="n">observer</code><code class="p">.</code><code class="n">OnNext</code><code class="p">(</code><code class="s">"World!"</code><code class="p">);</code>
        <code class="n">observer</code><code class="p">.</code><code class="n">OnCompleted</code><code class="p">();</code>
        <code class="k">return</code> <code class="n">NullDisposable</code><code class="p">.</code><code class="n">Instance</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">private</code> <code class="k">class</code> <code class="nc">NullDisposable</code> <code class="p">:</code> <code class="n">IDisposable</code>
    <code class="p">{</code>
        <code class="k">public</code> <code class="k">readonly</code> <code class="k">static</code> <code class="n">NullDisposable</code> <code class="n">Instance</code> <code class="p">=</code> <code class="k">new</code><code class="p">();</code>
        <code class="k">public</code> <code class="k">void</code> <code class="nf">Dispose</code><code class="p">()</code> <code class="p">{</code> <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>The moment an observer subscribes, this source will provide two values, the strings <code>"Hello,"</code> and <code>"World!"</code>, and will then indicate the end of the sequence by calling <code>OnCompleted</code>. It does all that inside <code>Subscribe</code>, so this doesn’t really look like a subscription—the sequence is already over by the time <code>Subscribe</code> returns, so there’s nothing meaningful to do to support unsubscription. That’s why this returns a trivial implementation of <code>IDisposable</code>. (I’ve chosen an extremely simple example so I can show the basics. Real sources will be more complex.)</p>
<p>To show this in action, we need to create an instance of <code>SimpleColdSource</code>, and also an instance of my observer class from <a data-type="xref" href="#simple_iobserver_implementation">Example 11-2</a>, and use that to subscribe to the source, as <a data-type="xref" href="#attaching_an_observer_to_an_observable">Example 11-4</a> does.</p>
<div data-type="example" id="attaching_an_observer_to_an_observable">
<h5><span class="label">Example 11-4. </span>Attaching an observer to an observable</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">source</code> <code class="p">=</code> <code class="k">new</code> <code class="n">SimpleColdSource</code><code class="p">();</code>
<code class="kt">var</code> <code class="n">sub</code> <code class="p">=</code> <code class="k">new</code> <code class="n">MySubscriber</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;();</code>
<code class="n">source</code><code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="n">sub</code><code class="p">);</code></pre></div>
<p>Predictably, this produces the following output:</p>
<pre data-type="programlisting">Received: Hello,
Received: World!
Complete</pre>
<p>In general, a cold observer will have access to some underlying source of information, which it can push to a subscriber on demand. In <a data-type="xref" href="#a_simple_cold_observable_source">Example 11-3</a>, that “source” was just two hardcoded values. <a data-type="xref" href="#file_cold_observable">Example 11-5</a> shows a slightly more interesting cold observable, which reads the lines out of a file and provides them to a subscriber.</p>
<div data-type="example" id="file_cold_observable">
<h5><span class="label">Example 11-5. </span>A cold observable representing a file’s contents</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">FilePusher</code> <code class="p">:</code> <code class="n">IObservable</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code>
<code class="p">{</code>
    <code class="k">private</code> <code class="k">readonly</code> <code class="kt">string</code> <code class="n">_path</code><code class="p">;</code>
    <code class="k">public</code> <code class="nf">FilePusher</code><code class="p">(</code><code class="kt">string</code> <code class="n">path</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">_path</code> <code class="p">=</code> <code class="n">path</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">public</code> <code class="n">IDisposable</code> <code class="nf">Subscribe</code><code class="p">(</code><code class="n">IObserver</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">observer</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="k">using</code> <code class="p">(</code><code class="kt">var</code> <code class="n">sr</code> <code class="p">=</code> <code class="k">new</code> <code class="n">StreamReader</code><code class="p">(</code><code class="n">_path</code><code class="p">))</code>
        <code class="p">{</code>
            <code class="k">while</code> <code class="p">(!</code><code class="n">sr</code><code class="p">.</code><code class="n">EndOfStream</code><code class="p">)</code>
            <code class="p">{</code>
                <code class="kt">string?</code> <code class="n">line</code> <code class="p">=</code> <code class="n">sr</code><code class="p">.</code><code class="n">ReadLine</code><code class="p">();</code>
                <code class="k">if</code> <code class="p">(</code><code class="n">line</code> <code class="k">is</code> <code class="n">not</code> <code class="k">null</code><code class="p">)</code>
                <code class="p">{</code>
                    <code class="n">observer</code><code class="p">.</code><code class="n">OnNext</code><code class="p">(</code><code class="n">line</code><code class="p">);</code>
                <code class="p">}</code>
            <code class="p">}</code>
        <code class="p">}</code>
        <code class="n">observer</code><code class="p">.</code><code class="n">OnCompleted</code><code class="p">();</code>
        <code class="k">return</code> <code class="n">NullDisposable</code><code class="p">.</code><code class="n">Instance</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">private</code> <code class="k">class</code> <code class="nc">NullDisposable</code> <code class="p">:</code> <code class="n">IDisposable</code>
    <code class="p">{</code>
        <code class="k">public</code> <code class="k">static</code> <code class="n">NullDisposable</code> <code class="n">Instance</code> <code class="p">=</code> <code class="k">new</code><code class="p">();</code>
        <code class="k">public</code> <code class="k">void</code> <code class="nf">Dispose</code><code class="p">()</code> <code class="p">{</code> <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>As before, this does not represent a live source of events, and it leaps into action only when something subscribes, but it’s a little more interesting than <a data-type="xref" href="#a_simple_cold_observable_source">Example 11-3</a>. This calls into the observer as and when it retrieves each line from a file, so although the point at which it starts doing its work is determined by the subscriber, this source is in control of the rate at which it provides values. Just like <a data-type="xref" href="#a_simple_cold_observable_source">Example 11-3</a>, this delivers all the items to the observer on the caller’s thread inside the call to <code>Subscribe</code>, but it would be a relatively small conceptual leap from <a data-type="xref" href="#file_cold_observable">Example 11-5</a> to one in which the code reading from the file either ran on a separate thread or used asynchronous techniques (such as those described in <a data-type="xref" href="ch17.xhtml#ch_asynchronous_language_features">Chapter 17</a>), thus enabling <code>Subscribe</code> to return before the work is complete (at which point you’d need to write a more interesting <code>IDisposable</code> implementation to enable callers to unsubscribe). This would still be a cold source, because it represents some underlying set of data that it can enumerate from the start for the benefit of each individual subscriber.</p>
<p><a data-type="xref" href="#file_cold_observable">Example 11-5</a> is not quite complete—it fails to handle errors that occur while reading from the file. We need to catch these and call the observer’s <code>OnError</code> method. Unfortunately, it’s not quite as simple as wrapping the whole loop in a <code>try</code> block, because that would also catch exceptions that emerged from the observer’s <code>OnNext</code> method. If that throws an exception, we should allow it to carry on up the stack—we should handle only exceptions that emerge from the places we expect in our code. Unfortunately, this rather complicates the code. <a data-type="xref" href="#handling_filesystem_errors">Example 11-6</a> puts all the code that uses <code>FileStream</code> inside a <code>try</code> block but will allow any exceptions thrown by the observer to propagate up the stack, because it’s not up to us to handle those.</p>
<div data-type="example" id="handling_filesystem_errors">
<h5><span class="label">Example 11-6. </span>Handling filesystem errors but not observer errors</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="n">IDisposable</code> <code class="nf">Subscribe</code><code class="p">(</code><code class="n">IObserver</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">observer</code><code class="p">)</code>
<code class="p">{</code>
    <code class="n">StreamReader</code><code class="p">?</code> <code class="n">sr</code> <code class="p">=</code> <code class="k">null</code><code class="p">;</code>
    <code class="kt">string?</code> <code class="n">line</code> <code class="p">=</code> <code class="k">null</code><code class="p">;</code>
    <code class="kt">bool</code> <code class="n">failed</code> <code class="p">=</code> <code class="k">false</code><code class="p">;</code>

    <code class="k">try</code>
    <code class="p">{</code>
        <code class="k">while</code> <code class="p">(</code><code class="k">true</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="k">try</code>
            <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="n">sr</code> <code class="p">==</code> <code class="k">null</code><code class="p">)</code>
                <code class="p">{</code>
                    <code class="n">sr</code> <code class="p">=</code> <code class="k">new</code> <code class="n">StreamReader</code><code class="p">(</code><code class="n">_path</code><code class="p">);</code>
                <code class="p">}</code>
                <code class="k">if</code> <code class="p">(</code><code class="n">sr</code><code class="p">.</code><code class="n">EndOfStream</code><code class="p">)</code>
                <code class="p">{</code>
                    <code class="k">break</code><code class="p">;</code>
                <code class="p">}</code>
                <code class="n">line</code> <code class="p">=</code> <code class="n">sr</code><code class="p">.</code><code class="n">ReadLine</code><code class="p">();</code>
            <code class="p">}</code>
            <code class="k">catch</code> <code class="p">(</code><code class="n">IOException</code> <code class="n">x</code><code class="p">)</code>
            <code class="p">{</code>
                <code class="n">observer</code><code class="p">.</code><code class="n">OnError</code><code class="p">(</code><code class="n">x</code><code class="p">);</code>
                <code class="n">failed</code> <code class="p">=</code> <code class="k">true</code><code class="p">;</code>
                <code class="k">break</code><code class="p">;</code>
            <code class="p">}</code>

            <code class="k">if</code> <code class="p">(</code><code class="n">line</code> <code class="k">is</code> <code class="n">not</code> <code class="k">null</code><code class="p">)</code>
            <code class="p">{</code>
                <code class="n">observer</code><code class="p">.</code><code class="n">OnNext</code><code class="p">(</code><code class="n">line</code><code class="p">);</code>
            <code class="p">}</code>
            <code class="k">else</code>
            <code class="p">{</code>
                <code class="k">break</code><code class="p">;</code>
            <code class="p">}</code>
        <code class="p">}</code>
    <code class="p">}</code>
    <code class="k">finally</code>
    <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="n">sr</code> <code class="p">!=</code> <code class="k">null</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="n">sr</code><code class="p">.</code><code class="n">Dispose</code><code class="p">();</code>
        <code class="p">}</code>
    <code class="p">}</code>
    <code class="k">if</code> <code class="p">(!</code><code class="n">failed</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">observer</code><code class="p">.</code><code class="n">OnCompleted</code><code class="p">();</code>
    <code class="p">}</code>
    <code class="k">return</code> <code class="n">NullDisposable</code><code class="p">.</code><code class="n">Instance</code><code class="p">;</code>
<code class="p">}</code></pre></div>
<p>If I/O exceptions occur while reading from the file, this reports them to the observer’s <code>OnError</code> method—so this source uses all three of the <code>IObserver&lt;T&gt;</code> methods.<a data-startref="ix_ch11-asciidoc7" data-type="indexterm" id="idm45884801388176"/><a data-startref="ix_ch11-asciidoc6" data-type="indexterm" id="idm45884801387568"/></p>
</div></section>
<section data-pdf-bookmark="Implementing hot sources" data-type="sect3"><div class="sect3" id="implementing_hot_sources">
<h3>Implementing hot sources</h3>
<p><a data-primary="hot observables" data-secondary="implementing" data-type="indexterm" id="ix_ch11-asciidoc8"/><a data-primary="IObservable&lt;T&gt; interface" data-secondary="implementing hot sources" data-type="indexterm" id="ix_ch11-asciidoc9"/>Hot sources notify all current subscribers of values as they become available. This means that any hot observable must keep track of which observers are currently subscribed. Subscription and notification are separated out with hot sources in a way that they usually aren’t with cold ones.</p>
<p><a data-type="xref" href="#keypress_monitor_iobservable">Example 11-7</a> is an observable source that reports a single item for each keypress, and it’s a particularly simple source as hot ones go. It’s single-threaded, so it doesn’t need to do anything special to avoid overlapping calls. It doesn’t report errors, so it never needs to call observers’ <code>OnError</code> methods. And it never stops, so it doesn’t need to call <code>OnCompleted</code> either. Even so, it’s quite involved. (Things will get much simpler once I introduce the Rx library support—this example is relatively complex because for now, I’m sticking with just the two fundamental interfaces.)</p>
<div data-type="example" id="keypress_monitor_iobservable">
<h5><span class="label">Example 11-7. </span><code>IObservable&lt;T&gt;</code> for monitoring keypresses</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">KeyWatcher</code> <code class="p">:</code> <code class="n">IObservable</code><code class="p">&lt;</code><code class="kt">char</code><code class="p">&gt;</code>
<code class="p">{</code>
    <code class="k">private</code> <code class="k">readonly</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Subscription</code><code class="p">&gt;</code> <code class="n">_subscriptions</code> <code class="p">=</code> <code class="k">new</code><code class="p">();</code>

    <code class="k">public</code> <code class="n">IDisposable</code> <code class="nf">Subscribe</code><code class="p">(</code><code class="n">IObserver</code><code class="p">&lt;</code><code class="kt">char</code><code class="p">&gt;</code> <code class="n">observer</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="kt">var</code> <code class="n">sub</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Subscription</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="n">observer</code><code class="p">);</code>
        <code class="n">_subscriptions</code><code class="p">.</code><code class="n">Add</code><code class="p">(</code><code class="n">sub</code><code class="p">);</code>
        <code class="k">return</code> <code class="n">sub</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">public</code> <code class="k">void</code> <code class="nf">Run</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="k">while</code> <code class="p">(</code><code class="k">true</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="c1">// Passing true here stops the console from showing the character</code>
            <code class="kt">char</code> <code class="n">c</code> <code class="p">=</code> <code class="n">Console</code><code class="p">.</code><code class="n">ReadKey</code><code class="p">(</code><code class="k">true</code><code class="p">).</code><code class="n">KeyChar</code><code class="p">;</code>

            <code class="c1">// ToArray duplicates the list, enabling us to iterate over a</code>
            <code class="c1">// snapshot of our subscribers. This handles the case where an</code>
            <code class="c1">// observer unsubscribes from inside its OnNext method.</code>
            <code class="k">foreach</code> <code class="p">(</code><code class="n">Subscription</code> <code class="n">sub</code> <code class="k">in</code> <code class="n">_subscriptions</code><code class="p">.</code><code class="n">ToArray</code><code class="p">())</code>
            <code class="p">{</code>
                <code class="n">sub</code><code class="p">.</code><code class="n">Observer</code><code class="p">.</code><code class="n">OnNext</code><code class="p">(</code><code class="n">c</code><code class="p">);</code>
            <code class="p">}</code>
        <code class="p">}</code>
    <code class="p">}</code>

    <code class="k">private</code> <code class="k">void</code> <code class="nf">RemoveSubscription</code><code class="p">(</code><code class="n">Subscription</code> <code class="n">sub</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">_subscriptions</code><code class="p">.</code><code class="n">Remove</code><code class="p">(</code><code class="n">sub</code><code class="p">);</code>
    <code class="p">}</code>

    <code class="k">private</code> <code class="k">class</code> <code class="nc">Subscription</code> <code class="p">:</code> <code class="n">IDisposable</code>
    <code class="p">{</code>
        <code class="k">private</code> <code class="n">KeyWatcher</code><code class="p">?</code> <code class="n">_parent</code><code class="p">;</code>
        <code class="k">public</code> <code class="nf">Subscription</code><code class="p">(</code><code class="n">KeyWatcher</code> <code class="n">parent</code><code class="p">,</code> <code class="n">IObserver</code><code class="p">&lt;</code><code class="kt">char</code><code class="p">&gt;</code> <code class="n">observer</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="n">_parent</code> <code class="p">=</code> <code class="n">parent</code><code class="p">;</code>
            <code class="n">Observer</code> <code class="p">=</code> <code class="n">observer</code><code class="p">;</code>
        <code class="p">}</code>

        <code class="k">public</code> <code class="n">IObserver</code><code class="p">&lt;</code><code class="kt">char</code><code class="p">&gt;</code> <code class="n">Observer</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="p">}</code>

        <code class="k">public</code> <code class="k">void</code> <code class="nf">Dispose</code><code class="p">()</code>
        <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="n">_parent</code> <code class="k">is</code> <code class="n">not</code> <code class="k">null</code><code class="p">)</code>
            <code class="p">{</code>
                <code class="n">_parent</code><code class="p">.</code><code class="n">RemoveSubscription</code><code class="p">(</code><code class="k">this</code><code class="p">);</code>
                <code class="n">_parent</code> <code class="p">=</code> <code class="k">null</code><code class="p">;</code>
            <code class="p">}</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>This defines a nested class called <code>Subscription</code> to keep track of each observer that subscribes, and this also provides the implementation of <code>IDisposable</code> that our <code>Subscribe</code> method is required to return. The observable creates a new instance of this nested class and adds it to a list of current subscribers during <code>Subscribe</code>, and then if <code>Dispose</code> is called, it removes itself from that list.</p>
<p>As a general rule in .NET, you should <code>Dispose</code> any <code>IDisposable</code> resources allocated on your behalf when you’ve finished using them. However, in Rx, it is common not to dispose objects representing subscriptions, so if you implement such an object, you should not count on it being disposed. It’s typically unnecessary, because Rx can clean up for you. Unlike with ordinary .NET events or delegates, observables can unambiguously come to an end, at which point any resources allocated to subscribers can be freed. (Some run indefinitely, but in that case, subscriptions usually remain active for the life of the program.) Admittedly, the examples I’ve shown so far don’t clean up automatically, because I’ve provided my own implementations that are simple enough not to need to, but the Rx libraries do if you use their source and subscriber implementations. The only time you’d normally dispose of a subscription in Rx is if you want to unsubscribe before the source completes.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Subscribers are not obliged to ensure that the <code>object</code> returned by <code>Subscribe</code> remains reachable. You can ignore it if you don’t need the ability to unsubscribe early, and it won’t matter if the garbage collector frees the object, because none of the <code>IDisposable</code> implementations that Rx supplies to represent subscriptions have finalizers. (And although you don’t normally implement these yourself—I’m doing so here only to illustrate how it works—if you did decide to write your own, take the same approach: do not implement a finalizer on a class that represents a subscription.)</p>
</div>
<p>The <code>KeyWatcher</code> class in <a data-type="xref" href="#keypress_monitor_iobservable">Example 11-7</a> has a <code>Run</code> method. That’s not a standard Rx feature; it’s just a loop that sits and waits for keyboard input—this observable won’t actually produce any notifications unless something calls that method. Each time this loop receives a key, it calls the <code>OnNext</code> method on every currently subscribed observer. Notice that I’m building a copy of the subscriber list (by calling <code>ToArray</code>—that’s a simple way to get a <code>List&lt;T&gt;</code> to duplicate its contents), because there’s every possibility that a subscriber might choose to unsubscribe in the middle of a call to <code>OnNext</code>. If I had passed the subscriber list directly to <code>foreach</code>, I would get an exception in this scenario, because lists don’t allow items to be added and removed if you’re in the middle of iterating through them.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>This example only guards against re-entrant calls on the same thread; handling multithreaded unsubscription would be altogether more complex. In fact, even building a copy is not sufficiently paranoid. I should really be checking that each observer in my snapshot is still currently subscribed before calling its <code>OnNext</code>, because it’s possible that one observer might choose to unsubscribe some other observer. This also makes no attempt to deal with unsubscription from another thread. Later on, I’ll replace all of this with a much more robust implementation from the Rx library.</p>
</div>
<p>In use, this hot source is very similar to my cold sources. We need to create an instance of the <code>KeyWatcher</code> and also another instance of my observer class (with a type argument of <code>char</code> this time, because this source produces characters instead of strings). Because this source does not generate items until its monitoring loop runs, I need to call <code>Run</code> to kick it off, as <a data-type="xref" href="#attaching_an_observer">Example 11-8</a> does.</p>
<div data-type="example" id="attaching_an_observer">
<h5><span class="label">Example 11-8. </span>Attaching an observer to an observable</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">source</code> <code class="p">=</code> <code class="k">new</code> <code class="n">KeyWatcher</code><code class="p">();</code>
<code class="kt">var</code> <code class="n">sub</code> <code class="p">=</code> <code class="k">new</code> <code class="n">MySubscriber</code><code class="p">&lt;</code><code class="kt">char</code><code class="p">&gt;();</code>
<code class="n">source</code><code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="n">sub</code><code class="p">);</code>
<code class="n">source</code><code class="p">.</code><code class="n">Run</code><code class="p">();</code></pre></div>
<p>Running that code, the application will wait for keyboard input, and if you press, say, the <em>m</em> key, the observer (<a data-type="xref" href="#simple_iobserver_implementation">Example 11-2</a>) will display the message <code>Received: m</code>. (And since my source never ends, the <code>Run</code> method will never return.)</p>
<p>You might need to deal with a mixture of hot and cold observables. Also, some cold sources have some hot characteristics. For example, you could imagine a source that represented alert messages, and it might make sense to implement that in such a way that it stored alerts, to make sure you didn’t miss anything that happens in between creating the source and attaching a subscriber. So it would be a cold source—any new subscriber would get all the events so far—but once a subscriber has caught up, the ongoing behavior would look more like a hot source, because any new events would be broadcast to all current subscribers. As you’ll see, the Rx libraries provide various ways to mix and adapt between the two types of sources.<a data-startref="ix_ch11-asciidoc9" data-type="indexterm" id="idm45884800959696"/><a data-startref="ix_ch11-asciidoc8" data-type="indexterm" id="idm45884800958992"/></p>
<p>While it’s useful to see what observers and observables need to do, it’s more productive to let Rx take care of the grunt work, so now I’ll show how you would write sources and subscribers if you were using the <code>System.Reactive</code> NuGet library instead of just the two fundamental interfaces<a data-startref="ix_ch11-asciidoc5" data-type="indexterm" id="idm45884800957280"/><a data-startref="ix_ch11-asciidoc4" data-type="indexterm" id="idm45884800956576"/>.<a data-startref="ix_ch11-asciidoc1" data-type="indexterm" id="idm45884800943424"/></p>
</div></section>
</div></section>
</div></section>
<section data-pdf-bookmark="Publishing and Subscribing with Delegates" data-type="sect1"><div class="sect1" id="publishing_and_subscribing_with_delegate">
<h1>Publishing and Subscribing with Delegates</h1>
<p><a data-primary="delegates" data-secondary="publishing and subscribing with" data-type="indexterm" id="ix_ch11-asciidoc10"/><a data-primary="reactive extensions (Rx)" data-secondary="publishing and subscribing with delegates" data-type="indexterm" id="ix_ch11-asciidoc11"/>If you use the <code>System.Reactive</code> NuGet package, you do not need to implement either <code>IObservable&lt;T&gt;</code> or <code>IObserver&lt;T&gt;</code> directly. The library provides several implementations. Some of these are adapters, bridging between Rx and other representations of asynchronously generated sequences. Some wrap existing observable streams. But the helpers aren’t just for adapting existing things. They can also help if you want to write code that originates new items or that acts as the final destination for items. The simplest of these helpers provide delegate-based APIs for creating and consuming observable streams.</p>
<section data-pdf-bookmark="Creating an Observable Source with Delegates" data-type="sect2"><div class="sect2" id="creating_an_observable_source_with_deleg">
<h2>Creating an Observable Source with Delegates</h2>
<p><a data-primary="delegates" data-secondary="creating an observable source with" data-type="indexterm" id="ix_ch11-asciidoc12"/>As you have seen in some of the preceding examples, although <code>IObservable&lt;T&gt;</code> is a simple interface, sources that implement it may have to do a fair amount of work to track subscribers. And we’ve not even seen the whole story yet. As you’ll see in <a data-type="xref" href="#schedulers">“Schedulers”</a>, a source often needs to take extra measures to ensure that it integrates well with Rx’s threading mechanisms. Fortunately, the Rx libraries can do some of that work for us. <a data-type="xref" href="#delegate-based_observable_source">Example 11-9</a> shows how to use the <code>Observable</code> class’s static <code>Create</code> method to implement a cold source. (Each call to <code>GetFilePusher</code> will create a new source, so this is effectively a factory method.)</p>
<div data-type="example" id="delegate-based_observable_source">
<h5><span class="label">Example 11-9. </span>Delegate-based observable source</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">static</code> <code class="n">IObservable</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">GetFilePusher</code><code class="p">(</code><code class="kt">string</code> <code class="n">path</code><code class="p">)</code>
<code class="p">{</code>
    <code class="k">return</code> <code class="n">Observable</code><code class="p">.</code><code class="n">Create</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;(</code><code class="n">observer</code> <code class="p">=&gt;</code>
    <code class="p">{</code>
        <code class="k">using</code> <code class="p">(</code><code class="kt">var</code> <code class="n">sr</code> <code class="p">=</code> <code class="k">new</code> <code class="n">StreamReader</code><code class="p">(</code><code class="n">path</code><code class="p">))</code>
        <code class="p">{</code>
            <code class="k">while</code> <code class="p">(!</code><code class="n">sr</code><code class="p">.</code><code class="n">EndOfStream</code><code class="p">)</code>
            <code class="p">{</code>
                <code class="kt">string?</code> <code class="n">line</code> <code class="p">=</code> <code class="n">sr</code><code class="p">.</code><code class="n">ReadLine</code><code class="p">();</code>
                <code class="k">if</code> <code class="p">(</code><code class="n">line</code> <code class="k">is</code> <code class="n">not</code> <code class="k">null</code><code class="p">)</code>
                <code class="p">{</code>
                    <code class="n">observer</code><code class="p">.</code><code class="n">OnNext</code><code class="p">(</code><code class="n">line</code><code class="p">);</code>
                <code class="p">}</code>
                <code class="k">else</code>
                <code class="p">{</code>
                    <code class="k">break</code><code class="p">;</code>
                <code class="p">}</code>
            <code class="p">}</code>
        <code class="p">}</code>
        <code class="n">observer</code><code class="p">.</code><code class="n">OnCompleted</code><code class="p">();</code>
        <code class="k">return</code> <code class="p">()</code> <code class="p">=&gt;</code> <code class="p">{</code> <code class="p">};</code>
    <code class="p">});</code>
<code class="p">}</code></pre></div>
<p>This serves the same purpose as <a data-type="xref" href="#file_cold_observable">Example 11-5</a>—it provides an observable source that supplies each line in a file in turn to subscribers. (As with <a data-type="xref" href="#file_cold_observable">Example 11-5</a>, I’ve left out error handling for clarity. In practice, you’d need to report errors in the same way as <a data-type="xref" href="#handling_filesystem_errors">Example 11-6</a>.) The heart of the code is the same, but I’ve been able to write just a single method instead of a whole class, because Rx is now providing the <code>IObserva⁠ble​&lt;T&gt;</code> implementation. Each time an observer subscribes to that observable, Rx calls the callback I passed to <code>Create</code>. So all I have to do is write the code that provides the items. As well as not needing the outer class implementing <code>IObservable&lt;T&gt;</code>, I’ve also been able to omit the nested class that implements <code>IDisposable</code>—the <code>Create</code> method allows us to return an <code>Action</code> delegate instead of an object, and it will invoke that if the subscriber chooses to unsubscribe. Since my method doesn’t return until after it has finished producing items, there’s nothing useful I can do, so I’ve just returned an empty method.</p>
<p>I’ve written rather less code than in <a data-type="xref" href="#file_cold_observable">Example 11-5</a>, but as well as simplifying my implementation, <code>Observable.Create</code> does two more slightly subtle things for us that are not immediately apparent from the code.</p>
<p>First, if a subscriber unsubscribes early, this code will now correctly stop sending it items, even though I’ve written no code to handle that. When an observer subscribes to a source of this kind, Rx does not pass the <code>IObserver&lt;T&gt;</code> directly to our callback. The <span class="keep-together"><code>observer</code></span> argument in the nested method in <a data-type="xref" href="#delegate-based_observable_source">Example 11-9</a> refers to an Rx-supplied wrapper. If the underlying observer unsubscribes, that wrapper automatically stops forwarding notifications. My loop will carry on running through the file even after the subscriber stops listening, which is wasteful, but at least the subscriber doesn’t get items after it has asked me to stop. (You may be wondering how the subscriber even gets a chance to unsubscribe, given that my code doesn’t return until it has finished. It could do this in its <code>OnNext</code> method.)</p>
<p>You can use Rx in conjunction with the C# asynchronous language features (specifically, the <code>async</code> and <code>await</code> keywords) to implement a version of <a data-type="xref" href="#delegate-based_observable_source">Example 11-9</a> that not only handles unsubscription more efficiently but also reads from the file asynchronously, meaning subscription does not need to block. This is significantly more efficient, and yet the code is almost identical. I won’t be introducing the asynchronous language features until <a data-type="xref" href="ch17.xhtml#ch_asynchronous_language_features">Chapter 17</a>, so this might not make complete sense yet, but if you’re curious, <a data-type="xref" href="#an_asynchronous_source">Example 11-10</a> shows how it looks. The modified lines are in bold. (Again, this is the version without error handling. Asynchronous methods can handle exceptions in much the same way as synchronous ones, so you could manage errors with the same approach as <a data-type="xref" href="#handling_filesystem_errors">Example 11-6</a>.)</p>
<div class="pagebreak-before less_space" data-type="example" id="an_asynchronous_source">
<h5><span class="label">Example 11-10. </span>An asynchronous source</h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="k">public</code><code> </code><code class="k">static</code><code> </code><code class="n">IObservable</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code><code> </code><code class="n">GetFilePusher</code><code class="p">(</code><code class="kt">string</code><code> </code><code class="n">path</code><code class="p">)</code><code>
</code><code class="p">{</code><code>
</code><code>    </code><strong><code class="k">return</code><code> </code><code class="n">Observable</code><code class="p">.</code><code class="n">Create</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code><code class="p">(</code><code class="k">async</code><code> </code><code class="p">(</code><code class="n">observer</code><code class="p">,</code><code> </code><code class="n">cancel</code><code class="p">)</code><code> </code><code class="p">=</code><code class="p">&gt;</code></strong><code>
</code><code>    </code><code class="p">{</code><code>
</code><code>        </code><code class="k">using</code><code> </code><code class="p">(</code><code class="kt">var</code><code> </code><code class="n">sr</code><code> </code><code class="p">=</code><code> </code><code class="k">new</code><code> </code><code class="n">StreamReader</code><code class="p">(</code><code class="n">path</code><code class="p">)</code><code class="p">)</code><code>
</code><code>        </code><code class="p">{</code><code>
</code><code>            </code><strong><code class="k">while</code><code> </code><code class="p">(</code><code class="p">!</code><code class="n">sr</code><code class="p">.</code><code class="n">EndOfStream</code><code> </code><code class="p">&amp;</code><code class="p">&amp;</code><code> </code><code class="p">!</code><code class="n">cancel</code><code class="p">.</code><code class="n">IsCancellationRequested</code><code class="p">)</code></strong><code>
</code><code>            </code><code class="p">{</code><code>
</code><code>                </code><strong><code class="kt">string?</code><code> </code><code class="n">line</code><code> </code><code class="p">=</code><code> </code><code class="k">await</code><code> </code><code class="n">sr</code><code class="p">.</code><code class="n">ReadLineAsync</code><code class="p">(</code><code class="p">)</code><code class="p">;</code></strong><code>
</code><code>                </code><code class="k">if</code><code> </code><code class="p">(</code><code class="n">line</code><code> </code><code class="k">is</code><code> </code><code class="n">not</code><code> </code><code class="k">null</code><code class="p">)</code><code>
</code><code>                </code><code class="p">{</code><code>
</code><code>                    </code><code class="n">observer</code><code class="p">.</code><code class="n">OnNext</code><code class="p">(</code><code class="n">line</code><code class="p">)</code><code class="p">;</code><code>
</code><code>                </code><code class="p">}</code><code>
</code><code>                </code><code class="k">else</code><code>
</code><code>                </code><code class="p">{</code><code>
</code><code>                    </code><code class="k">break</code><code class="p">;</code><code>
</code><code>                </code><code class="p">}</code><code>
</code><code>            </code><code class="p">}</code><code>
</code><code>        </code><code class="p">}</code><code>
</code><code>        </code><code class="n">observer</code><code class="p">.</code><code class="n">OnCompleted</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code>
</code><code>    </code><code class="p">}</code><code class="p">)</code><code class="p">;</code><code>
</code><code class="p">}</code></pre></div>
<p>The second thing <code>Observable.Create</code> does for us under the covers is that in certain circumstances, it will use Rx’s scheduler system to call our code via a work queue instead of invoking it directly. This avoids possible deadlocks in cases where you’ve chained multiple observables together. I will be describing schedulers later in this chapter.</p>
<p>This technique is good for cold sources such as <a data-type="xref" href="#delegate-based_observable_source">Example 11-9</a>. Hot sources work differently, broadcasting live events to all subscribers, and <code>Observable.Create</code> does not cater to them directly because it invokes the delegate you pass once for each subscriber. However, the Rx libraries can still help.</p>
<p>Rx provides a <code>Publish</code> extension method for any <code>IObservable&lt;T&gt;</code>, defined by the <code>Observable</code> class in the <code>System.Reactive.Linq</code> namespace. This method is designed to wrap a source whose subscription method (i.e., the delegate you pass to <code>Observa⁠ble​.Create</code>) supports being run only once but to which you want to attach multiple subscribers—it handles the multicast logic for you. Strictly speaking, a source that supports only a single subscription is degenerate, but as long as you hide it behind <code>Publish</code>, it doesn’t matter, and you can use this as a way to implement a hot source. <a data-type="xref" href="#delegate-based_hot_source">Example 11-11</a> shows how to create a source that provides the same functionality as the <code>KeyWatcher</code> in <a data-type="xref" href="#keypress_monitor_iobservable">Example 11-7</a>. I’ve also hooked up two subscribers, just to illustrate the point that this supports multiple subscribers.</p>
<div data-type="example" id="delegate-based_hot_source">
<h5><span class="label">Example 11-11. </span>Delegate-based hot source</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">IObservable</code><code class="p">&lt;</code><code class="kt">char</code><code class="p">&gt;</code> <code class="n">singularHotSource</code> <code class="p">=</code> <code class="n">Observable</code><code class="p">.</code><code class="n">Create</code><code class="p">(</code>
    <code class="p">(</code><code class="n">Func</code><code class="p">&lt;</code><code class="n">IObserver</code><code class="p">&lt;</code><code class="kt">char</code><code class="p">&gt;,</code> <code class="n">IDisposable</code><code class="p">&gt;)</code> <code class="p">(</code><code class="n">obs</code> <code class="p">=&gt;</code>
    <code class="p">{</code>
        <code class="k">while</code> <code class="p">(</code><code class="k">true</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="n">obs</code><code class="p">.</code><code class="n">OnNext</code><code class="p">(</code><code class="n">Console</code><code class="p">.</code><code class="n">ReadKey</code><code class="p">(</code><code class="k">true</code><code class="p">).</code><code class="n">KeyChar</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">}));</code>

<code class="n">IConnectableObservable</code><code class="p">&lt;</code><code class="kt">char</code><code class="p">&gt;</code> <code class="n">keySource</code> <code class="p">=</code> <code class="n">singularHotSource</code><code class="p">.</code><code class="n">Publish</code><code class="p">();</code>

<code class="n">keySource</code><code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="k">new</code> <code class="n">MySubscriber</code><code class="p">&lt;</code><code class="kt">char</code><code class="p">&gt;());</code>
<code class="n">keySource</code><code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="k">new</code> <code class="n">MySubscriber</code><code class="p">&lt;</code><code class="kt">char</code><code class="p">&gt;());</code>

<code class="n">keySource</code><code class="p">.</code><code class="n">Connect</code><code class="p">();</code></pre></div>
<p>The <code>Publish</code> method does not call <code>Subscribe</code> on the source immediately. Nor does it do so when you first attach a subscriber to the source it returns. I have to tell the published source when I want it to start. Notice that <code>Publish</code> returns an <code>IConnectableObservable&lt;T&gt;</code>. This derives from <code>IObservable&lt;T&gt;</code> and adds a single extra method, <code>Connect</code>. This interface represents a source that doesn’t start until it’s told to, and it’s designed to let you hook up all the subscribers you need before you set it running. Calling <code>Connect</code> on the source returned by <code>Publish</code> causes it to subscribe to my original source, invoking the subscription callback I passed to <code>Observable.Create</code> and running my loop. This causes the <code>Connect</code> method to have the same effect as calling <code>Run</code> on my original <a data-type="xref" href="#keypress_monitor_iobservable">Example 11-7</a>.</p>
<p><code>Connect</code> returns an <code>IDisposable</code>. This provides a way to disconnect at some later point—that is, to unsubscribe from the underlying source. (If you don’t call this, the connectable observable returned by <code>Publish</code> will remain subscribed to your source even if you <code>Dispose</code> each of the individual downstream subscriptions.) In this particular example, the call to <code>Connect</code> will never return, because the code I passed to <code>Observable.Create</code> also never returns. Most observable sources don’t do this. Typically, they avoid it by using either asynchronous or scheduler-based techniques, which I will show later in this chapter.</p>
<p>The combination of the delegate-based <code>Observable.Create</code> and the multicasting offered by <code>Publish</code> has enabled me to throw away everything in <a data-type="xref" href="#keypress_monitor_iobservable">Example 11-7</a> except for the loop that actually generates items, and even that has become simpler. Being able to remove about 80% of the code isn’t the whole story, either. This will work better—<code>Publish</code> lets Rx handle my subscribers, which will deal correctly with the awkward situations in which subscribers unsubscribe while being notified.</p>
<p>Of course, the Rx libraries don’t just help with implementing sources. They can simplify subscribers too.<a data-startref="ix_ch11-asciidoc12" data-type="indexterm" id="idm45884800452592"/></p>
</div></section>
<section data-pdf-bookmark="Subscribing to an Observable Source with Delegates" data-type="sect2"><div class="sect2" id="subscribing_to_an_observable_source_with">
<h2>Subscribing to an Observable Source with Delegates</h2>
<p><a data-primary="delegates" data-secondary="subscribing to an observable source with" data-type="indexterm" id="idm45884800450208"/>Just as you don’t have to implement <code>IObservable&lt;T&gt;</code>, it’s also not necessary to provide an implementation of <code>IObserver&lt;T&gt;</code>. You won’t always care about all three methods—the <code>KeyWatcher</code> observable in <a data-type="xref" href="#keypress_monitor_iobservable">Example 11-7</a> never even calls the 
<span class="keep-together"><code>OnCompleted</code></span> or <code>OnError</code> methods, because it runs indefinitely and has no error detection. Even when you do need to provide all three methods, you won’t necessarily want to write a whole separate type to provide them. So the Rx libraries provide extension methods to simplify subscription, defined by the <code>ObservableExtensions</code> class in the <code>System</code> namespace. Most C# source files include a <code>using System;</code> directive, or are in a project with an implicit global <code>using</code> directive for <code>System</code>, so the extensions it offers will usually be available as long as your project has a reference to the <code>System​.Reac⁠tive</code> NuGet package. There are several overloads for the <code>Subscribe</code> method available for any <code class="keep-together">IObservable&lt;T&gt;</code>. <a data-type="xref" href="#subscribing_without_iobserver">Example 11-12</a> uses one of them.</p>
<div data-type="example" id="subscribing_without_iobserver">
<h5><span class="label">Example 11-12. </span>Subscribing without implementing <code>IObserver&lt;T&gt;</code></h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="kt">var</code><code> </code><code class="n">source</code><code> </code><code class="p">=</code><code> </code><code class="k">new</code><code> </code><code class="n">KeyWatcher</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code>
</code><strong><code class="n">source</code><code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="k">value</code><code> </code><code class="p">=</code><code class="p">&gt;</code><code> </code><code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Received: "</code><code> </code><code class="p">+</code><code> </code><code class="k">value</code><code class="p">)</code><code class="p">)</code><code class="p">;</code></strong><code>
</code><code class="n">source</code><code class="p">.</code><code class="n">Run</code><code class="p">(</code><code class="p">)</code><code class="p">;</code></pre></div>
<p>This example has the same effect as <a data-type="xref" href="#attaching_an_observer">Example 11-8</a>. However, by using this approach, we no longer need to write a whole class implementing <code>IObserver&lt;T&gt;</code> like <a data-type="xref" href="#simple_iobserver_implementation">Example 11-2</a>. With this <code>Subscribe</code> extension method, Rx provides the <code>IObserver&lt;T&gt;</code> implementation for us, and we provide methods only for the notifications we want.</p>
<p>The <code>Subscribe</code> overload used by <a data-type="xref" href="#subscribing_without_iobserver">Example 11-12</a> takes an <code>Action&lt;T&gt;</code>, where <code>T</code> is the item type of the <code>IObservable&lt;T&gt;</code>, which in this case is <code>char</code>. My source doesn’t provide error notifications, nor does it use <code>OnCompleted</code> to indicate the end of the items, but plenty of sources do, so there are three overloads of <code>Subscribe</code> to handle that. One takes an extra delegate of type <code>Action&lt;Exception&gt;</code> to handle errors. Another takes a second delegate of type <code>Action</code> (i.e., one that takes no arguments) to handle the completion notification. The third overload takes three delegates—the same per-item callback that they all take, and then an exception handler and a completion <span class="keep-together">handler.</span></p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a data-primary="IObservable&lt;T&gt; interface" data-secondary="exception throwing" data-type="indexterm" id="idm45884800370944"/>If you do not provide an exception handler when using delegate-based subscription, but the source calls <code>OnError</code>, the <code>IObserver&lt;T&gt;</code> Rx supplies throws the exception to keep the error from going unnoticed. <a data-type="xref" href="#file_cold_observable">Example 11-5</a> calls <code>OnError</code> in the <code>catch</code> block where it handles I/O exceptions, and if you subscribed using the technique in <a data-type="xref" href="#subscribing_without_iobserver">Example 11-12</a>, you’d find that the call to <code>OnError</code> throws the <code>IOException</code> right back out again—the same exception is then thrown twice in a row, once by the <code>StreamReader</code> and then again by the Rx-supplied <code>IObserver&lt;T&gt;</code> implementation. Since we’d already be in the <code>catch</code> block in <a data-type="xref" href="#file_cold_observable">Example 11-5</a> by this time (and not the <code>try</code> block), this second throw would cause the exception to emerge from the <code>Subscribe</code> method, either to be handled farther up the stack or crashing the application.</p>
</div>
<p>There’s one more overload of the <code>Subscribe</code> extension method, taking no arguments. This subscribes to a source and then does nothing with the items it receives. (It will throw any errors back to the source, just like the other overloads that don’t take an error callback.) This would be useful if you have a source that does something important as a side effect of subscription, although it’s probably best to avoid designs where that’s necessary.<a data-startref="ix_ch11-asciidoc11" data-type="indexterm" id="idm45884800361328"/><a data-startref="ix_ch11-asciidoc10" data-type="indexterm" id="idm45884800360624"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Sequence Builders" data-type="sect1"><div class="sect1" id="sequence_builders">
<h1>Sequence Builders</h1>
<p><a data-primary="Observable class" data-type="indexterm" id="ix_ch11-asciidoc14a"/><a data-primary="reactive extensions (Rx)" data-secondary="sequence builders" data-type="indexterm" id="ix_ch11-asciidoc13"/><a data-primary="sequence builders, Rx" data-type="indexterm" id="ix_ch11-asciidoc14"/>Rx defines several methods that create new sequences from scratch, without requiring either custom types or callbacks. These are designed for certain simple scenarios such as single-element sequences, empty sequences, or particular patterns. These are all static methods defined by the <code>Observable</code> class.</p>
<section data-pdf-bookmark="Empty" data-type="sect2"><div class="sect2" id="rx_empty">
<h2>Empty</h2>
<p><a data-primary="sequence builders, Rx" data-secondary="Empty" data-type="indexterm" id="idm45884800352464"/>The <code>Observable.Empty&lt;T&gt;</code> method is similar to the <code>Enumerable.Empty&lt;T&gt;</code> method from LINQ to Objects that I showed in <a data-type="xref" href="ch10.xhtml#ch_linq">Chapter 10</a>: it produces an empty sequence. (The difference, of course, is that it implements <code>IObservable&lt;T&gt;</code>, not <code>IEnumera⁠ble​&lt;T&gt;</code>.) As with the LINQ to Objects method, this is useful when you’re working with APIs that demand an observable source and you have no items to provide.</p>
<p>Any observer that subscribes to an <code>Observable.Empty&lt;T&gt;</code> sequence will have its <code class="keep-together">OnCompleted</code> method called immediately.</p>
</div></section>
<section data-pdf-bookmark="Never" data-type="sect2"><div class="sect2" id="rx_never">
<h2>Never</h2>
<p><a data-primary="sequence builders, Rx" data-secondary="Never" data-type="indexterm" id="idm45884800345040"/>The <code>Observable.Never&lt;T&gt;</code> method produces a sequence that never does anything—it produces no items, and unlike an empty sequence, it never even completes. (The Rx team considered calling this <code>Infinite&lt;T&gt;</code> to emphasize the fact that as well as never producing anything, it also never ends.) There is no counterpart in LINQ to Objects. If you wanted to write an <code>IEnumerable&lt;T&gt;</code> equivalent of <code>Never</code>, it would be one that blocked indefinitely when you first tried to retrieve an item. In the pull-based world of LINQ to Objects, this would not be at all useful—it would cause the calling thread to freeze for the lifetime of the process. (An <code>IAsyncEnumerable&lt;T&gt;</code> equivalent would return a <code>ValueTask&lt;bool&gt;</code> that never completes from the first call to <code>MoveNextAsync</code>. This does not need to block a thread, but you still end up with a logical operation in progress that never completes.) But in Rx’s reactive world, sources don’t block progress just because they are in a state where they’re not currently producing items, so <code>Never</code> is a less disastrous idea. It can be helpful with some of the operators I’ll show later that can use an <code>IObservable&lt;T&gt;</code> to represent duration. <code>Never</code> can represent an activity you want to run indefinitely.</p>
</div></section>
<section data-pdf-bookmark="Return" data-type="sect2"><div class="sect2" id="rx_return">
<h2>Return</h2>
<p><a data-primary="sequence builders, Rx" data-secondary="Return" data-type="indexterm" id="idm45884800337456"/>The <code>Observable.Return&lt;T&gt;</code> method takes a single argument and returns an observable sequence that immediately produces that one value and then completes. Just as <code>Empty</code> is useful when something requires a sequence and you have no items, this is useful when something requires a sequence and you have exactly one item. This is a cold source—you can subscribe to it any number of times, and each subscriber will receive the same value. There is no exact equivalent in LINQ to Objects, although the Rx team provides a library called the Interactive Extensions for .NET (or Ix for short, available in the <code>System.Interactive</code> NuGet package) that provides <code>IEnumerable&lt;T&gt;</code> versions of this and several of the other operators described in this chapter that are in Rx but not LINQ to Objects.</p>
</div></section>
<section data-pdf-bookmark="Throw" data-type="sect2"><div class="sect2" id="rx_throw">
<h2>Throw</h2>
<p><a data-primary="sequence builders, Rx" data-secondary="Throw" data-type="indexterm" id="idm45884800332624"/>The <code>Observable.Throw&lt;T&gt;</code> method takes a single argument of type <code>Exception</code> and returns an observable sequence that passes that exception to <code>OnError</code> immediately for any subscriber. Like <code>Return</code>, this is also a cold source that can be subscribed to any number of times, and it will do the same thing to each subscriber.</p>
</div></section>
<section data-pdf-bookmark="Range" data-type="sect2"><div class="sect2" id="rx_range">
<h2>Range</h2>
<p><a data-primary="sequence builders, Rx" data-secondary="Range" data-type="indexterm" id="idm45884800328016"/>The <code>Observable.Range</code> method generates a sequence of numbers. (It always returns an <code>IObservable&lt;int&gt;</code>, which is why it does not take a type argument.) Like the <code>Enumerable.Range</code> method, it takes a starting number and a count. This is a cold source that will produce the entire range for each subscriber.</p>
</div></section>
<section data-pdf-bookmark="Repeat" data-type="sect2"><div class="sect2" id="repeat">
<h2>Repeat</h2>
<p><a data-primary="sequence builders, Rx" data-secondary="Repeat" data-type="indexterm" id="idm45884800323776"/>The <code>Observable.Repeat&lt;T&gt;</code> method takes an input and produces a sequence that repeatedly produces that input over and over again. The input can be a single value, but it can also be another observable sequence, in which case it will forward items until that input completes and will then resubscribe to produce the whole sequence repeatedly. (That means that this will only genuinely repeat the data if you pass it a cold observable.)</p>
<p>If you pass no other arguments, the resulting sequence will produce values indefinitely—the only way to stop it is to unsubscribe. You can also pass a count, saying how many times you would like the input to repeat.</p>
</div></section>
<section data-pdf-bookmark="Generate" data-type="sect2"><div class="sect2" id="generate">
<h2>Generate</h2>
<p><a data-primary="sequence builders, Rx" data-secondary="Generate" data-type="indexterm" id="idm45884800319520"/>The <code>Observable.Generate&lt;TState, TResult&gt;</code> method can produce more complex sequences than the other methods I’ve just described. You provide <code>Generate</code> with an object or value representing the generator’s initial state. This can be any type you like—it’s one of the method’s generic type arguments. You must also supply three functions: one that inspects the current state to decide whether the sequence is complete yet, one that advances the state in preparation for producing the next item, and one that determines the value to produce for the current state. <a data-type="xref" href="#generating_items">Example 11-13</a> uses this to create a source that produces random numbers until the sum total of all the numbers produced exceeds 10,000.</p>
<div data-type="example" id="generating_items">
<h5><span class="label">Example 11-13. </span>Generating items</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">IObservable</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">src</code> <code class="p">=</code> <code class="n">Observable</code><code class="p">.</code><code class="n">Generate</code><code class="p">(</code>
    <code class="p">(</code><code class="n">Current</code><code class="p">:</code> <code class="m">0</code><code class="p">,</code> <code class="n">Total</code><code class="p">:</code> <code class="m">0</code><code class="p">,</code> <code class="n">Random</code><code class="p">:</code> <code class="k">new</code> <code class="n">Random</code><code class="p">()),</code>
    <code class="n">state</code> <code class="p">=&gt;</code> <code class="n">state</code><code class="p">.</code><code class="n">Total</code> <code class="p">&lt;=</code> <code class="m">10000</code><code class="p">,</code>
    <code class="n">state</code> <code class="p">=&gt;</code>
    <code class="p">{</code>
        <code class="kt">int</code> <code class="k">value</code> <code class="p">=</code> <code class="n">state</code><code class="p">.</code><code class="n">Random</code><code class="p">.</code><code class="n">Next</code><code class="p">(</code><code class="m">1000</code><code class="p">);</code>
        <code class="k">return</code> <code class="p">(</code><code class="k">value</code><code class="p">,</code> <code class="n">state</code><code class="p">.</code><code class="n">Total</code> <code class="p">+</code> <code class="k">value</code><code class="p">,</code> <code class="n">state</code><code class="p">.</code><code class="n">Random</code><code class="p">);</code>
    <code class="p">},</code>
    <code class="n">state</code> <code class="p">=&gt;</code> <code class="n">state</code><code class="p">.</code><code class="n">Current</code><code class="p">);</code></pre></div>
<p>This always produces <code>0</code> as the first item, illustrating that <code>Generate</code> calls the function that determines the current value (the final lambda in <a data-type="xref" href="#generating_items">Example 11-13</a>) before making the first call to the function that iterates the state.</p>
<p class="widows_4">You could achieve the same effect as this example by using <code>Observable.Create</code> and a loop. However, <code>Generate</code> inverts the flow of control: instead of your code sitting in a loop telling Rx when to produce the next item, Rx asks your functions for the next item. This gives Rx more flexibility over scheduling of the work. For example, it enables <code>Generate</code> to offer overloads that bring timing into the picture. <a data-type="xref" href="#generating_timed_items">Example 11-14</a> produces items in a similar way but passes an extra function as the final argument that tells Rx to delay the delivery of each item by a random amount.</p>
<div data-type="example" id="generating_timed_items">
<h5><span class="label">Example 11-14. </span>Generating timed items</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">IObservable</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">src</code> <code class="p">=</code> <code class="n">Observable</code><code class="p">.</code><code class="n">Generate</code><code class="p">(</code>
    <code class="p">(</code><code class="n">Current</code><code class="p">:</code> <code class="m">0</code><code class="p">,</code> <code class="n">Total</code><code class="p">:</code> <code class="m">0</code><code class="p">,</code> <code class="n">Random</code><code class="p">:</code> <code class="k">new</code> <code class="n">Random</code><code class="p">()),</code>
    <code class="n">state</code> <code class="p">=&gt;</code> <code class="n">state</code><code class="p">.</code><code class="n">Total</code> <code class="p">&lt;</code> <code class="m">10000</code><code class="p">,</code>
    <code class="n">state</code> <code class="p">=&gt;</code>
    <code class="p">{</code>
        <code class="kt">int</code> <code class="k">value</code> <code class="p">=</code> <code class="n">state</code><code class="p">.</code><code class="n">Random</code><code class="p">.</code><code class="n">Next</code><code class="p">(</code><code class="m">1000</code><code class="p">);</code>
        <code class="k">return</code> <code class="p">(</code><code class="k">value</code><code class="p">,</code> <code class="n">state</code><code class="p">.</code><code class="n">Total</code> <code class="p">+</code> <code class="k">value</code><code class="p">,</code> <code class="n">state</code><code class="p">.</code><code class="n">Random</code><code class="p">);</code>
    <code class="p">},</code>
    <code class="n">state</code> <code class="p">=&gt;</code> <code class="n">state</code><code class="p">.</code><code class="n">Current</code><code class="p">,</code>
    <code class="n">state</code> <code class="p">=&gt;</code> <code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromMilliseconds</code><code class="p">(</code><code class="n">state</code><code class="p">.</code><code class="n">Random</code><code class="p">.</code><code class="n">Next</code><code class="p">(</code><code class="m">1000</code><code class="p">)));</code></pre></div>
<p>For this to work, Rx needs to be able to schedule work to happen at some point in the future. I’ll explain how this works in <a data-type="xref" href="#schedulers">“Schedulers”</a>.<a data-startref="ix_ch11-asciidoc14a" data-type="indexterm" id="idm45884800111904"/><a data-startref="ix_ch11-asciidoc14" data-type="indexterm" id="idm45884800073088"/><a data-startref="ix_ch11-asciidoc13" data-type="indexterm" id="idm45884800072480"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="LINQ Queries" data-type="sect1"><div class="sect1" id="linq_queries">
<h1>LINQ Queries</h1>
<p><a data-primary="LINQ" data-secondary="Rx LINQ queries" data-type="indexterm" id="ix_ch11-asciidoc15a"/><a data-primary="Rx LINQ queries" data-type="indexterm" id="ix_ch11-asciidoc15"/><a data-primary="reactive extensions (Rx)" data-secondary="LINQ queries" data-type="indexterm" id="ix_ch11-asciidoc16"/>One of the greatest benefits of using Rx is that it has a LINQ implementation, enabling you to write queries to process asynchronous streams of items such as events. <a data-type="xref" href="#filtering_items_with_a_linq_query">Example 11-15</a> illustrates this. It begins by producing an observable source representing <code>MouseMove</code> events from a UI element. I’ll talk about this technique in more detail in <a data-type="xref" href="#adaptation">“Adaptation”</a>, but for now it’s enough to know that Rx can wrap any .NET event as an observable source. Each event produces an item that provides two properties containing the values normally passed to event handlers as arguments (i.e., the sender and the event arguments).</p>
<div class="pagebreak-after" data-type="example" id="filtering_items_with_a_linq_query">
<h5><span class="label">Example 11-15. </span>Filtering items with a LINQ query</h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="n">IObservable</code><code class="p">&lt;</code><code class="n">EventPattern</code><code class="p">&lt;</code><code class="n">MouseEventArgs</code><code class="p">&gt;</code><code class="p">&gt;</code><code> </code><code class="n">mouseMoves</code><code> </code><code class="p">=</code><code>
</code><code>    </code><code class="n">Observable</code><code class="p">.</code><code class="n">FromEventPattern</code><code class="p">&lt;</code><code class="n">MouseEventArgs</code><code class="p">&gt;</code><code class="p">(</code><code>
</code><code>        </code><code class="n">background</code><code class="p">,</code><code> </code><code class="n">nameof</code><code class="p">(</code><code class="n">background</code><code class="p">.</code><code class="n">MouseMove</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code>
</code><code>
</code><strong><code class="n">IObservable</code><code class="p">&lt;</code><code class="n">Point</code><code class="p">&gt;</code><code> </code><code class="n">dragPositions</code><code> </code><code class="p">=</code></strong><code>
</code><code>    </code><strong><code class="k">from</code><code> </code><code class="n">move</code><code> </code><code class="k">in</code><code> </code><code class="n">mouseMoves</code></strong><code>
</code><code>    </code><strong><code class="k">where</code><code> </code><code class="n">Mouse</code><code class="p">.</code><code class="n">Captured</code><code> </code><code class="p">=</code><code class="p">=</code><code> </code><code class="n">background</code></strong><code>
</code><code>    </code><strong><code class="k">select</code><code> </code><code class="n">move</code><code class="p">.</code><code class="n">EventArgs</code><code class="p">.</code><code class="n">GetPosition</code><code class="p">(</code><code class="n">background</code><code class="p">)</code><code class="p">;</code></strong><code>
</code><code>
</code><code class="n">dragPositions</code><code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="n">point</code><code> </code><code class="p">=</code><code class="p">&gt;</code><code> </code><code class="p">{</code><code> </code><code class="n">line</code><code class="p">.</code><code class="n">Points</code><code class="p">.</code><code class="n">Add</code><code class="p">(</code><code class="n">point</code><code class="p">)</code><code class="p">;</code><code> </code><code class="p">}</code><code class="p">)</code><code class="p">;</code></pre></div>
<p><a data-primary="Rx LINQ queries" data-secondary="where clause" data-type="indexterm" id="idm45884799969264"/>The <code>where</code> clause in the LINQ query filters the events so that we process only those events that were raised while a specific UI element (<code>background</code>) has captured the mouse. This particular example is based on WPF, but in general, Windows desktop applications that want to support dragging <em>capture</em> the mouse when the mouse button is pressed and <em>release</em> it afterward. This ensures that the capturing element receives mouse move events for as long as the drag is in progress, even if the mouse moves over other UI elements. Typically, UI elements receive mouse move events when the mouse is over them even if they have not captured the mouse. So I need that <code>where</code> clause in <a data-type="xref" href="#filtering_items_with_a_linq_query">Example 11-15</a> to ignore those events, leaving only mouse movements that occur while a drag is in progress. So, for the code in <a data-type="xref" href="#filtering_items_with_a_linq_query">Example 11-15</a> to work, you’d need to attach event handlers such as those in <a data-type="xref" href="#capturing_the_mouse">Example 11-16</a> to the relevant element’s <code>MouseDown</code> and <code>MouseUp</code> events.</p>
<div data-type="example" id="capturing_the_mouse">
<h5><span class="label">Example 11-16. </span>Capturing the mouse</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">private</code> <code class="k">void</code> <code class="nf">OnBackgroundMouseDown</code><code class="p">(</code><code class="kt">object</code> <code class="n">sender</code><code class="p">,</code> <code class="n">MouseButtonEventArgs</code> <code class="n">e</code><code class="p">)</code>
<code class="p">{</code>
    <code class="n">background</code><code class="p">.</code><code class="n">CaptureMouse</code><code class="p">();</code>
<code class="p">}</code>

<code class="k">private</code> <code class="k">void</code> <code class="nf">OnBackgroundMouseUp</code><code class="p">(</code><code class="kt">object</code> <code class="n">sender</code><code class="p">,</code> <code class="n">MouseButtonEventArgs</code> <code class="n">e</code><code class="p">)</code>
<code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="n">Mouse</code><code class="p">.</code><code class="n">Captured</code> <code class="p">==</code> <code class="n">background</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">background</code><code class="p">.</code><code class="n">ReleaseMouseCapture</code><code class="p">();</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p><a data-primary="Rx LINQ queries" data-secondary="select clause" data-type="indexterm" id="idm45884799918560"/>The <code>select</code> clause in <a data-type="xref" href="#filtering_items_with_a_linq_query">Example 11-15</a> works in Rx just like it does in LINQ to Objects, or with any other LINQ provider. It allows us to extract information from the source items to use as the output. In this case, <code>mouseMoves</code> is an observable sequence of <code>EventPattern&lt;MouseEventArgs&gt;</code> objects, but what I really want is an observable sequence of mouse locations. So the <code>select</code> clause in <a data-type="xref" href="#filtering_items_with_a_linq_query">Example 11-15</a> asks for the position relative to a particular UI element.</p>
<p>The upshot of this query is that <code>dragPositions</code> refers to an observable sequence of <code>Point</code> values, which will report each change of mouse position that occurs while a particular UI element in my application has captured the mouse. This is a hot source, because it represents something that’s happening live: mouse input. The LINQ filtering and projection operators do not change the nature of the source, so if you apply them to a hot source, the resulting query will also be hot, and if the source is cold, the filtered result will be too.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p><a data-primary="Rx LINQ queries" data-secondary="Where operator" data-type="indexterm" id="idm45884799857872"/><a data-primary="Rx LINQ queries" data-secondary="Select operator" data-type="indexterm" id="idm45884799856784"/>Operators do not detect the hotness of the source. The <code>Where</code> and <code>Select</code> operators just pass this aspect straight through. Each time you subscribe to the final query produced by the <code>Select</code> operator, it will subscribe to its input. In this case, the input was the observable returned by the <code>Where</code> operator, which will in turn subscribe to the source produced by adapting the mouse move events. If you subscribe a second time, you’ll get a second chain of subscriptions. The hot event source will broadcast every event to both chains, so each item will go through the filtering and projection process twice. So be aware that attaching multiple subscribers to a complex query of a hot source will work but may incur unnecessary expense. If you need to do this, it may be better to call <code>Publish</code> on the query, which as you’ve seen, can make a single subscription to its input and then multicast each item to all its subscribers.</p>
</div>
<p>The final line of <a data-type="xref" href="#filtering_items_with_a_linq_query">Example 11-15</a> subscribes to the filtered and projected source and adds each <code>Point</code> value it produces to the <code>Points</code> collection of another UI element called <code>line</code>. That’s a <code>Polyline</code> element, not shown here,<sup><a data-type="noteref" href="ch11.xhtml#CHP-11-FN-1" id="CHP-11-FN-1-marker">1</a></sup> and the upshot of this is that you can scrawl on the application’s window with the mouse. (If you’ve been doing Windows development for long enough, you may remember the Scribble examples—the effect here is much the same.)</p>
<p>Rx provides most of the standard query operators described in <a data-type="xref" href="ch10.xhtml#ch_linq">Chapter 10</a>.<sup><a data-type="noteref" href="ch11.xhtml#CHP-11-FN-2" id="CHP-11-FN-2-marker">2</a></sup> Most of these work in Rx exactly as they do with other LINQ implementations. However, some work in ways that may seem slightly surprising at first glance, as I will describe in the next few sections.</p>
<section data-pdf-bookmark="Grouping Operators" data-type="sect2"><div class="sect2" id="grouping_operators">
<h2>Grouping Operators</h2>
<p><a data-primary="grouping operators" data-type="indexterm" id="ix_ch11-asciidoc17"/><a data-primary="Rx LINQ queries" data-secondary="grouping operators" data-type="indexterm" id="ix_ch11-asciidoc18"/><a data-primary="Rx LINQ queries" data-secondary="GroupBy operator" data-type="indexterm" id="idm45884799841584"/><a data-primary="Rx LINQ queries" data-secondary="GroupJoin operator" data-type="indexterm" id="idm45884799840640"/>The standard grouping operator, <code>GroupBy</code>, produces a sequence of sequences. With LINQ to Objects, it returns <code>IEnumerable&lt;IGrouping&lt;TKey, TSource&gt;&gt;</code>, and as you saw in <a data-type="xref" href="ch10.xhtml#ch_linq">Chapter 10</a>, <code>IGrouping&lt;TKey, TSource&gt;</code> itself derives from <code>IEnumera⁠ble​&lt;TSource&gt;</code>. The <code>GroupJoin</code> is similar in concept: although it returns a plain 
<span class="keep-together"><code>IEnumerable&lt;T&gt;</code></span>, that <code>T</code> is the result of a projection function that is passed a sequence as input. So, in either case, you get what is logically a sequence of sequences.</p>
<p>In the world of Rx, grouping produces an observable sequence of observable sequences. This is perfectly consistent but can seem a little surprising because Rx introduces a temporal aspect: the observable source that represents all the groups produces a new item (a new observable source) at the instant it discovers each new group. <a data-primary="FileSystemWatcher" data-type="indexterm" id="idm45884799835040"/><a data-type="xref" href="#grouping_events">Example 11-17</a> illustrates this by watching for changes in the filesystem and then forming them into groups based on the folder in which each occurred. For each group, we get an <code><span class="keep-together">IGrouped</span>Observable&lt;TKey, TSource&gt;</code>, which is the Rx equivalent of <code>IGrouping&lt;TKey, TSource&gt;</code>.</p>
<div data-type="example" id="grouping_events">
<h5><span class="label">Example 11-17. </span>Grouping events</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">string</code> <code class="n">path</code> <code class="p">=</code> <code class="n">Environment</code><code class="p">.</code><code class="n">GetFolderPath</code><code class="p">(</code><code class="n">Environment</code><code class="p">.</code><code class="n">SpecialFolder</code><code class="p">.</code><code class="n">MyDocuments</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">w</code> <code class="p">=</code> <code class="k">new</code> <code class="n">FileSystemWatcher</code><code class="p">(</code><code class="n">path</code><code class="p">);</code>
<code class="n">IObservable</code><code class="p">&lt;</code><code class="n">EventPattern</code><code class="p">&lt;</code><code class="n">FileSystemEventArgs</code><code class="p">&gt;&gt;</code> <code class="n">changes</code> <code class="p">=</code>
    <code class="n">Observable</code><code class="p">.</code><code class="n">FromEventPattern</code><code class="p">&lt;</code><code class="n">FileSystemEventHandler</code><code class="p">,</code> <code class="n">FileSystemEventArgs</code><code class="p">&gt;(</code>
        <code class="n">h</code> <code class="p">=&gt;</code> <code class="n">w</code><code class="p">.</code><code class="n">Changed</code> <code class="p">+=</code> <code class="n">h</code><code class="p">,</code> <code class="n">h</code> <code class="p">=&gt;</code> <code class="n">w</code><code class="p">.</code><code class="n">Changed</code> <code class="p">-=</code> <code class="n">h</code><code class="p">);</code>
<code class="n">w</code><code class="p">.</code><code class="n">IncludeSubdirectories</code> <code class="p">=</code> <code class="k">true</code><code class="p">;</code>
<code class="n">w</code><code class="p">.</code><code class="n">EnableRaisingEvents</code> <code class="p">=</code> <code class="k">true</code><code class="p">;</code>

<code class="n">IObservable</code><code class="p">&lt;</code><code class="n">IGroupedObservable</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="kt">string</code><code class="p">&gt;&gt;</code> <code class="n">folders</code> <code class="p">=</code>
    <code class="k">from</code> <code class="n">change</code> <code class="k">in</code> <code class="n">changes</code>
    <code class="k">group</code> <code class="n">Path</code><code class="p">.</code><code class="n">GetFileName</code><code class="p">(</code><code class="n">change</code><code class="p">.</code><code class="n">EventArgs</code><code class="p">.</code><code class="n">FullPath</code><code class="p">)</code>
       <code class="k">by</code> <code class="n">Path</code><code class="p">.</code><code class="n">GetDirectoryName</code><code class="p">(</code><code class="n">change</code><code class="p">.</code><code class="n">EventArgs</code><code class="p">.</code><code class="n">FullPath</code><code class="p">);</code>

<code class="n">folders</code><code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="n">f</code> <code class="p">=&gt;</code>
<code class="p">{</code>
    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"New folder ({0})"</code><code class="p">,</code> <code class="n">f</code><code class="p">.</code><code class="n">Key</code><code class="p">);</code>
    <code class="n">f</code><code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="n">file</code> <code class="p">=&gt;</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"File changed in folder {0}, {1}"</code><code class="p">,</code> <code class="n">f</code><code class="p">.</code><code class="n">Key</code><code class="p">,</code> <code class="n">file</code><code class="p">));</code>
<code class="p">});</code></pre></div>
<p>The lambda that subscribes to the grouping source, <code>folders</code>, subscribes to each group that the source produces. The number of folders from which events could occur is endless, as new ones could be added while the program is running. So the <code>folders</code> observable will produce a new observable source each time it detects a change in a folder it hasn’t seen before, as <a data-type="xref" href="#grouping_iobservables">Figure 11-2</a> shows.</p>
<p>Notice that the production of a new group doesn’t mean that any previous groups are now complete, which is different than how we typically consume groups in LINQ to Objects. When you run a grouping query on an <code>IEnumerable&lt;T&gt;</code>, as it produces each group you can enumerate the contents entirely before moving on to the next one. But you can’t do that with Rx, because each group is represented as an observable, and observables aren’t finished until they tell you they’re complete—instead, each group subscription remains active. In <a data-type="xref" href="#grouping_events">Example 11-17</a>, it’s entirely possible that a folder for which a group had already started will be dormant for a long time while activity occurs in other folders, only for it to start up again later. And more generally, Rx’s grouping operators have to be prepared for that to happen with any source.<a data-startref="ix_ch11-asciidoc18" data-type="indexterm" id="idm45884799697808"/><a data-startref="ix_ch11-asciidoc17" data-type="indexterm" id="idm45884799697136"/></p>
<figure><div class="figure" id="grouping_iobservables">
<img alt="Rx Group operator" height="405" src="assets/pc10_1102.png" width="600"/>
<h6><span class="label">Figure 11-2. </span>Splitting an <code>IObservable&lt;T&gt;</code> into groups</h6>
</div></figure>
</div></section>
<section data-pdf-bookmark="Join Operators" data-type="sect2"><div class="sect2" id="join_operators">
<h2>Join Operators</h2>
<p><a data-primary="Join operator" data-type="indexterm" id="ix_ch11-asciidoc19"/><a data-primary="Rx LINQ queries" data-secondary="Join operator" data-type="indexterm" id="ch11-joyn"/>Rx provides the standard <code>Join</code> and <code>GroupJoin</code> operators. However, they work a bit differently than how LINQ to Objects or most database LINQ providers handle joins. In those worlds, items from two input sets are typically joined based on having some value in common.</p>
<p>In a database, a very common example when joining two tables would be to connect rows where a foreign key column in a row from one table has the same value as a primary key column in a row from the other table. However, Rx does not base joins on values. Instead, items are joined if they are contemporaneous—if their durations overlap, then they are joined.</p>
<p>But hang on a minute. What exactly is an item’s duration? Rx deals in instantaneous events; producing an item, reporting an error, and finishing a stream are all things that happen at a particular moment. So the join operators use a convention: for each source item, you can provide a function that returns an <code>IObservable&lt;T&gt;</code>.</p>
<p>The duration for that source item starts when the item is produced and finishes when the corresponding <code>IObservable&lt;T&gt;</code> first reacts (i.e., it either completes or generates an item or an error). <a data-type="xref" href="#defining_duration_with_an_iobservableltg">Figure 11-3</a> illustrates this idea. At the top is an observable source, beneath which is a series of sources that define each item’s duration. At the bottom, I’ve shown the duration that the per-item observables establish for their source items.</p>
<figure><div class="figure" id="defining_duration_with_an_iobservableltg">
<img alt="" height="190" src="assets/pc10_1103.png" width="600"/>
<h6><span class="label">Figure 11-3. </span>Defining duration with an <code>IObservable&lt;T&gt;</code> for each source item</h6>
</div></figure>
<p>Although you can use a different <code>IObservable&lt;T&gt;</code> for each source item, as <a data-type="xref" href="#defining_duration_with_an_iobservableltg">Figure 11-3</a> shows, you don’t have to—it’s valid to use the same source every time. For example, if you apply the group operator to an <code>IObservable&lt;T&gt;</code> representing a stream of <code>MouseDown</code> events, and you then use another <code>IObservable&lt;T&gt;</code> representing a stream of <code>MouseUp</code> events to define the duration of each item, this would cause Rx to consider each <code>MouseDown</code> event’s “duration” to last until the next <code>MouseUp</code> event. <a data-type="xref" href="#defining_duration_with_a_pair_of_event">Figure 11-4</a> depicts this arrangement, and you can see that the effective duration of each <code>MouseDown</code> event, shown at the bottom, is delineated by a pair of <code>MouseDown</code> and <code>MouseUp</code> events.</p>
<figure><div class="figure" id="defining_duration_with_a_pair_of_event">
<img alt="" height="147" src="assets/pc10_1104.png" width="600"/>
<h6><span class="label">Figure 11-4. </span>Defining duration with a pair of event streams</h6>
</div></figure>
<p>A source can even define its own duration. For example, if you provide an observable source representing <code>MouseDown</code> events, you might want each item’s duration to end when the next item begins. This would mean that the items had contiguous durations—after the first item arrives, there is always exactly one current item, and it is the last one that occurred. <a data-type="xref" href="#adjacent_item_duration">Figure 11-5</a> illustrates this.</p>
<figure><div class="figure" id="adjacent_item_duration">
<img alt="" height="99" src="assets/pc10_1105.png" width="600"/>
<h6><span class="label">Figure 11-5. </span>Adjacent item duration</h6>
</div></figure>
<p>Item durations are allowed to overlap. If you wanted to, you could supply a duration-defining <code>IObservable&lt;T&gt;</code> that indicated that an input item’s duration finishes some time after the next item begins.</p>
<p>Now that we know how Rx decides what constitutes an item’s duration for the purposes of a join, how does it use that information? Remember, join operators combine two inputs. (The duration-defining sources do not count as an input. They provide additional information about one of the inputs.) Rx considers a pair of items from the two input streams to be related if their durations overlap. The way it presents related items in the output depends on whether you use the <code>Join</code> or the <code>GroupJoin</code> operator. The <code>Join</code> operator’s output is a stream containing one item for each pair of related items. (You provide a projection function that will be passed each pair, and it’s up to you what to do with them. This function gets to decide the output item type for the joined stream.) <a data-type="xref" href="#join_operator">Figure 11-6</a> shows two input streams based on the events <code>MouseDown</code> and <code>MouseMove</code> (with durations defined by <code>MouseUp</code> and <code>MouseMove</code>, respectively). These are similar to the sources in Figures <a data-type="xref" data-xrefstyle="select:labelnumber" href="#defining_duration_with_a_pair_of_event">11-4</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#adjacent_item_duration">11-5</a>, but I’ve added letters and numbers to make it easier to refer to each of the items in these streams. At the bottom of the diagram is the observable the <code>Join</code> operator would produce for these two streams.</p>
<figure><div class="figure" id="join_operator">
<img alt="" height="320" src="assets/pc10_1106.png" width="600"/>
<h6><span class="label">Figure 11-6. </span><code>Join</code> operator</h6>
</div></figure>
<p>As you can see, any place where the durations of two items from the input streams overlap, we get an output item combining the two inputs. If the overlapping items started at different times (which will normally be the case), the output item is produced whenever the later of the two inputs started. The <code>MouseDown</code> event <code>A</code> starts before the <code>MouseMove</code> event <code>1</code>, so the resulting output, <code>A1</code>, occurs where the overlap begins (i.e., when <code>MouseMove</code> event <code>1</code> occurs). But event <code>3</code> occurs before event <code>B</code>, so the joined output <code>B3</code> occurs when <code>B</code> starts.</p>
<p>Event <code>5</code>’s duration does not overlap with any <code>MouseDown</code> items’ durations, so we do not see any items for that in the output stream. Conversely, it would be possible for a <code>MouseMove</code> event to appear in multiple output items (just like each <code>MouseDown</code> event does). If there had been no <code>3</code> event, event <code>2</code> would have a duration that started inside <code>A</code> and finished inside <code>B</code>, so as well as the <code>A2</code> shown in <a data-type="xref" href="#join_operator">Figure 11-6</a>, there would be a <code>B2</code> event at the same time as <code>B</code> starts.</p>
<p><a data-type="xref" href="#query_expression_with_join">Example 11-18</a> shows code that performs the join illustrated in <a data-type="xref" href="#join_operator">Figure 11-6</a>, using a query expression. As you saw in <a data-type="xref" href="ch10.xhtml#ch_linq">Chapter 10</a>, the compiler turns query expressions into a series of method calls, and <a data-type="xref" href="#join_in_code">Example 11-19</a> shows the method-based equivalent of the query in <a data-type="xref" href="#query_expression_with_join">Example 11-18</a>.</p>
<div data-type="example" id="query_expression_with_join">
<h5><span class="label">Example 11-18. </span>Query expression with join</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">IObservable</code><code class="p">&lt;</code><code class="n">EventPattern</code><code class="p">&lt;</code><code class="n">MouseEventArgs</code><code class="p">&gt;&gt;</code> <code class="n">downs</code> <code class="p">=</code>
    <code class="n">Observable</code><code class="p">.</code><code class="n">FromEventPattern</code><code class="p">&lt;</code><code class="n">MouseEventArgs</code><code class="p">&gt;(</code>
        <code class="n">background</code><code class="p">,</code> <code class="n">nameof</code><code class="p">(</code><code class="n">background</code><code class="p">.</code><code class="n">MouseDown</code><code class="p">));</code>
<code class="n">IObservable</code><code class="p">&lt;</code><code class="n">EventPattern</code><code class="p">&lt;</code><code class="n">MouseEventArgs</code><code class="p">&gt;&gt;</code> <code class="n">ups</code> <code class="p">=</code>
    <code class="n">Observable</code><code class="p">.</code><code class="n">FromEventPattern</code><code class="p">&lt;</code><code class="n">MouseEventArgs</code><code class="p">&gt;(</code>
        <code class="n">background</code><code class="p">,</code> <code class="n">nameof</code><code class="p">(</code><code class="n">background</code><code class="p">.</code><code class="n">MouseUp</code><code class="p">));</code>
<code class="n">IObservable</code><code class="p">&lt;</code><code class="n">EventPattern</code><code class="p">&lt;</code><code class="n">MouseEventArgs</code><code class="p">&gt;&gt;</code> <code class="n">allMoves</code> <code class="p">=</code>
    <code class="n">Observable</code><code class="p">.</code><code class="n">FromEventPattern</code><code class="p">&lt;</code><code class="n">MouseEventArgs</code><code class="p">&gt;(</code>
        <code class="n">background</code><code class="p">,</code> <code class="n">nameof</code><code class="p">(</code><code class="n">background</code><code class="p">.</code><code class="n">MouseMove</code><code class="p">));</code>

<code class="n">IObservable</code><code class="p">&lt;</code><code class="n">Point</code><code class="p">&gt;</code> <code class="n">dragPositions</code> <code class="p">=</code>
    <code class="k">from</code> <code class="n">down</code> <code class="k">in</code> <code class="n">downs</code>
    <code class="k">join</code> <code class="n">move</code> <code class="k">in</code> <code class="n">allMoves</code>
      <code class="k">on</code> <code class="n">ups</code> <code class="k">equals</code> <code class="n">allMoves</code>
    <code class="k">select</code> <code class="n">move</code><code class="p">.</code><code class="n">EventArgs</code><code class="p">.</code><code class="n">GetPosition</code><code class="p">(</code><code class="n">background</code><code class="p">);</code></pre></div>
<div data-type="example" id="join_in_code">
<h5><span class="label">Example 11-19. </span>Join in code</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">IObservable</code><code class="p">&lt;</code><code class="n">Point</code><code class="p">&gt;</code> <code class="n">dragPositions</code> <code class="p">=</code> <code class="n">downs</code><code class="p">.</code><code class="n">Join</code><code class="p">(</code>
    <code class="n">allMoves</code><code class="p">,</code>
    <code class="n">down</code> <code class="p">=&gt;</code> <code class="n">ups</code><code class="p">,</code>
    <code class="n">move</code> <code class="p">=&gt;</code> <code class="n">allMoves</code><code class="p">,</code>
    <code class="p">(</code><code class="n">down</code><code class="p">,</code> <code class="n">move</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">move</code><code class="p">.</code><code class="n">EventArgs</code><code class="p">.</code><code class="n">GetPosition</code><code class="p">(</code><code class="n">background</code><code class="p">));</code></pre></div>
<p>We can use the <code>dragPositions</code> observable source produced by either of these examples to replace the one in <a data-type="xref" href="#filtering_items_with_a_linq_query">Example 11-15</a>. We no longer need to filter based on whether the <code>background</code> element has captured the mouse, because Rx is now providing us only move events whose duration overlaps with the duration of a mouse down event. Any moves that happen in between mouse presses will either be ignored or, if they are the last move to occur before a mouse down, we’ll receive that position at the moment the mouse button is pressed.<a data-startref="ch11-joyn" data-type="indexterm" id="idm45884799368976"/></p>
<p><a data-primary="GroupJoin operator" data-type="indexterm" id="ix_ch11-asciidoc21"/><a data-primary="Rx LINQ queries" data-secondary="GroupJoin operator" data-type="indexterm" id="ch11-grpjn"/><code>GroupJoin</code> combines items in a similar way, but instead of producing a single observable output, it produces an observable of observables. For the present example, that would mean that its output would produce a new observable source for each <code>MouseDown</code> input. This would consist of all the pairs containing that input, and it would have the same duration as that input. <a data-type="xref" href="#groupjoin_operator-id1">Figure 11-7</a> shows this operator in action with the same input events as <a data-type="xref" href="#join_operator">Figure 11-6</a>. I’ve put vertical bars on the ends of the output sequences to clarify when they will call their observers’ <code>OnComplete</code> methods. The start and finish of these observables align exactly with the duration of the corresponding input, so there is often a significant gap between when they produce their final output item and when they complete.</p>
<figure><div class="figure" id="groupjoin_operator-id1">
<img alt="" height="391" src="assets/pc10_1107.png" width="600"/>
<h6><span class="label">Figure 11-7. </span><code>GroupJoin</code> operator</h6>
</div></figure>
<p>In general, with LINQ, the <code>GroupJoin</code> operator is able to produce empty groups, so unlike the <code>Join</code> operator, there will be one output for each item from the first input even if there are no corresponding items from the other stream. The Rx <code>GroupJoin</code> works the same way, adding in a temporal aspect. Each output group starts at the same moment the corresponding input event happens (<code>MouseDown</code>, in this example) and ends when that event is deemed to have finished (at the next <code>MouseUp</code> here); if there were no moves in that time, that observable will generate no items. Since move event durations are contiguous here, that could happen only before receiving the first move. But in joins where the second input’s items have noncontiguous durations, empty groups are more likely.</p>
<p>In the context of my example application that allows the user to scribble in a window with the mouse, this grouped output is useful, because it presents each individual drag as a separate object. This means I could create a new line for each drag, rather than adding points onto the same increasingly long line. With the code in <a data-type="xref" href="#filtering_items_with_a_linq_query">Example 11-15</a>, each new drag operation will draw a line from wherever the previous drag finished to the new location, making it impossible to draw separate shapes. But grouped output makes separation easy. <a data-type="xref" href="#adding_a_new_line_for_each_drag_operatio">Example 11-20</a> subscribes to the grouped output, and for each new group (which represents a new drag operation), it creates a new <code>Polyline</code> to render the scribble and then subscribes to the items in the group to populate that individual line.</p>
<div data-type="example" id="adding_a_new_line_for_each_drag_operatio">
<h5><span class="label">Example 11-20. </span>Adding a new line for each drag operation</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">dragPointSets</code> <code class="p">=</code> <code class="k">from</code> <code class="n">mouseDown</code> <code class="k">in</code> <code class="n">downs</code>
                    <code class="k">join</code> <code class="n">move</code> <code class="k">in</code> <code class="n">allMoves</code>
                      <code class="k">on</code> <code class="n">ups</code> <code class="k">equals</code> <code class="n">allMoves</code> <code class="k">into</code> <code class="n">m</code>
                    <code class="k">select</code> <code class="n">m</code><code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">e</code> <code class="p">=&gt;</code> <code class="n">e</code><code class="p">.</code><code class="n">EventArgs</code><code class="p">.</code><code class="n">GetPosition</code><code class="p">(</code><code class="n">background</code><code class="p">));</code>

<code class="n">dragPointSets</code><code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="n">dragPoints</code> <code class="p">=&gt;</code>
<code class="p">{</code>
    <code class="kt">var</code> <code class="n">currentLine</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Polyline</code> <code class="p">{</code> <code class="n">Stroke</code> <code class="p">=</code> <code class="n">Brushes</code><code class="p">.</code><code class="n">Black</code><code class="p">,</code> <code class="n">StrokeThickness</code> <code class="p">=</code> <code class="m">2</code> <code class="p">};</code>
    <code class="n">background</code><code class="p">.</code><code class="n">Children</code><code class="p">.</code><code class="n">Add</code><code class="p">(</code><code class="n">currentLine</code><code class="p">);</code>

    <code class="n">dragPoints</code><code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="n">point</code> <code class="p">=&gt;</code>
    <code class="p">{</code>
        <code class="n">currentLine</code><code class="p">.</code><code class="n">Points</code><code class="p">.</code><code class="n">Add</code><code class="p">(</code><code class="n">point</code><code class="p">);</code>
    <code class="p">});</code>
<code class="p">});</code></pre></div>
<p>Just to be clear, all of this works in real time even with a join operator—these are all hot sources. The <code>IObservable&lt;IObservable&lt;Point&gt;&gt;</code> returned by <code>GroupJoin</code> in <a data-type="xref" href="#adding_a_new_line_for_each_drag_operatio">Example 11-20</a> will produce a new group the instant the mouse button is pressed. The <code>IObservable&lt;Point&gt;</code> from that group will produce a new <code>Point</code> immediately for each <code>MouseMove</code> event. The upshot is that the user sees the line appear and grow instantly when dragging the mouse.<a data-startref="ix_ch11-asciidoc21" data-type="indexterm" id="idm45884799264816"/><a data-startref="ix_ch11-asciidoc19" data-type="indexterm" id="idm45884799264112"/><a data-startref="ch11-grpjn" data-type="indexterm" id="idm45884799263440"/></p>
</div></section>
<section data-pdf-bookmark="SelectMany Operator" data-type="sect2"><div class="sect2" id="selectmany_operator-id1">
<h2>SelectMany Operator</h2>
<p><a data-primary="Rx LINQ queries" data-secondary="SelectMany operator" data-type="indexterm" id="idm45884799261680"/><a data-primary="SelectMany operator" data-type="indexterm" id="idm45884799220064"/>As you saw in <a data-type="xref" href="ch10.xhtml#ch_linq">Chapter 10</a>, the <code>SelectMany</code> operator effectively flattens a collection of collections into a single one. This operator gets used when a query expression has multiple <code>from</code> clauses, and with LINQ to Objects, its operation is similar to having nested <code>foreach</code> loops. With Rx, it still has this flattening effect—it lets you take an observable source where each item it produces is also an observable source (or can be used to generate one), and the result of the <code>SelectMany</code> operator will be a single observable sequence that contains all of the items from all of the child sources. However, as with grouping, things may be less orderly than in LINQ to Objects. The push-driven nature of Rx, with its potential for asynchronous operation, makes it possible for all of the observable sources involved to be pushing new items at once, including the original source that is used as a source of nested sources. (The operator still ensures that only one event will be delivered at a time—when it calls on <code>OnNext</code>, it waits for that to return before making another call. The potential for chaos only goes as far as mixing up the order in which events are delivered.)</p>
<p>When you use LINQ to Objects to iterate through a jagged array, everything happens in a straightforward order. It will retrieve the first nested array and then iterate through all the elements in that array before moving to the next nested array and iterating through that, and so on. But this orderly flattening occurs only because with <code>IEnumerable&lt;T&gt;</code>, the consumer of items is in control of when to retrieve which items. With Rx, subscribers receive items when sources provide them.</p>
<p>Despite the free-for-all, the behavior is straightforward enough: the output stream produced by <code>SelectMany</code> just provides items as and when the sources provide them.</p>
</div></section>
<section data-pdf-bookmark="Aggregation and Other Single-Value Operators" data-type="sect2"><div class="sect2" id="aggregation_and_other_single-value_opera">
<h2>Aggregation and Other Single-Value Operators</h2>
<p><a data-primary="aggregation" data-type="indexterm" id="idm45884799212672"/><a data-primary="Rx LINQ queries" data-secondary="aggregation and other single-value operators" data-type="indexterm" id="idm45884799211632"/>Several of the standard LINQ operators reduce an entire sequence of values to a single value. These include the aggregation operators, such as <code>Min</code>, <code>Sum</code>, and 
<span class="keep-together"><code>Aggregate</code></span>; the quantifiers <code>Any</code> and <code>All</code>; and the<a data-primary="Count operator" data-type="indexterm" id="idm45884799207728"/> <code>Count</code> operator. It also includes selective operators, such as <code>ElementAt</code>. These are available in Rx, but unlike most LINQ implementations, the Rx implementations do not return plain single values. They all return an <code>IObservable&lt;T&gt;</code>, just like operators that produce sequences as outputs.</p>
<div class="note2" data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>First</code>, <code>Last</code>, <code>FirstOrDefault</code>, <code>LastOrDefault</code>, <code>Single</code>, and <code>SingleOrDefault</code> operators should all work the same way, but for historical reasons, they do not. Introduced in v1 of Rx, they returned single values that were not wrapped in an <code>IObserva⁠ble​&lt;T&gt;</code>, which meant they would block until the source provided what they needed. This doesn’t fit well with a push-based model and risks introducing deadlock, so these are now deprecated, and there are new asynchronous versions that work the same way as the other single-value operators in Rx. These all just append <code>Async</code> to the original operators’ names (e.g., <code>FirstAsync</code>, <code>LastAsync</code>, etc.).</p>
</div>
<p>Each of these operators still produces a single value, but they all present that value as an observable source. The reason is that unlike LINQ to Objects, Rx cannot enumerate its input to calculate the aggregate value or to find the value being selected. The source is in control, so the Rx versions of these operators have to wait for the source to provide its values—like all operators, the single-value operators have to be reactive, not proactive. Operators that need to see every value, such as <code>Average</code>, cannot produce their result until the source says it has finished. Even an operator that doesn’t need to wait until the very end of the input, such as <code>FirstAsync</code> or <code>ElementAt</code>, still cannot do anything until the source decides to provide the value the operator is waiting for. As soon as a single-value operator is able to provide a value, it does so and then completes.</p>
<p>The <code>ToArray</code>, <code>ToList</code>, <code>ToDictionary</code>, and <code>ToLookup</code> operators work in a similar way. Although these all produce the entire contents of the source, they do so as a single output object, which is wrapped as a single-item observable source.</p>
<p>If you really want to sit and wait for the value of any of these items, you can use the <code>Wait</code> operator, a nonstandard operator specific to Rx available on any <code>IObserva⁠ble​&lt;T&gt;</code>. This blocking operator waits for the source to complete and then returns the final element, so the “sit and wait” behavior of the deprecated <code>First</code>, <code>Last</code>, etc., operators is still available; it’s just no longer the default. Alternatively, you can use C#’s asynchronous language features—you can give the <code>await</code> keyword an observable source. Logically, it does the same thing as <code>Wait</code>, but it does so with an efficient nonblocking asynchronous wait of the kind described in <a data-type="xref" href="ch17.xhtml#ch_asynchronous_language_features">Chapter 17</a>.</p>
</div></section>
<section data-pdf-bookmark="Concat Operator" data-type="sect2"><div class="sect2" id="concat_operator">
<h2>Concat Operator</h2>
<p><a data-primary="Concat operator" data-type="indexterm" id="idm45884799189456"/><a data-primary="Rx LINQ queries" data-secondary="Concat operator" data-type="indexterm" id="idm45884799188528"/>Rx’s <code>Concat</code> operator shares the same concept as other LINQ implementations: it combines two input sequences to produce a sequence that will produce every item in its first input, followed by every item in its second input. (In fact, Rx goes further than some LINQ providers and can accept a collection of inputs and will concatenate them all.) This is useful only if the first stream eventually completes—that’s true in LINQ to Objects too, of course, but infinite sources are more common in Rx. Also, be aware that this operator does not subscribe to the second stream until the first has finished. This is because cold streams typically start producing items when you subscribe, and the <code>Concat</code> operator does not want to have to buffer the second source’s items while it waits for the first to complete. This means that <code>Concat</code> may produce nondeterministic results when used with hot sources. (If you want an observable source that contains all the items from two hot sources, use <code>Merge</code>, which I’ll describe shortly.)</p>
<p>Rx is not satisfied with merely providing standard LINQ operators. It defines many more of its own operators.<a data-startref="ix_ch11-asciidoc16" data-type="indexterm" id="idm45884799185104"/><a data-startref="ix_ch11-asciidoc15a" data-type="indexterm" id="idm45884799184400"/><a data-startref="ix_ch11-asciidoc15" data-type="indexterm" id="idm45884799183728"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Rx Query Operators" data-type="sect1"><div class="sect1" id="rx_query_operators">
<h1>Rx Query Operators</h1>
<p><a data-primary="query operators, Rx" data-type="indexterm" id="ix_ch11-asciidoc22"/><a data-primary="reactive extensions (Rx)" data-secondary="query operators" data-type="indexterm" id="ix_ch11-asciidoc23"/><a data-primary="query operators, LINQ" data-see="LINQ operators" data-type="indexterm" id="idm45884799179024"/>One of Rx’s main goals is to simplify working with multiple potentially independent observable sources that produce items asynchronously. Rx’s designers sometimes refer to “orchestration and synchronization,” meaning that your system may have many things going on at once but that you need to achieve some kind of coherency in how your application reacts to events. Many of Rx’s operators are designed with this goal in mind.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Not everything in this section is driven by the unique requirements of Rx. A few of Rx’s nonstandard operators (e.g., <code>Scan</code>) would make perfect sense in other LINQ providers. And versions of many of these are available for <code>IEnumerable&lt;T&gt;</code> in the Interactive Extensions for .NET (Ix), which, as mentioned earlier, are to be found in the <code>System.Interactive</code> NuGet package.</p>
</div>
<p>Rx has such a large repertoire of operators that to do them all justice would roughly quadruple the size of this chapter, which is already on the long side. Since this is not a book about Rx, and because some of the operators are very specialized, I will just pick some of the most useful. I recommend browsing through the Rx documentation or <a href="https://github.com/dotnet/reactive">the source</a> to discover the full and remarkably comprehensive set of operators it provides.</p>
<section data-pdf-bookmark="Merge" data-type="sect2"><div class="sect2" id="merge">
<h2>Merge</h2>
<p><a data-primary="Merge operator (Rx)" data-type="indexterm" id="idm45884799172352"/><a data-primary="query operators, Rx" data-secondary="Merge" data-type="indexterm" id="idm45884799171424"/>The <code>Merge</code> operator combines all of the elements from two or more observable sequences into a single observable sequence. I can use this to fix a problem that occurs in Examples <a data-type="xref" data-xrefstyle="select:labelnumber" href="#filtering_items_with_a_linq_query">11-15</a>, <a data-type="xref" data-xrefstyle="select:labelnumber" href="#query_expression_with_join">11-18</a>, and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#adding_a_new_line_for_each_drag_operatio">11-20</a>. These all process mouse input, and if you’ve done much Windows UI programming, you know that you will not necessarily get a mouse move notification corresponding to the points at which the mouse button was pressed and released. The notifications for these button events include mouse location information, so Windows sees no need to send a separate mouse move message providing these locations, because it would just be sending you the same information twice. This is perfectly logical, and also rather annoying.<sup><a data-type="noteref" href="ch11.xhtml#CHP-11-FN-3" id="CHP-11-FN-3-marker">3</a></sup> These start and end locations are not in the observable source that represents mouse positions in those examples. I can fix that by merging in the positions from all three events. <a data-type="xref" href="#merging_observables">Example 11-21</a> shows how to fix <a data-type="xref" href="#filtering_items_with_a_linq_query">Example 11-15</a>.</p>
<div data-type="example" id="merging_observables">
<h5><span class="label">Example 11-21. </span>Merging observables</h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="n">IObservable</code><code class="p">&lt;</code><code class="n">EventPattern</code><code class="p">&lt;</code><code class="n">MouseEventArgs</code><code class="p">&gt;</code><code class="p">&gt;</code><code> </code><code class="n">downs</code><code> </code><code class="p">=</code><code>
</code><code>    </code><code class="n">Observable</code><code class="p">.</code><code class="n">FromEventPattern</code><code class="p">&lt;</code><code class="n">MouseEventArgs</code><code class="p">&gt;</code><code class="p">(</code><code>
</code><code>        </code><code class="n">background</code><code class="p">,</code><code> </code><code class="n">nameof</code><code class="p">(</code><code class="n">background</code><code class="p">.</code><code class="n">MouseDown</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code>
</code><code class="n">IObservable</code><code class="p">&lt;</code><code class="n">EventPattern</code><code class="p">&lt;</code><code class="n">MouseEventArgs</code><code class="p">&gt;</code><code class="p">&gt;</code><code> </code><code class="n">ups</code><code> </code><code class="p">=</code><code>
</code><code>    </code><code class="n">Observable</code><code class="p">.</code><code class="n">FromEventPattern</code><code class="p">&lt;</code><code class="n">MouseEventArgs</code><code class="p">&gt;</code><code class="p">(</code><code>
</code><code>        </code><code class="n">background</code><code class="p">,</code><code> </code><code class="n">nameof</code><code class="p">(</code><code class="n">background</code><code class="p">.</code><code class="n">MouseUp</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code>
</code><code class="n">IObservable</code><code class="p">&lt;</code><code class="n">EventPattern</code><code class="p">&lt;</code><code class="n">MouseEventArgs</code><code class="p">&gt;</code><code class="p">&gt;</code><code> </code><code class="n">allMoves</code><code> </code><code class="p">=</code><code>
</code><code>    </code><code class="n">Observable</code><code class="p">.</code><code class="n">FromEventPattern</code><code class="p">&lt;</code><code class="n">MouseEventArgs</code><code class="p">&gt;</code><code class="p">(</code><code>
</code><code>        </code><code class="n">background</code><code class="p">,</code><code> </code><code class="n">nameof</code><code class="p">(</code><code class="n">background</code><code class="p">.</code><code class="n">MouseMove</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code>
</code><code>
</code><code class="n">IObservable</code><code class="p">&lt;</code><code class="n">EventPattern</code><code class="p">&lt;</code><code class="n">MouseEventArgs</code><code class="p">&gt;</code><code class="p">&gt;</code><code> </code><code class="n">dragMoves</code><code> </code><code class="p">=</code><code>
</code><code>    </code><code class="k">from</code><code> </code><code class="n">move</code><code> </code><code class="k">in</code><code> </code><code class="n">allMoves</code><code>
</code><code>    </code><code class="k">where</code><code> </code><code class="n">Mouse</code><code class="p">.</code><code class="n">Captured</code><code> </code><code class="p">=</code><code class="p">=</code><code> </code><code class="n">background</code><code>
</code><code>    </code><code class="k">select</code><code> </code><code class="n">move</code><code class="p">;</code><code>
</code><code>
</code><strong><code class="n">IObservable</code><code class="p">&lt;</code><code class="n">EventPattern</code><code class="p">&lt;</code><code class="n">MouseEventArgs</code><code class="p">&gt;</code><code class="p">&gt;</code><code> </code><code class="n">allDragPositionEvents</code><code> </code><code class="p">=</code></strong><code>
</code><code>    </code><strong><code class="n">Observable</code><code class="p">.</code><code class="n">Merge</code><code class="p">(</code><code class="n">downs</code><code class="p">,</code><code> </code><code class="n">ups</code><code class="p">,</code><code> </code><code class="n">dragMoves</code><code class="p">)</code><code class="p">;</code></strong><code>
</code><code>
</code><code class="n">IObservable</code><code class="p">&lt;</code><code class="n">Point</code><code class="p">&gt;</code><code> </code><code class="n">dragPositions</code><code> </code><code class="p">=</code><code>
</code><code>    </code><code class="k">from</code><code> </code><code class="n">move</code><code> </code><code class="k">in</code><code> </code><code class="n">allDragPositionEvents</code><code>
</code><code>    </code><code class="k">select</code><code> </code><code class="n">move</code><code class="p">.</code><code class="n">EventArgs</code><code class="p">.</code><code class="n">GetPosition</code><code class="p">(</code><code class="n">background</code><code class="p">)</code><code class="p">;</code></pre></div>
<p>I’ve created three observables to represent the three relevant events: <code>MouseDown</code>, <code>MouseUp</code>, and <code>MouseMove</code>. Since all three of these need to share the same projection (the <code>select</code> clause), but only one needs to filter events, I’ve restructured things a bit. Only mouse moves need filtering, so I’ve written a separate query for that. I’ve then used the <code>Observable.Merge</code> method to combine all three event streams into one.</p>
<div class="note1" data-type="note" epub:type="note"><h6>Note</h6>
<p><code>Merge</code> is available both as an extension method and a nonextension <code>static</code> method. If you use the extension methods available on a single observable, the only <code>Merge</code> overloads available combine it with a single other source (optionally specifying a scheduler). In this case, I had three sources, which is why I used the nonextension method form. However, if you have an expression that is either an enumerable of observable sources or an observable source of observable sources, you’ll find that there are also <code>Merge</code> extension methods for these. So I could have written <code>new[] { downs, ups, dragMoves }.Merge()</code>.</p>
</div>
<p>My <code>allDragPositionEvents</code> variable refers to a single observable stream that will report all the mouse moves I need. Finally, I run this through a projection to extract the mouse position for each item. Again, the result is a hot stream. As before, it will produce a position any time the mouse moves while the <code>background</code> element has captured the mouse, but it will also produce a position each time either the <code>MouseDown</code> or <code>MouseUp</code> event occurs. I could subscribe to this with the same call shown in the final line of <a data-type="xref" href="#filtering_items_with_a_linq_query">Example 11-15</a> to keep my UI up to date, and this time, I wouldn’t be missing the start and end positions.</p>
<p>In the example I’ve just shown, the sources are all endless, but that will not always be the case. What should a merged observable do when one of its inputs stops? If one stops due to an error, that error will be passed on by the merged observable, at which point it will be complete—an observable is not allowed to continue producing items after reporting an error. However, although an input can unilaterally terminate the output with an error, if inputs complete normally, the merged observable doesn’t complete until all of its inputs are complete.</p>
</div></section>
<section data-pdf-bookmark="Windowing Operators" data-type="sect2"><div class="sect2" id="windowing_operators">
<h2>Windowing Operators</h2>
<p><a data-primary="query operators, Rx" data-secondary="Buffer" data-type="indexterm" id="ch11-win2"/><a data-primary="query operators, Rx" data-secondary="Window" data-type="indexterm" id="ch11-win"/><a data-primary="windowing operators" data-type="indexterm" id="ix_ch11-asciidoc25"/>Rx defines two operators, <a data-primary="Buffer operator" data-type="indexterm" id="ix_ch11-asciidoc26"/><a data-primary="windowing operators" data-secondary="Buffer operator" data-type="indexterm" id="ix_ch11-asciidoc27"/><code>Buffer</code> and <code>Window</code>, that both produce an observable output where each item is based on multiple adjacent items from the source. (The name <code>Window</code> has nothing to do with UIs, by the way.) <a data-type="xref" href="#sliding_windows_with_the_buffer_operator">Figure 11-8</a> shows three ways in which you could use the <code>Buffer</code> operator. I’ve numbered the circles representing items in the input, and below this are blobs representing the items that will emerge from the observable source produced by <code>Buffer</code>, with lines and numbers indicating which input items are associated with each output item. <code>Window</code> works in a very similar way, as you’ll see shortly.</p>
<figure><div class="figure" id="sliding_windows_with_the_buffer_operator">
<img alt="" height="441" src="assets/pc10_1108.png" width="600"/>
<h6><span class="label">Figure 11-8. </span>Sliding windows with the <code>Buffer</code> operator</h6>
</div></figure>
<p>In the first case, I’ve passed arguments of <code>(2, 2)</code>, indicating that I want each output item to correspond to two input items and that I want to start a new buffer on every second input item. That may sound like two different ways of saying the same thing until you look at the second example in <a data-type="xref" href="#sliding_windows_with_the_buffer_operator">Figure 11-8</a>, in which arguments of <code>(3, 2)</code> indicate that each output item corresponds to three items from the input, but I still want the buffers to begin on every other input. This means that each <em>window</em>—the set of items from the input used to build an output item—overlaps with its neighbors. This will happen whenever the second argument, the <em>skip</em>, is smaller than the window. The first output item’s window contains the first, second, and third input. The second output’s window contains the third, fourth, and fifth, so the third item appears in both.</p>
<p>The final example in the figure shows a window size of three, but this time I’ve asked for a skip size of one—so in this case, the window moves along by only one input item at a time, but it incorporates three items from the source each time. I could also specify a skip that is larger than the window, in which case the input items that fell between windows would simply be ignored.</p>
<p>The <code>Buffer</code> and <code>Window</code> operators tend to introduce a lag. In the second and third cases, the window size of three means that the input observable needs to produce its third value before the whole window can be provided for the output item. With <code>Buffer</code>, this always means a delay of the size of the window, but as you’ll see, with the <code>Window</code> operator, each window can get under way before it is full.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>Buffer</code> offers an overload that takes a single number, which has the same effect as passing the same number twice. (E.g., instead of <code>Buffer(2, 2)</code>, you could write just <code>Buffer(2)</code>.) This is logically equivalent to LINQ to Objects’ <code>Chunk</code> operator. As discussed in <a data-type="xref" href="ch10.xhtml#ch_linq">Chapter 10</a>, the main reason Rx didn’t use the same name is that Rx invented <code>Buffer</code> about a decade before LINQ to Objects added <code>Chunk</code>.</p>
</div>
<p>The difference between the <code>Buffer</code> and <code>Window</code> operators is the way in which they present the windowed items. <code>Buffer</code> is the most straightforward. It provides an <code class="keep-together">IObservable&lt;IList&lt;T&gt;&gt;</code>, where <code>T</code> is the input item type. In other words, if you subscribe to the output of <code>Buffer</code>, for each window produced, your subscriber will be passed a list containing all the items in the window. <a data-type="xref" href="#smoothing_input_with_buffer">Example 11-22</a> uses this to produce a smoothed-out version of the mouse locations from <a data-type="xref" href="#filtering_items_with_a_linq_query">Example 11-15</a>.</p>
<div data-type="example" id="smoothing_input_with_buffer">
<h5><span class="label">Example 11-22. </span>Smoothing input with <code>Buffer</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">IObservable</code><code class="p">&lt;</code><code class="n">Point</code><code class="p">&gt;</code> <code class="n">smoothed</code> <code class="p">=</code> <code class="k">from</code> <code class="n">points</code> <code class="k">in</code> <code class="n">dragPositions</code><code class="p">.</code><code class="n">Buffer</code><code class="p">(</code><code class="m">5</code><code class="p">,</code> <code class="m">2</code><code class="p">)</code>
                              <code class="k">let</code> <code class="n">x</code> <code class="p">=</code> <code class="n">points</code><code class="p">.</code><code class="n">Average</code><code class="p">(</code><code class="n">p</code> <code class="p">=&gt;</code> <code class="n">p</code><code class="p">.</code><code class="n">X</code><code class="p">)</code>
                              <code class="k">let</code> <code class="n">y</code> <code class="p">=</code> <code class="n">points</code><code class="p">.</code><code class="n">Average</code><code class="p">(</code><code class="n">p</code> <code class="p">=&gt;</code> <code class="n">p</code><code class="p">.</code><code class="n">Y</code><code class="p">)</code>
                              <code class="k">select</code> <code class="k">new</code> <code class="nf">Point</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code><code class="p">);</code></pre></div>
<p>The first line of this query states that I want to see groups of five consecutive mouse locations, and I want one group for every other input. The rest of the query calculates the average mouse position within the window and produces that as the output item. <a data-type="xref" href="#smoothing_in_action">Figure 11-9</a> shows the effect. The top line is the result of using the raw mouse positions. The line immediately beneath it uses the smoothed points generated by <a data-type="xref" href="#smoothing_input_with_buffer">Example 11-22</a> from the same input. As you can see, the top line is rather ragged, but the bottom line has smoothed out a lot of the lumps.</p>
<figure><div class="figure" id="smoothing_in_action">
<img alt="" height="119" src="assets/pc10_1109.png" width="406"/>
<h6><span class="label">Figure 11-9. </span>Smoothing in action</h6>
</div></figure>
<p><a data-type="xref" href="#smoothing_input_with_buffer">Example 11-22</a> uses a mixture of LINQ to Objects and Rx’s LINQ implementation. The query expression itself uses Rx, but the range variable, <code>points</code>, is of type <code>IList&lt;Point&gt;</code> (because <code>Buffer</code> returns an <code>IObservable&lt;IList&lt;Point&gt;&gt;</code> in this example). So the nested queries that invoke the <code>Average</code> operator on <code>points</code> will get the LINQ to Objects implementation.</p>
<p>If the <code>Buffer</code> operator’s input is hot, it will produce a hot observable as a result. So you could subscribe to the observable in the <code>smoothed</code> variable in <a data-type="xref" href="#smoothing_input_with_buffer">Example 11-22</a> with similar code to the final line of <a data-type="xref" href="#filtering_items_with_a_linq_query">Example 11-15</a>, and it would show the smoothed line in real time as you drag the mouse. As discussed, there will be a slight lag, of course—the code specifies a skip of two, so it will update the screen only for every other mouse event. Averaging over the last five points will also tend to increase the gap between the mouse pointer and the end of the line. With these parameters, the discrepancy is small enough not to be too distracting, but with more aggressive smoothing, it could get annoying.<a data-startref="ix_ch11-asciidoc27" data-type="indexterm" id="idm45884798816240"/><a data-startref="ix_ch11-asciidoc26" data-type="indexterm" id="idm45884798815568"/></p>
<p><a data-primary="Window operator" data-type="indexterm" id="ix_ch11-asciidoc28"/><a data-primary="windowing operators" data-secondary="Window operator" data-type="indexterm" id="ix_ch11-asciidoc29"/>The <code>Window</code> operator is very similar to the <code>Buffer</code> operator, but instead of presenting each window as an <code>IList&lt;T&gt;</code>, it provides an <code>IObservable&lt;T&gt;</code>. If you used <code>Window</code> on <code>dragPositions</code> in <a data-type="xref" href="#smoothing_input_with_buffer">Example 11-22</a>, the result would be <code>IObservable&lt;IObserva⁠ble​&lt;Point&gt;&gt;</code>. <a data-type="xref" href="#window_operator">Figure 11-10</a> shows how the <code>Window</code> operator would work in the last of the scenarios illustrated in <a data-type="xref" href="#sliding_windows_with_the_buffer_operator">Figure 11-8</a>, and as you can see, it can start each window sooner. It doesn’t have to wait until all of the items in the window are available; instead of providing a fully populated list containing the window, each output item is an <code>IObservable&lt;T&gt;</code> that will produce the window’s items as and when they become available. Each observable produced by <code>Window</code> completes immediately after supplying the final item (i.e., at the same instant at which <code>Buffer</code> would have provided the whole window). So, if your processing depends on having the whole window, <code>Window</code> can’t get it to you any faster, because it’s ultimately governed by the rate at which input items arrive, but it will start to provide values earlier.</p>
<p>One potentially surprising feature of the observables produced by <code>Window</code> in this example is their start times. Whereas they end immediately after producing their final item, they do not start immediately before producing their first. The observable representing the very first window starts right away—you will receive that observable as soon as you subscribe to the observable of observables the operator returns. So the first window will be available immediately, even if the <code>Window</code> operator’s input hasn’t done anything yet. Then each new window starts as soon as all the input items it needs to skip have been received. In this example, I’m using a skip count of one, so the second window starts after the input has produced one item, the third after two have been produced, and so on.</p>
<p>As you’ll see later in this section, and also in <a data-type="xref" href="#timed_operations">“Timed Operations”</a>, <code>Window</code> and <code>Buffer</code> support some other ways to define when each window starts and stops. The general pattern is that as soon as the <code>Window</code> operator gets to a point where a new item from the source would go into a new window, the operator creates that window, anticipating the window’s first item rather than waiting for it (see <a data-type="xref" href="#window_operator">Figure 11-10</a>).</p>
<figure><div class="figure" id="window_operator">
<img alt="" height="524" src="assets/pc10_1110.png" width="600"/>
<h6><span class="label">Figure 11-10. </span><code>Window</code> operator</h6>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If the input completes, all currently open windows will also complete. This means that it’s possible to see empty windows. (In fact, with a skip size of one, you’re guaranteed to get one empty window if the source completes.) In <a data-type="xref" href="#window_operator">Figure 11-10</a>, one window right at the bottom has started but has not yet produced any items. If the input were to complete without producing any more items, the three observable sources still in progress would also complete, including that final one that hasn’t yet produced anything.</p>
</div>
<p>Because <code>Window</code> delivers items into windows as soon as the source provides them, it might enable you to get started with processing sooner than you can with <code>Buffer</code>, perhaps improving overall responsiveness. The downside of <code>Window</code> is that it tends to be more complex—your subscribers will start receiving output values before all the items for the corresponding input window are available. Whereas <code>Buffer</code> provides you with a list that you can inspect at your leisure, with <code>Window</code>, you’ll need to continue working in Rx’s world of sequences that produce items only when they’re good and ready. To perform the same smoothing as <a data-type="xref" href="#smoothing_input_with_buffer">Example 11-22</a> with <code>Window</code> requires the code in <a data-type="xref" href="#smoothing_with_window">Example 11-23</a>.</p>
<div data-type="example" id="smoothing_with_window">
<h5><span class="label">Example 11-23. </span>Smoothing with <code>Window</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">IObservable</code><code class="p">&lt;</code><code class="n">Point</code><code class="p">&gt;</code> <code class="n">smoothed</code> <code class="p">=</code>
    <code class="k">from</code> <code class="n">points</code> <code class="k">in</code> <code class="n">dragPositions</code><code class="p">.</code><code class="n">Window</code><code class="p">(</code><code class="m">5</code><code class="p">,</code> <code class="m">2</code><code class="p">)</code>
    <code class="k">from</code> <code class="n">totals</code> <code class="k">in</code> <code class="n">points</code><code class="p">.</code><code class="n">Aggregate</code><code class="p">(</code>
      <code class="k">new</code> <code class="p">{</code> <code class="n">X</code> <code class="p">=</code> <code class="m">0.0</code><code class="p">,</code> <code class="n">Y</code> <code class="p">=</code> <code class="m">0.0</code><code class="p">,</code> <code class="n">Count</code> <code class="p">=</code> <code class="m">0</code> <code class="p">},</code>
      <code class="p">(</code><code class="n">acc</code><code class="p">,</code> <code class="n">point</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="k">new</code>
          <code class="p">{</code> <code class="n">X</code> <code class="p">=</code> <code class="n">acc</code><code class="p">.</code><code class="n">X</code> <code class="p">+</code> <code class="n">point</code><code class="p">.</code><code class="n">X</code><code class="p">,</code> <code class="n">Y</code> <code class="p">=</code> <code class="n">acc</code><code class="p">.</code><code class="n">Y</code> <code class="p">+</code> <code class="n">point</code><code class="p">.</code><code class="n">Y</code><code class="p">,</code> <code class="n">Count</code> <code class="p">=</code> <code class="n">acc</code><code class="p">.</code><code class="n">Count</code> <code class="p">+</code> <code class="m">1</code> <code class="p">})</code>
    <code class="k">where</code> <code class="n">totals</code><code class="p">.</code><code class="n">Count</code> <code class="p">&gt;</code> <code class="m">0</code>
    <code class="k">select</code> <code class="k">new</code> <code class="nf">Point</code><code class="p">(</code><code class="n">totals</code><code class="p">.</code><code class="n">X</code> <code class="p">/</code> <code class="n">totals</code><code class="p">.</code><code class="n">Count</code><code class="p">,</code> <code class="n">totals</code><code class="p">.</code><code class="n">Y</code> <code class="p">/</code> <code class="n">totals</code><code class="p">.</code><code class="n">Count</code><code class="p">);</code></pre></div>
<p>This is a little more complicated because I’ve been unable to use the <code>Average</code> operator, due to the need to cope with the possibility of empty windows. (Strictly speaking, that doesn’t matter in the case where I have one <code>Polyline</code> that keeps getting longer and longer. But if I group the points by drag operation, as <a data-type="xref" href="#adding_a_new_line_for_each_drag_operatio">Example 11-20</a> does, each individual observable source of points will complete at the end of the drag, forcing me to handle any empty windows.) <a data-primary="Aggregate operator" data-type="indexterm" id="idm45884798666992"/><a data-primary="LINQ operators" data-secondary="Aggregate" data-type="indexterm" id="idm45884798666384"/>The <code>Average</code> operator produces an error if you provide it with an empty sequence, so I’ve used the <code>Aggregate</code> operator instead, which lets me add a <code>where</code> clause to filter out empty windows instead of crashing. But that’s not the only aspect that is more complex.</p>
<p>As I mentioned earlier, all of Rx’s aggregation operators—<code>Aggregate</code>, <code>Min</code>, <code>Max</code>, and so on—work differently than with most LINQ providers. LINQ requires these operators to reduce the stream down to a single value, so they normally return a single value. For example, if I were to call the LINQ to Objects version of <code>Aggregate</code> with the arguments shown in <a data-type="xref" href="#smoothing_with_window">Example 11-23</a>, it would return a single value of the anonymous type I’m using for my accumulator. But in Rx, the return type is <code>IObservable&lt;T&gt;</code> (where <code>T</code> is that accumulator type in this case). It still produces a single value, but it presents that value through an observable source. Unlike LINQ to Objects, which can enumerate its input to calculate, say, an average, the Rx operator has to wait for the source to provide its values, so it can’t produce an aggregate of those values until the source says it has finished.</p>
<p>Because the <code>Aggregate</code> operator returns an <code>IObservable&lt;T&gt;</code>, I’ve had to use a second <code>from</code> clause. This passes that source to the <code>SelectMany</code> operator, which extracts all values and makes them appear in the final stream—in this case, there is just one value (per window), so <code>SelectMany</code> is effectively unwrapping the averaged point from its single-item stream.</p>
<p>The code in <a data-type="xref" href="#smoothing_with_window">Example 11-23</a> is a little more complex than <a data-type="xref" href="#smoothing_input_with_buffer">Example 11-22</a>, and I think it’s considerably harder to understand how it works. Worse, it doesn’t even offer any benefit. The <code>Aggregate</code> operator will begin its work as soon as inputs become available, but the code cannot produce the final result—the average—until it has seen every point in the window. If I’m going to have to wait until the end of the window before I can update the UI, I may as well stick with <code>Buffer</code>. So, in this particular case, <code>Window</code> was a lot more work for no benefit. However, if the work being done on the items in the window was less trivial, or if the volumes of data involved were so large that you didn’t want to buffer the entire window before starting to process it, the extra complexity could be worth the benefit of being able to start the aggregation process without having to wait for the whole input window to become available.</p>
<section data-pdf-bookmark="Demarcating windows with observables" data-type="sect3"><div class="sect3" id="demarcating_windows_with_observables">
<h3>Demarcating windows with observables</h3>
<p><a data-primary="windowing operators" data-secondary="demarcating windows with observables" data-type="indexterm" id="idm45884798615152"/>The <code>Window</code> and <code>Buffer</code> operators provide some other ways of defining when windows should start and finish. Just as the join operators can specify duration with an observable, you can supply a function that returns a duration-defining observable for each window. <a data-type="xref" href="#breaking_text_into_words_with_windows">Example 11-24</a> uses this to break keyboard input into words. The <code>keySource</code> variable in this example is the one from <a data-type="xref" href="#delegate-based_hot_source">Example 11-11</a>. It’s an observable sequence that produces an item for each keypress.</p>
<div data-type="example" id="breaking_text_into_words_with_windows">
<h5><span class="label">Example 11-24. </span>Breaking text into words with windows</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">IObservable</code><code class="p">&lt;</code><code class="n">IObservable</code><code class="p">&lt;</code><code class="kt">char</code><code class="p">&gt;&gt;</code> <code class="n">wordWindows</code> <code class="p">=</code> <code class="n">keySource</code><code class="p">.</code><code class="n">Window</code><code class="p">(</code>
    <code class="p">()</code> <code class="p">=&gt;</code> <code class="n">keySource</code><code class="p">.</code><code class="n">FirstAsync</code><code class="p">(</code><code class="kt">char</code><code class="p">.</code><code class="n">IsWhiteSpace</code><code class="p">));</code>

<code class="n">IObservable</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">words</code> <code class="p">=</code> <code class="k">from</code> <code class="n">wordWindow</code> <code class="k">in</code> <code class="n">wordWindows</code>
                            <code class="k">from</code> <code class="n">chars</code> <code class="k">in</code> <code class="n">wordWindow</code><code class="p">.</code><code class="n">ToArray</code><code class="p">()</code>
                            <code class="k">select</code> <code class="k">new</code> <code class="nf">string</code><code class="p">(</code><code class="n">chars</code><code class="p">).</code><code class="n">Trim</code><code class="p">();</code>

<code class="n">words</code><code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="n">word</code> <code class="p">=&gt;</code> <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Word: "</code> <code class="p">+</code> <code class="n">word</code><code class="p">));</code></pre></div>
<p>The <code>Window</code> operator will immediately create a new window in this example, and it will also invoke the lambda I’ve supplied to find out when that window should end. It will keep it open until the observable source my lambda returns either produces a value or completes. When that happens, <code>Window</code> will immediately open the next window, invoking my lambda again to get another observable to determine the length of the second window, and so on. The lambda here produces the next whitespace character from the keyboard, so the window will close on the next space. In other words, this breaks the input sequence into a series of windows where each window contains zero or more nonwhitespace characters followed by one whitespace 
<span class="keep-together">character.</span></p>
<p>The observable sequence the <code>Window</code> operator returns presents each window as an <code>IObservable&lt;char&gt;</code>. The second statement in <a data-type="xref" href="#breaking_text_into_words_with_windows">Example 11-24</a> is a query that converts each window to a string. (This will produce empty strings if the input contains multiple adjacent whitespace characters. That’s consistent with the behavior of the <code>string</code> type’s <code>Split</code> method, which performs the pull-oriented equivalent of this partitioning. If you don’t like it, you can always filter out the blanks with a <code>where</code> clause.)</p>
<p>Because <a data-type="xref" href="#breaking_text_into_words_with_windows">Example 11-24</a> uses <code>Window</code>, it will start making characters for each word available as soon as the user types them. But because my query calls <code>ToArray</code> on the window, it will end up waiting until the window completes before producing anything. This means <code>Buffer</code> would be equally effective. It would also be simpler. As <a data-type="xref" href="#work_breaking_with_buffer">Example 11-25</a> shows, I don’t need a second <code>from</code> clause to collect the completed window if I use <code>Buffer</code>, because it provides me with windows only once they are complete<a data-startref="ix_ch11-asciidoc29" data-type="indexterm" id="idm45884798500720"/><a data-startref="ix_ch11-asciidoc28" data-type="indexterm" id="idm45884798500112"/>.<a data-startref="ix_ch11-asciidoc25" data-type="indexterm" id="idm45884798499376"/><a data-startref="ch11-win" data-type="indexterm" id="idm45884798498768"/><a data-startref="ch11-win2" data-type="indexterm" id="idm45884798498160"/></p>
<div data-type="example" id="work_breaking_with_buffer">
<h5><span class="label">Example 11-25. </span>Word breaking with <code>Buffer</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">IObservable</code><code class="p">&lt;</code><code class="n">IList</code><code class="p">&lt;</code><code class="kt">char</code><code class="p">&gt;&gt;</code> <code class="n">wordWindows</code> <code class="p">=</code> <code class="n">keySource</code><code class="p">.</code><code class="n">Buffer</code><code class="p">(</code>
    <code class="p">()</code> <code class="p">=&gt;</code> <code class="n">keySource</code><code class="p">.</code><code class="n">FirstAsync</code><code class="p">(</code><code class="kt">char</code><code class="p">.</code><code class="n">IsWhiteSpace</code><code class="p">));</code>

<code class="n">IObservable</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">words</code> <code class="p">=</code> <code class="k">from</code> <code class="n">wordWindow</code> <code class="k">in</code> <code class="n">wordWindows</code>
                            <code class="k">select</code> <code class="k">new</code> <code class="nf">string</code><code class="p">(</code><code class="n">wordWindow</code><code class="p">.</code><code class="n">ToArray</code><code class="p">()).</code><code class="n">Trim</code><code class="p">();</code></pre></div>
</div></section>
</div></section>
<section data-pdf-bookmark="The Scan Operator" data-type="sect2"><div class="sect2" id="the_scan_operator">
<h2>The Scan Operator</h2>
<p><a data-primary="query operators, Rx" data-secondary="Scan" data-type="indexterm" id="idm45884798424496"/><a data-primary="Scan operator" data-type="indexterm" id="idm45884798423552"/>The <code>Scan</code> operator is very similar to the standard <code>Aggregate</code> operator, with one difference. Instead of producing a single result after its source completes, it produces a sequence containing each accumulator value in turn. To illustrate this, I will first introduce a record type that will act as a very simple model for a stock trade. This type, shown in <a data-type="xref" href="#simple_stock_trade_with_test_stream">Example 11-26</a>, also defines a static method that provides a randomly generated stream of trades for test purposes.</p>
<div data-type="example" id="simple_stock_trade_with_test_stream">
<h5><span class="label">Example 11-26. </span>Simple stock trade with test stream</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="n">record</code> <code class="nf">Trade</code><code class="p">(</code><code class="kt">string</code> <code class="n">StockName</code><code class="p">,</code> <code class="kt">decimal</code> <code class="n">UnitPrice</code><code class="p">,</code> <code class="kt">int</code> <code class="n">Number</code><code class="p">)</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">static</code> <code class="n">IObservable</code><code class="p">&lt;</code><code class="n">Trade</code><code class="p">&gt;</code> <code class="n">TestStream</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="k">return</code> <code class="n">Observable</code><code class="p">.</code><code class="n">Create</code><code class="p">&lt;</code><code class="n">Trade</code><code class="p">&gt;(</code><code class="n">obs</code> <code class="p">=&gt;</code>
        <code class="p">{</code>
            <code class="kt">string</code><code class="p">[]</code> <code class="n">names</code> <code class="p">=</code> <code class="p">{</code> <code class="s">"MSFT"</code><code class="p">,</code> <code class="s">"GOOGL"</code><code class="p">,</code> <code class="s">"AAPL"</code> <code class="p">};</code>
            <code class="kt">var</code> <code class="n">r</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Random</code><code class="p">(</code><code class="m">0</code><code class="p">);</code>
            <code class="k">for</code> <code class="p">(</code><code class="kt">int</code> <code class="n">i</code> <code class="p">=</code> <code class="m">0</code><code class="p">;</code> <code class="n">i</code> <code class="p">&lt;</code> <code class="m">100</code><code class="p">;</code> <code class="p">++</code><code class="n">i</code><code class="p">)</code>
            <code class="p">{</code>
                <code class="kt">var</code> <code class="n">t</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Trade</code><code class="p">(</code>
                    <code class="n">StockName</code><code class="p">:</code> <code class="n">names</code><code class="p">[</code><code class="n">r</code><code class="p">.</code><code class="n">Next</code><code class="p">(</code><code class="n">names</code><code class="p">.</code><code class="n">Length</code><code class="p">)],</code>
                    <code class="n">UnitPrice</code><code class="p">:</code> <code class="n">r</code><code class="p">.</code><code class="n">Next</code><code class="p">(</code><code class="m">1</code><code class="p">,</code> <code class="m">100</code><code class="p">),</code>
                    <code class="n">Number</code><code class="p">:</code> <code class="n">r</code><code class="p">.</code><code class="n">Next</code><code class="p">(</code><code class="m">10</code><code class="p">,</code> <code class="m">1000</code><code class="p">));</code>
                <code class="n">obs</code><code class="p">.</code><code class="n">OnNext</code><code class="p">(</code><code class="n">t</code><code class="p">);</code>
            <code class="p">}</code>
            <code class="n">obs</code><code class="p">.</code><code class="n">OnCompleted</code><code class="p">();</code>
            <code class="k">return</code> <code class="n">Disposable</code><code class="p">.</code><code class="n">Empty</code><code class="p">;</code>
        <code class="p">});</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p><a data-type="xref" href="#summing_with_aggregate">Example 11-27</a> shows the normal <code>Aggregate</code> operator being used to calculate the total number of stocks traded, by adding up the <code>Number</code> property of every trade. (You’d normally just use the <code>Sum</code> operator, of course, but I’m showing this for comparison with <code>Scan</code>.)</p>
<div data-type="example" id="summing_with_aggregate">
<h5><span class="label">Example 11-27. </span>Summing with <code>Aggregate</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">IObservable</code><code class="p">&lt;</code><code class="n">Trade</code><code class="p">&gt;</code> <code class="n">trades</code> <code class="p">=</code> <code class="n">Trade</code><code class="p">.</code><code class="n">TestStream</code><code class="p">();</code>

<code class="n">IObservable</code><code class="p">&lt;</code><code class="kt">long</code><code class="p">&gt;</code> <code class="n">tradeVolume</code> <code class="p">=</code> <code class="n">trades</code><code class="p">.</code><code class="n">Aggregate</code><code class="p">(</code>
    <code class="m">0L</code><code class="p">,</code> <code class="p">(</code><code class="n">total</code><code class="p">,</code> <code class="n">trade</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">total</code> <code class="p">+</code> <code class="n">trade</code><code class="p">.</code><code class="n">Number</code><code class="p">);</code>
<code class="n">tradeVolume</code><code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">);</code></pre></div>
<p>This displays a single number, because the observable produced by <code>Aggregate</code> provides only a single value. <a data-type="xref" href="#running_total_with_scan">Example 11-28</a> shows almost exactly the same code but using <code>Scan</code> instead.</p>
<div data-type="example" id="running_total_with_scan">
<h5><span class="label">Example 11-28. </span>Running total with <code>Scan</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">IObservable</code><code class="p">&lt;</code><code class="n">Trade</code><code class="p">&gt;</code> <code class="n">trades</code> <code class="p">=</code> <code class="n">Trade</code><code class="p">.</code><code class="n">TestStream</code><code class="p">();</code>

<code class="n">IObservable</code><code class="p">&lt;</code><code class="kt">long</code><code class="p">&gt;</code> <code class="n">tradeVolume</code> <code class="p">=</code> <code class="n">trades</code><code class="p">.</code><code class="n">Scan</code><code class="p">(</code>
    <code class="m">0L</code><code class="p">,</code> <code class="p">(</code><code class="n">total</code><code class="p">,</code> <code class="n">trade</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">total</code> <code class="p">+</code> <code class="n">trade</code><code class="p">.</code><code class="n">Number</code><code class="p">);</code>
<code class="n">tradeVolume</code><code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">);</code></pre></div>
<p>Instead of producing a single output value, this produces one output item for each input, which is the running total for all items the source has produced so far. <code>Scan</code> is particularly useful if you need aggregation-like behavior in an endless stream, such as one based on an event source. <code>Aggregate</code> is no use in that scenario because it will not produce anything if its input never completes.</p>
</div></section>
<section data-pdf-bookmark="The Amb Operator" data-type="sect2"><div class="sect2" id="the_amb_operator">
<h2>The Amb Operator</h2>
<p><a data-primary="Amb operator" data-type="indexterm" id="idm45884798079776"/><a data-primary="query operators, Rx" data-secondary="Amb" data-type="indexterm" id="idm45884798078848"/>Rx defines an operator with the somewhat cryptic name of <code>Amb</code>. (See the next sidebar, <a href="#why_amb_question">“Why Amb?”</a>) This takes any number of observable sequences and waits to see which one does something first. (The documentation talks about which of the inputs “reacts” first. This means that it calls any of the three <code>IObserver&lt;T&gt;</code> methods.) Whichever input jumps into action first effectively becomes the <code>Amb</code> operator’s output—it forwards everything the chosen stream does, immediately unsubscribing from the other streams. (If any of them manage to produce elements after the first stream does, but before the operator has had time to unsubscribe, those elements will be ignored.)</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="why_amb_question">
<h5>Why Amb?</h5>
<p>The <code>Amb</code> operator’s name is short for <em>ambiguous</em>. This seems like a violation of Microsoft’s own class library design guidelines, which forbid abbreviations unless the shortened form is more widely used than the full name and likely to be understood even by nonexperts. This operator’s name is well established—it was introduced in 1963 in a paper by John McCarthy (inventor of the LISP programming language). However, it’s not all that widely used, so the name fails the test of being instantly understandable by nonexperts.</p>
<p>However, the expanded name isn’t really any more transparent. If you’re not already familiar with the operator, the name <code>Ambiguous</code> wouldn’t be much more help in trying to guess what it does than just <code>Amb</code>. If you are familiar with it, you will already know that it’s called <code>Amb</code>. So there is no obvious downside to using the abbreviation, and there’s a benefit for people who already know it.</p>
<p>Another reason the Rx team used this name was to pay homage to John McCarthy, whose work was profoundly influential for computing in general, and for the LINQ and Rx projects in particular. (McCarthy’s work had a direct impact on many of the features discussed in this chapter and <a data-type="xref" href="ch10.xhtml#ch_linq">Chapter 10</a>.)</p>
</div></aside>
<p>You might use this operator to optimize a system’s response time by sending a request to multiple machines in a server pool and using the result from whichever responds first. (There are dangers with this technique, of course, not least of which is that it could increase the overall load on your system so much that the effect is to slow everything down, not speed anything up. However, there are some scenarios in which careful application of this technique can be successful.)</p>
</div></section>
<section data-pdf-bookmark="DistinctUntilChanged" data-type="sect2"><div class="sect2" id="distinctuntilchanged">
<h2>DistinctUntilChanged</h2>
<p><a data-primary="DistinctUntilChanged operator" data-type="indexterm" id="idm45884798067552"/><a data-primary="query operators, Rx" data-secondary="DistinctUntilChanged" data-type="indexterm" id="idm45884798066880"/>The final operator I’m going to describe in this section is very simple but rather useful. The <code>DistinctUntilChanged</code> operator removes adjacent duplicates. Suppose you have an observable source that produces items on a regular basis but tends to produce the same value multiple times in a row. You might need to take action only when a different value emerges. <code>DistinctUntilChanged</code> is for exactly this scenario—when its input produces an item, it will be passed on only if it was different from the previous item (or if it was the first item).</p>
<p>I’ve not yet shown all of the Rx operators I want to introduce. However, the remaining ones, which I’ll discuss in <a data-type="xref" href="#timed_operations">“Timed Operations”</a>, are all time sensitive. And before I can show those, I need to describe how Rx handles timing.<a data-startref="ix_ch11-asciidoc23" data-type="indexterm" id="idm45884798063152"/><a data-startref="ix_ch11-asciidoc22" data-type="indexterm" id="idm45884798062480"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Schedulers" data-type="sect1"><div class="sect1" id="schedulers">
<h1>Schedulers</h1>
<p><a data-primary="reactive extensions (Rx)" data-secondary="schedulers" data-type="indexterm" id="ix_ch11-asciidoc30"/><a data-primary="schedulers (Rx)" data-type="indexterm" id="ix_ch11-asciidoc31"/>Rx performs certain work through <em>schedulers</em>. A scheduler is an object that provides three services. The first is to decide when to execute a particular piece of work. For example, when an observer subscribes to a cold source, should the source’s items be delivered to the subscriber immediately, or should that work be deferred? The second service is to run work in a particular context. A scheduler might decide always to execute work on a particular thread, for example. The third job is to keep track of time. Some Rx operations are time dependent; to ensure predictable behavior and to enable testing, schedulers provide a virtualized model for time, so Rx code does not have to depend on the current time of day reported by .NET’s <code>DateTimeOffset</code> class.</p>
<p>The scheduler’s first two roles are sometimes interdependent. For example, Rx supplies a few schedulers for use in UI applications. There’s a <code>CoreDispatcherScheduler</code> for Windows Store apps, <code>DispatcherScheduler</code> for WPF applications, <code>Control​Sched⁠uler</code> for Windows Forms programs, and a more generic one called 
<span class="keep-together"><code>SynchronizationContextScheduler</code>,</span> which will work in all .NET UI frameworks, albeit with slightly less control over the details than the framework-specific ones. All of these have a common characteristic: they ensure that work executes in a suitable context for accessing UI objects, which typically means running the work on a particular thread. If code that schedules work is running on some other thread, the scheduler may have no choice but to defer the work, because it will not be able to run it until the UI framework is ready. This might mean waiting for a particular thread to finish whatever it is doing. In this case, running the work in the right context necessarily also has an impact on when the work is executed.</p>
<p>This isn’t always the case, though. Rx provides two schedulers that use the current thread. One of them, <code>ImmediateScheduler</code>, is extremely simple: it runs work the instant it is scheduled. When you give this scheduler some work, it won’t return until the work is complete. The other, <code>CurrentThreadScheduler</code>, maintains a work queue, which gives it some flexibility with ordering. For example, if some work is scheduled in the middle of executing some other piece of work, it can allow the work item in progress to finish before starting on the next. If no work items are queued or in progress, <code>CurrentThreadScheduler</code> runs work immediately, just like <code>Immediate​Sched⁠uler</code>. When a work item it has invoked completes, the <code>Current​Th⁠read​Sched⁠uler</code> inspects the queue and will invoke the next item if it’s not empty. So it attempts to complete all work items as quickly as possible, but unlike <code>ImmediateScheduler</code>, it will not start to process a new work item before the previous one has finished.</p>
<section data-pdf-bookmark="Specifying Schedulers" data-type="sect2"><div class="sect2" id="specifying_schedulers">
<h2>Specifying Schedulers</h2>
<p><a data-primary="schedulers (Rx)" data-secondary="specifying" data-type="indexterm" id="ix_ch11-asciidoc32"/>Rx operations often do not go through schedulers. Many observable sources invoke their subscribers’ methods directly. Sources that can generate a large number of items in quick succession are typically an exception. For example, the <code>Range</code> and <code>Repeat</code> methods for creating sequences use a scheduler to govern the rate at which they provide items to new subscribers. You can pass in an explicit scheduler or let them pick a default one. You can also get a scheduler involved explicitly even when using sources that don’t accept one as an argument.</p>
<section data-pdf-bookmark="ObserveOn" data-type="sect3"><div class="sect3" id="observeon">
<h3>ObserveOn</h3>
<p><a data-primary="ObserveOn extension methods" data-type="indexterm" id="idm45884798044320"/><a data-primary="schedulers (Rx)" data-secondary="ObserveOn extension method" data-type="indexterm" id="idm45884798043648"/>A common way to specify a scheduler is with one of the <code>ObserveOn</code> extension methods defined by various static classes in the <code>System.Reactive.Linq</code> namespace.<sup><a data-type="noteref" href="ch11.xhtml#CHP-11-FN-4" id="CHP-11-FN-4-marker">4</a></sup> This is useful if you want to handle events in a specific context (such as the UI thread) even though they may originate from somewhere else.</p>
<p>You can invoke <code>ObserveOn</code> on any <code>IObservable&lt;T&gt;</code>, passing in an <code>IScheduler</code>, and it returns another <code>IObservable&lt;T&gt;</code>. If you subscribe to the observable that returns, your observer’s <code>OnNext</code>, <code>OnCompleted</code>, and <code>OnError</code> methods will all be invoked through the scheduler you specified. <a data-type="xref" href="#observeon_specific_scheduler">Example 11-29</a> uses this to ensure that it’s safe to update the UI in the item handler callback.</p>
<div data-type="example" id="observeon_specific_scheduler">
<h5><span class="label">Example 11-29. </span><code>ObserveOn</code> specific scheduler</h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="n">IObservable</code><code class="p">&lt;</code><code class="n">Trade</code><code class="p">&gt;</code><code> </code><code class="n">trades</code><code> </code><code class="p">=</code><code> </code><code class="n">GetTradeStream</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code>
</code><code class="n">IObservable</code><code class="p">&lt;</code><code class="n">Trade</code><code class="p">&gt;</code><code> </code><code class="n">tradesInUiContext</code><code> </code><code class="p">=</code><code>
</code><code>    </code><strong><code class="n">trades</code><code class="p">.</code><code class="n">ObserveOn</code><code class="p">(</code><code class="n">DispatcherScheduler</code><code class="p">.</code><code class="n">Current</code><code class="p">)</code><code class="p">;</code></strong><code>
</code><code class="n">tradesInUiContext</code><code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="n">t</code><code> </code><code class="p">=</code><code class="p">&gt;</code><code>
</code><code class="p">{</code><code>
</code><code>    </code><code class="n">tradeInfoTextBox</code><code class="p">.</code><code class="n">AppendText</code><code class="p">(</code><code>
</code><code>        </code><code class="err">$</code><code class="s">"{t.StockName}: {t.Number} at {t.UnitPrice}\r\n"</code><code class="p">)</code><code class="p">;</code><code>
</code><code class="p">}</code><code class="p">)</code><code class="p">;</code></pre></div>
<p>In this example, I used the <code>DispatcherScheduler</code> class’s static <code>Current</code> property, which returns a scheduler that executes work via the current thread’s <code>Dispatcher</code>. (<code>Dispatcher</code> is the class that manages the UI message loop in WPF applications.) Rx’s <code>DispatcherObservable</code> class defines various extension methods providing WPF-specific overloads, and instead of passing in a scheduler, I can call <code>ObserveOn</code> passing just a <code>Dispatcher</code> object. I could use this in the codebehind for a UI element with code such as that in <a data-type="xref" href="#observeon_wpf_dispatcher">Example 11-30</a>.</p>
<div data-type="example" id="observeon_wpf_dispatcher">
<h5><span class="label">Example 11-30. </span><code>ObserveOn</code> WPF <code>Dispatcher</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">IObservable</code><code class="p">&lt;</code><code class="n">Trade</code><code class="p">&gt;</code> <code class="n">tradesInUiContext</code> <code class="p">=</code> <code class="n">trades</code><code class="p">.</code><code class="n">ObserveOn</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="n">Dispatcher</code><code class="p">);</code></pre></div>
<p>The advantage of this overload is that I don’t need to be on the UI thread at the point at which I call <code>ObserveOn</code>. The <code>Current</code> property used in <a data-type="xref" href="#observeon_specific_scheduler">Example 11-29</a> works only if you are on the thread for the dispatcher you require. If I’m already on that thread, there’s an even simpler way to set this up. I can use the <code>ObserveOnDispatcher</code> extension method, which obtains a <code>DispatcherScheduler</code> for the current thread’s dispatcher, as shown in <a data-type="xref" href="#observing_on_the_current_dispatcher">Example 11-31</a>.</p>
<div data-type="example" id="observing_on_the_current_dispatcher">
<h5><span class="label">Example 11-31. </span>Observing on the current dispatcher</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">IObservable</code><code class="p">&lt;</code><code class="n">Trade</code><code class="p">&gt;</code> <code class="n">tradesInUiContext</code> <code class="p">=</code> <code class="n">trades</code><code class="p">.</code><code class="n">ObserveOnDispatcher</code><code class="p">();</code></pre></div>
</div></section>
<section data-pdf-bookmark="SubscribeOn" data-type="sect3"><div class="sect3" id="subscribeon">
<h3>SubscribeOn</h3>
<p><a data-primary="schedulers (Rx)" data-secondary="SubscribeOn extension method" data-type="indexterm" id="idm45884797892288"/><a data-primary="SubscribeOn extension method" data-type="indexterm" id="idm45884797891152"/>Most of the various <code>ObserveOn</code> extension methods have corresponding 
<span class="keep-together"><code>SubscribeOn</code></span> methods. (There’s also <code>SubscribeOnDispatcher</code>, the counterpart of <code>ObserveOn​Dis⁠patcher</code>.) Instead of arranging for each call to an observer’s methods to be made through the scheduler, <code>SubscribeOn</code> performs the call to the source observable’s <code>Subscribe</code> method through the scheduler. And if you unsubscribe by calling 
<span class="keep-together"><code>Dispose</code>,</span> that will also be delivered through the scheduler. This can be important for cold sources, because many perform significant work in their <code>Subscribe</code> method, some even delivering all of their items immediately.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In general, there’s no guarantee of any correspondence between the context in which you subscribe to a source and the context in which the items it produces will be delivered to a subscriber. Some sources will notify you from their subscription context, but many won’t. If you need to receive notifications in a particular context, then unless the source provides some way to specify a scheduler, use <code>ObserveOn</code>.</p>
</div>
</div></section>
<section data-pdf-bookmark="Passing schedulers explicitly" data-type="sect3"><div class="sect3" id="passing_schedulers_explicitly">
<h3>Passing schedulers explicitly</h3>
<p><a data-primary="schedulers (Rx)" data-secondary="passing schedulers explicitly" data-type="indexterm" id="idm45884797865712"/>Some operations accept a scheduler as an argument. You will tend to find this in operations that can generate many items. The <code>Observable.Range</code> method that generates a sequence of numbers optionally takes a scheduler as a final argument to control the context from which these numbers are generated. This also applies to the APIs for adapting other sources, such as <code>IEnumerable&lt;T&gt;</code> to observable sources, as described in <a data-type="xref" href="#adaptation">“Adaptation”</a>.</p>
<p>Another scenario in which you can usually provide a scheduler is when using an observable that combines inputs. Earlier, you saw how the <code>Merge</code> operator combines the output of multiple sequences. You can provide a scheduler to tell the operator to subscribe to the sources from a specific context.</p>
<p>Finally, timed operations all depend on a scheduler. I will show some of these in <a data-type="xref" href="#timed_operations">“Timed Operations”</a>.<a data-startref="ix_ch11-asciidoc32" data-type="indexterm" id="idm45884797860656"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Built-in Schedulers" data-type="sect2"><div class="sect2" id="built-in_schedulers">
<h2>Built-in Schedulers</h2>
<p><a data-primary="schedulers (Rx)" data-secondary="built-in schedulers" data-type="indexterm" id="idm45884797858048"/>I’ve already described the four UI-oriented schedulers, <code>DispatcherScheduler</code> (for WPF), <code>CoreDispatcherScheduler</code> (for Windows Store apps), <code>ControlScheduler</code> (for Windows Forms), and <code>SynchronizationContextScheduler</code>, and also the two schedulers for running work on the current thread, <code>CurrentThreadScheduler</code> and <code>ImmediateScheduler</code>. But there are some others worth being aware of.</p>
<p><a data-primary="EventLoopScheduler" data-type="indexterm" id="idm45884797854096"/><code>EventLoopScheduler</code> runs all work items on a specific thread. It can create a new thread for you, or you can provide it with a callback method that it will invoke when it wants you to create the thread. You might use this in a UI application to process incoming data. It lets you move work off the UI thread to keep the application responsive but ensures that all processing happens on a single thread, which can simplify concurrency issues.</p>
<p><a data-primary="NewThreadScheduler" data-type="indexterm" id="idm45884797852688"/><code>NewThreadScheduler</code> creates a new thread for each top-level work item it processes. (If that work item spawns further work items, those will run on the same thread, rather than creating new ones.) This is appropriate only if you need to do a lot of work for each item, because threads have relatively high startup and teardown costs in Windows. You are normally better off using a thread pool if you need concurrent processing of work items.</p>
<p><a data-primary="TaskPoolScheduler" data-type="indexterm" id="idm45884797851312"/><code>TaskPoolScheduler</code> uses the Task Parallel Library’s (TPL) thread pool. The TPL, described in <a data-type="xref" href="ch16.xhtml#ch_multithreading">Chapter 16</a>, provides an efficient pool of threads that can reuse a single thread for multiple work items, amortizing the startup costs of creating the thread.</p>
<p><a data-primary="ThreadPoolScheduler" data-type="indexterm" id="idm45884797848976"/><code>ThreadPoolScheduler</code> uses the CLR’s thread pool to run work. This is similar in concept to the TPL thread pool, but it’s a somewhat older piece of technology. (The TPL was introduced in .NET 4.0, but the CLR thread pool has existed since v1.0.) This is a bit less efficient in certain scenarios. Rx introduced this scheduler because early versions of Rx supported old versions of .NET that didn’t have the TPL. It retains it for backward-compatibility reasons.</p>
<p><a data-primary="HistoricalScheduler" data-type="indexterm" id="idm45884797847600"/><code>HistoricalScheduler</code> is useful when you want to test time-sensitive code without needing to execute your tests in real time. All schedulers will provide a time-keeping service, but the <code>HistoricalScheduler</code> lets you decide the exact rate at which you want the scheduler to behave as though time is elapsing. So, if you need to test what happens if you wait 30 seconds, you can just tell the <code>HistoricalScheduler</code> to act as though 30 seconds have passed, without having to actually wait.<a data-startref="ix_ch11-asciidoc31" data-type="indexterm" id="idm45884797845680"/><a data-startref="ix_ch11-asciidoc30" data-type="indexterm" id="idm45884797844976"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Subjects" data-type="sect1"><div class="sect1" id="subjects">
<h1>Subjects</h1>
<p><a data-primary="reactive extensions (Rx)" data-secondary="subjects" data-type="indexterm" id="ix_ch11-asciidoc33"/><a data-primary="subjects, Rx" data-type="indexterm" id="ix_ch11-asciidoc34"/>Rx defines various <em>subjects</em>, classes that implement both <code>IObserver&lt;T&gt;</code> and 
<span class="keep-together"><code>IObservable&lt;T&gt;</code></span>. These can sometimes be useful if you need Rx to provide a robust implementation of either of these interfaces, but the usual <code>Observable.Create</code> or <code>Subscribe</code> methods are not convenient. For example, perhaps you need to provide an observable source, and there are several different places in your code from which you want to provide values for that source to produce. This is awkward to fit into the <code>Create</code> method’s subscription callback model and can be easier to handle with a subject. Some of the subject types provide additional behavior, but I’ll start with the simplest, <code>Subject&lt;T&gt;</code>.</p>
<section data-pdf-bookmark="Subject&lt;T&gt;" data-type="sect2"><div class="sect2" id="subject_of_t">
<h2>Subject&lt;T&gt;</h2>
<p><a data-primary="Subject&lt;T&gt; class" data-type="indexterm" id="ix_ch11-asciidoc35"/><a data-primary="subjects, Rx" data-secondary="Subject&lt;T&gt; class" data-type="indexterm" id="ix_ch11-asciidoc36"/>The <code>Subject&lt;T&gt;</code> class’s <code>IObserver&lt;T&gt;</code> implementation just relays calls to all observers that have subscribed using its <code>IObservable&lt;T&gt;</code> interface. So, if you subscribe one or more observables to a <code>Subject&lt;T&gt;</code> and then call <code>OnNext</code>, the subject will call <code>OnNext</code> on each of its subscribers. It’s the same for the other methods, <code>OnCompleted</code> and <code>OnError</code>. This multicast relay is very similar to the facility provided by the <code>Publish</code> operator<sup><a data-type="noteref" href="ch11.xhtml#CHP-11-FN-5" id="CHP-11-FN-5-marker">5</a></sup> I used in <a data-type="xref" href="#delegate-based_hot_source">Example 11-11</a>, so this provides an alternative way for me to remove all of the code for tracking subscribers from my <code>KeyWatcher</code> source, resulting in the code shown in <a data-type="xref" href="#implementing_iobservable_with_subject">Example 11-32</a>. This is much simpler than the original in <a data-type="xref" href="#keypress_monitor_iobservable">Example 11-7</a>, although not quite as simple as the delegate-based version in <a data-type="xref" href="#delegate-based_hot_source">Example 11-11</a>.</p>
<div data-type="example" id="implementing_iobservable_with_subject">
<h5><span class="label">Example 11-32. </span>Implementing <code>IObservable&lt;T&gt;</code> with a <code>Subject&lt;T&gt;</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">KeyWatcher</code> <code class="p">:</code> <code class="n">IObservable</code><code class="p">&lt;</code><code class="kt">char</code><code class="p">&gt;</code>
<code class="p">{</code>
    <code class="k">private</code> <code class="k">readonly</code> <code class="n">Subject</code><code class="p">&lt;</code><code class="kt">char</code><code class="p">&gt;</code> <code class="n">_subject</code> <code class="p">=</code> <code class="k">new</code><code class="p">();</code>

    <code class="k">public</code> <code class="n">IDisposable</code> <code class="nf">Subscribe</code><code class="p">(</code><code class="n">IObserver</code><code class="p">&lt;</code><code class="kt">char</code><code class="p">&gt;</code> <code class="n">observer</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="k">return</code> <code class="n">_subject</code><code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="n">observer</code><code class="p">);</code>
    <code class="p">}</code>

    <code class="k">public</code> <code class="k">void</code> <code class="nf">Run</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="k">while</code> <code class="p">(</code><code class="k">true</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="n">_subject</code><code class="p">.</code><code class="n">OnNext</code><code class="p">(</code><code class="n">Console</code><code class="p">.</code><code class="n">ReadKey</code><code class="p">(</code><code class="k">true</code><code class="p">).</code><code class="n">KeyChar</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>This defers to a <code>Subject&lt;char&gt;</code> in its <code>Subscribe</code> method, so everything that tries to subscribe to this <code>KeyWatcher</code> will end up being subscribed to that subject instead. My loop can then just call the subject’s <code>OnNext</code> method, and it’ll take care of broadcasting that to all the subscribers.</p>
<p>In fact, I can simplify things further by exposing the observable as a separate property, rather than making my entire type observable, as <a data-type="xref" href="#providing_an_iobservable_as_property">Example 11-33</a> shows. Not only does this make the code slightly simpler, but it also means my <code>KeyWatcher</code> could now provide multiple sources if it wanted to.</p>
<div data-type="example" id="providing_an_iobservable_as_property">
<h5><span class="label">Example 11-33. </span>Providing an <code>IObservable&lt;T&gt;</code> as a property</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">KeyWatcher</code>
<code class="p">{</code>
    <code class="k">private</code> <code class="k">readonly</code> <code class="n">Subject</code><code class="p">&lt;</code><code class="kt">char</code><code class="p">&gt;</code> <code class="n">_subject</code> <code class="p">=</code> <code class="k">new</code><code class="p">();</code>

    <code class="k">public</code> <code class="n">IObservable</code><code class="p">&lt;</code><code class="kt">char</code><code class="p">&gt;</code> <code class="n">Keys</code> <code class="p">=&gt;</code> <code class="n">_subject</code><code class="p">;</code>

    <code class="k">public</code> <code class="k">void</code> <code class="nf">Run</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="k">while</code> <code class="p">(</code><code class="k">true</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="n">_subject</code><code class="p">.</code><code class="n">OnNext</code><code class="p">(</code><code class="n">Console</code><code class="p">.</code><code class="n">ReadKey</code><code class="p">(</code><code class="k">true</code><code class="p">).</code><code class="n">KeyChar</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>This is still not quite as simple as the combination of <code>Observable.Create</code> and the <code>Publish</code> operator that I used in <a data-type="xref" href="#delegate-based_hot_source">Example 11-11</a>, but it does offer two advantages. First, it’s now easier to see when the loop that generates keypress notifications runs. I was in control of that in <a data-type="xref" href="#delegate-based_hot_source">Example 11-11</a>, but for anyone not totally familiar with how <code>Publish</code> works, it would not be obvious how this was being achieved. I find <a data-type="xref" href="#providing_an_iobservable_as_property">Example 11-33</a> a little less cryptic. Second, if I wanted to, I could use this subject from anywhere inside my <code>KeyWatcher</code> class, whereas in <a data-type="xref" href="#delegate-based_hot_source">Example 11-11</a>, the only place from which I could easily provide an item was inside the callback function invoked by <code>Observable.Create</code>. As it happens, in this example I don’t need this flexibility, but in scenarios where you do, a <code>Subject&lt;T&gt;</code> is likely to be a better choice than the callback approach.<a data-startref="ix_ch11-asciidoc36" data-type="indexterm" id="idm45884797662800"/><a data-startref="ix_ch11-asciidoc35" data-type="indexterm" id="idm45884797662096"/></p>
</div></section>
<section data-pdf-bookmark="BehaviorSubject&lt;T&gt;" data-type="sect2"><div class="sect2" id="behaviorsubjectltg">
<h2>BehaviorSubject&lt;T&gt;</h2>
<p><a data-primary="BehaviorSubject&lt;T&gt; class" data-type="indexterm" id="idm45884797617536"/><a data-primary="subjects, Rx" data-secondary="BehaviorSubject&lt;T&gt; class" data-type="indexterm" id="idm45884797616704"/><code>BehaviorSubject&lt;T&gt;</code> looks almost exactly like a <code>Subject&lt;T&gt;</code> except for one thing: when any observer first subscribes, it is guaranteed to receive a value straightaway as long you have not completed the subject by calling <code>OnComplete</code>. (If you have already completed the subject, it’ll just call <code>OnComplete</code> immediately on any further subscribers.) It remembers the last item it passed on and hands that out to new subscribers. When you construct a <code>BehaviorSubject&lt;T&gt;</code>, you have to supply an initial value that it will provide to new subscribers until the first call to <code>OnNext</code>.</p>
<p>One way to think of this subject is as Rx’s version of a variable. It’s something that has a value that you can retrieve at any time, and its value can also change over time. But being reactive, you subscribe to it to retrieve its value, and your observer will be notified of any further changes until you unsubscribe.</p>
<p>This subject has a mix of hot and cold characteristics. It will instantly provide a value to any subscriber, making it seem like a cold source, but once that’s happened, it then broadcasts new values to all subscribers, more like a hot source does. There’s another subject with a similar mix, but that takes the cold side a bit further.</p>
</div></section>
<section data-pdf-bookmark="ReplaySubject&lt;T&gt;" data-type="sect2"><div class="sect2" id="replaysubjectltg">
<h2>ReplaySubject&lt;T&gt;</h2>
<p><a data-primary="ReplaySubject&lt;T&gt; class" data-type="indexterm" id="idm45884797610640"/><a data-primary="subjects, Rx" data-secondary="ReplaySubject&lt;T&gt; class" data-type="indexterm" id="idm45884797609712"/><code>ReplaySubject&lt;T&gt;</code> can record every value it receives from whichever source you subscribe it to. (Or, if you invoke its methods directly, it remembers every value you provide through <code>OnNext</code>.) Each new subscriber to this subject will receive every item that the <code>ReplaySubject&lt;T&gt;</code> has seen so far. So this is much more like an ordinary cold subject—instead of just getting the most recent value as you would from a <code>BehaviorSubject&lt;T&gt;</code>, you get a complete set of items. However, once the <code>ReplaySubject&lt;T&gt;</code> has provided a particular subscriber with all of the items it has recorded, it then transitions into more hot-like behavior for that subscriber, because it will continue to provide new incoming items.</p>
<p>So, in the long run, every subscriber to a <code>ReplaySubject&lt;T&gt;</code> will by default see every item that the <code>ReplaySubject&lt;T&gt;</code> receives from its source, regardless of how early or late that subscriber subscribed to the subject.</p>
<p>In its default configuration, a <code>ReplaySubject&lt;T&gt;</code> will consume ever more memory for as long as it is subscribed to a source. There’s no way to tell it that it will have no more new subscribers and that it’s now OK for it to discard old items that it has already distributed to all of its existing subscribers. You should therefore not leave it subscribed indefinitely to an endless source. However, you can limit the amount that a <code>ReplaySubject&lt;T&gt;</code> buffers. It offers various constructor overloads, some of which let you specify either an upper limit on the number of items to replay or an upper limit on the time for which it will hold onto items. Obviously, if you do this, new subscribers can no longer depend on getting all of the items previously received.</p>
</div></section>
<section data-pdf-bookmark="AsyncSubject&lt;T&gt;" data-type="sect2"><div class="sect2" id="asyncsubjectltg">
<h2>AsyncSubject&lt;T&gt;</h2>
<p><a data-primary="AsyncSubject&lt;T&gt; class" data-type="indexterm" id="idm45884797602064"/><a data-primary="subjects, Rx" data-secondary="AsyncSubject&lt;T&gt;" data-type="indexterm" id="idm45884797601360"/><code>AsyncSubject&lt;T&gt;</code> remembers just one value from its source, but unlike <code>Behavior​Sub⁠ject&lt;T&gt;</code>, which remembers the most recent value, <code>AsyncSubject&lt;T&gt;</code> waits for its source to complete. It will then produce the final item as its output. If the source completes without providing any values, the <code>AsyncSubject&lt;T&gt;</code> will do the same to its subscribers.</p>
<p>If you subscribe to an <code>AsyncSubject&lt;T&gt;</code> before its source has completed, the 
<span class="keep-together"><code>AsyncSubject&lt;T&gt;</code></span> will do nothing with your observer until the source completes. But once the source has completed, the <code>AsyncSubject&lt;T&gt;</code> acts as a cold source that provides a single value, unless the source completed without providing a value, in which case this subject will complete all new subscribers immediately.<a data-startref="ix_ch11-asciidoc34" data-type="indexterm" id="idm45884797596320"/><a data-startref="ix_ch11-asciidoc33" data-type="indexterm" id="idm45884797595616"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Adaptation" data-type="sect1"><div class="sect1" id="adaptation">
<h1>Adaptation</h1>
<p><a data-primary="reactive extensions (Rx)" data-secondary="adaptation" data-type="indexterm" id="ix_ch11-asciidoc37"/>Interesting and powerful though Rx is, it would not be much use if it existed in a vacuum. If you are working with asynchronous notifications, it’s possible that they will be supplied by an API that does not support Rx. Although <code>IObservable&lt;T&gt;</code> and <code>IObserver&lt;T&gt;</code> have been around for a long time (since .NET 4.0, which was released in 2010), not every API that could support these interfaces does. Also, because Rx’s fundamental abstraction is a sequence of items, there’s a good chance that at some point you might need to convert between Rx’s push-oriented <code>IObservable&lt;T&gt;</code> and the pull-oriented equivalents <code>IEnumerable&lt;T&gt;</code> and <code>IAsyncEnumerable&lt;T&gt;</code>. Rx provides ways to adapt these and other kinds of sources into <code>IObservable&lt;T&gt;</code>, and in some cases, it can adapt in either direction.</p>
<section data-pdf-bookmark="IEnumerable&lt;T&gt; and IAsyncEnumerable&lt;T&gt;" data-type="sect2"><div class="sect2" id="ienumerableltg">
<h2>IEnumerable&lt;T&gt; and IAsyncEnumerable&lt;T&gt;</h2>
<p><a data-primary="IEnumerable&lt;T&gt; interface" data-secondary="adapting to Rx" data-type="indexterm" id="ix_ch11-asciidoc38"/><a data-primary="reactive extensions (Rx)" data-secondary="IAsyncEnumerable&lt;T&gt;" data-type="indexterm" id="ix_ch11-asciidoc39"/><a data-primary="reactive extensions (Rx)" data-secondary="IEnumerable&lt;T&gt;" data-type="indexterm" id="ix_ch11-asciidoc40"/>Any <code>IEnumerable&lt;T&gt;</code> can easily be brought into the world of Rx thanks to the <code>ToObservable</code> extension methods. These are defined by the <code>Observable</code> static class in the <code>System.Reactive.Linq</code> namespace. <a data-type="xref" href="#converting_an_ienumerableltg_to_an_iobse">Example 11-34</a> shows the simplest form, which takes no arguments.</p>
<div data-type="example" id="converting_an_ienumerableltg_to_an_iobse">
<h5><span class="label">Example 11-34. </span>Converting an <code>IEnumerable&lt;T&gt;</code> to an <code>IObservable&lt;T&gt;</code></h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="k">public</code><code> </code><code class="k">static</code><code> </code><code class="k">void</code><code> </code><code class="nf">ShowAll</code><code class="p">(</code><code class="n">IEnumerable</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code><code> </code><code class="n">source</code><code class="p">)</code><code>
</code><code class="p">{</code><code>
</code><code>    </code><strong><code class="n">IObservable</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code><code> </code><code class="n">observableSource</code><code> </code><code class="p">=</code><code> </code><code class="n">source</code><code class="p">.</code><code class="n">ToObservable</code><code class="p">(</code><code class="p">)</code><code class="p">;</code></strong><code>
</code><code>    </code><code class="n">observableSource</code><code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">)</code><code class="p">;</code><code>
</code><code class="p">}</code></pre></div>
<p>The <code>ToObservable</code> method itself does not enumerate its input—it just returns a wrapper that implements <code>IObservable&lt;T&gt;</code>. This wrapper is a cold source, and each time you subscribe an observer to it, only then does it iterate through the input, passing each item to the observer’s <code>OnNext</code> method and calling <code>OnCompleted</code> at the end. If the source throws an exception, this adapter will call <code>OnError</code>. <a data-type="xref" href="#toobservable_sketch">Example 11-35</a> shows how <code>ToObservable</code> might work if it weren’t for the fact that it needs to use a scheduler.</p>
<div data-type="example" id="toobservable_sketch">
<h5><span class="label">Example 11-35. </span>How <code>ToObservable</code> might look without scheduler support</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">static</code> <code class="n">IObservable</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="n">MyToObservable</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;(</code><code class="k">this</code> <code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="n">input</code><code class="p">)</code>
<code class="p">{</code>
    <code class="k">return</code> <code class="n">Observable</code><code class="p">.</code><code class="n">Create</code><code class="p">((</code><code class="n">IObserver</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="n">observer</code><code class="p">)</code> <code class="p">=&gt;</code>
        <code class="p">{</code>
            <code class="kt">bool</code> <code class="n">inObserver</code> <code class="p">=</code> <code class="k">false</code><code class="p">;</code>
            <code class="k">try</code>
            <code class="p">{</code>
                <code class="k">foreach</code> <code class="p">(</code><code class="n">T</code> <code class="n">item</code> <code class="k">in</code> <code class="n">input</code><code class="p">)</code>
                <code class="p">{</code>
                    <code class="n">inObserver</code> <code class="p">=</code> <code class="k">true</code><code class="p">;</code>
                    <code class="n">observer</code><code class="p">.</code><code class="n">OnNext</code><code class="p">(</code><code class="n">item</code><code class="p">);</code>
                    <code class="n">inObserver</code> <code class="p">=</code> <code class="k">false</code><code class="p">;</code>
                <code class="p">}</code>
                <code class="n">inObserver</code> <code class="p">=</code> <code class="k">true</code><code class="p">;</code>
                <code class="n">observer</code><code class="p">.</code><code class="n">OnCompleted</code><code class="p">();</code>
            <code class="p">}</code>
            <code class="k">catch</code> <code class="p">(</code><code class="n">Exception</code> <code class="n">x</code><code class="p">)</code>
            <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="n">inObserver</code><code class="p">)</code>
                <code class="p">{</code>
                    <code class="k">throw</code><code class="p">;</code>
                <code class="p">}</code>
                <code class="n">observer</code><code class="p">.</code><code class="n">OnError</code><code class="p">(</code><code class="n">x</code><code class="p">);</code>
            <code class="p">}</code>
            <code class="k">return</code> <code class="p">()</code> <code class="p">=&gt;</code> <code class="p">{</code> <code class="p">};</code>
        <code class="p">});</code>
<code class="p">}</code></pre></div>
<p>This is not how it really works, because <a data-type="xref" href="#toobservable_sketch">Example 11-35</a> cannot use a scheduler. (A full implementation would have been much harder to read, defeating the purpose of the example, which was to show the basic idea behind <code>ToObservable</code>.) The real method uses a scheduler to manage the iteration process, enabling subscription to occur asynchronously if required. It also supports stopping the work if the observer’s subscription is canceled early. There’s an overload that takes a single argument of type <code>IScheduler</code>, which lets you tell it to use a particular scheduler; if you don’t provide one, it’ll use <code>CurrentThreadScheduler</code>.</p>
<p>When it comes to going in the other direction—that is, when you have an 
<span class="keep-together"><code>IObservable&lt;T&gt;</code></span>, but you would like to treat it as an <code>IEnumerable&lt;T&gt;</code>—you can call the <span class="keep-together"><code>ToEnumerable</code></span> extension methods, also provided by the <span class="keep-together"><code>Observable</code></span> class. <a data-type="xref" href="#using_an_iobservable_as_an_ienumerable">Example 11-36</a> wraps an <code>IObservable&lt;string&gt;</code> as an <code>IEnumerable&lt;string&gt;</code> so that it can iterate over the items in the source using an ordinary <code>foreach</code> loop.</p>
<div data-type="example" id="using_an_iobservable_as_an_ienumerable">
<h5><span class="label">Example 11-36. </span>Using an <code>IObservable&lt;T&gt;</code> as an <code>IEnumerable&lt;T&gt;</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">static</code> <code class="k">void</code> <code class="nf">ShowAll</code><code class="p">(</code><code class="n">IObservable</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">source</code><code class="p">)</code>
<code class="p">{</code>
    <code class="k">foreach</code> <code class="p">(</code><code class="kt">string</code> <code class="n">s</code> <code class="k">in</code> <code class="n">source</code><code class="p">.</code><code class="n">ToEnumerable</code><code class="p">())</code>
    <code class="p">{</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">s</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>The wrapper subscribes to the source on your behalf. If the source provides items faster than you can iterate over them, the wrapper will store the items in a queue so you can retrieve them at your leisure. If the source does not provide items as fast as you can retrieve them, the wrapper will just wait until items become available.</p>
<p><a data-primary="IAsyncEnumerable&lt;T&gt; interface" data-type="indexterm" id="idm45884797300064"/>The <code>IAsyncEnumerable&lt;T&gt;</code> interface provides the same model as <code>IEnumerable&lt;T&gt;</code> but in a way that enables efficient asynchronous operation using the techniques discussed in <a data-type="xref" href="ch17.xhtml#ch_asynchronous_language_features">Chapter 17</a>. Rx offers a <code>ToObservable</code> extension method for this and also a <code>ToAsyncEnumerable</code> method extension method for <code>IObservable&lt;T&gt;</code>. These both come from the <code>AsyncEnumerable</code> class, and to use that you will need a reference to a separate NuGet package called <code>System.Linq.Async</code>.<a data-startref="ix_ch11-asciidoc40" data-type="indexterm" id="idm45884797322752"/><a data-startref="ix_ch11-asciidoc39" data-type="indexterm" id="idm45884797322016"/><a data-startref="ix_ch11-asciidoc38" data-type="indexterm" id="idm45884797281872"/></p>
</div></section>
<section data-pdf-bookmark=".NET Events" data-type="sect2"><div class="sect2" id="net_events">
<h2>.NET Events</h2>
<p><a data-primary=".NET events" data-primary-sortas="NET events" data-type="indexterm" id="ix_ch11-asciidoc41"/><a data-primary="IObservable&lt;T&gt; interface" data-secondary=".NET events and" data-secondary-sortas="NET events" data-type="indexterm" id="ix_ch11-asciidoc42"/><a data-primary="reactive extensions (Rx)" data-secondary=".NET events" data-secondary-sortas="NET events" data-type="indexterm" id="ix_ch11-asciidoc43"/><a data-primary="FileSystemWatcher" data-type="indexterm" id="idm45884797275680"/>Rx can wrap a .NET event as an <code>IObservable&lt;T&gt;</code> using the <code>Observable</code> class’s static <code>FromEventPattern</code> method. Earlier, in <a data-type="xref" href="#grouping_events">Example 11-17</a>, I used a <code>FileSystemWatcher</code>, a class from the <code>System.IO</code> namespace that raises various events when files are added, deleted, renamed, or otherwise modified in a particular folder. <a data-type="xref" href="#wrapping_an_event_in_an_iobservable">Example 11-37</a> reproduces the first part of that example, which I glossed over last time. This code uses the <code>Observable.FromEventPattern</code> static method to produce an observable source representing the watcher’s <code>Created</code> event. (If you want to handle a static event, you can pass a <code>Type</code> object as the first argument instead. <a data-type="xref" href="ch13.xhtml#ch_reflection">Chapter 13</a> describes the <code>Type</code> class.)</p>
<div data-type="example" id="wrapping_an_event_in_an_iobservable">
<h5><span class="label">Example 11-37. </span>Wrapping an event in an <code>IObservable&lt;T&gt;</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">string</code> <code class="n">path</code> <code class="p">=</code> <code class="n">Environment</code><code class="p">.</code><code class="n">GetFolderPath</code><code class="p">(</code><code class="n">Environment</code><code class="p">.</code><code class="n">SpecialFolder</code><code class="p">.</code><code class="n">MyPictures</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">watcher</code> <code class="p">=</code> <code class="k">new</code> <code class="n">FileSystemWatcher</code><code class="p">(</code><code class="n">path</code><code class="p">);</code>
<code class="n">watcher</code><code class="p">.</code><code class="n">EnableRaisingEvents</code> <code class="p">=</code> <code class="k">true</code><code class="p">;</code>

<code class="n">IObservable</code><code class="p">&lt;</code><code class="n">EventPattern</code><code class="p">&lt;</code><code class="n">FileSystemEventArgs</code><code class="p">&gt;&gt;</code> <code class="n">changes</code> <code class="p">=</code>
    <code class="n">Observable</code><code class="p">.</code><code class="n">FromEventPattern</code><code class="p">&lt;</code><code class="n">FileSystemEventArgs</code><code class="p">&gt;(</code>
        <code class="n">watcher</code><code class="p">,</code> <code class="n">nameof</code><code class="p">(</code><code class="n">watcher</code><code class="p">.</code><code class="n">Created</code><code class="p">));</code>
<code class="n">changes</code><code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="n">evt</code> <code class="p">=&gt;</code> <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">evt</code><code class="p">.</code><code class="n">EventArgs</code><code class="p">.</code><code class="n">FullPath</code><code class="p">));</code></pre></div>
<p>On the face of it, this seems significantly more complicated than just subscribing to the event in the normal way shown in <a data-type="xref" href="ch09.xhtml#ch_delegates_lambdas_events">Chapter 9</a>, and with no obvious advantage. And in this particular example, that would have been better. However, one benefit of using Rx is that if you were writing a UI application, you could use <span class="keep-together"><code>ObserveOn</code></span> with a suitable scheduler to ensure that your handler was always invoked on the right thread, regardless of which thread raised the event. Of course, another benefit—and the usual reason for doing this—is that you can use any of Rx’s query operators to process the events. (That’s why the original <a data-type="xref" href="#grouping_events">Example 11-17</a> did this.)</p>
<p>The element type of the observable source that <a data-type="xref" href="#wrapping_an_event_in_an_iobservable">Example 11-37</a> produces is <code>Event​Pat⁠tern&lt;FileSystemEventArgs&gt;</code>. The generic <code>EventPattern&lt;T&gt;</code> is a type defined by Rx specifically for representing the raising of an event, where the event’s delegate type conforms to the standard pattern described in <a data-type="xref" href="ch09.xhtml#ch_delegates_lambdas_events">Chapter 9</a> (i.e., it takes two arguments, the first being of type <code>object</code>, representing the object that raised the event, and the second being some type derived from <code>EventArgs</code>, containing information about the event). <code>EventPattern&lt;T&gt;</code> has two properties, <code>Sender</code> and <code>EventArgs</code>, corresponding to the two arguments that an event handler would receive. In effect, this is an object that represents what would normally be a method call to an event handler.</p>
<p>A surprising feature of <a data-type="xref" href="#wrapping_an_event_in_an_iobservable">Example 11-37</a> is that the second argument to <code>FromEvent​Pat⁠tern</code> is a string containing the name of the event. Rx resolves this to the real event member at runtime. This is less than ideal for a couple of reasons. First, it means that if you type the name in wrong, the compiler won’t notice (although using the <code>nameof</code> operator mitigates this). Second, it means the compiler can’t help you with types—if you handle a .NET event directly with a lambda, the compiler can infer the argument types from the event definition, but here, because we’re passing the event name as a string, the compiler doesn’t know which event I’m using (or even that I’m using an event at all), so I’ve had to specify the generic type argument for the method explicitly. And again, if I get that wrong, the compiler won’t know—it’ll be checked at runtime instead.</p>
<p>This string-based approach arises from a shortcoming of events: you can’t pass an event as an argument. In fact, events are very limited members. You can’t do anything with an event from outside of the class that defines it other than adding or removing handlers. This is one of the ways in which Rx improves on events—once you’re in the world of Rx, event sources and subscribers are both represented as objects (implementing <code>IObservable&lt;T&gt;</code> and <code>IObserver&lt;T&gt;</code>, respectively), making it straightforward to pass them into methods as arguments. But that doesn’t help us at the point where we’re dealing with an event that’s not yet in Rx’s world.</p>
<p>Rx does provide an overload that doesn’t require you to use a string—you can pass in delegates that add and remove the handlers for Rx, as <a data-type="xref" href="#delegate-based_event_wrapping">Example 11-38</a> shows.</p>
<div data-type="example" id="delegate-based_event_wrapping">
<h5><span class="label">Example 11-38. </span>Delegate-based event wrapping</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">IObservable</code><code class="p">&lt;</code><code class="n">EventPattern</code><code class="p">&lt;</code><code class="n">FileSystemEventArgs</code><code class="p">&gt;&gt;</code> <code class="n">changes</code> <code class="p">=</code>
    <code class="n">Observable</code><code class="p">.</code><code class="n">FromEventPattern</code><code class="p">&lt;</code><code class="n">FileSystemEventHandler</code><code class="p">,</code> <code class="n">FileSystemEventArgs</code><code class="p">&gt;(</code>
    <code class="n">h</code> <code class="p">=&gt;</code> <code class="n">watcher</code><code class="p">.</code><code class="n">Created</code> <code class="p">+=</code> <code class="n">h</code><code class="p">,</code> <code class="n">h</code> <code class="p">=&gt;</code> <code class="n">watcher</code><code class="p">.</code><code class="n">Created</code> <code class="p">-=</code> <code class="n">h</code><code class="p">);</code></pre></div>
<p>This is somewhat more verbose, because it requires a generic type argument specifying the handler delegate type as well as the event argument type. The string-based version discovers the handler type for itself at runtime, but because the normal reason for using the approach in <a data-type="xref" href="#delegate-based_event_wrapping">Example 11-38</a> is to get compile-time type checking, the compiler needs to know what types you’re using, and the lambdas in that example don’t provide quite enough information for the compiler to infer all the type arguments automatically.</p>
<p>As well as wrapping an event as an observable source, it’s possible to go in the other direction. Rx defines an operator for <code>IObservable&lt;EventPattern&lt;T&gt;&gt;</code> called <code>ToEventPattern&lt;T&gt;</code>. (Note that this is not available for any old observable source—it has to be an observable sequence of <code>EventPattern&lt;T&gt;</code>.) If you call this, it returns an object that implements <code>IEventPatternSource&lt;T&gt;</code>. This defines a single event called <code>OnNext</code>, of type <code>EventHandler&lt;T&gt;</code>, which allows you to hook up an event handler in the ordinary .NET way to an observable source.</p>
</div></section>
<section data-pdf-bookmark="Asynchronous APIs" data-type="sect2"><div class="sect2" id="asynchronous_apis">
<h2>Asynchronous APIs</h2>
<p><a data-primary="asynchronous APIs" data-type="indexterm" id="ix_ch11-asciidoc45"/><a data-primary="reactive extensions (Rx)" data-secondary="asynchronous APIs" data-type="indexterm" id="ix_ch11-asciidoc46"/>.NET supports various asynchronous patterns, which I’ll be describing in detail in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch16.xhtml#ch_multithreading">16</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch17.xhtml#ch_asynchronous_language_features">17</a>. The first to be introduced in .NET was the Asynchronous Programming Model (APM). However, this pattern is not supported directly by the new C# asynchronous language features, so most .NET APIs now use the TPL, and for older APIs the TPL offers adapters that can provide a task-based wrapper for an APM-based API. Rx can represent any TPL task as an observable source.</p>
<p>The basic model for all of .NET’s asynchronous patterns is that you start some work that will eventually complete, optionally producing a result. So it may seem odd to translate this into Rx, where the fundamental abstraction is a sequence of items, not a single result. In fact, one useful way to understand the difference between Rx and the TPL is that <code>IObservable&lt;T&gt;</code> is analogous to <code>IEnumerable&lt;T&gt;</code>, while <code>Task&lt;T&gt;</code> is analogous to a property of type <code>T</code>. Whereas with <code>IEnumerable&lt;T&gt;</code> and properties, the caller decides when to fetch information from the source, with <code>IObservable&lt;T&gt;</code> and <code>Task&lt;T&gt;</code>, the source provides the information when it’s ready. The choice of which party decides when to provide information is separate from the question of whether the information is singular or a sequence of items. So a mapping between singular asynchronous APIs and <code>IObservable&lt;T&gt;</code> seems a little mismatched. But then we can cross similar boundaries in the nonasynchronous world—as you saw in <a data-type="xref" href="ch10.xhtml#ch_linq">Chapter 10</a>, LINQ defines various standard operators that produce a single item from a sequence, such as <code>First</code> or <code>Last</code>. Rx supports those operators, but it additionally supports going in the other direction: bringing singular asynchronous sources into a stream-like world. The upshot is an <code>IObservable&lt;T&gt;</code> source that produces just a single item (or reports an error if the operation fails). The analogy in the nonasynchronous world would be taking a single value and wrapping it in an array so that you can pass it to an API that requires an <code>IEnumerable&lt;T&gt;</code>.</p>
<p><a data-type="xref" href="#wrapping_a_task_as_an_iobservable">Example 11-39</a> uses this facility to produce an <code>IObservable&lt;string&gt;</code> that will either produce a single value containing the text downloaded from a particular URL or report a failure should the download fail.<a data-primary="HttpClient class" data-type="indexterm" id="idm45884797069216"/></p>
<div data-type="example" id="wrapping_a_task_as_an_iobservable">
<h5><span class="label">Example 11-39. </span>Wrapping a <code>Task&lt;T&gt;</code> as an <code>IObservable&lt;T&gt;</code></h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="k">public</code><code> </code><code class="k">static</code><code> </code><code class="n">IObservable</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code><code> </code><code class="n">GetWebPageAsObservable</code><code class="p">(</code><code>
</code><code>    </code><code class="n">Uri</code><code> </code><code class="n">pageUrl</code><code class="p">,</code><code> </code><code class="n">IHttpClientFactory</code><code> </code><code class="n">cf</code><code class="p">)</code><code>
</code><code class="p">{</code><code>
</code><code>    </code><code class="n">HttpClient</code><code> </code><code class="n">web</code><code> </code><code class="p">=</code><code> </code><code class="n">cf</code><code class="p">.</code><code class="n">CreateClient</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code>
</code><code>    </code><code class="n">Task</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code><code> </code><code class="n">getPageTask</code><code> </code><code class="p">=</code><code> </code><code class="n">web</code><code class="p">.</code><code class="n">GetStringAsync</code><code class="p">(</code><code class="n">pageUrl</code><code class="p">)</code><code class="p">;</code><code>
</code><code>    </code><strong><code class="k">return</code><code> </code><code class="n">getPageTask</code><code class="p">.</code><code class="n">ToObservable</code><code class="p">(</code><code class="p">)</code><code class="p">;</code></strong><code>
</code><code class="p">}</code></pre></div>
<p>The <code>ToObservable</code> method used in this example is an extension method defined for <code>Task</code> by Rx. For this to be available, you’ll need the <code>System.Reactive.Thread⁠ing​.Tasks</code> namespace to be in scope.</p>
<p>One potentially unsatisfactory feature of <a data-type="xref" href="#wrapping_a_task_as_an_iobservable">Example 11-39</a> is that it will attempt the download only once, no matter how many observers subscribe to the source. Depending on your requirements, that might be fine, but in some scenarios, it might make sense to attempt to download a fresh copy every time. If you want that, a better approach would be to use the <code>Observable.FromAsync</code> method, because you pass that a lambda that it invokes each time a new observer subscribes. Your lambda returns a task that will then be wrapped as an observable source. <a data-type="xref" href="#creating_a_new_task_for_each_subscriber">Example 11-40</a> uses this to start a new download for each subscriber.</p>
<div data-type="example" id="creating_a_new_task_for_each_subscriber">
<h5><span class="label">Example 11-40. </span>Creating a new task for each subscriber</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">static</code> <code class="n">IObservable</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">GetWebPageAsObservable</code><code class="p">(</code>
    <code class="n">Uri</code> <code class="n">pageUrl</code><code class="p">,</code> <code class="n">IHttpClientFactory</code> <code class="n">cf</code><code class="p">)</code>
<code class="p">{</code>
    <code class="k">return</code> <code class="n">Observable</code><code class="p">.</code><code class="n">FromAsync</code><code class="p">(()</code> <code class="p">=&gt;</code>
        <code class="p">{</code>
            <code class="n">HttpClient</code> <code class="n">web</code> <code class="p">=</code> <code class="n">cf</code><code class="p">.</code><code class="n">CreateClient</code><code class="p">();</code>
            <code class="k">return</code> <code class="n">web</code><code class="p">.</code><code class="n">GetStringAsync</code><code class="p">(</code><code class="n">pageUrl</code><code class="p">);</code>
        <code class="p">});</code>
<code class="p">}</code></pre></div>
<p>This might be suboptimal if you have many subscribers. On the other hand, it’s more efficient when nothing attempts to subscribe at all. <a data-type="xref" href="#wrapping_a_task_as_an_iobservable">Example 11-39</a> starts the asynchronous work immediately without even waiting for any subscribers. That may be a good thing—if the stream will definitely have subscribers, kicking off slow work without waiting for the first subscriber will reduce your overall latency. However, if you are writing a class in a library that presents multiple observable sources, which might not all be used, deferring work until the first subscription might be better.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Timed Operations" data-type="sect1"><div class="sect1" id="timed_operations">
<h1>Timed Operations</h1>
<p><a data-primary="reactive extensions (Rx)" data-secondary="timed operations" data-type="indexterm" id="ix_ch11-asciidoc47"/><a data-primary="timed operations, Rx" data-type="indexterm" id="ix_ch11-asciidoc48"/>Because Rx can work with live streams of information, you may need to handle items in a time-sensitive way. For example, the rate at which items arrive might be important, or you may wish to group items based on when they were provided. In this final section, I’ll describe some of the time-based operators that Rx offers.</p>
<section data-pdf-bookmark="Interval" data-type="sect2"><div class="sect2" id="interval">
<h2>Interval</h2>
<p><a data-primary="timed operations, Rx" data-secondary="Interval" data-type="indexterm" id="ix_ch11-asciidoc50"/>The <code>Observable.Interval</code> method returns a sequence that regularly produces values at the interval specified by an argument of type <code>TimeSpan</code>. <a data-type="xref" href="#regular_items_with_interval">Example 11-41</a> creates and subscribes to a source that will produce one value every second.</p>
<div data-type="example" id="regular_items_with_interval">
<h5><span class="label">Example 11-41. </span>Regular items with <code>Interval</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">IObservable</code><code class="p">&lt;</code><code class="kt">long</code><code class="p">&gt;</code> <code class="n">src</code> <code class="p">=</code> <code class="n">Observable</code><code class="p">.</code><code class="n">Interval</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">1</code><code class="p">));</code>
<code class="n">src</code><code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="n">i</code> <code class="p">=&gt;</code> <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"Event {i} at {DateTime.Now:T}"</code><code class="p">));</code></pre></div>
<p>The items produced by <code>Interval</code> are of type <code>long</code>. It produces values of zero, one, <span class="keep-together">two, etc.</span></p>
<p><code>Interval</code> handles each subscriber independently (i.e., it is a cold source). To demonstrate this, add the code in <a data-type="xref" href="#two_subscribers_for_one_interval_source">Example 11-42</a> after that in <a data-type="xref" href="#regular_items_with_interval">Example 11-41</a> to wait for a short while and then create a second subscription.</p>
<div data-type="example" id="two_subscribers_for_one_interval_source">
<h5><span class="label">Example 11-42. </span>A second subscriber to an <code>Interval</code> source</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">Thread</code><code class="p">.</code><code class="n">Sleep</code><code class="p">(</code><code class="m">2500</code><code class="p">);</code>
<code class="n">src</code><code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="n">i</code> <code class="p">=&gt;</code> <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code>
    <code class="err">$</code><code class="s">"Event {i} at {DateTime.Now:T} (2nd subscriber)"</code><code class="p">));</code></pre></div>
<p>The second subscriber subscribes two and a half seconds after the first one, so this will produce the following output:</p>
<pre data-type="programlisting">Event 0 at 09:46:58
Event 1 at 09:46:59
Event 2 at 09:47:00
Event 0 at 09:47:00 (2nd subscriber)
Event 3 at 09:47:01
Event 1 at 09:47:01 (2nd subscriber)
Event 4 at 09:47:02
Event 2 at 09:47:02 (2nd subscriber)
Event 5 at 09:47:03
Event 3 at 09:47:03 (2nd subscriber)</pre>
<p>You can see that the second subscriber’s values start from zero, and that’s because it gets its own sequence. If you want a single set of these timed items to feed into multiple subscribers, you can use the <code>Publish</code> operator described earlier.</p>
<p>You could use an <code>Interval</code> source in conjunction with a group join as a way to break items into chunks based on when they arrive. (This is not the only way—there are overloads of <code>Buffer</code> and <code>Window</code> that can do the same.) <a data-type="xref" href="#calculating_words_per_minute">Example 11-43</a> combines a timer with an observable sequence representing the words the user types. (That second sequence is in the <code>words</code> variable, which comes from <a data-type="xref" href="#work_breaking_with_buffer">Example 11-25</a>.)</p>
<div data-type="example" id="calculating_words_per_minute">
<h5><span class="label">Example 11-43. </span>Calculating words per minute</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">IObservable</code><code class="p">&lt;</code><code class="kt">long</code><code class="p">&gt;</code> <code class="n">ticks</code> <code class="p">=</code> <code class="n">Observable</code><code class="p">.</code><code class="n">Interval</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">6</code><code class="p">));</code>
<code class="n">IObservable</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">wordGroupCounts</code> <code class="p">=</code> <code class="k">from</code> <code class="n">tick</code> <code class="k">in</code> <code class="n">ticks</code>
                                   <code class="k">join</code> <code class="n">word</code> <code class="k">in</code> <code class="n">words</code>
                                     <code class="k">on</code> <code class="n">ticks</code> <code class="k">equals</code> <code class="n">words</code> <code class="k">into</code> <code class="n">wordsInTick</code>
                                   <code class="k">from</code> <code class="n">count</code> <code class="k">in</code> <code class="n">wordsInTick</code><code class="p">.</code><code class="n">Count</code><code class="p">()</code>
                                   <code class="k">select</code> <code class="n">count</code> <code class="p">*</code> <code class="m">10</code><code class="p">;</code>

<code class="n">wordGroupCounts</code><code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="n">c</code> <code class="p">=&gt;</code> <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"Words per minute: {c}"</code><code class="p">));</code></pre></div>
<p>Having grouped the words into boundaries based on events from the <code>Interval</code> source, this query goes on to count the number of items in each group. Since the groups are evenly spaced in time, this can be used to calculate the approximate rate at which the user is typing words. I’m forming a group once every 6 seconds, so we can multiply the number of words in the group by 10 to estimate the words per minute.</p>
<p>The results are not entirely accurate, because Rx will join two items if their durations overlap. That will cause words to be counted multiple times here. The final word at the end of one interval will also be the first word at the start of the next interval. In this case, the measurements are pretty approximate, so I’m not too worried, but you would need to bear in mind how overlaps affect this sort of operation if you wanted more precise results. <code>Window</code> or <code>Buffer</code> may offer a better solution.<a data-startref="ix_ch11-asciidoc50" data-type="indexterm" id="idm45884796689664"/></p>
</div></section>
<section data-pdf-bookmark="Timer" data-type="sect2"><div class="sect2" id="timer">
<h2>Timer</h2>
<p><a data-primary="timed operations, Rx" data-secondary="Timer" data-type="indexterm" id="idm45884796687376"/>The <code>Observable.Timer</code> method can create a sequence that produces exactly one item. It waits for the duration specified with a <code>TimeSpan</code> argument before producing that item. It looks very similar to <code>Observable.Interval</code>, because not only does it take the same argument, but it even returns a sequence of the same type: <code>IObservable&lt;long&gt;</code>. So I can subscribe to this kind of source in almost exactly the same way as with an interval sequence, as <a data-type="xref" href="#single_item_with_timer">Example 11-44</a> shows.</p>
<div data-type="example" id="single_item_with_timer">
<h5><span class="label">Example 11-44. </span>Single item with <code>Timer</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">IObservable</code><code class="p">&lt;</code><code class="kt">long</code><code class="p">&gt;</code> <code class="n">src</code> <code class="p">=</code> <code class="n">Observable</code><code class="p">.</code><code class="n">Timer</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">1</code><code class="p">));</code>
<code class="n">src</code><code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="n">i</code> <code class="p">=&gt;</code> <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"Event {i} at {DateTime.Now:T}"</code><code class="p">));</code></pre></div>
<p>The effect is the same as an <code>Interval</code> that stops after producing its first item, so you will always get a value of zero. There are also overloads that accept an extra <code>TimeSpan</code>, which will repeatedly produce the value just like <code>Interval</code>. In fact, <code>Interval</code> uses <code>Timer</code> internally—it’s just a wrapper offering a simpler API.</p>
</div></section>
<section data-pdf-bookmark="Timestamp" data-type="sect2"><div class="sect2" id="timestamp">
<h2>Timestamp</h2>
<p><a data-primary="timed operations, Rx" data-secondary="Timestamp" data-type="indexterm" id="idm45884796620976"/><a data-primary="Timestamp operator" data-type="indexterm" id="idm45884796619776"/><a data-primary="query operators, Rx" data-secondary="Timestamp" data-type="indexterm" id="idm45884796619104"/>In the preceding two sections, I used <code>DateTime.Now</code> when writing out messages to indicate when the sources produced items. One potential problem with this is that it tells us the time at which our handler processed the message, which will not always be an accurate reflection of when the message was received. For example, if you have used <code>ObserveOn</code> to ensure that your handler always runs on the UI thread, there may be a significant delay in between the item being produced and your code getting to handle it, because the UI thread may be busy doing other things. You can mitigate this with the <code>Timestamp</code> operator, available on any <code>IObservable&lt;T&gt;</code>. <a data-type="xref" href="#timestamped_items">Example 11-45</a> uses this as an alternative way to show the time at which an <code>Interval</code> produces 
<span class="keep-together">its items.</span></p>
<div data-type="example" id="timestamped_items">
<h5><span class="label">Example 11-45. </span>Timestamped items</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">IObservable</code><code class="p">&lt;</code><code class="n">Timestamped</code><code class="p">&lt;</code><code class="kt">long</code><code class="p">&gt;&gt;</code> <code class="n">src</code> <code class="p">=</code>
    <code class="n">Observable</code><code class="p">.</code><code class="n">Interval</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">1</code><code class="p">)).</code><code class="n">Timestamp</code><code class="p">();</code>
<code class="n">src</code><code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="n">i</code> <code class="p">=&gt;</code> <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code>
    <code class="err">$</code><code class="s">"Event {i.Value} at {i.Timestamp.ToLocalTime():T}"</code><code class="p">));</code></pre></div>
<p>If the source observable’s item type is some type <code>T</code>, this operator will produce an observable of <code>Timestamped&lt;T&gt;</code> items. This defines a <code>Value</code> property, containing the original value from the source observable, and a <code>Timestamp</code> property, indicating when the value went through the <code>Timestamp</code> operator.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>Timestamp</code> property is a <code>DateTimeOffset</code>, and it picks a time zone offset of zero (i.e., it is in UTC). This provides a stable basis for timing by removing any possibility of moving in or out of daylight saving time while your program runs. However, if you want to show the timestamp to an end user, you may want to adjust it, which is why <a data-type="xref" href="#timestamped_items">Example 11-45</a> calls <code>ToLocalTime</code> on it.</p>
</div>
<p>You should apply this operator directly to the observable you want to timestamp, rather than leaving it later on in the chain. Writing <code>src.ObserveOn(sched)​.Time⁠stamp()</code> would defeat the purpose, because you would be timing the items after they had been dispatched by the scheduler passed to <code>ObserveOn</code>. You would want to write <code>src.Timestamp().ObserveOn(sched)</code> to ensure that you acquire a timestamp before feeding the items into a processing chain that might introduce delay.</p>
</div></section>
<section data-pdf-bookmark="TimeInterval" data-type="sect2"><div class="sect2" id="timeinterval">
<h2>TimeInterval</h2>
<p><a data-primary="timed operations, Rx" data-secondary="TimeInterval" data-type="indexterm" id="idm45884796565360"/><a data-primary="TimeInterval operator" data-type="indexterm" id="idm45884796538704"/><a data-primary="query operators, Rx" data-secondary="TimeInterval" data-type="indexterm" id="idm45884796538096"/>Whereas <code>Timestamp</code> records the current time at which items are produced, its relative counterpart <code>TimeInterval</code> records the time between successive items. <a data-type="xref" href="#measuring_the_gaps">Example 11-46</a> uses this on an observable sequence produced by <code>Observable.Interval</code>, so we’d expect the items to be reasonably evenly spaced.</p>
<div data-type="example" id="measuring_the_gaps">
<h5><span class="label">Example 11-46. </span>Measuring the gaps</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">IObservable</code><code class="p">&lt;</code><code class="kt">long</code><code class="p">&gt;</code> <code class="n">ticks</code> <code class="p">=</code> <code class="n">Observable</code><code class="p">.</code><code class="n">Interval</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">0.75</code><code class="p">));</code>
<code class="n">IObservable</code><code class="p">&lt;</code><code class="n">TimeInterval</code><code class="p">&lt;</code><code class="kt">long</code><code class="p">&gt;&gt;</code> <code class="n">timed</code> <code class="p">=</code> <code class="n">ticks</code><code class="p">.</code><code class="n">TimeInterval</code><code class="p">();</code>
<code class="n">timed</code><code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code>
    <code class="err">$</code><code class="s">"Event {x.Value} took {x.Interval.TotalSeconds:F3}"</code><code class="p">));</code></pre></div>
<p>While the <code>Timestamped&lt;T&gt;</code> items produced by the <code>Timestamp</code> operator provide a 
<span class="keep-together"><code>Timestamp</code></span> property, the <code>TimeInterval&lt;T&gt;</code> items produced by the <code>TimeInterval</code> operator define an <code>Interval</code> property. This is a <code>TimeSpan</code> instead of a <code>DateTimeOffset</code>. I’ve chosen to show the number of seconds between each item to three decimal places. Here’s some of what I see when I run it on my computer:</p>
<pre data-type="programlisting">Event 0 took 0.760
Event 1 took 0.757
Event 2 took 0.743
Event 3 took 0.751
Event 4 took 0.749
Event 5 took 0.750</pre>
<p>This shows intervals that are as much as 10 ms away from what I asked for, but that’s fairly typical. Windows is not a real-time operating system.</p>
</div></section>
<section data-pdf-bookmark="Throttle" data-type="sect2"><div class="sect2" id="throttle">
<h2>Throttle</h2>
<p><a data-primary="Throttle operator" data-type="indexterm" id="idm45884796489664"/><a data-primary="timed operations, Rx" data-secondary="Throttle" data-type="indexterm" id="idm45884796488736"/><a data-primary="query operators, Rx" data-secondary="Throttle" data-type="indexterm" id="idm45884796487792"/>The <code>Throttle</code> operator lets you limit the rate at which you process items. You pass a <code>TimeSpan</code> that specifies the minimum time interval you want between any two items. If the underlying source produces items faster than this, <code>Throttle</code> will just discard them. If the source is slower than the specified rate, <code>Throttle</code> just passes everything straight through.</p>
<p>Surprisingly (or at least, I found this surprising), once the source exceeds the specified rate, <code>Throttle</code> drops <em>everything</em> until the rate drops back down below the specified level. So, if you specify a rate of 10 items a second, and the source produces 100 per second, it won’t simply return every 10th item—it’ll return nothing until the source slows down.</p>
</div></section>
<section data-pdf-bookmark="Sample" data-type="sect2"><div class="sect2" id="sample">
<h2>Sample</h2>
<p><a data-primary="Sample operator" data-type="indexterm" id="idm45884796447600"/><a data-primary="timed operations, Rx" data-secondary="Sample" data-type="indexterm" id="idm45884796446768"/><a data-primary="query operators, Rx" data-secondary="Sample" data-type="indexterm" id="idm45884796445920"/>The <code>Sample</code> operator produces items from its input at the interval specified by its <code>TimeSpan</code> argument, regardless of the rate at which the input observable is generating items. If the underlying source produces items faster than the chosen rate, <code>Sample</code> drops items to limit the rate. However, if the source is running slower, the <code>Sample</code> operator will just repeat the last value to ensure a constant supply of notifications.</p>
</div></section>
<section data-pdf-bookmark="Timeout" data-type="sect2"><div class="sect2" id="timeout">
<h2>Timeout</h2>
<p><a data-primary="timed operations, Rx" data-secondary="Timeout" data-type="indexterm" id="idm45884796441520"/><a data-primary="Timeout operator" data-type="indexterm" id="idm45884796440320"/><a data-primary="query operators, Rx" data-secondary="Timeout" data-type="indexterm" id="idm45884796439648"/>The <code>Timeout</code> operator passes everything through from its source observable unless the source leaves too large a gap between either the subscription time and the first item or between two subsequent calls to the observer. You specify the minimum acceptable gap with a <code>TimeSpan</code> argument. If no activity occurs within that time, the <code>Timeout</code> operator completes by reporting a <code>TimeoutException</code> to <code>OnError</code>.</p>
</div></section>
<section data-pdf-bookmark="Windowing Operators" data-type="sect2"><div class="sect2" id="windowing_operators-id1">
<h2>Windowing Operators</h2>
<p><a data-primary="timed operations, Rx" data-secondary="windowing operators" data-type="indexterm" id="idm45884796434688"/><a data-primary="windowing operators" data-secondary="time-based overloads" data-type="indexterm" id="idm45884796433712"/>I described the <code>Buffer</code> and <code>Window</code> operators earlier, but I didn’t show their time-based overloads. As well as being able to specify a window size and skip count, or to mark window boundaries with an ancillary observable source, you can also specify time-based windows.</p>
<p>If you pass just a <code>TimeSpan</code>, both operators will break the input into adjacent windows at the specified interval. This provides a considerably simpler way to estimate the words per minute than <a data-type="xref" href="#calculating_words_per_minute">Example 11-43</a>. <a data-type="xref" href="#timed_windows_with_buffer">Example 11-47</a> shows how to achieve the same effect with the <code>Buffer</code> operator using a timed window.</p>
<div data-type="example" id="timed_windows_with_buffer">
<h5><span class="label">Example 11-47. </span>Timed windows with <code>Buffer</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">IObservable</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">wordGroupCounts</code> <code class="p">=</code>
    <code class="k">from</code> <code class="n">wordGroup</code> <code class="k">in</code> <code class="n">words</code><code class="p">.</code><code class="n">Buffer</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">6</code><code class="p">))</code>
    <code class="k">select</code> <code class="n">wordGroup</code><code class="p">.</code><code class="n">Count</code> <code class="p">*</code> <code class="m">10</code><code class="p">;</code>
<code class="n">wordGroupCounts</code><code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="n">c</code> <code class="p">=&gt;</code> <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Words per minute: "</code> <code class="p">+</code> <code class="n">c</code><code class="p">));</code></pre></div>
<p>There are also overloads accepting both a <code>TimeSpan</code> and an <code>int</code>, enabling you to close the current window (thus starting the next window) either when the specified interval elapses or when the number of items exceeds a threshold. In addition, there are overloads accepting two <code>TimeSpan</code> arguments. These support the time-based equivalent of the combination of a window size and a skip count. The first <code>TimeSpan</code> argument specifies the window duration, while the second specifies the interval at which to start new windows. This means the windows do not need to be strictly adjacent—you can have gaps between them, or they can overlap. <a data-type="xref" href="#overlapping_timed_windows">Example 11-48</a> uses this to provide more frequent estimates of the word rate while still using a six-second <span class="keep-together">window.</span></p>
<div data-type="example" id="overlapping_timed_windows">
<h5><span class="label">Example 11-48. </span>Overlapping timed windows</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">IObservable</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">wordGroupCounts</code> <code class="p">=</code>
    <code class="k">from</code> <code class="n">wordGroup</code> <code class="k">in</code> <code class="n">words</code><code class="p">.</code><code class="n">Buffer</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">6</code><code class="p">),</code>
                                   <code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">1</code><code class="p">))</code>
    <code class="k">select</code> <code class="n">wordGroup</code><code class="p">.</code><code class="n">Count</code> <code class="p">*</code> <code class="m">10</code><code class="p">;</code></pre></div>
<p>Unlike the join-based chunking I showed in <a data-type="xref" href="#calculating_words_per_minute">Example 11-43</a>, <code>Window</code> and <code>Buffer</code> do not double-count items because they are not based on a concept of overlapping durations. They treat item arrivals as instantaneous events, which are either inside or outside of any given window. So the examples I’ve just shown will provide a slightly more accurate measure of rate.</p>
</div></section>
<section data-pdf-bookmark="Delay" data-type="sect2"><div class="sect2" id="delay">
<h2>Delay</h2>
<p><a data-primary="Delay operator" data-type="indexterm" id="idm45884796287120"/><a data-primary="timed operations, Rx" data-secondary="Delay" data-type="indexterm" id="idm45884796286288"/><a data-primary="query operators, Rx" data-secondary="Delay" data-type="indexterm" id="idm45884796285376"/>The <code>Delay</code> operator allows you to time-shift an observable source. You can pass a <code>TimeSpan</code>, in which case the operator will delay everything by the specified amount, or you can pass a <code>DateTimeOffset</code>, indicating a specific time at which you would like it to start replaying its input. Alternatively, you can pass an observable, and whenever that observable first produces something or completes, the <code>Delay</code> operator will start producing the values it has stored.</p>
<p>Regardless of how the time-shift duration is determined, in all cases the <code>Delay</code> operator attempts to maintain the same spacing between inputs. So, if the underlying source produces an item immediately, then another item after three seconds, and then a third item after a minute, the observable produced by <code>Delay</code> will produce items separated by the same time intervals.</p>
<p>Obviously, if your source starts producing items at a ferocious rate—two million items in a second, perhaps—there’s a limit to the fidelity with which <code>Delay</code> can reproduce the exact timing of the items, but it will do its best. The limits on accuracy are not fixed. They will be determined by the nature of the scheduler you’re using and the available CPU capacity on the machine. For example, if you use one of the UI-based schedulers, it will be limited by the availability of the UI thread and the rate at which that can dispatch work. (As with all time-based operators, <code>Delay</code> will pick a default scheduler for you, but it provides overloads that let you pass one.)</p>
</div></section>
<section data-pdf-bookmark="DelaySubscription" data-type="sect2"><div class="sect2" id="delaysubscription">
<h2>DelaySubscription</h2>
<p><a data-primary="DelaySubscription operator" data-type="indexterm" id="idm45884796277904"/><a data-primary="timed operations, Rx" data-secondary="DelaySubscription" data-type="indexterm" id="idm45884796277008"/><a data-primary="query operators, Rx" data-secondary="DelaySubscription" data-type="indexterm" id="idm45884796276064"/>The <code>DelaySubscription</code> operator offers a similar set of overloads to the <code>Delay</code> operator, but the way it tries to effect a delay is different. When you subscribe to an observable source produced by <code>Delay</code>, it will immediately subscribe to the underlying source and start buffering items, forwarding each item only when the required delay has elapsed. The strategy employed by <code>DelaySubscription</code> is simply to delay the subscription to the underlying source and then forward each item immediately.</p>
<p>For cold sources, <code>DelaySubscription</code> will typically do what you need, because delaying the start of work for a cold source will typically time-shift the entire process. But for a hot source, <code>DelaySubscription</code> will cause you to miss any events that occurred during the delay, and after that, you’ll start getting events with no time shift.</p>
<p>The <code>Delay</code> operator is more dependable—by time-shifting each item individually, it works for both hot and cold sources. However, it has to do more work—it needs to buffer everything it receives for the delay duration. For busy sources or long delays, this could consume a lot of memory. And the attempt to reproduce the original timings with a time shift is considerably more complicated than just passing items straight on. So, in scenarios where it is viable, <code>DelaySubscription</code> is more efficient.<a data-startref="ix_ch11-asciidoc48" data-type="indexterm" id="idm45884796270464"/><a data-startref="ix_ch11-asciidoc47" data-type="indexterm" id="idm45884796269728"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Reaqtor—Rx as a Service" data-type="sect1"><div class="sect1" id="reaqtor">
<h1>Reaqtor—Rx as a Service</h1>
<p><a data-primary="reactive extensions (Rx)" data-secondary="Reaqtor" data-type="indexterm" id="idm45884796267376"/><a data-primary="Reaqtor" data-type="indexterm" id="idm45884796266432"/>In May of 2021, Microsoft open sourced Reaqtor, a set of components that makes it possible to host long-running Rx queries in a service. Microsoft has been using this internally to provide event-driven functionality in a variety of its online services, including the Bing search engine and the online versions of Office. It enables features such as setting up alerts that tell you when you’ll need to leave to get to an appointment on time given current traffic conditions, for example. It has a proven track record of being able to maintain millions of active queries. The code for the core libraries that make this possible is hosted at <a href="https://github.com/reaqtive/reaqtor">the Reaqtor source repository</a>, and you can find <a href="https://reaqtive.net">documentation and supporting information</a>.</p>
<p>Reaqtor takes the programming model of Rx—observable sequences, subjects, and operators—and exploits .NET’s expression tree features described in <a data-type="xref" href="ch09.xhtml#ch_delegates_lambdas_events">Chapter 9</a> to enable queries to be stored or sent across the network. It also provides versions of standard LINQ operators that are able to persist their state, enabling queries with stateful operators (e.g., <code>Aggregate</code>, <code>DistinctUntilChanged</code>, or anything else that needs to remember something about what it has already seen) to survive beyond the lifetime of any single process. This enables an application to define a LINQ query to some observable source of data and set up a subscription to that query that will be hosted in a server pool, persisting with an arbitrarily long lifetime. Reaqtor is designed to offer the same kind of durability as a database, so some of Microsoft’s applications have Rx queries that have been running uninterrupted for several years.</p>
<p>The relationship between Rx and Reaqtor is not unlike the relationship between LINQ to Objects and Entity Framework (EF) Core. As you saw in <a data-type="xref" href="ch10.xhtml#ch_linq">Chapter 10</a>, LINQ to Objects is built on <code>IEnumerable&lt;T&gt;</code>, and it works entirely in-memory, with no persistence or cross-process capability. EF Core takes the same basic concepts and offers most of the same operators, but by building on the expression-tree-based <code>IQueryable&lt;T&gt;</code>, EF Core is able to send representations of an application’s queries over to a database server so that they can be executed remotely—EF Core brings LINQ into a world of durable persistence and distributed execution. <a data-primary="IQbservable&lt;T&gt; interface" data-type="indexterm" id="idm45884796259472"/>Similarly, whereas Rx is built on <code>IObservable&lt;T&gt;</code> and runs entirely in-memory, Reaqtor uses an expression-tree-based interface <code>IQbservable&lt;T&gt;</code>. (Note the Q instead of an O, denoting its similarity in concept to <code>IQueryable&lt;T&gt;</code>.) <code>IQbservable&lt;T&gt;</code> looks very similar to <code>IObservable&lt;T&gt;</code> and offers all of the same operators, but because it works in the world of expression trees, it is possible for Reaqtor to convert queries into a form that can be sent over the network to a server farm, which can then reconstitute runnable versions of those queries hosted inside the server farm. It exploits the serializability to store the queries, enabling them to be migrated from one machine to another within the server farm, providing persistence and durability in the face of individual server failures. Reaqtor brings Rx into a world of durable persistence and distributed execution.</p>
<p>At the time of writing this, there isn’t an off-the-shelf hosted version of Reaqtor freely available, so it takes quite a lot of work to build something real from the Reaqtor libraries. But I’ve built a couple of applications on top of this with my employer, so I can say with confidence that it is certainly possible.</p>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="summary-id10">
<h1>Summary</h1>
<p>As you’ve now seen, the Reactive Extensions for .NET provide a lot of functionality. The concept underpinning Rx is a well-defined abstraction for sequences of items where the source decides when to provide each item, and a related abstraction representing a subscriber to such a sequence. By representing both concepts as objects, event sources and subscribers both become first-class entities, meaning you can pass them as arguments, store them in fields, and generally do anything with them that you can do with any other data type in .NET. While you can do all of that with a delegate too, .NET events are not first class. Moreover, Rx provides a clearly defined mechanism for notifying a subscriber of errors, something that neither delegates nor events handle well. As well as defining a first-class representation for event sources, Rx defines a comprehensive LINQ implementation, which is why Rx is sometimes described as LINQ to Events. In fact, it goes well beyond the set of standard LINQ operators, adding numerous operators that exploit and help to manage the live and potentially time-sensitive world that event-driven systems occupy. Rx also provides various services for bridging between its basic abstractions and those of other worlds, including standard .NET events, <code>IEnumerable&lt;T&gt;</code>, and various asynchronous models.<a data-startref="ix_ch11-asciidoc0" data-type="indexterm" id="idm45884796252944"/></p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="CHP-11-FN-1"><sup><a href="ch11.xhtml#CHP-11-FN-1-marker">1</a></sup> You can download the full WPF example to which this snippet belongs as part of the examples for this book.</p><p data-type="footnote" id="CHP-11-FN-2"><sup><a href="ch11.xhtml#CHP-11-FN-2-marker">2</a></sup> It is missing the <code>OrderBy</code> and <code>ThenBy</code> operators, because these make little sense in a push-based world. They cannot produce any items until they have seen all of their input items.</p><p data-type="footnote" id="CHP-11-FN-3"><sup><a href="ch11.xhtml#CHP-11-FN-3-marker">3</a></sup> Like some developers.</p><p data-type="footnote" id="CHP-11-FN-4"><sup><a href="ch11.xhtml#CHP-11-FN-4-marker">4</a></sup> The overloads are spread across multiple classes because some of these extension methods are technology specific. WPF gets <code>ObserveOn</code> overloads that work directly with its <code>Dispatcher</code> class instead of <code>IScheduler</code>, for example.</p><p data-type="footnote" id="CHP-11-FN-5"><sup><a href="ch11.xhtml#CHP-11-FN-5-marker">5</a></sup> In fact, <code>Publish</code> uses <code>Subject&lt;T&gt;</code> internally in the current version of Rx.</p></div></div></section></div></body></html>