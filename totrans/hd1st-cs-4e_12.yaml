- en: 'Chapter 8\. Enums and Collections: *Organizing your Data*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![Images](assets/405fig01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Data isn’t always as neat and tidy as you’d like it to be.**'
  prefs: []
  type: TYPE_NORMAL
- en: In the real world, you don’t receive your data in tidy little bits and pieces.
    No, your data’s going to come at you in **loads, piles, and bunches**. You’ll
    need some pretty powerful tools to organize all of it, and that’s where **enums**
    and **collections** come in. Enums are types that let you define valid values
    to categorize your data. Collections are special objects that store many values,
    letting you **store, sort, and manage** all the data that your programs need to
    pore through. That way, you can spend your time thinking about writing programs
    to work with your data, and let the collections worry about keeping track of it
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: Strings don’t always work for storing categories of data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’re going to be working with playing cards over the next few chapters, so
    let’s build a Card class that we’ll use. First, create a new Card class that has
    a constructor that lets you pass it a suit and value, which it stores as strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![Images](assets/406fig01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'That looks pretty good. We can create a Card object and use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'But there’s a problem. Using strings to hold suits and values can have some
    unexpected results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/406fig01a.png)'
  prefs: []
  type: TYPE_IMG
- en: We ***could*** add code to the constructor to check each string and make sure
    it’s a valid suit or value, and handle bad input by throwing an exception. That’s
    a valid approach—assuming you deal with the exceptions correctly, of course.
  prefs: []
  type: TYPE_NORMAL
- en: 'But ***wouldn’t it be great*** if the C# compiler could automatically detect
    those invalid values for us? What if the compiler could ensure that all of the
    cards are valid before you even run the code? Well, guess what: it ***will***
    do that! All you need to do is **enumerate** the values that are OK to use.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/406fig02.png)'
  prefs: []
  type: TYPE_IMG
- en: Enums let you work with a set of valid values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An **enum** or **enumeration type** is a data type that only allows certain
    values for that piece of data. So we could define an enum called `Suits`, and
    define the allowed suits:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/407fig01.png)'
  prefs: []
  type: TYPE_IMG
- en: An enum defines a new type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you use the `enum` keyword you’re **defining a new type**. Here are a
    few useful things to know about enums:'
  prefs: []
  type: TYPE_NORMAL
- en: '**An enum lets you define a new type that only allows a specific set of values.
    Any value that’s not part of the enum will break the code, which can prevent bugs
    later.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![Images](assets/btick.png) **You can use an enum as the type in a variable
    definition, just like you’d use string, int, or any other type:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![Images](assets/btick.png) **Since an enum is a type, you can use it to create
    an array:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![Images](assets/btick.png) **Use == to compare enum values. Here’s a method
    that takes a Suit enum as a parameter, and uses == to check if it’s equal to Suits.Hearts:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/407fig02.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](assets/btick.png) **But you can’t just make up a new value for the
    enum. If you do, the program won’t compile—which means you can avoid some annoying
    bugs:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler gives you an error if you use a value that’s not part of the enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/407fig03.png)'
  prefs: []
  type: TYPE_IMG
- en: Enums let you represent numbers with names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes it’s easier to work with numbers if you have names for them. You
    can assign numbers to the values in an enum and use the names to refer to them.
    That way, you don’t have a bunch of unexplained numbers floating around in your
    code. Here’s an enum to keep track of the scores for tricks at a dog competition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/408fig01.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can cast an int to an enum, and you can cast an (intbased) enum back to
    an int.
  prefs: []
  type: TYPE_NORMAL
- en: Some enums use a different type, like byte or long (like the one below). You
    can cast those to their type instead of int.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an excerpt from a method that uses the `TrickScore` enum by casting
    it to and from an int value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/408fig02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can cast the enum as a number and do calculations with it. You can even
    convert it to a string—an enum’s ToString method returns a string with the member
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/408fig03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you don’t assign any number to a name, the items in the list will be given
    values by default. The first item will be assigned a 0 value, the second a 1,
    etc. But what happens if you want to use really big numbers for one of the enumerators?
    The default type for the numbers in an enum is int, so you’ll need to specify
    the type you need using the colon (:) operator, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/408fig04.png)![Images](assets/408fig05.png)'
  prefs: []
  type: TYPE_IMG
- en: We could use an array to create a deck of cards...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What if you wanted to create a class to represent a deck of cards? It would
    need a way to keep track of every card in the deck, and it’d need to know what
    order they were in. A `Cards` array would do the trick—the top card in the deck
    would be at value 0, the next card at value 1, etc. Here’s a starting point—a
    Deck that starts out with a full deck of 52 cards:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/409fig10d.png)'
  prefs: []
  type: TYPE_IMG
- en: '...but what if you wanted to do more?'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Think of everything you might need to do with a deck of cards, though. If you’re
    playing a card game, you routinely need to change the order of the cards, and
    add and remove cards from the deck. You just can’t do that with an array very
    easily. For example, take another look at the AddWorker method from the Beehive
    Management System exercise in [#inheritance_your_objectapostrophes_famil](ch06.html#inheritance_your_objectapostrophes_famil):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/409fig10e.png)'
  prefs: []
  type: TYPE_IMG
- en: You had to use Array.Resize to make the array longer, then add the worker to
    the end. That’s a lot of work.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays can be annoying to work with
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An array is fine for storing a fixed list of values or references. Once you
    need to move array elements around, or add more elements than the array can hold,
    things start to get a little sticky. Here are a few ways that working with arrays
    can be troublesome.
  prefs: []
  type: TYPE_NORMAL
- en: Every array has a length. That length doesn’t change unless you resize the array,
    so you need to know the length to work with it. Let’s say you want to use an array
    to store Card references. If the number of references you want to store is less
    than the length of the array, you could use null references to keep some array
    elements empty.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/412fig01.png)'
  prefs: []
  type: TYPE_IMG
- en: You’d need to keep track of how many cards are being held in the array. You
    could add an int field—maybe you’d call it cardCount—that would hold the index
    of the last card in the array. So your three-card array would have a Length of
    7, but you’d set cardCount equal to 3.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/412fig02.png)'
  prefs: []
  type: TYPE_IMG
- en: Now things get complicated. It’s easy enough to add a Peek method that just
    returns a reference to the top card, so you can peek at the top of the deck. What
    if you want to add a card? If cardCount is less than the array’s Length, you can
    just put your card in the array at that index and add 1 to cardCount. But if the
    array is full, you’ll need to create a new, bigger array and copy the existing
    cards to it. Removing a card is easy enough—but after you subtract 1 from cardCount,
    you’ll need to make sure to set the removed card’s array index back to `null`.
    What if you need to remove a card **from the middle of the list**? If you remove
    card 4, you’ll need to move card 5 back to replace it, and then move 6 back, then
    7...wow, what a mess!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The AddWorker method from [#inheritance_your_objectapostrophes_famil](ch06.html#inheritance_your_objectapostrophes_famil)
    used the Array. Resize method to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Lists make it easy to store collections of...anything
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# and .NET have **collection** classes that handle all of those nasty issues
    that come up when you add and remove array elements. The most common sort of collection
    is a List<T>. Once you create a List<T> object, it’s easy to add an item, remove
    an item from any location in the list, peek at an item, and even move an item
    from one place in the list to another. Here’s how a list works.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We’ll sometimes leave the <T> off when referring to List in the book. When you
    see List, think List<T>.
  prefs: []
  type: TYPE_NORMAL
- en: '**First you create a new instance of List<T>.** Recall that every array has
    a type—you don’t just have an array, you have an int array, a Card array, etc.
    Lists are the same. You need to specify the type of object or value that the list
    will hold by putting it in angle brackets (<>) when you use the `new` keyword
    to create it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](assets/413fig01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Now you can add to your List<T>.** Once you’ve got a `List<T>` object, you
    can add as many items to it as you want as long as they’re ***polymorphic*** with
    whatever type you specified when you created your new List<T>—which means they’re
    assignable to the type (and that includes interfaces, abstract classes, and base
    classes).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](assets/413fig02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Lists are more flexible than arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The List class is built into the .NET Framework, and it lets you do a lot of
    things with objects that you can’t do with a plain old array. Check out some of
    the things you can do with a List<T>.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/414fig02.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s build an app to store shoes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It’s time to see a List in action. Let’s build a .NET Core console app that
    prompts the user to add or remove shoes. Here’s an example of what it looks like
    to run the app, adding two shoes and then removing them:'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with a Shoe class that stores the style and color for a shoe. Then
    we’ll create a class called ShoeCloset that stores the shoes in a List<Shoe>,
    with AddShoe and RemoveShoe methods that prompt the user to add or remove shoes.
  prefs: []
  type: TYPE_NORMAL
- en: '***Do this!***'
  prefs: []
  type: TYPE_NORMAL
- en: '**Add an enum for shoe style.** Some shoes are sneakers, others are sandals,
    so an enum makes sense:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Images](assets/p417fig001.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Add the Shoe class.** It uses the `Style` enum for the shoe style and a string
    for shoe color, and works just like the Card class we created earlier in the chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](assets/417fig01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](assets/417fig02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Press ‘a’ to add a shoe, then choose the type of shoe and type in the color.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Press ‘r’ to remove a shoe, then enter the number of the shoe to remove.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](assets/417fig03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**The ShoeCloset class uses a List<Shoe> to manage its shoes.** The ShoeCloset
    class has three methods—the PrintShoes method prints a list of shoes to the console,
    the AddShoe method prompts the user to add a shoe to the closet, and the RemoveShoe
    method prompts the user to remove a shoe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Images](assets/418fig01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Add the Program class with the entry point.** Notice how it doesn’t do very
    much? That’s because all of the interesting behavior is encapsulated in the ShoeCloset
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Images](assets/419fig01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Run your app and reproduce the sample output.** Try debugging the app, and
    start to get familiar with how you work with lists. No need to memorize anything
    right now—you’ll get plenty of practice with them!'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generic collections can store any type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You’ve already seen that a list can store strings or Shoes. You could also
    make lists of integers or any other object you can create. That makes a list a
    **generic collection**. When you create a new list object, you tie it to a specific
    type: you can have a list of ints, or strings, or Shoe objects. That makes working
    with lists easy—once you’ve created your list, you always know the type of data
    that’s inside it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what does “generic” really mean? Let’s use Visual Studio to explore generic
    collections. Open *ShoeCloset.cs* and hover your mouse cursor over `List`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg420-01a.png)'
  prefs: []
  type: TYPE_IMG
- en: '**A generic collection can hold any type of object, and gives you a consistent
    set of methods to work with the objects in the collection no matter what type
    of object it’s holding.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'There are a few things to notice:'
  prefs: []
  type: TYPE_NORMAL
- en: The List class is in the namespace System.Collections.Generic—this namespace
    has several classes for generic collections (which is why you needed the `using`
    line).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The description says that List provides “methods to search, sort, and manipulate
    lists.” You used some of these methods in your ShoeCloset class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The top line says `List<T>` and the bottom says `T is Shoe`. This is how generics
    are defined—it’s saying that List can handle any type, but for this specific list
    that type is the Shoe class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic lists are declared using <angle brackets>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you declare a list—no matter what type it holds—you always declare it the
    same way, using <angle brackets> to specify the type of object being stored in
    the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll often see generic classes (not just List) written like this: List<T>.
    That’s how you know the class can take any type.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg420-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Collection initializers are similar to object initializers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# gives you a nice bit of shorthand to cut down on typing when you need to
    create a list and immediately add a bunch of items to it. When you create a new
    List object, you can use a **collection initializer** to give it a starting list
    of items. It’ll add them as soon as the list is created.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/426fig01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**A collection initializer makes your code more compact by letting you combine
    creating a list with adding an initial set of items.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s create a List of Ducks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '***Do this!***'
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a Duck class that keeps track of your many neighborhood ducks. (You *do*
    collect ducks, don’t you?) **Create a new Console App project** and add a new
    Duck class and KindOfDuck enum.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/427fig01.png)![Images](assets/427fig02.png)'
  prefs: []
  type: TYPE_IMG
- en: Here’s the initializer for your List of Ducks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’ve got six ducks, so you’ll create a List<Duck> that has a collection initializer
    with six statements. Each statement in the initializer creates a new Duck, using
    an object initializer to set each Duck object’s Size and Kind fields. Make sure
    this `**using directive**` is at the top of *Program.cs*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then **add this PrintDucks method** to your Program class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, **add this code** to your Main method in *Program.cs* to create a
    List of Ducks and then print them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Run your code—it will print a bunch of Ducks to the console.**'
  prefs: []
  type: TYPE_NORMAL
- en: Lists are easy, but SORTING can be tricky
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s not hard to think about ways to sort numbers or letters. But how do you
    sort two individual objects, especially if they have multiple fields? In some
    cases you might want to order objects by the value in the Name field, while in
    other cases it might make sense to order objects based on height or date of birth.
    There are lots of ways you can order things, and lists support all of them.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/428fig01.png)'
  prefs: []
  type: TYPE_IMG
- en: Lists know how to sort themselves
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every List comes with a **Sort method** that rearranges all of the items in
    the list to put them in order. Lists already know how to sort most built-in types
    and classes, and it’s easy to teach them how to sort your own classes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Technically, it’s not the List<T> that knows how to sort itself. This is the
    job of an IComparer<T> object, which you’ll learn about in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/428fig02.png)'
  prefs: []
  type: TYPE_IMG
- en: IComparable<Duck> helps your List sort its Ducks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have a List of numbers and call its Sort method, it will sort the list
    with the smallest numbers first and largest last. How does the List know which
    way to sort the Duck objects? We tell List.Sort that the Duck class can be sorted—and
    we do that the way we typically indicate that a class can do a certain job, *with
    an interface*.
  prefs: []
  type: TYPE_NORMAL
- en: '**You can make any class work with List’s built-in Sort method by having it
    implement IComparable<T> and adding a CompareTo method.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The List.Sort method knows how to sort any type or class that **implements the
    IComparable<T> interface**. That interface has just one member—a method called
    CompareTo. Sort uses an object’s CompareTo method to compare it with other objects,
    and uses its return value (an int) to determine which comes first.
  prefs: []
  type: TYPE_NORMAL
- en: An object’s CompareTo method compares it to another object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way to give our List object the ability to sort ducks is to **modify the
    Duck class to implement IComparable<Duck>** and add its only member, a CompareTo
    method that takes a Duck reference as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update your project’s Duck class by implementing IComparable<Duck> so that
    it sorts itself based on duck size:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/429fig02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Add this line of code** to the end of your Main method just before the call
    to PrintDucks. This tells your list of ducks to sort itself. Now it sorts the
    ducks by size before printing them to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/429fig01.png)'
  prefs: []
  type: TYPE_IMG
- en: Use IComparer to tell your List how to sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Your Duck class implements IComparable, so List.Sort knows how to sort a List
    of Duck objects. But what if you want to sort them in a different way than usual?
    Or what if you want to sort a type of object that doesn’t implement IComparable?
    Then you can pass a **comparer object** as an argument to List.Sort, to give it
    a different way to sort its objects. Notice how List.Sort is overloaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/430fig01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There’s an overloaded version of List.Sort that **takes an IComparer<T> reference**,
    where T will be replaced by the generic type for your list (so for a List<Duck>
    it takes an IComparer<Duck> argument, for a List<string> it’s an IComparer<string>,
    etc.). You’ll pass it a reference to an object that implements an interface, and
    we know what that means: that it *does a specific job*. In this case, that job
    is comparing pairs of items in the list to tell List.Sort what order to sort them
    in.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The IComparer<T> interface has one member, a **method called Compare**. It’s
    just like the CompareTo method in IComparable<T>: it takes two object parameters,
    `x` and `y`, and returns an a positive value if `x` comes before `y`, a negative
    value if `x` comes after `y`, or zero if they’re the same.'
  prefs: []
  type: TYPE_NORMAL
- en: Add an IComparer to your project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Add the DuckComparerBySize class to your project**. It’s a comparer object
    that you can pass as a parameter to List.Sort to make it sort your ducks by size.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The IComparer interface is in the System.Collections.Generic namespace, so
    if you’re adding this class to a new file make sure it has the right `using` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the code for the comparer class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/430fig02.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Can you figure out how to modify DuckComparerBySize so it sorts the ducks
    largest to smallest instead?**'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**A comparer object is an instance of a class that implements IComparer<T>
    that you can pass as a reference to List.Sort. Its Compare method works just like
    the ComapreTo method in the IComparable<T> interface. When List.Sort compares
    its elements to sort them, it passes pairs of objects to the Compare method in
    your comparer object, so your List will sort differently depending on how you
    implement the comparer.**'
  prefs: []
  type: TYPE_NORMAL
- en: Create an instance of your comparer object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you want to sort using IComparer<T>, you need to create a new instance
    of the class that implements it—in this case, Duck. That’s the comparer object
    that will help List.Sort figure out how to sort its elements. Like any other (nonstatic)
    class, you need to instantiate it before you use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/431fig01.png)'
  prefs: []
  type: TYPE_IMG
- en: Multiple IComparer implementations, multiple ways to sort your objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can create multiple IComparer<Duck> classes with different sorting logic
    to sort the ducks in different ways. Then you can use the comparer you want when
    you need to sort in that particular way. Here’s another duck comparer implementation
    to add to your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/431fig02.png)'
  prefs: []
  type: TYPE_IMG
- en: Go back and modify your program to use this new comparer. Now it sorts the ducks
    by kind before it prints them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Comparers can do complex comparisons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One advantage to creating a separate class for sorting your ducks is that you
    can build more complex logic into that class—and you can add members that help
    determine how the list gets sorted.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/432fig01.png)'
  prefs: []
  type: TYPE_IMG
- en: Overriding a ToString method lets an object describe itself
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every object has a **method called ToString that converts it to a string**.
    You’ve already used it—any time you use `{curly braces}` in string interpolation
    that calls the ToString method of whatever’s inside them—and the IDE also takes
    advantage of it. When you create a class, it inherits the ToString method from
    Object, the top-level base class that all other classes extend.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Object.ToString method prints the **fully qualified class name**, or the
    namespace followed by a period followed by the class name. Since we used the namespace
    DucksProject when we were writing this chapter, the fully qualified class name
    for our Duck class is DucksProject.Duck:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/435fig001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The IDE also calls the ToString method—for example, when you watch or inspect
    a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/435fig01.png)'
  prefs: []
  type: TYPE_IMG
- en: Hmm, that’s not as useful as we’d hoped. You can see that there are six Duck
    objects in the list. If you expand a Duck, you can see its Kind and Size values.
    Wouldn’t it be easier if you could see all of them at once?
  prefs: []
  type: TYPE_NORMAL
- en: Override the ToString method to see your Ducks in the IDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Luckily, ToString is a virtual method of Object, the base class of every object.
    So all you need to do is **override the ToString** **method**—and when you do,
    you’ll see the results immediately in the IDE’s Watch window! Open up your Duck
    class and start adding a new method by typing `**override**`. As soon as you add
    a space, the IDE will show you the methods you can override:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/435fig02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Click on ToString()** to tell the IDE to add a new ToString method. Replace
    the contents so it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Run your program and look at the list again. Now the IDE shows you the contents
    of your Duck objects.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/435fig03.png)'
  prefs: []
  type: TYPE_IMG
- en: Update your foreach loops to let your Ducks and Cards write themselves to the
    console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You’ve seen two different examples of programs looping through a list of objects
    and calling Console.WriteLine to print a line to the console for each object—like
    this foreach loop that prints every Card in a List<Card>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The PrintDucks method did something similar for Duck objects in a List:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a pretty common thing to do with objects. Now that your Duck has a
    ToString method, your PrintDucks method should take advantage of it. Use the IDE’s
    IntelliSense to look through the overloads for the Console.WriteLine method—specifically
    this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/436fig01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can pass any object to Console.WriteLine, and it will call its ToString
    method. So you can replace the PrintDucks method with one that calls this overload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**Replace the PrintDucks method** with this one and run your code again. It
    prints the same output. If you want to add, say, a Color or Weight property to
    your Duck object, you just have to update the ToString method, and everything
    that uses it (including the PrintDucks method) will reflect that change.'
  prefs: []
  type: TYPE_NORMAL
- en: Add a ToString method to your Card object, too
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your Card object already has a Name property that returns the name of the card:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s exactly what its ToString method should do. So, add a ToString method
    to the Card class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**We decided to make the ToString method call the Name property. Do you think
    we made the right choice? Would it have been better to delete the Name property
    and move its code to the ToString method? When you’re going back to modify your
    code, you have to make choices like this—and it’s not always obvious which choice
    is best.**'
  prefs: []
  type: TYPE_NORMAL
- en: Now your programs that use Card objects will be easier to debug.
  prefs: []
  type: TYPE_NORMAL
- en: You can upcast an entire list using IEnumerable<T>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember how you can upcast any object to its superclass? Well, when you’ve
    got a List of objects, you can upcast the entire list at once. It’s called **covariance**,
    and all you need for it is an IEnumerable<T> interface reference.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how this works. We’ll start with the Duck class that you’ve been working
    with throughout the chapter. Then we’ll add a Bird class that it will extend.
    The Bird class will include a static method that iterates over a collection of
    Bird objects. Can we get it to work with a List of Ducks?
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/440fig01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Since all Ducks are Birds, covariance lets us convert a collection of Ducks
    to a collection of Birds. That can be really useful if you have to pass a List<Duck>
    to a method that only accepts a List<Bird>.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***Do this!***'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create a new Console App project.** Add a base class, Bird (for Duck to extend),
    and a Penguin class. We’ll use the ToString method to make it easy to see which
    class is which.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Images](assets/440fig02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Add your Duck class to the application.** Modify its declaration to **make
    it extend Bird**. You’ll also need to **add the KindOfDuck enum** from earlier
    in the chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Images](assets/441fig001.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Create the List<Duck> collection.** Go ahead and **add this code to your
    Main method**—it’s the code from earlier in the chapter, plus one line to upcast
    it to a List<Bird>:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Images](assets/441fig002.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Uh-oh—that code won’t compile. The error message is telling you that you can’t
    convert your Duck collection to a Bird collection. Let’s try assigning `ducks`
    to a List<Bird>:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](assets/441fig02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Well, that didn’t work. We got a different error, but it still says we can’t
    convert the type:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](assets/441fig03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Which makes sense—it’s exactly like safely upcasting versus downcasting, which
    you learned about in [#inheritance_your_objectapostrophes_famil](ch06.html#inheritance_your_objectapostrophes_famil):
    we can use assignment to downcast, but we need to use the `is` keyword to safely
    upcast. So how do we safely upcast our List<Duck> to a List<Bird>?'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Use covariance to make your ducks fly away.** That’s where **covariance**
    comes in: you can ***use assignment to upcast your List<Duck> to an IEnumerable<Bird>***.
    Once you’ve got your IEnumerable<Bird>, you can call its ToList method to convert
    it to a List<Bird>. You’ll need to add using using `System.Collections.Generic`;
    and using `System.Linq`; to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Images](assets/441fig003.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Use a Dictionary to store keys and values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A list is like a big long page full of names. What if you also want, for each
    name, an address? Or for every car in the `garage` list, you want details about
    that car? You need another kind of .NET collection: a **dictionary**. A dictionary
    lets you take a special value—the **key**—and associate that key with a bunch
    of data—the **value**. One more thing: a specific key can **only appear once**
    in any dictionary.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/442fig01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here’s how you declare a .NET Dictionary in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/442fig02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s see a dictionary in action. Here’s a small console app that uses a Dictionary<string,
    string> to keep track of the favorite foods of a few friends:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/442fig03.png)'
  prefs: []
  type: TYPE_IMG
- en: The Dictionary functionality rundown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dictionaries are a lot like lists. Both types are flexible in letting you work
    with lots of data types, and also come with lots of built-in functionality. Here
    are the basic things you can do with a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '**Add an item.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can add an item to a dictionary using its **indexer** with square brackets:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can also add an item to a dictionary using its **Add method:**
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Look up a value using its key.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The most important thing you’ll do with a dictionary is **look up values with
    the indexer**—which makes sense, because you stored those values in a dictionary
    so you could look them up using their unique keys. This example shows a Dictionary<string,
    string>, so we’ll look up values using a string key, and the dictionary returns
    a string value:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Remove an item.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Just like with a list, you can remove an item from a dictionary using the **Remove
    method**. All you need to pass to the Remove method is the key value to have both
    the key and the value removed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Get a list of keys.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can get a list of all of the keys in a dictionary using its **Keys property**
    and loop through it using a `foreach` loop. Here’s what that would look like:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Keys is a property of your Dictionary object. This particular dictionary has
    string keys, so Keys is a collection of strings.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Count the pairs in the dictionary.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Count property** returns the number of key/value pairs that are in the
    dictionary:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Keys are unique in a dictionary; any key appears exactly once. Values can appear
    any number of times—two keys can have the same value. That way, when you look
    up or remove a key, the dictionary knows what to remove.
  prefs: []
  type: TYPE_NORMAL
- en: Your key and value can be different types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Dictionaries are versatile! They can hold just about anything, not just value
    types but ***any kind of object***. Here’s an example of a dictionary that’s storing
    an integer as a key and a Duck object reference as a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It’s common to see a dictionary that maps integers to objects when you’re assigning
    unique ID numbers to objects.
  prefs: []
  type: TYPE_NORMAL
- en: Build a program that uses a dictionary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here’s a quick app that New York Yankees baseball fans will like. When an important
    player retires, the team retires the player’s jersey number. **Create a new console
    app** that looks up some Yankees who wore famous numbers and when those numbers
    were retired. Here’s a class to keep track of a retired baseball player:'
  prefs: []
  type: TYPE_NORMAL
- en: '***Do this!***'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s the Program class with a Main method that adds retired players to
    a dictionary. We can use the jersey number as the dictionary key because it’s
    **unique**—once a jersey number is retired, the team ***never uses it again***.
    That’s an important thing to consider when designing an app that uses a dictionary:
    you never want to discover your key is not as unique as you thought!'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Yogi Berra was #8 for the New York Yankees, while Cal Ripken Jr. was #8 for
    the Baltimore Orioles.But in a Dictionary, you can have duplicate values, but
    every key must be unique. Can you think of a way to store retired numbers for
    multiple teams?**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/444fig01.png)'
  prefs: []
  type: TYPE_IMG
- en: And yet MORE collection types...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: List and Dictionary are two of the most frequently used collection types that
    are part of the .NET. Lists and dictionaries are very flexible—you can access
    any of the data in them in any order. But sometimes you’re using a collection
    to represent a bunch of things in the real world that need to be accessed in a
    specific order. You can restrict how your code accesses the data in a collection
    by using **a Queue or a Stack**. Those are generic collections like List<T>, but
    they’re especially good at making sure that your data is processed in a certain
    order.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are other types of collections, too—but these are the ones that you’re
    most likely to come in contact with.
  prefs: []
  type: TYPE_NORMAL
- en: '**Use a Queue when the first object you store will be the first one you’ll
    use, like with:**'
  prefs: []
  type: TYPE_NORMAL
- en: Cars moving down a one-way street
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: People standing in line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customers on hold for a customer service support line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything else that’s handled on a first-come, first-served basis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A queue is first in, first out, which means that the first object that you put
    into the queue is the first one you pull out of it to use.
  prefs: []
  type: TYPE_NORMAL
- en: '**Use a Stack when you always want to use the object you stored most recently,
    like with:**'
  prefs: []
  type: TYPE_NORMAL
- en: Furniture loaded into the back of a moving truck
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A stack of books where you want to read the most recently added one first
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: People boarding or leaving a plane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pyramid of cheerleaders, where the ones on top have to dismount first...imagine
    the mess if the one on the bottom walked away first!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'A stack is last in, first out: the first object that goes into the stack is
    the last one that comes out of it.'
  prefs: []
  type: TYPE_NORMAL
- en: Generic .NET collections implement IEnumerable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Almost every large project that you’ll work on will include some sort of generic
    collection, because your programs need to store data. When you’re dealing with
    groups of similar things in the real world, they almost always naturally fall
    into a category that corresponds pretty well to one of these kinds of collections.
    No matter which of these collection types you use—List, Dictionary, Stack, or
    Queue—you’ll always be able to use a foreach loop with them because all of them
    implement IEnumerable<T>.
  prefs: []
  type: TYPE_NORMAL
- en: '**A queue is like a list that lets you add objects to the end and use the ones
    at the beginning. A stack only lets you access the last object you put into it.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can, however, use foreach to enumerate through a stack or queue, because
    they implement **IEnumerable!**
  prefs: []
  type: TYPE_NORMAL
- en: A queue is FIFO—first in, first out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **queue** is a lot like a list, except that you can’t just add or remove items
    at any index. To add an object to a queue, you **enqueue** it. That adds the object
    to the end of the queue. You can **dequeue** the first object from the front of
    the queue. When you do that, the object is removed from the queue, and the rest
    of the objects in the queue move up a position.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/446fig02.png)![Images](assets/446fig01.png)'
  prefs: []
  type: TYPE_IMG
- en: A stack is LIFO—last in, first out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **stack** is really similar to a queue—with one big difference. You **push**
    each item onto a stack, and when you want to take an item from the stack, you
    **pop** one off of it. When you pop an item off of a stack, you end up with the
    most recent item that you pushed onto it. It’s just like a stack of plates, magazines,
    or anything else—you can drop something onto the top of the stack, but you need
    to take it off before you can get to whatever’s underneath it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/447fig01.png)![Images](assets/447fig02z.png)![Images](assets/447fig02.png)![Images](assets/448fig01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**You don’t give up anything when you use a queue or a stack.**'
  prefs: []
  type: TYPE_NORMAL
- en: It’s really easy to copy a Queue object to a List object. It’s just as easy
    to copy a List to a Queue, a Queue to a Stack...in fact, you can create a List,
    Queue, or Stack from any other object that implements the IEnumerable<T> interface.
    All you have to do is use the overloaded constructor that lets you pass the collection
    you want to copy from as a parameter. That means you have the flexibility and
    convenience of representing your data with the collection that best matches the
    way you need it to be used. (But remember, you’re making a copy, which means you’re
    creating a whole new object and adding it to the heap.)
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/448fig02.png)'
  prefs: []
  type: TYPE_IMG
