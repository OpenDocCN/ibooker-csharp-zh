- en: 'Chapter 8\. Enums and Collections: *Organizing your Data*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。枚举和集合：*组织您的数据*
- en: '![Images](assets/405fig01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/405fig01.png)'
- en: '**Data isn’t always as neat and tidy as you’d like it to be.**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据并不总是那么整洁和整齐。**'
- en: In the real world, you don’t receive your data in tidy little bits and pieces.
    No, your data’s going to come at you in **loads, piles, and bunches**. You’ll
    need some pretty powerful tools to organize all of it, and that’s where **enums**
    and **collections** come in. Enums are types that let you define valid values
    to categorize your data. Collections are special objects that store many values,
    letting you **store, sort, and manage** all the data that your programs need to
    pore through. That way, you can spend your time thinking about writing programs
    to work with your data, and let the collections worry about keeping track of it
    for you.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，您不会收到整齐的小数据片段。不，您的数据会以**大量、堆和成群**的方式出现。您将需要一些非常强大的工具来组织所有这些数据，这就是**枚举**和**集合**发挥作用的地方。枚举是一种类型，让您定义用于对数据进行分类的有效值。集合是特殊的对象，可以存储许多值，让您**存储、排序和管理**程序需要处理的所有数据。这样，您可以花时间考虑编写处理数据的程序，而让集合为您跟踪数据。
- en: Strings don’t always work for storing categories of data
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串并不总是适用于存储数据的类别
- en: 'We’re going to be working with playing cards over the next few chapters, so
    let’s build a Card class that we’ll use. First, create a new Card class that has
    a constructor that lets you pass it a suit and value, which it stores as strings:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来几章，我们将使用扑克牌进行工作，因此让我们构建一个我们将使用的`Card`类。首先，创建一个新的`Card`类，其中包含一个构造函数，允许您传递花色和值，并将它们存储为字符串：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Images](assets/406fig01.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/406fig01.png)'
- en: 'That looks pretty good. We can create a Card object and use it like this:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错。我们可以创建一个`Card`对象并像这样使用它：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'But there’s a problem. Using strings to hold suits and values can have some
    unexpected results:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有个问题。使用字符串来保存花色和值可能会产生一些意想不到的结果：
- en: '![Images](assets/406fig01a.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/406fig01a.png)'
- en: We ***could*** add code to the constructor to check each string and make sure
    it’s a valid suit or value, and handle bad input by throwing an exception. That’s
    a valid approach—assuming you deal with the exceptions correctly, of course.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们***可以***向构造函数添加代码来检查每个字符串，并确保它是有效的花色或值，并通过抛出异常来处理不良输入。这是一个有效的方法——当然，前提是您正确处理异常。
- en: 'But ***wouldn’t it be great*** if the C# compiler could automatically detect
    those invalid values for us? What if the compiler could ensure that all of the
    cards are valid before you even run the code? Well, guess what: it ***will***
    do that! All you need to do is **enumerate** the values that are OK to use.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但是***如果*** C# 编译器能够自动检测到这些无效值，那不是很棒吗？如果编译器能够在您运行代码之前确保所有卡片都是有效的，会怎么样？好吧，猜猜看：它***会***做到！您需要做的就是**枚举**可以使用的值。
- en: '![Images](assets/406fig02.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/406fig02.png)'
- en: Enums let you work with a set of valid values
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举允许您使用一组有效的值
- en: 'An **enum** or **enumeration type** is a data type that only allows certain
    values for that piece of data. So we could define an enum called `Suits`, and
    define the allowed suits:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**枚举**或**枚举类型**是一种数据类型，仅允许该数据片段的某些值。因此，我们可以定义一个名为`Suits`的枚举，并定义允许的花色：'
- en: '![Images](assets/407fig01.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/407fig01.png)'
- en: An enum defines a new type
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举定义了一个新类型
- en: 'When you use the `enum` keyword you’re **defining a new type**. Here are a
    few useful things to know about enums:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`enum`关键字时，您正在**定义一个新类型**。以下是有关枚举的一些有用信息：
- en: '**An enum lets you define a new type that only allows a specific set of values.
    Any value that’s not part of the enum will break the code, which can prevent bugs
    later.**'
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**枚举允许您定义一个新类型，该类型仅允许特定的一组值。不属于枚举的任何值都将使代码崩溃，这可以防止以后的错误。**'
- en: '![Images](assets/btick.png) **You can use an enum as the type in a variable
    definition, just like you’d use string, int, or any other type:**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](assets/btick.png) **您可以将枚举用作变量定义中的类型，就像您使用字符串、整数或任何其他类型一样：**'
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![Images](assets/btick.png) **Since an enum is a type, you can use it to create
    an array:**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](assets/btick.png) **由于枚举是一种类型，您可以使用它来创建数组：**'
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![Images](assets/btick.png) **Use == to compare enum values. Here’s a method
    that takes a Suit enum as a parameter, and uses == to check if it’s equal to Suits.Hearts:**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](assets/btick.png) **使用 == 来比较枚举值。这里有一个接受`Suit`枚举作为参数，并使用==检查它是否等于`Suits.Hearts`的方法：**'
- en: '![Images](assets/407fig02.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/407fig02.png)'
- en: '![Images](assets/btick.png) **But you can’t just make up a new value for the
    enum. If you do, the program won’t compile—which means you can avoid some annoying
    bugs:**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](assets/btick.png) **但你不能随意为枚举创造一个新值。如果这样做，程序将无法编译——这意味着你可以避免一些讨厌的错误：**'
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The compiler gives you an error if you use a value that’s not part of the enum:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用不属于枚举的值，编译器会报错：
- en: '![Images](assets/407fig03.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/407fig03.png)'
- en: Enums let you represent numbers with names
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举让你用名称表示数字
- en: 'Sometimes it’s easier to work with numbers if you have names for them. You
    can assign numbers to the values in an enum and use the names to refer to them.
    That way, you don’t have a bunch of unexplained numbers floating around in your
    code. Here’s an enum to keep track of the scores for tricks at a dog competition:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，如果你有数字的名称，使用数字会更容易。你可以为枚举值分配数字，并使用名称来引用它们。这样，你的代码中就不会有大量未解释的数字漂来漂去了。这是一个枚举，用于跟踪狗比赛中技巧的得分：
- en: '![Images](assets/408fig01.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/408fig01.png)'
- en: Note
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can cast an int to an enum, and you can cast an (intbased) enum back to
    an int.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将整数转换为枚举，也可以将（基于整数的）枚举转换回整数。
- en: Some enums use a different type, like byte or long (like the one below). You
    can cast those to their type instead of int.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有些枚举使用不同类型，如byte或long（像下面这个）。你可以将它们转换为它们的类型，而不是int。
- en: 'Here’s an excerpt from a method that uses the `TrickScore` enum by casting
    it to and from an int value:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用`TrickScore`枚举的方法片段的摘录，通过将其转换为和从整数值中：
- en: '![Images](assets/408fig02.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/408fig02.png)'
- en: 'You can cast the enum as a number and do calculations with it. You can even
    convert it to a string—an enum’s ToString method returns a string with the member
    name:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将枚举转换为数字并进行计算。你甚至可以将其转换为字符串——枚举的`ToString`方法会返回带有成员名称的字符串：
- en: '![Images](assets/408fig03.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/408fig03.png)'
- en: 'If you don’t assign any number to a name, the items in the list will be given
    values by default. The first item will be assigned a 0 value, the second a 1,
    etc. But what happens if you want to use really big numbers for one of the enumerators?
    The default type for the numbers in an enum is int, so you’ll need to specify
    the type you need using the colon (:) operator, like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有为名称分配任何数字，列表中的项目将默认分配值。第一个项目将被分配为0值，第二个为1值，依此类推。但如果你想为枚举器中的一个使用非常大的数字会发生什么？枚举中数字的默认类型是int，所以你需要使用冒号（:)）运算符指定你需要的类型，就像这样：
- en: '![Images](assets/408fig04.png)![Images](assets/408fig05.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/408fig04.png)![图片](assets/408fig05.png)'
- en: We could use an array to create a deck of cards...
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们可以使用数组来创建一副牌...
- en: 'What if you wanted to create a class to represent a deck of cards? It would
    need a way to keep track of every card in the deck, and it’d need to know what
    order they were in. A `Cards` array would do the trick—the top card in the deck
    would be at value 0, the next card at value 1, etc. Here’s a starting point—a
    Deck that starts out with a full deck of 52 cards:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想创建一个表示一副牌的类会怎样？它需要一种方法来跟踪牌组中的每张牌，并且需要知道它们的顺序。`Cards`数组会起作用——牌组中的顶部牌的值为0，下一张牌为1，依此类推。这是一个起点——一个初始带有完整52张牌的牌组：
- en: '![Images](assets/409fig10d.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/409fig10d.png)'
- en: '...but what if you wanted to do more?'
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '...但如果你想做更多呢？'
- en: 'Think of everything you might need to do with a deck of cards, though. If you’re
    playing a card game, you routinely need to change the order of the cards, and
    add and remove cards from the deck. You just can’t do that with an array very
    easily. For example, take another look at the AddWorker method from the Beehive
    Management System exercise in [#inheritance_your_objectapostrophes_famil](ch06.html#inheritance_your_objectapostrophes_famil):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你可能需要用一副牌做的所有事情。如果你玩一种纸牌游戏，你通常需要改变牌的顺序，并从牌组中添加和删除牌。但你用数组却很难做到这一点。例如，再看一下《蜜蜂管理系统》练习中的`AddWorker`方法：
- en: '![Images](assets/409fig10e.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/409fig10e.png)'
- en: You had to use Array.Resize to make the array longer, then add the worker to
    the end. That’s a lot of work.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须使用`Array.Resize`将数组长度调整长，然后将工作者添加到末尾。这是一项很大的工作。
- en: Arrays can be annoying to work with
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与数组一起工作可能会很麻烦
- en: An array is fine for storing a fixed list of values or references. Once you
    need to move array elements around, or add more elements than the array can hold,
    things start to get a little sticky. Here are a few ways that working with arrays
    can be troublesome.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于存储固定值或引用的数组来说，这没问题。一旦你需要移动数组元素或添加超出数组容量的元素，情况就开始变得有点棘手。以下是使用数组时可能会遇到的一些问题。
- en: Every array has a length. That length doesn’t change unless you resize the array,
    so you need to know the length to work with it. Let’s say you want to use an array
    to store Card references. If the number of references you want to store is less
    than the length of the array, you could use null references to keep some array
    elements empty.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数组都有一个长度。除非你重新调整数组的大小，否则该长度不会改变，因此你需要知道长度才能使用它。假设你想要使用数组来存储 Card 的引用。如果你想要存储的引用数量少于数组的长度，你可以使用空引用来保持某些数组元素为空。
- en: '![Images](assets/412fig01.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/412fig01.png)'
- en: You’d need to keep track of how many cards are being held in the array. You
    could add an int field—maybe you’d call it cardCount—that would hold the index
    of the last card in the array. So your three-card array would have a Length of
    7, but you’d set cardCount equal to 3.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要跟踪数组中保存的卡片数量。你可以添加一个 int 字段 —— 也许你会称之为 cardCount，用来保存数组中最后一张卡片的索引。因此，你的三张卡片数组长度为
    7，但你会将 cardCount 设置为 3。
- en: '![Images](assets/412fig02.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/412fig02.png)'
- en: Now things get complicated. It’s easy enough to add a Peek method that just
    returns a reference to the top card, so you can peek at the top of the deck. What
    if you want to add a card? If cardCount is less than the array’s Length, you can
    just put your card in the array at that index and add 1 to cardCount. But if the
    array is full, you’ll need to create a new, bigger array and copy the existing
    cards to it. Removing a card is easy enough—but after you subtract 1 from cardCount,
    you’ll need to make sure to set the removed card’s array index back to `null`.
    What if you need to remove a card **from the middle of the list**? If you remove
    card 4, you’ll need to move card 5 back to replace it, and then move 6 back, then
    7...wow, what a mess!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在情况变得复杂了。添加一个 Peek 方法很容易，它只返回卡堆顶的引用，这样你就可以查看卡堆顶部了。如果你想添加一张卡片怎么办？如果 cardCount
    小于数组的长度，你可以把卡片放在该索引处，并将 cardCount 加 1。但如果数组已满，你就需要创建一个新的更大的数组，并将现有的卡片复制到新数组中。移除一张卡片很简单
    —— 但在从 cardCount 中减去 1 之后，你需要确保将移除的卡片的数组索引设为 `null`。如果你需要从列表中间移除一张卡片怎么办？如果你移除卡片
    4，你需要将卡片 5 移回来替换它，然后移动 6，再移动 7...哇，这多么混乱啊！
- en: Note
  id: totrans-57
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The AddWorker method from [#inheritance_your_objectapostrophes_famil](ch06.html#inheritance_your_objectapostrophes_famil)
    used the Array. Resize method to do this.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[#inheritance_your_objectapostrophes_famil](ch06.html#inheritance_your_objectapostrophes_famil)
    中的 AddWorker 方法使用了 Array.Resize 方法来执行此操作。'
- en: Lists make it easy to store collections of...anything
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表使得存储任何类型的集合变得容易
- en: C# and .NET have **collection** classes that handle all of those nasty issues
    that come up when you add and remove array elements. The most common sort of collection
    is a List<T>. Once you create a List<T> object, it’s easy to add an item, remove
    an item from any location in the list, peek at an item, and even move an item
    from one place in the list to another. Here’s how a list works.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: C# 和 .NET 拥有处理添加和移除数组元素时遇到的所有棘手问题的 **集合** 类。最常见的集合类型是 List<T>。一旦创建了 List<T>
    对象，就可以轻松地添加项目、从列表中任何位置移除项目、查看项目，甚至将项目从列表中的一个位置移动到另一个位置。以下是列表的工作原理。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We’ll sometimes leave the <T> off when referring to List in the book. When you
    see List, think List<T>.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们有时会在提到 List 时省略 <T>。当你看到 List 时，请想到 List<T>。
- en: '**First you create a new instance of List<T>.** Recall that every array has
    a type—you don’t just have an array, you have an int array, a Card array, etc.
    Lists are the same. You need to specify the type of object or value that the list
    will hold by putting it in angle brackets (<>) when you use the `new` keyword
    to create it:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**首先创建一个新的 List<T> 实例。** 请记住，每个数组都有一个类型 —— 你不只是有一个数组，你有一个 int 数组、一个 Card 数组等等。列表也是如此。当你使用
    `new` 关键字创建它时，你需要在尖括号（<>）中指定列表将要保存的对象或值的类型：'
- en: '[PRE5]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![Images](assets/413fig01.png)'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/413fig01.png)'
- en: '**Now you can add to your List<T>.** Once you’ve got a `List<T>` object, you
    can add as many items to it as you want as long as they’re ***polymorphic*** with
    whatever type you specified when you created your new List<T>—which means they’re
    assignable to the type (and that includes interfaces, abstract classes, and base
    classes).'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**现在您可以添加到您的 List<T> 中。** 一旦您有一个 List<T> 对象，只要这些对象与您创建 List<T> 时指定的类型*多态*，就可以添加任意数量的项目到其中——这意味着它们可以分配给该类型（包括接口、抽象类和基类）。'
- en: '[PRE6]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![Images](assets/413fig02.png)'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/413fig02.png)'
- en: Lists are more flexible than arrays
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表比数组更灵活
- en: The List class is built into the .NET Framework, and it lets you do a lot of
    things with objects that you can’t do with a plain old array. Check out some of
    the things you can do with a List<T>.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: List 类内置于 .NET Framework 中，它允许您执行许多对象操作，这些操作是使用普通数组无法完成的。查看一些您可以使用 List<T> 完成的操作。
- en: '![Images](assets/414fig02.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/414fig02.png)'
- en: Let’s build an app to store shoes
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们构建一个存储鞋子的应用程序
- en: 'It’s time to see a List in action. Let’s build a .NET Core console app that
    prompts the user to add or remove shoes. Here’s an example of what it looks like
    to run the app, adding two shoes and then removing them:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是看看列表（List）如何运作的时候了。让我们构建一个 .NET Core 控制台应用程序，提示用户添加或移除鞋子。以下是运行应用程序的示例，添加两只鞋子，然后将它们移除：
- en: We’ll start with a Shoe class that stores the style and color for a shoe. Then
    we’ll create a class called ShoeCloset that stores the shoes in a List<Shoe>,
    with AddShoe and RemoveShoe methods that prompt the user to add or remove shoes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个 Shoe 类开始，用于存储鞋子的样式和颜色。然后我们将创建一个名为 ShoeCloset 的类，该类使用 List<Shoe> 存储鞋子，并具有
    AddShoe 和 RemoveShoe 方法，这些方法提示用户添加或移除鞋子。
- en: '***Do this!***'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '***一定要这样做！***'
- en: '**Add an enum for shoe style.** Some shoes are sneakers, others are sandals,
    so an enum makes sense:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加一个用于鞋子样式的枚举。** 一些鞋子是运动鞋，其他的是凉鞋，所以枚举是有意义的：'
- en: '![Images](assets/p417fig001.png)'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/p417fig001.png)'
- en: '**Add the Shoe class.** It uses the `Style` enum for the shoe style and a string
    for shoe color, and works just like the Card class we created earlier in the chapter:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加 Shoe 类。** 它使用 Style 枚举表示鞋子样式和一个字符串表示鞋子颜色，其工作方式与我们之前在本章创建的 Card 类相似：'
- en: '[PRE7]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Images](assets/417fig01.png)'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/417fig01.png)'
- en: '[PRE8]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![Images](assets/417fig02.png)'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/417fig02.png)'
- en: '[PRE9]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Press ‘a’ to add a shoe, then choose the type of shoe and type in the color.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按‘a’键添加鞋子，然后选择鞋子类型并输入颜色。
- en: '[PRE10]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Press ‘r’ to remove a shoe, then enter the number of the shoe to remove.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按‘r’键移除鞋子，然后输入要移除的鞋子编号。
- en: '[PRE11]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![Images](assets/417fig03.png)'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/417fig03.png)'
- en: '**The ShoeCloset class uses a List<Shoe> to manage its shoes.** The ShoeCloset
    class has three methods—the PrintShoes method prints a list of shoes to the console,
    the AddShoe method prompts the user to add a shoe to the closet, and the RemoveShoe
    method prompts the user to remove a shoe:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ShoeCloset 类使用 List<Shoe> 来管理其鞋子。** ShoeCloset 类有三个方法——PrintShoes 方法将鞋子列表打印到控制台，AddShoe
    方法提示用户向衣柜添加鞋子，RemoveShoe 方法提示用户移除鞋子：'
- en: '![Images](assets/418fig01.png)'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/418fig01.png)'
- en: '**Add the Program class with the entry point.** Notice how it doesn’t do very
    much? That’s because all of the interesting behavior is encapsulated in the ShoeCloset
    class:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加具有入口点的 Program 类。** 注意它并没有做很多事情？这是因为所有有趣的行为都封装在 ShoeCloset 类中：'
- en: '![Images](assets/419fig01.png)'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/419fig01.png)'
- en: '**Run your app and reproduce the sample output.** Try debugging the app, and
    start to get familiar with how you work with lists. No need to memorize anything
    right now—you’ll get plenty of practice with them!'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行您的应用程序并重现示例输出。** 尝试调试应用程序，并开始熟悉如何使用列表。现在无需记住任何东西——您将有足够的练习！'
- en: Generic collections can store any type
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用集合可以存储任何类型
- en: 'You’ve already seen that a list can store strings or Shoes. You could also
    make lists of integers or any other object you can create. That makes a list a
    **generic collection**. When you create a new list object, you tie it to a specific
    type: you can have a list of ints, or strings, or Shoe objects. That makes working
    with lists easy—once you’ve created your list, you always know the type of data
    that’s inside it.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到列表可以存储字符串或鞋子。您还可以创建整数或任何其他对象的列表。这使得列表成为**通用集合**。创建新的列表对象时，将其绑定到特定类型：可以有整数列表、字符串列表或鞋子对象列表。这样可以轻松使用列表——一旦创建了列表，就始终知道其中的数据类型。
- en: 'But what does “generic” really mean? Let’s use Visual Studio to explore generic
    collections. Open *ShoeCloset.cs* and hover your mouse cursor over `List`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 但是“泛型”到底意味着什么？让我们使用 Visual Studio 探索泛型集合。打开 *ShoeCloset.cs* 并将鼠标悬停在 `List` 上：
- en: '![Images](assets/pg420-01a.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg420-01a.png)'
- en: '**A generic collection can hold any type of object, and gives you a consistent
    set of methods to work with the objects in the collection no matter what type
    of object it’s holding.**'
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**泛型集合可以容纳任何类型的对象，并且提供一致的一组方法来处理集合中的对象，无论它持有什么类型的对象。**'
- en: 'There are a few things to notice:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有几点需要注意：
- en: The List class is in the namespace System.Collections.Generic—this namespace
    has several classes for generic collections (which is why you needed the `using`
    line).
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: List 类位于命名空间 System.Collections.Generic——这个命名空间中有几个泛型集合类（这就是为什么你需要那个 `using`
    行）。
- en: The description says that List provides “methods to search, sort, and manipulate
    lists.” You used some of these methods in your ShoeCloset class.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述中说 List 提供了“搜索、排序和操作列表的方法”。你在 ShoeCloset 类中使用了其中一些方法。
- en: The top line says `List<T>` and the bottom says `T is Shoe`. This is how generics
    are defined—it’s saying that List can handle any type, but for this specific list
    that type is the Shoe class.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最上面一行说 `List<T>`，最下面一行说 `T is Shoe`。这就是泛型的定义方式——它表明 List 可以处理任何类型，但对于这个特定的列表，该类型是
    Shoe 类。
- en: Generic lists are declared using <angle brackets>
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型列表使用 <尖括号> 来声明。
- en: When you declare a list—no matter what type it holds—you always declare it the
    same way, using <angle brackets> to specify the type of object being stored in
    the list.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当你声明一个列表时——不管它保存什么类型的对象——你总是以相同的方式声明它，使用 <尖括号> 来指定列表中存储的对象类型。
- en: 'You’ll often see generic classes (not just List) written like this: List<T>.
    That’s how you know the class can take any type.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会看到泛型类（不仅仅是 List）这样写：List<T>。这样你就知道这个类可以接受任何类型。
- en: '![Images](assets/pg420-01.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg420-01.png)'
- en: Collection initializers are similar to object initializers
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合初始化器类似于对象初始化器。
- en: C# gives you a nice bit of shorthand to cut down on typing when you need to
    create a list and immediately add a bunch of items to it. When you create a new
    List object, you can use a **collection initializer** to give it a starting list
    of items. It’ll add them as soon as the list is created.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要创建列表并立即添加多个项目时，**C#** 提供了一种简便的快捷方式以减少输入量。当你创建一个新的 List 对象时，可以使用**集合初始化器**来提供初始的项目列表。它会在列表创建后立即添加这些项目。
- en: '![Images](assets/426fig01.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/426fig01.png)'
- en: '**A collection initializer makes your code more compact by letting you combine
    creating a list with adding an initial set of items.**'
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**集合初始化器通过允许你同时创建列表并添加初始项目，使得你的代码更加紧凑。**'
- en: Let’s create a List of Ducks
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们创建一个 Duck 列表。
- en: '***Do this!***'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '***就这样！***'
- en: Here’s a Duck class that keeps track of your many neighborhood ducks. (You *do*
    collect ducks, don’t you?) **Create a new Console App project** and add a new
    Duck class and KindOfDuck enum.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个 Duck 类，用于跟踪你的许多邻里鸭子。（你*确实*收集鸭子，对吧？） **创建一个新的控制台应用项目** 并添加一个新的 Duck 类和
    KindOfDuck 枚举。
- en: '![Images](assets/427fig01.png)![Images](assets/427fig02.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/427fig01.png)![图片](assets/427fig02.png)'
- en: Here’s the initializer for your List of Ducks
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这是你的 Duck 列表的初始化器。
- en: 'You’ve got six ducks, so you’ll create a List<Duck> that has a collection initializer
    with six statements. Each statement in the initializer creates a new Duck, using
    an object initializer to set each Duck object’s Size and Kind fields. Make sure
    this `**using directive**` is at the top of *Program.cs*:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你有六只鸭子，所以你会创建一个具有六个语句的 List<Duck>，每个语句在初始化器中创建一个新的 Duck，使用对象初始化器来设置每个 Duck 对象的
    Size 和 Kind 字段。确保这个 `**using directive**` 在 *Program.cs* 的顶部：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then **add this PrintDucks method** to your Program class:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将这个 **PrintDucks 方法添加到你的 Program 类中**：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, **add this code** to your Main method in *Program.cs* to create a
    List of Ducks and then print them:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 *Program.cs* 的 **Main** 方法中添加这段代码来创建一个 Duck 列表，然后打印它们：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Run your code—it will print a bunch of Ducks to the console.**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行你的代码——它将在控制台打印出一堆 Duck。**'
- en: Lists are easy, but SORTING can be tricky
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表很容易，但是排序可能有些棘手。
- en: It’s not hard to think about ways to sort numbers or letters. But how do you
    sort two individual objects, especially if they have multiple fields? In some
    cases you might want to order objects by the value in the Name field, while in
    other cases it might make sense to order objects based on height or date of birth.
    There are lots of ways you can order things, and lists support all of them.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 想要排序数字或字母并不难。但是如何对两个单独的对象进行排序，特别是它们有多个字段的情况下呢？在某些情况下，您可能希望按照“名称”字段的值对对象进行排序，而在其他情况下，可能根据“身高”或“出生日期”来排序对象才更合理。有很多种排序方法，而列表支持所有这些方法。
- en: '![Images](assets/428fig01.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/428fig01.png)'
- en: Lists know how to sort themselves
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表知道如何对自己进行排序
- en: Every List comes with a **Sort method** that rearranges all of the items in
    the list to put them in order. Lists already know how to sort most built-in types
    and classes, and it’s easy to teach them how to sort your own classes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 每个列表都有一个**排序方法**，可以重新排列列表中的所有项目，使它们按顺序排列。列表已经知道如何对大多数内置类型和类进行排序，并且可以轻松地教会它们如何对您自己的类进行排序。
- en: Note
  id: totrans-131
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Technically, it’s not the List<T> that knows how to sort itself. This is the
    job of an IComparer<T> object, which you’ll learn about in a minute.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，不是列表List<T>知道如何对自己进行排序。这是IComparer<T>对象的工作，您马上就会了解到它的工作原理。
- en: '![Images](assets/428fig02.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/428fig02.png)'
- en: IComparable<Duck> helps your List sort its Ducks
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IComparable<Duck>帮助列表排序它的鸭子
- en: If you have a List of numbers and call its Sort method, it will sort the list
    with the smallest numbers first and largest last. How does the List know which
    way to sort the Duck objects? We tell List.Sort that the Duck class can be sorted—and
    we do that the way we typically indicate that a class can do a certain job, *with
    an interface*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个数字列表并调用其排序方法，它将首先将最小的数字排序，然后是最大的。列表如何知道如何对鸭子对象进行排序呢？我们告诉列表(List.Sort)鸭子类可以进行排序——通常我们用接口*来表示一个类能够完成某个任务。
- en: '**You can make any class work with List’s built-in Sort method by having it
    implement IComparable<T> and adding a CompareTo method.**'
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**通过使其实现IComparable<T>并添加CompareTo方法，您可以使任何类与列表的内置排序方法配合使用。**'
- en: The List.Sort method knows how to sort any type or class that **implements the
    IComparable<T> interface**. That interface has just one member—a method called
    CompareTo. Sort uses an object’s CompareTo method to compare it with other objects,
    and uses its return value (an int) to determine which comes first.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: List.Sort方法知道如何对实现了IComparable<T>接口的任何类型或类进行排序。该接口只有一个成员——名为CompareTo的方法。Sort使用对象的CompareTo方法将其与其他对象进行比较，并使用其返回值（一个整数）来确定哪个对象排在前面。
- en: An object’s CompareTo method compares it to another object
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象的CompareTo方法将其与另一个对象进行比较
- en: One way to give our List object the ability to sort ducks is to **modify the
    Duck class to implement IComparable<Duck>** and add its only member, a CompareTo
    method that takes a Duck reference as a parameter.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的列表对象具有对鸭子进行排序的能力，一种方法是**修改鸭子类以实现IComparable<Duck>**并添加其唯一的成员，即接受鸭子引用作为参数的CompareTo方法。
- en: 'Update your project’s Duck class by implementing IComparable<Duck> so that
    it sorts itself based on duck size:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现IComparable<Duck>更新项目的鸭子类，以便根据鸭子的大小进行排序：
- en: '![Images](assets/429fig02.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/429fig02.png)'
- en: '**Add this line of code** to the end of your Main method just before the call
    to PrintDucks. This tells your list of ducks to sort itself. Now it sorts the
    ducks by size before printing them to the console:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**在调用PrintDucks之前的Main方法的最后添加这行代码**。这告诉您的鸭子列表对自己进行排序。现在它在将鸭子打印到控制台之前按大小对它们进行排序：'
- en: '![Images](assets/429fig01.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/429fig01.png)'
- en: Use IComparer to tell your List how to sort
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用IComparer告诉列表如何排序
- en: 'Your Duck class implements IComparable, so List.Sort knows how to sort a List
    of Duck objects. But what if you want to sort them in a different way than usual?
    Or what if you want to sort a type of object that doesn’t implement IComparable?
    Then you can pass a **comparer object** as an argument to List.Sort, to give it
    a different way to sort its objects. Notice how List.Sort is overloaded:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您的鸭子类实现了IComparable，所以List.Sort知道如何对鸭子对象列表进行排序。但是，如果您想以不同于通常方式的方式对它们进行排序怎么办？或者，如果您想对不实现IComparable的对象类型进行排序怎么办？那么您可以将一个**比较器对象**作为参数传递给List.Sort，以提供不同的排序方式。请注意List.Sort的重载方式：
- en: '![Images](assets/430fig01.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/430fig01.png)'
- en: 'There’s an overloaded version of List.Sort that **takes an IComparer<T> reference**,
    where T will be replaced by the generic type for your list (so for a List<Duck>
    it takes an IComparer<Duck> argument, for a List<string> it’s an IComparer<string>,
    etc.). You’ll pass it a reference to an object that implements an interface, and
    we know what that means: that it *does a specific job*. In this case, that job
    is comparing pairs of items in the list to tell List.Sort what order to sort them
    in.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: List.Sort 还有一个重载版本，**它接受一个 IComparer<T> 的引用**，其中 T 将被你列表的泛型类型替换（因此对于 List<Duck>，它接受一个
    IComparer<Duck> 参数，对于 List<string>，它是一个 IComparer<string>，等等）。你将传递一个实现接口的对象的引用，我们知道这意味着：它
    *完成特定的工作*。在这种情况下，这个工作是比较列表中项目对以告诉 List.Sort 如何排序它们的顺序。
- en: 'The IComparer<T> interface has one member, a **method called Compare**. It’s
    just like the CompareTo method in IComparable<T>: it takes two object parameters,
    `x` and `y`, and returns an a positive value if `x` comes before `y`, a negative
    value if `x` comes after `y`, or zero if they’re the same.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: IComparer<T> 接口只有一个成员，一个名为 Compare 的方法。它与 IComparable<T> 中的 CompareTo 方法完全相同：它接受两个对象参数
    `x` 和 `y`，如果 `x` 在 `y` 之前则返回正值，如果 `x` 在 `y` 之后则返回负值，如果它们相同则返回零。
- en: Add an IComparer to your project
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向你的项目中添加一个 IComparer
- en: '**Add the DuckComparerBySize class to your project**. It’s a comparer object
    that you can pass as a parameter to List.Sort to make it sort your ducks by size.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**将 DuckComparerBySize 类添加到你的项目中**。它是一个比较器对象，你可以将其作为参数传递给 List.Sort，以使其按大小排序你的鸭子。'
- en: 'The IComparer interface is in the System.Collections.Generic namespace, so
    if you’re adding this class to a new file make sure it has the right `using` directive:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: IComparer 接口位于 System.Collections.Generic 命名空间中，因此如果你将此类添加到新文件中，请确保它有正确的 `using`
    指令：
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here’s the code for the comparer class:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是比较器类的代码：
- en: '![Images](assets/430fig02.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/430fig02.png)'
- en: Note
  id: totrans-155
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Can you figure out how to modify DuckComparerBySize so it sorts the ducks
    largest to smallest instead?**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**你能想出如何修改 DuckComparerBySize 使其按从大到小排序鸭子吗？**'
- en: Note
  id: totrans-157
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**A comparer object is an instance of a class that implements IComparer<T>
    that you can pass as a reference to List.Sort. Its Compare method works just like
    the ComapreTo method in the IComparable<T> interface. When List.Sort compares
    its elements to sort them, it passes pairs of objects to the Compare method in
    your comparer object, so your List will sort differently depending on how you
    implement the comparer.**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**比较器对象是一个类的实例，该类实现了 IComparer<T>，你可以将其作为引用传递给 List.Sort。它的 Compare 方法的工作方式与
    IComparable<T> 接口中的 CompareTo 方法完全相同。当 List.Sort 比较其元素以对其进行排序时，它将一对对象传递给你的比较器对象的
    Compare 方法，因此你的列表将根据你实现的比较器不同而不同排序。**'
- en: Create an instance of your comparer object
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的比较器对象的一个实例
- en: 'When you want to sort using IComparer<T>, you need to create a new instance
    of the class that implements it—in this case, Duck. That’s the comparer object
    that will help List.Sort figure out how to sort its elements. Like any other (nonstatic)
    class, you need to instantiate it before you use it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想使用 IComparer<T> 进行排序时，你需要创建一个实现它的类的新实例——在本例中是 Duck。这就是比较器对象，它将帮助 List.Sort
    弄清楚如何对其元素进行排序。与任何其他（非静态）类一样，在使用之前你需要实例化它：
- en: '![Images](assets/431fig01.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/431fig01.png)'
- en: Multiple IComparer implementations, multiple ways to sort your objects
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个 IComparer 实现，多种排序对象的方式
- en: 'You can create multiple IComparer<Duck> classes with different sorting logic
    to sort the ducks in different ways. Then you can use the comparer you want when
    you need to sort in that particular way. Here’s another duck comparer implementation
    to add to your project:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建多个具有不同排序逻辑的 IComparer<Duck> 类来以不同方式排序鸭子。然后，当你需要以特定方式排序时，你可以使用你想要的比较器。这里是另一个添加到你的项目中的鸭子比较器实现：
- en: '![Images](assets/431fig02.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/431fig02.png)'
- en: Go back and modify your program to use this new comparer. Now it sorts the ducks
    by kind before it prints them.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 返回并修改你的程序，使用这个新的比较器。现在它在打印之前按种类对鸭子进行排序。
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Comparers can do complex comparisons
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较器可以进行复杂的比较
- en: One advantage to creating a separate class for sorting your ducks is that you
    can build more complex logic into that class—and you can add members that help
    determine how the list gets sorted.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的鸭子创建一个单独的排序类的一个优势是，你可以在该类中构建更复杂的逻辑，并且你可以添加帮助确定列表排序方式的成员。
- en: '![Images](assets/432fig01.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/432fig01.png)'
- en: Overriding a ToString method lets an object describe itself
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重写 ToString 方法让对象描述自己
- en: Every object has a **method called ToString that converts it to a string**.
    You’ve already used it—any time you use `{curly braces}` in string interpolation
    that calls the ToString method of whatever’s inside them—and the IDE also takes
    advantage of it. When you create a class, it inherits the ToString method from
    Object, the top-level base class that all other classes extend.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都有一个叫做 ToString 的**方法，将它转换为字符串**。你已经用过它了—任何时候你在字符串插值中使用 `{花括号}`，它都会调用花括号内部的
    ToString 方法—而且 IDE 也会利用它。当你创建一个类时，它会继承自 Object 的 ToString 方法，Object 是所有其他类扩展的顶级基类。
- en: 'The Object.ToString method prints the **fully qualified class name**, or the
    namespace followed by a period followed by the class name. Since we used the namespace
    DucksProject when we were writing this chapter, the fully qualified class name
    for our Duck class is DucksProject.Duck:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Object.ToString 方法打印**完全限定的类名**，或者命名空间后跟一个句点再跟类名。由于在编写本章时我们使用了命名空间 DucksProject，我们的
    Duck 类的完全限定类名是 DucksProject.Duck：
- en: '![Images](assets/435fig001.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/435fig001.png)'
- en: 'The IDE also calls the ToString method—for example, when you watch or inspect
    a variable:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: IDE 也会调用 ToString 方法—例如，当你查看或检查一个变量时：
- en: '![Images](assets/435fig01.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/435fig01.png)'
- en: Hmm, that’s not as useful as we’d hoped. You can see that there are six Duck
    objects in the list. If you expand a Duck, you can see its Kind and Size values.
    Wouldn’t it be easier if you could see all of them at once?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这并不像我们希望的那样有用。你可以看到列表中有六个 Duck 对象。如果你展开一个 Duck，你可以看到它的 Kind 和 Size 值。如果你一次能看到所有这些对象，那不是更方便吗？
- en: Override the ToString method to see your Ducks in the IDE
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖 ToString 方法以在 IDE 中查看你的 Duck 对象
- en: 'Luckily, ToString is a virtual method of Object, the base class of every object.
    So all you need to do is **override the ToString** **method**—and when you do,
    you’ll see the results immediately in the IDE’s Watch window! Open up your Duck
    class and start adding a new method by typing `**override**`. As soon as you add
    a space, the IDE will show you the methods you can override:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，ToString 是 Object 的虚方法，是每个对象的基类。所以你只需要**重写 ToString 方法**—当你这样做时，你会立即在 IDE
    的 Watch 窗口中看到结果！打开你的 Duck 类，并开始通过输入 `**override**` 来添加一个新方法。一旦你加入一个空格，IDE 将会显示你可以重写的方法：
- en: '![Images](assets/435fig02.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/435fig02.png)'
- en: '**Click on ToString()** to tell the IDE to add a new ToString method. Replace
    the contents so it looks like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**点击 ToString()** 告诉 IDE 添加一个新的 ToString 方法。替换内容使其看起来像这样：'
- en: '[PRE17]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Run your program and look at the list again. Now the IDE shows you the contents
    of your Duck objects.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的程序并再次查看列表。现在 IDE 会显示 Duck 对象的内容。
- en: '![Images](assets/435fig03.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/435fig03.png)'
- en: Update your foreach loops to let your Ducks and Cards write themselves to the
    console
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新你的 foreach 循环，让你的 Duck 和 Card 对象自己写入控制台
- en: 'You’ve seen two different examples of programs looping through a list of objects
    and calling Console.WriteLine to print a line to the console for each object—like
    this foreach loop that prints every Card in a List<Card>:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到两个不同的程序示例，它们循环遍历对象列表，并调用 Console.WriteLine 来打印列表中每个对象的内容—就像这个 foreach 循环一样，它会打印
    List<Card> 中的每个 Card：
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The PrintDucks method did something similar for Duck objects in a List:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: PrintDucks 方法对 List 中的 Duck 对象做了类似的事情：
- en: '[PRE19]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is a pretty common thing to do with objects. Now that your Duck has a
    ToString method, your PrintDucks method should take advantage of it. Use the IDE’s
    IntelliSense to look through the overloads for the Console.WriteLine method—specifically
    this one:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对对象的一个非常常见的操作。现在你的 Duck 有了一个 ToString 方法，你的 PrintDucks 方法应该利用它。使用 IDE 的 IntelliSense
    来浏览 Console.WriteLine 方法的重载—特别是这一个：
- en: '![Images](assets/436fig01.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/436fig01.png)'
- en: 'You can pass any object to Console.WriteLine, and it will call its ToString
    method. So you can replace the PrintDucks method with one that calls this overload:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将任何对象传递给 Console.WriteLine，它会调用它的 ToString 方法。所以你可以用调用这个重载的方法来替换 PrintDucks
    方法：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Replace the PrintDucks method** with this one and run your code again. It
    prints the same output. If you want to add, say, a Color or Weight property to
    your Duck object, you just have to update the ToString method, and everything
    that uses it (including the PrintDucks method) will reflect that change.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**用这个方法替换 PrintDucks 方法**，然后再次运行你的代码。它将打印相同的输出。如果你想要为你的 Duck 对象添加比如 Color 或者
    Weight 属性，你只需要更新 ToString 方法，一切使用它的地方（包括 PrintDucks 方法）都将反映这些变更。'
- en: Add a ToString method to your Card object, too
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 也为你的 Card 对象添加一个 ToString 方法
- en: 'Your Card object already has a Name property that returns the name of the card:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 Card 对象已经有一个返回卡片名称的 Name 属性：
- en: '[PRE21]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'That’s exactly what its ToString method should do. So, add a ToString method
    to the Card class:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是它的 ToString 方法应该做的事情。所以，在 Card 类中添加一个 ToString 方法：
- en: '[PRE22]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-199
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注：
- en: '**We decided to make the ToString method call the Name property. Do you think
    we made the right choice? Would it have been better to delete the Name property
    and move its code to the ToString method? When you’re going back to modify your
    code, you have to make choices like this—and it’s not always obvious which choice
    is best.**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们决定让 ToString 方法调用 Name 属性。你认为我们做对了吗？删除 Name 属性并将其代码移到 ToString 方法中会更好吗？当你回头修改代码时，你必须做出这样的选择
    —— 并不总是明显哪个选择最好。**'
- en: Now your programs that use Card objects will be easier to debug.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 Card 对象的程序将更容易调试。
- en: You can upcast an entire list using IEnumerable<T>
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你可以使用 IEnumerable<T> 向上转型整个列表。
- en: Remember how you can upcast any object to its superclass? Well, when you’ve
    got a List of objects, you can upcast the entire list at once. It’s called **covariance**,
    and all you need for it is an IEnumerable<T> interface reference.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 记得你可以将任何对象向上转型为其超类吗？嗯，当你有一个对象列表时，你可以一次性将整个列表向上转型。这就叫做**协变**，你只需要一个 IEnumerable<T>
    接口的引用。
- en: Let’s see how this works. We’ll start with the Duck class that you’ve been working
    with throughout the chapter. Then we’ll add a Bird class that it will extend.
    The Bird class will include a static method that iterates over a collection of
    Bird objects. Can we get it to work with a List of Ducks?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何运作的。我们将从本章一直使用的 Duck 类开始。然后我们将添加一个它将扩展的 Bird 类。Bird 类将包括一个静态方法，用于迭代
    Bird 对象的集合。我们能够让它与 Duck 的 List 一起工作吗？
- en: '![Images](assets/440fig01.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/440fig01.png)'
- en: '**Since all Ducks are Birds, covariance lets us convert a collection of Ducks
    to a collection of Birds. That can be really useful if you have to pass a List<Duck>
    to a method that only accepts a List<Bird>.**'
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**由于所有的 Duck 都是 Bird，协变允许我们将 Duck 集合转换为 Bird 集合。如果你必须将 List<Duck> 传递给只接受 List<Bird>
    的方法，这将非常有用。**'
- en: '***Do this!***'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '***去做这件事！***'
- en: '**Create a new Console App project.** Add a base class, Bird (for Duck to extend),
    and a Penguin class. We’ll use the ToString method to make it easy to see which
    class is which.'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个新的控制台应用程序项目。** 添加一个基类 Bird（用于 Duck 扩展）和一个 Penguin 类。我们将使用 ToString 方法来轻松查看每个类的区别。'
- en: '![Images](assets/440fig02.png)'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/440fig02.png)'
- en: '**Add your Duck class to the application.** Modify its declaration to **make
    it extend Bird**. You’ll also need to **add the KindOfDuck enum** from earlier
    in the chapter:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将你的 Duck 类添加到应用程序中。** 修改它的声明**使其扩展 Bird**。你还需要**添加此章节前面的 KindOfDuck 枚举**：'
- en: '![Images](assets/441fig001.png)'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/441fig001.png)'
- en: '**Create the List<Duck> collection.** Go ahead and **add this code to your
    Main method**—it’s the code from earlier in the chapter, plus one line to upcast
    it to a List<Bird>:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建 List<Duck> 集合。** 请继续在你的 Main 方法中**添加这段代码** ——它是本章前面的代码，再加上一行将其向上转型为 List<Bird>：'
- en: '![Images](assets/441fig002.png)'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/441fig002.png)'
- en: 'Uh-oh—that code won’t compile. The error message is telling you that you can’t
    convert your Duck collection to a Bird collection. Let’s try assigning `ducks`
    to a List<Bird>:'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 啊哦 —— 那段代码编译不通过。错误信息告诉你不能将 Duck 集合转换为 Bird 集合。让我们尝试将 `ducks` 赋值给一个 List<Bird>：
- en: '![Images](assets/441fig02.png)'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/441fig02.png)'
- en: 'Well, that didn’t work. We got a different error, but it still says we can’t
    convert the type:'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 哎呀，这没用。我们得到了一个不同的错误，但它仍然说我们无法转换类型：
- en: '![Images](assets/441fig03.png)'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/441fig03.png)'
- en: 'Which makes sense—it’s exactly like safely upcasting versus downcasting, which
    you learned about in [#inheritance_your_objectapostrophes_famil](ch06.html#inheritance_your_objectapostrophes_famil):
    we can use assignment to downcast, but we need to use the `is` keyword to safely
    upcast. So how do we safely upcast our List<Duck> to a List<Bird>?'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是有道理的 —— 这就像安全向上转型与向下转型一样，你在 [#inheritance_your_objectapostrophes_famil](ch06.html#inheritance_your_objectapostrophes_famil)
    中学到的：我们可以使用赋值运算符来进行向下转型，但我们需要使用 `is` 关键字来安全地向上转型。那么我们如何安全地将 List<Duck> 向上转型为 List<Bird>？
- en: '**Use covariance to make your ducks fly away.** That’s where **covariance**
    comes in: you can ***use assignment to upcast your List<Duck> to an IEnumerable<Bird>***.
    Once you’ve got your IEnumerable<Bird>, you can call its ToList method to convert
    it to a List<Bird>. You’ll need to add using using `System.Collections.Generic`;
    and using `System.Linq`; to the top of the file:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用协变让你的鸭子飞走。** 这就是**协变**的作用：你可以***使用赋值将你的List<Duck>向上转型为IEnumerable<Bird>***。一旦你得到了你的IEnumerable<Bird>，你可以调用它的ToList方法将其转换为List<Bird>。你需要在文件顶部添加using
    `System.Collections.Generic`; 和 using `System.Linq`;：'
- en: '![Images](assets/441fig003.png)'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/441fig003.png)'
- en: Use a Dictionary to store keys and values
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用字典来存储键和值
- en: 'A list is like a big long page full of names. What if you also want, for each
    name, an address? Or for every car in the `garage` list, you want details about
    that car? You need another kind of .NET collection: a **dictionary**. A dictionary
    lets you take a special value—the **key**—and associate that key with a bunch
    of data—the **value**. One more thing: a specific key can **only appear once**
    in any dictionary.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 列表就像一个长长的页面，上面写满了名字。如果你还想要，对于每个名字，一个地址呢？或者对于`garage`列表中的每辆车，你想要关于那辆车的详细信息？你需要另一种.NET集合：一个**字典**。字典让你取一个特殊的值——**键**——并将该键与一堆数据——**值**——关联起来。还有一件事：一个特定的键在任何字典中**只能出现一次**。
- en: '![Images](assets/442fig01.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/442fig01.png)'
- en: 'Here’s how you declare a .NET Dictionary in C#:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何在C#中声明.NET字典：
- en: '![Images](assets/442fig02.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/442fig02.png)'
- en: 'Let’s see a dictionary in action. Here’s a small console app that uses a Dictionary<string,
    string> to keep track of the favorite foods of a few friends:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看字典的实际应用。这是一个小型控制台应用程序，使用Dictionary<string, string>来跟踪几个朋友的最喜爱的食物：
- en: '![Images](assets/442fig03.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/442fig03.png)'
- en: The Dictionary functionality rundown
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典功能概述
- en: Dictionaries are a lot like lists. Both types are flexible in letting you work
    with lots of data types, and also come with lots of built-in functionality. Here
    are the basic things you can do with a dictionary.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 字典和列表很像。这两种类型都灵活地让你处理许多数据类型，并且都带有许多内置功能。以下是你可以用字典做的基本事情。
- en: '**Add an item.**'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加一个项目。**'
- en: 'You can add an item to a dictionary using its **indexer** with square brackets:'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以使用方括号的**索引器**向字典中添加一个项目：
- en: '[PRE23]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can also add an item to a dictionary using its **Add method:**
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以使用**Add方法**向字典中添加一个项目：
- en: '[PRE24]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Look up a value using its key.**'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用键查找值。**'
- en: 'The most important thing you’ll do with a dictionary is **look up values with
    the indexer**—which makes sense, because you stored those values in a dictionary
    so you could look them up using their unique keys. This example shows a Dictionary<string,
    string>, so we’ll look up values using a string key, and the dictionary returns
    a string value:'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将使用字典中最重要的功能是**使用索引器查找值**——这是有道理的，因为你将这些值存储在字典中，以便使用它们的唯一键查找它们。这个例子展示了一个Dictionary<string,
    string>，所以我们将使用一个字符串键查找值，并且字典返回一个字符串值：
- en: '[PRE25]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Remove an item.**'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移除一个项目。**'
- en: 'Just like with a list, you can remove an item from a dictionary using the **Remove
    method**. All you need to pass to the Remove method is the key value to have both
    the key and the value removed:'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就像列表一样，你可以使用**Remove方法**从字典中移除一个项目。你只需要传递给Remove方法的是要移除的键值：
- en: '[PRE26]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Get a list of keys.**'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取键的列表。**'
- en: 'You can get a list of all of the keys in a dictionary using its **Keys property**
    and loop through it using a `foreach` loop. Here’s what that would look like:'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以通过其**Keys属性**获取字典中所有键的列表，并使用`foreach`循环遍历它。下面是这样做的样子：
- en: '[PRE27]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Keys is a property of your Dictionary object. This particular dictionary has
    string keys, so Keys is a collection of strings.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Keys是你的字典对象的一个属性。这个特定的字典有字符串键，所以Keys是一个字符串集合。
- en: '**Count the pairs in the dictionary.**'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算字典中的对数。**'
- en: 'The **Count property** returns the number of key/value pairs that are in the
    dictionary:'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Count属性**返回字典中键/值对的数量：'
- en: '[PRE28]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-249
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Keys are unique in a dictionary; any key appears exactly once. Values can appear
    any number of times—two keys can have the same value. That way, when you look
    up or remove a key, the dictionary knows what to remove.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 键在字典中是唯一的；任何键只出现一次。值可以出现任意次数——两个键可以有相同的值。这样，当你查找或移除一个键时，字典知道要移除什么。
- en: Your key and value can be different types
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你的键和值可以是不同类型的
- en: 'Dictionaries are versatile! They can hold just about anything, not just value
    types but ***any kind of object***. Here’s an example of a dictionary that’s storing
    an integer as a key and a Duck object reference as a value:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 字典非常灵活！它们可以容纳几乎任何东西，不仅仅是值类型，而是***任何类型的对象***。这里有一个存储整数作为键和Duck对象引用作为值的字典的示例：
- en: '[PRE29]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-254
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It’s common to see a dictionary that maps integers to objects when you’re assigning
    unique ID numbers to objects.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当您为对象分配唯一的ID号码时，看到一个将整数映射到对象的字典是很常见的。
- en: Build a program that uses a dictionary
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个使用字典的程序
- en: 'Here’s a quick app that New York Yankees baseball fans will like. When an important
    player retires, the team retires the player’s jersey number. **Create a new console
    app** that looks up some Yankees who wore famous numbers and when those numbers
    were retired. Here’s a class to keep track of a retired baseball player:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个快速应用程序，纽约洋基棒球迷会喜欢的。当一名重要球员退役时，球队会退役球员的球衣号码。**创建一个新的控制台应用程序**，查找一些穿过著名号码的洋基球员以及这些号码何时被退役。这里有一个类来跟踪退役的棒球球员：
- en: '***Do this!***'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '***做这个！***'
- en: '[PRE30]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And here’s the Program class with a Main method that adds retired players to
    a dictionary. We can use the jersey number as the dictionary key because it’s
    **unique**—once a jersey number is retired, the team ***never uses it again***.
    That’s an important thing to consider when designing an app that uses a dictionary:
    you never want to discover your key is not as unique as you thought!'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个带有Main方法的Program类，将退役球员添加到字典中。我们可以使用球衣号码作为字典的键，因为它是**唯一的**——一旦球衣号码被退役，球队***永远不会再使用它***。这在设计使用字典的应用程序时是需要考虑的重要事项：您绝不希望发现您的键并不像您想象的那样唯一！
- en: Note
  id: totrans-261
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Yogi Berra was #8 for the New York Yankees, while Cal Ripken Jr. was #8 for
    the Baltimore Orioles.But in a Dictionary, you can have duplicate values, but
    every key must be unique. Can you think of a way to store retired numbers for
    multiple teams?**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**约基·贝拉曾经是纽约洋基队的#8号球员，而卡尔·里普肯·朱尓是巴尔的摩金莺的#8号球员。但在字典中，您可以有重复的值，但每个键必须是唯一的。您能想到一种方法来存储多个球队的退役号码吗？**'
- en: '![Images](assets/444fig01.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/444fig01.png)'
- en: And yet MORE collection types...
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多的集合类型...
- en: List and Dictionary are two of the most frequently used collection types that
    are part of the .NET. Lists and dictionaries are very flexible—you can access
    any of the data in them in any order. But sometimes you’re using a collection
    to represent a bunch of things in the real world that need to be accessed in a
    specific order. You can restrict how your code accesses the data in a collection
    by using **a Queue or a Stack**. Those are generic collections like List<T>, but
    they’re especially good at making sure that your data is processed in a certain
    order.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 列表和字典是.NET中最常用的两种集合类型之一。列表和字典非常灵活——你可以以任意顺序访问它们中的任何数据。但有时你使用集合来表示现实世界中需要按特定顺序访问的一堆东西。您可以使用**队列或堆栈**来限制代码访问集合中的数据。它们是像List<T>一样的泛型集合，但特别擅长确保按照特定顺序处理数据。
- en: Note
  id: totrans-266
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There are other types of collections, too—but these are the ones that you’re
    most likely to come in contact with.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他类型的集合，但这些是你最有可能接触到的。
- en: '**Use a Queue when the first object you store will be the first one you’ll
    use, like with:**'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**当您存储的第一个对象将是您要使用的第一个对象时，请使用队列：**'
- en: Cars moving down a one-way street
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汽车沿单向街道行驶
- en: People standing in line
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排队等候的人
- en: Customers on hold for a customer service support line
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待客服支持电话的客户
- en: Anything else that’s handled on a first-come, first-served basis
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他任何按先来先服务处理的事物
- en: Note
  id: totrans-273
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A queue is first in, first out, which means that the first object that you put
    into the queue is the first one you pull out of it to use.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是先进先出的，这意味着您放入队列的第一个对象是您取出并使用的第一个对象。
- en: '**Use a Stack when you always want to use the object you stored most recently,
    like with:**'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**当您总是想使用最近存储的对象时，请使用堆栈：**'
- en: Furniture loaded into the back of a moving truck
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 家具装载到移动卡车的后面
- en: A stack of books where you want to read the most recently added one first
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个书堆，你希望先读最近添加的那本书
- en: People boarding or leaving a plane
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登机或离开飞机的人
- en: A pyramid of cheerleaders, where the ones on top have to dismount first...imagine
    the mess if the one on the bottom walked away first!
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一堆啦啦队员，顶上的人必须先下来...想象一下，如果底下的人先走了会是什么情况！
- en: Note
  id: totrans-280
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'A stack is last in, first out: the first object that goes into the stack is
    the last one that comes out of it.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**栈**是后进先出：进入栈的第一个对象是最后一个出栈的对象。'
- en: Generic .NET collections implement IEnumerable
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型.NET集合实现IEnumerable
- en: Almost every large project that you’ll work on will include some sort of generic
    collection, because your programs need to store data. When you’re dealing with
    groups of similar things in the real world, they almost always naturally fall
    into a category that corresponds pretty well to one of these kinds of collections.
    No matter which of these collection types you use—List, Dictionary, Stack, or
    Queue—you’ll always be able to use a foreach loop with them because all of them
    implement IEnumerable<T>.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个大型项目都会包含某种通用集合，因为程序需要存储数据。当您在现实世界中处理类似的事物组时，它们几乎总是自然地归类到与这些种类的集合相对应的一类中。无论您使用哪种集合类型——List、Dictionary、Stack或Queue，您总是可以使用foreach循环，因为它们都实现了IEnumerable<T>接口。
- en: '**A queue is like a list that lets you add objects to the end and use the ones
    at the beginning. A stack only lets you access the last object you put into it.**'
  id: totrans-284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**队列就像一个允许您将对象添加到末尾并使用位于开头的对象的列表。栈只允许您访问您放入其中的最后一个对象。**'
- en: Note
  id: totrans-285
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can, however, use foreach to enumerate through a stack or queue, because
    they implement **IEnumerable!**
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用foreach枚举堆栈或队列，因为它们实现了**IEnumerable!**
- en: A queue is FIFO—first in, first out
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列是 FIFO—先进先出
- en: A **queue** is a lot like a list, except that you can’t just add or remove items
    at any index. To add an object to a queue, you **enqueue** it. That adds the object
    to the end of the queue. You can **dequeue** the first object from the front of
    the queue. When you do that, the object is removed from the queue, and the rest
    of the objects in the queue move up a position.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**队列**很像列表，但不能随意在任何索引处添加或删除项目。要将对象添加到队列中，您需要进行**入队**操作。这将对象添加到队列的末尾。您可以从队列的前端**出队**第一个对象。这样做时，该对象从队列中移除，并且队列中其余对象向前移动一个位置。'
- en: '![Images](assets/446fig02.png)![Images](assets/446fig01.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/446fig02.png)![图片](assets/446fig01.png)'
- en: A stack is LIFO—last in, first out
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**栈**是 LIFO—后进先出'
- en: A **stack** is really similar to a queue—with one big difference. You **push**
    each item onto a stack, and when you want to take an item from the stack, you
    **pop** one off of it. When you pop an item off of a stack, you end up with the
    most recent item that you pushed onto it. It’s just like a stack of plates, magazines,
    or anything else—you can drop something onto the top of the stack, but you need
    to take it off before you can get to whatever’s underneath it.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**栈**与队列非常相似，但有一个很大的区别。您需要**推**每个项目到栈上，当您想从栈中取出一个项目时，您需要**弹**一个项目。当您从栈中弹出一个项目时，您得到的是最近推入栈中的项目。这就像一个叠盘子、杂志或任何其他东西的栈一样——您可以把东西放在栈的顶部，但在获取其下面的内容之前，您需要把它拿掉。'
- en: '![Images](assets/447fig01.png)![Images](assets/447fig02z.png)![Images](assets/447fig02.png)![Images](assets/448fig01.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/447fig01.png)![图片](assets/447fig02z.png)![图片](assets/447fig02.png)![图片](assets/448fig01.png)'
- en: '**You don’t give up anything when you use a queue or a stack.**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**当您使用队列或栈时，您并不会失去任何东西。**'
- en: It’s really easy to copy a Queue object to a List object. It’s just as easy
    to copy a List to a Queue, a Queue to a Stack...in fact, you can create a List,
    Queue, or Stack from any other object that implements the IEnumerable<T> interface.
    All you have to do is use the overloaded constructor that lets you pass the collection
    you want to copy from as a parameter. That means you have the flexibility and
    convenience of representing your data with the collection that best matches the
    way you need it to be used. (But remember, you’re making a copy, which means you’re
    creating a whole new object and adding it to the heap.)
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 将队列对象复制到列表对象非常容易。将列表复制到队列，队列复制到堆栈也同样容易……事实上，您可以从任何实现IEnumerable<T>接口的其他对象创建列表、队列或堆栈。您只需使用允许您将要从中复制的集合作为参数传递的重载构造函数。这意味着您可以灵活方便地使用最适合您需要的集合来表示数据。（但请记住，您正在进行复制，这意味着您正在创建一个全新的对象并将其添加到堆中。）
- en: '![Images](assets/448fig02.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/448fig02.png)'
