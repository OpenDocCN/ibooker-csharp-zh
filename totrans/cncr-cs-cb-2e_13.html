<html><head></head><body><section data-pdf-bookmark="Chapter 13. Scheduling" data-type="chapter" epub:type="chapter"><div class="chapter" id="scheduling">&#13;
<h1><span class="label">Chapter 13. </span>Scheduling</h1>&#13;
&#13;
&#13;
<p>When <a data-primary="schedulers" data-secondary="overview" data-type="indexterm" id="idm45458686268328"/>a piece of code executes, it has to run on some thread somewhere. A <em>scheduler</em> is an object that decides where a certain piece of code runs. There are a few different scheduler types in the .NET framework, and they’re used with slight differences by parallel and dataflow code.</p>&#13;
&#13;
<p>I <a data-primary="schedulers" data-secondary="when to use" data-type="indexterm" id="idm45458686265944"/><a data-primary="context" data-secondary="specifying" data-see="schedulers" data-type="indexterm" id="idm45458686264936"/>recommend that you <em>not</em> specify a scheduler whenever possible; the defaults are usually correct. For example, the <code>await</code> operator in asynchronous code will automatically resume the method within the same context unless you override this default, as described in <a data-type="xref" href="ch02.html#recipe-async-configureawait">Recipe 2.7</a>. Similarly, reactive code has reasonable default contexts for raising its events, which you can override with <code>ObserveOn</code>, as described in <a data-type="xref" href="ch06.html#recipe-rx-observeon">Recipe 6.2</a>.</p>&#13;
&#13;
<p>If you need other code to execute in a specific context (e.g., a UI thread context or an ASP.NET request context), then you can use the scheduling recipes in this chapter to control the scheduling of your code.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="13.1 Scheduling Work to the Thread Pool" data-type="sect1"><div class="sect1" id="recipe-threadpool">&#13;
<h1>13.1 Scheduling Work to the Thread Pool</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458686257880">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="schedulers" data-secondary="in asynchronous programming" data-secondary-sortas="asynchronous" data-type="indexterm" id="ch13r12a"/><a data-primary="asynchronous programming" data-secondary="schedulers" data-type="indexterm" id="ch13r12b"/><a data-primary="thread pool" data-secondary="scheduling work on" data-type="indexterm" id="ch13r1a"/>have a piece of code that you explicitly want to execute on a threadpool thread.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458686252200">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>The <a data-primary="Task.Run method" data-type="indexterm" id="ch13r1b"/>vast majority of the time, you’ll want to use <code>Task.Run</code>, which is quite simple. The following code blocks a threadpool thread for 2 seconds:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="n">Task</code> <code class="n">task</code> <code class="p">=</code> <code class="n">Task</code><code class="p">.</code><code class="n">Run</code><code class="p">(()</code> <code class="p">=&gt;</code>&#13;
<code class="p">{</code>&#13;
  <code class="n">Thread</code><code class="p">.</code><code class="n">Sleep</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">2</code><code class="p">));</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p><code>Task.Run</code> also understands return values and asynchronous lambdas just fine. The task returned by <code>Task.Run</code> in the following code will complete after 2 seconds with a result of 13:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">task</code> <code class="p">=</code> <code class="n">Task</code><code class="p">.</code><code class="n">Run</code><code class="p">(</code><code class="k">async</code> <code class="p">()</code> <code class="p">=&gt;</code>&#13;
<code class="p">{</code>&#13;
  <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">2</code><code class="p">));</code>&#13;
  <code class="k">return</code> <code class="m">13</code><code class="p">;</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p><code>Task.Run</code> returns a <code>Task</code> (or <code>Task&lt;T&gt;</code>), which can be naturally consumed by asynchronous or reactive code.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458686150648">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p><code>Task.Run</code> is ideal for UI applications, when you have time-consuming work to do that cannot be done on the UI thread. For example, <a data-type="xref" href="ch08.html#recipe-async-interop-parallel">Recipe 8.4</a> uses <code>Task.Run</code> to push parallel processing to a threadpool thread. However, do not use <code>Task.Run</code> on ASP.NET unless you’re <em>absolutely</em> sure you know what you’re doing. On ASP.NET, request handling code is already running on a threadpool thread, so pushing it onto <em>another</em> threadpool thread is usually counterproductive.</p>&#13;
&#13;
<p><code>Task.Run</code> is an effective replacement for <code>BackgroundWorker</code>, <code>Delegate.BeginInvoke</code>, and <code>ThreadPool.QueueUserWorkItem</code>. None of those older APIs should be used in new code; code using <code>Task.Run</code> is much easier to write correctly and maintain over time. Furthermore, <code>Task.Run</code> handles the vast majority of use cases for <code>Thread</code>, so most uses of <code>Thread</code> can also be replaced with <code>Task.Run</code> (with the rare exception of single-thread apartment threads).</p>&#13;
&#13;
<p>Parallel and dataflow code executes on the thread pool by default, so there’s usually no need to use <code>Task.Run</code> with code executed by the <code>Parallel</code>, Parallel LINQ, or TPL Dataflow libraries.</p>&#13;
&#13;
<p>If <a data-primary="schedulers" data-secondary="in dynamic parallelism" data-secondary-sortas="dynamic" data-type="indexterm" id="idm45458686139752"/><a data-primary="dynamic parallelism" data-type="indexterm" id="idm45458686138472"/><a data-primary="Task.Factory.StartNew method" data-type="indexterm" id="idm45458686137800"/><a data-primary="parallel programming" data-secondary="dynamic parallelism" data-type="indexterm" id="idm45458686137112"/>you’re doing dynamic parallelism, then use <code>Task.Factory.StartNew</code> instead of <code>Task.Run</code>. This is necessary because the <code>Task</code> returned by <code>Task.Run</code> has its default options configured for asynchronous use (i.e., to be consumed by asynchronous or reactive code). It also doesn’t support advanced concepts, such as parent/child tasks, which are more common in dynamic parallel <a data-startref="ch13r1a" data-type="indexterm" id="idm45458686134040"/><a data-startref="ch13r1b" data-type="indexterm" id="idm45458686133336"/>code.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458686132536">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="ch08.html#recipe-rx-interop-async">Recipe 8.6</a> covers consuming asynchronous code (such as the task returned from <code>Task.Run</code>) with reactive code.</p>&#13;
&#13;
<p><a data-type="xref" href="ch08.html#recipe-async-interop-parallel">Recipe 8.4</a> covers asynchronously waiting for parallel code, which is most easily done via <code>Task.Run</code>.</p>&#13;
&#13;
<p><a data-type="xref" href="ch04.html#recipe-parallel-dynamicparallelism">Recipe 4.4</a> covers dynamic parallelism, a scenario where you should use <code>Task.Factory.StartNew</code> instead of <code>Task.Run</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="13.2 Executing Code with a Task Scheduler" data-type="sect1"><div class="sect1" id="recipe-taskscheduler">&#13;
<h1>13.2 Executing Code with a Task Scheduler</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458686124520">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You have multiple pieces of code that you need to execute in a certain way. For example, you may need all the pieces of code to execute on the UI thread, or you may need to execute only a certain number at a time.</p>&#13;
&#13;
<p>This recipe deals with how to define and construct a scheduler for those pieces of code. Actually applying that scheduler is the subject of the next two recipes.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458686092024">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>There <a data-primary="TaskScheduler type" data-type="indexterm" id="ch13r24a"/>are quite a few different types in .NET that can handle scheduling; this recipe focuses on <code>TaskScheduler</code> because it’s portable and relatively easy to use.</p>&#13;
&#13;
<p>The <a data-primary="thread pool" data-secondary="TaskScheduler.Default using" data-type="indexterm" id="idm45458686088280"/>simplest <code>TaskScheduler</code> is <code>TaskScheduler.Default</code>, which queues work to the thread pool. You will seldomly specify <code>TaskScheduler.Default</code> in your own code, but it’s important to be aware of it, since it’s the default for many scheduling scenarios. <code>Task.Run</code>, parallel, and dataflow code all use <code>TaskScheduler.Default</code>.</p>&#13;
&#13;
<p>You can capture a specific <em>context</em> and later schedule work back to it by using <span class="keep-together"><code>TaskScheduler.FromCurrentSynchronizationContext</code></span>:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="n">TaskScheduler</code> <code class="n">scheduler</code> <code class="p">=</code> <code class="n">TaskScheduler</code><code class="p">.</code><code class="n">FromCurrentSynchronizationContext</code><code class="p">();</code></pre>&#13;
&#13;
<p>This <a data-primary="SynchronizationContext type" data-type="indexterm" id="idm45458686080056"/>code creates a <code>TaskScheduler</code> to capture the current <code>SynchronizationContext</code> and schedule code onto that context. <code>SynchronizationContext</code> is a type that represents a general-purpose scheduling context. There are several different contexts in the .NET framework; most UI frameworks provide a <code>SynchronizationContext</code> that represents the UI thread, and<a data-primary="ASP.NET" data-secondary="context in" data-type="indexterm" id="idm45458686076312"/> ASP.NET before Core provided a <code>SynchronizationContext</code> that represented the HTTP request context.</p>&#13;
&#13;
<p><code>ConcurrentExclusiveSchedulerPair</code> is another <a data-primary="ConcurrentExclusiveSchedulerPair type" data-type="indexterm" id="ch13r2b"/>powerful type introduced in .NET 4.5; this is actually <em>two</em> schedulers that are related to each other. The <code>ConcurrentScheduler</code> member is a scheduler that allows multiple tasks to execute at the same time, as long as no task is executing on the <code>ExclusiveScheduler</code>. The <code>ExclusiveScheduler</code> only executes code one task at a time, and only when there’s no task already executing on the <code>ConcurrentScheduler</code>:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">schedulerPair</code> <code class="p">=</code> <code class="k">new</code> <code class="n">ConcurrentExclusiveSchedulerPair</code><code class="p">();</code>&#13;
<code class="n">TaskScheduler</code> <code class="n">concurrent</code> <code class="p">=</code> <code class="n">schedulerPair</code><code class="p">.</code><code class="n">ConcurrentScheduler</code><code class="p">;</code>&#13;
<code class="n">TaskScheduler</code> <code class="n">exclusive</code> <code class="p">=</code> <code class="n">schedulerPair</code><code class="p">.</code><code class="n">ExclusiveScheduler</code><code class="p">;</code></pre>&#13;
&#13;
<p>One common utilization for <code>ConcurrentExclusiveSchedulerPair</code> is to just use the <code>ExclusiveScheduler</code> to ensure only one task is executed at a time. Code that executes on the <code>ExclusiveScheduler</code> will run on the thread pool but will be restricted to executing exclusive of all other code using the same <code>ExclusiveScheduler</code> instance.</p>&#13;
&#13;
<p>Another use for <code>ConcurrentExclusiveSchedulerPair</code> is as a throttling scheduler. You can create a <code>ConcurrentExclusiveSchedulerPair</code> that will limit its own concurrency. In this scenario, the <code>ExclusiveScheduler</code> is usually not used:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">schedulerPair</code> <code class="p">=</code> <code class="k">new</code> <code class="n">ConcurrentExclusiveSchedulerPair</code><code class="p">(</code>&#13;
    <code class="n">TaskScheduler</code><code class="p">.</code><code class="n">Default</code><code class="p">,</code> <code class="n">maxConcurrencyLevel</code><code class="p">:</code> <code class="m">8</code><code class="p">);</code>&#13;
<code class="n">TaskScheduler</code> <code class="n">scheduler</code> <code class="p">=</code> <code class="n">schedulerPair</code><code class="p">.</code><code class="n">ConcurrentScheduler</code><code class="p">;</code></pre>&#13;
&#13;
<p>Note that this kind of throttling only throttles code while it is <em>executing</em>; it’s quite different than the kind of logical throttling covered in <a data-type="xref" href="ch12.html#recipe-throttling">Recipe 12.5</a>. In particular, asynchronous code is not considered to be executing while it is awaiting an operation. The <code>ConcurrentScheduler</code> throttles executing code; other throttling, such as <code>SemaphoreSlim</code>, throttles at a higher level (i.e., an entire <code>async</code> method).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458686091432">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>You may have noticed that the last code example passed <code>TaskScheduler.Default</code> into the constructor for <code>ConcurrentExclusiveSchedulerPair</code>. This is because <code>ConcurrentExclusiveSchedulerPair</code> applies its concurrent/exclusive logic around an existing <code>TaskScheduler</code>.</p>&#13;
&#13;
<p>This recipe introduces <code>TaskScheduler.FromCurrentSynchronizationContext</code>, which is useful for executing code on a captured context. It is also possible to use <code>SynchronizationContext</code> directly to execute code on that context; however, I don’t recommend this approach. Whenever possible, use the <code>await</code> operator to resume on an implicitly captured context, or use a <code>TaskScheduler</code> wrapper.</p>&#13;
&#13;
<p>Don’t ever use platform-specific types to execute code on a UI thread. WPF, Silverlight, iOS, and Android all provide the <code>Dispatcher</code> type, Universal Windows uses the <code>CoreDispatcher</code>, and Windows Forms has the <code>ISynchronizeInvoke</code> interface (i.e., <code>Control.Invoke</code>). Do not use any of these types in new code; just pretend they don’t exist. Using them ties your code to a specific platform unnecessarily. <code>SynchronizationContext</code> is a general-purpose abstraction around these types.</p>&#13;
&#13;
<p>System.Reactive (Rx) <a data-primary="IScheduler type" data-type="indexterm" id="idm45458685965512"/><a data-primary="reactive programming" data-secondary="schedulers" data-type="indexterm" id="idm45458685964424"/><a data-primary="schedulers" data-secondary="in reactive programming" data-secondary-sortas="reactive" data-type="indexterm" id="idm45458685963480"/>introduces a more general scheduler abstraction: <code>IScheduler</code>. An Rx scheduler is capable of wrapping any other kind of scheduler; the <code>TaskPoolScheduler</code> will wrap any <code>TaskFactory</code> (which contains a <code>TaskScheduler</code>). The Rx team also defined an <code>IScheduler</code> implementation that can be manually controlled for testing. If you do need to use a scheduler abstraction, I’d recommend the <code>IScheduler</code> from Rx; it’s well designed, well defined, and test friendly. However, most of the time you don’t need a scheduler abstraction, and earlier libraries, such as the Task Parallel Library (TPL) and TPL Dataflow, only understand <a data-startref="ch13r12a" data-type="indexterm" id="idm45458685959160"/><a data-startref="ch13r12b" data-type="indexterm" id="idm45458685958456"/><a data-startref="ch13r2b" data-type="indexterm" id="idm45458685957784"/>the <code>TaskScheduler</code> type.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458685965176">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="#recipe-parallel-scheduler">Recipe 13.3</a> covers applying a <code>TaskScheduler</code> to parallel code.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-dataflow-scheduler">Recipe 13.4</a> covers applying a <code>TaskScheduler</code> to dataflow code.</p>&#13;
&#13;
<p><a data-type="xref" href="ch12.html#recipe-throttling">Recipe 12.5</a> covers higher-level logical throttling.</p>&#13;
&#13;
<p><a data-type="xref" href="ch06.html#recipe-rx-observeon">Recipe 6.2</a> covers System.Reactive schedulers for event streams.</p>&#13;
&#13;
<p><a data-type="xref" href="ch07.html#recipe-rx-testscheduling">Recipe 7.6</a> covers the System.Reactive test scheduler.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="13.3 Scheduling Parallel Code" data-type="sect1"><div class="sect1" id="recipe-parallel-scheduler">&#13;
<h1>13.3 Scheduling Parallel Code</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458685920200">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="schedulers" data-secondary="in parallel programming" data-secondary-sortas="parallel" data-type="indexterm" id="idm45458685918872"/><a data-primary="parallel programming" data-secondary="schedulers" data-type="indexterm" id="idm45458685917592"/>need to control how the individual pieces of code are executed in parallel code.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458685916264">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Once <a data-primary="ParallelOptions type" data-type="indexterm" id="idm45458685914648"/>you create an appropriate <code>TaskScheduler</code> instance (see <a data-type="xref" href="#recipe-taskscheduler">Recipe 13.2</a>), you can include it in the options that you pass to a <code>Parallel</code> method. The following code takes a sequence of sequences of matrices. It starts a bunch of parallel loops and wants to limit the <em>total</em> parallelism of all loops simultaneously, regardless of how many matrices are in each sequence:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">void</code> <code class="nf">RotateMatrices</code><code class="p">(</code><code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">Matrix</code><code class="p">&gt;&gt;</code> <code class="n">collections</code><code class="p">,</code> <code class="kt">float</code> <code class="n">degrees</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="kt">var</code> <code class="n">schedulerPair</code> <code class="p">=</code> <code class="k">new</code> <code class="n">ConcurrentExclusiveSchedulerPair</code><code class="p">(</code>&#13;
      <code class="n">TaskScheduler</code><code class="p">.</code><code class="n">Default</code><code class="p">,</code> <code class="n">maxConcurrencyLevel</code><code class="p">:</code> <code class="m">8</code><code class="p">);</code>&#13;
  <code class="n">TaskScheduler</code> <code class="n">scheduler</code> <code class="p">=</code> <code class="n">schedulerPair</code><code class="p">.</code><code class="n">ConcurrentScheduler</code><code class="p">;</code>&#13;
  <code class="n">ParallelOptions</code> <code class="n">options</code> <code class="p">=</code> <code class="k">new</code> <code class="n">ParallelOptions</code> <code class="p">{</code> <code class="n">TaskScheduler</code> <code class="p">=</code> <code class="n">scheduler</code> <code class="p">};</code>&#13;
  <code class="n">Parallel</code><code class="p">.</code><code class="n">ForEach</code><code class="p">(</code><code class="n">collections</code><code class="p">,</code> <code class="n">options</code><code class="p">,</code>&#13;
      <code class="n">matrices</code> <code class="p">=&gt;</code> <code class="n">Parallel</code><code class="p">.</code><code class="n">ForEach</code><code class="p">(</code><code class="n">matrices</code><code class="p">,</code> <code class="n">options</code><code class="p">,</code>&#13;
          <code class="n">matrix</code> <code class="p">=&gt;</code> <code class="n">matrix</code><code class="p">.</code><code class="n">Rotate</code><code class="p">(</code><code class="n">degrees</code><code class="p">)));</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458685909656">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p><code>Parallel.Invoke</code> also takes an instance of <code>ParallelOptions</code>, so you can pass a <code>TaskScheduler</code> to <code>Parallel.Invoke</code> the same way as <code>Parallel.ForEach</code>. If you’re doing dynamic parallel code, you can pass <code>TaskScheduler</code> directly to <code>TaskFactory.StartNew</code> or <code>Task.ContinueWith</code>.</p>&#13;
&#13;
<p>There is no way to pass a <code>TaskScheduler</code> to Parallel LINQ (PLINQ) code.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458685828152">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="#recipe-taskscheduler">Recipe 13.2</a> covers common task schedulers and how to choose between them.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="13.4 Dataflow Synchronization Using Schedulers" data-type="sect1"><div class="sect1" id="recipe-dataflow-scheduler">&#13;
<h1>13.4 Dataflow Synchronization Using Schedulers</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458685824136">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="schedulers" data-secondary="in dataflow" data-secondary-sortas="dataflow" data-type="indexterm" id="idm45458685822808"/><a data-primary="dataflow" data-secondary="schedulers" data-type="indexterm" id="idm45458685821528"/>need to control how the individual pieces of code are executed in dataflow code.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458685820200">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Once you create an appropriate <code>TaskScheduler</code> instance (see <a data-type="xref" href="#recipe-taskscheduler">Recipe 13.2</a>), you can include it in the options that you pass to a dataflow block. When called from the UI thread, the following code creates a dataflow mesh that multiplies all of its input values by two (using the thread pool) and then appends the resulting values to the items of a list box (on the UI thread):</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">options</code> <code class="p">=</code> <code class="k">new</code> <code class="n">ExecutionDataflowBlockOptions</code>&#13;
<code class="p">{</code>&#13;
  <code class="n">TaskScheduler</code> <code class="p">=</code> <code class="n">TaskScheduler</code><code class="p">.</code><code class="n">FromCurrentSynchronizationContext</code><code class="p">(),</code>&#13;
<code class="p">};</code>&#13;
<code class="kt">var</code> <code class="n">multiplyBlock</code> <code class="p">=</code> <code class="k">new</code> <code class="n">TransformBlock</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">,</code> <code class="kt">int</code><code class="p">&gt;(</code><code class="n">item</code> <code class="p">=&gt;</code> <code class="n">item</code> <code class="p">*</code> <code class="m">2</code><code class="p">);</code>&#13;
<code class="kt">var</code> <code class="n">displayBlock</code> <code class="p">=</code> <code class="k">new</code> <code class="n">ActionBlock</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;(</code>&#13;
    <code class="n">result</code> <code class="p">=&gt;</code> <code class="n">ListBox</code><code class="p">.</code><code class="n">Items</code><code class="p">.</code><code class="n">Add</code><code class="p">(</code><code class="n">result</code><code class="p">),</code> <code class="n">options</code><code class="p">);</code>&#13;
<code class="n">multiplyBlock</code><code class="p">.</code><code class="n">LinkTo</code><code class="p">(</code><code class="n">displayBlock</code><code class="p">);</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458685815144">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Specifying a <code>TaskScheduler</code> is especially useful in coordinating the actions of blocks in different parts of your dataflow mesh. For example, you can utilize the <code>ConcurrentExclusiveSchedulerPair.ExclusiveScheduler</code> to ensure that blocks A and C never execute code at the same time, while allowing block B to execute whenever it wants.</p>&#13;
&#13;
<p>Keep in mind that synchronization by <code>TaskScheduler</code> only applies while the code is <em>executing</em>. For example, if you have an action block that runs asynchronous code and apply an exclusive scheduler, the code isn’t considered running when it is awaiting.</p>&#13;
&#13;
<p>You can specify a <code>TaskScheduler</code> for any kind of dataflow block. Even though a block may not execute your code (e.g., <code>BufferBlock&lt;T&gt;</code>), it still has housekeeping tasks that it needs to do, and it’ll use the provided <code>TaskScheduler</code> for all of its internal <a data-startref="ch13r24a" data-type="indexterm" id="idm45458685721144"/>work.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458685720056">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="#recipe-taskscheduler">Recipe 13.2</a> covers common task schedulers and how to choose between them.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>