<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xml:lang="en"
      lang="en"
      xmlns="http://www.w3.org/1999/xhtml"
      xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>Functional Programming with C#</title>
<link rel="stylesheet" type="text/css" href="override_v1.css"/>
<link rel="stylesheet" type="text/css" href="epub.css"/>
</head>
<body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 6. Discriminated Unions"><div class="chapter" id="Chapter6_Beginning">
<h1><span class="label">Chapter 6. </span>Discriminated Unions</h1>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45400862308624">
<h1>A Note for Early Release Readers</h1>
<p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p>

<p>This will be the sixth chapter of the final book. Please note that the GitHub repo will be made active later on.</p>

<p>If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the editor at <a href="mailto:jleonard@oreilly.com">jleonard@oreilly.com</a>.</p>
</div></aside>

<p>Discriminated unions (DUs) are a way of defining a type (or class in the OO world) that is actually one of a set of different types.  Which type an instance of a DU actually is at any given moment has to be checked before use.</p>

<p>F# has DUs available natively, and it’s a feature used extensively by F# developers.  Despite sharing a common runtime with C#, and the feature being there for us <em>in theory</em>, there are only plans in place to introduce them into C# at some point - but it’s not certain how or when.  What we can do in the meantime is roughly simulate them with abstract classes, and that’s the technique I’m going to talk about in this chapter.</p>

<p>This chapter is our very first dabble into some of the more advanced areas of functional programming.  Earlier chapters in the book were more focused on how you, the developer can work smart, not hard.  We’ve also looked at ways to reduce boilerplate, and to make code more robust and maintainable.</p>

<p>Discriminated unions<sup><a data-type="noteref" id="idm45400862303440-marker" href="ch06.html#idm45400862303440">1</a></sup> are a programming structure that will do all of this too, but are more than a simple extension method, or a single-line fix to remove a little bit of boilerplate.  DUs are closer in concept to a design pattern - in that they have a structure, and some logic that needs to be implemented around it.</p>






<section data-type="sect1" data-pdf-bookmark="Holiday Time"><div class="sect1" id="idm45400862302592">
<h1>Holiday Time</h1>

<p>Let’s imagine an old-school Object-Oriented problem where we’re creating a system for package holidays.  You know - the sort where the travel agency arrange your travel, accomodation, etc. all in one.  I’ll leave you to imagine what lovely destination you’re off too.  Personally, I’m quite fond of the Greek islands.</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">class</code> <code class="nc">Holiday</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="kt">int</code> <code class="n">Id</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
 <code class="k">public</code> <code class="n">Location</code> <code class="n">Destination</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
 <code class="k">public</code> <code class="n">Location</code> <code class="n">DepartureAirport</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
 <code class="k">public</code> <code class="n">DateTime</code> <code class="n">StartDate</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
 <code class="k">public</code> <code class="kt">int</code> <code class="n">DurationOfStay</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">HolidayWithMeals</code> <code class="p">:</code> <code class="n">Holiday</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="kt">int</code> <code class="n">NumberOfMeals</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code></pre>

<p>Now imagine we were creating, say, an account page for our customers<sup><a data-type="noteref" id="idm45400862223056-marker" href="ch06.html#idm45400862223056">2</a></sup>, and we want to list everything they’ve bought so far.  Not all that difficult, really.  We can use some relatively-new <code>is</code> statement to build the necessary string.  Here’s one way we could do it:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="kt">string</code> <code class="nf">formatHoliday</code><code class="p">(</code><code class="n">Holiday</code> <code class="n">h</code><code class="p">)</code> <code class="p">=&gt;</code>
 <code class="s">"From: "</code> <code class="p">+</code> <code class="n">h</code><code class="p">.</code><code class="n">DepartureAirport</code><code class="p">.</code><code class="n">Name</code> <code class="p">+</code> <code class="n">Environment</code><code class="p">.</code><code class="n">NewLine</code> <code class="p">+</code>
 <code class="s">"To: "</code> <code class="p">+</code> <code class="n">h</code><code class="p">.</code><code class="n">Destination</code><code class="p">.</code><code class="n">Name</code> <code class="p">+</code> <code class="n">Environment</code><code class="p">.</code><code class="n">NewLine</code> <code class="p">+</code>
 <code class="s">"Duration: "</code> <code class="p">+</code> <code class="n">h</code><code class="p">.</code><code class="n">DurationOfStay</code> <code class="p">+</code> <code class="s">" Day(s)"</code> <code class="p">+</code>
 <code class="p">(</code>
  <code class="n">h</code> <code class="k">is</code> <code class="n">HolidayWithMeals</code> <code class="n">hm</code>
   <code class="p">?</code> <code class="n">Environment</code><code class="p">.</code><code class="n">NewLine</code> <code class="p">+</code> <code class="s">"Number of Meals: "</code> <code class="p">+</code> <code class="n">hm</code><code class="p">.</code><code class="n">NumberOfMeals</code>
   <code class="p">:</code> <code class="kt">string</code><code class="p">.</code><code class="n">Empty</code>
 <code class="p">);</code></pre>

<p>If I wanted to quickly improve this with a few functional ideas, I could consider introducing a Fork combinator (see previous chapter),  The basic type is Holiday, the sub-type is a Holiday with a Meal.  Essentially the same thing, but with an extra field or two.</p>

<p>What if…​there was a project started up in the company.  Now, they’re going to start offering other types of service, separate from holidays.  They’re going to also start providing day trips that don’t involve hotels, flights, or anything else of that sort.  Entrance into Tower Bridge<sup><a data-type="noteref" id="idm45400862084240-marker" href="ch06.html#idm45400862084240">3</a></sup> in London, perhaps.  Or a quick jaunt up the Eiffel Tower in Paris.  Whatever you fancy.  World’s your oyster.</p>

<p>The object would look something like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">class</code> <code class="nc">DayTrip</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="kt">int</code> <code class="n">Id</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
 <code class="k">public</code> <code class="n">DateTime</code> <code class="n">DateOfTrip</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
 <code class="k">public</code> <code class="n">Location</code> <code class="n">Attraction</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
 <code class="k">public</code> <code class="kt">bool</code> <code class="n">CoachTripRequired</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code></pre>

<p>The point is though, that if we want to represent this new scenario with inheritance from a Holiday object, it doesn’t work.  An approach I’ve seen some people follow is to merge all of the fields together, along with a boolean to indicate which fields are the ones you should be looking at.</p>

<p>Something like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">class</code> <code class="nc">CustomerOffering</code>
<code class="p">{</code>
  <code class="k">public</code> <code class="kt">int</code> <code class="n">Id</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
  <code class="k">public</code> <code class="n">Location</code> <code class="n">Destination</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
  <code class="k">public</code> <code class="n">Location</code> <code class="n">DepartureAirport</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
  <code class="k">public</code> <code class="n">DateTime</code> <code class="n">StartDate</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
  <code class="k">public</code> <code class="kt">int</code> <code class="n">DurationOfStay</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
  <code class="k">public</code> <code class="kt">bool</code> <code class="n">CoachTripRequired</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
  <code class="k">public</code> <code class="kt">bool</code> <code class="n">IsDayTrip</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code></pre>

<p>This is a poor idea for several reasons.  For one, you’re breaking the Interface Segregation principle.  Whichever type it really is, you’re forcing it to hold fields that are irrelevant to it.  We’ve also doubled up the concepts of “Destination” and “Attraction”, as well as “DateOfTrip and “StartDate” here, to avoid duplication, but it means that we’ve lost some of the terminology that makes code dealing with day trips meaningful.</p>

<p>The other option is to maintain them as entirely separate types of object with no relationship between them at all.  Doing that though, we lose the ability to have a nice, concise, simple loop through every object.  We wouldn’t be able to list everything in a single table in date order.  There would have to be multiple tables.</p>

<p>None of the possibilities seem all that good.  But this is where DUs come charging to the rescue.  In the next section, I’ll show you how to use them to provide an optimum solution to this problem.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Holidays with Discriminated Unions"><div class="sect1" id="idm45400862302128">
<h1>Holidays with Discriminated Unions</h1>

<p>In F#, you can create a union type for our customer offering example, like this:</p>

<pre data-type="programlisting" data-code-language="fsharp"><code class="k">type</code> <code class="nc">CustomerOffering</code> <code class="o">=</code>
 <code class="o">|</code> <code class="n">Holiday</code>
 <code class="o">|</code> <code class="n">HolidayWithMeals</code>
 <code class="o">|</code> <code class="n">DayTrip</code></pre>

<p>What that means is that you can instantiate a new instance of CustomerOffering, but there are three separate types it could be, each potentially with their own entirely different properties.</p>

<p>This is the nearest we can get to this approach in C#:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">abstract</code> <code class="k">class</code> <code class="nc">CustomerOffering</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="kt">int</code> <code class="n">Id</code> <code class="p">{</code> <code class="n">Get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">Holiday</code> <code class="p">:</code> <code class="n">CustomerOffering</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="n">Location</code> <code class="n">Destination</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
 <code class="k">public</code> <code class="n">Location</code> <code class="n">DepartureAirport</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
 <code class="k">public</code> <code class="n">DateTime</code> <code class="n">StartDate</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
 <code class="k">public</code> <code class="kt">int</code> <code class="n">DurationOfStay</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">HolidayWithMeals</code> <code class="p">:</code> <code class="n">Holiday</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="kt">int</code> <code class="n">NumberOfMeals</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">DayTrip</code> <code class="p">:</code> <code class="n">CustomerOffering</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="n">DateTime</code> <code class="n">DateOfTrip</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
 <code class="k">public</code> <code class="n">Location</code> <code class="n">Attraction</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
 <code class="k">public</code> <code class="kt">bool</code> <code class="n">CoachTripRequired</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code></pre>

<p>On the face of it, it doesn’t seem entirely different to the first version of this set of classes, but there’s an important difference.  The base is abstract - you can’t actually create a CustomerOffering class.  Instead of being a family tree of classes with one parent at the top that all others conform to, all of the sub-classes are different, but equal in the hiararchy.</p>

<p>Here’s a class hiararchy diagram, which makes the difference between the two approaches clearer:</p>

<figure><div class="figure">
<img src="assets/Discriminatedunion.png" alt="OO vs Discriminated Union" width="1583" height="663"/>
<h6></h6>
</div></figure>

<p>The DayTrip class is in no way forced to conform to any concept that makes sense to the Holiday class.  DayTrip is completely its own thing.  It means it can use property names that correspond exactly to its own business logic, rather than having to retro-fit a few of the properties from Holiday.  In other words - DayTrip isn’t an <strong>extension</strong> of Holiday, it’s an <strong>alternative</strong> to it.</p>

<p>This also means you can have a single array of all CustomerOfferings, even though they’re wildly different.  No need for separate data sources.</p>

<p>We’d handle an array of CustomerOffering objects in code using a pattern matching statement:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="kt">string</code> <code class="nf">formatCustomerOffering</code><code class="p">(</code><code class="n">CustomerOffering</code> <code class="n">c</code><code class="p">)</code> <code class="p">=&gt;</code>
 <code class="n">c</code> <code class="k">switch</code>
 <code class="p">{</code>
  <code class="n">HolidayWithMeals</code> <code class="n">hm</code> <code class="p">=&gt;</code> <code class="k">this</code><code class="p">.</code><code class="n">formatHolidayWithMeal</code><code class="p">(</code><code class="n">hm</code><code class="p">),</code>
  <code class="n">Holiday</code> <code class="n">h</code> <code class="p">=&gt;</code> <code class="k">this</code><code class="p">.</code><code class="n">formatHoliday</code><code class="p">(</code><code class="n">h</code><code class="p">),</code>
  <code class="n">DayTrip</code> <code class="n">dt</code> <code class="p">=&gt;</code> <code class="k">this</code><code class="p">.</code><code class="n">formatDayTrip</code><code class="p">(</code><code class="n">tp</code><code class="p">)</code>
 <code class="p">};</code></pre>

<p>This simplifies the code everywhere the discriminated union is received, and gives rise to more descriptive code, and code that more accurately describes all of the possible outcomes of a function.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Schrödinger’s Union"><div class="sect1" id="idm45400861652064">
<h1>Schrödinger’s Union</h1>

<p>If you want an analogy of how these things work, think of poor old Schrödinger’s Cat.  This was a thought experiment proposed by an Austrian physisist Erwin Schrödinger to highlight a paradox in quantum mechanics.  The idea was that given a box containing a cat<sup><a data-type="noteref" id="idm45400861606272-marker" href="ch06.html#idm45400861606272">4</a></sup> and a radioactive isotope that had a 50-50 chance of decaying, which would kill the cat.  The point was that, according to quantum physics<sup><a data-type="noteref" id="idm45400861605424-marker" href="ch06.html#idm45400861605424">5</a></sup> until someone opens the box to check on the cat, both states - alive and dead - exist at the same time.  Meaning that the cat is both alive and dead at the same time.</p>

<p>This also means that if Herr Schrödinger were to send his cat/isotope box in the post to a friend<sup><a data-type="noteref" id="idm45400861604272-marker" href="ch06.html#idm45400861604272">6</a></sup> they have a box that could contain one of two states inside, and until they open it, they don’t know which.  Of course, the postal service being what it is, chances are the cat would dead upon arrival <em>either way</em>.  This is why you really shouldn’t try this one at home.  Trust me I’m not a Doctor, nor do I play one on TV.</p>

<p>That’s kind’ve how a discriminated union is.  A single returned value, but which may exist in two or more states.  You don’t know which until you examine it.</p>

<p>If a class doesn’t care which state, you can even pass it along to its next destination unopened.</p>

<p>Schrödinger’s cat as code might look like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">abstract</code> <code class="k">class</code> <code class="nc">SchrödingersCat</code> <code class="p">{</code> <code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">AliveCat</code> <code class="p">:</code> <code class="n">SchrödingersCat</code> <code class="p">{</code> <code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">DeadCat</code> <code class="p">:</code> <code class="n">SchrödingersCat</code> <code class="p">{</code> <code class="p">}</code></pre>

<p>I’m hoping you’re now clear on what exactly Discriminated Unions actually <strong>are</strong>.  I’m going to spend the rest of this chapter demonstrating a few examples of what they are <strong>for</strong>.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Naming Conventions"><div class="sect1" id="idm45400861576944">
<h1>Naming Conventions</h1>

<p>Let’s imagine a code module for writing out people’s names from the individual components.  If you have a traditional British name, like my own, then this is fairly straightforward.  A class to write a name like mine would look something like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">class</code> <code class="nc">BritishName</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="kt">string</code> <code class="n">FirstName</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
 <code class="k">public</code> <code class="n">IEnumerable</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">MiddleNames</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
 <code class="k">public</code> <code class="kt">string</code> <code class="n">LastName</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
 <code class="k">public</code> <code class="kt">string</code> <code class="n">Honorific</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code>

<code class="kt">var</code> <code class="n">simonsName</code> <code class="p">=</code> <code class="k">new</code> <code class="n">BritishName</code>
<code class="p">{</code>
 <code class="n">Honorific</code> <code class="p">=</code> <code class="s">"Mr."</code><code class="p">,</code>
 <code class="n">FirstName</code> <code class="p">=</code> <code class="s">"Simon"</code><code class="p">,</code>
 <code class="n">MiddleNames</code> <code class="p">=</code> <code class="k">new</code> <code class="p">[]</code> <code class="p">{</code> <code class="s">"John"</code> <code class="p">},</code>
 <code class="n">LastName</code> <code class="p">=</code> <code class="s">"Painter</code>
<code class="p">};</code></pre>

<p>The code to render it would be as simple as this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="kt">string</code> <code class="nf">formatName</code><code class="p">(</code><code class="n">BritishName</code> <code class="n">bn</code><code class="p">)</code> <code class="p">=&gt;</code>
 <code class="n">bn</code><code class="p">.</code><code class="n">Honorific</code> <code class="p">+</code> <code class="s">" "</code> <code class="n">bn</code><code class="p">.</code><code class="n">FirstName</code> <code class="p">+</code> <code class="s">" "</code> <code class="p">+</code> <code class="kt">string</code><code class="p">.</code><code class="n">Join</code><code class="p">(</code><code class="s">" "</code><code class="p">,</code> <code class="n">bn</code><code class="p">.</code><code class="n">MiddleNames</code><code class="p">)</code> <code class="p">+</code>
 <code class="s">" "</code> <code class="p">+</code> <code class="n">bn</code><code class="p">.</code><code class="n">LastName</code><code class="p">;</code>
<code class="c1">// Results in "Mr Simon John Painter"</code></pre>

<p>All done, right?  Well, this works for traditional British names, but what about Chinese names?  They aren’t written in the same order as British names.  Chinese names are written in the order &lt;family name&gt; &lt;given name&gt;, and many Chinese people take a “courtesy name” - a western-style name, which is used professionally.</p>

<p>Let’s take the example of the legendary actor, directory, writer, stunt-man, singer &amp; all-round awesome Human being - Jackie Chan.  His real name is Fang Shilong.  In that set of names, his family name (i.e. Surname) is Fang.  His personal name (often in English called the First name, or Christian Name) is Shilong.  Jackie is a courtesy name he’s used since he was very young.  This style of name doesn’t work whatsoever with the formatName function I created, above.</p>

<p>I <em>could</em> mangle the data a bit to make it work.  Something like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="kt">var</code> <code class="n">jackie</code> <code class="p">=</code> <code class="k">new</code> <code class="n">BritishName</code>
<code class="p">{</code>
 <code class="n">Honorific</code> <code class="p">=</code> <code class="s">"Xiānsheng"</code><code class="p">,</code> <code class="c1">// equivalent of "Mr."</code>
 <code class="n">FirstName</code> <code class="p">=</code> <code class="s">"Fang"</code><code class="p">,</code>
 <code class="n">LastName</code> <code class="p">=</code> <code class="s">"Shilong"</code>
<code class="p">}</code>
<code class="c1">// results in "xiānsheng Fang Shilong"</code></pre>

<p>So fine, this correctly writes his two official names in the correct order.  What about his courtesy name though?  There’s nothing to write that out.  Also, The Chinese equivalent of “Mr” - Xiānsheng <sup><a data-type="noteref" id="idm45400861305600-marker" href="ch06.html#idm45400861305600">7</a></sup> - actually goes <strong>after</strong> the name, so this is really pretty shoddy - even if we try re-purposing the existing fields.</p>

<p>We could add an awful lot of <code>if</code> statements into the code to check for the nationality of the person being described, but that approach would rapidly turn into a nightmare if we tried to scale it up to include more than 2 nationalities.</p>

<p>Once again, a better approach would be to use a discriminated union to represent the radically different data structures in a form that mirrors the reality of the thing they’re trying to represent.</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">abstract</code> <code class="k">class</code> <code class="nc">Name</code> <code class="p">{</code> <code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">BritishName</code> <code class="p">:</code> <code class="n">Name</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="kt">string</code> <code class="n">FirstName</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
 <code class="k">public</code> <code class="n">IEnumerable</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">MiddleNames</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
 <code class="k">public</code> <code class="kt">string</code> <code class="n">LastName</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
 <code class="k">public</code> <code class="kt">string</code> <code class="n">Honorific</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">ChineseName</code> <code class="p">:</code> <code class="n">Name</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="kt">string</code> <code class="n">FamilyName</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
 <code class="k">public</code> <code class="kt">string</code> <code class="n">GivenName</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
 <code class="k">public</code> <code class="kt">string</code> <code class="n">Honorific</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
 <code class="k">public</code> <code class="kt">string</code> <code class="n">CourtesyName</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code></pre>

<p>In my imaginary scenario there are probably separate data sources for each name type - each with their own schema.  Maybe a Web API for each country?</p>

<p>Using this union, we can actually create an array of names containing both me and Jackie Chan<sup><a data-type="noteref" id="idm45400861328768-marker" href="ch06.html#idm45400861328768">8</a></sup></p>

<pre data-type="programlisting" data-code-language="csharp"><code class="kt">var</code> <code class="n">names</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Name</code><code class="p">[]</code>
<code class="p">{</code>
 <code class="k">new</code> <code class="n">BritishName</code>
 <code class="p">{</code>
  <code class="n">Honorific</code> <code class="p">=</code> <code class="s">"Mr."</code><code class="p">,</code>
  <code class="n">FirstName</code> <code class="p">=</code> <code class="s">"Simon"</code><code class="p">,</code>
  <code class="n">MiddleNames</code> <code class="p">=</code> <code class="k">new</code> <code class="p">[]</code> <code class="p">{</code> <code class="s">"John"</code> <code class="p">},</code>
  <code class="n">LastName</code> <code class="p">=</code> <code class="s">"Painter"</code>
 <code class="p">},</code>
 <code class="k">new</code> <code class="n">ChineseName</code>
 <code class="p">{</code>
  <code class="n">Honorific</code> <code class="p">=</code> <code class="s">"Xiānsheng"</code><code class="p">,</code>
  <code class="n">FamilyName</code> <code class="p">=</code> <code class="s">"Fang"</code><code class="p">,</code>
  <code class="n">GivenName</code> <code class="p">=</code> <code class="s">"Shilong"</code><code class="p">,</code>
  <code class="n">CourtestyName</code> <code class="p">=</code> <code class="s">"Jackie"</code>
 <code class="p">}</code>
<code class="p">}</code></pre>

<p>I coud then extend out my formatting function with a pattern matching expression:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="kt">string</code> <code class="nf">formatName</code><code class="p">(</code><code class="n">Name</code> <code class="n">n</code><code class="p">)</code> <code class="p">=&gt;</code>
 <code class="n">n</code> <code class="k">switch</code>
 <code class="p">{</code>
  <code class="n">BritishName</code> <code class="n">bn</code> <code class="p">=&gt;</code> <code class="n">bn</code><code class="p">.</code><code class="n">Honorific</code> <code class="p">+</code> <code class="s">" "</code> <code class="n">bn</code><code class="p">.</code><code class="n">FirstName</code> <code class="p">+</code> <code class="s">" "</code>
     <code class="p">+</code> <code class="kt">string</code><code class="p">.</code><code class="n">Join</code><code class="p">(</code><code class="s">" "</code><code class="p">,</code> <code class="n">bn</code><code class="p">.</code><code class="n">MiddleNames</code><code class="p">)</code> <code class="p">+</code> <code class="s">" "</code> <code class="p">+</code> <code class="n">bn</code><code class="p">.</code><code class="n">LastName</code><code class="p">,</code>
  <code class="n">ChineseName</code> <code class="n">cn</code> <code class="p">=&gt;</code> <code class="n">cn</code><code class="p">.</code><code class="n">FamilyName</code> <code class="p">+</code> <code class="s">" "</code> <code class="p">+</code> <code class="n">cn</code><code class="p">.</code><code class="n">GivenName</code> <code class="p">+</code> <code class="s">" "</code> <code class="p">+</code>
     <code class="n">cn</code><code class="p">.</code><code class="n">Honorific</code> <code class="p">+</code> <code class="s">" \""</code> <code class="p">+</code> <code class="n">cn</code><code class="p">.</code><code class="n">CourtesyName</code> <code class="p">+</code> <code class="s">"\""</code>
 <code class="p">};</code>

<code class="kt">var</code> <code class="n">output</code> <code class="p">=</code> <code class="kt">string</code><code class="p">.</code><code class="n">Join</code><code class="p">(</code><code class="n">Environment</code><code class="p">.</code><code class="n">NewLine</code><code class="p">,</code> <code class="n">names</code><code class="p">);</code>
<code class="c1">// output =</code>
<code class="c1">// Mr. Simon John Painter</code>
<code class="c1">// Fang Shilong Xiānsheng "Jackie"</code></pre>

<p>This same principle can be applied to any style of naming for anywhere in the world, and the names given to fields will always be meaningful to that country, as well as always being correctly styled without re-purposing existing fields.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Database Lookup"><div class="sect1" id="idm45400861576352">
<h1>Database Lookup</h1>

<p>The sort of area of a system I’d often consider using Discriminated Unions in C# is as return types from functions defined on an interface.</p>

<p>One area I’m especially likely to use this technique is in lookup functions to data sources.  Let’s imagine for a moment you wanted to find someone’s details in a system of some kind somewhere.  The function is going to take an integer Id value, and return a Person record.</p>

<p>At least that’s what you’d often find people doing.  Something like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="n">Person</code>  <code class="nf">GetPerson</code><code class="p">(</code><code class="kt">int</code> <code class="n">id</code><code class="p">)</code>
<code class="p">{</code>
 <code class="c1">// Fill in some code here.  Whatever data</code>
 <code class="c1">// store you want to use.  Except mini-disc.</code>
<code class="p">}</code></pre>

<p>But if you think about it, returning a Person object is only <em>one</em> of the possible return states of the function.</p>

<p>What if an Id is entered for a person that doesn’t exist? You <em>could</em> return <code>Null</code> I suppose, but that’s not descriptive of what actually happened.  What if there were a handled <code>Exception</code> that resulted in nothing being returned?  The <code>Null</code> doesn’t tell you <em>why</em> it was returned.</p>

<p>The other possibility is an <code>Exception</code> being raised.  It might well not be the fault of your code, but nevertheless it could happen if there are network issues, or whatever.  What would you return in this case?</p>

<p>Rather than returning an unexplained <code>Null</code> and forcing other parts of the codebase to handle it, or an alternative return type object with metadata fields in it containing Exceptions, etc.  we could instead create a discriminated union:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">abstract</code> <code class="k">class</code> <code class="nc">PersonLookupResult</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="kt">int</code> <code class="n">Id</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">PersonFound</code> <code class="p">:</code> <code class="n">PersonLookupResult</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="n">Person</code> <code class="n">Person</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">PersonNotFound</code> <code class="p">:</code> <code class="n">PersonLookupResult</code>
<code class="p">{</code>

<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">ErrorWhileSearchingPerson</code> <code class="p">:</code> <code class="n">PersonLookupResult</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="n">Exception</code> <code class="n">Error</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code></pre>

<p>All of this means we can now return a single class from our GetPersonById function which tells the code utilizing the class that one of these three states has been returned, but which it is has already been determined.  There’s no need for the returned object to have logic applied to it, to determine whether it worked or not, and the states are completely descriptive of each case that needs to be handled.</p>

<p>The function would look something like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="n">PersonLookupResult</code>  <code class="nf">GetPerson</code><code class="p">(</code><code class="kt">int</code> <code class="n">id</code><code class="p">)</code>
<code class="p">{</code>
 <code class="k">try</code>
 <code class="p">{</code>
  <code class="kt">var</code> <code class="n">personFromDb</code> <code class="p">=</code> <code class="k">this</code><code class="p">.</code><code class="n">Db</code><code class="p">.</code><code class="n">Person</code><code class="p">.</code><code class="n">Lookup</code><code class="p">(</code><code class="n">id</code><code class="p">);</code>
  <code class="k">return</code> <code class="n">personFromDb</code> <code class="p">==</code> <code class="k">null</code>
   <code class="p">?</code> <code class="k">new</code> <code class="n">PersonNotFound</code> <code class="p">{</code> <code class="n">Id</code> <code class="p">=</code> <code class="n">id</code> <code class="p">}</code>
   <code class="p">:</code> <code class="k">new</code> <code class="n">PersonFound</code>
    <code class="p">{</code>
     <code class="n">Person</code> <code class="p">=</code> <code class="n">personFromDb</code><code class="p">,</code>
     <code class="n">Id</code> <code class="p">=</code> <code class="n">id</code>
    <code class="p">};</code>
 <code class="p">}</code>
 <code class="k">catch</code><code class="p">(</code><code class="n">Exception</code> <code class="n">e</code><code class="p">)</code>
 <code class="p">{</code>
  <code class="k">return</code> <code class="k">new</code> <code class="n">ErrorWhileSearchingPerson</code>
  <code class="p">{</code>
   <code class="n">Id</code> <code class="p">=</code> <code class="n">id</code><code class="p">,</code>
   <code class="n">Error</code> <code class="p">=</code> <code class="n">e</code>
  <code class="p">}</code>
 <code class="p">}</code>
<code class="p">}</code></pre>

<p>And consuming it is once again a matter of using a pattern matching expression to determine what to do:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="kt">string</code> <code class="nf">DescribePerson</code><code class="p">(</code><code class="kt">int</code> <code class="n">id</code><code class="p">)</code>
<code class="p">{</code>
 <code class="kt">var</code> <code class="n">p</code> <code class="p">=</code> <code class="k">this</code><code class="p">.</code><code class="n">PersonRepository</code><code class="p">.</code><code class="n">GetPerson</code><code class="p">(</code><code class="n">id</code><code class="p">);</code>
 <code class="k">return</code> <code class="n">p</code> <code class="k">switch</code>
 <code class="p">{</code>
  <code class="n">PersonFound</code> <code class="n">pf</code> <code class="p">=&gt;</code> <code class="s">"Their name is "</code> <code class="p">+</code> <code class="n">pf</code><code class="p">.</code><code class="n">Name</code><code class="p">,</code>
  <code class="n">PersonNotFound</code> <code class="n">_</code> <code class="p">=&gt;</code> <code class="s">"Person not found"</code><code class="p">,</code>
  <code class="n">ErrorWhileSearchingPerson</code> <code class="n">e</code> <code class="p">=&gt;</code> <code class="s">"An error occurred"</code> <code class="p">+</code> <code class="n">e</code><code class="p">.</code><code class="n">Error</code><code class="p">.</code><code class="n">Message</code>
 <code class="p">};</code>
<code class="p">}</code></pre>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Sending Email"><div class="sect1" id="idm45400860955552">
<h1>Sending Email</h1>

<p>The last example was fine for cases where you’re expecting a value back, but what about cases where there’s no return value?  Let’s imagine I’d written some code to send an email to a customer, or family member I can’t be bothered to write a message to myself<sup><a data-type="noteref" id="idm45400860602016-marker" href="ch06.html#idm45400860602016">9</a></sup>.</p>

<p>I don’t expect anything back, but I might like to know if an error has occured, so this time there are only two states I’m especially concerned with.</p>

<p>This is how I’d accomplish it:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">abstract</code> <code class="k">class</code> <code class="nc">EmailSendResult</code>
<code class="p">{</code>

<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">EmailSuccess</code> <code class="p">:</code> <code class="n">EmailSendResult</code>
<code class="p">{</code>

<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">EmailFailure</code> <code class="p">:</code> <code class="n">EmailSendResult</code>
<code class="p">{</code>
 <code class="n">pubic</code> <code class="n">Exception</code> <code class="n">Error</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code></pre>

<p>Use of this class in code might look like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="n">EmailSendResult</code> <code class="nf">SendEmail</code><code class="p">(</code><code class="kt">string</code> <code class="n">recipient</code><code class="p">,</code> <code class="kt">string</code> <code class="n">message</code><code class="p">)</code>
<code class="p">{</code>
 <code class="k">try</code>
 <code class="p">{</code>
  <code class="k">this</code><code class="p">.</code><code class="n">AzureEmailUtility</code><code class="p">.</code><code class="n">SendEmail</code><code class="p">(</code><code class="n">recipient</code><code class="p">,</code> <code class="n">message</code><code class="p">);</code>
  <code class="k">return</code> <code class="k">new</code> <code class="nf">EmailSuccess</code><code class="p">();</code>
 <code class="p">}</code>
 <code class="k">catch</code><code class="p">(</code><code class="n">Exception</code> <code class="n">e</code><code class="p">)</code>
 <code class="p">{</code>
  <code class="k">return</code> <code class="k">new</code> <code class="n">EmailFailure</code>
  <code class="p">{</code>
   <code class="n">Error</code> <code class="p">=</code> <code class="n">e</code>
  <code class="p">};</code>
 <code class="p">}</code>
<code class="p">}</code></pre>

<p>Usage of the function elsewhere in the codebase would look like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="kt">var</code> <code class="n">result</code> <code class="p">=</code> <code class="k">this</code><code class="p">.</code><code class="n">EmailTool</code><code class="p">.</code><code class="n">SendEmail</code><code class="p">(</code><code class="s">"Season's Greetings"</code><code class="p">,</code> <code class="s">"Hi, Uncle John.  How's it going?"</code><code class="p">);</code>

<code class="kt">var</code> <code class="n">messageToWriteToConsole</code> <code class="p">=</code> <code class="n">result</code> <code class="k">switch</code>
<code class="p">{</code>
 <code class="n">EmailFailure</code> <code class="n">ef</code> <code class="p">=&gt;</code> <code class="s">"An error occurred sending the email: "</code> <code class="p">+</code> <code class="n">ef</code><code class="p">.</code><code class="n">Error</code><code class="p">.</code><code class="n">Message</code><code class="p">,</code>
 <code class="n">EmailSuccess</code> <code class="n">_</code> <code class="p">=&gt;</code> <code class="s">"Email send successful"</code><code class="p">,</code>
 <code class="n">_</code> <code class="p">=&gt;</code> <code class="s">"Unknow Response"</code>
<code class="p">};</code>

<code class="k">this</code><code class="p">.</code><code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">messageToWriteToConsole</code><code class="p">);</code></pre>

<p>This, once again, means I can return an error message and failure state from the function, but without anything anywhere depending on properties it doesn’t need.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Console Input"><div class="sect1" id="idm45400860455616">
<h1>Console Input</h1>

<p>Some time ago I came up with the mad idea to try out my functional programming skills by converting an old text-based game written in HP Timeshare BASIC to functional-style C#.</p>

<p>The game was called Oregon Trail, and dated all the way back to 1975.  Hard as it is to believe, even older than I am!  Older even, than Star Wars.  In fact, it even predates monitors, and had to effectively be played on something that looked like a typewriter.  In those days, when the code said “print” - it meant it!</p>

<p>One of the most crucial things the game code had to do was to periodically take input from the user.  Most of the time an integer was required - either to select a command from a list, or to enter an amount of goods to purchase.  Other times, it was important to receive text, and to confirm what it was the user typed - such as in the hunting mini-game, where the user was required to type “BANG” as quickly as possible to simulate attempting to accurately hit a target.</p>

<p>I <em>could</em> have simply had a module in the codebase that returned raw user input from the console.  This would mean that every place in the entire codebase that required an integer value would be required to carry out a check, then a parse to integer, before getting on with whatever logic was actually required.</p>

<p>A smarter idea is to use a discriminated union to represent the different states the logic of the game recognises from user input, and keep the necessary int check code in a single place.</p>

<p>Something like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">abstract</code> <code class="k">class</code> <code class="nc">UserInput</code>
<code class="p">{</code>

<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">TextInput</code> <code class="p">:</code> <code class="n">UserInput</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="kt">string</code> <code class="n">Input</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">IntegerInput</code> <code class="p">:</code> <code class="n">UserInput</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="kt">int</code> <code class="n">Input</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">NoInput</code> <code class="p">:</code> <code class="n">UserInput</code>
<code class="p">{</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">ErrorFromConsole</code> <code class="p">:</code> <code class="n">UserInput</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="n">Exception</code> <code class="n">Error</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code></pre>

<p>I’m not honestly sure what errors are possible from the console, but I don’t think it’s wise to rule it out, especially as it’s something beyond the control of our application code.</p>

<p>The idea here is that I’m gradually shifting from the impure area beyond the codebase, into the pure, controlled area within it.  Like a multi-stage airlock.</p>

<figure><div class="figure">
<img src="assets/textinput.png" alt="stages of text input" width="1037" height="564"/>
<h6></h6>
</div></figure>

<p>Speaking of the console being beyond our control…​ If we want to keep our codebase as functional as possible, then it’s best to hide it behind an interface, so that we can inject mocks during test, and push back the non-pure area of our code a little further.</p>

<p>Something like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">interface</code> <code class="n">IConsole</code>
<code class="p">{</code>
 <code class="n">UserInput</code> <code class="nf">ReadInput</code><code class="p">(</code><code class="kt">string</code> <code class="n">userPromptMessage</code><code class="p">);</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">ConsoleShim</code> <code class="p">:</code> <code class="n">IConsole</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="n">UserInput</code> <code class="nf">ReadInput</code><code class="p">(</code><code class="kt">string</code> <code class="n">userPromptMessage</code><code class="p">)</code>
 <code class="p">{</code>
  <code class="k">try</code>
  <code class="p">{</code>
   <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">userPromptMessage</code><code class="p">);</code>
   <code class="kt">var</code> <code class="n">input</code> <code class="p">=</code> <code class="n">Console</code><code class="p">.</code><code class="n">ReadLine</code><code class="p">();</code>
   <code class="k">return</code> <code class="k">new</code> <code class="n">TextInput</code>
   <code class="p">{</code>
    <code class="n">Input</code> <code class="p">=</code> <code class="n">input</code>
   <code class="p">};</code>
  <code class="p">}</code>
  <code class="k">catch</code><code class="p">(</code><code class="n">Exception</code> <code class="n">e</code><code class="p">)</code>
  <code class="p">{</code>
   <code class="k">return</code> <code class="k">new</code> <code class="n">ErrorFromConsole</code>
   <code class="p">{</code>
    <code class="n">Error</code> <code class="p">=</code> <code class="n">e</code>
   <code class="p">};</code>
  <code class="p">}</code>
 <code class="p">}</code>
<code class="p">}</code></pre>

<p>That was the most basic representation possible of an interaction with the user.  That’s because that’s an area of the system with side effects, and I want to keep that as small as possible.</p>

<p>After that, I created another layer, but this time there was actually some logic applied to the text received from the player:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">class</code> <code class="nc">UserInteraction</code>
<code class="p">{</code>
 <code class="k">private</code> <code class="k">readonly</code> <code class="n">IConsole</code> <code class="n">_console</code><code class="p">;</code>
 <code class="k">public</code> <code class="nf">UserInteraction</code><code class="p">(</code><code class="n">IConsole</code> <code class="n">console</code><code class="p">)</code>
 <code class="p">{</code>
  <code class="k">this</code><code class="p">.</code><code class="n">_console</code> <code class="p">=</code> <code class="n">console</code><code class="p">;</code>
 <code class="p">}</code>

<code class="k">public</code> <code class="n">UserInput</code> <code class="nf">GetInputFromUser</code><code class="p">(</code><code class="kt">string</code> <code class="n">message</code><code class="p">)</code>
<code class="p">{</code>
	<code class="kt">var</code> <code class="n">input</code> <code class="p">=</code> <code class="k">this</code><code class="p">.</code><code class="n">_console</code><code class="p">.</code><code class="n">ReadInput</code><code class="p">(</code><code class="n">message</code><code class="p">);</code>
	<code class="kt">var</code> <code class="n">returnValue</code> <code class="p">=</code> <code class="n">input</code> <code class="k">switch</code>
	<code class="p">{</code>
		<code class="n">TextInput</code> <code class="n">x</code> <code class="k">when</code> <code class="kt">string</code><code class="p">.</code><code class="n">IsNullOrWhiteSpace</code><code class="p">(</code><code class="n">x</code><code class="p">.</code><code class="n">Input</code><code class="p">)</code> <code class="p">=&gt;</code>
		 <code class="k">new</code> <code class="nf">NoInput</code><code class="p">(),</code>
		<code class="n">TextInput</code> <code class="n">x</code> <code class="k">when</code> <code class="kt">int</code><code class="p">.</code><code class="n">TryParse</code><code class="p">(</code><code class="n">x</code><code class="p">.</code><code class="n">Input</code><code class="p">,</code> <code class="k">out</code> <code class="kt">var</code> <code class="n">_</code><code class="p">)=&gt;</code>
		 <code class="k">new</code> <code class="n">IntegerInput</code>
		 <code class="p">{</code>
			 <code class="n">Input</code> <code class="p">=</code> <code class="kt">int</code><code class="p">.</code><code class="n">Parse</code><code class="p">(</code><code class="n">x</code><code class="p">.</code><code class="n">Input</code><code class="p">)</code>
		 <code class="p">},</code>
		<code class="n">TextInput</code> <code class="n">x</code> <code class="p">=&gt;</code> <code class="k">new</code> <code class="n">TextInput</code>
		<code class="p">{</code>
			<code class="n">Input</code> <code class="p">=</code> <code class="n">x</code><code class="p">.</code><code class="n">Input</code>
		<code class="p">}</code>
	<code class="p">};</code>

	<code class="k">return</code> <code class="n">returnValue</code><code class="p">;</code>
<code class="p">}</code>
<code class="p">}</code></pre>

<p>This means that if I want to prompt the user for input, and guarantee that they gave me an interger, it’s now very easy to code:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="kt">int</code> <code class="nf">GetPlayerSpendOnOxen</code><code class="p">()</code>
<code class="p">{</code>
 <code class="kt">var</code> <code class="n">input</code> <code class="p">=</code> <code class="k">this</code><code class="p">.</code><code class="n">UserInteraction</code><code class="p">.</code><code class="n">GetInputFromUser</code><code class="p">(</code><code class="s">"How much do you want to spend on Oxen?"</code><code class="p">);</code>
 <code class="kt">var</code> <code class="n">returnValue</code> <code class="p">=</code> <code class="n">input</code> <code class="k">switch</code>
 <code class="p">{</code>
  <code class="n">IntegerInput</code> <code class="n">ii</code> <code class="p">=&gt;</code> <code class="n">ii</code><code class="p">.</code><code class="n">Input</code><code class="p">,</code>
  <code class="n">_</code> <code class="p">=&gt;</code> <code class="p">{</code>
   <code class="k">this</code><code class="p">.</code><code class="n">UserInteraction</code><code class="p">.</code><code class="n">WriteMessage</code><code class="p">(</code><code class="s">"Try again"</code><code class="p">);</code>
   <code class="k">return</code> <code class="nf">GetPlayerSpendOnOxen</code><code class="p">();</code>
  <code class="p">}</code>
 <code class="p">};</code>

 <code class="k">return</code> <code class="n">returnValue</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>What I’m doing in this code block is prompting the player for input.  Then, I check whether it’s the integer I expected - based on the check already done on it via a discriminated union.  If it’s an integer, great.  Job’s a good ‘un, return that interger.</p>

<p>If not, then the player needs to be prompted to try again, and I call this function again, recursively.  I could add more detail in about capturing and logging any errors received, but I think this demonstrates the principle soundly enough.</p>

<p>Note also, that there isn’t a need for a Try/Catch in this function.  That is already handled by the lower-level function.</p>

<p>There are many, many places this code checking for integer are needed in my Oregon Trail conversion.  Imagine how much code I’ve saved myself by wrapping the integer check into the structure of the return object!</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Generic Unions"><div class="sect1" id="idm45400860379168">
<h1>Generic Unions</h1>

<p>All of the discriminated unions so far are entirely situation specific.  Before wrapping up this chapter, I want to discuss a few options for creating entirely generic, reusable versions of the same idea.</p>

<p>Firstly, let me re-iterate - we can’t have discriminated unions you can simply declare easily, on the fly, like the folks in F# can.  It’s just not a thing we can do.  Sorry.  The best we can do is emulate it as closely as possible, with some sort of boilerplate trade-off.</p>

<p>Here are a couple of functional structures you can use.  There are, incidentally, more advanced ways to use these coming up in the next chapter.  Stay tuned for that.</p>








<section data-type="sect2" data-pdf-bookmark="Maybe"><div class="sect2" id="idm45400859900384">
<h2>Maybe</h2>

<p>If your intention with using a Discriminated Union is to represent that data might not have been found by a function, then the Maybe structure might be the one for you.</p>

<p>Implementations look like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">abstract</code> <code class="k">class</code> <code class="nc">Maybe</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code>
<code class="p">{</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">Something</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="p">:</code> <code class="n">Maybe</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="nf">Something</code><code class="p">(</code><code class="n">T</code> <code class="k">value</code><code class="p">)</code>
 <code class="p">{</code>
  <code class="k">this</code><code class="p">.</code><code class="n">Value</code> <code class="p">=</code> <code class="k">value</code><code class="p">;</code>
 <code class="p">}</code>

 <code class="k">public</code> <code class="n">T</code> <code class="n">Value</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="n">init</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">Nothing</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="p">:</code> <code class="n">Maybe</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code>
<code class="p">{</code>

<code class="p">}</code></pre>

<p>You’re basically using the Maybe abstract as a wrapper around another class, the actual class your function reutrns, but by wrapping it in this manner, you are signalling to the outside world that there may not necessarily be anything returned.</p>

<p>Here’s how you might use it for a function that returns a single object:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="n">Maybe</code><code class="p">&lt;</code><code class="n">DoctorWho</code><code class="p">&gt;</code> <code class="n">GetDoctor</code><code class="p">(</code><code class="kt">int</code> <code class="n">doctorNumber</code><code class="p">)</code>
<code class="p">{</code>
 <code class="k">try</code>
 <code class="p">{</code>
   <code class="k">using</code> <code class="nn">var</code> <code class="n">conn</code> <code class="p">=</code> <code class="k">this</code><code class="p">.</code><code class="n">_connectionFactory</code><code class="p">.</code><code class="n">Make</code><code class="p">();</code>
  <code class="c1">// Dapper query to the db</code>
  <code class="kt">var</code> <code class="n">data</code> <code class="p">=</code> <code class="n">conn</code><code class="p">.</code><code class="n">QuerySingleOrDefault</code><code class="p">&lt;</code><code class="n">Doctor</code><code class="p">&gt;(</code>
   <code class="s">"SELECT * FROM [dbo].[Doctors] WHERE DocNum = @docNum"</code><code class="p">,</code>
   <code class="k">new</code> <code class="p">{</code> <code class="n">docNum</code> <code class="p">=</code> <code class="n">doctorNumber</code> <code class="p">});</code>
   <code class="k">return</code> <code class="n">data</code> <code class="p">==</code> <code class="k">null</code>
    <code class="p">?</code> <code class="k">new</code> <code class="n">Nothing</code><code class="p">&lt;</code><code class="n">DoctorWho</code><code class="p">&gt;();</code>
    <code class="p">:</code> <code class="k">new</code> <code class="n">Something</code><code class="p">&lt;</code><code class="n">DoctorWho</code><code class="p">&gt;(</code><code class="n">data</code><code class="p">);</code>
 <code class="p">}</code>
<code class="k">catch</code><code class="p">(</code><code class="n">Exception</code> <code class="n">e</code><code class="p">)</code>
<code class="p">{</code>
 <code class="k">this</code><code class="p">.</code><code class="n">logger</code><code class="p">.</code><code class="n">LogError</code><code class="p">(</code><code class="n">e</code><code class="p">,</code> <code class="s">"An error occurred getting doctor "</code> <code class="p">+</code> <code class="n">doctorNumber</code><code class="p">);</code>
 <code class="k">return</code> <code class="k">new</code> <code class="n">Nothing</code><code class="p">&lt;</code><code class="n">DoctorWho</code><code class="p">&gt;();</code>
<code class="p">}</code>

<code class="p">}</code></pre>

<p>You’d use that something like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="c1">// William Hartnell.  He's the best!</code>
<code class="kt">var</code> <code class="n">doc</code> <code class="p">=</code> <code class="k">this</code><code class="p">.</code><code class="n">DoctorRepository</code><code class="p">.</code><code class="n">GetDoctor</code><code class="p">(</code><code class="m">1</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">message</code> <code class="p">=</code> <code class="n">doc</code> <code class="k">switch</code>
<code class="p">{</code>
 <code class="n">Something</code><code class="p">&lt;</code><code class="n">DoctorWho</code><code class="p">&gt;</code> <code class="n">s</code> <code class="p">=&gt;</code> <code class="s">"Played by "</code> <code class="p">+</code> <code class="n">s</code><code class="p">.</code><code class="n">Value</code><code class="p">.</code><code class="n">ActorName</code><code class="p">,</code>
 <code class="n">Nothing</code><code class="p">&lt;</code><code class="n">DoctorWho</code><code class="p">&gt;</code> <code class="n">_</code> <code class="p">=&gt;</code> <code class="s">"Unknown Doctor"</code>
<code class="p">};</code></pre>

<p>This doesn’t handle error situations especially well.  A Nothing state at least prevents unhandled exceptions from occurring, and we are logging, but nothing useful has been passed back to the end user.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Result"><div class="sect2" id="idm45400859642688">
<h2>Result</h2>

<p>An alternative to a Maybe is a Result, which represents the possibility that a function might throw an error, instead of returning anything.  It might look like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">abstract</code> <code class="k">class</code> <code class="nc">Result</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code>
<code class="p">{</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">Success</code> <code class="p">:</code> <code class="n">Result</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="n">Success</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;(</code><code class="n">T</code> <code class="k">value</code><code class="p">)</code>
 <code class="p">{</code>
  <code class="k">this</code><code class="p">.</code><code class="n">Value</code> <code class="p">=</code> <code class="k">value</code><code class="p">;</code>
 <code class="p">}</code>

 <code class="k">public</code> <code class="n">T</code> <code class="n">Value</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="n">init</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">Failure</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="p">:</code> <code class="n">Result</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="nf">Failure</code><code class="p">(</code><code class="n">Exception</code> <code class="n">e</code><code class="p">)</code>
 <code class="p">{</code>
  <code class="k">this</code><code class="p">.</code><code class="n">Error</code> <code class="p">=</code> <code class="n">e</code><code class="p">;</code>
 <code class="p">}</code>

 <code class="k">public</code> <code class="n">Exception</code> <code class="n">Error</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="n">init</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code></pre>

<p>Now, the Result version of the “Get Doctor” function looks like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="n">Result</code><code class="p">&lt;</code><code class="n">DoctorWho</code><code class="p">&gt;</code> <code class="n">GetDoctor</code><code class="p">(</code><code class="kt">int</code> <code class="n">doctorNumber</code><code class="p">)</code>
<code class="p">{</code>
 <code class="k">try</code>
 <code class="p">{</code>
   <code class="k">using</code> <code class="nn">var</code> <code class="n">conn</code> <code class="p">=</code> <code class="k">this</code><code class="p">.</code><code class="n">_connectionFactory</code><code class="p">.</code><code class="n">Make</code><code class="p">();</code>
  <code class="c1">// Dapper query to the db</code>
  <code class="kt">var</code> <code class="n">data</code> <code class="p">=</code> <code class="n">conn</code><code class="p">.</code><code class="n">QuerySingleOrDefault</code><code class="p">&lt;</code><code class="n">Doctor</code><code class="p">&gt;(</code>
   <code class="s">"SELECT * FROM [dbo].[Doctors] WHERE DocNum = @docNum"</code><code class="p">,</code>
   <code class="k">new</code> <code class="p">{</code> <code class="n">docNum</code> <code class="p">=</code> <code class="n">doctorNumber</code> <code class="p">});</code>
   <code class="k">return</code> <code class="k">new</code> <code class="n">Success</code><code class="p">&lt;</code><code class="n">DoctorWho</code><code class="p">&gt;(</code><code class="n">data</code><code class="p">);</code>
 <code class="p">}</code>
<code class="k">catch</code><code class="p">(</code><code class="n">Exception</code> <code class="n">e</code><code class="p">)</code>
<code class="p">{</code>
 <code class="k">this</code><code class="p">.</code><code class="n">logger</code><code class="p">.</code><code class="n">LogError</code><code class="p">(</code><code class="n">e</code><code class="p">,</code> <code class="s">"An error occurred getting doctor "</code> <code class="p">+</code> <code class="n">doctorNumber</code><code class="p">);</code>
 <code class="k">return</code> <code class="k">new</code> <code class="n">Failure</code><code class="p">&lt;</code><code class="n">DoctorWho</code><code class="p">&gt;(</code><code class="n">e</code><code class="p">);</code>
<code class="p">}</code>

<code class="p">}</code></pre>

<p>And you might consider using it, something like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="c1">// Sylvester McCoy.  He's the best too!</code>
<code class="kt">var</code> <code class="n">doc</code> <code class="p">=</code> <code class="k">this</code><code class="p">.</code><code class="n">DoctorRepository</code><code class="p">.</code><code class="n">GetDoctor</code><code class="p">(</code><code class="m">7</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">message</code> <code class="p">=</code> <code class="n">doc</code> <code class="k">switch</code>
<code class="p">{</code>
 <code class="n">Success</code><code class="p">&lt;</code><code class="n">DoctorWho</code><code class="p">&gt;</code> <code class="n">s</code> <code class="k">when</code> <code class="n">s</code><code class="p">.</code><code class="n">Value</code> <code class="p">==</code> <code class="k">null</code> <code class="p">=&gt;</code> <code class="s">"Unknown Doctor!"</code><code class="p">,</code>
 <code class="n">Success</code><code class="p">&lt;</code><code class="n">DoctorWho</code><code class="p">&gt;</code> <code class="n">s2</code> <code class="p">=&gt;</code> <code class="s">"Played by "</code> <code class="p">+</code> <code class="n">s2</code><code class="p">.</code><code class="n">Value</code><code class="p">.</code><code class="n">ActorName</code><code class="p">,</code>
 <code class="n">Failure</code><code class="p">&lt;</code><code class="n">DoctorWho</code><code class="p">&gt;</code> <code class="n">e</code> <code class="p">=&gt;</code> <code class="s">"An error occurred: "</code> <code class="n">e</code><code class="p">.</code><code class="n">Error</code><code class="p">.</code><code class="n">Message</code>
<code class="p">};</code></pre>

<p>Now I’m covering the error scenario in one of the possible states of the Discriminated Union, but the burden of null checking falls to the receiving function.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Maybe vs Result"><div class="sect2" id="idm45400859287376">
<h2>Maybe vs Result</h2>

<p>A perfectly valid question at this point - which is better to use?  Maybe or Result?</p>

<p>The Maybe gives a state that informs the user that no data has been found, removing the need for null checks, but effectively silently swallows errors.  It’s better than an unhandled exception, but it could result in unreported bugs.</p>

<p>The Result handles errors elegantly, but puts a burden on the receiving function to check for null.</p>

<p>My personal preference?  This might not be strictly within the standard definition of these structures, but I combine them into one.  I usually have a 3-state Maybe - Something, Nothing, Error.  That handles just about anything the codebase can throw at me.</p>

<p>This would be my personal solution to the problem:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">abstract</code> <code class="k">class</code> <code class="nc">Maybe</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code>
<code class="p">{</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">Something</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="p">:</code> <code class="n">Maybe</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="nf">Something</code><code class="p">(</code><code class="n">T</code> <code class="k">value</code><code class="p">)</code>
 <code class="p">{</code>
  <code class="k">this</code><code class="p">.</code><code class="n">Value</code> <code class="p">=</code> <code class="k">value</code><code class="p">;</code>
 <code class="p">}</code>

 <code class="k">public</code> <code class="n">T</code> <code class="n">Value</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="n">init</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">Nothing</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="p">:</code> <code class="n">Maybe</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code>
<code class="p">{</code>

<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">Error</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="p">:</code> <code class="n">Maybe</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="nf">Error</code><code class="p">(</code><code class="n">Exception</code> <code class="n">e</code><code class="p">)</code>
 <code class="p">{</code>
  <code class="k">this</code><code class="p">.</code><code class="n">CapturedError</code> <code class="p">=</code> <code class="n">e</code><code class="p">;</code>
 <code class="p">}</code>

 <code class="k">public</code> <code class="n">Exception</code> <code class="n">CapturedError</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="n">init</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code></pre>

<p>And I’d use it like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="n">Maybe</code><code class="p">&lt;</code><code class="n">DoctorWho</code><code class="p">&gt;</code> <code class="n">GetDoctor</code><code class="p">(</code><code class="kt">int</code> <code class="n">doctorNumber</code><code class="p">)</code>
<code class="p">{</code>
 <code class="k">try</code>
 <code class="p">{</code>
   <code class="k">using</code> <code class="nn">var</code> <code class="n">conn</code> <code class="p">=</code> <code class="k">this</code><code class="p">.</code><code class="n">_connectionFactory</code><code class="p">.</code><code class="n">Make</code><code class="p">();</code>
  <code class="c1">// Dapper query to the db</code>
  <code class="kt">var</code> <code class="n">data</code> <code class="p">=</code> <code class="n">conn</code><code class="p">.</code><code class="n">QuerySingleOrDefault</code><code class="p">&lt;</code><code class="n">Doctor</code><code class="p">&gt;(</code>
   <code class="s">"SELECT * FROM [dbo].[Doctors] WHERE DocNum = @docNum"</code><code class="p">,</code>
   <code class="k">new</code> <code class="p">{</code> <code class="n">docNum</code> <code class="p">=</code> <code class="n">doctorNumber</code> <code class="p">});</code>
   <code class="k">return</code> <code class="n">data</code> <code class="p">==</code> <code class="k">null</code>
    <code class="p">?</code> <code class="k">new</code> <code class="n">Nothing</code><code class="p">&lt;</code><code class="n">DoctorWho</code><code class="p">&gt;();</code>
    <code class="p">:</code> <code class="k">new</code> <code class="n">Something</code><code class="p">&lt;</code><code class="n">DoctorWho</code><code class="p">&gt;(</code><code class="n">data</code><code class="p">);</code>
 <code class="p">}</code>
<code class="k">catch</code><code class="p">(</code><code class="n">Exception</code> <code class="n">e</code><code class="p">)</code>
<code class="p">{</code>
 <code class="k">this</code><code class="p">.</code><code class="n">logger</code><code class="p">.</code><code class="n">LogError</code><code class="p">(</code><code class="n">e</code><code class="p">,</code> <code class="s">"An error occurred getting doctor "</code> <code class="p">+</code> <code class="n">doctorNumber</code><code class="p">);</code>
 <code class="k">return</code> <code class="k">new</code> <code class="n">Error</code><code class="p">&lt;</code><code class="n">DoctorWho</code><code class="p">&gt;(</code><code class="n">e</code><code class="p">);</code>
<code class="p">}</code>

<code class="p">}</code></pre>

<p>This means the receiving function can now handle all three states elegantly with a pattern matching expression:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="c1">// Peter Capaldi.  The other, other best Doctor!</code>
<code class="kt">var</code> <code class="n">doc</code> <code class="p">=</code> <code class="k">this</code><code class="p">.</code><code class="n">DoctorRepository</code><code class="p">.</code><code class="n">GetDoctor</code><code class="p">(</code><code class="m">12</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">message</code> <code class="p">=</code> <code class="n">doc</code> <code class="k">switch</code>
<code class="p">{</code>
 <code class="n">Nothing</code><code class="p">&lt;</code><code class="n">DoctorWho</code><code class="p">&gt;</code> <code class="n">_</code> <code class="p">=&gt;</code> <code class="s">"Unknown Doctor!"</code><code class="p">,</code>
 <code class="n">Something</code><code class="p">&lt;</code><code class="n">DoctorWho</code><code class="p">&gt;</code> <code class="n">s</code> <code class="p">=&gt;</code> <code class="s">"Played by "</code> <code class="p">+</code> <code class="n">s</code><code class="p">.</code><code class="n">Value</code><code class="p">.</code><code class="n">ActorName</code><code class="p">,</code>
 <code class="n">Error</code><code class="p">&lt;</code><code class="n">DoctorWho</code><code class="p">&gt;</code> <code class="n">e</code> <code class="p">=&gt;</code> <code class="s">"An error occurred: "</code> <code class="n">e</code><code class="p">.</code><code class="n">Error</code><code class="p">.</code><code class="n">Message</code>
<code class="p">};</code></pre>

<p>I find this allows me to provide a full set of responses to any given scenario, when returning from a function that requires a connection to the cold, dark, hungry-wolf-filled world beyond my program, and easily allows a more informative response back to the end user.</p>

<p>Before we finish on this topic, here’s how I’d use that same structure to handle a return type of Enumerable:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="n">Maybe</code><code class="p">&lt;</code><code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">DoctorWho</code><code class="p">&gt;&gt;</code> <code class="n">GetAllDoctors</code><code class="p">()</code>
<code class="p">{</code>
 <code class="k">try</code>
 <code class="p">{</code>
   <code class="k">using</code> <code class="nn">var</code> <code class="n">conn</code> <code class="p">=</code> <code class="k">this</code><code class="p">.</code><code class="n">_connectionFactory</code><code class="p">.</code><code class="n">Make</code><code class="p">();</code>
  <code class="c1">// Dapper query to the db</code>
  <code class="kt">var</code> <code class="n">data</code> <code class="p">=</code> <code class="n">conn</code><code class="p">.</code><code class="n">Query</code><code class="p">&lt;</code><code class="n">Doctor</code><code class="p">&gt;(</code>
   <code class="s">"SELECT * FROM [dbo].[Doctors]"</code><code class="p">);</code>
   <code class="k">return</code> <code class="n">data</code> <code class="p">==</code> <code class="k">null</code> <code class="p">||</code> <code class="p">!</code><code class="n">data</code><code class="p">.</code><code class="n">Any</code><code class="p">()</code>
    <code class="p">?</code> <code class="k">new</code> <code class="n">Nothing</code><code class="p">&lt;</code><code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">DoctorWho</code><code class="p">&gt;&gt;();</code>
    <code class="p">:</code> <code class="k">new</code> <code class="n">Something</code><code class="p">&lt;</code><code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">DoctorWho</code><code class="p">&gt;&gt;(</code><code class="n">data</code><code class="p">);</code>
 <code class="p">}</code>
<code class="k">catch</code><code class="p">(</code><code class="n">Exception</code> <code class="n">e</code><code class="p">)</code>
<code class="p">{</code>
 <code class="k">this</code><code class="p">.</code><code class="n">logger</code><code class="p">.</code><code class="n">LogError</code><code class="p">(</code><code class="n">e</code><code class="p">,</code> <code class="s">"An error occurred getting doctor "</code> <code class="p">+</code> <code class="n">doctorNumber</code><code class="p">);</code>
 <code class="k">return</code> <code class="k">new</code> <code class="n">Error</code><code class="p">&lt;</code><code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">DoctorWho</code><code class="p">&gt;&gt;(</code><code class="n">e</code><code class="p">);</code>
<code class="p">}</code>

<code class="p">}</code></pre>

<p>This allows me to handle the response from the function like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="c1">// Great chaps.  All of them!</code>
<code class="kt">var</code> <code class="n">doc</code> <code class="p">=</code> <code class="k">this</code><code class="p">.</code><code class="n">DoctorRepository</code><code class="p">.</code><code class="n">GetAllDoctors</code><code class="p">();</code>
<code class="kt">var</code> <code class="n">message</code> <code class="p">=</code> <code class="n">doc</code> <code class="k">switch</code>
<code class="p">{</code>
 <code class="n">Nothing</code><code class="p">&lt;</code><code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">DoctorWho</code><code class="p">&gt;&gt;</code> <code class="n">_</code> <code class="p">=&gt;</code> <code class="s">"No Doctors found!"</code><code class="p">,</code>
 <code class="n">Something</code><code class="p">&lt;</code><code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">DoctorWho</code><code class="p">&gt;&gt;</code> <code class="n">s</code> <code class="p">=&gt;</code> <code class="s">"The Doctors were played by: "</code> <code class="p">+</code>
  <code class="kt">string</code><code class="p">.</code><code class="n">Join</code><code class="p">(</code><code class="n">Environment</code><code class="p">.</code><code class="n">NewLine</code><code class="p">,</code> <code class="n">s</code><code class="p">.</code><code class="n">Value</code><code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code><code class="p">.</code><code class="n">ActorName</code><code class="p">),</code>
 <code class="n">Error</code><code class="p">&lt;</code><code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">DoctorWho</code><code class="p">&gt;&gt;</code> <code class="n">e</code> <code class="p">=&gt;</code> <code class="s">"An error occurred: "</code> <code class="n">e</code><code class="p">.</code><code class="n">Error</code><code class="p">.</code><code class="n">Message</code>
<code class="p">};</code></pre>

<p>Once again, nice and elegant, and everything has been considered.  This is an approach I use all the time in my everyday coding, and I hope after reading this chapter that you will too!</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Either"><div class="sect2" id="idm45400859291328">
<h2>Either</h2>

<p>Something and Result - in one form or another - now generically handle the idea of returning from a function where there’s some uncertainty as to how it might behave.  What about scenarios where you might want to return two or more entirely different types?</p>

<p>This is where the Either type comes in.  The syntax isn’t the nicest, but it does work.</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">abstract</code> <code class="k">class</code> <code class="nc">Either</code><code class="p">&lt;</code><code class="n">T1</code><code class="p">,</code> <code class="n">T2</code><code class="p">&gt;</code>
<code class="p">{</code>

<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">Left</code><code class="p">&lt;</code><code class="n">T1</code><code class="p">,</code> <code class="n">T2</code><code class="p">&gt;</code> <code class="p">:</code> <code class="n">Either</code><code class="p">&lt;</code><code class="n">T1</code><code class="p">,</code> <code class="n">T2</code><code class="p">&gt;</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="nf">Left</code><code class="p">(</code><code class="n">T1</code> <code class="k">value</code><code class="p">)</code>
 <code class="p">{</code>
  <code class="n">Value</code> <code class="p">=</code> <code class="k">value</code><code class="p">;</code>
 <code class="p">}</code>

 <code class="k">public</code> <code class="n">T1</code> <code class="n">Value</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="n">init</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">class</code> <code class="nc">Right</code><code class="p">&lt;</code><code class="n">T1</code><code class="p">,</code> <code class="n">T2</code><code class="p">&gt;</code> <code class="p">:</code> <code class="n">Either</code><code class="p">&lt;</code><code class="n">T1</code><code class="p">,</code> <code class="n">T2</code><code class="p">&gt;</code>
<code class="p">{</code>
 <code class="k">public</code> <code class="nf">Right</code><code class="p">(</code><code class="n">T2</code> <code class="k">value</code><code class="p">)</code>
 <code class="p">{</code>
  <code class="n">Value</code> <code class="p">=</code> <code class="k">value</code><code class="p">;</code>
 <code class="p">}</code>

 <code class="k">public</code> <code class="n">T2</code> <code class="n">Value</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="n">init</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code></pre>

<p>I could use it to create a type that might be left or right, like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="n">Either</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="kt">int</code><code class="p">&gt;</code> <code class="n">QuestionOrAnswer</code><code class="p">()</code> <code class="p">=&gt;</code>
 <code class="k">new</code> <code class="nf">Random</code><code class="p">().</code><code class="n">Next</code><code class="p">(</code><code class="m">1</code><code class="p">,</code> <code class="m">6</code><code class="p">)</code> <code class="p">&gt;=</code> <code class="m">4</code>
  <code class="p">?</code> <code class="k">new</code> <code class="n">Left</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="kt">int</code><code class="p">&gt;(</code><code class="s">"What do you get if you mulitply 6 by 9?"</code><code class="p">)</code>
  <code class="p">:</code> <code class="k">new</code> <code class="n">Right</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="kt">int</code><code class="p">&gt;(</code><code class="m">42</code><code class="p">);</code>

<code class="kt">var</code> <code class="n">data</code> <code class="p">=</code> <code class="n">QuestionOrAnswer</code><code class="p">();</code>
<code class="kt">var</code> <code class="n">output</code> <code class="p">=</code> <code class="n">data</code> <code class="k">switch</code>
<code class="p">{</code>
 <code class="n">Left</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="kt">int</code><code class="p">&gt;</code> <code class="n">l</code> <code class="p">=&gt;</code> <code class="s">"The ultimate question was: "</code> <code class="p">+</code> <code class="n">l</code><code class="p">.</code><code class="n">Value</code><code class="p">,</code>
 <code class="n">Right</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="kt">int</code><code class="p">&gt;</code> <code class="n">r</code> <code class="p">=&gt;</code> <code class="s">"The ultimate answer was: "</code> <code class="p">+</code> <code class="n">r</code><code class="p">.</code><code class="n">Value</code><code class="p">.</code><code class="n">ToString</code><code class="p">()</code>
<code class="p">};</code></pre>

<p>You could of course expand this out to have three or more different possible types.  I’m not entirely sure what you’d call each of them, but it’s certainly possible.  There’s just a lot of awkward boilerplate, in that you have to include all of the references to the generic types in a lot of places.  At least it works, though…​</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="idm45400858481376">
<h1>Conclusion</h1>

<p>In this chapter we discussed Discriminated Unions.  What exactly they are, how they are used, and just how incredibly powerful they are as a code feature.</p>

<p>Discriminated Unions can be used to massively cut down on boilerplate code, and make use of a datatype that descriptively represents all possible states of the system, in a way that strongly encourages the receiving function to handle them appropriately.</p>

<p>Discriminated Unions can’t be implemented quite as easily as in F#, or other functional languages, but there are possibilities in C#, at least.</p>

<p>In the next chapter, I’ll be looking into some more advanced functional concepts, which will take Discriminated Unions up to the next level!</p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45400862303440"><sup><a href="ch06.html#idm45400862303440-marker">1</a></sup> let me please re-assure everyone that despite being called “discriminated unions” they bear no connection to anyone’s view of love and/or marriage or to worker’s organizations.</p><p data-type="footnote" id="idm45400862223056"><sup><a href="ch06.html#idm45400862223056-marker">2</a></sup> Didn’t I tell you?  We’re in the travel business now, you and I!  Togther we’ll flog cheap holidays to unsuspecting punters until we retire rich and contented.  That, or carry on doing what we’re doing now.  Either way.</p><p data-type="footnote" id="idm45400862084240"><sup><a href="ch06.html#idm45400862084240-marker">3</a></sup> It’s not London Bridge, that famous one you’re thinking of.  London Bridge is elsewhere.  In Arizona, in fact.  No, really.  Look it up</p><p data-type="footnote" id="idm45400861606272"><sup><a href="ch06.html#idm45400861606272-marker">4</a></sup> N.B - no-one has ever done this.  I’m not aware of a single cat ever being sacrificed in the name of quantum mechanics</p><p data-type="footnote" id="idm45400861605424"><sup><a href="ch06.html#idm45400861605424-marker">5</a></sup> Somehow.  I’ve never really understood this part of it.</p><p data-type="footnote" id="idm45400861604272"><sup><a href="ch06.html#idm45400861604272-marker">6</a></sup> Wow.  What a horrible birthday present that would be.  Thanks, Schrödinger!</p><p data-type="footnote" id="idm45400861305600"><sup><a href="ch06.html#idm45400861305600-marker">7</a></sup> “先生” - It literally means “one who was born earlier”.  Interestingly, if you were to write the same letters in Japanese, it would be pronounced “Sensei”.  I’m a nerd - I love stuff like this!</p><p data-type="footnote" id="idm45400861328768"><sup><a href="ch06.html#idm45400861328768-marker">8</a></sup> Sadly the closest I’ll ever get to him for real.  Do watch some of his Hong-Kong films, if you haven’t already!  I’d start with the Police Story series.</p><p data-type="footnote" id="idm45400860602016"><sup><a href="ch06.html#idm45400860602016-marker">9</a></sup> Just kidding, folks, honest!  Please don’t take me off your Christmas card lists!</p></div></div></section></div>
</div>
</body>
</html>