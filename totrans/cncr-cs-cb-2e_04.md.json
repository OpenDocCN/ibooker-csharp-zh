["```cs\nvoid RotateMatrices(IEnumerable<Matrix> matrices, float degrees)\n{\n  Parallel.ForEach(matrices, matrix => matrix.Rotate(degrees));\n}\n```", "```cs\nvoid InvertMatrices(IEnumerable<Matrix> matrices)\n{\n  Parallel.ForEach(matrices, (matrix, state) =>\n  {\n    if (!matrix.IsInvertible)\n      state.Stop();\n    else\n      matrix.Invert();\n  });\n}\n```", "```cs\nvoid RotateMatrices(IEnumerable<Matrix> matrices, float degrees,\n    CancellationToken token)\n{\n  Parallel.ForEach(matrices,\n      new ParallelOptions { CancellationToken = token },\n      matrix => matrix.Rotate(degrees));\n}\n```", "```cs\n// Note: this is not the most efficient implementation.\n// This is just an example of using a lock to protect shared state.\nint InvertMatrices(IEnumerable<Matrix> matrices)\n{\n  object mutex = new object();\n  int nonInvertibleCount = 0;\n  Parallel.ForEach(matrices, matrix =>\n  {\n    if (matrix.IsInvertible)\n    {\n      matrix.Invert();\n    }\n    else\n    {\n      lock (mutex)\n      {\n        ++nonInvertibleCount;\n      }\n    }\n  });\n  return nonInvertibleCount;\n}\n```", "```cs\n// Note: this is not the most efficient implementation.\n// This is just an example of using a lock to protect shared state.\nint ParallelSum(IEnumerable<int> values)\n{\n  object mutex = new object();\n  int result = 0;\n  Parallel.ForEach(source: values,\n      localInit: () => 0,\n      body: (item, state, localValue) => localValue + item,\n      localFinally: localValue =>\n      {\n        lock (mutex)\n          result += localValue;\n      });\n  return result;\n}\n```", "```cs\nint ParallelSum(IEnumerable<int> values)\n{\n  return values.AsParallel().Sum();\n}\n```", "```cs\nint ParallelSum(IEnumerable<int> values)\n{\n  return values.AsParallel().Aggregate(\n      seed: 0,\n      func: (sum, item) => sum + item\n  );\n}\n```", "```cs\nvoid ProcessArray(double[] array)\n{\n  Parallel.Invoke(\n      () => ProcessPartialArray(array, 0, array.Length / 2),\n      () => ProcessPartialArray(array, array.Length / 2, array.Length)\n  );\n}\n\nvoid ProcessPartialArray(double[] array, int begin, int end)\n{\n  // CPU-intensive processing...\n}\n```", "```cs\nvoid DoAction20Times(Action action)\n{\n  Action[] actions = Enumerable.Repeat(action, 20).ToArray();\n  Parallel.Invoke(actions);\n}\n```", "```cs\nvoid DoAction20Times(Action action, CancellationToken token)\n{\n  Action[] actions = Enumerable.Repeat(action, 20).ToArray();\n  Parallel.Invoke(new ParallelOptions { CancellationToken = token }, actions);\n}\n```", "```cs\nvoid Traverse(Node current)\n{\n  DoExpensiveActionOnNode(current);\n  if (current.Left != null)\n  {\n    Task.Factory.StartNew(\n        () => Traverse(current.Left),\n        CancellationToken.None,\n        TaskCreationOptions.AttachedToParent,\n        TaskScheduler.Default);\n  }\n  if (current.Right != null)\n  {\n    Task.Factory.StartNew(\n        () => Traverse(current.Right),\n        CancellationToken.None,\n        TaskCreationOptions.AttachedToParent,\n        TaskScheduler.Default);\n  }\n}\n\nvoid ProcessTree(Node root)\n{\n  Task task = Task.Factory.StartNew(\n      () => Traverse(root),\n      CancellationToken.None,\n      TaskCreationOptions.None,\n      TaskScheduler.Default);\n  task.Wait();\n}\n```", "```cs\nTask task = Task.Factory.StartNew(\n    () => Thread.Sleep(TimeSpan.FromSeconds(2)),\n    CancellationToken.None,\n    TaskCreationOptions.None,\n    TaskScheduler.Default);\nTask continuation = task.ContinueWith(\n    t => Trace.WriteLine(\"Task is done\"),\n    CancellationToken.None,\n    TaskContinuationOptions.None,\n    TaskScheduler.Default);\n// The \"t\" argument to the continuation is the same as \"task\".\n```", "```cs\nIEnumerable<int> MultiplyBy2(IEnumerable<int> values)\n{\n  return values.AsParallel().Select(value => value * 2);\n}\n```", "```cs\nIEnumerable<int> MultiplyBy2(IEnumerable<int> values)\n{\n  return values.AsParallel().AsOrdered().Select(value => value * 2);\n}\n```", "```cs\nint ParallelSum(IEnumerable<int> values)\n{\n  return values.AsParallel().Sum();\n}\n```"]