- en: Chapter 14\. Scenarios
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章. 场景
- en: In this chapter, we’ll take a look at a variety of types and techniques to address
    some common scenarios when writing concurrent programs. These kinds of scenarios
    could fill up another entire book, so I’ve selected just a few that I’ve found
    the most useful.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍各种类型和技术，以解决编写并发程序时的一些常见场景。这些类型的情况可能填满另一本完整的书，因此我只选择了一些我认为最有用的情况。
- en: 14.1 Initializing Shared Resources
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.1 初始化共享资源
- en: Problem
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have a resource that is shared between multiple parts of your code. This
    resource needs to be initialized the first time it is accessed.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 您有一个在代码的多个部分之间共享的资源。第一次访问该资源时需要对其进行初始化。
- en: Solution
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'The .NET framework includes a type specifically for this purpose: `Lazy<T>`.
    You construct an instance of the `Lazy<T>` type with a factory delegate that is
    used to initialize the instance. The instance is then made available via the `Value`
    property. The following code illustrates the `Lazy<T>` type:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: .NET框架包括一种专门用于此目的的类型：`Lazy<T>`。您可以使用用于初始化实例的工厂委托构造`Lazy<T>`类型的实例。然后，通过`Value`属性使实例可用。以下代码演示了`Lazy<T>`类型：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: No matter how many threads call `UseSharedInteger` simultaneously, the factory
    delegate is only executed once, and all threads wait for the same instance. Once
    it’s created, the instance is cached and all future access to the `Value` property
    returns the same instance (in the preceding example, `MySharedInteger.Value` will
    always be `0`).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 无论多少线程同时调用`UseSharedInteger`，工厂委托只执行一次，并且所有线程都等待相同的实例。创建后，实例被缓存，并且所有对`Value`属性的未来访问都返回相同的实例（在上面的示例中，`MySharedInteger.Value`始终为`0`）。
- en: 'A very similar approach can be used if the initialization requires asynchronous
    work; in this case, you can use a `Lazy<Task<T>>`:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果初始化需要异步工作，可以使用`Lazy<Task<T>>`，可以使用类似的方法：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, the delegate returns a `Task<int>`, that is, an integer value
    determined asynchronously. No matter how many parts of the code call `Value` simultaneously,
    the `Task<int>` is only created once and returned to all callers. Each caller
    then has the option of (asynchronously) waiting until the task completes by passing
    the task to `await`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，委托返回一个`Task<int>`，即一个确定整数值的异步操作。无论代码的哪些部分同时调用`Value`，`Task<int>`只创建一次并返回给所有调用者。然后，每个调用者可以选择（异步地）等待任务完成，方法是将任务传递给`await`。
- en: 'The preceding code is an acceptable pattern, but there are some additional
    considerations. For one, the asynchronous delegate may be executed on any thread
    that calls `Value`, and that delegate will execute within that context. If there
    are different thread types that may call `Value` (e.g., a UI thread and a threadpool
    thread, or two different ASP.NET request threads), then it may be better to always
    execute the asynchronous delegate on a threadpool thread. This is easy enough
    to do by wrapping the factory delegate in a call to `Task.Run`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是一种可接受的模式，但还有一些额外的考虑因素。首先，异步委托可能在调用`Value`的任何线程上执行，并且该委托将在该上下文内执行。如果可能有不同类型的线程调用`Value`（例如，UI线程和线程池线程，或两个不同的ASP.NET请求线程），则始终在线程池线程上执行异步委托可能更好。通过将工厂委托包装在`Task.Run`调用中，可以很容易地实现这一点：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Another consideration is that the `Task<T>` instance is only created once.
    If the asynchronous delegate throws an exception, then the `Lazy<Task<T>>` will
    cache that faulted task. This is seldom desirable; usually it’s better to re-execute
    the delegate the next time the lazy value is requested rather than to cache the
    exception. There isn’t a way to “reset” the `Lazy<T>`, but you can create a new
    class that handles re-creating the `Lazy<T>` instance:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个考虑因素是，`Task<T>`实例只创建一次。如果异步委托抛出异常，则`Lazy<Task<T>>`将缓存该失败的任务。这很少是可取的；通常最好的做法是在下次请求懒惰值时重新执行委托，而不是缓存异常。没有办法“重置”`Lazy<T>`，但可以创建一个新的类来处理重新创建`Lazy<T>`实例的情况：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Discussion
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The final code sample in this recipe is a general code pattern for asynchronous
    lazy initialization, and it’s a bit awkward. The `AsyncEx` library includes an
    `AsyncLazy<T>` type that acts just like a `Lazy<Task<T>>` that executes its factory
    delegate on the thread pool and has an option for retrying on failure. It can
    also be awaited directly, so the declaration and usage look like the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方中的最终代码示例是异步延迟初始化的通用代码模式，有些笨拙。`AsyncEx` 库包含一个名为 `AsyncLazy<T>` 的类型，它就像一个 `Lazy<Task<T>>`，在线程池上执行其工厂委托，并具有失败重试选项。它也可以直接等待，因此声明和使用看起来如下所示：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-19
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The `AsyncLazy<T>` type is in the [`Nito.AsyncEx`](http://bit.ly/nito-async)
    NuGet package.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncLazy<T>` 类型位于 [`Nito.AsyncEx`](http://bit.ly/nito-async) NuGet 包中。'
- en: See Also
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 1](ch01.html#intro) covers basic `async`/`await` programming.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 1 章](ch01.html#intro) 涵盖了基本的 `async`/`await` 编程。'
- en: '[Recipe 13.1](ch13.html#recipe-threadpool) covers scheduling work to the thread
    pool.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 13.1](ch13.html#recipe-threadpool) 涵盖了将工作调度到线程池的方法。'
- en: 14.2 System.Reactive Deferred Evaluation
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.2 System.Reactive 延迟评估
- en: Problem
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create a new source observable whenever someone subscribes to it.
    For example, you want each subscription to represent a different request to a
    web service.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望每次有人订阅时都创建一个新的源可观察对象。例如，您希望每个订阅都代表对 web 服务的不同请求。
- en: Solution
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'The System.Reactive library has an operator `Observable.Defer`, which will
    execute a delegate each time the observable is subscribed to. This delegate acts
    as a factory that creates an observable. The following code uses `Defer` to call
    an asynchronous method every time someone subscribes to the observable:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: System.Reactive 库具有一个名为 `Observable.Defer` 的操作符，该操作符每次订阅可观察对象时都会执行一个委托。该委托充当创建可观察对象的工厂。以下代码使用
    `Defer` 来在每次有人订阅可观察对象时调用一个异步方法：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you execute this code, you should see this output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行此代码，应该会看到以下输出：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Discussion
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Your own code usually does not subscribe to an observable more than once, but
    some System.Reactive operators do in their implementation. For example, the `Observable.While`
    operator will resubscribe to a source sequence as long as its condition is true.
    `Defer` enables you to define an observable that is reevaluated every time a new
    subscription comes in. This is useful if you need to refresh or update the data
    for that observable.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您自己的代码通常不会多次订阅可观察对象，但某些 System.Reactive 操作符在其实现中会这样做。例如，`Observable.While` 操作符会在条件为
    true 时重新订阅源序列。`Defer` 允许您定义一个每次新订阅时都会重新评估的可观察对象。如果需要刷新或更新该可观察对象的数据，则这非常有用。
- en: See Also
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Recipe 8.6](ch08.html#recipe-rx-interop-async) covers wrapping asynchronous
    methods in observables.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 8.6](ch08.html#recipe-rx-interop-async) 涵盖了在可观察对象中包装异步方法。'
- en: 14.3 Asynchronous Data Binding
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.3 异步数据绑定
- en: Problem
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You are retrieving data asynchronously and need to data-bind the results (e.g.,
    in the ViewModel of a Model-View-ViewModel design).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在异步检索数据，并需要将结果数据绑定（例如，在 Model-View-ViewModel 设计的 ViewModel 中）。
- en: Solution
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: When a property is used in data binding, it must immediately and synchronously
    return some kind of result. If the actual value needs to be determined asynchronously,
    you can return a default result and later update the property with the correct
    value.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据绑定使用属性时，必须立即且同步返回某种结果。如果实际值需要异步确定，可以返回默认结果，稍后使用正确的值更新属性。
- en: Keep in mind that asynchronous operations may fail as well as succeed. Since
    you’re writing a ViewModel, you could use data binding to update the UI for an
    error condition as well.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，异步操作可能会失败，也可能会成功。由于您正在编写 ViewModel，因此可以使用数据绑定来更新 UI 以反映错误条件。
- en: 'The `Nito.Mvvm.Async library` has a type `NotifyTask` that can be used for
    this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Nito.Mvvm.Async library` 中有一个名为 `NotifyTask` 的类型可用于此目的：'
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It’s possible to data-bind to various properties on the `NotifyTask<T>` property,
    as this example shows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将数据绑定到`NotifyTask<T>`属性的各种属性，如本示例所示：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The MvvmCross library has a `MvxNotifyTask` that is much the same as `NotifyTask<T>`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: MvvmCross 库中有一个 `MvxNotifyTask`，与 `NotifyTask<T>` 非常相似。
- en: Discussion
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'It’s also possible to write your own data-binding wrapper instead of using
    the one from the libraries. The following code gives the basic idea:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以编写自己的数据绑定包装器，而不使用库中的一个。以下代码提供了基本思路：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note that this has an empty `catch` clause on purpose: that code specifically
    does want to catch all exceptions and handle those conditions via data binding.
    Also, the code explicitly does not want to use `ConfigureAwait(false)` because
    the `PropertyChanged` event should be raised on the UI thread.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里有一个空的`catch`子句是有意为之：该代码明确希望捕获所有异常，并通过数据绑定处理这些情况。此外，该代码明确不希望使用`ConfigureAwait(false)`，因为应在
    UI 线程上引发`PropertyChanged`事件。
- en: Tip
  id: totrans-51
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The `NotifyTask` type is in the [`Nito.Mvvm.Async`](http://bit.ly/nito-m-async)
    NuGet package. The `MvxNotifyTask` type is in the [`MvvmCross`](http://bit.ly/m-cross)
    NuGet package.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`NotifyTask`类型位于[`Nito.Mvvm.Async`](http://bit.ly/nito-m-async) NuGet 包中。`MvxNotifyTask`类型位于[`MvvmCross`](http://bit.ly/m-cross)
    NuGet 包中。'
- en: See Also
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 1](ch01.html#intro) covers basic `async`/`await` programming.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html#intro) 讨论了基本的`async`/`await`编程。'
- en: '[Recipe 2.7](ch02.html#recipe-async-configureawait) covers using `ConfigureAwait`.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[配方 2.7](ch02.html#recipe-async-configureawait) 讨论了如何使用`ConfigureAwait`。'
- en: 14.4 Implicit State
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.4 隐式状态
- en: Problem
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have some state variables that need to be accessible at different points
    in your call stack. For example, you have a current operation identifier that
    you want to use for logging but that you don’t want to add as a parameter to every
    method.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一些状态变量，需要在调用堆栈的不同点访问。例如，你有一个当前操作标识符，你希望用于日志记录，但不想将其添加为每个方法的参数。
- en: Solution
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: The best solution is to add parameters to your methods, store data as members
    of a class, or use dependency injection to provide data to the different parts
    of your code. In some situations, however, that would overcomplicate the code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳解决方案是向方法添加参数，将数据存储为类的成员，或使用依赖注入为代码的不同部分提供数据。然而，在某些情况下，这样做会使代码变得过于复杂。
- en: 'The `AsyncLocal<T>` type enables you to give your state an object where it
    can live on a logical “context.” The following code shows how to use `AsyncLocal<T>`
    to set an operation identifier that is later read by a logging method:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncLocal<T>`类型使您能够为状态提供一个对象，可以在逻辑“上下文”中存储它。以下代码展示了如何使用`AsyncLocal<T>`设置稍后由日志记录方法读取的操作标识符：'
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Many times, it’s useful to have a more complex data structure (such as a stack
    of values) in a single `AsyncLocal<T>` instance. This is possible, with one caveat:
    you should only store immutable data in the `AsyncLocal<T>`. Whenever you need
    to update the data, then you should overwrite the existing value. It is often
    helpful to hide the `AsyncLocal<T>` inside a helper type that ensures the stored
    data is immutable and updated correctly:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，在单个`AsyncLocal<T>`实例中拥有更复杂的数据结构（如值堆栈）是很有用的。这是可能的，但有一个重要注意事项：您应该只在`AsyncLocal<T>`中存储不可变数据。每当需要更新数据时，应该覆盖现有值。通常有助于将`AsyncLocal<T>`隐藏在一个助手类型中，以确保存储的数据是不可变的并且正确更新：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The wrapper type ensures that the underlying data is immutable and that new
    values are pushed onto the stack. It also provides a convenient `IDisposable`
    way of popping values off the stack.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 封装类型确保底层数据是不可变的，并且新值被推送到堆栈上。它还提供了一种便利的`IDisposable`方法来从堆栈中弹出值。
- en: Discussion
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Older code may use the `ThreadStatic` attribute for contextual state used by
    synchronous code. When converting older code to be asynchronous, `AsyncLocal<T>`
    is a prime candidate for replacing `ThreadStaticAttribute`. `AsyncLocal<T>` works
    for both synchronous and asynchronous code, and should be the default choice for
    implicit state in modern applications.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 旧代码可能使用`ThreadStatic`属性来处理同步代码使用的上下文状态。将旧代码转换为异步时，`AsyncLocal<T>`是替换`ThreadStaticAttribute`的首选。`AsyncLocal<T>`可用于同步和异步代码，并应该是现代应用程序中隐式状态的默认选择。
- en: See Also
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 1](ch01.html#intro) covers basic `async`/`await` programming.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html#intro) 讨论了基本的`async`/`await`编程。'
- en: '[Chapter 9](ch09.html#collections) covers several immutable collections, for
    when you need to store complex data as implicit state.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9章](ch09.html#collections) 讨论了几种不可变集合，用于在需要将复杂数据存储为隐式状态时使用。'
- en: 14.5 Identical Synchronous and Asynchronous Code
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.5 同步和异步代码相同
- en: Problem
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have some code that needs to be exposed through both synchronous and asynchronous
    APIs, but you don’t want to duplicate the logic. You’ll often encounter this situation
    when updating code to be asynchronous, but existing synchronous consumers cannot
    (yet) be changed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一些代码需要通过同步和异步 API 公开，但你不想重复逻辑。在更新代码以支持异步时，经常会遇到这种情况，但现有的同步消费者不能（暂时）改变。
- en: Solution
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: If you can, try to organize your code along modern design guidelines, like Ports
    and Adapters (Hexagonal Architecture), which separate your business logic from
    side effects such as I/O. If you can get into that situation, then there’s no
    need to expose both synchronous and asynchronous APIs for anything; your business
    logic would always be synchronous, and the I/O would always be asynchronous.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，请尝试按照现代设计指南组织您的代码，例如端口和适配器（六边形架构），将业务逻辑与I/O等副作用分离。如果能够达到这种情况，那么不需要为任何事情同时暴露同步和异步API；您的业务逻辑总是同步的，而I/O总是异步的。
- en: However, that’s a very lofty goal, and in The Real World, brownfield code can
    be messy, and there’s rarely time to make it perfect before adopting asynchronous
    code. Existing APIs often need to be maintained for backwards compatibility, even
    if they were poorly designed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是一个非常崇高的目标，在**现实世界**中，棕地代码可能会很混乱，在采用异步代码之前很少有时间使其完美。即使现有的API设计不佳，也经常需要维护以保持向后兼容性。
- en: There is no perfect solution in this scenario. Many developers attempt to have
    the synchronous code call the asynchronous code, or have the asynchronous code
    call the synchronous code, but both of those approaches are anti-patterns. The
    Boolean Argument Hack is the one that I tend to prefer in this situation. It’s
    a way to keep all the logic in a single method while exposing both synchronous
    and asynchronous APIs.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，没有完美的解决方案。许多开发人员尝试使同步代码调用异步代码，或使异步代码调用同步代码，但这两种方法都是反模式。在这种情况下，我倾向于使用布尔参数黑客。这是一种在单个方法中保持所有逻辑的方法，同时暴露同步和异步API。
- en: 'The primary idea of the Boolean Argument Hack is that there’s a private core
    method containing the logic. That core method has an asynchronous signature and
    takes a boolean argument determining whether the core method should be asynchronous
    or not. If the boolean argument specifies that the core method should be synchronous,
    then it *must* return an already-completed task. Then you can write both asynchronous
    and synchronous API methods that forward to the core method:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔参数黑客的主要思想是，有一个包含逻辑的私有核心方法。该核心方法具有异步签名，并带有布尔参数，确定核心方法是否应该是异步的。如果布尔参数指定核心方法应该是同步的，那么它必须返回一个已完成的任务。然后，您可以编写同时转发到核心方法的异步和同步API方法：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The asynchronous API `DelayAndReturnAsync` invokes `DelayAndReturnCore` with
    the boolean `sync` parameter set to `false`; this means that `DelayAndReturnCore`
    may behave asynchronously, and it uses `await` on the underlying asynchronous
    “delay” API `Task.Delay`. The task returned from `DelayAndReturnCore` is returned
    directly to the caller of `DelayAndReturnAsync`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 异步API `DelayAndReturnAsync` 调用带有布尔参数 `sync` 设置为 `false` 的 `DelayAndReturnCore`；这意味着
    `DelayAndReturnCore` 可能会异步执行，并使用底层异步的“延迟”API `Task.Delay`。从 `DelayAndReturnCore`
    返回的任务会直接返回给 `DelayAndReturnAsync` 的调用者。
- en: The synchronous API `DelayAndReturn` invokes `DelayAndReturnCore` with the boolean
    `sync` parameter set to `true`; this means that `DelayAndReturnCore` *must* behave
    synchronously, and it uses the underlying synchronous “delay” API `Thread.Sleep`.
    The task returned by `DelayAndReturnCore` must already be complete, so it’s safe
    to extract the result. `DelayAndReturn` uses `GetAwaiter().GetResult()` to retrieve
    the result from the task; this avoids an `AggregateException` wrapper that can
    happen if it were to use the `Task<T>.Result` property.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 同步API `DelayAndReturn` 调用带有布尔参数 `sync` 设置为 `true` 的 `DelayAndReturnCore`；这意味着
    `DelayAndReturnCore` 必须同步执行，并使用底层同步的“延迟”API `Thread.Sleep`。`DelayAndReturnCore`
    返回的任务必须已经完成，因此可以安全地提取结果。`DelayAndReturn` 使用 `GetAwaiter().GetResult()` 从任务中检索结果；这样做可以避免使用
    `Task<T>.Result` 属性时可能出现的 `AggregateException` 包装器。
- en: Discussion
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: This isn’t an ideal solution, but it’s one that can help with real-world applications.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个理想的解决方案，但它可以帮助处理现实世界的应用场景。
- en: Now, a few caveats for this solution. The most disastrous problems will arise
    if the `Core` method doesn’t properly honor its `sync` parameter. If the `Core`
    method ever returns an incomplete task when `sync` is `true`, then the synchronous
    API can easily deadlock; the only reason the synchronous API can block on its
    task is that it knows that the task is already complete. Similarly, if the `Core`
    method blocks a thread when `sync` is `false`, then the application isn’t as efficient
    as it should be.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个解决方案，现在需要注意一些注意事项。如果`Core`方法未能正确地尊重其`sync`参数，可能会出现最严重的问题。如果`Core`方法在`sync`为`true`时返回了一个不完整的任务，那么同步API很容易会发生死锁；同步API可以阻塞其任务的唯一原因是它知道任务已经完成。类似地，如果`Core`方法在`sync`为`false`时阻塞了线程，那么应用程序的效率就不如预期。
- en: One improvement that could be made to this solution is to add a check in the
    synchronous API, validating that the returned task is in fact completed. If it’s
    ever not completed, then there is a serious coding bug.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 可以对这个解决方案进行改进的一个方法是在同步API中添加一个检查，验证返回的任务实际上是已完成的。如果它曾经未完成过，那么这就是一个严重的编码错误。
- en: See Also
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Chapter 1](ch01.html#intro) covers basic `async`/`await` programming, including
    a discussion of deadlocks that can happen when blocking on asynchronous code in
    general.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html#intro)介绍了基本的`async`/`await`编程，包括讨论一般情况下在异步代码中阻塞可能导致的死锁问题。'
- en: 14.6 Railway Programming with Dataflow Meshes
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.6 数据流网格中的铁路编程
- en: Problem
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have a dataflow mesh set up, but some data items fail to process. You want
    to respond to these errors in a way that keeps your dataflow mesh operational.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经建立了一个数据流网格，但有些数据项未能处理。您希望以一种方式响应这些错误，以保持数据流网格的正常运行。
- en: Solution
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: By default, if a block encounters an exception when processing a data item,
    that block will fault, preventing it from processing any more data items. The
    core idea of this solution is to treat exceptions as just another kind of data.
    If the dataflow mesh operates on types that can be *either* an exception *or*
    data, then the mesh can remain operational even when exceptions occur and continue
    to process other data items.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果一个块在处理数据项时遇到异常，那么该块将会故障，导致无法继续处理任何数据项。这个解决方案的核心思想是将异常视为另一种数据。如果数据流网格操作的类型可以是*异常*或*数据*，那么即使出现异常，网格仍然可以继续运行并处理其他数据项。
- en: 'This is sometimes called “railway” programming because the items in the mesh
    can be viewed as traveling on one of two separate tracks. There’s the normal “data”
    track: if everything goes perfectly, the item stays on the “data” track and travels
    through the mesh, being transformed and operated on, until it reaches the end
    of the mesh. The second track is the “error” track; in any block, if an exception
    is raised when processing an item, that exception transfers to the “error” track
    and travels through the mesh. Exception items aren’t processed; they are just
    passed on from block to block, so they also reach the end of the mesh. The terminal
    blocks in the mesh end up receiving a sequence of items, each of which is either
    a data item or exception item; a data item represents data that has completed
    the entire mesh successfully, and an exception item represents a processing error
    at some point in the mesh.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编程方式有时被称为“铁路”编程，因为网格中的项目可以被视为沿着两条单独的轨道行驶。第一条是正常的“数据”轨道：如果一切顺利，项目将留在“数据”轨道上，并通过网格进行转换和操作，直到到达网格的末端。第二条轨道是“错误”轨道；在任何块中，如果处理项目时出现异常，该异常将转移到“错误”轨道并通过网格传递。异常项目不会被处理；它们只是从块传递到块，因此它们也会到达网格的末端。网格中的终端块最终会接收到一系列项目，每个项目都是数据项或异常项；数据项表示已成功完成整个网格的数据，异常项表示网格某个点的处理错误。
- en: In order to set up this kind of “railway” programming, you first need to define
    a type that represents either a data item or an exception. If you want to use
    a pre-built one, there are a few available. This kind of type is common in the
    functional programming community, where it’s commonly called `Try` or `Error`
    or `Exceptional`, and is a special case of the `Either` monad. I’ve defined my
    own `Try<T>` type that you can use as an example; it’s in the [`Nito.Try` NuGet
    package](https://www.nuget.org/packages/Nito.Try/) and the [source code is on
    GitHub](https://github.com/StephenCleary/Try).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置这种“铁路”编程，首先需要定义一个表示数据项或异常的类型。如果要使用预先构建的类型，有几种可用。这种类型在函数式编程社区中很常见，通常称为`Try`或`Error`或`Exceptional`，是`Either`单子的特例。我定义了自己的`Try<T>`类型作为示例；它在[`Nito.Try`
    NuGet包](https://www.nuget.org/packages/Nito.Try/)中，源代码在[GitHub上](https://github.com/StephenCleary/Try)。
- en: 'Once you have some kind of `Try<T>` type, setting up the mesh is a bit tedious
    but not terrible. The type of each dataflow block should be changed from `T` to
    `Try<T>`, and any processing in that block should be done by mapping one `Try<T>`
    value to another. With my `Try<T>` type, this is done by calling `Try<T>.Map`.
    I find it helpful to define small factory methods for railway-oriented dataflow
    blocks instead of having that extra code inline. The following code is an example
    of a helper method that constructs a `TransformBlock` that operates on `Try<T>`
    values by calling `Try<T>.Map`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有某种`Try<T>`类型，设置网格有点繁琐，但并不可怕。每个数据流块的类型应从`T`更改为`Try<T>`，并且该块中的任何处理都应通过将一个`Try<T>`值映射到另一个来完成。使用我的`Try<T>`类型，通过调用`Try<T>.Map`来完成这一点。我发现定义小工厂方法用于铁路导向数据流块而不是在行内添加额外代码会很有帮助。以下代码是一个帮助方法的示例，它构造一个在`Try<T>`值上操作的`TransformBlock`，通过调用`Try<T>.Map`：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With helpers like these in place, the dataflow mesh creation code is more straightforward:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些帮助程序，数据流网格创建代码会更加简单：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Discussion
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Railway programming is a great way to avoid faulting dataflow blocks. Since
    railway programming is a functional programming construct based on monads, it’s
    a bit awkward when translated to .NET, but it is usable. If you have a dataflow
    mesh that needs to be fault-tolerant, then railway programming is certainly worth
    it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 铁路编程是避免数据流块故障的好方法。由于铁路编程是基于单子的函数式编程构造，将其转换为.NET时有些笨拙，但可用。如果您有一个需要容错的数据流网格，那么铁路编程绝对值得一试。
- en: See Also
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 5.2](ch05.html#recipe-dataflow-errors) covers the normal way exceptions
    fault blocks and can propagate through a mesh if railway programming is not used.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 5.2](ch05.html#recipe-dataflow-errors)讲述了异常如何影响块的正常方式，并可以通过网格传播，如果不使用铁路编程。 '
- en: 14.7 Throttling Progress Updates
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.7 节流进度更新
- en: Problem
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have a long-running operation that reports progress, and you display progress
    updates in the UI. But the progress updates arrive too rapidly, causing your UI
    to be unresponsive.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您有一个长时间运行的操作，报告进度，并在UI中显示进度更新。但进度更新过于频繁，导致UI无响应。
- en: Solution
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Consider the following code, which reports progress very quickly:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，它非常快速地报告进度：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can execute this code from a GUI application by wrapping it in `Task.Run`
    and passing in an `IProgress<T>`. The following example code is for WPF, but the
    same concepts apply regardless of GUI platform (WPF, Xamarin, or Windows Forms):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将其包装在`Task.Run`中并传入`IProgress<T>`，从GUI应用程序执行此代码。以下示例代码适用于WPF，但相同的概念适用于任何GUI平台（WPF、Xamarin或Windows
    Forms）：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code will cause the UI to become unresponsive for quite some time, about
    20 seconds on my machine, and then suddenly the UI is responsive again and only
    displays the `"Done! Result:"` message. The intermediate progress reports were
    never seen. What is happening is that the background code is sending progress
    reports to the UI thread extremely quickly, so fast that after running for only
    3 seconds, it takes the UI thread another 17 seconds or so just to process all
    those progress reports, updating that label over and over. Lastly, the UI thread
    updates the label one last time with the `"Done! Result:"` values, and then *finally*
    has time to repaint the screen, displaying the updated label value to the user.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会导致UI在我的机器上变得无响应相当长的时间，大约20秒，然后突然UI重新响应并且只显示`"Done! Result:"`消息。中间的进度报告从未被看到。发生的情况是后台代码非常快地向UI线程发送进度报告，以至于在运行仅3秒后，UI线程需要大约额外的17秒来处理所有这些进度报告，一遍又一遍地更新标签。最后，UI线程最后一次更新标签的值为`"Done!
    Result:"`，然后*最终*有时间重新绘制屏幕，向用户显示更新后的标签值。
- en: The first thing to realize is that we need to throttle the progress reports.
    It’s the only way to ensure the UI has enough time to repaint itself between progress
    updates. The next thing to realize is that we want to throttle based on *time*,
    not the *number* of reports. While you may be tempted to throttle the progress
    reports by only sending one out of every hundred or so, this isn’t ideal for reasons
    discussed in the “Discussion” section.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要意识到的是，我们需要节流进度报告。这是确保UI在进度更新之间有足够时间重新绘制自身的唯一方法。接下来要意识到的是，我们希望基于*时间*而不是*报告数量*来进行节流。虽然您可能会试图通过仅发送每百个或更多报告中的一个来节流进度报告，但出于“讨论”部分所述的原因，这并不理想。
- en: The fact that we want to deal with *time* indicates that we should consider
    System.Reactive. And, in fact, System.Reactive has operators specifically designed
    to throttle on time. So, it sounds like System.Reactive will play a role in this
    solution.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望处理*时间*表明我们应该考虑System.Reactive。事实上，System.Reactive具有专门设计用于按时间节流的操作符。因此，System.Reactive似乎在这个解决方案中将发挥作用。
- en: 'To get started, you can define an `IProgress<T>` implementation that raises
    an event for each progress report, and then create an observable that receives
    those progress reports by wrapping that event:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，您可以定义一个`IProgress<T>`实现，该实现为每个进度报告触发一个事件，然后通过包装该事件创建一个可观察对象来接收这些进度报告：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The method `ObservableProgress.Create<T>` will create a pair: one `IObservable<T>`
    and one `IProgress<T>`, where all progress reports sent to the `IProgress<T>`
    will be sent to the subscribers of the `IObservable<T>`. We now have an observable
    stream for our progress reports; the next step is to throttle it.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`ObservableProgress.Create<T>`将创建一对：一个`IObservable<T>`和一个`IProgress<T>`，其中所有发送到`IProgress<T>`的进度报告将发送到`IObservable<T>`的订阅者。现在我们有了进度报告的可观察流；下一步是对其进行节流。
- en: We want to update the UI slowly enough that it can remain responsive, and we
    want to update the UI quickly enough that users can see the updates. Human perception
    is considerably slower than computer displays, so there’s a large window of possible
    values. If you prefer true readability, throttling to one update every second
    or so may be sufficient. If you prefer more real-time feedback, I find that one
    update every 100 or 200 milliseconds (ms) is fast enough that the user sees that
    something is happening fast and gets a general sense of the progress details,
    while still being slow enough for the UI to remain responsive.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望更新UI的速度足够慢，以使其保持响应，并且我们希望更新UI的速度足够快，以便用户能看到更新。人类感知远远慢于计算机显示，因此有很大的可能性。如果您更喜欢真实的可读性，每秒节流一次更新可能足够了。如果您更喜欢更实时的反馈，我发现每100或200毫秒（ms）节流一次更新足够快，以至于用户看到事情正在迅速发生，并获得进度详细信息的一般感觉，同时仍然足够慢以使UI保持响应。
- en: 'Another point to keep in mind is that progress reports can be raised from other
    threads—in this case, they are raised from a background thread. The throttling
    should be done as close to the source as possible, so we want to keep the throttling
    on the background thread. However, the code that updates the UI needs to be run
    on the UI thread. With this in mind, you can define a `CreateForUi` method that
    handles both the throttling and the transition to the UI thread:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个要记住的点是，进度报告可能会从其他线程引发—在这种情况下，它们是从后台线程引发的。节流应尽可能靠近源头完成，因此我们希望在后台线程上保持节流。然而，更新
    UI 的代码需要在 UI 线程上运行。考虑到这一点，您可以定义一个 `CreateForUi` 方法，处理节流和转换到 UI 线程：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now you have a helper method that will throttle your progress updates before
    they hit the UI. You can use the helper method in the previous code example in
    your button click handler:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您有一个辅助方法，可以在更新到达用户界面之前对其进行节流。您可以在前面的代码示例中的按钮点击处理程序中使用这个辅助方法：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The new code calls our helper method `ObservableProgress.CreateForUi`, which
    creates the `IObservable<T>` and `IProgress<T>` pair. The code subscribes to the
    progress updates and keeps that going until `Solve` is done. Finally, it passes
    the `IProgress<T>` to the long-running `Solve` method. As `Solve` calls `IProgress<T>.Report`,
    those reports are first sampled within a 100 ms time window, with one update every
    100-ms being forwarded to the UI thread and used to update the label text. The
    UI is now fully responsive!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 新代码调用了我们的辅助方法 `ObservableProgress.CreateForUi`，它创建了 `IObservable<T>` 和 `IProgress<T>`
    对。代码订阅进度更新，并保持到 `Solve` 完成为止。最后，它将 `IProgress<T>` 传递给长时间运行的 `Solve` 方法。当 `Solve`
    调用 `IProgress<T>.Report` 时，这些报告首先在 100 毫秒的时间窗口内进行采样，每 100 毫秒转发一次更新到 UI 线程，并用于更新标签文本。现在，UI
    完全响应！
- en: Discussion
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: This recipe is a fun combination of other recipes in this book! No new techniques
    were introduced; we just walked through which recipes to combine to come up with
    this solution.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是本书中其他配方的有趣组合！没有引入新技术；我们只是介绍了如何组合这些配方以得出这个解决方案。
- en: An alternative solution to this problem that you may see a lot in the wild is
    the “modulus solution.” The idea behind this solution is that `Solve` itself has
    to throttle its own progress updates; for example, if the code only wanted to
    process one update for every 100 actual updates, then the code may use some modulus
    technique like `if (value % 100 == 0) progress?.Report(value);`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在野外经常见到的这个问题的另一种替代解决方案是“模数解决方案”。这个解决方案的背后思想是 `Solve` 本身必须节流自己的进度更新；例如，如果代码只想处理每
    100 个实际更新的一个更新，那么代码可能使用一些模数技术，如 `if (value % 100 == 0) progress?.Report(value);`。
- en: There are a couple of problems with the modulus approach. The first is that
    there’s no “correct” modulus value; usually, the developer tries various values
    until it works well on their own laptop. The same code, however, may not behave
    well when running on a client’s massive server or inside an underpowered virtual
    machine. In addition, different platforms and environments cache very differently,
    which can make code run much faster (or slower) than expected. And, of course,
    the capabilities of the “latest” computer hardware do change over time. So the
    modulus value only ends up being a guess; it’s not going to be correct everywhere
    and throughout all time.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 采用模数方法存在几个问题。首先，没有“正确”的模数值；通常，开发人员会尝试各种值，直到在他们自己的笔记本电脑上运行良好。然而，同样的代码在运行在客户的大型服务器或不足的虚拟机内时可能表现不佳。此外，不同的平台和环境缓存方式差异很大，这可能导致代码运行比预期快得多（或慢得多）。当然，“最新”的计算机硬件的能力随时间而变化。因此，模数值最终只是一个猜测；它不会在所有地方和所有时间都正确。
- en: The other problem with the modulus approach is that it’s trying to fix the problem
    in the wrong part of the code. This problem is purely a UI issue; it’s the UI
    that has a problem, and it’s the UI layer that should provide the fix for it.
    In the example code for this recipe, `Solve` represents some background business
    processing logic; it shouldn’t be concerned with UI-specific issues. A Console
    app may want to use a very different modulus than a WPF app.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 模数方法的另一个问题是，它试图在代码的错误部分修复问题。这个问题纯粹是一个 UI 问题；UI 存在问题，并且 UI 层应该为其提供解决方法。在这个配方的示例代码中，`Solve`
    表示一些后台业务处理逻辑；它不应关心 UI 特定的问题。控制台应用程序可能希望使用与 WPF 应用程序非常不同的模数。
- en: 'The one thing that the modulus approach is correct on is that it’s best to
    throttle the updates *before* sending the updates to the UI thread. The solution
    in this recipe also does this: it throttles the updates immediately and synchronously
    on the background thread before sending them to the UI thread. By injecting its
    own `IProgress<T>` implementation, the UI is able to do its own throttling without
    requiring any changes to the `Solve` method itself.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 模数方法正确的一点是，在将更新发送到UI线程之前最好对更新进行节流。本示例中的解决方案也是如此：在将更新发送到UI线程之前，它立即在后台线程上同步地节流更新。通过注入自己的`IProgress<T>`实现，UI能够在不需要对`Solve`方法本身进行任何更改的情况下进行自己的节流。
- en: See Also
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 2.3](ch02.html#recipe-async-progress) covers using `IProgress<T>` to
    report progress from long-running operations.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 2.3](ch02.html#recipe-async-progress)涵盖了使用`IProgress<T>`从长时间运行的操作报告进度。'
- en: '[Recipe 13.1](ch13.html#recipe-threadpool) covers using `Task.Run` to run synchronous
    code on a threadpool thread.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 13.1](ch13.html#recipe-threadpool)涵盖了使用`Task.Run`在线程池线程上运行同步代码。'
- en: '[Recipe 6.1](ch06.html#recipe-rx-events) covers using `FromEvent` to wrap .NET
    events into observables.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 6.1](ch06.html#recipe-rx-events)涵盖了使用`FromEvent`将.NET事件包装成可观察对象。'
- en: '[Recipe 6.4](ch06.html#recipe-rx-throttle) covers using `Sample` to throttle
    observables by time.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 6.4](ch06.html#recipe-rx-throttle)涵盖了使用`Sample`按时间节流可观察对象。'
- en: '[Recipe 6.2](ch06.html#recipe-rx-observeon) covers using `ObserveOn` to move
    observable notifications to another context.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 6.2](ch06.html#recipe-rx-observeon)涵盖了使用`ObserveOn`将可观察通知移动到另一个上下文。'
