<html><head></head><body><section data-pdf-bookmark="Unity Lab #2: Write C# Code for Unity" data-type="afterword" epub:type="afterword"><div class="appendix" id="unity_lab_hash2_write_chash_code_for_uni">
<h1>Unity Lab #2: Write C# Code for Unity</h1>
<p><a data-primary="Unity" data-secondary="writing C# code for" data-type="indexterm" id="idm46402345581752"/>Unity isn’t <em>just</em> a powerful, cross-platform engine and editor for building 2D and 3D games and simulations. It’s also a <strong>great way to get practice writing C# code</strong>.</p>
<p>In the last Unity Lab, you learned how to navigate around Unity and your 3D space, and started to create and explore GameObjects. Now it’s time to write some code to take control of your GameObjects. The whole goal of that lab was to get you oriented in the Unity editor (and give you an easy way to remind yourself of how to navigate around it if you need it).</p>
<p>In this Unity Lab, you’ll start writing code to control your GameObjects. You’ll write C# code to explore concepts you’ll use in the rest of the Unity Labs, starting with adding a method that rotates the 8 Ball GameObject that you created in the last Unity Lab. You’ll also start using the Visual Studio debugger with Unity to sleuth out problems in your games.</p>
<section data-pdf-bookmark="C# scripts add behavior to your GameObjects" data-type="sect1"><div class="sect1" id="chash_scripts_add_behavior_to_your_gameo">
<h1>C# scripts add behavior to your GameObjects</h1>
<p><a data-primary="C#" data-secondary="scripts" data-type="indexterm" id="idm46402345578904"/><a data-primary="GameObjects" data-secondary="adding behavior to" data-type="indexterm" id="idm46402345571848"/>Now that you can add a GameObject to your scene, you need a way to make it, well, do stuff. That’s where your C# skills come in. Unity uses <strong>C# scripts</strong> to define the behavior of everything in the game.</p>
<p>This Unity Lab will introduce tools that you’ll use to work with C# and Unity. You’re going to build a simple “game” that’s really just a little bit of visual eye candy: you’ll make your 8 ball fly around the scene. Start by going to Unity Hub and <strong>opening the same project</strong> that you created in the first Unity Lab.</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/214fig01.png"/>
<h6/>
</div></figure>
<p>Here’s what you’ll do in this Unity Lab:</p>
<ol>
<li><p><strong>Attach a C# script to your GameObject.</strong> You’ll add a Script component to your Sphere GameObject. When you add it, Unity will create a class for you. You’ll modify that class so that it drives the 8 ball sphere’s behavior.</p></li>
<li><p><strong>Use Visual Studio to edit the script.</strong> Remember how you set the Unity editor’s preferences to make Visual Studio the script editor? That means you can just double-click on the script in the Unity editor and it will open up in Visual Studio.</p></li>
<li><p><strong>Play your game in Unity.</strong> There’s a Play button at the top of the screen. When you press it, it starts executing all of the scripts attached to the GameObjects in your scene. You’ll use that button to run the script that you added to the sphere.</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/214fig02.png"/>
<h6/>
</div></figure></li>
<li><p><strong>Use Unity and Visual Studio together to debug your script.</strong> You’ve already seen how valuable the Visual Studio debugger is when you’re trying to track down problems in your C# code. Unity and Visual Studio work together seamlessly so you can add breakpoints, use the Locals window, and work with the other familiar tools in the Visual Studio debugger while your game is running.</p></li>
</ol>
</div></section>
<section data-pdf-bookmark="Add a C# script to your GameObject" data-type="sect1"><div class="sect1" id="add_a_chash_script_to_your_gameobject">
<h1>Add a C# script to your GameObject</h1>
<p><a data-primary="C#" data-secondary="scripts" data-type="indexterm" id="idm46402345565048"/><a data-primary="GameObjects" data-secondary="adding C# script to" data-type="indexterm" id="idm46402345560664"/><a data-primary="Inspector window (Unity)" data-type="indexterm" id="idm46402345559656"/><a data-primary="Project window" data-type="indexterm" id="idm46402345558888"/>Unity is more than an amazing platform for building 2D and 3D games. Many people use it for artistic work, data visualization, augmented reality, and more. It’s especially valuable to you, as a C# learner, because you can write code to control everything that you see in a Unity game. That makes Unity <strong>a great tool for learning and exploring C#</strong>.</p>
<p>Let’s start using C# and Unity right now. Make sure the Sphere GameObject is selected, then <strong>click the Add Component button</strong> at the bottom of the Inspector window.</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/215fig01.png"/>
<h6/>
</div></figure>
<p>When you click it, Unity pops up a window with all of the different kinds of components that you can add—and there are <strong><em>a lot</em></strong> of them. <strong>Choose “New script”</strong> to add a new C# script to your Sphere GameObject. You’ll be prompted for a name. <strong>Name your script</strong> <code><strong>BallBehaviour</strong></code>.</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/215fig02.png"/>
<h6/>
</div></figure>
<p>Click the “Create and Add” button to add the script. You’ll see a component called <em>Ball Behaviour (Script)</em> appear in the Inspector window.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="watch_itexclamation_mark-idd0002">
<h5><span class="inlineimage"><img alt="Images" src="assets/watchit.png"/></span> Watch it!</h5>
<p><strong>Unity code uses British spelling.</strong></p>
<p><em>If you’re American (like us), or if you’re used to the US spelling of the word <strong>behavior</strong>, you’ll need to be careful when you work with Unity scripts because the class names often feature the British spelling <strong>behaviour</strong></em>.</p>
</div></aside>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/215fig03.png"/>
<h6/>
</div></figure>
<p>You’ll also see the C# script in the Project window.</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/215fig04.png"/>
<h6/>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><strong>The <span style="color:#9D9EA0;"><u>Project window</u></span> gives you a folder-based view of your project. Your Unity project is made up of files: media files, data files, C# scripts, textures, and more. Unity calls these files <span style="color:#9D9EA0;"><u>assets</u></span>. The Project window was displaying a folder called Assets when you right-clicked inside it to import your texture, so Unity added it to that folder.</strong></p>
</div>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><span style="color:#9D9EA0;">Did you notice a folder called Materials appeared in the Project window as soon as you dragged the 8 ball texture onto your sphere?</span></p>
</div>
</div></section>
<section data-pdf-bookmark="Write C# code to rotate your sphere" data-type="sect1"><div class="sect1" id="write_chash_code_to_rotate_your_sphere">
<h1>Write C# code to rotate your sphere</h1>
<p><a data-primary="Hierarchy window (Unity)" data-type="indexterm" id="idm46402345534248"/>In the first lab, you told Unity to use Visual Studio as its external script editor. So go ahead and <strong>double-click on your new C# script</strong>. When you do, <strong><em>Unity will open your script in Visual Studio</em></strong>. Your C# script contains a class called BallBehaviour with two empty methods called Start and Update:</p>
<pre data-type="programlisting"><span style="color:#9D9EA0;">using System.Collections;</span>
<span style="color:#9D9EA0;">using System.Collections.Generic;</span>
using UnityEngine;

public class BallBehaviour : MonoBehaviour
{
    <span style="color:#9D9EA0;">// Start is called before the first frame update</span>
    void Start()
    {
 
    }
    <span style="color:#9D9EA0;">// Update is called once per frame</span>
    void Update()
    {
 
    }
}</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><strong>You opened your C# script in Visual Studio by clicking on it in the <span style="color:#9D9EA0;"><u>Hierarchy window</u></span>, which shows you a list of every GameObject in the current scene. When Unity created your project, it added a scene called SampleScene with a camera and a light. You added a sphere to it, so your Hierarchy window will show all of those things.</strong></p>
</div>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><span style="color:#9D9EA0;">If Unity didn’t launch Visual Studio and open your C# script in it, go back to the beginning of Unity Lab 1 and make sure you followed the steps to set the External Tools preferences.</span></p>
</div>
<p>Here’s a line of code that will rotate your sphere. <strong><u>Add it</u> to your Update method</strong>:</p>
<pre data-type="programlisting"> <strong>transform.Rotate(Vector3.up, 180 * Time.deltaTime);</strong></pre>
<p>Now <strong>go back to the Unity editor</strong> and click the Play button in the toolbar to start your game: <span class="inlineimage"><img alt="Images" src="assets/216fig02.png"/></span></p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/216fig03.png"/>
<h6/>
</div></figure>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="your_code_up_close">
<h5><span class="inlineimage"><img alt="Images" src="assets/zoom.png"/></span> Your Code Up Close</h5>
<pre data-type="programlisting"><strong><span style="color:#9D9EA0;">using System.Collections;</span></strong>
<strong><span style="color:#9D9EA0;">using System.Collections.Generic;</span></strong>
<strong>using UnityEngine;</strong></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a data-primary="frame rate" data-type="indexterm" id="idm46402345508792"/><a data-primary="frames" data-type="indexterm" id="idm46402345507448"/><a data-primary="time.deltaTime (Unity)" data-type="indexterm" id="idm46402345506568"/><a data-primary="transform.Rotate method (Unity)" data-type="indexterm" id="idm46402345505768"/><a data-primary="Update method (Unity)" data-type="indexterm" id="idm46402345504888"/><strong>You learned about namespaces in <a href="ch02.html#dive_into_chash_statementscomma_classesc">#dive_into_chash_statementscomma_classesc</a>. When Unity created the file with the C# script, it added using lines at the top so it can use code in the UnityEngine namespace and other commonly used namespaces</strong></p>
</div>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><strong>A <span style="color:#9D9EA0;"><u>frame</u></span> is a fundamental concept of animation. Unity draws one still frame, then draws the next one very quickly, and your eye interprets changes in these frames as movement. Unity calls the Update method for every GameObject before each frame so it can move, rotate, or make any other changes that it needs to make. A faster computer will run at a higher <span style="color:#9D9EA0;"><u>frame rate</u></span>—or number of frames per second (FPS)—than a slower one.</strong></p>
</div>
<pre data-type="programlisting"><strong>public class BallBehaviour : MonoBehaviour</strong>
<strong>{</strong>
  <strong><span style="color:#9D9EA0;">// Start is called before the first frame update</span></strong>
  <strong>void Start()</strong>
  <strong>{</strong>
  <strong>}</strong>

  <strong><span style="color:#9D9EA0;">// Update is called once per frame</span></strong>
  <strong>void Update()</strong>
  <strong>{</strong>
     <strong>transform.Rotate(Vector3.up, 180 * Time.deltaTime);</strong>
  <strong>}</strong>
<strong>}</strong></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><strong>The <span style="color:#9D9EA0;"><u>transform.Rotate method</u></span> causes a GameObject to rotate. The first parameter is the axis to rotate around. In this case, your code used Vector3.up, which tells it to rotate around the Y axis. The second parameter is the number of degrees to rotate.</strong></p>
</div>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><strong>Different computers will run your game at different frame rates. If it’s running at 30 FPS, we want one rotation every 60 frames. If it’s running at 120 FPS, it should rotate once every 240 frames. Your game’s frame rate may even change if it needs to run more or less complex code.</strong></p>
<p><strong>That’s where the <span style="color:#9D9EA0;"><u>Time.deltaTime value</u></span> comes in handy. Every time the Unity engine calls a GameObject’s Update method—once per frame—it sets Time.deltaTime to the fraction of a second since the last frame. Since we want our ball to do a full rotation every two seconds, or 180 degrees per second, all we need to do is multiply it by Time.deltaTime to make sure that it rotates exactly as much as it needs to for that frame.</strong></p>
</div>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><span style="color:#9D9EA0;">Time.deltaTime is static—and like we saw in <a href="ch03.html#objectshellipget_orientedexclamation_mar">#objectshellipget_orientedexclamation_mar</a>, you don’t need an instance of the Time class to use it.</span></p>
</div>
<p>Inside your Update method, multiplying any value by Time.deltaTime turns it into that value per second.</p>
</div></aside>
</div></section>
<section data-pdf-bookmark="Add a breakpoint and debug your game" data-type="sect1"><div class="sect1" id="add_a_breakpoint_and_debug_your_game">
<h1>Add a breakpoint and debug your game</h1>
<p><a data-primary="breakpoints" data-type="indexterm" id="idm46402345515544"/><a data-primary="debugging mode" data-type="indexterm" id="idm46402345480808"/><a data-primary="frames" data-type="indexterm" id="idm46402345480168"/><a data-primary="hit count" data-type="indexterm" id="idm46402345479400"/>Let’s debug your Unity game. First <strong>stop your game</strong> if it’s still running (by pressing the Play button again). Then switch over to Visual Studio, and <strong>add a breakpoint</strong> on the line that you added to the Update method.</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/218fig01.png"/>
<h6/>
</div></figure>
<p>Now find the button at the top of Visual Studio that starts the debugger:</p>
<ul>
<li><p>In Windows it looks like this—<span class="inlineimage"><img alt="Images" src="assets/218fig02.png"/></span>—or choose Debug &gt;&gt; Start Debugging (F5) from the menu</p></li>
<li><p>In macOS it looks like this—<span class="inlineimage"><img alt="Images" src="assets/218fig03.png"/></span>—or choose Run &gt;&gt; Start Debugging (<span class="inlineimage"><img alt="Images" src="assets/218fig04.png"/></span>)</p></li>
</ul>
<p>Click that button to <strong>start the debugger</strong>. Now switch back to the Unity editor. If this is the first time you’re debugging this project, the Unity editor will pop up a dialog window with these buttons:</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/218fig05.png"/>
<h6/>
</div></figure>
<p>Press the “Enable debugging for this session” button (or if you want to keep that pop-up from appearing again, press “Enable debugging for all projects” ). Visual Studio is now <strong><em>attached</em></strong> to Unity, which means it can debug your game.</p>
<p>Now <strong>press the Play button in Unity</strong> to start your game. Since Visual Studio is attached to Unity, it <strong><em>breaks immediately</em></strong> on the breakpoint that you added, just like with any other breakpoint you’ve set.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><span style="color:#9D9EA0;">Congratulations, you’re now debugging a game!</span></p>
</div>
</div></section>
<section data-pdf-bookmark="Use a hit count to skip frames" data-type="sect1"><div class="sect1" id="use_a_hit_count_to_skip_frames">
<h1>Use a hit count to skip frames</h1>
<p>Sometimes it’s useful to let your game run for a while before your breakpoint stops it. For example, you might want your game to spawn and move its enemies before your breakpoint hits. Let’s tell your breakpoint to break every 500 frames. You can do that by adding a <strong>Hit Count condition</strong> to your breakpoint:</p>
<ul>
<li><p>On Windows, right-click on the breakpoint dot (<span class="inlineimage"><img alt="Images" src="assets/218fig07.png"/></span>) at the left side of the line, choose <strong>Conditions</strong> from the pop-up menu, select <em>Hit Count</em> and <em>Is a multiple of</em> from the dropdowns, and enter 500 in the box:</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/218fig08.png"/>
<h6/>
</div></figure></li>
<li><p>On macOS, right-click on the breakpoint dot (<span class="inlineimage"><img alt="Images" src="assets/218fig09.png"/></span>), choose <strong>Edit breakpoint…</strong> from the menu, then choose <em>When hit count is a multiple of</em> from the dropdown and enter 500 in the box:</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/218fig10.png"/>
<h6/>
</div></figure></li>
</ul>
<p>Now the breakpoint will only pause the game every 500 times the Update method is run—or every 500 frames­. So if your game is running at 60 FPS, that means when you press Continue the game will run for a little over 8 seconds before it breaks again. <strong>Press Continue, then switch back to Unity</strong> and watch the ball spin until the breakpoint breaks.</p>
</div></section>
<section data-pdf-bookmark="Use the debugger to understand Time.deltaTime" data-type="sect1"><div class="sect1" id="use_the_debugger_to_understand_timedotde">
<h1>Use the debugger to understand Time.deltaTime</h1>
<p><a data-primary="debugger" data-secondary="time.deltaTime and" data-type="indexterm" id="idm46402345447848"/><a data-primary="time.deltaTime (Unity)" data-type="indexterm" id="idm46402345446360"/>You’re going to be using Time.deltaTime in many of the Unity Labs projects. Let’s take advantage of your breakpoint and use the debugger to really understand what’s going on with this value.</p>
<p>While your game is paused on the breakpoint in Visual Studio, <strong>hover over Time.deltaTime</strong> to see the fraction of a second that elapsed since the previous frame (you’ll need to put your mouse cursor over <code><strong>deltaTime</strong></code>). Then <strong>add a watch for Time.deltaTime</strong> by selecting Time.deltaTime and choosing Add Watch from the right-mouse menu.</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/219fig01.png"/>
<h6/>
</div></figure>
<p><strong>Continue debugging</strong> (F5 on Windows, <span class="inlineimage"><img alt="Images" src="assets/219fig02.png"/></span> on macOS), just like with the other apps you’ve debugged), to resume your game. The ball will start rotating again, and after another 500 frames the breakpoint will trigger again. You can keep running the game for 500 frames at a time. Keep your eye on the Watch window each time it breaks.</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/219fig03.png"/>
<h6/>
</div></figure>
<p><strong>Stop debugging</strong> (Shift+F5 on Windows, <span class="inlineimage"><img alt="Images" src="assets/219fig02.png"/></span> on macOS) to stop your program. Then <strong>start debugging again</strong>.Since your game is still running, the breakpoint will <u>continue to work</u> when you reattach Visual Studio to Unity. Once you’re done debugging, <strong>toggle your breakpoint again</strong> so the IDE will still keep track of it but not break when it’s hit. <strong>Stop debugging</strong> one more time to detach from Unity.</p>
<p>Go back to Unity and <strong>stop your game</strong>—and save it, because the Play button <u>doesn’t</u> automatically save the game.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><span style="color:#9D9EA0;">The Play button in Unity starts and stops your game. Visual Studio will stay attached to Unity even when the game is stopped.</span></p>
</div>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="brain_power-idd0011">
<h5><span class="inlineimage"><img alt="Images" src="assets/brainpower.png"/></span> Brain Power</h5>
<p>Debug your game again and hover over “Vector3.up” to inspect its value—you’ll have to put your mouse cursor over up. It has a value of (0.0, 1.0, 0.0). What do you think that means?</p>
</div></aside>
</div></section>
<section data-pdf-bookmark="Add a cylinder to show where the Y axis is" data-type="sect1"><div class="sect1" id="add_a_cylinder_to_show_where_the_y_axis">
<h1>Add a cylinder to show where the Y axis is</h1>
<p><a data-primary="cylinders (Unity)" data-type="indexterm" id="idm46402345425400"/><a data-primary="Inspector window (Unity)" data-type="indexterm" id="idm46402345424152"/>Your sphere is rotating around the Y axis at the very center of the scene. Let’s add a very tall and very skinny cylinder to make it visible. <strong><em>Create a new cylinder</em></strong> by choosing <em>3D Object &gt;&gt; Cylinder</em> from the GameObject menu. Make sure it’s selected in the Hierarchy window, then look at the Inspector window and check that Unity created it at position (0, 0, 0)—if not, use the context menu (<span class="inlineimage"><img alt="Images" src="assets/220fig01.png"/></span>) to reset it.</p>
<p>Let’s make the cylinder tall and skinny. Choose the Scale tool from the toolbar: either click on it (<span class="inlineimage"><img alt="Images" src="assets/220fig02.png"/></span>) or press the R key. You should see the Scale Gizmo appear on your cylinder:</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/220fig03.png"/>
<h6/>
</div></figure>
<p>Click and drag the green cube up to elongate your cylinder along the Y axis. Then click on the red cube and drag it toward the cylinder to make it very narrow along the X axis, and do the same with the blue cube to make it very narrow along the Z axis. Watch the Transform panel in the Inspector as you change the cylinder’s scale—the Y scale will get larger, and the X and Z values will get much smaller.</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/220fig04.png"/>
<h6/>
</div></figure>
<p><strong>Click on the X label in the Scale row in the Transform panel and drag up and down.</strong> Make sure you click the actual X label to the left of the input box with the number. When you click the label it turns blue, and a blue box appears around the X value. As you drag your mouse up and down, the number in the box goes up and down, and the Scene view updates the scale in as you change it. Look closely as you drag—the scale can be positive and negative.</p>
<p>Now <strong>select the number inside the X box and type .1</strong>—the cylinder gets very skinny. Press Tab and type 20, then press Tab again and type .1, and press Enter.</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/220fig05.png"/>
<h6/>
</div></figure>
<p>Now your sphere has a very long cylinder going through it that shows the Y axis where Y = 0.</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/220fig06.png"/>
<h6/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Add fields to your class for the rotation angle and speed" data-type="sect1"><div class="sect1" id="add_fields_to_your_class_for_the_rotatio">
<h1>Add fields to your class for the rotation angle and speed</h1>
<p><a data-primary="classes" data-secondary="adding fields to" data-type="indexterm" id="idm46402345411544"/><a data-primary="fields" data-secondary="adding to classes" data-type="indexterm" id="idm46402345404248"/>In <a href="ch03.html#objectshellipget_orientedexclamation_mar">#objectshellipget_orientedexclamation_mar</a> you learned how C# classes can have <strong>fields</strong> that store values methods can use. Let’s modify your code to use fields. Add these four lines just under the class declaration, <strong>immediately after the first curly brace</strong> <code><strong>{:</strong></code></p>
<pre data-type="programlisting"><span style="color:#9D9EA0;">public class BallBehaviour : MonoBehaviour</span>
<span style="color:#9D9EA0;">{</span>
    <strong>public float XRotation = 0;</strong>
    <strong>public float YRotation = 1;</strong>
    <strong>public float ZRotation = 0;</strong>
    <strong>public float DegreesPerSecond = 180;</strong></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><strong>These are just like the fields that you added to the projects in <a href="ch03.html#objectshellipget_orientedexclamation_mar">#objectshellipget_orientedexclamation_mar</a> and <a href="ch04.html#types_and_references_getting_the_referen">#types_and_references_getting_the_referen</a>. They’re variables that keep track of their values—each time Update is called it reuses the same field over and over again.</strong></p>
</div>
<p>The XRotation, YRotation, and ZRotation fields each contain a value between 0 and 1, which you’ll combine to create a <strong>vector</strong> that determines the direction that the ball will rotate:</p>
<pre data-type="programlisting"> new Vector3(XRotation, YRotation, ZRotation)</pre>
<p>The DegreesPerSecond field contains the number of degrees to rotate per second, which you’ll multiply by Time.deltaTime just like before. <strong>Modify your Update method to use the fields.</strong> This new code creates a Vector3 variable called <code><strong>axis</strong></code> and passes it to the transform.Rotate method:</p>
<pre data-type="programlisting"><span style="color:#9D9EA0;"> void Update()</span>
<span style="color:#9D9EA0;"> {</span>
     <strong>Vector3 axis = new Vector3(XRotation, YRotation, ZRotation);</strong>
     <strong>transform.Rotate(axis, DegreesPerSecond * Time.deltaTime);</strong>
<span style="color:#9D9EA0;"> }</span></pre>
<p>Select the Sphere in the Hierarchy window. Your fields now show up in the Script component. When the Script component renders fields, it <u>adds spaces between the capital letters</u> to make them easier to read.</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/221fig03.png"/>
<h6/>
</div></figure>
<p>Run your game again. <strong><em>While it’s running</em></strong>, select the Sphere in the Hierarchy window and change the degrees per second to 360 or 90—the ball starts to spin at twice or half the speed. <u>Stop your game</u>—and the field will <u>reset to 180</u>.</p>
<p><u>While the game is stopped</u>, use the Unity editor to change the X Rotation to field to 1 and the Y Rotation field to 0. Start your game—the ball will rotate away from you. Click the X Rotation label and drag it up and down to change the value while the game is running. As soon as the number turns negative, the ball starts rotating toward you. Make it positive again and it starts rotating away from you.</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/221fig04.png"/>
<h6/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Use Debug.DrawRay to explore how 3D vectors work" data-type="sect1"><div class="sect1" id="use_debugdotdrawray_to_explore_how_3d_ve">
<h1>Use Debug.DrawRay to explore how 3D vectors work</h1>
<p><a data-primary="3D vectors (Unity)" data-type="indexterm" id="idm46402345378296"/><a data-primary="Debug.DrawRay" data-type="indexterm" id="idm46402345376504"/>A <strong>vector</strong> is a value with a <strong>length</strong> (or magnitude) and a <strong>direction</strong>. If you ever learned about vectors in a math class, you probably saw lots of diagrams like this one of a 2D vector:</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/222fig01.png"/>
<h6/>
</div></figure>
<p>That’s not hard to understand…on an intellectual level. But even those of us who took a math class that covered vectors don’t always have an <strong><em>intuitive</em></strong> grasp of how vectors work, especially in 3D. Here’s another area where we can use C# and Unity as a tool for learning and exploration.</p>
</div></section>
<section data-pdf-bookmark="Use Unity to visualize vectors in 3D" data-type="sect1"><div class="sect1" id="use_unity_to_visualize_vectors_in_3d">
<h1>Use Unity to visualize vectors in 3D</h1>
<p>You’re going to add code to your game to help you really “get” how 3D vectors work. Start by having a closer look at the first line of your Update method:</p>
<pre data-type="programlisting"> Vector3 axis = new Vector3(XRotation, YRotation, ZRotation);</pre>
<p>What does this line tell us about the vector?</p>
<ul>
<li><p><strong>It has a type: Vector3.</strong> Every variable declaration starts with a type. Instead of using string, int, or bool, you’re declaring it with the type Vector3. This is a type that Unity uses for 3D vectors.</p></li>
<li><p><strong>It has a variable name:</strong> <code><strong>axis</strong>.</code></p></li>
<li><p><strong>It uses the</strong> <code><strong>new</strong></code> <strong>keyword to create a Vector3.</strong> It uses the XRotation, YRotation, and ZRotation fields to create a vector with those values.</p></li>
</ul>
<p>So what does that 3D vector look like? There’s no need to guess—we can use one of Unity’s useful debugging tools to draw the vector for us. <strong>Add this line of code to the end of your Update method:</strong></p>
<pre data-type="programlisting">   <span style="color:#9D9EA0;">void Update()</span>
   <span style="color:#9D9EA0;">{</span>
       <span style="color:#9D9EA0;">Vector3 axis = new Vector3(XRotation, YRotation, ZRotation);</span>
       <span style="color:#9D9EA0;">transform.Rotate(axis, DegreesPerSecond * Time.deltaTime);</span>
       <strong>Debug.DrawRay(Vector3.zero, axis, Color.yellow);</strong>
   <span style="color:#9D9EA0;">}</span></pre>
<p>The Debug.DrawRay method is a special method that Unity provides to help you debug your games. It draws a <strong>ray</strong>—which is a vector that goes from one point to another—and takes parameters for its start point, end point, and color. There’s one catch: <strong><em>the ray <u>only</u> appears in the Scene view</em></strong>. The methods in Unity’s Debug class are designed so that they don’t interfere with your game. They typically only affect how your game interacts with the Unity editor.</p>
</div></section>
<section data-pdf-bookmark="Run the game to see the ray in the Scene view" data-type="sect1"><div class="sect1" id="run_the_game_to_see_the_ray_in_the_scene">
<h1>Run the game to see the ray in the <u>Scene view</u></h1>
<p><a data-primary="Scene view (Unity)" data-type="indexterm" id="idm46402345352216"/>Now run your game again. You won’t see anything different in the Game view because Debug.DrawRay is a tool for debugging that doesn’t affect gameplay at all. Use the Scene tab to <strong>switch to the <u>Scene</u> view</strong>. You may also need to <strong>reset the Wide layout</strong> by choosing Wide from the Layout dropdown.</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/223fig01.png"/>
<h6/>
</div></figure>
<p>Now you’re back in the familiar Scene view. Do these things to get a real sense of how 3D vectors work:</p>
<ul>
<li><p>Use the Inspector to <strong>modify the BallBehaviour script’s fields</strong>. Set the X Rotation to 0, Y Rotation to 0, and <strong>Z Rotation to 3</strong>. You should now see a yellow ray coming directly out of the Z axis and the ball rotating around it (remember, the ray only shows up in the Scene view).</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/223fig02.png"/>
<h6/>
</div></figure>
</li>
<li><p>Set the Z Rotation back to 3. Experiment with dragging the X Rotation and Y Rotation values to see what they do to the ray. Make sure to reset the Transform component each time you change them.</p></li>
<li><p>Use the Hand tool and the Scene Gizmo to get a better view. Click the X cone on the Scene Gizmo to set it to the view from the right. Keep clicking the cones on the Scene Gizmo until you see the view from the front. It’s easy to get lost—you can <strong>reset the Wide layout to get back to a familiar view</strong>.</p></li>
</ul>
</div></section>
<section data-pdf-bookmark="Add a duration to the ray so it leaves a trail" data-type="sect1"><div class="sect1" id="add_a_duration_to_the_ray_so_it_leaves_a">
<h1>Add a duration to the ray so it leaves a trail</h1>
<p>You can add a fourth argument to your Debug.DrawRay method call that specifies the number of seconds the ray should stay on the screen. Add <strong>.5f</strong> to make each ray stay on screen for half a second:</p>
<pre data-type="programlisting"> <span style="color:#9D9EA0;">Debug.DrawRay(Vector3.zero, axis, Color.yellow,</span> <strong>.5f</strong><span style="color:#9D9EA0;">);</span></pre>
<p>Now run the game again and switch to the Scene view. Now when you drag the numbers up and down, you’ll see a trail of rays left behind. This looks really interesting, but more importantly, it’s a great tool to visualize 3D vectors.</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/223fig03.png"/>
<h6/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Rotate your ball around a point in the scene" data-type="sect1"><div class="sect1" id="rotate_your_ball_around_a_point_in_the_s">
<h1>Rotate your ball around a point in the scene</h1>
<p>Your code calls the transform.Rotate method to rotate your ball around its center, which changes its X, Y, and Z rotation values. <strong>Select Sphere in the Hierarchy window and change its X position to 5</strong> in the Transform component. Then <strong>use the context menu (</strong><span class="inlineimage"><img alt="Images" src="assets/224fig01.png"/></span><strong>) in the BallBehaviour Script component</strong> to reset its fields. Run the game again—now the ball will be at position (5, 0, 0) and rotating around its own Y axis.</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/224fig02.png"/>
<h6/>
</div></figure>
<p>Let’s modify the Update method to use a different kind of rotation. Now we’ll make the ball rotate around the center point of the scene, coordinate (0, 0, 0), using the <strong>transform.RotateAround method</strong>, which rotates a GameObject around a point in the scene. (This is <em>different</em> from the transform.Rotate method you used earlier, which rotates a GameObject around its center.) Its first parameter is the point to rotate around. We’ll use <strong>Vector3.zero</strong> for that parameter, which is a shortcut for writing <code><strong>new Vector3(0, 0, 0)</strong></code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><span style="color:#9D9EA0;">This new Update method rotates the ball around the point (0, 0, 0) in the scene.</span></p>
</div>
<p>Here’s the new Update method:</p>
<pre data-type="programlisting"><span style="color:#9D9EA0;">void Update()</span>
<span style="color:#9D9EA0;">{</span>
    <strong>Vector3 axis = new Vector3(XRotation, YRotation, ZRotation);</strong>
    <strong>transform.RotateAround(Vector3.zero, axis, DegreesPerSecond * Time.deltaTime);</strong>
    <span style="color:#9D9EA0;">Debug.DrawRay(Vector3.zero, axis, Color.yellow, .5f);</span>
<span style="color:#9D9EA0;">}</span></pre>
<p>Now run your code. This time it rotates the ball in a big circle around the center point:</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/224fig04.png"/>
<h6/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Use Unity to take a closer look at rotation and vectors" data-type="sect1"><div class="sect1" id="use_unity_to_take_a_closer_look_at_rotat">
<h1>Use Unity to take a closer look at rotation and vectors</h1>
<p><a data-primary="Scene view (Unity)" data-type="indexterm" id="idm46402345313704"/>You’re going to be working with 3D objects and scenes in the rest of the Unity Labs throughout the book. Even those of us who spend a lot of time playing 3D video games don’t have a perfect feel for how vectors and 3D objects work, and how to move and rotate in a 3D space. Luckily, Unity is a great tool to <strong>explore how 3D objects work</strong>. Let’s start experimenting right now.</p>
<p>While your code is running, try changing parameters to experiment with the rotation:</p>
<ul>
<li><p><strong>Switch back to the Scene view</strong> so you can see the yellow ray that Debug.DrawRay renders in your BallBehaviour.Update method.</p></li>
<li><p>Use the Hierarchy window to <strong>select the Sphere</strong>. You should see its components in the Inspector window.</p></li>
<li><p>Change the <strong>X Rotation, Y Rotation, and Z Rotation values</strong> in the Script component to <strong>10</strong> so you see the vector rendered as a long ray. Use the Hand tool (Q) to rotate the Scene view until you can clearly see the ray.</p></li>
<li><p>Use the Transform component’s context menu (<span class="inlineimage"><img alt="Images" src="assets/225fig01a.png"/></span>) to <strong>reset the Transform component</strong>. Since the center of the sphere is now at the zero point in the scene, (0, 0, 0), it will rotate around its own center.</p></li>
<li><p>Then <strong>change the X position in</strong> the Transform component to <strong>2</strong>. The ball should now be rotating around the vector. You’ll see the ball cast a shadow on the Y axis cylinder as it flies by.</p>
<figure class="informal"><div class="figure">
<img alt="Images" src="assets/225fig01.png"/>
<h6/>
</div></figure></li>
</ul>
<p>Try <strong>repeating the last three steps</strong> for different values of X, Y, and Z rotation, resetting the Transform component each time so you start from a fixed point. Then try clicking the rotation field labels and dragging them up and down—see if you can get a feel for how the rotation works.</p>
<blockquote>
<p>Unity is a great tool to explore how 3D objects work by modifying properties on your GameObjects in real time.</p>
</blockquote>
</div></section>
<section data-pdf-bookmark="Get creative!" data-type="sect1"><div class="sect1" id="get_creativeexclamation_mark-idd0001">
<h1>Get creative!</h1>
<p>This is your chance to <strong>experiment on your own with C# and Unity</strong>. You’ve seen the basics of how you combine C# and Unity GameObjects. Take some time and play around with the different Unity tools and methods that you’ve learned about in the first two Unity Labs. Here are some ideas:</p>
<ul>
<li><p>Add cubes, cylinders, or capsules to your scene. Attach new scripts to them—make sure you give each script a unique name!—and make them rotate in different ways.</p></li>
<li><p>Try putting your rotating GameObjects in different positions around the scene. See if you can make interesting visual patterns out of multiple rotating GameObjects.</p></li>
<li><p>Try adding a light to the scene. What happens when you use transform.rotateAround to rotate the new light around various axes?</p></li>
<li><p>Here’s a quick coding challenge: try using += to add a value to one of the fields in your BallBehaviour script. Make sure you multiply that value by Time.deltaTime. Try adding an <code><strong>if</strong></code> statement that resets the field to 0 if it gets too large.</p></li>
</ul>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><span style="color:#9D9EA0;">Before you run the code, try to figure out what it will do. Does it act the way you expected it to act? Trying to predict how the code you added will act is a great technique for getting better at C#.</span></p>
</div>
<blockquote>
<p>Take the time to experiment with the tools and techniques you just learned. This is a great way to take advantage of Unity and Visual Studio as tools for exploration and learning.</p>
</blockquote>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="bullet_points-idd0009">
<h5>Bullet Points</h5>
<ul>
<li><p>The <strong>Scene Gizmo</strong> always displays the camera’s orientation.</p></li>
<li><p>You can <strong>attach a C# script</strong> to any GameObject. The script’s Update method will be called once per frame.</p></li>
<li><p>The <strong>transform.Rotate method</strong> causes a GameObject to rotate a number of degrees around an axis.</p></li>
<li><p>Inside your Update method, multiplying any value by <strong>Time.deltaTime</strong> turns it into that value per second.</p></li>
<li><p>You can <strong>attach</strong> the Visual Studio debugger to Unity to debug your game while it’s running. It will stay attached to Unity even when your game is not running.</p></li>
<li><p>Adding a <strong>Hit Count condition</strong> to a breakpoint to makes it break after the statement has executed a certain number of times.</p></li>
<li><p>A <strong>field</strong> is a variable that lives inside of a class outside of its methods, and it retains its value between method calls.</p></li>
<li><p>Adding public fields to the class in your Unity script makes the Script component show <strong>input boxes that let you modify those fields</strong>. It adds spaces between capital letters in the field names to make them easier to read.</p></li>
<li><p>You can create 3D vectors using <code><strong>new Vector3</strong></code>. (You learned about the <code><strong>new</strong></code> keyword in <a href="ch03.html#objectshellipget_orientedexclamation_mar">#objectshellipget_orientedexclamation_mar</a>.)</p></li>
<li><p>The <strong>Debug.DrawRay method</strong> draws a vector in the Scene view (but <u>not</u> the Game view). You can use vectors as a debugging tool, but also as a learning tool.</p></li>
<li><p>The <strong>transform.RotateAround method</strong> rotates a GameObject around a point in the scene.</p></li>
</ul>
</div></aside>
</div></section>
</div></section></body></html>