<html><head></head><body><section data-pdf-bookmark="Appendix. Learning Blazor App Projects" data-type="appendix" epub:type="appendix"><div class="appendix" id="appendix">
<h1><span class="label">Appendix. </span>Learning Blazor App Projects</h1>


<p>In this book, we’ve examined Learning Blazor, an app created for the book. The app consists of several projects that serve as isolated bits of functionality. The architecture is discussed in <a data-type="xref" href="ch01.html#perusing-the-app">“Perusing the “Learning Blazor” Sample App”</a>. The source code can be found on <a href="https://oreil.ly/learning-blazor-code">GitHub</a>.</p>

<p>The <em>learning-blazor.sln</em> solution file contains <a data-primary="learning-blazor.sln solution file" data-type="indexterm" id="idm46364998328144"/>several projects that together make up the entire application as a cohesive unit. While each project within the solution is responsible for its core functionality, orchestrating projects with disparate functionality cohesively is a requirement of any successful application. The following sections list the primary projects within the solution and provide topical details about them.</p>






<section data-pdf-bookmark="Web Client" data-type="sect1"><div class="sect1" id="idm46364998327280">
<h1>Web Client</h1>

<p>The client application, named <a data-primary="Web.Client project" data-type="indexterm" id="idm46364998326144"/>simply Web.Client, is a Blazor WebAssembly project targeting the <code>Microsoft.NET.Sdk.BlazorWebAssembly</code> software development kit (SDK). The web project is responsible for all of the user interactions and experiences. Through pages, client-side routing, form validation, model binding, and component-based UIs, the Web.Client project shows the most major features of Blazor. This app defines a <code>Learning.Blazor</code> namespace.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46364998324512">
<h5>Mindfulness and Poise</h5>
<p>The Blazor WebAssembly hosting model means that your C# code is served to the client browser. What do we tell ourselves about clients? “We must always assume the potential for malicious intent.” It’s better to be safe than sorry. Just as you’d avoid putting sensitive data like API keys, passwords, and private tokens into JavaScript, you should bring a sense of mindfulness to the client code you write in Blazor.</p>
</div></aside>
</div></section>













<section data-pdf-bookmark="Web API" data-type="sect1"><div class="sect1" id="idm46364998322992">
<h1>Web API</h1>

<p>The client application would <a data-primary="Web.Api" data-type="indexterm" id="idm46364998321616"/>be rather boring if not for data. How do web apps get data, you might ask? HTTP is the most common approach, but in addition to that, our application is also going to make <a data-primary="SignalR" data-type="indexterm" id="idm46364998320880"/>use of ASP.NET Core SignalR with Web Sockets for real-time web functionality.</p>
<div data-type="tip"><h6>Tip</h6>
<p>ASP.NET Core SignalR is an open source library that simplifies adding real-time web functionality to apps. It’s used in the sample source code to exemplify real-time functionality. For an overview of SignalR, see Microsoft’s <a href="https://oreil.ly/TrV3W">overview of ASP.NET Core SignalR</a>.</p>
</div>

<p>Again, the sample app uses the Blazor WebAssembly hosting model, but it’s still valuable to show real-time web functionality. As such, ASP.NET Core SignalR is used, but not in the same way that was previously described when using the Blazor Server hosting model.</p>

<p>There is an ASP.NET Core Web API project, named Web.Api, which targets 
<span class="keep-together"><code>Microsoft.NET.Sdk.Web</code>.</span> The project will offer up various endpoints on which the client app will rely. The API and SignalR endpoints will be protected by Azure Active Directory (Azure AD) business-to-consumer (B2C) authentication.</p>

<p>The Web API project uses an in-memory cache to ensure a responsive experience. Selective endpoints rely on services that will deterministically yield data from either the cache or the raw-HTTP-dependent endpoint.</p>
</div></section>













<section data-pdf-bookmark="Pwned Web API" data-type="sect1"><div class="sect1" id="idm46364998315904">
<h1>Pwned Web API</h1>

<p>The Pwned Web API project <a data-primary="Pwned Web API" data-type="indexterm" id="idm46364998314880"/>also relies on the <code>Microsoft.NET.Sdk.Web</code> SDK. This project exposes the <a href="https://oreil.ly/X0G2E">“Have I Been Pwned”</a> service functionality from Troy Hunt. After a user has provided consent to allow the application to use their email address, it is sent to the Pwned service. The API provides details that are used to notify the user if their email has been a part of a data breach.</p>
</div></section>













<section data-pdf-bookmark="Web Abstractions" data-type="sect1"><div class="sect1" id="idm46364998312880">
<h1>Web Abstractions</h1>

<p>With a simple C# class library project targeting <code>Microsoft.NET.Sdk</code>, the Web.Abstractions project <a data-primary="Web.Abstractions project" data-type="indexterm" id="idm46364998311360"/>defines a few abstractions that will be shared between the client and server apps. These contracts will serve as the glue for the SignalR endpoints. From the client’s perspective, these abstractions will provide a discoverability set of APIs from which the client can subscribe to events and methods with which they can communicate back to the server. From the server’s perspective, these abstractions solidify the method and event names, ensuring that there are not any possible misalignments. This is extremely important and a common pitfall in all JavaScript-based SPA 
<span class="keep-together">development.</span></p>
</div></section>













<section data-pdf-bookmark="Web Extensions" data-type="sect1"><div class="sect1" id="idm46364998309872">
<h1>Web Extensions</h1>

<p>In modern C# application <a data-primary="Web.Extensions project" data-type="indexterm" id="idm46364998308736"/>development, it’s common to encapsulate repetitive subroutines into extensions. Due to their repetitive nature, utilitarian extension methods are a perfect candidate for a shared class library-style project. In our case, we’ll use the Web.Extensions project that targets <code>Microsoft.NET.Sdk</code>. This project provides functionality that will be used throughout most of our other projects within our solution, especially both client and server app scenarios.</p>
</div></section>













<section data-pdf-bookmark="Web HTTP Extensions" data-type="sect1"><div class="sect1" id="idm46364998307072">
<h1>Web HTTP Extensions</h1>

<p>Another extensions class library <a data-primary="Web.Http.Extensions project" data-type="indexterm" id="idm46364998305936"/>focuses on defining defaults for the <code>HttpClient</code> type. There are several shared class libraries, all of which were making HTTP calls—​I wanted all HTTP calls that fail to have a specific retry policy for handling transient errors. These policies are defined within the Web.Http.Extensions project that targets <code>Microsoft.NET.Sdk</code>.</p>
</div></section>













<section data-pdf-bookmark="Web Functions" data-type="sect1"><div class="sect1" id="idm46364998303888">
<h1>Web Functions</h1>

<p>Serverless programming has become <a data-primary="Web.Functions project" data-type="indexterm" id="idm46364998302752"/>very prevalent over the past decade. Immutable infrastructure, resiliency, and scalability are always highly sought-after features. Azure Functions are used to wrap my weather services. I decided to use the Open Weather Map API, which is free, supports multiple languages, and is rather accurate. With an Azure Function app, I can encapsulate my configuration, protect my API keys, use dependency injection, and delegate calls to the weather API. This project is named Web.Functions, and it targets <code>Microsoft.NET.Sdk</code>.</p>
</div></section>













<section data-pdf-bookmark="Web Joke Services" data-type="sect1"><div class="sect1" id="idm46364998301376">
<h1>Web Joke Services</h1>

<p>Life is too short not to enjoy it—we need to laugh more, crack a smile, and not take ourselves so <a data-primary="Web.JokeServices library" data-type="indexterm" id="idm46364998300128"/>seriously. The Web.JokeServices library is responsible for aggregating jokes on a pseudorandom schedule. There are collectively three separate and free joke APIs that are aggregated in this project:</p>

<ul>
<li>
<p><a href="https://oreil.ly/Dmf7N">Internet Chuck Norris Database</a></p>
</li>
<li>
<p><a href="https://oreil.ly/LMitC">I Can Haz Dad Joke</a></p>
</li>
<li>
<p><a href="https://oreil.ly/U67QS">Random Programming Joke API</a></p>
</li>
</ul>
</div></section>













<section data-pdf-bookmark="Web Models" data-type="sect1"><div class="sect1" id="idm46364998295344">
<h1>Web Models</h1>

<p>The Web.Models project is a <em>shared</em> library used by <a data-primary="shared libraries" data-type="indexterm" id="idm46364998293824"/><a data-primary="Web.Models project" data-type="indexterm" id="idm46364998293216"/>many other projects in the solution. It contains all of the models used to represent various domain entities, such as shared models by services and clients alike. Anything in the app that is interacted with specifies a shape and has members that help to uniquely identify itself. This is, of course, at the core of object-oriented programming.</p>
</div></section>













<section data-pdf-bookmark="Web Twitter Components" data-type="sect1"><div class="sect1" id="idm46364998292224">
<h1>Web Twitter Components</h1>

<p>To exemplify component <a data-primary="Web.TwitterComponents project" data-type="indexterm" id="idm46364998291088"/>library functionality, I chose to create a Twitter component Razor library. It’s named Web.TwitterComponents, and the project relies on the 
<span class="keep-together"><code>Microsoft.NET.Sdk.Razor</code></span> SDK. It provides two components, one representing a tweet and the other representing a collection of tweets. This project will demonstrate how components are templated; it shows a parent-child hierarchy relationship. It shows how components can use JavaScript interop and update from asynchronous events.</p>
</div></section>













<section data-pdf-bookmark="Web Twitter Services" data-type="sect1"><div class="sect1" id="idm46364998289184">
<h1>Web Twitter Services</h1>

<p>The Web​.Twit⁠terServices <a data-primary="Web.TwitterServices project" data-type="indexterm" id="idm46364998288048"/>project is consumed by the Web.Api project, not the Web.TwitterComponents project. The Twitter services are used in the context of background service. Background services provide a means for managing long-running operations that function outside the request and response pipeline. As is the case with tweet streaming, as filtered tweets occur in real time, our services will propagate them accordingly.</p>
</div></section>







</div></section></body></html>