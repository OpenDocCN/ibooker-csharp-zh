["```cs\npublic static string FormatDictionary<TKey, TValue>(\n    IDictionary<TKey, TValue> input)\n{\n    var sb = new StringBuilder();\n    foreach (var item in input)\n    {\n        sb.AppendFormat(\"{0}: {1}\", item.Key, item.Value);\n        sb.AppendLine();\n    }\n\n    return sb.ToString();\n}\n```", "```cs\nstatic string UseDictionary(ConcurrentDictionary<int, string> cd)\n{\n    cd[1] = \"One\";\n    return cd[1];\n}\n```", "```cs\nclass Notifier\n{\n    private readonly Action _callback;\n    private readonly ThreadLocal<bool> _isCallbackInProgress = new();\n\n    public Notifier(Action callback)\n    {\n        _callback = callback;\n    }\n\n    public void Notify()\n    {\n        if (_isCallbackInProgress.Value)\n        {\n            throw new InvalidOperationException(\n                \"Notification already in progress on this thread\");\n        }\n\n        try\n        {\n            _isCallbackInProgress.Value = true;\n            _callback();\n        }\n        finally\n        {\n            _isCallbackInProgress.Value = false;\n        }\n    }\n}\n```", "```cs\ninternal static class Program\n{\n    private static readonly HttpClient http = new();\n\n    private static void Main(string[] args)\n    {\n        Thread t1 = new(MyThreadEntryPoint);\n        Thread t2 = new(MyThreadEntryPoint);\n        Thread t3 = new(MyThreadEntryPoint);\n\n        t1.Start(\"https://endjin.com/\");\n        t2.Start(\"https://oreilly.com/\");\n        t3.Start(\"https://dotnet.microsoft.com/\");\n    }\n\n    private static void MyThreadEntryPoint(object? arg)\n    {\n        string url = (string)arg!;\n\n        Console.WriteLine($\"Downloading {url}\");\n        var response = http.Send(new HttpRequestMessage(HttpMethod.Get, url));\n        using StreamReader r = new(response.Content.ReadAsStream());\n        string page = r.ReadToEnd();\n        Console.WriteLine($\"Downloaded {url}, length {page.Length}\");\n    }\n}\n```", "```cs\nTask.Run(() => MyThreadEntryPoint(\"https://oreilly.com/\"));\n```", "```cs\nprivate void findButton_Click(object sender, RoutedEventArgs e)\n{\n    `SynchronizationContext` `uiContext` `=` `SynchronizationContext``.``Current``!``;`\n\n    Task.Run(() =>\n    {\n        string pictures =\n            Environment.GetFolderPath(Environment.SpecialFolder.MyPictures);\n        var folder = new DirectoryInfo(pictures);\n        FileInfo[] allFiles =\n            folder.GetFiles(\"*.jpg\", SearchOption.AllDirectories);\n        FileInfo? largest =\n            allFiles.OrderByDescending(f => f.Length).FirstOrDefault();\n\n        if (largest is not null)\n        {\n            `uiContext``.``Post``(``_` `=``>`\n            {\n                long sizeMB = largest.Length / (1024 * 1024);\n                outputTextBox.Text =\n                    $\"Largest file ({sizeMB}MB) is {largest.FullName}\";\n            },\n            null);\n        }\n    });\n}\n```", "```cs\npublic class Defer\n{\n    private readonly Action _callback;\n    private readonly ExecutionContext? _context;\n\n    public Defer(Action callback)\n    {\n        _callback = callback;\n        _context = ExecutionContext.Capture()!;\n    }\n\n    public void Run()\n    {\n        if (_context is null) { _callback(); return; }\n        // When ExecutionContext.Run invokes the lambda we supply as the 2nd\n        // argument, it passes that lambda the value we supplied as the 3rd\n        // argument to Run. Here we're passing _callback, so the lambda has\n        // access to the Action we want to invoke. It would have been simpler\n        // to write \"_ => _callback()\", but the lambda would then need to\n        // capture 'this' to be able to access _callback, and that capture\n        // would cause an additional allocation.\n        ExecutionContext.Run(_context, (cb) => ((Action)cb!)(), _callback);\n    }\n}\n```", "```cs\npublic class SaleLog\n{\n    private readonly object _sync = new();\n\n    private decimal _total;\n\n    private readonly List<string> _saleDetails = new();\n\n    public decimal Total\n    {\n        get\n        {\n            lock (_sync)\n            {\n                return _total;\n            }\n        }\n    }\n\n    public void AddSale(string item, decimal price)\n    {\n        string details = $\"{item} sold at {price}\";\n        lock (_sync)\n        {\n            _total += price;\n            _saleDetails.Add(details);\n        }\n    }\n\n    public string[] GetDetails(out decimal total)\n    {\n        lock (_sync)\n        {\n            total = _total;\n            return _saleDetails.ToArray();\n        }\n    }\n}\n```", "```cs\nbool lockWasTaken = false;\nobject temp = _sync;\ntry\n{\n    Monitor.Enter(temp, ref lockWasTaken);\n    {\n        total = _total;\n        return _saleDetails.ToArray();\n    }\n}\nfinally\n{\n    if (lockWasTaken)\n    {\n        Monitor.Exit(temp);\n    }\n}\n```", "```cs\npublic class MessageQueue<T>\n{\n    private readonly object _sync = new();\n\n    private readonly Queue<T> _queue = new();\n\n    public void Post(T message)\n    {\n        lock (_sync)\n        {\n            bool wasEmpty = _queue.Count == 0;\n            _queue.Enqueue(message);\n            if (wasEmpty)\n            {\n                Monitor.Pulse(_sync);\n            }\n        }\n    }\n\n    public T Get()\n    {\n        lock (_sync)\n        {\n            while (_queue.Count == 0)\n            {\n                Monitor.Wait(_sync);\n            }\n            return _queue.Dequeue();\n        }\n    }\n}\n```", "```cs\npublic class DecimalTotal\n{\n    private decimal _total;\n\n    private SpinLock _lock;\n\n    public decimal Total\n    {\n        get\n        {\n            bool acquiredLock = false;\n            try\n            {\n                _lock.Enter(ref acquiredLock);\n                return _total;\n            }\n            finally\n            {\n                if (acquiredLock)\n                {\n                    _lock.Exit();\n                }\n            }\n        }\n    }\n\n    public void Add(decimal value)\n    {\n        bool acquiredLock = false;\n        try\n        {\n            _lock.Enter(ref acquiredLock);\n            _total += value;\n        }\n        finally\n        {\n            if (acquiredLock)\n            {\n                _lock.Exit();\n            }\n        }\n    }\n}\n```", "```cs\nstatic void LogFailure(string message, string mailServer)\n{\n    var email = new SmtpClient(mailServer);\n\n    `using` `(``var` `emailSent` `=` `new` `ManualResetEvent``(``false``)``)`\n    {\n        object sync = new();\n        bool tooLate = false; // Prevent call to Set after a timeout\n        `email``.``SendCompleted` `+``=` `(``_``,` `_``)` `=``>` `// (Event arguments unused here) `        `{`\n            `lock``(``sync``)`\n            `{`\n                `if` `(``!``tooLate``)` `{` `emailSent``.``Set``(``)``;` `}`\n            `}`\n        `}``;`\n        email.SendAsync(\"logger@example.com\", \"sysadmin@example.com\",\n            \"Failure Report\", \"An error occurred: \" + message, null);\n\n        LogPersistently(message);\n\n        `if` `(``!``emailSent``.``WaitOne``(``TimeSpan``.``FromMinutes``(``1``)``)``)`\n        {\n            LogPersistently(\"Timeout sending email for error: \" + message);\n        }\n\n        lock (sync)\n        {\n            tooLate = true;\n        }\n    }\n}\n```", "```cs\nstatic int InterlockedIncrement(ref int target)\n{\n    int current, newValue;\n    do\n    {\n        current = target;\n        newValue = current + 1;\n    }\n    while (Interlocked.CompareExchange(ref target, newValue, current)\n            != current);\n    return newValue;\n}\n```", "```cs\npublic class Cache<T>\n{\n    private static Dictionary<string, T>? _d;\n\n    public static IDictionary<string, T> Dictionary =>\n        LazyInitializer.EnsureInitialized(ref _d);\n}\n```", "```cs\nvar w = new HttpClient();\nstring url = \"https://endjin.com/\";\nTask<string> webGetTask = w.GetStringAsync(url);\n```", "```cs\nstring pageContent = await webGetTask;\n```", "```cs\nwebGetTask.ContinueWith(t =>\n{\n    string webContent = t.Result;\n    Console.WriteLine(\"Web page length: \" + webContent.Length);\n});\n```", "```cs\nprivate static void ShowContinuations()\n{\n    Task op = Task.Run(DoSomething);\n    var cs = new CancellationTokenSource();\n    Task onDone = op.ContinueWith(\n        _ => Console.WriteLine(\"Never runs\"),\n        cs.Token);\n    Task andAnotherThing = onDone.ContinueWith(\n        _ => Console.WriteLine(\"Continuation's continuation\"));\n    cs.Cancel();\n}\n\nstatic void DoSomething()\n{\n    Thread.Sleep(1000);\n    Console.WriteLine(\"Initial task finishing\");\n}\n```", "```cs\npublic partial class MainWindow : Window\n{\n    public MainWindow()\n    {\n        InitializeComponent();\n    }\n\n    private static readonly HttpClient w = new();\n    `private` `readonly` `TaskScheduler` `_uiScheduler` `=`\n        `TaskScheduler``.``FromCurrentSynchronizationContext``(``)``;`\n\n    private void FetchButtonClicked(object sender, RoutedEventArgs e)\n    {\n        string url = \"https://endjin.com/\";\n        Task<string> webGetTask = w.GetStringAsync(url);\n\n        webGetTask.ContinueWith(t =>\n        {\n            string webContent = t.Result;\n            outputTextBox.Text = webContent;\n        },\n        `_uiScheduler``)``;`\n    }\n}\n```", "```cs\npublic static class SmtpAsyncExtensions\n{\n    public static Task SendTaskAsync(this SmtpClient mailClient, string from,\n                                string recipients, string subject, string body)\n    {\n        var tcs = new TaskCompletionSource<object?>();\n\n        void CompletionHandler(object s, AsyncCompletedEventArgs e)\n        {\n            // Check this is the notification for our SendAsync.\n            if (!object.ReferenceEquals(e.UserState, tcs)) { return; }\n            mailClient.SendCompleted -= CompletionHandler;\n            if (e.Canceled)\n            {\n                tcs.SetCanceled();\n            }\n            else if (e.Error != null)\n            {\n                tcs.SetException(e.Error);\n            }\n            else\n            {\n                tcs.SetResult(null);\n            }\n        };\n\n        mailClient.SendCompleted += CompletionHandler;\n        mailClient.SendAsync(from, recipients, subject, body, tcs);\n\n        return tcs.Task;\n    }\n}\n```", "```cs\npublic virtual IAsyncResult BeginWrite(byte[] buffer, int offset, int count,\n    AsyncCallback callback, object state)...\npublic virtual void EndWrite(IAsyncResult asyncResult)...\n\npublic abstract void Write(byte[] buffer, int offset, int count)...\n```", "```cs\nstatic float[] ParallelConvolution(float[] input, float[] kernel)\n{\n    float[] output = new float[input.Length];\n    Parallel.For(0, input.Length, i =>\n    {\n        float total = 0;\n        for (int k = 0; k < Math.Min(kernel.Length, i + 1); ++k)\n        {\n            total += input[i - k] * kernel[k];\n        }\n        output[i] = total;\n    });\n\n    return output;\n}\n```"]