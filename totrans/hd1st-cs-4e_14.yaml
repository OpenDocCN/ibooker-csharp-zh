- en: 'Chapter 9\. LINQ and lambdas: *Get control of your data*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 LINQ和lambda：*掌控你的数据*
- en: '![Images](assets/pg467.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg467.png)'
- en: '**It’s a data-driven world...we all need to know how to live in it.**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**这是一个数据驱动的世界……我们都需要知道如何在其中生存。**'
- en: Gone are the days when you could program for days, even weeks, without dealing
    with **loads of data**. Today, ***everything is about data***, and that’s where
    **LINQ** comes in. LINQ is a feature of C# and .NET that not only lets you **query
    data** in your .NET collections in an intuitive way, but lets you **group data**
    and **merge data from different data sources**. You’ll add **unit tests** to make
    sure your code is working the way you want. Once you’ve got the hang of wrangling
    your data into manageable chunks, you can use **lambda expressions** to refactor
    your C# code to make it even more expressive
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 已经过去了你可以无需处理大量数据就能编程数天、甚至数周的时代。今天，***一切都与数据有关***，而这正是**LINQ**发挥作用的地方。LINQ是C#和.NET的特性，不仅让你以直观的方式**查询**.NET集合中的数据，还能让你**分组数据**并**合并来自不同数据源的数据**。你将添加**单元测试**以确保你的代码按照你想要的方式工作。一旦你掌握了将数据整理成可管理的块的窍门，你可以使用**lambda表达式**重构你的C#代码，使其更具表现力。
- en: Jimmy’s a Captain Amazing super-fan...
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jimmy是“超级队长”卡通迷中的铁杆粉丝…
- en: Meet Jimmy, one of the most enthusiastic collectors of Captain Amazing comics,
    graphic novels, and paraphernalia. He knows all the Captain trivia, he’s got props
    from all the movies, and he’s got a comic collection that can only be described
    as, well, amazing.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 认识一下Jimmy，他是“超级队长”漫画、图像小说和周边的热情收藏家之一。他知道所有关于队长的冷知识，他拥有所有电影的道具，他还有一个只能用“惊人”来形容的漫画收藏。
- en: '![Images](assets/pg468.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg468.png)'
- en: '...but his collection’s all over the place'
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: …但他的收藏物到处都是
- en: Jimmy may be passionate, but he’s not exactly organized. He’s trying to keep
    track of the most prized “crown jewel” comics of his collection, but he needs
    help. Can you build Jimmy an app to manage his comics?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Jimmy可能充满热情，但他并不是一个特别有条理的人。他试图追踪他收藏的最珍贵的“皇冠明珠”漫画，但他需要帮助。你能帮Jimmy建立一个管理他漫画的应用程序吗？
- en: '![Images](assets/pg469.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg469.png)'
- en: Use LINQ to query your collections
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LINQ查询你的集合
- en: In this chapter you’ll learn about **LINQ** (or **Language-**Integrated** Query**).
    LINQ combines really useful classes and methods with powerful features built directly
    into C#, all created to help you work with sequences of data—like Jimmy’s comic
    book collection.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将学习**LINQ**（或称**语言集成查询**）。LINQ将非常有用的类和方法与直接内置在C#中的强大功能结合起来，所有这些都是为了帮助你处理数据序列，就像Jimmy的漫画书收藏一样。
- en: 'Let’s use Visual Studio to start exploring LINQ. **Create a new Console App**
    (.NET Core) project and give it the name ***LinqTest***. Add this code, and when
    you get to the last line **add a period** and look at the IntelliSense window:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Visual Studio开始探索LINQ。创建一个新的控制台应用程序（.NET Core）项目，并将其命名为***LinqTest***。添加这段代码，当你到达最后一行时，请**加上一个句号**并查看智能感知窗口：
- en: '![Images](assets/pg470.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg470.png)'
- en: 'Let’s use some of those new methods to finish your console app:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一些新方法来完成你的控制台应用程序：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now run your app. It prints this line of text to the console:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行你的应用程序。它会在控制台打印出这一行文本：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So what did you just do?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 那么你刚刚做了什么？
- en: '**LINQ (or Language INtegrated Query) is a combination of C# features and .NET
    classes that helps you work with sequences of data.**'
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**LINQ（或语言集成查询）是C#特性和.NET类的结合，帮助你处理数据序列。**'
- en: LINQ works with any IEnumerable<T>
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LINQ可以与任何IEnumerable<T>一起工作
- en: When you added the `using System.Linq;` directive to your code, your List<int>
    suddenly got “superpowered”—a bunch of LINQ methods repeated appeared on it. You
    can do the same thing for ***any*** ***class that implements IEnumerable<T>.***
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在代码中添加了`using System.Linq;`指令后，你的List<int>突然“超级强大”起来——一堆LINQ方法立即出现在它上面。你可以对***任何***
    ***实现IEnumerable<T>的类***做同样的事情。
- en: When a class implements IEnumerable<T>, any instance of that class is a **sequence:**
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类实现IEnumerable<T>时，该类的任何实例都是一个**序列**：
- en: The list of numbers from 1 to 99 was a sequence.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从1到99的数字列表就是一个序列。
- en: When you called its Take method, it returned a reference to a sequence that
    contained the first five elements.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你调用其Take方法时，它返回一个包含前五个元素的序列的引用。
- en: When you called its TakeLast method, it returned another five-element sequence.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你调用其TakeLast方法时，它返回另一个包含五个元素的序列。
- en: And when you used Concat to combine the two five-element sequences, it created
    a new sequence with 10 elements and returned a reference to that new sequence.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你使用Concat将两个包含五个元素的序列合并时，它创建了一个新的包含10个元素的序列，并返回对该新序列的引用。
- en: '**Any time you have an object that implements the IEnumerable interface, you
    have a sequence that you can use with LINQ. Doing an operation on that sequence
    in order is called enumerating the sequence.**'
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**任何实现IEnumerable接口的对象都是一个你可以在LINQ中使用的序列。在该序列上执行操作按顺序称为枚举该序列。**'
- en: LINQ methods enumerate your sequences
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LINQ方法枚举你的序列
- en: 'You already know that `foreach` loops work with IEnumerable objects. Think
    about what a `foreach` loop does:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道`foreach`循环可以处理IEnumerable对象。想想`foreach`循环的工作原理：
- en: '![Images](assets/pg472.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg472.png)'
- en: When a method goes through each item in a sequence in order, that’s called **enumerating**
    the sequence. And that’s how LINQ methods work.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当方法按顺序遍历序列中的每个项时，这被称为**枚举**序列。这也是LINQ方法的工作方式。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Objects that implement the IEnumerable interface can be enumerated. That’s
    the job objects that implement the IEnumerable interface do.**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现IEnumerable接口的对象可以被枚举。这就是实现IEnumerable接口的对象所做的工作。**'
- en: Note
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**What if you want to find the first 30 issues in Jimmy’s collection starting
    with issue #118? LINQ provides a really useful method to help with that. The static
    Enumerable.Range method generates a sequence of integers. Calling Enumerable.Range(8,
    5) returns a sequence of 5 numbers starting with 8: 8, 9, 10, 11, 12.**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果你想找到Jimmy收藏中从第118期开始的前30期问题，你会怎么做？LINQ提供了一个非常有用的方法来帮助你。静态的Enumerable.Range方法生成一个整数序列。调用Enumerable.Range(8,
    5)会返回一个以8开头的5个数字序列：8, 9, 10, 11, 12。**'
- en: '![Images](assets/pg473-1.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg473-1.png)'
- en: Note
  id: totrans-37
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**The LINQ methods in this exercise have names that make it obvious what they
    do. Some LINQ methods, like Sum, Min, Max, Count, First, and Last, return a single
    value. The Sum method adds up the values in the sequence. The Average method returns
    their average value. The Min and Max methods return the smallest and largest values
    in the sequence. The First and Last methods do exactly what it sounds like they
    do.**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**在本练习中的LINQ方法具有能够清楚表明其功能的名称。一些LINQ方法，如Sum、Min、Max、Count、First和Last，返回单个值。Sum方法将序列中的值相加。Average方法返回它们的平均值。Min和Max方法返回序列中的最小值和最大值。First和Last方法则按其字面意义执行操作。**'
- en: '**Other LINQ methods, like Take, TakeLast, Concat, Reverse (which reverses
    the order in a sequence), and Skip (which skips the first elements in a sequence),
    return another sequence.**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**其他LINQ方法，如Take、TakeLast、Concat、Reverse（反转序列的顺序）和Skip（跳过序列中的前几个元素），返回另一个序列。**'
- en: LINQ’s query syntax
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LINQ的查询语法
- en: The LINQ methods you’ve seen so far may not be enough on their own to answer
    the kinds of questions about data that we might have—or the questions that Jimmy
    has about his comic collection.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止你看到的LINQ方法可能不足以单独回答关于数据的问题，或者说Jimmy关于他的漫画收藏的问题。
- en: And that’s where the **LINQ declarative query syntax** comes in. It uses special
    keywords—including `where`, `select`, `groupby`, and `join`—to build **queries**
    directly into your code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是**LINQ声明式查询语法**的用武之地。它使用特殊关键字，包括`where`、`select`、`groupby`和`join`，直接在你的代码中构建**查询**。
- en: LINQ queries are built from clauses
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LINQ查询由各种子句构建而成
- en: Let’s build a query that finds the numbers in an int array that are under 37
    and puts those numbers in ascending order. It does that using four **clauses**
    that tell it what object to query how to determine which of its members to select,
    how to sort the results, and how the results should be returned.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个查询，找出int数组中小于37的数字，并按升序排列这些数字。它使用四个**子句**告诉它要查询哪个对象，如何确定选择哪些成员，如何对结果进行排序，以及如何返回结果。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**LINQ queries work on sequences, or objects that implement IEnumerable<T>.
    LINQ queries start with a from clause:**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**LINQ查询适用于序列或实现IEnumerable<T>的对象。LINQ查询以from子句开始：**'
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**It tells the query what sequence to execute against, and assigns a name to
    use for each element being queried. It’s like the first line in a `foreach loop`:
    it declares a variable to use while iterating through the sequence that’s assigned
    each element in the sequence. So this:**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**它告诉查询执行对哪个序列，并为正在查询的每个元素分配一个名称。这就像`foreach`循环的第一行：它声明了一个变量，在遍历分配给该序列中每个元素时使用。因此：**'
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**iterates through each element in the `values` array in order, assigning the
    first value in the array to v, then the second, then the third, etc.**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**按顺序遍历`values`数组中的每个元素，将数组中的第一个值赋给v，然后第二个，第三个，依此类推。**'
- en: '![Images](assets/pg475.png)![Images](assets/pg476-2.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg475.png)![图片](assets/pg476-2.png)'
- en: '**LINQ isn’t just for numbers. It works with objects, too.**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**LINQ 不仅适用于数字，它也适用于对象。**'
- en: 'When Jimmy looks at stacks and stacks of disorganized comics, he might see
    paper, ink, and a jumbled mess. When us developers look at them, we see something
    else: **lots and lots of data** just waiting to be organized. How do we organize
    comic book data in C#? The same way we organize playing cards, bees, or items
    on Sloppy Joe’s menu: we create a class, then we use a collection to manage that
    class. So all we need to help Jimmy out is a Comic class, and code to help us
    bring some sanity to his collection. And LINQ will help!'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当吉米看着堆积如山的杂乱漫画时，他可能看到的是纸张、墨水和一团糟。而我们开发者看到的是另一番景象：**大量的数据**只等待整理。我们如何在 C# 中组织漫画数据？和我们组织纸牌、蜜蜂或者
    Sloppy Joe 菜单上的物品一样：我们创建一个类，然后使用集合来管理这个类。因此，帮助吉米的所有我们需要的就是一个 Comic 类，以及一些代码来帮助我们给他的收藏带来一些理性。LINQ
    将帮助我们！
- en: LINQ works with objects
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LINQ 适用于对象
- en: Jimmy wanted to know how much some of his prize comics are worth, so he hired
    a professional comic book appraiser to give him prices for each of them. It turns
    out that some of his comics are worth a lot of money! Let’s use collections to
    manage that data for him.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 吉米想知道他一些珍藏漫画的价值，所以他雇了一位专业的漫画评估师为他每一本漫画评估价格。结果表明，他的一些漫画价值不菲！让我们使用集合来为他管理这些数据。
- en: '***Do this!***'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '***就这样！***'
- en: '**Create a new console app and add a Comic class.**'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个新的控制台应用程序并添加一个 Comic 类。**'
- en: 'Use two automatic properties for the name and issue number:'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用两个自动属性来表示名称和期号：
- en: '![Images](assets/pg477-1.png)'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图像](assets/pg477-1.png)'
- en: '**Add a List that contains Jimmy’s catalog.**'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加一个包含吉米目录的 List。**'
- en: 'Add this static Catalog field to the Comic class. It returns a sequence with
    Jimmy’s prized comics:'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为 Comic 类添加这个静态 Catalog 字段。它返回一个序列，其中包含吉米珍藏的漫画：
- en: '![Images](assets/pg477-2.png)'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图像](assets/pg477-2.png)'
- en: '**Use a Dictionary to manage the prices.**'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用一个 Dictionary 来管理价格。**'
- en: 'Add a static Comic.Prices field—it’s a Dictionary<int, decimal> that lets you
    look up the price of each comic using its issue number (using the collection initializer
    syntax for dictionaries that you learned in [#enums_and_collections_organizing_your_da](ch08.html#enums_and_collections_organizing_your_da)).
    Note that we’re using the **IReadOnlyDictionary interface** for encapsulation—it’s
    an interface that includes only the methods to read values (so we don’t accidentally
    change the prices):'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加一个静态的 Comic.Prices 字段——它是一个 Dictionary<int, decimal>，让你可以通过漫画的期号查找每本漫画的价格（使用你在
    [#enums_and_collections_organizing_your_da](ch08.html#enums_and_collections_organizing_your_da)
    学到的字典的集合初始化语法）。请注意，我们使用了 **IReadOnlyDictionary 接口** 进行封装——它是一个仅包含读取值方法的接口（这样我们就不会意外更改价格）：
- en: '![Images](assets/pg477-3.png)'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图像](assets/pg477-3.png)'
- en: Note
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**We used a Dictionary to store the prices for the comics. We could have included
    a property called Price. We decided to keep information about the comic and price
    separate. We did this because prices for collectors’ items change all the time,
    but the name and issue number will always be the same. Do you think we made the
    right choice?**'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**我们使用 Dictionary 来存储漫画的价格。我们本可以在 Comic 类中包括一个名为 Price 的属性。但我们决定将漫画和价格信息分开。这是因为收藏品的价格随时会变动，但名称和期号将始终不变。你认为我们做出了正确的选择吗？**'
- en: Use a LINQ query to finish the app for Jimmy
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 LINQ 查询来完成吉米的应用程序
- en: 'We used the LINQ declarative query syntax earlier to create a query with four
    clauses: a `from` clause to create a range variable, a `where` clause to include
    only numbers under 37, an `orderby` clause to sort them in descending order, and
    a `select` clause to determine which elements to include in the resulting sequence.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用了 LINQ 声明查询语法来创建一个查询，其中包括四个子句：一个 `from` 子句创建一个范围变量，一个 `where` 子句只包括小于
    37 的数字，一个 `orderby` 子句按降序对它们进行排序，以及一个 `select` 子句确定包含在结果序列中的元素。
- en: Let’s **add a LINQ query to the Main method** that works exactly the same way—except
    using Comic objects instead of int values, so it writes a list of comics with
    a price > 500 in reverse order to the console. We’ll start with two `using` declarations
    so we can use IEnumerable<T> and LINQ methods. The query will return an IEnumerable<Comic>,
    then use a `foreach` loop to iterate through it and write the output.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Main 方法中**添加一个 LINQ 查询**，它的工作方式完全相同——只是使用 Comic 对象而不是 int 值，因此它将按价格> 500的顺序逆序打印漫画列表到控制台上。我们将从两个
    `using` 声明开始，这样我们就可以使用 IEnumerable<T> 和 LINQ 方法。查询将返回一个 IEnumerable<Comic>，然后使用
    `foreach` 循环来迭代它并输出结果。
- en: '**Modify the Main method to use a LINQ query.**'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**修改 Main 方法以使用 LINQ 查询。**'
- en: 'Here’s the entire Program class, including the `using` directives that you
    needed to add to the top:'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是整个 Program 类的代码，包括你需要添加到顶部的 `using` 指令：
- en: '![Images](assets/pg478-1.png)'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg478-1.png)'
- en: '**Output:**'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE4]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Use the descending keyword to make your orderby clause more readable.**'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用 `descending` 关键字可以使你的 orderby 子句更易读。**'
- en: 'Your `orderby` clause uses a minus sign to negate the comic prices before sorting,
    causing the query to sort them in descending order. But it’s easy to accidentally
    miss that minus sign when you’re reading the code and trying to figure out how
    it works. Luckily, there’s another way to get the same results. Remove the minus
    sign and **add the `descending` keyword** to the end of the clause:'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的 `orderby` 子句使用减号来对漫画价格进行排序前的取反，导致查询按降序排序。但是在阅读代码并尝试理解其工作原理时，很容易无意中忽略这个减号。幸运的是，有另一种方法可以获得相同的结果。删除减号并在子句末尾**添加
    `descending` 关键字**：
- en: '![Images](assets/pg478-2.png)'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg478-2.png)'
- en: The var keyword lets C# figure out variable types for you
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `var` 关键字可以让 C# 自动推断变量类型。
- en: We just saw that when we made the small change to the `select` clause, the type
    of sequence that the query returned changed. When it was `select comic;` the return
    type was IEnumerable<Comic>. When we changed it to `select $"{comic} is worth
    {Comic.Prices[comic.Issue]:c}";` the return type changed to IEnumerable<string>.
    When you’re working with LINQ, that happens all the time—you’re constantly tweaking
    your queries. It’s not always obvious exactly what type they return. Sometimes
    going back and updating all of your declarations can get annoying.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到，当我们对 `select` 子句进行了小改动时，查询返回的序列类型也发生了变化。当它是 `select comic;` 时，返回类型是 IEnumerable<Comic>。当我们将其改为
    `select $"{comic} is worth {Comic.Prices[comic.Issue]:c}";` 时，返回类型变为了 IEnumerable<string>。在使用
    LINQ 时，这种情况经常发生——你会不断地微调你的查询。很多时候并不明确它们确切的返回类型。有时候回过头去更新所有的声明会变得很烦人。
- en: 'Luckily, C# gives us a really useful tool to help keep variable declarations
    simple and readable. You can replace any variable declaration with the `var` **keyword**.
    So you can replace any of these declarations:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，C# 给了我们一个非常有用的工具，帮助保持变量声明简单和易读。你可以用 `var` **关键字** 替换任何变量声明。所以你可以用 `var`
    替换下列任何声明：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When you use the var keyword, you’re telling C# to use an implicitly typed variable.
    We saw that same word—implicit—back in [#enums_and_collections_organizing_your_da](ch08.html#enums_and_collections_organizing_your_da)
    when we talked about covariance. It means that C# figures out the types on its
    own.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 var 关键字时，你告诉 C# 使用隐式类型的变量。我们在 [#enums_and_collections_organizing_your_da](ch08.html#enums_and_collections_organizing_your_da)
    中也看到过同样的词——implicit——当我们讨论协变时。它意味着 C# 能够自行推断类型。
- en: 'with these declarations, which do exactly the same thing:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些声明，它们确实做了完全相同的事情：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: And you don’t have to change any of your code. Just replace the types with var
    and everything works.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 而且你无需改动任何代码。只需用 `var` 替换类型，一切都能正常工作。
- en: When you use var, C# figures out the variable’s type automatically
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `var` 时，C# 会自动推断变量的类型。
- en: 'Go ahead—try it right now. Comment out the first line of the LINQ query you
    just wrote, then replace IEnumerable<Comic> with var:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 继续吧，现在就试一试。注释掉你刚写的 LINQ 查询的第一行，然后用 `var` 替换 IEnumerable<Comic>：
- en: '![Images](assets/pg480.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg480.png)'
- en: The IDE figured out the mostExpensive variable’s type—and it’s a type we haven’t
    seen before. Remember in [#interfacescomma_castingcomma_and_quotati](ch07.html#interfacescomma_castingcomma_and_quotati)
    when we talked about how interfaces can extend other interfaces? The IOrderedEnumerable
    interface is part of LINQ—it’s used to represent a *sorted* sequence—and it extends
    the IEnumerable<T> interface. Try commenting out the `orderby` clause and hovering
    over the mostExpensive variable—you’ll find that it turns into an IEnumerable<Comic>.
    That’s because C# looks at the code to ***figure out the type of any variable
    you declare with*** ***var***.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: IDE 推断出了 mostExpensive 变量的类型——它是一种我们以前没见过的类型。还记得在 [#interfacescomma_castingcomma_and_quotati](ch07.html#interfacescomma_castingcomma_and_quotati)
    里我们讨论过接口如何扩展其他接口吗？IOrderedEnumerable 接口是 LINQ 的一部分——它用于表示*排序*序列——并且它扩展了 IEnumerable<T>
    接口。试着将 `orderby` 子句注释掉并将鼠标悬停在 mostExpensive 变量上——你会发现它变成了 IEnumerable<Comic>。这是因为
    C# 查看代码以***推断用 var 声明的任何变量的类型***。
- en: '![Images](assets/pg483.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg483.png)'
- en: '**You really can use var in your variable declarations.**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**你真的可以在变量声明中使用 var。**'
- en: And yes, it really is that simple. A lot of C# developers declare local variables
    using var almost all the time, and include the type only when it makes the code
    easier to read. As long as you’re declaring the variable and initializing it in
    the same statement, you can use var.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，确实如此简单。很多 C# 开发者几乎总是使用`var`声明局部变量，并且仅在使代码更易读时包含类型。只要你在同一语句中声明并初始化变量，就可以使用`var`。
- en: 'But there are some important restrictions on using var. For example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在使用`var`时有一些重要的限制。例如：
- en: You can only declare one variable at a time with var.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你只能使用`var`一次声明一个变量。
- en: You can’t use the variable you’re declaring in the declaration.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能在声明中使用正在声明的变量。
- en: You can’t declare it equal to `null`.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能将其声明为`null`。
- en: 'If you create a variable named `var`, you won’t be able to use it as a keyword
    anymore:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建一个名为`var`的变量，你将无法再将其用作关键字：
- en: You definitely can’t use var to declare a field or a property—you can only use
    it as a local variable inside a method.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你绝对不能使用`var`来声明字段或属性——你只能在方法内部使用它作为局部变量。
- en: If you stick to those ground rules, you can use var pretty much anywhere.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你坚持这些基本规则，你几乎可以在任何地方使用`var`。
- en: '**So when you did this in [#types_and_references_getting_the_referen](ch04.html#types_and_references_getting_the_referen):**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**所以当你在[#types_and_references_getting_the_referen](ch04.html#types_and_references_getting_the_referen)中这样做时：**'
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Or this in [#inheritance_your_objectapostrophes_famil](ch06.html#inheritance_your_objectapostrophes_famil):**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**或者在[#inheritance_your_objectapostrophes_famil](ch06.html#inheritance_your_objectapostrophes_famil)中这样做：**'
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Or this in [#enums_and_collections_organizing_your_da](ch08.html#enums_and_collections_organizing_your_da):**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**或者在[#enums_and_collections_organizing_your_da](ch08.html#enums_and_collections_organizing_your_da)中的这种情况：**'
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**You could have done this:**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**你本可以这样做：**'
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Or this:**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**或者这样做：**'
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Or this:**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**或者这样做：**'
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**...and your code would have worked exactly the same.**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**......而且你的代码将完全相同。**'
- en: '**But you can’t use var to declare a field or property:**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**但是你不能使用`var`声明字段或属性：**'
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: LINQ is versatile
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LINQ 是多才多艺的。
- en: With LINQ, you can do a lot more than just pull a few items out of a collection.
    You can modify the items before you return them. Once you’ve generated a set of
    result sequences, LINQ gives you a bunch of methods that work with them. Top to
    bottom, LINQ gives you the tools you need to manage your data. Let’s do a quick
    review of some of the LINQ features that we’ve already seen.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 LINQ，你不仅可以从集合中提取一些项目，还可以在返回它们之前修改这些项目。一旦生成了一组结果序列，LINQ 提供了一堆方法来处理它们。从顶到底，LINQ
    提供了你管理数据所需的工具。让我们快速回顾一下我们已经看到的一些 LINQ 特性。
- en: '**Modify every item returned from the query.**'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修改从查询返回的每个项目。**'
- en: This code will add a string onto the end of each element in an array of strings.
    It doesn’t change the array itself—it creates a new sequence of modified strings.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码将一个字符串添加到字符串数组的每个元素末尾。它不会改变数组本身，而是创建一个新的修改后字符串序列。
- en: '![Images](assets/pg486-1.png)'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg486-1.png)'
- en: '**Perform calculations on sequences.**'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对序列执行计算。**'
- en: You can use the LINQ methods on their own to get statistics about a sequence
    of numbers.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以单独使用 LINQ 方法来获取关于数字序列的统计信息。
- en: Note
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**The static String.Join method concatenates all of the items in a sequence
    into a string, specifying the separator to use between them.**'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**静态的 String.Join 方法将一个序列中所有项目连接为一个字符串，指定用于它们之间的分隔符。**'
- en: '[PRE14]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![Images](assets/pg486-2.png)'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg486-2.png)'
- en: LINQ queries aren’t run until you access their results
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LINQ 查询在访问其结果之前不会运行。
- en: 'When you include a LINQ query in your code, it uses **deferred evaluation**
    (sometimes called lazy evaluation). That means the LINQ query doesn’t actually
    do any enumerating or looping until your code executes a statement that ***uses
    the results of the query***. That sounds a little weird, but it makes a lot more
    sense when you see it in action. **Create a new console app** and add this code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在代码中包含 LINQ 查询时，它使用**延迟评估**（有时称为惰性评估）。这意味着直到你的代码执行一个使用查询结果的语句之前，LINQ 查询实际上不会进行枚举或循环。这听起来有点奇怪，但当你看到它实际运行时就会更有意义。**创建一个新的控制台应用程序**，并添加以下代码：
- en: '***Do this!***'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '***就这样！***'
- en: '![Images](assets/pg487-1.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg487-1.png)'
- en: Note
  id: totrans-132
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Did you get a weird compiler error? Make sure you added the two using directives
    to your code!**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**你是否收到了奇怪的编译器错误？确保将两个 using 指令添加到你的代码中！**'
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now run your app. Notice how the Console.WriteLine that prints `"Set up the
    query"` runs ***before*** the get accessor ever executes. That’s because the LINQ
    query won’t get executed until the `foreach` loop.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行你的应用程序。注意打印 `"Set up the query"` 的 Console.WriteLine 在 get 访问器执行之前***之前***运行。这是因为直到
    foreach 循环才会执行 LINQ 查询。
- en: '![Images](assets/pg487-2.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg487-2.png)'
- en: 'If you need the query to execute right now, you can force **immediate execution**
    by calling a LINQ method that needs to enumerate the entire list—for example,
    the ToList method, which turns it into a List<T>. Add this line, and change the
    foreach to use the new List:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要立即执行查询，可以通过调用需要枚举整个列表的 LINQ 方法来**立即执行**，例如 ToList 方法，将其转换为 List<T>。添加此行，并更改
    foreach 以使用新的列表：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Run the app again. This time you’ll see the get accessors called before the
    `foreach` loop starts executing—which makes sense, because ToList needs to access
    every element in the sequence to convert it to a List. Methods like Sum, Min,
    and Max also need to access every element in the sequence, so when you use them
    you’ll force LINQ to do immediate execution as well.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行应用程序。这次你会看到在开始执行 foreach 循环之前调用了 get 访问器——这是有道理的，因为 ToList 需要访问序列中的每个元素才能将其转换为
    List。像 Sum、Min 和 Max 这样的方法也需要访问序列中的每个元素，因此当你使用它们时，也会强制 LINQ 立即执行。
- en: Use a group query to separate your sequence into groups
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 group 查询将你的序列分成组
- en: Sometimes you really want to slice and dice your data. For example, Jimmy might
    want to group his comics by the decade they were published. Or maybe he wants
    to separate them by price (cheap ones in one collection, expensive ones in another).
    There are lots of reasons you might want to group your data together. That’s where
    the **LINQ group query** comes in handy.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你确实希望对数据进行切分和切块。例如，Jimmy 可能希望按照漫画出版的年代对其进行分组。或者他可能想按价格（便宜的放在一个集合中，昂贵的放在另一个集合中）分开它们。有很多理由你可能想要将数据分组在一起。这就是
    **LINQ group 查询** 很有用的地方。
- en: '***Group this!***'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '***分组数据！***'
- en: '![Images](assets/pg488.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg488.png)'
- en: '**Create a new console app and add the card classes and enums.**'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个新的控制台应用程序并添加卡片类和枚举。**'
- en: Create a **new .NET Core console app named *CardLinq***. Then go to the Solution
    Explorer panel, right-click on the project name, and choose Add >> Existing Items
    (or Add >>Existing Files on a Mac). Navigate to the folder where you saved the
    Two Decks project from [#enums_and_collections_organizing_your_da](ch08.html#enums_and_collections_organizing_your_da).
    Add the files with the **Suit and Value enums**, then add the **Deck, Card, and
    CardComparerByValue classes**.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个**名为 *CardLinq* 的新 .NET Core 控制台应用程序**。然后转到解决方案资源管理器面板，在项目名称上右键单击，选择添加 >>
    现有项（或在 Mac 上选择添加 >> 现有文件）。导航到你保存的来自[#enums_and_collections_organizing_your_da](ch08.html#enums_and_collections_organizing_your_da)的“Two
    Decks”项目所在的文件夹。添加带有**Suit 和 Value 枚举**的文件，然后添加**Deck、Card 和 CardComparerByValue
    类**。
- en: Note
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**You created the Deck class in the downloadable “Two Decks” project at the
    end of [#enums_and_collections_organizing_your_da](ch08.html#enums_and_collections_organizing_your_da).**'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**你在可下载的“Two Decks”项目的末尾创建了 Deck 类，在[#enums_and_collections_organizing_your_da](ch08.html#enums_and_collections_organizing_your_da)中。**'
- en: Make sure you **modify the namespace in each file you added** to match the namespace
    in *Program.cs* so your Main method can access the classes you added.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保**修改每个文件中的命名空间**以匹配 *Program.cs* 中的命名空间，以便你的 Main 方法可以访问你添加的类。
- en: '**Make your Card class sortable with IComparable<T>.**'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用 IComparable<T> 使你的 Card 类可排序。**'
- en: 'We’ll be using a LINQ `orderby` clause to sort groups, so we need the Card
    class to be sortable. Luckily, this works exactly like the List.Sort method, which
    you learned about in [#interfacescomma_castingcomma_and_quotati](ch07.html#interfacescomma_castingcomma_and_quotati).
    Modify your Card class to **extend the IComparable interface**:'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用 LINQ 的 `orderby` 子句对组进行排序，因此我们需要使 Card 类可排序。幸运的是，这与 List.Sort 方法完全相同，你在[#interfacescomma_castingcomma_and_quotati](ch07.html#interfacescomma_castingcomma_and_quotati)中学到过。修改你的
    Card 类以**扩展 IComparable 接口**：
- en: '![Images](assets/pg487-2a.png)'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg487-2a.png)'
- en: '**Modify the Deck.Shuffle method to support method chaining.**'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**修改 Deck.Shuffle 方法以支持方法链。**'
- en: 'The Shuffle class shuffles the deck. All you need to do to make it support
    method chaining is modify it to return a reference to the Deck instance that just
    got shuffled:'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Shuffle 类用于洗牌。要使其支持方法链，只需修改以返回刚刚被洗牌的 Deck 实例的引用：
- en: '![Images](assets/pg489-1.png)'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg489-1.png)'
- en: '**Use a LINQ query with group...by clause to group the cards by suit.**'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用带有 group...by 子句的 LINQ 查询，按花色分组卡片。**'
- en: 'The Main method will get 16 random cards by shuffling the deck, then using
    the LINQ Take method to pull the first 16 cards. Then it will use a LINQ query
    with a `group...by` **clause** to separate the deck into smaller sequences, with
    one sequence for each suit in the 16 cards:'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 主方法将通过洗牌整副牌随机取出16张牌，然后使用 LINQ 的 Take 方法取出前16张牌。然后它将使用带有`group...by` **子句**的
    LINQ 查询将整副牌分成较小的序列，每个序列对应16张牌中的一种花色：
- en: '![Images](assets/pg489-2.png)'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg489-2.png)'
- en: Note
  id: totrans-158
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**The group...by clause creates a sequence of groups that implement the IGrouping
    interface. IGrouping extends IEnumerable and adds exactly one member: a property
    called Key. So each group is a sequence of other sequences—in this case, it’s
    a group of Card sequences, where the key is the suit of the card (from the `Suits`
    enum). The full type of each group is IGrouping<Suits, Card>, which means it’s
    a sequence of Card sequences, each of which has a Suits value as its key.**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**group...by 子句创建实现 IGrouping 接口的一系列组。IGrouping 扩展 IEnumerable 并且仅添加一个成员：一个名为
    Key 的属性。因此，每个组都是其他序列的序列——在这种情况下，它是卡片序列的一个组，其中键是卡片的花色（来自`Suits`枚举）。每个组的完整类型是 IGrouping<Suits,
    Card>，这意味着它是卡片序列的序列，每个序列都以其花色作为键。**'
- en: Use join queries to merge data from two sequences
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 join 查询合并来自两个序列的数据
- en: Every good collector knows that critical reviews can have a big impact on values.
    Jimmy’s been keeping track of reviewer scores from two big comic review aggregators,
    MuddyCritic and Rotten Tornadoes. Now he needs to match them up to his collection.
    How’s he going to do that?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 每位好的收藏家都知道，关键评价对价值有很大影响。Jimmy 一直在跟踪两个大型漫评聚合网站，MuddyCritic 和 Rotten Tornadoes
    的评审分数。现在他需要将它们与他的收藏匹配起来。他将如何做呢？
- en: LINQ to the rescue! Its `join` keyword lets you **combine data from two sequences**
    using a single query. It does it by comparing items in one sequence with their
    matching items in a second sequence. (LINQ is smart enough to do this efficiently—it
    doesn’t actually compare every pair of items unless it has to.) The final result
    combines every pair that matches.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 来拯救！它的`join`关键字允许你使用单个查询**结合来自两个序列的数据**。它通过比较一个序列中的项与第二个序列中它们匹配的项来实现。 （LINQ
    足够聪明，能够高效地执行此操作——除非必须比较每对项。）最终结果将组合每个匹配的一对项。
- en: 'You’ll start your query with the usual `from` clause. But instead of following
    it up with the criteria to determine what goes into the results, you’ll add:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询将从通常的`from`子句开始。但是在接下来不是添加用于确定结果的条件，而是添加：
- en: '[PRE17]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `join` clause tells LINQ to enumerate both sequences to match up pairs with
    one member from each. It assigns `name` to the member it’ll pull out of the joined
    collection in each iteration. You’ll use that name in the `where` clause.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`join`子句告诉 LINQ 枚举两个序列以匹配每对成员。它在每次迭代中将`name`分配给从已连接集合中拉出的成员。你将在`where`子句中使用该名称。'
- en: '![Images](assets/pg491.png)'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg491.png)'
- en: Next you’ll add the `**on**` clause, which tells LINQ how to match the two collections
    together. You’ll follow it with the name of the member of the first collection
    you’re matching, followed by `**equals**` and the name of the member of the second
    collection to match it up with.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来你会加上`**on**`子句，告诉 LINQ 如何将这两个集合匹配在一起。接着是第一个集合中你要匹配的成员的名称，后面是`**equals**`和第二个集合中要匹配的成员的名称。
- en: You’ll continue the LINQ query with `**where**` and `**orderby**` clauses as
    usual. You could finish it with a normal `**select**` clause, but you usually
    want to return results that pull some data from one collection and other data
    from the other.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将像往常一样继续 LINQ 查询，使用`**where**`和`**orderby**`子句。你可以用正常的`**select**`子句完成它，但通常希望返回的结果从一个集合中提取一些数据，从另一个集合中提取其他数据。
- en: 'The result is a sequence of objects that have Name and Issue properties from
    Comic, but Critic and Score properties from Review. The result can’t be a sequence
    of Comic objects, but it also can’t be a sequence of Review objects, because neither
    class has all of those properties. The result is a different kind of type: ***an
    anonymous type.***'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一系列对象，这些对象具有 Comic 的 Name 和 Issue 属性，但具有 Review 的 Critic 和 Score 属性。结果不能是
    Comic 对象的序列，但也不能是 Review 对象的序列，因为两个类都没有所有这些属性。结果是一种不同类型：***匿名类型***。
- en: Use the new keyword to create anonymous types
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 new 关键字创建匿名类型
- en: 'You’ve been using the `new` keyword since [#objectshellipget_orientedexclamation_mar](ch03.html#objectshellipget_orientedexclamation_mar)
    to create instances of objects. Every time you use it, you include a type (so
    the statement `new Guy();` creates an instance of the type Guy). You can also
    use the `new` keyword without a type to create an **anonymous type**. That’s a
    perfectly valid type that has read-only properties, but doesn’t have a name. The
    type we returned from the query that joined Jimmy’s comics to reviews is an anonymous
    type. You can add properties to your anonymous type by using an object initializer.
    Here’s what that looks like:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 从[#objectshellipget_orientedexclamation_mar](ch03.html#objectshellipget_orientedexclamation_mar)开始，你一直在使用`new`关键字创建对象的实例。每次使用时，你都包含一个类型（因此语句`new
    Guy();`创建类型为Guy的实例）。你还可以使用`new`关键字而不带类型来创建一个**匿名类型**。这是一个完全有效的类型，具有只读属性，但没有名称。我们从将Jimmy的漫画与评论连接的查询中返回的类型就是匿名类型。你可以通过使用对象初始化程序为匿名类型添加属性。下面是其示例：
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Try pasting that into a new console app and running it. You’ll see this output:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将其粘贴到新的控制台应用程序中并运行它。你将看到以下输出：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now hover over `whatAmI` in the IDE and have a look at the IntelliSense window:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将鼠标悬停在IDE中的`whatAmI`上，并查看IntelliSense窗口：
- en: '![Images](assets/pg492-2a.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg492-2a.png)'
- en: Note
  id: totrans-177
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**The LINQ query we just saw that joins Jimmy’s comics with reviews returns
    an anonymous type. You’ll add that query to an app later in the chapter.**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们刚刚看到的将Jimmy的漫画与评论连接起来的LINQ查询返回了一个匿名类型。稍后的章节中，你将把该查询添加到应用程序中。**'
- en: 'The `whatAmI` variable is a reference type, just like any other reference.
    It points to an object on the heap, and you can use it to access that object’s
    members—in this case, two of its properties:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`whatAmI`变量是引用类型，就像任何其他引用一样。它指向堆上的一个对象，你可以使用它来访问该对象的成员——在本例中是其两个属性：'
- en: '[PRE20]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Besides the fact that they don’t have names, anonymous types are just like any
    other types.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 除了它们没有名称外，匿名类型和任何其他类型都一样。
- en: '![Images](assets/pg492-2.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg492-2.png)'
- en: '**Right! You use var to declare anonymous types.**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**没错！你使用`var`来声明匿名类型。**'
- en: In fact, that’s one of the most important uses of the `var` keyword.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这是`var`关键字的最重要用途之一。
- en: '![Images](assets/pg499.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg499.png)'
- en: Unit tests help you make sure your code works
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试帮助确保你的代码正常工作
- en: We intentionally left a bug in the code we gave you...but is that the *only*
    bug in the app? It’s easy to write code that doesn’t do exactly what you intended
    it to do. Luckily, there’s a way for us to find bugs so we can fix them. **Unit
    tests** are *automated* tests that help you make sure your code does what it’s
    supposed to do. Each unit test is a method that makes sure that a specific part
    of the code (the “unit” being tested) works. If the method runs without throwing
    an exception, it passes. If it throws an exception, it fails. Most large programs
    have a **suite** of tests that cover most or all of the code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在给你的代码中故意留了一个bug……但这是应用程序中*唯一*的bug吗？编写代码时很容易出现不符合预期的情况。幸运的是，我们有一种方法可以找到bug并加以修复。**单元测试**是*自动化*测试，可以帮助确保代码按预期工作。每个单元测试是一个方法，用于确保代码的特定部分（即被测试的“单元”）是否正常工作。如果方法运行时未抛出异常，则测试通过；如果抛出异常，则测试失败。大多数大型程序都有一套涵盖大部分或全部代码的**测试套件**。
- en: Visual Studio has built-in unit testing tools to help you write your tests and
    track which ones pass or fail. The unit tests in this book will use **MSTest**,
    a unit test framework (which means that it’s a set of classes that give you the
    tools to write unit tests) developed by Microsoft.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio内置了单元测试工具，帮助你编写测试并跟踪测试通过或失败的情况。本书中的单元测试将使用**MSTest**，这是由Microsoft开发的单元测试框架（意味着它是一组类，为你提供编写单元测试的工具）。
- en: Note
  id: totrans-189
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Visual Studio also supports unit tests written in NUnit and xUnit, two popular
    open source unit test frameworks for C# and .NET code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio还支持在NUnit和xUnit两种流行的开源单元测试框架中编写单元测试，这两种框架均适用于C#和.NET代码。
- en: Visual Studio for Windows has a Test Explorer window
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Visual Studio for Windows有一个测试资源管理器窗口
- en: Open the Test Explorer window by choosing ***View >> Test Explorer*** from the
    main menu bar. It shows you the unit tests on the left, and the results of the
    most recent run on the right. The toolbar has buttons to run all tests, run a
    single test, and repeat the last run.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择***View >> Test Explorer***从主菜单栏打开测试资源管理器窗口。左侧显示单元测试，右侧显示最近运行的结果。工具栏有按钮用于运行所有测试、运行单个测试和重复上次运行。
- en: '![Images](assets/pg500-1.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg500-1.png)'
- en: Note
  id: totrans-194
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**When you add unit tests to your solution, you can **`run`** your tests by
    clicking the Run All Tests button. You can **`debug`** your unit tests on Windows
    by choosing Tests >> Debug all tests, and on Mac by clicking Debug All Tests in
    the Unit Tests tool window.**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**当您向解决方案添加单元测试时，您可以通过点击“运行所有测试”按钮**`运行`**您的测试。您可以通过选择“测试 >> 调试所有测试”在 Windows
    上调试您的单元测试，并在 Mac 上通过在单元测试工具窗口中点击“调试所有测试”来调试。**'
- en: '![Images](assets/pg500-2.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg500-2.png)'
- en: Visual Studio for Mac has the Unit Tests tool window
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Visual Studio for Mac 拥有单元测试工具窗口。
- en: Open the Unit Test pad by choosing ***View >> Tool Windows >> Unit Tests***
    from the menu bar. It has buttons to run or debug your tests. When you run the
    unit tests, the IDE displays the results in a Test Results tool window (usually
    at the bottom of the IDE window).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择 ***视图 >> 工具窗口 >> 单元测试*** 打开单元测试面板。它有运行或调试您的测试的按钮。运行单元测试时，IDE 会在测试结果工具窗口中显示结果（通常在IDE窗口底部）。
- en: '![Images](assets/pg500-3.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg500-3.png)'
- en: Note
  id: totrans-200
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Back in [#objectshellipget_orientedexclamation_mar](ch03.html#objectshellipget_orientedexclamation_mar)
    you learned about prototypes, or early versions of games that you can play, test,
    learn from, and improve—and you saw how that idea can work with any kind of project,
    not just games. The same thing applies to testing. Sometimes the idea of testing
    software can seem a little abstract. Thinking about how game developers test their
    games can help us get used to the idea, and can make the concept of testing feel
    more intuitive.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 [#objectshellipget_orientedexclamation_mar](ch03.html#objectshellipget_orientedexclamation_mar)
    您了解到原型，或者可以玩、测试、学习和改进的游戏的早期版本，以及这个想法如何适用于任何类型的项目，而不仅仅是游戏。测试软件的概念有时可能显得有点抽象。考虑游戏开发人员如何测试他们的游戏可以帮助我们习惯这个想法，并使测试的概念更加直观。
- en: Note
  id: totrans-202
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Most development teams try to automate as much of their testing as possible,
    and run those tests before each commit. That way, they know if they inadvertently
    introduced a bug when they were making a fix or adding a new feature.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发团队尝试在每次提交之前自动化尽可能多的测试。这样，他们就知道在修复错误或添加新功能时是否无意中引入了 bug。
- en: Add a unit test project to Jimmy’s comic collection app
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Jimmy 的漫画收藏应用程序中添加一个单元测试项目。
- en: '**Add a new MSTest (.NET Core) project.**'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加一个新的 MSTest (.NET Core) 项目。**'
- en: 'Right-click on the solution name in the Solution Explorer, then choose **Add
    >> New Project...** from the menubar. Make sure it’s an **MSTest Test Project
    (.NET Core)**: on Windows use the “Search for Templates” box to search for MSTest;
    on macOS select Tests under “Web and Console” to see the project template. Name
    your project *JimmyLinqUnitTests*.'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中右键单击解决方案名称，然后选择 **添加 >> 新项目...** 从菜单栏。确保选择 **MSTest 测试项目 (.NET Core)**：在
    Windows 上使用“搜索模板”框搜索 MSTest；在 macOS 下选择“Web 和控制台”下的“测试”以查看项目模板。将项目命名为 *JimmyLinqUnitTests*。
- en: '**Add a dependency on your existing project.**'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在现有项目上添加依赖项。**'
- en: You’ll be building unit tests for the ComicAnalyzer class. When you have two
    different projects in the same solution, they’re *independent*—by default, the
    classes in one project can’t use classes in another project—so you’ll need to
    set up a dependency to let your unit tests use ComicAnalyzer.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您将为 ComicAnalyzer 类编写单元测试。当您在同一解决方案中有两个不同的项目时，它们是 *独立的*——默认情况下，一个项目中的类不能使用另一个项目中的类——因此，您需要设置依赖关系以让您的单元测试使用
    ComicAnalyzer。
- en: Expand the JimmyLinqUnitTests project in the Solution Explorer, then right-click
    on Dependencies and choose **Add Reference...** from the menu. Check the JimmyLinq
    project that you created for the exercise.
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 展开解决方案资源管理器中的 JimmyLinqUnitTests 项目，然后右键单击依赖项并选择 **添加引用...** 从菜单中选择检查您为练习创建的
    JimmyLinq 项目。
- en: '![Images](assets/pg502-1.png)'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg502-1.png)'
- en: '**Make your ComicAnalyzer class public.**'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使您的 ComicAnalyzer 类公开。**'
- en: 'When Visual Studio added the unit test project, it created a class called UnitTest1\.
    Edit the *UnitTest1.cs* file and try adding the `using JimmyLinq;` directive inside
    the namespace:'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当 Visual Studio 添加单元测试项目时，它会创建一个名为 UnitTest1 的类。编辑 *UnitTest1.cs* 文件，并尝试在命名空间内添加
    `using JimmyLinq;` 指令：
- en: '![Images](assets/pg502-2.png)'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg502-2.png)'
- en: Hmm, something’s wrong—the IDE won’t let you add the directive. The reason is
    that the JimmyLinq project has no public classes, enums, or other members. Try
    modifying the `Critics` enum to make it public (`**public enum Critics**`), then
    go back and try adding the `using` directive. Now you can add it! The IDE saw
    that the JimmyLinq namespace has public members, and added it to the pop-up window.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 哦，有些问题——IDE 不允许你添加该指令。原因是 JimmyLinq 项目没有公共类、枚举或其他成员。尝试修改 `Critics` 枚举以使其公开 (`**public
    enum Critics**`)，然后返回并尝试添加 `using` 指令。现在你可以添加它了！IDE 看到 JimmyLinq 命名空间有公共成员，并将其添加到弹出窗口中。
- en: 'Now change the ComicAnalyzer declaration to make it public: `**public static
    class ComicAnalyzer**`'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在将 ComicAnalyzer 声明更改为公共：`**public static class ComicAnalyzer**`
- en: '***Uh-oh—something’s wrong.*** Did you get a bunch of “Inconsistent accessibility”
    compiler errors?'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '***哎呀，出错了。*** 你收到了一堆“不一致的可访问性”编译器错误吗？'
- en: '![Images](assets/pg502-3.png)'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg502-3.png)'
- en: The problem is that ComicAnalyzer is public, but it exposes members that have
    no access modifiers, which makes them `**internal**`—so other projects in the
    solution can’t see them. **Add the `public` access modifier** to ***every*** ***class
    and enum*** in the JimmyLinq project. Now your solution will build again.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 问题在于 ComicAnalyzer 是公共的，但它公开了没有访问修饰符的成员，这使得它们 `**internal**` ——因此，解决方案中的其他项目无法看到它们。
    **在 JimmyLinq 项目中的每个类和枚举上添加 `public` 访问修饰符**。现在你的解决方案将再次构建成功。
- en: Write your first unit test
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写你的第一个单元测试
- en: 'The IDE added a class called UnitTest1 to your new MSTest project. Rename the
    class (and the file) ComicAnalyzerTests. The class contains a test method called
    TestMethod1\. Next, give it a very descriptive name: rename the method ComicAnalyzer_Should_Group_Comics.
    Here’s the code for your unit test class:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: IDE 向你的新 MSTest 项目中添加了一个名为 UnitTest1 的类。将该类（以及文件）重命名为 ComicAnalyzerTests。该类包含一个名为
    TestMethod1 的测试方法。接下来，给它起一个非常描述性的名称：将方法重命名为 ComicAnalyzer_Should_Group_Comics。这是你的单元测试类的代码：
- en: '![Images](assets/pg503-1.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg503-1.png)'
- en: Note
  id: totrans-222
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**When you run your unit tests in the IDE, it looks for any class with `[TestClass]`
    above it. That’s called an attribute. A test class includes test methods, which
    must be marked with the `[TestMethod]` attribute.**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**当你在 IDE 中运行单元测试时，它会查找任何带有 `[TestClass]` 的类。这称为属性。测试类包含测试方法，必须使用 `[TestMethod]`
    属性进行标记。**'
- en: '**MSTest unit tests use the Assert class, which has static methods that you
    can use to check that your code behaves the way you expect it to. This unit test
    uses the Assert.AreEqual method. It takes two parameters, an expected result (what
    you think the code should do) and an actual result (what it actually does), and
    throws an exception if they’re not equal.**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**MSTest 单元测试使用 Assert 类，该类具有你可以用来检查代码行为的静态方法。此单元测试使用 Assert.AreEqual 方法。它接受两个参数，预期结果（你认为代码应该做什么）和实际结果（它实际上做了什么），如果它们不相等则抛出异常。**'
- en: '**This test sets up some very limited test data: a sequence of three comics
    and a dictionary with three prices. Then it calls GroupComicsByPrice and uses
    Assert.AreEqual to validate that the results match what we expect.**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**此测试设置了一些非常有限的测试数据：三部漫画的序列和一个包含三个价格的字典。然后调用 GroupComicsByPrice，并使用 Assert.AreEqual
    来验证结果是否与我们预期的一致。**'
- en: 'Run your test by choosing **Test >> Run All Tests** (Windows) or **Run >> Run
    Unit Tests** (Mac) from the menubar. The IDE will pop up a Test Explorer window
    (Windows) or Test Results panel (Mac) with the test results:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择 **测试 >> 运行所有测试**（Windows）或 **运行 >> 运行单元测试**（Mac）来运行你的测试。IDE 将弹出一个测试资源管理器窗口（Windows）或测试结果面板（Mac），显示测试结果：
- en: '[PRE21]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is the result of a **failed unit test**. Look for the ![Images](assets/pg503-2.png)
    icon in Windows or the ![Images](assets/pg503-3.png) message at the bottom of
    the IDE window in Visual Studio for Mac—that’s how you see a count of your failed
    unit tests.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 **失败的单元测试** 结果。在 Windows 中，查找 ![图片](assets/pg503-2.png) 图标或在 Visual Studio
    for Mac 窗口底部查看 ![图片](assets/pg503-3.png) 消息，这是你查看失败单元测试计数的方法。
- en: '***Did you expect that unit test to fail? Can you figure out what went wrong
    with the test?***'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '***你期待该单元测试失败吗？你能弄清楚测试出了什么问题吗？***'
- en: Write a unit test for the GetReviews method
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 GetReviews 方法编写一个单元测试
- en: The unit test for the GroupComicsByPrice method used MSTest’s static Assert.AreEqual
    method to check expected values against actual ones. The GetReviews method *returns
    a sequence of strings*, not an individual value. We *could* use Assert.AreEqual
    to compare individual elements in that sequence, just like we did with the last
    two assertions, using LINQ methods like First to get specific elements...but that
    would take a LOT of code.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: GroupComicsByPrice 方法的单元测试使用了 MSTest 的静态 Assert.AreEqual 方法来检查预期值与实际值。GetReviews
    方法*返回一个字符串序列*，而不是单个值。我们*可以*使用 Assert.AreEqual 来比较该序列中的单个元素，就像我们在最后两个断言中所做的那样，使用
    LINQ 方法如 First 来获取特定元素……但那会需要大量的代码。
- en: 'Luckily, MSTest has a better way to compare collections: the **CollectionAssert
    class** has static methods for comparing expected versus actual collection results.
    So if you have a collection with expected results and a collection with actual
    results, you can compare them like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，MSTest 有一种更好的比较集合的方法：**CollectionAssert 类**有用于比较预期结果与实际集合结果的静态方法。因此，如果你有一个包含预期结果的集合和一个包含实际结果的集合，你可以像这样进行比较：
- en: '[PRE22]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If the expected and actual results don’t match the test will fail. Go ahead
    and **add this test** to validate the ComicAnalyzer.GetReviews method:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果预期结果和实际结果不匹配，测试将失败。继续**添加这个测试**以验证 ComicAnalyzer.GetReviews 方法：
- en: '[PRE23]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now run your tests again. You should see two unit tests pass.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新运行你的测试。你应该会看到两个单元测试通过。
- en: Write unit tests to handle edge cases and weird data
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写单元测试以处理边界情况和奇怪的数据
- en: In the real world, data is messy. For example, we never really told you exactly
    what review data is supposed to look like. You’ve seen review scores between 0
    and 100\. Did you assume those were the only values allowed? That’s definitely
    the way some review websites in the real world operate. What if we get some weird
    review scores—like negative ones, or really big ones, or zero? What if we get
    more than one score from a reviewer for an issue? Even if these things aren’t
    *supposed to* happen, they *might* happen.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，数据通常是混乱的。例如，我们从未准确告诉你评论数据应该是什么样子的。你见过评论分数在0到100之间。你以为这些是唯一允许的值吗？在现实世界中，确实有一些评论网站是这样操作的。如果我们得到一些奇怪的评论分数——比如负数、非常大的数或者零怎么办？如果一个评审人为同一个问题给出多个评分怎么办？即使这些事情*本不应该*发生，它们*可能*会发生。
- en: 'We want our code to be **robust**, which means that it handles problems, failures,
    and especially bad input data well. So let’s build a unit test that passes some
    weird data to GetReviews and makes sure it doesn’t break:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的代码**健壮**，这意味着它能很好地处理问题、失败，特别是坏的输入数据。因此，让我们构建一个单元测试，向 GetReviews 传递一些奇怪的数据，并确保它不会出问题：
- en: '![Images](assets/pg506.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg506.png)'
- en: Note
  id: totrans-241
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Always take time to write unit tests for edge cases and weird data—think of
    them as “must-have” and not “nice-to-have” tests. The point of unit testing is
    to cast the widest possible net to catch bugs, and these kinds of tests are really
    effective for that.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 总是抽出时间为边界情况和奇怪的数据编写单元测试——把它们看作“必需”而不是“可有”的测试。单元测试的目的是尽可能广泛地捕捉错误，这些类型的测试对此非常有效。
- en: '**It’s really important to add unit tests that handle edge cases and weird
    data. They can help you spot problems in your code that you wouldn’t find otherwise.**'
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**添加处理边界情况和奇怪数据的单元测试非常重要。它们可以帮助你发现你代码中否则无法找到的问题。**'
- en: '![Images](assets/pg507.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg507.png)'
- en: '**Your projects actually go faster when you write unit tests.**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**当你编写单元测试时，实际上你的项目会更快。**'
- en: We’re serious! It may seem counterintuitive that it takes *less time* to write
    *more code*, but if you’re in the habit of writing unit tests, your projects go
    a lot more smoothly because you find and fix bugs early. You’ve written a lot
    of code so far in the first eight and a half chapters of this book, which means
    you’ve almost certainly had to track down and fix bugs in your code. When you
    fixed those bugs, did you have to fix other code in your project too? When we
    find an unexpected bug, we often have to stop what we’re doing to track it down
    and fix it, and switching back and forth like that—losing our train of thought,
    having to interrupt our flow—can really slow things down. Unit tests help you
    find those bugs early, before they have a chance to interrupt your work.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是认真的！也许你觉得写*更多代码*却花费*更少时间*有些反直觉，但是如果你习惯于编写单元测试，你的项目将会更加顺利，因为你能早期发现并修复 Bug。在本书的前八个半章节中，你已经写了大量代码，这意味着你几乎肯定不得不追踪并修复过代码中的
    Bug。当你修复这些 Bug 时，是否需要同时修复项目中的其他代码？当我们发现意外 Bug 时，通常必须停下手头的工作来追踪和修复它，这样来回切换—丢失思路，不得不打断工作流—可能会减慢工作速度。单元测试帮助你早期发现这些
    Bug，在它们干扰你工作之前。
- en: '***Still wondering exactly when unit tests should be written? We included a
    downloadable project at the end of the chapter to help answer that question.***'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '***还在疑惑什么时候应该编写单元测试吗？我们在章节末尾包含了一个可下载的项目来帮助解答这个问题。***'
- en: Use the => operator to create lambda expressions
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 => 运算符创建 Lambda 表达式
- en: '***We left you hanging back at the beginning of the chapter.*** Remember that
    mysterious line we asked you to add to the Comic class? Here it is again:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '***我们在章节开头留下了你的疑问。*** 还记得我们让你在 Comic 类中添加的神秘行吗？在这里又是一次：'
- en: '[PRE24]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You’ve been using that ToString method throughout the chapter—you know it works.
    What would you do if we asked you to rewrite that method the way you’ve been writing
    methods so far? You might write something like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你在整章中一直在使用 ToString 方法—你知道它能工作。如果我们要求你按照迄今为止编写方法的方式来重写该方法，你可能会写出这样的代码：
- en: '[PRE25]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: And you’d basically be right. So what’s going on? What exactly is that => operator?
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上你是对的。那到底发生了什么？那个 => 运算符到底是什么？
- en: 'The => operator that you used in the ToString method is the **lambda operator**.
    You can use => to define a **lambda expression**, or an *anonymous function* defined
    within a single statement. Lambda expressions look like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 ToString 方法中使用的 => 运算符是**Lambda运算符**。你可以使用 => 定义**Lambda表达式**，或者在单个语句中定义的*匿名函数*。Lambda
    表达式看起来像这样：
- en: '[PRE26]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'There are two parts to a lambda expression:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式分为两部分：
- en: The `input-parameters` part is a list of parameters, just like you’d use when
    you declare a method. If there’s only one parameter, you can leave off the parentheses.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`input-parameters` 部分是一个参数列表，就像你在声明方法时使用的那样。如果只有一个参数，可以省略括号。'
- en: 'The `expression` is any C# expression: it can be an interpolated string, a
    statement that uses an operator, a method call—pretty much anything you would
    put in a statement.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expression` 是任何 C# 表达式：可以是插值字符串，使用运算符的语句，方法调用—基本上你放在语句中的任何东西。'
- en: Lambda expressions may look a little weird at first, but they’re just another
    way of using the ***same familiar C# expressions*** that you’ve been using throughout
    the book—just like the Comic.ToString method, which works the same way whether
    or not you use a lambda expression.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式起初可能看起来有些奇怪，但它们只是使用*同样熟悉的 C# 表达式*的另一种方式，这些表达式你在整本书中都在使用—就像 Comic.ToString
    方法一样，无论你是否使用 Lambda 表达式，它都能正常工作。
- en: '![Images](assets/pg508.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg508.png)'
- en: '**Yes! You can use lambda expressions to refactor many methods and properties.**'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**是的！你可以使用 Lambda 表达式重构许多方法和属性。**'
- en: You’ve written a lot of methods throughout this book that contain just a single
    statement. You could refactor most of them to use lambda expressions instead.
    In many cases, that could make your code easier to read and understand. Lambdas
    give you options—you can decide when using them improves your code.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，你已经编写了很多仅包含一个语句的方法。你可以将其中大部分重构为使用 Lambda 表达式。在许多情况下，这可以使你的代码更易于阅读和理解。Lambda
    给你提供了选择—你可以决定何时使用它们来改进你的代码。
- en: A lambda test drive
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda 测试驱动
- en: '![Images](assets/coma.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/coma.png)'
- en: Let’s kick the tires on lambda expressions, which give us a whole new way to
    write methods, including ones that return values or take parameters.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试用一下 Lambda 表达式，这为我们提供了一种全新的编写方法的方式，包括返回值或者带参数的方法。
- en: '**Create a new console app**. Add this Program class with the Main method:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个新的控制台应用**。添加这个带有Main方法的Program类：'
- en: '[PRE27]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![Images](assets/pg509-1.png)'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg509-1.png)'
- en: 'Run it a few times. Each time it prints a different random number, as in: `The
    value is 37.8709`'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行几次。每次它都会打印一个不同的随机数，例如：`The value is 37.8709`
- en: '**Refactor the GetRandomDouble and PrintValue methods** using the => operator:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 => 运算符**重构GetRandomDouble和PrintValue方法**：
- en: '![Images](assets/pg509-2.png)'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg509-2.png)'
- en: Run your program again—it should print a different random number, just like
    before.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次运行你的程序——它应该像以前一样打印不同的随机数。
- en: 'Before we do one more refactoring, **hover over the random field** and look
    at the IntelliSense pop-up:'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们进行最后一次重构之前，**悬停在随机字段**上并查看IntelliSense弹出窗口：
- en: '![Images](assets/pg509-3.png)'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg509-3.png)'
- en: '**Modify the random field** to use a lambda expression:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**修改随机字段**以使用lambda表达式：'
- en: '[PRE28]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The program still runs the same way. Now **hover over the random field** again:'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 程序仍然以相同的方式运行。现在再次**悬停在随机字段**上：
- en: '![Images](assets/pg509-4.png)'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg509-4.png)'
- en: Wait a minute—random isn’t a field anymore. Changing it into a lambda turned
    it into a property! That’s because **lambda expressions always work like methods**.
    So when random was a field, it got instantiated once when the class was constructed.
    When you changed the = to a => and converted it to a lambda, it became a method—which
    means ***a new instance of Random is created every time the property is accessed***.
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 等一下——random不再是一个字段了。将它改成lambda表达式将它变成了一个属性！这是因为**lambda表达式总是像方法一样工作**。所以当random是一个字段时，它在类构造时被实例化一次。当你把=改成=>并将其转换为lambda时，它变成了一个方法——这意味着每次访问属性时都会创建一个新的Random实例。
- en: Refactor a clown with lambdas
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用lambda重构小丑
- en: 'Back in [#interfacescomma_castingcomma_and_quotati](ch07.html#interfacescomma_castingcomma_and_quotati),
    you created an IClown interface with two members:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 [#interfacescomma_castingcomma_and_quotati](ch07.html#interfacescomma_castingcomma_and_quotati)，你创建了一个名为IClown的接口，有两个成员：
- en: '***Do this!***'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '***去做吧！***'
- en: '![Images](assets/pg509-5a.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg509-5a.png)'
- en: 'And you modified this class to implement that interface:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你修改了这个类来实现该接口：
- en: '[PRE29]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let’s do that same thing again—but this time we’ll use lambdas. **Create a
    new Console App** **project** and add the IClown interface and TallGuy class.
    Then modify TallGuy to implement IClown:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再做同样的事情——但这次我们将使用lambda表达式。**创建一个新的控制台应用程序项目**，并添加IClown接口和TallGuy类。然后修改TallGuy以实现IClown：
- en: '[PRE30]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now open the Quick Actions menu and choose **“Implement interface.”** The IDE
    fills in all of the interface members, having them throw NotImplementedExceptions
    just like it does when you use Generate Method.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开快速操作菜单，选择**“实现接口。”**IDE将填写所有接口成员，使它们像使用生成方法时一样抛出NotImplementedExceptions。
- en: '![Images](assets/pg510-2.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg510-2.png)'
- en: 'Let’s refactor these methods so they do the same thing as before, but now use
    lambda expressions:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构这些方法，使它们能够像以前一样完成相同的工作，但现在使用lambda表达式：
- en: '[PRE31]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![Images](assets/pg510-3.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg510-3.png)'
- en: 'Now add the same Main method you used back in [#interfacescomma_castingcomma_and_quotati](ch07.html#interfacescomma_castingcomma_and_quotati):'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加与你在 [#interfacescomma_castingcomma_and_quotati](ch07.html#interfacescomma_castingcomma_and_quotati)
    中使用的相同的Main方法：
- en: '[PRE32]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Run your app. The TallGuy class works just like it did in [#interfacescomma_castingcomma_and_quotati](ch07.html#interfacescomma_castingcomma_and_quotati),
    but now that we’ve refactored its members to use lambda expressions it’s more
    compact.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的应用程序。TallGuy类的工作方式与 [#interfacescomma_castingcomma_and_quotati](ch07.html#interfacescomma_castingcomma_and_quotati)
    中一样，但现在我们已经重构了它的成员，使用lambda表达式使得它更加紧凑。
- en: '***We think the new and improved TallGuy class is easier to read. Do you?***'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '***我们认为经过改进的TallGuy类更容易阅读。你觉得呢？***'
- en: '![Images](assets/pg510-4.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg510-4.png)'
- en: '**You can use the => operator to create a property with a get accessor that
    executes a lambda expression.**'
  id: totrans-298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**你可以使用 => 运算符创建一个具有get访问器执行lambda表达式的属性。**'
- en: 'Use the ?: operator to make your lambdas make choices'
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '使用 ?: 运算符让你的lambda表达式做出选择'
- en: 'What if you want your lambdas to do... more? It would be great if they could
    make decisions...and that’s where the **conditional operator** (which some people
    call the **ternary operator**) comes in. It works like this:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望你的lambda做更多的事情怎么办？如果它们能做出决策就好了……这就是**条件运算符**（有些人称之为**三元运算符**）派上用场的地方。它的工作方式如下：
- en: '[PRE33]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'which may look a little weird at first, so let’s have a look at an example.
    First of all, the ?: operator isn’t unique to lambdas—you can use it anywhere.
    Take this `if` statement from the AbilityScoreCalculator class in [#types_and_references_getting_the_referen](ch04.html#types_and_references_getting_the_referen):'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '刚开始可能看起来有点奇怪，所以让我们看一个示例。首先，?: 运算符并不局限于 lambda 表达式——你可以在任何地方使用它。从 AbilityScoreCalculator
    类中的 `if` 语句中取这个 `if` 语句：'
- en: '![Images](assets/pg513-1.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg513-1.png)'
- en: 'Notice how we set Score equal to the results of the ?: expression. The ?: expression
    **returns a value**: it checks the *condition* (added < Minimum), and then it
    either returns the *consequent* (Minimum) or the *alternative* (added).'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '注意如何将 Score 设置为 ?: 表达式的结果。?: 表达式**返回一个值**：它检查*条件*（added < Minimum），然后返回*结果*（Minimum）或*替代项*（added）。'
- en: 'When you have a method that looks like that `if/else` statement, you can **use
    ?:** **to refactor it as a lambda**. For example, take this method from the PaintballGun
    class in [#encapsulation_keep_your_privateshellippr](ch05.html#encapsulation_keep_your_privateshellippr):'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '当你有一个看起来像 `if/else` 语句的方法时，你可以**使用 ?: 来将其重构为 lambda**。例如，从 PaintballGun 类中的方法获取：'
- en: '![Images](assets/pg513-2.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg513-2.png)'
- en: 'Let’s rewrite that as a more concise lambda expression:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其重写为更简洁的 lambda 表达式：
- en: Notice the slight change—in the `if/else` version, the BallsLoaded property
    was set inside the then- and else-statements. We changed this to use a conditional
    operator that checked balls against MAGAZINE_SIZE and returned the correct value,
    and used that return value to set the BallsLoaded property.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 注意细微的变化——在 `if/else` 版本中，BallsLoaded 属性是在 then 和 else 语句中设置的。我们改为使用条件运算符来检查
    balls 是否符合 MAGAZINE_SIZE 并返回正确的值，并使用该返回值设置 BallsLoaded 属性。
- en: Lambda expressions and LINQ
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda 表达式和 LINQ
- en: 'Add this small LINQ query to any C# app, then hover over the `select` keyword
    in the code:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 将此小型 LINQ 查询添加到任何 C# 应用程序中，然后将鼠标悬停在代码中的 `select` 关键字上：
- en: '![Images](assets/pg514-1.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg514-1.png)'
- en: 'The IDE pops up a tooltip window just like it does ***when you hover over a
    method.*** Let’s take a closer look at the first line, which shows the method
    declaration:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: IDE 弹出一个工具提示窗口，就像你悬停在方法上时一样***。让我们更仔细地看一看第一行，显示了方法声明：
- en: '![Images](assets/pg514-2.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg514-2.png)'
- en: 'We can learn a few things from that method declaration:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从该方法声明中学到一些东西：
- en: The IEnumerable<int>.Select method returns an IEnumerable<int>.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IEnumerable<int>.Select 方法返回一个 IEnumerable<int>。
- en: It takes a single parameter of type Func<int, int>.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它接受一个类型为 Func<int, int> 的单一参数。
- en: Use lambda expressions with methods that take a Func parameter
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用带有 Func 参数的方法的 lambda 表达式
- en: 'When a method takes a Func<int, int> parameter, you can **call it with a lambda
    expression** that takes an int parameter and returns an int value. So you could
    refactor the select query like this:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法接受一个 Func<int, int> 参数时，你可以**使用一个接受 int 参数并返回 int 值的 lambda 表达式来调用它**。因此，你可以像这样重构
    select 查询：
- en: '[PRE34]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Go ahead—try that yourself in a console app. Add a foreach statement to print
    the output:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 前往——尝试在控制台应用程序中自己尝试。添加一个 foreach 语句来打印输出：
- en: '[PRE35]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When you print the results of the refactored query, you’ll get the sequence
    { 2, 4, 6, 8 }—exactly the same result as you got with the LINQ query syntax before
    you refactored it.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印重构后的查询结果时，你会得到序列 { 2, 4, 6, 8 }，与你在重构之前使用 LINQ 查询语法获得的结果完全相同。
- en: LINQ queries can be written as chained LINQ methods
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LINQ 查询可以编写为链式 LINQ 方法
- en: 'Take this LINQ query from earlier and **add it to an app** so we can explore
    a few more LINQ methods:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的 LINQ 查询中获取这个 LINQ 查询，**将其添加到一个应用程序**中，以便我们可以探索更多的 LINQ 方法：
- en: '[PRE36]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The OrderBy LINQ method sorts a sequence
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OrderBy LINQ 方法对序列进行排序
- en: 'Hover over the `**orderby**` keyword and take a look at its parameter:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 悬停在 `**orderby**` 关键字上，并查看其参数：
- en: '![Images](assets/pg515-1.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg515-1.png)'
- en: When you use an `orderby` clause in a LINQ query, it calls a LINQ OrderBy method
    that sorts the sequence. In this case, we can pass it a lambda expression with
    an int parameter that **returns the sort key**, or any value (which must implement
    IComparer) that it can use to sort the results.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 LINQ 查询中使用 `orderby` 子句时，它调用一个 LINQ OrderBy 方法对序列进行排序。在这种情况下，我们可以传递一个带有
    int 参数的 lambda 表达式**返回排序键**，或者实现了 IComparer 的任何值（必须实现 IComparer），以便它可以用来对结果进行排序。
- en: The Where LINQ method pulls out a subset of a sequence
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Where LINQ 方法从序列中提取一个子集
- en: 'Now hover over the `**where**` keyword in the LINQ query:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将鼠标悬停在 LINQ 查询中的 `**where**` 关键字上：
- en: '![Images](assets/pg515-2.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg515-2.png)'
- en: The `where` clause in a LINQ query calls a LINQ Where method that can use a
    lambda that returns a Boolean. ***The Where method calls that lambda for each
    element in the sequence***. If the lambda returns true, the element is included
    in the results. If the lambda returns false, the element is removed.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`where` 子句在 LINQ 查询中调用一个 LINQ Where 方法，该方法可以使用返回布尔值的 lambda 表达式。***Where 方法针对序列中的每个元素调用该
    lambda 表达式***。如果 lambda 表达式返回 true，则将该元素包含在结果中。如果 lambda 表达式返回 false，则将该元素移除。'
- en: Use the `=>` operator to create switch expressions
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 => 运算符创建 switch 表达式
- en: 'You’ve been using `switch` statements since [#inheritance_your_objectapostrophes_famil](ch06.html#inheritance_your_objectapostrophes_famil)
    to check a variable against several options. It’s a really useful tool... but
    have you noticed its limitations? For example, try adding a case that tests against
    a variable:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 自从[#inheritance_your_objectapostrophes_famil](ch06.html#inheritance_your_objectapostrophes_famil)以来，您一直在使用
    `switch` 语句来检查变量是否符合多个选项。这是一个非常有用的工具……但您是否注意到了它的局限性？例如，尝试添加一个针对变量的 case：
- en: '[PRE37]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You’ll get a C# compiler error: *A constant value is expected.* That’s because
    you can only use constant values—like literals and variables defined with the
    `const` keyword—in the `switch` statements that you’ve been using.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 您将收到一个 C# 编译器错误：*需要常量值*。这是因为您只能在您一直在使用的 `switch` 语句中使用常量值，例如文字常量和使用 `const`
    关键字定义的变量。
- en: But that all changes with the `=>` operator, which lets you create **switch
    expressions**. They’re similar to the `switch` statements that you’ve been using,
    but they’re *expressions* that return a value. A switch expression starts with
    a value to check and the `switch` keyword followed by a series of *switch arms*
    in curly brackets separated by commas. Each switch arm uses the => operator to
    check the value against an expression. If the first arm doesn’t match, it moves
    on to the next one, returning the value for the matching arm.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，`=>` 运算符改变了一切，它让您可以创建 **switch 表达式**。它们与您一直在使用的 `switch` 语句类似，但它们是*表达式*，会返回一个值。switch
    表达式以要检查的值开头，后跟关键字 `switch`，然后是一系列用逗号分隔的*switch arm*，在花括号内。每个 switch arm 使用 =>
    运算符根据表达式检查值。如果第一个 arm 不匹配，则移动到下一个 arm，返回匹配 arm 的值。
- en: '![Images](assets/pg517-1.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg517-1.png)'
- en: 'Let’s say you’re working on a card game that needs to assign a certain score
    based on suit, where spades are worth 6, hearts are worth 4, and other cards are
    worth 2\. You could write a `switch` statement like this:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在开发一个需要根据花色分配特定分数的纸牌游戏，其中黑桃值为 6，红心值为 4，其他牌值为 2。您可以编写如下的 `switch` 语句：
- en: '![Images](assets/pg517-2.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg517-2.png)'
- en: 'The whole goal of this `switch` statement is to use the cases to set the `score`
    variable—and a lot of our `switch` statements work that way. We can use the =>
    operator to create a switch expression that does the same thing:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `switch` 语句的整个目的是使用 case 来设置 `score` 变量——我们的许多 `switch` 语句都是这样工作的。我们可以使用 =>
    运算符创建一个执行相同操作的 switch 表达式：
- en: '![Images](assets/pg517-3.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg517-3.png)'
- en: Explore the Enumerable class
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Enumerable 类
- en: We’ve been using sequences for a while. We know they work with `foreach` loops
    and LINQ. But what, exactly, makes sequences tick? Let’s take a deeper dive to
    find out. We’ll start with the **Enumerable class**—specifically, with its three
    static methods, Range, Empty, and Repeat. You already saw the Enumerable.Range
    method earlier in the chapter. Let’s use the IDE to discover how the other two
    methods work. Type `**Enumerable**`. and then hover over Range, Empty, and Repeat
    in the IntelliSense pop-up to see their declarations and comments.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用序列一段时间了。我们知道它们可以与 `foreach` 循环和 LINQ 一起使用。但究竟是什么使序列运行起来？让我们深入探讨一下。我们将从
    **Enumerable 类** 开始——具体来说，是它的三个静态方法，Range、Empty 和 Repeat。您已经在本章的早些时候看到了 Enumerable.Range
    方法。让我们使用 IDE 发现其他两种方法的工作原理。键入 `**Enumerable**`。，然后将鼠标悬停在 IntelliSense 弹出窗口中的 Range、Empty
    和 Repeat 上，以查看它们的声明和注释。
- en: '![Images](assets/pg521.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg521.png)'
- en: Enumerable.Empty creates an empty sequence of any type
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Enumerable.Empty 创建任何类型的空序列
- en: 'Sometimes you need to pass an empty sequence to a method that takes an IEnumerable<T>
    (for example, in a unit test). The **Enumerable.Empty method** comes in handy
    in these cases:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，您需要向接受 IEnumerable<T> 的方法传递一个空序列（例如，在单元测试中）。在这些情况下，**Enumerable.Empty 方法**非常方便：
- en: '[PRE38]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Enumerable.Repeat repeats a value a number of times
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Enumerable.Repeat 重复一个值多次
- en: 'Let’s say you need a sequence of 100 3s, or 12 “yes” strings, or 83 identical
    anonymous objects. You’d be surprised at how often that happens! You can use the
    **Enumerable.Repeat method** for this—it returns a sequence of repeated values:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要一个包含 100 个 `3s`、12 个 “yes” 字符串或者 83 个相同匿名对象的序列。你会惊讶地发现这种情况经常发生！你可以使用 **Enumerable.Repeat
    方法**来做到这一点——它返回一个重复值的序列：
- en: '[PRE39]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: So what exactly is an IEnumerable<T>?
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么，究竟什么是 IEnumerable<T>？
- en: We’ve been using IEnumerable<T> for a while now. We haven’t really answered
    the question of what an enumerable sequence *actually is*. A really effective
    way to understand something is to build it ourselves, so let’s finish the chapter
    by building some sequences from the ground up.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用 IEnumerable<T> 一段时间了。我们还没有真正回答可枚举序列到底是什么的问题。理解某个东西的一个真正有效的方法是从头开始构建它，所以让我们通过从头开始构建一些序列来完成本章。
- en: Create an enumerable sequence by hand
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动创建一个可枚举序列
- en: 'Let’s say we have some sports:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一些体育运动：
- en: '[PRE40]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Obviously, we could create a new List<Sport> and use a collection initializer
    to populate it. But for the sake of exploring how sequences work, we’ll build
    one manually. Let’s create a new class called ManualSportSequence and make it
    implement the IEnumerable<Sport> interface. It just has two members that return
    an IEnumerator:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可以创建一个新的 List<Sport> 并使用集合初始化器来填充它。但是为了探索序列如何工作，我们将手动构建一个。让我们创建一个名为 ManualSportSequence
    的新类，并使其实现 IEnumerable<Sport> 接口。它只有两个成员，返回一个 IEnumerator：
- en: '![Images](assets/pg522-1.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg522-1.png)'
- en: OK, so what’s an IEnumerator? It’s an interface that lets you enumerate a sequence,
    moving through each item in the sequence one after another. It has a property,
    Current, which returns the current item being enumerated. Its MoveNext method
    moves to the next element in the sequence, returning false if the sequence has
    run out. After MoveNext is called, Current returns that next element. Finally,
    the Reset method resets the sequence back to the beginning. Once you have those
    methods, you have an enumerable sequence.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么 IEnumerator 是什么？它是一个接口，允许你枚举一个序列，逐个遍历序列中的每个项目。它有一个属性，Current，返回当前正在枚举的项目。它的
    MoveNext 方法移动到序列中的下一个元素，如果序列已经耗尽，则返回 false。在调用 MoveNext 后，Current 返回下一个元素。最后，Reset
    方法将序列重置回起始状态。一旦你有了这些方法，你就有了一个可枚举序列。
- en: '![Images](assets/pg522-2.png)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg522-2.png)'
- en: 'So let’s implement an IEnumerator<Sport>:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们实现一个 IEnumerator<Sport>：
- en: '![Images](assets/pg522-3.png)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg522-3.png)'
- en: 'And that’s all we need to create our own IEnumerable. Go ahead—give it a try.
    **Create a new console app**, add ManualSportSequence and ManualSportEnumerator,
    and then enumerate the sequence in a `foreach` loop:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们创建自己的 IEnumerable 所需的全部内容。继续——试试吧。**创建一个新的控制台应用程序**，添加 ManualSportSequence
    和 ManualSportEnumerator，然后在 `foreach` 循环中枚举这个序列：
- en: '[PRE41]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Use yield return to create your own sequences
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `yield return` 来创建你自己的序列
- en: 'C# gives you a much easier way to create enumerable sequences: the `**yield
    return statement**`. The `yield return` statement is a kind of all-in-one automatic
    enumerator creator. A good way to understand it is to see an example. Let’s use
    a **multiproject solution**, just to give you a little more practice with that.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: C# 提供了一种更容易创建可枚举序列的方法：`**yield return**` 语句。`yield return` 语句是一种全自动枚举器创建器。理解它的一个好方法是看一个例子。让我们使用
    **多项目解决方案**，这样你就能更多地练习一下。
- en: '**Add a new Console App project to your solution**—this is just like what you
    did when you added the MSTest project earlier in the chapter, except this time
    instead of choosing the project type MSTest choose the same Console App project
    type that you’ve been using for most of the projects in the book. Then right-click
    on the project under the solution and **choose “Set as startup project.”** Now
    when you launch the debugger in the IDE, it will run the new project. You can
    also right-click on any project in the solution and run or debug it.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '**将新的控制台应用程序项目添加到你的解决方案中** —— 这与你之前在章节中添加 MSTest 项目时所做的操作一样，只不过这次不是选择 MSTest
    项目类型，而是选择你在书中大多数项目中使用的相同控制台应用程序项目类型。然后，在解决方案下右键单击项目，选择 “Set as startup project.”
    当你在IDE中启动调试器时，它将运行新项目。你也可以右键单击解决方案中的任何项目并运行或调试它。'
- en: 'Here’s the code for the new console app:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新控制台应用程序的代码：
- en: '![Images](assets/pg523-1.png)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg523-1.png)'
- en: 'Run the app—it prints four lines: `apples`, `oranges`, `bananas`, and `unicorns`.
    So how does that work?'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序 —— 它会打印出四行：`apples`、`oranges`、`bananas` 和 `unicorns`。那么这是如何工作的呢？
- en: Use the debugger to explore yield return
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用调试器探索 yield return
- en: 'Set a breakpoint on the first line of the Main method and launch the debugger.
    Then use **Step Into** (F11 / ![Images](assets/pg523-2a.png)) to debug the code
    line by line, right into the iterator:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Main` 方法的第一行设置一个断点，然后启动调试器。然后使用**逐步执行**（F11 / ![图片](assets/pg523-2a.png)）逐行调试代码，直到进入迭代器：
- en: Step into the code, and keep stepping into it until you reach the first line
    of the SimpleEnumerable method.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入代码，并一直步进直到到达 `SimpleEnumerable` 方法的第一行。
- en: Step into that line again. It acts just like a `return` statement, returning
    control back to the statement that called it—in this case, back to the `foreach`
    statement, which calls Console.WriteLine to write `apples`.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次进入该行。它的作用就像是一个 `return` 语句，将控制权返回给调用它的语句——在本例中，回到了 `foreach` 语句，后者调用 `Console.WriteLine`
    输出 `apples`。
- en: 'Step two more times. Your app will jump back into the SimpleEnumerable method,
    but ***it skips the first statement in the method*** and goes right to the second
    line:'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再向前迈出两步。你的应用程序将回到 `SimpleEnumerable` 方法，但***跳过方法的第一条语句***，直接进入第二行：
- en: '![Images](assets/pg523-2.png)'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/pg523-2.png)'
- en: Keep stepping. The app returns to the `foreach` loop, then back to the ***third
    line*** of the method, then returns to the `foreach` loop, and goes back to the
    ***fourth line*** of the method.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续步进。应用程序返回到 `foreach` 循环，然后回到方法的***第三行***，然后返回到 `foreach` 循环，再回到方法的***第四行***。
- en: So `yield return` makes a method **return an enumerable sequence** by returning
    the next element in the sequence each time it’s called, and keeping track of where
    it returned from so it can pick up where it left off.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`yield return` 使一个方法**返回一个可枚举序列**，每次调用时返回序列中的下一个元素，并跟踪它返回的位置，以便可以从上次离开的地方继续执行。
- en: Use yield return to refactor ManualSportSequence
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `yield return` 重构 `ManualSportSequence`
- en: 'You can create your own IEnumerable<T> by **using `yield return` to implement
    the GetEnumerator method**. For example, here’s a BetterSportSequence class that
    does exactly the same thing as ManualSportSequence did. This version is much more
    compact because it uses `yield return` in its GetEnumerator implementation:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过**使用 `yield return` 实现 `GetEnumerator` 方法**来创建自己的 `IEnumerable<T>`。例如，这里有一个
    `BetterSportSequence` 类，它与 `ManualSportSequence` 做的事情完全一样。这个版本更加紧凑，因为它在其 `GetEnumerator`
    实现中使用了 `yield return`：
- en: '![Images](assets/pg524.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg524.png)'
- en: Go ahead and **add a new Console App project to your solution**. Add this new
    BetterSportSequence class, and modify the Main method to create an instance of
    it and enumerate the sequence.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 继续**添加新的控制台应用程序项目到你的解决方案**。添加这个新的 `BetterSportSequence` 类，并修改 `Main` 方法来创建它的实例并枚举序列。
- en: Add an indexer to BetterSportSequence
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 `BetterSportSequence` 添加一个索引器
- en: You’ve seen that you can use `yield return` in a method to create an IEnumerator<T>.
    You can also use it to create a class that implements IEnumerable<T>. One advantage
    of creating a separate class for your sequence is that you can add an **indexer**.
    You’ve already used indexers—any time you use brackets `[]` to retrieve an object
    from a list, array, or dictionary (like `myList[3]` or `myDictionary["Steve"]`),
    you’re using an indexer. An indexer is just a method. It looks a lot like a property,
    except it’s got a single named parameter.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到可以在方法中使用 `yield return` 创建 `IEnumerator<T>`。你还可以用它创建实现 `IEnumerable<T>`
    的类。为序列创建单独的类的一个优点是，你可以添加一个**索引器**。你已经使用过索引器——任何时候使用方括号 `[]` 从列表、数组或字典中检索对象（如 `myList[3]`
    或 `myDictionary["Steve"]`），你都在使用索引器。索引器只是一个方法。它看起来很像属性，只是它有一个命名参数。
- en: The IDE has an ***especially useful code snippet*** to help you add your indexer.
    Type `**indexer**` followed by two tabs, and the IDE will add the skeleton of
    an indexer for you automatically.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: IDE有一个***特别有用的代码片段***，帮助你添加索引器。输入 `**indexer**`，然后按两次 Tab 键，IDE将自动为你添加索引器的框架。
- en: 'Here’s an indexer for the SportCollection class:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `SportCollection` 类的索引器：
- en: '[PRE42]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Calling the indexer with `[3]` returns the value `Hockey`:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `[3]` 调用索引器返回值 `Hockey`：
- en: '[PRE43]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Take a close look when you use the snippet to create the indexer—it lets you
    set the type. You can define an indexer that takes different types, including
    strings and even objects. While our indexer only has a getter, you can also include
    a setter (just like the ones you’ve used to set items in a List).
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用片段创建索引器时，请仔细查看——它允许你设置类型。你可以定义一个接受不同类型（包括字符串和对象）的索引器。虽然我们的索引器只有一个 getter，但你也可以包含一个
    setter（就像你用来在列表中设置项目的 setter 一样）。
- en: Collectioncross
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合交叉
- en: '![Images](assets/pg527.png)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/pg527.png)'
- en: '[EclipseCrossword.com](http://EclipseCrossword.com)'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '[EclipseCrossword.com](http://EclipseCrossword.com)'
- en: '**Across**'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '**Across**'
- en: 1\. Use the var keyword to declare an _____ typed variable
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 使用 var 关键字声明一个_____类型的变量
- en: 7\. A collection _____ combines the declaration with items to add
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 7\. 一个集合_____结合声明和要添加的项
- en: 9\. What you’re trying to make your code when you have lots of tests for weird
    data and edge cases
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 9\. 当你有大量关于奇怪数据和边界情况的测试时，你试图让你的代码成为什么样子
- en: 11\. LINQ method to return the last elements in a sequence
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 11\. 返回序列中最后元素的 LINQ 方法
- en: 12\. A last-in, first-out (LIFO) collection
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 12\. 后进先出（LIFO）集合
- en: 18\. LINQ method to return the first elements in a sequence
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 18\. 返回序列中第一个元素的 LINQ 方法
- en: 19\. A method that has multiple constructors with different parameters
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 19\. 具有多个不同参数的构造函数的方法
- en: 20\. The type of parameter that tells you that you can use a lambda
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 20\. 告诉你可以使用 lambda 的参数类型
- en: 21\. What you take advantage of when you upcast an entire list
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 21\. 当对整个列表进行上转型时，你利用了什么
- en: 22\. What you’re using when you call myArray[3]
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 22\. 当你调用 myArray[3] 时所使用的东西
- en: 25\. What T gets replaced with when you see <T> in a class or interface definition
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 25\. 当你在类或接口定义中看到 <T> 时，T 被替换成什么
- en: 32\. The keyword you use to create an anonymous object
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 32\. 创建匿名对象所使用的关键字
- en: 33\. A data type that only allows certain values
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 33\. 只允许特定值的数据类型
- en: 34\. The kind of collection that can store any type
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 34\. 可以存储任何类型的集合类型
- en: 35\. The interface that all sequences implement
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 35\. 所有序列都实现的接口
- en: '36\. Another name for the ?: conditional operator'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '36\. 条件运算符 ?: 的另一个名称'
- en: '**Down**'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '**Down**'
- en: 1\. If you want to sort a List, its members need to implement this
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 如果你想对 List 进行排序，其成员需要实现这个
- en: 2\. A collection class for storing items in order
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 按顺序存储项目的集合类
- en: 3\. A collection that stores keys and values
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 存储键和值的集合
- en: 4\. What you pass to List.Sort to tell it how to sort its items
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 告诉 List.Sort 如何对其项进行排序的内容
- en: '**Down**'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '**Down**'
- en: '5\. What goes in the parentheses: ( _____ ) => expression;'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 括号中应填写的内容：( _____ ) => expression;
- en: 6\. You can’t use the var keyword to declare one of these
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. 你不能使用 var 关键字声明其中一个的类型
- en: 8\. The access modifier for a class that can’t be accessed by another project
    in a multiproject solution
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 8\. 在多项目解决方案中不能被其他项目访问的类的访问修饰符
- en: 10\. The kind of expression the => operator creates
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 10\. => 操作符创建的表达式类型
- en: 13\. LINQ method to append the elements from one sequence to the end of another
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 13\. 将一个序列的元素追加到另一个序列末尾的 LINQ 方法
- en: 14\. Every collection has this method to put a new element into it
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 14\. 每个集合都有的方法，用于向其中添加新元素
- en: 15\. What you can do with methods in a class that return the type of that class
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 15\. 在一个类中返回该类类型的方法可以做什么
- en: '16\. What kind of type you’re looking at when the IDE tells you this: `’a’
    is a new string Color, int Height`'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 16\. 当 IDE 告诉你这个时，你正在查看哪种类型：`’a’ is a new string Color, int Height`
- en: 17\. An object’s namespace followed by a period followed by the class is a fully
    _____ class name
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 17\. 对象的命名空间后跟一个点，再跟类名，就是完全_____类名
- en: 23\. The kind of evaluation that means a LINQ query isn’t run until its results
    are accessed
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 23\. 意味着直到访问其结果才运行 LINQ 查询的评估类型
- en: 24\. The clause in a LINQ query that sorts the results
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 24\. 在 LINQ 查询中对结果进行排序的子句
- en: 26\. Type of variable created by the from clause in a LINQ query
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 26\. 在 LINQ 查询的 from 子句中创建的变量类型
- en: 27\. The Enumerable method that returns a sequence with many copies of the same
    element
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 27\. 返回包含多个相同元素序列的 Enumerable 方法
- en: 28\. The clause in a LINQ query that determines which elements in the input
    to use
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 28\. 在 LINQ 查询中确定要使用的输入元素的子句
- en: 29\. A LINQ query that merges data from two sequences
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 29\. 合并两个序列数据的 LINQ 查询
- en: 30\. A first-in, first-out (FIFO) collection
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 30\. 先进先出（FIFO）集合
- en: 31\. The keyword a switch statement has that a switch expression doesn’t
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 31\. switch 表达式没有但 switch 语句有的关键字
- en: Collectioncross Solution
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合交叉解决方案
- en: '![Images](assets/pg528-3.png)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/pg528-3.png)'
