- en: 'Chapter 9\. LINQ and lambdas: *Get control of your data*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![Images](assets/pg467.png)'
  prefs: []
  type: TYPE_IMG
- en: '**It’s a data-driven world...we all need to know how to live in it.**'
  prefs: []
  type: TYPE_NORMAL
- en: Gone are the days when you could program for days, even weeks, without dealing
    with **loads of data**. Today, ***everything is about data***, and that’s where
    **LINQ** comes in. LINQ is a feature of C# and .NET that not only lets you **query
    data** in your .NET collections in an intuitive way, but lets you **group data**
    and **merge data from different data sources**. You’ll add **unit tests** to make
    sure your code is working the way you want. Once you’ve got the hang of wrangling
    your data into manageable chunks, you can use **lambda expressions** to refactor
    your C# code to make it even more expressive
  prefs: []
  type: TYPE_NORMAL
- en: Jimmy’s a Captain Amazing super-fan...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Meet Jimmy, one of the most enthusiastic collectors of Captain Amazing comics,
    graphic novels, and paraphernalia. He knows all the Captain trivia, he’s got props
    from all the movies, and he’s got a comic collection that can only be described
    as, well, amazing.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg468.png)'
  prefs: []
  type: TYPE_IMG
- en: '...but his collection’s all over the place'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jimmy may be passionate, but he’s not exactly organized. He’s trying to keep
    track of the most prized “crown jewel” comics of his collection, but he needs
    help. Can you build Jimmy an app to manage his comics?
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg469.png)'
  prefs: []
  type: TYPE_IMG
- en: Use LINQ to query your collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter you’ll learn about **LINQ** (or **Language-**Integrated** Query**).
    LINQ combines really useful classes and methods with powerful features built directly
    into C#, all created to help you work with sequences of data—like Jimmy’s comic
    book collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use Visual Studio to start exploring LINQ. **Create a new Console App**
    (.NET Core) project and give it the name ***LinqTest***. Add this code, and when
    you get to the last line **add a period** and look at the IntelliSense window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg470.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s use some of those new methods to finish your console app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run your app. It prints this line of text to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So what did you just do?
  prefs: []
  type: TYPE_NORMAL
- en: '**LINQ (or Language INtegrated Query) is a combination of C# features and .NET
    classes that helps you work with sequences of data.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: LINQ works with any IEnumerable<T>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you added the `using System.Linq;` directive to your code, your List<int>
    suddenly got “superpowered”—a bunch of LINQ methods repeated appeared on it. You
    can do the same thing for ***any*** ***class that implements IEnumerable<T>.***
  prefs: []
  type: TYPE_NORMAL
- en: When a class implements IEnumerable<T>, any instance of that class is a **sequence:**
  prefs: []
  type: TYPE_NORMAL
- en: The list of numbers from 1 to 99 was a sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you called its Take method, it returned a reference to a sequence that
    contained the first five elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you called its TakeLast method, it returned another five-element sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And when you used Concat to combine the two five-element sequences, it created
    a new sequence with 10 elements and returned a reference to that new sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Any time you have an object that implements the IEnumerable interface, you
    have a sequence that you can use with LINQ. Doing an operation on that sequence
    in order is called enumerating the sequence.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: LINQ methods enumerate your sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You already know that `foreach` loops work with IEnumerable objects. Think
    about what a `foreach` loop does:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg472.png)'
  prefs: []
  type: TYPE_IMG
- en: When a method goes through each item in a sequence in order, that’s called **enumerating**
    the sequence. And that’s how LINQ methods work.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Objects that implement the IEnumerable interface can be enumerated. That’s
    the job objects that implement the IEnumerable interface do.**'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**What if you want to find the first 30 issues in Jimmy’s collection starting
    with issue #118? LINQ provides a really useful method to help with that. The static
    Enumerable.Range method generates a sequence of integers. Calling Enumerable.Range(8,
    5) returns a sequence of 5 numbers starting with 8: 8, 9, 10, 11, 12.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg473-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**The LINQ methods in this exercise have names that make it obvious what they
    do. Some LINQ methods, like Sum, Min, Max, Count, First, and Last, return a single
    value. The Sum method adds up the values in the sequence. The Average method returns
    their average value. The Min and Max methods return the smallest and largest values
    in the sequence. The First and Last methods do exactly what it sounds like they
    do.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Other LINQ methods, like Take, TakeLast, Concat, Reverse (which reverses
    the order in a sequence), and Skip (which skips the first elements in a sequence),
    return another sequence.**'
  prefs: []
  type: TYPE_NORMAL
- en: LINQ’s query syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The LINQ methods you’ve seen so far may not be enough on their own to answer
    the kinds of questions about data that we might have—or the questions that Jimmy
    has about his comic collection.
  prefs: []
  type: TYPE_NORMAL
- en: And that’s where the **LINQ declarative query syntax** comes in. It uses special
    keywords—including `where`, `select`, `groupby`, and `join`—to build **queries**
    directly into your code.
  prefs: []
  type: TYPE_NORMAL
- en: LINQ queries are built from clauses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s build a query that finds the numbers in an int array that are under 37
    and puts those numbers in ascending order. It does that using four **clauses**
    that tell it what object to query how to determine which of its members to select,
    how to sort the results, and how the results should be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**LINQ queries work on sequences, or objects that implement IEnumerable<T>.
    LINQ queries start with a from clause:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**It tells the query what sequence to execute against, and assigns a name to
    use for each element being queried. It’s like the first line in a `foreach loop`:
    it declares a variable to use while iterating through the sequence that’s assigned
    each element in the sequence. So this:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**iterates through each element in the `values` array in order, assigning the
    first value in the array to v, then the second, then the third, etc.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg475.png)![Images](assets/pg476-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '**LINQ isn’t just for numbers. It works with objects, too.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'When Jimmy looks at stacks and stacks of disorganized comics, he might see
    paper, ink, and a jumbled mess. When us developers look at them, we see something
    else: **lots and lots of data** just waiting to be organized. How do we organize
    comic book data in C#? The same way we organize playing cards, bees, or items
    on Sloppy Joe’s menu: we create a class, then we use a collection to manage that
    class. So all we need to help Jimmy out is a Comic class, and code to help us
    bring some sanity to his collection. And LINQ will help!'
  prefs: []
  type: TYPE_NORMAL
- en: LINQ works with objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jimmy wanted to know how much some of his prize comics are worth, so he hired
    a professional comic book appraiser to give him prices for each of them. It turns
    out that some of his comics are worth a lot of money! Let’s use collections to
    manage that data for him.
  prefs: []
  type: TYPE_NORMAL
- en: '***Do this!***'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create a new console app and add a Comic class.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use two automatic properties for the name and issue number:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](assets/pg477-1.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Add a List that contains Jimmy’s catalog.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add this static Catalog field to the Comic class. It returns a sequence with
    Jimmy’s prized comics:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](assets/pg477-2.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Use a Dictionary to manage the prices.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a static Comic.Prices field—it’s a Dictionary<int, decimal> that lets you
    look up the price of each comic using its issue number (using the collection initializer
    syntax for dictionaries that you learned in [#enums_and_collections_organizing_your_da](ch08.html#enums_and_collections_organizing_your_da)).
    Note that we’re using the **IReadOnlyDictionary interface** for encapsulation—it’s
    an interface that includes only the methods to read values (so we don’t accidentally
    change the prices):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](assets/pg477-3.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: '**We used a Dictionary to store the prices for the comics. We could have included
    a property called Price. We decided to keep information about the comic and price
    separate. We did this because prices for collectors’ items change all the time,
    but the name and issue number will always be the same. Do you think we made the
    right choice?**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Use a LINQ query to finish the app for Jimmy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We used the LINQ declarative query syntax earlier to create a query with four
    clauses: a `from` clause to create a range variable, a `where` clause to include
    only numbers under 37, an `orderby` clause to sort them in descending order, and
    a `select` clause to determine which elements to include in the resulting sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s **add a LINQ query to the Main method** that works exactly the same way—except
    using Comic objects instead of int values, so it writes a list of comics with
    a price > 500 in reverse order to the console. We’ll start with two `using` declarations
    so we can use IEnumerable<T> and LINQ methods. The query will return an IEnumerable<Comic>,
    then use a `foreach` loop to iterate through it and write the output.
  prefs: []
  type: TYPE_NORMAL
- en: '**Modify the Main method to use a LINQ query.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s the entire Program class, including the `using` directives that you
    needed to add to the top:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](assets/pg478-1.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Output:**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Use the descending keyword to make your orderby clause more readable.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your `orderby` clause uses a minus sign to negate the comic prices before sorting,
    causing the query to sort them in descending order. But it’s easy to accidentally
    miss that minus sign when you’re reading the code and trying to figure out how
    it works. Luckily, there’s another way to get the same results. Remove the minus
    sign and **add the `descending` keyword** to the end of the clause:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](assets/pg478-2.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The var keyword lets C# figure out variable types for you
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We just saw that when we made the small change to the `select` clause, the type
    of sequence that the query returned changed. When it was `select comic;` the return
    type was IEnumerable<Comic>. When we changed it to `select $"{comic} is worth
    {Comic.Prices[comic.Issue]:c}";` the return type changed to IEnumerable<string>.
    When you’re working with LINQ, that happens all the time—you’re constantly tweaking
    your queries. It’s not always obvious exactly what type they return. Sometimes
    going back and updating all of your declarations can get annoying.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, C# gives us a really useful tool to help keep variable declarations
    simple and readable. You can replace any variable declaration with the `var` **keyword**.
    So you can replace any of these declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you use the var keyword, you’re telling C# to use an implicitly typed variable.
    We saw that same word—implicit—back in [#enums_and_collections_organizing_your_da](ch08.html#enums_and_collections_organizing_your_da)
    when we talked about covariance. It means that C# figures out the types on its
    own.
  prefs: []
  type: TYPE_NORMAL
- en: 'with these declarations, which do exactly the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: And you don’t have to change any of your code. Just replace the types with var
    and everything works.
  prefs: []
  type: TYPE_NORMAL
- en: When you use var, C# figures out the variable’s type automatically
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go ahead—try it right now. Comment out the first line of the LINQ query you
    just wrote, then replace IEnumerable<Comic> with var:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg480.png)'
  prefs: []
  type: TYPE_IMG
- en: The IDE figured out the mostExpensive variable’s type—and it’s a type we haven’t
    seen before. Remember in [#interfacescomma_castingcomma_and_quotati](ch07.html#interfacescomma_castingcomma_and_quotati)
    when we talked about how interfaces can extend other interfaces? The IOrderedEnumerable
    interface is part of LINQ—it’s used to represent a *sorted* sequence—and it extends
    the IEnumerable<T> interface. Try commenting out the `orderby` clause and hovering
    over the mostExpensive variable—you’ll find that it turns into an IEnumerable<Comic>.
    That’s because C# looks at the code to ***figure out the type of any variable
    you declare with*** ***var***.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg483.png)'
  prefs: []
  type: TYPE_IMG
- en: '**You really can use var in your variable declarations.**'
  prefs: []
  type: TYPE_NORMAL
- en: And yes, it really is that simple. A lot of C# developers declare local variables
    using var almost all the time, and include the type only when it makes the code
    easier to read. As long as you’re declaring the variable and initializing it in
    the same statement, you can use var.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there are some important restrictions on using var. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: You can only declare one variable at a time with var.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can’t use the variable you’re declaring in the declaration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can’t declare it equal to `null`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you create a variable named `var`, you won’t be able to use it as a keyword
    anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: You definitely can’t use var to declare a field or a property—you can only use
    it as a local variable inside a method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you stick to those ground rules, you can use var pretty much anywhere.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**So when you did this in [#types_and_references_getting_the_referen](ch04.html#types_and_references_getting_the_referen):**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Or this in [#inheritance_your_objectapostrophes_famil](ch06.html#inheritance_your_objectapostrophes_famil):**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Or this in [#enums_and_collections_organizing_your_da](ch08.html#enums_and_collections_organizing_your_da):**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**You could have done this:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**Or this:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**Or this:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**...and your code would have worked exactly the same.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**But you can’t use var to declare a field or property:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: LINQ is versatile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With LINQ, you can do a lot more than just pull a few items out of a collection.
    You can modify the items before you return them. Once you’ve generated a set of
    result sequences, LINQ gives you a bunch of methods that work with them. Top to
    bottom, LINQ gives you the tools you need to manage your data. Let’s do a quick
    review of some of the LINQ features that we’ve already seen.
  prefs: []
  type: TYPE_NORMAL
- en: '**Modify every item returned from the query.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This code will add a string onto the end of each element in an array of strings.
    It doesn’t change the array itself—it creates a new sequence of modified strings.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](assets/pg486-1.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Perform calculations on sequences.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the LINQ methods on their own to get statistics about a sequence
    of numbers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: '**The static String.Join method concatenates all of the items in a sequence
    into a string, specifying the separator to use between them.**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](assets/pg486-2.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: LINQ queries aren’t run until you access their results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you include a LINQ query in your code, it uses **deferred evaluation**
    (sometimes called lazy evaluation). That means the LINQ query doesn’t actually
    do any enumerating or looping until your code executes a statement that ***uses
    the results of the query***. That sounds a little weird, but it makes a lot more
    sense when you see it in action. **Create a new console app** and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '***Do this!***'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg487-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Did you get a weird compiler error? Make sure you added the two using directives
    to your code!**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now run your app. Notice how the Console.WriteLine that prints `"Set up the
    query"` runs ***before*** the get accessor ever executes. That’s because the LINQ
    query won’t get executed until the `foreach` loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg487-2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you need the query to execute right now, you can force **immediate execution**
    by calling a LINQ method that needs to enumerate the entire list—for example,
    the ToList method, which turns it into a List<T>. Add this line, and change the
    foreach to use the new List:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Run the app again. This time you’ll see the get accessors called before the
    `foreach` loop starts executing—which makes sense, because ToList needs to access
    every element in the sequence to convert it to a List. Methods like Sum, Min,
    and Max also need to access every element in the sequence, so when you use them
    you’ll force LINQ to do immediate execution as well.
  prefs: []
  type: TYPE_NORMAL
- en: Use a group query to separate your sequence into groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes you really want to slice and dice your data. For example, Jimmy might
    want to group his comics by the decade they were published. Or maybe he wants
    to separate them by price (cheap ones in one collection, expensive ones in another).
    There are lots of reasons you might want to group your data together. That’s where
    the **LINQ group query** comes in handy.
  prefs: []
  type: TYPE_NORMAL
- en: '***Group this!***'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg488.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Create a new console app and add the card classes and enums.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **new .NET Core console app named *CardLinq***. Then go to the Solution
    Explorer panel, right-click on the project name, and choose Add >> Existing Items
    (or Add >>Existing Files on a Mac). Navigate to the folder where you saved the
    Two Decks project from [#enums_and_collections_organizing_your_da](ch08.html#enums_and_collections_organizing_your_da).
    Add the files with the **Suit and Value enums**, then add the **Deck, Card, and
    CardComparerByValue classes**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: '**You created the Deck class in the downloadable “Two Decks” project at the
    end of [#enums_and_collections_organizing_your_da](ch08.html#enums_and_collections_organizing_your_da).**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Make sure you **modify the namespace in each file you added** to match the namespace
    in *Program.cs* so your Main method can access the classes you added.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Make your Card class sortable with IComparable<T>.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We’ll be using a LINQ `orderby` clause to sort groups, so we need the Card
    class to be sortable. Luckily, this works exactly like the List.Sort method, which
    you learned about in [#interfacescomma_castingcomma_and_quotati](ch07.html#interfacescomma_castingcomma_and_quotati).
    Modify your Card class to **extend the IComparable interface**:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](assets/pg487-2a.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Modify the Deck.Shuffle method to support method chaining.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Shuffle class shuffles the deck. All you need to do to make it support
    method chaining is modify it to return a reference to the Deck instance that just
    got shuffled:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](assets/pg489-1.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Use a LINQ query with group...by clause to group the cards by suit.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Main method will get 16 random cards by shuffling the deck, then using
    the LINQ Take method to pull the first 16 cards. Then it will use a LINQ query
    with a `group...by` **clause** to separate the deck into smaller sequences, with
    one sequence for each suit in the 16 cards:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](assets/pg489-2.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**The group...by clause creates a sequence of groups that implement the IGrouping
    interface. IGrouping extends IEnumerable and adds exactly one member: a property
    called Key. So each group is a sequence of other sequences—in this case, it’s
    a group of Card sequences, where the key is the suit of the card (from the `Suits`
    enum). The full type of each group is IGrouping<Suits, Card>, which means it’s
    a sequence of Card sequences, each of which has a Suits value as its key.**'
  prefs: []
  type: TYPE_NORMAL
- en: Use join queries to merge data from two sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every good collector knows that critical reviews can have a big impact on values.
    Jimmy’s been keeping track of reviewer scores from two big comic review aggregators,
    MuddyCritic and Rotten Tornadoes. Now he needs to match them up to his collection.
    How’s he going to do that?
  prefs: []
  type: TYPE_NORMAL
- en: LINQ to the rescue! Its `join` keyword lets you **combine data from two sequences**
    using a single query. It does it by comparing items in one sequence with their
    matching items in a second sequence. (LINQ is smart enough to do this efficiently—it
    doesn’t actually compare every pair of items unless it has to.) The final result
    combines every pair that matches.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll start your query with the usual `from` clause. But instead of following
    it up with the criteria to determine what goes into the results, you’ll add:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `join` clause tells LINQ to enumerate both sequences to match up pairs with
    one member from each. It assigns `name` to the member it’ll pull out of the joined
    collection in each iteration. You’ll use that name in the `where` clause.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](assets/pg491.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Next you’ll add the `**on**` clause, which tells LINQ how to match the two collections
    together. You’ll follow it with the name of the member of the first collection
    you’re matching, followed by `**equals**` and the name of the member of the second
    collection to match it up with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You’ll continue the LINQ query with `**where**` and `**orderby**` clauses as
    usual. You could finish it with a normal `**select**` clause, but you usually
    want to return results that pull some data from one collection and other data
    from the other.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The result is a sequence of objects that have Name and Issue properties from
    Comic, but Critic and Score properties from Review. The result can’t be a sequence
    of Comic objects, but it also can’t be a sequence of Review objects, because neither
    class has all of those properties. The result is a different kind of type: ***an
    anonymous type.***'
  prefs: []
  type: TYPE_NORMAL
- en: Use the new keyword to create anonymous types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You’ve been using the `new` keyword since [#objectshellipget_orientedexclamation_mar](ch03.html#objectshellipget_orientedexclamation_mar)
    to create instances of objects. Every time you use it, you include a type (so
    the statement `new Guy();` creates an instance of the type Guy). You can also
    use the `new` keyword without a type to create an **anonymous type**. That’s a
    perfectly valid type that has read-only properties, but doesn’t have a name. The
    type we returned from the query that joined Jimmy’s comics to reviews is an anonymous
    type. You can add properties to your anonymous type by using an object initializer.
    Here’s what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Try pasting that into a new console app and running it. You’ll see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now hover over `whatAmI` in the IDE and have a look at the IntelliSense window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg492-2a.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**The LINQ query we just saw that joins Jimmy’s comics with reviews returns
    an anonymous type. You’ll add that query to an app later in the chapter.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `whatAmI` variable is a reference type, just like any other reference.
    It points to an object on the heap, and you can use it to access that object’s
    members—in this case, two of its properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Besides the fact that they don’t have names, anonymous types are just like any
    other types.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg492-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Right! You use var to declare anonymous types.**'
  prefs: []
  type: TYPE_NORMAL
- en: In fact, that’s one of the most important uses of the `var` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg499.png)'
  prefs: []
  type: TYPE_IMG
- en: Unit tests help you make sure your code works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We intentionally left a bug in the code we gave you...but is that the *only*
    bug in the app? It’s easy to write code that doesn’t do exactly what you intended
    it to do. Luckily, there’s a way for us to find bugs so we can fix them. **Unit
    tests** are *automated* tests that help you make sure your code does what it’s
    supposed to do. Each unit test is a method that makes sure that a specific part
    of the code (the “unit” being tested) works. If the method runs without throwing
    an exception, it passes. If it throws an exception, it fails. Most large programs
    have a **suite** of tests that cover most or all of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio has built-in unit testing tools to help you write your tests and
    track which ones pass or fail. The unit tests in this book will use **MSTest**,
    a unit test framework (which means that it’s a set of classes that give you the
    tools to write unit tests) developed by Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Visual Studio also supports unit tests written in NUnit and xUnit, two popular
    open source unit test frameworks for C# and .NET code.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio for Windows has a Test Explorer window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open the Test Explorer window by choosing ***View >> Test Explorer*** from the
    main menu bar. It shows you the unit tests on the left, and the results of the
    most recent run on the right. The toolbar has buttons to run all tests, run a
    single test, and repeat the last run.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg500-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**When you add unit tests to your solution, you can **`run`** your tests by
    clicking the Run All Tests button. You can **`debug`** your unit tests on Windows
    by choosing Tests >> Debug all tests, and on Mac by clicking Debug All Tests in
    the Unit Tests tool window.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg500-2.png)'
  prefs: []
  type: TYPE_IMG
- en: Visual Studio for Mac has the Unit Tests tool window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open the Unit Test pad by choosing ***View >> Tool Windows >> Unit Tests***
    from the menu bar. It has buttons to run or debug your tests. When you run the
    unit tests, the IDE displays the results in a Test Results tool window (usually
    at the bottom of the IDE window).
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg500-3.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Back in [#objectshellipget_orientedexclamation_mar](ch03.html#objectshellipget_orientedexclamation_mar)
    you learned about prototypes, or early versions of games that you can play, test,
    learn from, and improve—and you saw how that idea can work with any kind of project,
    not just games. The same thing applies to testing. Sometimes the idea of testing
    software can seem a little abstract. Thinking about how game developers test their
    games can help us get used to the idea, and can make the concept of testing feel
    more intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Most development teams try to automate as much of their testing as possible,
    and run those tests before each commit. That way, they know if they inadvertently
    introduced a bug when they were making a fix or adding a new feature.
  prefs: []
  type: TYPE_NORMAL
- en: Add a unit test project to Jimmy’s comic collection app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Add a new MSTest (.NET Core) project.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click on the solution name in the Solution Explorer, then choose **Add
    >> New Project...** from the menubar. Make sure it’s an **MSTest Test Project
    (.NET Core)**: on Windows use the “Search for Templates” box to search for MSTest;
    on macOS select Tests under “Web and Console” to see the project template. Name
    your project *JimmyLinqUnitTests*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Add a dependency on your existing project.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You’ll be building unit tests for the ComicAnalyzer class. When you have two
    different projects in the same solution, they’re *independent*—by default, the
    classes in one project can’t use classes in another project—so you’ll need to
    set up a dependency to let your unit tests use ComicAnalyzer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Expand the JimmyLinqUnitTests project in the Solution Explorer, then right-click
    on Dependencies and choose **Add Reference...** from the menu. Check the JimmyLinq
    project that you created for the exercise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](assets/pg502-1.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Make your ComicAnalyzer class public.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When Visual Studio added the unit test project, it created a class called UnitTest1\.
    Edit the *UnitTest1.cs* file and try adding the `using JimmyLinq;` directive inside
    the namespace:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](assets/pg502-2.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Hmm, something’s wrong—the IDE won’t let you add the directive. The reason is
    that the JimmyLinq project has no public classes, enums, or other members. Try
    modifying the `Critics` enum to make it public (`**public enum Critics**`), then
    go back and try adding the `using` directive. Now you can add it! The IDE saw
    that the JimmyLinq namespace has public members, and added it to the pop-up window.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now change the ComicAnalyzer declaration to make it public: `**public static
    class ComicAnalyzer**`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '***Uh-oh—something’s wrong.*** Did you get a bunch of “Inconsistent accessibility”
    compiler errors?'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](assets/pg502-3.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The problem is that ComicAnalyzer is public, but it exposes members that have
    no access modifiers, which makes them `**internal**`—so other projects in the
    solution can’t see them. **Add the `public` access modifier** to ***every*** ***class
    and enum*** in the JimmyLinq project. Now your solution will build again.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Write your first unit test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The IDE added a class called UnitTest1 to your new MSTest project. Rename the
    class (and the file) ComicAnalyzerTests. The class contains a test method called
    TestMethod1\. Next, give it a very descriptive name: rename the method ComicAnalyzer_Should_Group_Comics.
    Here’s the code for your unit test class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg503-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**When you run your unit tests in the IDE, it looks for any class with `[TestClass]`
    above it. That’s called an attribute. A test class includes test methods, which
    must be marked with the `[TestMethod]` attribute.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**MSTest unit tests use the Assert class, which has static methods that you
    can use to check that your code behaves the way you expect it to. This unit test
    uses the Assert.AreEqual method. It takes two parameters, an expected result (what
    you think the code should do) and an actual result (what it actually does), and
    throws an exception if they’re not equal.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**This test sets up some very limited test data: a sequence of three comics
    and a dictionary with three prices. Then it calls GroupComicsByPrice and uses
    Assert.AreEqual to validate that the results match what we expect.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run your test by choosing **Test >> Run All Tests** (Windows) or **Run >> Run
    Unit Tests** (Mac) from the menubar. The IDE will pop up a Test Explorer window
    (Windows) or Test Results panel (Mac) with the test results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is the result of a **failed unit test**. Look for the ![Images](assets/pg503-2.png)
    icon in Windows or the ![Images](assets/pg503-3.png) message at the bottom of
    the IDE window in Visual Studio for Mac—that’s how you see a count of your failed
    unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: '***Did you expect that unit test to fail? Can you figure out what went wrong
    with the test?***'
  prefs: []
  type: TYPE_NORMAL
- en: Write a unit test for the GetReviews method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The unit test for the GroupComicsByPrice method used MSTest’s static Assert.AreEqual
    method to check expected values against actual ones. The GetReviews method *returns
    a sequence of strings*, not an individual value. We *could* use Assert.AreEqual
    to compare individual elements in that sequence, just like we did with the last
    two assertions, using LINQ methods like First to get specific elements...but that
    would take a LOT of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, MSTest has a better way to compare collections: the **CollectionAssert
    class** has static methods for comparing expected versus actual collection results.
    So if you have a collection with expected results and a collection with actual
    results, you can compare them like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If the expected and actual results don’t match the test will fail. Go ahead
    and **add this test** to validate the ComicAnalyzer.GetReviews method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now run your tests again. You should see two unit tests pass.
  prefs: []
  type: TYPE_NORMAL
- en: Write unit tests to handle edge cases and weird data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the real world, data is messy. For example, we never really told you exactly
    what review data is supposed to look like. You’ve seen review scores between 0
    and 100\. Did you assume those were the only values allowed? That’s definitely
    the way some review websites in the real world operate. What if we get some weird
    review scores—like negative ones, or really big ones, or zero? What if we get
    more than one score from a reviewer for an issue? Even if these things aren’t
    *supposed to* happen, they *might* happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want our code to be **robust**, which means that it handles problems, failures,
    and especially bad input data well. So let’s build a unit test that passes some
    weird data to GetReviews and makes sure it doesn’t break:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg506.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Always take time to write unit tests for edge cases and weird data—think of
    them as “must-have” and not “nice-to-have” tests. The point of unit testing is
    to cast the widest possible net to catch bugs, and these kinds of tests are really
    effective for that.
  prefs: []
  type: TYPE_NORMAL
- en: '**It’s really important to add unit tests that handle edge cases and weird
    data. They can help you spot problems in your code that you wouldn’t find otherwise.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![Images](assets/pg507.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Your projects actually go faster when you write unit tests.**'
  prefs: []
  type: TYPE_NORMAL
- en: We’re serious! It may seem counterintuitive that it takes *less time* to write
    *more code*, but if you’re in the habit of writing unit tests, your projects go
    a lot more smoothly because you find and fix bugs early. You’ve written a lot
    of code so far in the first eight and a half chapters of this book, which means
    you’ve almost certainly had to track down and fix bugs in your code. When you
    fixed those bugs, did you have to fix other code in your project too? When we
    find an unexpected bug, we often have to stop what we’re doing to track it down
    and fix it, and switching back and forth like that—losing our train of thought,
    having to interrupt our flow—can really slow things down. Unit tests help you
    find those bugs early, before they have a chance to interrupt your work.
  prefs: []
  type: TYPE_NORMAL
- en: '***Still wondering exactly when unit tests should be written? We included a
    downloadable project at the end of the chapter to help answer that question.***'
  prefs: []
  type: TYPE_NORMAL
- en: Use the => operator to create lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '***We left you hanging back at the beginning of the chapter.*** Remember that
    mysterious line we asked you to add to the Comic class? Here it is again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ve been using that ToString method throughout the chapter—you know it works.
    What would you do if we asked you to rewrite that method the way you’ve been writing
    methods so far? You might write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: And you’d basically be right. So what’s going on? What exactly is that => operator?
  prefs: []
  type: TYPE_NORMAL
- en: 'The => operator that you used in the ToString method is the **lambda operator**.
    You can use => to define a **lambda expression**, or an *anonymous function* defined
    within a single statement. Lambda expressions look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two parts to a lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: The `input-parameters` part is a list of parameters, just like you’d use when
    you declare a method. If there’s only one parameter, you can leave off the parentheses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `expression` is any C# expression: it can be an interpolated string, a
    statement that uses an operator, a method call—pretty much anything you would
    put in a statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambda expressions may look a little weird at first, but they’re just another
    way of using the ***same familiar C# expressions*** that you’ve been using throughout
    the book—just like the Comic.ToString method, which works the same way whether
    or not you use a lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg508.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Yes! You can use lambda expressions to refactor many methods and properties.**'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve written a lot of methods throughout this book that contain just a single
    statement. You could refactor most of them to use lambda expressions instead.
    In many cases, that could make your code easier to read and understand. Lambdas
    give you options—you can decide when using them improves your code.
  prefs: []
  type: TYPE_NORMAL
- en: A lambda test drive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![Images](assets/coma.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s kick the tires on lambda expressions, which give us a whole new way to
    write methods, including ones that return values or take parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '**Create a new console app**. Add this Program class with the Main method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](assets/pg509-1.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Run it a few times. Each time it prints a different random number, as in: `The
    value is 37.8709`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Refactor the GetRandomDouble and PrintValue methods** using the => operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Images](assets/pg509-2.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Run your program again—it should print a different random number, just like
    before.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Before we do one more refactoring, **hover over the random field** and look
    at the IntelliSense pop-up:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](assets/pg509-3.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Modify the random field** to use a lambda expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The program still runs the same way. Now **hover over the random field** again:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](assets/pg509-4.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Wait a minute—random isn’t a field anymore. Changing it into a lambda turned
    it into a property! That’s because **lambda expressions always work like methods**.
    So when random was a field, it got instantiated once when the class was constructed.
    When you changed the = to a => and converted it to a lambda, it became a method—which
    means ***a new instance of Random is created every time the property is accessed***.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Refactor a clown with lambdas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Back in [#interfacescomma_castingcomma_and_quotati](ch07.html#interfacescomma_castingcomma_and_quotati),
    you created an IClown interface with two members:'
  prefs: []
  type: TYPE_NORMAL
- en: '***Do this!***'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg509-5a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And you modified this class to implement that interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s do that same thing again—but this time we’ll use lambdas. **Create a
    new Console App** **project** and add the IClown interface and TallGuy class.
    Then modify TallGuy to implement IClown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now open the Quick Actions menu and choose **“Implement interface.”** The IDE
    fills in all of the interface members, having them throw NotImplementedExceptions
    just like it does when you use Generate Method.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg510-2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s refactor these methods so they do the same thing as before, but now use
    lambda expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '![Images](assets/pg510-3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now add the same Main method you used back in [#interfacescomma_castingcomma_and_quotati](ch07.html#interfacescomma_castingcomma_and_quotati):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Run your app. The TallGuy class works just like it did in [#interfacescomma_castingcomma_and_quotati](ch07.html#interfacescomma_castingcomma_and_quotati),
    but now that we’ve refactored its members to use lambda expressions it’s more
    compact.
  prefs: []
  type: TYPE_NORMAL
- en: '***We think the new and improved TallGuy class is easier to read. Do you?***'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg510-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '**You can use the => operator to create a property with a get accessor that
    executes a lambda expression.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Use the ?: operator to make your lambdas make choices'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What if you want your lambdas to do... more? It would be great if they could
    make decisions...and that’s where the **conditional operator** (which some people
    call the **ternary operator**) comes in. It works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'which may look a little weird at first, so let’s have a look at an example.
    First of all, the ?: operator isn’t unique to lambdas—you can use it anywhere.
    Take this `if` statement from the AbilityScoreCalculator class in [#types_and_references_getting_the_referen](ch04.html#types_and_references_getting_the_referen):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg513-1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice how we set Score equal to the results of the ?: expression. The ?: expression
    **returns a value**: it checks the *condition* (added < Minimum), and then it
    either returns the *consequent* (Minimum) or the *alternative* (added).'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have a method that looks like that `if/else` statement, you can **use
    ?:** **to refactor it as a lambda**. For example, take this method from the PaintballGun
    class in [#encapsulation_keep_your_privateshellippr](ch05.html#encapsulation_keep_your_privateshellippr):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg513-2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s rewrite that as a more concise lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the slight change—in the `if/else` version, the BallsLoaded property
    was set inside the then- and else-statements. We changed this to use a conditional
    operator that checked balls against MAGAZINE_SIZE and returned the correct value,
    and used that return value to set the BallsLoaded property.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions and LINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add this small LINQ query to any C# app, then hover over the `select` keyword
    in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg514-1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The IDE pops up a tooltip window just like it does ***when you hover over a
    method.*** Let’s take a closer look at the first line, which shows the method
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg514-2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can learn a few things from that method declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: The IEnumerable<int>.Select method returns an IEnumerable<int>.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It takes a single parameter of type Func<int, int>.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use lambda expressions with methods that take a Func parameter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a method takes a Func<int, int> parameter, you can **call it with a lambda
    expression** that takes an int parameter and returns an int value. So you could
    refactor the select query like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Go ahead—try that yourself in a console app. Add a foreach statement to print
    the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: When you print the results of the refactored query, you’ll get the sequence
    { 2, 4, 6, 8 }—exactly the same result as you got with the LINQ query syntax before
    you refactored it.
  prefs: []
  type: TYPE_NORMAL
- en: LINQ queries can be written as chained LINQ methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take this LINQ query from earlier and **add it to an app** so we can explore
    a few more LINQ methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The OrderBy LINQ method sorts a sequence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Hover over the `**orderby**` keyword and take a look at its parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg515-1.png)'
  prefs: []
  type: TYPE_IMG
- en: When you use an `orderby` clause in a LINQ query, it calls a LINQ OrderBy method
    that sorts the sequence. In this case, we can pass it a lambda expression with
    an int parameter that **returns the sort key**, or any value (which must implement
    IComparer) that it can use to sort the results.
  prefs: []
  type: TYPE_NORMAL
- en: The Where LINQ method pulls out a subset of a sequence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now hover over the `**where**` keyword in the LINQ query:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg515-2.png)'
  prefs: []
  type: TYPE_IMG
- en: The `where` clause in a LINQ query calls a LINQ Where method that can use a
    lambda that returns a Boolean. ***The Where method calls that lambda for each
    element in the sequence***. If the lambda returns true, the element is included
    in the results. If the lambda returns false, the element is removed.
  prefs: []
  type: TYPE_NORMAL
- en: Use the `=>` operator to create switch expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You’ve been using `switch` statements since [#inheritance_your_objectapostrophes_famil](ch06.html#inheritance_your_objectapostrophes_famil)
    to check a variable against several options. It’s a really useful tool... but
    have you noticed its limitations? For example, try adding a case that tests against
    a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll get a C# compiler error: *A constant value is expected.* That’s because
    you can only use constant values—like literals and variables defined with the
    `const` keyword—in the `switch` statements that you’ve been using.'
  prefs: []
  type: TYPE_NORMAL
- en: But that all changes with the `=>` operator, which lets you create **switch
    expressions**. They’re similar to the `switch` statements that you’ve been using,
    but they’re *expressions* that return a value. A switch expression starts with
    a value to check and the `switch` keyword followed by a series of *switch arms*
    in curly brackets separated by commas. Each switch arm uses the => operator to
    check the value against an expression. If the first arm doesn’t match, it moves
    on to the next one, returning the value for the matching arm.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg517-1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s say you’re working on a card game that needs to assign a certain score
    based on suit, where spades are worth 6, hearts are worth 4, and other cards are
    worth 2\. You could write a `switch` statement like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg517-2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The whole goal of this `switch` statement is to use the cases to set the `score`
    variable—and a lot of our `switch` statements work that way. We can use the =>
    operator to create a switch expression that does the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg517-3.png)'
  prefs: []
  type: TYPE_IMG
- en: Explore the Enumerable class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve been using sequences for a while. We know they work with `foreach` loops
    and LINQ. But what, exactly, makes sequences tick? Let’s take a deeper dive to
    find out. We’ll start with the **Enumerable class**—specifically, with its three
    static methods, Range, Empty, and Repeat. You already saw the Enumerable.Range
    method earlier in the chapter. Let’s use the IDE to discover how the other two
    methods work. Type `**Enumerable**`. and then hover over Range, Empty, and Repeat
    in the IntelliSense pop-up to see their declarations and comments.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg521.png)'
  prefs: []
  type: TYPE_IMG
- en: Enumerable.Empty creates an empty sequence of any type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes you need to pass an empty sequence to a method that takes an IEnumerable<T>
    (for example, in a unit test). The **Enumerable.Empty method** comes in handy
    in these cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Enumerable.Repeat repeats a value a number of times
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say you need a sequence of 100 3s, or 12 “yes” strings, or 83 identical
    anonymous objects. You’d be surprised at how often that happens! You can use the
    **Enumerable.Repeat method** for this—it returns a sequence of repeated values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: So what exactly is an IEnumerable<T>?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve been using IEnumerable<T> for a while now. We haven’t really answered
    the question of what an enumerable sequence *actually is*. A really effective
    way to understand something is to build it ourselves, so let’s finish the chapter
    by building some sequences from the ground up.
  prefs: []
  type: TYPE_NORMAL
- en: Create an enumerable sequence by hand
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s say we have some sports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, we could create a new List<Sport> and use a collection initializer
    to populate it. But for the sake of exploring how sequences work, we’ll build
    one manually. Let’s create a new class called ManualSportSequence and make it
    implement the IEnumerable<Sport> interface. It just has two members that return
    an IEnumerator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg522-1.png)'
  prefs: []
  type: TYPE_IMG
- en: OK, so what’s an IEnumerator? It’s an interface that lets you enumerate a sequence,
    moving through each item in the sequence one after another. It has a property,
    Current, which returns the current item being enumerated. Its MoveNext method
    moves to the next element in the sequence, returning false if the sequence has
    run out. After MoveNext is called, Current returns that next element. Finally,
    the Reset method resets the sequence back to the beginning. Once you have those
    methods, you have an enumerable sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg522-2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So let’s implement an IEnumerator<Sport>:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg522-3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And that’s all we need to create our own IEnumerable. Go ahead—give it a try.
    **Create a new console app**, add ManualSportSequence and ManualSportEnumerator,
    and then enumerate the sequence in a `foreach` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Use yield return to create your own sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C# gives you a much easier way to create enumerable sequences: the `**yield
    return statement**`. The `yield return` statement is a kind of all-in-one automatic
    enumerator creator. A good way to understand it is to see an example. Let’s use
    a **multiproject solution**, just to give you a little more practice with that.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Add a new Console App project to your solution**—this is just like what you
    did when you added the MSTest project earlier in the chapter, except this time
    instead of choosing the project type MSTest choose the same Console App project
    type that you’ve been using for most of the projects in the book. Then right-click
    on the project under the solution and **choose “Set as startup project.”** Now
    when you launch the debugger in the IDE, it will run the new project. You can
    also right-click on any project in the solution and run or debug it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code for the new console app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg523-1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the app—it prints four lines: `apples`, `oranges`, `bananas`, and `unicorns`.
    So how does that work?'
  prefs: []
  type: TYPE_NORMAL
- en: Use the debugger to explore yield return
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Set a breakpoint on the first line of the Main method and launch the debugger.
    Then use **Step Into** (F11 / ![Images](assets/pg523-2a.png)) to debug the code
    line by line, right into the iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: Step into the code, and keep stepping into it until you reach the first line
    of the SimpleEnumerable method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step into that line again. It acts just like a `return` statement, returning
    control back to the statement that called it—in this case, back to the `foreach`
    statement, which calls Console.WriteLine to write `apples`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Step two more times. Your app will jump back into the SimpleEnumerable method,
    but ***it skips the first statement in the method*** and goes right to the second
    line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Images](assets/pg523-2.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Keep stepping. The app returns to the `foreach` loop, then back to the ***third
    line*** of the method, then returns to the `foreach` loop, and goes back to the
    ***fourth line*** of the method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So `yield return` makes a method **return an enumerable sequence** by returning
    the next element in the sequence each time it’s called, and keeping track of where
    it returned from so it can pick up where it left off.
  prefs: []
  type: TYPE_NORMAL
- en: Use yield return to refactor ManualSportSequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can create your own IEnumerable<T> by **using `yield return` to implement
    the GetEnumerator method**. For example, here’s a BetterSportSequence class that
    does exactly the same thing as ManualSportSequence did. This version is much more
    compact because it uses `yield return` in its GetEnumerator implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](assets/pg524.png)'
  prefs: []
  type: TYPE_IMG
- en: Go ahead and **add a new Console App project to your solution**. Add this new
    BetterSportSequence class, and modify the Main method to create an instance of
    it and enumerate the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Add an indexer to BetterSportSequence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve seen that you can use `yield return` in a method to create an IEnumerator<T>.
    You can also use it to create a class that implements IEnumerable<T>. One advantage
    of creating a separate class for your sequence is that you can add an **indexer**.
    You’ve already used indexers—any time you use brackets `[]` to retrieve an object
    from a list, array, or dictionary (like `myList[3]` or `myDictionary["Steve"]`),
    you’re using an indexer. An indexer is just a method. It looks a lot like a property,
    except it’s got a single named parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The IDE has an ***especially useful code snippet*** to help you add your indexer.
    Type `**indexer**` followed by two tabs, and the IDE will add the skeleton of
    an indexer for you automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an indexer for the SportCollection class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling the indexer with `[3]` returns the value `Hockey`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Take a close look when you use the snippet to create the indexer—it lets you
    set the type. You can define an indexer that takes different types, including
    strings and even objects. While our indexer only has a getter, you can also include
    a setter (just like the ones you’ve used to set items in a List).
  prefs: []
  type: TYPE_NORMAL
- en: Collectioncross
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![Images](assets/pg527.png)'
  prefs: []
  type: TYPE_IMG
- en: '[EclipseCrossword.com](http://EclipseCrossword.com)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Across**'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Use the var keyword to declare an _____ typed variable
  prefs: []
  type: TYPE_NORMAL
- en: 7\. A collection _____ combines the declaration with items to add
  prefs: []
  type: TYPE_NORMAL
- en: 9\. What you’re trying to make your code when you have lots of tests for weird
    data and edge cases
  prefs: []
  type: TYPE_NORMAL
- en: 11\. LINQ method to return the last elements in a sequence
  prefs: []
  type: TYPE_NORMAL
- en: 12\. A last-in, first-out (LIFO) collection
  prefs: []
  type: TYPE_NORMAL
- en: 18\. LINQ method to return the first elements in a sequence
  prefs: []
  type: TYPE_NORMAL
- en: 19\. A method that has multiple constructors with different parameters
  prefs: []
  type: TYPE_NORMAL
- en: 20\. The type of parameter that tells you that you can use a lambda
  prefs: []
  type: TYPE_NORMAL
- en: 21\. What you take advantage of when you upcast an entire list
  prefs: []
  type: TYPE_NORMAL
- en: 22\. What you’re using when you call myArray[3]
  prefs: []
  type: TYPE_NORMAL
- en: 25\. What T gets replaced with when you see <T> in a class or interface definition
  prefs: []
  type: TYPE_NORMAL
- en: 32\. The keyword you use to create an anonymous object
  prefs: []
  type: TYPE_NORMAL
- en: 33\. A data type that only allows certain values
  prefs: []
  type: TYPE_NORMAL
- en: 34\. The kind of collection that can store any type
  prefs: []
  type: TYPE_NORMAL
- en: 35\. The interface that all sequences implement
  prefs: []
  type: TYPE_NORMAL
- en: '36\. Another name for the ?: conditional operator'
  prefs: []
  type: TYPE_NORMAL
- en: '**Down**'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. If you want to sort a List, its members need to implement this
  prefs: []
  type: TYPE_NORMAL
- en: 2\. A collection class for storing items in order
  prefs: []
  type: TYPE_NORMAL
- en: 3\. A collection that stores keys and values
  prefs: []
  type: TYPE_NORMAL
- en: 4\. What you pass to List.Sort to tell it how to sort its items
  prefs: []
  type: TYPE_NORMAL
- en: '**Down**'
  prefs: []
  type: TYPE_NORMAL
- en: '5\. What goes in the parentheses: ( _____ ) => expression;'
  prefs: []
  type: TYPE_NORMAL
- en: 6\. You can’t use the var keyword to declare one of these
  prefs: []
  type: TYPE_NORMAL
- en: 8\. The access modifier for a class that can’t be accessed by another project
    in a multiproject solution
  prefs: []
  type: TYPE_NORMAL
- en: 10\. The kind of expression the => operator creates
  prefs: []
  type: TYPE_NORMAL
- en: 13\. LINQ method to append the elements from one sequence to the end of another
  prefs: []
  type: TYPE_NORMAL
- en: 14\. Every collection has this method to put a new element into it
  prefs: []
  type: TYPE_NORMAL
- en: 15\. What you can do with methods in a class that return the type of that class
  prefs: []
  type: TYPE_NORMAL
- en: '16\. What kind of type you’re looking at when the IDE tells you this: `’a’
    is a new string Color, int Height`'
  prefs: []
  type: TYPE_NORMAL
- en: 17\. An object’s namespace followed by a period followed by the class is a fully
    _____ class name
  prefs: []
  type: TYPE_NORMAL
- en: 23\. The kind of evaluation that means a LINQ query isn’t run until its results
    are accessed
  prefs: []
  type: TYPE_NORMAL
- en: 24\. The clause in a LINQ query that sorts the results
  prefs: []
  type: TYPE_NORMAL
- en: 26\. Type of variable created by the from clause in a LINQ query
  prefs: []
  type: TYPE_NORMAL
- en: 27\. The Enumerable method that returns a sequence with many copies of the same
    element
  prefs: []
  type: TYPE_NORMAL
- en: 28\. The clause in a LINQ query that determines which elements in the input
    to use
  prefs: []
  type: TYPE_NORMAL
- en: 29\. A LINQ query that merges data from two sequences
  prefs: []
  type: TYPE_NORMAL
- en: 30\. A first-in, first-out (FIFO) collection
  prefs: []
  type: TYPE_NORMAL
- en: 31\. The keyword a switch statement has that a switch expression doesn’t
  prefs: []
  type: TYPE_NORMAL
- en: Collectioncross Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![Images](assets/pg528-3.png)'
  prefs: []
  type: TYPE_IMG
