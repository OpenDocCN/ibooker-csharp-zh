["```cs\nasync Task MyMethodAsync()\n{\n  int value = 10;\n  await Task.Delay(TimeSpan.FromSeconds(1));\n  value = value + 1;\n  await Task.Delay(TimeSpan.FromSeconds(1));\n  value = value - 1;\n  await Task.Delay(TimeSpan.FromSeconds(1));\n  Trace.WriteLine(value);\n}\n```", "```cs\nprivate int value;\n\nasync Task ModifyValueAsync()\n{\n  await Task.Delay(TimeSpan.FromSeconds(1));\n  value = value + 1;\n}\n\n// WARNING: may require synchronization; see discussion below.\nasync Task<int> ModifyValueConcurrentlyAsync()\n{\n  // Start three concurrent modifications.\n  Task task1 = ModifyValueAsync();\n  Task task2 = ModifyValueAsync();\n  Task task3 = ModifyValueAsync();\n\n  await Task.WhenAll(task1, task2, task3);\n\n  return value;\n}\n```", "```cs\nprivate int value;\n\nasync Task ModifyValueAsync()\n{\n  int originalValue = value;\n  await Task.Delay(TimeSpan.FromSeconds(1));\n  value = originalValue + 1;\n}\n```", "```cs\n// BAD CODE!!\nasync Task<int> SimpleParallelismAsync()\n{\n  int value = 0;\n  Task task1 = Task.Run(() => { value = value + 1; });\n  Task task2 = Task.Run(() => { value = value + 1; });\n  Task task3 = Task.Run(() => { value = value + 1; });\n  await Task.WhenAll(task1, task2, task3);\n  return value;\n}\n```", "```cs\nvoid IndependentParallelism(IEnumerable<int> values)\n{\n  Parallel.ForEach(values, item => Trace.WriteLine(item));\n}\n```", "```cs\n// BAD CODE!!\nint ParallelSum(IEnumerable<int> values)\n{\n  int result = 0;\n  Parallel.ForEach(source: values,\n      localInit: () => 0,\n      body: (item, state, localValue) => localValue + item,\n      localFinally: localValue => { result += localValue; });\n  return result;\n}\n```", "```cs\nasync Task<bool> PlayWithStackAsync()\n{\n  ImmutableStack<int> stack = ImmutableStack<int>.Empty;\n\n  Task task1 = Task.Run(() => Trace.WriteLine(stack.Push(3).Peek()));\n  Task task2 = Task.Run(() => Trace.WriteLine(stack.Push(5).Peek()));\n  Task task3 = Task.Run(() => Trace.WriteLine(stack.Push(7).Peek()));\n  await Task.WhenAll(task1, task2, task3);\n\n  return stack.IsEmpty; // Always returns true.\n}\n```", "```cs\n// BAD CODE!!\nasync Task<bool> PlayWithStackAsync()\n{\n  ImmutableStack<int> stack = ImmutableStack<int>.Empty;\n\n  Task task1 = Task.Run(() => { stack = stack.Push(3); });\n  Task task2 = Task.Run(() => { stack = stack.Push(5); });\n  Task task3 = Task.Run(() => { stack = stack.Push(7); });\n  await Task.WhenAll(task1, task2, task3);\n\n  return stack.IsEmpty;\n}\n```", "```cs\nasync Task<int> ThreadsafeCollectionsAsync()\n{\n  var dictionary = new ConcurrentDictionary<int, int>();\n\n  Task task1 = Task.Run(() => { dictionary.TryAdd(2, 3); });\n  Task task2 = Task.Run(() => { dictionary.TryAdd(3, 5); });\n  Task task3 = Task.Run(() => { dictionary.TryAdd(5, 7); });\n  await Task.WhenAll(task1, task2, task3);\n\n  return dictionary.Count; // Always returns 3.\n}\n```", "```cs\nclass MyClass\n{\n  // This lock protects the _value field.\n  private readonly object _mutex = new object();\n\n  private int _value;\n\n  public void Increment()\n  {\n    lock (_mutex)\n    {\n      _value = _value + 1;\n    }\n  }\n}\n```", "```cs\nclass MyClass\n{\n  // This lock protects the _value field.\n  private readonly SemaphoreSlim _mutex = new SemaphoreSlim(1);\n\n  private int _value;\n\n  public async Task DelayAndIncrementAsync()\n  {\n    await _mutex.WaitAsync();\n    try\n    {\n      int oldValue = _value;\n      await Task.Delay(TimeSpan.FromSeconds(oldValue));\n      _value = oldValue + 1;\n    }\n    finally\n    {\n      _mutex.Release();\n    }\n  }\n}\n```", "```cs\nclass MyClass\n{\n  // This lock protects the _value field.\n  private readonly AsyncLock _mutex = new AsyncLock();\n\n  private int _value;\n\n  public async Task DelayAndIncrementAsync()\n  {\n    using (await _mutex.LockAsync())\n    {\n      int oldValue = _value;\n      await Task.Delay(TimeSpan.FromSeconds(oldValue));\n      _value = oldValue + 1;\n    }\n  }\n}\n```", "```cs\nclass MyClass\n{\n  private readonly ManualResetEventSlim _initialized =\n      new ManualResetEventSlim();\n\n  private int _value;\n\n  public int WaitForInitialization()\n  {\n    _initialized.Wait();\n    return _value;\n  }\n\n  public void InitializeFromAnotherThread()\n  {\n    _value = 13;\n    _initialized.Set();\n  }\n}\n```", "```cs\nclass MyClass\n{\n  private readonly TaskCompletionSource<object> _initialized =\n      new TaskCompletionSource<object>();\n\n  private int _value1;\n  private int _value2;\n\n  public async Task<int> WaitForInitializationAsync()\n  {\n    await _initialized.Task;\n    return _value1 + _value2;\n  }\n\n  public void Initialize()\n  {\n    _value1 = 13;\n    _value2 = 17;\n    _initialized.TrySetResult(null);\n  }\n}\n```", "```cs\nclass MyClass\n{\n  private readonly AsyncManualResetEvent _connected =\n      new AsyncManualResetEvent();\n\n  public async Task WaitForConnectedAsync()\n  {\n    await _connected.WaitAsync();\n  }\n\n  public void ConnectedChanged(bool connected)\n  {\n    if (connected)\n      _connected.Set();\n    else\n      _connected.Reset();\n  }\n}\n```", "```cs\nIPropagatorBlock<int, int> DataflowMultiplyBy2()\n{\n  var options = new ExecutionDataflowBlockOptions\n  {\n    MaxDegreeOfParallelism = 10\n  };\n\n  return new TransformBlock<int, int>(data => data * 2, options);\n}\n\n// Using Parallel LINQ (PLINQ)\nIEnumerable<int> ParallelMultiplyBy2(IEnumerable<int> values)\n{\n  return values.AsParallel()\n      .WithDegreeOfParallelism(10)\n      .Select(item => item * 2);\n}\n\n// Using the Parallel class\nvoid ParallelRotateMatrices(IEnumerable<Matrix> matrices, float degrees)\n{\n  var options = new ParallelOptions\n  {\n    MaxDegreeOfParallelism = 10\n  };\n  Parallel.ForEach(matrices, options, matrix => matrix.Rotate(degrees));\n}\n```", "```cs\nasync Task<string[]> DownloadUrlsAsync(HttpClient client,\n    IEnumerable<string> urls)\n{\n  using var semaphore = new SemaphoreSlim(10);\n  Task<string>[] tasks = urls.Select(async url =>\n  {\n    await semaphore.WaitAsync();\n    try\n    {\n      return await client.GetStringAsync(url);\n    }\n    finally\n    {\n      semaphore.Release();\n    }\n  }).ToArray();\n  return await Task.WhenAll(tasks);\n}\n```"]