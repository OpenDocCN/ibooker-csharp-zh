- en: Chapter 1\. Introducing C# and .NET
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章\. 介绍C#和.NET
- en: C# is a general-purpose, type-safe, object-oriented programming language. The
    goal of the language is programmer productivity. To this end, C# balances simplicity,
    expressiveness, and performance. The chief architect of the language since its
    first version is Anders Hejlsberg (creator of Turbo Pascal and architect of Delphi).
    The C# language is platform neutral and works with a range of platform-specific
    runtimes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C#是一种通用、类型安全的面向对象编程语言。语言的目标是提高程序员的生产力。为此，C#平衡了简单性、表达能力和性能。自从第一个版本以来，语言的首席架构师是Anders
    Hejlsberg（Turbo Pascal的创造者和Delphi的架构师）。C#语言是平台中立的，并与一系列特定于平台的运行时配合工作。
- en: Object Orientation
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象
- en: 'C# is a rich implementation of the object-orientation paradigm, which includes
    *encapsulation*, *inheritance*, and *polymorphism*. Encapsulation means creating
    a boundary around an *object* to separate its external (public) behavior from
    its internal (private) implementation details. Following are the distinctive features
    of C# from an object-oriented perspective:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: C# 是面向对象范式的丰富实现，包括*封装*、*继承*和*多态*。封装意味着在*对象*周围创建一个边界，以分隔其外部（公共）行为和内部（私有）实现细节。以下是从面向对象的角度看C#的独特特性：
- en: Unified type system
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 统一类型系统
- en: The fundamental building block in C# is an encapsulated unit of data and functions
    called a *type*. C# has a *unified type system* in which all types ultimately
    share a common base type. This means that all types, whether they represent business
    objects or are primitive types such as numbers, share the same basic functionality.
    For example, an instance of any type can be converted to a string by calling its
    `ToString` method.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中的基本构建块是一个称为*类型*的封装单元，其中所有类型最终都共享一个共同的基类型。这意味着所有类型，无论是代表业务对象还是诸如数字之类的基本类型，都共享相同的基本功能。例如，任何类型的实例都可以通过调用其`ToString`方法转换为字符串。
- en: Classes and interfaces
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 类和接口
- en: In a traditional object-oriented paradigm, the only kind of type is a class.
    In C#, there are several other kinds of types, one of which is an *interface*.
    An interface is like a class that cannot hold data. This means that it can define
    only *behavior* (and not *state*), which allows for multiple inheritance as well
    as a separation between specification and implementation.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的面向对象范式中，类型的唯一种类是类。在C#中，还有几种其他类型，其中一种是*接口*。接口类似于一个不能持有数据的类。这意味着它只能定义*行为*（而不是*状态*），这允许多重继承以及规范与实现的分离。
- en: Properties, methods, and events
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 属性、方法和事件
- en: In the pure object-oriented paradigm, all functions are *methods*. In C#, methods
    are only one kind of *function member*, which also includes *properties* and *events*
    (there are others, too). Properties are function members that encapsulate a piece
    of an object’s state such as a button’s color or a label’s text. Events are function
    members that simplify acting on object state changes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯粹的面向对象范式中，所有函数都是*方法*。在C#中，方法只是*函数成员*的一种，其中还包括*属性*和*事件*（还有其他类型）。属性是封装对象状态的一部分的函数成员，例如按钮的颜色或标签的文本。事件是简化对象状态更改处理的函数成员。
- en: 'Although C# is primarily an object-oriented language, it also borrows from
    the *functional programming* paradigm, specifically:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 C# 主要是面向对象的语言，但它也借鉴了*函数式编程*范式，具体来说：
- en: Functions can be treated as values
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以被视为值
- en: Using *delegates*, C# allows functions to be passed as values to and from other
    functions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*委托*，C#允许将函数作为值传递给其他函数，并从其他函数返回。
- en: C# supports patterns for purity
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: C# 支持纯度模式
- en: Core to functional programming is avoiding the use of variables whose values
    change, in favor of declarative patterns. C# has key features to help with those
    patterns, including the ability to write unnamed functions on the fly that “capture”
    variables (*lambda expressions*), and the ability to perform list or reactive
    programming via *query expressions*. C# also provides *records*, which make it
    easy to write *immutable* (read-only) types.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的核心是避免使用值会变化的变量，而是采用声明式模式。C#具有关键功能来帮助这些模式，包括能够即时编写“捕获”变量的未命名函数（*lambda表达式*），以及通过*查询表达式*执行列表或响应式编程。C#还提供了*记录*，使得编写*不可变*（只读）类型变得更加容易。
- en: Type Safety
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型安全
- en: C# is primarily a *type-safe* language, meaning that instances of types can
    interact only through protocols they define, thereby ensuring each type’s internal
    consistency. For instance, C# prevents you from interacting with a *string* type
    as though it were an *integer* type.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: C#主要是一种*类型安全*的语言，意味着类型的实例只能通过它们定义的协议进行交互，从而确保每种类型的内部一致性。例如，C#会阻止你像操作*整数*类型一样操作*字符串*类型。
- en: More specifically, C# supports *static typing*, meaning that the language enforces
    type safety at *compile time*. This is in addition to type safety being enforced
    at *runtime*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，C#支持*静态类型*，这意味着语言在*编译时*强制实施类型安全性。这是对运行时类型安全性的补充。
- en: Static typing eliminates a large class of errors before a program is even run.
    It shifts the burden away from runtime unit tests onto the compiler to verify
    that all the types in a program fit together correctly. This makes large programs
    much easier to manage, more predictable, and more robust. Furthermore, static
    typing allows tools such as IntelliSense in Visual Studio to help you write a
    program because it knows for a given variable what type it is, and hence what
    methods you can call on that variable. Such tools can also identify everywhere
    in your program that a variable, type, or method is used, allowing for reliable
    refactoring.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型化甚至在程序运行之前就消除了大量错误。它将负担从运行时单元测试转移到编译器，以验证程序中所有类型的正确匹配。这使得大型程序更易管理，更可预测，更健壮。此外，静态类型化允许工具如Visual
    Studio中的智能感知帮助编程，因为它知道给定变量的类型，从而知道可以在该变量上调用哪些方法。此类工具还可以识别程序中使用变量、类型或方法的所有地方，从而支持可靠的重构。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: C# also allows parts of your code to be dynamically typed via the `dynamic`
    keyword. However, C# remains a predominantly statically typed language.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: C#还允许你的代码的部分通过`dynamic`关键字进行动态类型化。然而，C#仍然是一种主要静态类型的语言。
- en: C# is also called a *strongly typed language* because its type rules are strictly
    enforced (whether statically or at runtime). For instance, you cannot call a function
    that’s designed to accept an integer with a floating-point number, unless you
    first *explicitly* convert the floating-point number to an integer. This helps
    prevent mistakes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: C# 也被称为*强类型语言*，因为其类型规则严格执行（无论是静态还是运行时）。例如，你不能用浮点数直接调用设计为接受整数的函数，除非你首先*显式*将浮点数转换为整数。这有助于防止错误。
- en: Memory Management
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理
- en: C# relies on the runtime to perform automatic memory management. The Common
    Language Runtime has a garbage collector that executes as part of your program,
    reclaiming memory for objects that are no longer referenced. This frees programmers
    from explicitly deallocating the memory for an object, eliminating the problem
    of incorrect pointers encountered in languages such as C++.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: C#依赖运行时执行自动内存管理。公共语言运行时具有作为程序一部分执行的垃圾收集器，回收不再引用的对象的内存。这使得程序员无需显式地为对象释放内存，消除了在C++等语言中遇到的指针错误问题。
- en: 'C# does not eliminate pointers: it merely makes them unnecessary for most programming
    tasks. For performance-critical hotspots and interoperability, pointers and explicit
    memory allocation is permitted in blocks that are marked `unsafe`.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: C#并未消除指针：它仅使它们对大多数编程任务不必要。对于性能关键的热点和互操作性，可以在标记为`unsafe`的块中使用指针和显式内存分配。
- en: Platform Support
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台支持
- en: 'C# has runtimes that support the following platforms:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: C#具有支持以下平台的运行时：
- en: Windows 7+ Desktop (for rich-client, web, server, and command-line applications)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 7+桌面（用于富客户端、Web、服务器和命令行应用程序）
- en: macOS (for web and command-line applications—and rich-client applications via
    Mac Catalyst)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS（用于Web和命令行应用程序，以及通过Mac Catalyst的富客户端应用程序）
- en: Linux (for web and command-line applications)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux（用于Web和命令行应用程序）
- en: Android and iOS (for mobile applications)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android和iOS（用于移动应用程序）
- en: Windows 10 devices (Xbox, Surface Hub, and HoloLens) via UWP
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 10设备（Xbox、Surface Hub和HoloLens）通过UWP
- en: There is also a technology called *Blazor* that can compile C# to web assembly
    that runs in a browser.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种称为*Blazor*的技术，可以将C#编译为在浏览器中运行的WebAssembly。
- en: CLRs, BCLs, and Runtimes
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CLR、BCL和运行时
- en: Runtime support for C# programs consists of a *Common Language Runtime* and
    a *Base Class Library*. A runtime can also include a higher-level *application
    layer* that contains libraries for developing rich-client, mobile, or web applications
    (see [Figure 1-1](#runtime_architecture)). Different runtimes exist to allow for
    different kinds of applications, as well as different platforms.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: C# 程序的运行时支持包括 *公共语言运行时* 和 *基础类库*。运行时还可以包括一个更高级的 *应用层*，其中包含用于开发富客户端、移动或 Web 应用程序的库（见
    [图 1-1](#runtime_architecture)）。存在不同的运行时以支持不同类型的应用程序和不同的平台。
- en: '![Runtime architecture](assets/cn10_0101.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![运行时架构](assets/cn10_0101.png)'
- en: Figure 1-1\. Runtime architecture
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-1\. 运行时架构
- en: Common Language Runtime
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公共语言运行时
- en: A *Common Language Runtime* (CLR) provides essential runtime services such as
    automatic memory management and exception handling. (The word “common” refers
    to the fact that the same runtime can be shared by other *managed* programming
    languages, such as F#, Visual Basic, and Managed C++.)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*公共语言运行时*（CLR）提供了自动内存管理和异常处理等重要的运行时服务。（“公共”一词指的是同一个运行时可以被其他*托管*编程语言共享，如 F#、Visual
    Basic 和 Managed C++。）'
- en: C# is called a *managed language* because it compiles source code into managed
    code, which is represented in *Intermediate Language* (IL). The CLR converts the
    IL into the native code of the machine, such as X64 or X86, usually just prior
    to execution. This is referred to as Just-In-Time (JIT) compilation. Ahead-of-time
    compilation is also available to improve startup time with large assemblies or
    resource-constrained devices (and to satisfy iOS app store rules when developing
    mobile apps).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: C# 被称为 *托管语言*，因为它将源代码编译为托管代码，这些代码以 *中间语言*（IL）表示。CLR 将 IL 转换为机器的本机代码，如 X64 或
    X86，通常在执行前进行。这称为即时（JIT）编译。还可以提供预编译来改善大型程序集或资源受限设备的启动时间（以及在开发移动应用程序时满足 iOS 应用商店规则）。
- en: The container for managed code is called an *assembly*. An assembly contains
    not only IL but also type information (*metadata*). The presence of metadata allows
    assemblies to reference types in other assemblies without needing additional files.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 托管代码的容器称为 *程序集*。一个程序集不仅包含 IL，还包含类型信息（*元数据*）。有了元数据，程序集可以引用其他程序集中的类型，而无需额外的文件。
- en: Note
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can examine and disassemble the contents of an assembly with Microsoft’s
    *ildasm* tool. And with tools such as ILSpy or JetBrain’s dotPeek, you can go
    further and decompile the IL to C#. Because IL is higher level than native machine
    code, the decompiler can do quite a good job of reconstructing the original C#.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Microsoft 的 *ildasm* 工具可以检查和分解汇编内容。而使用 ILSpy 或 JetBrain 的 dotPeek 等工具，可以进一步反编译
    IL 到 C#。因为 IL 比本机机器码更高级，所以反编译器可以相当好地重建原始的 C#。
- en: A program can query its own metadata (*reflection*) and even generate new IL
    at runtime (*reflection.emit*).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可以查询其自身的元数据（*反射*），甚至在运行时生成新的 IL（*反射.emit*）。
- en: Base Class Library
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础类库
- en: A CLR always ships with a set of assemblies called a *Base Class Library* (BCL).
    A BCL provides core functionality to programmers, such as collections, input/output,
    text processing, XML/JSON handling, networking, encryption, interop, concurrency,
    and parallel programming.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: CLR 总是随附一组称为 *基础类库*（BCL）的程序集。BCL 为程序员提供核心功能，例如集合、输入/输出、文本处理、XML/JSON 处理、网络、加密、互操作、并发和并行编程。
- en: A BCL also implements types that the C# language itself requires (for features
    such as enumeration, querying, and asynchrony) and lets you explicitly access
    features of the CLR, such as Reflection and memory management.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: BCL 还实现了 C# 语言本身需要的类型（例如枚举、查询、异步等功能），并允许您显式访问 CLR 的功能，如反射和内存管理。
- en: Runtimes
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时
- en: A *runtime* (also called a *framework*) is a deployable unit that you download
    and install. A runtime consists of a CLR (with its BCL), plus an optional *application
    layer* specific to the kind of application that you’re writing—web, mobile, rich
    client, etc. (If you’re writing a command-line console application or a non-UI
    library, you don’t need an application layer.)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*运行时*（也称为*框架*）是一个可部署的单元，您可以下载并安装。运行时包括一个 CLR（及其 BCL），以及一个特定于您正在编写的应用程序类型的可选的
    *应用层* —— Web、移动、富客户端等。（如果您正在编写命令行控制台应用程序或非 UI 库，则不需要应用层。）'
- en: When writing an application, you *target* a particular runtime, which means
    that your application uses and depends on the functionality that the runtime provides.
    Your choice of runtime also determines which platforms your application will support.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写应用程序时，您*针对*特定运行时，这意味着您的应用程序使用并依赖运行时提供的功能。您的运行时选择还决定了应用程序将支持哪些平台。
- en: 'The following table lists the major runtime options:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了主要的运行时选项：
- en: '| Application layer | CLR/BCL | Program type | Runs on... |  |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 应用层 | CLR/BCL | 程序类型 | 运行于... |  |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| ASP.NET | .NET 8 | Web | Windows, Linux, macOS |  |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| ASP.NET | .NET 8 | Web | Windows、Linux、macOS |  |'
- en: '| Windows Desktop | .NET 8 | Windows | Windows 10+ |  |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| Windows Desktop | .NET 8 | Windows | Windows 10+ |  |'
- en: '| WinUI 3 | .NET 8 | Windows | Windows 10+ |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| WinUI 3 | .NET 8 | Windows | Windows 10+ |'
- en: '| MAUI | .NET 8 | Mobile, desktop | iOS, Android, macOS, Windows 10+ |  |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| MAUI | .NET 8 | 移动、桌面 | iOS、Android、macOS、Windows 10+ |  |'
- en: '| .NET Framework | .NET Framework | Web, Windows | Windows 7+ |  |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| .NET Framework | .NET Framework | Web, Windows | Windows 7+ |  |'
- en: '[Figure 1-2](#runtimes_for_chash) shows this information graphically and also
    serves as a guide to what’s covered in the book.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-2](#runtimes_for_chash) 在图形上显示了这些信息，同时也作为本书内容的指南。'
- en: '![Runtimes for C#](assets/cn10_0102.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![C# 运行时](assets/cn10_0102.png)'
- en: Figure 1-2\. Runtimes for C#
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-2\. C# 运行时
- en: .NET 8
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .NET 8
- en: .NET 8 is Microsoft’s flagship open-source runtime. You can write web and console
    applications that run on Windows, Linux, and macOS; rich-client applications that
    run on Windows 10+ and macOS; and mobile apps that run on iOS and Android. This
    book focuses on the .NET 8 CLR and BCL.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 8 是微软的旗舰开源运行时。您可以编写运行在 Windows、Linux 和 macOS 上的 Web 和控制台应用程序；运行在 Windows
    10+ 和 macOS 上的富客户端应用程序；以及运行在 iOS 和 Android 上的移动应用程序。本书重点介绍 .NET 8 的 CLR 和 BCL。
- en: Unlike .NET Framework, .NET 8 is not preinstalled on Windows machines. If you
    try to run a .NET 8 application without the correct runtime being present, a message
    will appear directing you to a web page where you can download the runtime. You
    can avoid this by creating a *self-contained* deployment, which includes the parts
    of the runtime required by the application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与 .NET Framework 不同，.NET 8 未预装在 Windows 机器上。如果尝试在没有正确运行时的情况下运行 .NET 8 应用程序，将出现消息引导您访问网页下载运行时。您可以通过创建*自包含*部署来避免这种情况，该部署包括应用程序所需的运行时部分。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: '.NET’s update history runs as follows: .NET Core 1.x → NET Core 2.x → .NET
    Core 3.x → .NET 5 → .NET 6 → .NET 7 → .NET 8\. After .NET Core 3, Microsoft removed
    “Core” from the name and skipped version 4 to avoid confusion with *.NET Framework*
    4.x, which precedes all of the preceding runtimes but is still supported and in
    popular use.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 的更新历史如下：.NET Core 1.x → .NET Core 2.x → .NET Core 3.x → .NET 5 → .NET 6
    → .NET 7 → .NET 8\. 在 .NET Core 3 之后，Microsoft 删除了名称中的“Core”，并跳过了版本 4，以避免与* .NET
    Framework* 4.x 混淆，后者是所有前述运行时的先行版本但仍得到支持并广泛使用。
- en: This means that assemblies compiled under .NET Core 1.x → .NET 7 will, in most
    cases, run without modification under .NET 8\. In contrast, assemblies compiled
    under (any version of) .NET Framework are usually incompatible with .NET 8.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在 .NET Core 1.x → .NET 7 下编译的程序集在大多数情况下可以在 .NET 8 下运行而无需修改。相比之下，在任何版本的 .NET
    Framework 下编译的程序集通常与 .NET 8 不兼容。
- en: Windows Desktop and WinUI 3
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows 桌面和 WinUI 3
- en: For writing rich-client applications that run on Windows 10 and above, you can
    choose between the classic Windows Desktop APIs (Windows Forms and WPF) and WinUI
    3\. The Windows Desktop APIs are part of the .NET Desktop runtime, whereas WinUI
    3 is part of the *Windows App SDK* (a separate download).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写在 Windows 10 及更高版本上运行的富客户端应用程序，您可以选择经典的 Windows 桌面 API（Windows Forms 和 WPF）和
    WinUI 3\. Windows 桌面 API 是 .NET 桌面运行时的一部分，而 WinUI 3 则属于*Windows 应用程序 SDK*（需要单独下载）。
- en: The classic Windows Desktop APIs have existed since 2006 and enjoy terrific
    third-party library support, as well as offering a wealth of answered questions
    on sites such as StackOverflow. *WinUI 3* was released in 2022 and is intended
    for writing modern immersive applications that feature the latest Windows 10+
    controls. It is a successor to the *Universal Windows Platform* (UWP).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的 Windows 桌面 API 自 2006 年以来存在，并且享有出色的第三方库支持，以及在诸如 StackOverflow 等网站上提供大量问题解答。*WinUI
    3* 在 2022 年发布，旨在编写现代沉浸式应用程序，具备最新的 Windows 10+ 控件。它是*Universal Windows Platform*（UWP）的后继者。
- en: MAUI
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MAUI
- en: '*MAUI* (Multi-platform App UI) is designed primarily for creating mobile apps
    for iOS and Android, although it can also be used for desktop apps that run on
    macOS and Windows via Mac Catalyst and WinUI 3\. MAUI is an evolution of Xamarin
    and allows a single project to target multiple platforms.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*MAUI*（多平台应用程序UI）主要设计用于创建iOS和Android的移动应用程序，尽管也可用于通过Mac Catalyst和WinUI 3在macOS和Windows上运行的桌面应用程序。MAUI是Xamarin的演变，允许单个项目目标多个平台。'
- en: Note
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: For cross-platform desktop applications, a third-party library called Avalonia
    offers an alternative to MAUI. Avalonia also runs on Linux and is architecturally
    simpler than MAUI (as it operates without the Catalyst/WinUI indirection layer).
    Avalonia has an API similar to WPF, and it also offers a commercial add-on called
    XPF that provides almost complete WPF compatibility.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于跨平台桌面应用程序，第三方库Avalonia提供了一个MAUI的替代方案。Avalonia还可以在Linux上运行，结构比MAUI更简单（因为它在没有Catalyst/WinUI间接层的情况下运行）。Avalonia的API类似于WPF，并且还提供一个名为XPF的商业附加组件，几乎完全兼容WPF。
- en: .NET Framework
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .NET Framework
- en: '*.NET Framework* is Microsoft’s original Windows-only runtime for writing web
    and rich-client applications that run (only) on Windows desktop/server. No major
    new releases are planned, although Microsoft will continue to support and maintain
    the current 4.8 release due to the wealth of existing applications.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*.NET Framework* 是微软最初仅限于Windows的运行时，用于编写运行于Windows桌面/服务器上的Web和丰富客户端应用程序。尽管没有计划推出主要新版本，但由于现有应用程序的丰富性，微软将继续支持和维护当前的4.8版本。'
- en: With the .NET Framework, the CLR/BCL is integrated with the application layer.
    Applications written in .NET Framework can be recompiled under .NET 8, although
    they usually require some modification. Some features of .NET Framework are not
    present in .NET 8 (and vice versa).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET Framework中，CLR/BCL与应用程序层集成。在.NET 8下重新编译.NET Framework编写的应用程序通常需要一些修改。.NET
    Framework的一些功能在.NET 8中不存在（反之亦然）。
- en: .NET Framework is preinstalled with Windows and is automatically patched via
    Windows Update. When you target .NET Framework 4.8, you can use the features of
    C# 7.3 and earlier. (You can override this by specifying a newer language version
    in the project file—this unlocks all of the latest language features except for
    those that require support from a newer runtime.)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework与Windows预装，并通过Windows更新自动打补丁。当你的目标是.NET Framework 4.8时，你可以使用C#
    7.3及更早版本的功能。（你可以通过在项目文件中指定更高语言版本来覆盖此设置，这将解锁所有最新语言功能，除了需要新运行时支持的那些功能。）
- en: Note
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The word “.NET” has long been used as an umbrella term for any technology that
    includes the word “.NET” (.NET Framework, .NET Core, .NET Standard, and so on).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 单词“.NET”长期以来被用作涵盖包括“.NET”在内的任何技术的总称（.NET Framework、.NET Core、.NET Standard等）。
- en: This means that Microsoft’s renaming of .NET Core to .NET has created an unfortunate
    ambiguity. In this book, we’ll refer to the new .NET as *.NET 5+* when an ambiguity
    arises. And to refer to .NET Core and its successors, we’ll use the phrase “.NET
    Core and .NET 5+.”
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着微软将.NET Core重命名为.NET，造成了不幸的歧义。在本书中，当出现歧义时，我们将把新的.NET称为*.NET 5+*。为了指代.NET
    Core及其后继版本，我们将使用短语“.NET Core和.NET 5+”。
- en: To add to the confusion, .NET (5+) is a framework, yet it’s very different from
    the *.NET Framework*. Hence, we’ll use the term *runtime* in preference to *framework*,
    where possible.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为增加混淆，.NET (5+) 是一个框架，但与*.NET Framework*截然不同。因此，在可能的情况下，我们将更倾向于使用术语*运行时*而非*框架*。
- en: Niche Runtimes
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 专用运行时
- en: 'There are also the following niche runtimes:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 还有以下专用运行时：
- en: Unity is a game development platform that allows game logic to be scripted with
    C#.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity是一个游戏开发平台，允许用C#编写游戏逻辑。
- en: '*Universal Windows Platform* (UWP) was designed for writing touch-first applications
    that run on Windows 10+ desktop and devices, including Xbox, Surface Hub, and
    HoloLens. UWP apps are sandboxed and ship via the Windows Store. UWP uses a version
    of the .NET Core 2.2 CLR/BCL, and it’s unlikely that this dependency will be updated;
    instead, Microsoft has recommended that users switch to its modern replacement,
    WinUI 3\. But because WinUI 3 only supports Windows desktop, UWP still has a niche
    application for targeting Xbox, Surface Hub, and HoloLens.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Universal Windows Platform*（UWP）旨在编写在Windows 10+桌面和设备上运行的触摸优先应用程序，包括Xbox、Surface
    Hub和HoloLens。UWP应用程序是沙盒化的，并通过Windows Store发布。UWP使用.NET Core 2.2 CLR/BCL的一个版本，不太可能更新这种依赖关系；相反，微软建议用户切换到其现代替代品WinUI
    3。但由于WinUI 3仅支持Windows桌面，UWP仍然在定位Xbox、Surface Hub和HoloLens时具有专用应用程序的市场。'
- en: The .NET Micro Framework is for running .NET code on highly resource-constrained
    embedded devices (under one megabyte).
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Micro Framework 用于在资源极为有限的嵌入式设备上运行 .NET 代码（不到一兆字节）。
- en: It’s also possible to run managed code within SQL Server. With SQL Server CLR
    integration, you can write custom functions, stored procedures, and aggregations
    in C# and then call them from SQL. This works in conjunction with .NET Framework
    and a special “hosted” CLR that enforces a sandbox to protect the integrity of
    the SQL Server process.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL Server 中还可以运行托管代码。通过 SQL Server CLR 集成，你可以用 C# 编写自定义函数、存储过程和聚合函数，然后从 SQL
    中调用它们。这与 .NET Framework 和一个特殊的“托管”CLR 结合使用，强制实施沙箱以保护 SQL Server 进程的完整性。
- en: A Brief History of C#
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 简史
- en: The following is a reverse chronology of the new features in each C# version,
    for the benefit of readers who are already familiar with an older version of the
    language.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是每个 C# 版本中新功能的逆时代顺序，以便读者了解老版本语言的好处。
- en: What’s New in C# 12
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 12 中的新功能
- en: C# 12 ships with Visual Studio 2022, and is used when you target .NET 8.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: C# 12 随 Visual Studio 2022 发布，并且当你的目标是 .NET 8 时使用。
- en: Collection expressions
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合表达式
- en: 'Rather than initializing an array as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是像下面这样初始化数组：
- en: '[PRE0]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'you can now use square brackets (a *collection expression*):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用方括号（一个 *集合表达式*）：
- en: '[PRE1]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Collection expressions have two major advantages. First, the same syntax also
    works with other collection types, such as lists and sets (and even the low-level
    span types):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 集合表达式有两个主要优点。首先，相同的语法也适用于其他集合类型，例如列表和集合（甚至低级别的 span 类型）：
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Second, they are *target-typed*, which means that you can omit the type in
    other scenarios where the compiler can infer it, such as when calling methods:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，它们是 *目标类型推断*，这意味着在编译器可以推断出类型的其他情况下，可以省略类型，例如在调用方法时：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: See [“Collection Initializers and Collection Expressions”](ch04.html#collection_initializers_and_collection)
    for more details.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 更多详情请参见 [“集合初始化器和集合表达式”](ch04.html#collection_initializers_and_collection)。
- en: Primary constructors in classes and structs
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类和结构体中的主要构造函数
- en: 'From C# 12, you can include a parameter list directly after a class (or struct)
    declaration:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 12 开始，你可以直接在类（或结构体）声明后包含一个参数列表：
- en: '[PRE4]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This instructs the compiler to automatically build a *primary constructor*,
    allowing the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这指示编译器自动构建一个 *主要构造函数*，允许以下操作：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This feature has existed since C# 9 with records—where they behave slightly
    differently. With records, the compiler generates (by default) a public init-only
    property for each primary constructor parameter. This is not the case with classes
    and structs; to achieve the same result, you must define those properties explicitly:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性自 C# 9 开始存在于记录（records）中——在那里它们的行为稍有不同。对于记录，编译器（默认情况下）为每个主要构造函数参数生成一个公共的只读属性。对于类和结构体来说并非如此；要达到相同的结果，必须显式定义这些属性：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Primary constructors work well in simple scenarios. We describe their nuances
    and limitations in [“Primary Constructors (C# 12)”](ch03.html#primary_constructors_left_parenthesisch).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 主要构造函数在简单场景中运行良好。我们在 [“主要构造函数（C# 12）”](ch03.html#primary_constructors_left_parenthesisch)
    中描述了它们的细微差别和限制。
- en: Default lambda parameters
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认的 Lambda 参数
- en: 'Just as ordinary methods can define parameters with default values:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 就像普通方法可以定义带有默认值的参数一样：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'so, too, can lambda expressions:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，lambda 表达式也可以：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This feature is useful with libraries such as ASP.NET Minimal API.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性在诸如 ASP.NET Minimal API 等库中非常有用。
- en: Alias any type
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 给任何类型取别名
- en: 'C# has always allowed you to alias a simple or generic type via the `using`
    directive:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: C# 一直允许你通过 `using` 指令给一个简单或通用类型取别名：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'From C# 12, this approach works with other kinds of types, too, such as arrays
    and tuples:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 12 开始，这种方法也适用于其他类型，例如数组和元组：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Other new features
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他新特性
- en: C# 12 also supports *inline arrays*, via the `[System.Runtime.CompilerServices.InlineArray]`
    attribute. This allows for the creation of fixed-size arrays in a struct without
    requiring an unsafe context, and is intended for use primarily within the runtime
    APIs.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: C# 12 还支持 *内联数组*，通过 `[System.Runtime.CompilerServices.InlineArray]` 属性。这允许在结构体中创建固定大小的数组而无需在不安全的上下文中进行，并且主要用于运行时
    API 中。
- en: What’s New in C# 11
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 11 中的新功能
- en: C# 11 shipped with Visual Studio 2022, and is used by default when you target
    .NET 7.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: C# 11 随 Visual Studio 2022 发布，并且当你的目标是 .NET 7 时默认使用。
- en: Raw string literals
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始字符串字面量
- en: 'Wrapping a string in three or more quote characters creates a *raw string literal*,
    which can contain almost any character sequence without escaping or doubling up.
    This makes it easy to represent JSON, XML, and HTML literals, as well as regular
    expressions and source code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 用三个或更多引号字符包裹字符串创建*原始字符串字面量*，它几乎可以包含任何字符序列，无需转义或重复：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Raw string literals can be multiline and permit interpolation via the `$` prefix:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 原始字符串字面量可以是多行的，并且可以通过`$`前缀进行插值：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Using two (or more) `$` characters in a raw string literal prefix changes the
    interpolation sequence from one brace to two (or more) braces, allowing you to
    include braces in the string itself:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始字符串字面量前使用两个（或更多）`$`字符可以改变插值序列，从单个大括号变为两个（或更多）大括号，允许你在字符串本身中包含大括号：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We cover the nuances of this feature in [“Raw string literals (C# 11)”](ch02.html#raw_string_literals_left_parenthesischa)
    and [“String interpolation”](ch02.html#string_interpolation).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[“原始字符串字面量（C# 11）”](ch02.html#raw_string_literals_left_parenthesischa)和[“字符串插值”](ch02.html#string_interpolation)章节中涵盖了此功能的细微差别。
- en: UTF-8 strings
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UTF-8字符串
- en: 'With the `u8` suffix, you create string literals encoded in UTF-8 rather than
    UTF-16\. This feature is intended for advanced scenarios such as the low-level
    handling of JSON text in performance hotspots:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`u8`后缀，你可以创建使用UTF-8编码而不是UTF-16编码的字符串字面量。此功能适用于高级场景，例如在性能热点中低级处理JSON文本：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The underlying type is `ReadOnlySpan<byte>` ([Chapter 23](ch23.html#spanless_thantgreater_than_and-id00089)),
    which you can convert to a byte array by calling its `ToArray()` method.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 底层类型是`ReadOnlySpan<byte>`（[第23章](ch23.html#spanless_thantgreater_than_and-id00089)），您可以通过调用其`ToArray()`方法将其转换为字节数组。
- en: List patterns
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表模式
- en: 'List patterns match a series of elements in square brackets, and work with
    any collection type that is countable (with a `Count` or `Length` property) and
    indexable (with an indexer of type `int` or `System.Index`):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表模式匹配方括号中的一系列元素，并与任何可计数的集合类型一起使用（具有`Count`或`Length`属性以及`int`类型或`System.Index`类型的索引器）：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'An underscore matches a single element of any value, and two dots match zero
    or more elements (a *slice*):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线匹配任意值的单个元素，而两个点匹配零个或多个元素（*切片*）：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A slice can be followed by the `var` pattern—see [“List Patterns”](ch04.html#list_patterns-id00076)
    for details.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 切片后可以跟随`var`模式—详见[“列表模式”](ch04.html#list_patterns-id00076)。
- en: Required members
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 必需成员
- en: 'Applying the `required` modifier to a field or property forces consumers of
    that class or struct to populate that member via an object initializer when constructing
    it:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将`required`修饰符应用于字段或属性会强制类或结构的使用者在构造时通过对象初始化器填充该成员：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With this feature, you can avoid writing constructors with long parameter lists,
    which can simplify subclassing. Should you also wish to write a constructor, you
    can apply the `[SetsRequiredMembers]` attribute to bypass the required member
    restriction for that constructor—see [“Required members (C# 11)”](ch03.html#required_members_left_parenthesischash)
    for details.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此功能，您可以避免编写具有长参数列表的构造函数，从而简化子类化。如果您希望编写构造函数，可以通过在其上应用`[SetsRequiredMembers]`属性来绕过该构造函数的必需成员限制—详见[“必需成员（C#
    11）”](ch03.html#required_members_left_parenthesischash)。
- en: Static virtual/abstract interface members
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态虚拟/抽象接口成员
- en: 'From C# 11, interfaces can declare members as `static virtual` or `static abstract`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 11开始，接口可以将成员声明为`static virtual`或`static abstract`：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'These members are implemented as static functions in classes or structs, and
    can be called polymorphically via a constrained type parameter:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些成员在类或结构中以静态函数实现，并可以通过约束类型参数进行多态调用。
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Operator functions can also be declared as `static virtual` or `static abstract`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符函数也可以声明为`static virtual`或`static abstract`。
- en: For details, see [“Static virtual/abstract interface members”](ch03.html#static_virtualsolidusabstract-id00091)
    and [“Static Polymorphism”](ch04.html#static_polymorphism). We also describe how
    to call static abstract members via reflection in [“Calling Static Virtual/Abstract
    Interface Members”](ch18.html#calling_static_virtualsolidusabstract_i).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 更多细节，请参见[“静态虚拟/抽象接口成员”](ch03.html#static_virtualsolidusabstract-id00091)和[“静态多态性”](ch04.html#static_polymorphism)。我们还描述了如何通过反射调用静态抽象成员的方法，详见[“调用静态虚拟/抽象接口成员”](ch18.html#calling_static_virtualsolidusabstract_i)。
- en: Generic math
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 泛型数学
- en: 'The `System.Numerics.INumber<TSelf>` interface (new to .NET 7) unifies arithmetic
    operations across all numeric types, allowing generic methods such as the following
    to be written:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Numerics.INumber<TSelf>` 接口（在 .NET 7 中新增）统一了所有数值类型的算术操作，允许编写如下泛型方法：'
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`INumber<TSelf>` is implemented by all real and integral numeric types in .NET
    (as well as `char`), and comprises several interfaces that include static abstract
    operator definitions such as the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`INumber<TSelf>` 被所有实数和整数数字类型（以及`char`）实现，并包含多个接口，包括以下静态抽象操作符定义：'
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We cover this in [“Polymorphic Operators”](ch04.html#polymorphic_operators)
    and [“Generic Math”](ch04.html#generic_math-id00069).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[“多态运算符”](ch04.html#polymorphic_operators)和[“通用数学”](ch04.html#generic_math-id00069)中进行了讨论。
- en: Other new features
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他新特性
- en: 'A type with the `file` accessibility modifier can be accessed only from within
    the same file, and is intended for use within source generators:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 具有`file`访问修饰符的类型只能从同一文件中访问，并且旨在在源生成器内使用：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: C# 11 also introduced checked operators (see [“Checked operators”](ch04.html#checked_operators)),
    for defining operator functions to be called inside `checked` blocks (this was
    required for a full implementation of generic math). C# 11 also relaxed the requirement
    to populate every field in a struct’s constructor (see [“Struct Construction Semantics”](ch03.html#struct_construction_semantics)).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: C# 11 还引入了检查运算符（参见[“检查运算符”](ch04.html#checked_operators)），用于定义在`checked`块内调用的运算符函数（这是实现通用数学的完整实现所需的）。C#
    11 还放宽了结构体构造函数中必须填充每个字段的要求（参见[“结构构造语义”](ch03.html#struct_construction_semantics)）。
- en: Finally, the `nint` and `nuint` native-sized integers types that were introduced
    in C# 9 to match the address space of the process at runtime (32 or 64 bits) were
    enhanced in C# 11 when targeting .NET 7 or later. Specifically, the compile-time
    distinction between these types and their underlying runtime types (`IntPtr` and
    `UIntPtr`) has melted away when targeting .NET 7+. See [“Native-Sized Integers”](ch04.html#native_sized_integers)
    for a full discussion.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，C# 11 在面向 .NET 7 或更高版本时增强了在运行时（32 或 64 位）匹配进程地址空间的`nint`和`nuint`本机大小整数类型，这些类型在
    C# 9 中引入时与其底层运行时类型（`IntPtr` 和 `UIntPtr`）之间的编译时区别已经消失。详见[“本机大小整数”](ch04.html#native_sized_integers)以获取详细讨论。
- en: What’s New in C# 10
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 10 中的新特性
- en: C# 10 shipped with Visual Studio 2022, and is used when you target .NET 6.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: C# 10 随 Visual Studio 2022 发布，并在目标 .NET 6 时使用。
- en: File-scoped namespaces
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件范围命名空间
- en: 'In the common case that all types in a file are defined in a single namespace,
    a *file-scoped namespace* declaration in C# 10 reduces clutter and eliminates
    an unnecessary level of indentation:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在常见情况下，文件中的所有类型都定义在单个命名空间中，C# 10 中的*文件范围命名空间*声明可以减少混乱并消除不必要的缩进级别：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The global using directive
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局 using 指令
- en: 'When you prefix a `using` directive with the `global` keyword, it applies the
    directive to all files in the project:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在`using`指令前加上`global`关键字时，它会将该指令应用于项目中的所有文件：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This lets you avoid repeating the same directives in every file. `global using`
    directives work with `using static`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这使您可以避免在每个文件中重复相同的指令。`global using` 指令与 `using static` 兼容。
- en: 'Additionally, .NET 6 projects now support *implicit global using directives*:
    if the `ImplicitUsings` element is set to true in the project file, the most commonly
    used namespaces are automatically imported (based on the SDK project type). See
    [“The global using Directive”](ch02.html#the_global_using_directive-id00095) for
    more detail.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，.NET 6 项目现在支持*隐式全局 using 指令*：如果项目文件中的`ImplicitUsings`元素设置为 true，则会自动导入最常用的命名空间（基于
    SDK 项目类型）。详见[“全局 using 指令”](ch02.html#the_global_using_directive-id00095)获取更多细节。
- en: Nondestructive mutation for anonymous types
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对于匿名类型的非破坏性突变
- en: 'C# 9 introduced the `with` keyword, to perform nondestructive mutation on records.
    In C# 10, the `with` keyword also works with anonymous types:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: C# 9 引入了`with`关键字，用于对记录执行非破坏性突变。在 C# 10 中，`with`关键字也适用于匿名类型：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: New deconstruction syntax
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的解构语法
- en: 'C# 7 introduced the deconstruction syntax for tuples (or any type with a `Deconstruct`
    method). C# 10 takes this syntax further, letting you mix assignment and declaration
    in the same deconstruction:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7 引入了元组（或任何具有`Deconstruct`方法的类型）的解构语法。C# 10 深化了此语法，允许在同一解构中混合赋值和声明：
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Field initializers and parameterless constructors in structs
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构中的字段初始化器和无参数构造函数
- en: From C# 10, you can include field initializers and parameterless constructors
    in structs (see [“Structs”](ch03.html#structs)). These execute only when the constructor
    is called explicitly, and so can easily be bypassed—for instance, via the `default`
    keyword. This feature was introduced primarily for the benefit of struct records.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 10开始，您可以在结构体中包含字段初始化程序和无参数构造函数（参见[“结构体”](ch03.html#structs)）。这些仅在显式调用构造函数时执行，因此可以轻松地通过`default`关键字绕过。此功能主要为结构记录的利益而引入。
- en: Record structs
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录结构体
- en: 'Records were first introduced in C# 9, where they acted as a compiled-enhanced
    class. In C# 10, records can also be structs:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 记录最早在C# 9中引入，作为增强编译类。在C# 10中，记录还可以是结构体：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The rules are otherwise similar: *record structs* have much the same features
    as *class structs* (see [“Records”](ch04.html#records-id00087)). An exception
    is that the compiler-generated properties on record structs are writable, unless
    you prefix the record declaration with the `readonly` keyword.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 否则规则相似：*记录结构体*与*类结构体*具有几乎相同的特性（参见[“记录”](ch04.html#records-id00087)）。唯一的例外是记录结构体上的编译器生成的属性是可写的，除非您在记录声明前加上`readonly`关键字。
- en: Lambda expression enhancements
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Lambda表达式增强
- en: 'The syntax around lambda expressions has been enhanced in a number of ways.
    First, implicit typing (`var`) is permitted:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对lambda表达式的语法进行了多方面增强。首先，允许隐式类型化（`var`）：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The implicit type for a lambda expression is an `Action` or `Func` delegate,
    so `greeter`, in this case, is of type `Func<string>`. You must explicitly state
    any parameter types:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: lambda表达式的隐式类型为`Action`或`Func`委托，在这种情况下，`greeter`的类型为`Func<string>`。必须明确声明任何参数类型：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Second, a lambda expression can specify a return type:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，lambda表达式可以指定返回类型：
- en: '[PRE30]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is primarily to improve compiler performance with complex nested lambdas.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这主要是为了改善复杂嵌套lambda的编译器性能。
- en: 'Third, you can pass a lambda expression into a method parameter of type `object`,
    `Delegate,` or `Expression`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，您可以将lambda表达式传递给`object`、`Delegate`或`Expression`类型的方法参数：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, you can apply attributes to a lambda expression’s compile-generated
    target method (as well as its parameters and return value):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以将属性应用于lambda表达式的编译生成目标方法（以及其参数和返回值）：
- en: '[PRE32]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: See [“Applying Attributes to Lambda Expressions”](ch04.html#applying_attributes_to_lambda_expressio)
    for more detail.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[“将属性应用于Lambda表达式”](ch04.html#applying_attributes_to_lambda_expressio)以获取更多详细信息。
- en: Nested property patterns
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌套属性模式
- en: 'The following simplified syntax is legal in C# 10 for nested property pattern
    matching (see [“Property Patterns”](ch04.html#property_patterns)):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 10中，可以使用以下简化的语法进行嵌套属性模式匹配（参见[“属性模式”](ch04.html#property_patterns)）：
- en: '[PRE33]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is equivalent to:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于：
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: CallerArgumentExpression
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CallerArgumentExpression
- en: 'A method parameter to which you apply the `[CallerArgumentExpression]` attribute
    captures an argument expression from the call site:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 将`[CallerArgumentExpression]`属性应用于方法参数，可以从调用站点捕获参数表达式：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This feature is intended primarily for validation and assertion libraries (see
    [“CallerArgumentExpression”](ch04.html#callerargumentexpression-id00054)).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能主要用于验证和断言库（参见[“CallerArgumentExpression”](ch04.html#callerargumentexpression-id00054)）。
- en: Other new features
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他新功能
- en: The `#line` directive has been enhanced in C# 10 to allow a column and range
    to be specified.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: C# 10中的`#line`指令已增强，允许指定列和范围。
- en: Interpolated strings in C# 10 can be constants, as long as the interpolated
    values are constants.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: C# 10中的插值字符串可以是常量，只要插入的值是常量即可。
- en: Records can seal the `ToString()` method in C# 10.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 记录可以在C# 10中封闭`ToString()`方法。
- en: 'C#’s definite assignment analysis has been improved so that expressions such
    as the following work:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: C#的明确赋值分析已得到改进，使得以下表达式等均可工作：
- en: '[PRE36]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '(Prior to C# 10, the compiler would generate an error: “Use of unassigned local
    variable ‘number’.”)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: （在C# 10之前，编译器会生成错误：“使用未分配的局部变量‘number’。”）
- en: What’s New in C# 9.0
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 9.0中的新功能
- en: C# 9.0 shipped with *Visual Studio 2019*, and is used when you target .NET 5.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: C# 9.0与*Visual Studio 2019*一同发布，并在您的目标为.NET 5时使用。
- en: Top-level statements
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 顶级语句
- en: 'With *top-level statements* (see [“Top-Level Statements”](ch02.html#top_level_statements-id00098)),
    you can write a program without the baggage of a `Main` method and `Program` class:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通过*顶级语句*（参见[“顶级语句”](ch02.html#top_level_statements-id00098)），您可以编写一个程序，而无需`Main`方法和`Program`类的包袱：
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Top-level statements can include methods (which act as local methods). You can
    also access command-line arguments via the “magic” `args` variable, and return
    a value to the caller. Top-level statements can be followed by type and namespace
    declarations.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层语句可以包含方法（作为本地方法）。您还可以通过“magic” `args` 变量访问命令行参数，并将值返回给调用者。顶层语句后面可以跟随类型和命名空间声明。
- en: Init-only setters
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅初始化的设置器
- en: 'An *init-only setter* (see [“Init-only setters”](ch03.html#init_only_setters-id00074))
    in a property declaration uses the `init` keyword instead of the `set` keyword:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性声明中，*仅初始化的设置器*（见[“仅初始化的设置器”](ch03.html#init_only_setters-id00074)）使用 `init`
    关键字而不是 `set` 关键字：
- en: '[PRE38]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This behaves like a read-only property, except that it can also be set via
    an object initializer:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这表现得像一个只读属性，但也可以通过对象初始化程序进行设置：
- en: '[PRE39]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This makes it possible to create immutable (read-only) types that can be populated
    via an object initializer instead of a constructor, and helps to avoid the antipattern
    of constructors that accept a large number of optional parameters. Init-only setters
    also allow for *nondestructive mutation* when used in *records*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得可以创建可通过对象初始化程序而不是构造函数填充的不可变（只读）类型，并有助于避免接受大量可选参数的构造函数的反模式。仅初始化的设置器还允许在*记录*中使用时进行*非破坏性变异*。
- en: Records
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录
- en: 'A *record* (see [“Records”](ch04.html#records-id00087)) is a special kind of
    class that’s designed to work well with immutable data. Its most special feature
    is that it supports *nondestructive mutation* via a new keyword (`with`):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*记录*（见[“记录”](ch04.html#records-id00087)）是一种特殊类型的类，旨在与不可变数据很好地配合。其最特别的功能是通过新关键字(`with`)支持*非破坏性变异*：'
- en: '[PRE40]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In simple cases, a record can also eliminate the boilerplate code of defining
    properties and writing a constructor and deconstructor. We can replace our `Point`
    record definition with the following, without loss of functionality:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单情况下，记录还可以消除定义属性和编写构造函数和析构函数的样板代码。我们可以用以下方式替换我们的 `Point` 记录定义，而不会丧失功能：
- en: '[PRE41]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Like tuples, records exhibit structural equality by default. Records can subclass
    other records, and can include the same constructs that classes can include. The
    compiler implements records as classes at runtime.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 像元组一样，默认情况下，记录展示结构相等性。记录可以子类化其他记录，并且可以包含类可以包含的相同结构。编译器在运行时将记录实现为类。
- en: Pattern-matching improvements
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模式匹配改进
- en: 'The *relational pattern* (see [“Patterns”](ch04.html#patterns)) allows the
    `<`, `>`, `<=`, and `>=` operators to appear in patterns:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*关系模式*（见[“模式”](ch04.html#patterns)）允许在模式中出现 `<`, `>`, `<=`, 和 `>=` 操作符：'
- en: '[PRE42]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'With *pattern combinators*, you can combine patterns via three new keywords
    (`and`, `or`, and `not`):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*模式组合器*，您可以通过三个新关键字(`and`, `or`, 和 `not`)组合模式：
- en: '[PRE43]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As with the `&&` and `||` operators, `and` has higher precedence than `or`.
    You can override this with parentheses.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `&&` 和 `||` 操作符一样，`and` 的优先级高于 `or`。您可以用括号覆盖这一点。
- en: 'The `not` combinator can be used with the *type pattern* to test whether an
    object is (not) a type:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`not` 组合器可以与*类型模式*一起使用，以测试对象是否为（非）类型：'
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Target-typed new expressions
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 靶向类型的新表达式
- en: 'When constructing an object, C# 9 lets you omit the type name when the compiler
    can infer it unambiguously:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造对象时，C# 9 允许您在编译器可以明确推断类型名称时省略类型名称：
- en: '[PRE45]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This is particularly useful when the variable declaration and initialization
    are in different parts of your code:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量声明和初始化位于代码的不同部分时，这尤其有用：
- en: '[PRE46]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'And in the following scenario:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在以下场景中：
- en: '[PRE47]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: See [“Target-Typed new Expressions”](ch02.html#target_typed_new_expressions-id00094)
    for more information.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参阅[“靶向类型的新表达式”](ch02.html#target_typed_new_expressions-id00094)。
- en: Interop improvements
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 互操作性改进
- en: C# 9 introduces *function pointers* (see [“Function Pointers”](ch04.html#function_pointers)
    and [“Callbacks with Function Pointers”](ch24.html#callbacks_with_function_pointers_left_p)).
    Their main purpose is to allow unmanaged code to call static methods in C# without
    the overhead of a delegate instance, with the ability to bypass the P/Invoke layer
    when the arguments and return types are *blittable* (represented identically on
    each side).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: C# 9 引入*函数指针*（见[“函数指针”](ch04.html#function_pointers)和[“使用函数指针进行回调”](ch24.html#callbacks_with_function_pointers_left_p)）。它们的主要目的是允许非托管代码调用C#中的静态方法，而无需委托实例的开销，并且可以绕过P/Invoke层，当参数和返回类型是*可直接传送*（在每一侧都表示相同）时。
- en: C# 9 also introduces the `nint` and `nuint` native-sized integer types (see
    [“Native-Sized Integers”](ch04.html#native_sized_integers)), which map at runtime
    to `System.IntPtr` and `System.UIntPtr`. At compile time, they behave like numeric
    types with support for arithmetic operations.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: C# 9 还引入了`nint`和`nuint`本机大小的整数类型（参见[“本机大小的整数”](ch04.html#native_sized_integers)），在运行时映射到`System.IntPtr`和`System.UIntPtr`。在编译时，它们表现得像支持算术运算的数值类型。
- en: Other new features
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他新特性
- en: 'Additionally, C# 9 now lets you:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，C# 9 现在还允许你：
- en: Override a method or read-only property such that it returns a more derived
    type (see [“Covariant return types”](ch03.html#covariant_return_types)).
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重写方法或只读属性，使其返回更派生的类型（参见[“协变返回类型”](ch03.html#covariant_return_types)）。
- en: Apply attributes to local functions (see [“Attributes”](ch04.html#attributes)).
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对本地函数应用属性（参见[“属性”](ch04.html#attributes)）。
- en: Apply the `static` keyword to lambda expressions or local functions to ensure
    that you don’t accidentally capture local or instance variables (see [“Static
    lambdas”](ch04.html#static_lambdas)).
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 lambda 表达式或本地函数应用`static`关键字，以确保不会意外捕获本地或实例变量（参见[“静态 lambda”](ch04.html#static_lambdas)）。
- en: Make any type work with the `foreach` statement, by writing a `GetEnumerator`
    extension method.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过编写`GetEnumerator`扩展方法，使任何类型与`foreach`语句一起工作。
- en: Define a *module initializer* method that executes once when an assembly is
    first loaded, by applying the `[ModuleInitializer]` attribute to a (static void
    parameterless) method.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义*模块初始化器*方法，该方法在装配体首次加载时执行，通过在（静态无参数）方法上应用`[ModuleInitializer]`属性。
- en: Use a “discard” (underscore symbol) as a lambda expression argument.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将“丢弃”（下划线符号）作为 lambda 表达式参数。
- en: Write *extended partial methods* that are mandatory to implement—enabling scenarios
    such as Roslyn’s new *source generators* (see [“Extended partial methods”](ch03.html#extended_partial_methods)).
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写*扩展部分方法*，这些方法是强制实现的，可用于场景，如 Roslyn 的新*源生成器*（参见[“扩展部分方法”](ch03.html#extended_partial_methods)）。
- en: Apply an attribute to methods, types, or modules to prevent local variables
    from being initialized by the runtime (see [“[SkipLocalsInit]”](ch04.html#left_square_bracketskiplocalsinitright)).
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将属性应用于方法、类型或模块，以防止本地变量在运行时被初始化（参见[“[SkipLocalsInit]”](ch04.html#left_square_bracketskiplocalsinitright)）。
- en: What’s New in C# 8.0
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 8.0的新功能
- en: C# 8.0 first shipped with *Visual Studio 2019*, and is still used today when
    you target .NET Core 3 or .NET Standard 2.1.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: C# 8.0首次与*Visual Studio 2019*一起发布，并在今天仍在使用，当你的目标是.NET Core 3或.NET Standard 2.1时。
- en: Indices and ranges
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引和范围
- en: '*Indices and ranges* simplify working with elements or portions of an array
    (or the low-level types `Span<T>` and `ReadOnlySpan<T>`).'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '*索引和范围*简化了与数组的元素或部分（或底层类型`Span<T>`和`ReadOnlySpan<T>`）的工作。'
- en: 'Indices let you refer to elements relative to the *end* of an array by using
    the `^` operator. `^1` refers to the last element, `^2` refers to the second-to-last
    element, and so on:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 索引允许你通过使用`^`运算符相对于数组的*末尾*引用元素。`^1`指的是最后一个元素，`^2`指的是倒数第二个元素，依此类推：
- en: '[PRE48]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Ranges let you “slice” an array by using the `..` operator:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 范围允许你使用`..`运算符“切片”数组：
- en: '[PRE49]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'C# implements indexes and ranges with the help of the `Index` and `Range` types:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: C#通过`Index`和`Range`类型实现索引和范围：
- en: '[PRE50]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You can support indices and ranges in your own classes by defining an indexer
    with a parameter type of `Index` or `Range`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过定义带有`Index`或`Range`参数类型的索引器来支持你自己的类：
- en: '[PRE51]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: For more information, see [“Indices and Ranges”](ch02.html#indices_and_ranges-id00073).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请参见[“索引和范围”](ch02.html#indices_and_ranges-id00073)。
- en: Null-coalescing assignment
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空值合并赋值
- en: The `??=` operator assigns a variable only if it’s null. Instead of
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`??=`运算符仅在变量为null时才分配变量。而不是'
- en: '[PRE52]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'you can now write this:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以这样写：
- en: '[PRE53]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Using declarations
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用声明
- en: 'If you omit the brackets and statement block following a `using` statement,
    it becomes a *using declaration*. The resource is then disposed when execution
    falls outside the *enclosing* statement block:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略`using`语句后的括号和语句块，则成为*using声明*。当执行超出*封闭*语句块时，资源将被释放：
- en: '[PRE54]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In this case, `reader` will be disposed when execution falls outside the `if`
    statement block.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当执行超出`if`语句块时，`reader`将被释放。
- en: Read-only members
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 只读成员
- en: 'C# 8 lets you apply the `readonly` modifier to a struct’s *functions*, ensuring
    that if the function attempts to modify any field, a compile-time error is generated:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: C# 8 允许你对结构体的*函数*应用`readonly`修饰符，确保如果函数试图修改任何字段，则会生成编译时错误：
- en: '[PRE55]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If a `readonly` function calls a non-`readonly` function, the compiler generates
    a warning (and defensively copies the struct to avoid the possibility of a mutation).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `readonly` 函数调用非 `readonly` 函数，则编译器会生成警告（并防御性地复制结构体以避免可能的突变）。
- en: Static local methods
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态局部方法
- en: Adding the `static` modifier to a local method prevents it from seeing the local
    variables and parameters of the enclosing method. This helps to reduce coupling
    and enables the local method to declare variables as it pleases, without risk
    of colliding with those in the containing method.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `static` 修饰符添加到局部方法可以防止其访问封闭方法的局部变量和参数。这有助于减少耦合，并使局部方法能够随意声明变量，而无需担心与包含方法中的变量冲突。
- en: Default interface members
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认接口成员
- en: 'C# 8 lets you add a default implementation to an interface member, making it
    optional to implement:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 8 中，您可以为接口成员添加默认实现，从而使得实现变为可选：
- en: '[PRE56]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This means that you can add a member to an interface without breaking implementations.
    Default implementations must be called explicitly through the interface:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您可以向接口添加成员而不会破坏现有实现。必须显式通过接口调用默认实现：
- en: '[PRE57]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Interfaces can also define static members (including fields), which can be
    accessed from code inside default implementations:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 接口还可以定义静态成员（包括字段），可以从默认实现内部的代码中访问：
- en: '[PRE58]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Or from outside the interface unless restricted via an accessibility modifier
    on the static interface member (such as `private`, `protected`, or `internal`):'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 或者从接口外部，除非在静态接口成员上通过可访问性修饰符（如 `private`、`protected` 或 `internal`）进行限制：
- en: '[PRE59]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Instance fields are prohibited. For more details, see [“Default Interface Members”](ch03.html#default_interface_members-id00061).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 实例字段是被禁止的。更多细节，请参见 [“默认接口成员”](ch03.html#default_interface_members-id00061)。
- en: Switch expressions
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Switch 表达式
- en: 'From C# 8, you can use `switch` in the context of an *expression*:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 自 C# 8 开始，您可以在 *表达式* 上下文中使用 `switch`：
- en: '[PRE60]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: For more examples, see [“Switch expressions”](ch02.html#switch_expressions-id00093).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 更多示例，请参见 [“Switch 表达式”](ch02.html#switch_expressions-id00093)。
- en: Tuple, positional, and property patterns
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组、位置和属性模式
- en: 'C# 8 supports three new patterns, mostly for the benefit of switch statements/expressions
    (see [“Patterns”](ch04.html#patterns)). *Tuple patterns* let you switch on multiple
    values:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: C# 8 支持三种新模式，主要用于增强 `switch` 语句/表达式的功能（请参见 [“模式”](ch04.html#patterns)）。*元组模式*
    允许您在多个值上进行 `switch`：
- en: '[PRE61]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '*Positional patterns* allow a similar syntax for objects that expose a deconstructor,
    and *property patterns* let you match on an object’s properties. You can use all
    of the patterns both in switches and with the `is` operator. The following example
    uses a *property pattern* to test whether `obj` is a string with a length of 4:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '*位置模式* 允许为公开解构器的对象使用类似的语法，*属性模式* 允许您匹配对象的属性。您可以在 `switch` 和 `is` 运算符中同时使用所有模式。以下示例使用
    *属性模式* 来测试 `obj` 是否为具有长度为 4 的字符串：'
- en: '[PRE62]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Nullable reference types
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可空引用类型
- en: Whereas *nullable value types* bring nullability to value types, *nullable reference
    types* do the opposite and bring (a degree of) *non-nullability* to reference
    types, with the purpose of helping to avoid `NullReferenceException`s. Nullable
    reference types introduce a level of safety that’s enforced purely by the compiler
    in the form of warnings or errors when it detects code that’s at risk of generating
    a `NullReferenceException`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 而 *可空值类型* 将 nullability 带给值类型，*可空引用类型* 则相反，并为引用类型带来（某种程度的）*非空值性*，旨在帮助避免 `NullReferenceException`。可空引用类型通过编译器纯粹形式的警告或错误引入了一定的安全级别，用于检测代码是否有可能生成
    `NullReferenceException`。
- en: 'Nullable reference types can be enabled either at the project level (via the
    `Nullable` element in the *.csproj* project file) or in code (via the `#nullable`
    directive). After it’s enabled, the compiler makes non-nullability the default:
    if you want a reference type to accept nulls, you must apply the `?` suffix to
    indicate a *nullable reference type*:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 可空引用类型可以在项目级别启用（通过 *.csproj* 项目文件中的 `Nullable` 元素）或在代码中启用（通过 `#nullable` 指令）。启用后，编译器将非空值性设置为默认值：如果要使引用类型接受
    null 值，必须应用 `?` 后缀以指示 *可空引用类型*：
- en: '[PRE63]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Uninitialized fields also generate a warning (if the type is not marked as
    nullable), as does dereferencing a nullable reference type, if the compiler thinks
    a `NullReferenceException` might occur:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型未标记为可为空，未初始化的字段会生成警告，还有可能发生 `NullReferenceException` 的可空引用类型解引用也会如此：
- en: '[PRE64]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'To remove the warning, you can use the *null-forgiving operator* (`!`):'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 要消除警告，您可以使用 *null-forgiving operator* (`!`)：
- en: '[PRE65]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: For a full discussion, see [“Nullable Reference Types”](ch04.html#nullable_reference_types-id00081).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 有关全面讨论，请参见[“可为空引用类型”](ch04.html#nullable_reference_types-id00081)。
- en: Asynchronous streams
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步流
- en: 'Prior to C# 8, you could use `yield return` to write an *iterator*, or `await`
    to write an *asynchronous function*. But you couldn’t do both and write an iterator
    that awaits, yielding elements asynchronously. C# 8 fixes this through the introduction
    of *asynchronous streams*:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的C# 8中，你可以使用`yield return`来编写*迭代器*，或者使用`await`来编写*异步函数*。但不能既编写迭代器又编写等待的异步函数。C#
    8通过引入*异步流*来解决这个问题：
- en: '[PRE66]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `await foreach` statement consumes an asynchronous stream:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`await foreach`语句消耗一个异步流：'
- en: '[PRE67]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: For more information, see [“Asynchronous Streams”](ch14.html#asynchronous_stream).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参见[“异步流”](ch14.html#asynchronous_stream)。
- en: What’s New in C# 7.x
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 7.x 新功能概述
- en: C# 7.x was first shipped with Visual Studio 2017\. C# 7.3 is still used today
    by Visual Studio 2019 when you target .NET Core 2, .NET Framework 4.6 to 4.8,
    or .NET Standard 2.0.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.x首次发布时可以在Visual Studio 2017中使用。C# 7.3仍然被Visual Studio 2019使用，当您针对.NET Core
    2、.NET Framework 4.6到4.8或.NET Standard 2.0进行定位时。
- en: C# 7.3
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 7.3
- en: 'C# 7.3 made minor improvements to existing features, such as enabling the use
    of the equality operators with tuples, improved overload resolution, and the ability
    to apply attributes to the backing fields of automatic properties:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.3对现有功能进行了微小的改进，例如使得可以在元组上使用等值运算符，改进的重载解析以及能够将属性应用于自动属性的支持：
- en: '[PRE68]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'C# 7.3 also built on C# 7.2’s advanced low-allocation programming features,
    with the ability to reassign *ref locals*, no requirement to pin when indexing
    `fixed` fields, and field initializer support with `stackalloc`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.3 还基于C# 7.2的高级低分配编程特性，具备重新分配*引用局部变量*的能力，不需要在索引`fixed`字段时固定内存，以及使用`stackalloc`支持字段初始化：
- en: '[PRE69]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Notice that stack-allocated memory can be assigned directly to a `Span<T>`.
    We describe spans—and why you would use them—in [Chapter 23](ch23.html#spanless_thantgreater_than_and-id00089).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，栈分配的内存可以直接分配给一个`Span<T>`。我们在[第23章](ch23.html#spanless_thantgreater_than_and-id00089)中描述了Span及其用途。
- en: C# 7.2
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 7.2
- en: 'C# 7.2 added a new `private protected` modifier (the *intersection* of `internal`
    and `protected`), the ability to follow named arguments with positional ones when
    calling methods, and `readonly` structs. A `readonly` struct enforces that all
    fields are `readonly`, to aid in declaring intent and to allow the compiler more
    optimization freedom:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.2 增加了一个新的`private protected`修饰符（`internal`和`protected`的交集），以及在调用方法时跟随命名参数使用位置参数的能力，以及`readonly`结构。`readonly`结构强制所有字段为`readonly`，以帮助声明意图，并允许编译器更大的优化自由度：
- en: '[PRE70]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'C# 7.2 also added specialized features to help with micro-optimization and
    low-allocation programming: see [“The in modifier”](ch02.html#the_in_modifier),
    [“Ref Locals”](ch02.html#ref_locals), [“Ref Returns”](ch02.html#ref_returns),
    and [“Ref Structs”](ch03.html#ref_structs).'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.2 还增加了专门的功能，以帮助进行微优化和低分配编程：请参见[“in修饰符”](ch02.html#the_in_modifier)、[“引用局部变量”](ch02.html#ref_locals)、[“引用返回”](ch02.html#ref_returns)和[“引用结构”](ch03.html#ref_structs)。
- en: C# 7.1
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 7.1
- en: 'From C# 7.1, you can omit the type when using the `default` keyword, if the
    type can be inferred:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 7.1开始，当使用`default`关键字时，如果类型可以被推断，你可以省略类型：
- en: '[PRE71]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'C# 7.1 also relaxed the rules for switch statements (so that you can pattern-match
    on generic type parameters), allowed a program’s `Main` method to be asynchronous,
    and allowed tuple element names to be inferred:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.1 还放宽了switch语句的规则（使得你可以在泛型类型参数上模式匹配），允许程序的`Main`方法是异步的，并允许推断元组元素的名称：
- en: '[PRE72]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Numeric literal improvements
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数字文字改进
- en: 'Numeric literals in C# 7 can include underscores to improve readability. These
    are called *digit separators* and are ignored by the compiler:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7中的数字文字可以包括下划线，以提高可读性。这些被称为*数字分隔符*，在编译器中会被忽略：
- en: '[PRE73]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '*Binary literals* can be specified with the `0b` prefix:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '*二进制文字*可以使用`0b`前缀指定：'
- en: '[PRE74]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Out variables and discards
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 出参变量和丢弃
- en: 'C# 7 makes it easier to call methods that contain `out` parameters. First,
    you can now declare *out variables* on the fly (see [“Out variables and discards”](ch02.html#out_variables_and_discards-id00083)):'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7使得调用包含`out`参数的方法变得更简单。首先，你现在可以在不声明*out变量的情况下快速创建*out变量（请参见[“out变量和丢弃”](ch02.html#out_variables_and_discards-id00083)）：
- en: '[PRE75]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'And when calling a method with multiple `out` parameters, you can *discard*
    ones you’re uninterested in with the underscore character:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用具有多个`out`参数的方法时，你可以用下划线字符丢弃不感兴趣的参数：
- en: '[PRE76]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Type patterns and pattern variables
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型模式和模式变量
- en: 'You can also introduce variables on the fly with the `is` operator. These are
    called *pattern variables* (see [“Introducing a pattern variable”](ch03.html#introducing_a_pattern_variable)):'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`is`运算符即时引入变量。这些称为*模式变量*（参见[“引入模式变量”](ch03.html#introducing_a_pattern_variable)）：
- en: '[PRE77]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The `switch` statement also supports type patterns, so you can switch on *type*
    as well as constants (see [“Switching on types”](ch02.html#switching_on_types)).
    You can specify conditions with a `when` clause and also switch on the `null`
    value:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句还支持类型模式，因此你可以根据*类型*以及常量进行切换（参见[“类型切换”](ch02.html#switching_on_types)）。你可以使用`when`子句指定条件，并在`null`值上进行切换：'
- en: '[PRE78]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Local methods
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 局部方法
- en: 'A *local method* is a method declared within another function (see [“Local
    methods”](ch03.html#local_methods-id00077)):'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '*局部方法*是在另一个函数内声明的方法（参见[“局部方法”](ch03.html#local_methods-id00077)）：'
- en: '[PRE79]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Local methods are visible only to the containing function and can capture local
    variables in the same way that lambda expressions do.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 局部方法仅对包含函数可见，并且可以像lambda表达式一样捕获局部变量。
- en: More expression-bodied members
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多的表达式主体成员
- en: 'C# 6 introduced the expression-bodied “fat-arrow” syntax for methods, read-only
    properties, operators, and indexers. C# 7 extends this to constructors, read/write
    properties, and finalizers:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: C# 6引入了方法、只读属性、运算符和索引器的表达式主体“胖箭头”语法。C# 7将其扩展到构造函数、读写属性和终结器：
- en: '[PRE80]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Deconstructors
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解构函数
- en: 'C# 7 introduces the *deconstructor* pattern (see [“Deconstructors”](ch03.html#deconstructors-id00060)).
    Whereas a constructor typically takes a set of values (as parameters) and assigns
    them to fields, a *deconstructor* does the reverse and assigns fields back to
    a set of variables. We could write a deconstructor for the `Person` class in the
    preceding example as follows (exception handling aside):'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7引入了*解构*模式（参见[“解构函数”](ch03.html#deconstructors-id00060)）。构造函数通常接受一组值（作为参数）并将它们分配给字段，而*解构*则相反，将字段分配回一组变量。我们可以为前面示例中的`Person`类编写如下的解构函数（除了异常处理）：
- en: '[PRE81]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Deconstructors are called with the following special syntax:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 解构函数使用以下特殊语法调用：
- en: '[PRE82]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Tuples
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组
- en: 'Perhaps the most notable improvement to C# 7 is explicit *tuple* support (see
    [“Tuples”](ch04.html#tuples-id00099)). Tuples provide a simple way to store a
    set of related values:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是C# 7最显著的改进是对显式*tuple*支持（参见[“元组”](ch04.html#tuples-id00099)）。元组提供了一种简单的方式来存储一组相关的值：
- en: '[PRE83]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'C#’s new tuples are syntactic sugar for using the `System.ValueTuple<…>` generic
    structs. But thanks to compiler magic, tuple elements can be named:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: C#的新元组是使用`System.ValueTuple<…>`泛型结构的语法糖。但由于编译器的魔法，元组元素可以被命名：
- en: '[PRE84]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'With tuples, functions can return multiple values without resorting to `out`
    parameters or extra type baggage:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 使用元组，函数可以返回多个值，而无需使用`out`参数或额外的类型包装：
- en: '[PRE85]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Tuples implicitly support the deconstruction pattern, so you can easily *deconstruct*
    them into individual variables:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 元组隐式支持解构模式，因此你可以轻松地将它们*解构*为单独的变量：
- en: '[PRE86]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: throw expressions
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: throw表达式
- en: 'Prior to C# 7, `throw` was always a statement. Now it can also appear as an
    expression in expression-bodied functions:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 7之前，`throw`始终是一个语句。现在它也可以出现在表达式主体的函数中作为一个表达式：
- en: '[PRE87]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'A `throw` expression can also appear in a ternary conditional expression:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`throw`表达式也可以出现在三元条件表达式中：'
- en: '[PRE88]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: What’s New in C# 6.0
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 6.0新特性
- en: C# 6.0, which shipped with *Visual Studio 2015*, features a new-generation compiler,
    completely written in C#. Known as project “Roslyn,” the new compiler exposes
    the entire compilation pipeline via libraries, allowing you to perform code analysis
    on arbitrary source code. The compiler itself is open source, and the source code
    is available at [*https://github.com/dotnet/roslyn*](https://github.com/dotnet/roslyn).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: C# 6.0随*Visual Studio 2015*一同发布，具有新一代完全用C#编写的编译器。被称为项目“Roslyn”的新编译器通过库公开了整个编译流水线，允许您对任意源代码执行代码分析。编译器本身是开源的，源代码位于[*https://github.com/dotnet/roslyn*](https://github.com/dotnet/roslyn)。
- en: In addition, C# 6.0 features several minor but significant enhancements, aimed
    primarily at reducing code clutter.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，C# 6.0还引入了几个次要但重要的增强功能，主要旨在减少代码混乱。
- en: 'The *null-conditional* (“Elvis”) operator (see [“Null Operators”](ch02.html#null_operators))
    avoids having to explicitly check for null before calling a method or accessing
    a type member. In the following example, `result` evaluates to null instead of
    throwing a `NullReferenceException`:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '*空值条件* (“Elvis”) 运算符 (见 [“空值运算符”](ch02.html#null_operators)) 避免在调用方法或访问类型成员之前显式检查
    null。在下面的例子中，`result` 评估为 null 而不是抛出 `NullReferenceException`：'
- en: '[PRE89]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '*Expression-bodied functions* (see [“Methods”](ch03.html#methods)) allow methods,
    properties, operators, and indexers that comprise a single expression to be written
    more tersely, in the style of a lambda expression:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '*表达式体函数* (见 [“方法”](ch03.html#methods)) 允许将由单个表达式组成的方法、属性、运算符和索引器以更简洁的方式编写，类似于
    lambda 表达式的风格：'
- en: '[PRE90]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '*Property initializers* ([Chapter 3](ch03.html#creating_types_in_chash)) let
    you assign an initial value to an automatic property:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '*属性初始化器* ([第3章](ch03.html#creating_types_in_chash)) 允许您为自动属性分配初始值：'
- en: '[PRE91]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Initialized properties can also be read-only:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化属性也可以是只读的：
- en: '[PRE92]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Read-only properties can also be set in the constructor, making it easier to
    create immutable (read-only) types.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 只读属性也可以在构造函数中设置，这样更容易创建不可变（只读）类型。
- en: '*Index initializers* ([Chapter 4](ch04.html#advanced_chash)) allow single-step
    initialization of any type that exposes an indexer:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '*索引初始化器* ([第4章](ch04.html#advanced_chash)) 允许对任何公开索引器的类型进行单步初始化：'
- en: '[PRE93]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '*String interpolation* (see [“String Type”](ch02.html#string_type)) offers
    a succinct alternative to `string.Format`:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串插值* (见 [“字符串类型”](ch02.html#string_type)) 提供了 `string.Format` 的简洁替代方法：'
- en: '[PRE94]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '*Exception filters* (see [“try Statements and Exceptions”](ch04.html#try_statements_and_exceptions))
    let you apply a condition to a catch block:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '*异常过滤器* (见 [“try 语句和异常”](ch04.html#try_statements_and_exceptions)) 允许您对 catch
    块应用条件：'
- en: '[PRE95]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The `using static` (see [“Namespaces”](ch02.html#namespaces-id00029)) directive
    lets you import all the static members of a type so that you can use those members
    unqualified:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`using static` (见 [“命名空间”](ch02.html#namespaces-id00029)) 指令允许您导入类型的所有静态成员，以便可以不加限定地使用这些成员：'
- en: '[PRE96]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The `nameof` ([Chapter 3](ch03.html#creating_types_in_chash)) operator returns
    the name of a variable, type, or other symbol as a string. This avoids breaking
    code when you rename a symbol in Visual Studio:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`nameof` ([第3章](ch03.html#creating_types_in_chash)) 运算符返回变量、类型或其他符号的名称作为字符串。这样可以避免在
    Visual Studio 中重命名符号时破坏代码：'
- en: '[PRE97]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: And finally, you’re now allowed to `await` inside `catch` and `finally` blocks.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您现在可以在 `catch` 和 `finally` 块内部使用 `await`。
- en: What’s New in C# 5.0
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 5.0 新特性
- en: C# 5.0’s big new feature was support for *asynchronous functions* via two new
    keywords, `async` and `await`. Asynchronous functions enable *asynchronous continuations*,
    which make it easier to write responsive and thread-safe rich-client applications.
    They also make it easy to write highly concurrent and efficient I/O-bound applications
    that don’t tie up a thread resource per operation. We cover asynchronous functions
    in detail in [Chapter 14](ch14.html#concurrency_and_asynchron).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: C# 5.0 的主要新功能是通过两个新关键字 `async` 和 `await` 支持 *异步函数*。异步函数使 *异步继续* 更容易编写响应式和线程安全的富客户端应用程序。它们还使编写高并发和高效的
    I/O 绑定应用程序变得轻松，而不会占用每个操作的线程资源。我们在 [第14章](ch14.html#concurrency_and_asynchron)
    中详细介绍了异步函数。
- en: What’s New in C# 4.0
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 4.0 新特性
- en: 'C# 4.0 introduced four major enhancements:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: C# 4.0 引入了四个重大改进：
- en: '*Dynamic binding* (Chapters [4](ch04.html#advanced_chash) and [19](ch19.html#dynamic_programming))
    defers *binding*—the process of resolving types and members—from compile time
    to runtime and is useful in scenarios that would otherwise require complicated
    reflection code. Dynamic binding is also useful when interoperating with dynamic
    languages and COM components.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '*动态绑定* (第 [4](ch04.html#advanced_chash) 和 [19](ch19.html#dynamic_programming)
    章节) 将 *绑定* —— 解析类型和成员的过程 —— 从编译时延迟到运行时，并且在需要复杂反射代码的场景下非常有用。动态绑定在与动态语言和 COM 组件互操作时也非常有用。'
- en: '*Optional parameters* ([Chapter 2](ch02.html#chash_language_basics)) allow
    functions to specify default parameter values so that callers can omit arguments,
    and *named arguments* allow a function caller to identify an argument by name
    rather than position.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '*可选参数* ([第2章](ch02.html#chash_language_basics)) 允许函数指定默认参数值，以便调用者可以省略参数，并且
    *命名参数* 允许函数调用者通过名称而非位置标识参数。'
- en: '*Type variance* rules were relaxed in C# 4.0 (Chapters [3](ch03.html#creating_types_in_chash)
    and [4](ch04.html#advanced_chash)), such that type parameters in generic interfaces
    and generic delegates can be marked as *covariant* or *contravariant*, allowing
    more natural type conversions.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 4.0 中放宽了*类型变异*规则（第[3](ch03.html#creating_types_in_chash)和[4](ch04.html#advanced_chash)章），使得泛型接口和泛型委托中的类型参数可以标记为*协变*或*逆变*，从而允许更自然的类型转换。
- en: '*COM interoperability* ([Chapter 24](ch24.html#native_and_com_interoperabilit))
    was enhanced in C# 4.0 in three ways. First, arguments can be passed by reference
    without the `ref` keyword (particularly useful in conjunction with optional parameters).
    Second, assemblies that contain COM interop types can be *linked* rather than
    *referenced*. Linked interop types support type equivalence, avoiding the need
    for *Primary Interop Assemblies* and putting an end to versioning and deployment
    headaches. Third, functions that return COM Variant types from linked interop
    types are mapped to `dynamic` rather than `object`, eliminating the need for casting.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '*COM 互操作性*（[第 24 章](ch24.html#native_and_com_interoperabilit)）在 C# 4.0 中通过三种方式进行了增强。首先，参数可以在不使用
    `ref` 关键字的情况下按引用传递（特别在与可选参数结合时非常有用）。其次，包含 COM 互操作类型的程序集可以进行*链接*而不是*引用*。链接的互操作类型支持类型等价性，避免了对*主互操作程序集*的需求，从而消除了版本控制和部署问题的头痛。第三，从链接的互操作类型返回
    COM 变体类型的函数被映射为 `dynamic` 而不是 `object`，消除了类型转换的需求。'
- en: What’s New in C# 3.0
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 3.0 中的新特性
- en: The features added to C# 3.0 were mostly centered on *Language-Integrated Query*
    (LINQ) capabilities. LINQ enables queries to be written directly within a C# program
    and checked *statically* for correctness, and query both local collections (such
    as lists or XML documents) or remote data sources (such as a database). The C#
    3.0 features added to support LINQ comprised implicitly typed local variables,
    anonymous types, object initializers, lambda expressions, extension methods, query
    expressions, and expression trees.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到 C# 3.0 的特性主要集中在*语言集成查询*（LINQ）功能上。LINQ 允许直接在 C# 程序中编写查询，并在*静态*上下文中检查其正确性，可以查询本地集合（如列表或
    XML 文档）或远程数据源（如数据库）。支持 LINQ 的 C# 3.0 特性包括隐式类型本地变量、匿名类型、对象初始化程序、Lambda 表达式、扩展方法、查询表达式和表达式树。
- en: '*Implicitly typed local variables* (`var` keyword, [Chapter 2](ch02.html#chash_language_basics))
    let you omit the variable type in a declaration statement, allowing the compiler
    to infer it. This reduces clutter as well as allowing *anonymous types* ([Chapter 4](ch04.html#advanced_chash)),
    which are simple classes created on the fly that are commonly used in the final
    output of LINQ queries. You can also implicitly type arrays ([Chapter 2](ch02.html#chash_language_basics)).'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '*隐式类型本地变量*（`var` 关键字，[第 2 章](ch02.html#chash_language_basics)）允许您在声明语句中省略变量类型，让编译器推断类型。这不仅减少了冗余，还允许*匿名类型*（[第
    4 章](ch04.html#advanced_chash)），这是在最终 LINQ 查询输出中常用的简单类。您还可以隐式类型化数组（[第 2 章](ch02.html#chash_language_basics)）。'
- en: '*Object initializers* ([Chapter 3](ch03.html#creating_types_in_chash)) simplify
    object construction by allowing you to set properties inline after the constructor
    call. Object initializers work with both named and anonymous types.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象初始化程序*（[第 3 章](ch03.html#creating_types_in_chash)）通过允许您在构造函数调用后内联设置属性来简化对象构建。对象初始化程序适用于命名类型和匿名类型。'
- en: '*Lambda expressions* ([Chapter 4](ch04.html#advanced_chash)) are miniature
    functions created by the compiler on the fly; they are particularly useful in
    “fluent” LINQ queries ([Chapter 8](ch08.html#linq_queries)).'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lambda 表达式*（[第 4 章](ch04.html#advanced_chash)）是编译器即时创建的迷你函数；它们在“流畅”的 LINQ
    查询中尤其有用（[第 8 章](ch08.html#linq_queries)）。'
- en: '*Extension methods* ([Chapter 4](ch04.html#advanced_chash)) extend an existing
    type with new methods (without altering the type’s definition), making static
    methods feel like instance methods. LINQ’s query operators are implemented as
    extension methods.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '*扩展方法*（[第 4 章](ch04.html#advanced_chash)）通过向现有类型添加新方法（而不更改类型的定义）来扩展类型，使静态方法感觉像实例方法。LINQ
    的查询操作符就是以扩展方法实现的。'
- en: '*Query expressions* ([Chapter 8](ch08.html#linq_queries)) provide a higher-level
    syntax for writing LINQ queries that can be substantially simpler when working
    with multiple sequences or range variables.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '*查询表达式*（[第 8 章](ch08.html#linq_queries)）提供了一种更高级的语法，用于编写 LINQ 查询，当处理多个序列或范围变量时可以大幅简化操作。'
- en: '*Expression trees* ([Chapter 8](ch08.html#linq_queries)) are miniature code
    Document Object Models (DOMs) that describe lambda expressions assigned to the
    special type `Expression<TDelegate>`. Expression trees make it possible for LINQ
    queries to execute remotely (e.g., on a database server) because they can be introspected
    and translated at runtime (e.g., into an SQL statement).'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '*表达式树*（[第8章](ch08.html#linq_queries)）是描述分配给特殊类型`Expression<TDelegate>`的lambda表达式的迷你代码文档对象模型（DOM）。表达式树使得LINQ查询可以在远程执行（例如在数据库服务器上），因为它们可以在运行时进行内省和翻译（例如转换成SQL语句）。'
- en: C# 3.0 also added automatic properties and partial methods.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: C# 3.0 还添加了自动属性和部分方法。
- en: '*Automatic properties* ([Chapter 3](ch03.html#creating_types_in_chash)) cut
    the work in writing properties that simply `get`/`set` a private backing field
    by having the compiler do that work automatically. *Partial methods* ([Chapter 3](ch03.html#creating_types_in_chash))
    let an autogenerated partial class provide customizable hooks for manual authoring
    that “melt away” if unused.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '*自动属性*（[第3章](ch03.html#creating_types_in_chash)）减少了编写仅`get`/`set`私有后备字段的属性所需的工作量，编译器会自动完成这些工作。*部分方法*（[第3章](ch03.html#creating_types_in_chash)）允许自动生成的部分类为手动编写提供可定制的钩子，如果未使用则会自动“消失”。'
- en: What’s New in C# 2.0
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 2.0 的新特性
- en: The big new features in C# 2 were generics ([Chapter 3](ch03.html#creating_types_in_chash)),
    nullable value types ([Chapter 4](ch04.html#advanced_chash)), iterators ([Chapter 4](ch04.html#advanced_chash)),
    and anonymous methods (the predecessor to lambda expressions). These features
    paved the way for the introduction of LINQ in C# 3.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: C# 2 中的重要新功能包括泛型（[第3章](ch03.html#creating_types_in_chash)）、可空值类型（[第4章](ch04.html#advanced_chash)）、迭代器（[第4章](ch04.html#advanced_chash)）和匿名方法（lambda表达式的前身）。这些功能为C#
    3中LINQ的引入铺平了道路。
- en: C# 2 also added support for partial classes, static classes, and a host of minor
    and miscellaneous features such as the namespace alias qualifier, friend assemblies,
    and fixed-size buffers.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: C# 2 还增加了对部分类、静态类以及一系列较小和杂项功能的支持，如命名空间别名限定符、友元程序集和固定大小缓冲区。
- en: The introduction of generics required a new CLR (CLR 2.0), because generics
    maintain full type fidelity at runtime.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型的引入要求一个新的CLR（CLR 2.0），因为泛型在运行时保持完整的类型保真度。
