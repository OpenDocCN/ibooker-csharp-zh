<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xml:lang="en"
      lang="en"
      xmlns="http://www.w3.org/1999/xhtml"
      xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>Functional Programming with C#</title>
<link rel="stylesheet" type="text/css" href="override_v1.css"/>
<link rel="stylesheet" type="text/css" href="epub.css"/>
</head>
<body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. Currying and Partial Application"><div class="chapter" id="chapter8_beginning">
<h1><span class="label">Chapter 8. </span>Currying and Partial Application</h1>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45400852784960">
<h1>A Note for Early Release Readers</h1>
<p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p>

<p>This will be the eighth chapter of the final book. Please note that the GitHub repo will be made active later on.</p>

<p>If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the editor at <a href="mailto:jleonard@oreilly.com">jleonard@oreilly.com</a>.</p>
</div></aside>

<p>Currying and Partial Application are two more functional concepts that come straight out of old maths papers.  The former has absolutely nothing to do with Indian food, delicious though it is<sup><a data-type="noteref" id="idm45400852781472-marker" href="ch08.html#idm45400852781472">1</a></sup> in fact it’s named after the pre-eminent American mathematician Haskell Brooks Curry, after whom no fewer than three programming languages are named<sup><a data-type="noteref" id="idm45400852780672-marker" href="ch08.html#idm45400852780672">2</a></sup>.</p>

<p>Currying came from Haskell Curry’s work on combinatory logic, which served as one of the bases for modern functional programming.  Rather than give a dry formal definition, I’ll explain by example.  This is a bit of vaguely C#-like pseudocode for an add function:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">interface</code> <code class="n">ICurriedFunctions</code>
<code class="p">{</code>
 <code class="kt">decimal</code> <code class="nf">Add</code><code class="p">(</code><code class="kt">decimal</code> <code class="n">a</code><code class="p">,</code> <code class="kt">decimal</code> <code class="n">b</code><code class="p">);</code>
<code class="p">}</code>

<code class="kt">var</code> <code class="n">curry</code> <code class="p">=</code> <code class="c1">// some logic for obtaining an implementation of the interface</code>

<code class="kt">var</code> <code class="n">answer</code> <code class="p">=</code> <code class="n">curry</code><code class="p">.</code><code class="n">Add</code><code class="p">(</code><code class="m">100</code><code class="p">,</code> <code class="m">200</code><code class="p">);</code></pre>

<p>In this example, we’d expect answer to simply be 300 (i.e. 100+200), which is indeed what it would be.</p>

<p>What if I were only to provide a single parameter, however?  Like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">interface</code> <code class="n">ICurriedFunctions</code>
<code class="p">{</code>
 <code class="kt">decimal</code> <code class="nf">Add</code><code class="p">(</code><code class="kt">decimal</code> <code class="n">a</code><code class="p">,</code> <code class="kt">decimal</code> <code class="n">b</code><code class="p">);</code>
<code class="p">}</code>

<code class="kt">var</code> <code class="n">curry</code> <code class="p">=</code> <code class="c1">// some logic for obtaining an implementation of the interface</code>

<code class="kt">var</code> <code class="n">answer</code> <code class="p">=</code> <code class="n">curry</code><code class="p">.</code><code class="n">Add</code><code class="p">(</code><code class="m">100</code><code class="p">);</code> <code class="c1">// What could it be?</code></pre>

<p>In this scenario, if this were a hypothetical curried function, what do you think you’d have returned to you in <em>answer</em>?</p>

<p>There’s a rule of thumb I’ve devised when working in functional programming - if there’s a question, the answer is likely to be “functions”.  Which is the case here.</p>

<p>If this were a curried function, then the the <em>answer</em> variable would be a  function.  It would be a modified version of the original <code>Add</code> function, but with the first parameter now set in stone as the value 100 - effectively making it a new function, one that adds 100 to whatever you provide.</p>

<p>You might use it like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">interface</code> <code class="n">ICurriedFunctions</code>
<code class="p">{</code>
 <code class="kt">decimal</code> <code class="nf">Add</code><code class="p">(</code><code class="kt">decimal</code> <code class="n">a</code><code class="p">,</code> <code class="kt">decimal</code> <code class="n">b</code><code class="p">);</code>
<code class="p">}</code>

<code class="kt">var</code> <code class="n">curry</code> <code class="p">=</code> <code class="c1">// some logic for obtaining an implementation of the interface</code>

<code class="kt">var</code> <code class="n">add100</code> <code class="p">=</code> <code class="n">curry</code><code class="p">.</code><code class="n">Add</code><code class="p">(</code><code class="m">100</code><code class="p">);</code> <code class="c1">// Func&lt;decimal,decimal&gt;, adds 100 to the input</code>

<code class="kt">var</code> <code class="n">answerA</code> <code class="p">=</code> <code class="n">add100</code><code class="p">(</code><code class="m">200</code><code class="p">);</code> <code class="c1">// 300 -&gt; 200+100</code>
<code class="kt">var</code> <code class="n">answerB</code> <code class="p">=</code> <code class="n">add100</code><code class="p">(</code><code class="m">0</code><code class="p">);</code> <code class="c1">// 100 -&gt; 0+100</code>
<code class="kt">var</code> <code class="n">answerC</code> <code class="p">=</code> <code class="n">add100</code><code class="p">(</code><code class="m">900</code><code class="p">);</code> <code class="c1">// 1000 -&gt; 900+100</code></pre>

<p>It’s basically a way to start with a function that has a number of parameters, and from it, create mutiple, more specific versions of that function.  One single base function can become many different functions.  You <em>could</em> compare it to the OO concept of inheritance, if you like?  In reality it’s <em>nothing</em> at all like inheritance.  There is only actually a single function with any logic behind it - the rest are effectively pointers to that base function holding parameters, ready to feed into it.</p>

<p>What exactly is the point of currying, though?  How do you use it?</p>

<p>Let me explain…​</p>






<section data-type="sect1" data-pdf-bookmark="Currying and large functions"><div class="sect1" id="idm45400852568464">
<h1>Currying and large functions</h1>

<p>In the “Add” example I gave above, we’ve only got a single pair of parameters, and so there are only two possibilities for what we could possibly do with them when Currying is possible:</p>
<ol>
<li>
<p>Supply the first parameter, get back a function</p>
</li>
<li>
<p>Supply both parameters and get back a value</p>
</li>

</ol>

<p>How would currying handle a function with greater than 2 base parameters?  For this I’ll use an example of a simple CSV parser - i.e. something that takes a CSV text file, breaks it into records by line, then uses some delimeter (typically a comma) to break it up again into individual properties within the record.</p>

<p>Let’s imagine I’d written a parser function to load in a batch of book data:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="c1">// Input in the format:</code>
<code class="c1">//</code>
<code class="c1">//title,author,publicationDate</code>
<code class="c1">//The Hitch-Hiker's Guide to the Galaxy,Douglas Adams,1979</code>
<code class="c1">//Dimension of Miracles,Robert Sheckley,1968</code>
<code class="c1">//The Stainless Steel Rat,Harry Harrison,1957</code>
<code class="c1">//The Unorthodox Engineers,Colin Kapp,1979</code>

<code class="k">public</code> <code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">Book</code><code class="p">&gt;</code> <code class="n">ParseBooks</code><code class="p">(</code><code class="kt">string</code> <code class="n">fileName</code><code class="p">)</code> <code class="p">=&gt;</code>
 <code class="n">File</code><code class="p">.</code><code class="n">ReadAllText</code><code class="p">(</code><code class="n">fileName</code><code class="p">)</code>
  <code class="p">.</code><code class="n">Split</code><code class="p">(</code><code class="s">"\r\n"</code><code class="p">)</code>
  <code class="p">.</code><code class="n">Skip</code><code class="p">(</code><code class="m">1</code><code class="p">)</code> <code class="c1">// Skip the header</code>
  <code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code><code class="p">.</code><code class="n">split</code><code class="p">(</code><code class="s">","</code><code class="p">).</code><code class="n">ToArray</code><code class="p">())</code>
  <code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="k">new</code> <code class="n">Book</code>
  <code class="p">{</code>
   <code class="n">Title</code> <code class="p">=</code> <code class="n">x</code><code class="p">[</code><code class="m">0</code><code class="p">],</code>
   <code class="n">Author</code> <code class="p">=</code> <code class="n">x</code><code class="p">[</code><code class="m">1</code><code class="p">],</code>
   <code class="n">PublicationDate</code> <code class="p">=</code> <code class="n">x</code><code class="p">[</code><code class="m">2</code><code class="p">]</code>
  <code class="p">});</code>

<code class="kt">var</code> <code class="n">bookData</code> <code class="p">=</code> <code class="n">parseBooks</code><code class="p">(</code><code class="s">"books.csv"</code><code class="p">);</code></pre>

<p>This is all well and good, except that the next two sets of books have different formats.  Books2.csv uses pipes instead of commas to separate fields, and Books3.csv comes from a Linux environment and has “\n” line endings instead of the Windows style “\r\n”.</p>

<p>We could get around this by creating 3 different functions that are near replicas of each other.  I’m not keen on unnecessary replication  though, since it adds too many problems for future developers that want to maintain the codebase.</p>

<p>A more reasonable solution is to add in parameters for everything that could possibly change.  Like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">Book</code><code class="p">&gt;</code> <code class="n">ParseBooks</code><code class="p">(</code>
 <code class="kt">string</code> <code class="n">lineBreak</code><code class="p">,</code>
 <code class="kt">bool</code> <code class="n">skipHeader</code><code class="p">,</code>
 <code class="kt">string</code> <code class="n">fieldDelimiter</code><code class="p">,</code>
 <code class="kt">string</code> <code class="n">fileName</code>
<code class="p">)</code> <code class="p">=&gt;</code>
 <code class="n">File</code><code class="p">.</code><code class="n">ReadAllText</code><code class="p">(</code><code class="n">fileName</code><code class="p">)</code>
  <code class="p">.</code><code class="n">Split</code><code class="p">(</code><code class="n">lineBreak</code><code class="p">)</code>
  <code class="p">.</code><code class="n">Skip</code><code class="p">(</code><code class="n">skipHeader</code> <code class="p">?</code> <code class="m">1</code> <code class="p">:</code> <code class="m">0</code><code class="p">)</code>
  <code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code><code class="p">.</code><code class="n">split</code><code class="p">(</code><code class="n">fieldDelimiter</code><code class="p">).</code><code class="n">ToArray</code><code class="p">())</code>
  <code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="k">new</code> <code class="n">Book</code>
  <code class="p">{</code>
   <code class="n">Title</code> <code class="p">=</code> <code class="n">x</code><code class="p">[</code><code class="m">0</code><code class="p">],</code>
   <code class="n">Author</code> <code class="p">=</code> <code class="n">x</code><code class="p">[</code><code class="m">1</code><code class="p">],</code>
   <code class="n">PublicationDate</code> <code class="p">=</code> <code class="n">x</code><code class="p">[</code><code class="m">2</code><code class="p">]</code>
  <code class="p">});</code>

<code class="kt">var</code> <code class="n">bookData</code> <code class="p">=</code> <code class="n">ParseBooks</code><code class="p">(</code><code class="n">Environment</code><code class="p">.</code><code class="n">NewLine</code><code class="p">,</code> <code class="k">true</code><code class="p">,</code> <code class="s">","</code><code class="p">,</code> <code class="s">"books.csv"</code><code class="p">);</code></pre>

<p>Now, If I wanted to follow the non-functional approach to the use of this function, I’d have to fill in every parameter every possible style of CSV file, like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="kt">var</code> <code class="n">bookData1</code> <code class="p">=</code> <code class="n">ParseBooks</code><code class="p">(</code><code class="n">Environment</code><code class="p">.</code><code class="n">NewLine</code><code class="p">,</code> <code class="k">true</code><code class="p">,</code>  <code class="s">","</code><code class="p">,</code> <code class="s">"books.csv"</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">bookData2</code> <code class="p">=</code> <code class="n">ParseBooks</code><code class="p">(</code><code class="n">Environment</code><code class="p">.</code><code class="n">NewLine</code><code class="p">,</code> <code class="k">true</code><code class="p">,</code> <code class="s">"|"</code><code class="p">,</code> <code class="s">"books2.csv"</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">bookData3</code> <code class="p">=</code> <code class="n">ParseBooks</code><code class="p">(</code><code class="s">"\n"</code><code class="p">,</code> <code class="k">false</code><code class="p">,</code> <code class="s">","</code><code class="p">,</code> <code class="s">"books3.csv"</code><code class="p">);</code></pre>

<p>What Currying actually means is to supply the parameters one at a time.  Any calls to a curried function results either in a new function with one fewer parameters, or else a concrete value if all parameters for the base function have been supplied.</p>

<p>The calls with the full set of supplied parameters, from the previous code sample, could be replaced like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="c1">// First some magic that curries the parseBooks function</code>
<code class="c1">// I'll look into implementation details later, let's just</code>
<code class="c1">// understand the theory for now.</code>

<code class="kt">var</code> <code class="n">curriedParseBooks</code> <code class="p">=</code> <code class="n">ParseBooks</code><code class="p">.</code><code class="n">Curry</code><code class="p">();</code>

<code class="c1">// these two have 3 parameters - string, string, string</code>
<code class="kt">var</code> <code class="n">parseSkipHeader</code> <code class="p">=</code> <code class="n">curriedParseBooks</code><code class="p">(</code><code class="k">true</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">parseNoHeader</code> <code class="p">=</code> <code class="n">curriedParseBooks</code><code class="p">(</code><code class="k">false</code><code class="p">);</code>

<code class="c1">// 2 parameters</code>
<code class="kt">var</code> <code class="n">parseSkipHeaderEnvNl</code> <code class="p">=</code> <code class="n">parseSkipHeader</code><code class="p">(</code><code class="n">Environment</code><code class="p">.</code><code class="n">NewLine</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">parseNoHeaderLinux</code> <code class="p">=</code> <code class="n">parseNoHeader</code><code class="p">(</code><code class="s">"\n"</code><code class="p">);</code>

<code class="c1">// 1 parameter each</code>
<code class="kt">var</code> <code class="n">parseSkipHeaderEnvNlCommarDel</code> <code class="p">=</code> <code class="n">parseSkipHeaderEnvNl</code><code class="p">(</code><code class="s">","</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">parseSkipHeaderEnvNlPipeDel</code> <code class="p">=</code> <code class="n">parseSkipHeaderEnvNl</code><code class="p">(</code><code class="s">"|"</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">parseNoHeaderLinuxCommarDel</code> <code class="p">=</code> <code class="n">parseNoHeaderLinux</code><code class="p">(</code><code class="s">","</code><code class="p">);</code>


<code class="c1">// Actual data, Enumerables of Book data</code>
<code class="kt">var</code> <code class="n">bookData1</code> <code class="p">=</code> <code class="n">parseSkipHeaderEnvNlCommarDel</code><code class="p">(</code><code class="s">"books.csv"</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">bookData2</code> <code class="p">=</code> <code class="n">parseSkipHeaderEnvNlPipeDel</code><code class="p">(</code><code class="s">"books2.csv"</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">bookData3</code> <code class="p">=</code> <code class="n">parseNoHeaderLinuxCommarDel</code><code class="p">(</code><code class="s">"books3.csv"</code><code class="p">);</code></pre>

<p>The point is that Currying turns a function with X parameters, into a sequence of X functions, each of which has a single parameter - the last one returning the final result.</p>

<p>You could even write the function calls above like this - if you really, really wanted to!:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="kt">var</code> <code class="n">bookData1</code> <code class="p">=</code> <code class="n">parseBooks</code><code class="p">(</code><code class="k">true</code><code class="p">)(</code><code class="n">Environment</code><code class="p">.</code><code class="n">NewLine</code><code class="p">)(</code><code class="s">","</code><code class="p">)(</code><code class="s">"books.csv"</code><code class="p">)</code>
<code class="kt">var</code> <code class="n">bookData2</code> <code class="p">=</code> <code class="n">parseBooks</code><code class="p">(</code><code class="k">true</code><code class="p">)(</code><code class="n">Environment</code><code class="p">.</code><code class="n">NewLine</code><code class="p">)(</code><code class="s">"|"</code><code class="p">)(</code><code class="s">"books2.csv"</code><code class="p">)</code>
<code class="kt">var</code> <code class="n">bookData3</code> <code class="p">=</code> <code class="n">parseBooks</code><code class="p">(</code><code class="k">true</code><code class="p">)(</code><code class="s">"\n"</code><code class="p">)(</code><code class="s">","</code><code class="p">)(</code><code class="s">"books3.csv"</code><code class="p">)</code></pre>

<p>The point of the first example of currying is that we’re gradually building up a hyper-specific version of the function that only takes a file name as a parameter.  In addition to that, we’re storing all of the intermediate versions for potential re-use in building up other functions.</p>

<p>What we’re effectively doing here is building up functions like a wall made of lego bricks, where each brick is a function.  Or, if you want to think about it another way, there’s a family tree of functions, with each choice made at each stage causing a branch in the family:</p>

<figure><div id="Chapter_8_function_family_tree_image" class="figure">
<img src="assets/ch08_001.png" alt="Images/ch08_001.png" width="641" height="421"/>
<h6><span class="label">Figure 8-1. </span>A The family tree of the parseBooks functions</h6>
</div></figure>

<p>Another example that might have uses in production is splitting up a logging function into multiple, more specific functions:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="c1">// For the sake of this exercise, the parameters are</code>
<code class="c1">// an enum (log type - warning, error, info, etc.) and a string</code>
<code class="c1">// containing a message to store in the log file</code>
<code class="kt">var</code> <code class="n">logger</code> <code class="p">=</code> <code class="n">getLoggerFunction</code><code class="p">()</code>
<code class="kt">var</code> <code class="n">curriedLogger</code> <code class="p">=</code> <code class="n">logger</code><code class="p">.</code><code class="n">Curry</code><code class="p">();</code>

<code class="kt">var</code> <code class="n">logInfo</code> <code class="p">=</code> <code class="n">curriedLogger</code><code class="p">(</code><code class="n">LogLevel</code><code class="p">.</code><code class="n">Info</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">logWarning</code> <code class="p">=</code> <code class="n">curriedLogger</code><code class="p">(</code><code class="n">LogLevel</code><code class="p">.</code><code class="n">Warning</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">logError</code> <code class="p">=</code> <code class="n">curriedLogger</code><code class="p">(</code><code class="n">LogLevel</code><code class="p">.</code><code class="n">Error</code><code class="p">);</code>

<code class="c1">// You'd use them then, like this:</code>

<code class="n">logInfo</code><code class="p">(</code><code class="s">"This currying lark works a treat!"</code><code class="p">);</code></pre>

<p>There are a few useful features of this approach:</p>

<ul>
<li>
<p>We’ve actually only created one single function at the end of the day, but from it, managed to create at least 3 usable variations which can be passed around, requiring only a filename to be usable.  That’s taking code re-use to an extra level!</p>
</li>
<li>
<p>There are also all of the intermediate functions available too. These can either be used directly, or as a starting point for creating additional new functions.</p>
</li>
</ul>

<p>There’s another use for currying in C# as well.  I’ll discuss that in the next section.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Currying and Higher-Order functions"><div class="sect1" id="idm45400852567552">
<h1>Currying and Higher-Order functions</h1>

<p>What if I wanted to use currying to create a few functions to convert between celsius and fahrenheit.  What I’d do is start with curried versions of each of the basic arithmetic operations, like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="c1">// once again, the Currying process is just magic for now.</code>
<code class="c1">// Keep reading for the implementation</code>

<code class="kt">var</code> <code class="k">add</code> <code class="p">=</code> <code class="p">((</code><code class="n">x</code><code class="p">,</code><code class="n">y</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">+</code> <code class="n">y</code><code class="p">).</code><code class="n">Curry</code><code class="p">();</code>
<code class="kt">var</code> <code class="n">subtract</code> <code class="p">=</code> <code class="p">((</code><code class="n">x</code><code class="p">,</code><code class="n">y</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">y</code> <code class="p">-</code> <code class="n">x</code><code class="p">).</code><code class="n">Curry</code><code class="p">();</code>
<code class="kt">var</code> <code class="n">multiply</code> <code class="p">=</code> <code class="p">((</code><code class="n">x</code><code class="p">,</code><code class="n">y</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">*</code> <code class="n">y</code><code class="p">).</code><code class="n">Curry</code><code class="p">();</code>
<code class="kt">var</code> <code class="n">divide</code> <code class="p">=</code> <code class="p">((</code><code class="n">x</code><code class="p">,</code><code class="n">y</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">y</code> <code class="p">/</code> <code class="n">x</code><code class="p">).</code><code class="n">Curry</code><code class="p">();</code></pre>

<p>Using this, along with the map function from a previous chapter, we can create a fairly consise set of function definitions:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="kt">var</code> <code class="n">celsiusToFahrenheit</code> <code class="p">=</code> <code class="n">x</code> <code class="p">=&gt;</code>
 <code class="n">x</code><code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">multiply</code><code class="p">(</code><code class="m">9</code><code class="p">))</code>
 <code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">divide</code><code class="p">(</code><code class="m">5</code><code class="p">))</code>
 <code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="k">add</code><code class="p">(</code><code class="m">32</code><code class="p">));</code>

<code class="kt">var</code> <code class="n">fahrenheitToCelsius</code> <code class="p">=</code> <code class="n">x</code><code class="p">=&gt;</code>
 <code class="n">x</code><code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">subtract</code><code class="p">(</code><code class="m">32</code><code class="p">))</code>
  <code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">multiply</code><code class="p">(</code><code class="m">5</code><code class="p">))</code>
  <code class="p">.</code><code class="n">Map</code><code class="p">(</code><code class="n">divide</code><code class="p">(</code><code class="m">9</code><code class="p">));</code></pre>

<p>Whether you find any of this useful if largely dependent on use case - what you’re actually trying to achieve and whether currying fits in with it.</p>

<p>It’s available for you in C# now, as you can see.  If, that is, we can find a way to implement it in C#…​</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Currying in .NET"><div class="sect1" id="idm45400851740720">
<h1>Currying in .NET</h1>

<p>So, the big question: More functional-based languages can do this natively with <strong>all</strong> functions in your codebase, can we do anything like this in .NET?</p>

<p>The short answer is no-ish.</p>

<p>The longer answer is yes, sort of.  It’s not as elegant as in a functional language (e.g. F#) where this is all available out of the box.  We either need to hard-code it, create a static class, or else hack around with the language a bit and jump through a few hoops.</p>

<p>The hard-coded method assumes that you will only ever use the function in a curried manner, like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="kt">var</code> <code class="n">Add</code> <code class="p">=</code> <code class="p">(</code><code class="kt">decimal</code> <code class="n">x</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="kt">decimal</code> <code class="n">y</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">+</code> <code class="n">y</code><code class="p">;</code>
<code class="kt">var</code> <code class="n">Subtract</code> <code class="p">=</code> <code class="p">(</code><code class="kt">decimal</code> <code class="n">x</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="kt">decimal</code> <code class="n">y</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">y</code> <code class="p">-</code> <code class="n">x</code><code class="p">;</code>
<code class="kt">var</code> <code class="n">Multiply</code> <code class="p">=</code> <code class="p">(</code><code class="kt">decimal</code> <code class="n">x</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="kt">decimal</code> <code class="n">y</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">*</code> <code class="n">y</code><code class="p">;</code>
<code class="kt">var</code> <code class="n">Divide</code> <code class="p">=</code> <code class="p">(</code><code class="kt">decimal</code> <code class="n">x</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="kt">decimal</code> <code class="n">y</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">y</code> <code class="p">/</code> <code class="n">x</code><code class="p">;</code></pre>

<p>Note that there are two sets of arrows in each function, meaning that we’ve defined one <code>Func</code> delegate that returns another -i.e. the actual type is <code>Func&lt;decimal,Func&lt;decimal,decimal&gt;&gt;</code>.  So long as you’re using C# 10 or later, then you’ll be able to take advantage of implicit typing with the <code>var</code> keyword, like in the example above.  Older versions of C# may need to implicity state the type of the delegates in the code sample above.</p>

<p>The second option is to create a static class that can be referenced from anywhere in the codebase.  You can call it what you’d like, but I’m going with <code>F</code> for Functional.</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">static</code> <code class="k">class</code> <code class="nc">CurryingExtensions</code>
<code class="p">{</code>
  <code class="k">public</code> <code class="k">static</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">T1</code><code class="p">,</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">T2</code><code class="p">,</code> <code class="n">TOut</code><code class="p">&gt;&gt;</code> <code class="n">Curry</code><code class="p">&lt;</code><code class="n">T1</code><code class="p">,</code> <code class="n">T2</code><code class="p">,</code> <code class="n">TOut</code><code class="p">&gt;(</code>
   <code class="n">Func</code><code class="p">&lt;</code><code class="n">T1</code><code class="p">,</code> <code class="n">T2</code><code class="p">,</code> <code class="n">TOut</code><code class="p">&gt;</code> <code class="n">functionToCurry</code><code class="p">)</code> <code class="p">=&gt;</code>
    <code class="p">(</code><code class="n">T1</code> <code class="n">x</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="n">T2</code> <code class="n">y</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">functionToCurry</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code><code class="p">);</code>

  <code class="k">public</code> <code class="k">static</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">T1</code><code class="p">,</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">T2</code><code class="p">,</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">T3</code><code class="p">,</code> <code class="n">TOut</code><code class="p">&gt;&gt;&gt;</code> <code class="n">Curry</code><code class="p">&lt;</code><code class="n">T1</code><code class="p">,</code> <code class="n">T2</code><code class="p">,</code> <code class="n">T3</code><code class="p">,</code> <code class="n">TOut</code><code class="p">&gt;(</code>
   <code class="n">Func</code><code class="p">&lt;</code><code class="n">T1</code><code class="p">,</code> <code class="n">T2</code><code class="p">,</code> <code class="n">T3</code><code class="p">,</code> <code class="n">TOut</code><code class="p">&gt;</code> <code class="n">functionToCurry</code><code class="p">)</code> <code class="p">=&gt;</code>
    <code class="p">(</code><code class="n">T1</code> <code class="n">x</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="n">T2</code> <code class="n">y</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="n">T3</code> <code class="n">z</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">functionToCurry</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code><code class="p">,</code> <code class="n">z</code><code class="p">);</code>

  <code class="k">public</code> <code class="k">static</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">T1</code><code class="p">,</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">T2</code><code class="p">,</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">T3</code><code class="p">,</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">T4</code><code class="p">,</code> <code class="n">TOut</code><code class="p">&gt;&gt;&gt;&gt;</code> <code class="n">Curry</code><code class="p">&lt;</code><code class="n">T1</code><code class="p">,</code> <code class="n">T2</code><code class="p">,</code> <code class="n">T3</code><code class="p">,</code> <code class="n">T4</code><code class="p">,</code> <code class="n">TOut</code><code class="p">&gt;(</code>
   <code class="n">Func</code><code class="p">&lt;</code><code class="n">T1</code><code class="p">,</code> <code class="n">T2</code><code class="p">,</code> <code class="n">T3</code><code class="p">,</code> <code class="n">T4</code><code class="p">,</code> <code class="n">TOut</code><code class="p">&gt;</code> <code class="n">functionToCurry</code><code class="p">)</code> <code class="p">=&gt;</code>
    <code class="p">(</code><code class="n">T1</code> <code class="n">x</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="n">T2</code> <code class="n">y</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="n">T3</code> <code class="n">z</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="n">T4</code> <code class="n">a</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">functionToCurry</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code><code class="p">,</code> <code class="n">z</code><code class="p">,</code> <code class="n">a</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>This effecively places layers of <code>Func</code> delegates between calls to the end function that’s being curried, and the areas of code that use it that way.</p>

<p>The down side to this method is that we’ll have to create a curry method for every possible number of parameters.  My example covers functions with 2, 3 or 4 parameters.  Functions with more than that would need another Curry method constructed, based on the same formula.</p>

<p>The other issue is that Visual Studio is unable to implicitly determine the type for the function being passed in, so it’s necessary to define the function to be curried within the call to F.Curry, declaring the type of each parameter, like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="kt">var</code> <code class="n">Add</code> <code class="p">=</code> <code class="n">F</code><code class="p">.</code><code class="n">Curry</code><code class="p">((</code><code class="kt">decimal</code> <code class="n">x</code><code class="p">,</code> <code class="kt">decimal</code> <code class="n">y</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">+</code> <code class="n">y</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">Subtract</code> <code class="p">=</code> <code class="n">F</code><code class="p">.</code><code class="n">Curry</code><code class="p">((</code><code class="kt">decimal</code> <code class="n">x</code><code class="p">,</code> <code class="kt">decimal</code> <code class="n">y</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">y</code> <code class="p">-</code> <code class="n">x</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">Multiply</code> <code class="p">=</code> <code class="n">F</code><code class="p">.</code><code class="n">Curry</code><code class="p">((</code><code class="kt">decimal</code> <code class="n">x</code><code class="p">,</code> <code class="kt">decimal</code> <code class="n">y</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">*</code> <code class="n">y</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">Divide</code> <code class="p">=</code> <code class="n">F</code><code class="p">.</code><code class="n">Curry</code><code class="p">((</code><code class="kt">decimal</code> <code class="n">y</code><code class="p">,</code> <code class="kt">decimal</code> <code class="n">y</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">y</code> <code class="p">/</code> <code class="n">x</code><code class="p">);</code></pre>

<p>The final option - and my preferred option - is to use extension methods to cut down somewhat on the boilerplate code necessary.  The definitions would look like this for 2, 3 and 4 parameter functions:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">static</code> <code class="k">class</code> <code class="nc">Ext</code>
<code class="p">{</code>
	<code class="k">public</code> <code class="k">static</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">T1</code><code class="p">,</code><code class="n">Func</code><code class="p">&lt;</code><code class="n">T2</code><code class="p">,</code> <code class="n">T3</code><code class="p">&gt;&gt;</code> <code class="n">Curry</code><code class="p">&lt;</code><code class="n">T1</code><code class="p">,</code><code class="n">T2</code><code class="p">,</code><code class="n">T3</code><code class="p">&gt;(</code>
	 <code class="k">this</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">T1</code><code class="p">,</code><code class="n">T2</code><code class="p">,</code><code class="n">T3</code><code class="p">&gt;</code> <code class="n">@this</code><code class="p">)</code> <code class="p">=&gt;</code>
		 <code class="p">(</code><code class="n">T1</code> <code class="n">x</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="n">T2</code> <code class="n">y</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">@this</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code><code class="p">);</code>

	<code class="k">public</code> <code class="k">static</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">T1</code><code class="p">,</code><code class="n">Func</code><code class="p">&lt;</code><code class="n">T2</code><code class="p">,</code><code class="n">Func</code><code class="p">&lt;</code><code class="n">T3</code><code class="p">,</code><code class="n">T4</code><code class="p">&gt;&gt;&gt;</code><code class="n">Curry</code><code class="p">&lt;</code><code class="n">T1</code><code class="p">,</code><code class="n">T2</code><code class="p">,</code><code class="n">T3</code><code class="p">,</code><code class="n">T4</code><code class="p">&gt;(</code>
	 <code class="k">this</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">T1</code><code class="p">,</code><code class="n">T2</code><code class="p">,</code><code class="n">T3</code><code class="p">,</code><code class="n">T4</code><code class="p">&gt;</code> <code class="n">@this</code><code class="p">)</code> <code class="p">=&gt;</code>
		 <code class="p">(</code><code class="n">T1</code> <code class="n">x</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="n">T2</code> <code class="n">y</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="n">T3</code> <code class="n">z</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">@this</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code><code class="p">,</code> <code class="n">z</code><code class="p">);</code>

	<code class="k">public</code> <code class="k">static</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">T1</code><code class="p">,</code><code class="n">Func</code><code class="p">&lt;</code><code class="n">T2</code><code class="p">,</code><code class="n">Func</code><code class="p">&lt;</code><code class="n">T3</code><code class="p">,</code><code class="n">Func</code><code class="p">&lt;</code><code class="n">T4</code><code class="p">,</code><code class="n">T5</code><code class="p">&gt;&gt;&gt;&gt;</code><code class="n">Curry</code><code class="p">&lt;</code><code class="n">T1</code><code class="p">,</code><code class="n">T2</code><code class="p">,</code><code class="n">T3</code><code class="p">,</code><code class="n">T4</code><code class="p">,</code><code class="n">T5</code><code class="p">&gt;(</code>
	 <code class="k">this</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">T1</code><code class="p">,</code><code class="n">T2</code><code class="p">,</code><code class="n">T3</code><code class="p">,</code><code class="n">T4</code><code class="p">,</code><code class="n">T5</code><code class="p">&gt;</code> <code class="n">@this</code><code class="p">)</code> <code class="p">=&gt;</code>
		 <code class="p">(</code><code class="n">T1</code> <code class="n">x</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="n">T2</code> <code class="n">y</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="n">T3</code> <code class="n">z</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="n">T4</code> <code class="n">a</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">@this</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code><code class="p">,</code> <code class="n">z</code><code class="p">,</code> <code class="n">a</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>That’s a fairly ugly block of code, isn’t it?  Good news is you can just shove that somewhere deep down at the back of your codebase, and largely forget it exists.</p>

<p>The usage would be like this:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="c1">// specifically define the function on one line</code>
<code class="c1">// it has to be stored as a `Func` delegate, rather than a</code>
<code class="c1">// Lambda expression</code>
<code class="kt">var</code> <code class="n">Add</code> <code class="p">=</code> <code class="p">(</code><code class="kt">decimal</code> <code class="n">x</code><code class="p">,</code> <code class="kt">decimal</code> <code class="n">y</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">x</code> <code class="p">+</code> <code class="n">y</code><code class="p">;</code>
<code class="kt">var</code> <code class="n">CurriedAdd</code> <code class="p">=</code> <code class="n">Add</code><code class="p">.</code><code class="n">Curry</code><code class="p">();</code>

<code class="kt">var</code> <code class="n">add10</code> <code class="p">=</code> <code class="n">CurriedAdd</code><code class="p">(</code><code class="m">10</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">answer</code> <code class="p">=</code> <code class="n">add10</code><code class="p">(</code><code class="m">100</code><code class="p">);</code>
<code class="c1">// answer = 110</code></pre>

<p>So that’s currying.  The eagle-eyed among you may have noticed that this chapter is called “Currying <strong>and</strong> Partial Application”.</p>

<p>What on earth is Partial Application?  Well…​since you asked so very nicely…​</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Partial Application"><div class="sect1" id="idm45400851739808">
<h1>Partial Application</h1>

<p>Partial application works along a very similar line to Currying, but there’s a subtle difference.  The two terms are often even used - incorrectly - in exchange for each other.</p>

<p>Currying deals <strong>exclusively</strong> with converting a function with a set of parameters into a series of successive function calls, each with a single paramater (the technical term is a <em>unary</em> function).</p>

<p>Partial appliction on the other hand allows you to apply as many parameters in one go as you want.  With data emerging if all of the parameters are filled in.</p>

<p>Returning to my earlier example of the parse function, these are the formats we’re working with:</p>

<ul>
<li>
<p>book1 - windows line endings, header, commas for fields</p>
</li>
<li>
<p>book2 - Windows line endings, header, pipe for fields</p>
</li>
<li>
<p>book3 - Linux ling endings, no header, commas for fields</p>
</li>
</ul>

<p>With the currying approach, we’re creating intermediate steps for setting each parameter of Book3, even though it’s ultimately the only use of each of those parameters.  We’re also doing the same for the SkipHeader and Line endings parameters for book1 and book2, even thought they’re the same.</p>

<p>It could be done like this to save space:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="kt">var</code> <code class="n">curriedParseBooks</code> <code class="p">=</code> <code class="n">parseBooks</code><code class="p">.</code><code class="n">Curry</code><code class="p">();</code>

<code class="kt">var</code> <code class="n">parseNoHeaderLinuxCommaDel</code> <code class="p">=</code> <code class="n">curriedParseBooks</code><code class="p">(</code><code class="k">false</code><code class="p">)(</code><code class="s">"\n"</code><code class="p">)(</code><code class="s">","</code><code class="p">);</code>

<code class="kt">var</code> <code class="n">parseWindowsHeader</code> <code class="p">=</code> <code class="n">curriedParseBooks</code><code class="p">(</code><code class="k">true</code><code class="p">)(</code><code class="n">Environment</code><code class="p">.</code><code class="n">NewLine</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">parseWindowsHeaderComma</code> <code class="p">=</code> <code class="n">parseWindowsHeader</code><code class="p">(</code><code class="s">","</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">parseWindowsHeaderPipe</code> <code class="p">=</code> <code class="n">parseWindowsHeader</code><code class="p">(</code><code class="s">"|"</code><code class="p">);</code>

<code class="c1">// Actual data, Enumerables of Book data</code>
<code class="kt">var</code> <code class="n">bookData1</code> <code class="p">=</code> <code class="n">parseWindowsHeaderComma</code><code class="p">(</code><code class="s">"books.csv"</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">bookData2</code> <code class="p">=</code> <code class="n">parseWindowsHeaderPipe</code><code class="p">(</code><code class="s">"books2.csv"</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">bookData3</code> <code class="p">=</code> <code class="n">parseNoHeaderLinuxCommaDel</code><code class="p">(</code><code class="s">"books3.csv"</code><code class="p">);</code></pre>

<p>But it’s much cleaner if we can just use partial application to apply the 2 parameters neatly.</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="c1">// I'm using an extension method called Partial to apply</code>
<code class="c1">// parameters.  Check out the next section for implementation details</code>

<code class="kt">var</code> <code class="n">parseNoHeaderLinuxCommarDel</code> <code class="p">=</code> <code class="n">ParseBooks</code><code class="p">.</code><code class="n">Partial</code><code class="p">(</code><code class="k">false</code><code class="p">,</code><code class="s">"\n"</code><code class="p">,</code><code class="s">","</code><code class="p">);</code>

<code class="kt">var</code> <code class="n">parseWindowsHeader</code> <code class="p">=</code>
 <code class="n">curriedParseBooks</code><code class="p">.</code><code class="n">Partial</code><code class="p">(</code><code class="k">true</code><code class="p">,</code><code class="n">Environment</code><code class="p">.</code><code class="n">NewLine</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">parseWindowsHeaderComma</code> <code class="p">=</code> <code class="n">parseWindowsHeader</code><code class="p">.</code><code class="n">Partial</code><code class="p">(</code><code class="s">","</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">parseWindowsHeaderPipe</code> <code class="p">=</code> <code class="n">parseWindowsHeader</code><code class="p">.</code><code class="n">Partial</code><code class="p">(</code><code class="s">"|"</code><code class="p">);</code>

<code class="c1">// Actual data, Enumerables of Book data</code>
<code class="kt">var</code> <code class="n">bookData1</code> <code class="p">=</code> <code class="n">parseWindowsHeaderComma</code><code class="p">(</code><code class="s">"books.csv"</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">bookData2</code> <code class="p">=</code> <code class="n">parseWindowsHeaderPipe</code><code class="p">(</code><code class="s">"books2.csv"</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">bookData3</code> <code class="p">=</code> <code class="n">parseNoHeaderLinuxCommarDel</code><code class="p">(</code><code class="s">"books3.csv"</code><code class="p">);</code></pre>

<p>I think that’s pretty elegant as a solution, and it still allows us to have re-usable intermediate functions where we need them, but still only a single base function.</p>

<p>In the next section, I’ll show you how to actually implement this.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Partial Application in .NET"><div class="sect1" id="idm45400850883104">
<h1>Partial Application in .NET</h1>

<p>This is the bad news.  There’s absolutely no way whatsoever to elegantly implement Partial Application in C#.  What you’re going to have to do is create an extension method for each and every combination of the number of parameters going in to the number of parameters going out.</p>

<p>In the example I just gave, I’d need:</p>

<ul>
<li>
<p>4 parameters to 1 for <code>parseNoHeaderLinuxCommaDel</code></p>
</li>
<li>
<p>4 paramters to 2 for <code>parseWindowsHeader</code></p>
</li>
<li>
<p>2 parameters to 1 for <code>parseWindowsHeaderComma</code> and <code>parseWindowsHeaderPipe</code></p>
</li>
</ul>

<p>Here’s what each of those examples would look like:</p>

<pre data-type="programlisting" data-code-language="csharp"><code class="k">public</code> <code class="k">static</code> <code class="k">class</code> <code class="nc">PartialApplicationExtensions</code>
<code class="p">{</code>
<code class="c1">// 4 parameters to 1</code>
 <code class="k">public</code> <code class="k">static</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">T4</code><code class="p">,</code><code class="n">TOut</code><code class="p">&gt;</code> <code class="n">Partial</code><code class="p">&lt;</code><code class="n">T1</code><code class="p">,</code><code class="n">T2</code><code class="p">,</code><code class="n">T3</code><code class="p">,</code><code class="n">T4</code><code class="p">,</code><code class="n">TOut</code><code class="p">&gt;(</code>
  <code class="k">this</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">T1</code><code class="p">,</code><code class="n">T2</code><code class="p">,</code><code class="n">T3</code><code class="p">,</code><code class="n">T4</code><code class="p">,</code><code class="n">TOut</code><code class="p">&gt;</code> <code class="n">f</code><code class="p">,</code>
  <code class="n">T1</code> <code class="n">one</code><code class="p">,</code> <code class="n">T2</code> <code class="n">two</code><code class="p">,</code> <code class="n">T3</code> <code class="n">three</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="n">T4</code> <code class="n">four</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">f</code><code class="p">(</code><code class="n">one</code><code class="p">,</code> <code class="n">two</code><code class="p">,</code> <code class="n">three</code><code class="p">,</code> <code class="n">four</code><code class="p">);</code>

<code class="c1">// 4 parameters to 2</code>
 <code class="k">public</code> <code class="k">static</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">T3</code><code class="p">,</code><code class="n">T4</code><code class="p">,</code><code class="n">TOut</code><code class="p">&gt;</code><code class="n">Partial</code><code class="p">&lt;</code><code class="n">T1</code><code class="p">,</code><code class="n">T2</code><code class="p">,</code><code class="n">T3</code><code class="p">,</code><code class="n">T4</code><code class="p">,</code><code class="n">TOut</code><code class="p">&gt;(</code>
  <code class="k">this</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">T1</code><code class="p">,</code><code class="n">T2</code><code class="p">,</code><code class="n">T3</code><code class="p">,</code><code class="n">T4</code><code class="p">,</code><code class="n">TOut</code><code class="p">&gt;</code> <code class="n">f</code><code class="p">,</code>
  <code class="n">T1</code> <code class="n">one</code><code class="p">,</code> <code class="n">T2</code> <code class="n">two</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="n">T3</code> <code class="n">three</code><code class="p">,</code> <code class="n">T4</code> <code class="n">four</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">f</code><code class="p">(</code><code class="n">one</code><code class="p">,</code> <code class="n">two</code><code class="p">,</code> <code class="n">three</code><code class="p">,</code> <code class="n">four</code><code class="p">);</code>

 <code class="c1">// 2 parameters to 1</code>
 <code class="k">public</code> <code class="k">static</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">T2</code><code class="p">,</code> <code class="n">TOut</code><code class="p">&gt;</code> <code class="n">Partial</code><code class="p">&lt;</code><code class="n">T1</code><code class="p">,</code><code class="n">T2</code><code class="p">,</code><code class="n">TOut</code><code class="p">&gt;(</code>
  <code class="k">this</code> <code class="n">Func</code><code class="p">&lt;</code><code class="n">T1</code><code class="p">,</code><code class="n">T2</code><code class="p">,</code><code class="n">TOut</code><code class="p">&gt;</code> <code class="n">f</code><code class="p">,</code> <code class="n">T1</code> <code class="n">one</code><code class="p">)</code> <code class="p">=&gt;</code>
   <code class="p">(</code><code class="n">T2</code> <code class="n">two</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">f</code><code class="p">(</code><code class="n">one</code><code class="p">,</code> <code class="n">two</code><code class="p">);</code>

<code class="p">}</code></pre>

<p>If you decide that partial application is a technique you’d like to persue, then you could either add Partial methods to your codebase as you feel they’re needed, or else put aside a block of time to create as many as you think you’re ever likely to need.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="idm45400850580464">
<h1>Conclusion</h1>

<p>Currying and Partial Application are two powerful, related concepts in functional programming.  Sadly they’re not available natively in C#, and aren’t ever likely to be.</p>

<p>They can be implemented by the use of static classes or extension methods, which add some boilerplate to the codebase - which is ironic, considering that these techniques are intended in part to reduce boilerplate.</p>

<p>Given that C# doesn’t support higher-order functions to the same level as F# and other functional languages. C# can’t necessarily  pass functions around unless they’re converted to <code>Func</code> delegates.</p>

<p>Even if functions are converted over to `Func`then the Roslyn compiler can’t always determine parameter types correctly.  T</p>

<p>hese techniques will never be as useful in the C# world as they are in other languages.  Despite that though, they have their uses in reducing boilerplate, and in enabling a greater level of code re-usability than would otherwise be possible.</p>

<p>The decision to use them or not is a matter of personal preference.  I wouldn’t regard them as essential for functional C#, but they may be worth exploring nevertheless.</p>

<p>In our next chapter, we’ll be exploring the deeper mysteries of indefinite loops in functional C#, and what on earth Tail Optimised Recursion Calls are.</p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45400852781472"><sup><a href="ch08.html#idm45400852781472-marker">1</a></sup> food tip: If you’re ever in Mumbai, try a Tibb’s Frankie from Shivaji Park, you won’t regret it!</p><p data-type="footnote" id="idm45400852780672"><sup><a href="ch08.html#idm45400852780672-marker">2</a></sup> Haskell, obviously, but also Brook and Curry, two lesser-known languages</p></div></div></section></div>
</div>
</body>
</html>