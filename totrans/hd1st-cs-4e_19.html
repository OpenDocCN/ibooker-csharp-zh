<html><head></head><body><section data-pdf-bookmark="Unity Lab #6 Scene Navigation" data-type="afterword" epub:type="afterword"><div class="appendix" id="unity_lab_hash6_scene_navigation">&#13;
<h1>Unity Lab #6 Scene Navigation</h1>&#13;
<p><a data-primary="Unity" data-secondary="scene navigation" data-type="indexterm" id="idm46402337779512"/>In the last Unity Lab, you created a scene with a floor (a plane) and a player (a sphere nested under a cylinder), and you used a NavMesh, a NavMesh Agent, and raycasting to get your player to follow your mouse clicks around the scene.</p>&#13;
<p>Now we’ll pick up where the last Unity Lab left off. The goal of these labs is to get you familiar with Unity’s <strong>pathfinding and navigation system</strong>, a sophisticated AI system that lets you create characters that can find their way around the worlds you create. In this lab, you’ll use Unity’s navigation system to make your GameObjects move themselves around a scene.</p>&#13;
<p>Along the way you’ll learn about useful tools: you’ll create a more complex scene and bake a NavMesh that lets an agent navigate it, you’ll create static and moving obstacles, and most importantly, you’ll <strong>get more practice writing C# code</strong>.</p>&#13;
<section data-pdf-bookmark="Let’s pick up where the last Unity Lab left off" data-type="sect1"><div class="sect1" id="letapostrophes_pick_up_where_the_last_un">&#13;
<h1>Let’s pick up where the last Unity Lab left off</h1>&#13;
<p>In the last Unity Lab, you created a player out of a sphere head nested under a cylinder body. Then you added a NavMesh Agent component to move the player around the scene, using raycasting to find the point on the floor that the player clicked. In this lab, you’ll pick up where the last one left off. You’ll add GameObjects to the scene, including stairs and obstacles so you can see how Unity’s navigation AI handles them. Then you’ll add a moving obstacle to really put that NavMesh Agent through its paces.</p>&#13;
<p>So go ahead and <strong>open the Unity project</strong> that you saved at the end of the last Unity Lab. If you’ve been saving up the Unity Labs to do them back to back, then you’re probably ready to jump right in! But if not, take a few minutes and flip through the last Unity Lab again—and also look through the code that you wrote for it.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg652.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><span style="color:#9D9EA0;">If you’re using our book because you’re preparing to be a professional developer, being able to go back and read and refactor the code in your old projects is a really important skill—and not just for game development!</span></p>&#13;
</div>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="there_are_no_dumb_questions-idd0043">&#13;
<h5>there are no Dumb Questions</h5>&#13;
<p><strong>Q: There were a lot of moving parts in the last Unity Lab. Can you go through them again, just so I’m sure I have everything?</strong></p>&#13;
<p><strong>A:</strong> Definitely. The Unity scene you created in the last lab has four separate pieces. It’s easy to lose track of how they work together, so let’s go through them one by one:</p>&#13;
<p>1. First there’s the <strong>NavMesh</strong>, which defines all of the “walkable” places your player can move around on in the scene. You made this by setting the floor as a walkable surface and then “baking” the mesh.</p>&#13;
<p>2. Next there’s the <strong>NavMesh Agent</strong>, a component that can “take over” your GameObject and move it around the NavMesh just by calling its SetDestination method. You added this to your <em>Player</em> GameObject.</p>&#13;
<p>3. The camera’s <strong>ScreenPointToRay method</strong> creates a ray that goes through a point on the screen. You added code to the Update method that checks if the player is currently pressing the mouse button, If so, it uses the current mouse position to compute the ray.</p>&#13;
<p>4. <strong>Raycasting</strong> is a tool that lets you cast (basically “shoot”) a ray. Unity has a useful Physics.Raycast method that takes a ray, casts it up to a certain distance, and if it hits something tells you what it hit.</p>&#13;
<p><strong>Q: So how do those parts work together?</strong></p>&#13;
<p><strong>A:</strong> Whenever you’re trying to figure out how the different parts of a system work together, <strong><em>understanding the overall goal</em></strong> is a great place to start. In this case, the goal is to let the player click anywhere on the floor and have a GameObject move there automatically. Let’s break that down into a set of individual steps. The code needs to:</p>&#13;
<p>• <strong>Detect that the player clicked the mouse.</strong></p>&#13;
<p>Your code uses Input.GetMouseButtonDown to detect a mouse click.</p>&#13;
<p><strong>• Figure out what point in the scene that click corresponds to.</strong></p>&#13;
<p>It uses Camera.ScreenPointToRay and Physics.Raycast to do raycasting and figure out which point in the scene the player clicked.</p>&#13;
<p><strong>• Tell the NavMesh Agent to set that point as a destination.</strong></p>&#13;
<p>The NavMeshAgent.SetDestination method triggers the agent to calculate a new path and start moving towards the new destination.</p>&#13;
<p><em>The MoveToClick method <strong>was <u>adapted</u> from code on the Unity Manual page</strong> for the NavMeshAgent.SetDestination method. Take a minute and read it right now—<strong>choose Help &gt;&gt; Scripting Reference</strong> from the main menu, then search for NavMeshAgent.SetDestination.</em></p>&#13;
</div></aside>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Add a platform to your scene" data-type="sect1"><div class="sect1" id="add_a_platform_to_your_scene">&#13;
<h1>Add a platform to your scene</h1>&#13;
<p><a data-primary="isometric view (Unity)" data-type="indexterm" id="idm46402337750504"/><a data-primary="platforms, in scenes (Unity)" data-type="indexterm" id="idm46402337749768"/>Let’s do a little experimentation with Unity’s navigation system. To help us do that, we’ll add more GameObjects to build a platform with stairs, a ramp, and an obstacle. Here’s what it will look like:</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg653-1.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>It’s a little easier to see what’s going on if we switch to an <strong>isometric</strong> view, or a view that doesn’t show perspective. In a <strong>perspective</strong> view, objects that are further away look small, while closer objects look large. In an isometric view, objects are always the same size no matter how far away they are from the camera.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg653-2.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><strong>Sometimes it’s easier to see what’s going on in your scene if you switch to an isometric view. You can always reset the layout if you lose track of the view.</strong></p>&#13;
</div>&#13;
<p><strong>Add 10 GameObjects</strong> to your scene. <strong>Create a new material called <em>Platform</em></strong> in your Materials folder with albedo color CC472F, and add it to <u>all</u> of the GameObjects <u>except</u> for Obstacle, which uses a <strong>new material called <em>8 Ball</em></strong> with the 8 Ball Texture map from the first Unity Lab. This table shows their names, types, and positions:</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg653-3.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Use bake options to make the platform walkable" data-type="sect1"><div class="sect1" id="use_bake_options_to_make_the_platform_wa">&#13;
<h1>Use bake options to make the platform walkable</h1>&#13;
<p>Use Shift-click to select all of the new GameObjects that you added to the scene, then use Control-click (or Command-click on a Mac) to deselect Obstacle. Go to the Navigation window and click the Object button, then <strong>make them all walkable by</strong> checking Navigation Static and setting the Navigation Area to Walkable. <strong>Make the Obstacle GameObject not walkable</strong> by selecting it, clicking Navigation Static, and setting Navigation Area to Not Walkable.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg654-1.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>Now follow the same steps that you used before to <strong>bake the NavMesh</strong>: click the Bake button at the top of the Navigation window to switch to the Bake view, then click the Bake button at the bottom.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg654-2.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>It looks like it worked! The NavMesh now appears on top of the platform, and there’s space around the obstacle. Try running the game. Click on top of the platform and see what happens.</p>&#13;
<p>Hmm, hold on. Things aren’t working the way we expected them to. When you click on top of the platform, the player goes <strong><em>under</em></strong> it. If you look closely at the NavMesh that’s displayed when you’re viewing the Navigation window, you’ll see that it also has space around the stairs and ramp, but <u>doesn’t actually include either of them in the NavMesh</u>. The player has no way to get to the point you clicked on, so the AI gets it as close as it can.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg654-3.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Include the stairs and ramp in your NavMesh" data-type="sect1"><div class="sect1" id="include_the_stairs_and_ramp_in_your_navm">&#13;
<h1>Include the stairs and ramp in your NavMesh</h1>&#13;
<p><a data-primary="exercises" data-secondary="writing code" data-type="indexterm" id="idm46402337722488"/><a data-primary="NavMesh" data-type="indexterm" id="idm46402337721032"/>An AI that couldn’t get your player up or down a ramp or stairs wouldn’t be very intelligent. Luckily, Unity’s pathfinding system can handle both of those cases. We just need to make a few small adjustments to the options when we bake the NavMesh. Let’s start with the stairs. Go back to the Bake window and notice that the default value of Step Height is 0.4. Take a careful look at the measurements for your steps—they’re all 0.5 units tall. So to tell the navigation system to include steps that are 0.5 units, <strong>change the Step Height to 0.5</strong>. You’ll see the picture of the step in the diagram  get taller, and the number above it change from the default 0.4 value to 0.5.</p>&#13;
<p>We still need to include the ramp in the NavMesh. When you created the GameObjects for the platform, you gave the ramp an X rotation of –46, which means that it’s a 46-degree incline. The Max Slope setting defaults to 45, which means it will only include ramps, hills, or other slopes with at most a 45-degree incline. So <strong>change Max Slope to 46</strong>, then <strong>bake the NavMesh again</strong>. Now it will include the ramp and stairs.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg655.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>Start your game and test out your new NavMesh changes.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="exercise-idd0034">&#13;
<h5><span class="inlineimage"><img alt="Images" src="assets/exercise.png"/></span> Exercise</h5>&#13;
<p><strong>Here’s another Unity coding challenge!</strong> Earlier, we pointed the camera straight down by setting its X rotation to 90. Let’s see if we can get a better look at the player by making the arrow keys and mouse scroll wheel control the camera. You already know almost everything you need to get it to work—we just need to add a little code. <em>It may seem complicated, but you <u>can</u> do this!</em></p>&#13;
<ul>&#13;
<li><p><strong>Create a new script called MoveCamera and drag it onto the camera.</strong> It should have a Transform field called Player. Drag the Player GameObject out of the Hierarchy and <strong>onto the Player field in the Inspector</strong>. Since the field’s type is Transform, it copies a reference to the Player GameObject’s Transform component.</p></li>&#13;
<li><p><strong>Make the arrow keys rotate the camera around the player.</strong> Input.GetKey(KeyCode.LeftArrow) will return true if the player is currently pressing the left arrow key, and you can use RightArrow, UpArrow, and DownArrow to check for the other arrow keys. Use this method just like you used Input.GetMouseButtonDown in your MoveToClick script to check for mouse clicks. When the player presses a key, call transform.RotateAround to rotate around the player’s position. The player’s position is the first argument; use Vector3.left, Vector3.right, Vector3.up, or Vector3.down as the second argument, and a field called Angle (set to 3F) as the third argument.</p></li>&#13;
<li><p><strong>Make the scroll wheel zoom the camera.</strong> Input.GetAxis(“Mouse ScrollWheel”) returns a number (usually between –0.4 and 0.4) that represents how much the scroll wheel moved (or 0 if it didn’t move). Add a float field called ZoomSpeed set to 0.25F. Check if the scroll wheel moved. If it did, do a little vector arithmetic to zoom the camera by multiplying transform.position by (1F + scrollWheelValue * ZoomSpeed).</p></li>&#13;
<li><p><strong>Point the camera at the player.</strong> The transform.LookAt method makes a GameObject look at a position. Then <u>reset the Main Camera’s Transform</u> to position (0, 1, –10) and rotation (0, 0, 0).</p></li>&#13;
</ul>&#13;
<p><span style="color:#9D9EA0;">It’s not cheating to peek at the solution!</span></p>&#13;
</div></aside>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="exercise_solution-idd0025">&#13;
<h5><span class="inlineimage"><img alt="Images" src="assets/exercise.png"/></span> <strong>Exercise Solution</strong></h5>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><span style="color:#9D9EA0;">It’s OK if your code looks a little different than ours as long as it works. There are a LOT of ways to solve any coding problem! Just make sure to take some time and understand how this code works.</span></p>&#13;
</div>&#13;
<p><strong>Here’s another Unity coding challenge!</strong> We pointed the camera straight down by setting its X rotation to 90. Let’s see if we can get a better look at the player by making the arrow keys and mouse scroll wheel control the camera. You already know almost everything you need to get it to work—we just need to give you a little code to include. <em>It seems like a lot, but <strong>you <u>can</u> do this!</strong></em></p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg656-1.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>Don’t forget to drag Player onto the field in the script component in the Main Camera.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg656-2.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>Try experimenting with different angles and zoom speeds to see what feels best to you.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Fix height problems in the NavMesh" data-type="sect1"><div class="sect1" id="fix_height_problems_in_the_navmesh">&#13;
<h1>Fix height problems in the NavMesh</h1>&#13;
<p><a data-primary="NavMesh" data-type="indexterm" id="idm46402337690408"/>Now that we’ve got control of the camera, we can get a good look at what’s going on under the platform—and something doesn’t look quite right. Start your game, then rotate the camera and zoom in so you can get a clear view of the obstacle sticking out under the platform. Click the floor on one side of the obstacle, then the other. It looks like the player is going right through the obstacle! And it goes right through the end of the ramp, too.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg657-1.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>But if you move the player back to the top of the platform, it avoids the obstacle just fine. What’s going on?</p>&#13;
<p>Look closely at the parts of the NavMesh above and below the obstacle. Notice any differences between them?</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg657-2.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>Go back to the part of the last lab where you set up the NavMesh Agent component—specifically, the part where you set the Height to 3. Now you just need to do the same for the NavMesh. Go back to the Bake options in the Navigation window and <strong>set the Agent Height to 3, then bake your mesh again</strong>.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg657-3.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>This created a gap in the NavMesh under the obstacle and expanded the gap under the ramp. Now the player doesn’t hit either the obstacle or the ramp when moving around under the platform.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Add a NavMesh Obstacle" data-type="sect1"><div class="sect1" id="add_a_navmesh_obstacle">&#13;
<h1>Add a NavMesh Obstacle</h1>&#13;
<p><a data-primary="NavMesh" data-type="indexterm" id="idm46402337683032"/>You already added a static obstacle in the middle of your platform: you created a stretched-out capsule and marked it non-walkable, and when you baked your NavMesh it had a hole around the obstacle so the player has to walk around it. What if you want an obstacle that moves? Try moving the obstacle—the NavMesh doesn’t change! It still has a hole <em>where the obstacle was</em>, not where it currently is. If you bake it again, it just creates a hole around the obstacle’s new location. To add an obstacle that <u>moves</u>, add a <strong>NavMesh Obstacle component</strong> to a GameObject.</p>&#13;
<p>Let’s do that right now. <strong>Add a Cube to your scene</strong> with position (–5.75, 1, –1) and scale (2, 2, 0.25). Create a new material for it with a dark gray color (333333) and name your new GameObject <em>Moving Obstacle</em>. This will act as a kind of gate at the bottom of the ramp that can move up out of the way of the player or down to block it.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg658-1.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>We just need one more thing. Click the Add Component button at the bottom of the Inspector window and choose Navigation &gt;&gt; Nav Mesh Obstacle to <strong>add a NavMesh Obstacle component</strong> to your Cube GameObject.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg658-2.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>If you leave all of the options at their default settings, you get an obstacle that the NavMesh Agent can’t get through. Instead, the Agent hits it and stops. <strong>Check the Carve box</strong>—this causes the obstacle to <strong><em>create a moving hole in the NavMesh</em></strong> that follows the GameObject. Now your Moving Obstacle GameObject can block the player from navigating up and down the ramp. Since the NavMesh height is set to 3, if the obstacle is less than 3 units above the floor it will create a hole in the NavMesh underneath it. If it goes above that height, the hole disappears.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><strong>The Unity Manual has thorough—and readable!—explanations for the various components. Click the Open Reference button (<span class="inlineimage"><img alt="Images" src="assets/pg658-3.png"/></span> ) at the top of the Nav Mesh Obstacle panel in the Inspector to open up the manual page. Take a minute to read it—it does a great job of explaining the options.</strong></p>&#13;
</div>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Add a script to move the obstacle up and down" data-type="sect1"><div class="sect1" id="add_a_script_to_move_the_obstacle_up_and">&#13;
<h1>Add a script to move the obstacle up and down</h1>&#13;
<p><a data-primary="OnMouseDrag method" data-type="indexterm" id="idm46402337663512"/>This script uses the <strong>OnMouseDrag</strong> method. It works just like the OnMouseDown method you used in the last lab, except that it’s called when the GameObject is dragged.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg659-1.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><strong>The first if statement keeps the block from moving below the floor, and the second keeps it from moving too high. Can you figure out how they work?</strong></p>&#13;
</div>&#13;
<p><strong>Drag your script onto the Moving Obstacle GameObject</strong> and run the game—uh-oh, something’s wrong. You can click and drag the obstacle up and down, but it <u>also moves the player</u>. Fix this by <strong>adding a tag</strong> to the GameObject.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg659-3.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>Then <strong>modify your MoveToClick script</strong> to check for the tag:</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg659-2.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>Run your game again. If you click on the obstacle you can drag it up and down, and it stops when it hits the floor or gets too high. Click anywhere else, and the player moves just like before. Now you can <strong>experiment with the NavMesh Obstacle options</strong> (this is easier if you reduce the Speed in the Player’s NavMesh Agent):</p>&#13;
<ul>&#13;
<li><p>Start your game. Click on <em>Moving Obstacle</em> in the Hierarchy window and <strong>uncheck the Carve option</strong>. Move your player to the top of the ramp, then click at the bottom of the ramp—the player will bump into the obstacle and stop. Drag the obstacle up, and the player will continue moving.</p></li>&#13;
<li><p>Now <strong>check Carve</strong> and try the same thing. As you move the obstacle up and down, the player will recalculate its route, taking the long way around to avoid the obstacle if it’s down, and changing course in real time as you move the obstacle.</p></li>&#13;
</ul>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="there_are_no_dumb_questions-idd0044">&#13;
<h5>there are no Dumb Questions</h5>&#13;
<p><strong>Q: How does that MoveObstacle script work? It’s using += to update transform.position—does that mean it’s using vector arithmetic?</strong></p>&#13;
<p><strong>A:</strong> Yes, and this is a great opportunity to understand vector arithmetic better. Input.GetAxis returns a number that’s positive if the mouse moves up and negative if the mouse moves down (try adding a Debug.Log statement so you can see its value). The obstacle starts at position (–5.75, 1, –1). If the player moves the mouse up and GetAxis returns 0.372, the += operation adds (0, 0.372, 0) to the position. That means it <strong>adds both of the X values</strong> to get a new X value, then does the same for the Y and Z values. So the new Y position is 1 + 0.372 = 1.372, and since we’re adding 0 to the X and Z values, only the Y value changes and it moves up.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Get creative!" data-type="sect1"><div class="sect1" id="get_creativeexclamation_mark-idd0004">&#13;
<h1>Get creative!</h1>&#13;
<p>Can you find ways to improve your game and get practice writing code? Here are some ideas to help you get creative:</p>&#13;
<ul>&#13;
<li><p>Build out the scene—add more ramps, stairs, platforms, and obstacles. Find creative ways to use materials. Search the web for new texture maps. Make it look interesting!</p></li>&#13;
<li><p>Make the NavMesh Agent move faster when the player holds down the Shift key. Search for “KeyCode” in the Scripting Reference to find the left/right Shift key codes.</p></li>&#13;
<li><p>You used OnMouseDown, Rotate, RotateAround, and Destroy in the last lab. See if you can use them to create obstacles that rotate or disappear when you click them.</p></li>&#13;
<li><p>We don’t actually have a game just yet, just a player navigating around a scene. Can you find a way to <strong>turn your program into a timed obstacle course</strong>?</p></li>&#13;
</ul>&#13;
<p><strong><em>You already know enough about Unity to start building interesting games—and that’s a great  way to get practice so you can keep getting better as a developer.</em></strong></p>&#13;
<blockquote>&#13;
<p><strong>This is your chance to experiment. Using your creativity is a really effective way to quickly build up your coding skills.</strong></p>&#13;
</blockquote>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="bullet_points-idd0028">&#13;
<h5>Bullet Points</h5>&#13;
<ul>&#13;
<li><p>When you bake the NavMesh, you can specify a <strong>maximum slope and step height</strong> to let NavMesh Agents navigate ramps and stairs in the scene.</p></li>&#13;
<li><p>You can also <strong>specify the agent height</strong> to create holes in the mesh around obstacles that are too low for the agent to get around.</p></li>&#13;
<li><p>When a NavMesh Agent moves a GameObject around a scene, it will <strong>avoid obstacles</strong> (and, optionally, other NavMesh Agents).</p></li>&#13;
<li><p>The label under the Scene Gizmo shows an icon to indicate if it is in <strong>perspective</strong> mode (distant objects look smaller than near objects) or <strong>isometric</strong> mode (all objects appear the same size no matter how far away they are). You can use this icon to toggle between the two views.</p></li>&#13;
<li><p>The <strong>transform.LookAt method</strong> makes a GameObject look at a position. You can use it to make the camera point at a GameObject in the scene.</p></li>&#13;
<li><p>Calling <strong>Input.GetAxis(“Mouse ScrollWheel”)</strong> returns a number (usually between –0.4 and 0.4) that represents how much the scroll wheel moved (or 0 if it didn’t move).</p></li>&#13;
<li><p>Calling <strong>Input.GetAxis(“Mouse Y”)</strong> lets you capture mouse movements up and down. You can combine it with OnMouseDrag to move a GameObject with the mouse.</p></li>&#13;
<li><p>Add a <strong>NavMesh Obstacle</strong> component to create obstacles that can carve moving holes in the NavMesh.</p></li>&#13;
<li><p>The Input class has methods to capture input during the Update method, like <strong>Input.GetAxis</strong> for mouse movement and <strong>Input.GetKey</strong> for keyboard input.</p></li>&#13;
</ul>&#13;
</div></aside>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Downloadable exercise: Animal match boss battle" data-type="sect1"><div class="sect1" id="downloadable_exercise_animal_match_boss">&#13;
<h1>Downloadable exercise: Animal match boss battle</h1>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/com25.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p>If you’ve played a lot of video games (and we’re pretty sure that you have!), then you’ve had to play through a whole lot of boss battles—those fights at the end of a level or section where you face off against an opponent that’s bigger and stronger than what you’ve seen so far. We have one last challenge for you before the end of the book—consider it the <em>Head First C#</em> boss battle.</p>&#13;
<p>In <a href="ch01.html#start_building_with_chash_build_somethin">#start_building_with_chash_build_somethin</a> you built an animal matching game. It was a great start, but it’s missing... something. Can you figure out how to turn your animal matching game into a memory game? Go to our GitHub page and download the PDF for this project—or if you want to play this boss battle in Hard mode, just dive right in and see if you can do it on your own.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg661.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<p><strong>There’s so much more downloadable material! The book may be over, but we can keep the learning going. We’ve put together even more downloadable material on important C# topics. We’ve also continued the Unity learning path with additional Unity Labs and even a Unity boss battle.</strong></p>&#13;
<p><strong>We hope you’ve learned a lot—and even more importantly, we hope your C# learning journey is just beginning. Great developers never stop learning.</strong></p>&#13;
<p><strong>Head to our GitHub page for more: <a href="https://github.com/head-first-csharp/fourth-edition">https://github.com/head-first-csharp/fourth-edition</a>.</strong></p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Thank you for reading our book!" data-type="sect1"><div class="sect1" id="thank_you_for_reading_our_bookexclamatio">&#13;
<h1>Thank you for reading our book!</h1>&#13;
<p>Pat yourself on the back—this is a real accomplishment! We hope this journey has been as rewarding for you as it has been for us, and that you’ve enjoyed all of the projects and the code that you’ve written along the way.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="But wait, there’s more! Your journey’s just begun..." data-type="sect1"><div class="sect1" id="but_waitcomma_thereapostrophes_moreexcla">&#13;
<h1>But wait, there’s more! Your journey’s just begun...</h1>&#13;
<p>In some chapters we gave you additional projects that you could download from our GitHub page: <a href="https://github.com/head-first-csharp/fourth-edition">https://github.com/head-first-csharp/fourth-edition</a>.</p>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg662-1.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Check out these great C# and .Net resources!</p>&#13;
<p>Get connected with the .NET Developer Community: <a href="https://dotnet.microsoft.com/platform/community">https://dotnet.microsoft.com/platform/community</a>.</p>&#13;
<p>Watch live streams and chat with the team that builds .NET and C#: <a href="https://dotnet.microsoft.com/platform/community/standup">https://dotnet.microsoft.com/platform/community/standup</a>.</p>&#13;
<p>Learn more in the docs: <a href="https://docs.microsoft.com/en-us/dotnet">https://docs.microsoft.com/en-us/dotnet</a>.</p>&#13;
</div>&#13;
<p>The GitHub page contains <strong>lots of additional material</strong>. There’s still more to learn, and more projects to do!</p>&#13;
<p><strong><em>Keep your C# learning journey going</em></strong> by downloading PDFs that continue the <em>Head First C#</em> story and cover <strong>essential C# topics</strong>, including:</p>&#13;
<ul>&#13;
<li><p>Event handlers</p></li>&#13;
<li><p>Delegates</p></li>&#13;
<li><p>The MVVM pattern (including a retro arcade game project)</p></li>&#13;
<li><p><strong><em>...and more!</em></strong></p></li>&#13;
</ul>&#13;
<p>And while you’re there, there’s <strong>more to learn about Unity</strong>. You can download:</p>&#13;
<ul>&#13;
<li><p>PDF versions of all of the Unity Labs in this book</p></li>&#13;
<li><p><strong><em>Even more Unity Labs</em></strong> that cover physics, collisions, and more!</p></li>&#13;
<li><p>A <strong>Unity Lab boss battle</strong> to put your Unity development skills to the test</p></li>&#13;
<li><p>A complete <strong>Unity Lab project</strong> to create a game from the ground up</p></li>&#13;
</ul>&#13;
</div></section>&#13;
<section data-pdf-bookmark="And check out these essential (and amazing!) books by some of our friends and colleagues, also published by O’REILLY" data-type="sect1"><div class="sect1" id="and_check_out_these_essential_left_paren">&#13;
<h1>And check out these essential (and <u>amazing!</u>) books by some of our friends and colleagues, also published by O’REILLY</h1>&#13;
<figure class="informal"><div class="figure">&#13;
<img alt="Images" src="assets/pg662-2.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</div></section>&#13;
</div></section></body></html>