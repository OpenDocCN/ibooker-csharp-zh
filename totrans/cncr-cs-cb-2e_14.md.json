["```cs\nstatic int _simpleValue;\nstatic readonly Lazy<int> MySharedInteger = new Lazy<int>(() => _simpleValue++);\n\nvoid UseSharedInteger()\n{\n  int sharedValue = MySharedInteger.Value;\n}\n```", "```cs\nstatic int _simpleValue;\nstatic readonly Lazy<Task<int>> MySharedAsyncInteger =\n    new Lazy<Task<int>>(async () =>\n    {\n      await Task.Delay(TimeSpan.FromSeconds(2)).ConfigureAwait(false);\n      return _simpleValue++;\n    });\n\nasync Task GetSharedIntegerAsync()\n{\n  int sharedValue = await MySharedAsyncInteger.Value;\n}\n```", "```cs\nstatic int _simpleValue;\nstatic readonly Lazy<Task<int>> MySharedAsyncInteger =\n  new Lazy<Task<int>>(() => Task.Run(async () =>\n  {\n    await Task.Delay(TimeSpan.FromSeconds(2));\n    return _simpleValue++;\n  }));\n\nasync Task GetSharedIntegerAsync()\n{\n  int sharedValue = await MySharedAsyncInteger.Value;\n}\n```", "```cs\npublic sealed class AsyncLazy<T>\n{\n  private readonly object _mutex;\n  private readonly Func<Task<T>> _factory;\n  private Lazy<Task<T>> _instance;\n\n  public AsyncLazy(Func<Task<T>> factory)\n  {\n    _mutex = new object();\n    _factory = RetryOnFailure(factory);\n    _instance = new Lazy<Task<T>>(_factory);\n  }\n\n  private Func<Task<T>> RetryOnFailure(Func<Task<T>> factory)\n  {\n    return async () =>\n    {\n      try\n      {\n        return await factory().ConfigureAwait(false);\n      }\n      catch\n      {\n        lock (_mutex)\n        {\n          _instance = new Lazy<Task<T>>(_factory);\n        }\n        throw;\n      }\n    };\n  }\n\n  public Task<T> Task\n  {\n    get\n    {\n      lock (_mutex)\n        return _instance.Value;\n    }\n  }\n}\n\nstatic int _simpleValue;\nstatic readonly AsyncLazy<int> MySharedAsyncInteger =\n  new AsyncLazy<int>(() => Task.Run(async () =>\n  {\n    await Task.Delay(TimeSpan.FromSeconds(2));\n    return _simpleValue++;\n  }));\n\nasync Task GetSharedIntegerAsync()\n{\n  int sharedValue = await MySharedAsyncInteger.Task;\n}\n```", "```cs\nstatic int _simpleValue;\nprivate static readonly AsyncLazy<int> MySharedAsyncInteger =\n  new AsyncLazy<int>(async () =>\n  {\n    await Task.Delay(TimeSpan.FromSeconds(2));\n    return _simpleValue++;\n  },\n  AsyncLazyFlags.RetryOnFailure);\n\npublic async Task UseSharedIntegerAsync()\n{\n  int sharedValue = await MySharedAsyncInteger;\n}\n```", "```cs\nvoid SubscribeWithDefer()\n{\n  var invokeServerObservable = Observable.Defer(\n      () => GetValueAsync().ToObservable());\n  invokeServerObservable.Subscribe(_ => { });\n  invokeServerObservable.Subscribe(_ => { });\n\n  Console.ReadKey();\n}\n\nasync Task<int> GetValueAsync()\n{\n  Console.WriteLine(\"Calling server...\");\n  await Task.Delay(TimeSpan.FromSeconds(2));\n  Console.WriteLine(\"Returning result...\");\n  return 13;\n}\n```", "```cs\nCalling server...\nCalling server...\nReturning result...\nReturning result...\n```", "```cs\nclass MyViewModel\n{\n  public MyViewModel()\n  {\n    MyValue = NotifyTask.Create(CalculateMyValueAsync());\n  }\n\n  public NotifyTask<int> MyValue { get; private set; }\n\n  private async Task<int> CalculateMyValueAsync()\n  {\n    await Task.Delay(TimeSpan.FromSeconds(10));\n    return 13;\n  }\n}\n```", "```cs\n<Grid>\n  <Label Content=\"Loading...\"\n      Visibility=\"{Binding MyValue.IsNotCompleted,\n Converter={StaticResource BooleanToVisibilityConverter}}\"/>\n  <Label Content=\"{Binding MyValue.Result}\"\n      Visibility=\"{Binding MyValue.IsSuccessfullyCompleted,\n Converter={StaticResource BooleanToVisibilityConverter}}\"/>\n  <Label Content=\"An error occurred\" Foreground=\"Red\"\n      Visibility=\"{Binding MyValue.IsFaulted,\n Converter={StaticResource BooleanToVisibilityConverter}}\"/>\n</Grid>\n```", "```cs\nclass BindableTask<T> : INotifyPropertyChanged\n{\n  private readonly Task<T> _task;\n\n  public BindableTask(Task<T> task)\n  {\n    _task = task;\n    var _ = WatchTaskAsync();\n  }\n\n  private async Task WatchTaskAsync()\n  {\n    try\n    {\n      await _task;\n    }\n    catch\n    {\n    }\n\n    OnPropertyChanged(\"IsNotCompleted\");\n    OnPropertyChanged(\"IsSuccessfullyCompleted\");\n    OnPropertyChanged(\"IsFaulted\");\n    OnPropertyChanged(\"Result\");\n  }\n\n  public bool IsNotCompleted { get { return !_task.IsCompleted; } }\n  public bool IsSuccessfullyCompleted\n  {\n    get { return _task.Status == TaskStatus.RanToCompletion; }\n  }\n  public bool IsFaulted { get { return _task.IsFaulted; } }\n  public T Result\n  {\n    get { return IsSuccessfullyCompleted ? _task.Result : default; }\n  }\n\n  public event PropertyChangedEventHandler PropertyChanged;\n\n  protected virtual void OnPropertyChanged(string propertyName)\n  {\n    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));\n  }\n}\n```", "```cs\nprivate static AsyncLocal<Guid> _operationId = new AsyncLocal<Guid>();\n\nasync Task DoLongOperationAsync()\n{\n  _operationId.Value = Guid.NewGuid();\n\n  await DoSomeStepOfOperationAsync();\n}\n\nasync Task DoSomeStepOfOperationAsync()\n{\n  await Task.Delay(100); // Some async work\n\n  // Do some logging here.\n  Trace.WriteLine(\"In operation: \" + _operationId.Value);\n}\n```", "```cs\ninternal sealed class AsyncLocalGuidStack\n{\n  private readonly AsyncLocal<ImmutableStack<Guid>> _operationIds =\n      new AsyncLocal<ImmutableStack<Guid>>();\n\n  private ImmutableStack<Guid> Current =>\n      _operationIds.Value ?? ImmutableStack<Guid>.Empty;\n\n  public IDisposable Push(Guid value)\n  {\n    _operationIds.Value = Current.Push(value);\n    return new PopWhenDisposed(this);\n  }\n\n  private void Pop()\n  {\n    ImmutableStack<Guid> newValue = Current.Pop();\n    if (newValue.IsEmpty)\n      newValue = null;\n    _operationIds.Value = newValue;\n  }\n\n  public IEnumerable<Guid> Values => Current;\n\n  private sealed class PopWhenDisposed : IDisposable\n  {\n    private AsyncLocalGuidStack _stack;\n\n    public PopWhenDisposed(AsyncLocalGuidStack stack) =>\n        _stack = stack;\n\n    public void Dispose()\n    {\n      _stack?.Pop();\n      _stack = null;\n    }\n  }\n}\n\nprivate static AsyncLocalGuidStack _operationIds = new AsyncLocalGuidStack();\n\nasync Task DoLongOperationAsync()\n{\n  using (_operationIds.Push(Guid.NewGuid()))\n    await DoSomeStepOfOperationAsync();\n}\n\nasync Task DoSomeStepOfOperationAsync()\n{\n  await Task.Delay(100); // some async work\n\n  // Do some logging here.\n  Trace.WriteLine(\"In operation: \" +\n      string.Join(\":\", _operationIds.Values));\n}\n```", "```cs\nprivate async Task<int> DelayAndReturnCore(bool sync)\n{\n  int value = 100;\n\n  // Do some work.\n  if (sync)\n    Thread.Sleep(value); // Call synchronous API.\n  else\n    await Task.Delay(value); // Call asynchronous API.\n\n  return value;\n}\n\n// Asynchronous API\npublic Task<int> DelayAndReturnAsync() =>\n    DelayAndReturnCore(sync: false);\n\n// Synchronous API\npublic int DelayAndReturn() =>\n    DelayAndReturnCore(sync: true).GetAwaiter().GetResult();\n```", "```cs\nprivate static TransformBlock<Try<TInput>, Try<TOutput>>\n    RailwayTransform<TInput, TOutput>(Func<TInput, TOutput> func)\n{\n  return new TransformBlock<Try<TInput>, Try<TOutput>>(t => t.Map(func));\n}\n```", "```cs\nvar subtractBlock = RailwayTransform<int, int>(value => value - 2);\nvar divideBlock = RailwayTransform<int, int>(value => 60 / value);\nvar multiplyBlock = RailwayTransform<int, int>(value => value * 2);\n\nvar options = new DataflowLinkOptions { PropagateCompletion = true };\nsubtractBlock.LinkTo(divideBlock, options);\ndivideBlock.LinkTo(multiplyBlock, options);\n\n// Insert data items into the first block.\nsubtractBlock.Post(Try.FromValue(5));\nsubtractBlock.Post(Try.FromValue(2));\nsubtractBlock.Post(Try.FromValue(4));\nsubtractBlock.Complete();\n\n// Receive data/exception items from the last block.\nwhile (await multiplyBlock.OutputAvailableAsync())\n{\n  Try<int> item = await multiplyBlock.ReceiveAsync();\n  if (item.IsValue)\n    Console.WriteLine(item.Value);\n  else\n    Console.WriteLine(item.Exception.Message);\n}\n```", "```cs\nprivate string Solve(IProgress<int> progress)\n{\n  // Count as quickly as possible for 3 seconds.\n  var endTime = DateTime.UtcNow.AddSeconds(3);\n  int value = 0;\n  while (DateTime.UtcNow < endTime)\n  {\n    value++;\n    progress?.Report(value);\n  }\n  return value.ToString();\n}\n```", "```cs\n// For simplicity, this code updates a label directly.\n// In a real-world MVVM application, those assignments\n//  would instead be updating a ViewModel property\n//  which is data-bound to the actual UI.\nprivate async void StartButton_Click(object sender, RoutedEventArgs e)\n{\n  MyLabel.Content = \"Starting...\";\n  var progress = new Progress<int>(value => MyLabel.Content = value);\n  var result = await Task.Run(() => Solve(progress));\n  MyLabel.Content = $\"Done! Result: {result}\";\n}\n```", "```cs\npublic static class ObservableProgress\n{\n  private sealed class EventProgress<T> : IProgress<T>\n  {\n    void IProgress<T>.Report(T value) => OnReport?.Invoke(value);\n    public event Action<T> OnReport;\n  }\n\n  public static (IObservable<T>, IProgress<T>) Create<T>()\n  {\n    var progress = new EventProgress<T>();\n    var observable = Observable.FromEvent<T>(\n        handler => progress.OnReport += handler,\n        handler => progress.OnReport -= handler);\n    return (observable, progress);\n  }\n}\n```", "```cs\npublic static class ObservableProgress\n{\n  // Note: this must be called from the UI thread.\n  public static (IObservable<T>, IProgress<T>) CreateForUi<T>(\n      TimeSpan? sampleInterval = null)\n  {\n    var (observable, progress) = Create<T>();\n    observable = observable\n        .Sample(sampleInterval ?? TimeSpan.FromMilliseconds(100))\n        .ObserveOn(SynchronizationContext.Current);\n    return (observable, progress);\n  }\n}\n```", "```cs\n// For simplicity, this code updates a label directly.\n// In a real-world MVVM application, those assignments\n//  would instead be updating a ViewModel property\n//  which is data-bound to the actual UI.\nprivate async void StartButton_Click(object sender, RoutedEventArgs e)\n{\n  MyLabel.Content = \"Starting...\";\n  var (observable, progress) = ObservableProgress.CreateForUi<int>();\n  string result;\n  using (observable.Subscribe(value => MyLabel.Content = value))\n    result = await Task.Run(() => Solve(progress));\n  MyLabel.Content = $\"Done! Result: {result}\";\n}\n```"]