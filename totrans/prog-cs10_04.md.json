["```cs\npublic class NamedContainer<T>\n{\n    public NamedContainer(T item, string name)\n    {\n        Item = item;\n        Name = name;\n    }\n\n    public T Item { get; }\n    public string Name { get; }\n}\n```", "```cs\npublic record NamedContainer<T>(T Item, string Name);\n```", "```cs\nvar a = new NamedContainer<int>(42, \"The answer\");\nvar b = new NamedContainer<int>(99, \"Number of red balloons\");\nvar c = new NamedContainer<string>(\"Programming C#\", \"Book title\");\n```", "```cs\n// ...where a, and b come from ExampleÂ 4-3. var namedInts = new List<NamedContainer<int>>() { a, b };\nvar namedNamedItem = new NamedContainer<NamedContainer<int>>(a, \"Wrapped\");\n```", "```cs\n// For illustration only. Consider using Lazy<T> in a real program. public static class Deferred<T>\n    `where` `T` `:` `new``(``)`\n{\n    private static T? _instance;\n\n    public static T Instance\n    {\n        get\n        {\n            if (_instance == null)\n            {\n                `_instance` `=` `new` `T``(``)``;`\n            }\n            return _instance;\n        }\n    }\n}\n```", "```cs\npublic class GenericComparer<T> : IComparer<T>\n    `where` `T` `:` `IComparable``<``T``>`\n{\n    public int Compare(T? x, T? y)\n    {\n        if (x == null) { return y == null ? 0 : -1; }\n        return x.CompareTo(y);\n    }\n}\n```", "```cs\npublic class GenericComparer<T> : IComparer<T>\n{\n    public int Compare(IComparable<T>? x, T? y)\n    {\n        if (x == null) { return y == null ? 0 : -1; }\n        return x.CompareTo(y);\n    }\n}\n```", "```cs\npublic class GenericComparer<T> : IComparer<T>\n{\n    public int Compare(T? x, T? y)\n    {\n        if (x == null) { return y == null ? 0 : -1; }\n        return x.CompareTo(y);\n    }\n}\n```", "```cs\npublic class Foo<T1, T2>\n    where T1 : T2\n...\n```", "```cs\npublic class Bar<T>\n    where T : class\n...\n```", "```cs\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\nusing Moq;\n\npublic class TestBase<TSubject, TFake>\n    where TSubject : new()\n    where TFake : class\n{\n    public TSubject? Subject { get; private set; }\n    public Mock<TFake>? Fake { get; private set; }\n\n [TestInitialize]\n    public void Initialize()\n    {\n        Subject = new TSubject();\n        Fake = new Mock<TFake>();\n    }\n}\n```", "```cs\npublic class Quux<T>\n    where T : struct\n...\n```", "```cs\npublic class RequireDelegate<T>\n    where T : Delegate\n{\n}\n\npublic class RequireEnum<T>\n    where T : Enum\n{\n}\n```", "```cs\npublic class Spong<T>\n    where T : IEnumerable<T>, IDisposable, new()\n...\n```", "```cs\nstatic void ShowDefault<T>()\n{\n    Console.WriteLine(default(T));\n}\n```", "```cs\nstatic T? GetDefault<T>() => default;\n```", "```cs\npublic static T GetLast<T>(T[] items) => items[^1];\n```", "```cs\nint[] values = { 1, 2, 3 };\nint last = GetLast<int>(values);\n```", "```cs\npublic static T MakeFake<T>()\n    where T : class\n{\n    return new Mock<T>().Object;\n}\n```", "```cs\nint[] values = { 1, 2, 3 };\nint last = GetLast(values);\n```", "```cs\n(int, int) p = (42, 99);\n```", "```cs\nValueTuple<int, int> p2 = (42, 99);\n```", "```cs\npublic static (int X, int Y) Pos() => (10, 20);\n```", "```cs\npublic static T Add<T>(T x, T y)\n{\n    return x + y;  // Will not compile\n}\n```"]