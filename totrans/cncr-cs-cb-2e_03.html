<html><head></head><body><section data-pdf-bookmark="Chapter 3. Asynchronous Streams" data-type="chapter" epub:type="chapter"><div class="chapter" id="async-streams">&#13;
<h1><span class="label">Chapter 3. </span>Asynchronous Streams</h1>&#13;
&#13;
&#13;
<p><em>Asynchronous streams</em> are <a data-primary="asynchronous streams" data-secondary="overview" data-type="indexterm" id="ch3over"/><a data-primary="asynchronous enumerables" data-type="indexterm" id="idm45458703862696"/><a data-primary="enumerables" data-secondary="asynchronous" data-type="indexterm" id="idm45458703862056"/><a data-primary="IAsyncEnumerable type" data-type="indexterm" id="idm45458703861112"/>a way to asynchronously receive multiple data items. They’re built on <em>asynchronous enumerables</em> (<code>IAsyncEnumerable&lt;T&gt;</code>). An asynchronous enumerable is an asynchronous version of an enumerable; that is, it can produce items on demand for a consumer, and each item may be produced asynchronously.</p>&#13;
&#13;
<p>I find it useful to contrast asynchronous streams with other types that may be more familiar and to consider the differences. This helps me remember when to use asynchronous streams and when other types would be more appropriate.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="orm:non-recipe" data-pdf-bookmark="Asynchronous Streams and Task&lt;T&gt;" data-type="sect1"><div class="sect1" id="idm45458703858664">&#13;
<h1>Asynchronous Streams and Task&lt;T&gt;</h1>&#13;
&#13;
<p>The <a data-primary="tasks" data-secondary="compared to asynchronous streams" data-type="indexterm" id="idm45458703857048"/><a data-primary="asynchronous streams" data-secondary="compared to tasks" data-type="indexterm" id="idm45458703855704"/>standard asynchronous approach with <code>Task&lt;T&gt;</code> is only sufficient for asynchronously handling a single data value. Once a given <code>Task&lt;T&gt;</code> completes, that’s it; a single <code>Task&lt;T&gt;</code> cannot provide more than one value of <code>T</code> for its consumers. Even if <code>T</code> is a collection, the value can only be provided once. See <a data-type="xref" href="ch01.html#intro-async">“Introduction to Asynchronous Programming”</a> and <a data-type="xref" href="ch02.html#async-basics">Chapter 2</a> for more on using <code>async</code> with <code>Task&lt;T&gt;</code>.</p>&#13;
&#13;
<p>When comparing <code>Task&lt;T&gt;</code> to asynchronous streams, the asynchronous streams are more similar to enumerables. Specifically, an <code>IAsyncEnumerator&lt;T&gt;</code> may provide any number of <code>T</code> values, one at a time. Like <code>IEnumerator&lt;T&gt;</code>, an <code>IAsyncEnumerator&lt;T&gt;</code> may be infinite in length.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="orm:non-recipe" data-pdf-bookmark="Asynchronous Streams and IEnumerable&lt;T&gt;" data-type="sect1"><div class="sect1" id="idm45458703816088">&#13;
<h1>Asynchronous Streams and IEnumerable&lt;T&gt;</h1>&#13;
&#13;
<p><code>IAsyncEnumerable&lt;T&gt;</code>, as the name would imply, is similar to <code>IEnumerable&lt;T&gt;</code>. This is perhaps not a surprise; they both enable consumers to retrieve elements from them one at a time. The big difference is in the name: one is asynchronous and the other is not.</p>&#13;
&#13;
<p>When your code iterates over an <code>IEnumerable&lt;T&gt;</code>, it blocks as it retrieves each element from the enumerable. If the <code>IEnumerable&lt;T&gt;</code> is representing some I/O-bound operation, such as a database query or API call, then the consuming code ends up blocking on I/O, which is not ideal. <code>IAsyncEnumerable&lt;T&gt;</code> works just like an <code>IEnumerable&lt;T&gt;</code>, except that it asynchronously retrieves each next element.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="orm:non-recipe" data-pdf-bookmark="Asynchronous Streams and Task&lt;IEnumerable&lt;T&gt;&gt;" data-type="sect1"><div class="sect1" id="idm45458703811304">&#13;
<h1>Asynchronous Streams and Task&lt;IEnumerable&lt;T&gt;&gt;</h1>&#13;
&#13;
<p>It is <a data-primary="tasks" data-secondary="collections returned by" data-type="indexterm" id="idm45458703809448"/>entirely possible to asynchronously return a collection with more than one item; one common example is <code>Task&lt;List&lt;T&gt;&gt;</code>. Still, <code>async</code> methods that return <code>List&lt;T&gt;</code> only get one <code>return</code> statement; the collection must be completely populated before it is returned. Even methods returning <code>Task&lt;IEnumerable&lt;T&gt;&gt;</code> may asynchronously return an enumerable, but then that enumerable is evaluated synchronously. Consider that LINQ-to-Entities has a <code>ToListAsync</code> LINQ method that returns <code>Task&lt;List&lt;T&gt;&gt;</code>. When a LINQ provider executes this, it has to communicate with the database and get <em>all</em> the matching responses back before it can finish populating the list and return it.</p>&#13;
&#13;
<p>The limitation of <code>Task&lt;IEnumerable&lt;T&gt;&gt;</code> is that it cannot return items as it gets them; if returning a collection, it has to load all of its items into memory, populate the collection, and then return the entire collection all at once. Even if it returns a LINQ query, it can asynchronously build that query, but once the query is returned, each item is retrieved from that query synchronously. <code>IAsyncEnumerable&lt;T&gt;</code> also returns multiple items asynchronously, but the difference is that <code>IAsyncEnumerable&lt;T&gt;</code> can act asynchronously for <em>each</em> item returned. It’s a true asynchronous stream of items.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="orm:non-recipe" data-pdf-bookmark="Asynchronous Streams and IObservable&lt;T&gt;" data-type="sect1"><div class="sect1" id="idm45458703801656">&#13;
<h1>Asynchronous Streams and IObservable&lt;T&gt;</h1>&#13;
&#13;
<p>Observables <a data-primary="observable streams" data-secondary="compared to asynchronous streams" data-type="indexterm" id="idm45458703799640"/><a data-primary="asynchronous streams" data-secondary="compared to observable streams" data-type="indexterm" id="idm45458703798600"/>are a true notion of asynchronous streams; they produce their notifications one at a time with true support for asynchronous production (no blocking). But the consumption pattern for <code>IObservable&lt;T&gt;</code> is completely different than that of <code>IAsyncEnumerable&lt;T&gt;</code>. See <a data-type="xref" href="ch06.html#rx-basics">Chapter 6</a> for more details about <code>IObservable&lt;T&gt;</code>.</p>&#13;
&#13;
<p>To consume an <code>IObservable&lt;T&gt;</code>, code needs to define a LINQ-like query through which the observable notifications will flow, and then subscribe to the observable in order to start the flow. When working with observables, the code first defines how it will <em>react</em> to the incoming notifications, and then it turns them on (hence the name “reactive”). In contrast, consuming an <code>IAsyncEnumerable&lt;T&gt;</code> is done very similarly to consuming an <code>IEnumerable&lt;T&gt;</code>, except that the consumption is asynchronous.</p>&#13;
&#13;
<p>There <a data-primary="backpressure" data-secondary="with observable streams" data-type="indexterm" id="idm45458703792312"/><a data-primary="reactive programming" data-secondary="backpressure problem with" data-type="indexterm" id="idm45458703791304"/><a data-primary="notifications" data-secondary="in reactive programming" data-secondary-sortas="reactive" data-type="indexterm" id="idm45458703790344"/>is also a backpressure problem; all notifications in System.Reactive are synchronous, so as soon as one item notification is sent to its subscribers, the observable continues execution and retrieves the next item to publish, possibly calling the API again. If the consuming code is consuming the stream asynchronously (i.e., doing some asynchronous action for each notification as it arrives), then the observable will race ahead of the consuming code.</p>&#13;
&#13;
<p>A nice way of thinking about the difference between them is that <code>IObservable&lt;T&gt;</code> is push-based and <code>IAsyncEnumerable&lt;T&gt;</code> is pull-based. An observable stream will push notifications at your code, but an asynchronous stream will passively let your code (asynchronously) pull data items out of it. Only when the consuming code requests the next item does the observable stream resume execution.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="orm:non-recipe" data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45458703786872">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>A theoretical example may be useful. Many APIs take <code>offset</code> and <code>limit</code> parameters to enable paging of results. Let’s say we wanted to define a method that retrieves results from an API that does paging, and we want our method to handle the paging so that our higher-level methods don’t have to deal with that.</p>&#13;
&#13;
<p>If <a data-primary="tasks" data-secondary="compared to asynchronous streams" data-type="indexterm" id="idm45458703783336"/><a data-primary="asynchronous streams" data-secondary="compared to tasks" data-type="indexterm" id="idm45458703782360"/>our method returns <code>Task&lt;T&gt;</code>, we are limited to returning only a single <code>T</code>. This is fine for a single call to the API where the <code>T</code> is the result of the API, but it doesn’t work well as a return type if we want our method to call the API multiple times.</p>&#13;
&#13;
<p>If our method returns <code>IEnumerable&lt;T&gt;</code>, we can create a loop, paging through the API results by calling it multiple times. Each time the method calls the API, it would <code>yield return</code> the results of that page. Further API calls are only necessary if the enumeration continues. Unfortunately, methods returning <code>IEnumerable&lt;T&gt;</code> cannot be asynchronous, so all our API calls are forced to be synchronous.</p>&#13;
&#13;
<p>If <a data-primary="tasks" data-secondary="collections returned by" data-type="indexterm" id="idm45458703777368"/>our method returns Task&lt;List&lt;T&gt;&gt;, then we can have a loop that pages through the API results, calling the API asynchronously. However, the code cannot return each item as it gets the response; it would have to build up all the results and return them all at once.</p>&#13;
&#13;
<p>If <a data-primary="observable streams" data-secondary="compared to asynchronous streams" data-type="indexterm" id="idm45458703775576"/><a data-primary="asynchronous streams" data-secondary="compared to observable streams" data-type="indexterm" id="idm45458703774552"/>our method returns <code>IObservable&lt;T&gt;</code>, we can use <code>System.Reactive</code> to implement an observable stream that begins requests when subscribed to and publishes each item as we get them. The abstraction is push-based; it appears to consuming code that the API results are being pushed to them, which is more awkward to handle. <code>IObservable&lt;T&gt;</code> would be a better fit for scenarios like receiving and responding to WebSocket/SignalR messages.</p>&#13;
&#13;
<p>If <a data-primary="asynchronous enumerables" data-type="indexterm" id="idm45458703771160"/><a data-primary="enumerables" data-secondary="asynchronous" data-type="indexterm" id="idm45458703770440"/><a data-primary="IAsyncEnumerable type" data-type="indexterm" id="idm45458703769464"/>our method returns <code>IAsyncEnumerable&lt;T&gt;</code>, we can have a natural loop that uses both <code>await</code> and <code>yield return</code> to create a true pull-based asynchronous stream. <code>IAsyncEnumerable&lt;T&gt;</code> is the natural fit for this kind of <a data-startref="ch3over" data-type="indexterm" id="idm45458703766840"/>scenario.</p>&#13;
&#13;
<p><a data-type="xref" href="#type-classification">Table 3-1</a> summarizes the different roles of common types.</p>&#13;
<table id="type-classification">&#13;
<caption><span class="label">Table 3-1. </span>Type classifications</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Type</th>&#13;
<th>Single or multiple value</th>&#13;
<th>Asynchronous or synchronous</th>&#13;
<th>Push or pull</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>T</code></p></td>&#13;
<td><p>Single value</p></td>&#13;
<td><p>Synchronous</p></td>&#13;
<td><p>N/A</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>IEnumerable&lt;T&gt;</code></p></td>&#13;
<td><p>Multiple values</p></td>&#13;
<td><p>Synchronous</p></td>&#13;
<td><p>N/A</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>Task&lt;T&gt;</code></p></td>&#13;
<td><p>Single value</p></td>&#13;
<td><p>Asynchronous</p></td>&#13;
<td><p>Pull</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>IAsyncEnumerable&lt;T&gt;</code></p></td>&#13;
<td><p>Multiple values</p></td>&#13;
<td><p>Asynchronous</p></td>&#13;
<td><p>Pull</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>IObservable&lt;T&gt;</code></p></td>&#13;
<td><p>Single or multiple</p></td>&#13;
<td><p>Asynchronous</p></td>&#13;
<td><p>Push</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>As this book goes to press, .NET Core 3.0 is still in beta, so the details around asynchronous streams may change.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="3.1 Creating Asynchronous Streams" data-type="sect1"><div class="sect1" id="recipe-async-streams-produce">&#13;
<h1>3.1 Creating Asynchronous Streams</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458703743000">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="asynchronous streams" data-secondary="creating" data-type="indexterm" id="ch3r1a"/>need to return multiple values, and each value may require some asynchronous work. This point is commonly reached from one of two paths:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>You have multiple values to return (as an <code>IEnumerable&lt;T&gt;</code>), and then need to add asynchronous work.</p>&#13;
</li>&#13;
<li>&#13;
<p>You have a single asynchronous return (as a <code>Task&lt;T&gt;</code>), and then need to add other return values.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458703736616">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Returning <a data-primary="yield return statement" data-type="indexterm" id="ch3r1b"/><a data-primary="asynchronous enumerables" data-type="indexterm" id="idm45458703733912"/><a data-primary="enumerables" data-secondary="asynchronous" data-type="indexterm" id="idm45458703733192"/><a data-primary="IAsyncEnumerable type" data-type="indexterm" id="idm45458703732248"/>multiple values from a method can be done with <code>yield return</code>, and asynchronous methods use <code>async</code> and <code>await</code>. With asynchronous streams, you can combine these two; just use a return type of <code>IAsyncEnumerable&lt;T&gt;</code>:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">async</code> <code class="n">IAsyncEnumerable</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">GetValuesAsync</code><code class="p">()</code>&#13;
<code class="p">{</code>&#13;
  <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="m">1000</code><code class="p">);</code> <code class="c1">// some asynchronous work</code>&#13;
  <code class="k">yield</code> <code class="k">return</code> <code class="m">10</code><code class="p">;</code>&#13;
  <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="m">1000</code><code class="p">);</code> <code class="c1">// more asynchronous work</code>&#13;
  <code class="k">yield</code> <code class="k">return</code> <code class="m">13</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This simple example illustrates how <code>await</code> can be used with <code>yield return</code> to create an asynchronous stream.</p>&#13;
&#13;
<p>A more real-world example is asynchronously enumerating over all the results of an API that uses parameters for paging:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">async</code> <code class="n">IAsyncEnumerable</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">GetValuesAsync</code><code class="p">(</code><code class="n">HttpClient</code> <code class="n">client</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="kt">int</code> <code class="n">offset</code> <code class="p">=</code> <code class="m">0</code><code class="p">;</code>&#13;
  <code class="k">const</code> <code class="kt">int</code> <code class="n">limit</code> <code class="p">=</code> <code class="m">10</code><code class="p">;</code>&#13;
  <code class="k">while</code> <code class="p">(</code><code class="k">true</code><code class="p">)</code>&#13;
  <code class="p">{</code>&#13;
    <code class="c1">// Get the current page of results and parse them.</code>&#13;
    <code class="kt">string</code> <code class="n">result</code> <code class="p">=</code> <code class="k">await</code> <code class="n">client</code><code class="p">.</code><code class="n">GetStringAsync</code><code class="p">(</code>&#13;
        <code class="err">$</code><code class="s">"https://example.com/api/values?offset={offset}&amp;limit={limit}"</code><code class="p">);</code>&#13;
    <code class="kt">string</code><code class="p">[]</code> <code class="n">valuesOnThisPage</code> <code class="p">=</code> <code class="n">result</code><code class="p">.</code><code class="n">Split</code><code class="p">(</code><code class="sc">'\n'</code><code class="p">);</code>&#13;
&#13;
    <code class="c1">// Produce the results for this page.</code>&#13;
    <code class="k">foreach</code> <code class="p">(</code><code class="kt">string</code> <code class="k">value</code> <code class="k">in</code> <code class="n">valuesOnThisPage</code><code class="p">)</code>&#13;
      <code class="k">yield</code> <code class="k">return</code> <code class="k">value</code><code class="p">;</code>&#13;
&#13;
    <code class="c1">// If this is the last page, we're done.</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="n">valuesOnThisPage</code><code class="p">.</code><code class="n">Length</code> <code class="p">!=</code> <code class="n">limit</code><code class="p">)</code>&#13;
      <code class="k">break</code><code class="p">;</code>&#13;
&#13;
    <code class="c1">// Otherwise, proceed to the next page.</code>&#13;
    <code class="n">offset</code> <code class="p">+=</code> <code class="n">limit</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>When <code>GetValuesAsync</code> starts, it does an asynchronous request for the first page of data, and then produces the first element. When the second element is then requested, <code>GetValuesAsync</code> produces it immediately, since it is also in that same first page of data. The next element is also in that page, and so on, up to 10 elements. Then, when the 11th element is requested, all the values in <code>valuesOnThisPage</code> will have been produced, so there are no more elements on the first page. <code>GetValuesAsync</code> will continue executing its <code>while</code> loop, proceed to the next page, do an asynchronous request for the second page of data, receive back a new batch of values, and then it’ll produce the 11th element.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458703582232">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Ever since <code>async</code> and <code>await</code> were introduced, users have been wondering how to use them with <code>yield return</code>. For many years, that wasn’t possible, but asynchronous streams has now brought this capability to C# and modern versions of .NET.</p>&#13;
&#13;
<p>One thing you may notice with the more realistic example is that only some of the results need any asynchronous work. In that example, with a page length of 10, only about 1 out of every 10 elements will need asynchronous work. If the page size is 20, then only 1 out of every 20 elements will need asynchronous work.</p>&#13;
&#13;
<p>This <a data-primary="ValueTask type" data-type="indexterm" id="idm45458703577816"/>is a normal pattern with asynchronous streams. For many streams,  the majority of asynchronous iteration is actually synchronous; asynchronous streams merely <em>allow</em> any next item to be retrieved asynchronously. Asynchronous streams were designed with both asynchronous and synchronous code in mind; this is why asynchronous streams are built on <code>ValueTask&lt;T&gt;</code>. By using <code>ValueTask&lt;T&gt;</code> under the hood, asynchronous streams maximize their efficiency, whether items are retrieved synchronously or asynchronously. See <a data-type="xref" href="ch02.html#recipe-async-implement-valuetask">Recipe 2.10</a> for more about <code>ValueTask&lt;T&gt;</code> and when it is appropriate to use.</p>&#13;
&#13;
<p>When you do implement asynchronous streams, consider supporting cancellation. See <a data-type="xref" href="#recipe-async-streams-cancellation">Recipe 3.4</a> for a detailed discussion of cancellation with asynchronous streams. Some scenarios do not require actual cancellation; the consuming code can always choose not to retrieve the next element. That is a perfectly fine approach if there’s no external source for the cancellation. If you have an asynchronous stream where you want to cancel the asynchronous stream, even if it’s in the middle of getting the next element, then you’d want to support proper cancellation <a data-startref="ch3r1a" data-type="indexterm" id="idm45458703572392"/><a data-startref="ch3r1b" data-type="indexterm" id="idm45458703571720"/>using a <code>CancellationToken</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458703570376">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="#recipe-async-streams-consume">Recipe 3.2</a> covers consuming asynchronous streams.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-async-streams-cancellation">Recipe 3.4</a> covers handling cancellation for asynchronous streams.</p>&#13;
&#13;
<p><a data-type="xref" href="ch02.html#recipe-async-implement-valuetask">Recipe 2.10</a> has more detail about <code>ValueTask&lt;T&gt;</code> and when it is appropriate to use.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="3.2 Consuming Asynchronous Streams" data-type="sect1"><div class="sect1" id="recipe-async-streams-consume">&#13;
<h1>3.2 Consuming Asynchronous Streams</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458703563608">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="asynchronous streams" data-secondary="consuming" data-type="indexterm" id="ch3r2a"/>need to process the results of an asynchronous stream, also known as an asynchronous enumerable.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458703560504">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Consuming <a data-primary="await foreach statement" data-type="indexterm" id="ch3r2b"/><a data-primary="asynchronous enumerables" data-type="indexterm" id="idm45458703557736"/><a data-primary="enumerables" data-secondary="asynchronous" data-type="indexterm" id="idm45458703557048"/><a data-primary="IAsyncEnumerable type" data-type="indexterm" id="idm45458703556104"/>an asynchronous operation is done via <code>await</code>, and consuming an enumerable is usually done via <code>foreach</code>. Consuming an asynchronous enumerable is done by combining these two into <code>await foreach</code>. For example, given an asynchronous enumerable that pages over API responses, you can consume it and write each element to the console:</p>&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="n">IAsyncEnumerable</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">GetValuesAsync</code><code class="p">(</code><code class="n">HttpClient</code> <code class="n">client</code><code class="p">);</code>&#13;
&#13;
<code class="k">public</code> <code class="k">async</code> <code class="n">Task</code> <code class="nf">ProcessValueAsync</code><code class="p">(</code><code class="n">HttpClient</code> <code class="n">client</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="k">await</code> <code class="k">foreach</code> <code class="p">(</code><code class="kt">string</code> <code class="k">value</code> <code class="k">in</code> <code class="n">GetValuesAsync</code><code class="p">(</code><code class="n">client</code><code class="p">))</code>&#13;
  <code class="p">{</code>&#13;
    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="k">value</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Conceptually, what is happening here is that <code>GetValuesAsync</code> is invoked, and it returns an <code>IAsyncEnumerable&lt;T&gt;</code>. The <code>foreach</code> then creates an asynchronous enumerator from that asynchronous enumerable. Asynchronous enumerators are logically similar to regular enumerators, except that their “get next element” operation may be asynchronous. So, the <code>await foreach</code> will <code>await</code> for the next element to arrive or for the asynchronous enumerator to complete. If an element arrived, <code>await foreach</code> will execute its loop body; if the asynchronous enumerator is complete, then the loop will exit.</p>&#13;
&#13;
<p>It is also natural to do asynchronous processing of each element:</p>&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="n">IAsyncEnumerable</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">GetValuesAsync</code><code class="p">(</code><code class="n">HttpClient</code> <code class="n">client</code><code class="p">);</code>&#13;
&#13;
<code class="k">public</code> <code class="k">async</code> <code class="n">Task</code> <code class="nf">ProcessValueAsync</code><code class="p">(</code><code class="n">HttpClient</code> <code class="n">client</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="k">await</code> <code class="k">foreach</code> <code class="p">(</code><code class="kt">string</code> <code class="k">value</code> <code class="k">in</code> <code class="n">GetValuesAsync</code><code class="p">(</code><code class="n">client</code><code class="p">))</code>&#13;
  <code class="p">{</code>&#13;
    <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="m">100</code><code class="p">);</code> <code class="c1">// asynchronous work</code>&#13;
    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="k">value</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In this case, the <code>await foreach</code> won’t proceed to the next element until the loop body is complete. So, the <code>await foreach</code> will asynchronously receive the first element, then asynchronously execute the loop body for that first element, then asynchronously receive the next element, then asynchronously execute the loop body for that next element, and so on.</p>&#13;
&#13;
<p>There is an <code>await</code> buried in the <code>await foreach</code>: the “get next element” operation is awaited. With a regular <code>await</code>, you can avoid the implicitly captured context by using <code>ConfigureAwait(false)</code>, as described in <a data-type="xref" href="ch02.html#recipe-async-configureawait">Recipe 2.7</a>. Asynchronous streams also support <code>ConfigureAwait(false)</code>, which is passed to the hidden <code>await</code> statements:</p>&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="n">IAsyncEnumerable</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">GetValuesAsync</code><code class="p">(</code><code class="n">HttpClient</code> <code class="n">client</code><code class="p">);</code>&#13;
&#13;
<code class="k">public</code> <code class="k">async</code> <code class="n">Task</code> <code class="nf">ProcessValueAsync</code><code class="p">(</code><code class="n">HttpClient</code> <code class="n">client</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="k">await</code> <code class="k">foreach</code> <code class="p">(</code><code class="kt">string</code> <code class="k">value</code> <code class="k">in</code> <code class="n">GetValuesAsync</code><code class="p">(</code><code class="n">client</code><code class="p">).</code><code class="n">ConfigureAwait</code><code class="p">(</code><code class="k">false</code><code class="p">))</code>&#13;
  <code class="p">{</code>&#13;
    <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="m">100</code><code class="p">).</code><code class="n">ConfigureAwait</code><code class="p">(</code><code class="k">false</code><code class="p">);</code> <code class="c1">// asynchronous work</code>&#13;
    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="k">value</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458703445144">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p><code>await foreach</code> is the most natural way to consume asynchronous streams. The language supports <code>ConfigureAwait(false)</code> for avoiding context in <code>await foreach</code>.</p>&#13;
&#13;
<p>It’s also possible to pass in cancellation tokens; this is a bit more advanced due to the complexity of asynchronous streams, so you can find it covered in <a data-type="xref" href="#recipe-async-streams-cancellation">Recipe 3.4</a>.</p>&#13;
&#13;
<p>While it’s possible and natural to use <code>await foreach</code> to consume asynchronous streams, there’s an exhaustive library of asynchronous LINQ operators available; some of the more popular ones are covered in <a data-type="xref" href="#recipe-async-streams-linq">Recipe 3.3</a>.</p>&#13;
&#13;
<p>The body of <code>await foreach</code> can be either synchronous or asynchronous. For the asynchronous example in particular, this is something that is much trickier to get right when working with other streaming abstractions, such as <code>IObservable&lt;T&gt;</code>. This is because observable subscriptions must be synchronous, but <code>await foreach</code> permits natural asynchronous processing.</p>&#13;
&#13;
<p>The <code>await foreach</code> generates an <code>await</code> used for the “get next element” operation; it also generates an <code>await</code> used to asynchronously dispose the <a data-startref="ch3r2a" data-type="indexterm" id="idm45458703402280"/><a data-startref="ch3r2b" data-type="indexterm" id="idm45458703401576"/>enumerable.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458703400648">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="#recipe-async-streams-produce">Recipe 3.1</a> covers producing asynchronous streams.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-async-streams-cancellation">Recipe 3.4</a> covers handling cancellation for asynchronous streams.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-async-streams-linq">Recipe 3.3</a> covers common LINQ methods for asynchronous streams.</p>&#13;
&#13;
<p><a data-type="xref" href="ch11.html#recipe-oop-dispose">Recipe 11.6</a> covers asynchronous disposal.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="3.3 Using LINQ with Asynchronous Streams" data-type="sect1"><div class="sect1" id="recipe-async-streams-linq">&#13;
<h1>3.3 Using LINQ with Asynchronous Streams</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458703393144">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="asynchronous streams" data-secondary="processing with LINQ operators" data-type="indexterm" id="ch3r3a"/><a data-primary="LINQ" data-secondary="processing asynchronous streams" data-type="indexterm" id="ch3r3b"/>want to process an asynchronous stream using well-defined and well-tested operators.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458703388856">&#13;
<h2>Solution</h2>&#13;
&#13;
<p><code>IEnumerable&lt;T&gt;</code> has LINQ to Objects, and <code>IObservable&lt;T&gt;</code> has LINQ to Events. Both of these have libraries of extension methods that define operators you can use to build queries. <code>IAsyncEnumerable&lt;T&gt;</code> also has LINQ support, <a data-primary="System.Linq.Async library" data-type="indexterm" id="idm45458703385896"/><a data-primary="IAsyncEnumerable type" data-type="indexterm" id="idm45458703385128"/><a data-primary="asynchronous enumerables" data-type="indexterm" id="idm45458703384456"/>provided by the .NET community in the <code>System.Linq.Async</code> NuGet package.</p>&#13;
&#13;
<p>As an example, one of the common questions about LINQ is how to use the <code>Where</code> operator if the predicate for <code>Where</code> is asynchronous. In other words, you want to filter a sequence based on some asynchronous condition—e.g., you need to look up each element in a database or API to see if it should be included in the result sequence. <code>Where</code> doesn’t work with an asynchronous condition because the <code>Where</code> operator requires that its delegate return an immediate, synchronous answer.</p>&#13;
&#13;
<p>Asynchronous <a data-primary="WhereAwait operator" data-type="indexterm" id="idm45458703380296"/>streams have a support library that defines many useful operators. In the following example, <code>WhereAwait</code> is the proper choice:</p>&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="n">IAsyncEnumerable</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">values</code> <code class="p">=</code> <code class="n">SlowRange</code><code class="p">().</code><code class="n">WhereAwait</code><code class="p">(</code>&#13;
    <code class="k">async</code> <code class="k">value</code> <code class="p">=&gt;</code>&#13;
    <code class="p">{</code>&#13;
      <code class="c1">// Do some asynchronous work to determine</code>&#13;
      <code class="c1">//  if this element should be included.</code>&#13;
      <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="m">10</code><code class="p">);</code>&#13;
      <code class="k">return</code> <code class="k">value</code> <code class="p">%</code> <code class="m">2</code> <code class="p">==</code> <code class="m">0</code><code class="p">;</code>&#13;
    <code class="p">});</code>&#13;
&#13;
<code class="k">await</code> <code class="k">foreach</code> <code class="p">(</code><code class="kt">int</code> <code class="n">result</code> <code class="k">in</code> <code class="n">values</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">result</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Produce sequence that slows down as it progresses.</code>&#13;
<code class="k">async</code> <code class="n">IAsyncEnumerable</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">SlowRange</code><code class="p">()</code>&#13;
<code class="p">{</code>&#13;
  <code class="k">for</code> <code class="p">(</code><code class="kt">int</code> <code class="n">i</code> <code class="p">=</code> <code class="m">0</code><code class="p">;</code> <code class="n">i</code> <code class="p">!=</code> <code class="m">10</code><code class="p">;</code> <code class="p">++</code><code class="n">i</code><code class="p">)</code>&#13;
  <code class="p">{</code>&#13;
    <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">i</code> <code class="p">*</code> <code class="m">100</code><code class="p">);</code>&#13;
    <code class="k">yield</code> <code class="k">return</code> <code class="n">i</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>LINQ operators for asynchronous streams also include synchronous versions; it does make sense to apply a synchronous <code>Where</code> (or <code>Select</code>, or whatever) to an asynchronous stream. The result is still an asynchronous stream:</p>&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="n">IAsyncEnumerable</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">values</code> <code class="p">=</code> <code class="n">SlowRange</code><code class="p">().</code><code class="n">Where</code><code class="p">(</code>&#13;
    <code class="k">value</code> <code class="p">=&gt;</code> <code class="k">value</code> <code class="p">%</code> <code class="m">2</code> <code class="p">==</code> <code class="m">0</code><code class="p">);</code>&#13;
&#13;
<code class="k">await</code> <code class="k">foreach</code> <code class="p">(</code><code class="kt">int</code> <code class="n">result</code> <code class="k">in</code> <code class="n">values</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">result</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>All of your old LINQ friends are here: <code>Where</code>, <code>Select</code>, <code>SelectMany</code>, and even <code>Join</code>. Most LINQ operators now also take asynchronous delegates, like the <code>WhereAwait</code> example above.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458703294280">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Asynchronous streams are pull-based, so there’s no time-related operators like there are for observables. <code>Throttle</code> and <code>Sample</code> don’t make sense in this world, since the elements are pulled out of the asynchronous stream on demand.</p>&#13;
&#13;
<p>LINQ <a data-primary="ToAsyncEnumerable method" data-type="indexterm" id="idm45458703290824"/><a data-primary="enumerables" data-secondary="converting to asynchronous" data-type="indexterm" id="idm45458703290152"/>methods for asynchronous streams can also be useful for regular enumerables. If you find yourself in this situation, you can call <code>ToAsyncEnumerable()</code> on any <code>IEnumerable&lt;T&gt;</code>, and then you’ll have an asynchronous stream interface that you can use with <code>WhereAwait</code>, <code>SelectAwait</code>, and other operators that support asynchronous delegates.</p>&#13;
&#13;
<p>Before <a data-primary="LINQ" data-secondary="Await and Async suffixes with" data-type="indexterm" id="idm45458703286952"/><a data-primary="Await suffix" data-type="indexterm" id="idm45458703285544"/><a data-primary="Async suffix" data-secondary="for LINQ operators" data-type="indexterm" id="idm45458703284840"/>you dive in, a word on naming is in order. The example in this recipe used <code>WhereAwait</code> as the asynchronous equivalent of <code>Where</code>. As you explore the LINQ operators for asynchronous streams, you’ll find that some end in <code>Async</code> and others end in <code>Await</code>. The operators that end in <code>Async</code> return an awaitable; they represent a regular value, not an asynchronous sequence. The operators that end in <code>Await</code> take an asynchronous delegate; the <code>Await</code> in their name implies that they actually perform an <code>await</code> on the delegate you pass to them.</p>&#13;
&#13;
<p>We already looked at an example of the <code>Await</code> suffix with <code>Where</code> and <code>WhereAwait</code>. The <code>Async</code> suffix only applies to <em>termination operators</em>—operators that extract some value or perform some calculation and return an asynchronous scalar value instead of an asynchronous sequence. An example of a termination operator is <code>CountAsync</code>, the asynchronous stream version of <code>Count</code>, which can count the number of elements that match some predicate:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">int</code> <code class="n">count</code> <code class="p">=</code> <code class="k">await</code> <code class="n">SlowRange</code><code class="p">().</code><code class="n">CountAsync</code><code class="p">(</code>&#13;
    <code class="k">value</code> <code class="p">=&gt;</code> <code class="k">value</code> <code class="p">%</code> <code class="m">2</code> <code class="p">==</code> <code class="m">0</code><code class="p">);</code></pre>&#13;
&#13;
<p>That predicate can <em>also</em> be asynchronous, in which case you would then use the <code>CountAwaitAsync</code> operator, since it both takes an asynchronous delegate (which it will <code>await</code>) and produces a single terminal value, the count:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">int</code> <code class="n">count</code> <code class="p">=</code> <code class="k">await</code> <code class="n">SlowRange</code><code class="p">().</code><code class="n">CountAwaitAsync</code><code class="p">(</code>&#13;
    <code class="k">async</code> <code class="k">value</code> <code class="p">=&gt;</code>&#13;
    <code class="p">{</code>&#13;
      <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="m">10</code><code class="p">);</code>&#13;
      <code class="k">return</code> <code class="k">value</code> <code class="p">%</code> <code class="m">2</code> <code class="p">==</code> <code class="m">0</code><code class="p">;</code>&#13;
    <code class="p">});</code></pre>&#13;
&#13;
<p>In summary, operators that can take delegates have two names: one with an <code>Await</code> suffix and one without. In addition, operators that return a terminal value rather than an asynchronous stream end in <code>Async</code>. If an operator takes an asynchronous delegate <em>and</em> returns a terminal value, then it has both <a data-startref="ch3r3a" data-type="indexterm" id="idm45458703207288"/><a data-startref="ch3r3b" data-type="indexterm" id="idm45458703206760"/>suffixes.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>The <a data-primary="System.Linq.Async library" data-type="indexterm" id="idm45458703204952"/><a data-primary="System.Interactive.Async library" data-type="indexterm" id="idm45458703204248"/>LINQ operators for asynchronous streams are in the NuGet package for <a href="http://bit.ly/sys-linq-async"><code>System.Linq.Async</code></a>.&#13;
Additional LINQ operators for asynchronous streams can be found in the NuGet package for <a href="http://bit.ly/sys-int-async"><code>System.Interactive.Async</code></a>.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458703293688">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="#recipe-async-streams-produce">Recipe 3.1</a> covers producing asynchronous streams.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-async-streams-consume">Recipe 3.2</a> covers consuming asynchronous streams.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="3.4 Asynchronous Streams and Cancellation" data-type="sect1"><div class="sect1" id="recipe-async-streams-cancellation">&#13;
<h1>3.4 Asynchronous Streams and Cancellation</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458703196424">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="asynchronous streams" data-secondary="cancelling" data-type="indexterm" id="ch3r4a"/><a data-primary="cancellation" data-secondary="asynchronous streams" data-type="indexterm" id="ch3r4b"/>want a way to cancel asynchronous streams.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458703192216">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Not all asynchronous streams require cancellation. It’s possible to simply stop enumerating when a condition is reached. If that is the only kind of “cancellation” necessary, then a true cancellation isn’t required, as the following example shows:</p>&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">await</code> <code class="k">foreach</code> <code class="p">(</code><code class="kt">int</code> <code class="n">result</code> <code class="k">in</code> <code class="n">SlowRange</code><code class="p">())</code>&#13;
<code class="p">{</code>&#13;
  <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">result</code><code class="p">);</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="n">result</code> <code class="p">&gt;=</code> <code class="m">8</code><code class="p">)</code>&#13;
    <code class="k">break</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Produce sequence that slows down as it progresses.</code>&#13;
<code class="k">async</code> <code class="n">IAsyncEnumerable</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">SlowRange</code><code class="p">()</code>&#13;
<code class="p">{</code>&#13;
  <code class="k">for</code> <code class="p">(</code><code class="kt">int</code> <code class="n">i</code> <code class="p">=</code> <code class="m">0</code><code class="p">;</code> <code class="n">i</code> <code class="p">!=</code> <code class="m">10</code><code class="p">;</code> <code class="p">++</code><code class="n">i</code><code class="p">)</code>&#13;
  <code class="p">{</code>&#13;
    <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">i</code> <code class="p">*</code> <code class="m">100</code><code class="p">);</code>&#13;
    <code class="k">yield</code> <code class="k">return</code> <code class="n">i</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>That <a data-primary="CancellationToken type" data-type="indexterm" id="idm45458703188408"/>said, it’s often useful to cancel asynchronous streams, as some operators pass cancellation tokens to their source streams. In this scenario, you’ would want to use a <code>CancellationToken</code> to stop the <code>await foreach</code> from external code.</p>&#13;
&#13;
<p>An <code>async</code> method returning <code>IAsyncEnumerable&lt;T&gt;</code> may take a cancellation token by defining a parameter marked with the <code>EnumeratorCancellation</code> attribute. It can then use the token naturally, which is usually done by passing it to other APIs that take cancellation tokens, like this:</p>&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">using</code> <code class="k">var</code> <code class="n">cts</code> <code class="p">=</code> <code class="k">new</code> <code class="n">CancellationTokenSource</code><code class="p">(</code><code class="m">500</code><code class="p">);</code>&#13;
<code class="n">CancellationToken</code> <code class="n">token</code> <code class="p">=</code> <code class="n">cts</code><code class="p">.</code><code class="n">Token</code><code class="p">;</code>&#13;
<code class="k">await</code> <code class="k">foreach</code> <code class="p">(</code><code class="kt">int</code> <code class="n">result</code> <code class="k">in</code> <code class="n">SlowRange</code><code class="p">(</code><code class="n">token</code><code class="p">))</code>&#13;
<code class="p">{</code>&#13;
  <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">result</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Produce sequence that slows down as it progresses.</code>&#13;
<code class="k">async</code> <code class="n">IAsyncEnumerable</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">SlowRange</code><code class="p">(</code>&#13;
<code class="na">    [EnumeratorCancellation]</code> <code class="n">CancellationToken</code> <code class="n">token</code> <code class="p">=</code> <code class="k">default</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="k">for</code> <code class="p">(</code><code class="kt">int</code> <code class="n">i</code> <code class="p">=</code> <code class="m">0</code><code class="p">;</code> <code class="n">i</code> <code class="p">!=</code> <code class="m">10</code><code class="p">;</code> <code class="p">++</code><code class="n">i</code><code class="p">)</code>&#13;
  <code class="p">{</code>&#13;
    <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">i</code> <code class="p">*</code> <code class="m">100</code><code class="p">,</code> <code class="n">token</code><code class="p">);</code>&#13;
    <code class="k">yield</code> <code class="k">return</code> <code class="n">i</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458703111096">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>The example solution here passes the <code>CancellationToken</code> directly to the method returning the asynchronous enumerator. This is the most common usage.</p>&#13;
&#13;
<p>There are other scenarios where your code will be given an asynchronous enumerator and will want to apply a <code>CancellationToken</code> to the enumerators it uses. Cancellation tokens are used when starting a new enumeration of an enumerable, so it makes sense to apply a <code>CancellationToken</code> in this way. The enumerable itself is <em>defined</em> by the <code>SlowRange</code> method, but it’s not started until it is consumed. There are even some scenarios where different cancellation tokens should be passed to different enumerations of the enumerable.</p>&#13;
&#13;
<p>Briefly; it <a data-primary="WithCancellation method" data-type="indexterm" id="idm45458703054904"/>is not the enumerable that is cancelable, but the enumerator created by that enumerable. This is an uncommon but important use case, and it’s the reason asynchronous streams support a <code>WithCancellation</code> extension method that you can use to attach a <code>CancellationToken</code> to a specific iteration of an asynchronous stream:</p>&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">async</code> <code class="n">Task</code> <code class="nf">ConsumeSequence</code><code class="p">(</code><code class="n">IAsyncEnumerable</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">items</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="k">using</code> <code class="k">var</code> <code class="n">cts</code> <code class="p">=</code> <code class="k">new</code> <code class="n">CancellationTokenSource</code><code class="p">(</code><code class="m">500</code><code class="p">);</code>&#13;
  <code class="n">CancellationToken</code> <code class="n">token</code> <code class="p">=</code> <code class="n">cts</code><code class="p">.</code><code class="n">Token</code><code class="p">;</code>&#13;
  <code class="k">await</code> <code class="k">foreach</code> <code class="p">(</code><code class="kt">int</code> <code class="n">result</code> <code class="k">in</code> <code class="n">items</code><code class="p">.</code><code class="n">WithCancellation</code><code class="p">(</code><code class="n">token</code><code class="p">))</code>&#13;
  <code class="p">{</code>&#13;
    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">result</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Produce sequence that slows down as it progresses.</code>&#13;
<code class="k">async</code> <code class="n">IAsyncEnumerable</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">SlowRange</code><code class="p">(</code>&#13;
<code class="na">    [EnumeratorCancellation]</code> <code class="n">CancellationToken</code> <code class="n">token</code> <code class="p">=</code> <code class="k">default</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="k">for</code> <code class="p">(</code><code class="kt">int</code> <code class="n">i</code> <code class="p">=</code> <code class="m">0</code><code class="p">;</code> <code class="n">i</code> <code class="p">!=</code> <code class="m">10</code><code class="p">;</code> <code class="p">++</code><code class="n">i</code><code class="p">)</code>&#13;
  <code class="p">{</code>&#13;
    <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">i</code> <code class="p">*</code> <code class="m">100</code><code class="p">,</code> <code class="n">token</code><code class="p">);</code>&#13;
    <code class="k">yield</code> <code class="k">return</code> <code class="n">i</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">await</code> <code class="nf">ConsumeSequence</code><code class="p">(</code><code class="n">SlowRange</code><code class="p">());</code></pre>&#13;
&#13;
<p>With the <code>EnumeratorCancellation</code> parameter attribute in place, the compiler takes care of passing the token from <code>WithCancellation</code> to the <code>token</code> parameter marked by <code>EnumeratorCancellation</code>, and the cancellation request now causes <code>await foreach</code> to raise an <code>OperationCanceledException</code> after it has processed the first few items.</p>&#13;
&#13;
<p>The <code>WithCancellation</code> extension method doesn’t prevent <code>ConfigureAwait(false)</code>. Both extension methods can be chained <a data-startref="ch3r4a" data-type="indexterm" id="idm45458702982280"/><a data-startref="ch3r4b" data-type="indexterm" id="idm45458702981576"/>together:</p>&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">async</code> <code class="n">Task</code> <code class="nf">ConsumeSequence</code><code class="p">(</code><code class="n">IAsyncEnumerable</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">items</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="k">using</code> <code class="k">var</code> <code class="n">cts</code> <code class="p">=</code> <code class="k">new</code> <code class="n">CancellationTokenSource</code><code class="p">(</code><code class="m">500</code><code class="p">);</code>&#13;
  <code class="n">CancellationToken</code> <code class="n">token</code> <code class="p">=</code> <code class="n">cts</code><code class="p">.</code><code class="n">Token</code><code class="p">;</code>&#13;
  <code class="k">await</code> <code class="k">foreach</code> <code class="p">(</code><code class="kt">int</code> <code class="n">result</code> <code class="k">in</code> <code class="n">items</code>&#13;
      <code class="p">.</code><code class="n">WithCancellation</code><code class="p">(</code><code class="n">token</code><code class="p">).</code><code class="n">ConfigureAwait</code><code class="p">(</code><code class="k">false</code><code class="p">))</code>&#13;
  <code class="p">{</code>&#13;
    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">result</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458702979736">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="#recipe-async-streams-produce">Recipe 3.1</a> covers producing asynchronous streams.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-async-streams-consume">Recipe 3.2</a> covers consuming asynchronous streams.</p>&#13;
&#13;
<p><a data-type="xref" href="ch10.html#cancellation">Chapter 10</a> covers cooperative cancellation across multiple technologies.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>