<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 17. Asynchronous Language Features" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_asynchronous_language_features">
<h1><span class="label">Chapter 17. </span>Asynchronous Language Features</h1>
<p><a data-primary="asynchronous language features" data-type="indexterm" id="ix_ch17-asciidoc0"/>C# provides language-level support for using and implementing asynchronous methods. Asynchronous APIs are often the most efficient way to use certain services. For example, most I/O is handled asynchronously inside the OS kernel, because most peripherals, such as disk controllers or network adapters, are able to do the majority of their work autonomously. They need the CPU to be involved only at the start and end of each operation.</p>
<p>Although many of the services offered by operating systems are intrinsically asynchronous, developers often choose to use them through synchronous APIs (i.e., ones that do not return until the work is complete). This can waste resources, because they block the thread until the I/O completes. Threads have overheads, and if you’re aiming to get the best performance in a highly concurrent application (e.g., a web app serving large numbers of users), it’s usually best to have a relatively small number of OS threads. Ideally, your application would have no more OS threads than you have hardware threads, but that’s optimal only if you can ensure that threads only ever block when there’s no outstanding work for them to do. (<a data-type="xref" href="ch16.xhtml#ch_multithreading">Chapter 16</a> described the difference between OS threads and hardware threads.) The more threads that get blocked inside synchronous API calls, the more threads you’ll need to handle your workload, reducing efficiency. In performance-sensitive code, asynchronous APIs are useful, because instead of wasting resources by forcing a thread to sit and wait for I/O to complete, a thread can kick off the work and then do something else productive in the meantime.</p>
<p>The problem with asynchronous APIs is that they can be significantly more complex to use than synchronous ones, particularly if you need to coordinate multiple related operations and deal with errors. This was often why developers chose the less efficient synchronous alternatives back in the days before any mainstream programming languages provided built-in support. In 2012, C# and Visual Basic brought such features out of the research labs, and since then many other popular languages have added analogous features (most notably JavaScript, which acquired a very similar-looking syntax in 2016). The asynchronous features in C# make it possible to write code that uses efficient asynchronous APIs while retaining most of the simplicity of code that uses simpler synchronous APIs.</p>
<p>These language features are also useful in some scenarios in which maximizing throughput is not the primary performance goal. With client-side code, it’s important to avoid blocking the UI thread to maintain responsiveness, and asynchronous APIs provide one way to do that. The language support for asynchronous code can handle thread affinity issues, which greatly simplifies the job of writing highly responsive UI code.</p>
<section data-pdf-bookmark="Asynchronous Keywords: async and await" data-type="sect1"><div class="sect1" id="asynchronous_keywords_colon_async_and_aw">
<h1>Asynchronous Keywords: async and await</h1>
<p><a data-primary="async keyword" data-type="indexterm" id="ix_ch17-ascii+doc1"/><a data-primary="asynchronous language features" data-secondary="async and await keywords" data-type="indexterm" id="ix_ch17-asciidoc2"/><a data-primary="await keyword" data-type="indexterm" id="ix_ch17-asciidoc3"/>C# presents its support for asynchronous code through two keywords: <code>async</code> and <code>await</code>. The first of these is not meant to be used on its own. You put the <code>async</code> keyword in a method’s declaration, and this tells the compiler that you intend to use asynchronous features in the method. If this keyword is not present, you are not allowed to use the <code>await</code> keyword.</p>
<p>This is arguably redundant—the compiler produces an error if you attempt to use <code>await</code> without <code>async</code>. If it knows when a method’s body is trying to use asynchronous features, why do we need to tell it explicitly? There are two reasons. First, as you’ll see, these features radically change the behavior of the code the compiler generates, so it’s useful for anyone reading the code to see a clear indication that the method behaves asynchronously. Second, <code>await</code> wasn’t always a keyword in C#, so developers were once free to use it as an identifier. Perhaps Microsoft could have designed the grammar for <code>await</code> so that it acts as a keyword only in very specific contexts, enabling you to continue to use it as an identifier in all other scenarios, but the C# team decided to take a slightly more coarse-grained approach: you cannot use <code>await</code> as an identifier inside an <code>async</code> method, but it’s a valid identifier anywhere else.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>async</code> keyword does not change the signature of the method. It determines how the method is compiled, not how it is used.</p>
</div>
<p>The program entry point is an interesting case. Normally, the <code>Main</code> method returns either <code>void</code> or <code>int</code>, but you can also return either a <code>Task</code> or <code>Task&lt;int&gt;</code>. The .NET runtime doesn’t support asynchronous entry points, so if you use either of these task return types, the C# compiler will generate a hidden method that acts as the real entry point, which calls your asynchronous <code>Main</code> and then blocks until the task it returns completes. This makes it possible to make the <code>Main</code> method of a C# program <code>async</code> (although the compiler will generate the wrapper when you use these return types even if you don’t make the method <code>async</code>). <a data-primary="C# 10.0" data-secondary="async keyword" data-type="indexterm" id="idm45884785535392"/>If you use C# 10.0’s top-level statements to avoid having to declare <code>Main</code> explicitly, there’s no place to put the <code>async</code> keyword or a return type, so this is the one case where the compiler deduces whether a method is asynchronous from whether you use <code>await</code>. It bases the program entry point’s return type on whether you return anything.</p>
<p>So the <code>async</code> keyword simply declares your intention to use the <code>await</code> keyword. (While you mustn’t use <code>await</code> without <code>async</code>, it’s not an error to apply the <code>async</code> keyword to a method that doesn’t use <code>await</code>. However, it would serve no purpose, so the compiler will generate a warning if you do this.) <a data-type="xref" href="#using_async_and_await_when_fetching_http">Example 17-1</a> shows a fairly typical example. <a data-primary="HttpClient class" data-type="indexterm" id="idm45884785528768"/>This uses the <code>HttpClient</code> class to request just the headers for a particular resource (using the standard <code>HEAD</code> verb that the HTTP protocol defines for this purpose). It then displays the results in a UI control—this method is part of the code<span class="keep-together">behind</span> for a UI that includes a <code>TextBox</code> named <code>headerListTextBox</code>.</p>
<div data-type="example" id="using_async_and_await_when_fetching_http">
<h5><span class="label">Example 17-1. </span>Using <code>async</code> and <code>await</code> when fetching HTTP headers</h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="c1">// Note: as you'll see later, async methods usually should not be void
</code><code class="k">private</code> <code class="k">async</code> <code class="k">void</code> <code class="nf">FetchAndShowHeaders</code><code class="p">(</code><code class="kt">string</code> <code class="n">url</code><code class="p">,</code> <code class="n">IHttpClientFactory</code> <code class="n">cf</code><code class="p">)</code>
<code class="p">{</code>
    <code class="k">using</code> <code class="p">(</code><code class="n">HttpClient</code> <code class="n">w</code> <code class="p">=</code> <code class="n">cf</code><code class="p">.</code><code class="n">CreateClient</code><code class="p">(</code><code class="p">)</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="kt">var</code> <code class="n">req</code> <code class="p">=</code> <code class="k">new</code> <code class="n">HttpRequestMessage</code><code class="p">(</code><code class="n">HttpMethod</code><code class="p">.</code><code class="n">Head</code><code class="p">,</code> <code class="n">url</code><code class="p">)</code><code class="p">;</code>
        <code class="n">HttpResponseMessage</code> <code class="n">response</code> <code class="p">=</code>
            <strong><code class="k">await</code> <code class="n">w</code><code class="p">.</code><code class="n">SendAsync</code><code class="p">(</code><code class="n">req</code><code class="p">,</code> <code class="n">HttpCompletionOption</code><code class="p">.</code><code class="n">ResponseHeadersRead</code><code class="p">)</code><code class="p">;</code></strong>

        <code class="n">headerListTextBox</code><code class="p">.</code><code class="n">Text</code> <code class="p">=</code> <code class="n">response</code><code class="p">.</code><code class="n">Headers</code><code class="p">.</code><code class="n">ToString</code><code class="p">(</code><code class="p">)</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>This code contains a single <code>await</code> expression, shown in bold. You use the <code>await</code> keyword in an expression that may take some time to produce a result, and it indicates that the remainder of the method should not execute until that operation is complete. This sounds a lot like what a blocking, synchronous API does, but the difference is that an <code>await</code> expression does not block the thread—this code is not quite what it seems.</p>
<p>The <code>HttpClient</code> class’s <code>SendAsync</code> method returns a <code>Task&lt;HttpResponseMessage&gt;</code>, and you might be wondering why we wouldn’t just use its <code>Result</code> property. As you saw in <a data-type="xref" href="ch16.xhtml#ch_multithreading">Chapter 16</a>, if the task is not complete, this property blocks the thread until the result is available (or the task fails, in which case it will throw an exception instead). However, this is a dangerous thing to do in a UI application: if you block the UI thread by trying to read the <code>Result</code> of an incomplete task, you will prevent progress of any operations that need to run on that thread. Since a lot of the work that UI applications do needs to happen on the UI thread, blocking that thread in this way more or less guarantees that deadlock will occur sooner or later, causing the application to freeze. So don’t do that!</p>
<p>Although the <code>await</code> expression in <a data-type="xref" href="#using_async_and_await_when_fetching_http">Example 17-1</a> does something that is logically similar to reading <code>Result</code>, it works very differently. If the task’s result is not available immediately, the <code>await</code> keyword does not make the thread wait, despite what its name suggests. Instead, it causes the containing method to return. You can use a debugger to verify that <code>FetchAndShowHeaders</code> returns immediately. For example, if I call that method from the button click event handler shown in <a data-type="xref" href="#calling_the_asynchronous_method">Example 17-2</a>, I can put a breakpoint on the <code>Debug.WriteLine</code> call in that handler and another breakpoint on the code in <a data-type="xref" href="#using_async_and_await_when_fetching_http">Example 17-1</a> that will update the <code>headerListTextBox.Text</code> property.</p>
<div data-type="example" id="calling_the_asynchronous_method">
<h5><span class="label">Example 17-2. </span>Calling the asynchronous method</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">private</code> <code class="k">void</code> <code class="nf">fetchHeadersButton_Click</code><code class="p">(</code><code class="kt">object</code> <code class="n">sender</code><code class="p">,</code> <code class="n">RoutedEventArgs</code> <code class="n">e</code><code class="p">)</code>
<code class="p">{</code>
    <code class="n">FetchAndShowHeaders</code><code class="p">(</code><code class="s">"https://endjin.com/"</code><code class="p">,</code> <code class="k">this</code><code class="p">.</code><code class="n">clientFactory</code><code class="p">);</code>
    <code class="n">Debug</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Method returned"</code><code class="p">);</code>
<code class="p">}</code></pre></div>
<p>Running this in the debugger, I find that the code hits the breakpoint on the last statement of <a data-type="xref" href="#calling_the_asynchronous_method">Example 17-2</a> before it hits the breakpoint on the final statement of <a data-type="xref" href="#using_async_and_await_when_fetching_http">Example 17-1</a>. In other words, the section of <a data-type="xref" href="#using_async_and_await_when_fetching_http">Example 17-1</a> that follows the <code>await</code> expression runs <em>after</em> the method has returned to its caller. Evidently, the compiler is somehow arranging for the remainder of the method to be run via a callback that occurs once the asynchronous operation completes.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Visual Studio’s debugger plays some tricks when you debug asynchronous methods to enable you to step through them as though they were normal methods. This is usually helpful, but it can sometimes conceal the true nature of execution. The debugging steps I just described were contrived to defeat Visual Studio’s attempts to be clever and instead to reveal what is really happening.</p>
</div>
<p>Notice that the code in <a data-type="xref" href="#using_async_and_await_when_fetching_http">Example 17-1</a> expects to run on the UI thread because it modifies the text box’s <code>Text</code> property toward the end. Asynchronous APIs do not necessarily guarantee to notify you of completion on the same thread on which you started the work—in fact, most won’t. Despite this, <a data-type="xref" href="#using_async_and_await_when_fetching_http">Example 17-1</a> works as intended, so as well as converting half of the method to a callback, the <code>await</code> keyword is handling thread affinity issues for us.</p>
<p>The C# compiler evidently performs some major surgery on your code each time you use the <code>await</code> keyword. In older versions of C#, if you wanted to use this asynchronous API and then update the UI, you would need to have written something like <a data-type="xref" href="#manual_asynchronous_coding">Example 17-3</a>. This uses a technique I showed in <a data-type="xref" href="ch16.xhtml#ch_multithreading">Chapter 16</a>: it sets up a continuation for the task returned by <code>SendAsync</code>, using a <code>TaskScheduler</code> to ensure that the continuation’s body runs on the UI thread.</p>
<div data-type="example" id="manual_asynchronous_coding">
<h5><span class="label">Example 17-3. </span>Manual asynchronous coding</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">private</code> <code class="k">void</code> <code class="nf">OldSchoolFetchHeaders</code><code class="p">(</code><code class="kt">string</code> <code class="n">url</code><code class="p">,</code> <code class="n">IHttpClientFactory</code> <code class="n">cf</code><code class="p">)</code>
<code class="p">{</code>
    <code class="n">HttpClient</code> <code class="n">w</code> <code class="p">=</code> <code class="n">cf</code><code class="p">.</code><code class="n">CreateClient</code><code class="p">();</code>
    <code class="kt">var</code> <code class="n">req</code> <code class="p">=</code> <code class="k">new</code> <code class="n">HttpRequestMessage</code><code class="p">(</code><code class="n">HttpMethod</code><code class="p">.</code><code class="n">Head</code><code class="p">,</code> <code class="n">url</code><code class="p">);</code>

    <code class="kt">var</code> <code class="n">uiScheduler</code> <code class="p">=</code> <code class="n">TaskScheduler</code><code class="p">.</code><code class="n">FromCurrentSynchronizationContext</code><code class="p">();</code>
    <code class="n">w</code><code class="p">.</code><code class="n">SendAsync</code><code class="p">(</code><code class="n">req</code><code class="p">,</code> <code class="n">HttpCompletionOption</code><code class="p">.</code><code class="n">ResponseHeadersRead</code><code class="p">)</code>
        <code class="p">.</code><code class="n">ContinueWith</code><code class="p">(</code><code class="n">sendTask</code> <code class="p">=&gt;</code>
        <code class="p">{</code>
            <code class="k">try</code>
            <code class="p">{</code>
                <code class="n">HttpResponseMessage</code> <code class="n">response</code> <code class="p">=</code> <code class="n">sendTask</code><code class="p">.</code><code class="n">Result</code><code class="p">;</code>
                <code class="n">headerListTextBox</code><code class="p">.</code><code class="n">Text</code> <code class="p">=</code> <code class="n">response</code><code class="p">.</code><code class="n">Headers</code><code class="p">.</code><code class="n">ToString</code><code class="p">();</code>
            <code class="p">}</code>
            <code class="k">finally</code>
            <code class="p">{</code>
                <code class="n">w</code><code class="p">.</code><code class="n">Dispose</code><code class="p">();</code>
            <code class="p">}</code>
        <code class="p">},</code>
        <code class="n">uiScheduler</code><code class="p">);</code>
<code class="p">}</code></pre></div>
<p>This is a reasonable way to use the TPL directly, and it has a similar effect to <a data-type="xref" href="#using_async_and_await_when_fetching_http">Example 17-1</a>, although it’s not an exact representation of how the C# compiler transforms the code. As I’ll show later, <code>await</code> uses a pattern that is supported by, but does not require, <code>Task</code> or <code>Task&lt;T&gt;</code>. It also generates code that handles early completion (where the task has already finished by the time you’re ready to wait for it) far more efficiently than <a data-type="xref" href="#manual_asynchronous_coding">Example 17-3</a>. But before I show the details of what the compiler does, I want to illustrate some of the problems it solves for you, which is best done by showing the kind of code you might have written back before this language feature existed.</p>
<p>My current example is pretty simple, because it involves only one asynchronous operation, but aside from the two steps I’ve already discussed—setting up some kind of completion callback and ensuring that it runs on the correct thread—I’ve also had to deal with the <code>using</code> statement that was in <a data-type="xref" href="#using_async_and_await_when_fetching_http">Example 17-1</a>. <a data-type="xref" href="#manual_asynchronous_coding">Example 17-3</a> can’t use the <code>using</code> keyword, because we want to dispose the <code>HttpClient</code> object only after we’ve finished with it.<sup><a data-type="noteref" href="ch17.xhtml#idm45884785189952" id="idm45884785189952-marker">1</a></sup> Calling <code>Dispose</code> shortly before the outer method returns would not work, because we need to be able to use the object when the continuation runs, and that will typically happen a fair bit later. So I need to create the object in one method (the outer one) and then dispose of it in a different method (the nested one). And because I’m calling <code>Dispose</code> by hand, it’s now my problem to deal with exceptions, so I’ve had to wrap all of the code I moved into the callback with a <code>try</code> block and call <code>Dispose</code> in a <code>finally</code> block. (In fact, I’ve not even done a comprehensive job—in the unlikely event that either the <code>HttpRequestMessage</code> constructor or the call that retrieves the task scheduler were to throw an exception, the <code>HttpClient</code> would not get disposed. I’m handling only the case where the HTTP operation itself fails.)</p>
<p><a data-type="xref" href="#manual_asynchronous_coding">Example 17-3</a> has used a task scheduler to arrange for the continuation to run via the <code>SynchronizationContext</code> that was current when the work started. This ensures that the callback occurs on the correct thread to update the UI. The <code>await</code> keyword can take care of that for us.</p>
<section data-pdf-bookmark="Execution and Synchronization Contexts" data-type="sect2"><div class="sect2" id="execution_and_synchronization_contexts">
<h2>Execution and Synchronization Contexts</h2>
<p><a data-primary="async keyword" data-secondary="execution and synchronization contexts" data-type="indexterm" id="ix_ch17-asciidoc4"/><a data-primary="asynchronous language features" data-secondary="execution and synchronization contexts" data-type="indexterm" id="ix_ch17-asciidoc5"/><a data-primary="await keyword" data-secondary="execution and synchronization contexts" data-type="indexterm" id="ix_ch17-asciidoc6"/><a data-primary="execution context" data-type="indexterm" id="ix_ch17-asciidoc7"/><a data-primary="synchronization context" data-type="indexterm" id="ix_ch17-asciidoc8"/>When your program’s execution reaches an <code>await</code> expression for an operation that doesn’t complete immediately, the code generated for that <code>await</code> will ensure that the current execution context has been captured. (It might not have to do much—if this is not the first <code>await</code> to block in this method, and if the context hasn’t changed since, it will have been captured already.) When the asynchronous operation completes, the remainder of your method will be executed through the execution context.<sup><a data-type="noteref" href="ch17.xhtml#idm45884785171152" id="idm45884785171152-marker">2</a></sup></p>
<p>As I described in <a data-type="xref" href="ch16.xhtml#ch_multithreading">Chapter 16</a>, the execution context handles certain contextual information that needs to flow when one method invokes another (even when it does so indirectly). But there’s another kind of context that we may be interested in, particularly when writing UI code: the synchronization context (which was also described in <a data-type="xref" href="ch16.xhtml#ch_multithreading">Chapter 16</a>).</p>
<p>While all <code>await</code> expressions capture the execution context, the decision of whether to flow synchronization context as well is controlled by the type being awaited. If you <code>await</code> for a <code>Task</code>, the synchronization context will also be captured by default. Tasks are not the only thing you can <code>await</code>, and I’ll describe how types can support <code>await</code> in the section <a data-type="xref" href="#the_await_pattern">“The await Pattern”</a>.</p>
<p>Sometimes, you might want to avoid getting the synchronization context involved. If you want to perform asynchronous work starting from a UI thread, but you have no particular need to remain on that thread, scheduling every continuation through the synchronization context is unnecessary overhead. If the asynchronous operation is a <code>Task</code> or <code>Task&lt;T&gt;</code> (or the equivalent value types, <code>ValueTask</code> or <code>ValueTask&lt;T&gt;</code>), you can declare that you don’t want this by calling the <span class="keep-together"><code>ConfigureAwait</code></span> method passing <code>false</code>. This returns a different representation of the asynchronous operation, and if you <code>await</code> that instead of the original task, it will ignore the current <code>Syn⁠chr⁠oni⁠zat⁠ion​Con⁠text</code> if there is one. (There’s no equivalent mechanism for opting out of the execution context.) <a data-type="xref" href="#configureawait">Example 17-4</a> shows how to use this.</p>
<div data-type="example" id="configureawait">
<h5><span class="label">Example 17-4. </span><code>ConfigureAwait</code></h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="k">private</code> <code class="k">async</code> <code class="k">void</code> <code class="nf">OnFetchButtonClick</code><code class="p">(</code><code class="kt">object</code> <code class="n">sender</code><code class="p">,</code> <code class="n">RoutedEventArgs</code> <code class="n">e</code><code class="p">)</code>
<code class="p">{</code>
    <code class="k">using</code> <code class="p">(</code><code class="n">HttpClient</code> <code class="n">w</code> <code class="p">=</code> <code class="k">this</code><code class="p">.</code><code class="n">clientFactory</code><code class="p">.</code><code class="n">CreateClient</code><code class="p">(</code><code class="p">)</code><code class="p">)</code>
    <code class="k">using</code> <code class="p">(</code><code class="n">Stream</code> <code class="n">f</code> <code class="p">=</code> <code class="n">File</code><code class="p">.</code><code class="n">Create</code><code class="p">(</code><code class="n">fileTextBox</code><code class="p">.</code><code class="n">Text</code><code class="p">)</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">Task</code><code class="p">&lt;</code><code class="n">Stream</code><code class="p">&gt;</code> <code class="n">getStreamTask</code> <code class="p">=</code> <code class="n">w</code><code class="p">.</code><code class="n">GetStreamAsync</code><code class="p">(</code><code class="n">urlTextBox</code><code class="p">.</code><code class="n">Text</code><code class="p">)</code><code class="p">;</code>
        <strong><code class="n">Stream</code> <code class="n">getStream</code> <code class="p">=</code> <code class="k">await</code> <code class="n">getStreamTask</code><code class="p">.</code><code class="n">ConfigureAwait</code><code class="p">(</code><code class="k">false</code><code class="p">)</code><code class="p">;</code></strong>

        <code class="n">Task</code> <code class="n">copyTask</code> <code class="p">=</code> <code class="n">getStream</code><code class="p">.</code><code class="n">CopyToAsync</code><code class="p">(</code><code class="n">f</code><code class="p">)</code><code class="p">;</code>
        <strong><code class="k">await</code> <code class="n">copyTask</code><code class="p">.</code><code class="n">ConfigureAwait</code><code class="p">(</code><code class="k">false</code><code class="p">)</code><code class="p">;</code></strong>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>
<p>This code is a click handler for a button, so it initially runs on a UI thread. It retrieves the <code>Text</code> property from a couple of text boxes. Then it kicks off some asynchronous work—fetching the content for a URL and copying the data into a file. It does not use any UI elements after fetching those two <code>Text</code> properties, so it doesn’t matter if the remainder of the method runs on some separate thread. By passing <code>false</code> to <code>ConfigureAwait</code> and waiting on the value it returns, we are telling the TPL that we are happy for it to use whatever thread is convenient to notify us of completion, which in this case will most likely be a thread pool thread. This will enable the work to complete more efficiently and more quickly, because it avoids getting the UI thread involved unnecessarily after each <code>await</code>.</p>
<p><a data-primary="IAsyncOperation&lt;T&gt; class" data-type="indexterm" id="idm45884785057936"/>Not all asynchronous APIs return <code>Task</code> or <code>Task&lt;T&gt;</code>. For example, various asynchronous APIs introduced to Windows as part of UWP (an API for building desktop and tablet applications) return an <code>IAsyncOperation&lt;T&gt;</code> instead of <code>Task&lt;T&gt;</code>. This is because UWP is not .NET-specific, and it has its own runtime-independent representation for asynchronous operations that can also be used from <span class="keep-together">C++</span> and JavaScript. This interface is conceptually similar to TPL tasks, and it supports the await pattern, meaning you can use <code>await</code> with these APIs. However, it does not provide <code>Con⁠fig⁠ure​Awa⁠it</code>. If you want to do something similar to <a data-type="xref" href="#configureawait">Example 17-4</a> with one of these APIs, you can use the <code>AsTask</code> extension method that wraps an <code>IAsyncOperation&lt;T&gt;</code> as a <code>Task&lt;T&gt;</code>, and you can call <code>ConfigureAwait</code> on that task instead.</p>
<div data-type="tip"><h6>Tip</h6>
<p>If you are writing libraries, then in most cases you should call <code>ConfigureAwait(false)</code> anywhere you use <code>await</code>. This is because continuing via the synchronization context can be expensive, and in some cases it can introduce the possibility of deadlock occurring. The only exceptions are when you are doing something that positively requires the synchronization context to be preserved, or you know for certain that your library will only ever be used in application frameworks that do not set up a synchronization context. (E.g., ASP.NET Core applications do not use synchronization contexts, so it generally doesn’t matter whether or not you call <code>ConfigureAwait(false)</code> in those.)</p>
</div>
<p><a data-type="xref" href="#using_async_and_await_when_fetching_http">Example 17-1</a> contained just one <code>await</code> expression, and even that turned out to be fairly complex to reproduce with classic TPL programming. <a data-type="xref" href="#configureawait">Example 17-4</a> contains two, and achieving equivalent behavior without the aid of the <code>await</code> keyword would require rather more code, because exceptions could occur before the first <code>await</code>, after the second, or between, and we’d need to call <code>Dispose</code> on the <code>HttpClient</code> and <code>Stream</code> in any of those cases (as well as in the case where no exception is thrown). However, things can get considerably more complex than that once flow control gets involved.<a data-startref="ix_ch17-asciidoc8" data-type="indexterm" id="idm45884785001184"/><a data-startref="ix_ch17-asciidoc7" data-type="indexterm" id="idm45884785000480"/><a data-startref="ix_ch17-asciidoc6" data-type="indexterm" id="idm45884784999808"/><a data-startref="ix_ch17-asciidoc5" data-type="indexterm" id="idm45884784999136"/><a data-startref="ix_ch17-asciidoc4" data-type="indexterm" id="idm45884784998464"/></p>
</div></section>
<section data-pdf-bookmark="Multiple Operations and Loops" data-type="sect2"><div class="sect2" id="multiple_operations_and_loops">
<h2>Multiple Operations and Loops</h2>
<p><a data-primary="async keyword" data-secondary="multiple operations and loops" data-type="indexterm" id="ix_ch17-asciidoc9"/><a data-primary="asynchronous language features" data-secondary="multiple operations and loops" data-type="indexterm" id="ix_ch17-asciidoc10"/><a data-primary="await keyword" data-secondary="multiple operations and loops" data-type="indexterm" id="ix_ch17-asciidoc11"/>Suppose that instead of fetching headers, or just copying the HTTP response body to a file, I wanted to process the data in the body. If the body is large, retrieving it is an operation that could require multiple, slow steps. <a data-type="xref" href="#multiple_asynchronous_operations">Example 17-5</a> fetches a web page gradually.</p>
<div data-type="example" id="multiple_asynchronous_operations">
<h5><span class="label">Example 17-5. </span>Multiple asynchronous operations</h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="k">private</code> <code class="k">async</code> <code class="k">void</code> <code class="nf">FetchAndShowBody</code><code class="p">(</code><code class="kt">string</code> <code class="n">url</code><code class="p">,</code> <code class="n">IHttpClientFactory</code> <code class="n">cf</code><code class="p">)</code>
<code class="p">{</code>
    <code class="k">using</code> <code class="p">(</code><code class="n">HttpClient</code> <code class="n">w</code> <code class="p">=</code> <code class="n">cf</code><code class="p">.</code><code class="n">CreateClient</code><code class="p">(</code><code class="p">)</code><code class="p">)</code>
    <code class="p">{</code>
        <strong><code class="n">Stream</code> <code class="n">body</code> <code class="p">=</code> <code class="k">await</code> <code class="n">w</code><code class="p">.</code><code class="n">GetStreamAsync</code><code class="p">(</code><code class="n">url</code><code class="p">)</code><code class="p">;</code></strong>
        <code class="k">using</code> <code class="p">(</code><code class="kt">var</code> <code class="n">bodyTextReader</code> <code class="p">=</code> <code class="k">new</code> <code class="n">StreamReader</code><code class="p">(</code><code class="n">body</code><code class="p">)</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="k">while</code> <code class="p">(</code><code class="p">!</code><code class="n">bodyTextReader</code><code class="p">.</code><code class="n">EndOfStream</code><code class="p">)</code>
            <code class="p">{</code>
                <strong><code class="kt">string?</code> <code class="n">line</code> <code class="p">=</code> <code class="k">await</code> <code class="n">bodyTextReader</code><code class="p">.</code><code class="n">ReadLineAsync</code><code class="p">(</code><code class="p">)</code><code class="p">;</code></strong>
                <code class="n">bodyTextBox</code><code class="p">.</code><code class="n">AppendText</code><code class="p">(</code><code class="n">line</code><code class="p">)</code><code class="p">;</code>
                <code class="n">bodyTextBox</code><code class="p">.</code><code class="n">AppendText</code><code class="p">(</code><code class="n">Environment</code><code class="p">.</code><code class="n">NewLine</code><code class="p">)</code><code class="p">;</code>
                <strong><code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromMilliseconds</code><code class="p">(</code><code class="m">10</code><code class="p">)</code><code class="p">)</code><code class="p">;</code></strong>
            <code class="p">}</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>This now contains three <code>await</code> expressions. The first kicks off an HTTP GET request, and that operation will complete when we get the first part of the response, but the response might not be complete yet—there may be several megabytes of content to come. This code presumes that the content will be text, so it wraps the <code>Stream</code> object that comes back in a <code>StreamReader</code>, which presents the bytes in a stream as text.<sup><a data-type="noteref" href="ch17.xhtml#CHP-18-FN-3" id="CHP-18-FN-3-marker">3</a></sup> It then uses that wrapper’s asynchronous <code>ReadLineAsync</code> method to read text a line at a time from the response. Because data tends to arrive in chunks, reading the first line may take a while, but the next few calls to this method will probably complete immediately, because each network packet we receive will typically contain multiple lines. But if the code can read faster than data arrives over the network, eventually it will have consumed all the lines that appeared in the first packet, and it will then take a while before the next line becomes available. So the calls to <code>ReadLineAsync</code> will return some tasks that are slow and some that complete immediately. The third asynchronous operation is a call to <code>Task.Delay</code>. I’ve added this to slow things down so that I can see the data arriving gradually in the UI. <code>Task.Delay</code> returns a <code>Task</code> that completes after the specified delay, so this provides an asynchronous equivalent to <code>Thread.Sleep</code>. (<code>Thread.Sleep</code> blocks the calling thread, but <code>await Task.Delay</code> introduces a delay without blocking the thread.)</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>I’ve put each <code>await</code> expression in a separate statement, but this is not a requirement. It’s perfectly legal to write expressions of the form <code>(await t1) + (await t2)</code>. (You can omit the parentheses if you like, because <code>await</code> has higher precedence than addition; I prefer the visual emphasis they provide here.)</p>
</div>
<p>I’m not going to show you the complete pre-<code>async</code> equivalent of <a data-type="xref" href="#multiple_asynchronous_operations">Example 17-5</a>, because it would be enormous, but I’ll describe some of the problems. First, we’ve got a loop with a body that contains two <code>await</code> blocks. To produce something equivalent with <code>Task</code> and callbacks means building your own loop constructs, because the code for the loop ends up being split across three methods: the one that starts the loop running (which would be the nested method acting as the continuation callback for <code>GetStreamAsync</code>) and the two callbacks that handle the completion of <code>ReadLineAsync</code> and <code>Task.Delay</code>. You can solve this by having a local method that starts a new iteration and calling that from two places: the point at which you want to start the loop and again in the <code>Task.Delay</code> continuation to kick off the next iteration. <a data-type="xref" href="#an_incomplete_manual_asynchronous_loop">Example 17-6</a> shows this technique, but it illustrates just one aspect of what we’re expecting the compiler to do for us; it is not a complete alternative to <a data-type="xref" href="#multiple_asynchronous_operations">Example 17-5</a>.</p>
<div data-type="example" id="an_incomplete_manual_asynchronous_loop">
<h5><span class="label">Example 17-6. </span>An incomplete manual asynchronous loop</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">private</code> <code class="k">void</code> <code class="nf">IncompleteOldSchoolFetchAndShowBody</code><code class="p">(</code>
    <code class="kt">string</code> <code class="n">url</code><code class="p">,</code> <code class="n">IHttpClientFactory</code> <code class="n">cf</code><code class="p">)</code>
<code class="p">{</code>
    <code class="n">HttpClient</code> <code class="n">w</code> <code class="p">=</code> <code class="n">cf</code><code class="p">.</code><code class="n">CreateClient</code><code class="p">();</code>
    <code class="kt">var</code> <code class="n">uiScheduler</code> <code class="p">=</code> <code class="n">TaskScheduler</code><code class="p">.</code><code class="n">FromCurrentSynchronizationContext</code><code class="p">();</code>
    <code class="n">w</code><code class="p">.</code><code class="n">GetStreamAsync</code><code class="p">(</code><code class="n">url</code><code class="p">).</code><code class="n">ContinueWith</code><code class="p">(</code><code class="n">getStreamTask</code> <code class="p">=&gt;</code>
    <code class="p">{</code>
        <code class="n">Stream</code> <code class="n">body</code> <code class="p">=</code> <code class="n">getStreamTask</code><code class="p">.</code><code class="n">Result</code><code class="p">;</code>
        <code class="kt">var</code> <code class="n">bodyTextReader</code> <code class="p">=</code> <code class="k">new</code> <code class="n">StreamReader</code><code class="p">(</code><code class="n">body</code><code class="p">);</code>

        <code class="n">StartNextIteration</code><code class="p">();</code>

        <code class="k">void</code> <code class="nf">StartNextIteration</code><code class="p">()</code>
        <code class="p">{</code>
            <code class="k">if</code> <code class="p">(!</code><code class="n">bodyTextReader</code><code class="p">.</code><code class="n">EndOfStream</code><code class="p">)</code>
            <code class="p">{</code>
                <code class="n">bodyTextReader</code><code class="p">.</code><code class="n">ReadLineAsync</code><code class="p">().</code><code class="n">ContinueWith</code><code class="p">(</code><code class="n">readLineTask</code> <code class="p">=&gt;</code>
                    <code class="p">{</code>
                        <code class="kt">string?</code> <code class="n">line</code> <code class="p">=</code> <code class="n">readLineTask</code><code class="p">.</code><code class="n">Result</code><code class="p">;</code>

                        <code class="n">bodyTextBox</code><code class="p">.</code><code class="n">AppendText</code><code class="p">(</code><code class="n">line</code><code class="p">);</code>
                        <code class="n">bodyTextBox</code><code class="p">.</code><code class="n">AppendText</code><code class="p">(</code><code class="n">Environment</code><code class="p">.</code><code class="n">NewLine</code><code class="p">);</code>

                        <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromMilliseconds</code><code class="p">(</code><code class="m">10</code><code class="p">))</code>
                            <code class="p">.</code><code class="n">ContinueWith</code><code class="p">(</code>
                                <code class="n">_</code> <code class="p">=&gt;</code> <code class="n">StartNextIteration</code><code class="p">(),</code> <code class="n">uiScheduler</code><code class="p">);</code>
                    <code class="p">},</code>
                <code class="n">uiScheduler</code><code class="p">);</code>
            <code class="p">}</code>
        <code class="p">};</code>
    <code class="p">},</code>
        <code class="n">uiScheduler</code><code class="p">);</code>
<code class="p">}</code></pre></div>
<p>This code works after a fashion, but it doesn’t even attempt to dispose any of the resources it uses. There are several places in which failure could occur, so we can’t just put a single <code>using</code> block or <code>try</code>/<code>finally</code> pair in to clean things up. And even without that additional complication, the code is barely recognizable—it’s not obvious that this is attempting to perform the same basic operations as <a data-type="xref" href="#multiple_asynchronous_operations">Example 17-5</a>. With proper error handling, it would be completely unreadable. In practice, it would probably be easier to take a <span class="keep-together">different</span> approach entirely, writing a class that implements a state machine to keep track of where the work has gotten to. That will probably make it easier to produce code that operates correctly, but it’s not going to make it any easier for someone reading your code to understand that what they’re looking at is really little more than a loop at heart.</p>
<p>No wonder so many developers used to prefer synchronous APIs. But C# lets us write asynchronous code that has almost exactly the same structure as the synchronous equivalent, giving us all of the performance and responsiveness benefits of asynchronous code without the pain. That’s the main benefit of <code>async</code> and <code>await</code> in a nutshell.<a data-startref="ix_ch17-asciidoc11" data-type="indexterm" id="idm45884784679456"/><a data-startref="ix_ch17-asciidoc10" data-type="indexterm" id="idm45884784678720"/><a data-startref="ix_ch17-asciidoc9" data-type="indexterm" id="idm45884784678048"/></p>
<section data-pdf-bookmark="Consuming and producing asynchronous sequences" data-type="sect3"><div class="sect3" id="idm45884784677248">
<h3>Consuming and producing asynchronous sequences</h3>
<p><a data-primary="async keyword" data-secondary="consuming/producing asynchronous sequences" data-type="indexterm" id="ix_ch17-asciidoc12"/><a data-primary="asynchronous language features" data-secondary="consuming/producing asynchronous sequences" data-type="indexterm" id="ix_ch17-asciidoc13"/><a data-primary="await keyword" data-secondary="consuming/producing asynchronous sequences" data-type="indexterm" id="ix_ch17-asciidoc14"/><a data-type="xref" href="#multiple_asynchronous_operations">Example 17-5</a> showed a <code>while</code> loop, and as you’d expect, you’re free to use other kinds of loops such as <code>for</code> and <code>foreach</code> in <code>async</code> methods. <a data-primary="collections" data-secondary="iteration with foreach loops" data-type="indexterm" id="idm45884784669216"/>However, <code>foreach</code> can introduce a subtle problem: What happens if the collection you iterate over needs to perform slow operations? This doesn’t arise for collection types such as arrays or <code>HashSet&lt;T&gt;</code>, where all the collection’s items are already in memory, but what about the <code>IEnumerable&lt;string&gt;</code> returned by <code>File.ReadLines</code>? That’s an obvious candidate for asynchronous operation, but in practice, it will just block your thread each time it needs to wait for more data to arrive from storage. And that’s because the pattern expected by <code>foreach</code> doesn’t support asynchronous operation. The heart of the problem is that the method <code>foreach</code> will call to move to the next item—it expects the enumerator (often, but not always an implementation of <code>IEnumerator&lt;T&gt;</code>) to provide a <code>MoveNext</code> method with a signature like the one shown in <a data-type="xref" href="#ienumerator_movenext">Example 17-7</a>.</p>
<div data-type="example" id="ienumerator_movenext">
<h5><span class="label">Example 17-7. </span>The non-async-friendly <code>IEnumerator.MoveNext</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">bool</code> <code class="nf">MoveNext</code><code class="p">();</code></pre></div>
<p>If more items are forthcoming but are not yet available, collections have no choice but to block the thread, not returning from <code>MoveNext</code> until the data arrives. Fortunately, C# recognizes a variation on this pattern. <a data-primary="IAsyncEnumerable&lt;T&gt; interface" data-type="indexterm" id="ix_ch17-asciidoc14a"/>The runtime libraries define a pair of types,<sup><a data-type="noteref" href="ch17.xhtml#idm45884784599056" id="idm45884784599056-marker">4</a></sup> shown in <a data-type="xref" href="#async_enumeration_types">Example 17-8</a> (first introduced in <a data-type="xref" href="ch05.xhtml#ch_collections">Chapter 5</a>), that embody this new pattern. As with the synchronous <code>IEnumerable&lt;T&gt;</code>, <code>foreach</code> doesn’t strictly require these exact types. Anything offering members of the same signature will work.</p>
<div data-type="example" id="async_enumeration_types">
<h5><span class="label">Example 17-8. </span><code>IAsyncEnumerable&lt;T&gt;</code> and <code>IAsyncEnumerator&lt;T&gt;</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">interface</code> <code class="n">IAsyncEnumerable</code><code class="p">&lt;</code><code class="k">out</code> <code class="n">T</code><code class="p">&gt;</code>
<code class="p">{</code>
    <code class="n">IAsyncEnumerator</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="n">GetAsyncEnumerator</code><code class="p">(</code>
        <code class="n">CancellationToken</code> <code class="n">cancellationToken</code> <code class="p">=</code> <code class="k">default</code><code class="p">);</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">interface</code> <code class="n">IAsyncEnumerator</code><code class="p">&lt;</code><code class="k">out</code> <code class="n">T</code><code class="p">&gt;</code> <code class="p">:</code> <code class="n">IAsyncDisposable</code>
<code class="p">{</code>
    <code class="n">T</code> <code class="n">Current</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="p">}</code>

    <code class="n">ValueTask</code><code class="p">&lt;</code><code class="kt">bool</code><code class="p">&gt;</code> <code class="n">MoveNextAsync</code><code class="p">();</code>
<code class="p">}</code></pre></div>
<p><a data-primary="foreach loops" data-secondary="asynchronous" data-type="indexterm" id="idm45884784559376"/>Conceptually this is identical to the synchronous pattern: an asynchronous <code>foreach</code> will ask the collection object for an enumerator and will repeatedly ask it to advance to the next item, executing the loop body with the value returned by <code>Current</code> each time until the enumerator indicates that there are no more items. The main difference is that the synchronous <code>MoveNext</code> has been replaced by <code>MoveNextAsync</code>, which returns an awaitable <code>ValueTask&lt;T&gt;</code>. (The <code>IAsyncEnumerable&lt;T&gt;</code> interface also provides support for passing in a cancellation token. An asynchronous <code>foreach</code> won’t use that itself directly, but you can use this indirectly through the <code>WithCancellation</code> extension method for <code>IAsyncEnumerable&lt;T&gt;</code>.)</p>
<p><a data-primary="collections" data-secondary="asynchronous iteration with foreach loops" data-type="indexterm" id="idm45884784498912"/><a data-primary="collections" data-secondary="implementing IAsyncEnumerable&lt;T&gt; with iterators" data-type="indexterm" id="idm45884784497760"/>To consume an enumerable source that implements this pattern, you must put the <code>await</code> keyword in front of the <code>foreach</code>. C# can also help you to implement this pattern: <a data-type="xref" href="ch05.xhtml#ch_collections">Chapter 5</a> showed how you can use the <code>yield</code> keyword in an <em>iterator</em> method to implement <code>IEnumerable&lt;T&gt;</code>, but you can also return an <code>IAs⁠ync​Enu⁠mer⁠abl⁠e&lt;T&gt;</code>. <a data-primary="iterators" data-secondary="implementing IAsyncEnumerable&lt;T&gt; with" data-type="indexterm" id="idm45884784493616"/><a data-type="xref" href="#async_iteration">Example 17-9</a> shows both implementation and consumption of <code>IAsyncEnumerable&lt;T&gt;</code> in action.</p>
<div data-type="example" id="async_iteration">
<h5><span class="label">Example 17-9. </span>Consuming and producing asynchronous enumerables</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">await</code> <code class="nf">foreach</code> <code class="p">(</code><code class="kt">string</code> <code class="n">line</code> <code class="k">in</code> <code class="n">ReadLinesAsync</code><code class="p">(</code><code class="n">args</code><code class="p">[</code><code class="m">0</code><code class="p">]))</code>
<code class="p">{</code>
    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">line</code><code class="p">);</code>
<code class="p">}</code>

<code class="k">static</code> <code class="k">async</code> <code class="n">IAsyncEnumerable</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">ReadLinesAsync</code><code class="p">(</code><code class="kt">string</code> <code class="n">path</code><code class="p">)</code>
<code class="p">{</code>
    <code class="k">using</code> <code class="p">(</code><code class="kt">var</code> <code class="n">bodyTextReader</code> <code class="p">=</code> <code class="k">new</code> <code class="n">StreamReader</code><code class="p">(</code><code class="n">path</code><code class="p">))</code>
    <code class="p">{</code>
        <code class="k">while</code> <code class="p">(!</code><code class="n">bodyTextReader</code><code class="p">.</code><code class="n">EndOfStream</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="kt">string?</code> <code class="n">line</code> <code class="p">=</code> <code class="k">await</code> <code class="n">bodyTextReader</code><code class="p">.</code><code class="n">ReadLineAsync</code><code class="p">();</code>
            <code class="k">if</code> <code class="p">(</code><code class="n">line</code> <code class="k">is</code> <code class="n">not</code> <code class="k">null</code><code class="p">)</code> <code class="p">{</code> <code class="k">yield</code> <code class="k">return</code> <code class="n">line</code><code class="p">;</code> <code class="p">}</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>Since this language support makes creating and using <code>IAsyncEnumerable&lt;T&gt;</code> very similar to working with <code>IEnumerable&lt;T&gt;</code>, you might be wondering whether there are asynchronous versions of the various LINQ operators described in <a data-type="xref" href="ch10.xhtml#ch_linq">Chapter 10</a>. Unlike LINQ to Objects, <code>IAsyncEnumerable&lt;T&gt;</code> implementations are not in the parts of the runtime libraries built into .NET or .NET Standard, but Microsoft does supply a suitable NuGet package. If you add a reference to the <code>System.Linq.Async</code> package, the usual <code>using System.Linq;</code> declaration will make all the LINQ operators available on <code>IAsyncEnumerable&lt;T&gt;</code> expressions.</p>
<p>While we’re looking at asynchronous equivalents of widely implemented types, we should look at <code>IAsyncDisposable</code>.<a data-startref="ix_ch17-asciidoc14a" data-type="indexterm" id="idm45884784366176"/><a data-startref="ix_ch17-asciidoc14" data-type="indexterm" id="idm45884784365568"/><a data-startref="ix_ch17-asciidoc13" data-type="indexterm" id="idm45884784364960"/><a data-startref="ix_ch17-asciidoc12" data-type="indexterm" id="idm45884784364320"/></p>
</div></section>
<section data-pdf-bookmark="Asynchronous disposal" data-type="sect3"><div class="sect3" id="idm45884784676656">
<h3>Asynchronous disposal</h3>
<p><a data-primary="disposal" data-secondary="IAsyncDisposable interface" data-type="indexterm" id="idm45884784362368"/><a data-primary="async keyword" data-secondary="asynchronous disposal" data-type="indexterm" id="idm45884784361088"/><a data-primary="asynchronous disposal" data-type="indexterm" id="idm45884784360144"/><a data-primary="asynchronous language features" data-secondary="asynchronous disposal" data-type="indexterm" id="idm45884784359472"/><a data-primary="await keyword" data-secondary="asynchronous disposal" data-type="indexterm" id="idm45884784358560"/><a data-primary="IAsyncDisposable interface" data-type="indexterm" id="idm45884784357616"/>As <a data-type="xref" href="ch07.xhtml#ch_object_lifetime">Chapter 7</a> described, the <code>IDisposable</code> interface is implemented by types that need to perform some sort of cleanup promptly, such as closing an open handle, <a data-primary="using statement" data-type="indexterm" id="idm45884784355472"/>and there is language support in the form of <code>using</code> statements. But what if the cleanup involves potentially slow work, such as flushing data out to disk? .NET Core 3.1, .NET, and .NET Standard 2.1 provide the <code>IAsyncDisposable</code> interface for this scenario. As <a data-type="xref" href="#async_disposal">Example 17-10</a> shows, you can put the <code>await</code> keyword in front of a <code>using</code> statement to consume an asynchronously disposable resource. (You can also put <code>await</code> in front of a <code>using</code> declaration.)</p>
<div data-type="example" id="async_disposal">
<h5><span class="label">Example 17-10. </span>Consuming and implementing <code>IAsyncDisposable</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">await</code> <code class="nf">using</code> <code class="p">(</code><code class="n">DiagnosticWriter</code> <code class="n">w</code> <code class="p">=</code> <code class="k">new</code><code class="p">(</code><code class="s">@"c:\temp\log.txt"</code><code class="p">))</code>
<code class="p">{</code>
    <code class="k">await</code> <code class="n">w</code><code class="p">.</code><code class="n">LogAsync</code><code class="p">(</code><code class="s">"Test"</code><code class="p">);</code>
<code class="p">}</code>

<code class="k">class</code> <code class="nc">DiagnosticWriter</code> <code class="p">:</code> <code class="n">IAsyncDisposable</code>
<code class="p">{</code>
    <code class="k">private</code> <code class="n">StreamWriter</code><code class="p">?</code> <code class="n">_sw</code><code class="p">;</code>

    <code class="k">public</code> <code class="nf">DiagnosticWriter</code><code class="p">(</code><code class="kt">string</code> <code class="n">path</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">_sw</code> <code class="p">=</code> <code class="k">new</code> <code class="n">StreamWriter</code><code class="p">(</code><code class="n">path</code><code class="p">);</code>
    <code class="p">}</code>

    <code class="k">public</code> <code class="n">Task</code> <code class="nf">LogAsync</code><code class="p">(</code><code class="kt">string</code> <code class="n">message</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="n">_sw</code> <code class="k">is</code> <code class="k">null</code><code class="p">)</code>
        <code class="p">{</code> <code class="k">throw</code> <code class="k">new</code> <code class="n">ObjectDisposedException</code><code class="p">(</code><code class="n">nameof</code><code class="p">(</code><code class="n">DiagnosticWriter</code><code class="p">));</code> <code class="p">}</code>
        <code class="k">return</code> <code class="n">_sw</code><code class="p">.</code><code class="n">WriteLineAsync</code><code class="p">(</code><code class="n">message</code><code class="p">);</code>
    <code class="p">}</code>

    <code class="k">public</code> <code class="k">async</code> <code class="n">ValueTask</code> <code class="nf">DisposeAsync</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="n">_sw</code> <code class="p">!=</code> <code class="k">null</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="k">await</code> <code class="nf">LogAsync</code><code class="p">(</code><code class="s">"Done"</code><code class="p">);</code>
            <code class="k">await</code> <code class="n">_sw</code><code class="p">.</code><code class="n">DisposeAsync</code><code class="p">();</code>
            <code class="n">_sw</code> <code class="p">=</code> <code class="k">null</code><code class="p">;</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Although the <code>await</code> keyword appears in front of the <code>using</code> statement, the potentially slow operation that it awaits happens when execution leaves the <code>using</code> statement’s block. This is unavoidable since <code>using</code> statements and declarations effectively hide the call to <code>Dispose</code>.</p>
</div>
<p><a data-type="xref" href="#async_disposal">Example 17-10</a> also shows how to implement <code>IAsyncDisposable</code>. <a data-primary="DisposeAsync method" data-type="indexterm" id="idm45884784182416"/>Whereas the synchronous <code>IDisposable</code> defines a single <code>Dispose</code> method, its asynchronous counterpart defines a single <code>DisposeAsync</code> method that returns a <code>ValueTask</code>. This enables us to annotate the method with <code>async</code>. An <code>await using</code> statement will ensure that the task returned by <code>DisposeAsync</code> completes at the end of its block before execution continues. You may have noticed that we’ve used a few different return types for <code>async</code> methods. Iterators are a special case, just as they are in synchronous code, but what about these methods that return various task types?</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Returning a Task" data-type="sect2"><div class="sect2" id="returning_a_task">
<h2>Returning a Task</h2>
<p><a data-primary="async keyword" data-secondary="returning a task" data-type="indexterm" id="ix_ch17-asciidoc15"/><a data-primary="asynchronous language features" data-secondary="returning a task" data-type="indexterm" id="ix_ch17-asciidoc16"/><a data-primary="await keyword" data-secondary="returning a task" data-type="indexterm" id="ix_ch17-asciidoc17"/><a data-primary="Task and Task&lt;T&gt; classes" data-secondary="returning" data-type="indexterm" id="ix_ch17-asciidoc18"/>Any method that uses <code>await</code> could itself take a certain amount of time to run, so as well as being able to call asynchronous APIs, you will usually also want to present an asynchronous public face. The C# compiler enables methods marked with the <code>async</code> keyword to return an object that represents the asynchronous work in progress. Instead of returning <code>void</code>, you can return a <code>Task</code>, or you can return a <code>Task&lt;T&gt;</code>, where <code>T</code> is any type. This enables callers to discover the status of the work your method performs, the opportunity to attach continuations, and if you use <code>Task&lt;T&gt;</code>, a way to get the result. Alternatively, you can return the value type equivalents, <code>ValueTask</code> and <code>ValueTask&lt;T&gt;</code>. Returning any of these means that if your method is called from another <code>async</code> method, it can use <code>await</code> to wait for your method to complete and, if applicable, to collect its result.</p>
<p>Returning a task is almost always preferable to <code>void</code> when using <code>async</code> because with a <code>void</code> return type, there’s no way for callers to know when your method has really finished, or to discover when it throws an exception. (Asynchronous methods can continue to run after returning—in fact, that’s the whole point—so by the time you throw an exception, the original caller will probably not be on the stack.) By returning a task object, you provide the compiler with a way to make exceptions available and, where applicable, a way to provide a result.</p>
<p>Returning a task is so trivially easy that there’s very little reason not to. To modify the method in <a data-type="xref" href="#multiple_asynchronous_operations">Example 17-5</a> to return a task, I only need to make a single change. I make the return type <code>Task</code> instead of <code>void</code>, as shown in <a data-type="xref" href="#ex_returning_a_task">Example 17-11</a>, and the rest of the code can remain exactly the same.</p>
<div data-type="example" id="ex_returning_a_task">
<h5><span class="label">Example 17-11. </span>Returning a <code>Task</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">private</code> <code class="k">async</code> <code class="n">Task</code> <code class="nf">FetchAndShowBody</code><code class="p">(</code><code class="kt">string</code> <code class="n">url</code><code class="p">,</code> <code class="n">IHttpClientFactory</code> <code class="n">cf</code><code class="p">)</code>
<code class="c1">// ...as before</code></pre></div>
<p>The compiler automatically generates the code required to produce a <code>Task</code> object (or a <code>ValueTask</code>, if you use that as your return type) and set it into a completed or faulted state when the method either returns or throws an exception. A return type of <code>Task</code> is the asynchronous equivalent of <code>void</code>, since the <code>Task</code> produces no result when it completes (which is why we don’t need to add a <code>return</code> statement to this method even though it now has a return type of <code>Task</code>). And if you want to return a result from your task, that’s also easy. Make the return type <code>Task&lt;T&gt;</code> or <code>ValueTask&lt;T&gt;</code>, where <code>T</code> is your result type, and then you can use the <code>return</code> keyword as though your method were a normal, non-async method, as <a data-type="xref" href="#returning_a_task_of_t">Example 17-12</a> shows.</p>
<div data-type="example" id="returning_a_task_of_t">
<h5><span class="label">Example 17-12. </span>Returning a <code>Task&lt;T&gt;</code></h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="k">public</code> <code class="k">static</code> <code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">string?</code><code class="p">&gt;</code> <code class="n">GetServerHeader</code><code class="p">(</code>
    <code class="kt">string</code> <code class="n">url</code><code class="p">,</code> <code class="n">IHttpClientFactory</code> <code class="n">cf</code><code class="p">)</code>
<code class="p">{</code>
    <code class="k">using</code> <code class="p">(</code><code class="n">HttpClient</code> <code class="n">w</code> <code class="p">=</code> <code class="n">cf</code><code class="p">.</code><code class="n">CreateClient</code><code class="p">(</code><code class="p">)</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="kt">var</code> <code class="n">request</code> <code class="p">=</code> <code class="k">new</code> <code class="n">HttpRequestMessage</code><code class="p">(</code><code class="n">HttpMethod</code><code class="p">.</code><code class="n">Head</code><code class="p">,</code> <code class="n">url</code><code class="p">)</code><code class="p">;</code>
        <code class="n">HttpResponseMessage</code> <code class="n">response</code> <code class="p">=</code> <code class="k">await</code> <code class="n">w</code><code class="p">.</code><code class="n">SendAsync</code><code class="p">(</code>
            <code class="n">request</code><code class="p">,</code> <code class="n">HttpCompletionOption</code><code class="p">.</code><code class="n">ResponseHeadersRead</code><code class="p">)</code><code class="p">;</code>

        <code class="kt">string?</code> <code class="n">result</code> <code class="p">=</code> <code class="k">null</code><code class="p">;</code>
        <code class="n">IEnumerable</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code><code class="p">?</code> <code class="n">values</code><code class="p">;</code>
        <code class="k">if</code> <code class="p">(</code><code class="n">response</code><code class="p">.</code><code class="n">Headers</code><code class="p">.</code><code class="n">TryGetValues</code><code class="p">(</code><code class="s">"Server"</code><code class="p">,</code> <code class="k">out</code> <code class="n">values</code><code class="p">)</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="n">result</code> <code class="p">=</code> <code class="n">values</code><code class="p">.</code><code class="n">FirstOrDefault</code><code class="p">(</code><code class="p">)</code><code class="p">;</code>
        <code class="p">}</code>
        <strong><code class="k">return</code> <code class="n">result</code><code class="p">;</code></strong>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>This fetches HTTP headers asynchronously in the same way as <a data-type="xref" href="#using_async_and_await_when_fetching_http">Example 17-1</a>, but instead of displaying the results, this picks out the value of the first <code>Server:</code> header and makes that the result of the <code>Task&lt;string?&gt;</code> that this method returns. (It needs to be a nullable string because the header might not be present.) As you can see, the <code>return</code> statement just returns a <code>string?</code>, even though the method’s return type is <code>Task&lt;string?&gt;</code>. The compiler generates code that completes the task and arranges for that string to be the result. With either a <code>Task</code> or <code>Task&lt;T&gt;</code> return type, the generated code produces a task similar to the kind you would get using <code>Task​Com⁠ple⁠tio⁠nSo⁠urc⁠e&lt;T&gt;</code>, as described in <a data-type="xref" href="ch16.xhtml#ch_multithreading">Chapter 16</a>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Just as the <code>await</code> keyword can use any asynchronous method that fits a particular pattern (described later), C# offers the same flexibility when it comes to implementing an asynchronous method. You are not limited to <code>Task</code>, <code>Task&lt;T&gt;</code>, <code>ValueTask</code>, and <code>ValueTask&lt;T&gt;</code>. You can return any type that meets two conditions: it must be annotated with the <code>AsyncMethodBuilder</code> attribute, identifying a class that the compiler can use to manage the progress and completion of the task, and it must also offer a <code>GetAwaiter</code> method that returns a type implementing the <code>ICriticalNotifyCompletion</code> interface.</p>
</div>
<p>There’s very little downside to returning one of the built-in task types. Callers are not obliged to do anything with it, so your method will be just as easy to use as a <code>void</code> method but with the added advantage that a task is available to callers that want one. About the only reason for returning <code>void</code> would be if some external constraint forces your method to have a particular signature. For example, most event handlers are required to have a return type of <code>void</code>—that’s why some of my earlier examples did it. But unless you are forced to use it, <code>void</code> is not a recommended return type for an asynchronous method.<a data-startref="ix_ch17-asciidoc18" data-type="indexterm" id="idm45884783958960"/><a data-startref="ix_ch17-asciidoc17" data-type="indexterm" id="idm45884783958256"/><a data-startref="ix_ch17-asciidoc16" data-type="indexterm" id="idm45884783957584"/><a data-startref="ix_ch17-asciidoc15" data-type="indexterm" id="idm45884783956912"/></p>
</div></section>
<section data-pdf-bookmark="Applying async to Nested Methods" data-type="sect2"><div class="sect2" id="applying_async_to_nested_methods">
<h2>Applying async to Nested Methods</h2>
<p><a data-primary="async keyword" data-secondary="applying to nested methods" data-type="indexterm" id="idm45884783950544"/><a data-primary="asynchronous language features" data-secondary="applying async to nested methods" data-type="indexterm" id="idm45884783949600"/><a data-primary="await keyword" data-secondary="applying async to nested methods" data-type="indexterm" id="idm45884783948720"/><a data-primary="nested methods, applying async to" data-type="indexterm" id="idm45884783947808"/><a data-primary="nested methods" data-see="local functions" data-type="indexterm" id="idm45884783947168"/>In the examples shown so far, I have applied the <code>async</code> keyword to ordinary methods. You can also use it on anonymous functions (either anonymous methods or lambdas) and local functions. For example, if you’re writing a program that creates UI elements programmatically, you may find it convenient to attach event handlers written as lambdas, and you might want to make some of those asynchronous, as <a data-type="xref" href="#an_asynchronous_lambda">Example 17-13</a> does.</p>
<div data-type="example" id="an_asynchronous_lambda">
<h5><span class="label">Example 17-13. </span>An asynchronous lambda</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">okButton</code><code class="p">.</code><code class="n">Click</code> <code class="p">+=</code> <code class="k">async</code> <code class="p">(</code><code class="n">s</code><code class="p">,</code> <code class="n">e</code><code class="p">)</code> <code class="p">=&gt;</code>
<code class="p">{</code>
    <code class="k">using</code> <code class="p">(</code><code class="n">HttpClient</code> <code class="n">w</code> <code class="p">=</code> <code class="k">this</code><code class="p">.</code><code class="n">clientFactory</code><code class="p">.</code><code class="n">CreateClient</code><code class="p">())</code>
    <code class="p">{</code>
        <code class="n">infoTextBlock</code><code class="p">.</code><code class="n">Text</code> <code class="p">=</code> <code class="k">await</code> <code class="n">w</code><code class="p">.</code><code class="n">GetStringAsync</code><code class="p">(</code><code class="n">uriTextBox</code><code class="p">.</code><code class="n">Text</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">};</code></pre></div>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>This has nothing to do with asynchronous delegate invocation, the now-deprecated technique I mentioned in <a data-type="xref" href="ch09.xhtml#ch_delegates_lambdas_events">Chapter 9</a> for using the thread pool that used to be popular before anonymous methods and the TPL provided better alternatives.<a data-startref="ix_ch17-asciidoc3" data-type="indexterm" id="idm45884783863392"/><a data-startref="ix_ch17-asciidoc2" data-type="indexterm" id="idm45884783862784"/><a data-startref="ix_ch17-asciidoc1" data-type="indexterm" id="idm45884783862112"/></p>
</div>
</div></section>
</div></section>
<section data-pdf-bookmark="The await Pattern" data-type="sect1"><div class="sect1" id="the_await_pattern">
<h1>The await Pattern</h1>
<p><a data-primary="asynchronous language features" data-secondary="await pattern" data-type="indexterm" id="ix_ch17-asciidoc19"/><a data-primary="await pattern" data-type="indexterm" id="ix_ch17-asciidoc20"/>The majority of the asynchronous APIs that support the <code>await</code> keyword will return a TPL task of some kind. However, C# does not absolutely require this. It will <code>await</code> anything that implements a particular pattern. Moreover, although <code>Task</code> supports this pattern, the way it works means that the compiler uses tasks in a slightly different way than you would when using the TPL directly—this is partly why I said earlier that the code showing task-based asynchronous equivalents to <code>await</code>-based code did not represent exactly what the compiler does. In this section, I’m going to show how the compiler uses tasks and other types that support <code>await</code> to better illustrate how it really works.</p>
<p>I’ll create a custom implementation of the <code>await</code> pattern to show what the C# compiler expects. <a data-type="xref" href="#calling_a_custom_awaitable_implementatio">Example 17-14</a> shows an asynchronous method, <code>UseCustomAsync</code>, that uses this custom implementation. It assigns the result of the <code>await</code> expression into a <code>string</code>, so it clearly expects the asynchronous operation to produce a <code>string</code> as its output. It calls a method, <code>CustomAsync</code>, which returns our implementation of the pattern (which will be shown later in <a data-type="xref" href="#an_excessively_simple_await_pattern_impl">Example 17-15</a>). As you can see, this is not a <code>Task&lt;string&gt;</code>.</p>
<div data-type="example" id="calling_a_custom_awaitable_implementatio">
<h5><span class="label">Example 17-14. </span>Calling a custom awaitable implementation</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">static</code> <code class="k">async</code> <code class="n">Task</code> <code class="nf">UseCustomAsync</code><code class="p">()</code>
<code class="p">{</code>
    <code class="kt">string</code> <code class="n">result</code> <code class="p">=</code> <code class="k">await</code> <code class="n">CustomAsync</code><code class="p">();</code>
    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">result</code><code class="p">);</code>
<code class="p">}</code>

<code class="k">public</code> <code class="k">static</code> <code class="n">MyAwaitableType</code> <code class="nf">CustomAsync</code><code class="p">()</code>
<code class="p">{</code>
    <code class="k">return</code> <code class="k">new</code> <code class="nf">MyAwaitableType</code><code class="p">();</code>
<code class="p">}</code></pre></div>
<p>The compiler expects the <code>await</code> keyword’s operand to be a type that provides a method called <code>GetAwaiter</code>. This can be an ordinary instance member or an extension method. (So it is possible to make <code>await</code> work with a type that does not support it innately by defining a suitable extension method.) This method must return an object or value, known as an <em>awaiter</em>, that does three things.</p>
<p><a data-primary="IsCompleted property" data-type="indexterm" id="ix_ch17-asciidoc21"/>First, the awaiter must provide a <code>bool</code> property called <code>IsCompleted</code>. The code that the compiler generates for the <code>await</code> uses this to discover whether the operation has already finished. In situations where no slow work needs to be done (e.g., when a call to <code>ReadAsync</code> on a <code>Stream</code> can be handled immediately with data that the stream already has in a buffer), it would be a waste to set up a callback. So <code>await</code> avoids creating an unnecessary delegate if the <code>IsCompleted</code> property returns <code>true</code>, and it will just continue straight on with the remainder of the method.</p>
<p>The compiler also requires a way to get the result once the work is complete, so the awaiter must have a <code>GetResult</code> method. Its return type defines the result type of the operation—it will be the type of the <code>await</code> expression. (If there is no result, the return type is <code>void</code>. <code>GetResult</code> still needs to be present, because it is responsible for throwing exceptions if the operation fails.) Since <a data-type="xref" href="#calling_a_custom_awaitable_implementatio">Example 17-14</a> assigns the result of the <code>await</code> into a variable of type <code>string</code>, the <code>GetResult</code> method of the awaiter returned by the <code>MyAwaitableType</code> class’s <code>GetAwaiter</code> must be <code>string</code> (or some type implicitly convertible to <code>string</code>).</p>
<p>Finally, the compiler needs to be able to supply a callback. If <code>IsCompleted</code> returns <code>false</code>, indicating that the operation is not yet complete, the code generated for the <code>await</code> expression will create a delegate that will run the rest of the method. It needs to be able to pass that to the awaiter. (This is similar to passing a delegate to a task’s <code>ContinueWith</code> method.) For this, the compiler requires not just a method but also an interface. You are required to implement <code>INotifyCompletion</code>, and there’s an optional interface that it’s recommended you also implement where possible called <code>ICriticalNotifyCompletion</code>. These do similar things: each defines a single method (<code>OnCompleted</code> and <code>UnsafeOnCompleted</code>, respectively) that takes a single <code>Action</code> delegate, and the awaiter must invoke this delegate once the operation completes. The distinction between these two interfaces and their corresponding methods is that the first requires the awaiter to flow the current execution context to the target method, whereas the latter does not. The .NET runtime libraries features that the C# compiler uses to help build asynchronous methods always flow the execution context for you, so the generated code typically calls <span class="keep-together"><code>UnsafeOnCompleted</code></span> where available to avoid flowing it twice. (If the compiler used <code>OnCompleted</code>, the awaiter would flow context too.) However, on .NET Framework, you’ll find that security constraints may prevent the use of <span class="keep-together"><code>UnsafeOnCompleted</code></span>. (.NET Framework had a concept of <em>untrusted code</em>. Code from potentially untrustworthy origins—perhaps because it was downloaded from the internet—would be subject to various constraints. This concept was dropped in .NET Core, but various vestiges remain, such as this design detail of asynchronous operations.) Because <code>UnsafeOnCompleted</code> does not flow execution context, untrusted code must not be allowed to call it, because that would provide a way to bypass certain security mechanisms. .NET Framework implementations 
<span class="keep-together">of <code>UnsafeOnCompleted</code></span> provided for the various task types are marked with the 
<span class="keep-together"><code>SecurityCriticalAttribute</code>,</span> which means that only fully trusted code can call it. We need <code>OnCompleted</code> so that partially trusted code is able to use the awaiter.</p>
<p><a data-type="xref" href="#an_excessively_simple_await_pattern_impl">Example 17-15</a> shows the minimum viable implementation of the awaiter pattern. This is oversimplified, because it always completes synchronously, so its <code>OnCompleted</code> method doesn’t do anything. If you use the <code>await</code> keyword on an instance of <code>My​Awa⁠ita⁠ble⁠Type</code>, the code that the C# compiler generates will never call <code>OnCompleted</code>. The <code>await</code> pattern requires that <code>OnCompleted</code> is only called if <code>IsCompleted</code> returns <code>false</code>, and, in this example, <code>IsCompleted</code> always returns <code>true</code>. This is why I’ve made <code>OnCompleted</code> throw an exception. However, although this example is unrealistically simple, it will serve to illustrate what <code>await</code> does.</p>
<div data-type="example" id="an_excessively_simple_await_pattern_impl">
<h5><span class="label">Example 17-15. </span>An excessively simple <code>await</code> pattern implementation</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">MyAwaitableType</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="n">MinimalAwaiter</code> <code class="nf">GetAwaiter</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="k">return</code> <code class="k">new</code> <code class="nf">MinimalAwaiter</code><code class="p">();</code>
    <code class="p">}</code>

    <code class="k">public</code> <code class="k">class</code> <code class="nc">MinimalAwaiter</code> <code class="p">:</code> <code class="n">INotifyCompletion</code>
    <code class="p">{</code>
        <code class="k">public</code> <code class="kt">bool</code> <code class="n">IsCompleted</code> <code class="p">=&gt;</code> <code class="k">true</code><code class="p">;</code>

        <code class="k">public</code> <code class="kt">string</code> <code class="nf">GetResult</code><code class="p">()</code> <code class="p">=&gt;</code> <code class="s">"This is a result"</code><code class="p">;</code>

        <code class="k">public</code> <code class="k">void</code> <code class="nf">OnCompleted</code><code class="p">(</code><code class="n">Action</code> <code class="n">continuation</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="k">throw</code> <code class="k">new</code> <code class="nf">NotImplementedException</code><code class="p">();</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>With this code in place, we can see what <a data-type="xref" href="#calling_a_custom_awaitable_implementatio">Example 17-14</a> will do. It will call <code>Get​Awai⁠ter</code> on the <code>MyAwaitableType</code> instance returned by the <code>CustomAsync</code> method. Then it will test the awaiter’s <code>IsCompleted</code> property, and if it’s <code>true</code> (which it will be), it will run the rest of the method immediately. The compiler doesn’t know <code>IsCompleted</code> will always be <code>true</code> in this case, so it generates code to handle the <code>false</code> case. This will create a delegate that, when invoked, will run the rest of the method and pass that delegate to the waiter’s <code>OnCompleted</code> method. (I’ve not provided <code>UnsafeOnCompleted</code> here, so it is forced to use <code>OnCompleted</code>.) <a data-type="xref" href="#a_very_rough_approximation_of_what_await">Example 17-16</a> shows code that does all of this.</p>
<div data-type="example" id="a_very_rough_approximation_of_what_await">
<h5><span class="label">Example 17-16. </span>A very rough approximation of what <code>await</code> does</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">static</code> <code class="k">void</code> <code class="nf">ManualUseCustomAsync</code><code class="p">()</code>
<code class="p">{</code>
    <code class="kt">var</code> <code class="n">awaiter</code> <code class="p">=</code> <code class="n">CustomAsync</code><code class="p">().</code><code class="n">GetAwaiter</code><code class="p">();</code>
    <code class="k">if</code> <code class="p">(</code><code class="n">awaiter</code><code class="p">.</code><code class="n">IsCompleted</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">TheRest</code><code class="p">(</code><code class="n">awaiter</code><code class="p">);</code>
    <code class="p">}</code>
    <code class="k">else</code>
    <code class="p">{</code>
        <code class="n">awaiter</code><code class="p">.</code><code class="n">OnCompleted</code><code class="p">(()</code> <code class="p">=&gt;</code> <code class="n">TheRest</code><code class="p">(</code><code class="n">awaiter</code><code class="p">));</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="k">private</code> <code class="k">static</code> <code class="k">void</code> <code class="nf">TheRest</code><code class="p">(</code><code class="n">MyAwaitableType</code><code class="p">.</code><code class="n">MinimalAwaiter</code> <code class="n">awaiter</code><code class="p">)</code>
<code class="p">{</code>
    <code class="kt">string</code> <code class="n">result</code> <code class="p">=</code> <code class="n">awaiter</code><code class="p">.</code><code class="n">GetResult</code><code class="p">();</code>
    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">result</code><code class="p">);</code>
<code class="p">}</code></pre></div>
<p>I’ve split the method into two pieces, because the C# compiler avoids creating a delegate in the case where <code>IsCompleted</code> is <code>true</code>, and I wanted to do the same. However, this is not quite what the C# compiler does—it also manages to avoid creating an extra method for each <code>await</code> statement, but this means it has to create considerably more complex code. In fact, for methods that just contain a single <code>await</code>, it introduces rather more overhead than <a data-type="xref" href="#a_very_rough_approximation_of_what_await">Example 17-16</a>. However, once the number of <code>await</code> expressions starts to increase, the complexity pays off, because the compiler does not need to add any further methods. <a data-type="xref" href="#a_slightly_closer_approximation_to_how_a">Example 17-17</a> shows something closer to what the compiler does.</p>
<div data-type="example" id="a_slightly_closer_approximation_to_how_a">
<h5><span class="label">Example 17-17. </span>A slightly closer approximation to how <code>await</code> works</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">private</code> <code class="k">class</code> <code class="nc">ManualUseCustomAsyncState</code>
<code class="p">{</code>
    <code class="k">private</code> <code class="kt">int</code> <code class="n">state</code><code class="p">;</code>
    <code class="k">private</code> <code class="n">MyAwaitableType</code><code class="p">.</code><code class="n">MinimalAwaiter</code><code class="p">?</code> <code class="n">awaiter</code><code class="p">;</code>

    <code class="k">public</code> <code class="k">void</code> <code class="nf">MoveNext</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="n">state</code> <code class="p">==</code> <code class="m">0</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="n">awaiter</code> <code class="p">=</code> <code class="n">CustomAsync</code><code class="p">().</code><code class="n">GetAwaiter</code><code class="p">();</code>
            <code class="k">if</code> <code class="p">(!</code><code class="n">awaiter</code><code class="p">.</code><code class="n">IsCompleted</code><code class="p">)</code>
            <code class="p">{</code>
                <code class="n">state</code> <code class="p">=</code> <code class="m">1</code><code class="p">;</code>
                <code class="n">awaiter</code><code class="p">.</code><code class="n">OnCompleted</code><code class="p">(</code><code class="n">MoveNext</code><code class="p">);</code>
                <code class="k">return</code><code class="p">;</code>
            <code class="p">}</code>
        <code class="p">}</code>
        <code class="kt">string</code> <code class="n">result</code> <code class="p">=</code> <code class="n">awaiter</code><code class="p">!.</code><code class="n">GetResult</code><code class="p">();</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">result</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="k">static</code> <code class="k">void</code> <code class="nf">ManualUseCustomAsync</code><code class="p">()</code>
<code class="p">{</code>
    <code class="kt">var</code> <code class="n">s</code> <code class="p">=</code> <code class="k">new</code> <code class="n">ManualUseCustomAsyncState</code><code class="p">();</code>
    <code class="n">s</code><code class="p">.</code><code class="n">MoveNext</code><code class="p">();</code>
<code class="p">}</code></pre></div>
<p>This is still simpler than the real code, but it shows the basic strategy: the compiler generates a nested type that acts as a state machine. This has a field (<code>state</code>) that keeps track of where the method has got to so far, and it also contains fields corresponding to the method’s local variables (just the <code>awaiter</code> variable in this example). When an asynchronous operation does not block (i.e., its <code>IsCompleted</code> returns <code>true</code> immediately), the method can just continue to the next part, but once it encounters an operation that needs some time, it updates the <code>state</code> variable to remember where it is and then uses the relevant awaiter’s <code>OnCompleted</code> method. Notice that the method it asks to be called on completion is the same one that is already running: <code>MoveNext</code>. And this continues to be the case no matter how many <code>await</code>s you need to perform—every completion callback invokes the same method; the class simply remembers how far it had already gotten, and the method picks up from there. That way, no matter how many times an <code>await</code> blocks, it never needs to create more than one delegate.<a data-startref="ix_ch17-asciidoc21" data-type="indexterm" id="idm45884783440400"/></p>
<p><a data-primary="unspeakable names" data-type="indexterm" id="idm45884783439440"/>I won’t show the real generated code. It is borderline unreadable, because it contains a lot of <em>unspeakable</em> identifiers. (Remember from <a data-type="xref" href="ch03.xhtml#ch_types">Chapter 3</a> that when the C# compiler needs to generate items with identifiers that must not collide with or be directly visible to our code, it creates a name that the runtime considers legal but that is not legal in C#; this is called an <em>unspeakable</em> name.) Moreover, the compiler-generated code uses various helper classes from the <code>System.Runtime.CompilerServices</code> namespace that are intended for use only from asynchronous methods to manage things like determining which of the completion interfaces the awaiter supports and handling the related <span class="keep-together">execution</span> context flow. Also, if the method returns a task, there are additional helpers to create and update that. But when it comes to understanding the nature of the relationship between an awaitable type and the code the compiler produces for an <code>await</code> expression, <a data-type="xref" href="#a_slightly_closer_approximation_to_how_a">Example 17-17</a> gives a fair impression.<a data-startref="ix_ch17-asciidoc20" data-type="indexterm" id="idm45884783401344"/><a data-startref="ix_ch17-asciidoc19" data-type="indexterm" id="idm45884783400672"/></p>
</div></section>
<section data-pdf-bookmark="Error Handling" data-type="sect1"><div class="sect1" id="error_handling-id1">
<h1>Error Handling</h1>
<p><a data-primary="asynchronous language features" data-secondary="error handling" data-type="indexterm" id="ix_ch17-asciidoc22"/><a data-primary="error handling" data-seealso="exception handling; exceptions" data-type="indexterm" id="ix_ch17-asciidoc23"/>The <code>await</code> keyword deals with exceptions much as you’d hope it would: if an asynchronous operation fails, the exception emerges from the <code>await</code> expression that was consuming that operation. The general principle that asynchronous code can be structured in the same way as ordinary synchronous code continues to apply in the face of exceptions, and the compiler does whatever work is required to make that possible.</p>
<p><a data-type="xref" href="#multiple_potential_points_of_failure">Example 17-18</a> contains two asynchronous operations, one of which occurs in a loop. This is similar to <a data-type="xref" href="#multiple_asynchronous_operations">Example 17-5</a>. It does something a bit different with the content it fetches, but most importantly, it returns a task. This provides a place for an error to go if any of the operations should fail.</p>
<div data-type="example" id="multiple_potential_points_of_failure">
<h5><span class="label">Example 17-18. </span>Multiple potential points of failure</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">private</code> <code class="k">static</code> <code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">FindLongestLineAsync</code><code class="p">(</code>
    <code class="kt">string</code> <code class="n">url</code><code class="p">,</code> <code class="n">IHttpClientFactory</code> <code class="n">cf</code><code class="p">)</code>
<code class="p">{</code>
    <code class="k">using</code> <code class="p">(</code><code class="n">HttpClient</code> <code class="n">w</code> <code class="p">=</code> <code class="n">cf</code><code class="p">.</code><code class="n">CreateClient</code><code class="p">())</code>
    <code class="p">{</code>
        <code class="n">Stream</code> <code class="n">body</code> <code class="p">=</code> <code class="k">await</code> <code class="n">w</code><code class="p">.</code><code class="n">GetStreamAsync</code><code class="p">(</code><code class="n">url</code><code class="p">);</code>
        <code class="k">using</code> <code class="p">(</code><code class="kt">var</code> <code class="n">bodyTextReader</code> <code class="p">=</code> <code class="k">new</code> <code class="n">StreamReader</code><code class="p">(</code><code class="n">body</code><code class="p">))</code>
        <code class="p">{</code>
            <code class="kt">string</code> <code class="n">longestLine</code> <code class="p">=</code> <code class="kt">string</code><code class="p">.</code><code class="n">Empty</code><code class="p">;</code>
            <code class="k">while</code> <code class="p">(!</code><code class="n">bodyTextReader</code><code class="p">.</code><code class="n">EndOfStream</code><code class="p">)</code>
            <code class="p">{</code>
                <code class="kt">string?</code> <code class="n">line</code> <code class="p">=</code> <code class="k">await</code> <code class="n">bodyTextReader</code><code class="p">.</code><code class="n">ReadLineAsync</code><code class="p">();</code>
                <code class="k">if</code> <code class="p">(</code><code class="n">line</code> <code class="k">is</code> <code class="n">not</code> <code class="k">null</code> <code class="p">&amp;&amp;</code> <code class="n">longestLine</code><code class="p">.</code><code class="n">Length</code> <code class="p">&gt;</code> <code class="n">line</code><code class="p">.</code><code class="n">Length</code><code class="p">)</code>
                <code class="p">{</code>
                    <code class="n">longestLine</code> <code class="p">=</code> <code class="n">line</code><code class="p">;</code>
                <code class="p">}</code>
            <code class="p">}</code>
            <code class="k">return</code> <code class="n">longestLine</code><code class="p">;</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>Exceptions are potentially challenging with asynchronous operations because by the time a failure occurs, the method call that originally started the work is likely to have returned. The <code>FindLongestLineAsync</code> method in this example will usually return as soon as it executes the first <code>await</code> expression. (It’s possible that it won’t—if HTTP caching is in use, or if the <code>IHttpClientFactory</code> returns a client configured as a fake that never makes any real requests, this operation could succeed immediately. But typically, that operation will take some time, causing the method to return.) Suppose this operation succeeds and the rest of the method starts to run, but partway through the loop that retrieves the body of the response, the <span class="keep-together">computer</span> loses network connectivity. This will cause one of the operations started by <code>ReadLineAsync</code> to fail.</p>
<p>An exception will emerge from the <code>await</code> for that operation. There is no exception handling in this method, so what should happen next? Normally, you’d expect the exception to start working its way up the stack, but what’s above this method on the stack? It almost certainly won’t be the code that originally called it—remember, the method will usually return as soon as it hits the first <code>await</code>, so at this stage, we’re running as a result of being called back by the awaiter for the task returned by <code>ReadLineAsync</code>. Chances are, we’ll be running on some thread from the thread pool, and the code directly above us in the stack will be part of the task awaiter. This won’t know what to do with our exception.</p>
<p>But the exception does not propagate up the stack. When an exception goes unhandled in an <code>async</code> method that returns a task, the compiler-generated code catches it and puts the task returned by that method into a faulted state (which will in turn mean that anything that was waiting for that task can now continue). If the code that called <code>FindLongestLineAsync</code> is working directly with the TPL, it will be able to see the exception by detecting that faulted state and retrieving the task’s <code>Exception</code> property. Alternatively, it can either call <code>Wait</code> or fetch the task’s <code>Result</code> property, and in either case, the task will throw an <code>AggregateException</code> containing the original exception. But if the code calling <code>FindLongestLineAsync</code> uses <code>await</code> on the task we return, the exception gets rethrown from that. From the calling code’s point of view, it looks just like the exception emerged as it would normally, as <a data-type="xref" href="#handling_exceptions_from_await">Example 17-19</a> shows.</p>
<div data-type="example" id="handling_exceptions_from_await">
<h5><span class="label">Example 17-19. </span>Handling exceptions from <code>await</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">try</code>
<code class="p">{</code>
    <code class="kt">string</code> <code class="n">longest</code> <code class="p">=</code> <code class="k">await</code> <code class="n">FindLongestLineAsync</code><code class="p">(</code>
        <code class="s">"http://192.168.22.1/"</code><code class="p">,</code> <code class="k">this</code><code class="p">.</code><code class="n">clientFactory</code><code class="p">);</code>
    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Longest line: "</code> <code class="p">+</code> <code class="n">longest</code><code class="p">);</code>
<code class="p">}</code>
<code class="k">catch</code> <code class="p">(</code><code class="n">HttpRequestException</code> <code class="n">x</code><code class="p">)</code>
<code class="p">{</code>
    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Error fetching page: "</code> <code class="p">+</code> <code class="n">x</code><code class="p">.</code><code class="n">Message</code><code class="p">);</code>
<code class="p">}</code></pre></div>
<p>This is almost deceptively simple. Remember that the compiler performs substantial restructuring of the code around each <code>await</code>, and the execution of what looks like a single method may involve multiple calls in practice. So preserving the semantics of even a simple exception handling block like this (or related constructs, such as a <code>using</code> statement) is nontrivial. If you have ever attempted to write equivalent error handling for asynchronous work without the help of the compiler, you’ll appreciate how much C# is doing for you here.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>await</code> does not rethrow the <code>AggregateException</code> provided by the task’s <code>Exception</code> property. It rethrows the original exception. This enables <code>async</code> methods to handle the error in the same way synchronous code would.</p>
</div>
<section data-pdf-bookmark="Validating Arguments" data-type="sect2"><div class="sect2" id="validating_arguments">
<h2>Validating Arguments</h2>
<p><a data-primary="arguments" data-secondary="validation" data-type="indexterm" id="idm45884783155328"/><a data-primary="asynchronous language features" data-secondary="validating arguments" data-type="indexterm" id="idm45884783154352"/><a data-primary="error handling" data-secondary="validating arguments" data-type="indexterm" id="idm45884783153440"/><a data-primary="ArgumentNullException class" data-type="indexterm" id="idm45884783152496"/>There’s one potentially surprising aspect of the way C# automatically reports exceptions through the task your asynchronous method returns. It means that code such as that in <a data-type="xref" href="#surprising_argument_validation">Example 17-20</a> doesn’t do what you might expect.</p>
<div data-type="example" id="surprising_argument_validation">
<h5><span class="label">Example 17-20. </span>Potentially surprising argument validation</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">FindLongestLineAsync</code><code class="p">(</code><code class="kt">string</code> <code class="n">url</code><code class="p">)</code>
<code class="p">{</code>
    <code class="n">ArgumentNullException</code><code class="p">.</code><code class="n">ThrowIfNull</code><code class="p">(</code><code class="n">url</code><code class="p">);</code>
    <code class="p">...</code></pre></div>
<p>Inside an <code>async</code> method, the compiler treats all exceptions in the same way: none are allowed to pass up the stack as they would with a normal method, and they will always be reported by faulting the returned task. This is true even of exceptions thrown before the first <code>await</code>. In this example, the argument validation happens before the method does anything else, so at that stage, we will still be running on the original caller’s thread. You might have thought that an argument exception thrown by this part of the code would propagate directly back to the caller. In fact, the caller will see a nonexceptional return, producing a task that is in a faulted state.</p>
<p>If the calling method immediately calls <code>await</code> on the return task, this won’t matter much—it will see the exception in any case. But some code may choose not to wait immediately, in which case it won’t see the argument exception until later. For simple argument validation exceptions where the caller has clearly made a programming error, you might expect code to throw an exception immediately, but this code doesn’t do that.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If it’s not possible to determine whether a particular argument is valid without performing slow work, you will not be able to throw immediately if you want a truly asynchronous method. In that case, you would need to decide whether you would rather have the method block until it can validate all arguments or have argument exceptions be reported via the returned task instead of being thrown immediately.</p>
</div>
<p>Most <code>async</code> methods work this way, but suppose you want to throw this kind of exception straightaway (e.g., because it’s being called from code that does not immediately <code>await</code> the result, and you’d like to discover the problem as soon as possible). The usual technique is to write a normal method that validates the arguments before calling an <code>async</code> method that does the work, and to make that second method either private or local. (You would have to do something similar to perform immediate argument validation with iterators too, incidentally. Iterators were described in 
<span class="keep-together"><a data-type="xref" href="ch05.xhtml#ch_collections">Chapter 5</a>.)</span> <a data-type="xref" href="#validating_arguments_for_async_methods">Example 17-21</a> shows such a public wrapper method and the start of the method it calls to do the real work.</p>
<div data-type="example" id="validating_arguments_for_async_methods">
<h5><span class="label">Example 17-21. </span>Validating arguments for <code>async</code> methods</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">static</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">FindLongestLineAsync</code><code class="p">(</code><code class="kt">string</code> <code class="n">url</code><code class="p">)</code>
<code class="p">{</code>
    <code class="n">ArgumentNullException</code><code class="p">.</code><code class="n">ThrowIfNull</code><code class="p">(</code><code class="n">url</code><code class="p">);</code>
    <code class="k">return</code> <code class="nf">FindLongestLineCore</code><code class="p">(</code><code class="n">url</code><code class="p">);</code>

    <code class="k">static</code> <code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">FindLongestLineCore</code><code class="p">(</code><code class="kt">string</code> <code class="n">url</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="p">...</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>Because the public method is not marked with <code>async</code>, any exceptions it throws will propagate directly to the caller. But any failures that occur once the work is underway in the local method will be reported through the task.</p>
<p>I’ve chosen to forward the <code>url</code> argument to the local method. I didn’t have to, because a local method can access its containing method’s variables. However, relying on that causes the compiler to create a type to hold the locals to share them across the methods. Where possible, it will make this a value type, passing it by reference to the inner type, but in cases where the inner method’s scope might outlive the outer method, it can’t do that. And since the local method here is <code>async</code>, it is likely to continue to run long after the outer method’s stack frame no longer exists, so this would cause the compiler to create a reference type just to hold that <code>url</code> argument. By passing the argument in, we avoid this (and I’ve marked the method as <code>static</code> to indicate that this is my intent—this means the compiler will produce an error if I inadvertently use anything from the outer method in the local one). The compiler will probably still have to generate code that creates an object to hold on to local variables in the inner method during asynchronous execution, but at least we’ve avoided creating more objects than necessary.</p>
</div></section>
<section data-pdf-bookmark="Singular and Multiple Exceptions" data-type="sect2"><div class="sect2" id="singular_and_multiple_exceptions">
<h2>Singular and Multiple Exceptions</h2>
<p><a data-primary="AggregateException class" data-type="indexterm" id="ix_ch17-asciidoc24"/><a data-primary="asynchronous language features" data-secondary="singular and multiple exceptions" data-type="indexterm" id="ix_ch17-asciidoc25"/><a data-primary="error handling" data-secondary="singular and multiple exceptions" data-type="indexterm" id="ix_ch17-asciidoc26"/>As <a data-type="xref" href="ch16.xhtml#ch_multithreading">Chapter 16</a> showed, the TPL defines a model for reporting multiple errors—a task’s <code>Exception</code> property returns an <code>AggregateException</code>. Even if there is only a single failure, you still have to extract it from its containing <code>AggregateException</code>. However, if you use the <code>await</code> keyword, it does this for you—as you saw in <a data-type="xref" href="#handling_exceptions_from_await">Example 17-19</a>, it retrieves the first exception in the <code>InnerExceptions</code> and rethrows that.</p>
<p>This is handy when the operation can produce only a single failure—it saves you from having to write additional code to handle the aggregate exception and then dig out the contents. (If you’re using a task returned by an <code>async</code> method, it will never contain more than one exception.) However, it does present a problem if you’re working with composite tasks that can fail in multiple ways simultaneously. For example, <code>Task.WhenAll</code> takes a collection of tasks and returns a single task that completes only when all its constituent tasks complete. If some of them complete by failing, you’ll get an <span class="keep-together"><code>AggregateException</code></span> that contains multiple errors. If you use <code>await</code> with such an operation, it will throw only the first of those exceptions back to you.</p>
<p>The usual TPL mechanisms—the <code>Wait</code> method or the <code>Result</code> property—provide the complete set of errors (by throwing the <code>AggregateException</code> itself instead of its first inner exception), but they both block the thread if the task is not yet complete. What if you want the efficient asynchronous operation of <code>await</code>, which uses threads only when there’s something for them to do, but you still want to see all the errors? <a data-type="xref" href="#throwless_awaiting_followed_by_wait">Example 17-22</a> shows one approach.</p>
<div data-type="example" id="throwless_awaiting_followed_by_wait">
<h5><span class="label">Example 17-22. </span>Throwless awaiting followed by <code>Wait</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">static</code> <code class="k">async</code> <code class="n">Task</code> <code class="nf">CatchAll</code><code class="p">(</code><code class="n">Task</code><code class="p">[]</code> <code class="n">ts</code><code class="p">)</code>
<code class="p">{</code>
    <code class="k">try</code>
    <code class="p">{</code>
        <code class="kt">var</code> <code class="n">t</code> <code class="p">=</code> <code class="n">Task</code><code class="p">.</code><code class="n">WhenAll</code><code class="p">(</code><code class="n">ts</code><code class="p">);</code>
        <code class="k">await</code> <code class="n">t</code><code class="p">.</code><code class="n">ContinueWith</code><code class="p">(</code>
                    <code class="n">x</code> <code class="p">=&gt;</code> <code class="p">{},</code>
                    <code class="n">TaskContinuationOptions</code><code class="p">.</code><code class="n">ExecuteSynchronously</code><code class="p">);</code>
        <code class="n">t</code><code class="p">.</code><code class="n">Wait</code><code class="p">();</code>
    <code class="p">}</code>
    <code class="k">catch</code> <code class="p">(</code><code class="n">AggregateException</code> <code class="n">all</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">all</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>This uses <code>await</code> to take advantage of the efficient nature of asynchronous C# methods, but instead of calling <code>await</code> on the composite task itself, it sets up a continuation. A continuation can complete successfully when its antecedent completes, regardless of whether the antecedent succeeded or failed. This continuation has an empty body, so there’s nothing to go wrong, which means that the <code>await</code> will not throw here. The call to <code>Wait</code> will throw an <code>AggregateException</code> if anything failed, enabling the <code>catch</code> block to see all of the exceptions. And because we call <code>Wait</code> only after the <code>await</code> completes, we know the task is already finished, so the call will not block.</p>
<p>The one downside of this is that it ends up setting up a whole extra task just so we can wait without hitting an exception. I’ve configured the continuation to execute synchronously, so this will avoid scheduling a second piece of work via the thread pool, but there’s still a somewhat unsatisfactory waste of resources here. A messier but more efficient approach would be to use <code>await</code> in the usual way but to write an exception handler that checks to see if there were other exceptions, as shown in <a data-type="xref" href="#looking_for_additional_exceptions">Example 17-23</a>.</p>
<div data-type="example" id="looking_for_additional_exceptions">
<h5><span class="label">Example 17-23. </span>Looking for additional exceptions</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">static</code> <code class="k">async</code> <code class="n">Task</code> <code class="nf">CatchAll</code><code class="p">(</code><code class="n">Task</code><code class="p">[]</code> <code class="n">ts</code><code class="p">)</code>
<code class="p">{</code>
    <code class="n">Task</code><code class="p">?</code> <code class="n">t</code> <code class="p">=</code> <code class="k">null</code><code class="p">;</code>
    <code class="k">try</code>
    <code class="p">{</code>
        <code class="n">t</code> <code class="p">=</code> <code class="n">Task</code><code class="p">.</code><code class="n">WhenAll</code><code class="p">(</code><code class="n">ts</code><code class="p">);</code>
        <code class="k">await</code> <code class="n">t</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">catch</code> <code class="p">(</code><code class="n">Exception</code> <code class="n">first</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">first</code><code class="p">);</code>

        <code class="k">if</code> <code class="p">(</code><code class="n">t</code><code class="p">?.</code><code class="n">Exception</code><code class="p">?.</code><code class="n">InnerExceptions</code><code class="p">.</code><code class="n">Count</code> <code class="p">&gt;</code> <code class="m">1</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"I've found some more:"</code><code class="p">);</code>
            <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">t</code><code class="p">.</code><code class="n">Exception</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>This avoids creating an extra task, but the downside is that the exception handling looks a little odd.<a data-startref="ix_ch17-asciidoc26" data-type="indexterm" id="idm45884782901744"/><a data-startref="ix_ch17-asciidoc25" data-type="indexterm" id="idm45884782901136"/><a data-startref="ix_ch17-asciidoc24" data-type="indexterm" id="idm45884782790976"/></p>
</div></section>
<section data-pdf-bookmark="Concurrent Operations and Missed Exceptions" data-type="sect2"><div class="sect2" id="concurrent_operations_and_missed_excepti">
<h2>Concurrent Operations and Missed Exceptions</h2>
<p><a data-primary="asynchronous language features" data-secondary="concurrent operations and missed exceptions" data-type="indexterm" id="idm45884782788720"/><a data-primary="error handling" data-secondary="concurrent operations and missed exceptions" data-type="indexterm" id="idm45884782787808"/>The most straightforward way to use <code>await</code> is to do one thing after another, just as you would with synchronous code. Although doing work strictly sequentially may not sound like it takes full advantage of the potential of asynchronous code, it does make much more efficient use of the available threads than the synchronous equivalent, and it also works well in client-side UI code, leaving the UI thread free to respond to input even while work is then in progress. However, you might want to go further.</p>
<p>It is possible to kick off multiple pieces of work simultaneously. You can call an asynchronous API, and instead of using <code>await</code> immediately, you can store the result in a variable and then start another piece of work before waiting for both. Although this is a viable technique, and might reduce the overall execution time of your operations, there’s a trap for the unwary, shown in <a data-type="xref" href="#how_not_to_run_multiple_concurrent_opera">Example 17-24</a>.</p>
<div data-type="example" id="how_not_to_run_multiple_concurrent_opera">
<h5><span class="label">Example 17-24. </span>How not to run multiple concurrent operations</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">static</code> <code class="k">async</code> <code class="n">Task</code> <code class="nf">GetSeveral</code><code class="p">(</code><code class="n">IHttpClientFactory</code> <code class="n">cf</code><code class="p">)</code>
<code class="p">{</code>
    <code class="k">using</code> <code class="p">(</code><code class="n">HttpClient</code> <code class="n">w</code> <code class="p">=</code> <code class="n">cf</code><code class="p">.</code><code class="n">CreateClient</code><code class="p">())</code>
    <code class="p">{</code>
        <code class="n">w</code><code class="p">.</code><code class="n">MaxResponseContentBufferSize</code> <code class="p">=</code> <code class="m">2_000_000</code><code class="p">;</code>

        <code class="n">Task</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">g1</code> <code class="p">=</code> <code class="n">w</code><code class="p">.</code><code class="n">GetStringAsync</code><code class="p">(</code><code class="s">"https://endjin.com/"</code><code class="p">);</code>
        <code class="n">Task</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">g2</code> <code class="p">=</code> <code class="n">w</code><code class="p">.</code><code class="n">GetStringAsync</code><code class="p">(</code><code class="s">"https://oreilly.com"</code><code class="p">);</code>

        <code class="c1">// BAD!</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">((</code><code class="k">await</code> <code class="n">g1</code><code class="p">).</code><code class="n">Length</code><code class="p">);</code>
        <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">((</code><code class="k">await</code> <code class="n">g2</code><code class="p">).</code><code class="n">Length</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>This fetches content from two URLs concurrently. Having started both pieces of work, it uses two <code>await</code> expressions to collect the results of each and to display the lengths of the resulting strings. If the operations succeed, this will work, but it doesn’t handle errors well. If the first operation fails, the code will never get as far as executing the second <code>await</code>. This means that if the second operation also fails, nothing will look at the exception it throws. Eventually, the TPL will detect that the exception has gone unobserved, which will result in the <code>UnobservedTaskException</code> event being raised. (<a data-type="xref" href="ch16.xhtml#ch_multithreading">Chapter 16</a> discussed the TPL’s unobserved exception handling.) The problem is that this will happen only very occasionally—it requires both operations to fail in quick succession—so it’s something that would be very easy to miss in testing.</p>
<p>You could avoid this with careful exception handling—you could catch any exceptions that emerge from the first <code>await</code> before going on to execute the second, for example. Alternatively, you could use <code>Task.WhenAll</code> to wait for all the tasks as a single operation—this will produce a faulted task with an <code>AggregateException</code> if anything fails, enabling you to see all errors. Of course, as you saw in the preceding section, multiple failures of this kind are awkward to deal with when you’re using <code>await</code>. But if you want to launch multiple asynchronous operations and have them all in flight simultaneously, you’re going to need more complex code to coordinate the results than you would do when performing work sequentially. Even so, the <code>await</code> and <code>async</code> keywords still make life much easier.<a data-startref="ix_ch17-asciidoc23" data-type="indexterm" id="idm45884782708032"/><a data-startref="ix_ch17-asciidoc22" data-type="indexterm" id="idm45884782707328"/></p>
</div></section>
</div></section>
<section class="less_space pagebreak-before" data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="summary-async">
<h1>Summary</h1>
<p>Asynchronous operations do not block the thread from which they are invoked. This can make them more efficient than synchronous APIs, which is particularly important on heavily loaded machines. It also makes them suitable for use on the client side, because they enable you to perform long-running work without causing the UI to become unresponsive. Without language support, asynchronous operations can be complex to use correctly, particularly when handling errors across multiple related operations. C#’s <code>await</code> keyword enables you to write asynchronous code in a style that looks just like normal synchronous code. It gets a little more complex if you want a single method to manage multiple concurrent operations, but even if you write an asynchronous method that does things strictly in order, you will get the benefits of making much more efficient use of threads in a server application—it will be able to support more simultaneous users, because each individual operation 
<span class="keep-together">uses fewer</span> resources—and on the client side, you’ll get the benefit of a more responsive UI.</p>
<p>Methods that use <code>await</code> must be marked with the <code>async</code> keyword and should usually return one of <code>Task</code>, <code>Task&lt;T&gt;</code>, <code>ValueTask</code>, or <code>ValueTask&lt;T&gt;</code>. (C# allows a <code>void</code> return type, but you would normally use this only when you have no choice.) The compiler will arrange for this task to complete successfully once your method returns, or to complete with a fault if your method fails at any point in its execution. Because <code>await</code> can consume any <code>Task</code> or <code>Task&lt;T&gt;</code>, this makes it easy to split asynchronous logic across multiple methods, because a high-level method can <code>await</code> a lower-level <code>async</code> method. Usually, the work eventually ends up being performed by some task-based API, but it doesn’t have to be, because <code>await</code> only demands a certain pattern—it will accept any expression on which you can invoke a <code>GetWaiter</code> method to obtain a suitable type.<a data-startref="ix_ch17-asciidoc0" data-type="indexterm" id="idm45884782654960"/></p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45884785189952"><sup><a href="ch17.xhtml#idm45884785189952-marker">1</a></sup> This example is a bit contrived so that I can illustrate how <code>using</code> works in <code>async</code> methods. Disposing an <code>HttpClient</code> obtained from an <code>IHttpClientFactory</code> is normally optional, and in cases where you <code>new</code> up an <code>HttpClient</code> directly, it’s better to hang on to it and reuse it, as discussed in <a data-type="xref" href="ch07.xhtml#optional_disposal">“Optional Disposal”</a>.</p><p data-type="footnote" id="idm45884785171152"><sup><a href="ch17.xhtml#idm45884785171152-marker">2</a></sup> As it happens, <a data-type="xref" href="#manual_asynchronous_coding">Example 17-3</a> does this too, because the TPL captures the execution context for us.</p><p data-type="footnote" id="CHP-18-FN-3"><sup><a href="ch17.xhtml#CHP-18-FN-3-marker">3</a></sup> Strictly speaking, I should inspect the HTTP response headers to discover the encoding, and configure the <code>StreamReader</code> with that. Instead, I’m letting it detect the encoding, which will work well enough for demonstration purposes.</p><p data-type="footnote" id="idm45884784599056"><sup><a href="ch17.xhtml#idm45884784599056-marker">4</a></sup> These are available in .NET Core 3.1, .NET, and .NET Standard 2.1. With .NET Framework, you will need to use the <code>Microsoft.Bcl.AsyncInterfaces</code> NuGet package.</p></div></div></section></div></body></html>