["```cs\n// Calculate prime numbers using a simple (unoptimized) algorithm.\n\nIEnumerable<int> numbers = Enumerable.Range (3, 100000-3);\n\nvar parallelQuery = \n  from n in numbers.AsParallel()\n  where Enumerable.Range (2, (int) Math.Sqrt (n)).All (i => n % i > 0)\n  select n;\n\nint[] primes = parallelQuery.ToArray();\n```", "```cs\nmySequence.AsParallel()           // Wraps sequence in ParallelQuery<int>\n          .Where (n => n > 100)   // Outputs another ParallelQuery<int>\n          .AsParallel()           // Unnecessary - and inefficient!\n          .Select (n => n * n)\n```", "```cs\nmyCollection.AsParallel().AsOrdered()...\n```", "```cs\ninputSequence.AsParallel().AsOrdered()\n  *.QueryOperator1*()\n * .QueryOperator2*()\n  .AsUnordered()       // From here on, ordering doesn’t matter\n  .*QueryOperator3*()\n  ...\n```", "```cs\n.WithExecutionMode (ParallelExecutionMode.ForceParallelism)\n```", "```cs\nif (!File.Exists (\"WordLookup.txt\")    // Contains about 150,000 words\n  File.WriteAllText (\"WordLookup.txt\",\n    await new HttpClient().GetStringAsync (\n      \"http://www.albahari.com/ispell/allwords.txt\"));\n\nvar wordLookup = new HashSet<string> (\n  File.ReadAllLines (\"WordLookup.txt\"),\n  StringComparer.InvariantCultureIgnoreCase);\n```", "```cs\nvar random = new Random();\nstring[] wordList = wordLookup.ToArray();\n\nstring[] wordsToTest = Enumerable.Range (0, 1000000)\n  .Select (i => wordList [random.Next (0, wordList.Length)])\n  .ToArray();\n\nwordsToTest [12345] = \"woozsh\";     // Introduce a couple\nwordsToTest [23456] = \"wubsie\";     // of spelling mistakes.\n```", "```cs\nvar query = wordsToTest\n  .AsParallel()\n  .Select  ((word, index) => (word, index))\n  .Where   (iword => !wordLookup.Contains (iword.word))\n  .OrderBy (iword => iword.index);\n\nforeach (var mistake in query)\n  Console.WriteLine (mistake.word + \" - index = \" + mistake.index);\n\n// OUTPUT:\n// woozsh - index = 12345\n// wubsie - index = 23456\n```", "```cs\nstring[] wordsToTest = Enumerable.Range (0, 1000000)\n  .Select (i => wordList [random.Next (0, wordList.Length)])\n  .ToArray();\n```", "```cs\nvar localRandom = new ThreadLocal<Random>\n ( () => new Random (Guid.NewGuid().GetHashCode()) );\n\nstring[] wordsToTest = Enumerable.Range (0, 1000000).AsParallel()\n  .Select (i => wordList [localRandom.Value.Next (0, wordList.Length)])\n  .ToArray();\n```", "```cs\n// The following query multiplies each element by its position.\n// Given an input of Enumerable.Range(0,999), it should output squares.\nint i = 0;\nvar query = from n in Enumerable.Range(0,999).AsParallel() select n * i++;\n```", "```cs\nvar query = Enumerable.Range(0,999).AsParallel().Select ((n, i) => n * i);\n```", "```cs\n...AsParallel().WithDegreeOfParallelism(4)...\n```", "```cs\n\"The Quick Brown Fox\"\n  .AsParallel().WithDegreeOfParallelism (2)\n  .Where (c => !char.IsWhiteSpace (c))\n  .AsParallel().WithDegreeOfParallelism (3)   // Forces Merge + Partition\n  .Select (c => char.ToUpper (c))\n```", "```cs\nIEnumerable<int> tenMillion = Enumerable.Range (3, 10_000_000);\n\nvar cancelSource = new CancellationTokenSource();\ncancelSource.CancelAfter (100);   // Cancel query after 100 milliseconds\n\nvar primeNumberQuery = \n  from n in tenMillion.AsParallel().WithCancellation (cancelSource.Token)\n  where Enumerable.Range (2, (int) Math.Sqrt (n)).All (i => n % i > 0)\n  select n;\n\ntry \n{\n  // Start query running:\n  int[] primes = primeNumberQuery.ToArray();\n  // We'll never get here because the other thread will cancel us.\n}\ncatch (OperationCanceledException)\n{\n  Console.WriteLine (\"Query canceled\");\n}\n```", "```cs\nforeach (int n in parallelQuery)\n  DoSomething (n);\n```", "```cs\n\"abcdef\".AsParallel().Select (c => char.ToUpper(c)).ForAll (Console.Write);\n```", "```cs\nint[] numbers = { 3, 4, 5, 6, 7, 8, 9 };\nvar parallelQuery =\n  Partitioner.Create (numbers, true).AsParallel()\n  .Where (...)\n```", "```cs\nParallelEnumerable.Range (1, 10000000).Sum (i => Math.Sqrt (i))\n```", "```cs\nint[] numbers = { 1, 2, 3 };\nint sum = numbers.Aggregate (0, (total, n) => total + n);   // 6\n```", "```cs\nnumbers.AsParallel().Aggregate (\n () => 0,                                      // seedFactory\n  (localTotal, n) => localTotal + n,           // updateAccumulatorFunc\n  (mainTot, localTot) => mainTot + localTot,   // combineAccumulatorFunc\n  finalResult => finalResult)                  // resultSelector\n```", "```cs\nstring text = \"Let’s suppose this is a really long string\";\nvar letterFrequencies = new int[26];\nforeach (char c in text)\n{\n  int index = char.ToUpper (c) - 'A';\n  if (index >= 0 && index < 26) letterFrequencies [index]++;\n};\n```", "```cs\nint[] result =\n  text.Aggregate (\n    new int[26],                // Create the \"accumulator\"\n    (letterFrequencies, c) =>   // Aggregate a letter into the accumulator\n    {\n      int index = char.ToUpper (c) - 'A';\n      if (index >= 0 && index < 26) letterFrequencies [index]++;\n      return letterFrequencies;\n    });\n```", "```cs\nint[] result =\n  text.AsParallel().Aggregate (\n   () => new int[26],             // Create a new local accumulator\n\n    (localFrequencies, c) =>       // Aggregate into the local accumulator\n    {\n      int index = char.ToUpper (c) - 'A';\n      if (index >= 0 && index < 26) localFrequencies [index]++;\n      return localFrequencies;\n    },\n                                   // Aggregate local->main accumulator\n    (mainFreq, localFreq) =>\n      mainFreq.Zip (localFreq, (f1, f2) => f1 + f2).ToArray(),\n\n    finalResult => finalResult     // Perform any final transformation\n  );                               // on the end result.\n```", "```cs\npublic static void Invoke (params Action[] actions);\n```", "```cs\nParallel.Invoke (\n () => new WebClient().DownloadFile (\"http://www.linqpad.net\", \"lp.html\"),\n () => new WebClient().DownloadFile (\"http://microsoft.com\", \"ms.html\"));\n```", "```cs\nvar data = new List<string>();\nParallel.Invoke (\n () => data.Add (new WebClient().DownloadString (\"http://www.foo.com\")),\n () => data.Add (new WebClient().DownloadString (\"http://www.far.com\")));\n```", "```cs\npublic static void Invoke (ParallelOptions options,\n                           params Action[] actions);\n```", "```cs\npublic static ParallelLoopResult For (\n  int fromInclusive, int toExclusive, Action<int> body)\n\npublic static ParallelLoopResult ForEach<TSource> (\n  IEnumerable<TSource> source, Action<TSource> body)\n```", "```cs\nfor (int i = 0; i < 100; i++)\n  Foo (i);\n```", "```cs\nParallel.For (0, 100, i => Foo (i));\n```", "```cs\nParallel.For (0, 100, Foo);\n```", "```cs\nforeach (char c in \"Hello, world\")\n  Foo (c);\n```", "```cs\nParallel.ForEach (\"Hello, world\", Foo);\n```", "```cs\nvar keyPairs = new string[6];\n\nParallel.For (0, keyPairs.Length,\n              i => keyPairs[i] = RSA.Create().ToXmlString (true));\n```", "```cs\nstring[] keyPairs =\n  ParallelEnumerable.Range (0, 6)\n  .Select (i => RSA.Create().ToXmlString (true))\n  .ToArray();\n```", "```cs\nParallel.For (0, 100, i =>\n{\n  Parallel.For (0, 50, j => Foo (i, j));   // Sequential would be better\n});                                        // for the inner loop.\n```", "```cs\nint i = 0;\nforeach (char c in \"Hello, world\")\n  Console.WriteLine (c.ToString() + i++);\n```", "```cs\npublic static ParallelLoopResult ForEach<TSource> (\n  IEnumerable<TSource> source, Action<TSource,ParallelLoopState,long> body)\n```", "```cs\nParallel.ForEach (\"Hello, world\", (c, state, i) =>\n{\n   Console.WriteLine (c.ToString() + i);\n});\n```", "```cs\nif (!File.Exists (\"WordLookup.txt\"))    // Contains about 150,000 words\n  new WebClient().DownloadFile (\n    \"http://www.albahari.com/ispell/allwords.txt\", \"WordLookup.txt\");\n\nvar wordLookup = new HashSet<string> (\n  File.ReadAllLines (\"WordLookup.txt\"),\n  StringComparer.InvariantCultureIgnoreCase);\n\nvar random = new Random();\nstring[] wordList = wordLookup.ToArray();\n\nstring[] wordsToTest = Enumerable.Range (0, 1000000)\n  .Select (i => wordList [random.Next (0, wordList.Length)])\n  .ToArray();\n\nwordsToTest [12345] = \"woozsh\";     // Introduce a couple\nwordsToTest [23456] = \"wubsie\";     // of spelling mistakes.\n```", "```cs\nvar misspellings = new ConcurrentBag<Tuple<int,string>>();\n\nParallel.ForEach (wordsToTest, (word, state, i) =>\n{\n  if (!wordLookup.Contains (word))\n    misspellings.Add (Tuple.Create ((int) i, word));\n});\n```", "```cs\npublic class ParallelLoopState\n{\n  public void Break();\n  public void Stop();\n\n  public bool IsExceptional { get; }\n  public bool IsStopped { get; }\n  public long? LowestBreakIteration { get; }\n  public bool ShouldExitCurrentIteration { get; }\n}\n```", "```cs\nforeach (char c in \"Hello, world\")\n  if (c == ',')\n    break;\n  else\n    Console.Write (c);\n```", "```cs\nParallel.ForEach (\"Hello, world\", (c, loopState) =>\n{\n  if (c == ',')\n    loopState.Break();\n  else\n    Console.Write (c);\n});\n\n// OUTPUT: Hlloe\n```", "```cs\npublic static ParallelLoopResult For <TLocal> (\n  int fromInclusive,\n  int toExclusive,\n  Func <TLocal> localInit,\n  Func <int, ParallelLoopState, TLocal, TLocal> body,\n  Action <TLocal> localFinally);\n```", "```cs\nobject locker = new object();\ndouble total = 0;\nParallel.For (1, 10000000,\n              i => { lock (locker) total += Math.Sqrt (i); });\n```", "```cs\nobject locker = new object();\ndouble grandTotal = 0;\n\nParallel.For (1, 10000000,\n\n  () => 0.0,                        // Initialize the local value.\n\n  (i, state, localTotal) =>         // Body delegate. Notice that it\n     localTotal + Math.Sqrt (i),    // returns the new local total.\n\n  localTotal =>                                    // Add the local value\n    { lock (locker) grandTotal += localTotal; }    // to the master value.\n);\n```", "```cs\nParallelEnumerable.Range (1, 10000000)\n                  .Sum (i => Math.Sqrt (i))\n```", "```cs\nvar task = Task.Factory.StartNew (Greet, \"Hello\");\ntask.Wait();  // Wait for task to complete.\n\nvoid Greet (object state) { Console.Write (state); }   // Hello\n```", "```cs\nvar task = Task.Factory.StartNew (state => Greet (\"Hello\"), \"Greeting\");\nConsole.WriteLine (task.AsyncState);   // Greeting\ntask.Wait();\n\nvoid Greet (string message) { Console.Write (message); }\n```", "```cs\nLongRunning, PreferFairness, AttachedToParent\n```", "```cs\nTask parent = Task.Factory.StartNew (() =>\n{\n  Console.WriteLine (\"I am a parent\");\n\n  Task.Factory.StartNew (() =>        // Detached task\n  {\n    Console.WriteLine (\"I am detached\");\n  });\n\n  Task.Factory.StartNew (() =>        // Child task\n  {\n    Console.WriteLine (\"I am a child\");\n  }, TaskCreationOptions.AttachedToParent);\n});\n```", "```cs\nTaskCreationOptions atp = TaskCreationOptions.AttachedToParent;\nvar parent = Task.Factory.StartNew (() => \n{\n  Task.Factory.StartNew (() =>   // Child\n  {\n    Task.Factory.StartNew (() => { throw null; }, atp);   // Grandchild\n  }, atp);\n});\n\n// The following call throws a NullReferenceException (wrapped\n// in nested AggregateExceptions):\nparent.Wait();\n```", "```cs\n// Assume t1, t2 and t3 are tasks:\nvar exceptions = new List<Exception>();\ntry { t1.Wait(); } catch (AggregateException ex) { exceptions.Add (ex); }\ntry { t2.Wait(); } catch (AggregateException ex) { exceptions.Add (ex); }\ntry { t3.Wait(); } catch (AggregateException ex) { exceptions.Add (ex); }\nif (exceptions.Count > 0) throw new AggregateException (exceptions);\n```", "```cs\nvar cts = new CancellationTokenSource();\nCancellationToken token = cts.Token;\ncts.CancelAfter (500);\n\nTask task = Task.Factory.StartNew (() => \n{\n  Thread.Sleep (1000);\n  token.ThrowIfCancellationRequested();  // Check for cancellation request\n}, token);\n\ntry { task.Wait(); }\ncatch (AggregateException ex)\n{\n  Console.WriteLine (ex.InnerException is TaskCanceledException);  // True\n  Console.WriteLine (task.IsCanceled);                             // True\n  Console.WriteLine (task.Status);                             // Canceled\n}\n```", "```cs\nvar cancelSource = new CancellationTokenSource();\nCancellationToken token = cancelSource.Token;\n\nTask task = Task.Factory.StartNew (() =>\n{\n  // Pass our cancellation token into a PLINQ query:\n  var query = *someSequence*.AsParallel().WithCancellation (token)...\n  ... *enumerate query* ...\n});\n```", "```cs\nTask task1 = Task.Factory.StartNew (() => Console.Write (\"antecedent..\"));\nTask task2 = task1.ContinueWith (ant => Console.Write (\"..continuation\"));\n```", "```cs\nTask.Factory.StartNew<int> (() => 8)\n  .ContinueWith (ant => ant.Result * 2)\n  .ContinueWith (ant => Math.Sqrt (ant.Result))\n  .ContinueWith (ant => Console.WriteLine (ant.Result));   // 4\n```", "```cs\nTask continuation = Task.Factory.StartNew     (()  => { throw null; })\n                                .ContinueWith (ant =>\n  {\n    ant.Wait();\n    // Continue processing...\n  });\n\ncontinuation.Wait();    // Exception is now thrown back to caller.\n```", "```cs\nTask task1 = Task.Factory.StartNew (() => { throw null; });\n\nTask error = task1.ContinueWith (ant => Console.Write (ant.Exception),\n                                 TaskContinuationOptions.OnlyOnFaulted);\n\nTask ok = task1.ContinueWith (ant => Console.Write (\"Success!\"),\n                              TaskContinuationOptions.NotOnFaulted);\n```", "```cs\npublic static void IgnoreExceptions (this Task task)\n{\n  task.ContinueWith (t => { var ignore = t.Exception; },\n    TaskContinuationOptions.OnlyOnFaulted);\n}\n```", "```cs\nTask.Factory.StartNew (() => { throw null; }).IgnoreExceptions();\n```", "```cs\nTaskCreationOptions atp = TaskCreationOptions.AttachedToParent;\nTask.Factory.StartNew (() =>\n{\n  Task.Factory.StartNew (() => { throw null; }, atp);\n  Task.Factory.StartNew (() => { throw null; }, atp);\n  Task.Factory.StartNew (() => { throw null; }, atp);\n})\n.ContinueWith (p => Console.WriteLine (p.Exception),\n                    TaskContinuationOptions.OnlyOnFaulted);\n```", "```cs\nNotOnRanToCompletion = 0x10000,\nNotOnFaulted = 0x20000,\nNotOnCanceled = 0x40000,\n```", "```cs\nOnlyOnRanToCompletion = NotOnFaulted | NotOnCanceled,\nOnlyOnFaulted = NotOnRanToCompletion | NotOnCanceled,\nOnlyOnCanceled = NotOnRanToCompletion | NotOnFaulted\n```", "```cs\nTask t1 = Task.Factory.StartNew (...);\n\nTask fault = t1.ContinueWith (ant => Console.WriteLine (\"fault\"),\n                              TaskContinuationOptions.OnlyOnFaulted);\n\nTask t3 = fault.ContinueWith (ant => Console.WriteLine (\"t3\"));\n```", "```cs\nTask t3 = fault.ContinueWith (ant => Console.WriteLine (\"t3\"),\n                              TaskContinuationOptions.NotOnCanceled);\n```", "```cs\nvar task1 = Task.Run (() => Console.Write (\"X\"));\nvar task2 = Task.Run (() => Console.Write (\"Y\"));\n```", "```cs\nvar continuation = Task.Factory.ContinueWhenAll (\n  new[] { task1, task2 }, tasks => Console.WriteLine (\"Done\"));\n```", "```cs\nvar continuation = Task.WhenAll (task1, task2)\n                       .ContinueWith (ant => Console.WriteLine (\"Done\"));\n```", "```cs\nvar t = Task.Factory.StartNew (() => Thread.Sleep (1000));\nt.ContinueWith (ant => Console.Write (\"X\"));\nt.ContinueWith (ant => Console.Write (\"Y\"));\n```", "```cs\n// Suppose we are on a UI thread in a Windows Forms / WPF application:\n_uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();\n```", "```cs\nTask.Run (() => Foo())\n  .ContinueWith (ant => lblResult.Content = ant.Result, _uiScheduler);\n```", "```cs\nvar factory = new TaskFactory (\n  TaskCreationOptions.LongRunning | TaskCreationOptions.AttachedToParent,\n  TaskContinuationOptions.None);\n```", "```cs\nTask task1 = factory.StartNew (Method1);\nTask task2 = factory.StartNew (Method2);\n...\n```", "```cs\ntry\n{\n  var query = from i in Enumerable.Range (0, 1000000)\n              select 100 / i;\n  ...\n}\ncatch (DivideByZeroException)\n{\n  ...\n}\n```", "```cs\ntry\n{\n  var query = from i in ParallelEnumerable.Range (0, 1000000)\n              select 100 / i;\n  // Enumerate query\n  ...\n}\ncatch (AggregateException aex)\n{\n  foreach (Exception ex in aex.InnerExceptions)\n    Console.WriteLine (ex.Message);\n}\n```", "```cs\ncatch (AggregateException aex)\n{\n  foreach (Exception ex in aex.Flatten().InnerExceptions)\n    myLogWriter.LogException (ex);\n}\n```", "```cs\npublic void Handle (Func<Exception, bool> predicate)\n```", "```cs\nvar parent = Task.Factory.StartNew (() => \n{\n  // We’ll throw 3 exceptions at once using 3 child tasks:\n\n  int[] numbers = { 0 };\n\n  var childFactory = new TaskFactory\n   (TaskCreationOptions.AttachedToParent, TaskContinuationOptions.None);\n\n  childFactory.StartNew (() => 5 / numbers[0]);   // Division by zero\n  childFactory.StartNew (() => numbers [1]);      // Index out of range\n  childFactory.StartNew (() => { throw null; });  // Null reference\n});\n\ntry { parent.Wait(); }\ncatch (AggregateException aex)\n{\n  aex.Flatten().Handle (ex =>   // Note that we still need to call Flatten\n  {\n    if (ex is DivideByZeroException)\n    {\n      Console.WriteLine (\"Divide by zero\");\n      return true;                           // This exception is \"handled\"\n    }\n    if (ex is IndexOutOfRangeException)\n    {\n      Console.WriteLine (\"Index out of range\");\n      return true;                           // This exception is \"handled\"   \n    }\n    return false;    // All other exceptions will get rethrown\n  });\n}\n```", "```cs\nvar d = new ConcurrentDictionary<int,int>();\nfor (int i = 0; i < 1000000; i++) d[i] = 123;\n```", "```cs\nvar d = new Dictionary<int,int>();\nfor (int i = 0; i < 1000000; i++) lock (d) d[i] = 123;\n```", "```cs\nConcurrentStack<T>\nConcurrentQueue<T>\nConcurrentBag<T>\n```", "```cs\nvoid CopyTo (T[] array, int index);\nT[] ToArray();\nbool TryAdd (T item);\nbool TryTake (out T item);\n```", "```cs\nint result;\nlock (myStack) if (myStack.Count > 0) result = myStack.Pop();\n```", "```cs\nvar misspellings = new ConcurrentBag<Tuple<int,string>>();\n\nParallel.ForEach (wordsToTest, (word, state, i) =>\n{\n  if (!wordLookup.Contains (word))\n    misspellings.Add (Tuple.Create ((int) i, word));\n});\n```", "```cs\npublic class PCQueue : IDisposable\n{\n  BlockingCollection<Action> _taskQ = new BlockingCollection<Action>();\n\n  public PCQueue (int workerCount)\n  {\n    // Create and start a separate Task for each consumer:\n    for (int i = 0; i < workerCount; i++)\n      Task.Factory.StartNew (Consume);\n  }\n\n  public void Enqueue (Action action) { _taskQ.Add (action); }\n\n  void Consume()\n  {\n    // This sequence that we’re enumerating will *block* when no elements\n    // are available and will *end* when CompleteAdding is called.\n\n    foreach (Action action in _taskQ.GetConsumingEnumerable())\n      action();     // Perform task.\n  }\n\n  public void Dispose() { _taskQ.CompleteAdding(); }\n}\n```", "```cs\npublic class PCQueue : IDisposable\n{\n  BlockingCollection<Task> _taskQ = new BlockingCollection<Task>();\n\n  public PCQueue (int workerCount)\n  {\n    // Create and start a separate Task for each consumer:\n    for (int i = 0; i < workerCount; i++)\n      Task.Factory.StartNew (Consume);\n  }\n\n  public Task Enqueue (Action action, CancellationToken cancelToken\n                                            = default (CancellationToken))\n  {\n    var task = new Task (action, cancelToken);\n    _taskQ.Add (task);\n    return task;\n  }\n\n  public Task<TResult> Enqueue<TResult> (Func<TResult> func, \n              CancellationToken cancelToken = default (CancellationToken))\n  {\n    var task = new Task<TResult> (func, cancelToken);\n    _taskQ.Add (task);\n    return task;\n  }\n\n  void Consume()\n  {\n    foreach (var task in _taskQ.GetConsumingEnumerable())\n      try \n      {\n          if (!task.IsCanceled) task.RunSynchronously();\n      } \n      catch (InvalidOperationException) { }  // Race condition\n  }\n\n  public void Dispose() { _taskQ.CompleteAdding(); }\n}\n```", "```cs\nvar pcQ = new PCQueue (2);    // Maximum concurrency of 2\nstring result = await pcQ.Enqueue (() => \"That was easy!\");\n...\n```"]