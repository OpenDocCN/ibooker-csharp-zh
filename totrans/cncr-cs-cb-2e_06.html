<html><head></head><body><section data-pdf-bookmark="Chapter 6. System.Reactive Basics" data-type="chapter" epub:type="chapter"><div class="chapter" id="rx-basics">
<h1><span class="label">Chapter 6. </span>System.Reactive Basics</h1>


<p>LINQ is <a data-primary="reactive programming" data-secondary="compared to LINQ" data-type="indexterm" id="idm45458700647928"/><a data-primary="LINQ" data-secondary="compared to reactive programming" data-type="indexterm" id="idm45458700646920"/>a set of language features that enable developers to query sequences. The two most common LINQ providers are the built-in LINQ to Objects (which is based on <code>IEnumerable&lt;T&gt;</code>) and LINQ to Entities (based on <code>IQueryable&lt;T&gt;</code>). There are many other providers available, and most providers have the same general structure. Queries are lazily evaluated, and the sequences produce values as necessary. Conceptually, this is a pull model; during evaluation, value items are pulled from the query one at a time.</p>

<p>System.Reactive (Rx) <a data-primary="reactive programming" data-secondary="overview" data-type="indexterm" id="idm45458700644136"/>treats events as sequences of data that arrive over time. As such, you can think of Rx as LINQ to Events (based on <code>IObservable&lt;T&gt;</code>). The main difference between observables and other LINQ providers is that Rx is a “push” model, meaning that the query defines how the program reacts as events arrive. Rx builds on top of LINQ, adding some powerful new operators as extension methods.</p>

<p>This <a data-primary="reactive programming" data-secondary="LINQ operators available in" data-type="indexterm" id="idm45458700641800"/>chapter looks at some of the more common Rx operations. Bear in mind that all of the LINQ operators are also available, so simple operations, such as filtering (<code>Where</code>) and projection (<code>Select</code>), work conceptually the same as they do with any other LINQ provider. We won’t cover these common LINQ operations here; we’ll focus on the new capabilities that Rx builds on top of LINQ, particularly those dealing with <em>time</em>.</p>

<p>To <a data-primary="System.Reactive library" data-type="indexterm" id="idm45458700638488"/>use System.Reactive, install the NuGet package for <a href="http://bit.ly/sys-reactive"><code>System.Reactive</code></a> into your application.</p>






<section class="recipe" data-pdf-bookmark="6.1 Converting .NET Events" data-type="sect1"><div class="sect1" id="recipe-rx-events">
<h1>6.1 Converting .NET Events</h1>








<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458700634872">
<h2>Problem</h2>

<p>You <a data-primary="reactive programming" data-secondary="converting .NET events for" data-type="indexterm" id="ch6r1a"/><a data-primary="events" data-secondary="converting to observable streams" data-type="indexterm" id="ch6r1b"/><a data-primary="observable streams" data-secondary="converting .NET events to" data-type="indexterm" id="ch6r1c"/>have an event that you need to treat as a System.Reactive input stream, producing some data via <code>OnNext</code> each time the event is raised.</p>
</div></section>













<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458700628872">
<h2>Solution</h2>

<p>The<a data-primary="Observable.FromEventPattern method" data-type="indexterm" id="idm45458700627144"/><a data-primary="Observable.FromEvent method" data-type="indexterm" id="idm45458700626344"/> <code>Observable</code> class defines several event converters. Most .NET framework events are compatible with <code>FromEventPattern</code>, but if you have events that don’t follow the common pattern, you can use <code>FromEvent</code> instead.</p>

<p><code>FromEventPattern</code> works best if the event delegate type is <code>EventHandler&lt;T&gt;</code>. Many newer framework types use this event delegate type. For example, the <code>Progress&lt;T&gt;</code> type defines a <code>ProgressChanged</code> event, which is of type <code>EventHandler&lt;T&gt;</code>, so it can be easily wrapped with <code>FromEventPattern</code>:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">progress</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Progress</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;();</code>
<code class="n">IObservable</code><code class="p">&lt;</code><code class="n">EventPattern</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;&gt;</code> <code class="n">progressReports</code> <code class="p">=</code>
    <code class="n">Observable</code><code class="p">.</code><code class="n">FromEventPattern</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;(</code>
        <code class="n">handler</code> <code class="p">=&gt;</code> <code class="n">progress</code><code class="p">.</code><code class="n">ProgressChanged</code> <code class="p">+=</code> <code class="n">handler</code><code class="p">,</code>
        <code class="n">handler</code> <code class="p">=&gt;</code> <code class="n">progress</code><code class="p">.</code><code class="n">ProgressChanged</code> <code class="p">-=</code> <code class="n">handler</code><code class="p">);</code>
<code class="n">progressReports</code><code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="n">data</code> <code class="p">=&gt;</code> <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"OnNext: "</code> <code class="p">+</code> <code class="n">data</code><code class="p">.</code><code class="n">EventArgs</code><code class="p">));</code></pre>

<p>Note here that the <code>data.EventArgs</code> is strongly typed to be an <code>int</code>. The type argument to <code>FromEventPattern</code> (<code>int</code> in the previous example) is the same as the type <code>T</code> in <code>EventHandler&lt;T&gt;</code>. The two lambda arguments to <code>FromEventPattern</code> enable System.Reactive to subscribe and unsubscribe from the event.</p>

<p>The newer user interface frameworks use <code>EventHandler&lt;T&gt;</code>, and can easily be used with <code>FromEventPattern</code>, but older types often define a unique delegate type for each event. These can also be used with <code>FromEventPattern</code>, but it takes a bit more work. For example, the <code>System.Timers.Timer</code> type defines an <code>Elapsed</code> event, which is of type <code>ElapsedEventHandler</code>. You can wrap older events like this with <code>FromEventPattern</code>:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">timer</code> <code class="p">=</code> <code class="k">new</code> <code class="n">System</code><code class="p">.</code><code class="n">Timers</code><code class="p">.</code><code class="n">Timer</code><code class="p">(</code><code class="n">interval</code><code class="p">:</code> <code class="m">1000</code><code class="p">)</code> <code class="p">{</code> <code class="n">Enabled</code> <code class="p">=</code> <code class="k">true</code> <code class="p">};</code>
<code class="n">IObservable</code><code class="p">&lt;</code><code class="n">EventPattern</code><code class="p">&lt;</code><code class="n">ElapsedEventArgs</code><code class="p">&gt;&gt;</code> <code class="n">ticks</code> <code class="p">=</code>
    <code class="n">Observable</code><code class="p">.</code><code class="n">FromEventPattern</code><code class="p">&lt;</code><code class="n">ElapsedEventHandler</code><code class="p">,</code> <code class="n">ElapsedEventArgs</code><code class="p">&gt;(</code>
        <code class="n">handler</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="n">s</code><code class="p">,</code> <code class="n">a</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">handler</code><code class="p">(</code><code class="n">s</code><code class="p">,</code> <code class="n">a</code><code class="p">),</code>
        <code class="n">handler</code> <code class="p">=&gt;</code> <code class="n">timer</code><code class="p">.</code><code class="n">Elapsed</code> <code class="p">+=</code> <code class="n">handler</code><code class="p">,</code>
        <code class="n">handler</code> <code class="p">=&gt;</code> <code class="n">timer</code><code class="p">.</code><code class="n">Elapsed</code> <code class="p">-=</code> <code class="n">handler</code><code class="p">);</code>
<code class="n">ticks</code><code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="n">data</code> <code class="p">=&gt;</code> <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"OnNext: "</code> <code class="p">+</code> <code class="n">data</code><code class="p">.</code><code class="n">EventArgs</code><code class="p">.</code><code class="n">SignalTime</code><code class="p">));</code></pre>

<p>Note that in this example that <code>data.EventArgs</code> is still strongly typed. The type arguments to <code>FromEventPattern</code> are now the unique handler type and the derived <code>EventArgs</code> type. The first lambda argument to <code>FromEventPattern</code> is a converter from <code>EventHandler&lt;ElapsedEventArgs&gt;</code> to <code>ElapsedEventHandler</code>; the converter should do nothing more than pass along the event.</p>

<p>That syntax is definitely getting awkward. Here’s another option, which uses reflection:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">timer</code> <code class="p">=</code> <code class="k">new</code> <code class="n">System</code><code class="p">.</code><code class="n">Timers</code><code class="p">.</code><code class="n">Timer</code><code class="p">(</code><code class="n">interval</code><code class="p">:</code> <code class="m">1000</code><code class="p">)</code> <code class="p">{</code> <code class="n">Enabled</code> <code class="p">=</code> <code class="k">true</code> <code class="p">};</code>
<code class="n">IObservable</code><code class="p">&lt;</code><code class="n">EventPattern</code><code class="p">&lt;</code><code class="kt">object</code><code class="p">&gt;&gt;</code> <code class="n">ticks</code> <code class="p">=</code>
    <code class="n">Observable</code><code class="p">.</code><code class="n">FromEventPattern</code><code class="p">(</code><code class="n">timer</code><code class="p">,</code> <code class="n">nameof</code><code class="p">(</code><code class="n">Timer</code><code class="p">.</code><code class="n">Elapsed</code><code class="p">));</code>
<code class="n">ticks</code><code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="n">data</code> <code class="p">=&gt;</code> <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"OnNext: "</code>
    <code class="p">+</code> <code class="p">((</code><code class="n">ElapsedEventArgs</code><code class="p">)</code><code class="n">data</code><code class="p">.</code><code class="n">EventArgs</code><code class="p">).</code><code class="n">SignalTime</code><code class="p">));</code></pre>

<p>With this approach, the call to <code>FromEventPattern</code> is much easier. Note that there’s one drawback to this approach: the consumer doesn’t get strongly typed data. Because <code>data.EventArgs</code> is of type <code>object</code>, you have to cast it to <code>ElapsedEventArgs</code> yourself.</p>
</div></section>













<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458700628248">
<h2>Discussion</h2>

<p>Events are a common source of data for System.Reactive streams. This recipe covers wrapping any events that conform to the standard event pattern (where the first argument is the sender and the second argument is the event arguments type). If you have unusual event types, you can still use the <code>Observable.FromEvent</code> method overloads to wrap them into an observable.</p>

<p>When <a data-primary="OnNext notifications" data-type="indexterm" id="idm45458700302744"/>events are wrapped into an observable, <code>OnNext</code> is called each time the event is raised. When you’re dealing with <code>AsyncCompletedEventArgs</code>, this can cause surprising behavior, because any exception is passed along as data (<code>OnNext</code>), not as an error (<code>OnError</code>). Consider this wrapper for <code>WebClient.DownloadStringCompleted</code>, for example:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">client</code> <code class="p">=</code> <code class="k">new</code> <code class="n">WebClient</code><code class="p">();</code>
<code class="n">IObservable</code><code class="p">&lt;</code><code class="n">EventPattern</code><code class="p">&lt;</code><code class="kt">object</code><code class="p">&gt;&gt;</code> <code class="n">downloadedStrings</code> <code class="p">=</code>
    <code class="n">Observable</code><code class="p">.</code>
    <code class="n">FromEventPattern</code><code class="p">(</code><code class="n">client</code><code class="p">,</code> <code class="n">nameof</code><code class="p">(</code><code class="n">WebClient</code><code class="p">.</code><code class="n">DownloadStringCompleted</code><code class="p">));</code>
<code class="n">downloadedStrings</code><code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code>
    <code class="n">data</code> <code class="p">=&gt;</code>
    <code class="p">{</code>
      <code class="kt">var</code> <code class="n">eventArgs</code> <code class="p">=</code> <code class="p">(</code><code class="n">DownloadStringCompletedEventArgs</code><code class="p">)</code><code class="n">data</code><code class="p">.</code><code class="n">EventArgs</code><code class="p">;</code>
      <code class="k">if</code> <code class="p">(</code><code class="n">eventArgs</code><code class="p">.</code><code class="n">Error</code> <code class="p">!=</code> <code class="k">null</code><code class="p">)</code>
        <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"OnNext: (Error) "</code> <code class="p">+</code> <code class="n">eventArgs</code><code class="p">.</code><code class="n">Error</code><code class="p">);</code>
      <code class="k">else</code>
        <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"OnNext: "</code> <code class="p">+</code> <code class="n">eventArgs</code><code class="p">.</code><code class="n">Result</code><code class="p">);</code>
    <code class="p">},</code>
    <code class="n">ex</code> <code class="p">=&gt;</code> <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"OnError: "</code> <code class="p">+</code> <code class="n">ex</code><code class="p">.</code><code class="n">ToString</code><code class="p">()),</code>
    <code class="p">()</code> <code class="p">=&gt;</code> <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"OnCompleted"</code><code class="p">));</code>
<code class="n">client</code><code class="p">.</code><code class="n">DownloadStringAsync</code><code class="p">(</code><code class="k">new</code> <code class="n">Uri</code><code class="p">(</code><code class="s">"http://invalid.example.com/"</code><code class="p">));</code></pre>

<p>When <code>WebClient.DownloadStringAsync</code> completes with an error, the event is raised with an exception in <code>AsyncCompletedEventArgs.Error</code>. Unfortunately, System.Reactive sees this as a data event, so if you then run the preceding code you will see <code>OnNext: (Error)</code> printed instead of <code>OnError:</code>.</p>

<p>Some <a data-primary="reactive programming" data-secondary="subscriptions" data-type="indexterm" id="idm45458700169336"/><a data-primary="subscriptions" data-type="indexterm" id="idm45458700168440"/><a data-primary="context" data-secondary="controlling, for subscriptions" data-type="indexterm" id="idm45458700167768"/>event subscriptions and unsubscriptions must be done from a particular context. For example, events on many UI controls must be subscribed to from the UI thread. System.Reactive provides an operator that will control the context for subscribing and unsubscribing: <code>SubscribeOn</code>. The <code>SubscribeOn</code> operator isn’t necessary in most situations because most of the time a UI-based subscription is done from the UI <a data-startref="ch6r1a" data-type="indexterm" id="idm45458700165432"/><a data-startref="ch6r1b" data-type="indexterm" id="idm45458700164728"/><a data-startref="ch6r1c" data-type="indexterm" id="idm45458700164056"/>thread.</p>
<div data-type="tip"><h6>Tip</h6>
<p><code>SubscribeOn</code> controls the context for the code that adds and removes the event handlers. Don’t confuse this with <code>ObserveOn</code>, which controls the context for the observable notifications (the delegates passed to <code>Subscribe</code>).</p>
</div>
</div></section>













<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458700160888">
<h2>See Also</h2>

<p><a data-type="xref" href="#recipe-rx-observeon">Recipe 6.2</a> covers how to change the context in which events are raised.</p>

<p><a data-type="xref" href="#recipe-rx-throttle">Recipe 6.4</a> covers how to throttle events so subscribers aren’t overwhelmed.</p>
</div></section>





</div></section>













<section class="recipe" data-pdf-bookmark="6.2 Sending Notifications to a Context" data-type="sect1"><div class="sect1" id="recipe-rx-observeon">
<h1>6.2 Sending Notifications to a Context</h1>








<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458700155720">
<h2>Problem</h2>

<p>System.Reactive <a data-primary="OnNext notifications" data-type="indexterm" id="idm45458700154168"/><a data-primary="reactive programming" data-secondary="sending notifications to a context" data-type="indexterm" id="ch6r2a"/><a data-primary="notifications" data-secondary="sending to a context" data-type="indexterm" id="ch6r2b"/><a data-primary="reactive programming" data-secondary="schedulers" data-type="indexterm" id="ch6r2c"/><a data-primary="schedulers" data-secondary="in reactive programming" data-secondary-sortas="reactive" data-type="indexterm" id="ch6r2d"/><a data-primary="context" data-secondary="sending notifications to" data-type="indexterm" id="ch6r2e"/>does its best to be thread agnostic. So, it’ll raise notifications (e.g., <code>OnNext</code>) in whatever thread happens to be current. Each <code>OnNext</code> notification will happen sequentially, but not necessarily on the same thread.</p>

<p>You often want these notifications raised in a particular context. For example, UI elements should only be manipulated from the UI thread that owns them, so if you’re updating a UI in response to a notification that is arriving on a threadpool thread, then you’ll need to move over to the UI thread.</p>
</div></section>













<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458700145352">
<h2>Solution</h2>

<p>System.Reactive <a data-primary="ObserveOn operator" data-type="indexterm" id="idm45458700143624"/>provides the <code>ObserveOn</code> operator to move notifications to another scheduler.</p>

<p>Consider <a data-primary="Interval operator" data-type="indexterm" id="idm45458700141928"/>the following example, which uses the <code>Interval</code> operator to create <code>OnNext</code> notifications once a second:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="k">private</code> <code class="k">void</code> <code class="nf">Button_Click</code><code class="p">(</code><code class="kt">object</code> <code class="n">sender</code><code class="p">,</code> <code class="n">RoutedEventArgs</code> <code class="n">e</code><code class="p">)</code>
<code class="p">{</code>
  <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"UI thread is {Environment.CurrentManagedThreadId}"</code><code class="p">);</code>
  <code class="n">Observable</code><code class="p">.</code><code class="n">Interval</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">1</code><code class="p">))</code>
      <code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code>
          <code class="err">$</code><code class="s">"Interval {x} on thread {Environment.CurrentManagedThreadId}"</code><code class="p">));</code>
<code class="p">}</code></pre>

<p>On my machine, the output looks like the following:</p>

<pre data-type="programlisting">UI thread is 9
Interval 0 on thread 10
Interval 1 on thread 10
Interval 2 on thread 11
Interval 3 on thread 11
Interval 4 on thread 10
Interval 5 on thread 11
Interval 6 on thread 11</pre>

<p>Since <code>Interval</code> is based on a timer (without a specific thread), the notifications are raised on a threadpool thread, rather than the UI thread. If you need to update a UI element, you can pipe those notifications through <code>ObserveOn</code> and pass a synchronization context representing the UI thread:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="k">private</code> <code class="k">void</code> <code class="nf">Button_Click</code><code class="p">(</code><code class="kt">object</code> <code class="n">sender</code><code class="p">,</code> <code class="n">RoutedEventArgs</code> <code class="n">e</code><code class="p">)</code>
<code class="p">{</code>
  <code class="n">SynchronizationContext</code> <code class="n">uiContext</code> <code class="p">=</code> <code class="n">SynchronizationContext</code><code class="p">.</code><code class="n">Current</code><code class="p">;</code>
  <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"UI thread is {Environment.CurrentManagedThreadId}"</code><code class="p">);</code>
  <code class="n">Observable</code><code class="p">.</code><code class="n">Interval</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">1</code><code class="p">))</code>
      <code class="p">.</code><code class="n">ObserveOn</code><code class="p">(</code><code class="n">uiContext</code><code class="p">)</code>
      <code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code>
          <code class="err">$</code><code class="s">"Interval {x} on thread {Environment.CurrentManagedThreadId}"</code><code class="p">));</code>
<code class="p">}</code></pre>

<p>Another common usage of <code>ObserveOn</code> is to move <em>off</em> the UI thread when necessary. Consider a situation where you need to do some CPU-intensive computation whenever the mouse moves. By default, all mouse moves are raised on the UI thread, so you can use <code>ObserveOn</code> to move those notifications to a threadpool thread, do the computation, and then move the result notifications back to the UI thread:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="n">SynchronizationContext</code> <code class="n">uiContext</code> <code class="p">=</code> <code class="n">SynchronizationContext</code><code class="p">.</code><code class="n">Current</code><code class="p">;</code>
<code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"UI thread is {Environment.CurrentManagedThreadId}"</code><code class="p">);</code>
<code class="n">Observable</code><code class="p">.</code><code class="n">FromEventPattern</code><code class="p">&lt;</code><code class="n">MouseEventHandler</code><code class="p">,</code> <code class="n">MouseEventArgs</code><code class="p">&gt;(</code>
        <code class="n">handler</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="n">s</code><code class="p">,</code> <code class="n">a</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">handler</code><code class="p">(</code><code class="n">s</code><code class="p">,</code> <code class="n">a</code><code class="p">),</code>
        <code class="n">handler</code> <code class="p">=&gt;</code> <code class="n">MouseMove</code> <code class="p">+=</code> <code class="n">handler</code><code class="p">,</code>
        <code class="n">handler</code> <code class="p">=&gt;</code> <code class="n">MouseMove</code> <code class="p">-=</code> <code class="n">handler</code><code class="p">)</code>
    <code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">evt</code> <code class="p">=&gt;</code> <code class="n">evt</code><code class="p">.</code><code class="n">EventArgs</code><code class="p">.</code><code class="n">GetPosition</code><code class="p">(</code><code class="k">this</code><code class="p">))</code>
    <code class="p">.</code><code class="n">ObserveOn</code><code class="p">(</code><code class="n">Scheduler</code><code class="p">.</code><code class="n">Default</code><code class="p">)</code>
    <code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">position</code> <code class="p">=&gt;</code>
    <code class="p">{</code>
      <code class="c1">// Complex calculation</code>
      <code class="n">Thread</code><code class="p">.</code><code class="n">Sleep</code><code class="p">(</code><code class="m">100</code><code class="p">);</code>
      <code class="kt">var</code> <code class="n">result</code> <code class="p">=</code> <code class="n">position</code><code class="p">.</code><code class="n">X</code> <code class="p">+</code> <code class="n">position</code><code class="p">.</code><code class="n">Y</code><code class="p">;</code>
      <code class="kt">var</code> <code class="n">thread</code> <code class="p">=</code> <code class="n">Environment</code><code class="p">.</code><code class="n">CurrentManagedThreadId</code><code class="p">;</code>
      <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"Calculated result {result} on thread {thread}"</code><code class="p">);</code>
      <code class="k">return</code> <code class="n">result</code><code class="p">;</code>
    <code class="p">})</code>
    <code class="p">.</code><code class="n">ObserveOn</code><code class="p">(</code><code class="n">uiContext</code><code class="p">)</code>
    <code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code>
        <code class="err">$</code><code class="s">"Result {x} on thread {Environment.CurrentManagedThreadId}"</code><code class="p">));</code></pre>

<p>If you execute this sample, you’ll see the calculations done on a threadpool thread and the results printed on the UI thread. However, you’ll also notice that the calculations and results will lag behind the input; they’ll queue up because the mouse location updates more often than every 100 ms. System.Reactive has several techniques for handling this situation; one common one covered in <a data-type="xref" href="#recipe-rx-throttle">Recipe 6.4</a> is throttling the input.</p>
</div></section>













<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458700144728">
<h2>Discussion</h2>

<p><code>ObserveOn</code> actually moves notifications to a System.Reactive <em>scheduler</em>. This recipe covered the default (thread pool) scheduler and one way of creating a UI scheduler. The most common uses for the <code>ObserveOn</code> operator are moving on or off the UI thread, but schedulers are also useful in other scenarios. A more advanced scenario where schedulers are useful is faking the passage of time when unit testing, which you’ll find <a data-startref="ch6r2a" data-type="indexterm" id="idm45458699801304"/><a data-startref="ch6r2b" data-type="indexterm" id="idm45458699800600"/><a data-startref="ch6r2c" data-type="indexterm" id="idm45458699799928"/><a data-startref="ch6r2d" data-type="indexterm" id="idm45458699799256"/><a data-startref="ch6r2e" data-type="indexterm" id="idm45458699798584"/>covered in <a data-type="xref" href="ch07.html#recipe-rx-testscheduling">Recipe 7.6</a>.</p>
<div data-type="tip"><h6>Tip</h6>
<p><code>ObserveOn</code> controls the context for the observable notifications. This is not to be confused with <code>SubscribeOn</code>, which controls the context for the code that adds and removes the event handlers.</p>
</div>
</div></section>













<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458699794904">
<h2>See Also</h2>

<p><a data-type="xref" href="#recipe-rx-events">Recipe 6.1</a> covers how to create sequences from events, and using <code>SubscribeOn</code>.</p>

<p><a data-type="xref" href="#recipe-rx-throttle">Recipe 6.4</a> covers throttling event streams.</p>

<p><a data-type="xref" href="ch07.html#recipe-rx-testscheduling">Recipe 7.6</a> covers the special scheduler used for testing your System.Reactive code.</p>
</div></section>





</div></section>













<section class="recipe" data-pdf-bookmark="6.3 Grouping Event Data with Windows and Buffers" data-type="sect1"><div class="sect1" id="recipe-rx-windows">
<h1>6.3 Grouping Event Data with Windows and Buffers</h1>








<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458699788200">
<h2>Problem</h2>

<p>You <a data-primary="reactive programming" data-secondary="grouping events into windows and buffers" data-type="indexterm" id="ch6r3a"/><a data-primary="events" data-secondary="grouping, in reactive code" data-type="indexterm" id="ch6r3d"/>have a sequence of events, and you want to group the incoming events as they arrive. As an example, you need to react to pairs of inputs. As another example, you need to react to all inputs within a two-second window.</p>
</div></section>













<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458699783688">
<h2>Solution</h2>

<p>System.Reactive <a data-primary="Buffer operator" data-type="indexterm" id="ch6r3b"/><a data-primary="Window operator" data-type="indexterm" id="ch6r3c"/>provides a pair of operators that group incoming sequences: <code>Buffer</code> and <code>Window</code>. <code>Buffer</code> will hold on to the incoming events until the group is complete, at which time it forwards them all at once as a collection of events. <code>Window</code> will logically group the incoming events but will pass them along as they arrive. The return type of <code>Buffer</code> is <code>IObservable&lt;IList&lt;T&gt;&gt;</code> (an event stream of collections); the return type of <code>Window</code> is <code>IObservable&lt;IObservable&lt;T&gt;&gt;</code> (an event stream of event streams).</p>

<p>The <a data-primary="Interval operator" data-type="indexterm" id="idm45458699775736"/>following example uses the <code>Interval</code> operator to create <code>OnNext</code> notifications once a second and then buffers them two at a time:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="n">Observable</code><code class="p">.</code><code class="n">Interval</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">1</code><code class="p">))</code>
    <code class="p">.</code><code class="n">Buffer</code><code class="p">(</code><code class="m">2</code><code class="p">)</code>
    <code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code>
        <code class="err">$</code><code class="s">"{DateTime.Now.Second}: Got {x[0]} and {x[1]}"</code><code class="p">));</code></pre>

<p>On my machine, this code produces a pair of outputs every two seconds:</p>

<pre data-type="programlisting">13: Got 0 and 1
15: Got 2 and 3
17: Got 4 and 5
19: Got 6 and 7
21: Got 8 and 9</pre>

<p>The following is a similar example of using <code>Window</code> to create groups of two events:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="n">Observable</code><code class="p">.</code><code class="n">Interval</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">1</code><code class="p">))</code>
    <code class="p">.</code><code class="n">Window</code><code class="p">(</code><code class="m">2</code><code class="p">)</code>
    <code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="k">group</code> <code class="p">=&gt;</code>
    <code class="p">{</code>
      <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"{DateTime.Now.Second}: Starting new group"</code><code class="p">);</code>
      <code class="k">group</code><code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code>
          <code class="n">x</code> <code class="p">=&gt;</code> <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"{DateTime.Now.Second}: Saw {x}"</code><code class="p">),</code>
          <code class="p">()</code> <code class="p">=&gt;</code> <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"{DateTime.Now.Second}: Ending group"</code><code class="p">));</code>
    <code class="p">});</code></pre>

<p>On my machine, this <code>Window</code> example produces this output:</p>

<pre data-type="programlisting">17: Starting new group
18: Saw 0
19: Saw 1
19: Ending group
19: Starting new group
20: Saw 2
21: Saw 3
21: Ending group
21: Starting new group
22: Saw 4
23: Saw 5
23: Ending group
23: Starting new group</pre>

<p>These examples illustrate the difference between <code>Buffer</code> and <code>Window</code>. <code>Buffer</code> waits for all the events in its group and then publishes a single collection. <code>Window</code> groups events the same way, but publishes the events as they come in; <code>Window</code> immediately publishes an observable that will publish the events for that window.</p>

<p>Both <code>Buffer</code> and <code>Window</code> also work with time spans. The following code is an example where all mouse move events are collected in windows of one second:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="k">private</code> <code class="k">void</code> <code class="nf">Button_Click</code><code class="p">(</code><code class="kt">object</code> <code class="n">sender</code><code class="p">,</code> <code class="n">RoutedEventArgs</code> <code class="n">e</code><code class="p">)</code>
<code class="p">{</code>
  <code class="n">Observable</code><code class="p">.</code><code class="n">FromEventPattern</code><code class="p">&lt;</code><code class="n">MouseEventHandler</code><code class="p">,</code> <code class="n">MouseEventArgs</code><code class="p">&gt;(</code>
          <code class="n">handler</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="n">s</code><code class="p">,</code> <code class="n">a</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">handler</code><code class="p">(</code><code class="n">s</code><code class="p">,</code> <code class="n">a</code><code class="p">),</code>
          <code class="n">handler</code> <code class="p">=&gt;</code> <code class="n">MouseMove</code> <code class="p">+=</code> <code class="n">handler</code><code class="p">,</code>
          <code class="n">handler</code> <code class="p">=&gt;</code> <code class="n">MouseMove</code> <code class="p">-=</code> <code class="n">handler</code><code class="p">)</code>
      <code class="p">.</code><code class="n">Buffer</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">1</code><code class="p">))</code>
      <code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code>
          <code class="err">$</code><code class="s">"{DateTime.Now.Second}: Saw {x.Count} items."</code><code class="p">));</code>
<code class="p">}</code></pre>

<p>Depending on how you move the mouse, you should see output like the following:</p>

<pre data-type="programlisting">49: Saw 93 items.
50: Saw 98 items.
51: Saw 39 items.
52: Saw 0 items.
53: Saw 4 items.
54: Saw 0 items.
55: Saw 58 items.</pre>
</div></section>













<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458699783224">
<h2>Discussion</h2>

<p><code>Buffer</code> and <code>Window</code> are some of the tools you have for taming input and shaping it the way you want it to look. Another useful technique is throttling, which you’ll learn about in <a data-type="xref" href="#recipe-rx-throttle">Recipe 6.4</a>.</p>

<p>Both <code>Buffer</code> and <code>Window</code> have other overloads that can be used in more advanced scenarios. The overloads with <code>skip</code> and <code>timeShift</code> parameters enable you to create groups that overlap other groups or skip elements in between groups. There are also overloads that take delegates, which enable you to dynamically define the boundary of the <a data-startref="ch6r3" data-type="indexterm" id="idm45458699490376"/><a data-startref="ch6r3b" data-type="indexterm" id="idm45458699489672"/><a data-startref="ch6r3c" data-type="indexterm" id="idm45458699489000"/><a data-startref="ch6r3d" data-type="indexterm" id="idm45458699488328"/>groups.</p>
</div></section>













<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458699487400">
<h2>See Also</h2>

<p><a data-type="xref" href="#recipe-rx-events">Recipe 6.1</a> covers how to create sequences from events.</p>

<p><a data-type="xref" href="#recipe-rx-throttle">Recipe 6.4</a> covers throttling event streams.</p>
</div></section>





</div></section>













<section class="recipe" data-pdf-bookmark="6.4 Taming Event Streams with Throttling and Sampling" data-type="sect1"><div class="sect1" id="recipe-rx-throttle">
<h1>6.4 Taming Event Streams with Throttling and Sampling</h1>








<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458699482200">
<h2>Problem</h2>

<p>A <a data-primary="reactive programming" data-secondary="throttling and sampling events" data-type="indexterm" id="ch6r4a"/><a data-primary="events" data-secondary="throttling and sampling, in reactive code" data-type="indexterm" id="ch6r4d"/><a data-primary="throttling" data-secondary="events, in reactive programming" data-type="indexterm" id="idm45458699478312"/>common problem with writing reactive code is when the events come in too quickly. A fast-moving stream of events can overwhelm your program’s processing.</p>
</div></section>













<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458699476840">
<h2>Solution</h2>

<p>System.Reactive <a data-primary="Throttle operator" data-type="indexterm" id="ch6r4b"/><a data-primary="Sample operator" data-type="indexterm" id="ch6r4c"/>provides operators specifically for dealing with a flood of event data. The <code>Throttle</code> and <code>Sample</code> operators give us two different ways to tame fast input events.</p>

<p>The <code>Throttle</code> operator establishes a sliding timeout window. When an incoming event arrives, it resets the timeout window. When the timeout window expires, it publishes the last event value that arrived within the window.</p>

<p>The following example monitors mouse movements and uses <code>Throttle</code> to only report updates once the mouse has stayed still for a full second:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="k">private</code> <code class="k">void</code> <code class="nf">Button_Click</code><code class="p">(</code><code class="kt">object</code> <code class="n">sender</code><code class="p">,</code> <code class="n">RoutedEventArgs</code> <code class="n">e</code><code class="p">)</code>
<code class="p">{</code>
  <code class="n">Observable</code><code class="p">.</code><code class="n">FromEventPattern</code><code class="p">&lt;</code><code class="n">MouseEventHandler</code><code class="p">,</code> <code class="n">MouseEventArgs</code><code class="p">&gt;(</code>
          <code class="n">handler</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="n">s</code><code class="p">,</code> <code class="n">a</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">handler</code><code class="p">(</code><code class="n">s</code><code class="p">,</code> <code class="n">a</code><code class="p">),</code>
          <code class="n">handler</code> <code class="p">=&gt;</code> <code class="n">MouseMove</code> <code class="p">+=</code> <code class="n">handler</code><code class="p">,</code>
          <code class="n">handler</code> <code class="p">=&gt;</code> <code class="n">MouseMove</code> <code class="p">-=</code> <code class="n">handler</code><code class="p">)</code>
      <code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code><code class="p">.</code><code class="n">EventArgs</code><code class="p">.</code><code class="n">GetPosition</code><code class="p">(</code><code class="k">this</code><code class="p">))</code>
      <code class="p">.</code><code class="n">Throttle</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">1</code><code class="p">))</code>
      <code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code>
          <code class="err">$</code><code class="s">"{DateTime.Now.Second}: Saw {x.X + x.Y}"</code><code class="p">));</code>
<code class="p">}</code></pre>

<p>The output varies considerably based on mouse movement, but one example run on my machine looked like this:</p>

<pre data-type="programlisting">47: Saw 139
49: Saw 137
51: Saw 424
56: Saw 226</pre>

<p><code>Throttle</code> is often used in situations such as autocomplete, when the user is typing text into a text box, and you don’t want to do the actual lookup until the user stops typing.</p>

<p><code>Sample</code> takes a different approach to taming fast-moving sequences. <code>Sample</code> establishes a regular timeout period and publishes the most recent value within that window each time the timeout expires. If no values were received within the sample period, then no results are published for that period.</p>

<p>The following example captures mouse movements and samples them in one-second intervals. Unlike the <code>Throttle</code> example, this <code>Sample</code> example doesn’t require you to hold the mouse still to see data:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="k">private</code> <code class="k">void</code> <code class="nf">Button_Click</code><code class="p">(</code><code class="kt">object</code> <code class="n">sender</code><code class="p">,</code> <code class="n">RoutedEventArgs</code> <code class="n">e</code><code class="p">)</code>
<code class="p">{</code>
  <code class="n">Observable</code><code class="p">.</code><code class="n">FromEventPattern</code><code class="p">&lt;</code><code class="n">MouseEventHandler</code><code class="p">,</code> <code class="n">MouseEventArgs</code><code class="p">&gt;(</code>
          <code class="n">handler</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="n">s</code><code class="p">,</code> <code class="n">a</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">handler</code><code class="p">(</code><code class="n">s</code><code class="p">,</code> <code class="n">a</code><code class="p">),</code>
          <code class="n">handler</code> <code class="p">=&gt;</code> <code class="n">MouseMove</code> <code class="p">+=</code> <code class="n">handler</code><code class="p">,</code>
          <code class="n">handler</code> <code class="p">=&gt;</code> <code class="n">MouseMove</code> <code class="p">-=</code> <code class="n">handler</code><code class="p">)</code>
      <code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code><code class="p">.</code><code class="n">EventArgs</code><code class="p">.</code><code class="n">GetPosition</code><code class="p">(</code><code class="k">this</code><code class="p">))</code>
      <code class="p">.</code><code class="n">Sample</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">1</code><code class="p">))</code>
      <code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code>
          <code class="err">$</code><code class="s">"{DateTime.Now.Second}: Saw {x.X + x.Y}"</code><code class="p">));</code>
<code class="p">}</code></pre>

<p>Here’s the output on my machine when I first left the mouse still for a few seconds and then continuously moved it:</p>

<pre data-type="programlisting">12: Saw 311
17: Saw 254
18: Saw 269
19: Saw 342
20: Saw 224
21: Saw 277</pre>
</div></section>













<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458699476376">
<h2>Discussion</h2>

<p>Throttling and sampling are essential tools for taming the flood of input. Don’t forget that you can also easily do filtering with the standard LINQ <code>Where</code> operator. You can think of the <code>Throttle</code> and <code>Sample</code> operators as similar to <code>Where</code>, only they filter on time windows instead of filtering on event data. All three of these operators help you tame fast-moving input streams in different <a data-startref="ch6r4a" data-type="indexterm" id="idm45458699218520"/><a data-startref="ch6r4b" data-type="indexterm" id="idm45458699217816"/><a data-startref="ch6r4c" data-type="indexterm" id="idm45458699217144"/><a data-startref="ch6r4d" data-type="indexterm" id="idm45458699216472"/>ways.</p>
</div></section>













<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458699215544">
<h2>See Also</h2>

<p><a data-type="xref" href="#recipe-rx-events">Recipe 6.1</a> covers how to create sequences from events.</p>

<p><a data-type="xref" href="#recipe-rx-observeon">Recipe 6.2</a> covers how to change the context in which events are raised.</p>
</div></section>





</div></section>













<section class="recipe" data-pdf-bookmark="6.5 Timeouts" data-type="sect1"><div class="sect1" id="recipe-rx-timeout">
<h1>6.5 Timeouts</h1>








<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458699210344">
<h2>Problem</h2>

<p>You <a data-primary="reactive programming" data-secondary="timeouts, creating" data-type="indexterm" id="ch6r5a"/><a data-primary="timeouts" data-type="indexterm" id="ch6r5b"/>expect an event to arrive within a certain time and need to ensure that your program will respond in a timely fashion, even if the event doesn’t arrive. Most commonly, this kind of expected event is a single asynchronous operation (e.g., expecting the response from a web service request).</p>
</div></section>













<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458699206072">
<h2>Solution</h2>

<p>The <code>Timeout</code> operator establishes a sliding timeout window on its input stream. Whenever a new event arrives, the timeout window is reset. If the timeout expires without seeing an event in that window, the <code>Timeout</code> operator will end the stream with an <code>OnError</code> notification containing a <code>TimeoutException</code>.</p>

<p>The following example issues a web request for the example domain and applies a timeout of one second. To get the web request started, the code uses <code>ToObservable</code> to convert a <code>Task&lt;T&gt;</code> to an <code>IObservable&lt;T&gt;</code> (see <a data-type="xref" href="ch08.html#recipe-rx-interop-async">Recipe 8.6</a>):</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="k">void</code> <code class="nf">GetWithTimeout</code><code class="p">(</code><code class="n">HttpClient</code> <code class="n">client</code><code class="p">)</code>
<code class="p">{</code>
  <code class="n">client</code><code class="p">.</code><code class="n">GetStringAsync</code><code class="p">(</code><code class="s">"http://www.example.com/"</code><code class="p">).</code><code class="n">ToObservable</code><code class="p">()</code>
      <code class="p">.</code><code class="n">Timeout</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">1</code><code class="p">))</code>
      <code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code>
          <code class="n">x</code> <code class="p">=&gt;</code> <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"{DateTime.Now.Second}: Saw {x.Length}"</code><code class="p">),</code>
          <code class="n">ex</code> <code class="p">=&gt;</code> <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">ex</code><code class="p">));</code>
<code class="p">}</code></pre>

<p><code>Timeout</code> is ideal for asynchronous operations, such as web requests, but it can be applied to any event stream. The following example applies <code>Timeout</code> to mouse movements, which are easier to play around with:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="k">private</code> <code class="k">void</code> <code class="nf">Button_Click</code><code class="p">(</code><code class="kt">object</code> <code class="n">sender</code><code class="p">,</code> <code class="n">RoutedEventArgs</code> <code class="n">e</code><code class="p">)</code>
<code class="p">{</code>
  <code class="n">Observable</code><code class="p">.</code><code class="n">FromEventPattern</code><code class="p">&lt;</code><code class="n">MouseEventHandler</code><code class="p">,</code> <code class="n">MouseEventArgs</code><code class="p">&gt;(</code>
          <code class="n">handler</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="n">s</code><code class="p">,</code> <code class="n">a</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">handler</code><code class="p">(</code><code class="n">s</code><code class="p">,</code> <code class="n">a</code><code class="p">),</code>
          <code class="n">handler</code> <code class="p">=&gt;</code> <code class="n">MouseMove</code> <code class="p">+=</code> <code class="n">handler</code><code class="p">,</code>
          <code class="n">handler</code> <code class="p">=&gt;</code> <code class="n">MouseMove</code> <code class="p">-=</code> <code class="n">handler</code><code class="p">)</code>
      <code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code><code class="p">.</code><code class="n">EventArgs</code><code class="p">.</code><code class="n">GetPosition</code><code class="p">(</code><code class="k">this</code><code class="p">))</code>
      <code class="p">.</code><code class="n">Timeout</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">1</code><code class="p">))</code>
      <code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code>
          <code class="n">x</code> <code class="p">=&gt;</code> <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"{DateTime.Now.Second}: Saw {x.X + x.Y}"</code><code class="p">),</code>
          <code class="n">ex</code> <code class="p">=&gt;</code> <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">ex</code><code class="p">));</code>
<code class="p">}</code></pre>

<p>On my machine, I moved the mouse a bit and then kept it still for a second, and got these results:</p>

<pre data-type="programlisting">16: Saw 180
16: Saw 178
16: Saw 177
16: Saw 176
System.TimeoutException: The operation has timed out.</pre>

<p>Note that once the <code>TimeoutException</code> is sent to <code>OnError</code>, the stream is finished. No more mouse movements come through. You may not want exactly this behavior, so the <code>Timeout</code> operator has overloads that substitute a second stream when the timeout occurs instead of ending the stream with an exception.</p>

<p>The code in the following example observes mouse movements until there’s a timeout. After the timeout, the code observes mouse clicks:</p>

<pre data-code-language="csharp" data-type="programlisting"><code class="k">private</code> <code class="k">void</code> <code class="nf">Button_Click</code><code class="p">(</code><code class="kt">object</code> <code class="n">sender</code><code class="p">,</code> <code class="n">RoutedEventArgs</code> <code class="n">e</code><code class="p">)</code>
<code class="p">{</code>
  <code class="n">IObservable</code><code class="p">&lt;</code><code class="n">Point</code><code class="p">&gt;</code> <code class="n">clicks</code> <code class="p">=</code>
      <code class="n">Observable</code><code class="p">.</code><code class="n">FromEventPattern</code><code class="p">&lt;</code><code class="n">MouseButtonEventHandler</code><code class="p">,</code> <code class="n">MouseButtonEventArgs</code><code class="p">&gt;(</code>
          <code class="n">handler</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="n">s</code><code class="p">,</code> <code class="n">a</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">handler</code><code class="p">(</code><code class="n">s</code><code class="p">,</code> <code class="n">a</code><code class="p">),</code>
          <code class="n">handler</code> <code class="p">=&gt;</code> <code class="n">MouseDown</code> <code class="p">+=</code> <code class="n">handler</code><code class="p">,</code>
          <code class="n">handler</code> <code class="p">=&gt;</code> <code class="n">MouseDown</code> <code class="p">-=</code> <code class="n">handler</code><code class="p">)</code>
      <code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code><code class="p">.</code><code class="n">EventArgs</code><code class="p">.</code><code class="n">GetPosition</code><code class="p">(</code><code class="k">this</code><code class="p">));</code>

  <code class="n">Observable</code><code class="p">.</code><code class="n">FromEventPattern</code><code class="p">&lt;</code><code class="n">MouseEventHandler</code><code class="p">,</code> <code class="n">MouseEventArgs</code><code class="p">&gt;(</code>
          <code class="n">handler</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="n">s</code><code class="p">,</code> <code class="n">a</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">handler</code><code class="p">(</code><code class="n">s</code><code class="p">,</code> <code class="n">a</code><code class="p">),</code>
          <code class="n">handler</code> <code class="p">=&gt;</code> <code class="n">MouseMove</code> <code class="p">+=</code> <code class="n">handler</code><code class="p">,</code>
          <code class="n">handler</code> <code class="p">=&gt;</code> <code class="n">MouseMove</code> <code class="p">-=</code> <code class="n">handler</code><code class="p">)</code>
      <code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code><code class="p">.</code><code class="n">EventArgs</code><code class="p">.</code><code class="n">GetPosition</code><code class="p">(</code><code class="k">this</code><code class="p">))</code>
      <code class="p">.</code><code class="n">Timeout</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">1</code><code class="p">),</code> <code class="n">clicks</code><code class="p">)</code>
      <code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code>
          <code class="n">x</code> <code class="p">=&gt;</code> <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"{DateTime.Now.Second}: Saw {x.X},{x.Y}"</code><code class="p">),</code>
          <code class="n">ex</code> <code class="p">=&gt;</code> <code class="n">Trace</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">ex</code><code class="p">));</code>
<code class="p">}</code></pre>

<p>On my machine, I moved the mouse a bit, then held it still for a second, and then clicked a couple of different points. The following outputs shows the mouse movements quickly moving through until the timeout, and then the two clicks:</p>

<pre data-type="programlisting">49: Saw 95,39
49: Saw 94,39
49: Saw 94,38
49: Saw 94,37
53: Saw 130,141
55: Saw 469,4</pre>
</div></section>













<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458699205480">
<h2>Discussion</h2>

<p><code>Timeout</code> is an essential operator in nontrivial applications because you always want your program to be responsive even if the rest of the world isn’t. It’s particularly useful when you have asynchronous operations, but it can be applied to any event stream. Note that the underlying operation is not actually canceled; in the case of a timeout, the operation will continue executing until it succeeds or <a data-startref="ch6r5a" data-type="indexterm" id="idm45458698790856"/><a data-startref="ch6r5b" data-type="indexterm" id="idm45458698790152"/>fails.</p>
</div></section>













<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458698789096">
<h2>See Also</h2>

<p><a data-type="xref" href="#recipe-rx-events">Recipe 6.1</a> covers how to create sequences from events.</p>

<p><a data-type="xref" href="ch08.html#recipe-rx-interop-async">Recipe 8.6</a> covers wrapping asynchronous code as an observable event stream.</p>

<p><a data-type="xref" href="ch10.html#recipe-cancel-rx">Recipe 10.6</a> covers unsubscribing from sequences as a result of a <code>CancellationToken</code>.</p>

<p><a data-type="xref" href="ch10.html#recipe-cancel-timeout">Recipe 10.3</a> covers using a <code>CancellationToken</code> as a timeout.</p>
</div></section>





</div></section>







</div></section></body></html>